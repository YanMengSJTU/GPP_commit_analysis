diff --git a/okhttp-urlconnection/src/main/java/com/squareup/okhttp/OkUrlFactory.java b/okhttp-urlconnection/src/main/java/com/squareup/okhttp/OkUrlFactory.java
index 2c5f95ff79..4b34559e4c 100644
--- a/okhttp-urlconnection/src/main/java/com/squareup/okhttp/OkUrlFactory.java
+++ b/okhttp-urlconnection/src/main/java/com/squareup/okhttp/OkUrlFactory.java
@@ -15,13 +15,11 @@
  */
 package com.squareup.okhttp;
 
-import com.squareup.okhttp.internal.InternalCache;
-import com.squareup.okhttp.internal.huc.CacheAdapter;
 import com.squareup.okhttp.internal.huc.HttpURLConnectionImpl;
 import com.squareup.okhttp.internal.huc.HttpsURLConnectionImpl;
+
 import java.net.HttpURLConnection;
 import java.net.Proxy;
-import java.net.ResponseCache;
 import java.net.URL;
 import java.net.URLConnection;
 import java.net.URLStreamHandler;
@@ -38,17 +36,6 @@ public OkHttpClient client() {
     return client;
   }
 
-  /** Sets the response cache to be used to read and write cached responses. */
-  OkUrlFactory setResponseCache(ResponseCache responseCache) {
-    client.setInternalCache(responseCache != null ? new CacheAdapter(responseCache) : null);
-    return this;
-  }
-
-  ResponseCache getResponseCache() {
-    InternalCache cache = client.internalCache();
-    return cache instanceof CacheAdapter ? ((CacheAdapter) cache).getDelegate() : null;
-  }
-
   /**
    * Returns a copy of this stream handler factory that includes a shallow copy
    * of the internal {@linkplain OkHttpClient HTTP client}.
diff --git a/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/CacheAdapter.java b/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/CacheAdapter.java
deleted file mode 100644
index 13a34c032b..0000000000
--- a/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/CacheAdapter.java
+++ /dev/null
@@ -1,105 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal.huc;
-
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
-import com.squareup.okhttp.internal.InternalCache;
-import com.squareup.okhttp.internal.http.CacheRequest;
-import com.squareup.okhttp.internal.http.CacheStrategy;
-import java.io.IOException;
-import java.io.OutputStream;
-import java.net.CacheResponse;
-import java.net.HttpURLConnection;
-import java.net.ResponseCache;
-import java.net.URI;
-import java.util.List;
-import java.util.Map;
-import okio.Okio;
-import okio.Sink;
-
-/** Adapts {@link ResponseCache} to {@link InternalCache}. */
-public final class CacheAdapter implements InternalCache {
-  private final ResponseCache delegate;
-
-  public CacheAdapter(ResponseCache delegate) {
-    this.delegate = delegate;
-  }
-
-  public ResponseCache getDelegate() {
-    return delegate;
-  }
-
-  @Override public Response get(Request request) throws IOException {
-    CacheResponse javaResponse = getJavaCachedResponse(request);
-    if (javaResponse == null) {
-      return null;
-    }
-    return JavaApiConverter.createOkResponse(request, javaResponse);
-  }
-
-  @Override public CacheRequest put(Response response) throws IOException {
-    URI uri = response.request().uri();
-    HttpURLConnection connection = JavaApiConverter.createJavaUrlConnection(response);
-    final java.net.CacheRequest request = delegate.put(uri, connection);
-    if (request == null) {
-      return null;
-    }
-    return new CacheRequest() {
-      @Override public Sink body() throws IOException {
-        OutputStream body = request.getBody();
-        return body != null ? Okio.sink(body) : null;
-      }
-
-      @Override public void abort() {
-        request.abort();
-      }
-    };
-  }
-
-  @Override public void remove(Request request) throws IOException {
-    // This method is treated as optional and there is no obvious way of implementing it with
-    // ResponseCache. Removing items from the cache due to modifications made from this client is
-    // not essential given that modifications could be made from any other client. We have to assume
-    // that it's ok to keep using the cached data. Otherwise the server shouldn't declare it as
-    // cacheable or the client should be careful about caching it.
-  }
-
-  @Override public void update(Response cached, Response network) throws IOException {
-    // This method is treated as optional and there is no obvious way of implementing it with
-    // ResponseCache. Updating headers is useful if the server changes the metadata for a resource
-    // (e.g. max age) to extend or truncate the life of that resource in the cache. If the metadata
-    // is not updated the caching behavior may not be optimal, but will obey the metadata sent
-    // with the original cached response.
-  }
-
-  @Override public void trackConditionalCacheHit() {
-    // This method is optional.
-  }
-
-  @Override public void trackResponse(CacheStrategy cacheStrategy) {
-    // This method is optional.
-  }
-
-  /**
-   * Returns the {@link CacheResponse} from the delegate by converting the
-   * OkHttp {@link Request} into the arguments required by the {@link ResponseCache}.
-   */
-  private CacheResponse getJavaCachedResponse(Request request) throws IOException {
-    Map<String, List<String>> headers = JavaApiConverter.extractJavaHeaders(request);
-    return delegate.get(request.uri(), request.method(), headers);
-  }
-}
diff --git a/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java b/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java
index fbcf90cb17..d09e971058 100644
--- a/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java
+++ b/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java
@@ -23,15 +23,18 @@
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.Request;
+import com.squareup.okhttp.RequestBody;
 import com.squareup.okhttp.Response;
 import com.squareup.okhttp.Route;
 import com.squareup.okhttp.internal.Internal;
 import com.squareup.okhttp.internal.Platform;
+import com.squareup.okhttp.internal.http.RouteException;
 import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.internal.http.HttpDate;
 import com.squareup.okhttp.internal.http.HttpEngine;
 import com.squareup.okhttp.internal.http.HttpMethod;
 import com.squareup.okhttp.internal.http.OkHeaders;
+import com.squareup.okhttp.internal.http.RequestException;
 import com.squareup.okhttp.internal.http.RetryableSink;
 import com.squareup.okhttp.internal.http.StatusLine;
 import java.io.FileNotFoundException;
@@ -47,10 +50,13 @@
 import java.net.URL;
 import java.security.Permission;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.Date;
+import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 import java.util.concurrent.TimeUnit;
 import okio.BufferedSink;
 import okio.Sink;
@@ -68,6 +74,9 @@
  * header fields, request method, etc.) are immutable.
  */
 public class HttpURLConnectionImpl extends HttpURLConnection {
+  private static final Set<String> METHODS = new LinkedHashSet<>(
+      Arrays.asList("OPTIONS", "GET", "HEAD", "POST", "PUT", "DELETE", "TRACE", "PATCH"));
+  private static final RequestBody EMPTY_REQUEST_BODY = RequestBody.create(null, new byte[0]);
 
   final OkHttpClient client;
 
@@ -75,7 +84,7 @@
 
   /** Like the superclass field of the same name, but a long and available on all platforms. */
   private long fixedContentLength = -1;
-  private int redirectionCount;
+  private int followUpCount;
   protected IOException httpEngineFailure;
   protected HttpEngine httpEngine;
   /** Lazily created (with synthetic headers) on first call to getHeaders(). */
@@ -126,8 +135,9 @@ public HttpURLConnectionImpl(URL url, OkHttpClient client) {
   @Override public final InputStream getErrorStream() {
     try {
       HttpEngine response = getResponse();
-      if (response.hasResponseBody() && response.getResponse().code() >= HTTP_BAD_REQUEST) {
-        return response.getResponseBodyBytes();
+      if (HttpEngine.hasBody(response.getResponse())
+          && response.getResponse().code() >= HTTP_BAD_REQUEST) {
+        return response.getResponse().body().byteStream();
       }
       return null;
     } catch (IOException e) {
@@ -228,11 +238,7 @@ private static String responseSourceHeader(Response response) {
       throw new FileNotFoundException(url.toString());
     }
 
-    InputStream result = response.getResponseBodyBytes();
-    if (result == null) {
-      throw new ProtocolException("No response body exists; responseCode=" + getResponseCode());
-    }
-    return result;
+    return response.getResponse().body().byteStream();
   }
 
   @Override public final OutputStream getOutputStream() throws IOException {
@@ -312,11 +318,15 @@ private void initHttpEngine() throws IOException {
 
   private HttpEngine newHttpEngine(String method, Connection connection,
       RetryableSink requestBody, Response priorResponse) {
+    // OkHttp's Call API requires a placeholder body; the real body will be streamed separately.
+    RequestBody placeholderBody = HttpMethod.requiresRequestBody(method)
+        ? EMPTY_REQUEST_BODY
+        : null;
     Request.Builder builder = new Request.Builder()
         .url(getURL())
-        .method(method, null /* No body; that's passed separately. */);
+        .method(method, placeholderBody);
     Headers headers = requestHeaders.build();
-    for (int i = 0; i < headers.size(); i++) {
+    for (int i = 0, size = headers.size(); i < size; i++) {
       builder.addHeader(headers.name(i), headers.value(i));
     }
 
@@ -349,8 +359,8 @@ private HttpEngine newHttpEngine(String method, Connection connection,
       engineClient = client.clone().setCache(null);
     }
 
-    return new HttpEngine(engineClient, request, bufferRequestBody, connection, null, requestBody,
-        priorResponse);
+    return new HttpEngine(engineClient, request, bufferRequestBody, true, false, connection, null,
+        requestBody, priorResponse);
   }
 
   private String defaultUserAgent() {
@@ -383,8 +393,8 @@ private HttpEngine getResponse() throws IOException {
         return httpEngine;
       }
 
-      if (response.isRedirect() && ++redirectionCount > HttpEngine.MAX_REDIRECTS) {
-        throw new ProtocolException("Too many redirects: " + redirectionCount);
+      if (++followUpCount > HttpEngine.MAX_FOLLOW_UPS) {
+        throw new ProtocolException("Too many follow-up requests: " + followUpCount);
       }
 
       // The first request was insufficient. Prepare for another...
@@ -430,7 +440,25 @@ private boolean execute(boolean readResponse) throws IOException {
       }
 
       return true;
+    } catch (RequestException e) {
+      // An attempt to interpret a request failed.
+      IOException toThrow = e.getCause();
+      httpEngineFailure = toThrow;
+      throw toThrow;
+    } catch (RouteException e) {
+      // The attempt to connect via a route failed. The request will not have been sent.
+      HttpEngine retryEngine = httpEngine.recover(e);
+      if (retryEngine != null) {
+        httpEngine = retryEngine;
+        return false;
+      }
+
+      // Give up; recovery is not possible.
+      IOException toThrow = e.getLastConnectException();
+      httpEngineFailure = toThrow;
+      throw toThrow;
     } catch (IOException e) {
+      // An attempt to communicate with a server failed. The request may have been sent.
       HttpEngine retryEngine = httpEngine.recover(e);
       if (retryEngine != null) {
         httpEngine = retryEngine;
@@ -550,9 +578,8 @@ private void setProtocols(String protocolsString, boolean append) {
   }
 
   @Override public void setRequestMethod(String method) throws ProtocolException {
-    if (!HttpMethod.METHODS.contains(method)) {
-      throw new ProtocolException(
-          "Expected one of " + HttpMethod.METHODS + " but was " + method);
+    if (!METHODS.contains(method)) {
+      throw new ProtocolException("Expected one of " + METHODS + " but was " + method);
     }
     this.method = method;
   }
diff --git a/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/JavaApiConverter.java b/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/JavaApiConverter.java
deleted file mode 100644
index b1a9246464..0000000000
--- a/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/JavaApiConverter.java
+++ /dev/null
@@ -1,696 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal.huc;
-
-import android.annotation.TargetApi;
-
-import com.squareup.okhttp.Handshake;
-import com.squareup.okhttp.Headers;
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
-import com.squareup.okhttp.ResponseBody;
-import com.squareup.okhttp.internal.Util;
-import com.squareup.okhttp.internal.http.OkHeaders;
-import com.squareup.okhttp.internal.http.StatusLine;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.net.CacheResponse;
-import java.net.HttpURLConnection;
-import java.net.ProtocolException;
-import java.net.SecureCacheResponse;
-import java.net.URI;
-import java.net.URLConnection;
-import java.security.Principal;
-import java.security.cert.Certificate;
-import java.util.Collections;
-import java.util.List;
-import java.util.Map;
-
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.HttpsURLConnection;
-import javax.net.ssl.SSLPeerUnverifiedException;
-import javax.net.ssl.SSLSocketFactory;
-
-import okio.BufferedSource;
-import okio.Okio;
-
-/**
- * Helper methods that convert between Java and OkHttp representations.
- */
-public final class JavaApiConverter {
-
-	private JavaApiConverter() {
-	}
-
-	/**
-	 * Creates an OkHttp {@link Response} using the supplied {@link URI} and {@link URLConnection} to supply the data. The URLConnection is
-	 * assumed to already be connected.
-	 */
-	public static Response createOkResponse(URI uri, URLConnection urlConnection) throws IOException {
-		HttpURLConnection httpUrlConnection = (HttpURLConnection) urlConnection;
-
-		Response.Builder okResponseBuilder = new Response.Builder();
-
-		// Request: Create one from the URL connection.
-		// A connected HttpURLConnection does not permit access to request headers.
-		Map<String, List<String>> requestHeaders = null;
-		Request okRequest = createOkRequest(uri, httpUrlConnection.getRequestMethod(), requestHeaders);
-		okResponseBuilder.request(okRequest);
-
-		// Status line
-		StatusLine statusLine = StatusLine.parse(extractStatusLine(httpUrlConnection));
-		okResponseBuilder.protocol(statusLine.protocol);
-		okResponseBuilder.code(statusLine.code);
-		okResponseBuilder.message(statusLine.message);
-
-		// Response headers
-		Headers okHeaders = extractOkResponseHeaders(httpUrlConnection);
-		okResponseBuilder.headers(okHeaders);
-
-		// Response body
-		ResponseBody okBody = createOkBody(okHeaders, urlConnection.getInputStream());
-		okResponseBuilder.body(okBody);
-
-		// Handle SSL handshake information as needed.
-		if (httpUrlConnection instanceof HttpsURLConnection) {
-			HttpsURLConnection httpsUrlConnection = (HttpsURLConnection) httpUrlConnection;
-
-			Certificate[] peerCertificates;
-			try {
-				peerCertificates = httpsUrlConnection.getServerCertificates();
-			} catch (SSLPeerUnverifiedException e) {
-				peerCertificates = null;
-			}
-
-			Certificate[] localCertificates = httpsUrlConnection.getLocalCertificates();
-
-			Handshake handshake = Handshake.get(httpsUrlConnection.getCipherSuite(), nullSafeImmutableList(peerCertificates),
-					nullSafeImmutableList(localCertificates));
-			okResponseBuilder.handshake(handshake);
-		}
-
-		return okResponseBuilder.build();
-	}
-
-	/**
-	 * Creates an OkHttp {@link Response} using the supplied {@link Request} and {@link CacheResponse} to supply the data.
-	 */
-	static Response createOkResponse(Request request, CacheResponse javaResponse) throws IOException {
-		Response.Builder okResponseBuilder = new Response.Builder();
-
-		// Request: Use the one provided.
-		okResponseBuilder.request(request);
-
-		// Status line: Java has this as one of the headers.
-		StatusLine statusLine = StatusLine.parse(extractStatusLine(javaResponse));
-		okResponseBuilder.protocol(statusLine.protocol);
-		okResponseBuilder.code(statusLine.code);
-		okResponseBuilder.message(statusLine.message);
-
-		// Response headers
-		Headers okHeaders = extractOkHeaders(javaResponse);
-		okResponseBuilder.headers(okHeaders);
-
-		// Response body
-		ResponseBody okBody = createOkBody(okHeaders, javaResponse.getBody());
-		okResponseBuilder.body(okBody);
-
-		// Handle SSL handshake information as needed.
-		if (javaResponse instanceof SecureCacheResponse) {
-			SecureCacheResponse javaSecureCacheResponse = (SecureCacheResponse) javaResponse;
-
-			// Handshake doesn't support null lists.
-			List<Certificate> peerCertificates;
-			try {
-				peerCertificates = javaSecureCacheResponse.getServerCertificateChain();
-			} catch (SSLPeerUnverifiedException e) {
-				peerCertificates = Collections.emptyList();
-			}
-			List<Certificate> localCertificates = javaSecureCacheResponse.getLocalCertificateChain();
-			if (localCertificates == null) {
-				localCertificates = Collections.emptyList();
-			}
-			Handshake handshake = Handshake.get(javaSecureCacheResponse.getCipherSuite(), peerCertificates, localCertificates);
-			okResponseBuilder.handshake(handshake);
-		}
-
-		return okResponseBuilder.build();
-	}
-
-	/**
-	 * Creates an OkHttp {@link Request} from the supplied information.
-	 *
-	 * <p>
-	 * This method allows a {@code null} value for {@code requestHeaders} for situations where a connection is already connected and access
-	 * to the headers has been lost. See {@link java.net.HttpURLConnection#getRequestProperties()} for details.
-	 */
-	public static Request createOkRequest(URI uri, String requestMethod, Map<String, List<String>> requestHeaders) {
-
-		Request.Builder builder = new Request.Builder().url(uri.toString()).method(requestMethod, null);
-
-		if (requestHeaders != null) {
-			Headers headers = extractOkHeaders(requestHeaders);
-			builder.headers(headers);
-		}
-		return builder.build();
-	}
-
-	/**
-	 * Creates a {@link java.net.CacheResponse} of the correct (sub)type using information gathered from the supplied {@link Response}.
-	 */
-	public static CacheResponse createJavaCacheResponse(final Response response) {
-		final Headers headers = response.headers();
-		final ResponseBody body = response.body();
-		if (response.request().isHttps()) {
-			final Handshake handshake = response.handshake();
-			return new SecureCacheResponse() {
-				@Override
-				public String getCipherSuite() {
-					return handshake != null ? handshake.cipherSuite() : null;
-				}
-
-				@Override
-				public List<Certificate> getLocalCertificateChain() {
-					if (handshake == null)
-						return null;
-					// Java requires null, not an empty list here.
-					List<Certificate> certificates = handshake.localCertificates();
-					return certificates.size() > 0 ? certificates : null;
-				}
-
-				@Override
-				public List<Certificate> getServerCertificateChain() throws SSLPeerUnverifiedException {
-					if (handshake == null)
-						return null;
-					// Java requires null, not an empty list here.
-					List<Certificate> certificates = handshake.peerCertificates();
-					return certificates.size() > 0 ? certificates : null;
-				}
-
-				@Override
-				public Principal getPeerPrincipal() throws SSLPeerUnverifiedException {
-					if (handshake == null)
-						return null;
-					return handshake.peerPrincipal();
-				}
-
-				@Override
-				public Principal getLocalPrincipal() {
-					if (handshake == null)
-						return null;
-					return handshake.localPrincipal();
-				}
-
-				@Override
-				public Map<String, List<String>> getHeaders() throws IOException {
-					// Java requires that the entry with a null key be the status line.
-					return OkHeaders.toMultimap(headers, StatusLine.get(response).toString());
-				}
-
-				@Override
-				public InputStream getBody() throws IOException {
-					if (body == null)
-						return null;
-					return body.byteStream();
-				}
-			};
-		} else {
-			return new CacheResponse() {
-				@Override
-				public Map<String, List<String>> getHeaders() throws IOException {
-					// Java requires that the entry with a null key be the status line.
-					return OkHeaders.toMultimap(headers, StatusLine.get(response).toString());
-				}
-
-				@Override
-				public InputStream getBody() throws IOException {
-					if (body == null)
-						return null;
-					return body.byteStream();
-				}
-			};
-		}
-	}
-
-	/**
-	 * Creates an {@link java.net.HttpURLConnection} of the correct subclass from the supplied OkHttp {@link Response}.
-	 */
-	static HttpURLConnection createJavaUrlConnection(Response okResponse) {
-		Request request = okResponse.request();
-		// Create an object of the correct class in case the ResponseCache uses instanceof.
-		if (request.isHttps()) {
-			return new CacheHttpsURLConnection(new CacheHttpURLConnection(okResponse));
-		} else {
-			return new CacheHttpURLConnection(okResponse);
-		}
-	}
-
-	/**
-	 * Extracts an immutable request header map from the supplied {@link com.squareup.okhttp.Headers}.
-	 */
-	static Map<String, List<String>> extractJavaHeaders(Request request) {
-		return OkHeaders.toMultimap(request.headers(), null);
-	}
-
-	/**
-	 * Extracts OkHttp headers from the supplied {@link java.net.CacheResponse}. Only real headers are extracted. See
-	 * {@link #extractStatusLine(java.net.CacheResponse)}.
-	 */
-	private static Headers extractOkHeaders(CacheResponse javaResponse) throws IOException {
-		Map<String, List<String>> javaResponseHeaders = javaResponse.getHeaders();
-		return extractOkHeaders(javaResponseHeaders);
-	}
-
-	/**
-	 * Extracts OkHttp headers from the supplied {@link java.net.HttpURLConnection}. Only real headers are extracted. See
-	 * {@link #extractStatusLine(java.net.HttpURLConnection)}.
-	 */
-	private static Headers extractOkResponseHeaders(HttpURLConnection httpUrlConnection) {
-		Map<String, List<String>> javaResponseHeaders = httpUrlConnection.getHeaderFields();
-		return extractOkHeaders(javaResponseHeaders);
-	}
-
-	/**
-	 * Extracts OkHttp headers from the supplied {@link Map}. Only real headers are extracted. Any entry (one with a {@code null} key) is
-	 * discarded.
-	 */
-	// @VisibleForTesting
-	static Headers extractOkHeaders(Map<String, List<String>> javaHeaders) {
-		Headers.Builder okHeadersBuilder = new Headers.Builder();
-		for (Map.Entry<String, List<String>> javaHeader : javaHeaders.entrySet()) {
-			String name = javaHeader.getKey();
-			if (name == null) {
-				// The Java API uses the null key to store the status line in responses.
-				// Earlier versions of OkHttp would use the null key to store the "request line" in
-				// requests. e.g. "GET / HTTP 1.1". Although this is no longer the case it must be
-				// explicitly ignored because Headers.Builder does not support null keys.
-				continue;
-			}
-			for (String value : javaHeader.getValue()) {
-				okHeadersBuilder.add(name, value);
-			}
-		}
-		return okHeadersBuilder.build();
-	}
-
-	/**
-	 * Extracts the status line from the supplied Java API {@link java.net.HttpURLConnection}. As per the spec, the status line is held as
-	 * the header with the null key. Returns {@code null} if there is no status line.
-	 */
-	private static String extractStatusLine(HttpURLConnection httpUrlConnection) {
-		// Java specifies that this will be be response header with a null key.
-		return httpUrlConnection.getHeaderField(null);
-	}
-
-	/**
-	 * Extracts the status line from the supplied Java API {@link java.net.CacheResponse}. As per the spec, the status line is held as the
-	 * header with the null key. Returns {@code null} if there is no status line.
-	 */
-	private static String extractStatusLine(CacheResponse javaResponse) throws IOException {
-		Map<String, List<String>> javaResponseHeaders = javaResponse.getHeaders();
-		return extractStatusLine(javaResponseHeaders);
-	}
-
-	// VisibleForTesting
-	static String extractStatusLine(Map<String, List<String>> javaResponseHeaders) {
-		List<String> values = javaResponseHeaders.get(null);
-		if (values == null || values.size() == 0) {
-			return null;
-		}
-		return values.get(0);
-	}
-
-	/**
-	 * Creates an OkHttp Response.Body containing the supplied information.
-	 */
-	private static ResponseBody createOkBody(final Headers okHeaders, InputStream body) {
-		final BufferedSource source = Okio.buffer(Okio.source(body));
-		return new ResponseBody() {
-			@Override
-			public MediaType contentType() {
-				String contentTypeHeader = okHeaders.get("Content-Type");
-				return contentTypeHeader == null ? null : MediaType.parse(contentTypeHeader);
-			}
-
-			@Override
-			public long contentLength() {
-				return OkHeaders.contentLength(okHeaders);
-			}
-
-			@Override
-			public BufferedSource source() {
-				return source;
-			}
-		};
-	}
-
-	/**
-	 * An {@link java.net.HttpURLConnection} that represents an HTTP request at the point where the request has been made, and the response
-	 * headers have been received, but the body content, if present, has not been read yet. This intended to provide enough information for
-	 * {@link java.net.ResponseCache} subclasses and no more.
-	 *
-	 * <p>
-	 * Much of the method implementations are overrides to delegate to the OkHttp request and response, or to deny access to information as
-	 * a real HttpURLConnection would after connection.
-	 */
-	private static final class CacheHttpURLConnection extends HttpURLConnection {
-
-		private final Request request;
-		private final Response response;
-
-		public CacheHttpURLConnection(Response response) {
-			super(response.request().url());
-			this.request = response.request();
-			this.response = response;
-
-			// Configure URLConnection inherited fields.
-			this.connected = true;
-			this.doOutput = response.body() == null;
-
-			// Configure HttpUrlConnection inherited fields.
-			this.method = request.method();
-		}
-
-		// HTTP connection lifecycle methods
-
-		@Override
-		public void connect() throws IOException {
-			throw throwRequestModificationException();
-		}
-
-		@Override
-		public void disconnect() {
-			throw throwRequestModificationException();
-		}
-
-		// HTTP Request methods
-
-		@Override
-		public void setRequestProperty(String key, String value) {
-			throw throwRequestModificationException();
-		}
-
-		@Override
-		public void addRequestProperty(String key, String value) {
-			throw throwRequestModificationException();
-		}
-
-		@Override
-		public String getRequestProperty(String key) {
-			return request.header(key);
-		}
-
-		@Override
-		public Map<String, List<String>> getRequestProperties() {
-			// This is to preserve RI and compatibility with OkHttp's HttpURLConnectionImpl. There seems
-			// no good reason why this should fail while getRequestProperty() is ok.
-			throw throwRequestHeaderAccessException();
-		}
-
-		@Override
-		public void setFixedLengthStreamingMode(int contentLength) {
-			throw throwRequestModificationException();
-		}
-
-		@Override
-		public void setFixedLengthStreamingMode(long contentLength) {
-			throw throwRequestModificationException();
-		}
-
-		@Override
-		public void setChunkedStreamingMode(int chunklen) {
-			throw throwRequestModificationException();
-		}
-
-		@Override
-		public void setInstanceFollowRedirects(boolean followRedirects) {
-			throw throwRequestModificationException();
-		}
-
-		@Override
-		public boolean getInstanceFollowRedirects() {
-			// Return the platform default.
-			return super.getInstanceFollowRedirects();
-		}
-
-		@Override
-		public void setRequestMethod(String method) throws ProtocolException {
-			throw throwRequestModificationException();
-		}
-
-		@Override
-		public String getRequestMethod() {
-			return request.method();
-		}
-
-		// HTTP Response methods
-
-		@Override
-		public String getHeaderFieldKey(int position) {
-			// Deal with index 0 meaning "status line"
-			if (position < 0) {
-				throw new IllegalArgumentException("Invalid header index: " + position);
-			}
-			if (position == 0) {
-				return null;
-			}
-			return response.headers().name(position - 1);
-		}
-
-		@Override
-		public String getHeaderField(int position) {
-			// Deal with index 0 meaning "status line"
-			if (position < 0) {
-				throw new IllegalArgumentException("Invalid header index: " + position);
-			}
-			if (position == 0) {
-				return StatusLine.get(response).toString();
-			}
-			return response.headers().value(position - 1);
-		}
-
-		@Override
-		public String getHeaderField(String fieldName) {
-			return fieldName == null ? StatusLine.get(response).toString() : response.headers().get(fieldName);
-		}
-
-		@Override
-		public Map<String, List<String>> getHeaderFields() {
-			return OkHeaders.toMultimap(response.headers(), StatusLine.get(response).toString());
-		}
-
-		@Override
-		public int getResponseCode() throws IOException {
-			return response.code();
-		}
-
-		@Override
-		public String getResponseMessage() throws IOException {
-			return response.message();
-		}
-
-		@Override
-		public InputStream getErrorStream() {
-			return null;
-		}
-
-		// HTTP miscellaneous methods
-
-		@Override
-		public boolean usingProxy() {
-			// It's safe to return false here, even if a proxy is in use. The problem is we don't
-			// necessarily know if we're going to use a proxy by the time we ask the cache for a response.
-			return false;
-		}
-
-		// URLConnection methods
-
-		@Override
-		public void setConnectTimeout(int timeout) {
-			throw throwRequestModificationException();
-		}
-
-		@Override
-		public int getConnectTimeout() {
-			// Impossible to say.
-			return 0;
-		}
-
-		@Override
-		public void setReadTimeout(int timeout) {
-			throw throwRequestModificationException();
-		}
-
-		@Override
-		public int getReadTimeout() {
-			// Impossible to say.
-			return 0;
-		}
-
-		@Override
-		public Object getContent() throws IOException {
-			throw throwResponseBodyAccessException();
-		}
-
-		@Override
-		public Object getContent(Class[] classes) throws IOException {
-			throw throwResponseBodyAccessException();
-		}
-
-		@Override
-		public InputStream getInputStream() throws IOException {
-			throw throwResponseBodyAccessException();
-		}
-
-		@Override
-		public OutputStream getOutputStream() throws IOException {
-			throw throwRequestModificationException();
-		}
-
-		@Override
-		public void setDoInput(boolean doInput) {
-			throw throwRequestModificationException();
-		}
-
-		@Override
-		public boolean getDoInput() {
-			return true;
-		}
-
-		@Override
-		public void setDoOutput(boolean doOutput) {
-			throw throwRequestModificationException();
-		}
-
-		@Override
-		public boolean getDoOutput() {
-			return request.body() != null;
-		}
-
-		@Override
-		public void setAllowUserInteraction(boolean allowUserInteraction) {
-			throw throwRequestModificationException();
-		}
-
-		@Override
-		public boolean getAllowUserInteraction() {
-			return false;
-		}
-
-		@Override
-		public void setUseCaches(boolean useCaches) {
-			throw throwRequestModificationException();
-		}
-
-		@Override
-		public boolean getUseCaches() {
-			return super.getUseCaches();
-		}
-
-		@Override
-		public void setIfModifiedSince(long ifModifiedSince) {
-			throw throwRequestModificationException();
-		}
-
-		@Override
-		public long getIfModifiedSince() {
-			return 0;
-		}
-
-		@Override
-		public boolean getDefaultUseCaches() {
-			return super.getDefaultUseCaches();
-		}
-
-		@Override
-		public void setDefaultUseCaches(boolean defaultUseCaches) {
-			super.setDefaultUseCaches(defaultUseCaches);
-		}
-	}
-
-	/** An HttpsURLConnection to offer to the cache. */
-	private static final class CacheHttpsURLConnection extends DelegatingHttpsURLConnection {
-		private final CacheHttpURLConnection delegate;
-
-		public CacheHttpsURLConnection(CacheHttpURLConnection delegate) {
-			super(delegate);
-			this.delegate = delegate;
-		}
-
-		@Override
-		protected Handshake handshake() {
-			return delegate.response.handshake();
-		}
-
-		@Override
-		public void setHostnameVerifier(HostnameVerifier hostnameVerifier) {
-			throw throwRequestModificationException();
-		}
-
-		@Override
-		public HostnameVerifier getHostnameVerifier() {
-			throw throwRequestSslAccessException();
-		}
-
-		@Override
-		public void setSSLSocketFactory(SSLSocketFactory socketFactory) {
-			throw throwRequestModificationException();
-		}
-
-		@Override
-		public SSLSocketFactory getSSLSocketFactory() {
-			throw throwRequestSslAccessException();
-		}
-
-		// @Override public long getContentLengthLong() {
-		// return delegate.getContentLengthLong();
-		// }
-
-		@TargetApi(19)
-		@Override
-		public void setFixedLengthStreamingMode(long contentLength) {
-			delegate.setFixedLengthStreamingMode(contentLength);
-		}
-
-		// @Override public long getHeaderFieldLong(String field, long defaultValue) {
-		// return delegate.getHeaderFieldLong(field, defaultValue);
-		// }
-	}
-
-	private static RuntimeException throwRequestModificationException() {
-		throw new UnsupportedOperationException("ResponseCache cannot modify the request.");
-	}
-
-	private static RuntimeException throwRequestHeaderAccessException() {
-		throw new UnsupportedOperationException("ResponseCache cannot access request headers");
-	}
-
-	private static RuntimeException throwRequestSslAccessException() {
-		throw new UnsupportedOperationException("ResponseCache cannot access SSL internals");
-	}
-
-	private static RuntimeException throwResponseBodyAccessException() {
-		throw new UnsupportedOperationException("ResponseCache cannot access the response body.");
-	}
-
-	private static <T> List<T> nullSafeImmutableList(T[] elements) {
-		return elements == null ? Collections.<T> emptyList() : Util.immutableList(elements);
-	}
-
-}
diff --git a/okhttp-urlconnection/src/test/java/com/squareup/okhttp/OkUrlFactoryTest.java b/okhttp-urlconnection/src/test/java/com/squareup/okhttp/OkUrlFactoryTest.java
new file mode 100644
index 0000000000..a7dc44b0d0
--- /dev/null
+++ b/okhttp-urlconnection/src/test/java/com/squareup/okhttp/OkUrlFactoryTest.java
@@ -0,0 +1,167 @@
+package com.squareup.okhttp;
+
+import com.squareup.okhttp.internal.Platform;
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
+import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
+import java.io.IOException;
+import java.net.HttpURLConnection;
+import java.text.DateFormat;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.Locale;
+import java.util.TimeZone;
+import java.util.concurrent.TimeUnit;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
+
+import static java.nio.charset.StandardCharsets.US_ASCII;
+import static okio.Okio.buffer;
+import static okio.Okio.source;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+public class OkUrlFactoryTest {
+  @Rule public MockWebServerRule serverRule = new MockWebServerRule();
+  @Rule public TemporaryFolder cacheFolder = new TemporaryFolder();
+
+  private MockWebServer server;
+  private OkUrlFactory factory;
+
+  @Before public void setUp() throws IOException {
+    server = serverRule.get();
+
+    OkHttpClient client = new OkHttpClient();
+    client.setCache(new Cache(cacheFolder.getRoot(), 10 * 1024 * 1024));
+    factory = new OkUrlFactory(client);
+  }
+
+  /**
+   * Response code 407 should only come from proxy servers. Android's client
+   * throws if it is sent by an origin server.
+   */
+  @Test public void originServerSends407() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(407));
+
+    HttpURLConnection conn = factory.open(server.getUrl("/"));
+    try {
+      conn.getResponseCode();
+      fail();
+    } catch (IOException ignored) {
+    }
+  }
+
+  @Test public void networkResponseSourceHeader() throws Exception {
+    server.enqueue(new MockResponse().setBody("Isla Sorna"));
+
+    HttpURLConnection connection = factory.open(server.getUrl("/"));
+    assertResponseHeader(connection, "NETWORK 200");
+    assertResponseBody(connection, "Isla Sorna");
+  }
+
+  @Test public void networkFailureResponseSourceHeader() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    HttpURLConnection connection = factory.open(server.getUrl("/"));
+    assertResponseHeader(connection, "NETWORK 404");
+  }
+
+  @Test public void conditionalCacheHitResponseSourceHeaders() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(0, TimeUnit.SECONDS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("Isla Nublar"));
+    server.enqueue(new MockResponse().setResponseCode(304));
+
+    HttpURLConnection connection1 = factory.open(server.getUrl("/"));
+    assertResponseHeader(connection1, "NETWORK 200");
+    assertResponseBody(connection1, "Isla Nublar");
+
+    HttpURLConnection connection2 = factory.open(server.getUrl("/"));
+    assertResponseHeader(connection2, "CONDITIONAL_CACHE 304");
+    assertResponseBody(connection2, "Isla Nublar");
+  }
+
+  @Test public void conditionalCacheMissResponseSourceHeaders() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(0, TimeUnit.SECONDS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("Isla Nublar"));
+    server.enqueue(new MockResponse().setBody("Isla Sorna"));
+
+    HttpURLConnection connection1 = factory.open(server.getUrl("/"));
+    assertResponseHeader(connection1, "NETWORK 200");
+    assertResponseBody(connection1, "Isla Nublar");
+
+    HttpURLConnection connection2 = factory.open(server.getUrl("/"));
+    assertResponseHeader(connection2, "CONDITIONAL_CACHE 200");
+    assertResponseBody(connection2, "Isla Sorna");
+  }
+
+  @Test public void cacheResponseSourceHeaders() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Expires: " + formatDate(2, TimeUnit.HOURS))
+        .setBody("Isla Nublar"));
+
+    HttpURLConnection connection1 = factory.open(server.getUrl("/"));
+    assertResponseHeader(connection1, "NETWORK 200");
+    assertResponseBody(connection1, "Isla Nublar");
+
+    HttpURLConnection connection2 = factory.open(server.getUrl("/"));
+    assertResponseHeader(connection2, "CACHE 200");
+    assertResponseBody(connection2, "Isla Nublar");
+  }
+
+  @Test public void noneResponseSourceHeaders() throws Exception {
+    server.enqueue(new MockResponse().setBody("Isla Nublar"));
+
+    HttpURLConnection connection1 = factory.open(server.getUrl("/"));
+    assertResponseHeader(connection1, "NETWORK 200");
+    assertResponseBody(connection1, "Isla Nublar");
+
+    HttpURLConnection connection2 = factory.open(server.getUrl("/"));
+    connection2.setRequestProperty("Cache-Control", "only-if-cached");
+    assertResponseHeader(connection2, "NONE");
+  }
+
+  @Test
+  public void setInstanceFollowRedirectsFalse() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(302)
+        .addHeader("Location: /b")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    HttpURLConnection connection = factory.open(server.getUrl("/a"));
+    connection.setInstanceFollowRedirects(false);
+    assertResponseBody(connection, "A");
+    assertResponseCode(connection, 302);
+  }
+
+  private void assertResponseBody(HttpURLConnection connection, String expected) throws Exception {
+    String actual = buffer(source(connection.getInputStream())).readString(US_ASCII);
+    assertEquals(expected, actual);
+  }
+
+  private void assertResponseHeader(HttpURLConnection connection, String expected) {
+    final String headerFieldPrefix = Platform.get().getPrefix();
+    assertEquals(expected, connection.getHeaderField(headerFieldPrefix + "-Response-Source"));
+  }
+
+  private void assertResponseCode(HttpURLConnection connection, int expected) throws IOException {
+    assertEquals(expected, connection.getResponseCode());
+  }
+
+  private static String formatDate(long delta, TimeUnit timeUnit) {
+    return formatDate(new Date(System.currentTimeMillis() + timeUnit.toMillis(delta)));
+  }
+
+  private static String formatDate(Date date) {
+    DateFormat rfc1123 = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss zzz", Locale.US);
+    rfc1123.setTimeZone(TimeZone.getTimeZone("GMT"));
+    return rfc1123.format(date);
+  }
+}
diff --git a/okhttp-urlconnection/src/test/java/com/squareup/okhttp/UrlConnectionCacheTest.java b/okhttp-urlconnection/src/test/java/com/squareup/okhttp/UrlConnectionCacheTest.java
new file mode 100644
index 0000000000..db0ed8fa6c
--- /dev/null
+++ b/okhttp-urlconnection/src/test/java/com/squareup/okhttp/UrlConnectionCacheTest.java
@@ -0,0 +1,1836 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.squareup.okhttp;
+
+import com.squareup.okhttp.internal.Internal;
+import com.squareup.okhttp.internal.SslContextBuilder;
+import com.squareup.okhttp.internal.Util;
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
+import com.squareup.okhttp.mockwebserver.RecordedRequest;
+import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.GzipSink;
+import okio.Okio;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
+
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.HttpsURLConnection;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSession;
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.OutputStream;
+import java.net.CookieHandler;
+import java.net.CookieManager;
+import java.net.HttpCookie;
+import java.net.HttpURLConnection;
+import java.net.ResponseCache;
+import java.net.URL;
+import java.net.URLConnection;
+import java.security.Principal;
+import java.security.cert.Certificate;
+import java.text.DateFormat;
+import java.text.SimpleDateFormat;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Date;
+import java.util.List;
+import java.util.Locale;
+import java.util.TimeZone;
+import java.util.concurrent.TimeUnit;
+
+import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+/** Test caching with {@link OkUrlFactory}. */
+public final class UrlConnectionCacheTest {
+  private static final HostnameVerifier NULL_HOSTNAME_VERIFIER = new HostnameVerifier() {
+    @Override public boolean verify(String s, SSLSession sslSession) {
+      return true;
+    }
+  };
+
+  private static final SSLContext sslContext = SslContextBuilder.localhost();
+
+  @Rule public TemporaryFolder cacheRule = new TemporaryFolder();
+  @Rule public MockWebServerRule serverRule = new MockWebServerRule();
+  @Rule public MockWebServerRule server2Rule = new MockWebServerRule();
+
+  private final OkUrlFactory client = new OkUrlFactory(new OkHttpClient());
+  private MockWebServer server;
+  private MockWebServer server2;
+  private Cache cache;
+  private final CookieManager cookieManager = new CookieManager();
+
+  @Before public void setUp() throws Exception {
+    server = serverRule.get();
+    server.setProtocolNegotiationEnabled(false);
+    server2 = server2Rule.get();
+    cache = new Cache(cacheRule.getRoot(), Integer.MAX_VALUE);
+    client.client().setCache(cache);
+    CookieHandler.setDefault(cookieManager);
+  }
+
+  @After public void tearDown() throws Exception {
+    ResponseCache.setDefault(null);
+    CookieHandler.setDefault(null);
+  }
+
+  @Test public void responseCacheAccessWithOkHttpMember() throws IOException {
+    assertSame(cache, client.client().getCache());
+  }
+
+  /**
+   * Test that response caching is consistent with the RI and the spec.
+   * http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.4
+   */
+  @Test public void responseCachingByResponseCode() throws Exception {
+      // Test each documented HTTP/1.1 code, plus the first unused value in each range.
+      // http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html
+
+      // We can't test 100 because it's not really a response.
+      // assertCached(false, 100);
+      assertCached(false, 101);
+      assertCached(false, 102);
+      assertCached(true,  200);
+      assertCached(false, 201);
+      assertCached(false, 202);
+      assertCached(true,  203);
+      assertCached(true,  204);
+      assertCached(false, 205);
+      assertCached(false, 206); //Electing to not cache partial responses
+      assertCached(false, 207);
+      assertCached(true,  300);
+      assertCached(true,  301);
+      assertCached(true,  302);
+      assertCached(false, 303);
+      assertCached(false, 304);
+      assertCached(false, 305);
+      assertCached(false, 306);
+      assertCached(true,  307);
+      assertCached(true,  308);
+      assertCached(false, 400);
+      assertCached(false, 401);
+      assertCached(false, 402);
+      assertCached(false, 403);
+      assertCached(true,  404);
+      assertCached(true,  405);
+      assertCached(false, 406);
+      assertCached(false, 408);
+      assertCached(false, 409);
+      // the HTTP spec permits caching 410s, but the RI doesn't.
+      assertCached(true,  410);
+      assertCached(false, 411);
+      assertCached(false, 412);
+      assertCached(false, 413);
+      assertCached(true,  414);
+      assertCached(false, 415);
+      assertCached(false, 416);
+      assertCached(false, 417);
+      assertCached(false, 418);
+
+      assertCached(false, 500);
+      assertCached(true,  501);
+      assertCached(false, 502);
+      assertCached(false, 503);
+      assertCached(false, 504);
+      assertCached(false, 505);
+      assertCached(false, 506);
+  }
+
+  private void assertCached(boolean shouldPut, int responseCode) throws Exception {
+    server = new MockWebServer();
+    MockResponse response = new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setResponseCode(responseCode)
+        .setBody("ABCDE")
+        .addHeader("WWW-Authenticate: challenge");
+    if (responseCode == HttpURLConnection.HTTP_PROXY_AUTH) {
+      response.addHeader("Proxy-Authenticate: Basic realm=\"protected area\"");
+    } else if (responseCode == HttpURLConnection.HTTP_UNAUTHORIZED) {
+      response.addHeader("WWW-Authenticate: Basic realm=\"protected area\"");
+    }
+    server.enqueue(response);
+    server.start();
+
+    URL url = server.getUrl("/");
+    HttpURLConnection conn = client.open(url);
+    assertEquals(responseCode, conn.getResponseCode());
+
+    // exhaust the content stream
+    readAscii(conn);
+
+    Response cached = cache.get(new Request.Builder().url(url).build());
+    if (shouldPut) {
+      assertNotNull(Integer.toString(responseCode), cached);
+      cached.body().close();
+    } else {
+      assertNull(Integer.toString(responseCode), cached);
+    }
+    server.shutdown(); // tearDown() isn't sufficient; this test starts multiple servers
+  }
+
+  @Test public void responseCachingAndInputStreamSkipWithFixedLength() throws IOException {
+    testResponseCaching(TransferKind.FIXED_LENGTH);
+  }
+
+  @Test public void responseCachingAndInputStreamSkipWithChunkedEncoding() throws IOException {
+    testResponseCaching(TransferKind.CHUNKED);
+  }
+
+  @Test public void responseCachingAndInputStreamSkipWithNoLengthHeaders() throws IOException {
+    testResponseCaching(TransferKind.END_OF_STREAM);
+  }
+
+  /**
+   * HttpURLConnection.getInputStream().skip(long) causes ResponseCache corruption
+   * http://code.google.com/p/android/issues/detail?id=8175
+   */
+  private void testResponseCaching(TransferKind transferKind) throws IOException {
+    MockResponse response =
+        new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+            .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+            .setStatus("HTTP/1.1 200 Fantastic");
+    transferKind.setBody(response, "I love puppies but hate spiders", 1);
+    server.enqueue(response);
+
+    // Make sure that calling skip() doesn't omit bytes from the cache.
+    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
+    InputStream in = urlConnection.getInputStream();
+    assertEquals("I love ", readAscii(urlConnection, "I love ".length()));
+    reliableSkip(in, "puppies but hate ".length());
+    assertEquals("spiders", readAscii(urlConnection, "spiders".length()));
+    assertEquals(-1, in.read());
+    in.close();
+    assertEquals(1, cache.getWriteSuccessCount());
+    assertEquals(0, cache.getWriteAbortCount());
+
+    urlConnection = client.open(server.getUrl("/")); // cached!
+    in = urlConnection.getInputStream();
+    assertEquals("I love puppies but hate spiders",
+        readAscii(urlConnection, "I love puppies but hate spiders".length()));
+    assertEquals(200, urlConnection.getResponseCode());
+    assertEquals("Fantastic", urlConnection.getResponseMessage());
+
+    assertEquals(-1, in.read());
+    in.close();
+    assertEquals(1, cache.getWriteSuccessCount());
+    assertEquals(0, cache.getWriteAbortCount());
+    assertEquals(2, cache.getRequestCount());
+    assertEquals(1, cache.getHitCount());
+  }
+
+  @Test public void secureResponseCaching() throws IOException {
+    server.useHttps(sslContext.getSocketFactory(), false);
+    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setBody("ABC"));
+
+    HttpsURLConnection c1 = (HttpsURLConnection) client.open(server.getUrl("/"));
+    c1.setSSLSocketFactory(sslContext.getSocketFactory());
+    c1.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+    assertEquals("ABC", readAscii(c1));
+
+    // OpenJDK 6 fails on this line, complaining that the connection isn't open yet
+    String suite = c1.getCipherSuite();
+    List<Certificate> localCerts = toListOrNull(c1.getLocalCertificates());
+    List<Certificate> serverCerts = toListOrNull(c1.getServerCertificates());
+    Principal peerPrincipal = c1.getPeerPrincipal();
+    Principal localPrincipal = c1.getLocalPrincipal();
+
+    HttpsURLConnection c2 = (HttpsURLConnection) client.open(server.getUrl("/")); // cached!
+    c2.setSSLSocketFactory(sslContext.getSocketFactory());
+    c2.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+    assertEquals("ABC", readAscii(c2));
+
+    assertEquals(2, cache.getRequestCount());
+    assertEquals(1, cache.getNetworkCount());
+    assertEquals(1, cache.getHitCount());
+
+    assertEquals(suite, c2.getCipherSuite());
+    assertEquals(localCerts, toListOrNull(c2.getLocalCertificates()));
+    assertEquals(serverCerts, toListOrNull(c2.getServerCertificates()));
+    assertEquals(peerPrincipal, c2.getPeerPrincipal());
+    assertEquals(localPrincipal, c2.getLocalPrincipal());
+  }
+
+  @Test public void responseCachingAndRedirects() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
+        .addHeader("Location: /foo"));
+    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setBody("ABC"));
+    server.enqueue(new MockResponse().setBody("DEF"));
+
+    HttpURLConnection connection = client.open(server.getUrl("/"));
+    assertEquals("ABC", readAscii(connection));
+
+    connection = client.open(server.getUrl("/")); // cached!
+    assertEquals("ABC", readAscii(connection));
+
+    assertEquals(4, cache.getRequestCount()); // 2 requests + 2 redirects
+    assertEquals(2, cache.getNetworkCount());
+    assertEquals(2, cache.getHitCount());
+  }
+
+  @Test public void redirectToCachedResult() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60").setBody("ABC"));
+    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
+        .addHeader("Location: /foo"));
+    server.enqueue(new MockResponse().setBody("DEF"));
+
+    assertEquals("ABC", readAscii(client.open(server.getUrl("/foo"))));
+    RecordedRequest request1 = server.takeRequest();
+    assertEquals("GET /foo HTTP/1.1", request1.getRequestLine());
+    assertEquals(0, request1.getSequenceNumber());
+
+    assertEquals("ABC", readAscii(client.open(server.getUrl("/bar"))));
+    RecordedRequest request2 = server.takeRequest();
+    assertEquals("GET /bar HTTP/1.1", request2.getRequestLine());
+    assertEquals(1, request2.getSequenceNumber());
+
+    // an unrelated request should reuse the pooled connection
+    assertEquals("DEF", readAscii(client.open(server.getUrl("/baz"))));
+    RecordedRequest request3 = server.takeRequest();
+    assertEquals("GET /baz HTTP/1.1", request3.getRequestLine());
+    assertEquals(2, request3.getSequenceNumber());
+  }
+
+  @Test public void secureResponseCachingAndRedirects() throws IOException {
+    server.useHttps(sslContext.getSocketFactory(), false);
+    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
+        .addHeader("Location: /foo"));
+    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setBody("ABC"));
+    server.enqueue(new MockResponse().setBody("DEF"));
+
+    client.client().setSslSocketFactory(sslContext.getSocketFactory());
+    client.client().setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+
+    HttpsURLConnection connection1 = (HttpsURLConnection) client.open(server.getUrl("/"));
+    assertEquals("ABC", readAscii(connection1));
+    assertNotNull(connection1.getCipherSuite());
+
+    // Cached!
+    HttpsURLConnection connection2 = (HttpsURLConnection) client.open(server.getUrl("/"));
+    assertEquals("ABC", readAscii(connection2));
+    assertNotNull(connection2.getCipherSuite());
+
+    assertEquals(4, cache.getRequestCount()); // 2 direct + 2 redirect = 4
+    assertEquals(2, cache.getHitCount());
+    assertEquals(connection1.getCipherSuite(), connection2.getCipherSuite());
+  }
+
+  /**
+   * We've had bugs where caching and cross-protocol redirects yield class
+   * cast exceptions internal to the cache because we incorrectly assumed that
+   * HttpsURLConnection was always HTTPS and HttpURLConnection was always HTTP;
+   * in practice redirects mean that each can do either.
+   *
+   * https://github.com/square/okhttp/issues/214
+   */
+  @Test public void secureResponseCachingAndProtocolRedirects() throws IOException {
+    server2.useHttps(sslContext.getSocketFactory(), false);
+    server2.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setBody("ABC"));
+    server2.enqueue(new MockResponse().setBody("DEF"));
+
+    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
+        .addHeader("Location: " + server2.getUrl("/")));
+
+    client.client().setSslSocketFactory(sslContext.getSocketFactory());
+    client.client().setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+
+    HttpURLConnection connection1 = client.open(server.getUrl("/"));
+    assertEquals("ABC", readAscii(connection1));
+
+    // Cached!
+    HttpURLConnection connection2 = client.open(server.getUrl("/"));
+    assertEquals("ABC", readAscii(connection2));
+
+    assertEquals(4, cache.getRequestCount()); // 2 direct + 2 redirect = 4
+    assertEquals(2, cache.getHitCount());
+  }
+
+  @Test public void serverDisconnectsPrematurelyWithContentLengthHeader() throws IOException {
+    testServerPrematureDisconnect(TransferKind.FIXED_LENGTH);
+  }
+
+  @Test public void serverDisconnectsPrematurelyWithChunkedEncoding() throws IOException {
+    testServerPrematureDisconnect(TransferKind.CHUNKED);
+  }
+
+  @Test public void serverDisconnectsPrematurelyWithNoLengthHeaders() throws IOException {
+    // Intentionally empty. This case doesn't make sense because there's no
+    // such thing as a premature disconnect when the disconnect itself
+    // indicates the end of the data stream.
+  }
+
+  private void testServerPrematureDisconnect(TransferKind transferKind) throws IOException {
+    MockResponse response = new MockResponse();
+    transferKind.setBody(response, "ABCDE\nFGHIJKLMNOPQRSTUVWXYZ", 16);
+    server.enqueue(truncateViolently(response, 16));
+    server.enqueue(new MockResponse().setBody("Request #2"));
+
+    BufferedReader reader = new BufferedReader(
+        new InputStreamReader(client.open(server.getUrl("/")).getInputStream()));
+    assertEquals("ABCDE", reader.readLine());
+    try {
+      reader.readLine();
+      fail("This implementation silently ignored a truncated HTTP body.");
+    } catch (IOException expected) {
+    } finally {
+      reader.close();
+    }
+
+    assertEquals(1, cache.getWriteAbortCount());
+    assertEquals(0, cache.getWriteSuccessCount());
+    URLConnection connection = client.open(server.getUrl("/"));
+    assertEquals("Request #2", readAscii(connection));
+    assertEquals(1, cache.getWriteAbortCount());
+    assertEquals(1, cache.getWriteSuccessCount());
+  }
+
+  @Test public void clientPrematureDisconnectWithContentLengthHeader() throws IOException {
+    testClientPrematureDisconnect(TransferKind.FIXED_LENGTH);
+  }
+
+  @Test public void clientPrematureDisconnectWithChunkedEncoding() throws IOException {
+    testClientPrematureDisconnect(TransferKind.CHUNKED);
+  }
+
+  @Test public void clientPrematureDisconnectWithNoLengthHeaders() throws IOException {
+    testClientPrematureDisconnect(TransferKind.END_OF_STREAM);
+  }
+
+  private void testClientPrematureDisconnect(TransferKind transferKind) throws IOException {
+    // Setting a low transfer speed ensures that stream discarding will time out.
+    MockResponse response = new MockResponse().throttleBody(6, 1, TimeUnit.SECONDS);
+    transferKind.setBody(response, "ABCDE\nFGHIJKLMNOPQRSTUVWXYZ", 1024);
+    server.enqueue(response);
+    server.enqueue(new MockResponse().setBody("Request #2"));
+
+    URLConnection connection = client.open(server.getUrl("/"));
+    InputStream in = connection.getInputStream();
+    assertEquals("ABCDE", readAscii(connection, 5));
+    in.close();
+    try {
+      in.read();
+      fail("Expected an IOException because the stream is closed.");
+    } catch (IOException expected) {
+    }
+
+    assertEquals(1, cache.getWriteAbortCount());
+    assertEquals(0, cache.getWriteSuccessCount());
+    connection = client.open(server.getUrl("/"));
+    assertEquals("Request #2", readAscii(connection));
+    assertEquals(1, cache.getWriteAbortCount());
+    assertEquals(1, cache.getWriteSuccessCount());
+  }
+
+  @Test public void defaultExpirationDateFullyCachedForLessThan24Hours() throws Exception {
+    //      last modified: 105 seconds ago
+    //             served:   5 seconds ago
+    //   default lifetime: (105 - 5) / 10 = 10 seconds
+    //            expires:  10 seconds from served date = 5 seconds from now
+    server.enqueue(
+        new MockResponse().addHeader("Last-Modified: " + formatDate(-105, TimeUnit.SECONDS))
+            .addHeader("Date: " + formatDate(-5, TimeUnit.SECONDS))
+            .setBody("A"));
+
+    URL url = server.getUrl("/");
+    assertEquals("A", readAscii(client.open(url)));
+    URLConnection connection = client.open(url);
+    assertEquals("A", readAscii(connection));
+    assertNull(connection.getHeaderField("Warning"));
+  }
+
+  @Test public void defaultExpirationDateConditionallyCached() throws Exception {
+    //      last modified: 115 seconds ago
+    //             served:  15 seconds ago
+    //   default lifetime: (115 - 15) / 10 = 10 seconds
+    //            expires:  10 seconds from served date = 5 seconds ago
+    String lastModifiedDate = formatDate(-115, TimeUnit.SECONDS);
+    RecordedRequest conditionalRequest = assertConditionallyCached(
+        new MockResponse().addHeader("Last-Modified: " + lastModifiedDate)
+            .addHeader("Date: " + formatDate(-15, TimeUnit.SECONDS)));
+    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
+  }
+
+  @Test public void defaultExpirationDateFullyCachedForMoreThan24Hours() throws Exception {
+    //      last modified: 105 days ago
+    //             served:   5 days ago
+    //   default lifetime: (105 - 5) / 10 = 10 days
+    //            expires:  10 days from served date = 5 days from now
+    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-105, TimeUnit.DAYS))
+        .addHeader("Date: " + formatDate(-5, TimeUnit.DAYS))
+        .setBody("A"));
+
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+    URLConnection connection = client.open(server.getUrl("/"));
+    assertEquals("A", readAscii(connection));
+    assertEquals("113 HttpURLConnection \"Heuristic expiration\"",
+        connection.getHeaderField("Warning"));
+  }
+
+  @Test public void noDefaultExpirationForUrlsWithQueryString() throws Exception {
+    server.enqueue(
+        new MockResponse().addHeader("Last-Modified: " + formatDate(-105, TimeUnit.SECONDS))
+            .addHeader("Date: " + formatDate(-5, TimeUnit.SECONDS))
+            .setBody("A"));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    URL url = server.getUrl("/?foo=bar");
+    assertEquals("A", readAscii(client.open(url)));
+    assertEquals("B", readAscii(client.open(url)));
+  }
+
+  @Test public void expirationDateInThePastWithLastModifiedHeader() throws Exception {
+    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
+    RecordedRequest conditionalRequest = assertConditionallyCached(
+        new MockResponse().addHeader("Last-Modified: " + lastModifiedDate)
+            .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
+    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
+  }
+
+  @Test public void expirationDateInThePastWithNoLastModifiedHeader() throws Exception {
+    assertNotCached(new MockResponse().addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
+  }
+
+  @Test public void expirationDateInTheFuture() throws Exception {
+    assertFullyCached(new MockResponse().addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
+  }
+
+  @Test public void maxAgePreferredWithMaxAgeAndExpires() throws Exception {
+    assertFullyCached(new MockResponse().addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=60"));
+  }
+
+  @Test public void maxAgeInThePastWithDateAndLastModifiedHeaders() throws Exception {
+    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
+    RecordedRequest conditionalRequest = assertConditionallyCached(
+        new MockResponse().addHeader("Date: " + formatDate(-120, TimeUnit.SECONDS))
+            .addHeader("Last-Modified: " + lastModifiedDate)
+            .addHeader("Cache-Control: max-age=60"));
+    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
+  }
+
+  @Test public void maxAgeInThePastWithDateHeaderButNoLastModifiedHeader() throws Exception {
+    // Chrome interprets max-age relative to the local clock. Both our cache
+    // and Firefox both use the earlier of the local and server's clock.
+    assertNotCached(new MockResponse().addHeader("Date: " + formatDate(-120, TimeUnit.SECONDS))
+        .addHeader("Cache-Control: max-age=60"));
+  }
+
+  @Test public void maxAgeInTheFutureWithDateHeader() throws Exception {
+    assertFullyCached(new MockResponse().addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=60"));
+  }
+
+  @Test public void maxAgeInTheFutureWithNoDateHeader() throws Exception {
+    assertFullyCached(new MockResponse().addHeader("Cache-Control: max-age=60"));
+  }
+
+  @Test public void maxAgeWithLastModifiedButNoServedDate() throws Exception {
+    assertFullyCached(
+        new MockResponse().addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
+            .addHeader("Cache-Control: max-age=60"));
+  }
+
+  @Test public void maxAgeInTheFutureWithDateAndLastModifiedHeaders() throws Exception {
+    assertFullyCached(
+        new MockResponse().addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
+            .addHeader("Date: " + formatDate(0, TimeUnit.SECONDS))
+            .addHeader("Cache-Control: max-age=60"));
+  }
+
+  @Test public void maxAgePreferredOverLowerSharedMaxAge() throws Exception {
+    assertFullyCached(new MockResponse().addHeader("Date: " + formatDate(-2, TimeUnit.MINUTES))
+        .addHeader("Cache-Control: s-maxage=60")
+        .addHeader("Cache-Control: max-age=180"));
+  }
+
+  @Test public void maxAgePreferredOverHigherMaxAge() throws Exception {
+    assertNotCached(new MockResponse().addHeader("Date: " + formatDate(-2, TimeUnit.MINUTES))
+        .addHeader("Cache-Control: s-maxage=180")
+        .addHeader("Cache-Control: max-age=60"));
+  }
+
+  @Test public void requestMethodOptionsIsNotCached() throws Exception {
+    testRequestMethod("OPTIONS", false);
+  }
+
+  @Test public void requestMethodGetIsCached() throws Exception {
+    testRequestMethod("GET", true);
+  }
+
+  @Test public void requestMethodHeadIsNotCached() throws Exception {
+    // We could support this but choose not to for implementation simplicity
+    testRequestMethod("HEAD", false);
+  }
+
+  @Test public void requestMethodPostIsNotCached() throws Exception {
+    // We could support this but choose not to for implementation simplicity
+    testRequestMethod("POST", false);
+  }
+
+  @Test public void requestMethodPutIsNotCached() throws Exception {
+    testRequestMethod("PUT", false);
+  }
+
+  @Test public void requestMethodDeleteIsNotCached() throws Exception {
+    testRequestMethod("DELETE", false);
+  }
+
+  @Test public void requestMethodTraceIsNotCached() throws Exception {
+    testRequestMethod("TRACE", false);
+  }
+
+  private void testRequestMethod(String requestMethod, boolean expectCached) throws Exception {
+    // 1. seed the cache (potentially)
+    // 2. expect a cache hit or miss
+    server.enqueue(new MockResponse().addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .addHeader("X-Response-ID: 1"));
+    server.enqueue(new MockResponse().addHeader("X-Response-ID: 2"));
+
+    URL url = server.getUrl("/");
+
+    HttpURLConnection request1 = client.open(url);
+    request1.setRequestMethod(requestMethod);
+    addRequestBodyIfNecessary(requestMethod, request1);
+    request1.getInputStream().close();
+    assertEquals("1", request1.getHeaderField("X-Response-ID"));
+
+    URLConnection request2 = client.open(url);
+    request2.getInputStream().close();
+    if (expectCached) {
+      assertEquals("1", request2.getHeaderField("X-Response-ID"));
+    } else {
+      assertEquals("2", request2.getHeaderField("X-Response-ID"));
+    }
+  }
+
+  @Test public void postInvalidatesCache() throws Exception {
+    testMethodInvalidates("POST");
+  }
+
+  @Test public void putInvalidatesCache() throws Exception {
+    testMethodInvalidates("PUT");
+  }
+
+  @Test public void deleteMethodInvalidatesCache() throws Exception {
+    testMethodInvalidates("DELETE");
+  }
+
+  private void testMethodInvalidates(String requestMethod) throws Exception {
+    // 1. seed the cache
+    // 2. invalidate it
+    // 3. expect a cache miss
+    server.enqueue(
+        new MockResponse().setBody("A").addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
+    server.enqueue(new MockResponse().setBody("B"));
+    server.enqueue(new MockResponse().setBody("C"));
+
+    URL url = server.getUrl("/");
+
+    assertEquals("A", readAscii(client.open(url)));
+
+    HttpURLConnection invalidate = client.open(url);
+    invalidate.setRequestMethod(requestMethod);
+    addRequestBodyIfNecessary(requestMethod, invalidate);
+    assertEquals("B", readAscii(invalidate));
+
+    assertEquals("C", readAscii(client.open(url)));
+  }
+
+  @Test public void postInvalidatesCacheWithUncacheableResponse() throws Exception {
+    // 1. seed the cache
+    // 2. invalidate it with uncacheable response
+    // 3. expect a cache miss
+    server.enqueue(
+        new MockResponse().setBody("A").addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
+    server.enqueue(new MockResponse().setBody("B").setResponseCode(500));
+    server.enqueue(new MockResponse().setBody("C"));
+
+    URL url = server.getUrl("/");
+
+    assertEquals("A", readAscii(client.open(url)));
+
+    HttpURLConnection invalidate = client.open(url);
+    invalidate.setRequestMethod("POST");
+    addRequestBodyIfNecessary("POST", invalidate);
+    assertEquals("B", readAscii(invalidate));
+
+    assertEquals("C", readAscii(client.open(url)));
+  }
+
+  @Test public void etag() throws Exception {
+    RecordedRequest conditionalRequest =
+        assertConditionallyCached(new MockResponse().addHeader("ETag: v1"));
+    assertEquals("v1", conditionalRequest.getHeader("If-None-Match"));
+  }
+
+  @Test public void etagAndExpirationDateInThePast() throws Exception {
+    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
+    RecordedRequest conditionalRequest = assertConditionallyCached(
+        new MockResponse().addHeader("ETag: v1")
+            .addHeader("Last-Modified: " + lastModifiedDate)
+            .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
+    assertEquals("v1", conditionalRequest.getHeader("If-None-Match"));
+    assertNull(conditionalRequest.getHeader("If-Modified-Since"));
+  }
+
+  @Test public void etagAndExpirationDateInTheFuture() throws Exception {
+    assertFullyCached(new MockResponse().addHeader("ETag: v1")
+        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
+  }
+
+  @Test public void cacheControlNoCache() throws Exception {
+    assertNotCached(new MockResponse().addHeader("Cache-Control: no-cache"));
+  }
+
+  @Test public void cacheControlNoCacheAndExpirationDateInTheFuture() throws Exception {
+    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
+    RecordedRequest conditionalRequest = assertConditionallyCached(
+        new MockResponse().addHeader("Last-Modified: " + lastModifiedDate)
+            .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+            .addHeader("Cache-Control: no-cache"));
+    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
+  }
+
+  @Test public void pragmaNoCache() throws Exception {
+    assertNotCached(new MockResponse().addHeader("Pragma: no-cache"));
+  }
+
+  @Test public void pragmaNoCacheAndExpirationDateInTheFuture() throws Exception {
+    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
+    RecordedRequest conditionalRequest = assertConditionallyCached(
+        new MockResponse().addHeader("Last-Modified: " + lastModifiedDate)
+            .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+            .addHeader("Pragma: no-cache"));
+    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
+  }
+
+  @Test public void cacheControlNoStore() throws Exception {
+    assertNotCached(new MockResponse().addHeader("Cache-Control: no-store"));
+  }
+
+  @Test public void cacheControlNoStoreAndExpirationDateInTheFuture() throws Exception {
+    assertNotCached(new MockResponse().addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: no-store"));
+  }
+
+  @Test public void partialRangeResponsesDoNotCorruptCache() throws Exception {
+    // 1. request a range
+    // 2. request a full document, expecting a cache miss
+    server.enqueue(new MockResponse().setBody("AA")
+        .setResponseCode(HttpURLConnection.HTTP_PARTIAL)
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .addHeader("Content-Range: bytes 1000-1001/2000"));
+    server.enqueue(new MockResponse().setBody("BB"));
+
+    URL url = server.getUrl("/");
+
+    URLConnection range = client.open(url);
+    range.addRequestProperty("Range", "bytes=1000-1001");
+    assertEquals("AA", readAscii(range));
+
+    assertEquals("BB", readAscii(client.open(url)));
+  }
+
+  @Test public void serverReturnsDocumentOlderThanCache() throws Exception {
+    server.enqueue(new MockResponse().setBody("A")
+        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
+    server.enqueue(new MockResponse().setBody("B")
+        .addHeader("Last-Modified: " + formatDate(-4, TimeUnit.HOURS)));
+
+    URL url = server.getUrl("/");
+
+    assertEquals("A", readAscii(client.open(url)));
+    assertEquals("A", readAscii(client.open(url)));
+  }
+
+  @Test public void nonIdentityEncodingAndConditionalCache() throws Exception {
+    assertNonIdentityEncodingCached(
+        new MockResponse().addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
+            .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
+  }
+
+  @Test public void nonIdentityEncodingAndFullCache() throws Exception {
+    assertNonIdentityEncodingCached(
+        new MockResponse().addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
+            .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
+  }
+
+  private void assertNonIdentityEncodingCached(MockResponse response) throws Exception {
+    server.enqueue(
+        response.setBody(gzip("ABCABCABC")).addHeader("Content-Encoding: gzip"));
+    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    // At least three request/response pairs are required because after the first request is cached
+    // a different execution path might be taken. Thus modifications to the cache applied during
+    // the second request might not be visible until another request is performed.
+    assertEquals("ABCABCABC", readAscii(client.open(server.getUrl("/"))));
+    assertEquals("ABCABCABC", readAscii(client.open(server.getUrl("/"))));
+    assertEquals("ABCABCABC", readAscii(client.open(server.getUrl("/"))));
+  }
+
+  @Test public void notModifiedSpecifiesEncoding() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody(gzip("ABCABCABC"))
+        .addHeader("Content-Encoding: gzip")
+        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED)
+        .addHeader("Content-Encoding: gzip"));
+    server.enqueue(new MockResponse()
+        .setBody("DEFDEFDEF"));
+
+    assertEquals("ABCABCABC", readAscii(client.open(server.getUrl("/"))));
+    assertEquals("ABCABCABC", readAscii(client.open(server.getUrl("/"))));
+    assertEquals("DEFDEFDEF", readAscii(client.open(server.getUrl("/"))));
+  }
+
+  /** https://github.com/square/okhttp/issues/947 */
+  @Test public void gzipAndVaryOnAcceptEncoding() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody(gzip("ABCABCABC"))
+        .addHeader("Content-Encoding: gzip")
+        .addHeader("Vary: Accept-Encoding")
+        .addHeader("Cache-Control: max-age=60"));
+    server.enqueue(new MockResponse().setBody("FAIL"));
+
+    assertEquals("ABCABCABC", readAscii(client.open(server.getUrl("/"))));
+    assertEquals("ABCABCABC", readAscii(client.open(server.getUrl("/"))));
+  }
+
+  @Test public void conditionalCacheHitIsNotDoublePooled() throws Exception {
+    server.enqueue(new MockResponse().addHeader("ETag: v1").setBody("A"));
+    server.enqueue(new MockResponse()
+        .clearHeaders()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    ConnectionPool pool = ConnectionPool.getDefault();
+    pool.evictAll();
+    client.client().setConnectionPool(pool);
+
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+    assertEquals(1, client.client().getConnectionPool().getConnectionCount());
+  }
+
+  @Test public void expiresDateBeforeModifiedDate() throws Exception {
+    assertConditionallyCached(
+        new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+            .addHeader("Expires: " + formatDate(-2, TimeUnit.HOURS)));
+  }
+
+  @Test public void requestMaxAge() throws IOException {
+    server.enqueue(new MockResponse().setBody("A")
+        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
+        .addHeader("Date: " + formatDate(-1, TimeUnit.MINUTES))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+
+    URLConnection connection = client.open(server.getUrl("/"));
+    connection.addRequestProperty("Cache-Control", "max-age=30");
+    assertEquals("B", readAscii(connection));
+  }
+
+  @Test public void requestMinFresh() throws IOException {
+    server.enqueue(new MockResponse().setBody("A")
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+
+    URLConnection connection = client.open(server.getUrl("/"));
+    connection.addRequestProperty("Cache-Control", "min-fresh=120");
+    assertEquals("B", readAscii(connection));
+  }
+
+  @Test public void requestMaxStale() throws IOException {
+    server.enqueue(new MockResponse().setBody("A")
+        .addHeader("Cache-Control: max-age=120")
+        .addHeader("Date: " + formatDate(-4, TimeUnit.MINUTES)));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+
+    URLConnection connection = client.open(server.getUrl("/"));
+    connection.addRequestProperty("Cache-Control", "max-stale=180");
+    assertEquals("A", readAscii(connection));
+    assertEquals("110 HttpURLConnection \"Response is stale\"",
+        connection.getHeaderField("Warning"));
+  }
+
+  @Test public void requestMaxStaleNotHonoredWithMustRevalidate() throws IOException {
+    server.enqueue(new MockResponse().setBody("A")
+        .addHeader("Cache-Control: max-age=120, must-revalidate")
+        .addHeader("Date: " + formatDate(-4, TimeUnit.MINUTES)));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+
+    URLConnection connection = client.open(server.getUrl("/"));
+    connection.addRequestProperty("Cache-Control", "max-stale=180");
+    assertEquals("B", readAscii(connection));
+  }
+
+  @Test public void requestOnlyIfCachedWithNoResponseCached() throws IOException {
+    // (no responses enqueued)
+
+    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection.addRequestProperty("Cache-Control", "only-if-cached");
+    assertGatewayTimeout(connection);
+    assertEquals(1, cache.getRequestCount());
+    assertEquals(0, cache.getNetworkCount());
+    assertEquals(0, cache.getHitCount());
+  }
+
+  @Test public void requestOnlyIfCachedWithFullResponseCached() throws IOException {
+    server.enqueue(new MockResponse().setBody("A")
+        .addHeader("Cache-Control: max-age=30")
+        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
+
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+    URLConnection connection = client.open(server.getUrl("/"));
+    connection.addRequestProperty("Cache-Control", "only-if-cached");
+    assertEquals("A", readAscii(connection));
+    assertEquals(2, cache.getRequestCount());
+    assertEquals(1, cache.getNetworkCount());
+    assertEquals(1, cache.getHitCount());
+  }
+
+  @Test public void requestOnlyIfCachedWithConditionalResponseCached() throws IOException {
+    server.enqueue(new MockResponse().setBody("A")
+        .addHeader("Cache-Control: max-age=30")
+        .addHeader("Date: " + formatDate(-1, TimeUnit.MINUTES)));
+
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection.addRequestProperty("Cache-Control", "only-if-cached");
+    assertGatewayTimeout(connection);
+    assertEquals(2, cache.getRequestCount());
+    assertEquals(1, cache.getNetworkCount());
+    assertEquals(0, cache.getHitCount());
+  }
+
+  @Test public void requestOnlyIfCachedWithUnhelpfulResponseCached() throws IOException {
+    server.enqueue(new MockResponse().setBody("A"));
+
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection.addRequestProperty("Cache-Control", "only-if-cached");
+    assertGatewayTimeout(connection);
+    assertEquals(2, cache.getRequestCount());
+    assertEquals(1, cache.getNetworkCount());
+    assertEquals(0, cache.getHitCount());
+  }
+
+  @Test public void requestCacheControlNoCache() throws Exception {
+    server.enqueue(
+        new MockResponse().addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
+            .addHeader("Date: " + formatDate(0, TimeUnit.SECONDS))
+            .addHeader("Cache-Control: max-age=60")
+            .setBody("A"));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    URL url = server.getUrl("/");
+    assertEquals("A", readAscii(client.open(url)));
+    URLConnection connection = client.open(url);
+    connection.setRequestProperty("Cache-Control", "no-cache");
+    assertEquals("B", readAscii(connection));
+  }
+
+  @Test public void requestPragmaNoCache() throws Exception {
+    server.enqueue(
+        new MockResponse().addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
+            .addHeader("Date: " + formatDate(0, TimeUnit.SECONDS))
+            .addHeader("Cache-Control: max-age=60")
+            .setBody("A"));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    URL url = server.getUrl("/");
+    assertEquals("A", readAscii(client.open(url)));
+    URLConnection connection = client.open(url);
+    connection.setRequestProperty("Pragma", "no-cache");
+    assertEquals("B", readAscii(connection));
+  }
+
+  @Test public void clientSuppliedIfModifiedSinceWithCachedResult() throws Exception {
+    MockResponse response =
+        new MockResponse().addHeader("ETag: v3").addHeader("Cache-Control: max-age=0");
+    String ifModifiedSinceDate = formatDate(-24, TimeUnit.HOURS);
+    RecordedRequest request =
+        assertClientSuppliedCondition(response, "If-Modified-Since", ifModifiedSinceDate);
+    assertEquals(ifModifiedSinceDate, request.getHeader("If-Modified-Since"));
+    assertNull(request.getHeader("If-None-Match"));
+  }
+
+  @Test public void clientSuppliedIfNoneMatchSinceWithCachedResult() throws Exception {
+    String lastModifiedDate = formatDate(-3, TimeUnit.MINUTES);
+    MockResponse response = new MockResponse().addHeader("Last-Modified: " + lastModifiedDate)
+        .addHeader("Date: " + formatDate(-2, TimeUnit.MINUTES))
+        .addHeader("Cache-Control: max-age=0");
+    RecordedRequest request = assertClientSuppliedCondition(response, "If-None-Match", "v1");
+    assertEquals("v1", request.getHeader("If-None-Match"));
+    assertNull(request.getHeader("If-Modified-Since"));
+  }
+
+  private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String conditionName,
+      String conditionValue) throws Exception {
+    server.enqueue(seed.setBody("A"));
+    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    URL url = server.getUrl("/");
+    assertEquals("A", readAscii(client.open(url)));
+
+    HttpURLConnection connection = client.open(url);
+    connection.addRequestProperty(conditionName, conditionValue);
+    assertEquals(HttpURLConnection.HTTP_NOT_MODIFIED, connection.getResponseCode());
+    assertEquals("", readAscii(connection));
+
+    server.takeRequest(); // seed
+    return server.takeRequest();
+  }
+
+  /**
+   * Confirm that {@link URLConnection#setIfModifiedSince} causes an
+   * If-Modified-Since header with a GMT timestamp.
+   *
+   * https://code.google.com/p/android/issues/detail?id=66135
+   */
+  @Test public void setIfModifiedSince() throws Exception {
+    server.enqueue(new MockResponse().setBody("A"));
+
+    URL url = server.getUrl("/");
+    URLConnection connection = client.open(url);
+    connection.setIfModifiedSince(1393666200000L);
+    assertEquals("A", readAscii(connection));
+    RecordedRequest request = server.takeRequest();
+    String ifModifiedSinceHeader = request.getHeader("If-Modified-Since");
+    assertEquals("Sat, 01 Mar 2014 09:30:00 GMT", ifModifiedSinceHeader);
+  }
+
+  /**
+   * For Last-Modified and Date headers, we should echo the date back in the
+   * exact format we were served.
+   */
+  @Test public void retainServedDateFormat() throws Exception {
+    // Serve a response with a non-standard date format that OkHttp supports.
+    Date lastModifiedDate = new Date(System.currentTimeMillis() + TimeUnit.HOURS.toMillis(-1));
+    Date servedDate = new Date(System.currentTimeMillis() + TimeUnit.HOURS.toMillis(-2));
+    DateFormat dateFormat = new SimpleDateFormat("EEE dd-MMM-yyyy HH:mm:ss z", Locale.US);
+    dateFormat.setTimeZone(TimeZone.getTimeZone("EDT"));
+    String lastModifiedString = dateFormat.format(lastModifiedDate);
+    String servedString = dateFormat.format(servedDate);
+
+    // This response should be conditionally cached.
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + lastModifiedString)
+        .addHeader("Expires: " + servedString)
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+
+    // The first request has no conditions.
+    RecordedRequest request1 = server.takeRequest();
+    assertNull(request1.getHeader("If-Modified-Since"));
+
+    // The 2nd request uses the server's date format.
+    RecordedRequest request2 = server.takeRequest();
+    assertEquals(lastModifiedString, request2.getHeader("If-Modified-Since"));
+  }
+
+  @Test public void clientSuppliedConditionWithoutCachedResult() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    HttpURLConnection connection = client.open(server.getUrl("/"));
+    String clientIfModifiedSince = formatDate(-24, TimeUnit.HOURS);
+    connection.addRequestProperty("If-Modified-Since", clientIfModifiedSince);
+    assertEquals(HttpURLConnection.HTTP_NOT_MODIFIED, connection.getResponseCode());
+    assertEquals("", readAscii(connection));
+  }
+
+  @Test public void authorizationRequestFullyCached() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60").setBody("A"));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    URL url = server.getUrl("/");
+    URLConnection connection = client.open(url);
+    connection.addRequestProperty("Authorization", "password");
+    assertEquals("A", readAscii(connection));
+    assertEquals("A", readAscii(client.open(url)));
+  }
+
+  @Test public void contentLocationDoesNotPopulateCache() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
+        .addHeader("Content-Location: /bar")
+        .setBody("A"));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    assertEquals("A", readAscii(client.open(server.getUrl("/foo"))));
+    assertEquals("B", readAscii(client.open(server.getUrl("/bar"))));
+  }
+
+  @Test public void useCachesFalseDoesNotWriteToCache() throws Exception {
+    server.enqueue(
+        new MockResponse().addHeader("Cache-Control: max-age=60").setBody("A").setBody("A"));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    URLConnection connection = client.open(server.getUrl("/"));
+    connection.setUseCaches(false);
+    assertEquals("A", readAscii(connection));
+    assertEquals("B", readAscii(client.open(server.getUrl("/"))));
+  }
+
+  @Test public void useCachesFalseDoesNotReadFromCache() throws Exception {
+    server.enqueue(
+        new MockResponse().addHeader("Cache-Control: max-age=60").setBody("A").setBody("A"));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+    URLConnection connection = client.open(server.getUrl("/"));
+    connection.setUseCaches(false);
+    assertEquals("B", readAscii(connection));
+  }
+
+  @Test public void defaultUseCachesSetsInitialValueOnly() throws Exception {
+    URL url = new URL("http://localhost/");
+    URLConnection c1 = client.open(url);
+    URLConnection c2 = client.open(url);
+    assertTrue(c1.getDefaultUseCaches());
+    c1.setDefaultUseCaches(false);
+    try {
+      assertTrue(c1.getUseCaches());
+      assertTrue(c2.getUseCaches());
+      URLConnection c3 = client.open(url);
+      assertFalse(c3.getUseCaches());
+    } finally {
+      c1.setDefaultUseCaches(true);
+    }
+  }
+
+  @Test public void connectionIsReturnedToPoolAfterConditionalSuccess() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("A"));
+    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    assertEquals("A", readAscii(client.open(server.getUrl("/a"))));
+    assertEquals("A", readAscii(client.open(server.getUrl("/a"))));
+    assertEquals("B", readAscii(client.open(server.getUrl("/b"))));
+
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+    assertEquals(2, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void statisticsConditionalCacheMiss() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("A"));
+    server.enqueue(new MockResponse().setBody("B"));
+    server.enqueue(new MockResponse().setBody("C"));
+
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+    assertEquals(1, cache.getRequestCount());
+    assertEquals(1, cache.getNetworkCount());
+    assertEquals(0, cache.getHitCount());
+    assertEquals("B", readAscii(client.open(server.getUrl("/"))));
+    assertEquals("C", readAscii(client.open(server.getUrl("/"))));
+    assertEquals(3, cache.getRequestCount());
+    assertEquals(3, cache.getNetworkCount());
+    assertEquals(0, cache.getHitCount());
+  }
+
+  @Test public void statisticsConditionalCacheHit() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("A"));
+    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+    assertEquals(1, cache.getRequestCount());
+    assertEquals(1, cache.getNetworkCount());
+    assertEquals(0, cache.getHitCount());
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+    assertEquals(3, cache.getRequestCount());
+    assertEquals(3, cache.getNetworkCount());
+    assertEquals(2, cache.getHitCount());
+  }
+
+  @Test public void statisticsFullCacheHit() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60").setBody("A"));
+
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+    assertEquals(1, cache.getRequestCount());
+    assertEquals(1, cache.getNetworkCount());
+    assertEquals(0, cache.getHitCount());
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+    assertEquals(3, cache.getRequestCount());
+    assertEquals(1, cache.getNetworkCount());
+    assertEquals(2, cache.getHitCount());
+  }
+
+  @Test public void varyMatchesChangedRequestHeaderField() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Accept-Language")
+        .setBody("A"));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    URL url = server.getUrl("/");
+    HttpURLConnection frConnection = client.open(url);
+    frConnection.addRequestProperty("Accept-Language", "fr-CA");
+    assertEquals("A", readAscii(frConnection));
+
+    HttpURLConnection enConnection = client.open(url);
+    enConnection.addRequestProperty("Accept-Language", "en-US");
+    assertEquals("B", readAscii(enConnection));
+  }
+
+  @Test public void varyMatchesUnchangedRequestHeaderField() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Accept-Language")
+        .setBody("A"));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    URL url = server.getUrl("/");
+    URLConnection connection1 = client.open(url);
+    connection1.addRequestProperty("Accept-Language", "fr-CA");
+    assertEquals("A", readAscii(connection1));
+    URLConnection connection2 = client.open(url);
+    connection2.addRequestProperty("Accept-Language", "fr-CA");
+    assertEquals("A", readAscii(connection2));
+  }
+
+  @Test public void varyMatchesAbsentRequestHeaderField() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Foo")
+        .setBody("A"));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+  }
+
+  @Test public void varyMatchesAddedRequestHeaderField() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Foo")
+        .setBody("A"));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+    URLConnection fooConnection = client.open(server.getUrl("/"));
+    fooConnection.addRequestProperty("Foo", "bar");
+    assertEquals("B", readAscii(fooConnection));
+  }
+
+  @Test public void varyMatchesRemovedRequestHeaderField() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Foo")
+        .setBody("A"));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    URLConnection fooConnection = client.open(server.getUrl("/"));
+    fooConnection.addRequestProperty("Foo", "bar");
+    assertEquals("A", readAscii(fooConnection));
+    assertEquals("B", readAscii(client.open(server.getUrl("/"))));
+  }
+
+  @Test public void varyFieldsAreCaseInsensitive() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: ACCEPT-LANGUAGE")
+        .setBody("A"));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    URL url = server.getUrl("/");
+    URLConnection connection1 = client.open(url);
+    connection1.addRequestProperty("Accept-Language", "fr-CA");
+    assertEquals("A", readAscii(connection1));
+    URLConnection connection2 = client.open(url);
+    connection2.addRequestProperty("accept-language", "fr-CA");
+    assertEquals("A", readAscii(connection2));
+  }
+
+  @Test public void varyMultipleFieldsWithMatch() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Accept-Language, Accept-Charset")
+        .addHeader("Vary: Accept-Encoding")
+        .setBody("A"));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    URL url = server.getUrl("/");
+    URLConnection connection1 = client.open(url);
+    connection1.addRequestProperty("Accept-Language", "fr-CA");
+    connection1.addRequestProperty("Accept-Charset", "UTF-8");
+    connection1.addRequestProperty("Accept-Encoding", "identity");
+    assertEquals("A", readAscii(connection1));
+    URLConnection connection2 = client.open(url);
+    connection2.addRequestProperty("Accept-Language", "fr-CA");
+    connection2.addRequestProperty("Accept-Charset", "UTF-8");
+    connection2.addRequestProperty("Accept-Encoding", "identity");
+    assertEquals("A", readAscii(connection2));
+  }
+
+  @Test public void varyMultipleFieldsWithNoMatch() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Accept-Language, Accept-Charset")
+        .addHeader("Vary: Accept-Encoding")
+        .setBody("A"));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    URL url = server.getUrl("/");
+    URLConnection frConnection = client.open(url);
+    frConnection.addRequestProperty("Accept-Language", "fr-CA");
+    frConnection.addRequestProperty("Accept-Charset", "UTF-8");
+    frConnection.addRequestProperty("Accept-Encoding", "identity");
+    assertEquals("A", readAscii(frConnection));
+    URLConnection enConnection = client.open(url);
+    enConnection.addRequestProperty("Accept-Language", "en-CA");
+    enConnection.addRequestProperty("Accept-Charset", "UTF-8");
+    enConnection.addRequestProperty("Accept-Encoding", "identity");
+    assertEquals("B", readAscii(enConnection));
+  }
+
+  @Test public void varyMultipleFieldValuesWithMatch() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Accept-Language")
+        .setBody("A"));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    URL url = server.getUrl("/");
+    URLConnection connection1 = client.open(url);
+    connection1.addRequestProperty("Accept-Language", "fr-CA, fr-FR");
+    connection1.addRequestProperty("Accept-Language", "en-US");
+    assertEquals("A", readAscii(connection1));
+
+    URLConnection connection2 = client.open(url);
+    connection2.addRequestProperty("Accept-Language", "fr-CA, fr-FR");
+    connection2.addRequestProperty("Accept-Language", "en-US");
+    assertEquals("A", readAscii(connection2));
+  }
+
+  @Test public void varyMultipleFieldValuesWithNoMatch() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Accept-Language")
+        .setBody("A"));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    URL url = server.getUrl("/");
+    URLConnection connection1 = client.open(url);
+    connection1.addRequestProperty("Accept-Language", "fr-CA, fr-FR");
+    connection1.addRequestProperty("Accept-Language", "en-US");
+    assertEquals("A", readAscii(connection1));
+
+    URLConnection connection2 = client.open(url);
+    connection2.addRequestProperty("Accept-Language", "fr-CA");
+    connection2.addRequestProperty("Accept-Language", "en-US");
+    assertEquals("B", readAscii(connection2));
+  }
+
+  @Test public void varyAsterisk() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: *")
+        .setBody("A"));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+    assertEquals("B", readAscii(client.open(server.getUrl("/"))));
+  }
+
+  @Test public void varyAndHttps() throws Exception {
+    server.useHttps(sslContext.getSocketFactory(), false);
+    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Accept-Language")
+        .setBody("A"));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    URL url = server.getUrl("/");
+    HttpsURLConnection connection1 = (HttpsURLConnection) client.open(url);
+    connection1.setSSLSocketFactory(sslContext.getSocketFactory());
+    connection1.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+    connection1.addRequestProperty("Accept-Language", "en-US");
+    assertEquals("A", readAscii(connection1));
+
+    HttpsURLConnection connection2 = (HttpsURLConnection) client.open(url);
+    connection2.setSSLSocketFactory(sslContext.getSocketFactory());
+    connection2.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+    connection2.addRequestProperty("Accept-Language", "en-US");
+    assertEquals("A", readAscii(connection2));
+  }
+
+  @Test public void cachePlusCookies() throws Exception {
+    server.enqueue(new MockResponse().addHeader(
+        "Set-Cookie: a=FIRST; domain=" + server.getCookieDomain() + ";")
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("A"));
+    server.enqueue(new MockResponse().addHeader(
+        "Set-Cookie: a=SECOND; domain=" + server.getCookieDomain() + ";")
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    URL url = server.getUrl("/");
+    assertEquals("A", readAscii(client.open(url)));
+    assertCookies(url, "a=FIRST");
+    assertEquals("A", readAscii(client.open(url)));
+    assertCookies(url, "a=SECOND");
+  }
+
+  @Test public void getHeadersReturnsNetworkEndToEndHeaders() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Allow: GET, HEAD")
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("A"));
+    server.enqueue(new MockResponse().addHeader("Allow: GET, HEAD, PUT")
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    URLConnection connection1 = client.open(server.getUrl("/"));
+    assertEquals("A", readAscii(connection1));
+    assertEquals("GET, HEAD", connection1.getHeaderField("Allow"));
+
+    URLConnection connection2 = client.open(server.getUrl("/"));
+    assertEquals("A", readAscii(connection2));
+    assertEquals("GET, HEAD, PUT", connection2.getHeaderField("Allow"));
+  }
+
+  @Test public void getHeadersReturnsCachedHopByHopHeaders() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Transfer-Encoding: identity")
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("A"));
+    server.enqueue(new MockResponse().addHeader("Transfer-Encoding: none")
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    URLConnection connection1 = client.open(server.getUrl("/"));
+    assertEquals("A", readAscii(connection1));
+    assertEquals("identity", connection1.getHeaderField("Transfer-Encoding"));
+
+    URLConnection connection2 = client.open(server.getUrl("/"));
+    assertEquals("A", readAscii(connection2));
+    assertEquals("identity", connection2.getHeaderField("Transfer-Encoding"));
+  }
+
+  @Test public void getHeadersDeletesCached100LevelWarnings() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Warning: 199 test danger")
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("A"));
+    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    URLConnection connection1 = client.open(server.getUrl("/"));
+    assertEquals("A", readAscii(connection1));
+    assertEquals("199 test danger", connection1.getHeaderField("Warning"));
+
+    URLConnection connection2 = client.open(server.getUrl("/"));
+    assertEquals("A", readAscii(connection2));
+    assertEquals(null, connection2.getHeaderField("Warning"));
+  }
+
+  @Test public void getHeadersRetainsCached200LevelWarnings() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Warning: 299 test danger")
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("A"));
+    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    URLConnection connection1 = client.open(server.getUrl("/"));
+    assertEquals("A", readAscii(connection1));
+    assertEquals("299 test danger", connection1.getHeaderField("Warning"));
+
+    URLConnection connection2 = client.open(server.getUrl("/"));
+    assertEquals("A", readAscii(connection2));
+    assertEquals("299 test danger", connection2.getHeaderField("Warning"));
+  }
+
+  public void assertCookies(URL url, String... expectedCookies) throws Exception {
+    List<String> actualCookies = new ArrayList<>();
+    for (HttpCookie cookie : cookieManager.getCookieStore().get(url.toURI())) {
+      actualCookies.add(cookie.toString());
+    }
+    assertEquals(Arrays.asList(expectedCookies), actualCookies);
+  }
+
+  @Test public void cachePlusRange() throws Exception {
+    assertNotCached(new MockResponse().setResponseCode(HttpURLConnection.HTTP_PARTIAL)
+            .addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
+            .addHeader("Content-Range: bytes 100-100/200")
+            .addHeader("Cache-Control: max-age=60"));
+  }
+
+  @Test public void conditionalHitUpdatesCache() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(0, TimeUnit.SECONDS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("A"));
+    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=30")
+        .addHeader("Allow: GET, HEAD")
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    // cache miss; seed the cache
+    HttpURLConnection connection1 = client.open(server.getUrl("/a"));
+    assertEquals("A", readAscii(connection1));
+    assertEquals(null, connection1.getHeaderField("Allow"));
+
+    // conditional cache hit; update the cache
+    HttpURLConnection connection2 = client.open(server.getUrl("/a"));
+    assertEquals(HttpURLConnection.HTTP_OK, connection2.getResponseCode());
+    assertEquals("A", readAscii(connection2));
+    assertEquals("GET, HEAD", connection2.getHeaderField("Allow"));
+
+    // full cache hit
+    HttpURLConnection connection3 = client.open(server.getUrl("/a"));
+    assertEquals("A", readAscii(connection3));
+    assertEquals("GET, HEAD", connection3.getHeaderField("Allow"));
+
+    assertEquals(2, server.getRequestCount());
+  }
+
+  @Test public void responseSourceHeaderCached() throws IOException {
+    server.enqueue(new MockResponse().setBody("A")
+        .addHeader("Cache-Control: max-age=30")
+        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
+
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+    URLConnection connection = client.open(server.getUrl("/"));
+    connection.addRequestProperty("Cache-Control", "only-if-cached");
+    assertEquals("A", readAscii(connection));
+  }
+
+  @Test public void responseSourceHeaderConditionalCacheFetched() throws IOException {
+    server.enqueue(new MockResponse().setBody("A")
+        .addHeader("Cache-Control: max-age=30")
+        .addHeader("Date: " + formatDate(-31, TimeUnit.MINUTES)));
+    server.enqueue(new MockResponse().setBody("B")
+        .addHeader("Cache-Control: max-age=30")
+        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
+
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+    HttpURLConnection connection = client.open(server.getUrl("/"));
+    assertEquals("B", readAscii(connection));
+  }
+
+  @Test public void responseSourceHeaderConditionalCacheNotFetched() throws IOException {
+    server.enqueue(new MockResponse().setBody("A")
+        .addHeader("Cache-Control: max-age=0")
+        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
+    server.enqueue(new MockResponse().setResponseCode(304));
+
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+    HttpURLConnection connection = client.open(server.getUrl("/"));
+    assertEquals("A", readAscii(connection));
+  }
+
+  @Test public void responseSourceHeaderFetched() throws IOException {
+    server.enqueue(new MockResponse().setBody("A"));
+
+    URLConnection connection = client.open(server.getUrl("/"));
+    assertEquals("A", readAscii(connection));
+  }
+
+  @Test public void emptyResponseHeaderNameFromCacheIsLenient() throws Exception {
+    Headers.Builder headers = new Headers.Builder()
+        .add("Cache-Control: max-age=120");
+    Internal.instance.addLenient(headers, ": A");
+    server.enqueue(new MockResponse().setHeaders(headers.build()).setBody("body"));
+
+    HttpURLConnection connection = client.open(server.getUrl("/"));
+    assertEquals("A", connection.getHeaderField(""));
+  }
+
+  /**
+   * Old implementations of OkHttp's response cache wrote header fields like
+   * ":status: 200 OK". This broke our cached response parser because it split
+   * on the first colon. This regression test exists to help us read these old
+   * bad cache entries.
+   *
+   * https://github.com/square/okhttp/issues/227
+   */
+  @Test public void testGoldenCacheResponse() throws Exception {
+    cache.close();
+    server.enqueue(new MockResponse()
+        .clearHeaders()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    URL url = server.getUrl("/");
+    String urlKey = Util.md5Hex(url.toString());
+    String entryMetadata = ""
+        + "" + url + "\n"
+        + "GET\n"
+        + "0\n"
+        + "HTTP/1.1 200 OK\n"
+        + "7\n"
+        + ":status: 200 OK\n"
+        + ":version: HTTP/1.1\n"
+        + "etag: foo\n"
+        + "content-length: 3\n"
+        + "OkHttp-Received-Millis: " + System.currentTimeMillis() + "\n"
+        + "X-Android-Response-Source: NETWORK 200\n"
+        + "OkHttp-Sent-Millis: " + System.currentTimeMillis() + "\n"
+        + "\n"
+        + "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA\n"
+        + "1\n"
+        + "MIIBpDCCAQ2gAwIBAgIBATANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDEw1qd2lsc29uLmxvY2FsMB4XDTEzMDgy"
+        + "OTA1MDE1OVoXDTEzMDgzMDA1MDE1OVowGDEWMBQGA1UEAxMNandpbHNvbi5sb2NhbDCBnzANBgkqhkiG9w0BAQEF"
+        + "AAOBjQAwgYkCgYEAlFW+rGo/YikCcRghOyKkJanmVmJSce/p2/jH1QvNIFKizZdh8AKNwojt3ywRWaDULA/RlCUc"
+        + "ltF3HGNsCyjQI/+Lf40x7JpxXF8oim1E6EtDoYtGWAseelawus3IQ13nmo6nWzfyCA55KhAWf4VipelEy8DjcuFK"
+        + "v6L0xwXnI0ECAwEAATANBgkqhkiG9w0BAQsFAAOBgQAuluNyPo1HksU3+Mr/PyRQIQS4BI7pRXN8mcejXmqyscdP"
+        + "7S6J21FBFeRR8/XNjVOp4HT9uSc2hrRtTEHEZCmpyoxixbnM706ikTmC7SN/GgM+SmcoJ1ipJcNcl8N0X6zym4dm"
+        + "yFfXKHu2PkTo7QFdpOJFvP3lIigcSZXozfmEDg==\n"
+        + "-1\n";
+    String entryBody = "abc";
+    String journalBody = ""
+        + "libcore.io.DiskLruCache\n"
+        + "1\n"
+        + "201105\n"
+        + "2\n"
+        + "\n"
+        + "CLEAN " + urlKey + " " + entryMetadata.length() + " " + entryBody.length() + "\n";
+    writeFile(cache.getDirectory(), urlKey + ".0", entryMetadata);
+    writeFile(cache.getDirectory(), urlKey + ".1", entryBody);
+    writeFile(cache.getDirectory(), "journal", journalBody);
+    cache = new Cache(cache.getDirectory(), Integer.MAX_VALUE);
+    client.client().setCache(cache);
+
+    HttpURLConnection connection = client.open(url);
+    assertEquals(entryBody, readAscii(connection));
+    assertEquals("3", connection.getHeaderField("Content-Length"));
+    assertEquals("foo", connection.getHeaderField("etag"));
+  }
+
+  private void writeFile(File directory, String file, String content) throws IOException {
+    BufferedSink sink = Okio.buffer(Okio.sink(new File(directory, file)));
+    sink.writeUtf8(content);
+    sink.close();
+  }
+
+  /**
+   * @param delta the offset from the current date to use. Negative
+   * values yield dates in the past; positive values yield dates in the
+   * future.
+   */
+  private String formatDate(long delta, TimeUnit timeUnit) {
+    return formatDate(new Date(System.currentTimeMillis() + timeUnit.toMillis(delta)));
+  }
+
+  private String formatDate(Date date) {
+    DateFormat rfc1123 = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss zzz", Locale.US);
+    rfc1123.setTimeZone(TimeZone.getTimeZone("GMT"));
+    return rfc1123.format(date);
+  }
+
+  private void addRequestBodyIfNecessary(String requestMethod, HttpURLConnection invalidate)
+      throws IOException {
+    if (requestMethod.equals("POST") || requestMethod.equals("PUT")) {
+      invalidate.setDoOutput(true);
+      OutputStream requestBody = invalidate.getOutputStream();
+      requestBody.write('x');
+      requestBody.close();
+    }
+  }
+
+  private void assertNotCached(MockResponse response) throws Exception {
+    server.enqueue(response.setBody("A"));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    URL url = server.getUrl("/");
+    assertEquals("A", readAscii(client.open(url)));
+    assertEquals("B", readAscii(client.open(url)));
+  }
+
+  /** @return the request with the conditional get headers. */
+  private RecordedRequest assertConditionallyCached(MockResponse response) throws Exception {
+    // scenario 1: condition succeeds
+    server.enqueue(response.setBody("A").setStatus("HTTP/1.1 200 A-OK"));
+    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    // scenario 2: condition fails
+    server.enqueue(response.setBody("B").setStatus("HTTP/1.1 200 B-OK"));
+    server.enqueue(new MockResponse().setStatus("HTTP/1.1 200 C-OK").setBody("C"));
+
+    URL valid = server.getUrl("/valid");
+    HttpURLConnection connection1 = client.open(valid);
+    assertEquals("A", readAscii(connection1));
+    assertEquals(HttpURLConnection.HTTP_OK, connection1.getResponseCode());
+    assertEquals("A-OK", connection1.getResponseMessage());
+    HttpURLConnection connection2 = client.open(valid);
+    assertEquals("A", readAscii(connection2));
+    assertEquals(HttpURLConnection.HTTP_OK, connection2.getResponseCode());
+    assertEquals("A-OK", connection2.getResponseMessage());
+
+    URL invalid = server.getUrl("/invalid");
+    HttpURLConnection connection3 = client.open(invalid);
+    assertEquals("B", readAscii(connection3));
+    assertEquals(HttpURLConnection.HTTP_OK, connection3.getResponseCode());
+    assertEquals("B-OK", connection3.getResponseMessage());
+    HttpURLConnection connection4 = client.open(invalid);
+    assertEquals("C", readAscii(connection4));
+    assertEquals(HttpURLConnection.HTTP_OK, connection4.getResponseCode());
+    assertEquals("C-OK", connection4.getResponseMessage());
+
+    server.takeRequest(); // regular get
+    return server.takeRequest(); // conditional get
+  }
+
+  private void assertFullyCached(MockResponse response) throws Exception {
+    server.enqueue(response.setBody("A"));
+    server.enqueue(response.setBody("B"));
+
+    URL url = server.getUrl("/");
+    assertEquals("A", readAscii(client.open(url)));
+    assertEquals("A", readAscii(client.open(url)));
+  }
+
+  /**
+   * Shortens the body of {@code response} but not the corresponding headers.
+   * Only useful to test how clients respond to the premature conclusion of
+   * the HTTP body.
+   */
+  private MockResponse truncateViolently(MockResponse response, int numBytesToKeep) {
+    response.setSocketPolicy(DISCONNECT_AT_END);
+    Headers headers = response.getHeaders();
+    Buffer truncatedBody = new Buffer();
+    truncatedBody.write(response.getBody(), numBytesToKeep);
+    response.setBody(truncatedBody);
+    response.setHeaders(headers);
+    return response;
+  }
+
+  /**
+   * Reads {@code count} characters from the stream. If the stream is
+   * exhausted before {@code count} characters can be read, the remaining
+   * characters are returned and the stream is closed.
+   */
+  private String readAscii(URLConnection connection, int count) throws IOException {
+    HttpURLConnection httpConnection = (HttpURLConnection) connection;
+    InputStream in = httpConnection.getResponseCode() < HttpURLConnection.HTTP_BAD_REQUEST
+        ? connection.getInputStream()
+        : httpConnection.getErrorStream();
+    StringBuilder result = new StringBuilder();
+    for (int i = 0; i < count; i++) {
+      int value = in.read();
+      if (value == -1) {
+        in.close();
+        break;
+      }
+      result.append((char) value);
+    }
+    return result.toString();
+  }
+
+  private String readAscii(URLConnection connection) throws IOException {
+    return readAscii(connection, Integer.MAX_VALUE);
+  }
+
+  private void reliableSkip(InputStream in, int length) throws IOException {
+    while (length > 0) {
+      length -= in.skip(length);
+    }
+  }
+
+  private void assertGatewayTimeout(HttpURLConnection connection) throws IOException {
+    try {
+      connection.getInputStream();
+      fail();
+    } catch (FileNotFoundException expected) {
+    }
+    assertEquals(504, connection.getResponseCode());
+    assertEquals(-1, connection.getErrorStream().read());
+  }
+
+  enum TransferKind {
+    CHUNKED() {
+      @Override void setBody(MockResponse response, Buffer content, int chunkSize)
+          throws IOException {
+        response.setChunkedBody(content, chunkSize);
+      }
+    },
+    FIXED_LENGTH() {
+      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
+        response.setBody(content);
+      }
+    },
+    END_OF_STREAM() {
+      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
+        response.setBody(content);
+        response.setSocketPolicy(DISCONNECT_AT_END);
+        response.removeHeader("Content-Length");
+      }
+    };
+
+    abstract void setBody(MockResponse response, Buffer content, int chunkSize) throws IOException;
+
+    void setBody(MockResponse response, String content, int chunkSize) throws IOException {
+      setBody(response, new Buffer().writeUtf8(content), chunkSize);
+    }
+  }
+
+  private <T> List<T> toListOrNull(T[] arrayOrNull) {
+    return arrayOrNull != null ? Arrays.asList(arrayOrNull) : null;
+  }
+
+  /** Returns a gzipped copy of {@code bytes}. */
+  public Buffer gzip(String data) throws IOException {
+    Buffer result = new Buffer();
+    BufferedSink sink = Okio.buffer(new GzipSink(result));
+    sink.writeUtf8(data);
+    sink.close();
+    return result;
+  }
+}
diff --git a/okhttp-urlconnection/src/test/java/com/squareup/okhttp/internal/huc/URLEncodingTest.java b/okhttp-urlconnection/src/test/java/com/squareup/okhttp/internal/huc/URLEncodingTest.java
new file mode 100644
index 0000000000..5a4ed10ac2
--- /dev/null
+++ b/okhttp-urlconnection/src/test/java/com/squareup/okhttp/internal/huc/URLEncodingTest.java
@@ -0,0 +1,176 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.squareup.okhttp.internal.huc;
+
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.OkUrlFactory;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import com.squareup.okhttp.internal.Internal;
+import com.squareup.okhttp.internal.InternalCache;
+import com.squareup.okhttp.internal.http.CacheRequest;
+import com.squareup.okhttp.internal.http.CacheStrategy;
+
+import java.io.IOException;
+import java.net.CacheResponse;
+import java.net.HttpURLConnection;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.net.URL;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicReference;
+import org.junit.Ignore;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+
+/**
+ * Exercises HttpURLConnection to convert URL to a URI. Unlike URL#toURI,
+ * HttpURLConnection recovers from URLs with unescaped but unsupported URI
+ * characters like '{' and '|' by escaping these characters.
+ */
+public final class URLEncodingTest {
+  /**
+   * This test goes through the exhaustive set of interesting ASCII characters
+   * because most of those characters are interesting in some way according to
+   * RFC 2396 and RFC 2732. http://b/1158780
+   */
+  @Test @Ignore public void lenientUrlToUri() throws Exception {
+    // alphanum
+    testUrlToUriMapping("abzABZ09", "abzABZ09", "abzABZ09", "abzABZ09", "abzABZ09");
+
+    // control characters
+    testUrlToUriMapping("\u0001", "%01", "%01", "%01", "%01");
+    testUrlToUriMapping("\u001f", "%1F", "%1F", "%1F", "%1F");
+
+    // ascii characters
+    testUrlToUriMapping("%20", "%20", "%20", "%20", "%20");
+    testUrlToUriMapping("%20", "%20", "%20", "%20", "%20");
+    testUrlToUriMapping(" ", "%20", "%20", "%20", "%20");
+    testUrlToUriMapping("!", "!", "!", "!", "!");
+    testUrlToUriMapping("\"", "%22", "%22", "%22", "%22");
+    testUrlToUriMapping("#", null, null, null, "%23");
+    testUrlToUriMapping("$", "$", "$", "$", "$");
+    testUrlToUriMapping("&", "&", "&", "&", "&");
+    testUrlToUriMapping("'", "'", "'", "'", "'");
+    testUrlToUriMapping("(", "(", "(", "(", "(");
+    testUrlToUriMapping(")", ")", ")", ")", ")");
+    testUrlToUriMapping("*", "*", "*", "*", "*");
+    testUrlToUriMapping("+", "+", "+", "+", "+");
+    testUrlToUriMapping(",", ",", ",", ",", ",");
+    testUrlToUriMapping("-", "-", "-", "-", "-");
+    testUrlToUriMapping(".", ".", ".", ".", ".");
+    testUrlToUriMapping("/", null, "/", "/", "/");
+    testUrlToUriMapping(":", null, ":", ":", ":");
+    testUrlToUriMapping(";", ";", ";", ";", ";");
+    testUrlToUriMapping("<", "%3C", "%3C", "%3C", "%3C");
+    testUrlToUriMapping("=", "=", "=", "=", "=");
+    testUrlToUriMapping(">", "%3E", "%3E", "%3E", "%3E");
+    testUrlToUriMapping("?", null, null, "?", "?");
+    testUrlToUriMapping("@", "@", "@", "@", "@");
+    testUrlToUriMapping("[", null, "%5B", null, "%5B");
+    testUrlToUriMapping("\\", "%5C", "%5C", "%5C", "%5C");
+    testUrlToUriMapping("]", null, "%5D", null, "%5D");
+    testUrlToUriMapping("^", "%5E", "%5E", "%5E", "%5E");
+    testUrlToUriMapping("_", "_", "_", "_", "_");
+    testUrlToUriMapping("`", "%60", "%60", "%60", "%60");
+    testUrlToUriMapping("{", "%7B", "%7B", "%7B", "%7B");
+    testUrlToUriMapping("|", "%7C", "%7C", "%7C", "%7C");
+    testUrlToUriMapping("}", "%7D", "%7D", "%7D", "%7D");
+    testUrlToUriMapping("~", "~", "~", "~", "~");
+    testUrlToUriMapping("~", "~", "~", "~", "~");
+    testUrlToUriMapping("\u007f", "%7F", "%7F", "%7F", "%7F");
+
+    // beyond ascii
+    testUrlToUriMapping("\u0080", "%C2%80", "%C2%80", "%C2%80", "%C2%80");
+    testUrlToUriMapping("\u20ac", "\u20ac", "\u20ac", "\u20ac", "\u20ac");
+    testUrlToUriMapping("\ud842\udf9f", "\ud842\udf9f", "\ud842\udf9f", "\ud842\udf9f",
+        "\ud842\udf9f");
+  }
+
+  @Test @Ignore public void lenientUrlToUriNul() throws Exception {
+    testUrlToUriMapping("\u0000", "%00", "%00", "%00", "%00"); // RI fails this
+  }
+
+  private void testUrlToUriMapping(String string, String asAuthority, String asFile, String asQuery,
+      String asFragment) throws Exception {
+    if (asAuthority != null) {
+      assertEquals("http://host" + asAuthority + ".tld/",
+          backdoorUrlToUri(new URL("http://host" + string + ".tld/")).toString());
+    }
+    if (asFile != null) {
+      assertEquals("http://host.tld/file" + asFile + "/",
+          backdoorUrlToUri(new URL("http://host.tld/file" + string + "/")).toString());
+    }
+    if (asQuery != null) {
+      assertEquals("http://host.tld/file?q" + asQuery + "=x",
+          backdoorUrlToUri(new URL("http://host.tld/file?q" + string + "=x")).toString());
+    }
+    assertEquals("http://host.tld/file#" + asFragment + "-x",
+        backdoorUrlToUri(new URL("http://host.tld/file#" + asFragment + "-x")).toString());
+  }
+
+  private URI backdoorUrlToUri(URL url) throws Exception {
+    final AtomicReference<URI> uriReference = new AtomicReference<>();
+
+    OkHttpClient client = new OkHttpClient();
+    Internal.instance.setCache(client, new InternalCache() {
+      @Override
+      public Response get(Request request) throws IOException {
+        uriReference.set(request.uri());
+        throw new UnsupportedOperationException();
+      }
+
+      @Override
+      public CacheRequest put(Response response) throws IOException {
+        return null;
+      }
+
+      @Override
+      public void remove(Request request) throws IOException {
+
+      }
+
+      @Override
+      public void update(Response cached, Response network) throws IOException {
+
+      }
+
+      @Override
+      public void trackConditionalCacheHit() {
+
+      }
+
+      @Override
+      public void trackResponse(CacheStrategy cacheStrategy) {
+
+      }
+    });
+
+    try {
+      HttpURLConnection connection = new OkUrlFactory(client).open(url);
+      connection.getResponseCode();
+    } catch (Exception expected) {
+      if (expected.getCause() instanceof URISyntaxException) {
+        expected.printStackTrace();
+      }
+    }
+
+    return uriReference.get();
+  }
+}
diff --git a/okhttp-ws/README.md b/okhttp-ws/README.md
new file mode 100644
index 0000000000..054ea91fbf
--- /dev/null
+++ b/okhttp-ws/README.md
@@ -0,0 +1,22 @@
+OkHttp Web Sockets
+==================
+
+RFC6455-compliant web socket implementation.
+
+Create a `WebSocketCall` with a `Request` and an `OkHttpClient` instance.
+```java
+WebSocketCall call = WebSocketCall.create(client, request);
+```
+
+A `WebSocketListener` will notify of the initial connection, server-sent messages, and any failures
+on the connection.
+
+Start the web socket by calling `enqueue` on `WebSocketCall` with the `WebSocketListener`.
+```java
+call.enqueue(new WebSocketListener() {
+  // ...
+});
+```
+
+*Note: This module's API should be considered experimental and may be subject to breaking changes
+in future releases.*
diff --git a/okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/RealWebSocket.java b/okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/RealWebSocket.java
new file mode 100644
index 0000000000..07d763ba45
--- /dev/null
+++ b/okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/RealWebSocket.java
@@ -0,0 +1,189 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.ws;
+
+import com.squareup.okhttp.internal.NamedRunnable;
+import com.squareup.okhttp.ws.WebSocket;
+import com.squareup.okhttp.ws.WebSocketListener;
+import java.io.IOException;
+import java.net.ProtocolException;
+import java.util.Random;
+import java.util.concurrent.Executor;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.BufferedSource;
+
+import static com.squareup.okhttp.internal.ws.WebSocketReader.FrameCallback;
+
+public abstract class RealWebSocket implements WebSocket {
+  /** A close code which indicates that the peer encountered a protocol exception. */
+  private static final int CLOSE_PROTOCOL_EXCEPTION = 1002;
+
+  private final WebSocketWriter writer;
+  private final WebSocketReader reader;
+  private final WebSocketListener listener;
+
+  /** True after calling {@link #close(int, String)}. No writes are allowed afterward. */
+  private volatile boolean writerSentClose;
+  /** True after a close frame was read by the reader. No frames will follow it. */
+  private volatile boolean readerSentClose;
+  /** Lock required to negotiate closing the connection. */
+  private final Object closeLock = new Object();
+
+  public RealWebSocket(boolean isClient, BufferedSource source, BufferedSink sink, Random random,
+      final Executor replyExecutor, final WebSocketListener listener, final String url) {
+    this.listener = listener;
+
+    writer = new WebSocketWriter(isClient, sink, random);
+    reader = new WebSocketReader(isClient, source, new FrameCallback() {
+      @Override public void onMessage(BufferedSource source, PayloadType type) throws IOException {
+        listener.onMessage(source, type);
+      }
+
+      @Override public void onPing(final Buffer buffer) {
+        replyExecutor.execute(new NamedRunnable("OkHttp %s WebSocket Pong Reply", url) {
+          @Override protected void execute() {
+            try {
+              writer.writePong(buffer);
+            } catch (IOException ignored) {
+            }
+          }
+        });
+      }
+
+      @Override public void onPong(Buffer buffer) {
+        listener.onPong(buffer);
+      }
+
+      @Override public void onClose(final int code, final String reason) {
+        final boolean writeCloseResponse;
+        synchronized (closeLock) {
+          readerSentClose = true;
+
+          // If the writer has not indicated a desire to close we will write a close response.
+          writeCloseResponse = !writerSentClose;
+        }
+
+        replyExecutor.execute(new NamedRunnable("OkHttp %s WebSocket Close Reply", url) {
+          @Override protected void execute() {
+            peerClose(code, reason, writeCloseResponse);
+          }
+        });
+      }
+    });
+  }
+
+  /**
+   * Read a single message from the web socket and deliver it to the listener. This method should
+   * be called in a loop with the return value indicating whether looping should continue.
+   */
+  public boolean readMessage() {
+    try {
+      reader.processNextFrame();
+      return !readerSentClose;
+    } catch (IOException e) {
+      readerErrorClose(e);
+      return false;
+    }
+  }
+
+  @Override public BufferedSink newMessageSink(PayloadType type) {
+    if (writerSentClose) throw new IllegalStateException("closed");
+    return writer.newMessageSink(type);
+  }
+
+  @Override public void sendMessage(PayloadType type, Buffer payload) throws IOException {
+    if (writerSentClose) throw new IllegalStateException("closed");
+    writer.sendMessage(type, payload);
+  }
+
+  @Override public void sendPing(Buffer payload) throws IOException {
+    if (writerSentClose) throw new IllegalStateException("closed");
+    writer.writePing(payload);
+  }
+
+  /** Send an unsolicited pong with the specified payload. */
+  public void sendPong(Buffer payload) throws IOException {
+    if (writerSentClose) throw new IllegalStateException("closed");
+    writer.writePong(payload);
+  }
+
+  @Override public void close(int code, String reason) throws IOException {
+    if (writerSentClose) throw new IllegalStateException("closed");
+
+    boolean closeConnection;
+    synchronized (closeLock) {
+      writerSentClose = true;
+
+      // If the reader has also indicated a desire to close we will close the connection.
+      closeConnection = readerSentClose;
+    }
+
+    writer.writeClose(code, reason);
+
+    if (closeConnection) {
+      closeConnection();
+    }
+  }
+
+  /** Replies and closes this web socket when a close frame is read from the peer. */
+  private void peerClose(int code, String reason, boolean writeCloseResponse) {
+    if (writeCloseResponse) {
+      try {
+        writer.writeClose(code, reason);
+      } catch (IOException ignored) {
+      }
+    }
+
+    try {
+      closeConnection();
+    } catch (IOException ignored) {
+    }
+
+    listener.onClose(code, reason);
+  }
+
+  /** Called on the reader thread when an error occurs. */
+  private void readerErrorClose(IOException e) {
+    boolean writeCloseResponse;
+    synchronized (closeLock) {
+      readerSentClose = true;
+
+      // If the writer has not closed we will close the connection.
+      writeCloseResponse = !writerSentClose;
+    }
+
+    if (writeCloseResponse) {
+      if (e instanceof ProtocolException) {
+        // For protocol exceptions, try to inform the server of such.
+        try {
+          writer.writeClose(CLOSE_PROTOCOL_EXCEPTION, null);
+        } catch (IOException ignored) {
+        }
+      }
+    }
+
+    try {
+      closeConnection();
+    } catch (IOException ignored) {
+    }
+
+    listener.onFailure(e);
+  }
+
+  /** Perform any tear-down work on the connection (close the socket, recycle, etc.). */
+  protected abstract void closeConnection() throws IOException;
+}
diff --git a/okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/WebSocketProtocol.java b/okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/WebSocketProtocol.java
new file mode 100644
index 0000000000..2b93398fa5
--- /dev/null
+++ b/okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/WebSocketProtocol.java
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.ws;
+
+public final class WebSocketProtocol {
+  /** Magic value which must be appended to the key in a response header. */
+  public static final String ACCEPT_MAGIC = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
+
+  /*
+  Each frame starts with two bytes of data.
+
+   0 1 2 3 4 5 6 7    0 1 2 3 4 5 6 7
+  +-+-+-+-+-------+  +-+-------------+
+  |F|R|R|R| OP    |  |M| LENGTH      |
+  |I|S|S|S| CODE  |  |A|             |
+  |N|V|V|V|       |  |S|             |
+  | |1|2|3|       |  |K|             |
+  +-+-+-+-+-------+  +-+-------------+
+  */
+
+  /** Byte 0 flag for whether this is the final fragment in a message. */
+  static final int B0_FLAG_FIN = 0b10000000;
+  /** Byte 0 reserved flag 1. Must be 0 unless negotiated otherwise. */
+  static final int B0_FLAG_RSV1 = 0b01000000;
+  /** Byte 0 reserved flag 2. Must be 0 unless negotiated otherwise. */
+  static final int B0_FLAG_RSV2 = 0b00100000;
+  /** Byte 0 reserved flag 3. Must be 0 unless negotiated otherwise. */
+  static final int B0_FLAG_RSV3 = 0b00010000;
+  /** Byte 0 mask for the frame opcode. */
+  static final int B0_MASK_OPCODE = 0b00001111;
+  /** Flag in the opcode which indicates a control frame. */
+  static final int OPCODE_FLAG_CONTROL = 0b00001000;
+
+  /**
+   * Byte 1 flag for whether the payload data is masked.
+   * <p>
+   * If this flag is set, the next four bytes represent the mask key. These bytes appear after
+   * any additional bytes specified by {@link #B1_MASK_LENGTH}.
+   */
+  static final int B1_FLAG_MASK = 0b10000000;
+  /**
+   * Byte 1 mask for the payload length.
+   * <p>
+   * If this value is {@link #PAYLOAD_SHORT}, the next two bytes represent the length.
+   * If this value is {@link #PAYLOAD_LONG}, the next eight bytes represent the length.
+   */
+  static final int B1_MASK_LENGTH = 0b01111111;
+
+  static final int OPCODE_CONTINUATION = 0x0;
+  static final int OPCODE_TEXT = 0x1;
+  static final int OPCODE_BINARY = 0x2;
+
+  static final int OPCODE_CONTROL_CLOSE = 0x8;
+  static final int OPCODE_CONTROL_PING = 0x9;
+  static final int OPCODE_CONTROL_PONG = 0xa;
+
+  /**
+   * Maximum length of frame payload. Larger payloads, if supported, can use the special values
+   * {@link #PAYLOAD_SHORT} or {@link #PAYLOAD_LONG}.
+   */
+  static final int PAYLOAD_MAX = 125;
+  /**
+   * Value for {@link #B1_MASK_LENGTH} which indicates the next two bytes are the unsigned length.
+   */
+  static final int PAYLOAD_SHORT = 126;
+  /**
+   * Value for {@link #B1_MASK_LENGTH} which indicates the next eight bytes are the unsigned
+   * length.
+   */
+  static final int PAYLOAD_LONG = 127;
+
+  static void toggleMask(byte[] buffer, long byteCount, byte[] key, long frameBytesRead) {
+    int keyLength = key.length;
+    for (int i = 0; i < byteCount; i++, frameBytesRead++) {
+      int keyIndex = (int) (frameBytesRead % keyLength);
+      buffer[i] = (byte) (buffer[i] ^ key[keyIndex]);
+    }
+  }
+
+  private WebSocketProtocol() {
+    throw new AssertionError("No instances.");
+  }
+}
diff --git a/okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/WebSocketReader.java b/okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/WebSocketReader.java
new file mode 100644
index 0000000000..ce548b17ea
--- /dev/null
+++ b/okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/WebSocketReader.java
@@ -0,0 +1,294 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.ws;
+
+import java.io.EOFException;
+import java.io.IOException;
+import java.net.ProtocolException;
+import okio.Buffer;
+import okio.BufferedSource;
+import okio.Okio;
+import okio.Source;
+import okio.Timeout;
+
+import static com.squareup.okhttp.ws.WebSocket.PayloadType;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.B0_FLAG_FIN;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.B0_FLAG_RSV1;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.B0_FLAG_RSV2;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.B0_FLAG_RSV3;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.B0_MASK_OPCODE;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.B1_FLAG_MASK;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.B1_MASK_LENGTH;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_BINARY;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_CONTINUATION;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_CONTROL_CLOSE;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_CONTROL_PING;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_CONTROL_PONG;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_FLAG_CONTROL;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_TEXT;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.PAYLOAD_LONG;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.PAYLOAD_MAX;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.PAYLOAD_SHORT;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.toggleMask;
+import static java.lang.Integer.toHexString;
+
+/**
+ * An <a href="http://tools.ietf.org/html/rfc6455">RFC 6455</a>-compatible WebSocket frame reader.
+ */
+public final class WebSocketReader {
+  public interface FrameCallback {
+    void onMessage(BufferedSource source, PayloadType type) throws IOException;
+    void onPing(Buffer buffer);
+    void onPong(Buffer buffer);
+    void onClose(int code, String reason);
+  }
+
+  private final boolean isClient;
+  private final BufferedSource source;
+  private final FrameCallback frameCallback;
+
+  private final Source framedMessageSource = new FramedMessageSource();
+
+  private boolean closed;
+  private boolean messageClosed;
+
+  // Stateful data about the current frame.
+  private int opcode;
+  private long frameLength;
+  private long frameBytesRead;
+  private boolean isFinalFrame;
+  private boolean isControlFrame;
+  private boolean isMasked;
+
+  private final byte[] maskKey = new byte[4];
+  private final byte[] maskBuffer = new byte[2048];
+
+  public WebSocketReader(boolean isClient, BufferedSource source, FrameCallback frameCallback) {
+    if (source == null) throw new NullPointerException("source == null");
+    if (frameCallback == null) throw new NullPointerException("frameCallback == null");
+    this.isClient = isClient;
+    this.source = source;
+    this.frameCallback = frameCallback;
+  }
+
+  /**
+   * Process the next protocol frame.
+   * <ul>
+   * <li>If it is a control frame this will result in a single call to {@link FrameCallback}.</li>
+   * <li>If it is a message frame this will result in a single call to {@link
+   * FrameCallback#onMessage}. If the message spans multiple frames, each interleaved control
+   * frame will result in a corresponding call to {@link FrameCallback}.
+   * </ul>
+   */
+  public void processNextFrame() throws IOException {
+    readHeader();
+    if (isControlFrame) {
+      readControlFrame();
+    } else {
+      readMessageFrame();
+    }
+  }
+
+  private void readHeader() throws IOException {
+    if (closed) throw new IOException("closed");
+
+    int b0 = source.readByte() & 0xff;
+
+    opcode = b0 & B0_MASK_OPCODE;
+    isFinalFrame = (b0 & B0_FLAG_FIN) != 0;
+    isControlFrame = (b0 & OPCODE_FLAG_CONTROL) != 0;
+
+    // Control frames must be final frames (cannot contain continuations).
+    if (isControlFrame && !isFinalFrame) {
+      throw new ProtocolException("Control frames must be final.");
+    }
+
+    boolean reservedFlag1 = (b0 & B0_FLAG_RSV1) != 0;
+    boolean reservedFlag2 = (b0 & B0_FLAG_RSV2) != 0;
+    boolean reservedFlag3 = (b0 & B0_FLAG_RSV3) != 0;
+    if (reservedFlag1 || reservedFlag2 || reservedFlag3) {
+      // Reserved flags are for extensions which we currently do not support.
+      throw new ProtocolException("Reserved flags are unsupported.");
+    }
+
+    int b1 = source.readByte() & 0xff;
+
+    isMasked = (b1 & B1_FLAG_MASK) != 0;
+    if (isMasked == isClient) {
+      // Masked payloads must be read on the server. Unmasked payloads must be read on the client.
+      throw new ProtocolException("Client-sent frames must be masked. Server sent must not.");
+    }
+
+    // Get frame length, optionally reading from follow-up bytes if indicated by special values.
+    frameLength = b1 & B1_MASK_LENGTH;
+    if (frameLength == PAYLOAD_SHORT) {
+      frameLength = source.readShort() & 0xffffL; // Value is unsigned.
+    } else if (frameLength == PAYLOAD_LONG) {
+      frameLength = source.readLong();
+      if (frameLength < 0) {
+        throw new ProtocolException(
+            "Frame length 0x" + Long.toHexString(frameLength) + " > 0x7FFFFFFFFFFFFFFF");
+      }
+    }
+    frameBytesRead = 0;
+
+    if (isControlFrame && frameLength > PAYLOAD_MAX) {
+      throw new ProtocolException("Control frame must be less than " + PAYLOAD_MAX + "B.");
+    }
+
+    if (isMasked) {
+      // Read the masking key as bytes so that they can be used directly for unmasking.
+      source.readFully(maskKey);
+    }
+  }
+
+  private void readControlFrame() throws IOException {
+    Buffer buffer = null;
+    if (frameBytesRead < frameLength) {
+      buffer = new Buffer();
+
+      if (isClient) {
+        source.readFully(buffer, frameLength);
+      } else {
+        while (frameBytesRead < frameLength) {
+          int toRead = (int) Math.min(frameLength - frameBytesRead, maskBuffer.length);
+          int read = source.read(maskBuffer, 0, toRead);
+          if (read == -1) throw new EOFException();
+          toggleMask(maskBuffer, read, maskKey, frameBytesRead);
+          buffer.write(maskBuffer, 0, read);
+          frameBytesRead += read;
+        }
+      }
+    }
+
+    switch (opcode) {
+      case OPCODE_CONTROL_PING:
+        frameCallback.onPing(buffer);
+        break;
+      case OPCODE_CONTROL_PONG:
+        frameCallback.onPong(buffer);
+        break;
+      case OPCODE_CONTROL_CLOSE:
+        int code = 0;
+        String reason = "";
+        if (buffer != null) {
+          if (buffer.size() < 2) {
+            throw new ProtocolException("Close payload must be at least two bytes.");
+          }
+          code = buffer.readShort();
+          if (code < 1000 || code >= 5000) {
+            throw new ProtocolException("Code must be in range [1000,5000): " + code);
+          }
+
+          reason = buffer.readUtf8();
+        }
+        frameCallback.onClose(code, reason);
+        closed = true;
+        break;
+      default:
+        throw new ProtocolException("Unknown control opcode: " + toHexString(opcode));
+    }
+  }
+
+  private void readMessageFrame() throws IOException {
+    PayloadType type;
+    switch (opcode) {
+      case OPCODE_TEXT:
+        type = PayloadType.TEXT;
+        break;
+      case OPCODE_BINARY:
+        type = PayloadType.BINARY;
+        break;
+      default:
+        throw new ProtocolException("Unknown opcode: " + toHexString(opcode));
+    }
+
+    messageClosed = false;
+    frameCallback.onMessage(Okio.buffer(framedMessageSource), type);
+    if (!messageClosed) {
+      throw new IllegalStateException("Listener failed to call close on message payload.");
+    }
+  }
+
+  /** Read headers and process any control frames until we reach a non-control frame. */
+  private void readUntilNonControlFrame() throws IOException {
+    while (!closed) {
+      readHeader();
+      if (!isControlFrame) {
+        break;
+      }
+      readControlFrame();
+    }
+  }
+
+  /**
+   * A special source which knows how to read a message body across one or more frames. Control
+   * frames that occur between fragments will be processed. If the message payload is masked this
+   * will unmask as it's being processed.
+   */
+  private final class FramedMessageSource implements Source {
+    @Override public long read(Buffer sink, long byteCount) throws IOException {
+      if (closed) throw new IOException("closed");
+      if (messageClosed) throw new IllegalStateException("closed");
+
+      if (frameBytesRead == frameLength) {
+        if (isFinalFrame) return -1; // We are exhausted and have no continuations.
+
+        readUntilNonControlFrame();
+        if (opcode != OPCODE_CONTINUATION) {
+          throw new ProtocolException("Expected continuation opcode. Got: " + toHexString(opcode));
+        }
+        if (isFinalFrame && frameLength == 0) {
+          return -1; // Fast-path for empty final frame.
+        }
+      }
+
+      long toRead = Math.min(byteCount, frameLength - frameBytesRead);
+
+      long read;
+      if (isMasked) {
+        toRead = Math.min(toRead, maskBuffer.length);
+        read = source.read(maskBuffer, 0, (int) toRead);
+        if (read == -1) throw new EOFException();
+        toggleMask(maskBuffer, read, maskKey, frameBytesRead);
+        sink.write(maskBuffer, 0, (int) read);
+      } else {
+        read = source.read(sink, toRead);
+        if (read == -1) throw new EOFException();
+      }
+
+      frameBytesRead += read;
+      return read;
+    }
+
+    @Override public Timeout timeout() {
+      return source.timeout();
+    }
+
+    @Override public void close() throws IOException {
+      if (messageClosed) return;
+      messageClosed = true;
+      if (closed) return;
+
+      // Exhaust the remainder of the message, if any.
+      source.skip(frameLength - frameBytesRead);
+      while (!isFinalFrame) {
+        readUntilNonControlFrame();
+        source.skip(frameLength);
+      }
+    }
+  }
+}
diff --git a/okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/WebSocketWriter.java b/okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/WebSocketWriter.java
new file mode 100644
index 0000000000..fc5de753a1
--- /dev/null
+++ b/okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/WebSocketWriter.java
@@ -0,0 +1,292 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.ws;
+
+import java.io.IOException;
+import java.util.Random;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.Okio;
+import okio.Sink;
+import okio.Timeout;
+
+import static com.squareup.okhttp.ws.WebSocket.PayloadType;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.B0_FLAG_FIN;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.B1_FLAG_MASK;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_BINARY;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_CONTINUATION;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_CONTROL_CLOSE;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_CONTROL_PING;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_CONTROL_PONG;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_TEXT;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.PAYLOAD_LONG;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.PAYLOAD_MAX;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.PAYLOAD_SHORT;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.toggleMask;
+
+/**
+ * An <a href="http://tools.ietf.org/html/rfc6455">RFC 6455</a>-compatible WebSocket frame writer.
+ * <p>
+ * This class is partially thread safe. Only a single "main" thread should be sending messages via
+ * calls to {@link #newMessageSink} or {@link #sendMessage} as well as any calls to
+ * {@link #writePing} or {@link #writeClose}. Other threads may call {@link #writePing},
+ * {@link #writePong}, or {@link #writeClose} which will interleave on the wire with frames from
+ * the main thread.
+ */
+public final class WebSocketWriter {
+  private final boolean isClient;
+  /** Writes must be guarded by synchronizing on this instance! */
+  private final BufferedSink sink;
+  private final Random random;
+
+  private final FrameSink frameSink = new FrameSink();
+
+  private boolean closed;
+  private boolean activeWriter;
+
+  private final byte[] maskKey;
+  private final byte[] maskBuffer;
+
+  public WebSocketWriter(boolean isClient, BufferedSink sink, Random random) {
+    if (sink == null) throw new NullPointerException("sink == null");
+    if (random == null) throw new NullPointerException("random == null");
+    this.isClient = isClient;
+    this.sink = sink;
+    this.random = random;
+
+    // Masks are only a concern for client writers.
+    maskKey = isClient ? new byte[4] : null;
+    maskBuffer = isClient ? new byte[2048] : null;
+  }
+
+  /** Send a ping with the supplied {@code payload}. Payload may be {@code null} */
+  public void writePing(Buffer payload) throws IOException {
+    synchronized (sink) {
+      writeControlFrame(OPCODE_CONTROL_PING, payload);
+    }
+  }
+
+  /** Send a pong with the supplied {@code payload}. Payload may be {@code null} */
+  public void writePong(Buffer payload) throws IOException {
+    synchronized (sink) {
+      writeControlFrame(OPCODE_CONTROL_PONG, payload);
+    }
+  }
+
+  /**
+   * Send a close frame with optional code and reason.
+   *
+   * @param code Status code as defined by
+   * <a href="http://tools.ietf.org/html/rfc6455#section-7.4">Section 7.4 of RFC 6455</a> or
+   * {@code 0}.
+   * @param reason Reason for shutting down or {@code null}.
+   */
+  public void writeClose(int code, String reason) throws IOException {
+    Buffer payload = null;
+    if (code != 0 || reason != null) {
+      if (code != 0 && (code < 1000 || code >= 5000)) {
+        throw new IllegalArgumentException("Code must be in range [1000,5000).");
+      }
+      payload = new Buffer();
+      payload.writeShort(code);
+      if (reason != null) {
+        payload.writeUtf8(reason);
+      }
+    }
+
+    synchronized (sink) {
+      writeControlFrame(OPCODE_CONTROL_CLOSE, payload);
+      closed = true;
+    }
+  }
+
+  private void writeControlFrame(int opcode, Buffer payload) throws IOException {
+    if (closed) throw new IOException("closed");
+
+    int length = 0;
+    if (payload != null) {
+      length = (int) payload.size();
+      if (length > PAYLOAD_MAX) {
+        throw new IllegalArgumentException(
+            "Payload size must be less than or equal to " + PAYLOAD_MAX);
+      }
+    }
+
+    int b0 = B0_FLAG_FIN | opcode;
+    sink.writeByte(b0);
+
+    int b1 = length;
+    if (isClient) {
+      b1 |= B1_FLAG_MASK;
+      sink.writeByte(b1);
+
+      random.nextBytes(maskKey);
+      sink.write(maskKey);
+
+      if (payload != null) {
+        writeAllMasked(payload, length);
+      }
+    } else {
+      sink.writeByte(b1);
+
+      if (payload != null) {
+        sink.writeAll(payload);
+      }
+    }
+
+    sink.flush();
+  }
+
+  /**
+   * Stream a message payload as a series of frames. This allows control frames to be interleaved
+   * between parts of the message.
+   */
+  public BufferedSink newMessageSink(PayloadType type) {
+    if (type == null) throw new NullPointerException("type == null");
+    if (activeWriter) {
+      throw new IllegalStateException("Another message writer is active. Did you call close()?");
+    }
+    activeWriter = true;
+
+    frameSink.payloadType = type;
+    frameSink.isFirstFrame = true;
+    return Okio.buffer(frameSink);
+  }
+
+  /**
+   * Send a message payload as a single frame. This will block any control frames that need sent
+   * until it is completed.
+   */
+  public void sendMessage(PayloadType type, Buffer payload) throws IOException {
+    if (type == null) throw new NullPointerException("type == null");
+    if (payload == null) throw new NullPointerException("payload == null");
+    if (activeWriter) {
+      throw new IllegalStateException("A message writer is active. Did you call close()?");
+    }
+    writeFrame(type, payload, payload.size(), true /* first frame */, true /* final */);
+  }
+
+  private void writeFrame(PayloadType payloadType, Buffer source, long byteCount,
+      boolean isFirstFrame, boolean isFinal) throws IOException {
+    if (closed) throw new IOException("closed");
+
+    int opcode = OPCODE_CONTINUATION;
+    if (isFirstFrame) {
+      switch (payloadType) {
+        case TEXT:
+          opcode = OPCODE_TEXT;
+          break;
+        case BINARY:
+          opcode = OPCODE_BINARY;
+          break;
+        default:
+          throw new IllegalStateException("Unknown payload type: " + payloadType);
+      }
+    }
+
+    synchronized (sink) {
+      int b0 = opcode;
+      if (isFinal) {
+        b0 |= B0_FLAG_FIN;
+      }
+      sink.writeByte(b0);
+
+      int b1 = 0;
+      if (isClient) {
+        b1 |= B1_FLAG_MASK;
+        random.nextBytes(maskKey);
+      }
+      if (byteCount <= PAYLOAD_MAX) {
+        b1 |= (int) byteCount;
+        sink.writeByte(b1);
+      } else if (byteCount <= 0xffffL) { // Unsigned short.
+        b1 |= PAYLOAD_SHORT;
+        sink.writeByte(b1);
+        sink.writeShort((int) byteCount);
+      } else {
+        b1 |= PAYLOAD_LONG;
+        sink.writeByte(b1);
+        sink.writeLong(byteCount);
+      }
+
+      if (isClient) {
+        sink.write(maskKey);
+        writeAllMasked(source, byteCount);
+      } else {
+        sink.write(source, byteCount);
+      }
+
+      sink.flush();
+    }
+  }
+
+  private void writeAllMasked(BufferedSource source, long byteCount) throws IOException {
+    long written = 0;
+    while (written < byteCount) {
+      int toRead = (int) Math.min(byteCount, maskBuffer.length);
+      int read = source.read(maskBuffer, 0, toRead);
+      if (read == -1) throw new AssertionError();
+      toggleMask(maskBuffer, read, maskKey, written);
+      sink.write(maskBuffer, 0, read);
+      written += read;
+    }
+  }
+
+  private final class FrameSink implements Sink {
+    private PayloadType payloadType;
+    private boolean isFirstFrame;
+
+    @Override public void write(Buffer source, long byteCount) throws IOException {
+      writeFrame(payloadType, source, byteCount, isFirstFrame, false /* final */);
+      isFirstFrame = false;
+    }
+
+    @Override public void flush() throws IOException {
+      if (closed) throw new IOException("closed");
+
+      synchronized (sink) {
+        sink.flush();
+      }
+    }
+
+    @Override public Timeout timeout() {
+      return sink.timeout();
+    }
+
+    @SuppressWarnings("PointlessBitwiseExpression")
+    @Override public void close() throws IOException {
+      if (closed) throw new IOException("closed");
+
+      int length = 0;
+
+      synchronized (sink) {
+        sink.writeByte(B0_FLAG_FIN | OPCODE_CONTINUATION);
+
+        if (isClient) {
+          sink.writeByte(B1_FLAG_MASK | length);
+          random.nextBytes(maskKey);
+          sink.write(maskKey);
+        } else {
+          sink.writeByte(length);
+        }
+        sink.flush();
+      }
+
+      activeWriter = false;
+    }
+  }
+}
diff --git a/okhttp-ws/src/main/java/com/squareup/okhttp/ws/WebSocket.java b/okhttp-ws/src/main/java/com/squareup/okhttp/ws/WebSocket.java
new file mode 100644
index 0000000000..4cf2f42d6f
--- /dev/null
+++ b/okhttp-ws/src/main/java/com/squareup/okhttp/ws/WebSocket.java
@@ -0,0 +1,68 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.ws;
+
+import java.io.IOException;
+import okio.Buffer;
+import okio.BufferedSink;
+
+/** Blocking interface to connect and write to a web socket. */
+public interface WebSocket {
+  /** The format of a message payload. */
+  enum PayloadType {
+    /** UTF8-encoded text data. */
+    TEXT,
+    /** Arbitrary binary data. */
+    BINARY
+  }
+
+  /**
+   * Stream a message payload to the server of the specified {code type}.
+   * <p>
+   * You must call {@link BufferedSink#close() close()} to complete the message. Calls to
+   * {@link BufferedSink#flush() flush()} write a frame fragment. The message may be empty.
+   *
+   * @throws IllegalStateException if not connected, already closed, or another writer is active.
+   */
+  BufferedSink newMessageSink(WebSocket.PayloadType type);
+
+  /**
+   * Send a message payload to the server of the specified {@code type}.
+   *
+   * @throws IllegalStateException if not connected, already closed, or another writer is active.
+   */
+  void sendMessage(WebSocket.PayloadType type, Buffer payload) throws IOException;
+
+  /**
+   * Send a ping to the server with optional payload.
+   *
+   * @throws IllegalStateException if already closed.
+   */
+  void sendPing(Buffer payload) throws IOException;
+
+  /**
+   * Send a close frame to the server.
+   * <p>
+   * The corresponding {@link WebSocketListener} will continue to get messages until its
+   * {@link WebSocketListener#onClose onClose()} method is called.
+   * <p>
+   * It is an error to call this method before calling close on an active writer. Calling this
+   * method more than once has no effect.
+   *
+   * @throws IllegalStateException if already closed.
+   */
+  void close(int code, String reason) throws IOException;
+}
diff --git a/okhttp-ws/src/main/java/com/squareup/okhttp/ws/WebSocketCall.java b/okhttp-ws/src/main/java/com/squareup/okhttp/ws/WebSocketCall.java
new file mode 100644
index 0000000000..80b3f0558f
--- /dev/null
+++ b/okhttp-ws/src/main/java/com/squareup/okhttp/ws/WebSocketCall.java
@@ -0,0 +1,208 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.ws;
+
+import com.squareup.okhttp.Call;
+import com.squareup.okhttp.Callback;
+import com.squareup.okhttp.Connection;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import com.squareup.okhttp.internal.Internal;
+import com.squareup.okhttp.internal.NamedRunnable;
+import com.squareup.okhttp.internal.Util;
+import com.squareup.okhttp.internal.ws.RealWebSocket;
+import com.squareup.okhttp.internal.ws.WebSocketProtocol;
+import java.io.IOException;
+import java.net.ProtocolException;
+import java.security.SecureRandom;
+import java.util.Collections;
+import java.util.Random;
+import java.util.concurrent.Executor;
+import java.util.concurrent.LinkedBlockingDeque;
+import java.util.concurrent.ThreadPoolExecutor;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.ByteString;
+
+import static java.util.concurrent.TimeUnit.SECONDS;
+
+public final class WebSocketCall {
+  /**
+   * Prepares the {@code request} to create a web socket at some point in the future.
+   */
+  public static WebSocketCall create(OkHttpClient client, Request request) {
+    return new WebSocketCall(client, request);
+  }
+
+  private final Request request;
+  private final Call call;
+  private final Random random;
+  private final String key;
+
+  WebSocketCall(OkHttpClient client, Request request) {
+    this(client, request, new SecureRandom());
+  }
+
+  WebSocketCall(OkHttpClient client, Request request, Random random) {
+    if (!"GET".equals(request.method())) {
+      throw new IllegalArgumentException("Request must be GET: " + request.method());
+    }
+    this.random = random;
+
+    byte[] nonce = new byte[16];
+    random.nextBytes(nonce);
+    key = ByteString.of(nonce).base64();
+
+    // Copy the client. Otherwise changes (socket factory, redirect policy,
+    // etc.) may incorrectly be reflected in the request when it is executed.
+    client = client.clone();
+    // Force HTTP/1.1 until the WebSocket over HTTP/2 version is finalized.
+    client.setProtocols(Collections.singletonList(com.squareup.okhttp.Protocol.HTTP_1_1));
+
+    request = request.newBuilder()
+        .header("Upgrade", "websocket")
+        .header("Connection", "Upgrade")
+        .header("Sec-WebSocket-Key", key)
+        .header("Sec-WebSocket-Version", "13")
+        .build();
+    this.request = request;
+
+    call = client.newCall(request);
+  }
+
+  /**
+   * Schedules the request to be executed at some point in the future.
+   *
+   * <p>The {@link OkHttpClient#getDispatcher dispatcher} defines when the request will run:
+   * usually immediately unless there are several other requests currently being executed.
+   *
+   * <p>This client will later call back {@code responseCallback} with either an HTTP response or a
+   * failure exception. If you {@link #cancel} a request before it completes the callback will not
+   * be invoked.
+   *
+   * @throws IllegalStateException when the call has already been executed.
+   */
+  public void enqueue(final WebSocketListener listener) {
+    Callback responseCallback = new Callback() {
+      @Override public void onResponse(Response response) throws IOException {
+        try {
+          createWebSocket(response, listener);
+        } catch (IOException e) {
+          listener.onFailure(e);
+        }
+      }
+
+      @Override public void onFailure(Request request, IOException e) {
+        listener.onFailure(e);
+      }
+    };
+    // TODO call.enqueue(responseCallback, true);
+    Internal.instance.callEnqueue(call, responseCallback, true);
+  }
+
+  /** Cancels the request, if possible. Requests that are already complete cannot be canceled. */
+  public void cancel() {
+    call.cancel();
+  }
+
+  private void createWebSocket(Response response, WebSocketListener listener)
+      throws IOException {
+    if (response.code() != 101) {
+      // TODO call.engine.releaseConnection();
+      Internal.instance.callEngineReleaseConnection(call);
+      throw new ProtocolException("Expected HTTP 101 response but was '"
+          + response.code()
+          + " "
+          + response.message()
+          + "'");
+    }
+
+    String headerConnection = response.header("Connection");
+    if (!"Upgrade".equalsIgnoreCase(headerConnection)) {
+      throw new ProtocolException(
+          "Expected 'Connection' header value 'Upgrade' but was '" + headerConnection + "'");
+    }
+    String headerUpgrade = response.header("Upgrade");
+    if (!"websocket".equalsIgnoreCase(headerUpgrade)) {
+      throw new ProtocolException(
+          "Expected 'Upgrade' header value 'websocket' but was '" + headerUpgrade + "'");
+    }
+    String headerAccept = response.header("Sec-WebSocket-Accept");
+    String acceptExpected = Util.shaBase64(key + WebSocketProtocol.ACCEPT_MAGIC);
+    if (!acceptExpected.equals(headerAccept)) {
+      throw new ProtocolException("Expected 'Sec-WebSocket-Accept' header value '"
+          + acceptExpected
+          + "' but was '"
+          + headerAccept
+          + "'");
+    }
+
+    // TODO connection = call.engine.getConnection();
+    Connection connection = Internal.instance.callEngineGetConnection(call);
+    // TODO if (!connection.clearOwner()) {
+    if (!Internal.instance.clearOwner(connection)) {
+      throw new IllegalStateException("Unable to take ownership of connection.");
+    }
+
+    BufferedSource source = Internal.instance.connectionRawSource(connection);
+    BufferedSink sink = Internal.instance.connectionRawSink(connection);
+
+    final RealWebSocket webSocket =
+        ConnectionWebSocket.create(response, connection, source, sink, random, listener);
+
+    // TODO connection.setOwner(webSocket);
+    Internal.instance.connectionSetOwner(connection, webSocket);
+
+    listener.onOpen(webSocket, request, response);
+
+    // Start a dedicated thread for reading the web socket.
+    new Thread(new NamedRunnable("OkHttp WebSocket reader %s", request.urlString()) {
+      @Override protected void execute() {
+        while (webSocket.readMessage()) {
+        }
+      }
+    }).start();
+  }
+
+  // Keep static so that the WebSocketCall instance can be garbage collected.
+  private static class ConnectionWebSocket extends RealWebSocket {
+    static RealWebSocket create(Response response, Connection connection, BufferedSource source,
+        BufferedSink sink, Random random, WebSocketListener listener) {
+      String url = response.request().urlString();
+      ThreadPoolExecutor replyExecutor =
+          new ThreadPoolExecutor(1, 1, 1, SECONDS, new LinkedBlockingDeque<Runnable>(),
+              Util.threadFactory(String.format("OkHttp %s WebSocket", url), true));
+      replyExecutor.allowCoreThreadTimeOut(true);
+
+      return new ConnectionWebSocket(connection, source, sink, random, replyExecutor, listener,
+          url);
+    }
+
+    private final Connection connection;
+
+    private ConnectionWebSocket(Connection connection, BufferedSource source, BufferedSink sink,
+        Random random, Executor replyExecutor, WebSocketListener listener, String url) {
+      super(true /* is client */, source, sink, random, replyExecutor, listener, url);
+      this.connection = connection;
+    }
+
+    @Override protected void closeConnection() throws IOException {
+      // TODO connection.closeIfOwnedBy(this);
+      Internal.instance.closeIfOwnedBy(connection, this);
+    }
+  }
+}
diff --git a/okhttp-ws/src/main/java/com/squareup/okhttp/ws/WebSocketListener.java b/okhttp-ws/src/main/java/com/squareup/okhttp/ws/WebSocketListener.java
new file mode 100644
index 0000000000..a113eed244
--- /dev/null
+++ b/okhttp-ws/src/main/java/com/squareup/okhttp/ws/WebSocketListener.java
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.ws;
+
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import java.io.IOException;
+import okio.Buffer;
+import okio.BufferedSource;
+
+import static com.squareup.okhttp.ws.WebSocket.PayloadType;
+
+/** Listener for server-initiated messages on a connected {@link WebSocket}. */
+public interface WebSocketListener {
+  void onOpen(WebSocket webSocket, Request request, Response response) throws IOException;
+
+  /**
+   * Called when a server message is received. The {@code type} indicates whether the
+   * {@code payload} should be interpreted as UTF-8 text or binary data.
+   *
+   * <p>Implementations <strong>must</strong> call {@code source.close()} before returning. This
+   * indicates completion of parsing the message payload and will consume any remaining bytes in
+   * the message.
+   */
+  void onMessage(BufferedSource payload, PayloadType type) throws IOException;
+
+  /**
+   * Called when a server pong is received. This is usually a result of calling {@link
+   * WebSocket#sendPing(Buffer)} but might also be unsolicited.
+   */
+  void onPong(Buffer payload);
+
+  /**
+   * Called when the server sends a close message. This may have been initiated
+   * from a call to {@link WebSocket#close(int, String) close()} or as an unprompted
+   * message from the server.
+   *
+   * @param code The <a href="http://tools.ietf.org/html/rfc6455#section-7.4.1">RFC-compliant</a>
+   * status code.
+   * @param reason Reason for close or an empty string.
+   */
+  void onClose(int code, String reason);
+
+  /** Called when the transport or protocol layer of this web socket errors during communication. */
+  void onFailure(IOException e);
+}
diff --git a/okhttp/pom.xml b/okhttp/pom.xml
deleted file mode 100644
index 62f93125f1..0000000000
--- a/okhttp/pom.xml
+++ /dev/null
@@ -1,48 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.okhttp</groupId>
-    <artifactId>parent</artifactId>
-    <version>2.1.0-SNAPSHOT</version>
-  </parent>
-
-  <artifactId>okhttp</artifactId>
-  <name>OkHttp</name>
-
-  <dependencies>
-    <dependency>
-      <groupId>com.squareup.okio</groupId>
-      <artifactId>okio</artifactId>
-    </dependency>
-  </dependencies>
-
-  <build>
-    <plugins>
-      <plugin>
-        <groupId>org.codehaus.mojo</groupId>
-        <artifactId>templating-maven-plugin</artifactId>
-        <version>1.0-alpha-3</version>
-        <executions>
-          <execution>
-            <goals>
-              <goal>filter-sources</goal>
-            </goals>
-          </execution>
-        </executions>
-      </plugin>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-javadoc-plugin</artifactId>
-        <configuration>
-          <excludePackageNames>com.squareup.okhttp.internal:com.squareup.okhttp.internal.*</excludePackageNames>
-          <links>
-            <link>http://square.github.io/okio/</link>
-          </links>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Address.java b/okhttp/src/main/java/com/squareup/okhttp/Address.java
index 06894eb93c..6f6ce08d5f 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Address.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Address.java
@@ -17,6 +17,7 @@
 
 import com.squareup.okhttp.internal.Util;
 import java.net.Proxy;
+import java.net.ProxySelector;
 import java.util.List;
 import javax.net.SocketFactory;
 import javax.net.ssl.HostnameVerifier;
@@ -45,15 +46,17 @@
   final Authenticator authenticator;
   final List<Protocol> protocols;
   final List<ConnectionSpec> connectionSpecs;
+  final ProxySelector proxySelector;
 
   public Address(String uriHost, int uriPort, SocketFactory socketFactory,
       SSLSocketFactory sslSocketFactory, HostnameVerifier hostnameVerifier,
       CertificatePinner certificatePinner, Authenticator authenticator, Proxy proxy,
-      List<Protocol> protocols, List<ConnectionSpec> connectionSpecs) {
+      List<Protocol> protocols, List<ConnectionSpec> connectionSpecs, ProxySelector proxySelector) {
     if (uriHost == null) throw new NullPointerException("uriHost == null");
     if (uriPort <= 0) throw new IllegalArgumentException("uriPort <= 0: " + uriPort);
     if (authenticator == null) throw new IllegalArgumentException("authenticator == null");
     if (protocols == null) throw new IllegalArgumentException("protocols == null");
+    if (proxySelector == null) throw new IllegalArgumentException("proxySelector == null");
     this.proxy = proxy;
     this.uriHost = uriHost;
     this.uriPort = uriPort;
@@ -64,6 +67,7 @@ public Address(String uriHost, int uriPort, SocketFactory socketFactory,
     this.authenticator = authenticator;
     this.protocols = Util.immutableList(protocols);
     this.connectionSpecs = Util.immutableList(connectionSpecs);
+    this.proxySelector = proxySelector;
   }
 
   /** Returns the hostname of the origin server. */
@@ -121,12 +125,27 @@ public Authenticator getAuthenticator() {
 
   /**
    * Returns this address's explicitly-specified HTTP proxy, or null to
-   * delegate to the HTTP client's proxy selector.
+   * delegate to the {@linkplain #getProxySelector proxy selector}.
    */
   public Proxy getProxy() {
     return proxy;
   }
 
+  /**
+   * Returns this address's proxy selector. Only used if the proxy is null. If none of this
+   * selector's proxies are reachable, a direct connection will be attempted.
+   */
+  public ProxySelector getProxySelector() {
+    return proxySelector;
+  }
+
+  /**
+   * Returns this address's certificate pinner. Only used for secure connections.
+   */
+  public CertificatePinner getCertificatePinner() {
+    return certificatePinner;
+  }
+
   @Override public boolean equals(Object other) {
     if (other instanceof Address) {
       Address that = (Address) other;
@@ -137,21 +156,25 @@ public Proxy getProxy() {
           && equal(this.hostnameVerifier, that.hostnameVerifier)
           && equal(this.certificatePinner, that.certificatePinner)
           && equal(this.authenticator, that.authenticator)
-          && equal(this.protocols, that.protocols);
+          && equal(this.protocols, that.protocols)
+          && equal(this.connectionSpecs, that.connectionSpecs)
+          && equal(this.proxySelector, that.proxySelector);
     }
     return false;
   }
 
   @Override public int hashCode() {
     int result = 17;
+    result = 31 * result + (proxy != null ? proxy.hashCode() : 0);
     result = 31 * result + uriHost.hashCode();
     result = 31 * result + uriPort;
     result = 31 * result + (sslSocketFactory != null ? sslSocketFactory.hashCode() : 0);
     result = 31 * result + (hostnameVerifier != null ? hostnameVerifier.hashCode() : 0);
     result = 31 * result + (certificatePinner != null ? certificatePinner.hashCode() : 0);
     result = 31 * result + authenticator.hashCode();
-    result = 31 * result + (proxy != null ? proxy.hashCode() : 0);
     result = 31 * result + protocols.hashCode();
+    result = 31 * result + connectionSpecs.hashCode();
+    result = 31 * result + proxySelector.hashCode();
     return result;
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Cache.java b/okhttp/src/main/java/com/squareup/okhttp/Cache.java
index c80e866cf6..03c37a55d7 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Cache.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Cache.java
@@ -24,7 +24,7 @@
 import com.squareup.okhttp.internal.http.HttpMethod;
 import com.squareup.okhttp.internal.http.OkHeaders;
 import com.squareup.okhttp.internal.http.StatusLine;
-import java.io.ByteArrayInputStream;
+import com.squareup.okhttp.internal.io.FileSystem;
 import java.io.File;
 import java.io.IOException;
 import java.security.cert.Certificate;
@@ -33,7 +33,10 @@
 import java.security.cert.CertificateFactory;
 import java.util.ArrayList;
 import java.util.Collections;
+import java.util.Iterator;
 import java.util.List;
+import java.util.NoSuchElementException;
+import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
 import okio.ByteString;
@@ -44,64 +47,88 @@
 import okio.Source;
 
 /**
- * Caches HTTP and HTTPS responses to the filesystem so they may be reused,
- * saving time and bandwidth.
+ * Caches HTTP and HTTPS responses to the filesystem so they may be reused, saving time and
+ * bandwidth.
  *
  * <h3>Cache Optimization</h3>
  * To measure cache effectiveness, this class tracks three statistics:
  * <ul>
- *     <li><strong>{@linkplain #getRequestCount() Request Count:}</strong> the
- *         number of HTTP requests issued since this cache was created.
- *     <li><strong>{@linkplain #getNetworkCount() Network Count:}</strong> the
- *         number of those requests that required network use.
- *     <li><strong>{@linkplain #getHitCount() Hit Count:}</strong> the number of
- *         those requests whose responses were served by the cache.
+ *   <li><strong>{@linkplain #getRequestCount() Request Count:}</strong> the number of HTTP
+ *     requests issued since this cache was created.
+ *   <li><strong>{@linkplain #getNetworkCount() Network Count:}</strong> the number of those
+ *     requests that required network use.
+ *   <li><strong>{@linkplain #getHitCount() Hit Count:}</strong> the number of those requests whose
+ *     responses were served by the cache.
  * </ul>
- * Sometimes a request will result in a conditional cache hit. If the cache
- * contains a stale copy of the response, the client will issue a conditional
- * {@code GET}. The server will then send either the updated response if it has
- * changed, or a short 'not modified' response if the client's copy is still
- * valid. Such responses increment both the network count and hit count.
  *
- * <p>The best way to improve the cache hit rate is by configuring the web
- * server to return cacheable responses. Although this client honors all <a
- * href="http://www.ietf.org/rfc/rfc2616.txt">HTTP/1.1 (RFC 2068)</a> cache
- * headers, it doesn't cache partial responses.
+ * Sometimes a request will result in a conditional cache hit. If the cache contains a stale copy of
+ * the response, the client will issue a conditional {@code GET}. The server will then send either
+ * the updated response if it has changed, or a short 'not modified' response if the client's copy
+ * is still valid. Such responses increment both the network count and hit count.
+ *
+ * <p>The best way to improve the cache hit rate is by configuring the web server to return
+ * cacheable responses. Although this client honors all <a
+ * href="http://tools.ietf.org/html/rfc7234">HTTP/1.1 (RFC 7234)</a> cache headers, it doesn't cache
+ * partial responses.
  *
  * <h3>Force a Network Response</h3>
- * In some situations, such as after a user clicks a 'refresh' button, it may be
- * necessary to skip the cache, and fetch data directly from the server. To force
- * a full refresh, add the {@code no-cache} directive: <pre>   {@code
- *         connection.addRequestProperty("Cache-Control", "no-cache");
+ * In some situations, such as after a user clicks a 'refresh' button, it may be necessary to skip
+ * the cache, and fetch data directly from the server. To force a full refresh, add the {@code
+ * no-cache} directive: <pre>   {@code
+ *
+ *   Request request = new Request.Builder()
+ *       .cacheControl(new CacheControl.Builder().noCache().build())
+ *       .url("http://publicobject.com/helloworld.txt")
+ *       .build();
  * }</pre>
- * If it is only necessary to force a cached response to be validated by the
- * server, use the more efficient {@code max-age=0} instead: <pre>   {@code
- *         connection.addRequestProperty("Cache-Control", "max-age=0");
+ *
+ * If it is only necessary to force a cached response to be validated by the server, use the more
+ * efficient {@code max-age=0} directive instead: <pre>   {@code
+ *
+ *   Request request = new Request.Builder()
+ *       .cacheControl(new CacheControl.Builder()
+ *           .maxAge(0, TimeUnit.SECONDS)
+ *           .build())
+ *       .url("http://publicobject.com/helloworld.txt")
+ *       .build();
  * }</pre>
  *
  * <h3>Force a Cache Response</h3>
- * Sometimes you'll want to show resources if they are available immediately,
- * but not otherwise. This can be used so your application can show
- * <i>something</i> while waiting for the latest data to be downloaded. To
- * restrict a request to locally-cached resources, add the {@code
+ * Sometimes you'll want to show resources if they are available immediately, but not otherwise.
+ * This can be used so your application can show <i>something</i> while waiting for the latest data
+ * to be downloaded. To restrict a request to locally-cached resources, add the {@code
  * only-if-cached} directive: <pre>   {@code
- *     try {
- *         connection.addRequestProperty("Cache-Control", "only-if-cached");
- *         InputStream cached = connection.getInputStream();
- *         // the resource was cached! show it
- *     } catch (FileNotFoundException e) {
- *         // the resource was not cached
+ *
+ *     Request request = new Request.Builder()
+ *         .cacheControl(new CacheControl.Builder()
+ *             .onlyIfCached()
+ *             .build())
+ *         .url("http://publicobject.com/helloworld.txt")
+ *         .build();
+ *     Response forceCacheResponse = client.newCall(request).execute();
+ *     if (forceCacheResponse.code() != 504) {
+ *       // The resource was cached! Show it.
+ *     } else {
+ *       // The resource was not cached.
  *     }
  * }</pre>
- * This technique works even better in situations where a stale response is
- * better than no response. To permit stale cached responses, use the {@code
- * max-stale} directive with the maximum staleness in seconds: <pre>   {@code
- *         int maxStale = 60 * 60 * 24 * 28; // tolerate 4-weeks stale
- *         connection.addRequestProperty("Cache-Control", "max-stale=" + maxStale);
+ * This technique works even better in situations where a stale response is better than no response.
+ * To permit stale cached responses, use the {@code max-stale} directive with the maximum staleness
+ * in seconds: <pre>   {@code
+ *
+ *   Request request = new Request.Builder()
+ *       .cacheControl(new CacheControl.Builder()
+ *           .maxStale(365, TimeUnit.DAYS)
+ *           .build())
+ *       .url("http://publicobject.com/helloworld.txt")
+ *       .build();
  * }</pre>
+ *
+ * <p>The {@link CacheControl} class can configure request caching directives and parse response
+ * caching directives. It even offers convenient constants {@link CacheControl#FORCE_NETWORK} and
+ * {@link CacheControl#FORCE_CACHE} that address the use cases above.
  */
 public final class Cache {
-  // TODO: add APIs to iterate the cache?
   private static final int VERSION = 201105;
   private static final int ENTRY_METADATA = 0;
   private static final int ENTRY_BODY = 1;
@@ -137,12 +164,12 @@
   private int hitCount;
   private int requestCount;
 
-  public Cache(File directory, long maxSize) throws IOException {
-    cache = DiskLruCache.open(directory, VERSION, ENTRY_COUNT, maxSize);
+  public Cache(File directory, long maxSize) {
+    cache = DiskLruCache.create(FileSystem.SYSTEM, directory, VERSION, ENTRY_COUNT, maxSize);
   }
 
   private static String urlToKey(Request request) {
-    return Util.hash(request.urlString());
+    return Util.md5Hex(request.urlString());
   }
 
   Response get(Request request) {
@@ -259,6 +286,58 @@ public void evictAll() throws IOException {
     cache.evictAll();
   }
 
+  /**
+   * Returns an iterator over the URLs in this cache. This iterator doesn't throw {@code
+   * ConcurrentModificationException}, but if new responses are added while iterating, their URLs
+   * will not be returned. If existing responses are evicted during iteration, they will be absent
+   * (unless they were already returned).
+   *
+   * <p>The iterator supports {@linkplain Iterator#remove}. Removing a URL from the iterator evicts
+   * the corresponding response from the cache. Use this to evict selected responses.
+   */
+  public Iterator<String> urls() throws IOException {
+    return new Iterator<String>() {
+      final Iterator<DiskLruCache.Snapshot> delegate = cache.snapshots();
+
+      String nextUrl;
+      boolean canRemove;
+
+      @Override public boolean hasNext() {
+        if (nextUrl != null) return true;
+
+        canRemove = false; // Prevent delegate.remove() on the wrong item!
+        while (delegate.hasNext()) {
+          DiskLruCache.Snapshot snapshot = delegate.next();
+          try {
+            BufferedSource metadata = Okio.buffer(snapshot.getSource(ENTRY_METADATA));
+            nextUrl = metadata.readUtf8LineStrict();
+            return true;
+          } catch (IOException ignored) {
+            // We couldn't read the metadata for this snapshot; possibly because the host filesystem
+            // has disappeared! Skip it.
+          } finally {
+            snapshot.close();
+          }
+        }
+
+        return false;
+      }
+
+      @Override public String next() {
+        if (!hasNext()) throw new NoSuchElementException();
+        String result = nextUrl;
+        nextUrl = null;
+        canRemove = true;
+        return result;
+      }
+
+      @Override public void remove() {
+        if (!canRemove) throw new IllegalStateException("remove() before next()");
+        delegate.remove();
+      }
+    };
+  }
+
   public synchronized int getWriteAbortCount() {
     return writeAbortCount;
   }
@@ -267,7 +346,7 @@ public synchronized int getWriteSuccessCount() {
     return writeSuccessCount;
   }
 
-  public long getSize() {
+  public long getSize() throws IOException {
     return cache.size();
   }
 
@@ -431,7 +510,7 @@ public Entry(Source in) throws IOException {
         Headers.Builder varyHeadersBuilder = new Headers.Builder();
         int varyRequestHeaderLineCount = readInt(source);
         for (int i = 0; i < varyRequestHeaderLineCount; i++) {
-          varyHeadersBuilder.addLine(source.readUtf8LineStrict());
+          varyHeadersBuilder.addLenient(source.readUtf8LineStrict());
         }
         varyHeaders = varyHeadersBuilder.build();
 
@@ -442,7 +521,7 @@ public Entry(Source in) throws IOException {
         Headers.Builder responseHeadersBuilder = new Headers.Builder();
         int responseHeaderLineCount = readInt(source);
         for (int i = 0; i < responseHeaderLineCount; i++) {
-          responseHeadersBuilder.addLine(source.readUtf8LineStrict());
+          responseHeadersBuilder.addLenient(source.readUtf8LineStrict());
         }
         responseHeaders = responseHeadersBuilder.build();
 
@@ -481,9 +560,9 @@ public void writeTo(DiskLruCache.Editor editor) throws IOException {
       sink.writeByte('\n');
       sink.writeUtf8(requestMethod);
       sink.writeByte('\n');
-      sink.writeUtf8(Integer.toString(varyHeaders.size()));
+      sink.writeDecimalLong(varyHeaders.size());
       sink.writeByte('\n');
-      for (int i = 0; i < varyHeaders.size(); i++) {
+      for (int i = 0, size = varyHeaders.size(); i < size; i++) {
         sink.writeUtf8(varyHeaders.name(i));
         sink.writeUtf8(": ");
         sink.writeUtf8(varyHeaders.value(i));
@@ -492,9 +571,9 @@ public void writeTo(DiskLruCache.Editor editor) throws IOException {
 
       sink.writeUtf8(new StatusLine(protocol, code, message).toString());
       sink.writeByte('\n');
-      sink.writeUtf8(Integer.toString(responseHeaders.size()));
+      sink.writeDecimalLong(responseHeaders.size());
       sink.writeByte('\n');
-      for (int i = 0; i < responseHeaders.size(); i++) {
+      for (int i = 0, size = responseHeaders.size(); i < size; i++) {
         sink.writeUtf8(responseHeaders.name(i));
         sink.writeUtf8(": ");
         sink.writeUtf8(responseHeaders.value(i));
@@ -505,8 +584,8 @@ public void writeTo(DiskLruCache.Editor editor) throws IOException {
         sink.writeByte('\n');
         sink.writeUtf8(handshake.cipherSuite());
         sink.writeByte('\n');
-        writeCertArray(sink, handshake.peerCertificates());
-        writeCertArray(sink, handshake.localCertificates());
+        writeCertList(sink, handshake.peerCertificates());
+        writeCertList(sink, handshake.localCertificates());
       }
       sink.close();
     }
@@ -524,8 +603,9 @@ private boolean isHttps() {
         List<Certificate> result = new ArrayList<>(length);
         for (int i = 0; i < length; i++) {
           String line = source.readUtf8LineStrict();
-          byte[] bytes = ByteString.decodeBase64(line).toByteArray();
-          result.add(certificateFactory.generateCertificate(new ByteArrayInputStream(bytes)));
+          Buffer bytes = new Buffer();
+          bytes.write(ByteString.decodeBase64(line));
+          result.add(certificateFactory.generateCertificate(bytes.inputStream()));
         }
         return result;
       } catch (CertificateException e) {
@@ -533,10 +613,10 @@ private boolean isHttps() {
       }
     }
 
-    private void writeCertArray(BufferedSink sink, List<Certificate> certificates)
+    private void writeCertList(BufferedSink sink, List<Certificate> certificates)
         throws IOException {
       try {
-        sink.writeUtf8(Integer.toString(certificates.size()));
+        sink.writeDecimalLong(certificates.size());
         sink.writeByte('\n');
         for (int i = 0, size = certificates.size(); i < size; i++) {
           byte[] bytes = certificates.get(i).getEncoded();
@@ -576,11 +656,15 @@ public Response response(Request request, DiskLruCache.Snapshot snapshot) {
   }
 
   private static int readInt(BufferedSource source) throws IOException {
-    String line = source.readUtf8LineStrict();
     try {
-      return Integer.parseInt(line);
+      long result = source.readDecimalLong();
+      String line = source.readUtf8LineStrict();
+      if (result < 0 || result > Integer.MAX_VALUE || !line.isEmpty()) {
+        throw new IOException("expected an int but was \"" + result + line + "\"");
+      }
+      return (int) result;
     } catch (NumberFormatException e) {
-      throw new IOException("Expected an integer but was \"" + line + "\"");
+      throw new IOException(e.getMessage());
     }
   }
 
diff --git a/okhttp/src/main/java/com/squareup/okhttp/CacheControl.java b/okhttp/src/main/java/com/squareup/okhttp/CacheControl.java
index 774f785760..2ee8982b0c 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/CacheControl.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/CacheControl.java
@@ -34,6 +34,7 @@
   private final boolean noStore;
   private final int maxAgeSeconds;
   private final int sMaxAgeSeconds;
+  private final boolean isPrivate;
   private final boolean isPublic;
   private final boolean mustRevalidate;
   private final int maxStaleSeconds;
@@ -41,19 +42,23 @@
   private final boolean onlyIfCached;
   private final boolean noTransform;
 
+  String headerValue; // Lazily computed, if absent.
+
   private CacheControl(boolean noCache, boolean noStore, int maxAgeSeconds, int sMaxAgeSeconds,
-      boolean isPublic, boolean mustRevalidate, int maxStaleSeconds, int minFreshSeconds,
-      boolean onlyIfCached, boolean noTransform) {
+      boolean isPrivate, boolean isPublic, boolean mustRevalidate, int maxStaleSeconds,
+      int minFreshSeconds, boolean onlyIfCached, boolean noTransform, String headerValue) {
     this.noCache = noCache;
     this.noStore = noStore;
     this.maxAgeSeconds = maxAgeSeconds;
     this.sMaxAgeSeconds = sMaxAgeSeconds;
+    this.isPrivate = isPrivate;
     this.isPublic = isPublic;
     this.mustRevalidate = mustRevalidate;
     this.maxStaleSeconds = maxStaleSeconds;
     this.minFreshSeconds = minFreshSeconds;
     this.onlyIfCached = onlyIfCached;
     this.noTransform = noTransform;
+    this.headerValue = headerValue;
   }
 
   private CacheControl(Builder builder) {
@@ -61,6 +66,7 @@ private CacheControl(Builder builder) {
     this.noStore = builder.noStore;
     this.maxAgeSeconds = builder.maxAgeSeconds;
     this.sMaxAgeSeconds = -1;
+    this.isPrivate = false;
     this.isPublic = false;
     this.mustRevalidate = false;
     this.maxStaleSeconds = builder.maxStaleSeconds;
@@ -103,6 +109,10 @@ public int sMaxAgeSeconds() {
     return sMaxAgeSeconds;
   }
 
+  public boolean isPrivate() {
+    return isPrivate;
+  }
+
   public boolean isPublic() {
     return isPublic;
   }
@@ -143,6 +153,7 @@ public static CacheControl parse(Headers headers) {
     boolean noStore = false;
     int maxAgeSeconds = -1;
     int sMaxAgeSeconds = -1;
+    boolean isPrivate = false;
     boolean isPublic = false;
     boolean mustRevalidate = false;
     int maxStaleSeconds = -1;
@@ -150,40 +161,54 @@ public static CacheControl parse(Headers headers) {
     boolean onlyIfCached = false;
     boolean noTransform = false;
 
-    for (int i = 0; i < headers.size(); i++) {
-      if (!headers.name(i).equalsIgnoreCase("Cache-Control")
-          && !headers.name(i).equalsIgnoreCase("Pragma")) {
+    boolean canUseHeaderValue = true;
+    String headerValue = null;
+
+    for (int i = 0, size = headers.size(); i < size; i++) {
+      String name = headers.name(i);
+      String value = headers.value(i);
+
+      if (name.equalsIgnoreCase("Cache-Control")) {
+        if (headerValue != null) {
+          // Multiple cache-control headers means we can't use the raw value.
+          canUseHeaderValue = false;
+        } else {
+          headerValue = value;
+        }
+      } else if (name.equalsIgnoreCase("Pragma")) {
+        // Might specify additional cache-control params. We invalidate just in case.
+        canUseHeaderValue = false;
+      } else {
         continue;
       }
 
-      String string = headers.value(i);
       int pos = 0;
-      while (pos < string.length()) {
+      while (pos < value.length()) {
         int tokenStart = pos;
-        pos = HeaderParser.skipUntil(string, pos, "=,;");
-        String directive = string.substring(tokenStart, pos).trim();
+        pos = HeaderParser.skipUntil(value, pos, "=,;");
+        String directive = value.substring(tokenStart, pos).trim();
         String parameter;
 
-        if (pos == string.length() || string.charAt(pos) == ',' || string.charAt(pos) == ';') {
+        if (pos == value.length() || value.charAt(pos) == ',' || value.charAt(pos) == ';') {
           pos++; // consume ',' or ';' (if necessary)
           parameter = null;
         } else {
           pos++; // consume '='
-          pos = HeaderParser.skipWhitespace(string, pos);
+          pos = HeaderParser.skipWhitespace(value, pos);
 
           // quoted string
-          if (pos < string.length() && string.charAt(pos) == '\"') {
+          if (pos < value.length() && value.charAt(pos) == '\"') {
             pos++; // consume '"' open quote
             int parameterStart = pos;
-            pos = HeaderParser.skipUntil(string, pos, "\"");
-            parameter = string.substring(parameterStart, pos);
+            pos = HeaderParser.skipUntil(value, pos, "\"");
+            parameter = value.substring(parameterStart, pos);
             pos++; // consume '"' close quote (if necessary)
 
             // unquoted string
           } else {
             int parameterStart = pos;
-            pos = HeaderParser.skipUntil(string, pos, ",;");
-            parameter = string.substring(parameterStart, pos).trim();
+            pos = HeaderParser.skipUntil(value, pos, ",;");
+            parameter = value.substring(parameterStart, pos).trim();
           }
         }
 
@@ -195,6 +220,8 @@ public static CacheControl parse(Headers headers) {
           maxAgeSeconds = HeaderParser.parseSeconds(parameter, -1);
         } else if ("s-maxage".equalsIgnoreCase(directive)) {
           sMaxAgeSeconds = HeaderParser.parseSeconds(parameter, -1);
+        } else if ("private".equalsIgnoreCase(directive)) {
+          isPrivate = true;
         } else if ("public".equalsIgnoreCase(directive)) {
           isPublic = true;
         } else if ("must-revalidate".equalsIgnoreCase(directive)) {
@@ -211,16 +238,25 @@ public static CacheControl parse(Headers headers) {
       }
     }
 
-    return new CacheControl(noCache, noStore, maxAgeSeconds, sMaxAgeSeconds, isPublic,
-        mustRevalidate, maxStaleSeconds, minFreshSeconds, onlyIfCached, noTransform);
+    if (!canUseHeaderValue) {
+      headerValue = null;
+    }
+    return new CacheControl(noCache, noStore, maxAgeSeconds, sMaxAgeSeconds, isPrivate, isPublic,
+        mustRevalidate, maxStaleSeconds, minFreshSeconds, onlyIfCached, noTransform, headerValue);
   }
 
   @Override public String toString() {
+    String result = headerValue;
+    return result != null ? result : (headerValue = headerValue());
+  }
+
+  private String headerValue() {
     StringBuilder result = new StringBuilder();
     if (noCache) result.append("no-cache, ");
     if (noStore) result.append("no-store, ");
     if (maxAgeSeconds != -1) result.append("max-age=").append(maxAgeSeconds).append(", ");
     if (sMaxAgeSeconds != -1) result.append("s-maxage=").append(sMaxAgeSeconds).append(", ");
+    if (isPrivate) result.append("private, ");
     if (isPublic) result.append("public, ");
     if (mustRevalidate) result.append("must-revalidate, ");
     if (maxStaleSeconds != -1) result.append("max-stale=").append(maxStaleSeconds).append(", ");
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Call.java b/okhttp/src/main/java/com/squareup/okhttp/Call.java
index cf9cc1ea57..99393cf1ec 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Call.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Call.java
@@ -16,19 +16,17 @@
 package com.squareup.okhttp;
 
 import com.squareup.okhttp.internal.NamedRunnable;
+import com.squareup.okhttp.internal.http.RouteException;
 import com.squareup.okhttp.internal.http.HttpEngine;
-import com.squareup.okhttp.internal.http.OkHeaders;
-import com.squareup.okhttp.internal.http.RetryableSink;
+import com.squareup.okhttp.internal.http.RequestException;
 import java.io.IOException;
 import java.net.MalformedURLException;
 import java.net.ProtocolException;
 import java.net.URL;
 import java.util.logging.Level;
-import okio.BufferedSink;
-import okio.BufferedSource;
 
 import static com.squareup.okhttp.internal.Internal.logger;
-import static com.squareup.okhttp.internal.http.HttpEngine.MAX_REDIRECTS;
+import static com.squareup.okhttp.internal.http.HttpEngine.MAX_FOLLOW_UPS;
 
 /**
  * A call is a request that has been prepared for execution. A call can be
@@ -37,21 +35,20 @@
  */
 public class Call {
   private final OkHttpClient client;
-  private int redirectionCount;
 
   // Guarded by this.
   private boolean executed;
   volatile boolean canceled;
 
-  /** The request; possibly a consequence of redirects or auth headers. */
-  private Request request;
+  /** The application's original request unadulterated by redirects or auth headers. */
+  Request originalRequest;
   HttpEngine engine;
 
-  protected Call(OkHttpClient client, Request request) {
+  Call(OkHttpClient client, Request originalRequest) {
     // Copy the client. Otherwise changes (socket factory, redirect policy,
     // etc.) may incorrectly be reflected in the request when it is executed.
     this.client = client.copyWithDefaults();
-    this.request = request;
+    this.originalRequest = originalRequest;
   }
 
   /**
@@ -81,8 +78,7 @@ public Response execute() throws IOException {
     }
     try {
       client.getDispatcher().executed(this);
-      Response result = getResponse();
-      engine.releaseConnection(); // Transfer ownership of the body to the caller.
+      Response result = getResponseWithInterceptorChain(false);
       if (result == null) throw new IOException("Canceled");
       return result;
     } finally {
@@ -91,7 +87,7 @@ public Response execute() throws IOException {
   }
 
   Object tag() {
-    return request.tag();
+    return originalRequest.tag();
   }
 
   /**
@@ -108,11 +104,15 @@ Object tag() {
    * @throws IllegalStateException when the call has already been executed.
    */
   public void enqueue(Callback responseCallback) {
+    enqueue(responseCallback, false);
+  }
+
+  void enqueue(Callback responseCallback, boolean forWebSocket) {
     synchronized (this) {
       if (executed) throw new IllegalStateException("Already Executed");
       executed = true;
     }
-    client.getDispatcher().enqueue(new AsyncCall(responseCallback));
+    client.getDispatcher().enqueue(new AsyncCall(responseCallback, forWebSocket));
   }
 
   /**
@@ -130,22 +130,24 @@ public boolean isCanceled() {
 
   final class AsyncCall extends NamedRunnable {
     private final Callback responseCallback;
+    private final boolean forWebSocket;
 
-    private AsyncCall(Callback responseCallback) {
-      super("OkHttp %s", request.urlString());
+    private AsyncCall(Callback responseCallback, boolean forWebSocket) {
+      super("OkHttp %s", originalRequest.urlString());
       this.responseCallback = responseCallback;
+      this.forWebSocket = forWebSocket;
     }
 
     String host() {
-      return request.url().getHost();
+      return originalRequest.url().getHost();
     }
 
     Request request() {
-      return request;
+      return originalRequest;
     }
 
     Object tag() {
-      return request.tag();
+      return originalRequest.tag();
     }
 
     void cancel() {
@@ -159,13 +161,12 @@ Call get() {
     @Override protected void execute() {
       boolean signalledCallback = false;
       try {
-        Response response = getResponse();
+        Response response = getResponseWithInterceptorChain(forWebSocket);
         if (canceled) {
           signalledCallback = true;
-          responseCallback.onFailure(request, new IOException("Canceled"));
+          responseCallback.onFailure(originalRequest, new IOException("Canceled"));
         } else {
           signalledCallback = true;
-          engine.releaseConnection();
           responseCallback.onResponse(response);
         }
       } catch (IOException e) {
@@ -173,7 +174,7 @@ Call get() {
           // Do not signal the callback twice!
           logger.log(Level.INFO, "Callback failure for " + toLoggableString(), e);
         } else {
-          responseCallback.onFailure(request, e);
+          responseCallback.onFailure(engine.getRequest(), e);
         }
       } finally {
         client.getDispatcher().finished(this);
@@ -188,21 +189,56 @@ Call get() {
   private String toLoggableString() {
     String string = canceled ? "canceled call" : "call";
     try {
-      String redactedUrl = new URL(request.url(), "/...").toString();
+      String redactedUrl = new URL(originalRequest.url(), "/...").toString();
       return string + " to " + redactedUrl;
     } catch (MalformedURLException e) {
       return string;
     }
   }
 
+  private Response getResponseWithInterceptorChain(boolean forWebSocket) throws IOException {
+    Interceptor.Chain chain = new ApplicationInterceptorChain(0, originalRequest, forWebSocket);
+    return chain.proceed(originalRequest);
+  }
+
+  class ApplicationInterceptorChain implements Interceptor.Chain {
+    private final int index;
+    private final Request request;
+    private final boolean forWebSocket;
+
+    ApplicationInterceptorChain(int index, Request request, boolean forWebSocket) {
+      this.index = index;
+      this.request = request;
+      this.forWebSocket = forWebSocket;
+    }
+
+    @Override public Connection connection() {
+      return null;
+    }
+
+    @Override public Request request() {
+      return request;
+    }
+
+    @Override public Response proceed(Request request) throws IOException {
+      if (index < client.interceptors().size()) {
+        // There's another interceptor in the chain. Call that.
+        Interceptor.Chain chain = new ApplicationInterceptorChain(index + 1, request, forWebSocket);
+        return client.interceptors().get(index).intercept(chain);
+      } else {
+        // No more interceptors. Do HTTP.
+        return getResponse(request, forWebSocket);
+      }
+    }
+  }
+
   /**
    * Performs the request and returns the response. May return null if this
    * call was canceled.
    */
-  private Response getResponse() throws IOException {
+  Response getResponse(Request request, boolean forWebSocket) throws IOException {
     // Copy body metadata to the appropriate request headers.
     RequestBody body = request.body();
-    RetryableSink requestBodyOut = null;
     if (body != null) {
       Request.Builder requestBuilder = request.newBuilder();
 
@@ -224,21 +260,32 @@ private Response getResponse() throws IOException {
     }
 
     // Create the initial HTTP engine. Retries and redirects need new engine for each attempt.
-    engine = new HttpEngine(client, request, false, null, null, requestBodyOut, null);
+    engine = new HttpEngine(client, request, false, false, forWebSocket, null, null, null, null);
 
+    int followUpCount = 0;
     while (true) {
-      if (canceled) return null;
+      if (canceled) {
+        engine.releaseConnection();
+        throw new IOException("Canceled");
+      }
 
       try {
         engine.sendRequest();
-
-        if (request.body() != null) {
-          BufferedSink sink = engine.getBufferedRequestBody();
-          request.body().writeTo(sink);
-        }
-
         engine.readResponse();
+      } catch (RequestException e) {
+        // The attempt to interpret the request failed. Give up.
+        throw e.getCause();
+      } catch (RouteException e) {
+        // The attempt to connect via a route failed. The request will not have been sent.
+        HttpEngine retryEngine = engine.recover(e);
+        if (retryEngine != null) {
+          engine = retryEngine;
+          continue;
+        }
+        // Give up; recovery is not possible.
+        throw e.getLastConnectException();
       } catch (IOException e) {
+        // An attempt to communicate with a server failed. The request may have been sent.
         HttpEngine retryEngine = engine.recover(e, null);
         if (retryEngine != null) {
           engine = retryEngine;
@@ -253,14 +300,14 @@ private Response getResponse() throws IOException {
       Request followUp = engine.followUpRequest();
 
       if (followUp == null) {
-        engine.releaseConnection();
-        return response.newBuilder()
-            .body(new RealResponseBody(response, engine.getResponseBody()))
-            .build();
+        if (!forWebSocket) {
+          engine.releaseConnection();
+        }
+        return response;
       }
 
-      if (engine.getResponse().isRedirect() && ++redirectionCount > MAX_REDIRECTS) {
-        throw new ProtocolException("Too many redirects: " + redirectionCount);
+      if (++followUpCount > MAX_FOLLOW_UPS) {
+        throw new ProtocolException("Too many follow-up requests: " + followUpCount);
       }
 
       if (!engine.sameConnection(followUp.url())) {
@@ -269,30 +316,8 @@ private Response getResponse() throws IOException {
 
       Connection connection = engine.close();
       request = followUp;
-      engine = new HttpEngine(client, request, false, connection, null, null, response);
-    }
-  }
-
-  private static class RealResponseBody extends ResponseBody {
-    private final Response response;
-    private final BufferedSource source;
-
-    RealResponseBody(Response response, BufferedSource source) {
-      this.response = response;
-      this.source = source;
-    }
-
-    @Override public MediaType contentType() {
-      String contentType = response.header("Content-Type");
-      return contentType != null ? MediaType.parse(contentType) : null;
-    }
-
-    @Override public long contentLength() {
-      return OkHeaders.contentLength(response);
-    }
-
-    @Override public BufferedSource source() {
-      return source;
+      engine = new HttpEngine(client, request, false, false, forWebSocket, connection, null, null,
+          response);
     }
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/CertificatePinner.java b/okhttp/src/main/java/com/squareup/okhttp/CertificatePinner.java
index 10423737cb..15a29527dc 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/CertificatePinner.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/CertificatePinner.java
@@ -18,14 +18,16 @@
 import com.squareup.okhttp.internal.Util;
 import java.security.cert.Certificate;
 import java.security.cert.X509Certificate;
-import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.LinkedHashMap;
+import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 import javax.net.ssl.SSLPeerUnverifiedException;
 import okio.ByteString;
 
-import static java.util.Collections.unmodifiableList;
+import static java.util.Collections.unmodifiableSet;
 
 /**
  * Constrains which certificates are trusted. Pinning certificates defends
@@ -90,8 +92,28 @@
  *       .build();
  * }</pre>
  *
- * Pinning is per-hostname. To pin both {@code publicobject.com} and {@code
- * www.publicobject.com}, you must configure both hostnames.
+ * Pinning is per-hostname and/or per-wildcard pattern. To pin both
+ * {@code publicobject.com} and {@code www.publicobject.com}, you must
+ * configure both hostnames.
+ *
+ * <p>Wildcard pattern rules:
+ * <ol>
+ *   <li>Asterisk {@code *} is only permitted in the left-most
+ *       domain name label and must be the only character in that label
+ *       (i.e., must match the whole left-most label). For example,
+ *       {@code *.example.com} is permitted, while {@code *a.example.com},
+ *       {@code a*.example.com}, {@code a*b.example.com}, {@code a.*.example.com}
+ *       are not permitted.
+ *   <li>Asterisk {@code *} cannot match across domain name labels.
+ *       For example, {@code *.example.com} matches {@code test.example.com}
+ *       but does not match {@code sub.test.example.com}.
+ *   <li>Wildcard patterns for single-label domain names are not permitted.
+ * </ol>
+ *
+ * If hostname pinned directly and via wildcard pattern, both
+ * direct and wildcard pins will be used. For example: {@code *.example.com} pinned
+ * with {@code pin1} and {@code a.example.com} pinned with {@code pin2},
+ * to check {@code a.example.com} both {@code pin1} and {@code pin2} will be used.
  *
  * <h3>Warning: Certificate Pinning is Dangerous!</h3>
  * Pinning certificates limits your server team's abilities to update their TLS
@@ -99,11 +121,18 @@
  * complexity and limit your ability to migrate between certificate authorities.
  * Do not use certificate pinning without the blessing of your server's TLS
  * administrator!
+ *
+ * <h4>Note about self-signed certificates</h4>
+ * {@link CertificatePinner} can not be used to pin self-signed certificate
+ * if such certificate is not accepted by {@link javax.net.ssl.TrustManager}.
+ *
+ * @see <a href="https://www.owasp.org/index.php/Certificate_and_Public_Key_Pinning">
+ *     OWASP: Certificate and Public Key Pinning</a>
  */
 public final class CertificatePinner {
   public static final CertificatePinner DEFAULT = new Builder().build();
 
-  private final Map<String, List<ByteString>> hostnameToPins;
+  private final Map<String, Set<ByteString>> hostnameToPins;
 
   private CertificatePinner(Builder builder) {
     hostnameToPins = Util.immutableMap(builder.hostnameToPins);
@@ -118,13 +147,15 @@ private CertificatePinner(Builder builder) {
    * @throws SSLPeerUnverifiedException if {@code peerCertificates} don't match
    *     the certificates pinned for {@code hostname}.
    */
-  public void check(String hostname, Certificate... peerCertificates)
+  public void check(String hostname, List<Certificate> peerCertificates)
       throws SSLPeerUnverifiedException {
-    List<ByteString> pins = hostnameToPins.get(hostname);
+
+    Set<ByteString> pins = findMatchingPins(hostname);
+
     if (pins == null) return;
 
-    for (Certificate c : peerCertificates) {
-      X509Certificate x509Certificate = (X509Certificate) c;
+    for (int i = 0, size = peerCertificates.size(); i < size; i++) {
+      X509Certificate x509Certificate = (X509Certificate) peerCertificates.get(i);
       if (pins.contains(sha1(x509Certificate))) return; // Success!
     }
 
@@ -132,10 +163,10 @@ public void check(String hostname, Certificate... peerCertificates)
     StringBuilder message = new StringBuilder()
         .append("Certificate pinning failure!")
         .append("\n  Peer certificate chain:");
-    for (Certificate c : peerCertificates) {
-      X509Certificate x509Certificate = (X509Certificate) c;
-      message.append("\n    sha1/").append(sha1(x509Certificate).base64()).append(": ")
-          .append(x509Certificate.getSubjectDN().getName());
+    for (int i = 0, size = peerCertificates.size(); i < size; i++) {
+      X509Certificate x509Certificate = (X509Certificate) peerCertificates.get(i);
+      message.append("\n    ").append(pin(x509Certificate))
+          .append(": ").append(x509Certificate.getSubjectDN().getName());
     }
     message.append("\n  Pinned certificates for ").append(hostname).append(":");
     for (ByteString pin : pins) {
@@ -144,6 +175,45 @@ public void check(String hostname, Certificate... peerCertificates)
     throw new SSLPeerUnverifiedException(message.toString());
   }
 
+  /** @deprecated replaced with {@link #check(String, List)}. */
+  public void check(String hostname, Certificate... peerCertificates)
+      throws SSLPeerUnverifiedException {
+    check(hostname, Arrays.asList(peerCertificates));
+  }
+
+  /**
+   * Returns list of matching certificates' pins for the hostname
+   * or {@code null} if hostname does not have pinned certificates.
+   */
+  Set<ByteString> findMatchingPins(String hostname) {
+    Set<ByteString> directPins   = hostnameToPins.get(hostname);
+    Set<ByteString> wildcardPins = null;
+
+    int indexOfFirstDot = hostname.indexOf('.');
+    int indexOfLastDot  = hostname.lastIndexOf('.');
+
+    // Skip hostnames with one dot symbol for wildcard pattern search
+    //   example.com   will  be skipped
+    //   a.example.com won't be skipped
+    if (indexOfFirstDot != indexOfLastDot) {
+      // a.example.com -> search for wildcard pattern *.example.com
+      wildcardPins = hostnameToPins.get("*." + hostname.substring(indexOfFirstDot + 1));
+    }
+
+    if (directPins == null && wildcardPins == null) return null;
+
+    if (directPins != null && wildcardPins != null) {
+      Set<ByteString> pins = new LinkedHashSet<>();
+      pins.addAll(directPins);
+      pins.addAll(wildcardPins);
+      return pins;
+    }
+
+    if (directPins != null) return directPins;
+
+    return wildcardPins;
+  }
+
   /**
    * Returns the SHA-1 of {@code certificate}'s public key. This uses the
    * mechanism Moxie Marlinspike describes in <a
@@ -162,18 +232,21 @@ private static ByteString sha1(X509Certificate x509Certificate) {
 
   /** Builds a configured certificate pinner. */
   public static final class Builder {
-    private final Map<String, List<ByteString>> hostnameToPins = new LinkedHashMap<>();
+    private final Map<String, Set<ByteString>> hostnameToPins = new LinkedHashMap<>();
 
     /**
-     * Pins certificates for {@code hostname}. Each pin is a SHA-1 hash of a
-     * certificate's Subject Public Key Info, base64-encoded and prefixed with
-     * "sha1/".
+     * Pins certificates for {@code hostname}.
+     *
+     * @param hostname lower-case host name or wildcard pattern such as {@code *.example.com}.
+     * @param pins SHA-1 hashes. Each pin is a SHA-1 hash of a
+     *     certificate's Subject Public Key Info, base64-encoded and prefixed with
+     *     {@code sha1/}.
      */
     public Builder add(String hostname, String... pins) {
       if (hostname == null) throw new IllegalArgumentException("hostname == null");
 
-      List<ByteString> hostPins = new ArrayList<>();
-      List<ByteString> previousPins = hostnameToPins.put(hostname, unmodifiableList(hostPins));
+      Set<ByteString> hostPins = new LinkedHashSet<>();
+      Set<ByteString> previousPins = hostnameToPins.put(hostname, unmodifiableSet(hostPins));
       if (previousPins != null) {
         hostPins.addAll(previousPins);
       }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/CipherSuite.java b/okhttp/src/main/java/com/squareup/okhttp/CipherSuite.java
index c531e213b7..13344578be 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/CipherSuite.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/CipherSuite.java
@@ -367,7 +367,7 @@ private CipherSuite(
     this.javaName = javaName;
   }
 
-  static CipherSuite forJavaName(String javaName) {
+  public static CipherSuite forJavaName(String javaName) {
     return javaName.startsWith("SSL_")
         ? valueOf("TLS_" + javaName.substring(4))
         : valueOf(javaName);
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Connection.java b/okhttp/src/main/java/com/squareup/okhttp/Connection.java
index f1d0015425..6819952dda 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Connection.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Connection.java
@@ -16,24 +16,20 @@
  */
 package com.squareup.okhttp;
 
-import com.squareup.okhttp.internal.Platform;
 import com.squareup.okhttp.internal.http.HttpConnection;
 import com.squareup.okhttp.internal.http.HttpEngine;
 import com.squareup.okhttp.internal.http.HttpTransport;
-import com.squareup.okhttp.internal.http.OkHeaders;
+import com.squareup.okhttp.internal.http.RouteException;
+import com.squareup.okhttp.internal.http.SocketConnector;
 import com.squareup.okhttp.internal.http.SpdyTransport;
 import com.squareup.okhttp.internal.http.Transport;
 import com.squareup.okhttp.internal.spdy.SpdyConnection;
 import java.io.IOException;
-import java.net.Proxy;
 import java.net.Socket;
-import java.net.URL;
-import javax.net.ssl.SSLSocket;
-
-import static com.squareup.okhttp.internal.Util.getDefaultPort;
-import static com.squareup.okhttp.internal.Util.getEffectivePort;
-import static java.net.HttpURLConnection.HTTP_OK;
-import static java.net.HttpURLConnection.HTTP_PROXY_AUTH;
+import java.net.UnknownServiceException;
+import java.util.List;
+import okio.BufferedSink;
+import okio.BufferedSource;
 
 /**
  * The sockets and streams of an HTTP, HTTPS, or HTTPS+SPDY connection. May be
@@ -136,23 +132,42 @@ void closeIfOwnedBy(Object owner) throws IOException {
     socket.close();
   }
 
-  void connect(int connectTimeout, int readTimeout, int writeTimeout, Request tunnelRequest)
-      throws IOException {
+  void connect(int connectTimeout, int readTimeout, int writeTimeout, Request request,
+      List<ConnectionSpec> connectionSpecs, boolean connectionRetryEnabled) throws RouteException {
     if (connected) throw new IllegalStateException("already connected");
 
-    if (route.proxy.type() == Proxy.Type.DIRECT || route.proxy.type() == Proxy.Type.HTTP) {
-      socket = route.address.socketFactory.createSocket();
+    SocketConnector socketConnector = new SocketConnector(this, pool);
+    SocketConnector.ConnectedSocket connectedSocket;
+    if (route.address.getSslSocketFactory() != null) {
+      // https:// communication
+      connectedSocket = socketConnector.connectTls(connectTimeout, readTimeout, writeTimeout,
+          request, route, connectionSpecs, connectionRetryEnabled);
     } else {
-      socket = new Socket(route.proxy);
+      // http:// communication.
+      if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {
+        throw new RouteException(
+            new UnknownServiceException(
+                "CLEARTEXT communication not supported: " + connectionSpecs));
+      }
+      connectedSocket = socketConnector.connectCleartext(connectTimeout, readTimeout, route);
     }
 
-    socket.setSoTimeout(readTimeout);
-    Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);
-
-    if (route.address.sslSocketFactory != null) {
-      upgradeToTls(tunnelRequest, readTimeout, writeTimeout);
-    } else {
-      httpConnection = new HttpConnection(pool, this, socket);
+    socket = connectedSocket.socket;
+    handshake = connectedSocket.handshake;
+    protocol = connectedSocket.alpnProtocol == null
+        ? Protocol.HTTP_1_1 : connectedSocket.alpnProtocol;
+
+    try {
+      if (protocol == Protocol.SPDY_3 || protocol == Protocol.HTTP_2) {
+        socket.setSoTimeout(0); // SPDY timeouts are set per-stream.
+        spdyConnection = new SpdyConnection.Builder(route.address.uriHost, true, socket)
+            .protocol(protocol).build();
+        spdyConnection.sendConnectionPreface();
+      } else {
+        httpConnection = new HttpConnection(pool, this, socket);
+      }
+    } catch (IOException e) {
+      throw new RouteException(e);
     }
     connected = true;
   }
@@ -161,13 +176,14 @@ void connect(int connectTimeout, int readTimeout, int writeTimeout, Request tunn
    * Connects this connection if it isn't already. This creates tunnels, shares
    * the connection with the connection pool, and configures timeouts.
    */
-  void connectAndSetOwner(OkHttpClient client, Object owner, Request request) throws IOException {
+  void connectAndSetOwner(OkHttpClient client, Object owner, Request request)
+      throws RouteException {
     setOwner(owner);
 
     if (!isConnected()) {
-      Request tunnelRequest = tunnelRequest(request);
-      connect(client.getConnectTimeout(), client.getReadTimeout(),
-          client.getWriteTimeout(), tunnelRequest);
+      List<ConnectionSpec> connectionSpecs = route.address.getConnectionSpecs();
+      connect(client.getConnectTimeout(), client.getReadTimeout(), client.getWriteTimeout(),
+          request, connectionSpecs, client.getRetryOnConnectionFailure());
       if (isSpdy()) {
         client.getConnectionPool().share(this);
       }
@@ -177,90 +193,6 @@ void connectAndSetOwner(OkHttpClient client, Object owner, Request request) thro
     setTimeouts(client.getReadTimeout(), client.getWriteTimeout());
   }
 
-  /**
-   * Returns a request that creates a TLS tunnel via an HTTP proxy, or null if
-   * no tunnel is necessary. Everything in the tunnel request is sent
-   * unencrypted to the proxy server, so tunnels include only the minimum set of
-   * headers. This avoids sending potentially sensitive data like HTTP cookies
-   * to the proxy unencrypted.
-   */
-  private Request tunnelRequest(Request request) throws IOException {
-    if (!route.requiresTunnel()) return null;
-
-    String host = request.url().getHost();
-    int port = getEffectivePort(request.url());
-    String authority = (port == getDefaultPort("https")) ? host : (host + ":" + port);
-    Request.Builder result = new Request.Builder()
-        .url(new URL("https", host, port, "/"))
-        .header("Host", authority)
-        .header("Proxy-Connection", "Keep-Alive"); // For HTTP/1.0 proxies like Squid.
-
-    // Copy over the User-Agent header if it exists.
-    String userAgent = request.header("User-Agent");
-    if (userAgent != null) {
-      result.header("User-Agent", userAgent);
-    }
-
-    // Copy over the Proxy-Authorization header if it exists.
-    String proxyAuthorization = request.header("Proxy-Authorization");
-    if (proxyAuthorization != null) {
-      result.header("Proxy-Authorization", proxyAuthorization);
-    }
-
-    return result.build();
-  }
-
-  /**
-   * Create an {@code SSLSocket} and perform the TLS handshake and certificate
-   * validation.
-   */
-  private void upgradeToTls(Request tunnelRequest, int readTimeout, int writeTimeout)
-      throws IOException {
-    Platform platform = Platform.get();
-
-    // Make an SSL Tunnel on the first message pair of each SSL + proxy connection.
-    if (tunnelRequest != null) {
-      makeTunnel(tunnelRequest, readTimeout, writeTimeout);
-    }
-
-    // Create the wrapper over connected socket.
-    socket = route.address.sslSocketFactory
-        .createSocket(socket, route.address.uriHost, route.address.uriPort, true /* autoClose */);
-    SSLSocket sslSocket = (SSLSocket) socket;
-
-    // Configure the socket's ciphers, TLS versions, and extensions.
-    route.connectionSpec.apply(sslSocket, route);
-
-    // Force handshake. This can throw!
-    sslSocket.startHandshake();
-
-    // Verify that the socket's certificates are acceptable for the target host.
-    if (!route.address.hostnameVerifier.verify(route.address.uriHost, sslSocket.getSession())) {
-      throw new IOException("Hostname '" + route.address.uriHost + "' was not verified");
-    }
-
-    // Check that the certificate pinner is satisfied by the certificates presented.
-    route.address.certificatePinner.check(route.address.uriHost,
-        sslSocket.getSession().getPeerCertificates());
-
-    handshake = Handshake.get(sslSocket.getSession());
-
-    String maybeProtocol;
-    if (route.connectionSpec.supportsTlsExtensions()
-        && (maybeProtocol = platform.getSelectedProtocol(sslSocket)) != null) {
-      protocol = Protocol.get(maybeProtocol); // Throws IOE on unknown.
-    }
-
-    if (protocol == Protocol.SPDY_3 || protocol == Protocol.HTTP_2) {
-      sslSocket.setSoTimeout(0); // SPDY timeouts are set per-stream.
-      spdyConnection = new SpdyConnection.Builder(route.address.getUriHost(), true, socket)
-          .protocol(protocol).build();
-      spdyConnection.sendConnectionPreface();
-    } else {
-      httpConnection = new HttpConnection(pool, this, socket);
-    }
-  }
-
   /** Returns true if {@link #connect} has been attempted on this connection. */
   boolean isConnected() {
     return connected;
@@ -279,6 +211,16 @@ public Socket getSocket() {
     return socket;
   }
 
+  BufferedSource rawSource() {
+    if (httpConnection == null) throw new UnsupportedOperationException();
+    return httpConnection.rawSource();
+  }
+
+  BufferedSink rawSink() {
+    if (httpConnection == null) throw new UnsupportedOperationException();
+    return httpConnection.rawSink();
+  }
+
   /** Returns true if this connection is alive. */
   boolean isAlive() {
     return !socket.isClosed() && !socket.isInputShutdown() && !socket.isOutputShutdown();
@@ -304,14 +246,6 @@ boolean isIdle() {
     return spdyConnection == null || spdyConnection.isIdle();
   }
 
-  /**
-   * Returns true if this connection has been idle for longer than
-   * {@code keepAliveDurationNs}.
-   */
-  boolean isExpired(long keepAliveDurationNs) {
-    return getIdleStartTimeNs() < System.nanoTime() - keepAliveDurationNs;
-  }
-
   /**
    * Returns the time in ns when this connection became idle. Undefined if
    * this connection is not idle.
@@ -356,12 +290,17 @@ void setProtocol(Protocol protocol) {
     this.protocol = protocol;
   }
 
-  void setTimeouts(int readTimeoutMillis, int writeTimeoutMillis) throws IOException {
+  void setTimeouts(int readTimeoutMillis, int writeTimeoutMillis)
+      throws RouteException {
     if (!connected) throw new IllegalStateException("setTimeouts - not connected");
 
     // Don't set timeouts on shared SPDY connections.
     if (httpConnection != null) {
-      socket.setSoTimeout(readTimeoutMillis);
+      try {
+        socket.setSoTimeout(readTimeoutMillis);
+      } catch (IOException e) {
+        throw new RouteException(e);
+      }
       httpConnection.setTimeouts(readTimeoutMillis, writeTimeoutMillis);
     }
   }
@@ -378,42 +317,17 @@ int recycleCount() {
     return recycleCount;
   }
 
-  /**
-   * To make an HTTPS connection over an HTTP proxy, send an unencrypted
-   * CONNECT request to create the proxy connection. This may need to be
-   * retried if the proxy requires authorization.
-   */
-  private void makeTunnel(Request request, int readTimeout, int writeTimeout)
-      throws IOException {
-    HttpConnection tunnelConnection = new HttpConnection(pool, this, socket);
-    tunnelConnection.setTimeouts(readTimeout, writeTimeout);
-    URL url = request.url();
-    String requestLine = "CONNECT " + url.getHost() + ":" + url.getPort() + " HTTP/1.1";
-    while (true) {
-      tunnelConnection.writeRequest(request.headers(), requestLine);
-      tunnelConnection.flush();
-      Response response = tunnelConnection.readResponse().request(request).build();
-      tunnelConnection.emptyResponseBody();
-
-      switch (response.code()) {
-        case HTTP_OK:
-          // Assume the server won't send a TLS ServerHello until we send a TLS ClientHello. If that
-          // happens, then we will have buffered bytes that are needed by the SSLSocket!
-          if (tunnelConnection.bufferSize() > 0) {
-            throw new IOException("TLS tunnel buffered too many bytes!");
-          }
-          return;
-
-        case HTTP_PROXY_AUTH:
-          request = OkHeaders.processAuthHeader(
-              route.address.authenticator, response, route.proxy);
-          if (request != null) continue;
-          throw new IOException("Failed to authenticate with proxy");
-
-        default:
-          throw new IOException(
-              "Unexpected response code for CONNECT: " + response.code());
-      }
-    }
+  @Override public String toString() {
+    return "Connection{"
+        + route.address.uriHost + ":" + route.address.uriPort
+        + ", proxy="
+        + route.proxy
+        + " hostAddress="
+        + route.inetSocketAddress.getAddress().getHostAddress()
+        + " cipherSuite="
+        + (handshake != null ? handshake.cipherSuite() : "none")
+        + " protocol="
+        + protocol
+        + '}';
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java b/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java
index b52c234e45..ba664ea992 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java
@@ -23,7 +23,7 @@
 import java.util.LinkedList;
 import java.util.List;
 import java.util.ListIterator;
-import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executor;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
@@ -52,7 +52,6 @@
  * initialized lazily.
  */
 public final class ConnectionPool {
-  private static final int MAX_CONNECTIONS_TO_CLEANUP = 2;
   private static final long DEFAULT_KEEP_ALIVE_DURATION_MS = 5 * 60 * 1000; // 5 min
 
   private static final ConnectionPool systemDefault;
@@ -78,40 +77,24 @@
 
   private final LinkedList<Connection> connections = new LinkedList<>();
 
-  /** We use a single background thread to cleanup expired connections. */
-  private final ExecutorService executorService = new ThreadPoolExecutor(0, 1,
-      60L, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),
-      Util.threadFactory("OkHttp ConnectionPool", true));
+  /**
+   * A background thread is used to cleanup expired connections. There will be, at most, a single
+   * thread running per connection pool.
+   *
+   * <p>A {@link ThreadPoolExecutor} is used and not a
+   * {@link java.util.concurrent.ScheduledThreadPoolExecutor}; ScheduledThreadPoolExecutors do not
+   * shrink. This executor shrinks the thread pool after a period of inactivity, and starts threads
+   * as needed. Delays are instead handled by the {@link #connectionsCleanupRunnable}. It is
+   * important that the {@link #connectionsCleanupRunnable} stops eventually, otherwise it will pin
+   * the thread, and thus the connection pool, in memory.
+   */
+  private Executor executor = new ThreadPoolExecutor(
+      0 /* corePoolSize */, 1 /* maximumPoolSize */, 60L /* keepAliveTime */, TimeUnit.SECONDS,
+      new LinkedBlockingQueue<Runnable>(), Util.threadFactory("OkHttp ConnectionPool", true));
+
   private final Runnable connectionsCleanupRunnable = new Runnable() {
     @Override public void run() {
-      List<Connection> expiredConnections = new ArrayList<>(MAX_CONNECTIONS_TO_CLEANUP);
-      int idleConnectionCount = 0;
-      synchronized (ConnectionPool.this) {
-        for (ListIterator<Connection> i = connections.listIterator(connections.size());
-            i.hasPrevious(); ) {
-          Connection connection = i.previous();
-          if (!connection.isAlive() || connection.isExpired(keepAliveDurationNs)) {
-            i.remove();
-            expiredConnections.add(connection);
-            if (expiredConnections.size() == MAX_CONNECTIONS_TO_CLEANUP) break;
-          } else if (connection.isIdle()) {
-            idleConnectionCount++;
-          }
-        }
-
-        for (ListIterator<Connection> i = connections.listIterator(connections.size());
-            i.hasPrevious() && idleConnectionCount > maxIdleConnections; ) {
-          Connection connection = i.previous();
-          if (connection.isIdle()) {
-            expiredConnections.add(connection);
-            i.remove();
-            --idleConnectionCount;
-          }
-        }
-      }
-      for (Connection expiredConnection : expiredConnections) {
-        Util.closeQuietly(expiredConnection.getSocket());
-      }
+      runCleanupUntilPoolIsEmpty();
     }
   };
 
@@ -120,32 +103,6 @@ public ConnectionPool(int maxIdleConnections, long keepAliveDurationMs) {
     this.keepAliveDurationNs = keepAliveDurationMs * 1000 * 1000;
   }
 
-  /**
-   * Returns a snapshot of the connections in this pool, ordered from newest to
-   * oldest. Waits for the cleanup callable to run if it is currently scheduled.
-   */
-  List<Connection> getConnections() {
-    waitForCleanupCallableToRun();
-    synchronized (this) {
-      return new ArrayList<>(connections);
-    }
-  }
-
-  /**
-   * Blocks until the executor service has processed all currently enqueued
-   * jobs.
-   */
-  private void waitForCleanupCallableToRun() {
-    try {
-      executorService.submit(new Runnable() {
-        @Override public void run() {
-        }
-      }).get();
-    } catch (Exception e) {
-      throw new AssertionError();
-    }
-  }
-
   public static ConnectionPool getDefault() {
     return systemDefault;
   }
@@ -155,8 +112,14 @@ public synchronized int getConnectionCount() {
     return connections.size();
   }
 
-  /** Returns total number of spdy connections in the pool. */
+  /** @deprecated Use {@link #getMultiplexedConnectionCount()}. */
+  @Deprecated
   public synchronized int getSpdyConnectionCount() {
+    return getMultiplexedConnectionCount();
+  }
+
+  /** Returns total number of multiplexed connections in the pool. */
+  public synchronized int getMultiplexedConnectionCount() {
     int total = 0;
     for (Connection connection : connections) {
       if (connection.isSpdy()) total++;
@@ -166,11 +129,7 @@ public synchronized int getSpdyConnectionCount() {
 
   /** Returns total number of http connections in the pool. */
   public synchronized int getHttpConnectionCount() {
-    int total = 0;
-    for (Connection connection : connections) {
-      if (!connection.isSpdy()) total++;
-    }
-    return total;
+    return connections.size() - getMultiplexedConnectionCount();
   }
 
   /** Returns a recycled connection to {@code address}, or null if no such connection exists. */
@@ -203,7 +162,6 @@ public synchronized Connection get(Address address) {
       connections.addFirst(foundConnection); // Add it back after iteration.
     }
 
-    executorService.execute(connectionsCleanupRunnable);
     return foundConnection;
   }
 
@@ -237,12 +195,20 @@ void recycle(Connection connection) {
     }
 
     synchronized (this) {
-      connections.addFirst(connection);
+      addConnection(connection);
       connection.incrementRecycleCount();
       connection.resetIdleStartTime();
     }
+  }
 
-    executorService.execute(connectionsCleanupRunnable);
+  private void addConnection(Connection connection) {
+    boolean empty = connections.isEmpty();
+    connections.addFirst(connection);
+    if (empty) {
+      executor.execute(connectionsCleanupRunnable);
+    } else {
+      notifyAll();
+    }
   }
 
   /**
@@ -251,24 +217,121 @@ void recycle(Connection connection) {
    */
   void share(Connection connection) {
     if (!connection.isSpdy()) throw new IllegalArgumentException();
-    executorService.execute(connectionsCleanupRunnable);
-    if (connection.isAlive()) {
-      synchronized (this) {
-        connections.addFirst(connection);
-      }
+    if (!connection.isAlive()) return;
+    synchronized (this) {
+      addConnection(connection);
     }
   }
 
   /** Close and remove all connections in the pool. */
   public void evictAll() {
-    List<Connection> connections;
+    List<Connection> toEvict;
+    synchronized (this) {
+      toEvict = new ArrayList<>(connections);
+      connections.clear();
+      notifyAll();
+    }
+
+    for (int i = 0, size = toEvict.size(); i < size; i++) {
+      Util.closeQuietly(toEvict.get(i).getSocket());
+    }
+  }
+
+  private void runCleanupUntilPoolIsEmpty() {
+    while (true) {
+      if (!performCleanup()) return; // Halt cleanup.
+    }
+  }
+
+  /**
+   * Attempts to make forward progress on connection eviction. There are three possible outcomes:
+   *
+   * <h3>The pool is empty.</h3>
+   * In this case, this method returns false and the eviction job should exit because there are no
+   * further cleanup tasks coming. (If additional connections are added to the pool, another cleanup
+   * job must be enqueued.)
+   *
+   * <h3>Connections were evicted.</h3>
+   * At least one connections was eligible for immediate eviction and was evicted. The method
+   * returns true and cleanup should continue.
+   *
+   * <h3>We waited to evict.</h3>
+   * None of the pooled connections were eligible for immediate eviction. Instead, we waited until
+   * either a connection became eligible for eviction, or the connections list changed. In either
+   * case, the method returns true and cleanup should continue.
+   */
+  // VisibleForTesting
+  boolean performCleanup() {
+    List<Connection> evictableConnections;
+
     synchronized (this) {
-      connections = new ArrayList<>(this.connections);
-      this.connections.clear();
+      if (connections.isEmpty()) return false; // Halt cleanup.
+
+      evictableConnections = new ArrayList<>();
+      int idleConnectionCount = 0;
+      long now = System.nanoTime();
+      long nanosUntilNextEviction = keepAliveDurationNs;
+
+      // Collect connections eligible for immediate eviction.
+      for (ListIterator<Connection> i = connections.listIterator(connections.size());
+          i.hasPrevious(); ) {
+        Connection connection = i.previous();
+        long nanosUntilEviction = connection.getIdleStartTimeNs() + keepAliveDurationNs - now;
+        if (nanosUntilEviction <= 0 || !connection.isAlive()) {
+          i.remove();
+          evictableConnections.add(connection);
+        } else if (connection.isIdle()) {
+          idleConnectionCount++;
+          nanosUntilNextEviction = Math.min(nanosUntilNextEviction, nanosUntilEviction);
+        }
+      }
+
+      // If the pool has too many idle connections, gather more! Oldest to newest.
+      for (ListIterator<Connection> i = connections.listIterator(connections.size());
+          i.hasPrevious() && idleConnectionCount > maxIdleConnections; ) {
+        Connection connection = i.previous();
+        if (connection.isIdle()) {
+          evictableConnections.add(connection);
+          i.remove();
+          --idleConnectionCount;
+        }
+      }
+
+      // If there's nothing to evict, wait. (This will be interrupted if connections are added.)
+      if (evictableConnections.isEmpty()) {
+        try {
+          long millisUntilNextEviction = nanosUntilNextEviction / (1000 * 1000);
+          long remainderNanos = nanosUntilNextEviction - millisUntilNextEviction * (1000 * 1000);
+          this.wait(millisUntilNextEviction, (int) remainderNanos);
+          return true; // Cleanup continues.
+        } catch (InterruptedException ignored) {
+        }
+      }
     }
 
-    for (int i = 0, size = connections.size(); i < size; i++) {
-      Util.closeQuietly(connections.get(i).getSocket());
+    // Actually do the eviction. Note that we avoid synchronized() when closing sockets.
+    for (int i = 0, size = evictableConnections.size(); i < size; i++) {
+      Connection expiredConnection = evictableConnections.get(i);
+      Util.closeQuietly(expiredConnection.getSocket());
     }
+
+    return true; // Cleanup continues.
+  }
+
+  /**
+   * Replace the default {@link Executor} with a different one. Only use in tests.
+   */
+  // VisibleForTesting
+  void replaceCleanupExecutorForTests(Executor cleanupExecutor) {
+    this.executor = cleanupExecutor;
+  }
+
+  /**
+   * Returns a snapshot of the connections in this pool, ordered from newest to
+   * oldest. Only use in tests.
+   */
+  // VisibleForTesting
+  synchronized List<Connection> getConnections() {
+    return new ArrayList<>(connections);
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/ConnectionSpec.java b/okhttp/src/main/java/com/squareup/okhttp/ConnectionSpec.java
index ba9d548377..5e0f7d868a 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/ConnectionSpec.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/ConnectionSpec.java
@@ -15,7 +15,6 @@
  */
 package com.squareup.okhttp;
 
-import com.squareup.okhttp.internal.Platform;
 import com.squareup.okhttp.internal.Util;
 import java.util.Arrays;
 import java.util.List;
@@ -23,59 +22,63 @@
 
 /**
  * Specifies configuration for the socket connection that HTTP traffic travels through. For {@code
- * https:} URLs, this includes the TLS version and ciphers to use when negotiating a secure
+ * https:} URLs, this includes the TLS version and cipher suites to use when negotiating a secure
  * connection.
  */
 public final class ConnectionSpec {
 
+  // This is a subset of the cipher suites supported in Chrome 37, current as of 2014-10-5.
+  // All of these suites are available on Android 5.0; earlier releases support a subset of
+  // these suites. https://github.com/square/okhttp/issues/330
+  private static final CipherSuite[] APPROVED_CIPHER_SUITES = new CipherSuite[] {
+      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
+      CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
+      CipherSuite.TLS_DHE_RSA_WITH_AES_128_GCM_SHA256,
+
+      // Note that the following cipher suites are all on HTTP/2's bad cipher suites list. We'll
+      // continue to include them until better suites are commonly available. For example, none
+      // of the better cipher suites listed above shipped with Android 4.4 or Java 7.
+      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,
+      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,
+      CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,
+      CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,
+      CipherSuite.TLS_DHE_RSA_WITH_AES_128_CBC_SHA,
+      CipherSuite.TLS_DHE_DSS_WITH_AES_128_CBC_SHA,
+      CipherSuite.TLS_DHE_RSA_WITH_AES_256_CBC_SHA,
+      CipherSuite.TLS_RSA_WITH_AES_128_GCM_SHA256,
+      CipherSuite.TLS_RSA_WITH_AES_128_CBC_SHA,
+      CipherSuite.TLS_RSA_WITH_AES_256_CBC_SHA,
+      CipherSuite.TLS_RSA_WITH_3DES_EDE_CBC_SHA,
+  };
+
   /** A modern TLS connection with extensions like SNI and ALPN available. */
   public static final ConnectionSpec MODERN_TLS = new Builder(true)
-      .cipherSuites(
-          // This is a subset of the cipher suites supported in Chrome 37, current as of 2014-10-5.
-          // All of these suites are available on Android L; earlier releases support a subset of
-          // these suites. https://github.com/square/okhttp/issues/330
-          CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
-          CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
-          CipherSuite.TLS_DHE_RSA_WITH_AES_128_GCM_SHA256,
-          CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,
-          CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,
-          CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,
-          CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,
-          CipherSuite.TLS_ECDHE_ECDSA_WITH_RC4_128_SHA,
-          CipherSuite.TLS_ECDHE_RSA_WITH_RC4_128_SHA,
-          CipherSuite.TLS_DHE_RSA_WITH_AES_128_CBC_SHA,
-          CipherSuite.TLS_DHE_DSS_WITH_AES_128_CBC_SHA,
-          CipherSuite.TLS_DHE_RSA_WITH_AES_256_CBC_SHA,
-          CipherSuite.TLS_RSA_WITH_AES_128_GCM_SHA256,
-          CipherSuite.TLS_RSA_WITH_AES_128_CBC_SHA,
-          CipherSuite.TLS_RSA_WITH_AES_256_CBC_SHA,
-          CipherSuite.TLS_RSA_WITH_3DES_EDE_CBC_SHA,
-          CipherSuite.TLS_RSA_WITH_RC4_128_SHA,
-          CipherSuite.TLS_RSA_WITH_RC4_128_MD5
-      )
-      .tlsVersions(TlsVersion.TLS_1_2, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0, TlsVersion.SSL_3_0)
+      .cipherSuites(APPROVED_CIPHER_SUITES)
+      .tlsVersions(TlsVersion.TLS_1_2, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0)
       .supportsTlsExtensions(true)
       .build();
 
   /** A backwards-compatible fallback connection for interop with obsolete servers. */
   public static final ConnectionSpec COMPATIBLE_TLS = new Builder(MODERN_TLS)
-      .tlsVersions(TlsVersion.SSL_3_0)
+      .tlsVersions(TlsVersion.TLS_1_0)
+      .supportsTlsExtensions(true)
       .build();
 
   /** Unencrypted, unauthenticated connections for {@code http:} URLs. */
   public static final ConnectionSpec CLEARTEXT = new Builder(false).build();
 
   final boolean tls;
-  private final String[] cipherSuites;
-  private final String[] tlsVersions;
-  final boolean supportsTlsExtensions;
 
   /**
-   * Caches the subset of this spec that's supported by the host platform. It's possible that the
-   * platform hosts multiple implementations of {@link SSLSocket}, in which case this cache will be
-   * incorrect.
+   * Used if tls == true. The cipher suites to set on the SSLSocket. {@code null} means "use
+   * default set".
    */
-  private ConnectionSpec supportedSpec;
+  private final String[] cipherSuites;
+
+  /** Used if tls == true. The TLS protocol versions to use. */
+  private final String[] tlsVersions;
+
+  final boolean supportsTlsExtensions;
 
   private ConnectionSpec(Builder builder) {
     this.tls = builder.tls;
@@ -88,7 +91,14 @@ public boolean isTls() {
     return tls;
   }
 
+  /**
+   * Returns the cipher suites to use for a connection. This method can return {@code null} if the
+   * cipher suites enabled by default should be used.
+   */
   public List<CipherSuite> cipherSuites() {
+    if (cipherSuites == null) {
+      return null;
+    }
     CipherSuite[] result = new CipherSuite[cipherSuites.length];
     for (int i = 0; i < cipherSuites.length; i++) {
       result[i] = CipherSuite.forJavaName(cipherSuites[i]);
@@ -108,40 +118,120 @@ public boolean supportsTlsExtensions() {
     return supportsTlsExtensions;
   }
 
-  /** Applies this spec to {@code sslSocket} for {@code route}. */
-  void apply(SSLSocket sslSocket, Route route) {
-    ConnectionSpec specToApply = supportedSpec;
-    if (specToApply == null) {
-      specToApply = supportedSpec(sslSocket);
-      supportedSpec = specToApply;
-    }
+  /** Applies this spec to {@code sslSocket}. */
+  void apply(SSLSocket sslSocket, boolean isFallback) {
+    ConnectionSpec specToApply = supportedSpec(sslSocket, isFallback);
 
     sslSocket.setEnabledProtocols(specToApply.tlsVersions);
-    sslSocket.setEnabledCipherSuites(specToApply.cipherSuites);
 
-    Platform platform = Platform.get();
-    if (specToApply.supportsTlsExtensions) {
-      platform.configureTlsExtensions(sslSocket, route.address.uriHost, route.address.protocols);
+    String[] cipherSuitesToEnable = specToApply.cipherSuites;
+    // null means "use default set".
+    if (cipherSuitesToEnable != null) {
+      sslSocket.setEnabledCipherSuites(cipherSuitesToEnable);
     }
   }
 
   /**
-   * Returns a copy of this that omits cipher suites and TLS versions not
-   * supported by {@code sslSocket}.
+   * Returns a copy of this that omits cipher suites and TLS versions not enabled by
+   * {@code sslSocket}.
    */
-  private ConnectionSpec supportedSpec(SSLSocket sslSocket) {
-    List<String> supportedCipherSuites = Util.intersect(Arrays.asList(cipherSuites),
-        Arrays.asList(sslSocket.getSupportedCipherSuites()));
-    List<String> supportedTlsVersions = Util.intersect(Arrays.asList(tlsVersions),
-        Arrays.asList(sslSocket.getSupportedProtocols()));
+  private ConnectionSpec supportedSpec(SSLSocket sslSocket, boolean isFallback) {
+    String[] cipherSuitesToEnable = null;
+    if (cipherSuites != null) {
+      String[] cipherSuitesToSelectFrom = sslSocket.getEnabledCipherSuites();
+      cipherSuitesToEnable =
+          Util.intersect(String.class, cipherSuites, cipherSuitesToSelectFrom);
+    }
+
+    if (isFallback) {
+      // In accordance with https://tools.ietf.org/html/draft-ietf-tls-downgrade-scsv-00
+      // the SCSV cipher is added to signal that a protocol fallback has taken place.
+      final String fallbackScsv = "TLS_FALLBACK_SCSV";
+      boolean socketSupportsFallbackScsv =
+          Arrays.asList(sslSocket.getSupportedCipherSuites()).contains(fallbackScsv);
+
+      if (socketSupportsFallbackScsv) {
+        // Add the SCSV cipher to the set of enabled cipher suites iff it is supported.
+        String[] oldEnabledCipherSuites = cipherSuitesToEnable != null
+            ? cipherSuitesToEnable
+            : sslSocket.getEnabledCipherSuites();
+        String[] newEnabledCipherSuites = new String[oldEnabledCipherSuites.length + 1];
+        System.arraycopy(oldEnabledCipherSuites, 0,
+            newEnabledCipherSuites, 0, oldEnabledCipherSuites.length);
+        newEnabledCipherSuites[newEnabledCipherSuites.length - 1] = fallbackScsv;
+        cipherSuitesToEnable = newEnabledCipherSuites;
+      }
+    }
+
+    String[] protocolsToSelectFrom = sslSocket.getEnabledProtocols();
+    String[] protocolsToEnable = Util.intersect(String.class, tlsVersions, protocolsToSelectFrom);
     return new Builder(this)
-        .cipherSuites(supportedCipherSuites.toArray(new String[supportedCipherSuites.size()]))
-        .tlsVersions(supportedTlsVersions.toArray(new String[supportedTlsVersions.size()]))
+        .cipherSuites(cipherSuitesToEnable)
+        .tlsVersions(protocolsToEnable)
         .build();
   }
 
+  /**
+   * Returns {@code true} if the socket, as currently configured, supports this ConnectionSpec.
+   * In order for a socket to be compatible the enabled cipher suites and protocols must intersect.
+   *
+   * <p>For cipher suites, at least one of the {@link #cipherSuites() required cipher suites} must
+   * match the socket's enabled cipher suites. If there are no required cipher suites the socket
+   * must have at least one cipher suite enabled.
+   *
+   * <p>For protocols, at least one of the {@link #tlsVersions() required protocols} must match the
+   * socket's enabled protocols.
+   */
+  public boolean isCompatible(SSLSocket socket) {
+    if (!tls) {
+      return false;
+    }
+
+    String[] enabledProtocols = socket.getEnabledProtocols();
+    boolean requiredProtocolsEnabled = nonEmptyIntersection(tlsVersions, enabledProtocols);
+    if (!requiredProtocolsEnabled) {
+      return false;
+    }
+
+    boolean requiredCiphersEnabled;
+    if (cipherSuites == null) {
+      requiredCiphersEnabled = socket.getEnabledCipherSuites().length > 0;
+    } else {
+      String[] enabledCipherSuites = socket.getEnabledCipherSuites();
+      requiredCiphersEnabled = nonEmptyIntersection(cipherSuites, enabledCipherSuites);
+    }
+    return requiredCiphersEnabled;
+  }
+
+  /**
+   * An N*M intersection that terminates if any intersection is found. The sizes of both
+   * arguments are assumed to be so small, and the likelihood of an intersection so great, that it
+   * is not worth the CPU cost of sorting or the memory cost of hashing.
+   */
+  private static boolean nonEmptyIntersection(String[] a, String[] b) {
+    if (a == null || b == null || a.length == 0 || b.length == 0) {
+      return false;
+    }
+    for (String toFind : a) {
+      if (contains(b, toFind)) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  private static <T> boolean contains(T[] array, T value) {
+    for (T arrayValue : array) {
+      if (Util.equal(value, arrayValue)) {
+        return true;
+      }
+    }
+    return false;
+  }
+
   @Override public boolean equals(Object other) {
     if (!(other instanceof ConnectionSpec)) return false;
+    if (other == this) return true;
 
     ConnectionSpec that = (ConnectionSpec) other;
     if (this.tls != that.tls) return false;
@@ -167,7 +257,9 @@ private ConnectionSpec supportedSpec(SSLSocket sslSocket) {
 
   @Override public String toString() {
     if (tls) {
-      return "ConnectionSpec(cipherSuites=" + cipherSuites()
+      List<CipherSuite> cipherSuites = cipherSuites();
+      String cipherSuitesString = cipherSuites == null ? "[use default]" : cipherSuites.toString();
+      return "ConnectionSpec(cipherSuites=" + cipherSuitesString
           + ", tlsVersions=" + tlsVersions()
           + ", supportsTlsExtensions=" + supportsTlsExtensions
           + ")";
@@ -182,7 +274,7 @@ private ConnectionSpec supportedSpec(SSLSocket sslSocket) {
     private String[] tlsVersions;
     private boolean supportsTlsExtensions;
 
-    private Builder(boolean tls) {
+    Builder(boolean tls) {
       this.tls = tls;
     }
 
@@ -201,29 +293,48 @@ public Builder cipherSuites(CipherSuite... cipherSuites) {
       for (int i = 0; i < cipherSuites.length; i++) {
         strings[i] = cipherSuites[i].javaName;
       }
-
-      return cipherSuites(strings);
+      this.cipherSuites = strings;
+      return this;
     }
 
-    Builder cipherSuites(String[] cipherSuites) {
-      this.cipherSuites = cipherSuites; // No defensive copy.
+    public Builder cipherSuites(String... cipherSuites) {
+      if (!tls) throw new IllegalStateException("no cipher suites for cleartext connections");
+
+      if (cipherSuites == null) {
+        this.cipherSuites = null;
+      } else {
+        // This makes a defensive copy!
+        this.cipherSuites = cipherSuites.clone();
+      }
+
       return this;
     }
 
     public Builder tlsVersions(TlsVersion... tlsVersions) {
       if (!tls) throw new IllegalStateException("no TLS versions for cleartext connections");
+      if (tlsVersions.length == 0) {
+        throw new IllegalArgumentException("At least one TlsVersion is required");
+      }
 
       // Convert enums to the string names Java wants. This makes a defensive copy!
       String[] strings = new String[tlsVersions.length];
       for (int i = 0; i < tlsVersions.length; i++) {
         strings[i] = tlsVersions[i].javaName;
       }
-
-      return tlsVersions(strings);
+      this.tlsVersions = strings;
+      return this;
     }
 
-    Builder tlsVersions(String... tlsVersions) {
-      this.tlsVersions = tlsVersions; // No defensive copy.
+    public Builder tlsVersions(String... tlsVersions) {
+      if (!tls) throw new IllegalStateException("no TLS versions for cleartext connections");
+
+      if (tlsVersions == null) {
+        this.tlsVersions = null;
+      } else {
+        // This makes a defensive copy!
+        this.tlsVersions = tlsVersions.clone();
+      }
+
       return this;
     }
 
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java b/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java
index 95eb7b0ad3..a9346701fb 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java
@@ -22,7 +22,7 @@
 import java.util.Deque;
 import java.util.Iterator;
 import java.util.concurrent.ExecutorService;
-import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
 
@@ -59,7 +59,7 @@ public Dispatcher() {
   public synchronized ExecutorService getExecutorService() {
     if (executorService == null) {
       executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,
-          new LinkedBlockingQueue<Runnable>(), Util.threadFactory("OkHttp Dispatcher", false));
+          new SynchronousQueue<Runnable>(), Util.threadFactory("OkHttp Dispatcher", false));
     }
     return executorService;
   }
@@ -177,4 +177,12 @@ synchronized void executed(Call call) {
   synchronized void finished(Call call) {
     if (!executedCalls.remove(call)) throw new AssertionError("Call wasn't in-flight!");
   }
+
+  public synchronized int getRunningCallCount() {
+    return runningCalls.size();
+  }
+
+  public synchronized int getQueuedCallCount() {
+    return readyCalls.size();
+  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/FormEncodingBuilder.java b/okhttp/src/main/java/com/squareup/okhttp/FormEncodingBuilder.java
index 891fbff005..8a253dafcb 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/FormEncodingBuilder.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/FormEncodingBuilder.java
@@ -15,42 +15,48 @@
  */
 package com.squareup.okhttp;
 
-import com.squareup.okhttp.internal.Util;
-import java.io.UnsupportedEncodingException;
-import java.net.URLEncoder;
+import okio.Buffer;
 
 /**
  * Fluent API to build <a href="http://www.w3.org/MarkUp/html-spec/html-spec_8.html#SEC8.2.1">HTML
  * 2.0</a>-compliant form data.
  */
 public final class FormEncodingBuilder {
-  private static final MediaType CONTENT_TYPE
-      = MediaType.parse("application/x-www-form-urlencoded");
+  private static final MediaType CONTENT_TYPE =
+      MediaType.parse("application/x-www-form-urlencoded");
 
-  private final StringBuilder content = new StringBuilder();
+  private final Buffer content = new Buffer();
 
   /** Add new key-value pair. */
   public FormEncodingBuilder add(String name, String value) {
-    if (content.length() > 0) {
-      content.append('&');
+    if (content.size() > 0) {
+      content.writeByte('&');
     }
-    try {
-      content.append(URLEncoder.encode(name, "UTF-8"))
-          .append('=')
-          .append(URLEncoder.encode(value, "UTF-8"));
-    } catch (UnsupportedEncodingException e) {
-      throw new AssertionError(e);
+    HttpUrl.canonicalize(content, name, 0, name.length(),
+        HttpUrl.QUERY_COMPONENT_ENCODE_SET, false, true);
+    content.writeByte('=');
+    HttpUrl.canonicalize(content, value, 0, value.length(),
+        HttpUrl.QUERY_COMPONENT_ENCODE_SET, false, true);
+    return this;
+  }
+
+  /** Add new key-value pair. */
+  public FormEncodingBuilder addEncoded(String name, String value) {
+    if (content.size() > 0) {
+      content.writeByte('&');
     }
+    HttpUrl.canonicalize(content, name, 0, name.length(),
+        HttpUrl.QUERY_COMPONENT_ENCODE_SET, true, true);
+    content.writeByte('=');
+    HttpUrl.canonicalize(content, value, 0, value.length(),
+        HttpUrl.QUERY_COMPONENT_ENCODE_SET, true, true);
     return this;
   }
 
   public RequestBody build() {
-    if (content.length() == 0) {
+    if (content.size() == 0) {
       throw new IllegalStateException("Form encoded body must have at least one part.");
     }
-
-    // Convert to bytes so RequestBody.create() doesn't add a charset to the content-type.
-    byte[] contentBytes = content.toString().getBytes(Util.UTF_8);
-    return RequestBody.create(CONTENT_TYPE, contentBytes);
+    return RequestBody.create(CONTENT_TYPE, content.snapshot());
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Headers.java b/okhttp/src/main/java/com/squareup/okhttp/Headers.java
index c1bf0c5045..29d9dc82ca 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Headers.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Headers.java
@@ -19,10 +19,11 @@
 
 import com.squareup.okhttp.internal.http.HttpDate;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Collections;
 import java.util.Date;
+import java.util.LinkedHashMap;
 import java.util.List;
+import java.util.Map;
 import java.util.Set;
 import java.util.TreeSet;
 
@@ -96,7 +97,7 @@ public String value(int index) {
   /** Returns an immutable case-insensitive set of header names. */
   public Set<String> names() {
     TreeSet<String> result = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);
-    for (int i = 0; i < size(); i++) {
+    for (int i = 0, size = size(); i < size; i++) {
       result.add(name(i));
     }
     return Collections.unmodifiableSet(result);
@@ -105,7 +106,7 @@ public String value(int index) {
   /** Returns an immutable list of the header values for {@code name}. */
   public List<String> values(String name) {
     List<String> result = null;
-    for (int i = 0; i < size(); i++) {
+    for (int i = 0, size = size(); i < size; i++) {
       if (name.equalsIgnoreCase(name(i))) {
         if (result == null) result = new ArrayList<>(2);
         result.add(value(i));
@@ -118,18 +119,32 @@ public String value(int index) {
 
   public Builder newBuilder() {
     Builder result = new Builder();
-    result.namesAndValues.addAll(Arrays.asList(namesAndValues));
+    Collections.addAll(result.namesAndValues, namesAndValues);
     return result;
   }
 
   @Override public String toString() {
     StringBuilder result = new StringBuilder();
-    for (int i = 0; i < size(); i++) {
+    for (int i = 0, size = size(); i < size; i++) {
       result.append(name(i)).append(": ").append(value(i)).append("\n");
     }
     return result.toString();
   }
 
+  public Map<String, List<String>> toMultimap() {
+    Map<String, List<String>> result = new LinkedHashMap<String, List<String>>();
+    for (int i = 0, size = size(); i < size; i++) {
+      String name = name(i);
+      List<String> values = result.get(name);
+      if (values == null) {
+        values = new ArrayList<>(2);
+        result.put(name, values);
+      }
+      values.add(value(i));
+    }
+    return result;
+  }
+
   private static String get(String[] namesAndValues, String name) {
     for (int i = namesAndValues.length - 2; i >= 0; i -= 2) {
       if (name.equalsIgnoreCase(namesAndValues[i])) {
@@ -168,11 +183,42 @@ public static Headers of(String... namesAndValues) {
     return new Headers(namesAndValues);
   }
 
+  /**
+   * Returns headers for the header names and values in the {@link Map}.
+   */
+  public static Headers of(Map<String, String> headers) {
+    if (headers == null) {
+      throw new IllegalArgumentException("Expected map with header names and values");
+    }
+
+    // Make a defensive copy and clean it up.
+    String[] namesAndValues = new String[headers.size() * 2];
+    int i = 0;
+    for (Map.Entry<String, String> header : headers.entrySet()) {
+      if (header.getKey() == null || header.getValue() == null) {
+        throw new IllegalArgumentException("Headers cannot be null");
+      }
+      String name = header.getKey().trim();
+      String value = header.getValue().trim();
+      if (name.length() == 0 || name.indexOf('\0') != -1 || value.indexOf('\0') != -1) {
+        throw new IllegalArgumentException("Unexpected header: " + name + ": " + value);
+      }
+      namesAndValues[i] = name;
+      namesAndValues[i + 1] = value;
+      i += 2;
+    }
+
+    return new Headers(namesAndValues);
+  }
+
   public static final class Builder {
     private final List<String> namesAndValues = new ArrayList<>(20);
 
-    /** Add an header line containing a field name, a literal colon, and a value. */
-    Builder addLine(String line) {
+    /**
+     * Add a header line without any validation. Only appropriate for headers from the remote peer
+     * or cache.
+     */
+    Builder addLenient(String line) {
       int index = line.indexOf(":", 1);
       if (index != -1) {
         return addLenient(line.substring(0, index), line.substring(index + 1));
@@ -185,6 +231,15 @@ Builder addLine(String line) {
       }
     }
 
+    /** Add an header line containing a field name, a literal colon, and a value. */
+    public Builder add(String line) {
+      int index = line.indexOf(":");
+      if (index == -1) {
+        throw new IllegalArgumentException("Unexpected header: " + line);
+      }
+      return add(line.substring(0, index).trim(), line.substring(index + 1));
+    }
+
     /** Add a field with the specified value. */
     public Builder add(String name, String value) {
       if (name == null) throw new IllegalArgumentException("name == null");
@@ -197,9 +252,9 @@ public Builder add(String name, String value) {
 
     /**
      * Add a field with the specified value without any validation. Only
-     * appropriate for headers from the remote peer.
+     * appropriate for headers from the remote peer or cache.
      */
-    private Builder addLenient(String name, String value) {
+    Builder addLenient(String name, String value) {
       namesAndValues.add(name);
       namesAndValues.add(value.trim());
       return this;
diff --git a/okhttp/src/main/java/com/squareup/okhttp/HttpUrl.java b/okhttp/src/main/java/com/squareup/okhttp/HttpUrl.java
new file mode 100644
index 0000000000..795bd75b16
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/HttpUrl.java
@@ -0,0 +1,1474 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import java.net.IDN;
+import java.net.InetAddress;
+import java.net.MalformedURLException;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.net.URL;
+import java.net.UnknownHostException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Locale;
+import java.util.Set;
+import okio.Buffer;
+
+/**
+ * A uniform resource locator (URL) with a scheme of either {@code http} or {@code https}. Use this
+ * class to compose and decompose Internet addresses. For example, this code will compose and print
+ * a URL for Google search: <pre>   {@code
+ *
+ *   HttpUrl url = new HttpUrl.Builder()
+ *       .scheme("https")
+ *       .host("www.google.com")
+ *       .addPathSegment("search")
+ *       .addQueryParameter("q", "polar bears")
+ *       .build();
+ *   System.out.println(url);
+ * }</pre>
+ *
+ * which prints: <pre>   {@code
+ *
+ *     https://www.google.com/search?q=polar%20bears
+ * }</pre>
+ *
+ * As another example, this code prints the human-readable query parameters of a Twitter search:
+ * <pre>   {@code
+ *
+ *   HttpUrl url = HttpUrl.parse("https://twitter.com/search?q=cute%20%23puppies&f=images");
+ *   for (int i = 0, size = url.querySize(); i < size; i++) {
+ *     System.out.println(url.queryParameterName(i) + ": " + url.queryParameterValue(i));
+ *   }
+ * }</pre>
+ *
+ * which prints: <pre>   {@code
+ *
+ *   q: cute #puppies
+ *   f: images
+ * }</pre>
+ *
+ * In addition to composing URLs from their component parts and decomposing URLs into their
+ * component parts, this class implements relative URL resolution: what address you'd reach by
+ * clicking a relative link on a specified page. For example: <pre>   {@code
+ *
+ *   HttpUrl base = HttpUrl.parse("https://www.youtube.com/user/WatchTheDaily/videos");
+ *   HttpUrl link = base.resolve("../../watch?v=cbP2N1BQdYc");
+ *   System.out.println(link);
+ * }</pre>
+ *
+ * which prints: <pre>   {@code
+ *
+ *   https://www.youtube.com/watch?v=cbP2N1BQdYc
+ * }</pre>
+ *
+ * <h3>What's in a URL?</h3>
+ *
+ * A URL has several components.
+ *
+ * <h4>Scheme</h4>
+ * Sometimes referred to as <i>protocol</i>, A URL's scheme describes what mechanism should be used
+ * to retrieve the resource. Although URLs have many schemes ({@code mailto}, {@code file}, {@code
+ * ftp}), this class only supports {@code http} and {@code https}. Use {@link URI java.net.URI} for
+ * URLs with arbitrary schemes.
+ *
+ * <h4>Username and Password</h4>
+ * Username and password are either present, or the empty string {@code ""} if absent. This class
+ * offers no mechanism to differentiate empty from absent. Neither of these components are popular
+ * in practice. Typically HTTP applications use other mechanisms for user identification and
+ * authentication.
+ *
+ * <h4>Host</h4>
+ * The host identifies the webserver that serves the URL's resource. It is either a hostname like
+ * {@code square.com} or {@code localhost}, an IPv4 address like {@code 192.168.0.1}, or an IPv6
+ * address like {@code ::1}.
+ *
+ * <p>Usually a webserver is reachable with multiple identifiers: its IP addresses, registered
+ * domain names, and even {@code localhost} when connecting from the server itself. Each of a
+ * webserver's names is a distinct URL and they are not interchangeable. For example, even if
+ * {@code http://square.github.io/dagger} and {@code http://google.github.io/dagger} are served by
+ * the same IP address, the two URLs identify different resources.
+ *
+ * <h4>Port</h4>
+ * The port used to connect to the webserver. By default this is 80 for HTTP and 443 for HTTPS. This
+ * class never returns -1 for the port: if no port is explicitly specified in the URL then the
+ * scheme's default is used.
+ *
+ * <h4>Path</h4>
+ * The path identifies a specific resource on the host. Paths have a hierarchical structure like
+ * "/square/okhttp/issues/1486". Each path segment is prefixed with "/". This class offers methods
+ * to compose and decompose paths by segment. If a path's last segment is the empty string, then the
+ * path ends with "/". This class always builds non-empty paths: if the path is omitted it defaults
+ * to "/", which is a path whose only segment is the empty string.
+ *
+ * <h4>Query</h4>
+ * The query is optional: it can be null, empty, or non-empty. For many HTTP URLs the query string
+ * is subdivided into a collection of name-value parameters. This class offers methods to set the
+ * query as the single string, or as individual name-value parameters. With name-value parameters
+ * the values are optional and names may be repeated.
+ *
+ * <h4>Fragment</h4>
+ * The fragment is optional: it can be null, empty, or non-empty. Unlike host, port, path, and query
+ * the fragment is not sent to the webserver: it's private to the client.
+ *
+ * <h3>Encoding</h3>
+ * Each component must be encoded before it is embedded in the complete URL. As we saw above, the
+ * string {@code cute #puppies} is encoded as {@code cute%20%23puppies} when used as a query
+ * parameter value.
+ *
+ * <h4>Percent encoding</h4>
+ * Percent encoding replaces a character (like {@code \ud83c\udf69}) with its UTF-8 hex bytes (like
+ * {@code %F0%9F%8D%A9}). This approach works for whitespace characters, control characters,
+ * non-ASCII characters, and characters that already have another meaning in a particular context.
+ *
+ * <p>Percent encoding is used in every URL component except for the hostname. But the set of
+ * characters that need to be encoded is different for each component. For example, the path
+ * component must escape all of its {@code ?} characters, otherwise it could be interpreted as the
+ * start of the URL's query. But within the query and fragment components, the {@code ?} character
+ * doesn't delimit anything and doesn't need to be escaped. <pre>   {@code
+ *
+ *   HttpUrl url = HttpUrl.parse("http://who-let-the-dogs.out").newBuilder()
+ *       .addPathSegment("_Who?_")
+ *       .query("_Who?_")
+ *       .fragment("_Who?_")
+ *       .build();
+ *   System.out.println(url);
+ * }</pre>
+ *
+ * This prints: <pre>   {@code
+ *
+ *   http://who-let-the-dogs.out/_Who%3F_?_Who?_#_Who?_
+ * }</pre>
+ *
+ * When parsing URLs that lack percent encoding where it is required, this class will percent encode
+ * the offending characters.
+ *
+ * <h4>IDNA Mapping and Punycode encoding</h4>
+ * Hostnames have different requirements and use a different encoding scheme. It consists of IDNA
+ * mapping and Punycode encoding.
+ *
+ * <p>In order to avoid confusion and discourage phishing attacks,
+ * <a href="http://www.unicode.org/reports/tr46/#ToASCII">IDNA Mapping</a> transforms names to avoid
+ * confusing characters. This includes basic case folding: transforming shouting {@code SQUARE.COM}
+ * into cool and casual {@code square.com}. It also handles more exotic characters. For example, the
+ * Unicode trademark sign (™) could be confused for the letters "TM" in {@code http://ho™mail.com}.
+ * To mitigate this, the single character (™) maps to the string (tm). There is similar policy for
+ * all of the 1.1 million Unicode code points. Note that some code points such as "\ud83c\udf69" are
+ * not mapped and cannot be used in a hostname.
+ *
+ * <p><a href="http://ietf.org/rfc/rfc3492.txt">Punycode</a> converts a Unicode string to an ASCII
+ * string to make international domain names work everywhere. For example, "σ" encodes as
+ * "xn--4xa". The encoded string is not human readable, but can be used with classes like {@link
+ * InetAddress} to establish connections.
+ *
+ * <h3>Why another URL model?</h3>
+ * Java includes both {@link URL java.net.URL} and {@link URI java.net.URI}. We offer a new URL
+ * model to address problems that the others don't.
+ *
+ * <h4>Different URLs should be different</h4>
+ * Although they have different content, {@code java.net.URL} considers the following two URLs
+ * equal, and the {@link Object#equals equals()} method between them returns true:
+ * <ul>
+ *   <li>http://square.github.io/
+ *   <li>http://google.github.io/
+ * </ul>
+ * This is because those two hosts share the same IP address. This is an old, bad design decision
+ * that makes {@code java.net.URL} unusable for many things. It shouldn't be used as a {@link
+ * java.util.Map Map} key or in a {@link Set}. Doing so is both inefficient because equality may
+ * require a DNS lookup, and incorrect because unequal URLs may be equal because of how they are
+ * hosted.
+ *
+ * <h4>Equal URLs should be equal</h4>
+ * These two URLs are semantically identical, but {@code java.net.URI} disagrees:
+ * <ul>
+ *   <li>http://host:80/
+ *   <li>http://host
+ * </ul>
+ * Both the unnecessary port specification ({@code :80}) and the absent trailing slash ({@code /})
+ * cause URI to bucket the two URLs separately. This harms URI's usefulness in collections. Any
+ * application that stores information-per-URL will need to either canonicalize manually, or suffer
+ * unnecessary redundancy for such URLs.
+ *
+ * <p>Because they don't attempt canonical form, these classes are surprisingly difficult to use
+ * securely. Suppose you're building a webservice that checks that incoming paths are prefixed
+ * "/static/images/" before serving the corresponding assets from the filesystem. <pre>   {@code
+ *
+ *   String attack = "http://example.com/static/images/../../../../../etc/passwd";
+ *   System.out.println(new URL(attack).getPath());
+ *   System.out.println(new URI(attack).getPath());
+ *   System.out.println(HttpUrl.parse(attack).path());
+ * }</pre>
+ *
+ * By canonicalizing the input paths, they are complicit in directory traversal attacks. Code that
+ * checks only the path prefix may suffer!
+ * <pre>   {@code
+ *
+ *    /static/images/../../../../../etc/passwd
+ *    /static/images/../../../../../etc/passwd
+ *    /etc/passwd
+ * }</pre>
+ *
+ * <h4>If it works on the web, it should work in your application</h4>
+ * The {@code java.net.URI} class is strict around what URLs it accepts. It rejects URLs like
+ * "http://example.com/abc|def" because the '|' character is unsupported. This class is more
+ * forgiving: it will automatically percent-encode the '|', yielding "http://example.com/abc%7Cdef".
+ * This kind behavior is consistent with web browsers. {@code HttpUrl} prefers consistency with
+ * major web browsers over consistency with obsolete specifications.
+ *
+ * <h4>Paths and Queries should decompose</h4>
+ * Neither of the built-in URL models offer direct access to path segments or query parameters.
+ * Manually using {@code StringBuilder} to assemble these components is cumbersome: do '+'
+ * characters get silently replaced with spaces? If a query parameter contains a '&amp;', does that
+ * get escaped? By offering methods to read and write individual query parameters directly,
+ * application developers are saved from the hassles of encoding and decoding.
+ *
+ * <h4>Plus a modern API</h4>
+ * The URL (JDK1.0) and URI (Java 1.4) classes predate builders and instead use telescoping
+ * constructors. For example, there's no API to compose a URI with a custom port without also
+ * providing a query and fragment.
+ *
+ * <p>Instances of {@link HttpUrl} are well-formed and always have a scheme, host, and path. With
+ * {@code java.net.URL} it's possible to create an awkward URL like {@code http:/} with scheme and
+ * path but no hostname. Building APIs that consume such malformed values is difficult!
+ *
+ * <p>This class has a modern API. It avoids punitive checked exceptions: {@link #parse parse()}
+ * returns null if the input is an invalid URL. You can even be explicit about whether each
+ * component has been encoded already.
+ */
+public final class HttpUrl {
+  private static final char[] HEX_DIGITS =
+      { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
+  static final String USERNAME_ENCODE_SET = " \"':;<=>@[]^`{}|/\\?#";
+  static final String PASSWORD_ENCODE_SET = " \"':;<=>@[]\\^`{}|/\\?#";
+  static final String PATH_SEGMENT_ENCODE_SET = " \"<>^`{}|/\\?#";
+  static final String QUERY_ENCODE_SET = " \"'<>#";
+  static final String QUERY_COMPONENT_ENCODE_SET = " \"'<>#&=";
+  static final String FRAGMENT_ENCODE_SET = "";
+
+  /** Either "http" or "https". */
+  private final String scheme;
+
+  /** Decoded username. */
+  private final String username;
+
+  /** Decoded password. */
+  private final String password;
+
+  /** Canonical hostname. */
+  private final String host;
+
+  /** Either 80, 443 or a user-specified port. In range [1..65535]. */
+  private final int port;
+
+  /**
+   * A list of canonical path segments. This list always contains at least one element, which may
+   * be the empty string. Each segment is formatted with a leading '/', so if path segments were
+   * ["a", "b", ""], then the encoded path would be "/a/b/".
+   */
+  private final List<String> pathSegments;
+
+  /**
+   * Alternating, decoded query names and values, or null for no query. Names may be empty or
+   * non-empty, but never null. Values are null if the name has no corresponding '=' separator, or
+   * empty, or non-empty.
+   */
+  private final List<String> queryNamesAndValues;
+
+  /** Decoded fragment. */
+  private final String fragment;
+
+  /** Canonical URL. */
+  private final String url;
+
+  private HttpUrl(Builder builder) {
+    this.scheme = builder.scheme;
+    this.username = percentDecode(builder.encodedUsername);
+    this.password = percentDecode(builder.encodedPassword);
+    this.host = builder.host;
+    this.port = builder.effectivePort();
+    this.pathSegments = percentDecode(builder.encodedPathSegments);
+    this.queryNamesAndValues = builder.encodedQueryNamesAndValues != null
+        ? percentDecode(builder.encodedQueryNamesAndValues)
+        : null;
+    this.fragment = builder.encodedFragment != null
+        ? percentDecode(builder.encodedFragment)
+        : null;
+    this.url = builder.toString();
+  }
+
+  /** Returns this URL as a {@link URL java.net.URL}. */
+  public URL url() {
+    try {
+      return new URL(url);
+    } catch (MalformedURLException e) {
+      throw new RuntimeException(e); // Unexpected!
+    }
+  }
+
+  /**
+   * Attempt to convert this URL to a {@link URI java.net.URI}. This method throws an unchecked
+   * {@link IllegalStateException} if the URL it holds isn't valid by URI's overly-stringent
+   * standard. For example, URI rejects paths containing the '[' character. Consult that class for
+   * the exact rules of what URLs are permitted.
+   */
+  public URI uri() {
+    try {
+      return new URI(url);
+    } catch (URISyntaxException e) {
+      throw new IllegalStateException("not valid as a java.net.URI: " + url);
+    }
+  }
+
+  /** Returns either "http" or "https". */
+  public String scheme() {
+    return scheme;
+  }
+
+  public boolean isHttps() {
+    return scheme.equals("https");
+  }
+
+  /** Returns the username, or an empty string if none is set. */
+  public String encodedUsername() {
+    if (username.isEmpty()) return "";
+    int usernameStart = scheme.length() + 3; // "://".length() == 3.
+    int usernameEnd = delimiterOffset(url, usernameStart, url.length(), ":@");
+    return url.substring(usernameStart, usernameEnd);
+  }
+
+  public String username() {
+    return username;
+  }
+
+  /** Returns the password, or an empty string if none is set. */
+  public String encodedPassword() {
+    if (password.isEmpty()) return "";
+    int passwordStart = url.indexOf(':', scheme.length() + 3) + 1;
+    int passwordEnd = url.indexOf('@');
+    return url.substring(passwordStart, passwordEnd);
+  }
+
+  /** Returns the decoded password, or an empty string if none is present. */
+  public String password() {
+    return password;
+  }
+
+  /**
+   * Returns the host address suitable for use with {@link InetAddress#getAllByName(String)}. May
+   * be:
+   * <ul>
+   *   <li>A regular host name, like {@code android.com}.
+   *   <li>An IPv4 address, like {@code 127.0.0.1}.
+   *   <li>An IPv6 address, like {@code ::1}. Note that there are no square braces.
+   *   <li>An encoded IDN, like {@code xn--n3h.net}.
+   * </ul>
+   */
+  public String host() {
+    return host;
+  }
+
+  /**
+   * Returns the explicitly-specified port if one was provided, or the default port for this URL's
+   * scheme. For example, this returns 8443 for {@code https://square.com:8443/} and 443 for {@code
+   * https://square.com/}. The result is in {@code [1..65535]}.
+   */
+  public int port() {
+    return port;
+  }
+
+  /**
+   * Returns 80 if {@code scheme.equals("http")}, 443 if {@code scheme.equals("https")} and -1
+   * otherwise.
+   */
+  public static int defaultPort(String scheme) {
+    if (scheme.equals("http")) {
+      return 80;
+    } else if (scheme.equals("https")) {
+      return 443;
+    } else {
+      return -1;
+    }
+  }
+
+  public int pathSize() {
+    return pathSegments.size();
+  }
+
+  /**
+   * Returns the entire path of this URL, encoded for use in HTTP resource resolution. The
+   * returned path is always nonempty and is prefixed with {@code /}.
+   */
+  public String encodedPath() {
+    int pathStart = url.indexOf('/', scheme.length() + 3); // "://".length() == 3.
+    int pathEnd = delimiterOffset(url, pathStart, url.length(), "?#");
+    return url.substring(pathStart, pathEnd);
+  }
+
+  static void pathSegmentsToString(StringBuilder out, List<String> pathSegments) {
+    for (int i = 0, size = pathSegments.size(); i < size; i++) {
+      out.append('/');
+      out.append(pathSegments.get(i));
+    }
+  }
+
+  public List<String> encodedPathSegments() {
+    int pathStart = url.indexOf('/', scheme.length() + 3);
+    int pathEnd = delimiterOffset(url, pathStart, url.length(), "?#");
+    List<String> result = new ArrayList<>();
+    for (int i = pathStart; i < pathEnd; ) {
+      i++; // Skip the '/'.
+      int segmentEnd = delimiterOffset(url, i, pathEnd, "/");
+      result.add(url.substring(i, segmentEnd));
+      i = segmentEnd;
+    }
+    return result;
+  }
+
+  public List<String> pathSegments() {
+    return pathSegments;
+  }
+
+  /**
+   * Returns the query of this URL, encoded for use in HTTP resource resolution. The returned string
+   * may be null (for URLs with no query), empty (for URLs with an empty query) or non-empty (all
+   * other URLs).
+   */
+  public String encodedQuery() {
+    if (queryNamesAndValues == null) return null; // No query.
+    int queryStart = url.indexOf('?') + 1;
+    int queryEnd = delimiterOffset(url, queryStart + 1, url.length(), "#");
+    return url.substring(queryStart, queryEnd);
+  }
+
+  static void namesAndValuesToQueryString(StringBuilder out, List<String> namesAndValues) {
+    for (int i = 0, size = namesAndValues.size(); i < size; i += 2) {
+      String name = namesAndValues.get(i);
+      String value = namesAndValues.get(i + 1);
+      if (i > 0) out.append('&');
+      out.append(name);
+      if (value != null) {
+        out.append('=');
+        out.append(value);
+      }
+    }
+  }
+
+  /**
+   * Cuts {@code encodedQuery} up into alternating parameter names and values. This divides a
+   * query string like {@code subject=math&easy&problem=5-2=3} into the list {@code ["subject",
+   * "math", "easy", null, "problem", "5-2=3"]}. Note that values may be null and may contain
+   * '=' characters.
+   */
+  static List<String> queryStringToNamesAndValues(String encodedQuery) {
+    List<String> result = new ArrayList<>();
+    for (int pos = 0; pos <= encodedQuery.length(); ) {
+      int ampersandOffset = encodedQuery.indexOf('&', pos);
+      if (ampersandOffset == -1) ampersandOffset = encodedQuery.length();
+
+      int equalsOffset = encodedQuery.indexOf('=', pos);
+      if (equalsOffset == -1 || equalsOffset > ampersandOffset) {
+        result.add(encodedQuery.substring(pos, ampersandOffset));
+        result.add(null); // No value for this name.
+      } else {
+        result.add(encodedQuery.substring(pos, equalsOffset));
+        result.add(encodedQuery.substring(equalsOffset + 1, ampersandOffset));
+      }
+      pos = ampersandOffset + 1;
+    }
+    return result;
+  }
+
+  public String query() {
+    if (queryNamesAndValues == null) return null; // No query.
+    StringBuilder result = new StringBuilder();
+    namesAndValuesToQueryString(result, queryNamesAndValues);
+    return result.toString();
+  }
+
+  public int querySize() {
+    return queryNamesAndValues != null ? queryNamesAndValues.size() / 2 : 0;
+  }
+
+  /**
+   * Returns the first query parameter named {@code name} decoded using UTF-8, or null if there is
+   * no such query parameter.
+   */
+  public String queryParameter(String name) {
+    if (queryNamesAndValues == null) return null;
+    for (int i = 0, size = queryNamesAndValues.size(); i < size; i += 2) {
+      if (name.equals(queryNamesAndValues.get(i))) {
+        return queryNamesAndValues.get(i + 1);
+      }
+    }
+    return null;
+  }
+
+  public Set<String> queryParameterNames() {
+    if (queryNamesAndValues == null) return Collections.emptySet();
+    Set<String> result = new LinkedHashSet<>();
+    for (int i = 0, size = queryNamesAndValues.size(); i < size; i += 2) {
+      result.add(queryNamesAndValues.get(i));
+    }
+    return Collections.unmodifiableSet(result);
+  }
+
+  public List<String> queryParameterValues(String name) {
+    if (queryNamesAndValues == null) return Collections.emptyList();
+    List<String> result = new ArrayList<>();
+    for (int i = 0, size = queryNamesAndValues.size(); i < size; i += 2) {
+      if (name.equals(queryNamesAndValues.get(i))) {
+        result.add(queryNamesAndValues.get(i + 1));
+      }
+    }
+    return Collections.unmodifiableList(result);
+  }
+
+  public String queryParameterName(int index) {
+    return queryNamesAndValues.get(index * 2);
+  }
+
+  public String queryParameterValue(int index) {
+    return queryNamesAndValues.get(index * 2 + 1);
+  }
+
+  public String encodedFragment() {
+    if (fragment == null) return null;
+    int fragmentStart = url.indexOf('#') + 1;
+    return url.substring(fragmentStart);
+  }
+
+  public String fragment() {
+    return fragment;
+  }
+
+  /** Returns the URL that would be retrieved by following {@code link} from this URL. */
+  public HttpUrl resolve(String link) {
+    return new Builder().parse(this, link);
+  }
+
+  public Builder newBuilder() {
+    Builder result = new Builder();
+    result.scheme = scheme;
+    result.encodedUsername = encodedUsername();
+    result.encodedPassword = encodedPassword();
+    result.host = host;
+    result.port = port;
+    result.encodedPathSegments.clear();
+    result.encodedPathSegments.addAll(encodedPathSegments());
+    result.encodedQuery(encodedQuery());
+    result.encodedFragment = encodedFragment();
+    return result;
+  }
+
+  /**
+   * Returns a new {@code OkUrl} representing {@code url} if it is a well-formed HTTP or HTTPS URL,
+   * or null if it isn't.
+   */
+  public static HttpUrl parse(String url) {
+    return new Builder().parse(null, url);
+  }
+
+  /**
+   * Returns an {@link HttpUrl} for {@code url} if its protocol is {@code http} or {@code https}, or
+   * null if it has any other protocol.
+   */
+  public static HttpUrl get(URL url) {
+    return parse(url.toString());
+  }
+
+  public static HttpUrl get(URI uri) {
+    return parse(uri.toString());
+  }
+
+  @Override public boolean equals(Object o) {
+    return o instanceof HttpUrl && ((HttpUrl) o).url.equals(url);
+  }
+
+  @Override public int hashCode() {
+    return url.hashCode();
+  }
+
+  @Override public String toString() {
+    return url;
+  }
+
+  public static final class Builder {
+    String scheme;
+    String encodedUsername = "";
+    String encodedPassword = "";
+    String host;
+    int port = -1;
+    final List<String> encodedPathSegments = new ArrayList<>();
+    List<String> encodedQueryNamesAndValues;
+    String encodedFragment;
+
+    public Builder() {
+      encodedPathSegments.add(""); // The default path is '/' which needs a trailing space.
+    }
+
+    public Builder scheme(String scheme) {
+      if (scheme == null) {
+        throw new IllegalArgumentException("scheme == null");
+      } else if (scheme.equalsIgnoreCase("http")) {
+        this.scheme = "http";
+      } else if (scheme.equalsIgnoreCase("https")) {
+        this.scheme = "https";
+      } else {
+        throw new IllegalArgumentException("unexpected scheme: " + scheme);
+      }
+      return this;
+    }
+
+    public Builder username(String username) {
+      if (username == null) throw new IllegalArgumentException("username == null");
+      this.encodedUsername = canonicalize(username, USERNAME_ENCODE_SET, false, false);
+      return this;
+    }
+
+    public Builder encodedUsername(String encodedUsername) {
+      if (encodedUsername == null) throw new IllegalArgumentException("encodedUsername == null");
+      this.encodedUsername = canonicalize(encodedUsername, USERNAME_ENCODE_SET, true, false);
+      return this;
+    }
+
+    public Builder password(String password) {
+      if (password == null) throw new IllegalArgumentException("password == null");
+      this.encodedPassword = canonicalize(password, PASSWORD_ENCODE_SET, false, false);
+      return this;
+    }
+
+    public Builder encodedPassword(String encodedPassword) {
+      if (encodedPassword == null) throw new IllegalArgumentException("encodedPassword == null");
+      this.encodedPassword = canonicalize(encodedPassword, PASSWORD_ENCODE_SET, true, false);
+      return this;
+    }
+
+    /**
+     * @param host either a regular hostname, International Domain Name, IPv4 address, or IPv6
+     *     address.
+     */
+    public Builder host(String host) {
+      if (host == null) throw new IllegalArgumentException("host == null");
+      String encoded = canonicalizeHost(host, 0, host.length());
+      if (encoded == null) throw new IllegalArgumentException("unexpected host: " + host);
+      this.host = encoded;
+      return this;
+    }
+
+    public Builder port(int port) {
+      if (port <= 0 || port > 65535) throw new IllegalArgumentException("unexpected port: " + port);
+      this.port = port;
+      return this;
+    }
+
+    int effectivePort() {
+      return port != -1 ? port : defaultPort(scheme);
+    }
+
+    public Builder addPathSegment(String pathSegment) {
+      if (pathSegment == null) throw new IllegalArgumentException("pathSegment == null");
+      push(pathSegment, 0, pathSegment.length(), false, false);
+      return this;
+    }
+
+    public Builder addEncodedPathSegment(String encodedPathSegment) {
+      if (encodedPathSegment == null) {
+        throw new IllegalArgumentException("encodedPathSegment == null");
+      }
+      push(encodedPathSegment, 0, encodedPathSegment.length(), false, true);
+      return this;
+    }
+
+    public Builder setPathSegment(int index, String pathSegment) {
+      if (pathSegment == null) throw new IllegalArgumentException("pathSegment == null");
+      String canonicalPathSegment = canonicalize(
+          pathSegment, 0, pathSegment.length(), PATH_SEGMENT_ENCODE_SET, false, false);
+      if (isDot(canonicalPathSegment) || isDotDot(canonicalPathSegment)) {
+        throw new IllegalArgumentException("unexpected path segment: " + pathSegment);
+      }
+      encodedPathSegments.set(index, canonicalPathSegment);
+      return this;
+    }
+
+    public Builder setEncodedPathSegment(int index, String encodedPathSegment) {
+      if (encodedPathSegment == null) {
+        throw new IllegalArgumentException("encodedPathSegment == null");
+      }
+      String canonicalPathSegment = canonicalize(encodedPathSegment,
+          0, encodedPathSegment.length(), PATH_SEGMENT_ENCODE_SET, true, false);
+      encodedPathSegments.set(index, canonicalPathSegment);
+      if (isDot(canonicalPathSegment) || isDotDot(canonicalPathSegment)) {
+        throw new IllegalArgumentException("unexpected path segment: " + encodedPathSegment);
+      }
+      return this;
+    }
+
+    public Builder removePathSegment(int index) {
+      encodedPathSegments.remove(index);
+      if (encodedPathSegments.isEmpty()) {
+        encodedPathSegments.add(""); // Always leave at least one '/'.
+      }
+      return this;
+    }
+
+    public Builder encodedPath(String encodedPath) {
+      if (encodedPath == null) throw new IllegalArgumentException("encodedPath == null");
+      if (!encodedPath.startsWith("/")) {
+        throw new IllegalArgumentException("unexpected encodedPath: " + encodedPath);
+      }
+      resolvePath(encodedPath, 0, encodedPath.length());
+      return this;
+    }
+
+    public Builder query(String query) {
+      this.encodedQueryNamesAndValues = query != null
+          ? queryStringToNamesAndValues(canonicalize(query, QUERY_ENCODE_SET, false, true))
+          : null;
+      return this;
+    }
+
+    public Builder encodedQuery(String encodedQuery) {
+      this.encodedQueryNamesAndValues = encodedQuery != null
+          ? queryStringToNamesAndValues(canonicalize(encodedQuery, QUERY_ENCODE_SET, true, true))
+          : null;
+      return this;
+    }
+
+    /** Encodes the query parameter using UTF-8 and adds it to this URL's query string. */
+    public Builder addQueryParameter(String name, String value) {
+      if (name == null) throw new IllegalArgumentException("name == null");
+      if (encodedQueryNamesAndValues == null) encodedQueryNamesAndValues = new ArrayList<>();
+      encodedQueryNamesAndValues.add(canonicalize(name, QUERY_COMPONENT_ENCODE_SET, false, true));
+      encodedQueryNamesAndValues.add(value != null
+          ? canonicalize(value, QUERY_COMPONENT_ENCODE_SET, false, true)
+          : null);
+      return this;
+    }
+
+    /** Adds the pre-encoded query parameter to this URL's query string. */
+    public Builder addEncodedQueryParameter(String encodedName, String encodedValue) {
+      if (encodedName == null) throw new IllegalArgumentException("encodedName == null");
+      if (encodedQueryNamesAndValues == null) encodedQueryNamesAndValues = new ArrayList<>();
+      encodedQueryNamesAndValues.add(
+          canonicalize(encodedName, QUERY_COMPONENT_ENCODE_SET, true, true));
+      encodedQueryNamesAndValues.add(encodedValue != null
+          ? canonicalize(encodedValue, QUERY_COMPONENT_ENCODE_SET, true, true)
+          : null);
+      return this;
+    }
+
+    public Builder setQueryParameter(String name, String value) {
+      removeAllQueryParameters(name);
+      addQueryParameter(name, value);
+      return this;
+    }
+
+    public Builder setEncodedQueryParameter(String encodedName, String encodedValue) {
+      removeAllEncodedQueryParameters(encodedName);
+      addEncodedQueryParameter(encodedName, encodedValue);
+      return this;
+    }
+
+    public Builder removeAllQueryParameters(String name) {
+      if (name == null) throw new IllegalArgumentException("name == null");
+      if (encodedQueryNamesAndValues == null) return this;
+      String nameToRemove = canonicalize(name, QUERY_COMPONENT_ENCODE_SET, false, true);
+      removeAllCanonicalQueryParameters(nameToRemove);
+      return this;
+    }
+
+    public Builder removeAllEncodedQueryParameters(String encodedName) {
+      if (encodedName == null) throw new IllegalArgumentException("encodedName == null");
+      if (encodedQueryNamesAndValues == null) return this;
+      removeAllCanonicalQueryParameters(
+          canonicalize(encodedName, QUERY_COMPONENT_ENCODE_SET, true, true));
+      return this;
+    }
+
+    private void removeAllCanonicalQueryParameters(String canonicalName) {
+      for (int i = encodedQueryNamesAndValues.size() - 2; i >= 0; i -= 2) {
+        if (canonicalName.equals(encodedQueryNamesAndValues.get(i))) {
+          encodedQueryNamesAndValues.remove(i + 1);
+          encodedQueryNamesAndValues.remove(i);
+          if (encodedQueryNamesAndValues.isEmpty()) {
+            encodedQueryNamesAndValues = null;
+            return;
+          }
+        }
+      }
+    }
+
+    public Builder fragment(String fragment) {
+      if (fragment == null) throw new IllegalArgumentException("fragment == null");
+      this.encodedFragment = canonicalize(fragment, FRAGMENT_ENCODE_SET, false, false);
+      return this;
+    }
+
+    public Builder encodedFragment(String encodedFragment) {
+      if (encodedFragment == null) throw new IllegalArgumentException("encodedFragment == null");
+      this.encodedFragment = canonicalize(encodedFragment, FRAGMENT_ENCODE_SET, true, false);
+      return this;
+    }
+
+    public HttpUrl build() {
+      if (scheme == null) throw new IllegalStateException("scheme == null");
+      if (host == null) throw new IllegalStateException("host == null");
+      return new HttpUrl(this);
+    }
+
+    @Override public String toString() {
+      StringBuilder result = new StringBuilder();
+      result.append(scheme);
+      result.append("://");
+
+      if (!encodedUsername.isEmpty() || !encodedPassword.isEmpty()) {
+        result.append(encodedUsername);
+        if (!encodedPassword.isEmpty()) {
+          result.append(':');
+          result.append(encodedPassword);
+        }
+        result.append('@');
+      }
+
+      if (host.indexOf(':') != -1) {
+        // Host is an IPv6 address.
+        result.append('[');
+        result.append(host);
+        result.append(']');
+      } else {
+        result.append(host);
+      }
+
+      int effectivePort = effectivePort();
+      if (effectivePort != defaultPort(scheme)) {
+        result.append(':');
+        result.append(effectivePort);
+      }
+
+      pathSegmentsToString(result, encodedPathSegments);
+
+      if (encodedQueryNamesAndValues != null) {
+        result.append('?');
+        namesAndValuesToQueryString(result, encodedQueryNamesAndValues);
+      }
+
+      if (encodedFragment != null) {
+        result.append('#');
+        result.append(encodedFragment);
+      }
+
+      return result.toString();
+    }
+
+    HttpUrl parse(HttpUrl base, String input) {
+      int pos = skipLeadingAsciiWhitespace(input, 0, input.length());
+      int limit = skipTrailingAsciiWhitespace(input, pos, input.length());
+
+      // Scheme.
+      int schemeDelimiterOffset = schemeDelimiterOffset(input, pos, limit);
+      if (schemeDelimiterOffset != -1) {
+        if (input.regionMatches(true, pos, "https:", 0, 6)) {
+          this.scheme = "https";
+          pos += "https:".length();
+        } else if (input.regionMatches(true, pos, "http:", 0, 5)) {
+          this.scheme = "http";
+          pos += "http:".length();
+        } else {
+          return null; // Not an HTTP scheme.
+        }
+      } else if (base != null) {
+        this.scheme = base.scheme;
+      } else {
+        return null; // No scheme.
+      }
+
+      // Authority.
+      boolean hasUsername = false;
+      boolean hasPassword = false;
+      int slashCount = slashCount(input, pos, limit);
+      if (slashCount >= 2 || base == null || !base.scheme.equals(this.scheme)) {
+        // Read an authority if either:
+        //  * The input starts with 2 or more slashes. These follow the scheme if it exists.
+        //  * The input scheme exists and is different from the base URL's scheme.
+        //
+        // The structure of an authority is:
+        //   username:password@host:port
+        //
+        // Username, password and port are optional.
+        //   [username[:password]@]host[:port]
+        pos += slashCount;
+        authority:
+        while (true) {
+          int componentDelimiterOffset = delimiterOffset(input, pos, limit, "@/\\?#");
+          int c = componentDelimiterOffset != limit
+              ? input.charAt(componentDelimiterOffset)
+              : -1;
+          switch (c) {
+            case '@':
+              // User info precedes.
+              if (!hasPassword) {
+                int passwordColonOffset = delimiterOffset(
+                    input, pos, componentDelimiterOffset, ":");
+                String canonicalUsername = canonicalize(
+                    input, pos, passwordColonOffset, USERNAME_ENCODE_SET, true, false);
+                this.encodedUsername = hasUsername
+                    ? this.encodedUsername + "%40" + canonicalUsername
+                    : canonicalUsername;
+                if (passwordColonOffset != componentDelimiterOffset) {
+                  hasPassword = true;
+                  this.encodedPassword = canonicalize(input, passwordColonOffset + 1,
+                      componentDelimiterOffset, PASSWORD_ENCODE_SET, true, false);
+                }
+                hasUsername = true;
+              } else {
+                this.encodedPassword = this.encodedPassword + "%40" + canonicalize(
+                    input, pos, componentDelimiterOffset, PASSWORD_ENCODE_SET, true, false);
+              }
+              pos = componentDelimiterOffset + 1;
+              break;
+
+            case -1:
+            case '/':
+            case '\\':
+            case '?':
+            case '#':
+              // Host info precedes.
+              int portColonOffset = portColonOffset(input, pos, componentDelimiterOffset);
+              if (portColonOffset + 1 < componentDelimiterOffset) {
+                this.host = canonicalizeHost(input, pos, portColonOffset);
+                this.port = parsePort(input, portColonOffset + 1, componentDelimiterOffset);
+                if (this.port == -1) return null; // Invalid port.
+              } else {
+                this.host = canonicalizeHost(input, pos, portColonOffset);
+                this.port = defaultPort(this.scheme);
+              }
+              if (this.host == null) return null; // Invalid host.
+              pos = componentDelimiterOffset;
+              break authority;
+          }
+        }
+      } else {
+        // This is a relative link. Copy over all authority components. Also maybe the path & query.
+        this.encodedUsername = base.encodedUsername();
+        this.encodedPassword = base.encodedPassword();
+        this.host = base.host;
+        this.port = base.port;
+        this.encodedPathSegments.clear();
+        this.encodedPathSegments.addAll(base.encodedPathSegments());
+        if (pos == limit || input.charAt(pos) == '#') {
+          encodedQuery(base.encodedQuery());
+        }
+      }
+
+      // Resolve the relative path.
+      int pathDelimiterOffset = delimiterOffset(input, pos, limit, "?#");
+      resolvePath(input, pos, pathDelimiterOffset);
+      pos = pathDelimiterOffset;
+
+      // Query.
+      if (pos < limit && input.charAt(pos) == '?') {
+        int queryDelimiterOffset = delimiterOffset(input, pos, limit, "#");
+        this.encodedQueryNamesAndValues = queryStringToNamesAndValues(canonicalize(
+            input, pos + 1, queryDelimiterOffset, QUERY_ENCODE_SET, true, true));
+        pos = queryDelimiterOffset;
+      }
+
+      // Fragment.
+      if (pos < limit && input.charAt(pos) == '#') {
+        this.encodedFragment = canonicalize(
+            input, pos + 1, limit, FRAGMENT_ENCODE_SET, true, false);
+      }
+
+      return build();
+    }
+
+    private void resolvePath(String input, int pos, int limit) {
+      // Read a delimiter.
+      if (pos == limit) {
+        // Empty path: keep the base path as-is.
+        return;
+      }
+      char c = input.charAt(pos);
+      if (c == '/' || c == '\\') {
+        // Absolute path: reset to the default "/".
+        encodedPathSegments.clear();
+        encodedPathSegments.add("");
+        pos++;
+      } else {
+        // Relative path: clear everything after the last '/'.
+        encodedPathSegments.set(encodedPathSegments.size() - 1, "");
+      }
+
+      // Read path segments.
+      for (int i = pos; i < limit; ) {
+        int pathSegmentDelimiterOffset = delimiterOffset(input, i, limit, "/\\");
+        boolean segmentHasTrailingSlash = pathSegmentDelimiterOffset < limit;
+        push(input, i, pathSegmentDelimiterOffset, segmentHasTrailingSlash, true);
+        i = pathSegmentDelimiterOffset;
+        if (segmentHasTrailingSlash) i++;
+      }
+    }
+
+    /** Adds a path segment. If the input is ".." or equivalent, this pops a path segment. */
+    private void push(String input, int pos, int limit, boolean addTrailingSlash,
+        boolean alreadyEncoded) {
+      String segment = canonicalize(
+          input, pos, limit, PATH_SEGMENT_ENCODE_SET, alreadyEncoded, false);
+      if (isDot(segment)) {
+        return; // Skip '.' path segments.
+      }
+      if (isDotDot(segment)) {
+        pop();
+        return;
+      }
+      if (encodedPathSegments.get(encodedPathSegments.size() - 1).isEmpty()) {
+        encodedPathSegments.set(encodedPathSegments.size() - 1, segment);
+      } else {
+        encodedPathSegments.add(segment);
+      }
+      if (addTrailingSlash) {
+        encodedPathSegments.add("");
+      }
+    }
+
+    private boolean isDot(String input) {
+      return input.equals(".") || input.equalsIgnoreCase("%2e");
+    }
+
+    private boolean isDotDot(String input) {
+      return input.equals("..")
+          || input.equalsIgnoreCase("%2e.")
+          || input.equalsIgnoreCase(".%2e")
+          || input.equalsIgnoreCase("%2e%2e");
+    }
+
+    /**
+     * Removes a path segment. When this method returns the last segment is always "", which means
+     * the encoded path will have a trailing '/'.
+     *
+     * <p>Popping "/a/b/c/" yields "/a/b/". In this case the list of path segments goes from
+     * ["a", "b", "c", ""] to ["a", "b", ""].
+     *
+     * <p>Popping "/a/b/c" also yields "/a/b/". The list of path segments goes from ["a", "b", "c"]
+     * to ["a", "b", ""].
+     */
+    private void pop() {
+      String removed = encodedPathSegments.remove(encodedPathSegments.size() - 1);
+
+      // Make sure the path ends with a '/' by either adding an empty string or clearing a segment.
+      if (removed.isEmpty() && !encodedPathSegments.isEmpty()) {
+        encodedPathSegments.set(encodedPathSegments.size() - 1, "");
+      } else {
+        encodedPathSegments.add("");
+      }
+    }
+
+    /**
+     * Increments {@code pos} until {@code input[pos]} is not ASCII whitespace. Stops at {@code
+     * limit}.
+     */
+    private int skipLeadingAsciiWhitespace(String input, int pos, int limit) {
+      for (int i = pos; i < limit; i++) {
+        switch (input.charAt(i)) {
+          case '\t':
+          case '\n':
+          case '\f':
+          case '\r':
+          case ' ':
+            continue;
+          default:
+            return i;
+        }
+      }
+      return limit;
+    }
+
+    /**
+     * Decrements {@code limit} until {@code input[limit - 1]} is not ASCII whitespace. Stops at
+     * {@code pos}.
+     */
+    private int skipTrailingAsciiWhitespace(String input, int pos, int limit) {
+      for (int i = limit - 1; i >= pos; i--) {
+        switch (input.charAt(i)) {
+          case '\t':
+          case '\n':
+          case '\f':
+          case '\r':
+          case ' ':
+            continue;
+          default:
+            return i + 1;
+        }
+      }
+      return pos;
+    }
+
+    /**
+     * Returns the index of the ':' in {@code input} that is after scheme characters. Returns -1 if
+     * {@code input} does not have a scheme that starts at {@code pos}.
+     */
+    private static int schemeDelimiterOffset(String input, int pos, int limit) {
+      if (limit - pos < 2) return -1;
+
+      char c0 = input.charAt(pos);
+      if ((c0 < 'a' || c0 > 'z') && (c0 < 'A' || c0 > 'Z')) return -1; // Not a scheme start char.
+
+      for (int i = pos + 1; i < limit; i++) {
+        char c = input.charAt(i);
+
+        if ((c >= 'a' && c <= 'z')
+            || (c >= 'A' && c <= 'Z')
+            || c == '+'
+            || c == '-'
+            || c == '.') {
+          continue; // Scheme character. Keep going.
+        } else if (c == ':') {
+          return i; // Scheme prefix!
+        } else {
+          return -1; // Non-scheme character before the first ':'.
+        }
+      }
+
+      return -1; // No ':'; doesn't start with a scheme.
+    }
+
+    /** Returns the number of '/' and '\' slashes in {@code input}, starting at {@code pos}. */
+    private static int slashCount(String input, int pos, int limit) {
+      int slashCount = 0;
+      while (pos < limit) {
+        char c = input.charAt(pos);
+        if (c == '\\' || c == '/') {
+          slashCount++;
+          pos++;
+        } else {
+          break;
+        }
+      }
+      return slashCount;
+    }
+
+    /** Finds the first ':' in {@code input}, skipping characters between square braces "[...]". */
+    private static int portColonOffset(String input, int pos, int limit) {
+      for (int i = pos; i < limit; i++) {
+        switch (input.charAt(i)) {
+          case '[':
+            while (++i < limit) {
+              if (input.charAt(i) == ']') break;
+            }
+            break;
+          case ':':
+            return i;
+        }
+      }
+      return limit; // No colon.
+    }
+
+    private static String canonicalizeHost(String input, int pos, int limit) {
+      // Start by percent decoding the host. The WHATWG spec suggests doing this only after we've
+      // checked for IPv6 square braces. But Chrome does it first, and that's more lenient.
+      String percentDecoded = percentDecode(input, pos, limit);
+
+      // If the input is encased in square braces "[...]", drop 'em. We have an IPv6 address.
+      if (percentDecoded.startsWith("[") && percentDecoded.endsWith("]")) {
+        InetAddress inetAddress = decodeIpv6(percentDecoded, 1, percentDecoded.length() - 1);
+        return inetAddress != null ? inetAddress.getHostAddress() : null;
+      }
+
+      // Do IDN decoding. This converts {@code ☃.net} to {@code xn--n3h.net}.
+      String idnDecoded = domainToAscii(percentDecoded);
+      if (idnDecoded == null) return null;
+
+      // Confirm that the decoded result doesn't contain any illegal characters.
+      int length = idnDecoded.length();
+      if (delimiterOffset(idnDecoded, 0, length, "\u0000\t\n\r #%/:?@[\\]") != length) {
+        return null;
+      }
+
+      return idnDecoded;
+    }
+
+    /** Decodes an IPv6 address like 1111:2222:3333:4444:5555:6666:7777:8888 or ::1. */
+    private static InetAddress decodeIpv6(String input, int pos, int limit) {
+      byte[] address = new byte[16];
+      int b = 0;
+      int compress = -1;
+      int groupOffset = -1;
+
+      for (int i = pos; i < limit; ) {
+        if (b == address.length) return null; // Too many groups.
+
+        // Read a delimiter.
+        if (i + 2 <= limit && input.regionMatches(i, "::", 0, 2)) {
+          // Compression "::" delimiter, which is anywhere in the input, including its prefix.
+          if (compress != -1) return null; // Multiple "::" delimiters.
+          i += 2;
+          b += 2;
+          compress = b;
+          if (i == limit) break;
+        } else if (b != 0) {
+          // Group separator ":" delimiter.
+          if (input.regionMatches(i, ":", 0, 1)) {
+            i++;
+          } else if (input.regionMatches(i, ".", 0, 1)) {
+            // If we see a '.', rewind to the beginning of the previous group and parse as IPv4.
+            if (!decodeIpv4Suffix(input, groupOffset, limit, address, b - 2)) return null;
+            b += 2; // We rewound two bytes and then added four.
+            break;
+          } else {
+            return null; // Wrong delimiter.
+          }
+        }
+
+        // Read a group, one to four hex digits.
+        int value = 0;
+        groupOffset = i;
+        for (; i < limit; i++) {
+          char c = input.charAt(i);
+          int hexDigit = decodeHexDigit(c);
+          if (hexDigit == -1) break;
+          value = (value << 4) + hexDigit;
+        }
+        int groupLength = i - groupOffset;
+        if (groupLength == 0 || groupLength > 4) return null; // Group is the wrong size.
+
+        // We've successfully read a group. Assign its value to our byte array.
+        address[b++] = (byte) ((value >>> 8) & 0xff);
+        address[b++] = (byte) (value & 0xff);
+      }
+
+      // All done. If compression happened, we need to move bytes to the right place in the
+      // address. Here's a sample:
+      //
+      //      input: "1111:2222:3333::7777:8888"
+      //     before: { 11, 11, 22, 22, 33, 33, 00, 00, 77, 77, 88, 88, 00, 00, 00, 00  }
+      //   compress: 6
+      //          b: 10
+      //      after: { 11, 11, 22, 22, 33, 33, 00, 00, 00, 00, 00, 00, 77, 77, 88, 88 }
+      //
+      if (b != address.length) {
+        if (compress == -1) return null; // Address didn't have compression or enough groups.
+        System.arraycopy(address, compress, address, address.length - (b - compress), b - compress);
+        Arrays.fill(address, compress, compress + (address.length - b), (byte) 0);
+      }
+
+      try {
+        return InetAddress.getByAddress(address);
+      } catch (UnknownHostException e) {
+        throw new AssertionError();
+      }
+    }
+
+    /** Decodes an IPv4 address suffix of an IPv6 address, like 1111::5555:6666:192.168.0.1. */
+    private static boolean decodeIpv4Suffix(
+        String input, int pos, int limit, byte[] address, int addressOffset) {
+      int b = addressOffset;
+
+      for (int i = pos; i < limit; ) {
+        if (b == address.length) return false; // Too many groups.
+
+        // Read a delimiter.
+        if (b != addressOffset) {
+          if (input.charAt(i) != '.') return false; // Wrong delimiter.
+          i++;
+        }
+
+        // Read 1 or more decimal digits for a value in 0..255.
+        int value = 0;
+        int groupOffset = i;
+        for (; i < limit; i++) {
+          char c = input.charAt(i);
+          if (c < '0' || c > '9') break;
+          if (value == 0 && groupOffset != i) return false; // Reject unnecessary leading '0's.
+          value = (value * 10) + c - '0';
+          if (value > 255) return false; // Value out of range.
+        }
+        int groupLength = i - groupOffset;
+        if (groupLength == 0) return false; // No digits.
+
+        // We've successfully read a byte.
+        address[b++] = (byte) value;
+      }
+
+      if (b != addressOffset + 4) return false; // Too few groups. We wanted exactly four.
+      return true; // Success.
+    }
+
+    private static String domainToAscii(String input) {
+      try {
+        String result = IDN.toASCII(input).toLowerCase(Locale.US);
+        if (result.isEmpty()) return null;
+        // TODO: implement all label limits.
+        return result;
+      } catch (IllegalArgumentException e) {
+        return null;
+      }
+    }
+
+    private static int parsePort(String input, int pos, int limit) {
+      try {
+        // Canonicalize the port string to skip '\n' etc.
+        String portString = canonicalize(input, pos, limit, "", false, false);
+        int i = Integer.parseInt(portString);
+        if (i > 0 && i <= 65535) return i;
+        return -1;
+      } catch (NumberFormatException e) {
+        return -1; // Invalid port.
+      }
+    }
+  }
+
+  /**
+   * Returns the index of the first character in {@code input} that contains a character in {@code
+   * delimiters}. Returns limit if there is no such character.
+   */
+  private static int delimiterOffset(String input, int pos, int limit, String delimiters) {
+    for (int i = pos; i < limit; i++) {
+      if (delimiters.indexOf(input.charAt(i)) != -1) return i;
+    }
+    return limit;
+  }
+
+  static String percentDecode(String encoded) {
+    return percentDecode(encoded, 0, encoded.length());
+  }
+
+  private List<String> percentDecode(List<String> list) {
+    List<String> result = new ArrayList<>(list.size());
+    for (String s : list) {
+      result.add(s != null ? percentDecode(s) : null);
+    }
+    return Collections.unmodifiableList(result);
+  }
+
+  static String percentDecode(String encoded, int pos, int limit) {
+    for (int i = pos; i < limit; i++) {
+      char c = encoded.charAt(i);
+      if (c == '%') {
+        // Slow path: the character at i requires decoding!
+        Buffer out = new Buffer();
+        out.writeUtf8(encoded, pos, i);
+        percentDecode(out, encoded, i, limit);
+        return out.readUtf8();
+      }
+    }
+
+    // Fast path: no characters in [pos..limit) required decoding.
+    return encoded.substring(pos, limit);
+  }
+
+  static void percentDecode(Buffer out, String encoded, int pos, int limit) {
+    int codePoint;
+    for (int i = pos; i < limit; i += Character.charCount(codePoint)) {
+      codePoint = encoded.codePointAt(i);
+      if (codePoint == '%' && i + 2 < limit) {
+        int d1 = decodeHexDigit(encoded.charAt(i + 1));
+        int d2 = decodeHexDigit(encoded.charAt(i + 2));
+        if (d1 != -1 && d2 != -1) {
+          out.writeByte((d1 << 4) + d2);
+          i += 2;
+          continue;
+        }
+      }
+      out.writeUtf8CodePoint(codePoint);
+    }
+  }
+
+  static int decodeHexDigit(char c) {
+    if (c >= '0' && c <= '9') return c - '0';
+    if (c >= 'a' && c <= 'f') return c - 'a' + 10;
+    if (c >= 'A' && c <= 'F') return c - 'A' + 10;
+    return -1;
+  }
+
+  /**
+   * Returns a substring of {@code input} on the range {@code [pos..limit)} with the following
+   * transformations:
+   * <ul>
+   *   <li>Tabs, newlines, form feeds and carriage returns are skipped.
+   *   <li>In queries, ' ' is encoded to '+' and '+' is encoded to "%2B".
+   *   <li>Characters in {@code encodeSet} are percent-encoded.
+   *   <li>Control characters and non-ASCII characters are percent-encoded.
+   *   <li>All other characters are copied without transformation.
+   * </ul>
+   *
+   * @param alreadyEncoded true to leave '%' as-is; false to convert it to '%25'.
+   * @param query true if to encode ' ' as '+', and '+' as "%2B".
+   */
+  static String canonicalize(String input, int pos, int limit, String encodeSet,
+      boolean alreadyEncoded, boolean query) {
+    int codePoint;
+    for (int i = pos; i < limit; i += Character.charCount(codePoint)) {
+      codePoint = input.codePointAt(i);
+      if (codePoint < 0x20
+          || codePoint >= 0x7f
+          || encodeSet.indexOf(codePoint) != -1
+          || (codePoint == '%' && !alreadyEncoded)
+          || (query && codePoint == '+')) {
+        // Slow path: the character at i requires encoding!
+        Buffer out = new Buffer();
+        out.writeUtf8(input, pos, i);
+        canonicalize(out, input, i, limit, encodeSet, alreadyEncoded, query);
+        return out.readUtf8();
+      }
+    }
+
+    // Fast path: no characters in [pos..limit) required encoding.
+    return input.substring(pos, limit);
+  }
+
+  static void canonicalize(Buffer out, String input, int pos, int limit,
+      String encodeSet, boolean alreadyEncoded, boolean query) {
+    Buffer utf8Buffer = null; // Lazily allocated.
+    int codePoint;
+    for (int i = pos; i < limit; i += Character.charCount(codePoint)) {
+      codePoint = input.codePointAt(i);
+      if (alreadyEncoded
+          && (codePoint == '\t' || codePoint == '\n' || codePoint == '\f' || codePoint == '\r')) {
+        // Skip this character.
+      } else if (query && codePoint == '+') {
+        // HTML permits space to be encoded as '+'. We use '%20' to avoid special cases.
+        out.writeUtf8(alreadyEncoded ? "%20" : "%2B");
+      } else if (codePoint < 0x20
+          || codePoint >= 0x7f
+          || encodeSet.indexOf(codePoint) != -1
+          || (codePoint == '%' && !alreadyEncoded)) {
+        // Percent encode this character.
+        if (utf8Buffer == null) {
+          utf8Buffer = new Buffer();
+        }
+        utf8Buffer.writeUtf8CodePoint(codePoint);
+        while (!utf8Buffer.exhausted()) {
+          int b = utf8Buffer.readByte() & 0xff;
+          out.writeByte('%');
+          out.writeByte(HEX_DIGITS[(b >> 4) & 0xf]);
+          out.writeByte(HEX_DIGITS[b & 0xf]);
+        }
+      } else {
+        // This character doesn't need encoding. Just copy it over.
+        out.writeUtf8CodePoint(codePoint);
+      }
+    }
+  }
+
+  static String canonicalize(
+      String input, String encodeSet, boolean alreadyEncoded, boolean query) {
+    return canonicalize(input, 0, input.length(), encodeSet, alreadyEncoded, query);
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Interceptor.java b/okhttp/src/main/java/com/squareup/okhttp/Interceptor.java
new file mode 100644
index 0000000000..03325be973
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/Interceptor.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import java.io.IOException;
+
+/**
+ * Observes, modifies, and potentially short-circuits requests going out and the corresponding
+ * requests coming back in. Typically interceptors will be used to add, remove, or transform headers
+ * on the request or response.
+ */
+public interface Interceptor {
+  Response intercept(Chain chain) throws IOException;
+
+  interface Chain {
+    Request request();
+    Response proceed(Request request) throws IOException;
+    Connection connection();
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/MultipartBuilder.java b/okhttp/src/main/java/com/squareup/okhttp/MultipartBuilder.java
index e31d183951..5b160b6741 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/MultipartBuilder.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/MultipartBuilder.java
@@ -73,10 +73,9 @@
 
   private final ByteString boundary;
   private MediaType type = MIXED;
-  private long length = 0;
 
-  // Parallel lists of nullable headings (boundary + headers) and non-null bodies.
-  private final List<Buffer> partHeadings = new ArrayList<>();
+  // Parallel lists of nullable headers and non-null bodies.
+  private final List<Headers> partHeaders = new ArrayList<>();
   private final List<RequestBody> partBodies = new ArrayList<>();
 
   /** Creates a new multipart builder that uses a random boundary token. */
@@ -126,17 +125,8 @@ public MultipartBuilder addPart(Headers headers, RequestBody body) {
       throw new IllegalArgumentException("Unexpected header: Content-Length");
     }
 
-    Buffer heading = createPartHeading(headers, body, partHeadings.isEmpty());
-    partHeadings.add(heading);
+    partHeaders.add(headers);
     partBodies.add(body);
-
-    long bodyContentLength = body.contentLength();
-    if (bodyContentLength == -1) {
-      length = -1;
-    } else if (length != -1) {
-      length += heading.size() + bodyContentLength;
-    }
-
     return this;
   }
 
@@ -195,94 +185,116 @@ public MultipartBuilder addFormDataPart(String name, String filename, RequestBod
     return addPart(Headers.of("Content-Disposition", disposition.toString()), value);
   }
 
-  /** Creates a part "heading" from the boundary and any real or generated headers. */
-  private Buffer createPartHeading(Headers headers, RequestBody body, boolean isFirst) {
-    Buffer sink = new Buffer();
-
-    if (!isFirst) {
-      sink.write(CRLF);
-    }
-    sink.write(DASHDASH);
-    sink.write(boundary);
-    sink.write(CRLF);
-
-    if (headers != null) {
-      for (int i = 0; i < headers.size(); i++) {
-        sink.writeUtf8(headers.name(i))
-            .write(COLONSPACE)
-            .writeUtf8(headers.value(i))
-            .write(CRLF);
-      }
-    }
-
-    MediaType contentType = body.contentType();
-    if (contentType != null) {
-      sink.writeUtf8("Content-Type: ")
-          .writeUtf8(contentType.toString())
-          .write(CRLF);
-    }
-
-    long contentLength = body.contentLength();
-    if (contentLength != -1) {
-      sink.writeUtf8("Content-Length: ")
-          .writeUtf8(Long.toString(contentLength))
-          .write(CRLF);
-    }
-
-    sink.write(CRLF);
-
-    return sink;
-  }
-
   /** Assemble the specified parts into a request body. */
   public RequestBody build() {
-    if (partHeadings.isEmpty()) {
+    if (partHeaders.isEmpty()) {
       throw new IllegalStateException("Multipart body must have at least one part.");
     }
-    return new MultipartRequestBody(type, boundary, partHeadings, partBodies, length);
+    return new MultipartRequestBody(type, boundary, partHeaders, partBodies);
   }
 
   private static final class MultipartRequestBody extends RequestBody {
     private final ByteString boundary;
     private final MediaType contentType;
-    private final List<Buffer> partHeadings;
+    private final List<Headers> partHeaders;
     private final List<RequestBody> partBodies;
-    private final long length;
+    private long contentLength = -1L;
 
-    public MultipartRequestBody(MediaType type, ByteString boundary, List<Buffer> partHeadings,
-        List<RequestBody> partBodies, long length) {
+    public MultipartRequestBody(MediaType type, ByteString boundary, List<Headers> partHeaders,
+        List<RequestBody> partBodies) {
       if (type == null) throw new NullPointerException("type == null");
 
       this.boundary = boundary;
       this.contentType = MediaType.parse(type + "; boundary=" + boundary.utf8());
-      this.partHeadings = Util.immutableList(partHeadings);
+      this.partHeaders = Util.immutableList(partHeaders);
       this.partBodies = Util.immutableList(partBodies);
-      if (length != -1) {
-        // Add the length of the final boundary.
-        length += CRLF.length + DASHDASH.length + boundary.size() + DASHDASH.length + CRLF.length;
-      }
-      this.length = length;
-    }
-
-    @Override public long contentLength() {
-      return length;
     }
 
     @Override public MediaType contentType() {
       return contentType;
     }
 
-    @Override public void writeTo(BufferedSink sink) throws IOException {
-      for (int i = 0, size = partHeadings.size(); i < size; i++) {
-        sink.writeAll(partHeadings.get(i).clone());
-        partBodies.get(i).writeTo(sink);
+    @Override public long contentLength() throws IOException {
+      long result = contentLength;
+      if (result != -1L) return result;
+      return contentLength = writeOrCountBytes(null, true);
+    }
+
+    /**
+     * Either writes this request to {@code sink} or measures its content length. We have one method
+     * do double-duty to make sure the counting and content are consistent, particularly when it
+     * comes to awkward operations like measuring the encoded length of header strings, or the
+     * length-in-digits of an encoded integer.
+     */
+    private long writeOrCountBytes(BufferedSink sink, boolean countBytes) throws IOException {
+      long byteCount = 0L;
+
+      Buffer byteCountBuffer = null;
+      if (countBytes) {
+        sink = byteCountBuffer = new Buffer();
+      }
+
+      for (int p = 0, partCount = partHeaders.size(); p < partCount; p++) {
+        Headers headers = partHeaders.get(p);
+        RequestBody body = partBodies.get(p);
+
+        sink.write(DASHDASH);
+        sink.write(boundary);
+        sink.write(CRLF);
+
+        if (headers != null) {
+          for (int h = 0, headerCount = headers.size(); h < headerCount; h++) {
+            sink.writeUtf8(headers.name(h))
+                .write(COLONSPACE)
+                .writeUtf8(headers.value(h))
+                .write(CRLF);
+          }
+        }
+
+        MediaType contentType = body.contentType();
+        if (contentType != null) {
+          sink.writeUtf8("Content-Type: ")
+              .writeUtf8(contentType.toString())
+              .write(CRLF);
+        }
+
+        long contentLength = body.contentLength();
+        if (contentLength != -1) {
+          sink.writeUtf8("Content-Length: ")
+              .writeDecimalLong(contentLength)
+              .write(CRLF);
+        } else if (countBytes) {
+          // We can't measure the body's size without the sizes of its components.
+          byteCountBuffer.clear();
+          return -1L;
+        }
+
+        sink.write(CRLF);
+
+        if (countBytes) {
+          byteCount += contentLength;
+        } else {
+          partBodies.get(p).writeTo(sink);
+        }
+
+        sink.write(CRLF);
       }
 
-      sink.write(CRLF);
       sink.write(DASHDASH);
       sink.write(boundary);
       sink.write(DASHDASH);
       sink.write(CRLF);
+
+      if (countBytes) {
+        byteCount += byteCountBuffer.size();
+        byteCountBuffer.clear();
+      }
+
+      return byteCount;
+    }
+
+    @Override public void writeTo(BufferedSink sink) throws IOException {
+      writeOrCountBytes(sink, false);
     }
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java b/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
index e723b3333d..06c9fbd443 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
@@ -22,6 +22,7 @@
 import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.internal.http.AuthenticatorAdapter;
 import com.squareup.okhttp.internal.http.HttpEngine;
+import com.squareup.okhttp.internal.http.RouteException;
 import com.squareup.okhttp.internal.http.Transport;
 import com.squareup.okhttp.internal.tls.OkHostnameVerifier;
 import java.io.IOException;
@@ -30,12 +31,16 @@
 import java.net.ProxySelector;
 import java.net.URLConnection;
 import java.security.GeneralSecurityException;
+import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.TimeUnit;
 import javax.net.SocketFactory;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
+import okio.BufferedSink;
+import okio.BufferedSource;
 
 /**
  * Configures and creates HTTP connections. Most applications can use a single
@@ -86,8 +91,12 @@
         return pooled.isReadable();
       }
 
-      @Override public void addLine(Headers.Builder builder, String line) {
-        builder.addLine(line);
+      @Override public void addLenient(Headers.Builder builder, String line) {
+        builder.addLenient(line);
+      }
+
+      @Override public void addLenient(Headers.Builder builder, String name, String value) {
+        builder.addLenient(name, value);
       }
 
       @Override public void setCache(OkHttpClient client, InternalCache internalCache) {
@@ -115,9 +124,39 @@
       }
 
       @Override public void connectAndSetOwner(OkHttpClient client, Connection connection,
-          HttpEngine owner, Request request) throws IOException {
+          HttpEngine owner, Request request) throws RouteException {
         connection.connectAndSetOwner(client, owner, request);
       }
+
+      @Override
+      public void callEnqueue(Call call, Callback responseCallback, boolean forWebSocket) {
+        call.enqueue(responseCallback, forWebSocket);
+      }
+
+      @Override public void callEngineReleaseConnection(Call call) throws IOException {
+        call.engine.releaseConnection();
+      }
+
+      @Override public Connection callEngineGetConnection(Call call) {
+        return call.engine.getConnection();
+      }
+
+      @Override public BufferedSource connectionRawSource(Connection connection) {
+        return connection.rawSource();
+      }
+
+      @Override public BufferedSink connectionRawSink(Connection connection) {
+        return connection.rawSink();
+      }
+
+      @Override public void connectionSetOwner(Connection connection, Object owner) {
+        connection.setOwner(owner);
+      }
+
+      @Override
+      public void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket, boolean isFallback) {
+        tlsConfiguration.apply(sslSocket, isFallback);
+      }
     };
   }
 
@@ -129,6 +168,8 @@
   private Proxy proxy;
   private List<Protocol> protocols;
   private List<ConnectionSpec> connectionSpecs;
+  private final List<Interceptor> interceptors = new ArrayList<>();
+  private final List<Interceptor> networkInterceptors = new ArrayList<>();
   private ProxySelector proxySelector;
   private CookieHandler cookieHandler;
 
@@ -145,6 +186,7 @@
   private Network network;
   private boolean followSslRedirects = true;
   private boolean followRedirects = true;
+  private boolean retryOnConnectionFailure = true;
   private int connectTimeout;
   private int readTimeout;
   private int writeTimeout;
@@ -160,6 +202,8 @@ private OkHttpClient(OkHttpClient okHttpClient) {
     this.proxy = okHttpClient.proxy;
     this.protocols = okHttpClient.protocols;
     this.connectionSpecs = okHttpClient.connectionSpecs;
+    this.interceptors.addAll(okHttpClient.interceptors);
+    this.networkInterceptors.addAll(okHttpClient.networkInterceptors);
     this.proxySelector = okHttpClient.proxySelector;
     this.cookieHandler = okHttpClient.cookieHandler;
     this.cache = okHttpClient.cache;
@@ -173,60 +217,67 @@ private OkHttpClient(OkHttpClient okHttpClient) {
     this.network = okHttpClient.network;
     this.followSslRedirects = okHttpClient.followSslRedirects;
     this.followRedirects = okHttpClient.followRedirects;
+    this.retryOnConnectionFailure = okHttpClient.retryOnConnectionFailure;
     this.connectTimeout = okHttpClient.connectTimeout;
     this.readTimeout = okHttpClient.readTimeout;
     this.writeTimeout = okHttpClient.writeTimeout;
   }
 
   /**
-   * Sets the default connect timeout for new connections. A value of 0 means no timeout.
+   * Sets the default connect timeout for new connections. A value of 0 means no timeout, otherwise
+   * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
    *
    * @see URLConnection#setConnectTimeout(int)
    */
-  public final void setConnectTimeout(long timeout, TimeUnit unit) {
+  public void setConnectTimeout(long timeout, TimeUnit unit) {
     if (timeout < 0) throw new IllegalArgumentException("timeout < 0");
     if (unit == null) throw new IllegalArgumentException("unit == null");
     long millis = unit.toMillis(timeout);
     if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException("Timeout too large.");
+    if (millis == 0 && timeout > 0) throw new IllegalArgumentException("Timeout too small.");
     connectTimeout = (int) millis;
   }
 
   /** Default connect timeout (in milliseconds). */
-  public final int getConnectTimeout() {
+  public int getConnectTimeout() {
     return connectTimeout;
   }
 
   /**
-   * Sets the default read timeout for new connections. A value of 0 means no timeout.
+   * Sets the default read timeout for new connections. A value of 0 means no timeout, otherwise
+   * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
    *
    * @see URLConnection#setReadTimeout(int)
    */
-  public final void setReadTimeout(long timeout, TimeUnit unit) {
+  public void setReadTimeout(long timeout, TimeUnit unit) {
     if (timeout < 0) throw new IllegalArgumentException("timeout < 0");
     if (unit == null) throw new IllegalArgumentException("unit == null");
     long millis = unit.toMillis(timeout);
     if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException("Timeout too large.");
+    if (millis == 0 && timeout > 0) throw new IllegalArgumentException("Timeout too small.");
     readTimeout = (int) millis;
   }
 
   /** Default read timeout (in milliseconds). */
-  public final int getReadTimeout() {
+  public int getReadTimeout() {
     return readTimeout;
   }
 
   /**
-   * Sets the default write timeout for new connections. A value of 0 means no timeout.
+   * Sets the default write timeout for new connections. A value of 0 means no timeout, otherwise
+   * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
    */
-  public final void setWriteTimeout(long timeout, TimeUnit unit) {
+  public void setWriteTimeout(long timeout, TimeUnit unit) {
     if (timeout < 0) throw new IllegalArgumentException("timeout < 0");
     if (unit == null) throw new IllegalArgumentException("unit == null");
     long millis = unit.toMillis(timeout);
     if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException("Timeout too large.");
+    if (millis == 0 && timeout > 0) throw new IllegalArgumentException("Timeout too small.");
     writeTimeout = (int) millis;
   }
 
   /** Default write timeout (in milliseconds). */
-  public final int getWriteTimeout() {
+  public int getWriteTimeout() {
     return writeTimeout;
   }
 
@@ -236,12 +287,12 @@ public final int getWriteTimeout() {
    * only honored when this proxy is null (which it is by default). To disable
    * proxy use completely, call {@code setProxy(Proxy.NO_PROXY)}.
    */
-  public final OkHttpClient setProxy(Proxy proxy) {
+  public OkHttpClient setProxy(Proxy proxy) {
     this.proxy = proxy;
     return this;
   }
 
-  public final Proxy getProxy() {
+  public Proxy getProxy() {
     return proxy;
   }
 
@@ -254,12 +305,12 @@ public final Proxy getProxy() {
    * <p>If unset, the {@link ProxySelector#getDefault() system-wide default}
    * proxy selector will be used.
    */
-  public final OkHttpClient setProxySelector(ProxySelector proxySelector) {
+  public OkHttpClient setProxySelector(ProxySelector proxySelector) {
     this.proxySelector = proxySelector;
     return this;
   }
 
-  public final ProxySelector getProxySelector() {
+  public ProxySelector getProxySelector() {
     return proxySelector;
   }
 
@@ -270,47 +321,50 @@ public final ProxySelector getProxySelector() {
    * <p>If unset, the {@link CookieHandler#getDefault() system-wide default}
    * cookie handler will be used.
    */
-  public final OkHttpClient setCookieHandler(CookieHandler cookieHandler) {
+  public OkHttpClient setCookieHandler(CookieHandler cookieHandler) {
     this.cookieHandler = cookieHandler;
     return this;
   }
 
-  public final CookieHandler getCookieHandler() {
+  public CookieHandler getCookieHandler() {
     return cookieHandler;
   }
 
   /** Sets the response cache to be used to read and write cached responses. */
-  final void setInternalCache(InternalCache internalCache) {
+  void setInternalCache(InternalCache internalCache) {
     this.internalCache = internalCache;
     this.cache = null;
   }
 
-  final InternalCache internalCache() {
+  InternalCache internalCache() {
     return internalCache;
   }
 
-  public final OkHttpClient setCache(Cache cache) {
+  public OkHttpClient setCache(Cache cache) {
     this.cache = cache;
     this.internalCache = null;
     return this;
   }
 
-  public final Cache getCache() {
+  public Cache getCache() {
     return cache;
   }
 
   /**
-   * Sets the socket factory used to create connections.
+   * Sets the socket factory used to create connections. OkHttp only uses
+   * the parameterless {@link SocketFactory#createSocket() createSocket()}
+   * method to create unconnected sockets. Overriding this method,
+   * e. g., allows the socket to be bound to a specific local address.
    *
    * <p>If unset, the {@link SocketFactory#getDefault() system-wide default}
    * socket factory will be used.
    */
-  public final OkHttpClient setSocketFactory(SocketFactory socketFactory) {
+  public OkHttpClient setSocketFactory(SocketFactory socketFactory) {
     this.socketFactory = socketFactory;
     return this;
   }
 
-  public final SocketFactory getSocketFactory() {
+  public SocketFactory getSocketFactory() {
     return socketFactory;
   }
 
@@ -319,12 +373,12 @@ public final SocketFactory getSocketFactory() {
    *
    * <p>If unset, a lazily created SSL socket factory will be used.
    */
-  public final OkHttpClient setSslSocketFactory(SSLSocketFactory sslSocketFactory) {
+  public OkHttpClient setSslSocketFactory(SSLSocketFactory sslSocketFactory) {
     this.sslSocketFactory = sslSocketFactory;
     return this;
   }
 
-  public final SSLSocketFactory getSslSocketFactory() {
+  public SSLSocketFactory getSslSocketFactory() {
     return sslSocketFactory;
   }
 
@@ -334,12 +388,12 @@ public final SSLSocketFactory getSslSocketFactory() {
    *
    * <p>If unset, a default hostname verifier will be used.
    */
-  public final OkHttpClient setHostnameVerifier(HostnameVerifier hostnameVerifier) {
+  public OkHttpClient setHostnameVerifier(HostnameVerifier hostnameVerifier) {
     this.hostnameVerifier = hostnameVerifier;
     return this;
   }
 
-  public final HostnameVerifier getHostnameVerifier() {
+  public HostnameVerifier getHostnameVerifier() {
     return hostnameVerifier;
   }
 
@@ -349,12 +403,12 @@ public final HostnameVerifier getHostnameVerifier() {
    * SSL socket factory} to establish trust. Pinning certificates avoids the
    * need to trust certificate authorities.
    */
-  public final OkHttpClient setCertificatePinner(CertificatePinner certificatePinner) {
+  public OkHttpClient setCertificatePinner(CertificatePinner certificatePinner) {
     this.certificatePinner = certificatePinner;
     return this;
   }
 
-  public final CertificatePinner getCertificatePinner() {
+  public CertificatePinner getCertificatePinner() {
     return certificatePinner;
   }
 
@@ -365,12 +419,12 @@ public final CertificatePinner getCertificatePinner() {
    * <p>If unset, the {@link java.net.Authenticator#setDefault system-wide default}
    * authenticator will be used.
    */
-  public final OkHttpClient setAuthenticator(Authenticator authenticator) {
+  public OkHttpClient setAuthenticator(Authenticator authenticator) {
     this.authenticator = authenticator;
     return this;
   }
 
-  public final Authenticator getAuthenticator() {
+  public Authenticator getAuthenticator() {
     return authenticator;
   }
 
@@ -380,12 +434,12 @@ public final Authenticator getAuthenticator() {
    * <p>If unset, the {@link ConnectionPool#getDefault() system-wide
    * default} connection pool will be used.
    */
-  public final OkHttpClient setConnectionPool(ConnectionPool connectionPool) {
+  public OkHttpClient setConnectionPool(ConnectionPool connectionPool) {
     this.connectionPool = connectionPool;
     return this;
   }
 
-  public final ConnectionPool getConnectionPool() {
+  public ConnectionPool getConnectionPool() {
     return connectionPool;
   }
 
@@ -396,25 +450,51 @@ public final ConnectionPool getConnectionPool() {
    * <p>If unset, protocol redirects will be followed. This is different than
    * the built-in {@code HttpURLConnection}'s default.
    */
-  public final OkHttpClient setFollowSslRedirects(boolean followProtocolRedirects) {
+  public OkHttpClient setFollowSslRedirects(boolean followProtocolRedirects) {
     this.followSslRedirects = followProtocolRedirects;
     return this;
   }
 
-  public final boolean getFollowSslRedirects() {
+  public boolean getFollowSslRedirects() {
     return followSslRedirects;
   }
 
   /** Configure this client to follow redirects. If unset, redirects be followed. */
-  public final void setFollowRedirects(boolean followRedirects) {
+  public void setFollowRedirects(boolean followRedirects) {
     this.followRedirects = followRedirects;
   }
 
-  public final boolean getFollowRedirects() {
+  public boolean getFollowRedirects() {
     return followRedirects;
   }
 
-  final RouteDatabase routeDatabase() {
+  /**
+   * Configure this client to retry or not when a connectivity problem is encountered. By default,
+   * this client silently recovers from the following problems:
+   *
+   * <ul>
+   *   <li><strong>Unreachable IP addresses.</strong> If the URL's host has multiple IP addresses,
+   *       failure to reach any individual IP address doesn't fail the overall request. This can
+   *       increase availability of multi-homed services.
+   *   <li><strong>Stale pooled connections.</strong> The {@link ConnectionPool} reuses sockets
+   *       to decrease request latency, but these connections will occasionally time out.
+   *   <li><strong>Unreachable proxy servers.</strong> A {@link ProxySelector} can be used to
+   *       attempt multiple proxy servers in sequence, eventually falling back to a direct
+   *       connection.
+   * </ul>
+   *
+   * Set this to false to avoid retrying requests when doing so is destructive. In this case the
+   * calling application should do its own recovery of connectivity failures.
+   */
+  public void setRetryOnConnectionFailure(boolean retryOnConnectionFailure) {
+    this.retryOnConnectionFailure = retryOnConnectionFailure;
+  }
+
+  public boolean getRetryOnConnectionFailure() {
+    return retryOnConnectionFailure;
+  }
+
+  RouteDatabase routeDatabase() {
     return routeDatabase;
   }
 
@@ -422,13 +502,13 @@ final RouteDatabase routeDatabase() {
    * Sets the dispatcher used to set policy and execute asynchronous requests.
    * Must not be null.
    */
-  public final OkHttpClient setDispatcher(Dispatcher dispatcher) {
+  public OkHttpClient setDispatcher(Dispatcher dispatcher) {
     if (dispatcher == null) throw new IllegalArgumentException("dispatcher == null");
     this.dispatcher = dispatcher;
     return this;
   }
 
-  public final Dispatcher getDispatcher() {
+  public Dispatcher getDispatcher() {
     return dispatcher;
   }
 
@@ -443,16 +523,15 @@ public final Dispatcher getDispatcher() {
    * <ul>
    *   <li><a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html">http/1.1</a>
    *   <li><a href="http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1">spdy/3.1</a>
-   *   <li><a href="http://tools.ietf.org/html/draft-ietf-httpbis-http2-14">h2-14</a>
+   *   <li><a href="http://tools.ietf.org/html/draft-ietf-httpbis-http2-17">h2</a>
    * </ul>
    *
-   * <p><strong>This is an evolving set.</strong> Future releases may drop
-   * support for transitional protocols (like h2-14), in favor of their
-   * successors (h2). The http/1.1 transport will never be dropped.
+   * <p><strong>This is an evolving set.</strong> Future releases include
+   * support for transitional protocols. The http/1.1 transport will never be
+   * dropped.
    *
    * <p>If multiple protocols are specified, <a
-   * href="https://technotes.googlecode.com/git/nextprotoneg.html">NPN</a> or
-   * <a href="http://tools.ietf.org/html/draft-ietf-tls-applayerprotoneg">ALPN</a>
+   * href="http://tools.ietf.org/html/draft-ietf-tls-applayerprotoneg">ALPN</a>
    * will be used to negotiate a transport.
    *
    * <p>{@link Protocol#HTTP_1_0} is not supported in this set. Requests are
@@ -463,7 +542,7 @@ public final Dispatcher getDispatcher() {
    *     must contain {@link Protocol#HTTP_1_1}. It must not contain null or
    *     {@link Protocol#HTTP_1_0}.
    */
-  public final OkHttpClient setProtocols(List<Protocol> protocols) {
+  public OkHttpClient setProtocols(List<Protocol> protocols) {
     protocols = Util.immutableList(protocols);
     if (!protocols.contains(Protocol.HTTP_1_1)) {
       throw new IllegalArgumentException("protocols doesn't contain http/1.1: " + protocols);
@@ -478,19 +557,37 @@ public final OkHttpClient setProtocols(List<Protocol> protocols) {
     return this;
   }
 
-  public final List<Protocol> getProtocols() {
+  public List<Protocol> getProtocols() {
     return protocols;
   }
 
-  public final OkHttpClient setConnectionSpecs(List<ConnectionSpec> connectionSpecs) {
+  public OkHttpClient setConnectionSpecs(List<ConnectionSpec> connectionSpecs) {
     this.connectionSpecs = Util.immutableList(connectionSpecs);
     return this;
   }
 
-  public final List<ConnectionSpec> getConnectionSpecs() {
+  public List<ConnectionSpec> getConnectionSpecs() {
     return connectionSpecs;
   }
 
+  /**
+   * Returns a modifiable list of interceptors that observe the full span of each call: from before
+   * the connection is established (if any) until after the response source is selected (either the
+   * origin server, cache, or both).
+   */
+  public List<Interceptor> interceptors() {
+    return interceptors;
+  }
+
+  /**
+   * Returns a modifiable list of interceptors that observe a single network request and response.
+   * These interceptors must call {@link Interceptor.Chain#proceed} exactly once: it is an error for
+   * a network interceptor to short-circuit or repeat a network request.
+   */
+  public List<Interceptor> networkInterceptors() {
+    return networkInterceptors;
+  }
+
   /**
    * Prepares the {@code request} to be executed at some point in the future.
    */
@@ -511,7 +608,7 @@ public OkHttpClient cancel(Object tag) {
    * Returns a shallow copy of this OkHttpClient that uses the system-wide
    * default for each field that hasn't been explicitly configured.
    */
-  final OkHttpClient copyWithDefaults() {
+  OkHttpClient copyWithDefaults() {
     OkHttpClient result = new OkHttpClient(this);
     if (result.proxySelector == null) {
       result.proxySelector = ProxySelector.getDefault();
@@ -552,9 +649,9 @@ final OkHttpClient copyWithDefaults() {
   /**
    * Java and Android programs default to using a single global SSL context,
    * accessible to HTTP clients as {@link SSLSocketFactory#getDefault()}. If we
-   * used the shared SSL context, when OkHttp enables NPN for its SPDY-related
-   * stuff, it would also enable NPN for other usages, which might crash them
-   * because NPN is enabled when it isn't expected to be.
+   * used the shared SSL context, when OkHttp enables ALPN for its SPDY-related
+   * stuff, it would also enable ALPN for other usages, which might crash them
+   * because ALPN is enabled when it isn't expected to be.
    *
    * <p>This code avoids that by defaulting to an OkHttp-created SSL context.
    * The drawback of this approach is that apps that customize the global SSL
@@ -574,11 +671,7 @@ private synchronized SSLSocketFactory getDefaultSSLSocketFactory() {
   }
 
   /** Returns a shallow copy of this OkHttpClient. */
-  @Override public final OkHttpClient clone() {
-    try {
-      return (OkHttpClient) super.clone();
-    } catch (CloneNotSupportedException e) {
-      throw new AssertionError();
-    }
+  @Override public OkHttpClient clone() {
+    return new OkHttpClient(this);
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Protocol.java b/okhttp/src/main/java/com/squareup/okhttp/Protocol.java
index e514d44171..6b02098133 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Protocol.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Protocol.java
@@ -19,8 +19,7 @@
 
 /**
  * Protocols that OkHttp implements for <a
- * href="http://tools.ietf.org/html/draft-agl-tls-nextprotoneg-04">NPN</a> and
- * <a href="http://tools.ietf.org/html/draft-ietf-tls-applayerprotoneg">ALPN</a>
+ * href="http://tools.ietf.org/html/draft-ietf-tls-applayerprotoneg">ALPN</a>
  * selection.
  *
  * <h3>Protocol vs Scheme</h3>
@@ -62,14 +61,12 @@
    * multiplexing multiple requests on the same socket, and server-push.
    * HTTP/1.1 semantics are layered on HTTP/2.
    *
-   * <p>This version of OkHttp implements HTTP/2 <a
-   * href="http://tools.ietf.org/html/draft-ietf-httpbis-http2-14">draft 12</a>
-   * with HPACK <a
-   * href="http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-09">draft
-   * 6</a>. Future releases of OkHttp may use this identifier for a newer draft
-   * of these specs.
+   * <p>HTTP/2 requires deployments of HTTP/2 that use TLS 1.2 support
+   * {@linkplain com.squareup.okhttp.CipherSuite#TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256}
+   * , present in Java 8+ and Android 5+. Servers that enforce this may send an
+   * exception message including the string {@code INADEQUATE_SECURITY}.
    */
-  HTTP_2("h2-14");
+  HTTP_2("h2");
 
   private final String protocol;
 
@@ -91,8 +88,8 @@ public static Protocol get(String protocol) throws IOException {
   }
 
   /**
-   * Returns the string used to identify this protocol for ALPN and NPN, like
-   * "http/1.1", "spdy/3.1" or "h2-14".
+   * Returns the string used to identify this protocol for ALPN, like
+   * "http/1.1", "spdy/3.1" or "h2".
    */
   @Override public String toString() {
     return protocol;
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Request.java b/okhttp/src/main/java/com/squareup/okhttp/Request.java
index 890a34ad55..9b0169dbb1 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Request.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Request.java
@@ -15,13 +15,9 @@
  */
 package com.squareup.okhttp;
 
-import com.squareup.okhttp.internal.Platform;
-import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.internal.http.HttpMethod;
 import java.io.IOException;
-import java.net.MalformedURLException;
 import java.net.URI;
-import java.net.URISyntaxException;
 import java.net.URL;
 import java.util.List;
 
@@ -30,45 +26,44 @@
  * is null or itself immutable.
  */
 public final class Request {
-  private final String urlString;
+  private final HttpUrl url;
   private final String method;
   private final Headers headers;
   private final RequestBody body;
   private final Object tag;
 
-  private volatile URL url; // Lazily initialized.
-  private volatile URI uri; // Lazily initialized.
+  private volatile URL javaNetUrl; // Lazily initialized.
+  private volatile URI javaNetUri; // Lazily initialized.
   private volatile CacheControl cacheControl; // Lazily initialized.
 
   private Request(Builder builder) {
-    this.urlString = builder.urlString;
+    this.url = builder.url;
     this.method = builder.method;
     this.headers = builder.headers.build();
     this.body = builder.body;
     this.tag = builder.tag != null ? builder.tag : this;
-    this.url = builder.url;
+  }
+
+  public HttpUrl httpUrl() {
+    return url;
   }
 
   public URL url() {
-    try {
-      URL result = url;
-      return result != null ? result : (url = new URL(urlString));
-    } catch (MalformedURLException e) {
-      throw new RuntimeException("Malformed URL: " + urlString, e);
-    }
+    URL result = javaNetUrl;
+    return result != null ? result : (javaNetUrl = url.url());
   }
 
   public URI uri() throws IOException {
     try {
-      URI result = uri;
-      return result != null ? result : (uri = Platform.get().toUriLenient(url()));
-    } catch (URISyntaxException e) {
+      URI result = javaNetUri;
+      return result != null ? result : (javaNetUri = url.uri());
+    } catch (IllegalStateException e) {
       throw new IOException(e.getMessage());
     }
   }
 
   public String urlString() {
-    return urlString;
+    return url.toString();
   }
 
   public String method() {
@@ -109,22 +104,21 @@ public CacheControl cacheControl() {
   }
 
   public boolean isHttps() {
-    return url().getProtocol().equals("https");
+    return url.isHttps();
   }
 
   @Override public String toString() {
     return "Request{method="
         + method
         + ", url="
-        + urlString
+        + url
         + ", tag="
         + (tag != this ? tag : null)
         + '}';
   }
 
   public static class Builder {
-    private String urlString;
-    private URL url;
+    private HttpUrl url;
     private String method;
     private Headers.Builder headers;
     private RequestBody body;
@@ -136,7 +130,6 @@ public Builder() {
     }
 
     private Builder(Request request) {
-      this.urlString = request.urlString;
       this.url = request.url;
       this.method = request.method;
       this.body = request.body;
@@ -144,17 +137,32 @@ private Builder(Request request) {
       this.headers = request.headers.newBuilder();
     }
 
-    public Builder url(String url) {
+    public Builder url(HttpUrl url) {
       if (url == null) throw new IllegalArgumentException("url == null");
-      urlString = url;
+      this.url = url;
       return this;
     }
 
+    public Builder url(String url) {
+      if (url == null) throw new IllegalArgumentException("url == null");
+
+      // Silently replace websocket URLs with HTTP URLs.
+      if (url.regionMatches(true, 0, "ws:", 0, 3)) {
+        url = "http:" + url.substring(3);
+      } else if (url.regionMatches(true, 0, "wss:", 0, 4)) {
+        url = "https:" + url.substring(4);
+      }
+
+      HttpUrl parsed = HttpUrl.parse(url);
+      if (parsed == null) throw new IllegalArgumentException("unexpected url: " + url);
+      return url(parsed);
+    }
+
     public Builder url(URL url) {
       if (url == null) throw new IllegalArgumentException("url == null");
-      this.url = url;
-      this.urlString = url.toString();
-      return this;
+      HttpUrl parsed = HttpUrl.get(url);
+      if (parsed == null) throw new IllegalArgumentException("unexpected url: " + url);
+      return url(parsed);
     }
 
     /**
@@ -209,8 +217,12 @@ public Builder post(RequestBody body) {
       return method("POST", body);
     }
 
+    public Builder delete(RequestBody body) {
+      return method("DELETE", body);
+    }
+
     public Builder delete() {
-      return method("DELETE", null);
+      return delete(RequestBody.create(null, new byte[0]));
     }
 
     public Builder put(RequestBody body) {
@@ -228,8 +240,8 @@ public Builder method(String method, RequestBody body) {
       if (body != null && !HttpMethod.permitsRequestBody(method)) {
         throw new IllegalArgumentException("method " + method + " must not have a request body.");
       }
-      if (body == null && HttpMethod.permitsRequestBody(method)) {
-        body = RequestBody.create(null, Util.EMPTY_BYTE_ARRAY);
+      if (body == null && HttpMethod.requiresRequestBody(method)) {
+        throw new IllegalArgumentException("method " + method + " must have a request body.");
       }
       this.method = method;
       this.body = body;
@@ -247,7 +259,7 @@ public Builder tag(Object tag) {
     }
 
     public Request build() {
-      if (urlString == null) throw new IllegalStateException("url == null");
+      if (url == null) throw new IllegalStateException("url == null");
       return new Request(this);
     }
   }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/RequestBody.java b/okhttp/src/main/java/com/squareup/okhttp/RequestBody.java
index 83203c3dbd..50933f71fd 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/RequestBody.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/RequestBody.java
@@ -20,6 +20,7 @@
 import java.io.IOException;
 import java.nio.charset.Charset;
 import okio.BufferedSink;
+import okio.ByteString;
 import okio.Okio;
 import okio.Source;
 
@@ -31,7 +32,7 @@
    * Returns the number of bytes that will be written to {@code out} in a call
    * to {@link #writeTo}, or -1 if that count is unknown.
    */
-  public long contentLength() {
+  public long contentLength() throws IOException {
     return -1;
   }
 
@@ -55,21 +56,44 @@ public static RequestBody create(MediaType contentType, String content) {
     return create(contentType, bytes);
   }
 
+  /** Returns a new request body that transmits {@code content}. */
+  public static RequestBody create(final MediaType contentType, final ByteString content) {
+    return new RequestBody() {
+      @Override public MediaType contentType() {
+        return contentType;
+      }
+
+      @Override public long contentLength() throws IOException {
+        return content.size();
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        sink.write(content);
+      }
+    };
+  }
+
   /** Returns a new request body that transmits {@code content}. */
   public static RequestBody create(final MediaType contentType, final byte[] content) {
-    if (content == null) throw new NullPointerException("content == null");
+    return create(contentType, content, 0, content.length);
+  }
 
+  /** Returns a new request body that transmits {@code content}. */
+  public static RequestBody create(final MediaType contentType, final byte[] content,
+      final int offset, final int byteCount) {
+    if (content == null) throw new NullPointerException("content == null");
+    Util.checkOffsetAndCount(content.length, offset, byteCount);
     return new RequestBody() {
       @Override public MediaType contentType() {
         return contentType;
       }
 
       @Override public long contentLength() {
-        return content.length;
+        return byteCount;
       }
 
       @Override public void writeTo(BufferedSink sink) throws IOException {
-        sink.write(content);
+        sink.write(content, offset, byteCount);
       }
     };
   }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/ResponseBody.java b/okhttp/src/main/java/com/squareup/okhttp/ResponseBody.java
index e91238a0f2..bdd98b4c69 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/ResponseBody.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/ResponseBody.java
@@ -22,6 +22,7 @@
 import java.io.InputStreamReader;
 import java.io.Reader;
 import java.nio.charset.Charset;
+import okio.Buffer;
 import okio.BufferedSource;
 
 import static com.squareup.okhttp.internal.Util.UTF_8;
@@ -36,13 +37,13 @@
    * Returns the number of bytes in that will returned by {@link #bytes}, or
    * {@link #byteStream}, or -1 if unknown.
    */
-  public abstract long contentLength();
+  public abstract long contentLength() throws IOException;
 
-  public final InputStream byteStream() {
+  public final InputStream byteStream() throws IOException {
     return source().inputStream();
   }
 
-  public abstract BufferedSource source();
+  public abstract BufferedSource source() throws IOException;
 
   public final byte[] bytes() throws IOException {
     long contentLength = contentLength();
@@ -68,7 +69,7 @@ public final InputStream byteStream() {
    * of the Content-Type header. If that header is either absent or lacks a
    * charset, this will attempt to decode the response body as UTF-8.
    */
-  public final Reader charStream() {
+  public final Reader charStream() throws IOException {
     Reader r = reader;
     return r != null ? r : (reader = new InputStreamReader(byteStream(), charset()));
   }
@@ -90,4 +91,46 @@ private Charset charset() {
   @Override public void close() throws IOException {
     source().close();
   }
+
+  /**
+   * Returns a new response body that transmits {@code content}. If {@code
+   * contentType} is non-null and lacks a charset, this will use UTF-8.
+   */
+  public static ResponseBody create(MediaType contentType, String content) {
+    Charset charset = Util.UTF_8;
+    if (contentType != null) {
+      charset = contentType.charset();
+      if (charset == null) {
+        charset = Util.UTF_8;
+        contentType = MediaType.parse(contentType + "; charset=utf-8");
+      }
+    }
+    Buffer buffer = new Buffer().writeString(content, charset);
+    return create(contentType, buffer.size(), buffer);
+  }
+
+  /** Returns a new response body that transmits {@code content}. */
+  public static ResponseBody create(final MediaType contentType, byte[] content) {
+    Buffer buffer = new Buffer().write(content);
+    return create(contentType, content.length, buffer);
+  }
+
+  /** Returns a new response body that transmits {@code content}. */
+  public static ResponseBody create(
+      final MediaType contentType, final long contentLength, final BufferedSource content) {
+    if (content == null) throw new NullPointerException("source == null");
+    return new ResponseBody() {
+      @Override public MediaType contentType() {
+        return contentType;
+      }
+
+      @Override public long contentLength() {
+        return contentLength;
+      }
+
+      @Override public BufferedSource source() {
+        return content;
+      }
+    };
+  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Route.java b/okhttp/src/main/java/com/squareup/okhttp/Route.java
index 6e6c3bf33c..2d27a03090 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Route.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Route.java
@@ -28,8 +28,6 @@
  *   <li><strong>IP address:</strong> whether connecting directly to an origin
  *       server or a proxy, opening a socket requires an IP address. The DNS
  *       server may return multiple IP addresses to attempt.
- *   <li><strong>TLS configuration:</strong> which cipher suites and TLS
- *       versions to attempt with the HTTPS connection.
  * </ul>
  * Each route is a specific selection of these options.
  */
@@ -37,10 +35,8 @@
   final Address address;
   final Proxy proxy;
   final InetSocketAddress inetSocketAddress;
-  final ConnectionSpec connectionSpec;
 
-  public Route(Address address, Proxy proxy, InetSocketAddress inetSocketAddress,
-      ConnectionSpec connectionSpec) {
+  public Route(Address address, Proxy proxy, InetSocketAddress inetSocketAddress) {
     if (address == null) {
       throw new NullPointerException("address == null");
     }
@@ -50,13 +46,9 @@ public Route(Address address, Proxy proxy, InetSocketAddress inetSocketAddress,
     if (inetSocketAddress == null) {
       throw new NullPointerException("inetSocketAddress == null");
     }
-    if (connectionSpec == null) {
-      throw new NullPointerException("connectionConfiguration == null");
-    }
     this.address = address;
     this.proxy = proxy;
     this.inetSocketAddress = inetSocketAddress;
-    this.connectionSpec = connectionSpec;
   }
 
   public Address getAddress() {
@@ -78,10 +70,6 @@ public InetSocketAddress getSocketAddress() {
     return inetSocketAddress;
   }
 
-  public ConnectionSpec getConnectionSpec() {
-    return connectionSpec;
-  }
-
   /**
    * Returns true if this route tunnels HTTPS through an HTTP proxy. See <a
    * href="http://www.ietf.org/rfc/rfc2817.txt">RFC 2817, Section 5.2</a>.
@@ -95,8 +83,7 @@ public boolean requiresTunnel() {
       Route other = (Route) obj;
       return address.equals(other.address)
           && proxy.equals(other.proxy)
-          && inetSocketAddress.equals(other.inetSocketAddress)
-          && connectionSpec.equals(other.connectionSpec);
+          && inetSocketAddress.equals(other.inetSocketAddress);
     }
     return false;
   }
@@ -106,7 +93,6 @@ public boolean requiresTunnel() {
     result = 31 * result + address.hashCode();
     result = 31 * result + proxy.hashCode();
     result = 31 * result + inetSocketAddress.hashCode();
-    result = 31 * result + connectionSpec.hashCode();
     return result;
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/TlsVersion.java b/okhttp/src/main/java/com/squareup/okhttp/TlsVersion.java
index b33115ac3d..bfa95c410b 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/TlsVersion.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/TlsVersion.java
@@ -34,7 +34,7 @@ private TlsVersion(String javaName) {
     this.javaName = javaName;
   }
 
-  static TlsVersion forJavaName(String javaName) {
+  public static TlsVersion forJavaName(String javaName) {
     switch (javaName) {
       case "TLSv1.2": return TLS_1_2;
       case "TLSv1.1": return TLS_1_1;
@@ -43,4 +43,8 @@ static TlsVersion forJavaName(String javaName) {
     }
     throw new IllegalArgumentException("Unexpected TLS version: " + javaName);
   }
+
+  public String javaName() {
+    return javaName;
+  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/ConnectionSpecSelector.java b/okhttp/src/main/java/com/squareup/okhttp/internal/ConnectionSpecSelector.java
new file mode 100644
index 0000000000..dabe8b26e5
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/ConnectionSpecSelector.java
@@ -0,0 +1,141 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.squareup.okhttp.internal;
+
+import com.squareup.okhttp.ConnectionSpec;
+
+import java.io.IOException;
+import java.io.InterruptedIOException;
+import java.net.ProtocolException;
+import java.net.UnknownServiceException;
+import java.security.cert.CertificateException;
+import java.util.Arrays;
+import java.util.List;
+import javax.net.ssl.SSLHandshakeException;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import javax.net.ssl.SSLProtocolException;
+import javax.net.ssl.SSLSocket;
+
+/**
+ * Handles the connection spec fallback strategy: When a secure socket connection fails
+ * due to a handshake / protocol problem the connection may be retried with different protocols.
+ * Instances are stateful and should be created and used for a single connection attempt.
+ */
+public final class ConnectionSpecSelector {
+
+  private final List<ConnectionSpec> connectionSpecs;
+  private int nextModeIndex;
+  private boolean isFallbackPossible;
+  private boolean isFallback;
+
+  public ConnectionSpecSelector(List<ConnectionSpec> connectionSpecs) {
+    this.nextModeIndex = 0;
+    this.connectionSpecs = connectionSpecs;
+  }
+
+  /**
+   * Configures the supplied {@link SSLSocket} to connect to the specified host using an appropriate
+   * {@link ConnectionSpec}. Returns the chosen {@link ConnectionSpec}, never {@code null}.
+   *
+   * @throws IOException if the socket does not support any of the TLS modes available
+   */
+  public ConnectionSpec configureSecureSocket(SSLSocket sslSocket) throws IOException {
+    ConnectionSpec tlsConfiguration = null;
+    for (int i = nextModeIndex, size = connectionSpecs.size(); i < size; i++) {
+      ConnectionSpec connectionSpec = connectionSpecs.get(i);
+      if (connectionSpec.isCompatible(sslSocket)) {
+        tlsConfiguration = connectionSpec;
+        nextModeIndex = i + 1;
+        break;
+      }
+    }
+
+    if (tlsConfiguration == null) {
+      // This may be the first time a connection has been attempted and the socket does not support
+      // any the required protocols, or it may be a retry (but this socket supports fewer
+      // protocols than was suggested by a prior socket).
+      throw new UnknownServiceException(
+          "Unable to find acceptable protocols. isFallback=" + isFallback
+              + ", modes=" + connectionSpecs
+              + ", supported protocols=" + Arrays.toString(sslSocket.getEnabledProtocols()));
+    }
+
+    isFallbackPossible = isFallbackPossible(sslSocket);
+
+    Internal.instance.apply(tlsConfiguration, sslSocket, isFallback);
+
+    return tlsConfiguration;
+  }
+
+  /**
+   * Reports a failure to complete a connection. Determines the next {@link ConnectionSpec} to
+   * try, if any.
+   *
+   * @return {@code true} if the connection should be retried using
+   *     {@link #configureSecureSocket(SSLSocket)} or {@code false} if not
+   */
+  public boolean connectionFailed(IOException e) {
+    // Any future attempt to connect using this strategy will be a fallback attempt.
+    isFallback = true;
+
+    // TODO(nfuller): This is the same logic as in HttpEngine.
+    // If there was a protocol problem, don't recover.
+    if (e instanceof ProtocolException) {
+      return false;
+    }
+
+    // If there was an interruption or timeout, don't recover.
+    if (e instanceof InterruptedIOException) {
+      return false;
+    }
+
+    // Look for known client-side or negotiation errors that are unlikely to be fixed by trying
+    // again with a different connection spec.
+    if (e instanceof SSLHandshakeException) {
+      // If the problem was a CertificateException from the X509TrustManager,
+      // do not retry.
+      if (e.getCause() instanceof CertificateException) {
+        return false;
+      }
+    }
+    if (e instanceof SSLPeerUnverifiedException) {
+      // e.g. a certificate pinning error.
+      return false;
+    }
+    // TODO(nfuller): End of common code.
+
+
+    // On Android, SSLProtocolExceptions can be caused by TLS_FALLBACK_SCSV failures, which means we
+    // retry those when we probably should not.
+    return ((e instanceof SSLHandshakeException || e instanceof SSLProtocolException))
+        && isFallbackPossible;
+  }
+
+  /**
+   * Returns {@code true} if any later {@link ConnectionSpec} in the fallback strategy looks
+   * possible based on the supplied {@link SSLSocket}. It assumes that a future socket will have the
+   * same capabilities as the supplied socket.
+   */
+  private boolean isFallbackPossible(SSLSocket socket) {
+    for (int i = nextModeIndex; i < connectionSpecs.size(); i++) {
+      if (connectionSpecs.get(i).isCompatible(socket)) {
+        return true;
+      }
+    }
+    return false;
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java b/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java
index a5e5e4fbd6..09b80af9c5 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java
@@ -16,23 +16,30 @@
 
 package com.squareup.okhttp.internal;
 
+import android.annotation.SuppressLint;
+
+import com.squareup.okhttp.internal.io.FileSystem;
+
 import java.io.Closeable;
 import java.io.EOFException;
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.IOException;
+import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Iterator;
 import java.util.LinkedHashMap;
+import java.util.NoSuchElementException;
+import java.util.concurrent.Executor;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
+
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
-import okio.ForwardingSink;
 import okio.Okio;
 import okio.Sink;
 import okio.Source;
@@ -44,38 +51,38 @@
  * the regex <strong>[a-z0-9_-]{1,64}</strong>. Values are byte sequences,
  * accessible as streams or files. Each value must be between {@code 0} and
  * {@code Integer.MAX_VALUE} bytes in length.
- *
+ * <p/>
  * <p>The cache stores its data in a directory on the filesystem. This
  * directory must be exclusive to the cache; the cache may delete or overwrite
  * files from its directory. It is an error for multiple processes to use the
  * same cache directory at the same time.
- *
+ * <p/>
  * <p>This cache limits the number of bytes that it will store on the
  * filesystem. When the number of stored bytes exceeds the limit, the cache will
  * remove entries in the background until the limit is satisfied. The limit is
  * not strict: the cache may temporarily exceed it while waiting for files to be
  * deleted. The limit does not include filesystem overhead or the cache
  * journal so space-sensitive applications should set a conservative limit.
- *
+ * <p/>
  * <p>Clients call {@link #edit} to create or update the values of an entry. An
  * entry may have only one editor at one time; if a value is not available to be
  * edited then {@link #edit} will return null.
  * <ul>
- *     <li>When an entry is being <strong>created</strong> it is necessary to
- *         supply a full set of values; the empty value should be used as a
- *         placeholder if necessary.
- *     <li>When an entry is being <strong>edited</strong>, it is not necessary
- *         to supply data for every value; values default to their previous
- *         value.
+ * <li>When an entry is being <strong>created</strong> it is necessary to
+ * supply a full set of values; the empty value should be used as a
+ * placeholder if necessary.
+ * <li>When an entry is being <strong>edited</strong>, it is not necessary
+ * to supply data for every value; values default to their previous
+ * value.
  * </ul>
  * Every {@link #edit} call must be matched by a call to {@link Editor#commit}
  * or {@link Editor#abort}. Committing is atomic: a read observes the full set
  * of values as they were before or after the commit, but never a mix of values.
- *
+ * <p/>
  * <p>Clients call {@link #get} to read a snapshot of an entry. The read will
  * observe the value at the time that {@link #get} was called. Updates and
  * removals after the call do not impact ongoing reads.
- *
+ * <p/>
  * <p>This class is tolerant of some I/O errors. If files are missing from the
  * filesystem, the corresponding entries will be dropped from the cache. If
  * an error occurs while writing a cache value, the edit will fail silently.
@@ -83,17 +90,17 @@
  * responding appropriately.
  */
 public final class DiskLruCache implements Closeable {
-  static final String JOURNAL_FILE = "journal";
-  static final String JOURNAL_FILE_TEMP = "journal.tmp";
-  static final String JOURNAL_FILE_BACKUP = "journal.bkp";
-  static final String MAGIC = "libcore.io.DiskLruCache";
-  static final String VERSION_1 = "1";
-  static final long ANY_SEQUENCE_NUMBER = -1;
-  static final Pattern LEGAL_KEY_PATTERN = Pattern.compile("[a-z0-9_-]{1,120}");
-  private static final String CLEAN = "CLEAN";
-  private static final String DIRTY = "DIRTY";
-  private static final String REMOVE = "REMOVE";
-  private static final String READ = "READ";
+    static final String JOURNAL_FILE = "journal";
+    static final String JOURNAL_FILE_TEMP = "journal.tmp";
+    static final String JOURNAL_FILE_BACKUP = "journal.bkp";
+    static final String MAGIC = "libcore.io.DiskLruCache";
+    static final String VERSION_1 = "1";
+    static final long ANY_SEQUENCE_NUMBER = -1;
+    static final Pattern LEGAL_KEY_PATTERN = Pattern.compile("[a-z0-9_-]{1,120}");
+    private static final String CLEAN = "CLEAN";
+    private static final String DIRTY = "DIRTY";
+    private static final String REMOVE = "REMOVE";
+    private static final String READ = "READ";
 
     /*
      * This cache uses a journal file named "journal". A typical journal file
@@ -135,839 +142,923 @@
      * it exists when the cache is opened.
      */
 
-  private final File directory;
-  private final File journalFile;
-  private final File journalFileTmp;
-  private final File journalFileBackup;
-  private final int appVersion;
-  private long maxSize;
-  private final int valueCount;
-  private long size = 0;
-  private BufferedSink journalWriter;
-  private final LinkedHashMap<String, Entry> lruEntries = new LinkedHashMap<>(0, 0.75f, true);
-  private int redundantOpCount;
-
-  /**
-   * To differentiate between old and current snapshots, each entry is given
-   * a sequence number each time an edit is committed. A snapshot is stale if
-   * its sequence number is not equal to its entry's sequence number.
-   */
-  private long nextSequenceNumber = 0;
-
-  /** This cache uses a single background thread to evict entries. */
-  final ThreadPoolExecutor executorService = new ThreadPoolExecutor(0, 1, 60L, TimeUnit.SECONDS,
-      new LinkedBlockingQueue<Runnable>(), Util.threadFactory("OkHttp DiskLruCache", true));
-  private final Runnable cleanupRunnable = new Runnable() {
-    public void run() {
-      synchronized (DiskLruCache.this) {
-        if (journalWriter == null) {
-          return; // Closed.
+    private final FileSystem fileSystem;
+    private final File directory;
+    private final File journalFile;
+    private final File journalFileTmp;
+    private final File journalFileBackup;
+    private final int appVersion;
+    private long maxSize;
+    private final int valueCount;
+    private long size = 0;
+    private BufferedSink journalWriter;
+    private final LinkedHashMap<String, Entry> lruEntries = new LinkedHashMap<>(0, 0.75f, true);
+    private int redundantOpCount;
+    private boolean hasJournalErrors;
+
+    // Must be read and written when synchronized on 'this'.
+    private boolean initialized;
+    private boolean closed;
+
+    /**
+     * To differentiate between old and current snapshots, each entry is given
+     * a sequence number each time an edit is committed. A snapshot is stale if
+     * its sequence number is not equal to its entry's sequence number.
+     */
+    private long nextSequenceNumber = 0;
+
+    /**
+     * Used to run 'cleanupRunnable' for journal rebuilds.
+     */
+    private final Executor executor;
+    private final Runnable cleanupRunnable = new Runnable() {
+        public void run() {
+            synchronized (DiskLruCache.this) {
+                if (!initialized | closed) {
+                    return; // Nothing to do
+                }
+                try {
+                    trimToSize();
+                    if (journalRebuildRequired()) {
+                        rebuildJournal();
+                        redundantOpCount = 0;
+                    }
+                } catch (IOException e) {
+                    throw new RuntimeException(e);
+                }
+            }
         }
-        try {
-          trimToSize();
-          if (journalRebuildRequired()) {
-            rebuildJournal();
-            redundantOpCount = 0;
-          }
-        } catch (IOException e) {
-          throw new RuntimeException(e);
-        }
-      }
-    }
-  };
-
-  private DiskLruCache(File directory, int appVersion, int valueCount, long maxSize) {
-    this.directory = directory;
-    this.appVersion = appVersion;
-    this.journalFile = new File(directory, JOURNAL_FILE);
-    this.journalFileTmp = new File(directory, JOURNAL_FILE_TEMP);
-    this.journalFileBackup = new File(directory, JOURNAL_FILE_BACKUP);
-    this.valueCount = valueCount;
-    this.maxSize = maxSize;
-  }
-
-  /**
-   * Opens the cache in {@code directory}, creating a cache if none exists
-   * there.
-   *
-   * @param directory a writable directory
-   * @param valueCount the number of values per cache entry. Must be positive.
-   * @param maxSize the maximum number of bytes this cache should use to store
-   * @throws IOException if reading or writing the cache directory fails
-   */
-  public static DiskLruCache open(File directory, int appVersion, int valueCount, long maxSize)
-      throws IOException {
-    if (maxSize <= 0) {
-      throw new IllegalArgumentException("maxSize <= 0");
-    }
-    if (valueCount <= 0) {
-      throw new IllegalArgumentException("valueCount <= 0");
+    };
+
+    DiskLruCache(FileSystem fileSystem, File directory, int appVersion, int valueCount, long maxSize,
+                 Executor executor) {
+        this.fileSystem = fileSystem;
+        this.directory = directory;
+        this.appVersion = appVersion;
+        this.journalFile = new File(directory, JOURNAL_FILE);
+        this.journalFileTmp = new File(directory, JOURNAL_FILE_TEMP);
+        this.journalFileBackup = new File(directory, JOURNAL_FILE_BACKUP);
+        this.valueCount = valueCount;
+        this.maxSize = maxSize;
+        this.executor = executor;
     }
 
-    // If a bkp file exists, use it instead.
-    File backupFile = new File(directory, JOURNAL_FILE_BACKUP);
-    if (backupFile.exists()) {
-      File journalFile = new File(directory, JOURNAL_FILE);
-      // If journal file also exists just delete backup file.
-      if (journalFile.exists()) {
-        backupFile.delete();
-      } else {
-        renameTo(backupFile, journalFile, false);
-      }
-    }
+    // Visible for testing.
+    @SuppressLint("Assert")
+    void initialize() throws IOException {
+        assert Thread.holdsLock(this);
 
-    // Prefer to pick up where we left off.
-    DiskLruCache cache = new DiskLruCache(directory, appVersion, valueCount, maxSize);
-    if (cache.journalFile.exists()) {
-      try {
-        cache.readJournal();
-        cache.processJournal();
-        return cache;
-      } catch (IOException journalIsCorrupt) {
-        Platform.get().logW("DiskLruCache " + directory + " is corrupt: "
-            + journalIsCorrupt.getMessage() + ", removing");
-        cache.delete();
-      }
-    }
+        if (initialized) {
+            return; // Already initialized.
+        }
 
-    // Create a new empty cache.
-    directory.mkdirs();
-    cache = new DiskLruCache(directory, appVersion, valueCount, maxSize);
-    cache.rebuildJournal();
-    return cache;
-  }
-
-  private void readJournal() throws IOException {
-    BufferedSource source = Okio.buffer(Okio.source(journalFile));
-    try {
-      String magic = source.readUtf8LineStrict();
-      String version = source.readUtf8LineStrict();
-      String appVersionString = source.readUtf8LineStrict();
-      String valueCountString = source.readUtf8LineStrict();
-      String blank = source.readUtf8LineStrict();
-      if (!MAGIC.equals(magic)
-          || !VERSION_1.equals(version)
-          || !Integer.toString(appVersion).equals(appVersionString)
-          || !Integer.toString(valueCount).equals(valueCountString)
-          || !"".equals(blank)) {
-        throw new IOException("unexpected journal header: [" + magic + ", " + version + ", "
-            + valueCountString + ", " + blank + "]");
-      }
-
-      int lineCount = 0;
-      while (true) {
-        try {
-          readJournalLine(source.readUtf8LineStrict());
-          lineCount++;
-        } catch (EOFException endOfJournal) {
-          break;
+        // If a bkp file exists, use it instead.
+        if (fileSystem.exists(journalFileBackup)) {
+            // If journal file also exists just delete backup file.
+            if (fileSystem.exists(journalFile)) {
+                fileSystem.delete(journalFileBackup);
+            } else {
+                fileSystem.rename(journalFileBackup, journalFile);
+            }
+        }
+
+        // Prefer to pick up where we left off.
+        if (fileSystem.exists(journalFile)) {
+            try {
+                readJournal();
+                processJournal();
+                initialized = true;
+                return;
+            } catch (IOException journalIsCorrupt) {
+                Platform.get().logW("DiskLruCache " + directory + " is corrupt: "
+                        + journalIsCorrupt.getMessage() + ", removing");
+                delete();
+                closed = false;
+            }
         }
-      }
-      redundantOpCount = lineCount - lruEntries.size();
 
-      // If we ended on a truncated line, rebuild the journal before appending to it.
-      if (!source.exhausted()) {
         rebuildJournal();
-      } else {
-        journalWriter = Okio.buffer(Okio.appendingSink(journalFile));
-      }
-    } finally {
-      Util.closeQuietly(source);
-    }
-  }
 
-  private void readJournalLine(String line) throws IOException {
-    int firstSpace = line.indexOf(' ');
-    if (firstSpace == -1) {
-      throw new IOException("unexpected journal line: " + line);
+        initialized = true;
     }
 
-    int keyBegin = firstSpace + 1;
-    int secondSpace = line.indexOf(' ', keyBegin);
-    final String key;
-    if (secondSpace == -1) {
-      key = line.substring(keyBegin);
-      if (firstSpace == REMOVE.length() && line.startsWith(REMOVE)) {
-        lruEntries.remove(key);
-        return;
-      }
-    } else {
-      key = line.substring(keyBegin, secondSpace);
-    }
+    /**
+     * Create a cache which will reside in {@code directory}. This cache is lazily initialized on
+     * first access and will be created if it does not exist.
+     *
+     * @param directory  a writable directory
+     * @param valueCount the number of values per cache entry. Must be positive.
+     * @param maxSize    the maximum number of bytes this cache should use to store
+     */
+    public static DiskLruCache create(FileSystem fileSystem, File directory, int appVersion,
+                                      int valueCount, long maxSize) {
+        if (maxSize <= 0) {
+            throw new IllegalArgumentException("maxSize <= 0");
+        }
+        if (valueCount <= 0) {
+            throw new IllegalArgumentException("valueCount <= 0");
+        }
 
-    Entry entry = lruEntries.get(key);
-    if (entry == null) {
-      entry = new Entry(key);
-      lruEntries.put(key, entry);
-    }
+        // Use a single background thread to evict entries.
+        Executor executor = new ThreadPoolExecutor(0, 1, 60L, TimeUnit.SECONDS,
+                new LinkedBlockingQueue<Runnable>(), Util.threadFactory("OkHttp DiskLruCache", true));
 
-    if (secondSpace != -1 && firstSpace == CLEAN.length() && line.startsWith(CLEAN)) {
-      String[] parts = line.substring(secondSpace + 1).split(" ");
-      entry.readable = true;
-      entry.currentEditor = null;
-      entry.setLengths(parts);
-    } else if (secondSpace == -1 && firstSpace == DIRTY.length() && line.startsWith(DIRTY)) {
-      entry.currentEditor = new Editor(entry);
-    } else if (secondSpace == -1 && firstSpace == READ.length() && line.startsWith(READ)) {
-      // This work was already done by calling lruEntries.get().
-    } else {
-      throw new IOException("unexpected journal line: " + line);
+        return new DiskLruCache(fileSystem, directory, appVersion, valueCount, maxSize, executor);
     }
-  }
-
-  /**
-   * Computes the initial size and collects garbage as a part of opening the
-   * cache. Dirty entries are assumed to be inconsistent and will be deleted.
-   */
-  private void processJournal() throws IOException {
-    deleteIfExists(journalFileTmp);
-    for (Iterator<Entry> i = lruEntries.values().iterator(); i.hasNext(); ) {
-      Entry entry = i.next();
-      if (entry.currentEditor == null) {
-        for (int t = 0; t < valueCount; t++) {
-          size += entry.lengths[t];
-        }
-      } else {
-        entry.currentEditor = null;
-        for (int t = 0; t < valueCount; t++) {
-          deleteIfExists(entry.cleanFiles[t]);
-          deleteIfExists(entry.dirtyFiles[t]);
+
+    private void readJournal() throws IOException {
+        BufferedSource source = Okio.buffer(fileSystem.source(journalFile));
+        try {
+            String magic = source.readUtf8LineStrict();
+            String version = source.readUtf8LineStrict();
+            String appVersionString = source.readUtf8LineStrict();
+            String valueCountString = source.readUtf8LineStrict();
+            String blank = source.readUtf8LineStrict();
+            if (!MAGIC.equals(magic)
+                    || !VERSION_1.equals(version)
+                    || !Integer.toString(appVersion).equals(appVersionString)
+                    || !Integer.toString(valueCount).equals(valueCountString)
+                    || !"".equals(blank)) {
+                throw new IOException("unexpected journal header: [" + magic + ", " + version + ", "
+                        + valueCountString + ", " + blank + "]");
+            }
+
+            int lineCount = 0;
+            while (true) {
+                try {
+                    readJournalLine(source.readUtf8LineStrict());
+                    lineCount++;
+                } catch (EOFException endOfJournal) {
+                    break;
+                }
+            }
+            redundantOpCount = lineCount - lruEntries.size();
+
+            // If we ended on a truncated line, rebuild the journal before appending to it.
+            if (!source.exhausted()) {
+                rebuildJournal();
+            } else {
+                journalWriter = newJournalWriter();
+            }
+        } finally {
+            Util.closeQuietly(source);
         }
-        i.remove();
-      }
     }
-  }
-
-  /**
-   * Creates a new journal that omits redundant information. This replaces the
-   * current journal if it exists.
-   */
-  private synchronized void rebuildJournal() throws IOException {
-    if (journalWriter != null) {
-      journalWriter.close();
+
+    private BufferedSink newJournalWriter() throws FileNotFoundException {
+        Sink fileSink = fileSystem.appendingSink(journalFile);
+        Sink faultHidingSink = new FaultHidingSink(fileSink) {
+            @SuppressLint("Assert")
+            @Override
+            protected void onException(IOException e) {
+                assert (Thread.holdsLock(DiskLruCache.this));
+                hasJournalErrors = true;
+            }
+        };
+        return Okio.buffer(faultHidingSink);
     }
 
-    BufferedSink writer = Okio.buffer(Okio.sink(journalFileTmp));
-    try {
-      writer.writeUtf8(MAGIC).writeByte('\n');
-      writer.writeUtf8(VERSION_1).writeByte('\n');
-      writer.writeUtf8(Integer.toString(appVersion)).writeByte('\n');
-      writer.writeUtf8(Integer.toString(valueCount)).writeByte('\n');
-      writer.writeByte('\n');
+    private void readJournalLine(String line) throws IOException {
+        int firstSpace = line.indexOf(' ');
+        if (firstSpace == -1) {
+            throw new IOException("unexpected journal line: " + line);
+        }
 
-      for (Entry entry : lruEntries.values()) {
-        if (entry.currentEditor != null) {
-          writer.writeUtf8(DIRTY).writeByte(' ');
-          writer.writeUtf8(entry.key);
-          writer.writeByte('\n');
+        int keyBegin = firstSpace + 1;
+        int secondSpace = line.indexOf(' ', keyBegin);
+        final String key;
+        if (secondSpace == -1) {
+            key = line.substring(keyBegin);
+            if (firstSpace == REMOVE.length() && line.startsWith(REMOVE)) {
+                lruEntries.remove(key);
+                return;
+            }
         } else {
-          writer.writeUtf8(CLEAN).writeByte(' ');
-          writer.writeUtf8(entry.key);
-          writer.writeUtf8(entry.getLengths());
-          writer.writeByte('\n');
-        }
-      }
-    } finally {
-      writer.close();
+            key = line.substring(keyBegin, secondSpace);
+        }
+
+        Entry entry = lruEntries.get(key);
+        if (entry == null) {
+            entry = new Entry(key);
+            lruEntries.put(key, entry);
+        }
+
+        if (secondSpace != -1 && firstSpace == CLEAN.length() && line.startsWith(CLEAN)) {
+            String[] parts = line.substring(secondSpace + 1).split(" ");
+            entry.readable = true;
+            entry.currentEditor = null;
+            entry.setLengths(parts);
+        } else if (secondSpace == -1 && firstSpace == DIRTY.length() && line.startsWith(DIRTY)) {
+            entry.currentEditor = new Editor(entry);
+        } else if (secondSpace == -1 && firstSpace == READ.length() && line.startsWith(READ)) {
+            // This work was already done by calling lruEntries.get().
+        } else {
+            throw new IOException("unexpected journal line: " + line);
+        }
     }
 
-    if (journalFile.exists()) {
-      renameTo(journalFile, journalFileBackup, true);
+    /**
+     * Computes the initial size and collects garbage as a part of opening the
+     * cache. Dirty entries are assumed to be inconsistent and will be deleted.
+     */
+    private void processJournal() throws IOException {
+        fileSystem.delete(journalFileTmp);
+        for (Iterator<Entry> i = lruEntries.values().iterator(); i.hasNext(); ) {
+            Entry entry = i.next();
+            if (entry.currentEditor == null) {
+                for (int t = 0; t < valueCount; t++) {
+                    size += entry.lengths[t];
+                }
+            } else {
+                entry.currentEditor = null;
+                for (int t = 0; t < valueCount; t++) {
+                    fileSystem.delete(entry.cleanFiles[t]);
+                    fileSystem.delete(entry.dirtyFiles[t]);
+                }
+                i.remove();
+            }
+        }
     }
-    renameTo(journalFileTmp, journalFile, false);
-    journalFileBackup.delete();
 
-    journalWriter = Okio.buffer(Okio.appendingSink(journalFile));
-  }
+    /**
+     * Creates a new journal that omits redundant information. This replaces the
+     * current journal if it exists.
+     */
+    private synchronized void rebuildJournal() throws IOException {
+        if (journalWriter != null) {
+            journalWriter.close();
+        }
 
-  private static void deleteIfExists(File file) throws IOException {
-    // If delete() fails, make sure it's because the file didn't exist!
-    if (!file.delete() && file.exists()) {
-      throw new IOException("failed to delete " + file);
-    }
-  }
+        BufferedSink writer = Okio.buffer(fileSystem.sink(journalFileTmp));
+        try {
+            writer.writeUtf8(MAGIC).writeByte('\n');
+            writer.writeUtf8(VERSION_1).writeByte('\n');
+            writer.writeDecimalLong(appVersion).writeByte('\n');
+            writer.writeDecimalLong(valueCount).writeByte('\n');
+            writer.writeByte('\n');
+
+            for (Entry entry : lruEntries.values()) {
+                if (entry.currentEditor != null) {
+                    writer.writeUtf8(DIRTY).writeByte(' ');
+                    writer.writeUtf8(entry.key);
+                    writer.writeByte('\n');
+                } else {
+                    writer.writeUtf8(CLEAN).writeByte(' ');
+                    writer.writeUtf8(entry.key);
+                    entry.writeLengths(writer);
+                    writer.writeByte('\n');
+                }
+            }
+        } finally {
+            writer.close();
+        }
 
-  private static void renameTo(File from, File to, boolean deleteDestination) throws IOException {
-    if (deleteDestination) {
-      deleteIfExists(to);
-    }
-    if (!from.renameTo(to)) {
-      throw new IOException();
-    }
-  }
-
-  /**
-   * Returns a snapshot of the entry named {@code key}, or null if it doesn't
-   * exist is not currently readable. If a value is returned, it is moved to
-   * the head of the LRU queue.
-   */
-  public synchronized Snapshot get(String key) throws IOException {
-    checkNotClosed();
-    validateKey(key);
-    Entry entry = lruEntries.get(key);
-    if (entry == null) {
-      return null;
-    }
+        if (fileSystem.exists(journalFile)) {
+            fileSystem.rename(journalFile, journalFileBackup);
+        }
+        fileSystem.rename(journalFileTmp, journalFile);
+        fileSystem.delete(journalFileBackup);
 
-    if (!entry.readable) {
-      return null;
+        journalWriter = newJournalWriter();
+        hasJournalErrors = false;
     }
 
-    // Open all streams eagerly to guarantee that we see a single published
-    // snapshot. If we opened streams lazily then the streams could come
-    // from different edits.
-    Source[] sources = new Source[valueCount];
-    try {
-      for (int i = 0; i < valueCount; i++) {
-        sources[i] = Okio.source(entry.cleanFiles[i]);
-      }
-    } catch (FileNotFoundException e) {
-      // A file must have been deleted manually!
-      for (int i = 0; i < valueCount; i++) {
-        if (sources[i] != null) {
-          Util.closeQuietly(sources[i]);
-        } else {
-          break;
+    /**
+     * Returns a snapshot of the entry named {@code key}, or null if it doesn't
+     * exist is not currently readable. If a value is returned, it is moved to
+     * the head of the LRU queue.
+     */
+    public synchronized Snapshot get(String key) throws IOException {
+        initialize();
+
+        checkNotClosed();
+        validateKey(key);
+        Entry entry = lruEntries.get(key);
+        if (entry == null || !entry.readable) return null;
+
+        Snapshot snapshot = entry.snapshot();
+        if (snapshot == null) return null;
+
+        redundantOpCount++;
+        journalWriter.writeUtf8(READ).writeByte(' ').writeUtf8(key).writeByte('\n');
+        if (journalRebuildRequired()) {
+            executor.execute(cleanupRunnable);
         }
-      }
-      return null;
-    }
 
-    redundantOpCount++;
-    journalWriter.writeUtf8(READ).writeByte(' ').writeUtf8(key).writeByte('\n');
-    if (journalRebuildRequired()) {
-      executorService.execute(cleanupRunnable);
+        return snapshot;
     }
 
-    return new Snapshot(key, entry.sequenceNumber, sources, entry.lengths);
-  }
-
-  /**
-   * Returns an editor for the entry named {@code key}, or null if another
-   * edit is in progress.
-   */
-  public Editor edit(String key) throws IOException {
-    return edit(key, ANY_SEQUENCE_NUMBER);
-  }
-
-  private synchronized Editor edit(String key, long expectedSequenceNumber) throws IOException {
-    checkNotClosed();
-    validateKey(key);
-    Entry entry = lruEntries.get(key);
-    if (expectedSequenceNumber != ANY_SEQUENCE_NUMBER && (entry == null
-        || entry.sequenceNumber != expectedSequenceNumber)) {
-      return null; // Snapshot is stale.
-    }
-    if (entry == null) {
-      entry = new Entry(key);
-      lruEntries.put(key, entry);
-    } else if (entry.currentEditor != null) {
-      return null; // Another edit is in progress.
+    /**
+     * Returns an editor for the entry named {@code key}, or null if another
+     * edit is in progress.
+     */
+    public Editor edit(String key) throws IOException {
+        return edit(key, ANY_SEQUENCE_NUMBER);
     }
 
-    Editor editor = new Editor(entry);
-    entry.currentEditor = editor;
-
-    // Flush the journal before creating files to prevent file leaks.
-    journalWriter.writeUtf8(DIRTY).writeByte(' ').writeUtf8(key).writeByte('\n');
-    journalWriter.flush();
-    return editor;
-  }
-
-  /** Returns the directory where this cache stores its data. */
-  public File getDirectory() {
-    return directory;
-  }
-
-  /**
-   * Returns the maximum number of bytes that this cache should use to store
-   * its data.
-   */
-  public synchronized long getMaxSize() {
-    return maxSize;
-  }
-
-  /**
-   * Changes the maximum number of bytes the cache can store and queues a job
-   * to trim the existing store, if necessary.
-   */
-  public synchronized void setMaxSize(long maxSize) {
-    this.maxSize = maxSize;
-    executorService.execute(cleanupRunnable);
-  }
-
-  /**
-   * Returns the number of bytes currently being used to store the values in
-   * this cache. This may be greater than the max size if a background
-   * deletion is pending.
-   */
-  public synchronized long size() {
-    return size;
-  }
-
-  private synchronized void completeEdit(Editor editor, boolean success) throws IOException {
-    Entry entry = editor.entry;
-    if (entry.currentEditor != editor) {
-      throw new IllegalStateException();
-    }
+    private synchronized Editor edit(String key, long expectedSequenceNumber) throws IOException {
+        initialize();
 
-    // If this edit is creating the entry for the first time, every index must have a value.
-    if (success && !entry.readable) {
-      for (int i = 0; i < valueCount; i++) {
-        if (!editor.written[i]) {
-          editor.abort();
-          throw new IllegalStateException("Newly created entry didn't create value for index " + i);
+        checkNotClosed();
+        validateKey(key);
+        Entry entry = lruEntries.get(key);
+        if (expectedSequenceNumber != ANY_SEQUENCE_NUMBER && (entry == null
+                || entry.sequenceNumber != expectedSequenceNumber)) {
+            return null; // Snapshot is stale.
         }
-        if (!entry.dirtyFiles[i].exists()) {
-          editor.abort();
-          return;
+        if (entry != null && entry.currentEditor != null) {
+            return null; // Another edit is in progress.
         }
-      }
-    }
 
-    for (int i = 0; i < valueCount; i++) {
-      File dirty = entry.dirtyFiles[i];
-      if (success) {
-        if (dirty.exists()) {
-          File clean = entry.cleanFiles[i];
-          dirty.renameTo(clean);
-          long oldLength = entry.lengths[i];
-          long newLength = clean.length();
-          entry.lengths[i] = newLength;
-          size = size - oldLength + newLength;
-        }
-      } else {
-        deleteIfExists(dirty);
-      }
-    }
+        // Flush the journal before creating files to prevent file leaks.
+        journalWriter.writeUtf8(DIRTY).writeByte(' ').writeUtf8(key).writeByte('\n');
+        journalWriter.flush();
 
-    redundantOpCount++;
-    entry.currentEditor = null;
-    if (entry.readable | success) {
-      entry.readable = true;
-      journalWriter.writeUtf8(CLEAN).writeByte(' ');
-      journalWriter.writeUtf8(entry.key);
-      journalWriter.writeUtf8(entry.getLengths());
-      journalWriter.writeByte('\n');
-      if (success) {
-        entry.sequenceNumber = nextSequenceNumber++;
-      }
-    } else {
-      lruEntries.remove(entry.key);
-      journalWriter.writeUtf8(REMOVE).writeByte(' ');
-      journalWriter.writeUtf8(entry.key);
-      journalWriter.writeByte('\n');
-    }
-    journalWriter.flush();
+        if (hasJournalErrors) {
+            return null; // Don't edit; the journal can't be written.
+        }
 
-    if (size > maxSize || journalRebuildRequired()) {
-      executorService.execute(cleanupRunnable);
+        if (entry == null) {
+            entry = new Entry(key);
+            lruEntries.put(key, entry);
+        }
+        Editor editor = new Editor(entry);
+        entry.currentEditor = editor;
+        return editor;
     }
-  }
-
-  /**
-   * We only rebuild the journal when it will halve the size of the journal
-   * and eliminate at least 2000 ops.
-   */
-  private boolean journalRebuildRequired() {
-    final int redundantOpCompactThreshold = 2000;
-    return redundantOpCount >= redundantOpCompactThreshold
-        && redundantOpCount >= lruEntries.size();
-  }
-
-  /**
-   * Drops the entry for {@code key} if it exists and can be removed. If the
-   * entry for {@code key} is currently being edited, that edit will complete
-   * normally but its value will not be stored.
-   *
-   * @return true if an entry was removed.
-   */
-  public synchronized boolean remove(String key) throws IOException {
-    checkNotClosed();
-    validateKey(key);
-    Entry entry = lruEntries.get(key);
-    if (entry == null) return false;
-    return removeEntry(entry);
-  }
-
-  private boolean removeEntry(Entry entry) throws IOException {
-    if (entry.currentEditor != null) {
-      entry.currentEditor.hasErrors = true; // Prevent the edit from completing normally.
+
+    /**
+     * Returns the directory where this cache stores its data.
+     */
+    public File getDirectory() {
+        return directory;
     }
 
-    for (int i = 0; i < valueCount; i++) {
-      File file = entry.cleanFiles[i];
-      deleteIfExists(file);
-      size -= entry.lengths[i];
-      entry.lengths[i] = 0;
+    /**
+     * Returns the maximum number of bytes that this cache should use to store
+     * its data.
+     */
+    public synchronized long getMaxSize() {
+        return maxSize;
     }
 
-    redundantOpCount++;
-    journalWriter.writeUtf8(REMOVE).writeByte(' ').writeUtf8(entry.key).writeByte('\n');
-    lruEntries.remove(entry.key);
+    /**
+     * Changes the maximum number of bytes the cache can store and queues a job
+     * to trim the existing store, if necessary.
+     */
+    public synchronized void setMaxSize(long maxSize) {
+        this.maxSize = maxSize;
+        if (initialized) {
+            executor.execute(cleanupRunnable);
+        }
+    }
 
-    if (journalRebuildRequired()) {
-      executorService.execute(cleanupRunnable);
+    /**
+     * Returns the number of bytes currently being used to store the values in
+     * this cache. This may be greater than the max size if a background
+     * deletion is pending.
+     */
+    public synchronized long size() throws IOException {
+        initialize();
+        return size;
     }
 
-    return true;
-  }
+    private synchronized void completeEdit(Editor editor, boolean success) throws IOException {
+        Entry entry = editor.entry;
+        if (entry.currentEditor != editor) {
+            throw new IllegalStateException();
+        }
 
-  /** Returns true if this cache has been closed. */
-  public boolean isClosed() {
-    return journalWriter == null;
-  }
+        // If this edit is creating the entry for the first time, every index must have a value.
+        if (success && !entry.readable) {
+            for (int i = 0; i < valueCount; i++) {
+                if (!editor.written[i]) {
+                    editor.abort();
+                    throw new IllegalStateException("Newly created entry didn't create value for index " + i);
+                }
+                if (!fileSystem.exists(entry.dirtyFiles[i])) {
+                    editor.abort();
+                    return;
+                }
+            }
+        }
 
-  private void checkNotClosed() {
-    if (journalWriter == null) {
-      throw new IllegalStateException("cache is closed");
-    }
-  }
-
-  /** Force buffered operations to the filesystem. */
-  public synchronized void flush() throws IOException {
-    checkNotClosed();
-    trimToSize();
-    journalWriter.flush();
-  }
-
-  /** Closes this cache. Stored values will remain on the filesystem. */
-  public synchronized void close() throws IOException {
-    if (journalWriter == null) {
-      return; // Already closed.
-    }
-    // Copying for safe iteration.
-    for (Entry entry : lruEntries.values().toArray(new Entry[lruEntries.size()])) {
-      if (entry.currentEditor != null) {
-        entry.currentEditor.abort();
-      }
-    }
-    trimToSize();
-    journalWriter.close();
-    journalWriter = null;
-  }
-
-  private void trimToSize() throws IOException {
-    while (size > maxSize) {
-      Entry toEvict = lruEntries.values().iterator().next();
-      removeEntry(toEvict);
-    }
-  }
-
-  /**
-   * Closes the cache and deletes all of its stored values. This will delete
-   * all files in the cache directory including files that weren't created by
-   * the cache.
-   */
-  public void delete() throws IOException {
-    close();
-    Util.deleteContents(directory);
-  }
-
-  /**
-   * Deletes all stored values from the cache. In-flight edits will complete
-   * normally but their values will not be stored.
-   */
-  public synchronized void evictAll() throws IOException {
-    // Copying for safe iteration.
-    for (Entry entry : lruEntries.values().toArray(new Entry[lruEntries.size()])) {
-      removeEntry(entry);
-    }
-  }
+        for (int i = 0; i < valueCount; i++) {
+            File dirty = entry.dirtyFiles[i];
+            if (success) {
+                if (fileSystem.exists(dirty)) {
+                    File clean = entry.cleanFiles[i];
+                    fileSystem.rename(dirty, clean);
+                    long oldLength = entry.lengths[i];
+                    long newLength = fileSystem.size(clean);
+                    entry.lengths[i] = newLength;
+                    size = size - oldLength + newLength;
+                }
+            } else {
+                fileSystem.delete(dirty);
+            }
+        }
 
-  private void validateKey(String key) {
-    Matcher matcher = LEGAL_KEY_PATTERN.matcher(key);
-    if (!matcher.matches()) {
-      throw new IllegalArgumentException(
-          "keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\"");
-    }
-  }
+        redundantOpCount++;
+        entry.currentEditor = null;
+        if (entry.readable | success) {
+            entry.readable = true;
+            journalWriter.writeUtf8(CLEAN).writeByte(' ');
+            journalWriter.writeUtf8(entry.key);
+            entry.writeLengths(journalWriter);
+            journalWriter.writeByte('\n');
+            if (success) {
+                entry.sequenceNumber = nextSequenceNumber++;
+            }
+        } else {
+            lruEntries.remove(entry.key);
+            journalWriter.writeUtf8(REMOVE).writeByte(' ');
+            journalWriter.writeUtf8(entry.key);
+            journalWriter.writeByte('\n');
+        }
+        journalWriter.flush();
 
-  private static String sourceToString(Source in) throws IOException {
-    try {
-      return Okio.buffer(in).readUtf8();
-    } finally {
-      Util.closeQuietly(in);
-    }
-  }
-
-  /** A snapshot of the values for an entry. */
-  public final class Snapshot implements Closeable {
-    private final String key;
-    private final long sequenceNumber;
-    private final Source[] sources;
-    private final long[] lengths;
-
-    private Snapshot(String key, long sequenceNumber, Source[] sources, long[] lengths) {
-      this.key = key;
-      this.sequenceNumber = sequenceNumber;
-      this.sources = sources;
-      this.lengths = lengths;
+        if (size > maxSize || journalRebuildRequired()) {
+            executor.execute(cleanupRunnable);
+        }
     }
 
     /**
-     * Returns an editor for this snapshot's entry, or null if either the
-     * entry has changed since this snapshot was created or if another edit
-     * is in progress.
+     * We only rebuild the journal when it will halve the size of the journal
+     * and eliminate at least 2000 ops.
      */
-    public Editor edit() throws IOException {
-      return DiskLruCache.this.edit(key, sequenceNumber);
+    private boolean journalRebuildRequired() {
+        final int redundantOpCompactThreshold = 2000;
+        return redundantOpCount >= redundantOpCompactThreshold
+                && redundantOpCount >= lruEntries.size();
     }
 
-    /** Returns the unbuffered stream with the value for {@code index}. */
-    public Source getSource(int index) {
-      return sources[index];
+    /**
+     * Drops the entry for {@code key} if it exists and can be removed. If the
+     * entry for {@code key} is currently being edited, that edit will complete
+     * normally but its value will not be stored.
+     *
+     * @return true if an entry was removed.
+     */
+    public synchronized boolean remove(String key) throws IOException {
+        initialize();
+
+        checkNotClosed();
+        validateKey(key);
+        Entry entry = lruEntries.get(key);
+        if (entry == null) return false;
+        return removeEntry(entry);
     }
 
-    /** Returns the string value for {@code index}. */
-    public String getString(int index) throws IOException {
-      return sourceToString(getSource(index));
-    }
+    private boolean removeEntry(Entry entry) throws IOException {
+        if (entry.currentEditor != null) {
+            entry.currentEditor.hasErrors = true; // Prevent the edit from completing normally.
+        }
 
-    /** Returns the byte length of the value for {@code index}. */
-    public long getLength(int index) {
-      return lengths[index];
-    }
+        for (int i = 0; i < valueCount; i++) {
+            fileSystem.delete(entry.cleanFiles[i]);
+            size -= entry.lengths[i];
+            entry.lengths[i] = 0;
+        }
 
-    public void close() {
-      for (Source in : sources) {
-        Util.closeQuietly(in);
-      }
-    }
-  }
+        redundantOpCount++;
+        journalWriter.writeUtf8(REMOVE).writeByte(' ').writeUtf8(entry.key).writeByte('\n');
+        lruEntries.remove(entry.key);
 
-  private static final Sink NULL_SINK = new Sink() {
-    @Override public void write(Buffer source, long byteCount) throws IOException {
-      // Eat all writes silently. Nom nom.
-    }
+        if (journalRebuildRequired()) {
+            executor.execute(cleanupRunnable);
+        }
 
-    @Override public void flush() throws IOException {
+        return true;
     }
 
-    @Override public Timeout timeout() {
-      return Timeout.NONE;
+    /**
+     * Returns true if this cache has been closed.
+     */
+    public synchronized boolean isClosed() {
+        return closed;
     }
 
-    @Override public void close() throws IOException {
+    private synchronized void checkNotClosed() {
+        if (isClosed()) {
+            throw new IllegalStateException("cache is closed");
+        }
     }
-  };
-
-  /** Edits the values for an entry. */
-  public final class Editor {
-    private final Entry entry;
-    private final boolean[] written;
-    private boolean hasErrors;
-    private boolean committed;
-
-    private Editor(Entry entry) {
-      this.entry = entry;
-      this.written = (entry.readable) ? null : new boolean[valueCount];
+
+    /**
+     * Force buffered operations to the filesystem.
+     */
+    public synchronized void flush() throws IOException {
+        if (!initialized) return;
+
+        checkNotClosed();
+        trimToSize();
+        journalWriter.flush();
     }
 
     /**
-     * Returns an unbuffered input stream to read the last committed value,
-     * or null if no value has been committed.
+     * Closes this cache. Stored values will remain on the filesystem.
      */
-    public Source newSource(int index) throws IOException {
-      synchronized (DiskLruCache.this) {
-        if (entry.currentEditor != this) {
-          throw new IllegalStateException();
+    public synchronized void close() throws IOException {
+        if (!initialized || closed) {
+            closed = true;
+            return;
         }
-        if (!entry.readable) {
-          return null;
+        // Copying for safe iteration.
+        for (Entry entry : lruEntries.values().toArray(new Entry[lruEntries.size()])) {
+            if (entry.currentEditor != null) {
+                entry.currentEditor.abort();
+            }
         }
-        try {
-          return Okio.source(entry.cleanFiles[index]);
-        } catch (FileNotFoundException e) {
-          return null;
+        trimToSize();
+        journalWriter.close();
+        journalWriter = null;
+        closed = true;
+    }
+
+    private void trimToSize() throws IOException {
+        while (size > maxSize) {
+            Entry toEvict = lruEntries.values().iterator().next();
+            removeEntry(toEvict);
         }
-      }
     }
 
     /**
-     * Returns the last committed value as a string, or null if no value
-     * has been committed.
+     * Closes the cache and deletes all of its stored values. This will delete
+     * all files in the cache directory including files that weren't created by
+     * the cache.
      */
-    public String getString(int index) throws IOException {
-      Source source = newSource(index);
-      return source != null ? sourceToString(source) : null;
+    public void delete() throws IOException {
+        close();
+        fileSystem.deleteContents(directory);
     }
 
     /**
-     * Returns a new unbuffered output stream to write the value at
-     * {@code index}. If the underlying output stream encounters errors
-     * when writing to the filesystem, this edit will be aborted when
-     * {@link #commit} is called. The returned output stream does not throw
-     * IOExceptions.
+     * Deletes all stored values from the cache. In-flight edits will complete
+     * normally but their values will not be stored.
      */
-    public Sink newSink(int index) throws IOException {
-      synchronized (DiskLruCache.this) {
-        if (entry.currentEditor != this) {
-          throw new IllegalStateException();
+    public synchronized void evictAll() throws IOException {
+        initialize();
+        // Copying for safe iteration.
+        for (Entry entry : lruEntries.values().toArray(new Entry[lruEntries.size()])) {
+            removeEntry(entry);
         }
-        if (!entry.readable) {
-          written[index] = true;
+    }
+
+    private void validateKey(String key) {
+        Matcher matcher = LEGAL_KEY_PATTERN.matcher(key);
+        if (!matcher.matches()) {
+            throw new IllegalArgumentException(
+                    "keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\"");
         }
-        File dirtyFile = entry.dirtyFiles[index];
-        Sink sink;
-        try {
-          sink = Okio.sink(dirtyFile);
-        } catch (FileNotFoundException e) {
-          // Attempt to recreate the cache directory.
-          directory.mkdirs();
-          try {
-            sink = Okio.sink(dirtyFile);
-          } catch (FileNotFoundException e2) {
-            // We are unable to recover. Silently eat the writes.
-            return NULL_SINK;
-          }
-        }
-        return new FaultHidingSink(sink);
-      }
     }
 
-    /** Sets the value at {@code index} to {@code value}. */
-    public void set(int index, String value) throws IOException {
-      BufferedSink writer = Okio.buffer(newSink(index));
-      writer.writeUtf8(value);
-      writer.close();
+    /**
+     * Returns an iterator over the cache's current entries. This iterator doesn't throw {@code
+     * ConcurrentModificationException}, but if new entries are added while iterating, those new
+     * entries will not be returned by the iterator. If existing entries are removed during iteration,
+     * they will be absent (unless they were already returned).
+     * <p/>
+     * <p>If there are I/O problems during iteration, this iterator fails silently. For example, if
+     * the hosting filesystem becomes unreachable, the iterator will omit elements rather than
+     * throwing exceptions.
+     * <p/>
+     * <p><strong>The caller must {@link Snapshot#close close}</strong> each snapshot returned by
+     * {@link Iterator#next}. Failing to do so leaks open files!
+     * <p/>
+     * <p>The returned iterator supports {@link Iterator#remove}.
+     */
+    public synchronized Iterator<Snapshot> snapshots() throws IOException {
+        initialize();
+        return new Iterator<Snapshot>() {
+            /** Iterate a copy of the entries to defend against concurrent modification errors. */
+            final Iterator<Entry> delegate = new ArrayList<>(lruEntries.values()).iterator();
+
+            /** The snapshot to return from {@link #next}. Null if we haven't computed that yet. */
+            Snapshot nextSnapshot;
+
+            /** The snapshot to remove with {@link #remove}. Null if removal is illegal. */
+            Snapshot removeSnapshot;
+
+            @Override
+            public boolean hasNext() {
+                if (nextSnapshot != null) return true;
+
+                synchronized (DiskLruCache.this) {
+                    // If the cache is closed, truncate the iterator.
+                    if (closed) return false;
+
+                    while (delegate.hasNext()) {
+                        Entry entry = delegate.next();
+                        Snapshot snapshot = entry.snapshot();
+                        if (snapshot == null) continue; // Evicted since we copied the entries.
+                        nextSnapshot = snapshot;
+                        return true;
+                    }
+                }
+
+                return false;
+            }
+
+            @Override
+            public Snapshot next() {
+                if (!hasNext()) throw new NoSuchElementException();
+                removeSnapshot = nextSnapshot;
+                nextSnapshot = null;
+                return removeSnapshot;
+            }
+
+            @Override
+            public void remove() {
+                if (removeSnapshot == null)
+                    throw new IllegalStateException("remove() before next()");
+                try {
+                    DiskLruCache.this.remove(removeSnapshot.key);
+                } catch (IOException ignored) {
+                    // Nothing useful to do here. We failed to remove from the cache. Most likely that's
+                    // because we couldn't update the journal, but the cached entry will still be gone.
+                } finally {
+                    removeSnapshot = null;
+                }
+            }
+        };
     }
 
     /**
-     * Commits this edit so it is visible to readers.  This releases the
-     * edit lock so another edit may be started on the same key.
+     * A snapshot of the values for an entry.
      */
-    public void commit() throws IOException {
-      synchronized (DiskLruCache.this) {
-        if (hasErrors) {
-          completeEdit(this, false);
-          removeEntry(entry); // The previous entry is stale.
-        } else {
-          completeEdit(this, true);
+    public final class Snapshot implements Closeable {
+        private final String key;
+        private final long sequenceNumber;
+        private final Source[] sources;
+        private final long[] lengths;
+
+        private Snapshot(String key, long sequenceNumber, Source[] sources, long[] lengths) {
+            this.key = key;
+            this.sequenceNumber = sequenceNumber;
+            this.sources = sources;
+            this.lengths = lengths;
+        }
+
+        public String key() {
+            return key;
+        }
+
+        /**
+         * Returns an editor for this snapshot's entry, or null if either the
+         * entry has changed since this snapshot was created or if another edit
+         * is in progress.
+         */
+        public Editor edit() throws IOException {
+            return DiskLruCache.this.edit(key, sequenceNumber);
+        }
+
+        /**
+         * Returns the unbuffered stream with the value for {@code index}.
+         */
+        public Source getSource(int index) {
+            return sources[index];
+        }
+
+        /**
+         * Returns the byte length of the value for {@code index}.
+         */
+        public long getLength(int index) {
+            return lengths[index];
+        }
+
+        public void close() {
+            for (Source in : sources) {
+                Util.closeQuietly(in);
+            }
         }
-        committed = true;
-      }
     }
 
+    private static final Sink NULL_SINK = new Sink() {
+        @Override
+        public void write(Buffer source, long byteCount) throws IOException {
+            source.skip(byteCount);
+        }
+
+        @Override
+        public void flush() throws IOException {
+        }
+
+        @Override
+        public Timeout timeout() {
+            return Timeout.NONE;
+        }
+
+        @Override
+        public void close() throws IOException {
+        }
+    };
+
     /**
-     * Aborts this edit. This releases the edit lock so another edit may be
-     * started on the same key.
+     * Edits the values for an entry.
      */
-    public void abort() throws IOException {
-      synchronized (DiskLruCache.this) {
-        completeEdit(this, false);
-      }
-    }
+    public final class Editor {
+        private final Entry entry;
+        private final boolean[] written;
+        private boolean hasErrors;
+        private boolean committed;
+
+        private Editor(Entry entry) {
+            this.entry = entry;
+            this.written = (entry.readable) ? null : new boolean[valueCount];
+        }
 
-    public void abortUnlessCommitted() {
-      synchronized (DiskLruCache.this) {
-        if (!committed) {
-          try {
-            completeEdit(this, false);
-          } catch (IOException ignored) {
-          }
+        /**
+         * Returns an unbuffered input stream to read the last committed value,
+         * or null if no value has been committed.
+         */
+        public Source newSource(int index) throws IOException {
+            synchronized (DiskLruCache.this) {
+                if (entry.currentEditor != this) {
+                    throw new IllegalStateException();
+                }
+                if (!entry.readable) {
+                    return null;
+                }
+                try {
+                    return fileSystem.source(entry.cleanFiles[index]);
+                } catch (FileNotFoundException e) {
+                    return null;
+                }
+            }
         }
-      }
-    }
 
-    private class FaultHidingSink extends ForwardingSink {
-      public FaultHidingSink(Sink delegate) {
-        super(delegate);
-      }
+        /**
+         * Returns a new unbuffered output stream to write the value at
+         * {@code index}. If the underlying output stream encounters errors
+         * when writing to the filesystem, this edit will be aborted when
+         * {@link #commit} is called. The returned output stream does not throw
+         * IOExceptions.
+         */
+        public Sink newSink(int index) throws IOException {
+            synchronized (DiskLruCache.this) {
+                if (entry.currentEditor != this) {
+                    throw new IllegalStateException();
+                }
+                if (!entry.readable) {
+                    written[index] = true;
+                }
+                File dirtyFile = entry.dirtyFiles[index];
+                Sink sink;
+                try {
+                    sink = fileSystem.sink(dirtyFile);
+                } catch (FileNotFoundException e) {
+                    return NULL_SINK;
+                }
+                return new FaultHidingSink(sink) {
+                    @Override
+                    protected void onException(IOException e) {
+                        synchronized (DiskLruCache.this) {
+                            hasErrors = true;
+                        }
+                    }
+                };
+            }
+        }
 
-      @Override public void write(Buffer source, long byteCount) throws IOException {
-        try {
-          super.write(source, byteCount);
-        } catch (IOException e) {
-          synchronized (DiskLruCache.this) {
-            hasErrors = true;
-          }
+        /**
+         * Commits this edit so it is visible to readers.  This releases the
+         * edit lock so another edit may be started on the same key.
+         */
+        public void commit() throws IOException {
+            synchronized (DiskLruCache.this) {
+                if (hasErrors) {
+                    completeEdit(this, false);
+                    removeEntry(entry); // The previous entry is stale.
+                } else {
+                    completeEdit(this, true);
+                }
+                committed = true;
+            }
         }
-      }
 
-      @Override public void flush() throws IOException {
-        try {
-          super.flush();
-        } catch (IOException e) {
-          synchronized (DiskLruCache.this) {
-            hasErrors = true;
-          }
+        /**
+         * Aborts this edit. This releases the edit lock so another edit may be
+         * started on the same key.
+         */
+        public void abort() throws IOException {
+            synchronized (DiskLruCache.this) {
+                completeEdit(this, false);
+            }
         }
-      }
 
-      @Override public void close() throws IOException {
-        try {
-          super.close();
-        } catch (IOException e) {
-          synchronized (DiskLruCache.this) {
-            hasErrors = true;
-          }
+        public void abortUnlessCommitted() {
+            synchronized (DiskLruCache.this) {
+                if (!committed) {
+                    try {
+                        completeEdit(this, false);
+                    } catch (IOException ignored) {
+                    }
+                }
+            }
         }
-      }
-    }
-  }
-
-  private final class Entry {
-    private final String key;
-
-    /** Lengths of this entry's files. */
-    private final long[] lengths;
-    private final File[] cleanFiles;
-    private final File[] dirtyFiles;
-
-    /** True if this entry has ever been published. */
-    private boolean readable;
-
-    /** The ongoing edit or null if this entry is not being edited. */
-    private Editor currentEditor;
-
-    /** The sequence number of the most recently committed edit to this entry. */
-    private long sequenceNumber;
-
-    private Entry(String key) {
-      this.key = key;
-
-      lengths = new long[valueCount];
-      cleanFiles = new File[valueCount];
-      dirtyFiles = new File[valueCount];
-
-      // The names are repetitive so re-use the same builder to avoid allocations.
-      StringBuilder fileBuilder = new StringBuilder(key).append('.');
-      int truncateTo = fileBuilder.length();
-      for (int i = 0; i < valueCount; i++) {
-        fileBuilder.append(i);
-        cleanFiles[i] = new File(directory, fileBuilder.toString());
-        fileBuilder.append(".tmp");
-        dirtyFiles[i] = new File(directory, fileBuilder.toString());
-        fileBuilder.setLength(truncateTo);
-      }
     }
 
-    public String getLengths() throws IOException {
-      StringBuilder result = new StringBuilder();
-      for (long size : lengths) {
-        result.append(' ').append(size);
-      }
-      return result.toString();
-    }
+    private final class Entry {
+        private final String key;
+
+        /**
+         * Lengths of this entry's files.
+         */
+        private final long[] lengths;
+        private final File[] cleanFiles;
+        private final File[] dirtyFiles;
+
+        /**
+         * True if this entry has ever been published.
+         */
+        private boolean readable;
+
+        /**
+         * The ongoing edit or null if this entry is not being edited.
+         */
+        private Editor currentEditor;
+
+        /**
+         * The sequence number of the most recently committed edit to this entry.
+         */
+        private long sequenceNumber;
+
+        private Entry(String key) {
+            this.key = key;
+
+            lengths = new long[valueCount];
+            cleanFiles = new File[valueCount];
+            dirtyFiles = new File[valueCount];
+
+            // The names are repetitive so re-use the same builder to avoid allocations.
+            StringBuilder fileBuilder = new StringBuilder(key).append('.');
+            int truncateTo = fileBuilder.length();
+            for (int i = 0; i < valueCount; i++) {
+                fileBuilder.append(i);
+                cleanFiles[i] = new File(directory, fileBuilder.toString());
+                fileBuilder.append(".tmp");
+                dirtyFiles[i] = new File(directory, fileBuilder.toString());
+                fileBuilder.setLength(truncateTo);
+            }
+        }
 
-    /** Set lengths using decimal numbers like "10123". */
-    private void setLengths(String[] strings) throws IOException {
-      if (strings.length != valueCount) {
-        throw invalidLengths(strings);
-      }
+        /**
+         * Set lengths using decimal numbers like "10123".
+         */
+        private void setLengths(String[] strings) throws IOException {
+            if (strings.length != valueCount) {
+                throw invalidLengths(strings);
+            }
+
+            try {
+                for (int i = 0; i < strings.length; i++) {
+                    lengths[i] = Long.parseLong(strings[i]);
+                }
+            } catch (NumberFormatException e) {
+                throw invalidLengths(strings);
+            }
+        }
 
-      try {
-        for (int i = 0; i < strings.length; i++) {
-          lengths[i] = Long.parseLong(strings[i]);
+        /**
+         * Append space-prefixed lengths to {@code writer}.
+         */
+        void writeLengths(BufferedSink writer) throws IOException {
+            for (long length : lengths) {
+                writer.writeByte(' ').writeDecimalLong(length);
+            }
+        }
+
+        private IOException invalidLengths(String[] strings) throws IOException {
+            throw new IOException("unexpected journal line: " + Arrays.toString(strings));
         }
-      } catch (NumberFormatException e) {
-        throw invalidLengths(strings);
-      }
-    }
 
-    private IOException invalidLengths(String[] strings) throws IOException {
-      throw new IOException("unexpected journal line: " + Arrays.toString(strings));
+        /**
+         * Returns a snapshot of this entry. This opens all streams eagerly to guarantee that we see a
+         * single published snapshot. If we opened streams lazily then the streams could come from
+         * different edits.
+         */
+        Snapshot snapshot() {
+            if (!Thread.holdsLock(DiskLruCache.this)) throw new AssertionError();
+
+            Source[] sources = new Source[valueCount];
+            long[] lengths = this.lengths.clone(); // Defensive copy since these can be zeroed out.
+            try {
+                for (int i = 0; i < valueCount; i++) {
+                    sources[i] = fileSystem.source(cleanFiles[i]);
+                }
+                return new Snapshot(key, sequenceNumber, sources, lengths);
+            } catch (FileNotFoundException e) {
+                // A file must have been deleted manually!
+                for (int i = 0; i < valueCount; i++) {
+                    if (sources[i] != null) {
+                        Util.closeQuietly(sources[i]);
+                    } else {
+                        break;
+                    }
+                }
+                return null;
+            }
+        }
     }
-  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/FaultHidingSink.java b/okhttp/src/main/java/com/squareup/okhttp/internal/FaultHidingSink.java
new file mode 100644
index 0000000000..91e990db8d
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/FaultHidingSink.java
@@ -0,0 +1,51 @@
+package com.squareup.okhttp.internal;
+
+import java.io.IOException;
+import okio.Buffer;
+import okio.ForwardingSink;
+import okio.Sink;
+
+/** A sink that never throws IOExceptions, even if the underlying sink does. */
+class FaultHidingSink extends ForwardingSink {
+  private boolean hasErrors;
+
+  public FaultHidingSink(Sink delegate) {
+    super(delegate);
+  }
+
+  @Override public void write(Buffer source, long byteCount) throws IOException {
+    if (hasErrors) {
+      source.skip(byteCount);
+      return;
+    }
+    try {
+      super.write(source, byteCount);
+    } catch (IOException e) {
+      hasErrors = true;
+      onException(e);
+    }
+  }
+
+  @Override public void flush() throws IOException {
+    if (hasErrors) return;
+    try {
+      super.flush();
+    } catch (IOException e) {
+      hasErrors = true;
+      onException(e);
+    }
+  }
+
+  @Override public void close() throws IOException {
+    if (hasErrors) return;
+    try {
+      super.close();
+    } catch (IOException e) {
+      hasErrors = true;
+      onException(e);
+    }
+  }
+
+  protected void onException(IOException e) {
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/Internal.java b/okhttp/src/main/java/com/squareup/okhttp/internal/Internal.java
index 40a7cbce15..1e583ba1b3 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/Internal.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/Internal.java
@@ -15,16 +15,23 @@
  */
 package com.squareup.okhttp.internal;
 
+import com.squareup.okhttp.Call;
+import com.squareup.okhttp.Callback;
 import com.squareup.okhttp.Connection;
 import com.squareup.okhttp.ConnectionPool;
+import com.squareup.okhttp.ConnectionSpec;
 import com.squareup.okhttp.Headers;
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.internal.http.HttpEngine;
+import com.squareup.okhttp.internal.http.RouteException;
 import com.squareup.okhttp.internal.http.Transport;
 import java.io.IOException;
 import java.util.logging.Logger;
+import javax.net.ssl.SSLSocket;
+import okio.BufferedSink;
+import okio.BufferedSource;
 
 /**
  * Escalate internal APIs in {@code com.squareup.okhttp} so they can be used
@@ -33,6 +40,12 @@
  */
 public abstract class Internal {
   public static final Logger logger = Logger.getLogger(OkHttpClient.class.getName());
+
+  public static void initializeInstanceForTests() {
+    // Needed in tests to ensure that the instance is actually pointing to something.
+    new OkHttpClient();
+  }
+
   public static Internal instance;
 
   public abstract Transport newTransport(Connection connection, HttpEngine httpEngine)
@@ -50,7 +63,9 @@ public abstract Transport newTransport(Connection connection, HttpEngine httpEng
 
   public abstract boolean isReadable(Connection pooled);
 
-  public abstract void addLine(Headers.Builder builder, String line);
+  public abstract void addLenient(Headers.Builder builder, String line);
+
+  public abstract void addLenient(Headers.Builder builder, String name, String value);
 
   public abstract void setCache(OkHttpClient client, InternalCache internalCache);
 
@@ -65,5 +80,16 @@ public abstract Transport newTransport(Connection connection, HttpEngine httpEng
   public abstract void setNetwork(OkHttpClient client, Network network);
 
   public abstract void connectAndSetOwner(OkHttpClient client, Connection connection,
-      HttpEngine owner, Request request) throws IOException;
+      HttpEngine owner, Request request) throws RouteException;
+
+  public abstract void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket,
+      boolean isFallback);
+
+  // TODO delete the following when web sockets move into the main package.
+  public abstract void callEnqueue(Call call, Callback responseCallback, boolean forWebSocket);
+  public abstract void callEngineReleaseConnection(Call call) throws IOException;
+  public abstract Connection callEngineGetConnection(Call call);
+  public abstract BufferedSource connectionRawSource(Connection connection);
+  public abstract BufferedSink connectionRawSink(Connection connection);
+  public abstract void connectionSetOwner(Connection connection, Object owner);
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/NamedRunnable.java b/okhttp/src/main/java/com/squareup/okhttp/internal/NamedRunnable.java
index 992b2ae419..7a02ecfbde 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/NamedRunnable.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/NamedRunnable.java
@@ -20,7 +20,7 @@
  * Runnable implementation which always sets its thread name.
  */
 public abstract class NamedRunnable implements Runnable {
-  private final String name;
+  protected final String name;
 
   public NamedRunnable(String format, Object... args) {
     this.name = String.format(format, args);
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/Platform.java b/okhttp/src/main/java/com/squareup/okhttp/internal/Platform.java
index b1182d7e86..b9064959e0 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/Platform.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/Platform.java
@@ -25,9 +25,6 @@
 import java.net.InetSocketAddress;
 import java.net.Socket;
 import java.net.SocketException;
-import java.net.URI;
-import java.net.URISyntaxException;
-import java.net.URL;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.logging.Level;
@@ -37,27 +34,22 @@
 import static com.squareup.okhttp.internal.Internal.logger;
 
 /**
- * Access to Platform-specific features necessary for SPDY and advanced TLS.
- * This includes Server Name Indication (SNI) and session tickets.
+ * Access to platform-specific features.
  *
- * <h3>ALPN and NPN</h3>
- * This class uses TLS extensions ALPN and NPN to negotiate the upgrade from
- * HTTP/1.1 (the default protocol to use with TLS on port 443) to either SPDY
- * or HTTP/2.
+ * <h3>Server name indication (SNI)</h3>
+ * Supported on Android 2.3+.
  *
- * <p>NPN (Next Protocol Negotiation) was developed for SPDY. It is widely
- * available and we support it on both Android (4.1+) and OpenJDK 7 (via the
- * Jetty Alpn-boot library). NPN is not yet available on OpenJDK 8.
+ * <h3>Session Tickets</h3>
+ * Supported on Android 2.3+.
  *
- * <p>ALPN (Application Layer Protocol Negotiation) is the successor to NPN. It
- * has some technical advantages over NPN. ALPN first arrived in Android 4.4,
- * but that release suffers a <a href="http://goo.gl/y5izPP">concurrency bug</a>
- * so we don't use it. ALPN is supported on OpenJDK 7 and 8 (via the Jetty
- * ALPN-boot library).
+ * <h3>Android Traffic Stats (Socket Tagging)</h3>
+ * Supported on Android 4.0+.
  *
- * <p>On platforms that support both extensions, OkHttp will use both,
- * preferring ALPN's result. Future versions of OkHttp will drop support for
- * NPN.
+ * <h3>ALPN (Application Layer Protocol Negotiation)</h3>
+ * Supported on Android 5.0+. The APIs were present in Android 4.4, but that implementation was
+ * unstable.
+ *
+ * Supported on OpenJDK 7 and 8 (via the JettyALPN-boot library).
  */
 public class Platform {
   private static final Platform PLATFORM = findPlatform();
@@ -81,10 +73,6 @@ public void tagSocket(Socket socket) throws SocketException {
   public void untagSocket(Socket socket) throws SocketException {
   }
 
-  public URI toUriLenient(URL url) throws URISyntaxException {
-    return url.toURI(); // this isn't as good as the built-in toUriLenient
-  }
-
   /**
    * Configure TLS extensions on {@code sslSocket} for {@code route}.
    *
@@ -95,6 +83,13 @@ public void configureTlsExtensions(SSLSocket sslSocket, String hostname,
       List<Protocol> protocols) {
   }
 
+  /**
+   * Called after the TLS handshake to release resources allocated by {@link
+   * #configureTlsExtensions}.
+   */
+  public void afterHandshake(SSLSocket sslSocket) {
+  }
+
   /** Returns the negotiated protocol, or null if no protocol was negotiated. */
   public String getSelectedProtocol(SSLSocket socket) {
     return null;
@@ -111,82 +106,82 @@ private static Platform findPlatform() {
     try {
       try {
         Class.forName("com.android.org.conscrypt.OpenSSLSocketImpl");
-      } catch (ClassNotFoundException ignored) {
+      } catch (ClassNotFoundException e) {
         // Older platform before being unbundled.
         Class.forName("org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl");
       }
 
-      // Attempt to find Android 4.0+ APIs.
+      OptionalMethod<Socket> setUseSessionTickets
+          = new OptionalMethod<>(null, "setUseSessionTickets", boolean.class);
+      OptionalMethod<Socket> setHostname
+          = new OptionalMethod<>(null, "setHostname", String.class);
       Method trafficStatsTagSocket = null;
       Method trafficStatsUntagSocket = null;
+      OptionalMethod<Socket> getAlpnSelectedProtocol = null;
+      OptionalMethod<Socket> setAlpnProtocols = null;
+
+      // Attempt to find Android 4.0+ APIs.
       try {
         Class<?> trafficStats = Class.forName("android.net.TrafficStats");
         trafficStatsTagSocket = trafficStats.getMethod("tagSocket", Socket.class);
         trafficStatsUntagSocket = trafficStats.getMethod("untagSocket", Socket.class);
-      } catch (ClassNotFoundException ignored) {
-      } catch (NoSuchMethodException ignored) {
+
+        // Attempt to find Android 5.0+ APIs.
+        try {
+          Class.forName("android.net.Network"); // Arbitrary class added in Android 5.0.
+          getAlpnSelectedProtocol = new OptionalMethod<>(byte[].class, "getAlpnSelectedProtocol");
+          setAlpnProtocols = new OptionalMethod<>(null, "setAlpnProtocols", byte[].class);
+        } catch (ClassNotFoundException ignored) {
+        }
+      } catch (ClassNotFoundException | NoSuchMethodException ignored) {
       }
 
-      return new Android(trafficStatsTagSocket, trafficStatsUntagSocket);
+      return new Android(setUseSessionTickets, setHostname, trafficStatsTagSocket,
+          trafficStatsUntagSocket, getAlpnSelectedProtocol, setAlpnProtocols);
     } catch (ClassNotFoundException ignored) {
       // This isn't an Android runtime.
     }
 
-    try { // to find the Jetty's ALPN or NPN extension for OpenJDK.
+    // Find Jetty's ALPN extension for OpenJDK.
+    try {
       String negoClassName = "org.eclipse.jetty.alpn.ALPN";
-      Class<?> negoClass;
-      try {
-        negoClass = Class.forName(negoClassName);
-      } catch (ClassNotFoundException ignored) { // ALPN isn't on the classpath.
-        negoClassName = "org.eclipse.jetty.npn.NextProtoNego";
-        negoClass = Class.forName(negoClassName);
-      }
+      Class<?> negoClass = Class.forName(negoClassName);
       Class<?> providerClass = Class.forName(negoClassName + "$Provider");
       Class<?> clientProviderClass = Class.forName(negoClassName + "$ClientProvider");
       Class<?> serverProviderClass = Class.forName(negoClassName + "$ServerProvider");
       Method putMethod = negoClass.getMethod("put", SSLSocket.class, providerClass);
       Method getMethod = negoClass.getMethod("get", SSLSocket.class);
+      Method removeMethod = negoClass.getMethod("remove", SSLSocket.class);
       return new JdkWithJettyBootPlatform(
-          putMethod, getMethod, clientProviderClass, serverProviderClass);
-    } catch (ClassNotFoundException ignored) { // NPN isn't on the classpath.
-    } catch (NoSuchMethodException ignored) { // The ALPN or NPN version isn't what we expect.
+          putMethod, getMethod, removeMethod, clientProviderClass, serverProviderClass);
+    } catch (ClassNotFoundException | NoSuchMethodException ignored) {
     }
 
     return new Platform();
   }
 
-  /**
-   * Android 2.3 or better. Version 2.3 supports TLS session tickets and server
-   * name indication (SNI). Versions 4.1 supports NPN.
-   */
+  /** Android 2.3 or better. */
   private static class Android extends Platform {
-
-    // setUseSessionTickets(boolean)
-    private static final OptionalMethod<Socket> SET_USE_SESSION_TICKETS =
-        new OptionalMethod<Socket>(null, "setUseSessionTickets", Boolean.TYPE);
-    // setHostname(String)
-    private static final OptionalMethod<Socket> SET_HOSTNAME =
-        new OptionalMethod<Socket>(null, "setHostname", String.class);
-    // byte[] getAlpnSelectedProtocol()
-    private static final OptionalMethod<Socket> GET_ALPN_SELECTED_PROTOCOL =
-        new OptionalMethod<Socket>(byte[].class, "getAlpnSelectedProtocol");
-    // setAlpnSelectedProtocol(byte[])
-    private static final OptionalMethod<Socket> SET_ALPN_PROTOCOLS =
-        new OptionalMethod<Socket>(null, "setAlpnProtocols", byte[].class);
-    // byte[] getNpnSelectedProtocol()
-    private static final OptionalMethod<Socket> GET_NPN_SELECTED_PROTOCOL =
-        new OptionalMethod<Socket>(byte[].class, "getNpnSelectedProtocol");
-    // setNpnSelectedProtocol(byte[])
-    private static final OptionalMethod<Socket> SET_NPN_PROTOCOLS =
-        new OptionalMethod<Socket>(null, "setNpnProtocols", byte[].class);
+    private final OptionalMethod<Socket> setUseSessionTickets;
+    private final OptionalMethod<Socket> setHostname;
 
     // Non-null on Android 4.0+.
     private final Method trafficStatsTagSocket;
     private final Method trafficStatsUntagSocket;
 
-    private Android(Method trafficStatsTagSocket, Method trafficStatsUntagSocket) {
+    // Non-null on Android 5.0+.
+    private final OptionalMethod<Socket> getAlpnSelectedProtocol;
+    private final OptionalMethod<Socket> setAlpnProtocols;
+
+    public Android(OptionalMethod<Socket> setUseSessionTickets, OptionalMethod<Socket> setHostname,
+        Method trafficStatsTagSocket, Method trafficStatsUntagSocket,
+        OptionalMethod<Socket> getAlpnSelectedProtocol, OptionalMethod<Socket> setAlpnProtocols) {
+      this.setUseSessionTickets = setUseSessionTickets;
+      this.setHostname = setHostname;
       this.trafficStatsTagSocket = trafficStatsTagSocket;
       this.trafficStatsUntagSocket = trafficStatsUntagSocket;
+      this.getAlpnSelectedProtocol = getAlpnSelectedProtocol;
+      this.setAlpnProtocols = setAlpnProtocols;
     }
 
     @Override public void connectSocket(Socket socket, InetSocketAddress address,
@@ -206,49 +201,23 @@ private Android(Method trafficStatsTagSocket, Method trafficStatsUntagSocket) {
         SSLSocket sslSocket, String hostname, List<Protocol> protocols) {
       // Enable SNI and session tickets.
       if (hostname != null) {
-        SET_USE_SESSION_TICKETS.invokeOptionalWithoutCheckedException(sslSocket, true);
-        SET_HOSTNAME.invokeOptionalWithoutCheckedException(sslSocket, hostname);
-      }
-
-      // Enable NPN / ALPN.
-      boolean alpnSupported = SET_ALPN_PROTOCOLS.isSupported(sslSocket);
-      boolean npnSupported = SET_NPN_PROTOCOLS.isSupported(sslSocket);
-      if (!(alpnSupported || npnSupported)) {
-        return;
+        setUseSessionTickets.invokeOptionalWithoutCheckedException(sslSocket, true);
+        setHostname.invokeOptionalWithoutCheckedException(sslSocket, hostname);
       }
 
-      Object[] parameters = { concatLengthPrefixed(protocols) };
-      if (alpnSupported) {
-        SET_ALPN_PROTOCOLS.invokeWithoutCheckedException(sslSocket, parameters);
-      }
-      if (npnSupported) {
-        SET_NPN_PROTOCOLS.invokeWithoutCheckedException(sslSocket, parameters);
+      // Enable ALPN.
+      if (setAlpnProtocols != null && setAlpnProtocols.isSupported(sslSocket)) {
+        Object[] parameters = { concatLengthPrefixed(protocols) };
+        setAlpnProtocols.invokeWithoutCheckedException(sslSocket, parameters);
       }
     }
 
     @Override public String getSelectedProtocol(SSLSocket socket) {
-      boolean alpnSupported = GET_ALPN_SELECTED_PROTOCOL.isSupported(socket);
-      boolean npnSupported = GET_NPN_SELECTED_PROTOCOL.isSupported(socket);
-      if (!(alpnSupported || npnSupported)) {
-        return null;
-      }
+      if (getAlpnSelectedProtocol == null) return null;
+      if (!getAlpnSelectedProtocol.isSupported(socket)) return null;
 
-      // Prefer ALPN's result if it is present.
-      if (alpnSupported) {
-        byte[] alpnResult =
-            (byte[]) GET_ALPN_SELECTED_PROTOCOL.invokeWithoutCheckedException(socket);
-        if (alpnResult != null) {
-          return new String(alpnResult, Util.UTF_8);
-        }
-      }
-      if (npnSupported) {
-        byte[] npnResult =
-            (byte[]) GET_NPN_SELECTED_PROTOCOL.invokeWithoutCheckedException(socket);
-        if (npnResult != null) {
-          return new String(npnResult, Util.UTF_8);
-        }
-      }
-      return null;
+      byte[] alpnResult = (byte[]) getAlpnSelectedProtocol.invokeWithoutCheckedException(socket);
+      return alpnResult != null ? new String(alpnResult, Util.UTF_8) : null;
     }
 
     @Override public void tagSocket(Socket socket) throws SocketException {
@@ -277,19 +246,20 @@ private Android(Method trafficStatsTagSocket, Method trafficStatsUntagSocket) {
   }
 
   /**
-   * OpenJDK 7+ with {@code org.mortbay.jetty.npn/npn-boot} or
-   * {@code org.mortbay.jetty.alpn/alpn-boot} in the boot class path.
+   * OpenJDK 7+ with {@code org.mortbay.jetty.alpn/alpn-boot} in the boot class path.
    */
   private static class JdkWithJettyBootPlatform extends Platform {
-    private final Method getMethod;
     private final Method putMethod;
+    private final Method getMethod;
+    private final Method removeMethod;
     private final Class<?> clientProviderClass;
     private final Class<?> serverProviderClass;
 
-    public JdkWithJettyBootPlatform(Method putMethod, Method getMethod,
+    public JdkWithJettyBootPlatform(Method putMethod, Method getMethod, Method removeMethod,
         Class<?> clientProviderClass, Class<?> serverProviderClass) {
       this.putMethod = putMethod;
       this.getMethod = getMethod;
+      this.removeMethod = removeMethod;
       this.clientProviderClass = clientProviderClass;
       this.serverProviderClass = serverProviderClass;
     }
@@ -299,48 +269,52 @@ public JdkWithJettyBootPlatform(Method putMethod, Method getMethod,
       List<String> names = new ArrayList<>(protocols.size());
       for (int i = 0, size = protocols.size(); i < size; i++) {
         Protocol protocol = protocols.get(i);
-        if (protocol == Protocol.HTTP_1_0) continue; // No HTTP/1.0 for NPN or ALPN.
+        if (protocol == Protocol.HTTP_1_0) continue; // No HTTP/1.0 for ALPN.
         names.add(protocol.toString());
       }
       try {
         Object provider = Proxy.newProxyInstance(Platform.class.getClassLoader(),
             new Class[] { clientProviderClass, serverProviderClass }, new JettyNegoProvider(names));
         putMethod.invoke(null, sslSocket, provider);
-      } catch (InvocationTargetException e) {
-        throw new AssertionError(e);
-      } catch (IllegalAccessException e) {
+      } catch (InvocationTargetException | IllegalAccessException e) {
         throw new AssertionError(e);
       }
     }
 
+    @Override public void afterHandshake(SSLSocket sslSocket) {
+      try {
+        removeMethod.invoke(null, sslSocket);
+      } catch (IllegalAccessException | InvocationTargetException ignored) {
+        throw new AssertionError();
+      }
+    }
+
     @Override public String getSelectedProtocol(SSLSocket socket) {
       try {
         JettyNegoProvider provider =
             (JettyNegoProvider) Proxy.getInvocationHandler(getMethod.invoke(null, socket));
         if (!provider.unsupported && provider.selected == null) {
-          logger.log(Level.INFO, "NPN/ALPN callback dropped: SPDY and HTTP/2 are disabled. "
-              + "Is npn-boot or alpn-boot on the boot class path?");
+          logger.log(Level.INFO, "ALPN callback dropped: SPDY and HTTP/2 are disabled. "
+              + "Is alpn-boot on the boot class path?");
           return null;
         }
         return provider.unsupported ? null : provider.selected;
-      } catch (InvocationTargetException e) {
-        throw new AssertionError();
-      } catch (IllegalAccessException e) {
+      } catch (InvocationTargetException | IllegalAccessException e) {
         throw new AssertionError();
       }
     }
   }
 
   /**
-   * Handle the methods of NPN or ALPN's ClientProvider and ServerProvider
+   * Handle the methods of ALPN's ClientProvider and ServerProvider
    * without a compile-time dependency on those interfaces.
    */
   private static class JettyNegoProvider implements InvocationHandler {
     /** This peer's supported protocols. */
     private final List<String> protocols;
-    /** Set when remote peer notifies NPN or ALPN is unsupported. */
+    /** Set when remote peer notifies ALPN is unsupported. */
     private boolean unsupported;
-    /** The protocol the client (NPN) or server (ALPN) selected. */
+    /** The protocol the server selected. */
     private String selected;
 
     public JettyNegoProvider(List<String> protocols) {
@@ -354,12 +328,12 @@ public JettyNegoProvider(List<String> protocols) {
         args = Util.EMPTY_STRING_ARRAY;
       }
       if (methodName.equals("supports") && boolean.class == returnType) {
-        return true; // NPN or ALPN is supported.
+        return true; // ALPN is supported.
       } else if (methodName.equals("unsupported") && void.class == returnType) {
-        this.unsupported = true; // Peer doesn't support NPN or ALPN.
+        this.unsupported = true; // Peer doesn't support ALPN.
         return null;
       } else if (methodName.equals("protocols") && args.length == 0) {
-        return protocols; // Server (NPN) or Client (ALPN) advertises these protocols.
+        return protocols; // Client advertises these protocols.
       } else if ((methodName.equals("selectProtocol") || methodName.equals("select"))
           && String.class == returnType && args.length == 1 && args[0] instanceof List) {
         List<String> peerProtocols = (List) args[0];
@@ -372,7 +346,7 @@ public JettyNegoProvider(List<String> protocols) {
         return selected = protocols.get(0); // On no intersection, try peer's first protocol.
       } else if ((methodName.equals("protocolSelected") || methodName.equals("selected"))
           && args.length == 1) {
-        this.selected = (String) args[0]; // Client (NPN) or Server (ALPN) selected this protocol.
+        this.selected = (String) args[0]; // Server selected this protocol.
         return null;
       } else {
         return method.invoke(this, args);
@@ -388,7 +362,7 @@ public JettyNegoProvider(List<String> protocols) {
     Buffer result = new Buffer();
     for (int i = 0, size = protocols.size(); i < size; i++) {
       Protocol protocol = protocols.get(i);
-      if (protocol == Protocol.HTTP_1_0) continue; // No HTTP/1.0 for NPN.
+      if (protocol == Protocol.HTTP_1_0) continue; // No HTTP/1.0 for ALPN.
       result.writeByte(protocol.toString().length());
       result.writeUtf8(protocol.toString());
     }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/RouteDatabase.java b/okhttp/src/main/java/com/squareup/okhttp/internal/RouteDatabase.java
index 52c211eb54..1c96c7f6b2 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/RouteDatabase.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/RouteDatabase.java
@@ -22,9 +22,8 @@
 /**
  * A blacklist of failed routes to avoid when creating a new connection to a
  * target address. This is used so that OkHttp can learn from its mistakes: if
- * there was a failure attempting to connect to a specific IP address, proxy
- * server or TLS mode, that failure is remembered and alternate routes are
- * preferred.
+ * there was a failure attempting to connect to a specific IP address or proxy
+ * server, that failure is remembered and alternate routes are preferred.
  */
 public final class RouteDatabase {
   private final Set<Route> failedRoutes = new LinkedHashSet<>();
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/Util.java b/okhttp/src/main/java/com/squareup/okhttp/internal/Util.java
index bd24493615..eee686f104 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/Util.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/Util.java
@@ -16,11 +16,11 @@
 
 package com.squareup.okhttp.internal;
 
-import com.squareup.okhttp.internal.spdy.Header;
 import java.io.Closeable;
-import java.io.File;
 import java.io.IOException;
+import java.io.InterruptedIOException;
 import java.io.UnsupportedEncodingException;
+import java.lang.reflect.Array;
 import java.net.ServerSocket;
 import java.net.Socket;
 import java.net.URI;
@@ -30,26 +30,21 @@
 import java.security.NoSuchAlgorithmException;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collection;
 import java.util.Collections;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.TimeUnit;
 import okio.Buffer;
 import okio.ByteString;
 import okio.Source;
 
-import static java.util.concurrent.TimeUnit.NANOSECONDS;
-
 /** Junk drawer of utility methods. */
 public final class Util {
   public static final byte[] EMPTY_BYTE_ARRAY = new byte[0];
   public static final String[] EMPTY_STRING_ARRAY = new String[0];
 
-  /** A cheap and type-safe constant for the US-ASCII Charset. */
-  public static final Charset US_ASCII = Charset.forName("US-ASCII");
-
   /** A cheap and type-safe constant for the UTF-8 Charset. */
   public static final Charset UTF_8 = Charset.forName("UTF-8");
 
@@ -154,46 +149,63 @@ public static void closeAll(Closeable a, Closeable b) throws IOException {
   }
 
   /**
-   * Deletes the contents of {@code dir}. Throws an IOException if any file
-   * could not be deleted, or if {@code dir} is not a readable directory.
+   * Attempts to exhaust {@code source}, returning true if successful. This is useful when reading
+   * a complete source is helpful, such as when doing so completes a cache body or frees a socket
+   * connection for reuse.
    */
-  public static void deleteContents(File dir) throws IOException {
-    File[] files = dir.listFiles();
-    if (files == null) {
-      throw new IOException("not a readable directory: " + dir);
-    }
-    for (File file : files) {
-      if (file.isDirectory()) {
-        deleteContents(file);
-      }
-      if (!file.delete()) {
-        throw new IOException("failed to delete file: " + file);
-      }
+  public static boolean discard(Source source, int timeout, TimeUnit timeUnit) {
+    try {
+      return skipAll(source, timeout, timeUnit);
+    } catch (IOException e) {
+      return false;
     }
   }
 
-  /** Reads until {@code in} is exhausted or the timeout has elapsed. */
-  public static boolean skipAll(Source in, int timeoutMillis) throws IOException {
-    // TODO: Implement deadlines everywhere so they can do this work.
-    long startNanos = System.nanoTime();
-    Buffer skipBuffer = new Buffer();
-    while (NANOSECONDS.toMillis(System.nanoTime() - startNanos) < timeoutMillis) {
-      long read = in.read(skipBuffer, 2048);
-      if (read == -1) return true; // Successfully exhausted the stream.
-      skipBuffer.clear();
+  /**
+   * Reads until {@code in} is exhausted or the deadline has been reached. This is careful to not
+   * extend the deadline if one exists already.
+   */
+  public static boolean skipAll(Source source, int duration, TimeUnit timeUnit) throws IOException {
+    long now = System.nanoTime();
+    long originalDuration = source.timeout().hasDeadline()
+        ? source.timeout().deadlineNanoTime() - now
+        : Long.MAX_VALUE;
+    source.timeout().deadlineNanoTime(now + Math.min(originalDuration, timeUnit.toNanos(duration)));
+    try {
+      Buffer skipBuffer = new Buffer();
+      while (source.read(skipBuffer, 2048) != -1) {
+        skipBuffer.clear();
+      }
+      return true; // Success! The source has been exhausted.
+    } catch (InterruptedIOException e) {
+      return false; // We ran out of time before exhausting the source.
+    } finally {
+      if (originalDuration == Long.MAX_VALUE) {
+        source.timeout().clearDeadline();
+      } else {
+        source.timeout().deadlineNanoTime(now + originalDuration);
+      }
     }
-    return false; // Ran out of time.
   }
 
-  /** Returns a 32 character string containing a hash of {@code s}. */
-  public static String hash(String s) {
+  /** Returns a 32 character string containing an MD5 hash of {@code s}. */
+  public static String md5Hex(String s) {
     try {
       MessageDigest messageDigest = MessageDigest.getInstance("MD5");
       byte[] md5bytes = messageDigest.digest(s.getBytes("UTF-8"));
       return ByteString.of(md5bytes).hex();
-    } catch (NoSuchAlgorithmException e) {
+    } catch (NoSuchAlgorithmException | UnsupportedEncodingException e) {
       throw new AssertionError(e);
-    } catch (UnsupportedEncodingException e) {
+    }
+  }
+
+  /** Returns a Base 64-encoded string containing a SHA-1 hash of {@code s}. */
+  public static String shaBase64(String s) {
+    try {
+      MessageDigest messageDigest = MessageDigest.getInstance("SHA-1");
+      byte[] sha1Bytes = messageDigest.digest(s.getBytes("UTF-8"));
+      return ByteString.of(sha1Bytes).base64();
+    } catch (NoSuchAlgorithmException | UnsupportedEncodingException e) {
       throw new AssertionError(e);
     }
   }
@@ -234,25 +246,30 @@ public static ThreadFactory threadFactory(final String name, final boolean daemo
     };
   }
 
-  public static List<Header> headerEntries(String... elements) {
-    List<Header> result = new ArrayList<>(elements.length / 2);
-    for (int i = 0; i < elements.length; i += 2) {
-      result.add(new Header(elements[i], elements[i + 1]));
-    }
-    return result;
+  /**
+   * Returns an array containing containing only elements found in {@code first}  and also in
+   * {@code second}. The returned elements are in the same order as in {@code first}.
+   */
+  @SuppressWarnings("unchecked")
+  public static <T> T[] intersect(Class<T> arrayType, T[] first, T[] second) {
+    List<T> result = intersect(first, second);
+    return result.toArray((T[]) Array.newInstance(arrayType, result.size()));
   }
 
   /**
-   * Returns a copy of {@code a} containing only elements also in {@code b}. The returned elements
-   * are in the same order as in {@code a}.
+   * Returns a list containing containing only elements found in {@code first}  and also in
+   * {@code second}. The returned elements are in the same order as in {@code first}.
    */
-  public static <T> List<T> intersect(Collection<T> a, Collection<T> b) {
+  private static <T> List<T> intersect(T[] first, T[] second) {
     List<T> result = new ArrayList<>();
-    for (T t : a) {
-      if (b.contains(t)) {
-        result.add(t);
+    for (T a : first) {
+      for (T b : second) {
+        if (a.equals(b)) {
+          result.add(b);
+          break;
+        }
       }
     }
-    return Collections.unmodifiableList(result);
+    return result;
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/AuthenticatorAdapter.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/AuthenticatorAdapter.java
index a517ada7cc..9ccbb032c8 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/AuthenticatorAdapter.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/AuthenticatorAdapter.java
@@ -20,6 +20,7 @@
 import com.squareup.okhttp.Credentials;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
+import com.squareup.okhttp.internal.Util;
 import java.io.IOException;
 import java.net.Authenticator.RequestorType;
 import java.net.InetAddress;
@@ -43,8 +44,9 @@
       if (!"Basic".equalsIgnoreCase(challenge.getScheme())) continue;
 
       PasswordAuthentication auth = java.net.Authenticator.requestPasswordAuthentication(
-          url.getHost(), getConnectToInetAddress(proxy, url), url.getPort(), url.getProtocol(),
-          challenge.getRealm(), challenge.getScheme(), url, RequestorType.SERVER);
+          url.getHost(), getConnectToInetAddress(proxy, url), Util.getEffectivePort(url),
+          url.getProtocol(), challenge.getRealm(), challenge.getScheme(), url,
+          RequestorType.SERVER);
       if (auth == null) continue;
 
       String credential = Credentials.basic(auth.getUserName(), new String(auth.getPassword()));
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheStrategy.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheStrategy.java
index 70007dcb65..3f07edd7e1 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheStrategy.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheStrategy.java
@@ -1,16 +1,25 @@
 package com.squareup.okhttp.internal.http;
 
 import com.squareup.okhttp.CacheControl;
+import com.squareup.okhttp.Headers;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
+
 import java.util.Date;
 
 import static com.squareup.okhttp.internal.http.StatusLine.HTTP_PERM_REDIRECT;
+import static com.squareup.okhttp.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
+import static java.net.HttpURLConnection.HTTP_BAD_METHOD;
 import static java.net.HttpURLConnection.HTTP_GONE;
 import static java.net.HttpURLConnection.HTTP_MOVED_PERM;
+import static java.net.HttpURLConnection.HTTP_MOVED_TEMP;
 import static java.net.HttpURLConnection.HTTP_MULT_CHOICE;
 import static java.net.HttpURLConnection.HTTP_NOT_AUTHORITATIVE;
+import static java.net.HttpURLConnection.HTTP_NOT_FOUND;
+import static java.net.HttpURLConnection.HTTP_NOT_IMPLEMENTED;
+import static java.net.HttpURLConnection.HTTP_NO_CONTENT;
 import static java.net.HttpURLConnection.HTTP_OK;
+import static java.net.HttpURLConnection.HTTP_REQ_TOO_LONG;
 import static java.util.concurrent.TimeUnit.SECONDS;
 
 /**
@@ -38,26 +47,43 @@ private CacheStrategy(Request networkRequest, Response cacheResponse) {
    * request.
    */
   public static boolean isCacheable(Response response, Request request) {
-    // Always go to network for uncacheable response codes (RFC 2616, 13.4),
+    // Always go to network for uncacheable response codes (RFC 7231 section 6.1),
     // This implementation doesn't support caching partial content.
-    int responseCode = response.code();
-    if (responseCode != HTTP_OK
-        && responseCode != HTTP_NOT_AUTHORITATIVE
-        && responseCode != HTTP_MULT_CHOICE
-        && responseCode != HTTP_MOVED_PERM
-        && responseCode != HTTP_GONE
-        && responseCode != HTTP_PERM_REDIRECT) {
-      return false;
-    }
+    switch (response.code()) {
+      case HTTP_OK:
+      case HTTP_NOT_AUTHORITATIVE:
+      case HTTP_NO_CONTENT:
+      case HTTP_MULT_CHOICE:
+      case HTTP_MOVED_PERM:
+      case HTTP_NOT_FOUND:
+      case HTTP_BAD_METHOD:
+      case HTTP_GONE:
+      case HTTP_REQ_TOO_LONG:
+      case HTTP_NOT_IMPLEMENTED:
+      case HTTP_PERM_REDIRECT:
+      // These codes can be cached unless headers forbid it.
+      break;
+
+      case HTTP_MOVED_TEMP:
+      case HTTP_TEMP_REDIRECT:
+        // These codes can only be cached with the right response headers.
+        // http://tools.ietf.org/html/rfc7234#section-3
+        // s-maxage is not checked because OkHttp is a private cache that should ignore s-maxage.
+        if (response.header("Expires") != null
+            || response.cacheControl().maxAgeSeconds() != -1
+            || response.cacheControl().isPublic()
+            || response.cacheControl().isPrivate()) {
+          break;
+        }
+        // Fall-through.
 
-    // A 'no-store' directive on request or response prevents the response from being cached.
-    CacheControl responseCaching = response.cacheControl();
-    CacheControl requestCaching = request.cacheControl();
-    if (responseCaching.noStore() || requestCaching.noStore()) {
-      return false;
+      default:
+        // All other codes cannot be cached.
+        return false;
     }
 
-    return true;
+    // A 'no-store' directive on request or response prevents the response from being cached.
+    return !response.cacheControl().noStore() && !request.cacheControl().noStore();
   }
 
   public static class Factory {
@@ -103,9 +129,10 @@ public Factory(long nowMillis, Request request, Response cacheResponse) {
       this.cacheResponse = cacheResponse;
 
       if (cacheResponse != null) {
-        for (int i = 0; i < cacheResponse.headers().size(); i++) {
-          String fieldName = cacheResponse.headers().name(i);
-          String value = cacheResponse.headers().value(i);
+        Headers headers = cacheResponse.headers();
+        for (int i = 0, size = headers.size(); i < size; i++) {
+          String fieldName = headers.name(i);
+          String value = headers.value(i);
           if ("Date".equalsIgnoreCase(fieldName)) {
             servedDate = HttpDate.parse(value);
             servedDateString = value;
@@ -198,16 +225,14 @@ private CacheStrategy getCandidate() {
 
       Request.Builder conditionalRequestBuilder = request.newBuilder();
 
-      if (lastModified != null) {
+      if (etag != null) {
+        conditionalRequestBuilder.header("If-None-Match", etag);
+      } else if (lastModified != null) {
         conditionalRequestBuilder.header("If-Modified-Since", lastModifiedString);
       } else if (servedDate != null) {
         conditionalRequestBuilder.header("If-Modified-Since", servedDateString);
       }
 
-      if (etag != null) {
-        conditionalRequestBuilder.header("If-None-Match", etag);
-      }
-
       Request conditionalRequest = conditionalRequestBuilder.build();
       return hasConditions(conditionalRequest)
           ? new CacheStrategy(conditionalRequest, cacheResponse)
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java
index affc99d074..0d7d4e5594 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java
@@ -22,14 +22,15 @@
 import com.squareup.okhttp.Response;
 import com.squareup.okhttp.internal.Internal;
 import com.squareup.okhttp.internal.Util;
+import java.io.EOFException;
 import java.io.IOException;
 import java.net.ProtocolException;
 import java.net.Socket;
 import java.net.SocketTimeoutException;
-import java.util.concurrent.TimeUnit;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
+import okio.ForwardingTimeout;
 import okio.Okio;
 import okio.Sink;
 import okio.Source;
@@ -38,6 +39,7 @@
 import static com.squareup.okhttp.internal.Util.checkOffsetAndCount;
 import static com.squareup.okhttp.internal.http.StatusLine.HTTP_CONTINUE;
 import static com.squareup.okhttp.internal.http.Transport.DISCARD_STREAM_TIMEOUT_MILLIS;
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
 
 /**
  * A socket connection that can be used to send HTTP/1.1 messages. This class
@@ -46,16 +48,17 @@
  *   <li>{@link #writeRequest Send request headers}.
  *   <li>Open a sink to write the request body. Either {@link
  *       #newFixedLengthSink fixed-length} or {@link #newChunkedSink chunked}.
- *   <li>Write to and then close that stream.
+ *   <li>Write to and then close that sink.
  *   <li>{@link #readResponse Read response headers}.
- *   <li>Open the HTTP response body input stream. Either {@link
+ *   <li>Open a source to read the response body. Either {@link
  *       #newFixedLengthSource fixed-length}, {@link #newChunkedSource chunked}
  *       or {@link #newUnknownLengthSource unknown length}.
- *   <li>Read from and close that stream.
+ *   <li>Read from and close that source.
  * </ol>
  * <p>Exchanges that do not have a request body may skip creating and closing
- * the request body. Exchanges that do not have a response body must call {@link
- * #emptyResponseBody}.
+ * the request body. Exchanges that do not have a response body can call {@link
+ * #newFixedLengthSource(long) newFixedLengthSource(0)} and may skip reading and
+ * closing that source.
  */
 public final class HttpConnection {
   private static final int STATE_IDLE = 0; // Idle connections are ready to write request headers.
@@ -90,10 +93,10 @@ public HttpConnection(ConnectionPool pool, Connection connection, Socket socket)
 
   public void setTimeouts(int readTimeoutMillis, int writeTimeoutMillis) {
     if (readTimeoutMillis != 0) {
-      source.timeout().timeout(readTimeoutMillis, TimeUnit.MILLISECONDS);
+      source.timeout().timeout(readTimeoutMillis, MILLISECONDS);
     }
     if (writeTimeoutMillis != 0) {
-      sink.timeout().timeout(writeTimeoutMillis, TimeUnit.MILLISECONDS);
+      sink.timeout().timeout(writeTimeoutMillis, MILLISECONDS);
     }
   }
 
@@ -167,7 +170,7 @@ public boolean isReadable() {
   public void writeRequest(Headers headers, String requestLine) throws IOException {
     if (state != STATE_IDLE) throw new IllegalStateException("state: " + state);
     sink.writeUtf8(requestLine).writeUtf8("\r\n");
-    for (int i = 0; i < headers.size(); i ++) {
+    for (int i = 0, size = headers.size(); i < size; i ++) {
       sink.writeUtf8(headers.name(i))
           .writeUtf8(": ")
           .writeUtf8(headers.value(i))
@@ -183,23 +186,31 @@ public void writeRequest(Headers headers, String requestLine) throws IOException
       throw new IllegalStateException("state: " + state);
     }
 
-    while (true) {
-      StatusLine statusLine = StatusLine.parse(source.readUtf8LineStrict());
-
-      Response.Builder responseBuilder = new Response.Builder()
-          .protocol(statusLine.protocol)
-          .code(statusLine.code)
-          .message(statusLine.message);
-
-      Headers.Builder headersBuilder = new Headers.Builder();
-      readHeaders(headersBuilder);
-      headersBuilder.add(OkHeaders.SELECTED_PROTOCOL, statusLine.protocol.toString());
-      responseBuilder.headers(headersBuilder.build());
-
-      if (statusLine.code != HTTP_CONTINUE) {
-        state = STATE_OPEN_RESPONSE_BODY;
-        return responseBuilder;
+    try {
+      while (true) {
+        StatusLine statusLine = StatusLine.parse(source.readUtf8LineStrict());
+
+        Response.Builder responseBuilder = new Response.Builder()
+            .protocol(statusLine.protocol)
+            .code(statusLine.code)
+            .message(statusLine.message);
+
+        Headers.Builder headersBuilder = new Headers.Builder();
+        readHeaders(headersBuilder);
+        headersBuilder.add(OkHeaders.SELECTED_PROTOCOL, statusLine.protocol.toString());
+        responseBuilder.headers(headersBuilder.build());
+
+        if (statusLine.code != HTTP_CONTINUE) {
+          state = STATE_OPEN_RESPONSE_BODY;
+          return responseBuilder;
+        }
       }
+    } catch (EOFException e) {
+      // Provide more context if the server ends the stream before sending a response.
+      IOException exception = new IOException("unexpected end of stream on " + connection
+          + " (recycle count=" + Internal.instance.recycleCount(connection) + ")");
+      exception.initCause(e);
+      throw exception;
     }
   }
 
@@ -207,27 +218,7 @@ public void writeRequest(Headers headers, String requestLine) throws IOException
   public void readHeaders(Headers.Builder builder) throws IOException {
     // parse the result headers until the first blank line
     for (String line; (line = source.readUtf8LineStrict()).length() != 0; ) {
-      Internal.instance.addLine(builder, line);
-    }
-  }
-
-  /**
-   * Discards the response body so that the connection can be reused and the
-   * cache entry can be completed. This needs to be done judiciously, since it
-   * delays the current request in order to speed up a potential future request
-   * that may never occur.
-   */
-  public boolean discard(Source in, int timeoutMillis) {
-    try {
-      int socketTimeout = socket.getSoTimeout();
-      socket.setSoTimeout(timeoutMillis);
-      try {
-        return Util.skipAll(in, timeoutMillis);
-      } finally {
-        socket.setSoTimeout(socketTimeout);
-      }
-    } catch (IOException e) {
-      return false;
+      Internal.instance.addLenient(builder, line);
     }
   }
 
@@ -249,36 +240,47 @@ public void writeRequestBody(RetryableSink requestBody) throws IOException {
     requestBody.writeToSocket(sink);
   }
 
-  public Source newFixedLengthSource(CacheRequest cacheRequest, long length)
-      throws IOException {
+  public Source newFixedLengthSource(long length) throws IOException {
     if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
     state = STATE_READING_RESPONSE_BODY;
-    return new FixedLengthSource(cacheRequest, length);
+    return new FixedLengthSource(length);
   }
 
-  /**
-   * Call this to advance past a response body for HTTP responses that do not
-   * have a response body.
-   */
-  public void emptyResponseBody() throws IOException {
-    newFixedLengthSource(null, 0L); // Transition to STATE_IDLE.
-  }
-
-  public Source newChunkedSource(CacheRequest cacheRequest, HttpEngine httpEngine)
-      throws IOException {
+  public Source newChunkedSource(HttpEngine httpEngine) throws IOException {
     if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
     state = STATE_READING_RESPONSE_BODY;
-    return new ChunkedSource(cacheRequest, httpEngine);
+    return new ChunkedSource(httpEngine);
   }
 
-  public Source newUnknownLengthSource(CacheRequest cacheRequest) throws IOException {
+  public Source newUnknownLengthSource() throws IOException {
     if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
     state = STATE_READING_RESPONSE_BODY;
-    return new UnknownLengthSource(cacheRequest);
+    return new UnknownLengthSource();
+  }
+
+  public BufferedSink rawSink() {
+    return sink;
+  }
+
+  public BufferedSource rawSource() {
+    return source;
+  }
+
+  /**
+   * Sets the delegate of {@code timeout} to {@link Timeout#NONE} and resets its underlying timeout
+   * to the default configuration. Use this to avoid unexpected sharing of timeouts between pooled
+   * connections.
+   */
+  private void detachTimeout(ForwardingTimeout timeout) {
+    Timeout oldDelegate = timeout.delegate();
+    timeout.setDelegate(Timeout.NONE);
+    oldDelegate.clearDeadline();
+    oldDelegate.clearTimeout();
   }
 
   /** An HTTP body with a fixed length known in advance. */
   private final class FixedLengthSink implements Sink {
+    private final ForwardingTimeout timeout = new ForwardingTimeout(sink.timeout());
     private boolean closed;
     private long bytesRemaining;
 
@@ -287,7 +289,7 @@ private FixedLengthSink(long bytesRemaining) {
     }
 
     @Override public Timeout timeout() {
-      return sink.timeout();
+      return timeout;
     }
 
     @Override public void write(Buffer source, long byteCount) throws IOException {
@@ -310,38 +312,32 @@ private FixedLengthSink(long bytesRemaining) {
       if (closed) return;
       closed = true;
       if (bytesRemaining > 0) throw new ProtocolException("unexpected end of stream");
+      detachTimeout(timeout);
       state = STATE_READ_RESPONSE_HEADERS;
     }
   }
 
-  private static final String CRLF = "\r\n";
-  private static final byte[] HEX_DIGITS = {
-      '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'
-  };
-  private static final byte[] FINAL_CHUNK = new byte[] { '0', '\r', '\n', '\r', '\n' };
-
   /**
    * An HTTP body with alternating chunk sizes and chunk bodies. It is the
    * caller's responsibility to buffer chunks; typically by using a buffered
    * sink with this sink.
    */
   private final class ChunkedSink implements Sink {
-    /** Scratch space for up to 16 hex digits, and then a constant CRLF. */
-    private final byte[] hex = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '\r', '\n' };
-
+    private final ForwardingTimeout timeout = new ForwardingTimeout(sink.timeout());
     private boolean closed;
 
     @Override public Timeout timeout() {
-      return sink.timeout();
+      return timeout;
     }
 
     @Override public void write(Buffer source, long byteCount) throws IOException {
       if (closed) throw new IllegalStateException("closed");
       if (byteCount == 0) return;
 
-      writeHex(byteCount);
+      sink.writeHexadecimalUnsignedLong(byteCount);
+      sink.writeUtf8("\r\n");
       sink.write(source, byteCount);
-      sink.writeUtf8(CRLF);
+      sink.writeUtf8("\r\n");
     }
 
     @Override public synchronized void flush() throws IOException {
@@ -352,47 +348,18 @@ private FixedLengthSink(long bytesRemaining) {
     @Override public synchronized void close() throws IOException {
       if (closed) return;
       closed = true;
-      sink.write(FINAL_CHUNK);
+      sink.writeUtf8("0\r\n\r\n");
+      detachTimeout(timeout);
       state = STATE_READ_RESPONSE_HEADERS;
     }
-
-    /**
-     * Equivalent to, but cheaper than writing Long.toHexString().getBytes()
-     * followed by CRLF.
-     */
-    private void writeHex(long i) throws IOException {
-      int cursor = 16;
-      do {
-        hex[--cursor] = HEX_DIGITS[((int) (i & 0xf))];
-      } while ((i >>>= 4) != 0);
-      sink.write(hex, cursor, hex.length - cursor);
-    }
   }
 
-  private class AbstractSource {
-    private final CacheRequest cacheRequest;
-    protected final Sink cacheBody;
+  private abstract class AbstractSource implements Source {
+    protected final ForwardingTimeout timeout = new ForwardingTimeout(source.timeout());
     protected boolean closed;
 
-    AbstractSource(CacheRequest cacheRequest) throws IOException {
-      // Some apps return a null body; for compatibility we treat that like a null cache request.
-      Sink cacheBody = cacheRequest != null ? cacheRequest.body() : null;
-      if (cacheBody == null) {
-        cacheRequest = null;
-      }
-
-      this.cacheBody = cacheBody;
-      this.cacheRequest = cacheRequest;
-    }
-
-    /** Copy the last {@code byteCount} bytes of {@code source} to the cache body. */
-    protected final void cacheWrite(Buffer source, long byteCount) throws IOException {
-      if (cacheBody != null) {
-        // TODO source.copyTo(cacheBody, source.size() - byteCount, byteCount)
-        Buffer sourceCopy = source.clone();
-        sourceCopy.skip(sourceCopy.size() - byteCount);
-        cacheBody.write(sourceCopy, byteCount);
-      }
+    @Override public Timeout timeout() {
+      return timeout;
     }
 
     /**
@@ -402,9 +369,7 @@ protected final void cacheWrite(Buffer source, long byteCount) throws IOExceptio
     protected final void endOfInput(boolean recyclable) throws IOException {
       if (state != STATE_READING_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
 
-      if (cacheRequest != null) {
-        cacheBody.close();
-      }
+      detachTimeout(timeout);
 
       state = STATE_IDLE;
       if (recyclable && onIdle == ON_IDLE_POOL) {
@@ -429,54 +394,45 @@ protected final void endOfInput(boolean recyclable) throws IOException {
      * to cancel the transfer, closing the connection is the only solution.
      */
     protected final void unexpectedEndOfInput() {
-      if (cacheRequest != null) {
-        cacheRequest.abort();
-      }
       Util.closeQuietly(connection.getSocket());
       state = STATE_CLOSED;
     }
   }
 
   /** An HTTP body with a fixed length specified in advance. */
-  private class FixedLengthSource extends AbstractSource implements Source {
+  private class FixedLengthSource extends AbstractSource {
     private long bytesRemaining;
 
-    public FixedLengthSource(CacheRequest cacheRequest, long length) throws IOException {
-      super(cacheRequest);
+    public FixedLengthSource(long length) throws IOException {
       bytesRemaining = length;
       if (bytesRemaining == 0) {
         endOfInput(true);
       }
     }
 
-    @Override public long read(Buffer sink, long byteCount)
-        throws IOException {
+    @Override public long read(Buffer sink, long byteCount) throws IOException {
       if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
       if (closed) throw new IllegalStateException("closed");
       if (bytesRemaining == 0) return -1;
 
       long read = source.read(sink, Math.min(bytesRemaining, byteCount));
       if (read == -1) {
-        unexpectedEndOfInput(); // the server didn't supply the promised content length
+        unexpectedEndOfInput(); // The server didn't supply the promised content length.
         throw new ProtocolException("unexpected end of stream");
       }
 
       bytesRemaining -= read;
-      cacheWrite(sink, read);
       if (bytesRemaining == 0) {
         endOfInput(true);
       }
       return read;
     }
 
-    @Override public Timeout timeout() {
-      return source.timeout();
-    }
-
     @Override public void close() throws IOException {
       if (closed) return;
 
-      if (bytesRemaining != 0 && !discard(this, DISCARD_STREAM_TIMEOUT_MILLIS)) {
+      if (bytesRemaining != 0
+          && !Util.discard(this, DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
         unexpectedEndOfInput();
       }
 
@@ -485,19 +441,17 @@ public FixedLengthSource(CacheRequest cacheRequest, long length) throws IOExcept
   }
 
   /** An HTTP body with alternating chunk sizes and chunk bodies. */
-  private class ChunkedSource extends AbstractSource implements Source {
-    private static final int NO_CHUNK_YET = -1;
-    private int bytesRemainingInChunk = NO_CHUNK_YET;
+  private class ChunkedSource extends AbstractSource {
+    private static final long NO_CHUNK_YET = -1L;
+    private long bytesRemainingInChunk = NO_CHUNK_YET;
     private boolean hasMoreChunks = true;
     private final HttpEngine httpEngine;
 
-    ChunkedSource(CacheRequest cacheRequest, HttpEngine httpEngine) throws IOException {
-      super(cacheRequest);
+    ChunkedSource(HttpEngine httpEngine) throws IOException {
       this.httpEngine = httpEngine;
     }
 
-    @Override public long read(
-        Buffer sink, long byteCount) throws IOException {
+    @Override public long read(Buffer sink, long byteCount) throws IOException {
       if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
       if (closed) throw new IllegalStateException("closed");
       if (!hasMoreChunks) return -1;
@@ -509,30 +463,29 @@ public FixedLengthSource(CacheRequest cacheRequest, long length) throws IOExcept
 
       long read = source.read(sink, Math.min(byteCount, bytesRemainingInChunk));
       if (read == -1) {
-        unexpectedEndOfInput(); // the server didn't supply the promised chunk length
+        unexpectedEndOfInput(); // The server didn't supply the promised chunk length.
         throw new IOException("unexpected end of stream");
       }
       bytesRemainingInChunk -= read;
-      cacheWrite(sink, read);
       return read;
     }
 
     private void readChunkSize() throws IOException {
-      // read the suffix of the previous chunk
+      // Read the suffix of the previous chunk.
       if (bytesRemainingInChunk != NO_CHUNK_YET) {
         source.readUtf8LineStrict();
       }
-      String chunkSizeString = source.readUtf8LineStrict();
-      int index = chunkSizeString.indexOf(";");
-      if (index != -1) {
-        chunkSizeString = chunkSizeString.substring(0, index);
-      }
       try {
-        bytesRemainingInChunk = Integer.parseInt(chunkSizeString.trim(), 16);
+        bytesRemainingInChunk = source.readHexadecimalUnsignedLong();
+        String extensions = source.readUtf8LineStrict().trim();
+        if (bytesRemainingInChunk < 0 || (!extensions.isEmpty() && !extensions.startsWith(";"))) {
+          throw new ProtocolException("expected chunk size and optional extensions but was \""
+              + bytesRemainingInChunk + extensions + "\"");
+        }
       } catch (NumberFormatException e) {
-        throw new ProtocolException("Expected a hex chunk size but was " + chunkSizeString);
+        throw new ProtocolException(e.getMessage());
       }
-      if (bytesRemainingInChunk == 0) {
+      if (bytesRemainingInChunk == 0L) {
         hasMoreChunks = false;
         Headers.Builder trailersBuilder = new Headers.Builder();
         readHeaders(trailersBuilder);
@@ -541,13 +494,9 @@ private void readChunkSize() throws IOException {
       }
     }
 
-    @Override public Timeout timeout() {
-      return source.timeout();
-    }
-
     @Override public void close() throws IOException {
       if (closed) return;
-      if (hasMoreChunks && !discard(this, DISCARD_STREAM_TIMEOUT_MILLIS)) {
+      if (hasMoreChunks && !Util.discard(this, DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
         unexpectedEndOfInput();
       }
       closed = true;
@@ -555,13 +504,9 @@ private void readChunkSize() throws IOException {
   }
 
   /** An HTTP message body terminated by the end of the underlying stream. */
-  class UnknownLengthSource extends AbstractSource implements Source {
+  private class UnknownLengthSource extends AbstractSource {
     private boolean inputExhausted;
 
-    UnknownLengthSource(CacheRequest cacheRequest) throws IOException {
-      super(cacheRequest);
-    }
-
     @Override public long read(Buffer sink, long byteCount)
         throws IOException {
       if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
@@ -574,17 +519,11 @@ private void readChunkSize() throws IOException {
         endOfInput(false);
         return -1;
       }
-      cacheWrite(sink, read);
       return read;
     }
 
-    @Override public Timeout timeout() {
-      return source.timeout();
-    }
-
     @Override public void close() throws IOException {
       if (closed) return;
-      // TODO: discard unknown length streams for best caching?
       if (!inputExhausted) {
         unexpectedEndOfInput();
       }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
index 64628520c1..c57db06902 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
@@ -17,8 +17,12 @@
 
 package com.squareup.okhttp.internal.http;
 
+import com.squareup.okhttp.Address;
+import com.squareup.okhttp.CertificatePinner;
 import com.squareup.okhttp.Connection;
+import com.squareup.okhttp.ConnectionPool;
 import com.squareup.okhttp.Headers;
+import com.squareup.okhttp.Interceptor;
 import com.squareup.okhttp.MediaType;
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.Protocol;
@@ -28,21 +32,25 @@
 import com.squareup.okhttp.Route;
 import com.squareup.okhttp.internal.Internal;
 import com.squareup.okhttp.internal.InternalCache;
+import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.internal.Version;
 
 import java.io.IOException;
-import java.io.InputStream;
+import java.io.InterruptedIOException;
 import java.net.CookieHandler;
 import java.net.ProtocolException;
 import java.net.Proxy;
 import java.net.URL;
+import java.net.UnknownHostException;
 import java.security.cert.CertificateException;
 import java.util.Date;
 import java.util.List;
 import java.util.Map;
 
+import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLHandshakeException;
 import javax.net.ssl.SSLPeerUnverifiedException;
+import javax.net.ssl.SSLSocketFactory;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -50,6 +58,7 @@
 import okio.Okio;
 import okio.Sink;
 import okio.Source;
+import okio.Timeout;
 
 import static com.squareup.okhttp.internal.Util.closeQuietly;
 import static com.squareup.okhttp.internal.Util.getDefaultPort;
@@ -65,6 +74,7 @@
 import static java.net.HttpURLConnection.HTTP_PROXY_AUTH;
 import static java.net.HttpURLConnection.HTTP_SEE_OTHER;
 import static java.net.HttpURLConnection.HTTP_UNAUTHORIZED;
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
 
 /**
  * Handles a single HTTP request/response pair. Each HTTP engine follows this
@@ -86,10 +96,10 @@
  */
 public final class HttpEngine {
   /**
-   * How many redirects should we follow? Chrome follows 21; Firefox, curl,
-   * and wget follow 20; Safari follows 16; and HTTP/1.0 recommends 5.
+   * How many redirects and auth challenges should we attempt? Chrome follows 21 redirects; Firefox,
+   * curl, and wget follow 20; Safari follows 16; and HTTP/1.0 recommends 5.
    */
-  public static final int MAX_REDIRECTS = 20;
+  public static final int MAX_FOLLOW_UPS = 20;
 
   private static final ResponseBody EMPTY_BODY = new ResponseBody() {
     @Override public MediaType contentType() {
@@ -106,6 +116,7 @@
   final OkHttpClient client;
 
   private Connection connection;
+  private Address address;
   private RouteSelector routeSelector;
   private Route route;
   private final Response priorResponse;
@@ -149,12 +160,6 @@
    */
   private Response cacheResponse;
 
-  /**
-   * The response read from the network. Null if the network response hasn't
-   * been read yet, or if the network is not used. Never modified by OkHttp.
-   */
-  private Response networkResponse;
-
   /**
    * The user-visible response. This is derived from either the network
    * response, cache response, or both. It is customized to support OkHttp
@@ -164,33 +169,32 @@
 
   private Sink requestBodyOut;
   private BufferedSink bufferedRequestBody;
-
-  /** Null until a response is received from the network or the cache. */
-  private Source responseTransferSource;
-  private BufferedSource responseBody;
-  private InputStream responseBodyBytes;
+  private final boolean callerWritesRequestBody;
+  private final boolean forWebSocket;
 
   /** The cache request currently being populated from a network response. */
   private CacheRequest storeRequest;
   private CacheStrategy cacheStrategy;
 
   /**
-   * @param request the HTTP request without a body. The body must be
-   *     written via the engine's request body stream.
-   * @param connection the connection used for an intermediate response
-   *     immediately prior to this request/response pair, such as a same-host
-   *     redirect. This engine assumes ownership of the connection and must
-   *     release it when it is unneeded.
-   * @param routeSelector the route selector used for a failed attempt
-   *     immediately preceding this attempt, or null if this request doesn't
-   *     recover from a failure.
+   * @param request the HTTP request without a body. The body must be written via the engine's
+   *     request body stream.
+   * @param callerWritesRequestBody true for the {@code HttpURLConnection}-style interaction
+   *     model where control flow is returned to the calling application to write the request body
+   *     before the response body is readable.
+   * @param connection the connection used for an intermediate response immediately prior to this
+   *     request/response pair, such as a same-host redirect. This engine assumes ownership of the
+   *     connection and must release it when it is unneeded.
+   * @param routeSelector the route selector used for a failed attempt immediately preceding this
    */
   public HttpEngine(OkHttpClient client, Request request, boolean bufferRequestBody,
-      Connection connection, RouteSelector routeSelector, RetryableSink requestBodyOut,
-      Response priorResponse) {
+      boolean callerWritesRequestBody, boolean forWebSocket, Connection connection,
+      RouteSelector routeSelector, RetryableSink requestBodyOut, Response priorResponse) {
     this.client = client;
     this.userRequest = request;
     this.bufferRequestBody = bufferRequestBody;
+    this.callerWritesRequestBody = callerWritesRequestBody;
+    this.forWebSocket = forWebSocket;
     this.connection = connection;
     this.routeSelector = routeSelector;
     this.requestBodyOut = requestBodyOut;
@@ -208,8 +212,15 @@ public HttpEngine(OkHttpClient client, Request request, boolean bufferRequestBod
    * Figures out what the response source will be, and opens a socket to that
    * source if necessary. Prepares the request headers and gets ready to start
    * writing the request body if it exists.
+   *
+   * @throws RequestException if there was a problem with request setup. Unrecoverable.
+   * @throws RouteException if the was a problem during connection via a specific route. Sometimes
+   *     recoverable. See {@link #recover(RouteException)}.
+   * @throws IOException if there was a problem while making a request. Sometimes recoverable. See
+   *     {@link #recover(IOException)}.
+   *
    */
-  public void sendRequest() throws IOException {
+  public void sendRequest() throws RequestException, RouteException, IOException {
     if (cacheStrategy != null) return; // Already sent.
     if (transport != null) throw new IllegalStateException();
 
@@ -236,14 +247,16 @@ public void sendRequest() throws IOException {
     if (networkRequest != null) {
       // Open a connection unless we inherited one from a redirect.
       if (connection == null) {
-        connect(networkRequest);
+        connect();
       }
 
       transport = Internal.instance.newTransport(connection, this);
 
-      // Create a request body if we don't have one already. We'll already have
-      // one if we're retrying a failed POST.
-      if (permitsRequestBody() && requestBodyOut == null) {
+      // If the caller's control flow writes the request body, we need to create that stream
+      // immediately. And that means we need to immediately write the request headers, so we can
+      // start streaming the request body. (We may already have a request body if we're retrying a
+      // failed POST.)
+      if (callerWritesRequestBody && permitsRequestBody() && requestBodyOut == null) {
         long contentLength = OkHeaders.contentLength(request);
         if (bufferRequestBody) {
           if (contentLength > Integer.MAX_VALUE) {
@@ -253,7 +266,7 @@ public void sendRequest() throws IOException {
 
           if (contentLength != -1) {
             // Buffer a request body of a known length.
-            transport.writeRequestHeaders(request);
+            transport.writeRequestHeaders(networkRequest);
             requestBodyOut = new RetryableSink((int) contentLength);
           } else {
             // Buffer a request body of an unknown length. Don't write request
@@ -262,8 +275,8 @@ public void sendRequest() throws IOException {
             requestBodyOut = new RetryableSink();
           }
         } else {
-          transport.writeRequestHeaders(request);
-          requestBodyOut = transport.createRequestBody(request, contentLength);
+          transport.writeRequestHeaders(networkRequest);
+          requestBodyOut = transport.createRequestBody(networkRequest, contentLength);
         }
       }
 
@@ -293,9 +306,7 @@ public void sendRequest() throws IOException {
             .build();
       }
 
-      if (userResponse.body() != null) {
-        initContentStream(userResponse.body().source());
-      }
+      userResponse = unzip(userResponse);
     }
   }
 
@@ -306,17 +317,52 @@ private static Response stripBody(Response response) {
   }
 
   /** Connect to the origin server either directly or via a proxy. */
-  private void connect(Request request) throws IOException {
+  private void connect() throws RequestException, RouteException {
     if (connection != null) throw new IllegalStateException();
 
     if (routeSelector == null) {
-      routeSelector = RouteSelector.get(request, client);
+      address = createAddress(client, networkRequest);
+      try {
+        routeSelector = RouteSelector.get(address, networkRequest, client);
+      } catch (IOException e) {
+        throw new RequestException(e);
+      }
     }
 
-    connection = routeSelector.next(this);
+    connection = nextConnection();
     route = connection.getRoute();
   }
 
+  /**
+   * Returns the next connection to attempt.
+   *
+   * @throws java.util.NoSuchElementException if there are no more routes to attempt.
+   */
+  private Connection nextConnection() throws RouteException {
+    Connection connection = createNextConnection();
+    Internal.instance.connectAndSetOwner(client, connection, this, networkRequest);
+    return connection;
+  }
+
+  private Connection createNextConnection() throws RouteException {
+    ConnectionPool pool = client.getConnectionPool();
+
+    // Always prefer pooled connections over new connections.
+    for (Connection pooled; (pooled = pool.get(address)) != null; ) {
+      if (networkRequest.method().equals("GET") || Internal.instance.isReadable(pooled)) {
+        return pooled;
+      }
+      closeQuietly(pooled.getSocket());
+    }
+
+    try {
+      Route route = routeSelector.next();
+      return new Connection(pool, route);
+    } catch (IOException e) {
+      throw new RouteException(e);
+    }
+  }
+
   /**
    * Called immediately before the transport transmits HTTP request headers.
    * This is used to observe the sent time should the request be cached.
@@ -360,31 +406,86 @@ public Response getResponse() {
     return userResponse;
   }
 
-  public BufferedSource getResponseBody() {
-    if (userResponse == null) throw new IllegalStateException();
-    return responseBody;
+  public Connection getConnection() {
+    return connection;
   }
 
-  public InputStream getResponseBodyBytes() {
-    InputStream result = responseBodyBytes;
-    return result != null
-        ? result
-        : (responseBodyBytes = Okio.buffer(getResponseBody()).inputStream());
+  /**
+   * Attempt to recover from failure to connect via a route. Returns a new HTTP engine
+   * that should be used for the retry if there are other routes to try, or null if
+   * there are no more routes to try.
+   */
+  public HttpEngine recover(RouteException e) {
+    if (routeSelector != null && connection != null) {
+      connectFailed(routeSelector, e.getLastConnectException());
+    }
+
+    if (routeSelector == null && connection == null // No connection.
+        || routeSelector != null && !routeSelector.hasNext() // No more routes to attempt.
+        || !isRecoverable(e)) {
+      return null;
+    }
+
+    Connection connection = close();
+
+    // For failure recovery, use the same route selector with a new connection.
+    return new HttpEngine(client, userRequest, bufferRequestBody, callerWritesRequestBody,
+        forWebSocket, connection, routeSelector, (RetryableSink) requestBodyOut, priorResponse);
   }
 
-  public Connection getConnection() {
-    return connection;
+  private boolean isRecoverable(RouteException e) {
+    // If the application has opted-out of recovery, don't recover.
+    if (!client.getRetryOnConnectionFailure()) {
+      return false;
+    }
+
+    // Problems with a route may mean the connection can be retried with a new route, or may
+    // indicate a client-side or server-side issue that should not be retried. To tell, we must look
+    // at the cause.
+
+    IOException ioe = e.getLastConnectException();
+
+    // TODO(nfuller): This is the same logic as in ConnectionSpecSelector
+    // If there was a protocol problem, don't recover.
+    if (ioe instanceof ProtocolException) {
+      return false;
+    }
+
+    // If there was an interruption or timeout, don't recover.
+    if (ioe instanceof InterruptedIOException) {
+      return false;
+    }
+
+    // Look for known client-side or negotiation errors that are unlikely to be fixed by trying
+    // again with a different route.
+    if (ioe instanceof SSLHandshakeException) {
+      // If the problem was a CertificateException from the X509TrustManager,
+      // do not retry.
+      if (ioe.getCause() instanceof CertificateException) {
+        return false;
+      }
+    }
+    if (ioe instanceof SSLPeerUnverifiedException) {
+      // e.g. a certificate pinning error.
+      return false;
+    }
+    // TODO(nfuller): End of common code.
+
+    // An example of one we might want to retry with a different route is a problem connecting to a
+    // proxy and would manifest as a standard IOException. Unless it is one we know we should not
+    // retry, we return true and try a new route.
+    return true;
   }
 
   /**
-   * Report and attempt to recover from {@code e}. Returns a new HTTP engine
-   * that should be used for the retry if {@code e} is recoverable, or null if
+   * Report and attempt to recover from a failure to communicate with a server. Returns a new
+   * HTTP engine that should be used for the retry if {@code e} is recoverable, or null if
    * the failure is permanent. Requests with a body can only be recovered if the
    * body is buffered.
    */
   public HttpEngine recover(IOException e, Sink requestBodyOut) {
     if (routeSelector != null && connection != null) {
-      routeSelector.connectFailed(connection, e);
+      connectFailed(routeSelector, e);
     }
 
     boolean canRetryRequestBody = requestBodyOut == null || requestBodyOut instanceof RetryableSink;
@@ -398,8 +499,15 @@ public HttpEngine recover(IOException e, Sink requestBodyOut) {
     Connection connection = close();
 
     // For failure recovery, use the same route selector with a new connection.
-    return new HttpEngine(client, userRequest, bufferRequestBody, connection, routeSelector,
-        (RetryableSink) requestBodyOut, priorResponse);
+    return new HttpEngine(client, userRequest, bufferRequestBody, callerWritesRequestBody,
+        forWebSocket, connection, routeSelector, (RetryableSink) requestBodyOut, priorResponse);
+  }
+
+  private void connectFailed(RouteSelector routeSelector, IOException e) {
+    // If this is a recycled connection, don't count its failure against the route.
+    if (Internal.instance.recycleCount(connection) > 0) return;
+    Route failedRoute = connection.getRoute();
+    routeSelector.connectFailed(failedRoute, e);
   }
 
   public HttpEngine recover(IOException e) {
@@ -407,12 +515,22 @@ public HttpEngine recover(IOException e) {
   }
 
   private boolean isRecoverable(IOException e) {
-    // If the problem was a CertificateException from the X509TrustManager,
-    // do not retry, we didn't have an abrupt server-initiated exception.
-    boolean sslFailure = e instanceof SSLPeerUnverifiedException
-        || (e instanceof SSLHandshakeException && e.getCause() instanceof CertificateException);
-    boolean protocolFailure = e instanceof ProtocolException;
-    return !sslFailure && !protocolFailure;
+    // If the application has opted-out of recovery, don't recover.
+    if (!client.getRetryOnConnectionFailure()) {
+      return false;
+    }
+
+    // If there was a protocol problem, don't recover.
+    if (e instanceof ProtocolException) {
+      return false;
+    }
+
+    // If there was an interruption or timeout, don't recover.
+    if (e instanceof InterruptedIOException) {
+      return false;
+    }
+
+    return true;
   }
 
   /**
@@ -483,17 +601,14 @@ public Connection close() {
     }
 
     // If this engine never achieved a response body, its connection cannot be reused.
-    if (responseBody == null) {
+    if (userResponse == null) {
       if (connection != null) closeQuietly(connection.getSocket()); // TODO: does this break SPDY?
       connection = null;
       return null;
     }
 
     // Close the response body. This will recycle the connection if it is eligible.
-    closeQuietly(responseBody);
-
-    // Clear the buffer held by the response body input stream adapter.
-    closeQuietly(responseBodyBytes);
+    closeQuietly(userResponse.body());
 
     // Close the connection if it cannot be reused.
     if (transport != null && connection != null && !transport.canReuseConnection()) {
@@ -513,45 +628,49 @@ public Connection close() {
   }
 
   /**
-   * Initialize the response content stream from the response transfer source.
-   * These two sources are the same unless we're doing transparent gzip, in
-   * which case the content source is decompressed.
+   * Returns a new response that does gzip decompression on {@code response}, if transparent gzip
+   * was both offered by OkHttp and used by the origin server.
    *
-   * <p>Whenever we do transparent gzip we also strip the corresponding headers.
-   * We strip the Content-Encoding header to prevent the application from
-   * attempting to double decompress. We strip the Content-Length header because
-   * it is the length of the compressed content, but the application is only
-   * interested in the length of the uncompressed content.
+   * <p>In addition to decompression, this will also strip the corresponding headers. We strip the
+   * Content-Encoding header to prevent the application from attempting to double decompress. We
+   * strip the Content-Length header because it is the length of the compressed content, but the
+   * application is only interested in the length of the uncompressed content.
    *
-   * <p>This method should only be used for non-empty response bodies. Response
-   * codes like "304 Not Modified" can include "Content-Encoding: gzip" without
-   * a response body and we will crash if we attempt to decompress the zero-byte
-   * source.
+   * <p>This method should only be used for non-empty response bodies. Response codes like "304 Not
+   * Modified" can include "Content-Encoding: gzip" without a response body and we will crash if we
+   * attempt to decompress the zero-byte source.
    */
-  private void initContentStream(Source transferSource) throws IOException {
-    responseTransferSource = transferSource;
-    if (transparentGzip && "gzip".equalsIgnoreCase(userResponse.header("Content-Encoding"))) {
-      userResponse = userResponse.newBuilder()
-          .removeHeader("Content-Encoding")
-          .removeHeader("Content-Length")
-          .build();
-      responseBody = Okio.buffer(new GzipSource(transferSource));
-    } else {
-      responseBody = Okio.buffer(transferSource);
+  private Response unzip(final Response response) throws IOException {
+    if (!transparentGzip || !"gzip".equalsIgnoreCase(userResponse.header("Content-Encoding"))) {
+      return response;
     }
+
+    if (response.body() == null) {
+      return response;
+    }
+
+    GzipSource responseBody = new GzipSource(response.body().source());
+    Headers strippedHeaders = response.headers().newBuilder()
+        .removeAll("Content-Encoding")
+        .removeAll("Content-Length")
+        .build();
+    return response.newBuilder()
+        .headers(strippedHeaders)
+        .body(new RealResponseBody(strippedHeaders, Okio.buffer(responseBody)))
+        .build();
   }
 
   /**
    * Returns true if the response must have a (possibly 0-length) body.
    * See RFC 2616 section 4.3.
    */
-  public boolean hasResponseBody() {
+  public static boolean hasBody(Response response) {
     // HEAD requests never yield a body regardless of the response headers.
-    if (userRequest.method().equals("HEAD")) {
+    if (response.request().method().equals("HEAD")) {
       return false;
     }
 
-    int responseCode = userResponse.code();
+    int responseCode = response.code();
     if ((responseCode < HTTP_CONTINUE || responseCode >= 200)
         && responseCode != HTTP_NO_CONTENT
         && responseCode != HTTP_NOT_MODIFIED) {
@@ -561,8 +680,8 @@ public boolean hasResponseBody() {
     // If the Content-Length or Transfer-Encoding headers disagree with the
     // response code, the response is malformed. For best compatibility, we
     // honor the headers.
-    if (OkHeaders.contentLength(networkResponse) != -1
-        || "chunked".equalsIgnoreCase(networkResponse.header("Transfer-Encoding"))) {
+    if (OkHeaders.contentLength(response) != -1
+        || "chunked".equalsIgnoreCase(response.header("Transfer-Encoding"))) {
       return true;
     }
 
@@ -633,44 +752,49 @@ public void readResponse() throws IOException {
       return; // No network response to read.
     }
 
-    // Flush the request body if there's data outstanding.
-    if (bufferedRequestBody != null && bufferedRequestBody.buffer().size() > 0) {
-      bufferedRequestBody.flush();
-    }
+    Response networkResponse;
 
-    if (sentRequestMillis == -1) {
-      if (OkHeaders.contentLength(networkRequest) == -1
-          && requestBodyOut instanceof RetryableSink) {
-        // We might not learn the Content-Length until the request body has been buffered.
-        long contentLength = ((RetryableSink) requestBodyOut).contentLength();
-        networkRequest = networkRequest.newBuilder()
-            .header("Content-Length", Long.toString(contentLength))
-            .build();
-      }
+    if (forWebSocket) {
       transport.writeRequestHeaders(networkRequest);
-    }
+      networkResponse = readNetworkResponse();
 
-    if (requestBodyOut != null) {
-      if (bufferedRequestBody != null) {
-        // This also closes the wrapped requestBodyOut.
-        bufferedRequestBody.close();
-      } else {
-        requestBodyOut.close();
+    } else if (!callerWritesRequestBody) {
+      networkResponse = new NetworkInterceptorChain(0, networkRequest).proceed(networkRequest);
+
+    } else {
+      // Emit the request body's buffer so that everything is in requestBodyOut.
+      if (bufferedRequestBody != null && bufferedRequestBody.buffer().size() > 0) {
+        bufferedRequestBody.emit();
       }
-      if (requestBodyOut instanceof RetryableSink) {
-        transport.writeRequestBody((RetryableSink) requestBodyOut);
+
+      // Emit the request headers if we haven't yet. We might have just learned the Content-Length.
+      if (sentRequestMillis == -1) {
+        if (OkHeaders.contentLength(networkRequest) == -1
+            && requestBodyOut instanceof RetryableSink) {
+          long contentLength = ((RetryableSink) requestBodyOut).contentLength();
+          networkRequest = networkRequest.newBuilder()
+              .header("Content-Length", Long.toString(contentLength))
+              .build();
+        }
+        transport.writeRequestHeaders(networkRequest);
       }
-    }
 
-    transport.flushRequest();
+      // Write the request body to the socket.
+      if (requestBodyOut != null) {
+        if (bufferedRequestBody != null) {
+          // This also closes the wrapped requestBodyOut.
+          bufferedRequestBody.close();
+        } else {
+          requestBodyOut.close();
+        }
+        if (requestBodyOut instanceof RetryableSink) {
+          transport.writeRequestBody((RetryableSink) requestBodyOut);
+        }
+      }
+
+      networkResponse = readNetworkResponse();
+    }
 
-    networkResponse = transport.readResponseHeaders()
-        .request(networkRequest)
-        .handshake(connection.getHandshake())
-        .header(OkHeaders.SENT_MILLIS, Long.toString(sentRequestMillis))
-        .header(OkHeaders.RECEIVED_MILLIS, Long.toString(System.currentTimeMillis()))
-        .build();
-    Internal.instance.setProtocol(connection, networkResponse.protocol());
     receiveHeaders(networkResponse.headers());
 
     // If we have a cache response too, then we're doing a conditional get.
@@ -683,7 +807,7 @@ public void readResponse() throws IOException {
             .cacheResponse(stripBody(cacheResponse))
             .networkResponse(stripBody(networkResponse))
             .build();
-        transport.emptyTransferStream();
+        networkResponse.body().close();
         releaseConnection();
 
         // Update the cache after combining headers but before stripping the
@@ -691,10 +815,7 @@ public void readResponse() throws IOException {
         InternalCache responseCache = Internal.instance.internalCache(client);
         responseCache.trackConditionalCacheHit();
         responseCache.update(cacheResponse, stripBody(userResponse));
-
-        if (cacheResponse.body() != null) {
-          initContentStream(cacheResponse.body().source());
-        }
+        userResponse = unzip(userResponse);
         return;
       } else {
         closeQuietly(cacheResponse.body());
@@ -708,15 +829,162 @@ public void readResponse() throws IOException {
         .networkResponse(stripBody(networkResponse))
         .build();
 
-    if (!hasResponseBody()) {
-      // Don't call initContentStream() when the response doesn't have any content.
-      responseTransferSource = transport.getTransferStream(storeRequest);
-      responseBody = Okio.buffer(responseTransferSource);
-      return;
+    if (hasBody(userResponse)) {
+      maybeCache();
+      userResponse = unzip(cacheWritingResponse(storeRequest, userResponse));
+    }
+  }
+
+  class NetworkInterceptorChain implements Interceptor.Chain {
+    private final int index;
+    private final Request request;
+    private int calls;
+
+    NetworkInterceptorChain(int index, Request request) {
+      this.index = index;
+      this.request = request;
+    }
+
+    @Override public Connection connection() {
+      return connection;
+    }
+
+    @Override public Request request() {
+      return request;
+    }
+
+    @Override public Response proceed(Request request) throws IOException {
+      calls++;
+
+      if (index > 0) {
+        Interceptor caller = client.networkInterceptors().get(index - 1);
+        Address address = connection().getRoute().getAddress();
+
+        // Confirm that the interceptor uses the connection we've already prepared.
+        if (!request.url().getHost().equals(address.getUriHost())
+            || getEffectivePort(request.url()) != address.getUriPort()) {
+          throw new IllegalStateException("network interceptor " + caller
+              + " must retain the same host and port");
+        }
+
+        // Confirm that this is the interceptor's first call to chain.proceed().
+        if (calls > 1) {
+          throw new IllegalStateException("network interceptor " + caller
+              + " must call proceed() exactly once");
+        }
+      }
+
+      if (index < client.networkInterceptors().size()) {
+        // There's another interceptor in the chain. Call that.
+        NetworkInterceptorChain chain = new NetworkInterceptorChain(index + 1, request);
+        Interceptor interceptor = client.networkInterceptors().get(index);
+        Response interceptedResponse = interceptor.intercept(chain);
+
+        // Confirm that the interceptor made the required call to chain.proceed().
+        if (chain.calls != 1) {
+          throw new IllegalStateException("network interceptor " + interceptor
+              + " must call proceed() exactly once");
+        }
+
+        return interceptedResponse;
+      }
+
+      transport.writeRequestHeaders(request);
+
+      //Update the networkRequest with the possibly updated interceptor request.
+      networkRequest = request;
+
+      if (permitsRequestBody() && request.body() != null) {
+        Sink requestBodyOut = transport.createRequestBody(request, request.body().contentLength());
+        BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);
+        request.body().writeTo(bufferedRequestBody);
+        bufferedRequestBody.close();
+      }
+
+      return readNetworkResponse();
     }
+  }
+
+  private Response readNetworkResponse() throws IOException {
+    transport.finishRequest();
+
+    Response networkResponse = transport.readResponseHeaders()
+        .request(networkRequest)
+        .handshake(connection.getHandshake())
+        .header(OkHeaders.SENT_MILLIS, Long.toString(sentRequestMillis))
+        .header(OkHeaders.RECEIVED_MILLIS, Long.toString(System.currentTimeMillis()))
+        .build();
+
+    if (!forWebSocket) {
+      networkResponse = networkResponse.newBuilder()
+          .body(transport.openResponseBody(networkResponse))
+          .build();
+    }
+
+    Internal.instance.setProtocol(connection, networkResponse.protocol());
+    return networkResponse;
+  }
+
+  /**
+   * Returns a new source that writes bytes to {@code cacheRequest} as they are read by the source
+   * consumer. This is careful to discard bytes left over when the stream is closed; otherwise we
+   * may never exhaust the source stream and therefore not complete the cached response.
+   */
+  private Response cacheWritingResponse(final CacheRequest cacheRequest, Response response)
+      throws IOException {
+    // Some apps return a null body; for compatibility we treat that like a null cache request.
+    if (cacheRequest == null) return response;
+    Sink cacheBodyUnbuffered = cacheRequest.body();
+    if (cacheBodyUnbuffered == null) return response;
+
+    final BufferedSource source = response.body().source();
+    final BufferedSink cacheBody = Okio.buffer(cacheBodyUnbuffered);
+
+    Source cacheWritingSource = new Source() {
+      boolean cacheRequestClosed;
 
-    maybeCache();
-    initContentStream(transport.getTransferStream(storeRequest));
+      @Override public long read(Buffer sink, long byteCount) throws IOException {
+        long bytesRead;
+        try {
+          bytesRead = source.read(sink, byteCount);
+        } catch (IOException e) {
+          if (!cacheRequestClosed) {
+            cacheRequestClosed = true;
+            cacheRequest.abort(); // Failed to write a complete cache response.
+          }
+          throw e;
+        }
+
+        if (bytesRead == -1) {
+          if (!cacheRequestClosed) {
+            cacheRequestClosed = true;
+            cacheBody.close(); // The cache response is complete!
+          }
+          return -1;
+        }
+
+        sink.copyTo(cacheBody.buffer(), sink.size() - bytesRead, bytesRead);
+        cacheBody.emitCompleteSegments();
+        return bytesRead;
+      }
+
+      @Override public Timeout timeout() {
+        return source.timeout();
+      }
+
+      @Override public void close() throws IOException {
+        if (!cacheRequestClosed
+            && !Util.discard(this, Transport.DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
+          cacheRequestClosed = true;
+          cacheRequest.abort();
+        }
+        source.close();
+      }
+    };
+
+    return response.newBuilder()
+        .body(new RealResponseBody(response.headers(), Okio.buffer(cacheWritingSource)))
+        .build();
   }
 
   /**
@@ -750,7 +1018,7 @@ private static boolean validate(Response cached, Response network) {
   private static Headers combine(Headers cachedHeaders, Headers networkHeaders) throws IOException {
     Headers.Builder result = new Headers.Builder();
 
-    for (int i = 0; i < cachedHeaders.size(); i++) {
+    for (int i = 0, size = cachedHeaders.size(); i < size; i++) {
       String fieldName = cachedHeaders.name(i);
       String value = cachedHeaders.value(i);
       if ("Warning".equalsIgnoreCase(fieldName) && value.startsWith("1")) {
@@ -761,7 +1029,7 @@ private static Headers combine(Headers cachedHeaders, Headers networkHeaders) th
       }
     }
 
-    for (int i = 0; i < networkHeaders.size(); i++) {
+    for (int i = 0, size = networkHeaders.size(); i < size; i++) {
       String fieldName = networkHeaders.name(i);
       if ("Content-Length".equalsIgnoreCase(fieldName)) {
         continue; // Ignore content-length headers of validating responses.
@@ -861,4 +1129,26 @@ public boolean sameConnection(URL followUp) {
         && getEffectivePort(url) == getEffectivePort(followUp)
         && url.getProtocol().equals(followUp.getProtocol());
   }
+
+  private static Address createAddress(OkHttpClient client, Request request)
+      throws RequestException {
+    String uriHost = request.url().getHost();
+    if (uriHost == null || uriHost.length() == 0) {
+      throw new RequestException(new UnknownHostException(request.url().toString()));
+    }
+
+    SSLSocketFactory sslSocketFactory = null;
+    HostnameVerifier hostnameVerifier = null;
+    CertificatePinner certificatePinner = null;
+    if (request.isHttps()) {
+      sslSocketFactory = client.getSslSocketFactory();
+      hostnameVerifier = client.getHostnameVerifier();
+      certificatePinner = client.getCertificatePinner();
+    }
+
+    return new Address(uriHost, getEffectivePort(request.url()),
+        client.getSocketFactory(), sslSocketFactory, hostnameVerifier, certificatePinner,
+        client.getAuthenticator(), client.getProxy(), client.getProtocols(),
+        client.getConnectionSpecs(), client.getProxySelector());
+  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpMethod.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpMethod.java
index 78ffb414e0..b5f2a48f86 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpMethod.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpMethod.java
@@ -15,14 +15,7 @@
  */
 package com.squareup.okhttp.internal.http;
 
-import java.util.Arrays;
-import java.util.LinkedHashSet;
-import java.util.Set;
-
 public final class HttpMethod {
-  public static final Set<String> METHODS = new LinkedHashSet<>(Arrays.asList(
-      "OPTIONS", "GET", "HEAD", "POST", "PUT", "DELETE", "TRACE", "PATCH"));
-
   public static boolean invalidatesCache(String method) {
     return method.equals("POST")
         || method.equals("PATCH")
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpTransport.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpTransport.java
index de501bdc95..d02e1e56d1 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpTransport.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpTransport.java
@@ -18,7 +18,9 @@
 
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
+import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
+import okio.Okio;
 import okio.Sink;
 import okio.Source;
 
@@ -46,7 +48,7 @@ public HttpTransport(HttpEngine httpEngine, HttpConnection httpConnection) {
         "Cannot stream a request body without chunked encoding or a known content length!");
   }
 
-  @Override public void flushRequest() throws IOException {
+  @Override public void finishRequest() throws IOException {
     httpConnection.flush();
   }
 
@@ -104,28 +106,29 @@ public void writeRequestHeaders(Request request) throws IOException {
     return true;
   }
 
-  @Override public void emptyTransferStream() throws IOException {
-    httpConnection.emptyResponseBody();
+  @Override public ResponseBody openResponseBody(Response response) throws IOException {
+    Source source = getTransferStream(response);
+    return new RealResponseBody(response.headers(), Okio.buffer(source));
   }
 
-  @Override public Source getTransferStream(CacheRequest cacheRequest) throws IOException {
-    if (!httpEngine.hasResponseBody()) {
-      return httpConnection.newFixedLengthSource(cacheRequest, 0);
+  private Source getTransferStream(Response response) throws IOException {
+    if (!HttpEngine.hasBody(response)) {
+      return httpConnection.newFixedLengthSource(0);
     }
 
-    if ("chunked".equalsIgnoreCase(httpEngine.getResponse().header("Transfer-Encoding"))) {
-      return httpConnection.newChunkedSource(cacheRequest, httpEngine);
+    if ("chunked".equalsIgnoreCase(response.header("Transfer-Encoding"))) {
+      return httpConnection.newChunkedSource(httpEngine);
     }
 
-    long contentLength = OkHeaders.contentLength(httpEngine.getResponse());
+    long contentLength = OkHeaders.contentLength(response);
     if (contentLength != -1) {
-      return httpConnection.newFixedLengthSource(cacheRequest, contentLength);
+      return httpConnection.newFixedLengthSource(contentLength);
     }
 
     // Wrap the input stream from the connection (rather than just returning
     // "socketIn" directly here), so that we can control its use after the
     // reference escapes.
-    return httpConnection.newUnknownLengthSource(cacheRequest);
+    return httpConnection.newUnknownLengthSource();
   }
 
   @Override public void disconnect(HttpEngine engine) throws IOException {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/OkHeaders.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/OkHeaders.java
index b09801b487..c381c47562 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/OkHeaders.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/OkHeaders.java
@@ -87,7 +87,7 @@ private static long stringToLong(String s) {
    */
   public static Map<String, List<String>> toMultimap(Headers headers, String valueForNullKey) {
     Map<String, List<String>> result = new TreeMap<>(FIELD_NAME_COMPARATOR);
-    for (int i = 0; i < headers.size(); i++) {
+    for (int i = 0, size = headers.size(); i < size; i++) {
       String fieldName = headers.name(i);
       String value = headers.value(i);
 
@@ -122,7 +122,7 @@ public static void addCookies(Request.Builder builder, Map<String, List<String>>
   private static String buildCookieHeader(List<String> cookies) {
     if (cookies.size() == 1) return cookies.get(0);
     StringBuilder sb = new StringBuilder();
-    for (int i = 0; i < cookies.size(); i++) {
+    for (int i = 0, size = cookies.size(); i < size; i++) {
       if (i > 0) sb.append("; ");
       sb.append(cookies.get(i));
     }
@@ -146,16 +146,31 @@ public static boolean varyMatches(
    * be cached.
    */
   public static boolean hasVaryAll(Response response) {
-    return varyFields(response).contains("*");
+    return hasVaryAll(response.headers());
+  }
+
+  /**
+   * Returns true if a Vary header contains an asterisk. Such responses cannot
+   * be cached.
+   */
+  public static boolean hasVaryAll(Headers responseHeaders) {
+    return varyFields(responseHeaders).contains("*");
   }
 
   private static Set<String> varyFields(Response response) {
+    return varyFields(response.headers());
+  }
+
+  /**
+   * Returns the names of the request headers that need to be checked for
+   * equality when caching.
+   */
+  public static Set<String> varyFields(Headers responseHeaders) {
     Set<String> result = Collections.emptySet();
-    Headers headers = response.headers();
-    for (int i = 0; i < headers.size(); i++) {
-      if (!"Vary".equalsIgnoreCase(headers.name(i))) continue;
+    for (int i = 0, size = responseHeaders.size(); i < size; i++) {
+      if (!"Vary".equalsIgnoreCase(responseHeaders.name(i))) continue;
 
-      String value = headers.value(i);
+      String value = responseHeaders.value(i);
       if (result.isEmpty()) {
         result = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);
       }
@@ -171,16 +186,24 @@ public static boolean hasVaryAll(Response response) {
    * impact the content of response's body.
    */
   public static Headers varyHeaders(Response response) {
-    Set<String> varyFields = varyFields(response);
-    if (varyFields.isEmpty()) return new Headers.Builder().build();
-
     // Use the request headers sent over the network, since that's what the
     // response varies on. Otherwise OkHttp-supplied headers like
     // "Accept-Encoding: gzip" may be lost.
     Headers requestHeaders = response.networkResponse().request().headers();
+    Headers responseHeaders = response.headers();
+    return varyHeaders(requestHeaders, responseHeaders);
+  }
+
+  /**
+   * Returns the subset of the headers in {@code requestHeaders} that
+   * impact the content of response's body.
+   */
+  public static Headers varyHeaders(Headers requestHeaders, Headers responseHeaders) {
+    Set<String> varyFields = varyFields(responseHeaders);
+    if (varyFields.isEmpty()) return new Headers.Builder().build();
 
     Headers.Builder result = new Headers.Builder();
-    for (int i = 0; i < requestHeaders.size(); i++) {
+    for (int i = 0, size = requestHeaders.size(); i < size; i++) {
       String fieldName = requestHeaders.name(i);
       if (varyFields.contains(fieldName)) {
         result.add(fieldName, requestHeaders.value(i));
@@ -215,11 +238,11 @@ static boolean isEndToEnd(String fieldName) {
     // realm       = "realm" "=" realm-value
     // realm-value = quoted-string
     List<Challenge> result = new ArrayList<>();
-    for (int h = 0; h < responseHeaders.size(); h++) {
-      if (!challengeHeader.equalsIgnoreCase(responseHeaders.name(h))) {
+    for (int i = 0, size = responseHeaders.size(); i < size; i++) {
+      if (!challengeHeader.equalsIgnoreCase(responseHeaders.name(i))) {
         continue;
       }
-      String value = responseHeaders.value(h);
+      String value = responseHeaders.value(i);
       int pos = 0;
       while (pos < value.length()) {
         int tokenStart = pos;
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RealResponseBody.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RealResponseBody.java
new file mode 100644
index 0000000000..18d026f11a
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RealResponseBody.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.http;
+
+import com.squareup.okhttp.Headers;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.ResponseBody;
+import okio.BufferedSource;
+
+public final class RealResponseBody extends ResponseBody {
+  private final Headers headers;
+  private final BufferedSource source;
+
+  public RealResponseBody(Headers headers, BufferedSource source) {
+    this.headers = headers;
+    this.source = source;
+  }
+
+  @Override public MediaType contentType() {
+    String contentType = headers.get("Content-Type");
+    return contentType != null ? MediaType.parse(contentType) : null;
+  }
+
+  @Override public long contentLength() {
+    return OkHeaders.contentLength(headers);
+  }
+
+  @Override public BufferedSource source() {
+    return source;
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RequestException.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RequestException.java
new file mode 100644
index 0000000000..16893acdfb
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RequestException.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.http;
+
+import java.io.IOException;
+
+/**
+ * Indicates a problem with interpreting a request. It may indicate there was a problem with the
+ * request itself, or the environment being used to interpret the request (network failure, etc.).
+ */
+public final class RequestException extends Exception {
+
+  public RequestException(IOException cause) {
+    super(cause);
+  }
+
+  @Override
+  public IOException getCause() {
+    return (IOException) super.getCause();
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RetryableSink.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RetryableSink.java
index 9c50b702fe..371769f66e 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RetryableSink.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RetryableSink.java
@@ -72,8 +72,9 @@ public long contentLength() throws IOException {
   }
 
   public void writeToSocket(Sink socketOut) throws IOException {
-    // Clone the content; otherwise we won't have data to retry.
-    Buffer buffer = content.clone();
+    // Copy the content; otherwise we won't have data to retry.
+    Buffer buffer = new Buffer();
+    content.copyTo(buffer, 0, content.size());
     socketOut.write(buffer, buffer.size());
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RouteException.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RouteException.java
new file mode 100644
index 0000000000..62b31751e9
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RouteException.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.http;
+
+import java.io.IOException;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+
+/**
+ * An exception thrown to indicate a problem connecting via a single Route. Multiple attempts may
+ * have been made with alternative protocols, none of which were successful.
+ */
+public final class RouteException extends Exception {
+  private static final Method addSuppressedExceptionMethod;
+  static {
+    Method m;
+    try {
+      m = Throwable.class.getDeclaredMethod("addSuppressed", Throwable.class);
+    } catch (Exception e) {
+      m = null;
+    }
+    addSuppressedExceptionMethod = m;
+  }
+  private IOException lastException;
+
+  public RouteException(IOException cause) {
+    super(cause);
+    lastException = cause;
+  }
+
+  public IOException getLastConnectException() {
+    return lastException;
+  }
+
+  public void addConnectException(IOException e) {
+    addSuppressedIfPossible(e, lastException);
+    lastException = e;
+  }
+
+  private void addSuppressedIfPossible(IOException e, IOException suppressed) {
+    if (addSuppressedExceptionMethod != null) {
+      try {
+        addSuppressedExceptionMethod.invoke(e, suppressed);
+      } catch (InvocationTargetException | IllegalAccessException ignored) {
+      }
+    }
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RouteSelector.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RouteSelector.java
index a6e6022c9d..16448e4dea 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RouteSelector.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RouteSelector.java
@@ -16,10 +16,6 @@
 package com.squareup.okhttp.internal.http;
 
 import com.squareup.okhttp.Address;
-import com.squareup.okhttp.CertificatePinner;
-import com.squareup.okhttp.Connection;
-import com.squareup.okhttp.ConnectionSpec;
-import com.squareup.okhttp.ConnectionPool;
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Route;
@@ -30,19 +26,13 @@
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.net.Proxy;
-import java.net.ProxySelector;
 import java.net.SocketAddress;
 import java.net.SocketException;
 import java.net.URI;
-import java.net.UnknownHostException;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 import java.util.NoSuchElementException;
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.SSLHandshakeException;
-import javax.net.ssl.SSLProtocolException;
-import javax.net.ssl.SSLSocketFactory;
 
 import static com.squareup.okhttp.internal.Util.getEffectivePort;
 
@@ -56,15 +46,11 @@
   private final URI uri;
   private final Network network;
   private final OkHttpClient client;
-  private final ProxySelector proxySelector;
-  private final ConnectionPool pool;
   private final RouteDatabase routeDatabase;
-  private final Request request;
 
   /* The most recently attempted route. */
   private Proxy lastProxy;
   private InetSocketAddress lastInetSocketAddress;
-  private ConnectionSpec lastSpec;
 
   /* State for negotiating the next proxy to use. */
   private List<Proxy> proxies = Collections.emptyList();
@@ -74,47 +60,22 @@
   private List<InetSocketAddress> inetSocketAddresses = Collections.emptyList();
   private int nextInetSocketAddressIndex;
 
-  /* Specs to attempt with the connection. */
-  private List<ConnectionSpec> connectionSpecs = Collections.emptyList();
-  private int nextSpecIndex;
-
   /* State for negotiating failed routes */
   private final List<Route> postponedRoutes = new ArrayList<>();
 
-  private RouteSelector(Address address, URI uri, OkHttpClient client, Request request) {
+  private RouteSelector(Address address, URI uri, OkHttpClient client) {
     this.address = address;
     this.uri = uri;
     this.client = client;
-    this.proxySelector = client.getProxySelector();
-    this.pool = client.getConnectionPool();
     this.routeDatabase = Internal.instance.routeDatabase(client);
     this.network = Internal.instance.network(client);
-    this.request = request;
 
     resetNextProxy(uri, address.getProxy());
   }
 
-  public static RouteSelector get(Request request, OkHttpClient client) throws IOException {
-    String uriHost = request.url().getHost();
-    if (uriHost == null || uriHost.length() == 0) {
-      throw new UnknownHostException(request.url().toString());
-    }
-
-    SSLSocketFactory sslSocketFactory = null;
-    HostnameVerifier hostnameVerifier = null;
-    CertificatePinner certificatePinner = null;
-    if (request.isHttps()) {
-      sslSocketFactory = client.getSslSocketFactory();
-      hostnameVerifier = client.getHostnameVerifier();
-      certificatePinner = client.getCertificatePinner();
-    }
-
-    Address address = new Address(uriHost, getEffectivePort(request.url()),
-        client.getSocketFactory(), sslSocketFactory, hostnameVerifier, certificatePinner,
-        client.getAuthenticator(), client.getProxy(), client.getProtocols(),
-        client.getConnectionSpecs());
-
-    return new RouteSelector(address, request.uri(), client, request);
+  public static RouteSelector get(Address address, Request request, OkHttpClient client)
+      throws IOException {
+    return new RouteSelector(address, request.uri(), client);
   }
 
   /**
@@ -122,82 +83,45 @@ public static RouteSelector get(Request request, OkHttpClient client) throws IOE
    * least one route.
    */
   public boolean hasNext() {
-    return hasNextConnectionSpec()
-        || hasNextInetSocketAddress()
+    return hasNextInetSocketAddress()
         || hasNextProxy()
         || hasNextPostponed();
   }
 
-  /** Selects a route to attempt and connects it if it isn't already. */
-  public Connection next(HttpEngine owner) throws IOException {
-    Connection connection = nextUnconnected();
-    Internal.instance.connectAndSetOwner(client, connection, owner, request);
-    return connection;
-  }
-
-  /**
-   * Returns the next connection to attempt.
-   *
-   * @throws NoSuchElementException if there are no more routes to attempt.
-   */
-  Connection nextUnconnected() throws IOException {
-    // Always prefer pooled connections over new connections.
-    for (Connection pooled; (pooled = pool.get(address)) != null; ) {
-      if (request.method().equals("GET") || Internal.instance.isReadable(pooled)) return pooled;
-      pooled.getSocket().close();
-    }
-
+  public Route next() throws IOException {
     // Compute the next route to attempt.
-    if (!hasNextConnectionSpec()) {
-      if (!hasNextInetSocketAddress()) {
-        if (!hasNextProxy()) {
-          if (!hasNextPostponed()) {
-            throw new NoSuchElementException();
-          }
-          return new Connection(pool, nextPostponed());
+    if (!hasNextInetSocketAddress()) {
+      if (!hasNextProxy()) {
+        if (!hasNextPostponed()) {
+          throw new NoSuchElementException();
         }
-        lastProxy = nextProxy();
+        return nextPostponed();
       }
-      lastInetSocketAddress = nextInetSocketAddress();
+      lastProxy = nextProxy();
     }
-    lastSpec = nextConnectionSpec();
+    lastInetSocketAddress = nextInetSocketAddress();
 
-    Route route = new Route(address, lastProxy, lastInetSocketAddress, lastSpec);
+    Route route = new Route(address, lastProxy, lastInetSocketAddress);
     if (routeDatabase.shouldPostpone(route)) {
       postponedRoutes.add(route);
       // We will only recurse in order to skip previously failed routes. They will be tried last.
-      return nextUnconnected();
+      return next();
     }
 
-    return new Connection(pool, route);
+    return route;
   }
 
   /**
    * Clients should invoke this method when they encounter a connectivity
    * failure on a connection returned by this route selector.
    */
-  public void connectFailed(Connection connection, IOException failure) {
-    // If this is a recycled connection, don't count its failure against the route.
-    if (Internal.instance.recycleCount(connection) > 0) return;
-
-    Route failedRoute = connection.getRoute();
-    if (failedRoute.getProxy().type() != Proxy.Type.DIRECT && proxySelector != null) {
+  public void connectFailed(Route failedRoute, IOException failure) {
+    if (failedRoute.getProxy().type() != Proxy.Type.DIRECT && address.getProxySelector() != null) {
       // Tell the proxy selector when we fail to connect on a fresh connection.
-      proxySelector.connectFailed(uri, failedRoute.getProxy().address(), failure);
+      address.getProxySelector().connectFailed(uri, failedRoute.getProxy().address(), failure);
     }
 
     routeDatabase.failed(failedRoute);
-
-    // If the previously returned route's problem was not related to the connection's spec, and the
-    // next route only changes that, we shouldn't even attempt it. This suppresses it in both this
-    // selector and also in the route database.
-    if (!(failure instanceof SSLHandshakeException) && !(failure instanceof SSLProtocolException)) {
-      while (nextSpecIndex < connectionSpecs.size()) {
-        Route toSuppress = new Route(address, lastProxy, lastInetSocketAddress,
-            connectionSpecs.get(nextSpecIndex++));
-        routeDatabase.failed(toSuppress);
-      }
-    }
   }
 
   /** Prepares the proxy servers to try. */
@@ -209,7 +133,7 @@ private void resetNextProxy(URI uri, Proxy proxy) {
       // Try each of the ProxySelector choices until one connection succeeds. If none succeed
       // then we'll try a direct connection below.
       proxies = new ArrayList<>();
-      List<Proxy> selectedProxies = proxySelector.select(uri);
+      List<Proxy> selectedProxies = client.getProxySelector().select(uri);
       if (selectedProxies != null) proxies.addAll(selectedProxies);
       // Finally try a direct connection. We only try it once!
       proxies.removeAll(Collections.singleton(Proxy.NO_PROXY));
@@ -235,13 +159,13 @@ private Proxy nextProxy() throws IOException {
   }
 
   /** Prepares the socket addresses to attempt for the current proxy or host. */
-  private void resetNextInetSocketAddress(Proxy proxy) throws UnknownHostException {
+  private void resetNextInetSocketAddress(Proxy proxy) throws IOException {
     // Clear the addresses. Necessary if getAllByName() below throws!
     inetSocketAddresses = new ArrayList<>();
 
     String socketHost;
     int socketPort;
-    if (proxy.type() == Proxy.Type.DIRECT) {
+    if (proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.SOCKS) {
       socketHost = address.getUriHost();
       socketPort = getEffectivePort(uri);
     } else {
@@ -251,17 +175,41 @@ private void resetNextInetSocketAddress(Proxy proxy) throws UnknownHostException
             "Proxy.address() is not an " + "InetSocketAddress: " + proxyAddress.getClass());
       }
       InetSocketAddress proxySocketAddress = (InetSocketAddress) proxyAddress;
-      socketHost = proxySocketAddress.getHostName();
+      socketHost = getHostString(proxySocketAddress);
       socketPort = proxySocketAddress.getPort();
     }
 
+    if (socketPort < 1 || socketPort > 65535) {
+      throw new SocketException("No route to " + socketHost + ":" + socketPort
+          + "; port is out of range");
+    }
+
     // Try each address for best behavior in mixed IPv4/IPv6 environments.
     for (InetAddress inetAddress : network.resolveInetAddresses(socketHost)) {
       inetSocketAddresses.add(new InetSocketAddress(inetAddress, socketPort));
     }
+
     nextInetSocketAddressIndex = 0;
   }
 
+  /**
+   * Obtain a "host" from an {@link InetSocketAddress}. This returns a string containing either an
+   * actual host name or a numeric IP address.
+   */
+  // Visible for testing
+  static String getHostString(InetSocketAddress socketAddress) {
+    InetAddress address = socketAddress.getAddress();
+    if (address == null) {
+      // The InetSocketAddress was specified with a string (either a numeric IP or a host name). If
+      // it is a name, all IPs for that name should be tried. If it is an IP address, only that IP
+      // address should be tried.
+      return socketAddress.getHostName();
+    }
+    // The InetSocketAddress has a specific address: we should only try that address. Therefore we
+    // return the address and ignore any host name that may be available.
+    return address.getHostAddress();
+  }
+
   /** Returns true if there's another socket address to try. */
   private boolean hasNextInetSocketAddress() {
     return nextInetSocketAddressIndex < inetSocketAddresses.size();
@@ -273,34 +221,7 @@ private InetSocketAddress nextInetSocketAddress() throws IOException {
       throw new SocketException("No route to " + address.getUriHost()
           + "; exhausted inet socket addresses: " + inetSocketAddresses);
     }
-    InetSocketAddress result = inetSocketAddresses.get(nextInetSocketAddressIndex++);
-    resetConnectionSpecs();
-    return result;
-  }
-
-  /** Prepares the connection specs to attempt. */
-  private void resetConnectionSpecs() {
-    connectionSpecs = new ArrayList<>();
-    for (ConnectionSpec spec : address.getConnectionSpecs()) {
-      if (request.isHttps() == spec.isTls()) {
-        connectionSpecs.add(spec);
-      }
-    }
-    nextSpecIndex = 0;
-  }
-
-  /** Returns true if there's another connection spec to try. */
-  private boolean hasNextConnectionSpec() {
-    return nextSpecIndex < connectionSpecs.size();
-  }
-
-  /** Returns the next connection spec to try. */
-  private ConnectionSpec nextConnectionSpec() throws IOException {
-    if (!hasNextConnectionSpec()) {
-      throw new SocketException("No route to " + address.getUriHost()
-          + "; exhausted connection specs: " + connectionSpecs);
-    }
-    return connectionSpecs.get(nextSpecIndex++);
+    return inetSocketAddresses.get(nextInetSocketAddressIndex++);
   }
 
   /** Returns true if there is another postponed route to try. */
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/SocketConnector.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/SocketConnector.java
new file mode 100644
index 0000000000..c1159bc19b
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/SocketConnector.java
@@ -0,0 +1,280 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.http;
+
+import com.squareup.okhttp.Address;
+import com.squareup.okhttp.CertificatePinner;
+import com.squareup.okhttp.Connection;
+import com.squareup.okhttp.ConnectionPool;
+import com.squareup.okhttp.ConnectionSpec;
+import com.squareup.okhttp.Handshake;
+import com.squareup.okhttp.Protocol;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import com.squareup.okhttp.Route;
+import com.squareup.okhttp.internal.Platform;
+import com.squareup.okhttp.internal.ConnectionSpecSelector;
+import com.squareup.okhttp.internal.Util;
+import com.squareup.okhttp.internal.tls.OkHostnameVerifier;
+
+import java.io.IOException;
+import java.net.Proxy;
+import java.net.Socket;
+import java.net.URL;
+import java.security.cert.X509Certificate;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import javax.net.ssl.SSLSocket;
+import javax.net.ssl.SSLSocketFactory;
+
+import okio.Source;
+
+import static com.squareup.okhttp.internal.Util.closeQuietly;
+import static com.squareup.okhttp.internal.Util.getDefaultPort;
+import static com.squareup.okhttp.internal.Util.getEffectivePort;
+import static java.net.HttpURLConnection.HTTP_OK;
+import static java.net.HttpURLConnection.HTTP_PROXY_AUTH;
+
+/**
+ * Helper that can establish a socket connection to a {@link com.squareup.okhttp.Route} using the
+ * specified {@link ConnectionSpec} set. A {@link SocketConnector} can be used multiple times.
+ */
+public class SocketConnector {
+  private final Connection connection;
+  private final ConnectionPool connectionPool;
+
+  public SocketConnector(Connection connection, ConnectionPool connectionPool) {
+    this.connection = connection;
+    this.connectionPool = connectionPool;
+  }
+
+  public ConnectedSocket connectCleartext(int connectTimeout, int readTimeout, Route route)
+      throws RouteException {
+    Socket socket = connectRawSocket(readTimeout, connectTimeout, route);
+    return new ConnectedSocket(route, socket);
+  }
+
+  public ConnectedSocket connectTls(int connectTimeout, int readTimeout,
+      int writeTimeout, Request request, Route route, List<ConnectionSpec> connectionSpecs,
+      boolean connectionRetryEnabled) throws RouteException {
+
+    Address address = route.getAddress();
+    ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);
+    RouteException routeException = null;
+    do {
+      Socket socket = connectRawSocket(readTimeout, connectTimeout, route);
+      if (route.requiresTunnel()) {
+        createTunnel(readTimeout, writeTimeout, request, route, socket);
+      }
+
+      SSLSocket sslSocket = null;
+      try {
+        SSLSocketFactory sslSocketFactory = address.getSslSocketFactory();
+
+        // Create the wrapper over the connected socket.
+        sslSocket = (SSLSocket) sslSocketFactory
+            .createSocket(socket, address.getUriHost(), address.getUriPort(), true /* autoClose */);
+
+        // Configure the socket's ciphers, TLS versions, and extensions.
+        ConnectionSpec connectionSpec = connectionSpecSelector.configureSecureSocket(sslSocket);
+        Platform platform = Platform.get();
+        Handshake handshake = null;
+        Protocol alpnProtocol = null;
+        try {
+          if (connectionSpec.supportsTlsExtensions()) {
+            platform.configureTlsExtensions(
+                sslSocket, address.getUriHost(), address.getProtocols());
+          }
+          // Force handshake. This can throw!
+          sslSocket.startHandshake();
+
+          handshake = Handshake.get(sslSocket.getSession());
+
+          String maybeProtocol;
+          if (connectionSpec.supportsTlsExtensions()
+              && (maybeProtocol = platform.getSelectedProtocol(sslSocket)) != null) {
+            alpnProtocol = Protocol.get(maybeProtocol); // Throws IOE on unknown.
+          }
+        } finally {
+          platform.afterHandshake(sslSocket);
+        }
+
+        // Verify that the socket's certificates are acceptable for the target host.
+        if (!address.getHostnameVerifier().verify(address.getUriHost(), sslSocket.getSession())) {
+          X509Certificate cert = (X509Certificate) sslSocket.getSession()
+              .getPeerCertificates()[0];
+          throw new SSLPeerUnverifiedException(
+              "Hostname " + address.getUriHost() + " not verified:"
+              + "\n    certificate: " + CertificatePinner.pin(cert)
+              + "\n    DN: " + cert.getSubjectDN().getName()
+              + "\n    subjectAltNames: " + OkHostnameVerifier.allSubjectAltNames(cert));
+        }
+
+        // Check that the certificate pinner is satisfied by the certificates presented.
+        address.getCertificatePinner().check(address.getUriHost(), handshake.peerCertificates());
+
+        return new ConnectedSocket(route, sslSocket, alpnProtocol, handshake);
+      } catch (IOException e) {
+        boolean canRetry = connectionRetryEnabled && connectionSpecSelector.connectionFailed(e);
+        closeQuietly(sslSocket);
+        closeQuietly(socket);
+        if (routeException == null) {
+          routeException = new RouteException(e);
+        } else {
+          routeException.addConnectException(e);
+        }
+        if (!canRetry) {
+          throw routeException;
+        }
+      }
+    } while (true);
+  }
+
+  private Socket connectRawSocket(int soTimeout, int connectTimeout, Route route)
+      throws RouteException {
+    Platform platform = Platform.get();
+    try {
+      Proxy proxy = route.getProxy();
+      Address address = route.getAddress();
+      Socket socket;
+      if (proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP) {
+        socket = address.getSocketFactory().createSocket();
+      } else {
+        socket = new Socket(proxy);
+      }
+      socket.setSoTimeout(soTimeout);
+      platform.connectSocket(socket, route.getSocketAddress(), connectTimeout);
+
+      return socket;
+    } catch (IOException e) {
+      throw new RouteException(e);
+    }
+  }
+
+  /**
+   * To make an HTTPS connection over an HTTP proxy, send an unencrypted
+   * CONNECT request to create the proxy connection. This may need to be
+   * retried if the proxy requires authorization.
+   */
+  private void createTunnel(int readTimeout, int writeTimeout, Request request, Route route,
+      Socket socket) throws RouteException {
+    // Make an SSL Tunnel on the first message pair of each SSL + proxy connection.
+    try {
+      Request tunnelRequest = createTunnelRequest(request);
+      HttpConnection tunnelConnection = new HttpConnection(connectionPool, connection, socket);
+      tunnelConnection.setTimeouts(readTimeout, writeTimeout);
+      URL url = tunnelRequest.url();
+      String requestLine = "CONNECT " + url.getHost() + ":" + getEffectivePort(url) + " HTTP/1.1";
+      while (true) {
+        tunnelConnection.writeRequest(tunnelRequest.headers(), requestLine);
+        tunnelConnection.flush();
+        Response response = tunnelConnection.readResponse().request(tunnelRequest).build();
+        // The response body from a CONNECT should be empty, but if it is not then we should consume
+        // it before proceeding.
+        long contentLength = OkHeaders.contentLength(response);
+        if (contentLength == -1L) {
+          contentLength = 0L;
+        }
+        Source body = tunnelConnection.newFixedLengthSource(contentLength);
+        Util.skipAll(body, Integer.MAX_VALUE, TimeUnit.MILLISECONDS);
+        body.close();
+
+        switch (response.code()) {
+          case HTTP_OK:
+            // Assume the server won't send a TLS ServerHello until we send a TLS ClientHello. If
+            // that happens, then we will have buffered bytes that are needed by the SSLSocket!
+            // This check is imperfect: it doesn't tell us whether a handshake will succeed, just
+            // that it will almost certainly fail because the proxy has sent unexpected data.
+            if (tunnelConnection.bufferSize() > 0) {
+              throw new IOException("TLS tunnel buffered too many bytes!");
+            }
+            return;
+
+          case HTTP_PROXY_AUTH:
+            tunnelRequest = OkHeaders.processAuthHeader(
+                route.getAddress().getAuthenticator(), response, route.getProxy());
+            if (tunnelRequest != null) continue;
+            throw new IOException("Failed to authenticate with proxy");
+
+          default:
+            throw new IOException(
+                "Unexpected response code for CONNECT: " + response.code());
+        }
+      }
+    } catch (IOException e) {
+      throw new RouteException(e);
+    }
+  }
+
+  /**
+   * Returns a request that creates a TLS tunnel via an HTTP proxy, or null if
+   * no tunnel is necessary. Everything in the tunnel request is sent
+   * unencrypted to the proxy server, so tunnels include only the minimum set of
+   * headers. This avoids sending potentially sensitive data like HTTP cookies
+   * to the proxy unencrypted.
+   */
+  private Request createTunnelRequest(Request request) throws IOException {
+    String host = request.url().getHost();
+    int port = getEffectivePort(request.url());
+    String authority = (port == getDefaultPort("https")) ? host : (host + ":" + port);
+    Request.Builder result = new Request.Builder()
+        .url(new URL("https", host, port, "/"))
+        .header("Host", authority)
+        .header("Proxy-Connection", "Keep-Alive"); // For HTTP/1.0 proxies like Squid.
+
+    // Copy over the User-Agent header if it exists.
+    String userAgent = request.header("User-Agent");
+    if (userAgent != null) {
+      result.header("User-Agent", userAgent);
+    }
+
+    // Copy over the Proxy-Authorization header if it exists.
+    String proxyAuthorization = request.header("Proxy-Authorization");
+    if (proxyAuthorization != null) {
+      result.header("Proxy-Authorization", proxyAuthorization);
+    }
+
+    return result.build();
+  }
+
+  /**
+   * A connected socket with metadata.
+   */
+  public static class ConnectedSocket {
+    public final Route route;
+    public final Socket socket;
+    public final Protocol alpnProtocol;
+    public final Handshake handshake;
+
+    /** A connected plain / raw (i.e. unencrypted communication) socket. */
+    public ConnectedSocket(Route route, Socket socket) {
+      this.route = route;
+      this.socket = socket;
+      alpnProtocol = null;
+      handshake = null;
+    }
+
+    /** A connected {@link SSLSocket}. */
+    public ConnectedSocket(Route route, SSLSocket socket, Protocol alpnProtocol,
+        Handshake handshake) {
+      this.route = route;
+      this.socket = socket;
+      this.alpnProtocol = alpnProtocol;
+      this.handshake = handshake;
+    }
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
index afb30a9f8a..61b6610810 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
@@ -20,6 +20,7 @@
 import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
+import com.squareup.okhttp.ResponseBody;
 import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.internal.spdy.ErrorCode;
 import com.squareup.okhttp.internal.spdy.Header;
@@ -33,11 +34,9 @@
 import java.util.Locale;
 import java.util.Set;
 import java.util.concurrent.TimeUnit;
-import okio.Buffer;
 import okio.ByteString;
+import okio.Okio;
 import okio.Sink;
-import okio.Source;
-import okio.Timeout;
 
 import static com.squareup.okhttp.internal.spdy.Header.RESPONSE_STATUS;
 import static com.squareup.okhttp.internal.spdy.Header.TARGET_AUTHORITY;
@@ -97,7 +96,7 @@ public SpdyTransport(HttpEngine httpEngine, SpdyConnection spdyConnection) {
     requestBody.writeToSocket(stream.getSink());
   }
 
-  @Override public void flushRequest() throws IOException {
+  @Override public void finishRequest() throws IOException {
     stream.getSink().close();
   }
 
@@ -128,7 +127,7 @@ public SpdyTransport(HttpEngine httpEngine, SpdyConnection spdyConnection) {
     result.add(new Header(TARGET_SCHEME, request.url().getProtocol()));
 
     Set<ByteString> names = new LinkedHashSet<ByteString>();
-    for (int i = 0; i < headers.size(); i++) {
+    for (int i = 0, size = headers.size(); i < size; i++) {
       // header names must be lowercase.
       ByteString name = ByteString.encodeUtf8(headers.name(i).toLowerCase(Locale.US));
       String value = headers.value(i);
@@ -176,7 +175,7 @@ private static String joinOnNull(String first, String second) {
 
     Headers.Builder headersBuilder = new Headers.Builder();
     headersBuilder.set(OkHeaders.SELECTED_PROTOCOL, protocol.toString());
-    for (int i = 0; i < headerBlock.size(); i++) {
+    for (int i = 0, size = headerBlock.size(); i < size; i++) {
       ByteString name = headerBlock.get(i).name;
       String values = headerBlock.get(i).value.utf8();
       for (int start = 0; start < values.length(); ) {
@@ -196,7 +195,6 @@ private static String joinOnNull(String first, String second) {
       }
     }
     if (status == null) throw new ProtocolException("Expected ':status' header not present");
-    if (version == null) throw new ProtocolException("Expected ':version' header not present");
 
     StatusLine statusLine = StatusLine.parse(version + " " + status);
     return new Response.Builder()
@@ -206,19 +204,15 @@ private static String joinOnNull(String first, String second) {
         .headers(headersBuilder.build());
   }
 
-  @Override public void emptyTransferStream() {
-    // Do nothing.
-  }
-
-  @Override public Source getTransferStream(CacheRequest cacheRequest) throws IOException {
-    return new SpdySource(stream, cacheRequest);
+  @Override public ResponseBody openResponseBody(Response response) throws IOException {
+    return new RealResponseBody(response.headers(), Okio.buffer(stream.getSource()));
   }
 
   @Override public void releaseConnectionOnIdle() {
   }
 
   @Override public void disconnect(HttpEngine engine) throws IOException {
-    stream.close(ErrorCode.CANCEL);
+    if (stream != null) stream.close(ErrorCode.CANCEL);
   }
 
   @Override public boolean canReuseConnection() {
@@ -235,86 +229,4 @@ private static boolean isProhibitedHeader(Protocol protocol, ByteString name) {
       throw new AssertionError(protocol);
     }
   }
-
-  /** An HTTP message body terminated by the end of the underlying stream. */
-  private static class SpdySource implements Source {
-    private final SpdyStream stream;
-    private final Source source;
-    private final CacheRequest cacheRequest;
-    private final Sink cacheBody;
-
-    private boolean inputExhausted;
-    private boolean closed;
-
-    SpdySource(SpdyStream stream, CacheRequest cacheRequest) throws IOException {
-      this.stream = stream;
-      this.source = stream.getSource();
-
-      // Some apps return a null body; for compatibility we treat that like a null cache request.
-      Sink cacheBody = cacheRequest != null ? cacheRequest.body() : null;
-      if (cacheBody == null) {
-        cacheRequest = null;
-      }
-
-      this.cacheBody = cacheBody;
-      this.cacheRequest = cacheRequest;
-    }
-
-    @Override public long read(Buffer buffer, long byteCount)
-        throws IOException {
-      if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
-      if (closed) throw new IllegalStateException("closed");
-      if (inputExhausted) return -1;
-
-      long read = source.read(buffer, byteCount);
-      if (read == -1) {
-        inputExhausted = true;
-        if (cacheRequest != null) {
-          cacheBody.close();
-        }
-        return -1;
-      }
-
-      if (cacheBody != null) {
-        // TODO get buffer.copyTo(cacheBody, read);
-        cacheBody.write(buffer.clone(), read);
-      }
-
-      return read;
-    }
-
-    @Override public Timeout timeout() {
-      return source.timeout();
-    }
-
-    @Override public void close() throws IOException {
-      if (closed) return;
-
-      if (!inputExhausted && cacheBody != null) {
-        discardStream(); // Could make inputExhausted true!
-      }
-
-      closed = true;
-
-      if (!inputExhausted) {
-        stream.closeLater(ErrorCode.CANCEL);
-        if (cacheRequest != null) {
-          cacheRequest.abort();
-        }
-      }
-    }
-
-    private boolean discardStream() {
-      long oldTimeoutNanos = stream.readTimeout().timeoutNanos();
-      stream.readTimeout().timeout(DISCARD_STREAM_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);
-      try {
-        Util.skipAll(this, DISCARD_STREAM_TIMEOUT_MILLIS);
-        return true;
-      } catch (IOException e) {
-        return false;
-      } finally {
-        stream.readTimeout().timeout(oldTimeoutNanos, TimeUnit.NANOSECONDS);
-      }
-    }
-  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/Transport.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/Transport.java
index add6e8be14..77f7c9e746 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/Transport.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/Transport.java
@@ -18,9 +18,9 @@
 
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
+import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
 import okio.Sink;
-import okio.Source;
 
 public interface Transport {
   /**
@@ -42,17 +42,14 @@
    */
   void writeRequestBody(RetryableSink requestBody) throws IOException;
 
-  /** Flush the request body to the underlying socket. */
-  void flushRequest() throws IOException;
+  /** Flush the request to the underlying socket. */
+  void finishRequest() throws IOException;
 
-  /** Read response headers and update the cookie manager. */
+  /** Read and return response headers. */
   Response.Builder readResponseHeaders() throws IOException;
 
-  /** Notify the transport that no response body will be read. */
-  void emptyTransferStream() throws IOException;
-
-  // TODO: make this the content stream?
-  Source getTransferStream(CacheRequest cacheRequest) throws IOException;
+  /** Returns a stream that reads the response body. */
+  ResponseBody openResponseBody(Response response) throws IOException;
 
   /**
    * Configures the response body to pool or close the socket connection when
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/io/FileSystem.java b/okhttp/src/main/java/com/squareup/okhttp/internal/io/FileSystem.java
new file mode 100644
index 0000000000..74245997a5
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/io/FileSystem.java
@@ -0,0 +1,137 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.io;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import okio.Okio;
+import okio.Sink;
+import okio.Source;
+
+/**
+ * Access to read and write files on a hierarchical data store. Most callers should use the {@link
+ * #SYSTEM} implementation, which uses the host machine's local file system. Alternate
+ * implementations may be used to inject faults (for testing) or to transform stored data (to add
+ * encryption, for example).
+ *
+ * <p>All operations on a file system are racy. For example, guarding a call to {@link #source}
+ * with {@link #exists} does not guarantee that {@link FileNotFoundException} will not be thrown.
+ * The file may be moved between the two calls!
+ *
+ * <p>This interface is less ambitious than {@link java.nio.file.FileSystem} introduced in Java 7.
+ * It lacks important features like file watching, metadata, permissions, and disk space
+ * information. In exchange for these limitations, this interface is easier to implement and works
+ * on all versions of Java and Android.
+ */
+public interface FileSystem {
+  /** The host machine's local file system. */
+  FileSystem SYSTEM = new FileSystem() {
+    @Override public Source source(File file) throws FileNotFoundException {
+      return Okio.source(file);
+    }
+
+    @Override public Sink sink(File file) throws FileNotFoundException {
+      try {
+        return Okio.sink(file);
+      } catch (FileNotFoundException e) {
+        // Maybe the parent directory doesn't exist? Try creating it first.
+        file.getParentFile().mkdirs();
+        return Okio.sink(file);
+      }
+    }
+
+    @Override public Sink appendingSink(File file) throws FileNotFoundException {
+      try {
+        return Okio.appendingSink(file);
+      } catch (FileNotFoundException e) {
+        // Maybe the parent directory doesn't exist? Try creating it first.
+        file.getParentFile().mkdirs();
+        return Okio.appendingSink(file);
+      }
+    }
+
+    @Override public void delete(File file) throws IOException {
+      // If delete() fails, make sure it's because the file didn't exist!
+      if (!file.delete() && file.exists()) {
+        throw new IOException("failed to delete " + file);
+      }
+    }
+
+    @Override public boolean exists(File file) throws IOException {
+      return file.exists();
+    }
+
+    @Override public long size(File file) {
+      return file.length();
+    }
+
+    @Override public void rename(File from, File to) throws IOException {
+      delete(to);
+      if (!from.renameTo(to)) {
+        throw new IOException("failed to rename " + from + " to " + to);
+      }
+    }
+
+    @Override public void deleteContents(File directory) throws IOException {
+      File[] files = directory.listFiles();
+      if (files == null) {
+        throw new IOException("not a readable directory: " + directory);
+      }
+      for (File file : files) {
+        if (file.isDirectory()) {
+          deleteContents(file);
+        }
+        if (!file.delete()) {
+          throw new IOException("failed to delete " + file);
+        }
+      }
+    }
+  };
+
+  /** Reads from {@code file}. */
+  Source source(File file) throws FileNotFoundException;
+
+  /**
+   * Writes to {@code file}, discarding any data already present. Creates parent directories if
+   * necessary.
+   */
+  Sink sink(File file) throws FileNotFoundException;
+
+  /**
+   * Writes to {@code file}, appending if data is already present. Creates parent directories if
+   * necessary.
+   */
+  Sink appendingSink(File file) throws FileNotFoundException;
+
+  /** Deletes {@code file} if it exists. Throws if the file exists and cannot be deleted. */
+  void delete(File file) throws IOException;
+
+  /** Returns true if {@code file} exists on the file system. */
+  boolean exists(File file) throws IOException;
+
+  /** Returns the number of bytes stored in {@code file}, or 0 if it does not exist. */
+  long size(File file);
+
+  /** Renames {@code from} to {@code to}. Throws if the file cannot be renamed. */
+  void rename(File from, File to) throws IOException;
+
+  /**
+   * Recursively delete the contents of {@code directory}. Throws an IOException if any file could
+   * not be deleted, or if {@code dir} is not a readable directory.
+   */
+  void deleteContents(File directory) throws IOException;
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/ErrorCode.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/ErrorCode.java
index d1031258bc..701de92d64 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/ErrorCode.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/ErrorCode.java
@@ -15,7 +15,7 @@
  */
 package com.squareup.okhttp.internal.spdy;
 
-// http://tools.ietf.org/html/draft-ietf-httpbis-http2-14#section-7
+// http://tools.ietf.org/html/draft-ietf-httpbis-http2-17#section-7
 public enum ErrorCode {
   /** Not an error! For SPDY stream resets, prefer null over NO_ERROR. */
   NO_ERROR(0, -1, 0),
@@ -54,6 +54,8 @@
 
   INADEQUATE_SECURITY(12, -1, -1),
 
+  HTTP_1_1_REQUIRED(13, -1, -1),
+
   INVALID_CREDENTIALS(-1, 10, -1);
 
   public final int httpCode;
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
index f9b3a66480..c1c376dea6 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
@@ -27,7 +27,7 @@
   void readConnectionPreface() throws IOException;
   boolean nextFrame(Handler handler) throws IOException;
 
-  public interface Handler {
+  interface Handler {
     void data(boolean inFinished, int streamId, BufferedSource source, int length)
         throws IOException;
 
@@ -117,7 +117,7 @@ void pushPromise(int streamId, int promisedStreamId, List<Header> requestHeaders
      * initiated stream are available from a different network location or
      * protocol configuration.
      *
-     * <p>See <a href="https://tools.ietf.org/html/draft-ietf-httpbis-alt-svc-01">alt-svc</a>
+     * <p>See <a href="http://tools.ietf.org/html/draft-ietf-httpbis-alt-svc-01">alt-svc</a>
      *
      * @param streamId when a client-initiated stream ID (odd number), the
      *     origin of this alternate service is the origin of the stream. When
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft09.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Hpack.java
similarity index 77%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft09.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Hpack.java
index 91bdbf1c78..e8f9e51472 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft09.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Hpack.java
@@ -29,15 +29,15 @@
 import okio.Source;
 
 /**
- * Read and write HPACK v09.
+ * Read and write HPACK v10.
  *
- * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-09
+ * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12
  *
- * This implementation uses an array for the header table and a list for
+ * This implementation uses an array for the dynamic table and a list for
  * indexed entries.  Dynamic entries are added to the array, starting in the
  * last position moving forward.  When the array fills, it is doubled.
  */
-final class HpackDraft09 {
+final class Hpack {
   private static final int PREFIX_4_BITS = 0x0f;
   private static final int PREFIX_5_BITS = 0x1f;
   private static final int PREFIX_6_BITS = 0x3f;
@@ -107,63 +107,63 @@
       new Header("www-authenticate", "")
   };
 
-  private HpackDraft09() {
+  private Hpack() {
   }
 
-  // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-09#section-3.2
+  // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#section-3.1
   static final class Reader {
 
     private final List<Header> headerList = new ArrayList<>();
     private final BufferedSource source;
 
-    private int maxHeaderTableByteCountSetting;
-    private int maxHeaderTableByteCount;
+    private int headerTableSizeSetting;
+    private int maxDynamicTableByteCount;
     // Visible for testing.
-    Header[] headerTable = new Header[8];
+    Header[] dynamicTable = new Header[8];
     // Array is populated back to front, so new entries always have lowest index.
-    int nextHeaderIndex = headerTable.length - 1;
+    int nextHeaderIndex = dynamicTable.length - 1;
     int headerCount = 0;
-    int headerTableByteCount = 0;
+    int dynamicTableByteCount = 0;
 
-    Reader(int maxHeaderTableByteCountSetting, Source source) {
-      this.maxHeaderTableByteCountSetting = maxHeaderTableByteCountSetting;
-      this.maxHeaderTableByteCount = maxHeaderTableByteCountSetting;
+    Reader(int headerTableSizeSetting, Source source) {
+      this.headerTableSizeSetting = headerTableSizeSetting;
+      this.maxDynamicTableByteCount = headerTableSizeSetting;
       this.source = Okio.buffer(source);
     }
 
-    int maxHeaderTableByteCount() {
-      return maxHeaderTableByteCount;
+    int maxDynamicTableByteCount() {
+      return maxDynamicTableByteCount;
     }
 
     /**
-     * Called by the reader when the peer sent a new header table size setting.
-     * While this establishes the maximum header table size, the
-     * {@link #maxHeaderTableByteCount} set during processing may limit the
+     * Called by the reader when the peer sent {@link Settings#HEADER_TABLE_SIZE}.
+     * While this establishes the maximum dynamic table size, the
+     * {@link #maxDynamicTableByteCount} set during processing may limit the
      * table size to a smaller amount.
      * <p> Evicts entries or clears the table as needed.
      */
-    void maxHeaderTableByteCountSetting(int newMaxHeaderTableByteCountSetting) {
-      this.maxHeaderTableByteCountSetting = newMaxHeaderTableByteCountSetting;
-      this.maxHeaderTableByteCount = maxHeaderTableByteCountSetting;
-      adjustHeaderTableByteCount();
+    void headerTableSizeSetting(int headerTableSizeSetting) {
+      this.headerTableSizeSetting = headerTableSizeSetting;
+      this.maxDynamicTableByteCount = headerTableSizeSetting;
+      adjustDynamicTableByteCount();
     }
 
-    private void adjustHeaderTableByteCount() {
-      if (maxHeaderTableByteCount < headerTableByteCount) {
-        if (maxHeaderTableByteCount == 0) {
-          clearHeaderTable();
+    private void adjustDynamicTableByteCount() {
+      if (maxDynamicTableByteCount < dynamicTableByteCount) {
+        if (maxDynamicTableByteCount == 0) {
+          clearDynamicTable();
         } else {
-          evictToRecoverBytes(headerTableByteCount - maxHeaderTableByteCount);
+          evictToRecoverBytes(dynamicTableByteCount - maxDynamicTableByteCount);
         }
       }
     }
 
-    private void clearHeaderTable() {
+    private void clearDynamicTable() {
       headerList.clear();
-      Arrays.fill(headerTable, null);
-      nextHeaderIndex = headerTable.length - 1;
+      Arrays.fill(dynamicTable, null);
+      nextHeaderIndex = dynamicTable.length - 1;
       headerCount = 0;
-      headerTableByteCount = 0;
+      dynamicTableByteCount = 0;
     }
 
     /** Returns the count of entries evicted. */
@@ -171,13 +171,13 @@ private int evictToRecoverBytes(int bytesToRecover) {
       int entriesToEvict = 0;
       if (bytesToRecover > 0) {
         // determine how many headers need to be evicted.
-        for (int j = headerTable.length - 1; j >= nextHeaderIndex && bytesToRecover > 0; j--) {
-          bytesToRecover -= headerTable[j].hpackSize;
-          headerTableByteCount -= headerTable[j].hpackSize;
+        for (int j = dynamicTable.length - 1; j >= nextHeaderIndex && bytesToRecover > 0; j--) {
+          bytesToRecover -= dynamicTable[j].hpackSize;
+          dynamicTableByteCount -= dynamicTable[j].hpackSize;
           headerCount--;
           entriesToEvict++;
         }
-        System.arraycopy(headerTable, nextHeaderIndex + 1, headerTable,
+        System.arraycopy(dynamicTable, nextHeaderIndex + 1, dynamicTable,
             nextHeaderIndex + 1 + entriesToEvict, headerCount);
         nextHeaderIndex += entriesToEvict;
       }
@@ -202,12 +202,12 @@ void readHeaders() throws IOException {
           int index = readInt(b, PREFIX_6_BITS);
           readLiteralHeaderWithIncrementalIndexingIndexedName(index - 1);
         } else if ((b & 0x20) == 0x20) {  // 001NNNNN
-          maxHeaderTableByteCount = readInt(b, PREFIX_5_BITS);
-          if (maxHeaderTableByteCount < 0
-              || maxHeaderTableByteCount > maxHeaderTableByteCountSetting) {
-            throw new IOException("Invalid header table byte count " + maxHeaderTableByteCount);
+          maxDynamicTableByteCount = readInt(b, PREFIX_5_BITS);
+          if (maxDynamicTableByteCount < 0
+              || maxDynamicTableByteCount > headerTableSizeSetting) {
+            throw new IOException("Invalid dynamic table size update " + maxDynamicTableByteCount);
           }
-          adjustHeaderTableByteCount();
+          adjustDynamicTableByteCount();
         } else if (b == 0x10 || b == 0) { // 000?0000 - Ignore never indexed bit.
           readLiteralHeaderWithoutIndexingNewName();
         } else { // 000?NNNN - Ignore never indexed bit.
@@ -228,16 +228,16 @@ private void readIndexedHeader(int index) throws IOException {
         Header staticEntry = STATIC_HEADER_TABLE[index];
         headerList.add(staticEntry);
       } else {
-        int headerTableIndex = headerTableIndex(index - STATIC_HEADER_TABLE.length);
-        if (headerTableIndex < 0 || headerTableIndex > headerTable.length - 1) {
+        int dynamicTableIndex = dynamicTableIndex(index - STATIC_HEADER_TABLE.length);
+        if (dynamicTableIndex < 0 || dynamicTableIndex > dynamicTable.length - 1) {
           throw new IOException("Header index too large " + (index + 1));
         }
-        headerList.add(headerTable[headerTableIndex]);
+        headerList.add(dynamicTable[dynamicTableIndex]);
       }
     }
 
     // referencedHeaders is relative to nextHeaderIndex + 1.
-    private int headerTableIndex(int index) {
+    private int dynamicTableIndex(int index) {
       return nextHeaderIndex + 1 + index;
     }
 
@@ -257,20 +257,20 @@ private void readLiteralHeaderWithIncrementalIndexingIndexedName(int nameIndex)
         throws IOException {
       ByteString name = getName(nameIndex);
       ByteString value = readByteString();
-      insertIntoHeaderTable(-1, new Header(name, value));
+      insertIntoDynamicTable(-1, new Header(name, value));
     }
 
     private void readLiteralHeaderWithIncrementalIndexingNewName() throws IOException {
       ByteString name = checkLowercase(readByteString());
       ByteString value = readByteString();
-      insertIntoHeaderTable(-1, new Header(name, value));
+      insertIntoDynamicTable(-1, new Header(name, value));
     }
 
     private ByteString getName(int index) {
       if (isStaticHeader(index)) {
         return STATIC_HEADER_TABLE[index].name;
       } else {
-        return headerTable[headerTableIndex(index - STATIC_HEADER_TABLE.length)].name;
+        return dynamicTable[dynamicTableIndex(index - STATIC_HEADER_TABLE.length)].name;
       }
     }
 
@@ -279,39 +279,39 @@ private boolean isStaticHeader(int index) {
     }
 
     /** index == -1 when new. */
-    private void insertIntoHeaderTable(int index, Header entry) {
+    private void insertIntoDynamicTable(int index, Header entry) {
       headerList.add(entry);
 
       int delta = entry.hpackSize;
       if (index != -1) { // Index -1 == new header.
-        delta -= headerTable[headerTableIndex(index)].hpackSize;
+        delta -= dynamicTable[dynamicTableIndex(index)].hpackSize;
       }
 
       // if the new or replacement header is too big, drop all entries.
-      if (delta > maxHeaderTableByteCount) {
-        clearHeaderTable();
+      if (delta > maxDynamicTableByteCount) {
+        clearDynamicTable();
         return;
       }
 
       // Evict headers to the required length.
-      int bytesToRecover = (headerTableByteCount + delta) - maxHeaderTableByteCount;
+      int bytesToRecover = (dynamicTableByteCount + delta) - maxDynamicTableByteCount;
       int entriesEvicted = evictToRecoverBytes(bytesToRecover);
 
-      if (index == -1) { // Adding a value to the header table.
-        if (headerCount + 1 > headerTable.length) { // Need to grow the header table.
-          Header[] doubled = new Header[headerTable.length * 2];
-          System.arraycopy(headerTable, 0, doubled, headerTable.length, headerTable.length);
-          nextHeaderIndex = headerTable.length - 1;
-          headerTable = doubled;
+      if (index == -1) { // Adding a value to the dynamic table.
+        if (headerCount + 1 > dynamicTable.length) { // Need to grow the dynamic table.
+          Header[] doubled = new Header[dynamicTable.length * 2];
+          System.arraycopy(dynamicTable, 0, doubled, dynamicTable.length, dynamicTable.length);
+          nextHeaderIndex = dynamicTable.length - 1;
+          dynamicTable = doubled;
         }
         index = nextHeaderIndex--;
-        headerTable[index] = entry;
+        dynamicTable[index] = entry;
         headerCount++;
       } else { // Replace value at same position.
-        index += headerTableIndex(index) + entriesEvicted;
-        headerTable[index] = entry;
+        index += dynamicTableIndex(index) + entriesEvicted;
+        dynamicTable[index] = entry;
       }
-      headerTableByteCount += delta;
+      dynamicTableByteCount += delta;
     }
 
     private int readByte() throws IOException {
@@ -374,7 +374,7 @@ ByteString readByteString() throws IOException {
     }
 
     /** This does not use "never indexed" semantics for sensitive headers. */
-    // https://tools.ietf.org/html/draft-ietf-httpbis-header-compression-09#section-4.3.3
+    // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#section-6.2.3
     void writeHeaders(List<Header> headerBlock) throws IOException {
       // TODO: implement index tracking
       for (int i = 0, size = headerBlock.size(); i < size; i++) {
@@ -392,7 +392,7 @@ void writeHeaders(List<Header> headerBlock) throws IOException {
       }
     }
 
-    // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-09#section-4.1.1
+    // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#section-4.1.1
     void writeInt(int value, int prefixMask, int bits) throws IOException {
       // Write the raw value for a single byte value.
       if (value < prefixMask) {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Http2.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Http2.java
new file mode 100644
index 0000000000..b0de82610d
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Http2.java
@@ -0,0 +1,810 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.spdy;
+
+import com.squareup.okhttp.Protocol;
+
+import java.io.IOException;
+import java.util.List;
+import java.util.Locale;
+import java.util.logging.Logger;
+
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.ByteString;
+import okio.Source;
+import okio.Timeout;
+
+import static com.squareup.okhttp.internal.spdy.Http2.FrameLogger.formatHeader;
+import static java.lang.String.format;
+import static java.util.logging.Level.FINE;
+import static okio.ByteString.EMPTY;
+
+/**
+ * Read and write HTTP/2 frames.
+ * <p/>
+ * This implementation assumes we do not send an increased
+ * {@link Settings#getMaxFrameSize frame size setting} to the peer. Hence, we
+ * expect all frames to have a max length of {@link #INITIAL_MAX_FRAME_SIZE}.
+ * <p>http://tools.ietf.org/html/draft-ietf-httpbis-http2-17
+ */
+public final class Http2 implements Variant {
+    private static final Logger logger = Logger.getLogger(FrameLogger.class.getName());
+
+    @Override
+    public Protocol getProtocol() {
+        return Protocol.HTTP_2;
+    }
+
+    private static final ByteString CONNECTION_PREFACE
+            = ByteString.encodeUtf8("PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n");
+
+    /**
+     * The initial max frame size, applied independently writing to, or reading from the peer.
+     */
+    static final int INITIAL_MAX_FRAME_SIZE = 0x4000; // 16384
+
+    static final byte TYPE_DATA = 0x0;
+    static final byte TYPE_HEADERS = 0x1;
+    static final byte TYPE_PRIORITY = 0x2;
+    static final byte TYPE_RST_STREAM = 0x3;
+    static final byte TYPE_SETTINGS = 0x4;
+    static final byte TYPE_PUSH_PROMISE = 0x5;
+    static final byte TYPE_PING = 0x6;
+    static final byte TYPE_GOAWAY = 0x7;
+    static final byte TYPE_WINDOW_UPDATE = 0x8;
+    static final byte TYPE_CONTINUATION = 0x9;
+
+    static final byte FLAG_NONE = 0x0;
+    static final byte FLAG_ACK = 0x1; // Used for settings and ping.
+    static final byte FLAG_END_STREAM = 0x1; // Used for headers and data.
+    static final byte FLAG_END_HEADERS = 0x4; // Used for headers and continuation.
+    static final byte FLAG_END_PUSH_PROMISE = 0x4;
+    static final byte FLAG_PADDED = 0x8; // Used for headers and data.
+    static final byte FLAG_PRIORITY = 0x20; // Used for headers.
+    static final byte FLAG_COMPRESSED = 0x20; // Used for data.
+
+    /**
+     * Creates a frame reader with max header table size of 4096 and data frame
+     * compression disabled.
+     */
+    @Override
+    public FrameReader newReader(BufferedSource source, boolean client) {
+        return new Reader(source, 4096, client);
+    }
+
+    @Override
+    public FrameWriter newWriter(BufferedSink sink, boolean client) {
+        return new Writer(sink, client);
+    }
+
+    static final class Reader implements FrameReader {
+        private final BufferedSource source;
+        private final ContinuationSource continuation;
+        private final boolean client;
+
+        // Visible for testing.
+        final Hpack.Reader hpackReader;
+
+        Reader(BufferedSource source, int headerTableSize, boolean client) {
+            this.source = source;
+            this.client = client;
+            this.continuation = new ContinuationSource(this.source);
+            this.hpackReader = new Hpack.Reader(headerTableSize, continuation);
+        }
+
+        @Override
+        public void readConnectionPreface() throws IOException {
+            if (client) return; // Nothing to read; servers doesn't send a connection preface!
+            ByteString connectionPreface = source.readByteString(CONNECTION_PREFACE.size());
+            if (logger.isLoggable(FINE))
+                logger.fine(format("<< CONNECTION %s", connectionPreface.hex()));
+            if (!CONNECTION_PREFACE.equals(connectionPreface)) {
+                throw ioException("Expected a connection header but was %s", connectionPreface.utf8());
+            }
+        }
+
+        @Override
+        public boolean nextFrame(Handler handler) throws IOException {
+            try {
+                source.require(9); // Frame header size
+            } catch (IOException e) {
+                return false; // This might be a normal socket close.
+            }
+
+      /*  0                   1                   2                   3
+       *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+       * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+       * |                 Length (24)                   |
+       * +---------------+---------------+---------------+
+       * |   Type (8)    |   Flags (8)   |
+       * +-+-+-----------+---------------+-------------------------------+
+       * |R|                 Stream Identifier (31)                      |
+       * +=+=============================================================+
+       * |                   Frame Payload (0...)                      ...
+       * +---------------------------------------------------------------+
+       */
+            int length = readMedium(source);
+            if (length < 0 || length > INITIAL_MAX_FRAME_SIZE) {
+                throw ioException("FRAME_SIZE_ERROR: %s", length);
+            }
+            byte type = (byte) (source.readByte() & 0xff);
+            byte flags = (byte) (source.readByte() & 0xff);
+            int streamId = (source.readInt() & 0x7fffffff); // Ignore reserved bit.
+            if (logger.isLoggable(FINE))
+                logger.fine(formatHeader(true, streamId, length, type, flags));
+
+            switch (type) {
+                case TYPE_DATA:
+                    readData(handler, length, flags, streamId);
+                    break;
+
+                case TYPE_HEADERS:
+                    readHeaders(handler, length, flags, streamId);
+                    break;
+
+                case TYPE_PRIORITY:
+                    readPriority(handler, length, flags, streamId);
+                    break;
+
+                case TYPE_RST_STREAM:
+                    readRstStream(handler, length, flags, streamId);
+                    break;
+
+                case TYPE_SETTINGS:
+                    readSettings(handler, length, flags, streamId);
+                    break;
+
+                case TYPE_PUSH_PROMISE:
+                    readPushPromise(handler, length, flags, streamId);
+                    break;
+
+                case TYPE_PING:
+                    readPing(handler, length, flags, streamId);
+                    break;
+
+                case TYPE_GOAWAY:
+                    readGoAway(handler, length, flags, streamId);
+                    break;
+
+                case TYPE_WINDOW_UPDATE:
+                    readWindowUpdate(handler, length, flags, streamId);
+                    break;
+
+                default:
+                    // Implementations MUST discard frames that have unknown or unsupported types.
+                    source.skip(length);
+            }
+            return true;
+        }
+
+        private void readHeaders(Handler handler, int length, byte flags, int streamId)
+                throws IOException {
+            if (streamId == 0) throw ioException("PROTOCOL_ERROR: TYPE_HEADERS streamId == 0");
+
+            boolean endStream = (flags & FLAG_END_STREAM) != 0;
+
+            short padding = (flags & FLAG_PADDED) != 0 ? (short) (source.readByte() & 0xff) : 0;
+
+            if ((flags & FLAG_PRIORITY) != 0) {
+                readPriority(handler, streamId);
+                length -= 5; // account for above read.
+            }
+
+            length = lengthWithoutPadding(length, flags, padding);
+
+            List<Header> headerBlock = readHeaderBlock(length, padding, flags, streamId);
+
+            handler.headers(false, endStream, streamId, -1, headerBlock, HeadersMode.HTTP_20_HEADERS);
+        }
+
+        private List<Header> readHeaderBlock(int length, short padding, byte flags, int streamId)
+                throws IOException {
+            continuation.length = continuation.left = length;
+            continuation.padding = padding;
+            continuation.flags = flags;
+            continuation.streamId = streamId;
+
+            // TODO: Concat multi-value headers with 0x0, except COOKIE, which uses 0x3B, 0x20.
+            // http://tools.ietf.org/html/draft-ietf-httpbis-http2-17#section-8.1.2.5
+            hpackReader.readHeaders();
+            return hpackReader.getAndResetHeaderList();
+        }
+
+        private void readData(Handler handler, int length, byte flags, int streamId)
+                throws IOException {
+            // TODO: checkState open or half-closed (local) or raise STREAM_CLOSED
+            boolean inFinished = (flags & FLAG_END_STREAM) != 0;
+            boolean gzipped = (flags & FLAG_COMPRESSED) != 0;
+            if (gzipped) {
+                throw ioException("PROTOCOL_ERROR: FLAG_COMPRESSED without SETTINGS_COMPRESS_DATA");
+            }
+
+            short padding = (flags & FLAG_PADDED) != 0 ? (short) (source.readByte() & 0xff) : 0;
+            length = lengthWithoutPadding(length, flags, padding);
+
+            handler.data(inFinished, streamId, source, length);
+            source.skip(padding);
+        }
+
+        private void readPriority(Handler handler, int length, byte flags, int streamId)
+                throws IOException {
+            if (length != 5) throw ioException("TYPE_PRIORITY length: %d != 5", length);
+            if (streamId == 0) throw ioException("TYPE_PRIORITY streamId == 0");
+            readPriority(handler, streamId);
+        }
+
+        private void readPriority(Handler handler, int streamId) throws IOException {
+            int w1 = source.readInt();
+            boolean exclusive = (w1 & 0x80000000) != 0;
+            int streamDependency = (w1 & 0x7fffffff);
+            int weight = (source.readByte() & 0xff) + 1;
+            handler.priority(streamId, streamDependency, weight, exclusive);
+        }
+
+        private void readRstStream(Handler handler, int length, byte flags, int streamId)
+                throws IOException {
+            if (length != 4) throw ioException("TYPE_RST_STREAM length: %d != 4", length);
+            if (streamId == 0) throw ioException("TYPE_RST_STREAM streamId == 0");
+            int errorCodeInt = source.readInt();
+            ErrorCode errorCode = ErrorCode.fromHttp2(errorCodeInt);
+            if (errorCode == null) {
+                throw ioException("TYPE_RST_STREAM unexpected error code: %d", errorCodeInt);
+            }
+            handler.rstStream(streamId, errorCode);
+        }
+
+        private void readSettings(Handler handler, int length, byte flags, int streamId)
+                throws IOException {
+            if (streamId != 0) throw ioException("TYPE_SETTINGS streamId != 0");
+            if ((flags & FLAG_ACK) != 0) {
+                if (length != 0) throw ioException("FRAME_SIZE_ERROR ack frame should be empty!");
+                handler.ackSettings();
+                return;
+            }
+
+            if (length % 6 != 0) throw ioException("TYPE_SETTINGS length %% 6 != 0: %s", length);
+            Settings settings = new Settings();
+            for (int i = 0; i < length; i += 6) {
+                short id = source.readShort();
+                int value = source.readInt();
+
+                switch (id) {
+                    case 1: // SETTINGS_HEADER_TABLE_SIZE
+                        break;
+                    case 2: // SETTINGS_ENABLE_PUSH
+                        if (value != 0 && value != 1) {
+                            throw ioException("PROTOCOL_ERROR SETTINGS_ENABLE_PUSH != 0 or 1");
+                        }
+                        break;
+                    case 3: // SETTINGS_MAX_CONCURRENT_STREAMS
+                        id = 4; // Renumbered in draft 10.
+                        break;
+                    case 4: // SETTINGS_INITIAL_WINDOW_SIZE
+                        id = 7; // Renumbered in draft 10.
+                        if (value < 0) {
+                            throw ioException("PROTOCOL_ERROR SETTINGS_INITIAL_WINDOW_SIZE > 2^31 - 1");
+                        }
+                        break;
+                    case 5: // SETTINGS_MAX_FRAME_SIZE
+                        if (value < INITIAL_MAX_FRAME_SIZE || value > 16777215) {
+                            throw ioException("PROTOCOL_ERROR SETTINGS_MAX_FRAME_SIZE: %s", value);
+                        }
+                        break;
+                    case 6: // SETTINGS_MAX_HEADER_LIST_SIZE
+                        break; // Advisory only, so ignored.
+                    default:
+                        throw ioException("PROTOCOL_ERROR invalid settings id: %s", id);
+                }
+                settings.set(id, 0, value);
+            }
+            handler.settings(false, settings);
+            if (settings.getHeaderTableSize() >= 0) {
+                hpackReader.headerTableSizeSetting(settings.getHeaderTableSize());
+            }
+        }
+
+        private void readPushPromise(Handler handler, int length, byte flags, int streamId)
+                throws IOException {
+            if (streamId == 0) {
+                throw ioException("PROTOCOL_ERROR: TYPE_PUSH_PROMISE streamId == 0");
+            }
+            short padding = (flags & FLAG_PADDED) != 0 ? (short) (source.readByte() & 0xff) : 0;
+            int promisedStreamId = source.readInt() & 0x7fffffff;
+            length -= 4; // account for above read.
+            length = lengthWithoutPadding(length, flags, padding);
+            List<Header> headerBlock = readHeaderBlock(length, padding, flags, streamId);
+            handler.pushPromise(streamId, promisedStreamId, headerBlock);
+        }
+
+        private void readPing(Handler handler, int length, byte flags, int streamId)
+                throws IOException {
+            if (length != 8) throw ioException("TYPE_PING length != 8: %s", length);
+            if (streamId != 0) throw ioException("TYPE_PING streamId != 0");
+            int payload1 = source.readInt();
+            int payload2 = source.readInt();
+            boolean ack = (flags & FLAG_ACK) != 0;
+            handler.ping(ack, payload1, payload2);
+        }
+
+        private void readGoAway(Handler handler, int length, byte flags, int streamId)
+                throws IOException {
+            if (length < 8) throw ioException("TYPE_GOAWAY length < 8: %s", length);
+            if (streamId != 0) throw ioException("TYPE_GOAWAY streamId != 0");
+            int lastStreamId = source.readInt();
+            int errorCodeInt = source.readInt();
+            int opaqueDataLength = length - 8;
+            ErrorCode errorCode = ErrorCode.fromHttp2(errorCodeInt);
+            if (errorCode == null) {
+                throw ioException("TYPE_GOAWAY unexpected error code: %d", errorCodeInt);
+            }
+            ByteString debugData = EMPTY;
+            if (opaqueDataLength > 0) { // Must read debug data in order to not corrupt the connection.
+                debugData = source.readByteString(opaqueDataLength);
+            }
+            handler.goAway(lastStreamId, errorCode, debugData);
+        }
+
+        private void readWindowUpdate(Handler handler, int length, byte flags, int streamId)
+                throws IOException {
+            if (length != 4) throw ioException("TYPE_WINDOW_UPDATE length !=4: %s", length);
+            long increment = (source.readInt() & 0x7fffffffL);
+            if (increment == 0) throw ioException("windowSizeIncrement was 0", increment);
+            handler.windowUpdate(streamId, increment);
+        }
+
+        @Override
+        public void close() throws IOException {
+            source.close();
+        }
+    }
+
+    static final class Writer implements FrameWriter {
+        private final BufferedSink sink;
+        private final boolean client;
+        private final Buffer hpackBuffer;
+        private final Hpack.Writer hpackWriter;
+        private int maxFrameSize;
+        private boolean closed;
+
+        Writer(BufferedSink sink, boolean client) {
+            this.sink = sink;
+            this.client = client;
+            this.hpackBuffer = new Buffer();
+            this.hpackWriter = new Hpack.Writer(hpackBuffer);
+            this.maxFrameSize = INITIAL_MAX_FRAME_SIZE;
+        }
+
+        @Override
+        public synchronized void flush() throws IOException {
+            if (closed) throw new IOException("closed");
+            sink.flush();
+        }
+
+        @Override
+        public synchronized void ackSettings(Settings peerSettings) throws IOException {
+            if (closed) throw new IOException("closed");
+            this.maxFrameSize = peerSettings.getMaxFrameSize(maxFrameSize);
+            int length = 0;
+            byte type = TYPE_SETTINGS;
+            byte flags = FLAG_ACK;
+            int streamId = 0;
+            frameHeader(streamId, length, type, flags);
+            sink.flush();
+        }
+
+        @Override
+        public synchronized void connectionPreface() throws IOException {
+            if (closed) throw new IOException("closed");
+            if (!client) return; // Nothing to write; servers don't send connection headers!
+            if (logger.isLoggable(FINE)) {
+                logger.fine(format(">> CONNECTION %s", CONNECTION_PREFACE.hex()));
+            }
+            sink.write(CONNECTION_PREFACE.toByteArray());
+            sink.flush();
+        }
+
+        @Override
+        public synchronized void synStream(boolean outFinished, boolean inFinished,
+                                           int streamId, int associatedStreamId, List<Header> headerBlock)
+                throws IOException {
+            if (inFinished) throw new UnsupportedOperationException();
+            if (closed) throw new IOException("closed");
+            headers(outFinished, streamId, headerBlock);
+        }
+
+        @Override
+        public synchronized void synReply(boolean outFinished, int streamId,
+                                          List<Header> headerBlock) throws IOException {
+            if (closed) throw new IOException("closed");
+            headers(outFinished, streamId, headerBlock);
+        }
+
+        @Override
+        public synchronized void headers(int streamId, List<Header> headerBlock)
+                throws IOException {
+            if (closed) throw new IOException("closed");
+            headers(false, streamId, headerBlock);
+        }
+
+        @Override
+        public synchronized void pushPromise(int streamId, int promisedStreamId,
+                                             List<Header> requestHeaders) throws IOException {
+            if (closed) throw new IOException("closed");
+            if (hpackBuffer.size() != 0) throw new IllegalStateException();
+            hpackWriter.writeHeaders(requestHeaders);
+
+            long byteCount = hpackBuffer.size();
+            int length = (int) Math.min(maxFrameSize - 4, byteCount);
+            byte type = TYPE_PUSH_PROMISE;
+            byte flags = byteCount == length ? FLAG_END_HEADERS : 0;
+            frameHeader(streamId, length + 4, type, flags);
+            sink.writeInt(promisedStreamId & 0x7fffffff);
+            sink.write(hpackBuffer, length);
+
+            if (byteCount > length) writeContinuationFrames(streamId, byteCount - length);
+        }
+
+        void headers(boolean outFinished, int streamId, List<Header> headerBlock) throws IOException {
+            if (closed) throw new IOException("closed");
+            if (hpackBuffer.size() != 0) throw new IllegalStateException();
+            hpackWriter.writeHeaders(headerBlock);
+
+            long byteCount = hpackBuffer.size();
+            int length = (int) Math.min(maxFrameSize, byteCount);
+            byte type = TYPE_HEADERS;
+            byte flags = byteCount == length ? FLAG_END_HEADERS : 0;
+            if (outFinished) flags |= FLAG_END_STREAM;
+            frameHeader(streamId, length, type, flags);
+            sink.write(hpackBuffer, length);
+
+            if (byteCount > length) writeContinuationFrames(streamId, byteCount - length);
+        }
+
+        private void writeContinuationFrames(int streamId, long byteCount) throws IOException {
+            while (byteCount > 0) {
+                int length = (int) Math.min(maxFrameSize, byteCount);
+                byteCount -= length;
+                frameHeader(streamId, length, TYPE_CONTINUATION, byteCount == 0 ? FLAG_END_HEADERS : 0);
+                sink.write(hpackBuffer, length);
+            }
+        }
+
+        @Override
+        public synchronized void rstStream(int streamId, ErrorCode errorCode)
+                throws IOException {
+            if (closed) throw new IOException("closed");
+            if (errorCode.spdyRstCode == -1) throw new IllegalArgumentException();
+
+            int length = 4;
+            byte type = TYPE_RST_STREAM;
+            byte flags = FLAG_NONE;
+            frameHeader(streamId, length, type, flags);
+            sink.writeInt(errorCode.httpCode);
+            sink.flush();
+        }
+
+        @Override
+        public int maxDataLength() {
+            return maxFrameSize;
+        }
+
+        @Override
+        public synchronized void data(boolean outFinished, int streamId, Buffer source,
+                                      int byteCount) throws IOException {
+            if (closed) throw new IOException("closed");
+            byte flags = FLAG_NONE;
+            if (outFinished) flags |= FLAG_END_STREAM;
+            dataFrame(streamId, flags, source, byteCount);
+        }
+
+        void dataFrame(int streamId, byte flags, Buffer buffer, int byteCount) throws IOException {
+            byte type = TYPE_DATA;
+            frameHeader(streamId, byteCount, type, flags);
+            if (byteCount > 0) {
+                sink.write(buffer, byteCount);
+            }
+        }
+
+        @Override
+        public synchronized void settings(Settings settings) throws IOException {
+            if (closed) throw new IOException("closed");
+            int length = settings.size() * 6;
+            byte type = TYPE_SETTINGS;
+            byte flags = FLAG_NONE;
+            int streamId = 0;
+            frameHeader(streamId, length, type, flags);
+            for (int i = 0; i < Settings.COUNT; i++) {
+                if (!settings.isSet(i)) continue;
+                int id = i;
+                if (id == 4) id = 3; // SETTINGS_MAX_CONCURRENT_STREAMS renumbered.
+                else if (id == 7) id = 4; // SETTINGS_INITIAL_WINDOW_SIZE renumbered.
+                sink.writeShort(id);
+                sink.writeInt(settings.get(i));
+            }
+            sink.flush();
+        }
+
+        @Override
+        public synchronized void ping(boolean ack, int payload1, int payload2)
+                throws IOException {
+            if (closed) throw new IOException("closed");
+            int length = 8;
+            byte type = TYPE_PING;
+            byte flags = ack ? FLAG_ACK : FLAG_NONE;
+            int streamId = 0;
+            frameHeader(streamId, length, type, flags);
+            sink.writeInt(payload1);
+            sink.writeInt(payload2);
+            sink.flush();
+        }
+
+        @Override
+        public synchronized void goAway(int lastGoodStreamId, ErrorCode errorCode,
+                                        byte[] debugData) throws IOException {
+            if (closed) throw new IOException("closed");
+            if (errorCode.httpCode == -1) throw illegalArgument("errorCode.httpCode == -1");
+            int length = 8 + debugData.length;
+            byte type = TYPE_GOAWAY;
+            byte flags = FLAG_NONE;
+            int streamId = 0;
+            frameHeader(streamId, length, type, flags);
+            sink.writeInt(lastGoodStreamId);
+            sink.writeInt(errorCode.httpCode);
+            if (debugData.length > 0) {
+                sink.write(debugData);
+            }
+            sink.flush();
+        }
+
+        @Override
+        public synchronized void windowUpdate(int streamId, long windowSizeIncrement)
+                throws IOException {
+            if (closed) throw new IOException("closed");
+            if (windowSizeIncrement == 0 || windowSizeIncrement > 0x7fffffffL) {
+                throw illegalArgument("windowSizeIncrement == 0 || windowSizeIncrement > 0x7fffffffL: %s",
+                        windowSizeIncrement);
+            }
+            int length = 4;
+            byte type = TYPE_WINDOW_UPDATE;
+            byte flags = FLAG_NONE;
+            frameHeader(streamId, length, type, flags);
+            sink.writeInt((int) windowSizeIncrement);
+            sink.flush();
+        }
+
+        @Override
+        public synchronized void close() throws IOException {
+            closed = true;
+            sink.close();
+        }
+
+        void frameHeader(int streamId, int length, byte type, byte flags) throws IOException {
+            if (logger.isLoggable(FINE))
+                logger.fine(formatHeader(false, streamId, length, type, flags));
+            if (length > maxFrameSize) {
+                throw illegalArgument("FRAME_SIZE_ERROR length > %d: %d", maxFrameSize, length);
+            }
+            if ((streamId & 0x80000000) != 0)
+                throw illegalArgument("reserved bit set: %s", streamId);
+            writeMedium(sink, length);
+            sink.writeByte(type & 0xff);
+            sink.writeByte(flags & 0xff);
+            sink.writeInt(streamId & 0x7fffffff);
+        }
+    }
+
+    private static IllegalArgumentException illegalArgument(String message, Object... args) {
+        throw new IllegalArgumentException(format(message, args));
+    }
+
+    private static IOException ioException(String message, Object... args) throws IOException {
+        throw new IOException(format(message, args));
+    }
+
+    /**
+     * Decompression of the header block occurs above the framing layer. This
+     * class lazily reads continuation frames as they are needed by {@link
+     * Hpack.Reader#readHeaders()}.
+     */
+    static final class ContinuationSource implements Source {
+        private final BufferedSource source;
+
+        int length;
+        byte flags;
+        int streamId;
+
+        int left;
+        short padding;
+
+        public ContinuationSource(BufferedSource source) {
+            this.source = source;
+        }
+
+        @Override
+        public long read(Buffer sink, long byteCount) throws IOException {
+            while (left == 0) {
+                source.skip(padding);
+                padding = 0;
+                if ((flags & FLAG_END_HEADERS) != 0) return -1;
+                readContinuationHeader();
+                // TODO: test case for empty continuation header?
+            }
+
+            long read = source.read(sink, Math.min(byteCount, left));
+            if (read == -1) return -1;
+            left -= read;
+            return read;
+        }
+
+        @Override
+        public Timeout timeout() {
+            return source.timeout();
+        }
+
+        @Override
+        public void close() throws IOException {
+        }
+
+        private void readContinuationHeader() throws IOException {
+            int previousStreamId = streamId;
+
+            length = left = readMedium(source);
+            byte type = (byte) (source.readByte() & 0xff);
+            flags = (byte) (source.readByte() & 0xff);
+            if (logger.isLoggable(FINE))
+                logger.fine(formatHeader(true, streamId, length, type, flags));
+            streamId = (source.readInt() & 0x7fffffff);
+            if (type != TYPE_CONTINUATION) throw ioException("%s != TYPE_CONTINUATION", type);
+            if (streamId != previousStreamId)
+                throw ioException("TYPE_CONTINUATION streamId changed");
+        }
+    }
+
+    private static int lengthWithoutPadding(int length, byte flags, short padding)
+            throws IOException {
+        if ((flags & FLAG_PADDED) != 0) length--; // Account for reading the padding length.
+        if (padding > length) {
+            throw ioException("PROTOCOL_ERROR padding %s > remaining length %s", padding, length);
+        }
+        return (short) (length - padding);
+    }
+
+    /**
+     * Logs a human-readable representation of HTTP/2 frame headers.
+     * <p/>
+     * <p>The format is:
+     * <p/>
+     * <pre>
+     *   direction streamID length type flags
+     * </pre>
+     * Where direction is {@code <<} for inbound and {@code >>} for outbound.
+     * <p/>
+     * <p> For example, the following would indicate a HEAD request sent from
+     * the client.
+     * <pre>
+     * {@code
+     *   << 0x0000000f    12 HEADERS       END_HEADERS|END_STREAM
+     * }
+     * </pre>
+     */
+    static final class FrameLogger {
+
+        static String formatHeader(boolean inbound, int streamId, int length, byte type, byte flags) {
+            String formattedType = type < TYPES.length ? TYPES[type] : format("0x%02x", type);
+            String formattedFlags = formatFlags(type, flags);
+            return format(Locale.ENGLISH, "%s 0x%08x %5d %-13s %s", inbound ? "<<" : ">>", streamId, length,
+                    formattedType, formattedFlags);
+        }
+
+        /**
+         * Looks up valid string representing flags from the table. Invalid
+         * combinations are represented in binary.
+         */
+        // Visible for testing.
+        static String formatFlags(byte type, byte flags) {
+            if (flags == 0) return "";
+            switch (type) { // Special case types that have 0 or 1 flag.
+                case TYPE_SETTINGS:
+                case TYPE_PING:
+                    return flags == FLAG_ACK ? "ACK" : BINARY[flags];
+                case TYPE_PRIORITY:
+                case TYPE_RST_STREAM:
+                case TYPE_GOAWAY:
+                case TYPE_WINDOW_UPDATE:
+                    return BINARY[flags];
+            }
+            String result = flags < FLAGS.length ? FLAGS[flags] : BINARY[flags];
+            // Special case types that have overlap flag values.
+            if (type == TYPE_PUSH_PROMISE && (flags & FLAG_END_PUSH_PROMISE) != 0) {
+                return result.replace("HEADERS", "PUSH_PROMISE"); // TODO: Avoid allocation.
+            } else if (type == TYPE_DATA && (flags & FLAG_COMPRESSED) != 0) {
+                return result.replace("PRIORITY", "COMPRESSED"); // TODO: Avoid allocation.
+            }
+            return result;
+        }
+
+        /**
+         * Lookup table for valid frame types.
+         */
+        private static final String[] TYPES = new String[]{
+                "DATA",
+                "HEADERS",
+                "PRIORITY",
+                "RST_STREAM",
+                "SETTINGS",
+                "PUSH_PROMISE",
+                "PING",
+                "GOAWAY",
+                "WINDOW_UPDATE",
+                "CONTINUATION"
+        };
+
+        /**
+         * Lookup table for valid flags for DATA, HEADERS, CONTINUATION. Invalid
+         * combinations are represented in binary.
+         */
+        private static final String[] FLAGS = new String[0x40]; // Highest bit flag is 0x20.
+        private static final String[] BINARY = new String[256];
+
+        static {
+            for (int i = 0; i < BINARY.length; i++) {
+                BINARY[i] = format("%8s", Integer.toBinaryString(i)).replace(' ', '0');
+            }
+
+            FLAGS[FLAG_NONE] = "";
+            FLAGS[FLAG_END_STREAM] = "END_STREAM";
+
+            int[] prefixFlags = new int[]{FLAG_END_STREAM};
+
+            FLAGS[FLAG_PADDED] = "PADDED";
+            for (int prefixFlag : prefixFlags) {
+                FLAGS[prefixFlag | FLAG_PADDED] = FLAGS[prefixFlag] + "|PADDED";
+            }
+
+            FLAGS[FLAG_END_HEADERS] = "END_HEADERS"; // Same as END_PUSH_PROMISE.
+            FLAGS[FLAG_PRIORITY] = "PRIORITY"; // Same as FLAG_COMPRESSED.
+            FLAGS[FLAG_END_HEADERS | FLAG_PRIORITY] = "END_HEADERS|PRIORITY"; // Only valid on HEADERS.
+            int[] frameFlags =
+                    new int[]{FLAG_END_HEADERS, FLAG_PRIORITY, FLAG_END_HEADERS | FLAG_PRIORITY};
+
+            for (int frameFlag : frameFlags) {
+                for (int prefixFlag : prefixFlags) {
+                    FLAGS[prefixFlag | frameFlag] = FLAGS[prefixFlag] + '|' + FLAGS[frameFlag];
+                    FLAGS[prefixFlag | frameFlag | FLAG_PADDED] =
+                            FLAGS[prefixFlag] + '|' + FLAGS[frameFlag] + "|PADDED";
+                }
+            }
+
+            for (int i = 0; i < FLAGS.length; i++) { // Fill in holes with binary representation.
+                if (FLAGS[i] == null) FLAGS[i] = BINARY[i];
+            }
+        }
+    }
+
+    private static int readMedium(BufferedSource source) throws IOException {
+        return (source.readByte() & 0xff) << 16
+                | (source.readByte() & 0xff) << 8
+                | (source.readByte() & 0xff);
+    }
+
+    private static void writeMedium(BufferedSink sink, int i) throws IOException {
+        sink.writeByte((i >>> 16) & 0xff);
+        sink.writeByte((i >>> 8) & 0xff);
+        sink.writeByte(i & 0xff);
+    }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft14.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft14.java
deleted file mode 100644
index edbdc333cb..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft14.java
+++ /dev/null
@@ -1,771 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal.spdy;
-
-import com.squareup.okhttp.Protocol;
-import java.io.IOException;
-import java.util.List;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.ByteString;
-import okio.Source;
-import okio.Timeout;
-
-import static com.squareup.okhttp.internal.Internal.logger;
-import static com.squareup.okhttp.internal.spdy.Http20Draft14.FrameLogger.formatHeader;
-import static java.lang.String.format;
-import static java.util.logging.Level.FINE;
-import static okio.ByteString.EMPTY;
-
-/**
- * Read and write HTTP/2 v14 frames.
- * <p>
- * This implementation assumes we do not send an increased
- * {@link Settings#getMaxFrameSize frame size setting} to the peer. Hence, we
- * expect all frames to have a max length of {@link #INITIAL_MAX_FRAME_SIZE}.
- * <p>http://tools.ietf.org/html/draft-ietf-httpbis-http2-14
- */
-public final class Http20Draft14 implements Variant {
-  @Override public Protocol getProtocol() {
-    return Protocol.HTTP_2;
-  }
-
-  private static final ByteString CONNECTION_PREFACE
-      = ByteString.encodeUtf8("PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n");
-
-  /** The initial max frame size, applied independently writing to, or reading from the peer. */
-  static final int INITIAL_MAX_FRAME_SIZE = 0x4000; // 16384
-
-  static final byte TYPE_DATA = 0x0;
-  static final byte TYPE_HEADERS = 0x1;
-  static final byte TYPE_PRIORITY = 0x2;
-  static final byte TYPE_RST_STREAM = 0x3;
-  static final byte TYPE_SETTINGS = 0x4;
-  static final byte TYPE_PUSH_PROMISE = 0x5;
-  static final byte TYPE_PING = 0x6;
-  static final byte TYPE_GOAWAY = 0x7;
-  static final byte TYPE_WINDOW_UPDATE = 0x8;
-  static final byte TYPE_CONTINUATION = 0x9;
-
-  static final byte FLAG_NONE = 0x0;
-  static final byte FLAG_ACK = 0x1; // Used for settings and ping.
-  static final byte FLAG_END_STREAM = 0x1; // Used for headers and data.
-  static final byte FLAG_END_HEADERS = 0x4; // Used for headers and continuation.
-  static final byte FLAG_END_PUSH_PROMISE = 0x4;
-  static final byte FLAG_PADDED = 0x8; // Used for headers and data.
-  static final byte FLAG_PRIORITY = 0x20; // Used for headers.
-  static final byte FLAG_COMPRESSED = 0x20; // Used for data.
-
-  /**
-   * Creates a frame reader with max header table size of 4096 and data frame
-   * compression disabled.
-   */
-  @Override public FrameReader newReader(BufferedSource source, boolean client) {
-    return new Reader(source, 4096, client);
-  }
-
-  @Override public FrameWriter newWriter(BufferedSink sink, boolean client) {
-    return new Writer(sink, client);
-  }
-
-  static final class Reader implements FrameReader {
-    private final BufferedSource source;
-    private final ContinuationSource continuation;
-    private final boolean client;
-
-    // Visible for testing.
-    final HpackDraft09.Reader hpackReader;
-
-    Reader(BufferedSource source, int headerTableSize, boolean client) {
-      this.source = source;
-      this.client = client;
-      this.continuation = new ContinuationSource(this.source);
-      this.hpackReader = new HpackDraft09.Reader(headerTableSize, continuation);
-    }
-
-    @Override public void readConnectionPreface() throws IOException {
-      if (client) return; // Nothing to read; servers doesn't send a connection preface!
-      ByteString connectionPreface = source.readByteString(CONNECTION_PREFACE.size());
-      if (logger.isLoggable(FINE)) logger.fine(format("<< CONNECTION %s", connectionPreface.hex()));
-      if (!CONNECTION_PREFACE.equals(connectionPreface)) {
-        throw ioException("Expected a connection header but was %s", connectionPreface.utf8());
-      }
-    }
-
-    @Override public boolean nextFrame(Handler handler) throws IOException {
-      try {
-        source.require(9); // Frame header size
-      } catch (IOException e) {
-        return false; // This might be a normal socket close.
-      }
-
-      /*  0                   1                   2                   3
-       *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
-       * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-       * |                 Length (24)                   |
-       * +---------------+---------------+---------------+
-       * |   Type (8)    |   Flags (8)   |
-       * +-+-+-----------+---------------+-------------------------------+
-       * |R|                 Stream Identifier (31)                      |
-       * +=+=============================================================+
-       * |                   Frame Payload (0...)                      ...
-       * +---------------------------------------------------------------+
-       */
-      int length = readMedium(source);
-      if (length < 0 || length > INITIAL_MAX_FRAME_SIZE) {
-        throw ioException("FRAME_SIZE_ERROR: %s", length);
-      }
-      byte type = (byte) (source.readByte() & 0xff);
-      byte flags = (byte) (source.readByte() & 0xff);
-      int streamId = (source.readInt() & 0x7fffffff); // Ignore reserved bit.
-      if (logger.isLoggable(FINE)) logger.fine(formatHeader(true, streamId, length, type, flags));
-
-      switch (type) {
-        case TYPE_DATA:
-          readData(handler, length, flags, streamId);
-          break;
-
-        case TYPE_HEADERS:
-          readHeaders(handler, length, flags, streamId);
-          break;
-
-        case TYPE_PRIORITY:
-          readPriority(handler, length, flags, streamId);
-          break;
-
-        case TYPE_RST_STREAM:
-          readRstStream(handler, length, flags, streamId);
-          break;
-
-        case TYPE_SETTINGS:
-          readSettings(handler, length, flags, streamId);
-          break;
-
-        case TYPE_PUSH_PROMISE:
-          readPushPromise(handler, length, flags, streamId);
-          break;
-
-        case TYPE_PING:
-          readPing(handler, length, flags, streamId);
-          break;
-
-        case TYPE_GOAWAY:
-          readGoAway(handler, length, flags, streamId);
-          break;
-
-        case TYPE_WINDOW_UPDATE:
-          readWindowUpdate(handler, length, flags, streamId);
-          break;
-
-        default:
-          // Implementations MUST discard frames that have unknown or unsupported types.
-          source.skip(length);
-      }
-      return true;
-    }
-
-    private void readHeaders(Handler handler, int length, byte flags, int streamId)
-        throws IOException {
-      if (streamId == 0) throw ioException("PROTOCOL_ERROR: TYPE_HEADERS streamId == 0");
-
-      boolean endStream = (flags & FLAG_END_STREAM) != 0;
-
-      short padding = (flags & FLAG_PADDED) != 0 ? (short) (source.readByte() & 0xff) : 0;
-
-      if ((flags & FLAG_PRIORITY) != 0) {
-        readPriority(handler, streamId);
-        length -= 5; // account for above read.
-      }
-
-      length = lengthWithoutPadding(length, flags, padding);
-
-      List<Header> headerBlock = readHeaderBlock(length, padding, flags, streamId);
-
-      handler.headers(false, endStream, streamId, -1, headerBlock, HeadersMode.HTTP_20_HEADERS);
-    }
-
-    private List<Header> readHeaderBlock(int length, short padding, byte flags, int streamId)
-        throws IOException {
-      continuation.length = continuation.left = length;
-      continuation.padding = padding;
-      continuation.flags = flags;
-      continuation.streamId = streamId;
-
-      // TODO: Concat multi-value headers with 0x0, except COOKIE, which uses 0x3B, 0x20.
-      // http://tools.ietf.org/html/draft-ietf-httpbis-http2-14#section-8.1.2.5
-      hpackReader.readHeaders();
-      return hpackReader.getAndResetHeaderList();
-    }
-
-    private void readData(Handler handler, int length, byte flags, int streamId)
-        throws IOException {
-      // TODO: checkState open or half-closed (local) or raise STREAM_CLOSED
-      boolean inFinished = (flags & FLAG_END_STREAM) != 0;
-      boolean gzipped = (flags & FLAG_COMPRESSED) != 0;
-      if (gzipped) {
-        throw ioException("PROTOCOL_ERROR: FLAG_COMPRESSED without SETTINGS_COMPRESS_DATA");
-      }
-
-      short padding = (flags & FLAG_PADDED) != 0 ? (short) (source.readByte() & 0xff) : 0;
-      length = lengthWithoutPadding(length, flags, padding);
-
-      handler.data(inFinished, streamId, source, length);
-      source.skip(padding);
-    }
-
-    private void readPriority(Handler handler, int length, byte flags, int streamId)
-        throws IOException {
-      if (length != 5) throw ioException("TYPE_PRIORITY length: %d != 5", length);
-      if (streamId == 0) throw ioException("TYPE_PRIORITY streamId == 0");
-      readPriority(handler, streamId);
-    }
-
-    private void readPriority(Handler handler, int streamId) throws IOException {
-      int w1 = source.readInt();
-      boolean exclusive = (w1 & 0x80000000) != 0;
-      int streamDependency = (w1 & 0x7fffffff);
-      int weight = (source.readByte() & 0xff) + 1;
-      handler.priority(streamId, streamDependency, weight, exclusive);
-    }
-
-    private void readRstStream(Handler handler, int length, byte flags, int streamId)
-        throws IOException {
-      if (length != 4) throw ioException("TYPE_RST_STREAM length: %d != 4", length);
-      if (streamId == 0) throw ioException("TYPE_RST_STREAM streamId == 0");
-      int errorCodeInt = source.readInt();
-      ErrorCode errorCode = ErrorCode.fromHttp2(errorCodeInt);
-      if (errorCode == null) {
-        throw ioException("TYPE_RST_STREAM unexpected error code: %d", errorCodeInt);
-      }
-      handler.rstStream(streamId, errorCode);
-    }
-
-    private void readSettings(Handler handler, int length, byte flags, int streamId)
-        throws IOException {
-      if (streamId != 0) throw ioException("TYPE_SETTINGS streamId != 0");
-      if ((flags & FLAG_ACK) != 0) {
-        if (length != 0) throw ioException("FRAME_SIZE_ERROR ack frame should be empty!");
-        handler.ackSettings();
-        return;
-      }
-
-      if (length % 6 != 0) throw ioException("TYPE_SETTINGS length %% 6 != 0: %s", length);
-      Settings settings = new Settings();
-      for (int i = 0; i < length; i += 6) {
-        short id = source.readShort();
-        int value = source.readInt();
-
-        switch (id) {
-          case 1: // SETTINGS_HEADER_TABLE_SIZE
-            break;
-          case 2: // SETTINGS_ENABLE_PUSH
-            if (value != 0 && value != 1) {
-              throw ioException("PROTOCOL_ERROR SETTINGS_ENABLE_PUSH != 0 or 1");
-            }
-            break;
-          case 3: // SETTINGS_MAX_CONCURRENT_STREAMS
-            id = 4; // Renumbered in draft 10.
-            break;
-          case 4: // SETTINGS_INITIAL_WINDOW_SIZE
-            id = 7; // Renumbered in draft 10.
-            if (value < 0) {
-              throw ioException("PROTOCOL_ERROR SETTINGS_INITIAL_WINDOW_SIZE > 2^31 - 1");
-            }
-            break;
-          case 5: // SETTINGS_MAX_FRAME_SIZE
-            if (value < INITIAL_MAX_FRAME_SIZE || value > 16777215) {
-              throw ioException("PROTOCOL_ERROR SETTINGS_MAX_FRAME_SIZE: %s", value);
-            }
-            break;
-          case 6: // SETTINGS_MAX_HEADER_LIST_SIZE
-            break; // Advisory only, so ignored.
-          default:
-            throw ioException("PROTOCOL_ERROR invalid settings id: %s", id);
-        }
-        settings.set(id, 0, value);
-      }
-      handler.settings(false, settings);
-      if (settings.getHeaderTableSize() >= 0) {
-        hpackReader.maxHeaderTableByteCountSetting(settings.getHeaderTableSize());
-      }
-    }
-
-    private void readPushPromise(Handler handler, int length, byte flags, int streamId)
-        throws IOException {
-      if (streamId == 0) {
-        throw ioException("PROTOCOL_ERROR: TYPE_PUSH_PROMISE streamId == 0");
-      }
-      short padding = (flags & FLAG_PADDED) != 0 ? (short) (source.readByte() & 0xff) : 0;
-      int promisedStreamId = source.readInt() & 0x7fffffff;
-      length -= 4; // account for above read.
-      length = lengthWithoutPadding(length, flags, padding);
-      List<Header> headerBlock = readHeaderBlock(length, padding, flags, streamId);
-      handler.pushPromise(streamId, promisedStreamId, headerBlock);
-    }
-
-    private void readPing(Handler handler, int length, byte flags, int streamId)
-        throws IOException {
-      if (length != 8) throw ioException("TYPE_PING length != 8: %s", length);
-      if (streamId != 0) throw ioException("TYPE_PING streamId != 0");
-      int payload1 = source.readInt();
-      int payload2 = source.readInt();
-      boolean ack = (flags & FLAG_ACK) != 0;
-      handler.ping(ack, payload1, payload2);
-    }
-
-    private void readGoAway(Handler handler, int length, byte flags, int streamId)
-        throws IOException {
-      if (length < 8) throw ioException("TYPE_GOAWAY length < 8: %s", length);
-      if (streamId != 0) throw ioException("TYPE_GOAWAY streamId != 0");
-      int lastStreamId = source.readInt();
-      int errorCodeInt = source.readInt();
-      int opaqueDataLength = length - 8;
-      ErrorCode errorCode = ErrorCode.fromHttp2(errorCodeInt);
-      if (errorCode == null) {
-        throw ioException("TYPE_GOAWAY unexpected error code: %d", errorCodeInt);
-      }
-      ByteString debugData = EMPTY;
-      if (opaqueDataLength > 0) { // Must read debug data in order to not corrupt the connection.
-        debugData = source.readByteString(opaqueDataLength);
-      }
-      handler.goAway(lastStreamId, errorCode, debugData);
-    }
-
-    private void readWindowUpdate(Handler handler, int length, byte flags, int streamId)
-        throws IOException {
-      if (length != 4) throw ioException("TYPE_WINDOW_UPDATE length !=4: %s", length);
-      long increment = (source.readInt() & 0x7fffffffL);
-      if (increment == 0) throw ioException("windowSizeIncrement was 0", increment);
-      handler.windowUpdate(streamId, increment);
-    }
-
-    @Override public void close() throws IOException {
-      source.close();
-    }
-  }
-
-  static final class Writer implements FrameWriter {
-    private final BufferedSink sink;
-    private final boolean client;
-    private final Buffer hpackBuffer;
-    private final HpackDraft09.Writer hpackWriter;
-    private int maxFrameSize;
-    private boolean closed;
-
-    Writer(BufferedSink sink, boolean client) {
-      this.sink = sink;
-      this.client = client;
-      this.hpackBuffer = new Buffer();
-      this.hpackWriter = new HpackDraft09.Writer(hpackBuffer);
-      this.maxFrameSize = INITIAL_MAX_FRAME_SIZE;
-    }
-
-    @Override public synchronized void flush() throws IOException {
-      if (closed) throw new IOException("closed");
-      sink.flush();
-    }
-
-    @Override public synchronized void ackSettings(Settings peerSettings) throws IOException {
-      if (closed) throw new IOException("closed");
-      this.maxFrameSize = peerSettings.getMaxFrameSize(maxFrameSize);
-      int length = 0;
-      byte type = TYPE_SETTINGS;
-      byte flags = FLAG_ACK;
-      int streamId = 0;
-      frameHeader(streamId, length, type, flags);
-      sink.flush();
-    }
-
-    @Override public synchronized void connectionPreface() throws IOException {
-      if (closed) throw new IOException("closed");
-      if (!client) return; // Nothing to write; servers don't send connection headers!
-      if (logger.isLoggable(FINE)) {
-        logger.fine(format(">> CONNECTION %s", CONNECTION_PREFACE.hex()));
-      }
-      sink.write(CONNECTION_PREFACE.toByteArray());
-      sink.flush();
-    }
-
-    @Override public synchronized void synStream(boolean outFinished, boolean inFinished,
-        int streamId, int associatedStreamId, List<Header> headerBlock)
-        throws IOException {
-      if (inFinished) throw new UnsupportedOperationException();
-      if (closed) throw new IOException("closed");
-      headers(outFinished, streamId, headerBlock);
-    }
-
-    @Override public synchronized void synReply(boolean outFinished, int streamId,
-        List<Header> headerBlock) throws IOException {
-      if (closed) throw new IOException("closed");
-      headers(outFinished, streamId, headerBlock);
-    }
-
-    @Override public synchronized void headers(int streamId, List<Header> headerBlock)
-        throws IOException {
-      if (closed) throw new IOException("closed");
-      headers(false, streamId, headerBlock);
-    }
-
-    @Override public synchronized void pushPromise(int streamId, int promisedStreamId,
-        List<Header> requestHeaders) throws IOException {
-      if (closed) throw new IOException("closed");
-      if (hpackBuffer.size() != 0) throw new IllegalStateException();
-      hpackWriter.writeHeaders(requestHeaders);
-
-      long byteCount = hpackBuffer.size();
-      int length = (int) Math.min(maxFrameSize - 4, byteCount);
-      byte type = TYPE_PUSH_PROMISE;
-      byte flags = byteCount == length ? FLAG_END_HEADERS : 0;
-      frameHeader(streamId, length + 4, type, flags);
-      sink.writeInt(promisedStreamId & 0x7fffffff);
-      sink.write(hpackBuffer, length);
-
-      if (byteCount > length) writeContinuationFrames(streamId, byteCount - length);
-    }
-
-    void headers(boolean outFinished, int streamId, List<Header> headerBlock) throws IOException {
-      if (closed) throw new IOException("closed");
-      if (hpackBuffer.size() != 0) throw new IllegalStateException();
-      hpackWriter.writeHeaders(headerBlock);
-
-      long byteCount = hpackBuffer.size();
-      int length = (int) Math.min(maxFrameSize, byteCount);
-      byte type = TYPE_HEADERS;
-      byte flags = byteCount == length ? FLAG_END_HEADERS : 0;
-      if (outFinished) flags |= FLAG_END_STREAM;
-      frameHeader(streamId, length, type, flags);
-      sink.write(hpackBuffer, length);
-
-      if (byteCount > length) writeContinuationFrames(streamId, byteCount - length);
-    }
-
-    private void writeContinuationFrames(int streamId, long byteCount) throws IOException {
-      while (byteCount > 0) {
-        int length = (int) Math.min(maxFrameSize, byteCount);
-        byteCount -= length;
-        frameHeader(streamId, length, TYPE_CONTINUATION, byteCount == 0 ? FLAG_END_HEADERS : 0);
-        sink.write(hpackBuffer, length);
-      }
-    }
-
-    @Override public synchronized void rstStream(int streamId, ErrorCode errorCode)
-        throws IOException {
-      if (closed) throw new IOException("closed");
-      if (errorCode.spdyRstCode == -1) throw new IllegalArgumentException();
-
-      int length = 4;
-      byte type = TYPE_RST_STREAM;
-      byte flags = FLAG_NONE;
-      frameHeader(streamId, length, type, flags);
-      sink.writeInt(errorCode.httpCode);
-      sink.flush();
-    }
-
-    @Override public int maxDataLength() {
-      return maxFrameSize;
-    }
-
-    @Override public synchronized void data(boolean outFinished, int streamId, Buffer source,
-        int byteCount) throws IOException {
-      if (closed) throw new IOException("closed");
-      byte flags = FLAG_NONE;
-      if (outFinished) flags |= FLAG_END_STREAM;
-      dataFrame(streamId, flags, source, byteCount);
-    }
-
-    void dataFrame(int streamId, byte flags, Buffer buffer, int byteCount) throws IOException {
-      byte type = TYPE_DATA;
-      frameHeader(streamId, byteCount, type, flags);
-      if (byteCount > 0) {
-        sink.write(buffer, byteCount);
-      }
-    }
-
-    @Override public synchronized void settings(Settings settings) throws IOException {
-      if (closed) throw new IOException("closed");
-      int length = settings.size() * 6;
-      byte type = TYPE_SETTINGS;
-      byte flags = FLAG_NONE;
-      int streamId = 0;
-      frameHeader(streamId, length, type, flags);
-      for (int i = 0; i < Settings.COUNT; i++) {
-        if (!settings.isSet(i)) continue;
-        int id = i;
-        if (id == 4) id = 3; // SETTINGS_MAX_CONCURRENT_STREAMS renumbered.
-        else if (id == 7) id = 4; // SETTINGS_INITIAL_WINDOW_SIZE renumbered.
-        sink.writeShort(id);
-        sink.writeInt(settings.get(i));
-      }
-      sink.flush();
-    }
-
-    @Override public synchronized void ping(boolean ack, int payload1, int payload2)
-        throws IOException {
-      if (closed) throw new IOException("closed");
-      int length = 8;
-      byte type = TYPE_PING;
-      byte flags = ack ? FLAG_ACK : FLAG_NONE;
-      int streamId = 0;
-      frameHeader(streamId, length, type, flags);
-      sink.writeInt(payload1);
-      sink.writeInt(payload2);
-      sink.flush();
-    }
-
-    @Override public synchronized void goAway(int lastGoodStreamId, ErrorCode errorCode,
-        byte[] debugData) throws IOException {
-      if (closed) throw new IOException("closed");
-      if (errorCode.httpCode == -1) throw illegalArgument("errorCode.httpCode == -1");
-      int length = 8 + debugData.length;
-      byte type = TYPE_GOAWAY;
-      byte flags = FLAG_NONE;
-      int streamId = 0;
-      frameHeader(streamId, length, type, flags);
-      sink.writeInt(lastGoodStreamId);
-      sink.writeInt(errorCode.httpCode);
-      if (debugData.length > 0) {
-        sink.write(debugData);
-      }
-      sink.flush();
-    }
-
-    @Override public synchronized void windowUpdate(int streamId, long windowSizeIncrement)
-        throws IOException {
-      if (closed) throw new IOException("closed");
-      if (windowSizeIncrement == 0 || windowSizeIncrement > 0x7fffffffL) {
-        throw illegalArgument("windowSizeIncrement == 0 || windowSizeIncrement > 0x7fffffffL: %s",
-            windowSizeIncrement);
-      }
-      int length = 4;
-      byte type = TYPE_WINDOW_UPDATE;
-      byte flags = FLAG_NONE;
-      frameHeader(streamId, length, type, flags);
-      sink.writeInt((int) windowSizeIncrement);
-      sink.flush();
-    }
-
-    @Override public synchronized void close() throws IOException {
-      closed = true;
-      sink.close();
-    }
-
-    void frameHeader(int streamId, int length, byte type, byte flags) throws IOException {
-      if (logger.isLoggable(FINE)) logger.fine(formatHeader(false, streamId, length, type, flags));
-      if (length > maxFrameSize) {
-        throw illegalArgument("FRAME_SIZE_ERROR length > %d: %d", maxFrameSize, length);
-      }
-      if ((streamId & 0x80000000) != 0) throw illegalArgument("reserved bit set: %s", streamId);
-      writeMedium(sink, length);
-      sink.writeByte(type & 0xff);
-      sink.writeByte(flags & 0xff);
-      sink.writeInt(streamId & 0x7fffffff);
-    }
-  }
-
-  private static IllegalArgumentException illegalArgument(String message, Object... args) {
-    throw new IllegalArgumentException(format(message, args));
-  }
-
-  private static IOException ioException(String message, Object... args) throws IOException {
-    throw new IOException(format(message, args));
-  }
-
-  /**
-   * Decompression of the header block occurs above the framing layer. This
-   * class lazily reads continuation frames as they are needed by {@link
-   * HpackDraft09.Reader#readHeaders()}.
-   */
-  static final class ContinuationSource implements Source {
-    private final BufferedSource source;
-
-    int length;
-    byte flags;
-    int streamId;
-
-    int left;
-    short padding;
-
-    public ContinuationSource(BufferedSource source) {
-      this.source = source;
-    }
-
-    @Override public long read(Buffer sink, long byteCount) throws IOException {
-      while (left == 0) {
-        source.skip(padding);
-        padding = 0;
-        if ((flags & FLAG_END_HEADERS) != 0) return -1;
-        readContinuationHeader();
-        // TODO: test case for empty continuation header?
-      }
-
-      long read = source.read(sink, Math.min(byteCount, left));
-      if (read == -1) return -1;
-      left -= read;
-      return read;
-    }
-
-    @Override public Timeout timeout() {
-      return source.timeout();
-    }
-
-    @Override public void close() throws IOException {
-    }
-
-    private void readContinuationHeader() throws IOException {
-      int previousStreamId = streamId;
-
-      length = left = readMedium(source);
-      byte type = (byte) (source.readByte() & 0xff);
-      flags = (byte) (source.readByte() & 0xff);
-      if (logger.isLoggable(FINE)) logger.fine(formatHeader(true, streamId, length, type, flags));
-      streamId = (source.readInt() & 0x7fffffff);
-      if (type != TYPE_CONTINUATION) throw ioException("%s != TYPE_CONTINUATION", type);
-      if (streamId != previousStreamId) throw ioException("TYPE_CONTINUATION streamId changed");
-    }
-  }
-
-  private static int lengthWithoutPadding(int length, byte flags, short padding)
-      throws IOException {
-    if ((flags & FLAG_PADDED) != 0) length--; // Account for reading the padding length.
-    if (padding > length) {
-      throw ioException("PROTOCOL_ERROR padding %s > remaining length %s", padding, length);
-    }
-    return (short) (length - padding);
-  }
-
-  /**
-   * Logs a human-readable representation of HTTP/2 frame headers.
-   *
-   * <p>The format is:
-   *
-   * <pre>
-   *   direction streamID length type flags
-   * </pre>
-   * Where direction is {@code <<} for inbound and {@code >>} for outbound.
-   *
-   * <p> For example, the following would indicate a HEAD request sent from
-   * the client.
-   * <pre>
-   * {@code
-   *   << 0x0000000f    12 HEADERS       END_HEADERS|END_STREAM
-   * }
-   * </pre>
-   */
-  static final class FrameLogger {
-
-    static String formatHeader(boolean inbound, int streamId, int length, byte type, byte flags) {
-      String formattedType = type < TYPES.length ? TYPES[type] : format("0x%02x", type);
-      String formattedFlags = formatFlags(type, flags);
-      return format("%s 0x%08x %5d %-13s %s", inbound ? "<<" : ">>", streamId, length,
-          formattedType, formattedFlags);
-    }
-
-    /**
-     * Looks up valid string representing flags from the table. Invalid
-     * combinations are represented in binary.
-     */
-    // Visible for testing.
-    static String formatFlags(byte type, byte flags) {
-      if (flags == 0) return "";
-      switch (type) { // Special case types that have 0 or 1 flag.
-        case TYPE_SETTINGS:
-        case TYPE_PING:
-          return flags == FLAG_ACK ? "ACK" : BINARY[flags];
-        case TYPE_PRIORITY:
-        case TYPE_RST_STREAM:
-        case TYPE_GOAWAY:
-        case TYPE_WINDOW_UPDATE:
-          return BINARY[flags];
-      }
-      String result = flags < FLAGS.length ? FLAGS[flags] : BINARY[flags];
-      // Special case types that have overlap flag values.
-      if (type == TYPE_PUSH_PROMISE && (flags & FLAG_END_PUSH_PROMISE) != 0) {
-        return result.replace("HEADERS", "PUSH_PROMISE"); // TODO: Avoid allocation.
-      } else if (type == TYPE_DATA && (flags & FLAG_COMPRESSED) != 0) {
-        return result.replace("PRIORITY", "COMPRESSED"); // TODO: Avoid allocation.
-      }
-      return result;
-    }
-
-    /** Lookup table for valid frame types. */
-    private static final String[] TYPES = new String[] {
-        "DATA",
-        "HEADERS",
-        "PRIORITY",
-        "RST_STREAM",
-        "SETTINGS",
-        "PUSH_PROMISE",
-        "PING",
-        "GOAWAY",
-        "WINDOW_UPDATE",
-        "CONTINUATION"
-    };
-
-    /**
-     * Lookup table for valid flags for DATA, HEADERS, CONTINUATION. Invalid
-     * combinations are represented in binary.
-     */
-    private static final String[] FLAGS = new String[0x40]; // Highest bit flag is 0x20.
-    private static final String[] BINARY = new String[256];
-
-    static {
-      for (int i = 0; i < BINARY.length; i++) {
-        BINARY[i] = format("%8s", Integer.toBinaryString(i)).replace(' ', '0');
-      }
-
-      FLAGS[FLAG_NONE] = "";
-      FLAGS[FLAG_END_STREAM] = "END_STREAM";
-
-      int[] prefixFlags = new int[] {FLAG_END_STREAM};
-
-      FLAGS[FLAG_PADDED] = "PADDED";
-      for (int prefixFlag : prefixFlags) {
-         FLAGS[prefixFlag | FLAG_PADDED] = FLAGS[prefixFlag] + "|PADDED";
-      }
-
-      FLAGS[FLAG_END_HEADERS] = "END_HEADERS"; // Same as END_PUSH_PROMISE.
-      FLAGS[FLAG_PRIORITY] = "PRIORITY"; // Same as FLAG_COMPRESSED.
-      FLAGS[FLAG_END_HEADERS | FLAG_PRIORITY] = "END_HEADERS|PRIORITY"; // Only valid on HEADERS.
-      int[] frameFlags =
-          new int[] {FLAG_END_HEADERS, FLAG_PRIORITY, FLAG_END_HEADERS | FLAG_PRIORITY};
-
-      for (int frameFlag : frameFlags) {
-        for (int prefixFlag : prefixFlags) {
-          FLAGS[prefixFlag | frameFlag] = FLAGS[prefixFlag] + '|' + FLAGS[frameFlag];
-          FLAGS[prefixFlag | frameFlag | FLAG_PADDED] =
-              FLAGS[prefixFlag] + '|' + FLAGS[frameFlag] + "|PADDED";
-        }
-      }
-
-      for (int i = 0; i < FLAGS.length; i++) { // Fill in holes with binary representation.
-        if (FLAGS[i] == null) FLAGS[i] = BINARY[i];
-      }
-    }
-  }
-
-  private static int readMedium(BufferedSource source) throws IOException {
-    return (source.readByte() & 0xff) << 16
-        |  (source.readByte() & 0xff) <<  8
-        |  (source.readByte() & 0xff);
-  }
-
-  private static void writeMedium(BufferedSink sink, int i) throws IOException {
-    sink.writeByte((i >>> 16) & 0xff);
-    sink.writeByte((i >>>  8) & 0xff);
-    sink.writeByte(i          & 0xff);
-  }
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Huffman.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Huffman.java
index 91cb59eff0..06d5243d7e 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Huffman.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Huffman.java
@@ -31,7 +31,7 @@
 class Huffman {
 
   // Appendix C: Huffman Codes
-  // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-09#appendix-C
+  // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#appendix-B
   private static final int[] CODES = {
       0x1ff8, 0x7fffd8, 0xfffffe2, 0xfffffe3, 0xfffffe4, 0xfffffe5, 0xfffffe6, 0xfffffe7, 0xfffffe8,
       0xffffea, 0x3ffffffc, 0xfffffe9, 0xfffffea, 0x3ffffffd, 0xfffffeb, 0xfffffec, 0xfffffed,
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
index 458fb6db2b..029d850b1c 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
@@ -33,11 +33,13 @@
 import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
+import java.util.logging.Level;
 import okio.Buffer;
 import okio.BufferedSource;
 import okio.ByteString;
 import okio.Okio;
 
+import static com.squareup.okhttp.internal.Internal.logger;
 import static com.squareup.okhttp.internal.spdy.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
 
 /**
@@ -131,7 +133,7 @@ private SpdyConnection(Builder builder) throws IOException {
     pushObserver = builder.pushObserver;
     client = builder.client;
     handler = builder.handler;
-    // http://tools.ietf.org/html/draft-ietf-httpbis-http2-14#section-5.1.1
+    // http://tools.ietf.org/html/draft-ietf-httpbis-http2-17#section-5.1.1
     nextStreamId = builder.client ? 1 : 2;
     if (builder.client && protocol == Protocol.HTTP_2) {
       nextStreamId += 2; // In HTTP/2, 1 on client is reserved for Upgrade.
@@ -150,14 +152,14 @@ private SpdyConnection(Builder builder) throws IOException {
     hostName = builder.hostName;
 
     if (protocol == Protocol.HTTP_2) {
-      variant = new Http20Draft14();
+      variant = new Http2();
       // Like newSingleThreadExecutor, except lazy creates the thread.
       pushExecutor = new ThreadPoolExecutor(0, 1, 60, TimeUnit.SECONDS,
           new LinkedBlockingQueue<Runnable>(),
           Util.threadFactory(String.format("OkHttp %s Push Observer", hostName), true));
-      // 1 less than SPDY http://tools.ietf.org/html/draft-ietf-httpbis-http2-14#section-6.9.2
+      // 1 less than SPDY http://tools.ietf.org/html/draft-ietf-httpbis-http2-17#section-6.9.2
       peerSettings.set(Settings.INITIAL_WINDOW_SIZE, 0, 65535);
-      peerSettings.set(Settings.MAX_FRAME_SIZE, 0, Http20Draft14.INITIAL_MAX_FRAME_SIZE);
+      peerSettings.set(Settings.MAX_FRAME_SIZE, 0, Http2.INITIAL_MAX_FRAME_SIZE);
     } else if (protocol == Protocol.SPDY_3) {
       variant = new Spdy3();
       pushExecutor = null;
@@ -172,7 +174,7 @@ private SpdyConnection(Builder builder) throws IOException {
     new Thread(readerRunnable).start(); // Not a daemon thread.
   }
 
-  /** The protocol as selected using NPN or ALPN. */
+  /** The protocol as selected using ALPN. */
   public Protocol getProtocol() {
     return protocol;
   }
@@ -194,6 +196,7 @@ synchronized SpdyStream removeStream(int streamId) {
     if (stream != null && streams.isEmpty()) {
       setIdle(true);
     }
+    notifyAll(); // The removed stream may be blocked on a connection-wide window update.
     return stream;
   }
 
@@ -285,19 +288,16 @@ void writeSynReply(int streamId, boolean outFinished, List<Header> alternating)
   }
 
   /**
-   * Callers of this method are not thread safe, and sometimes on application
-   * threads.  Most often, this method will be called to send a buffer worth of
-   * data to the peer.
-   * <p>
-   * Writes are subject to the write window of the stream and the connection.
-   * Until there is a window sufficient to send {@code byteCount}, the caller
-   * will block.  For example, a user of {@code HttpURLConnection} who flushes
-   * more bytes to the output stream than the connection's write window will
-   * block.
-   * <p>
-   * Zero {@code byteCount} writes are not subject to flow control and
-   * will not block.  The only use case for zero {@code byteCount} is closing
-   * a flushed output stream.
+   * Callers of this method are not thread safe, and sometimes on application threads. Most often,
+   * this method will be called to send a buffer worth of data to the peer.
+   *
+   * <p>Writes are subject to the write window of the stream and the connection. Until there is a
+   * window sufficient to send {@code byteCount}, the caller will block. For example, a user of
+   * {@code HttpURLConnection} who flushes more bytes to the output stream than the connection's
+   * write window will block.
+   *
+   * <p>Zero {@code byteCount} writes are not subject to flow control and will not block. The only
+   * use case for zero {@code byteCount} is closing a flushed output stream.
    */
   public void writeData(int streamId, boolean outFinished, Buffer buffer, long byteCount)
       throws IOException {
@@ -311,6 +311,11 @@ public void writeData(int streamId, boolean outFinished, Buffer buffer, long byt
       synchronized (SpdyConnection.this) {
         try {
           while (bytesLeftInWriteWindow <= 0) {
+            // Before blocking, confirm that the stream we're writing is still open. It's possible
+            // that the stream has since been closed (such as if this write timed out.)
+            if (!streams.containsKey(streamId)) {
+              throw new IOException("stream closed");
+            }
             SpdyConnection.this.wait(); // Wait until we receive a WINDOW_UPDATE.
           }
         } catch (InterruptedException e) {
@@ -352,7 +357,7 @@ void writeSynReset(int streamId, ErrorCode statusCode) throws IOException {
   }
 
   void writeWindowUpdateLater(final int streamId, final long unacknowledgedBytesRead) {
-    executor.submit(new NamedRunnable("OkHttp Window Update %s stream %d", hostName, streamId) {
+    executor.execute(new NamedRunnable("OkHttp Window Update %s stream %d", hostName, streamId) {
       @Override public void execute() {
         try {
           frameWriter.windowUpdate(streamId, unacknowledgedBytesRead);
@@ -384,7 +389,7 @@ public Ping ping() throws IOException {
 
   private void writePingLater(
       final boolean reply, final int payload1, final int payload2, final Ping ping) {
-    executor.submit(new NamedRunnable("OkHttp %s ping %08x%08x",
+    executor.execute(new NamedRunnable("OkHttp %s ping %08x%08x",
         hostName, payload1, payload2) {
       @Override public void execute() {
         try {
@@ -636,12 +641,16 @@ private Reader() {
               inFinished, headerBlock);
           lastGoodStreamId = streamId;
           streams.put(streamId, newStream);
-          executor.submit(new NamedRunnable("OkHttp %s stream %d", hostName, streamId) {
+          executor.execute(new NamedRunnable("OkHttp %s stream %d", hostName, streamId) {
             @Override public void execute() {
               try {
                 handler.receive(newStream);
               } catch (IOException e) {
-                throw new RuntimeException(e);
+                logger.log(Level.INFO, "StreamHandler failure for " + hostName, e);
+                try {
+                  newStream.close(ErrorCode.PROTOCOL_ERROR);
+                } catch (IOException ignored) {
+                }
               }
             }
           });
@@ -704,7 +713,7 @@ private Reader() {
     }
 
     private void ackSettingsLater(final Settings peerSettings) {
-      executor.submit(new NamedRunnable("OkHttp %s ACK Settings", hostName) {
+      executor.execute(new NamedRunnable("OkHttp %s ACK Settings", hostName) {
         @Override public void execute() {
           try {
             frameWriter.ackSettings(peerSettings);
@@ -798,7 +807,7 @@ private void pushRequestLater(final int streamId, final List<Header> requestHead
       }
       currentPushRequests.add(streamId);
     }
-    pushExecutor.submit(new NamedRunnable("OkHttp %s Push Request[%s]", hostName, streamId) {
+    pushExecutor.execute(new NamedRunnable("OkHttp %s Push Request[%s]", hostName, streamId) {
       @Override public void execute() {
         boolean cancel = pushObserver.onRequest(streamId, requestHeaders);
         try {
@@ -816,7 +825,7 @@ private void pushRequestLater(final int streamId, final List<Header> requestHead
 
   private void pushHeadersLater(final int streamId, final List<Header> requestHeaders,
       final boolean inFinished) {
-    pushExecutor.submit(new NamedRunnable("OkHttp %s Push Headers[%s]", hostName, streamId) {
+    pushExecutor.execute(new NamedRunnable("OkHttp %s Push Headers[%s]", hostName, streamId) {
       @Override public void execute() {
         boolean cancel = pushObserver.onHeaders(streamId, requestHeaders, inFinished);
         try {
@@ -842,7 +851,7 @@ private void pushDataLater(final int streamId, final BufferedSource source, fina
     source.require(byteCount); // Eagerly read the frame before firing client thread.
     source.read(buffer, byteCount);
     if (buffer.size() != byteCount) throw new IOException(buffer.size() + " != " + byteCount);
-    pushExecutor.submit(new NamedRunnable("OkHttp %s Push Data[%s]", hostName, streamId) {
+    pushExecutor.execute(new NamedRunnable("OkHttp %s Push Data[%s]", hostName, streamId) {
       @Override public void execute() {
         try {
           boolean cancel = pushObserver.onData(streamId, buffer, byteCount, inFinished);
@@ -859,7 +868,7 @@ private void pushDataLater(final int streamId, final BufferedSource source, fina
   }
 
   private void pushResetLater(final int streamId, final ErrorCode errorCode) {
-    pushExecutor.submit(new NamedRunnable("OkHttp %s Push Reset[%s]", hostName, streamId) {
+    pushExecutor.execute(new NamedRunnable("OkHttp %s Push Reset[%s]", hostName, streamId) {
       @Override public void execute() {
         pushObserver.onReset(streamId, errorCode);
         synchronized (SpdyConnection.this) {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
index 331536d376..05ce57a964 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
@@ -53,7 +53,6 @@
 
   private final int id;
   private final SpdyConnection connection;
-  private long readTimeoutMillis = 0;
 
   /** Headers sent by the stream initiator. Immutable and non null. */
   private final List<Header> requestHeaders;
@@ -468,6 +467,14 @@ private void cancelStreamIfNecessary() throws IOException {
    * thread safe.
    */
   final class SpdyDataSink implements Sink {
+    private static final long EMIT_BUFFER_SIZE = 16384;
+
+    /**
+     * Buffer of outgoing data. This batches writes of small writes into this sink as larges
+     * frames written to the outgoing connection. Batching saves the (small) framing overhead.
+     */
+    private final Buffer sendBuffer = new Buffer();
+
     private boolean closed;
 
     /**
@@ -478,25 +485,38 @@ private void cancelStreamIfNecessary() throws IOException {
 
     @Override public void write(Buffer source, long byteCount) throws IOException {
       assert (!Thread.holdsLock(SpdyStream.this));
-      while (byteCount > 0) {
-        long toWrite;
-        synchronized (SpdyStream.this) {
-          writeTimeout.enter();
-          try {
-            while (bytesLeftInWriteWindow <= 0 && !finished && !closed && errorCode == null) {
-              waitForIo(); // Wait until we receive a WINDOW_UPDATE.
-            }
-          } finally {
-            writeTimeout.exitAndThrowIfTimedOut();
-          }
+      sendBuffer.write(source, byteCount);
+      while (sendBuffer.size() >= EMIT_BUFFER_SIZE) {
+        emitDataFrame(false);
+      }
+    }
 
-          checkOutNotClosed(); // Kick out if the stream was reset or closed while waiting.
-          toWrite = Math.min(bytesLeftInWriteWindow, byteCount);
-          bytesLeftInWriteWindow -= toWrite;
+    /**
+     * Emit a single data frame to the connection. The frame's size be limited by this stream's
+     * write window. This method will block until the write window is nonempty.
+     */
+    private void emitDataFrame(boolean outFinished) throws IOException {
+      long toWrite;
+      synchronized (SpdyStream.this) {
+        writeTimeout.enter();
+        try {
+          while (bytesLeftInWriteWindow <= 0 && !finished && !closed && errorCode == null) {
+            waitForIo(); // Wait until we receive a WINDOW_UPDATE for this stream.
+          }
+        } finally {
+          writeTimeout.exitAndThrowIfTimedOut();
         }
 
-        byteCount -= toWrite;
-        connection.writeData(id, false, source, toWrite);
+        checkOutNotClosed(); // Kick out if the stream was reset or closed while waiting.
+        toWrite = Math.min(bytesLeftInWriteWindow, sendBuffer.size());
+        bytesLeftInWriteWindow -= toWrite;
+      }
+
+      writeTimeout.enter();
+      try {
+        connection.writeData(id, outFinished && toWrite == sendBuffer.size(), sendBuffer, toWrite);
+      } finally {
+        writeTimeout.exitAndThrowIfTimedOut();
       }
     }
 
@@ -505,7 +525,10 @@ private void cancelStreamIfNecessary() throws IOException {
       synchronized (SpdyStream.this) {
         checkOutNotClosed();
       }
-      connection.flush();
+      while (sendBuffer.size() > 0) {
+        emitDataFrame(false);
+        connection.flush();
+      }
     }
 
     @Override public Timeout timeout() {
@@ -518,7 +541,15 @@ private void cancelStreamIfNecessary() throws IOException {
         if (closed) return;
       }
       if (!sink.finished) {
-        connection.writeData(id, true, null, 0);
+        // Emit the remaining data, setting the END_STREAM flag on the last frame.
+        if (sendBuffer.size() > 0) {
+          while (sendBuffer.size() > 0) {
+            emitDataFrame(true);
+          }
+        } else {
+          // Send an empty frame just so we can set the END_STREAM flag.
+          connection.writeData(id, true, null, 0);
+        }
       }
       synchronized (SpdyStream.this) {
         closed = true;
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Variant.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Variant.java
index 2dd6a5207e..c4b082d706 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Variant.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Variant.java
@@ -22,7 +22,7 @@
 /** A version and dialect of the framed socket protocol. */
 public interface Variant {
 
-  /** The protocol as selected using NPN or ALPN. */
+  /** The protocol as selected using ALPN. */
   Protocol getProtocol();
 
   /**
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/tls/OkHostnameVerifier.java b/okhttp/src/main/java/com/squareup/okhttp/internal/tls/OkHostnameVerifier.java
index 0438f6617b..740de1bcdf 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/tls/OkHostnameVerifier.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/tls/OkHostnameVerifier.java
@@ -58,6 +58,7 @@
   private OkHostnameVerifier() {
   }
 
+  @Override
   public boolean verify(String host, SSLSession session) {
     try {
       Certificate[] certificates = session.getPeerCertificates();
@@ -81,8 +82,9 @@ static boolean verifyAsIpAddress(String host) {
    * Returns true if {@code certificate} matches {@code ipAddress}.
    */
   private boolean verifyIpAddress(String ipAddress, X509Certificate certificate) {
-    for (String altName : getSubjectAltNames(certificate, ALT_IPA_NAME)) {
-      if (ipAddress.equalsIgnoreCase(altName)) {
+    List<String> altNames = getSubjectAltNames(certificate, ALT_IPA_NAME);
+    for (int i = 0, size = altNames.size(); i < size; i++) {
+      if (ipAddress.equalsIgnoreCase(altNames.get(i))) {
         return true;
       }
     }
@@ -95,9 +97,10 @@ private boolean verifyIpAddress(String ipAddress, X509Certificate certificate) {
   private boolean verifyHostName(String hostName, X509Certificate certificate) {
     hostName = hostName.toLowerCase(Locale.US);
     boolean hasDns = false;
-    for (String altName : getSubjectAltNames(certificate, ALT_DNS_NAME)) {
+    List<String> altNames = getSubjectAltNames(certificate, ALT_DNS_NAME);
+    for (int i = 0, size = altNames.size(); i < size; i++) {
       hasDns = true;
-      if (verifyHostName(hostName, altName)) {
+      if (verifyHostName(hostName, altNames.get(i))) {
         return true;
       }
     }
@@ -114,7 +117,16 @@ private boolean verifyHostName(String hostName, X509Certificate certificate) {
     return false;
   }
 
-  private List<String> getSubjectAltNames(X509Certificate certificate, int type) {
+  public static List<String> allSubjectAltNames(X509Certificate certificate) {
+    List<String> altIpaNames = getSubjectAltNames(certificate, ALT_IPA_NAME);
+    List<String> altDnsNames = getSubjectAltNames(certificate, ALT_DNS_NAME);
+    List<String> result = new ArrayList<>(altIpaNames.size() + altDnsNames.size());
+    result.addAll(altIpaNames);
+    result.addAll(altDnsNames);
+    return result;
+  }
+
+  private static List<String> getSubjectAltNames(X509Certificate certificate, int type) {
     List<String> result = new ArrayList<>();
     try {
       Collection<?> subjectAltNames = certificate.getSubjectAlternativeNames();
@@ -144,48 +156,97 @@ private boolean verifyHostName(String hostName, X509Certificate certificate) {
   }
 
   /**
-   * Returns true if {@code hostName} matches the name or pattern {@code cn}.
+   * Returns {@code true} iff {@code hostName} matches the domain name {@code pattern}.
    *
-   * @param hostName lowercase host name.
-   * @param cn certificate host name. May include wildcards like
-   *     {@code *.android.com}.
+   * @param hostName lower-case host name.
+   * @param pattern domain name pattern from certificate. May be a wildcard pattern such as
+   *        {@code *.android.com}.
    */
-  public boolean verifyHostName(String hostName, String cn) {
+  private boolean verifyHostName(String hostName, String pattern) {
+    // Basic sanity checks
     // Check length == 0 instead of .isEmpty() to support Java 5.
-    if (hostName == null || hostName.length() == 0 || cn == null || cn.length() == 0) {
+    if ((hostName == null) || (hostName.length() == 0) || (hostName.startsWith("."))
+        || (hostName.endsWith(".."))) {
+      // Invalid domain name
+      return false;
+    }
+    if ((pattern == null) || (pattern.length() == 0) || (pattern.startsWith("."))
+        || (pattern.endsWith(".."))) {
+      // Invalid pattern/domain name
       return false;
     }
 
-    cn = cn.toLowerCase(Locale.US);
-
-    if (!cn.contains("*")) {
-      return hostName.equals(cn);
+    // Normalize hostName and pattern by turning them into absolute domain names if they are not
+    // yet absolute. This is needed because server certificates do not normally contain absolute
+    // names or patterns, but they should be treated as absolute. At the same time, any hostName
+    // presented to this method should also be treated as absolute for the purposes of matching
+    // to the server certificate.
+    //   www.android.com  matches www.android.com
+    //   www.android.com  matches www.android.com.
+    //   www.android.com. matches www.android.com.
+    //   www.android.com. matches www.android.com
+    if (!hostName.endsWith(".")) {
+      hostName += '.';
+    }
+    if (!pattern.endsWith(".")) {
+      pattern += '.';
     }
+    // hostName and pattern are now absolute domain names.
+
+    pattern = pattern.toLowerCase(Locale.US);
+    // hostName and pattern are now in lower case -- domain names are case-insensitive.
 
-    if (cn.startsWith("*.") && hostName.regionMatches(0, cn, 2, cn.length() - 2)) {
-      return true; // "*.foo.com" matches "foo.com"
+    if (!pattern.contains("*")) {
+      // Not a wildcard pattern -- hostName and pattern must match exactly.
+      return hostName.equals(pattern);
+    }
+    // Wildcard pattern
+
+    // WILDCARD PATTERN RULES:
+    // 1. Asterisk (*) is only permitted in the left-most domain name label and must be the
+    //    only character in that label (i.e., must match the whole left-most label).
+    //    For example, *.example.com is permitted, while *a.example.com, a*.example.com,
+    //    a*b.example.com, a.*.example.com are not permitted.
+    // 2. Asterisk (*) cannot match across domain name labels.
+    //    For example, *.example.com matches test.example.com but does not match
+    //    sub.test.example.com.
+    // 3. Wildcard patterns for single-label domain names are not permitted.
+
+    if ((!pattern.startsWith("*.")) || (pattern.indexOf('*', 1) != -1)) {
+      // Asterisk (*) is only permitted in the left-most domain name label and must be the only
+      // character in that label
+      return false;
     }
 
-    int asterisk = cn.indexOf('*');
-    int dot = cn.indexOf('.');
-    if (asterisk > dot) {
-      return false; // malformed; wildcard must be in the first part of the cn
+    // Optimization: check whether hostName is too short to match the pattern. hostName must be at
+    // least as long as the pattern because asterisk must match the whole left-most label and
+    // hostName starts with a non-empty label. Thus, asterisk has to match one or more characters.
+    if (hostName.length() < pattern.length()) {
+      // hostName too short to match the pattern.
+      return false;
     }
 
-    if (!hostName.regionMatches(0, cn, 0, asterisk)) {
-      return false; // prefix before '*' doesn't match
+    if ("*.".equals(pattern)) {
+      // Wildcard pattern for single-label domain name -- not permitted.
+      return false;
     }
 
-    int suffixLength = cn.length() - (asterisk + 1);
-    int suffixStart = hostName.length() - suffixLength;
-    if (hostName.indexOf('.', asterisk) < suffixStart) {
-      return false; // wildcard '*' can't match a '.'
+    // hostName must end with the region of pattern following the asterisk.
+    String suffix = pattern.substring(1);
+    if (!hostName.endsWith(suffix)) {
+      // hostName does not end with the suffix
+      return false;
     }
 
-    if (!hostName.regionMatches(suffixStart, cn, asterisk + 1, suffixLength)) {
-      return false; // suffix after '*' doesn't match
+    // Check that asterisk did not match across domain name labels.
+    int suffixStartIndexInHostName = hostName.length() - suffix.length();
+    if ((suffixStartIndexInHostName > 0)
+        && (hostName.lastIndexOf('.', suffixStartIndexInHostName - 1) != -1)) {
+      // Asterisk is matching across domain name labels -- not permitted.
+      return false;
     }
 
+    // hostName matches pattern
     return true;
   }
 }
