diff --git a/okhttp/src/main/java/okhttp3/Call.java b/okhttp/src/main/java/okhttp3/Call.java
index 67d0f88d3d..f0f7df5951 100644
--- a/okhttp/src/main/java/okhttp3/Call.java
+++ b/okhttp/src/main/java/okhttp3/Call.java
@@ -16,6 +16,7 @@
 package okhttp3;
 
 import java.io.IOException;
+
 import okio.Timeout;
 
 /**
@@ -23,80 +24,85 @@
  * represents a single request/response pair (stream), it cannot be executed twice.
  */
 public interface Call extends Cloneable {
-  /** Returns the original request that initiated this call. */
-  Request request();
+    /**
+     * Returns the original request that initiated this call.
+     *  返回当前请求
+     */
+    Request request();
 
-  /**
-   * Invokes the request immediately, and blocks until the response can be processed or is in
-   * error.
-   *
-   * <p>To avoid leaking resources callers should close the {@link Response} which in turn will
-   * close the underlying {@link ResponseBody}.
-   *
-   * <pre>{@code
-   *
-   *   // ensure the response (and underlying response body) is closed
-   *   try (Response response = client.newCall(request).execute()) {
-   *     ...
-   *   }
-   *
-   * }</pre>
-   *
-   * <p>The caller may read the response body with the response's {@link Response#body} method. To
-   * avoid leaking resources callers must {@linkplain ResponseBody close the response body} or the
-   * Response.
-   *
-   * <p>Note that transport-layer success (receiving a HTTP response code, headers and body) does
-   * not necessarily indicate application-layer success: {@code response} may still indicate an
-   * unhappy HTTP response code like 404 or 500.
-   *
-   * @throws IOException if the request could not be executed due to cancellation, a connectivity
-   * problem or timeout. Because networks can fail during an exchange, it is possible that the
-   * remote server accepted the request before the failure.
-   * @throws IllegalStateException when the call has already been executed.
-   */
-  Response execute() throws IOException;
+    /**
+     * Invokes the request immediately, and blocks until the response can be processed or is in
+     * error.
+     * <p>
+     * <p>To avoid leaking resources callers should close the {@link Response} which in turn will
+     * close the underlying {@link ResponseBody}.
+     * <p>
+     * <pre>{@code
+     *
+     *   // ensure the response (and underlying response body) is closed
+     *   try (Response response = client.newCall(request).execute()) {
+     *     ...
+     *   }
+     *
+     * }</pre>
+     * <p>
+     * <p>The caller may read the response body with the response's {@link Response#body} method. To
+     * avoid leaking resources callers must {@linkplain ResponseBody close the response body} or the
+     * Response.
+     * <p>
+     * <p>Note that transport-layer success (receiving a HTTP response code, headers and body) does
+     * not necessarily indicate application-layer success: {@code response} may still indicate an
+     * unhappy HTTP response code like 404 or 500.
+     *
+     * @throws IOException           if the request could not be executed due to cancellation, a connectivity
+     *                               problem or timeout. Because networks can fail during an exchange, it is possible that the
+     *                               remote server accepted the request before the failure.
+     * @throws IllegalStateException when the call has already been executed.
+     */
+    Response execute() throws IOException;
 
-  /**
-   * Schedules the request to be executed at some point in the future.
-   *
-   * <p>The {@link OkHttpClient#dispatcher dispatcher} defines when the request will run: usually
-   * immediately unless there are several other requests currently being executed.
-   *
-   * <p>This client will later call back {@code responseCallback} with either an HTTP response or a
-   * failure exception.
-   *
-   * @throws IllegalStateException when the call has already been executed.
-   */
-  void enqueue(Callback responseCallback);
+    /**
+     * Schedules the request to be executed at some point in the future.
+     * <p>
+     * <p>The {@link OkHttpClient#dispatcher dispatcher} defines when the request will run: usually
+     * immediately unless there are several other requests currently being executed.
+     * <p>
+     * <p>This client will later call back {@code responseCallback} with either an HTTP response or a
+     * failure exception.
+     *
+     * @throws IllegalStateException when the call has already been executed.
+     */
+    void enqueue(Callback responseCallback);
 
-  /** Cancels the request, if possible. Requests that are already complete cannot be canceled. */
-  void cancel();
+    /**
+     * Cancels the request, if possible. Requests that are already complete cannot be canceled.
+     */
+    void cancel();
 
-  /**
-   * Returns true if this call has been either {@linkplain #execute() executed} or {@linkplain
-   * #enqueue(Callback) enqueued}. It is an error to execute a call more than once.
-   */
-  boolean isExecuted();
+    /**
+     * Returns true if this call has been either {@linkplain #execute() executed} or {@linkplain
+     * #enqueue(Callback) enqueued}. It is an error to execute a call more than once.
+     */
+    boolean isExecuted();
 
-  boolean isCanceled();
+    boolean isCanceled();
 
-  /**
-   * Returns a timeout that spans the entire call: resolving DNS, connecting, writing the request
-   * body, server processing, and reading the response body. If the call requires redirects or
-   * retries all must complete within one timeout period.
-   *
-   * <p>Configure the client's default timeout with {@link OkHttpClient.Builder#callTimeout}.
-   */
-  Timeout timeout();
+    /**
+     * Returns a timeout that spans the entire call: resolving DNS, connecting, writing the request
+     * body, server processing, and reading the response body. If the call requires redirects or
+     * retries all must complete within one timeout period.
+     * <p>
+     * <p>Configure the client's default timeout with {@link OkHttpClient.Builder#callTimeout}.
+     */
+    Timeout timeout();
 
-  /**
-   * Create a new, identical call to this one which can be enqueued or executed even if this call
-   * has already been.
-   */
-  Call clone();
+    /**
+     * Create a new, identical call to this one which can be enqueued or executed even if this call
+     * has already been.
+     */
+    Call clone();
 
-  interface Factory {
-    Call newCall(Request request);
-  }
+    interface Factory {
+        Call newCall(Request request);
+    }
 }
diff --git a/okhttp/src/main/java/okhttp3/ConnectionSpec.java b/okhttp/src/main/java/okhttp3/ConnectionSpec.java
index 004a97065b..1fa02be842 100644
--- a/okhttp/src/main/java/okhttp3/ConnectionSpec.java
+++ b/okhttp/src/main/java/okhttp3/ConnectionSpec.java
@@ -17,8 +17,10 @@
 
 import java.util.Arrays;
 import java.util.List;
+
 import javax.annotation.Nullable;
 import javax.net.ssl.SSLSocket;
+
 import okhttp3.internal.Util;
 
 import static okhttp3.internal.Util.concat;
@@ -30,312 +32,335 @@
  * Specifies configuration for the socket connection that HTTP traffic travels through. For {@code
  * https:} URLs, this includes the TLS version and cipher suites to use when negotiating a secure
  * connection.
- *
+ * <p>
  * <p>The TLS versions configured in a connection spec are only be used if they are also enabled in
  * the SSL socket. For example, if an SSL socket does not have TLS 1.3 enabled, it will not be used
  * even if it is present on the connection spec. The same policy also applies to cipher suites.
- *
+ * <p>
  * <p>Use {@link Builder#allEnabledTlsVersions()} and {@link Builder#allEnabledCipherSuites} to
  * defer all feature selection to the underlying SSL socket.
  */
 public final class ConnectionSpec {
 
-  // Most secure but generally supported list.
-  private static final CipherSuite[] RESTRICTED_CIPHER_SUITES = new CipherSuite[] {
-      // TLSv1.3
-      CipherSuite.TLS_AES_128_GCM_SHA256,
-      CipherSuite.TLS_AES_256_GCM_SHA384,
-      CipherSuite.TLS_CHACHA20_POLY1305_SHA256,
-      CipherSuite.TLS_AES_128_CCM_SHA256,
-      CipherSuite.TLS_AES_256_CCM_8_SHA256,
-
-      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
-      CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
-      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
-      CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
-      CipherSuite.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256,
-      CipherSuite.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256
-  };
-
-  // This is nearly equal to the cipher suites supported in Chrome 51, current as of 2016-05-25.
-  // All of these suites are available on Android 7.0; earlier releases support a subset of these
-  // suites. https://github.com/square/okhttp/issues/1972
-  private static final CipherSuite[] APPROVED_CIPHER_SUITES = new CipherSuite[] {
-      // TLSv1.3
-      CipherSuite.TLS_AES_128_GCM_SHA256,
-      CipherSuite.TLS_AES_256_GCM_SHA384,
-      CipherSuite.TLS_CHACHA20_POLY1305_SHA256,
-      CipherSuite.TLS_AES_128_CCM_SHA256,
-      CipherSuite.TLS_AES_256_CCM_8_SHA256,
-
-      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
-      CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
-      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
-      CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
-      CipherSuite.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256,
-      CipherSuite.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256,
-
-      // Note that the following cipher suites are all on HTTP/2's bad cipher suites list. We'll
-      // continue to include them until better suites are commonly available. For example, none
-      // of the better cipher suites listed above shipped with Android 4.4 or Java 7.
-      CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,
-      CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,
-      CipherSuite.TLS_RSA_WITH_AES_128_GCM_SHA256,
-      CipherSuite.TLS_RSA_WITH_AES_256_GCM_SHA384,
-      CipherSuite.TLS_RSA_WITH_AES_128_CBC_SHA,
-      CipherSuite.TLS_RSA_WITH_AES_256_CBC_SHA,
-      CipherSuite.TLS_RSA_WITH_3DES_EDE_CBC_SHA,
-  };
-
-  /** A secure TLS connection assuming a modern client platform and server. */
-  public static final ConnectionSpec RESTRICTED_TLS = new Builder(true)
-      .cipherSuites(RESTRICTED_CIPHER_SUITES)
-      .tlsVersions(TlsVersion.TLS_1_3, TlsVersion.TLS_1_2)
-      .supportsTlsExtensions(true)
-      .build();
-
-  /** A modern TLS connection with extensions like SNI and ALPN available. */
-  public static final ConnectionSpec MODERN_TLS = new Builder(true)
-      .cipherSuites(APPROVED_CIPHER_SUITES)
-      .tlsVersions(TlsVersion.TLS_1_3, TlsVersion.TLS_1_2, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0)
-      .supportsTlsExtensions(true)
-      .build();
-
-  /** A backwards-compatible fallback connection for interop with obsolete servers. */
-  public static final ConnectionSpec COMPATIBLE_TLS = new Builder(true)
-      .cipherSuites(APPROVED_CIPHER_SUITES)
-      .tlsVersions(TlsVersion.TLS_1_0)
-      .supportsTlsExtensions(true)
-      .build();
-
-  /** Unencrypted, unauthenticated connections for {@code http:} URLs. */
-  public static final ConnectionSpec CLEARTEXT = new Builder(false).build();
-
-  final boolean tls;
-  final boolean supportsTlsExtensions;
-  final @Nullable String[] cipherSuites;
-  final @Nullable String[] tlsVersions;
-
-  ConnectionSpec(Builder builder) {
-    this.tls = builder.tls;
-    this.cipherSuites = builder.cipherSuites;
-    this.tlsVersions = builder.tlsVersions;
-    this.supportsTlsExtensions = builder.supportsTlsExtensions;
-  }
-
-  public boolean isTls() {
-    return tls;
-  }
-
-  /**
-   * Returns the cipher suites to use for a connection. Returns null if all of the SSL socket's
-   * enabled cipher suites should be used.
-   */
-  public @Nullable List<CipherSuite> cipherSuites() {
-    return cipherSuites != null ? CipherSuite.forJavaNames(cipherSuites) : null;
-  }
-
-  /**
-   * Returns the TLS versions to use when negotiating a connection. Returns null if all of the SSL
-   * socket's enabled TLS versions should be used.
-   */
-  public @Nullable List<TlsVersion> tlsVersions() {
-    return tlsVersions != null ? TlsVersion.forJavaNames(tlsVersions) : null;
-  }
-
-  public boolean supportsTlsExtensions() {
-    return supportsTlsExtensions;
-  }
-
-  /** Applies this spec to {@code sslSocket}. */
-  void apply(SSLSocket sslSocket, boolean isFallback) {
-    ConnectionSpec specToApply = supportedSpec(sslSocket, isFallback);
-
-    if (specToApply.tlsVersions != null) {
-      sslSocket.setEnabledProtocols(specToApply.tlsVersions);
-    }
-    if (specToApply.cipherSuites != null) {
-      sslSocket.setEnabledCipherSuites(specToApply.cipherSuites);
-    }
-  }
-
-  /**
-   * Returns a copy of this that omits cipher suites and TLS versions not enabled by {@code
-   * sslSocket}.
-   */
-  private ConnectionSpec supportedSpec(SSLSocket sslSocket, boolean isFallback) {
-    String[] cipherSuitesIntersection = cipherSuites != null
-        ? intersect(CipherSuite.ORDER_BY_NAME, sslSocket.getEnabledCipherSuites(), cipherSuites)
-        : sslSocket.getEnabledCipherSuites();
-    String[] tlsVersionsIntersection = tlsVersions != null
-        ? intersect(Util.NATURAL_ORDER, sslSocket.getEnabledProtocols(), tlsVersions)
-        : sslSocket.getEnabledProtocols();
-
-    // In accordance with https://tools.ietf.org/html/draft-ietf-tls-downgrade-scsv-00
-    // the SCSV cipher is added to signal that a protocol fallback has taken place.
-    String[] supportedCipherSuites = sslSocket.getSupportedCipherSuites();
-    int indexOfFallbackScsv = indexOf(
-        CipherSuite.ORDER_BY_NAME, supportedCipherSuites, "TLS_FALLBACK_SCSV");
-    if (isFallback && indexOfFallbackScsv != -1) {
-      cipherSuitesIntersection = concat(
-          cipherSuitesIntersection, supportedCipherSuites[indexOfFallbackScsv]);
-    }
-
-    return new Builder(this)
-        .cipherSuites(cipherSuitesIntersection)
-        .tlsVersions(tlsVersionsIntersection)
-        .build();
-  }
-
-  /**
-   * Returns {@code true} if the socket, as currently configured, supports this connection spec. In
-   * order for a socket to be compatible the enabled cipher suites and protocols must intersect.
-   *
-   * <p>For cipher suites, at least one of the {@link #cipherSuites() required cipher suites} must
-   * match the socket's enabled cipher suites. If there are no required cipher suites the socket
-   * must have at least one cipher suite enabled.
-   *
-   * <p>For protocols, at least one of the {@link #tlsVersions() required protocols} must match the
-   * socket's enabled protocols.
-   */
-  public boolean isCompatible(SSLSocket socket) {
-    if (!tls) {
-      return false;
-    }
-
-    if (tlsVersions != null && !nonEmptyIntersection(
-        Util.NATURAL_ORDER, tlsVersions, socket.getEnabledProtocols())) {
-      return false;
-    }
-
-    if (cipherSuites != null && !nonEmptyIntersection(
-        CipherSuite.ORDER_BY_NAME, cipherSuites, socket.getEnabledCipherSuites())) {
-      return false;
+    // Most secure but generally supported list.
+    private static final CipherSuite[] RESTRICTED_CIPHER_SUITES = new CipherSuite[]{
+            // TLSv1.3
+            CipherSuite.TLS_AES_128_GCM_SHA256,
+            CipherSuite.TLS_AES_256_GCM_SHA384,
+            CipherSuite.TLS_CHACHA20_POLY1305_SHA256,
+            CipherSuite.TLS_AES_128_CCM_SHA256,
+            CipherSuite.TLS_AES_256_CCM_8_SHA256,
+
+            CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
+            CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
+            CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
+            CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
+            CipherSuite.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256,
+            CipherSuite.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256
+    };
+
+    // This is nearly equal to the cipher suites supported in Chrome 51, current as of 2016-05-25.
+    // All of these suites are available on Android 7.0; earlier releases support a subset of these
+    // suites. https://github.com/square/okhttp/issues/1972
+    private static final CipherSuite[] APPROVED_CIPHER_SUITES = new CipherSuite[]{
+            // TLSv1.3
+            CipherSuite.TLS_AES_128_GCM_SHA256,
+            CipherSuite.TLS_AES_256_GCM_SHA384,
+            CipherSuite.TLS_CHACHA20_POLY1305_SHA256,
+            CipherSuite.TLS_AES_128_CCM_SHA256,
+            CipherSuite.TLS_AES_256_CCM_8_SHA256,
+
+            CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
+            CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
+            CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
+            CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
+            CipherSuite.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256,
+            CipherSuite.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256,
+
+            // Note that the following cipher suites are all on HTTP/2's bad cipher suites list. We'll
+            // continue to include them until better suites are commonly available. For example, none
+            // of the better cipher suites listed above shipped with Android 4.4 or Java 7.
+            CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,
+            CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,
+            CipherSuite.TLS_RSA_WITH_AES_128_GCM_SHA256,
+            CipherSuite.TLS_RSA_WITH_AES_256_GCM_SHA384,
+            CipherSuite.TLS_RSA_WITH_AES_128_CBC_SHA,
+            CipherSuite.TLS_RSA_WITH_AES_256_CBC_SHA,
+            CipherSuite.TLS_RSA_WITH_3DES_EDE_CBC_SHA,
+    };
+
+    /**
+     * A secure TLS connection assuming a modern client platform and server.
+     */
+    public static final ConnectionSpec RESTRICTED_TLS = new Builder(true)
+            .cipherSuites(RESTRICTED_CIPHER_SUITES)
+            .tlsVersions(TlsVersion.TLS_1_3, TlsVersion.TLS_1_2)
+            .supportsTlsExtensions(true)
+            .build();
+
+    /**
+     * A modern TLS connection with extensions like SNI and ALPN available.
+     *
+     * TLS 连接
+     */
+    public static final ConnectionSpec MODERN_TLS = new Builder(true)
+            .cipherSuites(APPROVED_CIPHER_SUITES)
+            .tlsVersions(TlsVersion.TLS_1_3, TlsVersion.TLS_1_2, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0)
+            .supportsTlsExtensions(true)
+            .build();
+
+    /**
+     * A backwards-compatible fallback connection for interop with obsolete servers.
+     */
+    public static final ConnectionSpec COMPATIBLE_TLS = new Builder(true)
+            .cipherSuites(APPROVED_CIPHER_SUITES)
+            .tlsVersions(TlsVersion.TLS_1_0)
+            .supportsTlsExtensions(true)
+            .build();
+
+    /**
+     * Unencrypted, unauthenticated connections for {@code http:} URLs.
+     * 未加密、未认证的Http连接.
+     */
+    public static final ConnectionSpec CLEARTEXT = new Builder(false).build();
+
+    final boolean tls;
+    final boolean supportsTlsExtensions;
+    final @Nullable
+    String[] cipherSuites;
+    final @Nullable
+    String[] tlsVersions;
+
+    ConnectionSpec(Builder builder) {
+        this.tls = builder.tls;
+        this.cipherSuites = builder.cipherSuites;
+        this.tlsVersions = builder.tlsVersions;
+        this.supportsTlsExtensions = builder.supportsTlsExtensions;
     }
 
-    return true;
-  }
-
-  @Override public boolean equals(@Nullable Object other) {
-    if (!(other instanceof ConnectionSpec)) return false;
-    if (other == this) return true;
-
-    ConnectionSpec that = (ConnectionSpec) other;
-    if (this.tls != that.tls) return false;
-
-    if (tls) {
-      if (!Arrays.equals(this.cipherSuites, that.cipherSuites)) return false;
-      if (!Arrays.equals(this.tlsVersions, that.tlsVersions)) return false;
-      if (this.supportsTlsExtensions != that.supportsTlsExtensions) return false;
-    }
-
-    return true;
-  }
-
-  @Override public int hashCode() {
-    int result = 17;
-    if (tls) {
-      result = 31 * result + Arrays.hashCode(cipherSuites);
-      result = 31 * result + Arrays.hashCode(tlsVersions);
-      result = 31 * result + (supportsTlsExtensions ? 0 : 1);
+    public boolean isTls() {
+        return tls;
     }
-    return result;
-  }
 
-  @Override public String toString() {
-    if (!tls) {
-      return "ConnectionSpec()";
+    /**
+     * Returns the cipher suites to use for a connection. Returns null if all of the SSL socket's
+     * enabled cipher suites should be used.
+     */
+    public @Nullable
+    List<CipherSuite> cipherSuites() {
+        return cipherSuites != null ? CipherSuite.forJavaNames(cipherSuites) : null;
     }
 
-    String cipherSuitesString = cipherSuites != null ? cipherSuites().toString() : "[all enabled]";
-    String tlsVersionsString = tlsVersions != null ? tlsVersions().toString() : "[all enabled]";
-    return "ConnectionSpec("
-        + "cipherSuites=" + cipherSuitesString
-        + ", tlsVersions=" + tlsVersionsString
-        + ", supportsTlsExtensions=" + supportsTlsExtensions
-        + ")";
-  }
-
-  public static final class Builder {
-    boolean tls;
-    @Nullable String[] cipherSuites;
-    @Nullable String[] tlsVersions;
-    boolean supportsTlsExtensions;
-
-    Builder(boolean tls) {
-      this.tls = tls;
+    /**
+     * Returns the TLS versions to use when negotiating a connection. Returns null if all of the SSL
+     * socket's enabled TLS versions should be used.
+     */
+    public @Nullable
+    List<TlsVersion> tlsVersions() {
+        return tlsVersions != null ? TlsVersion.forJavaNames(tlsVersions) : null;
     }
 
-    public Builder(ConnectionSpec connectionSpec) {
-      this.tls = connectionSpec.tls;
-      this.cipherSuites = connectionSpec.cipherSuites;
-      this.tlsVersions = connectionSpec.tlsVersions;
-      this.supportsTlsExtensions = connectionSpec.supportsTlsExtensions;
+    public boolean supportsTlsExtensions() {
+        return supportsTlsExtensions;
     }
 
-    public Builder allEnabledCipherSuites() {
-      if (!tls) throw new IllegalStateException("no cipher suites for cleartext connections");
-      this.cipherSuites = null;
-      return this;
+    /**
+     * Applies this spec to {@code sslSocket}.
+     */
+    void apply(SSLSocket sslSocket, boolean isFallback) {
+        ConnectionSpec specToApply = supportedSpec(sslSocket, isFallback);
+
+        if (specToApply.tlsVersions != null) {
+            sslSocket.setEnabledProtocols(specToApply.tlsVersions);
+        }
+        if (specToApply.cipherSuites != null) {
+            sslSocket.setEnabledCipherSuites(specToApply.cipherSuites);
+        }
     }
 
-    public Builder cipherSuites(CipherSuite... cipherSuites) {
-      if (!tls) throw new IllegalStateException("no cipher suites for cleartext connections");
-
-      String[] strings = new String[cipherSuites.length];
-      for (int i = 0; i < cipherSuites.length; i++) {
-        strings[i] = cipherSuites[i].javaName;
-      }
-      return cipherSuites(strings);
+    /**
+     * Returns a copy of this that omits cipher suites and TLS versions not enabled by {@code
+     * sslSocket}.
+     */
+    private ConnectionSpec supportedSpec(SSLSocket sslSocket, boolean isFallback) {
+        String[] cipherSuitesIntersection = cipherSuites != null
+                ? intersect(CipherSuite.ORDER_BY_NAME, sslSocket.getEnabledCipherSuites(), cipherSuites)
+                : sslSocket.getEnabledCipherSuites();
+        String[] tlsVersionsIntersection = tlsVersions != null
+                ? intersect(Util.NATURAL_ORDER, sslSocket.getEnabledProtocols(), tlsVersions)
+                : sslSocket.getEnabledProtocols();
+
+        // In accordance with https://tools.ietf.org/html/draft-ietf-tls-downgrade-scsv-00
+        // the SCSV cipher is added to signal that a protocol fallback has taken place.
+        String[] supportedCipherSuites = sslSocket.getSupportedCipherSuites();
+        int indexOfFallbackScsv = indexOf(
+                CipherSuite.ORDER_BY_NAME, supportedCipherSuites, "TLS_FALLBACK_SCSV");
+        if (isFallback && indexOfFallbackScsv != -1) {
+            cipherSuitesIntersection = concat(
+                    cipherSuitesIntersection, supportedCipherSuites[indexOfFallbackScsv]);
+        }
+
+        return new Builder(this)
+                .cipherSuites(cipherSuitesIntersection)
+                .tlsVersions(tlsVersionsIntersection)
+                .build();
     }
 
-    public Builder cipherSuites(String... cipherSuites) {
-      if (!tls) throw new IllegalStateException("no cipher suites for cleartext connections");
-
-      if (cipherSuites.length == 0) {
-        throw new IllegalArgumentException("At least one cipher suite is required");
-      }
-
-      this.cipherSuites = cipherSuites.clone(); // Defensive copy.
-      return this;
+    /**
+     * Returns {@code true} if the socket, as currently configured, supports this connection spec. In
+     * order for a socket to be compatible the enabled cipher suites and protocols must intersect.
+     * <p>
+     * <p>For cipher suites, at least one of the {@link #cipherSuites() required cipher suites} must
+     * match the socket's enabled cipher suites. If there are no required cipher suites the socket
+     * must have at least one cipher suite enabled.
+     * <p>
+     * <p>For protocols, at least one of the {@link #tlsVersions() required protocols} must match the
+     * socket's enabled protocols.
+     */
+    public boolean isCompatible(SSLSocket socket) {
+        if (!tls) {
+            return false;
+        }
+
+        if (tlsVersions != null && !nonEmptyIntersection(
+                Util.NATURAL_ORDER, tlsVersions, socket.getEnabledProtocols())) {
+            return false;
+        }
+
+        if (cipherSuites != null && !nonEmptyIntersection(
+                CipherSuite.ORDER_BY_NAME, cipherSuites, socket.getEnabledCipherSuites())) {
+            return false;
+        }
+
+        return true;
     }
 
-    public Builder allEnabledTlsVersions() {
-      if (!tls) throw new IllegalStateException("no TLS versions for cleartext connections");
-      this.tlsVersions = null;
-      return this;
-    }
+    @Override
+    public boolean equals(@Nullable Object other) {
+        if (!(other instanceof ConnectionSpec)) return false;
+        if (other == this) return true;
 
-    public Builder tlsVersions(TlsVersion... tlsVersions) {
-      if (!tls) throw new IllegalStateException("no TLS versions for cleartext connections");
+        ConnectionSpec that = (ConnectionSpec) other;
+        if (this.tls != that.tls) return false;
 
-      String[] strings = new String[tlsVersions.length];
-      for (int i = 0; i < tlsVersions.length; i++) {
-        strings[i] = tlsVersions[i].javaName;
-      }
+        if (tls) {
+            if (!Arrays.equals(this.cipherSuites, that.cipherSuites)) return false;
+            if (!Arrays.equals(this.tlsVersions, that.tlsVersions)) return false;
+            if (this.supportsTlsExtensions != that.supportsTlsExtensions) return false;
+        }
 
-      return tlsVersions(strings);
+        return true;
     }
 
-    public Builder tlsVersions(String... tlsVersions) {
-      if (!tls) throw new IllegalStateException("no TLS versions for cleartext connections");
-
-      if (tlsVersions.length == 0) {
-        throw new IllegalArgumentException("At least one TLS version is required");
-      }
-
-      this.tlsVersions = tlsVersions.clone(); // Defensive copy.
-      return this;
+    @Override
+    public int hashCode() {
+        int result = 17;
+        if (tls) {
+            result = 31 * result + Arrays.hashCode(cipherSuites);
+            result = 31 * result + Arrays.hashCode(tlsVersions);
+            result = 31 * result + (supportsTlsExtensions ? 0 : 1);
+        }
+        return result;
     }
 
-    public Builder supportsTlsExtensions(boolean supportsTlsExtensions) {
-      if (!tls) throw new IllegalStateException("no TLS extensions for cleartext connections");
-      this.supportsTlsExtensions = supportsTlsExtensions;
-      return this;
+    @Override
+    public String toString() {
+        if (!tls) {
+            return "ConnectionSpec()";
+        }
+
+        String cipherSuitesString = cipherSuites != null ? cipherSuites().toString() : "[all enabled]";
+        String tlsVersionsString = tlsVersions != null ? tlsVersions().toString() : "[all enabled]";
+        return "ConnectionSpec("
+                + "cipherSuites=" + cipherSuitesString
+                + ", tlsVersions=" + tlsVersionsString
+                + ", supportsTlsExtensions=" + supportsTlsExtensions
+                + ")";
     }
 
-    public ConnectionSpec build() {
-      return new ConnectionSpec(this);
+    public static final class Builder {
+        boolean tls;
+        @Nullable
+        String[] cipherSuites;
+        @Nullable
+        String[] tlsVersions;
+        boolean supportsTlsExtensions;
+
+        Builder(boolean tls) {
+            this.tls = tls;
+        }
+
+        public Builder(ConnectionSpec connectionSpec) {
+            this.tls = connectionSpec.tls;
+            this.cipherSuites = connectionSpec.cipherSuites;
+            this.tlsVersions = connectionSpec.tlsVersions;
+            this.supportsTlsExtensions = connectionSpec.supportsTlsExtensions;
+        }
+
+        public Builder allEnabledCipherSuites() {
+            if (!tls) throw new IllegalStateException("no cipher suites for cleartext connections");
+            this.cipherSuites = null;
+            return this;
+        }
+
+        public Builder cipherSuites(CipherSuite... cipherSuites) {
+            if (!tls) throw new IllegalStateException("no cipher suites for cleartext connections");
+
+            String[] strings = new String[cipherSuites.length];
+            for (int i = 0; i < cipherSuites.length; i++) {
+                strings[i] = cipherSuites[i].javaName;
+            }
+            return cipherSuites(strings);
+        }
+
+        public Builder cipherSuites(String... cipherSuites) {
+            if (!tls) throw new IllegalStateException("no cipher suites for cleartext connections");
+
+            if (cipherSuites.length == 0) {
+                throw new IllegalArgumentException("At least one cipher suite is required");
+            }
+
+            this.cipherSuites = cipherSuites.clone(); // Defensive copy.
+            return this;
+        }
+
+        public Builder allEnabledTlsVersions() {
+            if (!tls) throw new IllegalStateException("no TLS versions for cleartext connections");
+            this.tlsVersions = null;
+            return this;
+        }
+
+        public Builder tlsVersions(TlsVersion... tlsVersions) {
+            if (!tls) throw new IllegalStateException("no TLS versions for cleartext connections");
+
+            String[] strings = new String[tlsVersions.length];
+            for (int i = 0; i < tlsVersions.length; i++) {
+                strings[i] = tlsVersions[i].javaName;
+            }
+
+            return tlsVersions(strings);
+        }
+
+        public Builder tlsVersions(String... tlsVersions) {
+            if (!tls) throw new IllegalStateException("no TLS versions for cleartext connections");
+
+            if (tlsVersions.length == 0) {
+                throw new IllegalArgumentException("At least one TLS version is required");
+            }
+
+            this.tlsVersions = tlsVersions.clone(); // Defensive copy.
+            return this;
+        }
+
+        public Builder supportsTlsExtensions(boolean supportsTlsExtensions) {
+            if (!tls)
+                throw new IllegalStateException("no TLS extensions for cleartext connections");
+            this.supportsTlsExtensions = supportsTlsExtensions;
+            return this;
+        }
+
+        public ConnectionSpec build() {
+            return new ConnectionSpec(this);
+        }
     }
-  }
 }
diff --git a/okhttp/src/main/java/okhttp3/Dispatcher.java b/okhttp/src/main/java/okhttp3/Dispatcher.java
index c405f9609f..e24a2b8438 100644
--- a/okhttp/src/main/java/okhttp3/Dispatcher.java
+++ b/okhttp/src/main/java/okhttp3/Dispatcher.java
@@ -25,249 +25,275 @@
 import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
+
 import javax.annotation.Nullable;
+
 import okhttp3.RealCall.AsyncCall;
 import okhttp3.internal.Util;
 
 /**
  * Policy on when async requests are executed.
- *
+ * <p>
  * <p>Each dispatcher uses an {@link ExecutorService} to run calls internally. If you supply your
  * own executor, it should be able to run {@linkplain #getMaxRequests the configured maximum} number
  * of calls concurrently.
  */
 public final class Dispatcher {
-  private int maxRequests = 64;
-  private int maxRequestsPerHost = 5;
-  private @Nullable Runnable idleCallback;
-
-  /** Executes calls. Created lazily. */
-  private @Nullable ExecutorService executorService;
-
-  /** Ready async calls in the order they'll be run. */
-  private final Deque<AsyncCall> readyAsyncCalls = new ArrayDeque<>();
-
-  /** Running asynchronous calls. Includes canceled calls that haven't finished yet. */
-  private final Deque<AsyncCall> runningAsyncCalls = new ArrayDeque<>();
-
-  /** Running synchronous calls. Includes canceled calls that haven't finished yet. */
-  private final Deque<RealCall> runningSyncCalls = new ArrayDeque<>();
+    private int maxRequests = 64;
+    private int maxRequestsPerHost = 5;
+    private @Nullable
+    Runnable idleCallback;
 
-  public Dispatcher(ExecutorService executorService) {
-    this.executorService = executorService;
-  }
+    /**
+     * Executes calls. Created lazily.
+     */
+    private @Nullable
+    ExecutorService executorService;
+
+    /**
+     * Ready async calls in the order they'll be run.
+     * 准备运行的异步请求
+     */
+    private final Deque<AsyncCall> readyAsyncCalls = new ArrayDeque<>();
+
+    /**
+     * Running asynchronous calls. Includes canceled calls that haven't finished yet.
+     * 正在运行的异步请求
+     */
+    private final Deque<AsyncCall> runningAsyncCalls = new ArrayDeque<>();
+
+    /**
+     * Running synchronous calls. Includes canceled calls that haven't finished yet.
+     * 正在运行的同步请求
+     */
+    private final Deque<RealCall> runningSyncCalls = new ArrayDeque<>();
+
+    public Dispatcher(ExecutorService executorService) {
+        this.executorService = executorService;
+    }
 
-  public Dispatcher() {
-  }
+    public Dispatcher() {
+    }
 
-  public synchronized ExecutorService executorService() {
-    if (executorService == null) {
-      executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,
-          new SynchronousQueue<Runnable>(), Util.threadFactory("OkHttp Dispatcher", false));
+    public synchronized ExecutorService executorService() {
+        if (executorService == null) {
+            executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,
+                    new SynchronousQueue<Runnable>(), Util.threadFactory("OkHttp Dispatcher", false));
+        }
+        return executorService;
     }
-    return executorService;
-  }
-
-  /**
-   * Set the maximum number of requests to execute concurrently. Above this requests queue in
-   * memory, waiting for the running calls to complete.
-   *
-   * <p>If more than {@code maxRequests} requests are in flight when this is invoked, those requests
-   * will remain in flight.
-   */
-  public void setMaxRequests(int maxRequests) {
-    if (maxRequests < 1) {
-      throw new IllegalArgumentException("max < 1: " + maxRequests);
+
+    /**
+     * Set the maximum number of requests to execute concurrently. Above this requests queue in
+     * memory, waiting for the running calls to complete.
+     * <p>
+     * <p>If more than {@code maxRequests} requests are in flight when this is invoked, those requests
+     * will remain in flight.
+     */
+    public void setMaxRequests(int maxRequests) {
+        if (maxRequests < 1) {
+            throw new IllegalArgumentException("max < 1: " + maxRequests);
+        }
+        synchronized (this) {
+            this.maxRequests = maxRequests;
+        }
+        promoteAndExecute();
     }
-    synchronized (this) {
-      this.maxRequests = maxRequests;
+
+    public synchronized int getMaxRequests() {
+        return maxRequests;
     }
-    promoteAndExecute();
-  }
-
-  public synchronized int getMaxRequests() {
-    return maxRequests;
-  }
-
-  /**
-   * Set the maximum number of requests for each host to execute concurrently. This limits requests
-   * by the URL's host name. Note that concurrent requests to a single IP address may still exceed
-   * this limit: multiple hostnames may share an IP address or be routed through the same HTTP
-   * proxy.
-   *
-   * <p>If more than {@code maxRequestsPerHost} requests are in flight when this is invoked, those
-   * requests will remain in flight.
-   *
-   * <p>WebSocket connections to hosts <b>do not</b> count against this limit.
-   */
-  public void setMaxRequestsPerHost(int maxRequestsPerHost) {
-    if (maxRequestsPerHost < 1) {
-      throw new IllegalArgumentException("max < 1: " + maxRequestsPerHost);
+
+    /**
+     * Set the maximum number of requests for each host to execute concurrently. This limits requests
+     * by the URL's host name. Note that concurrent requests to a single IP address may still exceed
+     * this limit: multiple hostnames may share an IP address or be routed through the same HTTP
+     * proxy.
+     * <p>
+     * <p>If more than {@code maxRequestsPerHost} requests are in flight when this is invoked, those
+     * requests will remain in flight.
+     * <p>
+     * <p>WebSocket connections to hosts <b>do not</b> count against this limit.
+     */
+    public void setMaxRequestsPerHost(int maxRequestsPerHost) {
+        if (maxRequestsPerHost < 1) {
+            throw new IllegalArgumentException("max < 1: " + maxRequestsPerHost);
+        }
+        synchronized (this) {
+            this.maxRequestsPerHost = maxRequestsPerHost;
+        }
+        promoteAndExecute();
     }
-    synchronized (this) {
-      this.maxRequestsPerHost = maxRequestsPerHost;
+
+    public synchronized int getMaxRequestsPerHost() {
+        return maxRequestsPerHost;
     }
-    promoteAndExecute();
-  }
-
-  public synchronized int getMaxRequestsPerHost() {
-    return maxRequestsPerHost;
-  }
-
-  /**
-   * Set a callback to be invoked each time the dispatcher becomes idle (when the number of running
-   * calls returns to zero).
-   *
-   * <p>Note: The time at which a {@linkplain Call call} is considered idle is different depending
-   * on whether it was run {@linkplain Call#enqueue(Callback) asynchronously} or
-   * {@linkplain Call#execute() synchronously}. Asynchronous calls become idle after the
-   * {@link Callback#onResponse onResponse} or {@link Callback#onFailure onFailure} callback has
-   * returned. Synchronous calls become idle once {@link Call#execute() execute()} returns. This
-   * means that if you are doing synchronous calls the network layer will not truly be idle until
-   * every returned {@link Response} has been closed.
-   */
-  public synchronized void setIdleCallback(@Nullable Runnable idleCallback) {
-    this.idleCallback = idleCallback;
-  }
-
-  void enqueue(AsyncCall call) {
-    synchronized (this) {
-      // 将 call加入到 readyAsyncCalls队列当中
-      readyAsyncCalls.add(call);
+
+    /**
+     * Set a callback to be invoked each time the dispatcher becomes idle (when the number of running
+     * calls returns to zero).
+     * <p>
+     * <p>Note: The time at which a {@linkplain Call call} is considered idle is different depending
+     * on whether it was run {@linkplain Call#enqueue(Callback) asynchronously} or
+     * {@linkplain Call#execute() synchronously}. Asynchronous calls become idle after the
+     * {@link Callback#onResponse onResponse} or {@link Callback#onFailure onFailure} callback has
+     * returned. Synchronous calls become idle once {@link Call#execute() execute()} returns. This
+     * means that if you are doing synchronous calls the network layer will not truly be idle until
+     * every returned {@link Response} has been closed.
+     */
+    public synchronized void setIdleCallback(@Nullable Runnable idleCallback) {
+        this.idleCallback = idleCallback;
     }
-    promoteAndExecute();
-  }
-
-  /**
-   * Cancel all calls currently enqueued or executing. Includes calls executed both {@linkplain
-   * Call#execute() synchronously} and {@linkplain Call#enqueue asynchronously}.
-   */
-  public synchronized void cancelAll() {
-    for (AsyncCall call : readyAsyncCalls) {
-      call.get().cancel();
+
+    void enqueue(AsyncCall call) {
+        synchronized (this) {
+            // 将 call加入到 readyAsyncCalls队列当中
+            readyAsyncCalls.add(call);
+        }
+        promoteAndExecute();
     }
 
-    for (AsyncCall call : runningAsyncCalls) {
-      call.get().cancel();
+    /**
+     * Cancel all calls currently enqueued or executing. Includes calls executed both {@linkplain
+     * Call#execute() synchronously} and {@linkplain Call#enqueue asynchronously}.
+     */
+    public synchronized void cancelAll() {
+        for (AsyncCall call : readyAsyncCalls) {
+            call.get().cancel();
+        }
+
+        for (AsyncCall call : runningAsyncCalls) {
+            call.get().cancel();
+        }
+
+        for (RealCall call : runningSyncCalls) {
+            call.cancel();
+        }
     }
 
-    for (RealCall call : runningSyncCalls) {
-      call.cancel();
+    /**
+     * Promotes eligible calls from {@link #readyAsyncCalls} to {@link #runningAsyncCalls} and runs
+     * them on the executor service. Must not be called with synchronization because executing calls
+     * can call into user code.
+     *
+     * @return true if the dispatcher is currently running calls.
+     */
+    private boolean promoteAndExecute() {
+        assert (!Thread.holdsLock(this));
+
+        List<AsyncCall> executableCalls = new ArrayList<>();
+        boolean isRunning;
+        synchronized (this) {
+            // 遍历 readyAsyncCalls
+            for (Iterator<AsyncCall> i = readyAsyncCalls.iterator(); i.hasNext(); ) {
+                AsyncCall asyncCall = i.next();
+
+                // 如果 runningAsyncCalls的size大于最大请求数，则直接跳出循环，不再遍历readyAsyncCalls
+                if (runningAsyncCalls.size() >= maxRequests) break; // Max capacity.
+
+                // 如果 该asyncCall所运行的主机上运行的请求数 大于 最大主机请求数，那么跳过执行该请求
+                if (runningCallsForHost(asyncCall) >= maxRequestsPerHost)
+                    continue; // Host max capacity.
+
+                // 将该请求从 readyAsyncCalls队列中删除
+                i.remove();
+                // 将该请求加入到 executableCalls
+                executableCalls.add(asyncCall);
+
+                // 将该请求加入到 runningAsyncCalls中
+                runningAsyncCalls.add(asyncCall);
+            }
+
+            // runningAsyncCalls.size() + runningSyncCalls.size()
+            isRunning = runningCallsCount() > 0;
+        }
+
+        // 遍历 executableCalls，将其中的请求对象AsyncCall放入线程池中执行
+        for (int i = 0, size = executableCalls.size(); i < size; i++) {
+            AsyncCall asyncCall = executableCalls.get(i);
+            asyncCall.executeOn(executorService());
+        }
+
+        return isRunning;
     }
-  }
-
-  /**
-   * Promotes eligible calls from {@link #readyAsyncCalls} to {@link #runningAsyncCalls} and runs
-   * them on the executor service. Must not be called with synchronization because executing calls
-   * can call into user code.
-   *
-   * @return true if the dispatcher is currently running calls.
-   */
-  private boolean promoteAndExecute() {
-    assert (!Thread.holdsLock(this));
-
-    List<AsyncCall> executableCalls = new ArrayList<>();
-    boolean isRunning;
-    synchronized (this) {
-      // 遍历 readyAsyncCalls
-      for (Iterator<AsyncCall> i = readyAsyncCalls.iterator(); i.hasNext(); ) {
-        AsyncCall asyncCall = i.next();
-
-        // 如果 runningAsyncCalls的size大于最大请求数，则直接跳出循环，不再遍历readyAsyncCalls
-        if (runningAsyncCalls.size() >= maxRequests) break; // Max capacity.
-
-        // 如果 该asyncCall所运行的主机上运行的请求数 大于 最大主机请求数，那么跳过执行该请求
-        if (runningCallsForHost(asyncCall) >= maxRequestsPerHost) continue; // Host max capacity.
-
-        // 将该请求从 readyAsyncCalls队列中删除
-        i.remove();
-        // 将该请求加入到 executableCalls
-        executableCalls.add(asyncCall);
-
-        // 将该请求加入到 runningAsyncCalls中
-        runningAsyncCalls.add(asyncCall);
-      }
-
-      // runningAsyncCalls.size() + runningSyncCalls.size()
-      isRunning = runningCallsCount() > 0;
+
+    /**
+     * Returns the number of running calls that share a host with {@code call}.
+     * 返回该主机上运行的请求书
+     */
+    private int runningCallsForHost(AsyncCall call) {
+        int result = 0;
+        for (AsyncCall c : runningAsyncCalls) {
+            if (c.get().forWebSocket) continue;
+            if (c.host().equals(call.host())) result++;
+        }
+        return result;
     }
 
-    // 遍历 executableCalls，将其中的请求对象AsyncCall放入线程池中执行
-    for (int i = 0, size = executableCalls.size(); i < size; i++) {
-      AsyncCall asyncCall = executableCalls.get(i);
-      asyncCall.executeOn(executorService());
+    /**
+     * Used by {@code Call#execute} to signal it is in-flight.
+     * 调用该方法，将RealCall对象加入到 runningSyncCalls中
+     */
+    synchronized void executed(RealCall call) {
+        runningSyncCalls.add(call);
     }
 
-    return isRunning;
-  }
-
-  /** Returns the number of running calls that share a host with {@code call}.
-   * 返回该主机上运行的请求书
-   * */
-  private int runningCallsForHost(AsyncCall call) {
-    int result = 0;
-    for (AsyncCall c : runningAsyncCalls) {
-      if (c.get().forWebSocket) continue;
-      if (c.host().equals(call.host())) result++;
+    /**
+     * Used by {@code AsyncCall#run} to signal completion.
+     */
+    void finished(AsyncCall call) {
+        finished(runningAsyncCalls, call);
     }
-    return result;
-  }
-
-  /** Used by {@code Call#execute} to signal it is in-flight.
-   * 调用该方法，将RealCall对象加入到 runningSyncCalls中
-   * */
-  synchronized void executed(RealCall call) {
-    runningSyncCalls.add(call);
-  }
-
-  /** Used by {@code AsyncCall#run} to signal completion. */
-  void finished(AsyncCall call) {
-    finished(runningAsyncCalls, call);
-  }
-
-  /** Used by {@code Call#execute} to signal completion. */
-  void finished(RealCall call) {
-    finished(runningSyncCalls, call);
-  }
-
-  private <T> void finished(Deque<T> calls, T call) {
-    Runnable idleCallback;
-    synchronized (this) {
-      if (!calls.remove(call)) throw new AssertionError("Call wasn't in-flight!");
-      idleCallback = this.idleCallback;
+
+    /**
+     * Used by {@code Call#execute} to signal completion.
+     */
+    void finished(RealCall call) {
+        finished(runningSyncCalls, call);
     }
 
-    boolean isRunning = promoteAndExecute();
+    private <T> void finished(Deque<T> calls, T call) {
+        Runnable idleCallback;
+        synchronized (this) {
+            if (!calls.remove(call)) throw new AssertionError("Call wasn't in-flight!");
+            idleCallback = this.idleCallback;
+        }
+
+        boolean isRunning = promoteAndExecute();
 
-    if (!isRunning && idleCallback != null) {
-      idleCallback.run();
+        if (!isRunning && idleCallback != null) {
+            idleCallback.run();
+        }
     }
-  }
 
-  /** Returns a snapshot of the calls currently awaiting execution. */
-  public synchronized List<Call> queuedCalls() {
-    List<Call> result = new ArrayList<>();
-    for (AsyncCall asyncCall : readyAsyncCalls) {
-      result.add(asyncCall.get());
+    /**
+     * Returns a snapshot of the calls currently awaiting execution.
+     */
+    public synchronized List<Call> queuedCalls() {
+        List<Call> result = new ArrayList<>();
+        for (AsyncCall asyncCall : readyAsyncCalls) {
+            result.add(asyncCall.get());
+        }
+        return Collections.unmodifiableList(result);
     }
-    return Collections.unmodifiableList(result);
-  }
-
-  /** Returns a snapshot of the calls currently being executed. */
-  public synchronized List<Call> runningCalls() {
-    List<Call> result = new ArrayList<>();
-    result.addAll(runningSyncCalls);
-    for (AsyncCall asyncCall : runningAsyncCalls) {
-      result.add(asyncCall.get());
+
+    /**
+     * Returns a snapshot of the calls currently being executed.
+     */
+    public synchronized List<Call> runningCalls() {
+        List<Call> result = new ArrayList<>();
+        result.addAll(runningSyncCalls);
+        for (AsyncCall asyncCall : runningAsyncCalls) {
+            result.add(asyncCall.get());
+        }
+        return Collections.unmodifiableList(result);
     }
-    return Collections.unmodifiableList(result);
-  }
 
-  public synchronized int queuedCallsCount() {
-    return readyAsyncCalls.size();
-  }
+    public synchronized int queuedCallsCount() {
+        return readyAsyncCalls.size();
+    }
 
-  public synchronized int runningCallsCount() {
-    return runningAsyncCalls.size() + runningSyncCalls.size();
-  }
+    public synchronized int runningCallsCount() {
+        return runningAsyncCalls.size() + runningSyncCalls.size();
+    }
 }
diff --git a/okhttp/src/main/java/okhttp3/OkHttpClient.java b/okhttp/src/main/java/okhttp3/OkHttpClient.java
index c86d3b3456..37fcae1df6 100644
--- a/okhttp/src/main/java/okhttp3/OkHttpClient.java
+++ b/okhttp/src/main/java/okhttp3/OkHttpClient.java
@@ -27,6 +27,7 @@
 import java.util.Random;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.TimeUnit;
+
 import javax.annotation.Nullable;
 import javax.net.SocketFactory;
 import javax.net.ssl.HostnameVerifier;
@@ -35,6 +36,7 @@
 import javax.net.ssl.SSLSocketFactory;
 import javax.net.ssl.TrustManager;
 import javax.net.ssl.X509TrustManager;
+
 import okhttp3.internal.Internal;
 import okhttp3.internal.Util;
 import okhttp3.internal.cache.InternalCache;
@@ -48,6 +50,7 @@
 import okhttp3.internal.ws.RealWebSocket;
 import okio.Sink;
 import okio.Source;
+
 import org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement;
 
 import static okhttp3.internal.Util.assertionError;
@@ -56,21 +59,21 @@
 /**
  * Factory for {@linkplain Call calls}, which can be used to send HTTP requests and read their
  * responses.
- *
+ * <p>
  * <h3>OkHttpClients should be shared</h3>
- *
+ * <p>
  * <p>OkHttp performs best when you create a single {@code OkHttpClient} instance and reuse it for
  * all of your HTTP calls. This is because each client holds its own connection pool and thread
  * pools. Reusing connections and threads reduces latency and saves memory. Conversely, creating a
  * client for each request wastes resources on idle pools.
- *
+ * <p>
  * <p>Use {@code new OkHttpClient()} to create a shared instance with the default settings:
  * <pre>   {@code
  *
  *   // The singleton HTTP client.
  *   public final OkHttpClient client = new OkHttpClient();
  * }</pre>
- *
+ * <p>
  * <p>Or use {@code new OkHttpClient.Builder()} to create a shared instance with custom settings:
  * <pre>   {@code
  *
@@ -80,967 +83,1059 @@
  *       .cache(new Cache(cacheDir, cacheSize))
  *       .build();
  * }</pre>
- *
+ * <p>
  * <h3>Customize your client with newBuilder()</h3>
- *
+ * <p>
  * <p>You can customize a shared OkHttpClient instance with {@link #newBuilder()}. This builds a
  * client that shares the same connection pool, thread pools, and configuration. Use the builder
  * methods to configure the derived client for a specific purpose.
- *
+ * <p>
  * <p>This example shows a call with a short 500 millisecond timeout: <pre>   {@code
- *
+ * <p>
  *   OkHttpClient eagerClient = client.newBuilder()
  *       .readTimeout(500, TimeUnit.MILLISECONDS)
  *       .build();
  *   Response response = eagerClient.newCall(request).execute();
  * }</pre>
- *
+ * <p>
  * <h3>Shutdown isn't necessary</h3>
- *
+ * <p>
  * <p>The threads and connections that are held will be released automatically if they remain idle.
  * But if you are writing a application that needs to aggressively release unused resources you may
  * do so.
- *
+ * <p>
  * <p>Shutdown the dispatcher's executor service with {@link ExecutorService#shutdown shutdown()}.
  * This will also cause future calls to the client to be rejected. <pre>   {@code
- *
+ * <p>
  *     client.dispatcher().executorService().shutdown();
  * }</pre>
- *
+ * <p>
  * <p>Clear the connection pool with {@link ConnectionPool#evictAll() evictAll()}. Note that the
  * connection pool's daemon thread may not exit immediately. <pre>   {@code
- *
+ * <p>
  *     client.connectionPool().evictAll();
  * }</pre>
- *
+ * <p>
  * <p>If your client has a cache, call {@link Cache#close close()}. Note that it is an error to
  * create calls against a cache that is closed, and doing so will cause the call to crash.
  * <pre>   {@code
  *
  *     client.cache().close();
  * }</pre>
- *
+ * <p>
  * <p>OkHttp also uses daemon threads for HTTP/2 connections. These will exit automatically if they
  * remain idle.
  */
 public class OkHttpClient implements Cloneable, Call.Factory, WebSocket.Factory {
-  static final List<Protocol> DEFAULT_PROTOCOLS = Util.immutableList(
-      Protocol.HTTP_2, Protocol.HTTP_1_1);
-
-  static final List<ConnectionSpec> DEFAULT_CONNECTION_SPECS = Util.immutableList(
-      ConnectionSpec.MODERN_TLS, ConnectionSpec.CLEARTEXT);
-
-  static {
-    Internal.instance = new Internal() {
-      @Override public void addLenient(Headers.Builder builder, String line) {
-        builder.addLenient(line);
-      }
-
-      @Override public void addLenient(Headers.Builder builder, String name, String value) {
-        builder.addLenient(name, value);
-      }
-
-      @Override public void setCache(OkHttpClient.Builder builder, InternalCache internalCache) {
-        builder.setInternalCache(internalCache);
-      }
-
-      @Override public boolean connectionBecameIdle(
-          ConnectionPool pool, RealConnection connection) {
-        return pool.connectionBecameIdle(connection);
-      }
-
-      @Override public RealConnection get(ConnectionPool pool, Address address,
-          StreamAllocation streamAllocation, Route route) {
-        return pool.get(address, streamAllocation, route);
-      }
-
-      @Override public boolean equalsNonHost(Address a, Address b) {
-        return a.equalsNonHost(b);
-      }
-
-      @Override public Socket deduplicate(
-          ConnectionPool pool, Address address, StreamAllocation streamAllocation) {
-        return pool.deduplicate(address, streamAllocation);
-      }
-
-      @Override public void put(ConnectionPool pool, RealConnection connection) {
-        pool.put(connection);
-      }
-
-      @Override public RouteDatabase routeDatabase(ConnectionPool connectionPool) {
-        return connectionPool.routeDatabase;
-      }
-
-      @Override public int code(Response.Builder responseBuilder) {
-        return responseBuilder.code;
-      }
-
-      @Override
-      public void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket, boolean isFallback) {
-        tlsConfiguration.apply(sslSocket, isFallback);
-      }
-
-      @Override public boolean isInvalidHttpUrlHost(IllegalArgumentException e) {
-        return e.getMessage().startsWith(HttpUrl.Builder.INVALID_HOST);
-      }
-
-      @Override public StreamAllocation streamAllocation(Call call) {
-        return ((RealCall) call).streamAllocation();
-      }
-
-      @Override public @Nullable IOException timeoutExit(Call call, @Nullable IOException e) {
-        return ((RealCall) call).timeoutExit(e);
-      }
-
-      @Override public Call newWebSocketCall(OkHttpClient client, Request originalRequest) {
-        return RealCall.newRealCall(client, originalRequest, true);
-      }
-    };
-  }
-
-  final Dispatcher dispatcher;
-  final @Nullable Proxy proxy;
-  final List<Protocol> protocols;
-  final List<ConnectionSpec> connectionSpecs;
-  final List<Interceptor> interceptors;
-  final List<Interceptor> networkInterceptors;
-  final EventListener.Factory eventListenerFactory;
-  final ProxySelector proxySelector;
-  final CookieJar cookieJar;
-  final @Nullable Cache cache;
-  final @Nullable InternalCache internalCache;
-  final SocketFactory socketFactory;
-  final SSLSocketFactory sslSocketFactory;
-  final CertificateChainCleaner certificateChainCleaner;
-  final HostnameVerifier hostnameVerifier;
-  final CertificatePinner certificatePinner;
-  final Authenticator proxyAuthenticator;
-  final Authenticator authenticator;
-  final ConnectionPool connectionPool;
-  final Dns dns;
-  final boolean followSslRedirects;
-  final boolean followRedirects;
-  final boolean retryOnConnectionFailure;
-  final int callTimeout;
-  final int connectTimeout;
-  final int readTimeout;
-  final int writeTimeout;
-  final int pingInterval;
-
-  public OkHttpClient() {
-    this(new Builder());
-  }
-
-  OkHttpClient(Builder builder) {
-    this.dispatcher = builder.dispatcher;
-    this.proxy = builder.proxy;
-    this.protocols = builder.protocols;
-    this.connectionSpecs = builder.connectionSpecs;
-    this.interceptors = Util.immutableList(builder.interceptors);
-    this.networkInterceptors = Util.immutableList(builder.networkInterceptors);
-    this.eventListenerFactory = builder.eventListenerFactory;
-    this.proxySelector = builder.proxySelector;
-    this.cookieJar = builder.cookieJar;
-    this.cache = builder.cache;
-    this.internalCache = builder.internalCache;
-    this.socketFactory = builder.socketFactory;
-
-    boolean isTLS = false;
-    for (ConnectionSpec spec : connectionSpecs) {
-      isTLS = isTLS || spec.isTls();
-    }
-
-    if (builder.sslSocketFactory != null || !isTLS) {
-      this.sslSocketFactory = builder.sslSocketFactory;
-      this.certificateChainCleaner = builder.certificateChainCleaner;
-    } else {
-      X509TrustManager trustManager = Util.platformTrustManager();
-      this.sslSocketFactory = newSslSocketFactory(trustManager);
-      this.certificateChainCleaner = CertificateChainCleaner.get(trustManager);
-    }
-
-    if (sslSocketFactory != null) {
-      Platform.get().configureSslSocketFactory(sslSocketFactory);
-    }
-
-    this.hostnameVerifier = builder.hostnameVerifier;
-    this.certificatePinner = builder.certificatePinner.withCertificateChainCleaner(
-        certificateChainCleaner);
-    this.proxyAuthenticator = builder.proxyAuthenticator;
-    this.authenticator = builder.authenticator;
-    this.connectionPool = builder.connectionPool;
-    this.dns = builder.dns;
-    this.followSslRedirects = builder.followSslRedirects;
-    this.followRedirects = builder.followRedirects;
-    this.retryOnConnectionFailure = builder.retryOnConnectionFailure;
-    this.callTimeout = builder.callTimeout;
-    this.connectTimeout = builder.connectTimeout;
-    this.readTimeout = builder.readTimeout;
-    this.writeTimeout = builder.writeTimeout;
-    this.pingInterval = builder.pingInterval;
-
-    if (interceptors.contains(null)) {
-      throw new IllegalStateException("Null interceptor: " + interceptors);
-    }
-    if (networkInterceptors.contains(null)) {
-      throw new IllegalStateException("Null network interceptor: " + networkInterceptors);
-    }
-  }
-
-  private static SSLSocketFactory newSslSocketFactory(X509TrustManager trustManager) {
-    try {
-      SSLContext sslContext = Platform.get().getSSLContext();
-      sslContext.init(null, new TrustManager[] { trustManager }, null);
-      return sslContext.getSocketFactory();
-    } catch (GeneralSecurityException e) {
-      throw assertionError("No System TLS", e); // The system has no TLS. Just give up.
-    }
-  }
-
-  /** Default call timeout (in milliseconds). */
-  public int callTimeoutMillis() {
-    return callTimeout;
-  }
-
-  /** Default connect timeout (in milliseconds). */
-  public int connectTimeoutMillis() {
-    return connectTimeout;
-  }
-
-  /** Default read timeout (in milliseconds). */
-  public int readTimeoutMillis() {
-    return readTimeout;
-  }
-
-  /** Default write timeout (in milliseconds). */
-  public int writeTimeoutMillis() {
-    return writeTimeout;
-  }
-
-  /** Web socket ping interval (in milliseconds). */
-  public int pingIntervalMillis() {
-    return pingInterval;
-  }
-
-  public @Nullable Proxy proxy() {
-    return proxy;
-  }
-
-  public ProxySelector proxySelector() {
-    return proxySelector;
-  }
-
-  public CookieJar cookieJar() {
-    return cookieJar;
-  }
-
-  public @Nullable Cache cache() {
-    return cache;
-  }
-
-  InternalCache internalCache() {
-    return cache != null ? cache.internalCache : internalCache;
-  }
-
-  public Dns dns() {
-    return dns;
-  }
-
-  public SocketFactory socketFactory() {
-    return socketFactory;
-  }
-
-  public SSLSocketFactory sslSocketFactory() {
-    return sslSocketFactory;
-  }
-
-  public HostnameVerifier hostnameVerifier() {
-    return hostnameVerifier;
-  }
-
-  public CertificatePinner certificatePinner() {
-    return certificatePinner;
-  }
-
-  public Authenticator authenticator() {
-    return authenticator;
-  }
-
-  public Authenticator proxyAuthenticator() {
-    return proxyAuthenticator;
-  }
-
-  public ConnectionPool connectionPool() {
-    return connectionPool;
-  }
-
-  public boolean followSslRedirects() {
-    return followSslRedirects;
-  }
-
-  public boolean followRedirects() {
-    return followRedirects;
-  }
-
-  public boolean retryOnConnectionFailure() {
-    return retryOnConnectionFailure;
-  }
-
-  public Dispatcher dispatcher() {
-    return dispatcher;
-  }
-
-  public List<Protocol> protocols() {
-    return protocols;
-  }
-
-  public List<ConnectionSpec> connectionSpecs() {
-    return connectionSpecs;
-  }
-
-  /**
-   * Returns an immutable list of interceptors that observe the full span of each call: from before
-   * the connection is established (if any) until after the response source is selected (either the
-   * origin server, cache, or both).
-   */
-  public List<Interceptor> interceptors() {
-    return interceptors;
-  }
-
-  /**
-   * Returns an immutable list of interceptors that observe a single network request and response.
-   * These interceptors must call {@link Interceptor.Chain#proceed} exactly once: it is an error for
-   * a network interceptor to short-circuit or repeat a network request.
-   */
-  public List<Interceptor> networkInterceptors() {
-    return networkInterceptors;
-  }
-
-  public EventListener.Factory eventListenerFactory() {
-    return eventListenerFactory;
-  }
-
-  /**
-   * Prepares the {@code request} to be executed at some point in the future.
-   */
-  @Override public Call newCall(Request request) {
-    return RealCall.newRealCall(this, request, false /* for web socket */);
-  }
-
-  /**
-   * Uses {@code request} to connect a new web socket.
-   */
-  @Override public WebSocket newWebSocket(Request request, WebSocketListener listener) {
-    RealWebSocket webSocket = new RealWebSocket(request, listener, new Random(), pingInterval);
-    webSocket.connect(this);
-    return webSocket;
-  }
-
-  public Builder newBuilder() {
-    return new Builder(this);
-  }
-
-  public static final class Builder {
-    Dispatcher dispatcher;
-    @Nullable Proxy proxy;
-    List<Protocol> protocols;
-    List<ConnectionSpec> connectionSpecs;
-    final List<Interceptor> interceptors = new ArrayList<>();
-    final List<Interceptor> networkInterceptors = new ArrayList<>();
-    EventListener.Factory eventListenerFactory;
-    ProxySelector proxySelector;
-    CookieJar cookieJar;
-    @Nullable Cache cache;
-    @Nullable InternalCache internalCache;
-    SocketFactory socketFactory;
-    @Nullable SSLSocketFactory sslSocketFactory;
-    @Nullable CertificateChainCleaner certificateChainCleaner;
-    HostnameVerifier hostnameVerifier;
-    CertificatePinner certificatePinner;
-    Authenticator proxyAuthenticator;
-    Authenticator authenticator;
-    ConnectionPool connectionPool;
-    Dns dns;
-    boolean followSslRedirects;
-    boolean followRedirects;
-    boolean retryOnConnectionFailure;
-    int callTimeout;
-    int connectTimeout;
-    int readTimeout;
-    int writeTimeout;
-    int pingInterval;
-
-    public Builder() {
-      dispatcher = new Dispatcher();
-      protocols = DEFAULT_PROTOCOLS;
-      connectionSpecs = DEFAULT_CONNECTION_SPECS;
-      eventListenerFactory = EventListener.factory(EventListener.NONE);
-      proxySelector = ProxySelector.getDefault();
-      if (proxySelector == null) {
-        proxySelector = new NullProxySelector();
-      }
-      cookieJar = CookieJar.NO_COOKIES;
-      socketFactory = SocketFactory.getDefault();
-      hostnameVerifier = OkHostnameVerifier.INSTANCE;
-      certificatePinner = CertificatePinner.DEFAULT;
-      proxyAuthenticator = Authenticator.NONE;
-      authenticator = Authenticator.NONE;
-      connectionPool = new ConnectionPool();
-      dns = Dns.SYSTEM;
-      followSslRedirects = true;
-      followRedirects = true;
-      retryOnConnectionFailure = true;
-      callTimeout = 0;
-      connectTimeout = 10_000;
-      readTimeout = 10_000;
-      writeTimeout = 10_000;
-      pingInterval = 0;
-    }
-
-    Builder(OkHttpClient okHttpClient) {
-      this.dispatcher = okHttpClient.dispatcher;
-      this.proxy = okHttpClient.proxy;
-      this.protocols = okHttpClient.protocols;
-      this.connectionSpecs = okHttpClient.connectionSpecs;
-      this.interceptors.addAll(okHttpClient.interceptors);
-      this.networkInterceptors.addAll(okHttpClient.networkInterceptors);
-      this.eventListenerFactory = okHttpClient.eventListenerFactory;
-      this.proxySelector = okHttpClient.proxySelector;
-      this.cookieJar = okHttpClient.cookieJar;
-      this.internalCache = okHttpClient.internalCache;
-      this.cache = okHttpClient.cache;
-      this.socketFactory = okHttpClient.socketFactory;
-      this.sslSocketFactory = okHttpClient.sslSocketFactory;
-      this.certificateChainCleaner = okHttpClient.certificateChainCleaner;
-      this.hostnameVerifier = okHttpClient.hostnameVerifier;
-      this.certificatePinner = okHttpClient.certificatePinner;
-      this.proxyAuthenticator = okHttpClient.proxyAuthenticator;
-      this.authenticator = okHttpClient.authenticator;
-      this.connectionPool = okHttpClient.connectionPool;
-      this.dns = okHttpClient.dns;
-      this.followSslRedirects = okHttpClient.followSslRedirects;
-      this.followRedirects = okHttpClient.followRedirects;
-      this.retryOnConnectionFailure = okHttpClient.retryOnConnectionFailure;
-      this.callTimeout = okHttpClient.callTimeout;
-      this.connectTimeout = okHttpClient.connectTimeout;
-      this.readTimeout = okHttpClient.readTimeout;
-      this.writeTimeout = okHttpClient.writeTimeout;
-      this.pingInterval = okHttpClient.pingInterval;
-    }
-
-    /**
-     * Sets the default timeout for complete calls. A value of 0 means no timeout, otherwise values
-     * must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
-     *
-     * <p>The call timeout spans the entire call: resolving DNS, connecting, writing the request
-     * body, server processing, and reading the response body. If the call requires redirects or
-     * retries all must complete within one timeout period.
-     */
-    public Builder callTimeout(long timeout, TimeUnit unit) {
-      callTimeout = checkDuration("timeout", timeout, unit);
-      return this;
-    }
-
-    /**
-     * Sets the default timeout for complete calls. A value of 0 means no timeout, otherwise values
-     * must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
-     *
-     * <p>The call timeout spans the entire call: resolving DNS, connecting, writing the request
-     * body, server processing, and reading the response body. If the call requires redirects or
-     * retries all must complete within one timeout period.
-     */
-    @IgnoreJRERequirement
-    public Builder callTimeout(Duration duration) {
-      callTimeout = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS);
-      return this;
-    }
-
-    /**
-     * Sets the default connect timeout for new connections. A value of 0 means no timeout,
-     * otherwise values must be between 1 and {@link Integer#MAX_VALUE} when converted to
-     * milliseconds.
-     *
-     * <p>The connect timeout is applied when connecting a TCP socket to the target host.
-     * The default value is 10 seconds.
-     */
-    public Builder connectTimeout(long timeout, TimeUnit unit) {
-      connectTimeout = checkDuration("timeout", timeout, unit);
-      return this;
+    static final List<Protocol> DEFAULT_PROTOCOLS = Util.immutableList(
+            Protocol.HTTP_2, Protocol.HTTP_1_1);
+
+    static final List<ConnectionSpec> DEFAULT_CONNECTION_SPECS = Util.immutableList(
+            ConnectionSpec.MODERN_TLS, ConnectionSpec.CLEARTEXT);
+
+    static {
+        Internal.instance = new Internal() {
+            @Override
+            public void addLenient(Headers.Builder builder, String line) {
+                builder.addLenient(line);
+            }
+
+            @Override
+            public void addLenient(Headers.Builder builder, String name, String value) {
+                builder.addLenient(name, value);
+            }
+
+            @Override
+            public void setCache(OkHttpClient.Builder builder, InternalCache internalCache) {
+                builder.setInternalCache(internalCache);
+            }
+
+            @Override
+            public boolean connectionBecameIdle(
+                    ConnectionPool pool, RealConnection connection) {
+                return pool.connectionBecameIdle(connection);
+            }
+
+            @Override
+            public RealConnection get(ConnectionPool pool, Address address,
+                                      StreamAllocation streamAllocation, Route route) {
+                return pool.get(address, streamAllocation, route);
+            }
+
+            @Override
+            public boolean equalsNonHost(Address a, Address b) {
+                return a.equalsNonHost(b);
+            }
+
+            @Override
+            public Socket deduplicate(
+                    ConnectionPool pool, Address address, StreamAllocation streamAllocation) {
+                return pool.deduplicate(address, streamAllocation);
+            }
+
+            @Override
+            public void put(ConnectionPool pool, RealConnection connection) {
+                pool.put(connection);
+            }
+
+            @Override
+            public RouteDatabase routeDatabase(ConnectionPool connectionPool) {
+                return connectionPool.routeDatabase;
+            }
+
+            @Override
+            public int code(Response.Builder responseBuilder) {
+                return responseBuilder.code;
+            }
+
+            @Override
+            public void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket, boolean isFallback) {
+                tlsConfiguration.apply(sslSocket, isFallback);
+            }
+
+            @Override
+            public boolean isInvalidHttpUrlHost(IllegalArgumentException e) {
+                return e.getMessage().startsWith(HttpUrl.Builder.INVALID_HOST);
+            }
+
+            @Override
+            public StreamAllocation streamAllocation(Call call) {
+                return ((RealCall) call).streamAllocation();
+            }
+
+            @Override
+            public @Nullable
+            IOException timeoutExit(Call call, @Nullable IOException e) {
+                return ((RealCall) call).timeoutExit(e);
+            }
+
+            @Override
+            public Call newWebSocketCall(OkHttpClient client, Request originalRequest) {
+                return RealCall.newRealCall(client, originalRequest, true);
+            }
+        };
     }
 
-    /**
-     * Sets the default connect timeout for new connections. A value of 0 means no timeout,
-     * otherwise values must be between 1 and {@link Integer#MAX_VALUE} when converted to
-     * milliseconds.
-     *
-     * <p>The connect timeout is applied when connecting a TCP socket to the target host.
-     * The default value is 10 seconds.
-     */
-    @IgnoreJRERequirement
-    public Builder connectTimeout(Duration duration) {
-      connectTimeout = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS);
-      return this;
+    final Dispatcher dispatcher;
+    final @Nullable
+    Proxy proxy;
+    final List<Protocol> protocols;
+    final List<ConnectionSpec> connectionSpecs;
+    final List<Interceptor> interceptors;
+    final List<Interceptor> networkInterceptors;
+    final EventListener.Factory eventListenerFactory;
+    final ProxySelector proxySelector;
+    final CookieJar cookieJar;
+    final @Nullable
+    Cache cache;
+    final @Nullable
+    InternalCache internalCache;
+    final SocketFactory socketFactory;
+    final SSLSocketFactory sslSocketFactory;
+    final CertificateChainCleaner certificateChainCleaner;
+    final HostnameVerifier hostnameVerifier;
+    final CertificatePinner certificatePinner;
+    final Authenticator proxyAuthenticator;
+    final Authenticator authenticator;
+    final ConnectionPool connectionPool;
+    final Dns dns;
+    final boolean followSslRedirects;
+    final boolean followRedirects;
+    final boolean retryOnConnectionFailure;
+    final int callTimeout;
+    final int connectTimeout;
+    final int readTimeout;
+    final int writeTimeout;
+    final int pingInterval;
+
+    public OkHttpClient() {
+        this(new Builder());
     }
 
-    /**
-     * Sets the default read timeout for new connections. A value of 0 means no timeout, otherwise
-     * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
-     *
-     * <p>The read timeout is applied to both the TCP socket and for individual read IO operations
-     * including on {@link Source} of the {@link Response}. The default value is 10 seconds.
-     *
-     * @see Socket#setSoTimeout(int)
-     * @see Source#timeout()
-     */
-    public Builder readTimeout(long timeout, TimeUnit unit) {
-      readTimeout = checkDuration("timeout", timeout, unit);
-      return this;
+    OkHttpClient(Builder builder) {
+        this.dispatcher = builder.dispatcher;
+        this.proxy = builder.proxy;
+        this.protocols = builder.protocols;
+        this.connectionSpecs = builder.connectionSpecs;
+        this.interceptors = Util.immutableList(builder.interceptors);
+        this.networkInterceptors = Util.immutableList(builder.networkInterceptors);
+        this.eventListenerFactory = builder.eventListenerFactory;
+        this.proxySelector = builder.proxySelector;
+        this.cookieJar = builder.cookieJar;
+        this.cache = builder.cache;
+        this.internalCache = builder.internalCache;
+        this.socketFactory = builder.socketFactory;
+
+        boolean isTLS = false;
+        for (ConnectionSpec spec : connectionSpecs) {
+            isTLS = isTLS || spec.isTls();
+        }
+
+        if (builder.sslSocketFactory != null || !isTLS) {
+            this.sslSocketFactory = builder.sslSocketFactory;
+            this.certificateChainCleaner = builder.certificateChainCleaner;
+        } else {
+            X509TrustManager trustManager = Util.platformTrustManager();
+            this.sslSocketFactory = newSslSocketFactory(trustManager);
+            this.certificateChainCleaner = CertificateChainCleaner.get(trustManager);
+        }
+
+        if (sslSocketFactory != null) {
+            Platform.get().configureSslSocketFactory(sslSocketFactory);
+        }
+
+        this.hostnameVerifier = builder.hostnameVerifier;
+        this.certificatePinner = builder.certificatePinner.withCertificateChainCleaner(
+                certificateChainCleaner);
+        this.proxyAuthenticator = builder.proxyAuthenticator;
+        this.authenticator = builder.authenticator;
+        this.connectionPool = builder.connectionPool;
+        this.dns = builder.dns;
+        this.followSslRedirects = builder.followSslRedirects;
+        this.followRedirects = builder.followRedirects;
+        this.retryOnConnectionFailure = builder.retryOnConnectionFailure;
+        this.callTimeout = builder.callTimeout;
+        this.connectTimeout = builder.connectTimeout;
+        this.readTimeout = builder.readTimeout;
+        this.writeTimeout = builder.writeTimeout;
+        this.pingInterval = builder.pingInterval;
+
+        if (interceptors.contains(null)) {
+            throw new IllegalStateException("Null interceptor: " + interceptors);
+        }
+        if (networkInterceptors.contains(null)) {
+            throw new IllegalStateException("Null network interceptor: " + networkInterceptors);
+        }
     }
 
-    /**
-     * Sets the default read timeout for new connections. A value of 0 means no timeout, otherwise
-     * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
-     *
-     * <p>The read timeout is applied to both the TCP socket and for individual read IO operations
-     * including on {@link Source} of the {@link Response}. The default value is 10 seconds.
-     *
-     * @see Socket#setSoTimeout(int)
-     * @see Source#timeout()
-     */
-    @IgnoreJRERequirement
-    public Builder readTimeout(Duration duration) {
-      readTimeout = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS);
-      return this;
+    private static SSLSocketFactory newSslSocketFactory(X509TrustManager trustManager) {
+        try {
+            SSLContext sslContext = Platform.get().getSSLContext();
+            sslContext.init(null, new TrustManager[]{trustManager}, null);
+            return sslContext.getSocketFactory();
+        } catch (GeneralSecurityException e) {
+            throw assertionError("No System TLS", e); // The system has no TLS. Just give up.
+        }
     }
 
     /**
-     * Sets the default write timeout for new connections. A value of 0 means no timeout, otherwise
-     * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
-     *
-     * <p>The write timeout is applied for individual write IO operations.
-     * The default value is 10 seconds.
-     *
-     * @see Sink#timeout()
+     * Default call timeout (in milliseconds).
      */
-    public Builder writeTimeout(long timeout, TimeUnit unit) {
-      writeTimeout = checkDuration("timeout", timeout, unit);
-      return this;
+    public int callTimeoutMillis() {
+        return callTimeout;
     }
 
     /**
-     * Sets the default write timeout for new connections. A value of 0 means no timeout, otherwise
-     * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
-     *
-     * <p>The write timeout is applied for individual write IO operations.
-     * The default value is 10 seconds.
-     *
-     * @see Sink#timeout()
+     * Default connect timeout (in milliseconds).
      */
-    @IgnoreJRERequirement
-    public Builder writeTimeout(Duration duration) {
-      writeTimeout = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS);
-      return this;
+    public int connectTimeoutMillis() {
+        return connectTimeout;
     }
 
     /**
-     * Sets the interval between HTTP/2 and web socket pings initiated by this client. Use this to
-     * automatically send ping frames until either the connection fails or it is closed. This keeps
-     * the connection alive and may detect connectivity failures.
-     *
-     * <p>If the server does not respond to each ping with a pong within {@code interval}, this
-     * client will assume that connectivity has been lost. When this happens on a web socket the
-     * connection is canceled and its listener is {@linkplain WebSocketListener#onFailure notified
-     * of the failure}. When it happens on an HTTP/2 connection the connection is closed and any
-     * calls it is carrying {@linkplain java.io.IOException will fail with an IOException}.
-     *
-     * <p>The default value of 0 disables client-initiated pings.
+     * Default read timeout (in milliseconds).
      */
-    public Builder pingInterval(long interval, TimeUnit unit) {
-      pingInterval = checkDuration("interval", interval, unit);
-      return this;
+    public int readTimeoutMillis() {
+        return readTimeout;
     }
 
     /**
-     * Sets the interval between HTTP/2 and web socket pings initiated by this client. Use this to
-     * automatically send ping frames until either the connection fails or it is closed. This keeps
-     * the connection alive and may detect connectivity failures.
-     *
-     * <p>If the server does not respond to each ping with a pong within {@code interval}, this
-     * client will assume that connectivity has been lost. When this happens on a web socket the
-     * connection is canceled and its listener is {@linkplain WebSocketListener#onFailure notified
-     * of the failure}. When it happens on an HTTP/2 connection the connection is closed and any
-     * calls it is carrying {@linkplain java.io.IOException will fail with an IOException}.
-     *
-     * <p>The default value of 0 disables client-initiated pings.
+     * Default write timeout (in milliseconds).
      */
-    @IgnoreJRERequirement
-    public Builder pingInterval(Duration duration) {
-      pingInterval = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS);
-      return this;
+    public int writeTimeoutMillis() {
+        return writeTimeout;
     }
 
     /**
-     * Sets the HTTP proxy that will be used by connections created by this client. This takes
-     * precedence over {@link #proxySelector}, which is only honored when this proxy is null (which
-     * it is by default). To disable proxy use completely, call {@code proxy(Proxy.NO_PROXY)}.
+     * Web socket ping interval (in milliseconds).
      */
-    public Builder proxy(@Nullable Proxy proxy) {
-      this.proxy = proxy;
-      return this;
+    public int pingIntervalMillis() {
+        return pingInterval;
     }
 
-    /**
-     * Sets the proxy selection policy to be used if no {@link #proxy proxy} is specified
-     * explicitly. The proxy selector may return multiple proxies; in that case they will be tried
-     * in sequence until a successful connection is established.
-     *
-     * <p>If unset, the {@link ProxySelector#getDefault() system-wide default} proxy selector will
-     * be used.
-     */
-    public Builder proxySelector(ProxySelector proxySelector) {
-      if (proxySelector == null) throw new NullPointerException("proxySelector == null");
-      this.proxySelector = proxySelector;
-      return this;
+    public @Nullable
+    Proxy proxy() {
+        return proxy;
     }
 
-    /**
-     * Sets the handler that can accept cookies from incoming HTTP responses and provides cookies to
-     * outgoing HTTP requests.
-     *
-     * <p>If unset, {@linkplain CookieJar#NO_COOKIES no cookies} will be accepted nor provided.
-     */
-    public Builder cookieJar(CookieJar cookieJar) {
-      if (cookieJar == null) throw new NullPointerException("cookieJar == null");
-      this.cookieJar = cookieJar;
-      return this;
+    public ProxySelector proxySelector() {
+        return proxySelector;
     }
 
-    /** Sets the response cache to be used to read and write cached responses. */
-    void setInternalCache(@Nullable InternalCache internalCache) {
-      this.internalCache = internalCache;
-      this.cache = null;
+    public CookieJar cookieJar() {
+        return cookieJar;
     }
 
-    /** Sets the response cache to be used to read and write cached responses. */
-    public Builder cache(@Nullable Cache cache) {
-      this.cache = cache;
-      this.internalCache = null;
-      return this;
+    public @Nullable
+    Cache cache() {
+        return cache;
     }
 
-    /**
-     * Sets the DNS service used to lookup IP addresses for hostnames.
-     *
-     * <p>If unset, the {@link Dns#SYSTEM system-wide default} DNS will be used.
-     */
-    public Builder dns(Dns dns) {
-      if (dns == null) throw new NullPointerException("dns == null");
-      this.dns = dns;
-      return this;
+    InternalCache internalCache() {
+        return cache != null ? cache.internalCache : internalCache;
     }
 
-    /**
-     * Sets the socket factory used to create connections. OkHttp only uses the parameterless {@link
-     * SocketFactory#createSocket() createSocket()} method to create unconnected sockets. Overriding
-     * this method, e. g., allows the socket to be bound to a specific local address.
-     *
-     * <p>If unset, the {@link SocketFactory#getDefault() system-wide default} socket factory will
-     * be used.
-     */
-    public Builder socketFactory(SocketFactory socketFactory) {
-      if (socketFactory == null) throw new NullPointerException("socketFactory == null");
-      if (socketFactory instanceof SSLSocketFactory) {
-        throw new IllegalArgumentException("socketFactory instanceof SSLSocketFactory");
-      }
-      this.socketFactory = socketFactory;
-      return this;
+    public Dns dns() {
+        return dns;
     }
 
-    /**
-     * Sets the socket factory used to secure HTTPS connections. If unset, the system default will
-     * be used.
-     *
-     * @deprecated {@code SSLSocketFactory} does not expose its {@link X509TrustManager}, which is
-     *     a field that OkHttp needs to build a clean certificate chain. This method instead must
-     *     use reflection to extract the trust manager. Applications should prefer to call {@link
-     *     #sslSocketFactory(SSLSocketFactory, X509TrustManager)}, which avoids such reflection.
-     */
-    public Builder sslSocketFactory(SSLSocketFactory sslSocketFactory) {
-      if (sslSocketFactory == null) throw new NullPointerException("sslSocketFactory == null");
-      this.sslSocketFactory = sslSocketFactory;
-      this.certificateChainCleaner = Platform.get().buildCertificateChainCleaner(sslSocketFactory);
-      return this;
+    public SocketFactory socketFactory() {
+        return socketFactory;
     }
 
-    /**
-     * Sets the socket factory and trust manager used to secure HTTPS connections. If unset, the
-     * system defaults will be used.
-     *
-     * <p>Most applications should not call this method, and instead use the system defaults. Those
-     * classes include special optimizations that can be lost if the implementations are decorated.
-     *
-     * <p>If necessary, you can create and configure the defaults yourself with the following code:
-     *
-     * <pre>   {@code
-     *
-     *   TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
-     *       TrustManagerFactory.getDefaultAlgorithm());
-     *   trustManagerFactory.init((KeyStore) null);
-     *   TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
-     *   if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {
-     *     throw new IllegalStateException("Unexpected default trust managers:"
-     *         + Arrays.toString(trustManagers));
-     *   }
-     *   X509TrustManager trustManager = (X509TrustManager) trustManagers[0];
-     *
-     *   SSLContext sslContext = SSLContext.getInstance("TLS");
-     *   sslContext.init(null, new TrustManager[] { trustManager }, null);
-     *   SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();
-     *
-     *   OkHttpClient client = new OkHttpClient.Builder()
-     *       .sslSocketFactory(sslSocketFactory, trustManager)
-     *       .build();
-     * }</pre>
-     */
-    public Builder sslSocketFactory(
-        SSLSocketFactory sslSocketFactory, X509TrustManager trustManager) {
-      if (sslSocketFactory == null) throw new NullPointerException("sslSocketFactory == null");
-      if (trustManager == null) throw new NullPointerException("trustManager == null");
-      this.sslSocketFactory = sslSocketFactory;
-      this.certificateChainCleaner = CertificateChainCleaner.get(trustManager);
-      return this;
+    public SSLSocketFactory sslSocketFactory() {
+        return sslSocketFactory;
     }
 
-    /**
-     * Sets the verifier used to confirm that response certificates apply to requested hostnames for
-     * HTTPS connections.
-     *
-     * <p>If unset, a default hostname verifier will be used.
-     */
-    public Builder hostnameVerifier(HostnameVerifier hostnameVerifier) {
-      if (hostnameVerifier == null) throw new NullPointerException("hostnameVerifier == null");
-      this.hostnameVerifier = hostnameVerifier;
-      return this;
+    public HostnameVerifier hostnameVerifier() {
+        return hostnameVerifier;
     }
 
-    /**
-     * Sets the certificate pinner that constrains which certificates are trusted. By default HTTPS
-     * connections rely on only the {@link #sslSocketFactory SSL socket factory} to establish trust.
-     * Pinning certificates avoids the need to trust certificate authorities.
-     */
-    public Builder certificatePinner(CertificatePinner certificatePinner) {
-      if (certificatePinner == null) throw new NullPointerException("certificatePinner == null");
-      this.certificatePinner = certificatePinner;
-      return this;
+    public CertificatePinner certificatePinner() {
+        return certificatePinner;
     }
 
-    /**
-     * Sets the authenticator used to respond to challenges from origin servers. Use {@link
-     * #proxyAuthenticator} to set the authenticator for proxy servers.
-     *
-     * <p>If unset, the {@linkplain Authenticator#NONE no authentication will be attempted}.
-     */
-    public Builder authenticator(Authenticator authenticator) {
-      if (authenticator == null) throw new NullPointerException("authenticator == null");
-      this.authenticator = authenticator;
-      return this;
+    public Authenticator authenticator() {
+        return authenticator;
     }
 
-    /**
-     * Sets the authenticator used to respond to challenges from proxy servers. Use {@link
-     * #authenticator} to set the authenticator for origin servers.
-     *
-     * <p>If unset, the {@linkplain Authenticator#NONE no authentication will be attempted}.
-     */
-    public Builder proxyAuthenticator(Authenticator proxyAuthenticator) {
-      if (proxyAuthenticator == null) throw new NullPointerException("proxyAuthenticator == null");
-      this.proxyAuthenticator = proxyAuthenticator;
-      return this;
+    public Authenticator proxyAuthenticator() {
+        return proxyAuthenticator;
     }
 
-    /**
-     * Sets the connection pool used to recycle HTTP and HTTPS connections.
-     *
-     * <p>If unset, a new connection pool will be used.
-     */
-    public Builder connectionPool(ConnectionPool connectionPool) {
-      if (connectionPool == null) throw new NullPointerException("connectionPool == null");
-      this.connectionPool = connectionPool;
-      return this;
+    public ConnectionPool connectionPool() {
+        return connectionPool;
     }
 
-    /**
-     * Configure this client to follow redirects from HTTPS to HTTP and from HTTP to HTTPS.
-     *
-     * <p>If unset, protocol redirects will be followed. This is different than the built-in {@code
-     * HttpURLConnection}'s default.
-     */
-    public Builder followSslRedirects(boolean followProtocolRedirects) {
-      this.followSslRedirects = followProtocolRedirects;
-      return this;
+    public boolean followSslRedirects() {
+        return followSslRedirects;
     }
 
-    /** Configure this client to follow redirects. If unset, redirects will be followed. */
-    public Builder followRedirects(boolean followRedirects) {
-      this.followRedirects = followRedirects;
-      return this;
+    public boolean followRedirects() {
+        return followRedirects;
     }
 
-    /**
-     * Configure this client to retry or not when a connectivity problem is encountered. By default,
-     * this client silently recovers from the following problems:
-     *
-     * <ul>
-     *   <li><strong>Unreachable IP addresses.</strong> If the URL's host has multiple IP addresses,
-     *       failure to reach any individual IP address doesn't fail the overall request. This can
-     *       increase availability of multi-homed services.
-     *   <li><strong>Stale pooled connections.</strong> The {@link ConnectionPool} reuses sockets
-     *       to decrease request latency, but these connections will occasionally time out.
-     *   <li><strong>Unreachable proxy servers.</strong> A {@link ProxySelector} can be used to
-     *       attempt multiple proxy servers in sequence, eventually falling back to a direct
-     *       connection.
-     * </ul>
-     *
-     * Set this to false to avoid retrying requests when doing so is destructive. In this case the
-     * calling application should do its own recovery of connectivity failures.
-     */
-    public Builder retryOnConnectionFailure(boolean retryOnConnectionFailure) {
-      this.retryOnConnectionFailure = retryOnConnectionFailure;
-      return this;
+    public boolean retryOnConnectionFailure() {
+        return retryOnConnectionFailure;
     }
 
-    /**
-     * Sets the dispatcher used to set policy and execute asynchronous requests. Must not be null.
-     */
-    public Builder dispatcher(Dispatcher dispatcher) {
-      if (dispatcher == null) throw new IllegalArgumentException("dispatcher == null");
-      this.dispatcher = dispatcher;
-      return this;
+    public Dispatcher dispatcher() {
+        return dispatcher;
     }
 
-    /**
-     * Configure the protocols used by this client to communicate with remote servers. By default
-     * this client will prefer the most efficient transport available, falling back to more
-     * ubiquitous protocols. Applications should only call this method to avoid specific
-     * compatibility problems, such as web servers that behave incorrectly when HTTP/2 is enabled.
-     *
-     * <p>The following protocols are currently supported:
-     *
-     * <ul>
-     *     <li><a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html">http/1.1</a>
-     *     <li><a href="https://tools.ietf.org/html/rfc7540">h2</a>
-     *     <li><a href="https://tools.ietf.org/html/rfc7540#section-3.4">h2 with prior knowledge
-     *         (cleartext only)</a>
-     * </ul>
-     *
-     * <p><strong>This is an evolving set.</strong> Future releases include support for transitional
-     * protocols. The http/1.1 transport will never be dropped.
-     *
-     * <p>If multiple protocols are specified, <a
-     * href="http://tools.ietf.org/html/draft-ietf-tls-applayerprotoneg">ALPN</a> will be used to
-     * negotiate a transport. Protocol negotiation is only attempted for HTTPS URLs.
-     *
-     * <p>{@link Protocol#HTTP_1_0} is not supported in this set. Requests are initiated with {@code
-     * HTTP/1.1}. If the server responds with {@code HTTP/1.0}, that will be exposed by {@link
-     * Response#protocol()}.
-     *
-     * @param protocols the protocols to use, in order of preference. If the list contains {@link
-     *     Protocol#H2_PRIOR_KNOWLEDGE} then that must be the only protocol and HTTPS URLs will not
-     *     be supported. Otherwise the list must contain {@link Protocol#HTTP_1_1}. The list must
-     *     not contain null or {@link Protocol#HTTP_1_0}.
-     */
-    public Builder protocols(List<Protocol> protocols) {
-      // Create a private copy of the list.
-      protocols = new ArrayList<>(protocols);
-
-      // Validate that the list has everything we require and nothing we forbid.
-      if (!protocols.contains(Protocol.H2_PRIOR_KNOWLEDGE)
-          && !protocols.contains(Protocol.HTTP_1_1)) {
-        throw new IllegalArgumentException(
-            "protocols must contain h2_prior_knowledge or http/1.1: " + protocols);
-      }
-      if (protocols.contains(Protocol.H2_PRIOR_KNOWLEDGE) && protocols.size() > 1) {
-        throw new IllegalArgumentException(
-            "protocols containing h2_prior_knowledge cannot use other protocols: " + protocols);
-      }
-      if (protocols.contains(Protocol.HTTP_1_0)) {
-        throw new IllegalArgumentException("protocols must not contain http/1.0: " + protocols);
-      }
-      if (protocols.contains(null)) {
-        throw new IllegalArgumentException("protocols must not contain null");
-      }
-
-      // Remove protocols that we no longer support.
-      protocols.remove(Protocol.SPDY_3);
-
-      // Assign as an unmodifiable list. This is effectively immutable.
-      this.protocols = Collections.unmodifiableList(protocols);
-      return this;
+    public List<Protocol> protocols() {
+        return protocols;
     }
 
-    public Builder connectionSpecs(List<ConnectionSpec> connectionSpecs) {
-      this.connectionSpecs = Util.immutableList(connectionSpecs);
-      return this;
+    public List<ConnectionSpec> connectionSpecs() {
+        return connectionSpecs;
     }
 
     /**
-     * Returns a modifiable list of interceptors that observe the full span of each call: from
-     * before the connection is established (if any) until after the response source is selected
-     * (either the origin server, cache, or both).
+     * Returns an immutable list of interceptors that observe the full span of each call: from before
+     * the connection is established (if any) until after the response source is selected (either the
+     * origin server, cache, or both).
      */
     public List<Interceptor> interceptors() {
-      return interceptors;
-    }
-
-    public Builder addInterceptor(Interceptor interceptor) {
-      if (interceptor == null) throw new IllegalArgumentException("interceptor == null");
-      interceptors.add(interceptor);
-      return this;
+        return interceptors;
     }
 
     /**
-     * Returns a modifiable list of interceptors that observe a single network request and response.
-     * These interceptors must call {@link Interceptor.Chain#proceed} exactly once: it is an error
-     * for a network interceptor to short-circuit or repeat a network request.
+     * Returns an immutable list of interceptors that observe a single network request and response.
+     * These interceptors must call {@link Interceptor.Chain#proceed} exactly once: it is an error for
+     * a network interceptor to short-circuit or repeat a network request.
      */
     public List<Interceptor> networkInterceptors() {
-      return networkInterceptors;
+        return networkInterceptors;
     }
 
-    public Builder addNetworkInterceptor(Interceptor interceptor) {
-      if (interceptor == null) throw new IllegalArgumentException("interceptor == null");
-      networkInterceptors.add(interceptor);
-      return this;
+    public EventListener.Factory eventListenerFactory() {
+        return eventListenerFactory;
     }
 
     /**
-     * Configure a single client scoped listener that will receive all analytic events
-     * for this client.
-     *
-     * @see EventListener for semantics and restrictions on listener implementations.
+     * Prepares the {@code request} to be executed at some point in the future.
      */
-    public Builder eventListener(EventListener eventListener) {
-      if (eventListener == null) throw new NullPointerException("eventListener == null");
-      this.eventListenerFactory = EventListener.factory(eventListener);
-      return this;
+    @Override
+    public Call newCall(Request request) {
+        return RealCall.newRealCall(this, request, false /* for web socket */);
     }
 
     /**
-     * Configure a factory to provide per-call scoped listeners that will receive analytic events
-     * for this client.
-     *
-     * @see EventListener for semantics and restrictions on listener implementations.
+     * Uses {@code request} to connect a new web socket.
      */
-    public Builder eventListenerFactory(EventListener.Factory eventListenerFactory) {
-      if (eventListenerFactory == null) {
-        throw new NullPointerException("eventListenerFactory == null");
-      }
-      this.eventListenerFactory = eventListenerFactory;
-      return this;
+    @Override
+    public WebSocket newWebSocket(Request request, WebSocketListener listener) {
+        RealWebSocket webSocket = new RealWebSocket(request, listener, new Random(), pingInterval);
+        webSocket.connect(this);
+        return webSocket;
+    }
+
+    public Builder newBuilder() {
+        return new Builder(this);
     }
 
-    public OkHttpClient build() {
-      return new OkHttpClient(this);
+    public static final class Builder {
+        /**
+         * 调度器
+         */
+        Dispatcher dispatcher;
+        @Nullable
+        Proxy proxy;
+
+        /**
+         * 默认支持的Http协议版本  --   Protocol.HTTP_2, Protocol.HTTP_1_1；
+         */
+        List<Protocol> protocols;
+
+        /**
+         * OKHttp连接（Connection）配置 ：
+         * 1）ConnectionSpec.MODERN_TLS ：针对TLS连接的配置
+         * 2）ConnectionSpec.CLEARTEXT ： 针对普通的Http连接的配置
+         */
+        List<ConnectionSpec> connectionSpecs;
+        final List<Interceptor> interceptors = new ArrayList<>();
+        final List<Interceptor> networkInterceptors = new ArrayList<>();
+
+        /**
+         * 一个Call的状态监听器
+         */
+        EventListener.Factory eventListenerFactory;
+
+        /**
+         * 代理选择器；
+         */
+        ProxySelector proxySelector;
+
+        /**
+         * Cookie，默认是没有Cookie的：CookieJar.NO_COOKIES
+         */
+        CookieJar cookieJar;
+        @Nullable
+        Cache cache;
+        @Nullable
+        InternalCache internalCache;
+        SocketFactory socketFactory;
+        @Nullable
+        SSLSocketFactory sslSocketFactory;
+        @Nullable
+        CertificateChainCleaner certificateChainCleaner;
+        HostnameVerifier hostnameVerifier;
+        CertificatePinner certificatePinner;
+        Authenticator proxyAuthenticator;
+        Authenticator authenticator;
+        ConnectionPool connectionPool;
+        Dns dns;
+        boolean followSslRedirects;
+        boolean followRedirects;
+        boolean retryOnConnectionFailure;
+        int callTimeout;
+        int connectTimeout;
+        int readTimeout;
+        int writeTimeout;
+        int pingInterval;
+
+        public Builder() {
+            // 调度器
+            dispatcher = new Dispatcher();
+
+            // 默认支持的Http协议版本  --   Protocol.HTTP_2, Protocol.HTTP_1_1；
+            protocols = DEFAULT_PROTOCOLS;
+
+            // OKHttp连接（Connection）配置
+            connectionSpecs = DEFAULT_CONNECTION_SPECS;
+
+            // 一个Call的状态监听器
+            eventListenerFactory = EventListener.factory(EventListener.NONE);
+
+            // 使用默认的代理选择器；
+            proxySelector = ProxySelector.getDefault();
+            if (proxySelector == null) {
+                proxySelector = new NullProxySelector();
+            }
+
+            //默认是没有Cookie的
+            cookieJar = CookieJar.NO_COOKIES;
+
+            //使用默认的Socket工厂产生Socket
+            socketFactory = SocketFactory.getDefault();
+
+            // hostnameVerifier、 certificatePinner、 proxyAuthenticator、 authenticator：安全相关的设置；
+            hostnameVerifier = OkHostnameVerifier.INSTANCE;
+            certificatePinner = CertificatePinner.DEFAULT;
+            proxyAuthenticator = Authenticator.NONE;
+            authenticator = Authenticator.NONE;
+
+            // 连接池
+            connectionPool = new ConnectionPool();
+
+            // 域名解析系统 domain name -> ip address
+            dns = Dns.SYSTEM;
+            followSslRedirects = true;
+            followRedirects = true;
+            retryOnConnectionFailure = true;
+            callTimeout = 0;
+            connectTimeout = 10_000;
+            readTimeout = 10_000;
+            writeTimeout = 10_000;
+            pingInterval = 0;
+        }
+
+        Builder(OkHttpClient okHttpClient) {
+            this.dispatcher = okHttpClient.dispatcher;
+            this.proxy = okHttpClient.proxy;
+            this.protocols = okHttpClient.protocols;
+            this.connectionSpecs = okHttpClient.connectionSpecs;
+            this.interceptors.addAll(okHttpClient.interceptors);
+            this.networkInterceptors.addAll(okHttpClient.networkInterceptors);
+            this.eventListenerFactory = okHttpClient.eventListenerFactory;
+            this.proxySelector = okHttpClient.proxySelector;
+            this.cookieJar = okHttpClient.cookieJar;
+            this.internalCache = okHttpClient.internalCache;
+            this.cache = okHttpClient.cache;
+            this.socketFactory = okHttpClient.socketFactory;
+            this.sslSocketFactory = okHttpClient.sslSocketFactory;
+            this.certificateChainCleaner = okHttpClient.certificateChainCleaner;
+            this.hostnameVerifier = okHttpClient.hostnameVerifier;
+            this.certificatePinner = okHttpClient.certificatePinner;
+            this.proxyAuthenticator = okHttpClient.proxyAuthenticator;
+            this.authenticator = okHttpClient.authenticator;
+            this.connectionPool = okHttpClient.connectionPool;
+            this.dns = okHttpClient.dns;
+            this.followSslRedirects = okHttpClient.followSslRedirects;
+            this.followRedirects = okHttpClient.followRedirects;
+            this.retryOnConnectionFailure = okHttpClient.retryOnConnectionFailure;
+            this.callTimeout = okHttpClient.callTimeout;
+            this.connectTimeout = okHttpClient.connectTimeout;
+            this.readTimeout = okHttpClient.readTimeout;
+            this.writeTimeout = okHttpClient.writeTimeout;
+            this.pingInterval = okHttpClient.pingInterval;
+        }
+
+        /**
+         * Sets the default timeout for complete calls. A value of 0 means no timeout, otherwise values
+         * must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
+         * <p>
+         * <p>The call timeout spans the entire call: resolving DNS, connecting, writing the request
+         * body, server processing, and reading the response body. If the call requires redirects or
+         * retries all must complete within one timeout period.
+         */
+        public Builder callTimeout(long timeout, TimeUnit unit) {
+            callTimeout = checkDuration("timeout", timeout, unit);
+            return this;
+        }
+
+        /**
+         * Sets the default timeout for complete calls. A value of 0 means no timeout, otherwise values
+         * must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
+         * <p>
+         * <p>The call timeout spans the entire call: resolving DNS, connecting, writing the request
+         * body, server processing, and reading the response body. If the call requires redirects or
+         * retries all must complete within one timeout period.
+         */
+        @IgnoreJRERequirement
+        public Builder callTimeout(Duration duration) {
+            callTimeout = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS);
+            return this;
+        }
+
+        /**
+         * Sets the default connect timeout for new connections. A value of 0 means no timeout,
+         * otherwise values must be between 1 and {@link Integer#MAX_VALUE} when converted to
+         * milliseconds.
+         * <p>
+         * <p>The connect timeout is applied when connecting a TCP socket to the target host.
+         * The default value is 10 seconds.
+         */
+        public Builder connectTimeout(long timeout, TimeUnit unit) {
+            connectTimeout = checkDuration("timeout", timeout, unit);
+            return this;
+        }
+
+        /**
+         * Sets the default connect timeout for new connections. A value of 0 means no timeout,
+         * otherwise values must be between 1 and {@link Integer#MAX_VALUE} when converted to
+         * milliseconds.
+         * <p>
+         * <p>The connect timeout is applied when connecting a TCP socket to the target host.
+         * The default value is 10 seconds.
+         */
+        @IgnoreJRERequirement
+        public Builder connectTimeout(Duration duration) {
+            connectTimeout = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS);
+            return this;
+        }
+
+        /**
+         * Sets the default read timeout for new connections. A value of 0 means no timeout, otherwise
+         * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
+         * <p>
+         * <p>The read timeout is applied to both the TCP socket and for individual read IO operations
+         * including on {@link Source} of the {@link Response}. The default value is 10 seconds.
+         *
+         * @see Socket#setSoTimeout(int)
+         * @see Source#timeout()
+         */
+        public Builder readTimeout(long timeout, TimeUnit unit) {
+            readTimeout = checkDuration("timeout", timeout, unit);
+            return this;
+        }
+
+        /**
+         * Sets the default read timeout for new connections. A value of 0 means no timeout, otherwise
+         * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
+         * <p>
+         * <p>The read timeout is applied to both the TCP socket and for individual read IO operations
+         * including on {@link Source} of the {@link Response}. The default value is 10 seconds.
+         *
+         * @see Socket#setSoTimeout(int)
+         * @see Source#timeout()
+         */
+        @IgnoreJRERequirement
+        public Builder readTimeout(Duration duration) {
+            readTimeout = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS);
+            return this;
+        }
+
+        /**
+         * Sets the default write timeout for new connections. A value of 0 means no timeout, otherwise
+         * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
+         * <p>
+         * <p>The write timeout is applied for individual write IO operations.
+         * The default value is 10 seconds.
+         *
+         * @see Sink#timeout()
+         */
+        public Builder writeTimeout(long timeout, TimeUnit unit) {
+            writeTimeout = checkDuration("timeout", timeout, unit);
+            return this;
+        }
+
+        /**
+         * Sets the default write timeout for new connections. A value of 0 means no timeout, otherwise
+         * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
+         * <p>
+         * <p>The write timeout is applied for individual write IO operations.
+         * The default value is 10 seconds.
+         *
+         * @see Sink#timeout()
+         */
+        @IgnoreJRERequirement
+        public Builder writeTimeout(Duration duration) {
+            writeTimeout = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS);
+            return this;
+        }
+
+        /**
+         * Sets the interval between HTTP/2 and web socket pings initiated by this client. Use this to
+         * automatically send ping frames until either the connection fails or it is closed. This keeps
+         * the connection alive and may detect connectivity failures.
+         * <p>
+         * <p>If the server does not respond to each ping with a pong within {@code interval}, this
+         * client will assume that connectivity has been lost. When this happens on a web socket the
+         * connection is canceled and its listener is {@linkplain WebSocketListener#onFailure notified
+         * of the failure}. When it happens on an HTTP/2 connection the connection is closed and any
+         * calls it is carrying {@linkplain java.io.IOException will fail with an IOException}.
+         * <p>
+         * <p>The default value of 0 disables client-initiated pings.
+         */
+        public Builder pingInterval(long interval, TimeUnit unit) {
+            pingInterval = checkDuration("interval", interval, unit);
+            return this;
+        }
+
+        /**
+         * Sets the interval between HTTP/2 and web socket pings initiated by this client. Use this to
+         * automatically send ping frames until either the connection fails or it is closed. This keeps
+         * the connection alive and may detect connectivity failures.
+         * <p>
+         * <p>If the server does not respond to each ping with a pong within {@code interval}, this
+         * client will assume that connectivity has been lost. When this happens on a web socket the
+         * connection is canceled and its listener is {@linkplain WebSocketListener#onFailure notified
+         * of the failure}. When it happens on an HTTP/2 connection the connection is closed and any
+         * calls it is carrying {@linkplain java.io.IOException will fail with an IOException}.
+         * <p>
+         * <p>The default value of 0 disables client-initiated pings.
+         */
+        @IgnoreJRERequirement
+        public Builder pingInterval(Duration duration) {
+            pingInterval = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS);
+            return this;
+        }
+
+        /**
+         * Sets the HTTP proxy that will be used by connections created by this client. This takes
+         * precedence over {@link #proxySelector}, which is only honored when this proxy is null (which
+         * it is by default). To disable proxy use completely, call {@code proxy(Proxy.NO_PROXY)}.
+         */
+        public Builder proxy(@Nullable Proxy proxy) {
+            this.proxy = proxy;
+            return this;
+        }
+
+        /**
+         * Sets the proxy selection policy to be used if no {@link #proxy proxy} is specified
+         * explicitly. The proxy selector may return multiple proxies; in that case they will be tried
+         * in sequence until a successful connection is established.
+         * <p>
+         * <p>If unset, the {@link ProxySelector#getDefault() system-wide default} proxy selector will
+         * be used.
+         */
+        public Builder proxySelector(ProxySelector proxySelector) {
+            if (proxySelector == null) throw new NullPointerException("proxySelector == null");
+            this.proxySelector = proxySelector;
+            return this;
+        }
+
+        /**
+         * Sets the handler that can accept cookies from incoming HTTP responses and provides cookies to
+         * outgoing HTTP requests.
+         * <p>
+         * <p>If unset, {@linkplain CookieJar#NO_COOKIES no cookies} will be accepted nor provided.
+         */
+        public Builder cookieJar(CookieJar cookieJar) {
+            if (cookieJar == null) throw new NullPointerException("cookieJar == null");
+            this.cookieJar = cookieJar;
+            return this;
+        }
+
+        /**
+         * Sets the response cache to be used to read and write cached responses.
+         */
+        void setInternalCache(@Nullable InternalCache internalCache) {
+            this.internalCache = internalCache;
+            this.cache = null;
+        }
+
+        /**
+         * Sets the response cache to be used to read and write cached responses.
+         */
+        public Builder cache(@Nullable Cache cache) {
+            this.cache = cache;
+            this.internalCache = null;
+            return this;
+        }
+
+        /**
+         * Sets the DNS service used to lookup IP addresses for hostnames.
+         * <p>
+         * <p>If unset, the {@link Dns#SYSTEM system-wide default} DNS will be used.
+         */
+        public Builder dns(Dns dns) {
+            if (dns == null) throw new NullPointerException("dns == null");
+            this.dns = dns;
+            return this;
+        }
+
+        /**
+         * Sets the socket factory used to create connections. OkHttp only uses the parameterless {@link
+         * SocketFactory#createSocket() createSocket()} method to create unconnected sockets. Overriding
+         * this method, e. g., allows the socket to be bound to a specific local address.
+         * <p>
+         * <p>If unset, the {@link SocketFactory#getDefault() system-wide default} socket factory will
+         * be used.
+         */
+        public Builder socketFactory(SocketFactory socketFactory) {
+            if (socketFactory == null) throw new NullPointerException("socketFactory == null");
+            if (socketFactory instanceof SSLSocketFactory) {
+                throw new IllegalArgumentException("socketFactory instanceof SSLSocketFactory");
+            }
+            this.socketFactory = socketFactory;
+            return this;
+        }
+
+        /**
+         * Sets the socket factory used to secure HTTPS connections. If unset, the system default will
+         * be used.
+         *
+         * @deprecated {@code SSLSocketFactory} does not expose its {@link X509TrustManager}, which is
+         * a field that OkHttp needs to build a clean certificate chain. This method instead must
+         * use reflection to extract the trust manager. Applications should prefer to call {@link
+         * #sslSocketFactory(SSLSocketFactory, X509TrustManager)}, which avoids such reflection.
+         */
+        public Builder sslSocketFactory(SSLSocketFactory sslSocketFactory) {
+            if (sslSocketFactory == null)
+                throw new NullPointerException("sslSocketFactory == null");
+            this.sslSocketFactory = sslSocketFactory;
+            this.certificateChainCleaner = Platform.get().buildCertificateChainCleaner(sslSocketFactory);
+            return this;
+        }
+
+        /**
+         * Sets the socket factory and trust manager used to secure HTTPS connections. If unset, the
+         * system defaults will be used.
+         * <p>
+         * <p>Most applications should not call this method, and instead use the system defaults. Those
+         * classes include special optimizations that can be lost if the implementations are decorated.
+         * <p>
+         * <p>If necessary, you can create and configure the defaults yourself with the following code:
+         * <p>
+         * <pre>   {@code
+         *
+         *   TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
+         *       TrustManagerFactory.getDefaultAlgorithm());
+         *   trustManagerFactory.init((KeyStore) null);
+         *   TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
+         *   if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {
+         *     throw new IllegalStateException("Unexpected default trust managers:"
+         *         + Arrays.toString(trustManagers));
+         *   }
+         *   X509TrustManager trustManager = (X509TrustManager) trustManagers[0];
+         *
+         *   SSLContext sslContext = SSLContext.getInstance("TLS");
+         *   sslContext.init(null, new TrustManager[] { trustManager }, null);
+         *   SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();
+         *
+         *   OkHttpClient client = new OkHttpClient.Builder()
+         *       .sslSocketFactory(sslSocketFactory, trustManager)
+         *       .build();
+         * }</pre>
+         */
+        public Builder sslSocketFactory(
+                SSLSocketFactory sslSocketFactory, X509TrustManager trustManager) {
+            if (sslSocketFactory == null)
+                throw new NullPointerException("sslSocketFactory == null");
+            if (trustManager == null) throw new NullPointerException("trustManager == null");
+            this.sslSocketFactory = sslSocketFactory;
+            this.certificateChainCleaner = CertificateChainCleaner.get(trustManager);
+            return this;
+        }
+
+        /**
+         * Sets the verifier used to confirm that response certificates apply to requested hostnames for
+         * HTTPS connections.
+         * <p>
+         * <p>If unset, a default hostname verifier will be used.
+         */
+        public Builder hostnameVerifier(HostnameVerifier hostnameVerifier) {
+            if (hostnameVerifier == null)
+                throw new NullPointerException("hostnameVerifier == null");
+            this.hostnameVerifier = hostnameVerifier;
+            return this;
+        }
+
+        /**
+         * Sets the certificate pinner that constrains which certificates are trusted. By default HTTPS
+         * connections rely on only the {@link #sslSocketFactory SSL socket factory} to establish trust.
+         * Pinning certificates avoids the need to trust certificate authorities.
+         */
+        public Builder certificatePinner(CertificatePinner certificatePinner) {
+            if (certificatePinner == null)
+                throw new NullPointerException("certificatePinner == null");
+            this.certificatePinner = certificatePinner;
+            return this;
+        }
+
+        /**
+         * Sets the authenticator used to respond to challenges from origin servers. Use {@link
+         * #proxyAuthenticator} to set the authenticator for proxy servers.
+         * <p>
+         * <p>If unset, the {@linkplain Authenticator#NONE no authentication will be attempted}.
+         */
+        public Builder authenticator(Authenticator authenticator) {
+            if (authenticator == null) throw new NullPointerException("authenticator == null");
+            this.authenticator = authenticator;
+            return this;
+        }
+
+        /**
+         * Sets the authenticator used to respond to challenges from proxy servers. Use {@link
+         * #authenticator} to set the authenticator for origin servers.
+         * <p>
+         * <p>If unset, the {@linkplain Authenticator#NONE no authentication will be attempted}.
+         */
+        public Builder proxyAuthenticator(Authenticator proxyAuthenticator) {
+            if (proxyAuthenticator == null)
+                throw new NullPointerException("proxyAuthenticator == null");
+            this.proxyAuthenticator = proxyAuthenticator;
+            return this;
+        }
+
+        /**
+         * Sets the connection pool used to recycle HTTP and HTTPS connections.
+         * <p>
+         * <p>If unset, a new connection pool will be used.
+         */
+        public Builder connectionPool(ConnectionPool connectionPool) {
+            if (connectionPool == null) throw new NullPointerException("connectionPool == null");
+            this.connectionPool = connectionPool;
+            return this;
+        }
+
+        /**
+         * Configure this client to follow redirects from HTTPS to HTTP and from HTTP to HTTPS.
+         * <p>
+         * <p>If unset, protocol redirects will be followed. This is different than the built-in {@code
+         * HttpURLConnection}'s default.
+         */
+        public Builder followSslRedirects(boolean followProtocolRedirects) {
+            this.followSslRedirects = followProtocolRedirects;
+            return this;
+        }
+
+        /**
+         * Configure this client to follow redirects. If unset, redirects will be followed.
+         */
+        public Builder followRedirects(boolean followRedirects) {
+            this.followRedirects = followRedirects;
+            return this;
+        }
+
+        /**
+         * Configure this client to retry or not when a connectivity problem is encountered. By default,
+         * this client silently recovers from the following problems:
+         * <p>
+         * <ul>
+         * <li><strong>Unreachable IP addresses.</strong> If the URL's host has multiple IP addresses,
+         * failure to reach any individual IP address doesn't fail the overall request. This can
+         * increase availability of multi-homed services.
+         * <li><strong>Stale pooled connections.</strong> The {@link ConnectionPool} reuses sockets
+         * to decrease request latency, but these connections will occasionally time out.
+         * <li><strong>Unreachable proxy servers.</strong> A {@link ProxySelector} can be used to
+         * attempt multiple proxy servers in sequence, eventually falling back to a direct
+         * connection.
+         * </ul>
+         * <p>
+         * Set this to false to avoid retrying requests when doing so is destructive. In this case the
+         * calling application should do its own recovery of connectivity failures.
+         */
+        public Builder retryOnConnectionFailure(boolean retryOnConnectionFailure) {
+            this.retryOnConnectionFailure = retryOnConnectionFailure;
+            return this;
+        }
+
+        /**
+         * Sets the dispatcher used to set policy and execute asynchronous requests. Must not be null.
+         */
+        public Builder dispatcher(Dispatcher dispatcher) {
+            if (dispatcher == null) throw new IllegalArgumentException("dispatcher == null");
+            this.dispatcher = dispatcher;
+            return this;
+        }
+
+        /**
+         * Configure the protocols used by this client to communicate with remote servers. By default
+         * this client will prefer the most efficient transport available, falling back to more
+         * ubiquitous protocols. Applications should only call this method to avoid specific
+         * compatibility problems, such as web servers that behave incorrectly when HTTP/2 is enabled.
+         * <p>
+         * <p>The following protocols are currently supported:
+         * <p>
+         * <ul>
+         * <li><a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html">http/1.1</a>
+         * <li><a href="https://tools.ietf.org/html/rfc7540">h2</a>
+         * <li><a href="https://tools.ietf.org/html/rfc7540#section-3.4">h2 with prior knowledge
+         * (cleartext only)</a>
+         * </ul>
+         * <p>
+         * <p><strong>This is an evolving set.</strong> Future releases include support for transitional
+         * protocols. The http/1.1 transport will never be dropped.
+         * <p>
+         * <p>If multiple protocols are specified, <a
+         * href="http://tools.ietf.org/html/draft-ietf-tls-applayerprotoneg">ALPN</a> will be used to
+         * negotiate a transport. Protocol negotiation is only attempted for HTTPS URLs.
+         * <p>
+         * <p>{@link Protocol#HTTP_1_0} is not supported in this set. Requests are initiated with {@code
+         * HTTP/1.1}. If the server responds with {@code HTTP/1.0}, that will be exposed by {@link
+         * Response#protocol()}.
+         *
+         * @param protocols the protocols to use, in order of preference. If the list contains {@link
+         *                  Protocol#H2_PRIOR_KNOWLEDGE} then that must be the only protocol and HTTPS URLs will not
+         *                  be supported. Otherwise the list must contain {@link Protocol#HTTP_1_1}. The list must
+         *                  not contain null or {@link Protocol#HTTP_1_0}.
+         */
+        public Builder protocols(List<Protocol> protocols) {
+            // Create a private copy of the list.
+            protocols = new ArrayList<>(protocols);
+
+            // Validate that the list has everything we require and nothing we forbid.
+            if (!protocols.contains(Protocol.H2_PRIOR_KNOWLEDGE)
+                    && !protocols.contains(Protocol.HTTP_1_1)) {
+                throw new IllegalArgumentException(
+                        "protocols must contain h2_prior_knowledge or http/1.1: " + protocols);
+            }
+            if (protocols.contains(Protocol.H2_PRIOR_KNOWLEDGE) && protocols.size() > 1) {
+                throw new IllegalArgumentException(
+                        "protocols containing h2_prior_knowledge cannot use other protocols: " + protocols);
+            }
+            if (protocols.contains(Protocol.HTTP_1_0)) {
+                throw new IllegalArgumentException("protocols must not contain http/1.0: " + protocols);
+            }
+            if (protocols.contains(null)) {
+                throw new IllegalArgumentException("protocols must not contain null");
+            }
+
+            // Remove protocols that we no longer support.
+            protocols.remove(Protocol.SPDY_3);
+
+            // Assign as an unmodifiable list. This is effectively immutable.
+            this.protocols = Collections.unmodifiableList(protocols);
+            return this;
+        }
+
+        public Builder connectionSpecs(List<ConnectionSpec> connectionSpecs) {
+            this.connectionSpecs = Util.immutableList(connectionSpecs);
+            return this;
+        }
+
+        /**
+         * Returns a modifiable list of interceptors that observe the full span of each call: from
+         * before the connection is established (if any) until after the response source is selected
+         * (either the origin server, cache, or both).
+         */
+        public List<Interceptor> interceptors() {
+            return interceptors;
+        }
+
+        public Builder addInterceptor(Interceptor interceptor) {
+            if (interceptor == null) throw new IllegalArgumentException("interceptor == null");
+            interceptors.add(interceptor);
+            return this;
+        }
+
+        /**
+         * Returns a modifiable list of interceptors that observe a single network request and response.
+         * These interceptors must call {@link Interceptor.Chain#proceed} exactly once: it is an error
+         * for a network interceptor to short-circuit or repeat a network request.
+         */
+        public List<Interceptor> networkInterceptors() {
+            return networkInterceptors;
+        }
+
+        public Builder addNetworkInterceptor(Interceptor interceptor) {
+            if (interceptor == null) throw new IllegalArgumentException("interceptor == null");
+            networkInterceptors.add(interceptor);
+            return this;
+        }
+
+        /**
+         * Configure a single client scoped listener that will receive all analytic events
+         * for this client.
+         *
+         * @see EventListener for semantics and restrictions on listener implementations.
+         */
+        public Builder eventListener(EventListener eventListener) {
+            if (eventListener == null) throw new NullPointerException("eventListener == null");
+            this.eventListenerFactory = EventListener.factory(eventListener);
+            return this;
+        }
+
+        /**
+         * Configure a factory to provide per-call scoped listeners that will receive analytic events
+         * for this client.
+         *
+         * @see EventListener for semantics and restrictions on listener implementations.
+         */
+        public Builder eventListenerFactory(EventListener.Factory eventListenerFactory) {
+            if (eventListenerFactory == null) {
+                throw new NullPointerException("eventListenerFactory == null");
+            }
+            this.eventListenerFactory = eventListenerFactory;
+            return this;
+        }
+
+        public OkHttpClient build() {
+            return new OkHttpClient(this);
+        }
     }
-  }
 }
diff --git a/okhttp/src/main/java/okhttp3/RealCall.java b/okhttp/src/main/java/okhttp3/RealCall.java
index c7ff58d336..99b4dd2d69 100644
--- a/okhttp/src/main/java/okhttp3/RealCall.java
+++ b/okhttp/src/main/java/okhttp3/RealCall.java
@@ -21,7 +21,9 @@
 import java.util.List;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.RejectedExecutionException;
+
 import javax.annotation.Nullable;
+
 import okhttp3.internal.NamedRunnable;
 import okhttp3.internal.cache.CacheInterceptor;
 import okhttp3.internal.connection.ConnectInterceptor;
@@ -38,291 +40,326 @@
 import static okhttp3.internal.platform.Platform.INFO;
 
 final class RealCall implements Call {
-  final OkHttpClient client;
-  final RetryAndFollowUpInterceptor retryAndFollowUpInterceptor;
-  final AsyncTimeout timeout;
-
-  /**
-   * There is a cycle between the {@link Call} and {@link EventListener} that makes this awkward.
-   * This will be set after we create the call instance then create the event listener instance.
-   */
-  private @Nullable EventListener eventListener;
-
-  /** The application's original request unadulterated by redirects or auth headers. */
-  final Request originalRequest;
-  final boolean forWebSocket;
-
-  // Guarded by this.
-  private boolean executed;
-
-  private RealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {
-    this.client = client;
-    this.originalRequest = originalRequest;
-    this.forWebSocket = forWebSocket;
-    this.retryAndFollowUpInterceptor = new RetryAndFollowUpInterceptor(client, forWebSocket);
-    this.timeout = new AsyncTimeout() {
-      @Override protected void timedOut() {
-        cancel();
-      }
-    };
-    this.timeout.timeout(client.callTimeoutMillis(), MILLISECONDS);
-  }
-
-  /**
-   * 将 OkHttpClient 与 Request对象关联的实际方法
-   * @param client
-   * @param originalRequest
-   * @param forWebSocket
-   * @return
-   */
-  static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {
-    // Safely publish the Call instance to the EventListener.
-    // 创建newCall对象
-    RealCall call = new RealCall(client, originalRequest, forWebSocket);
-    // 创建 EventListener对象
-    call.eventListener = client.eventListenerFactory().create(call);
-    return call;
-  }
-
-  @Override public Request request() {
-    return originalRequest;
-  }
-
-  /**
-   * 同步请求
-   * @return
-   * @throws IOException
-   */
-  @Override public Response execute() throws IOException {
-    // 1、首先利用 synchronized 加入了对象锁，防止多线程同时调用
-    synchronized (this) {
-      // 判断executed是否为true，
-      // true表示当前的call已经被执行了，那么抛出异常。
-      // false表示没有被执行，那么将executed设置为true，并且继续进行执行。
-      if (executed) throw new IllegalStateException("Already Executed");
-      executed = true;
-    }
-    // 2
-    captureCallStackTrace();
-
-    // 3
-    timeout.enter();
-
-    // 4、回调 callStart
-    eventListener.callStart(this);
-    try {
-      // 5、将 RealCall对象 加入到 dispatcher的同步队列中
-      client.dispatcher().executed(this);
-
-      // 6、
-      Response result = getResponseWithInterceptorChain();
-      if (result == null) throw new IOException("Canceled");
-      return result;
-    } catch (IOException e) {
-      e = timeoutExit(e);
-      // 发生异常，回调 callFailed
-      eventListener.callFailed(this, e);
-      throw e;
-    } finally {
-      //
-      client.dispatcher().finished(this);
-    }
-  }
+    final OkHttpClient client;
+    final RetryAndFollowUpInterceptor retryAndFollowUpInterceptor;
+    final AsyncTimeout timeout;
 
-  @Nullable IOException timeoutExit(@Nullable IOException cause) {
-    if (!timeout.exit()) return cause;
+    /**
+     * There is a cycle between the {@link Call} and {@link EventListener} that makes this awkward.
+     * This will be set after we create the call instance then create the event listener instance.
+     */
+    private @Nullable
+    EventListener eventListener;
 
-    InterruptedIOException e = new InterruptedIOException("timeout");
-    if (cause != null) {
-      e.initCause(cause);
+    /**
+     * The application's original request unadulterated by redirects or auth headers.
+     */
+    final Request originalRequest;
+    final boolean forWebSocket;
+
+    // Guarded by this.
+    private boolean executed;
+
+    private RealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {
+        this.client = client;
+        this.originalRequest = originalRequest;
+        this.forWebSocket = forWebSocket;
+        this.retryAndFollowUpInterceptor = new RetryAndFollowUpInterceptor(client, forWebSocket);
+        this.timeout = new AsyncTimeout() {
+            @Override
+            protected void timedOut() {
+                cancel();
+            }
+        };
+        this.timeout.timeout(client.callTimeoutMillis(), MILLISECONDS);
     }
-    return e;
-  }
-
-  private void captureCallStackTrace() {
-    Object callStackTrace = Platform.get().getStackTraceForCloseable("response.body().close()");
-    // retryAndFollowUpInterceptor加入了一个用于追踪堆栈信息的callStackTrace
-    retryAndFollowUpInterceptor.setCallStackTrace(callStackTrace);
-  }
 
     /**
-     * 异步请求
-     * @param responseCallback
+     * 将 OkHttpClient 与 Request对象关联的实际方法
+     *
+     * @param client
+     * @param originalRequest
+     * @param forWebSocket
+     * @return
      */
-  @Override public void enqueue(Callback responseCallback) {
-      // 1、首先利用 synchronized 加入了对象锁，防止多线程同时调用
-    synchronized (this) {
-        // 判断executed是否为true，
-        // true表示当前的call已经被执行了，那么抛出异常。
-        // false表示没有被执行，那么将executed设置为true，并且继续进行执行。
-      if (executed) throw new IllegalStateException("Already Executed");
-      executed = true;
+    static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {
+        // Safely publish the Call instance to the EventListener.
+        // 创建newCall对象
+        RealCall call = new RealCall(client, originalRequest, forWebSocket);
+        // 创建 EventListener对象
+        call.eventListener = client.eventListenerFactory().create(call);
+        return call;
     }
-    // 2
-    captureCallStackTrace();
 
-    // 3、回调 callStart
-    eventListener.callStart(this);
-
-    // 4、使用分发器
-    client.dispatcher().enqueue(new AsyncCall(responseCallback));
-  }
+    @Override
+    public Request request() {
+        return originalRequest;
+    }
 
-  @Override public void cancel() {
-    retryAndFollowUpInterceptor.cancel();
-  }
+    /**
+     * 同步请求方法，此方法会阻塞当前线程知道请求结果放回
+     *
+     * @return
+     * @throws IOException
+     */
+    @Override
+    public Response execute() throws IOException {
+        // 1、首先利用 synchronized 加入了对象锁，防止多线程同时调用
+        synchronized (this) {
+            // 判断executed是否为true，
+            // true表示当前的call已经被执行了，那么抛出异常。
+            // false表示没有被执行，那么将executed设置为true，并且继续进行执行。
+            if (executed) throw new IllegalStateException("Already Executed");
+            executed = true;
+        }
+        // 2
+        captureCallStackTrace();
+
+        // 3
+        timeout.enter();
+
+        // 4、回调 callStart
+        eventListener.callStart(this);
+        try {
+            // 5、将 RealCall对象 加入到 dispatcher的同步队列中
+            client.dispatcher().executed(this);
+
+            // 6、通过拦截器链获取响应Response
+            Response result = getResponseWithInterceptorChain();
+            if (result == null) throw new IOException("Canceled");
+            return result;
+        } catch (IOException e) {
+            e = timeoutExit(e);
+            // 发生异常，回调 callFailed
+            eventListener.callFailed(this, e);
+            throw e;
+        } finally {
+            // 不管请求成功与否，都进行finished()操作
+            client.dispatcher().finished(this);
+        }
+    }
 
-  @Override public Timeout timeout() {
-    return timeout;
-  }
+    @Nullable
+    IOException timeoutExit(@Nullable IOException cause) {
+        if (!timeout.exit()) return cause;
 
-  @Override public synchronized boolean isExecuted() {
-    return executed;
-  }
+        InterruptedIOException e = new InterruptedIOException("timeout");
+        if (cause != null) {
+            e.initCause(cause);
+        }
+        return e;
+    }
 
-  @Override public boolean isCanceled() {
-    return retryAndFollowUpInterceptor.isCanceled();
-  }
+    private void captureCallStackTrace() {
+        Object callStackTrace = Platform.get().getStackTraceForCloseable("response.body().close()");
+        // retryAndFollowUpInterceptor加入了一个用于追踪堆栈信息的callStackTrace
+        retryAndFollowUpInterceptor.setCallStackTrace(callStackTrace);
+    }
 
-  @SuppressWarnings("CloneDoesntCallSuperClone") // We are a final type & this saves clearing state.
-  @Override public RealCall clone() {
-    return RealCall.newRealCall(client, originalRequest, forWebSocket);
-  }
+    /**
+     * 异步请求方法，此方法会将请求添加到队列中，然后等待请求返回
+     *
+     * @param responseCallback
+     */
+    @Override
+    public void enqueue(Callback responseCallback) {
+        // 1、首先利用 synchronized 加入了对象锁，防止多线程同时调用
+        synchronized (this) {
+            // 判断executed是否为true，
+            // true表示当前的call已经被执行了，那么抛出异常。
+            // false表示没有被执行，那么将executed设置为true，并且继续进行执行。
+            if (executed) throw new IllegalStateException("Already Executed");
+            executed = true;
+        }
+        // 2
+        captureCallStackTrace();
 
-  StreamAllocation streamAllocation() {
-    return retryAndFollowUpInterceptor.streamAllocation();
-  }
+        // 3、回调 callStart
+        eventListener.callStart(this);
 
-  final class AsyncCall extends NamedRunnable {
-    private final Callback responseCallback;
+        // 4、使用分发器
+        client.dispatcher().enqueue(new AsyncCall(responseCallback));
+    }
 
-    AsyncCall(Callback responseCallback) {
-      super("OkHttp %s", redactedUrl());
-      this.responseCallback = responseCallback;
+    /**
+     * 取消请求
+     */
+    @Override
+    public void cancel() {
+        retryAndFollowUpInterceptor.cancel();
     }
 
-    String host() {
-      return originalRequest.url().host();
+    @Override
+    public Timeout timeout() {
+        return timeout;
     }
 
-    Request request() {
-      return originalRequest;
+    /**
+     * 请求是否在执行，
+     * 当execute()或者enqueue(Callback responseCallback)执行后该方法返回true
+     * @return
+     */
+    @Override
+    public synchronized boolean isExecuted() {
+        return executed;
     }
 
-    RealCall get() {
-      return RealCall.this;
+    /**
+     * 请求是否被取消
+     * @return
+     */
+    @Override
+    public boolean isCanceled() {
+        return retryAndFollowUpInterceptor.isCanceled();
     }
 
     /**
-     * Attempt to enqueue this async call on {@code executorService}. This will attempt to clean up
-     * if the executor has been shut down by reporting the call as failed.
+     * 创建一个新的一模一样的请求
+     * @return
      */
-    void executeOn(ExecutorService executorService) {
-      assert (!Thread.holdsLock(client.dispatcher()));
-      boolean success = false;
-      try {
-          // 将该AsyncCall对象加入到线程池中。
-          // 在线程池中，会调用Runnable的run方法，AsyncCall继承自NamedRunnable。
-          // NamedRunnable中的run方法，会执行抽象方法 execute()
-        executorService.execute(this);
-        success = true;
-      } catch (RejectedExecutionException e) {
-           //执行过程中发生了异常
-        InterruptedIOException ioException = new InterruptedIOException("executor rejected");
-        ioException.initCause(e);
-
-        // 回调 callFailed。eventListener是外部类RealCall的属性
-        eventListener.callFailed(RealCall.this, ioException);
-
-        // responseCallback回调onFailure。responseCallback对象是从构造方法中传递过来的
-        responseCallback.onFailure(RealCall.this, ioException);
-      } finally {
-        if (!success) {
-            // 如果线程池处理该请求失败了。调用dispatcher的finish方法。
-            // 成功，在execute()方法中已经执行了dispatcher的finish方法
-          client.dispatcher().finished(this); // This call is no longer running!
-        }
-      }
+    @SuppressWarnings("CloneDoesntCallSuperClone")
+    // We are a final type & this saves clearing state.
+    @Override
+    public RealCall clone() {
+        return RealCall.newRealCall(client, originalRequest, forWebSocket);
+    }
+
+    StreamAllocation streamAllocation() {
+        return retryAndFollowUpInterceptor.streamAllocation();
     }
 
-    @Override protected void execute() {
-      boolean signalledCallback = false;
-      timeout.enter();
-      try {
-        //
-        Response response = getResponseWithInterceptorChain();
-        if (retryAndFollowUpInterceptor.isCanceled()) {
-          signalledCallback = true;
-          responseCallback.onFailure(RealCall.this, new IOException("Canceled"));
-        } else {
-          signalledCallback = true;
-          responseCallback.onResponse(RealCall.this, response);
+    final class AsyncCall extends NamedRunnable {
+        private final Callback responseCallback;
+
+        AsyncCall(Callback responseCallback) {
+            super("OkHttp %s", redactedUrl());
+            this.responseCallback = responseCallback;
+        }
+
+        String host() {
+            return originalRequest.url().host();
         }
-      } catch (IOException e) {
-        e = timeoutExit(e);
-        if (signalledCallback) {
-          // Do not signal the callback twice!
-          Platform.get().log(INFO, "Callback failure for " + toLoggableString(), e);
-        } else {
-          eventListener.callFailed(RealCall.this, e);
-          responseCallback.onFailure(RealCall.this, e);
+
+        Request request() {
+            return originalRequest;
+        }
+
+        RealCall get() {
+            return RealCall.this;
+        }
+
+        /**
+         * Attempt to enqueue this async call on {@code executorService}. This will attempt to clean up
+         * if the executor has been shut down by reporting the call as failed.
+         */
+        void executeOn(ExecutorService executorService) {
+            assert (!Thread.holdsLock(client.dispatcher()));
+            boolean success = false;
+            try {
+                // 将该AsyncCall对象加入到线程池中。
+                // 在线程池中，会调用Runnable的run方法，AsyncCall继承自NamedRunnable。
+                // NamedRunnable中的run方法，会执行抽象方法 execute()
+                executorService.execute(this);
+                success = true;
+            } catch (RejectedExecutionException e) {
+                //执行过程中发生了异常
+                InterruptedIOException ioException = new InterruptedIOException("executor rejected");
+                ioException.initCause(e);
+
+                // 回调 callFailed。eventListener是外部类RealCall的属性
+                eventListener.callFailed(RealCall.this, ioException);
+
+                // responseCallback回调onFailure。responseCallback对象是从构造方法中传递过来的
+                responseCallback.onFailure(RealCall.this, ioException);
+            } finally {
+                if (!success) {
+                    // 如果线程池处理该请求失败了。调用dispatcher的finish方法。
+                    // 成功，在execute()方法中已经执行了dispatcher的finish方法
+                    client.dispatcher().finished(this); // This call is no longer running!
+                }
+            }
+        }
+
+        @Override
+        protected void execute() {
+            boolean signalledCallback = false;
+            timeout.enter();
+            try {
+                //
+                Response response = getResponseWithInterceptorChain();
+                if (retryAndFollowUpInterceptor.isCanceled()) {
+                    signalledCallback = true;
+                    responseCallback.onFailure(RealCall.this, new IOException("Canceled"));
+                } else {
+                    signalledCallback = true;
+                    responseCallback.onResponse(RealCall.this, response);
+                }
+            } catch (IOException e) {
+                e = timeoutExit(e);
+                if (signalledCallback) {
+                    // Do not signal the callback twice!
+                    Platform.get().log(INFO, "Callback failure for " + toLoggableString(), e);
+                } else {
+                    eventListener.callFailed(RealCall.this, e);
+                    responseCallback.onFailure(RealCall.this, e);
+                }
+            } finally {
+                client.dispatcher().finished(this);
+            }
         }
-      } finally {
-        client.dispatcher().finished(this);
-      }
     }
-  }
-
-  /**
-   * Returns a string that describes this call. Doesn't include a full URL as that might contain
-   * sensitive information.
-   */
-  String toLoggableString() {
-    return (isCanceled() ? "canceled " : "")
-        + (forWebSocket ? "web socket" : "call")
-        + " to " + redactedUrl();
-  }
-
-  String redactedUrl() {
-    return originalRequest.url().redact();
-  }
-
-  /**
-   * 真正执行 网络请求的方法
-   * @return
-   * @throws IOException
-   */
-  Response getResponseWithInterceptorChain() throws IOException {
-    // Build a full stack of interceptors.
-    List<Interceptor> interceptors = new ArrayList<>();
-    interceptors.addAll(client.interceptors());
-
-    //失败和重定向过滤器
-    interceptors.add(retryAndFollowUpInterceptor);
-
-    // 封装request和response过滤器
-    interceptors.add(new BridgeInterceptor(client.cookieJar()));
-
-    // 缓存相关的过滤器，负责读取缓存直接返回、更新缓存
-    interceptors.add(new CacheInterceptor(client.internalCache()));
-
-    // 负责和服务器建立连接
-    interceptors.add(new ConnectInterceptor(client));
-
-    if (!forWebSocket) {
-      // 配置 OkHttpClient 时设置的 networkInterceptors
-      interceptors.addAll(client.networkInterceptors());
+
+    /**
+     * Returns a string that describes this call. Doesn't include a full URL as that might contain
+     * sensitive information.
+     */
+    String toLoggableString() {
+        return (isCanceled() ? "canceled " : "")
+                + (forWebSocket ? "web socket" : "call")
+                + " to " + redactedUrl();
+    }
+
+    String redactedUrl() {
+        return originalRequest.url().redact();
     }
 
-    // 负责向服务器发送请求数据、从服务器读取响应数据(实际网络请求)
-    interceptors.add(new CallServerInterceptor(forWebSocket));
+    /**
+     * 真正执行 网络请求的方法
+     *
+     * @return
+     * @throws IOException
+     */
+    Response getResponseWithInterceptorChain() throws IOException {
+        // Build a full stack of interceptors.
+        List<Interceptor> interceptors = new ArrayList<>();
+        interceptors.addAll(client.interceptors());
+
+        //失败和重定向过滤器
+        interceptors.add(retryAndFollowUpInterceptor);
 
-    // 生成 过滤器链
-    Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0,
-        originalRequest, this, eventListener, client.connectTimeoutMillis(),
-        client.readTimeoutMillis(), client.writeTimeoutMillis());
+        // 封装request和response过滤器
+        interceptors.add(new BridgeInterceptor(client.cookieJar()));
 
-    // 执行过滤器
-    return chain.proceed(originalRequest);
-  }
+        // 缓存相关的过滤器，负责读取缓存直接返回、更新缓存
+        interceptors.add(new CacheInterceptor(client.internalCache()));
+
+        // 负责和服务器建立连接
+        interceptors.add(new ConnectInterceptor(client));
+
+        if (!forWebSocket) {
+            // 配置 OkHttpClient 时设置的 networkInterceptors
+            interceptors.addAll(client.networkInterceptors());
+        }
+
+        // 负责向服务器发送请求数据、从服务器读取响应数据(实际网络请求)
+        interceptors.add(new CallServerInterceptor(forWebSocket));
+
+        // 生成 过滤器链
+        Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0,
+                originalRequest, this, eventListener, client.connectTimeoutMillis(),
+                client.readTimeoutMillis(), client.writeTimeoutMillis());
+
+        // 执行过滤器
+        return chain.proceed(originalRequest);
+    }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java b/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java
index 52f9880892..4f4c41082e 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java
@@ -140,6 +140,8 @@ public Response proceed(Request request, StreamAllocation streamAllocation, Http
     }
 
     // Call the next interceptor in the chain.
+    // 创建拦截器链
+    // index+1，访问的时候只能从下一个拦截器访问
     RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,
         connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,
         writeTimeout);
