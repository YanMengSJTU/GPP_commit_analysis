diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
index 3ae2a34572..59b50c70af 100644
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
@@ -71,7 +71,6 @@
 import okhttp3.internal.platform.Platform;
 import okhttp3.internal.ws.RealWebSocket;
 import okhttp3.internal.ws.WebSocketProtocol;
-import okhttp3.WebSocketListener;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -656,22 +655,6 @@ private void handleWebSocketUpgrade(Socket socket, BufferedSource source, Buffer
 
     writeHttpResponse(socket, sink, response);
 
-    final WebSocketListener listener = response.getWebSocketListener();
-    final CountDownLatch connectionClose = new CountDownLatch(1);
-
-    ThreadPoolExecutor replyExecutor =
-        new ThreadPoolExecutor(1, 1, 1, SECONDS, new LinkedBlockingDeque<Runnable>(),
-            Util.threadFactory(Util.format("MockWebServer %s WebSocket", request.getPath()),
-                true));
-    replyExecutor.allowCoreThreadTimeOut(true);
-    final RealWebSocket webSocket =
-        new RealWebSocket(false /* is server */, source, sink, new SecureRandom(), replyExecutor,
-            listener, request.getPath()) {
-          @Override protected void close() throws IOException {
-            connectionClose.countDown();
-          }
-        };
-
     // Adapt the request and response into our Request and Response domain model.
     String scheme = request.getTlsVersion() != null ? "https" : "http";
     String authority = request.getHeader("Host"); // Has host and port.
@@ -687,16 +670,27 @@ private void handleWebSocketUpgrade(Socket socket, BufferedSource source, Buffer
         .protocol(Protocol.HTTP_1_1)
         .build();
 
-    listener.onOpen(webSocket, fancyResponse);
+    String name = request.getPath();
+    ThreadPoolExecutor replyExecutor =
+        new ThreadPoolExecutor(1, 1, 1, SECONDS, new LinkedBlockingDeque<Runnable>(),
+            Util.threadFactory(Util.format("MockWebServer %s WebSocket Replier", name), true));
+    replyExecutor.allowCoreThreadTimeOut(true);
+
+    final CountDownLatch connectionClose = new CountDownLatch(1);
+    RealWebSocket webSocket =
+        new RealWebSocket(false /* is server */, source, sink, new SecureRandom(), replyExecutor,
+            response.getWebSocketListener(), fancyResponse, name) {
+          @Override protected void shutdown() {
+            connectionClose.countDown();
+          }
+        };
 
-    while (webSocket.readMessage()) {
-    }
+    webSocket.loopReader();
 
     // Even if messages are no longer being read we need to wait for the connection close signal.
     try {
       connectionClose.await();
-    } catch (InterruptedException e) {
-      throw new RuntimeException(e);
+    } catch (InterruptedException ignored) {
     }
 
     replyExecutor.shutdown();
diff --git a/okhttp-tests/src/main/java/okhttp3/AutobahnTester.java b/okhttp-tests/src/main/java/okhttp3/AutobahnTester.java
index bb4afa55f1..0c1974af59 100644
--- a/okhttp-tests/src/main/java/okhttp3/AutobahnTester.java
+++ b/okhttp-tests/src/main/java/okhttp3/AutobahnTester.java
@@ -62,7 +62,7 @@ public void run() throws IOException {
     }
   }
 
-  private void runTest(final long number, final long count) throws IOException {
+  private void runTest(final long number, final long count) {
     final CountDownLatch latch = new CountDownLatch(1);
     final AtomicLong startNanos = new AtomicLong();
     newWebSocket("/runCase?case=" + number + "&agent=okhttp") //
@@ -105,8 +105,8 @@ private void runTest(final long number, final long count) throws IOException {
             latch.countDown();
           }
 
-          @Override public void onFailure(IOException e, Response response) {
-            e.printStackTrace(System.out);
+          @Override public void onFailure(Throwable t, Response response) {
+            t.printStackTrace(System.out);
             latch.countDown();
           }
         });
@@ -126,7 +126,7 @@ private void runTest(final long number, final long count) throws IOException {
   private long getTestCount() throws IOException {
     final CountDownLatch latch = new CountDownLatch(1);
     final AtomicLong countRef = new AtomicLong();
-    final AtomicReference<IOException> failureRef = new AtomicReference<>();
+    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
     newWebSocket("/getCaseCount").enqueue(new WebSocketListener() {
       @Override public void onOpen(WebSocket webSocket, Response response) {
       }
@@ -143,8 +143,8 @@ private long getTestCount() throws IOException {
         latch.countDown();
       }
 
-      @Override public void onFailure(IOException e, Response response) {
-        failureRef.set(e);
+      @Override public void onFailure(Throwable t, Response response) {
+        failureRef.set(t);
         latch.countDown();
       }
     });
@@ -155,9 +155,9 @@ private long getTestCount() throws IOException {
     } catch (InterruptedException e) {
       throw new AssertionError();
     }
-    IOException failure = failureRef.get();
+    Throwable failure = failureRef.get();
     if (failure != null) {
-      throw failure;
+      throw new RuntimeException(failure);
     }
     return countRef.get();
   }
@@ -178,7 +178,7 @@ private void updateReports() {
         latch.countDown();
       }
 
-      @Override public void onFailure(IOException e, Response response) {
+      @Override public void onFailure(Throwable t, Response response) {
         latch.countDown();
       }
     });
diff --git a/okhttp-tests/src/test/java/okhttp3/TestLogHandler.java b/okhttp-tests/src/test/java/okhttp3/TestLogHandler.java
index d3745e1a0d..0ec9bc34fb 100644
--- a/okhttp-tests/src/test/java/okhttp3/TestLogHandler.java
+++ b/okhttp-tests/src/test/java/okhttp3/TestLogHandler.java
@@ -15,38 +15,38 @@
  */
 package okhttp3;
 
-import java.util.ArrayList;
-import java.util.List;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.TimeUnit;
 import java.util.logging.Handler;
 import java.util.logging.LogRecord;
-import java.util.logging.SimpleFormatter;
 
 /**
  * A log handler that records which log messages were published so that a calling test can make
  * assertions about them.
  */
 public final class TestLogHandler extends Handler {
-  private final List<String> logs = new ArrayList<>();
+  private final BlockingQueue<String> logs = new LinkedBlockingQueue<>();
 
-  @Override public synchronized void publish(LogRecord logRecord) {
+  @Override public void publish(LogRecord logRecord) {
     if (getFormatter() == null) {
       logs.add(logRecord.getLevel() + ": " + logRecord.getMessage());
     } else {
       logs.add(getFormatter().format(logRecord));
     }
-    notifyAll();
   }
 
   @Override public void flush() {
   }
 
-  @Override public void close() throws SecurityException {
+  @Override public void close() {
   }
 
-  public synchronized String take() throws InterruptedException {
-    while (logs.isEmpty()) {
-      wait();
+  public String take() throws InterruptedException {
+    String message = logs.poll(10, TimeUnit.SECONDS);
+    if (message == null) {
+      throw new AssertionError("Timed out waiting for log message.");
     }
-    return logs.remove(0);
+    return message;
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/WebSocketCallTest.java b/okhttp-tests/src/test/java/okhttp3/WebSocketCallTest.java
index cfa15377f0..4766a7ab27 100644
--- a/okhttp-tests/src/test/java/okhttp3/WebSocketCallTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/WebSocketCallTest.java
@@ -18,26 +18,30 @@
 import java.io.IOException;
 import java.net.ProtocolException;
 import java.util.Random;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicReference;
+import java.util.logging.Logger;
 import okhttp3.internal.tls.SslClient;
+import okhttp3.internal.ws.EmptyWebSocketListener;
 import okhttp3.internal.ws.WebSocketRecorder;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okio.Buffer;
 import org.junit.After;
+import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 
+import static okhttp3.WebSocket.BINARY;
 import static okhttp3.WebSocket.TEXT;
+import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.fail;
 
 public final class WebSocketCallTest {
-  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final MockWebServer webServer = new MockWebServer();
 
   private final SslClient sslClient = SslClient.localhost();
-  private final WebSocketRecorder listener = new WebSocketRecorder();
+  private final WebSocketRecorder clientListener = new WebSocketRecorder("client");
+  private final WebSocketRecorder serverListener = new WebSocketRecorder("server");
   private final Random random = new Random(0);
   private OkHttpClient client = new OkHttpClient.Builder()
       .addInterceptor(new Interceptor() {
@@ -50,132 +54,281 @@
       .build();
 
   @After public void tearDown() {
-    listener.assertExhausted();
+    clientListener.assertExhausted();
   }
 
-  @Test public void clientPingPong() throws IOException {
-    WebSocketListener serverListener = new EmptyWebSocketListener();
-    server.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+  @Test public void textMessage() throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    enqueueClientWebSocket();
 
-    WebSocket webSocket = awaitWebSocket();
-    webSocket.sendPing(new Buffer().writeUtf8("Hello, WebSockets!"));
-    listener.assertPong(new Buffer().writeUtf8("Hello, WebSockets!"));
+    WebSocket client = clientListener.assertOpen();
+    serverListener.assertOpen();
+
+    client.sendMessage(RequestBody.create(TEXT, "Hello, WebSockets!"));
+    serverListener.assertTextMessage("Hello, WebSockets!");
   }
 
-  @Test public void clientMessage() throws IOException {
-    WebSocketRecorder serverListener = new WebSocketRecorder();
-    server.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+  @Test public void binaryMessage() throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    enqueueClientWebSocket();
 
-    WebSocket webSocket = awaitWebSocket();
-    webSocket.sendMessage(RequestBody.create(TEXT, "Hello, WebSockets!"));
-    serverListener.assertTextMessage("Hello, WebSockets!");
+    WebSocket client = clientListener.assertOpen();
+    serverListener.assertOpen();
+
+    client.sendMessage(RequestBody.create(BINARY, "Hello!"));
+    serverListener.assertBinaryMessage(new byte[] {'H', 'e', 'l', 'l', 'o', '!'});
+  }
+
+  @Test public void nullMessageThrows() throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    enqueueClientWebSocket();
+
+    WebSocket client = clientListener.assertOpen();
+    try {
+      client.sendMessage(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertEquals("message == null", e.getMessage());
+    }
+  }
+
+  @Test public void missingContentTypeThrows() throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    enqueueClientWebSocket();
+
+    WebSocket client = clientListener.assertOpen();
+    try {
+      client.sendMessage(RequestBody.create(null, "Hey!"));
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("Message content type was null. Must use WebSocket.TEXT or WebSocket.BINARY.",
+          e.getMessage());
+    }
+  }
+
+  @Test public void unknownContentTypeThrows() throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    enqueueClientWebSocket();
+
+    WebSocket client = clientListener.assertOpen();
+    try {
+      client.sendMessage(RequestBody.create(MediaType.parse("text/plain"), "Hey!"));
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals(
+          "Unknown message content type: text/plain. Must use WebSocket.TEXT or WebSocket.BINARY.",
+          e.getMessage());
+    }
+  }
+
+  @Test public void pingPong() throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    enqueueClientWebSocket();
+
+    WebSocket client = clientListener.assertOpen();
+
+    client.sendPing(new Buffer().writeUtf8("Hello, WebSockets!"));
+    clientListener.assertPong(new Buffer().writeUtf8("Hello, WebSockets!"));
   }
 
   @Test public void serverMessage() throws IOException {
-    WebSocketListener serverListener = new EmptyWebSocketListener() {
-      @Override public void onOpen(final WebSocket webSocket, Response response) {
-        new Thread() {
-          @Override public void run() {
-            try {
-              webSocket.sendMessage(RequestBody.create(TEXT, "Hello, WebSockets!"));
-            } catch (IOException e) {
-              throw new AssertionError(e);
-            }
-          }
-        }.start();
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    enqueueClientWebSocket();
+
+    clientListener.assertOpen();
+    WebSocket server = serverListener.assertOpen();
+
+    server.sendMessage(RequestBody.create(TEXT, "Hello, WebSockets!"));
+    clientListener.assertTextMessage("Hello, WebSockets!");
+  }
+
+  @Test public void throwingOnOpenClosesAndFails() {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+
+    final RuntimeException e = new RuntimeException();
+    clientListener.setNextEventDelegate(new EmptyWebSocketListener() {
+      @Override public void onOpen(WebSocket webSocket, Response response) {
+        throw e;
       }
-    };
-    server.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    });
+    enqueueClientWebSocket();
 
-    awaitWebSocket();
-    listener.assertTextMessage("Hello, WebSockets!");
+    serverListener.assertOpen();
+    serverListener.assertClose(1001, "");
+    clientListener.assertFailure(e);
+  }
+
+  @Ignore("AsyncCall currently lets runtime exceptions propagate.")
+  @Test public void throwingOnFailLogs() throws InterruptedException {
+    TestLogHandler logs = new TestLogHandler();
+    Logger logger = Logger.getLogger(OkHttpClient.class.getName());
+    logger.addHandler(logs);
+
+    webServer.enqueue(new MockResponse().setResponseCode(200).setBody("Body"));
+
+    final RuntimeException e = new RuntimeException();
+    clientListener.setNextEventDelegate(new EmptyWebSocketListener() {
+      @Override public void onFailure(Throwable t, Response response) {
+        throw e;
+      }
+    });
+
+    enqueueClientWebSocket();
+
+    assertEquals("", logs.take());
+    logger.removeHandler(logs);
+  }
+
+  @Test public void throwingOnMessageClosesAndFails() throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    enqueueClientWebSocket();
+
+    clientListener.assertOpen();
+    WebSocket server = serverListener.assertOpen();
+
+    final RuntimeException e = new RuntimeException();
+    clientListener.setNextEventDelegate(new EmptyWebSocketListener() {
+      @Override public void onMessage(ResponseBody message) {
+        throw e;
+      }
+    });
+
+    server.sendMessage(RequestBody.create(TEXT, "Hello, WebSockets!"));
+    clientListener.assertFailure(e);
+    serverListener.assertClose(1001, "");
+  }
+
+  @Test public void throwingOnOnPongClosesAndFails() throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    enqueueClientWebSocket();
+
+    WebSocket client = clientListener.assertOpen();
+    serverListener.assertOpen();
+
+    final RuntimeException e = new RuntimeException();
+    clientListener.setNextEventDelegate(new EmptyWebSocketListener() {
+      @Override public void onPong(Buffer payload) {
+        throw e;
+      }
+    });
+
+    client.sendPing(new Buffer());
+    clientListener.assertFailure(e);
+    serverListener.assertClose(1001, "");
+  }
+
+  @Test public void throwingOnCloseClosesNormallyAndFails() throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    enqueueClientWebSocket();
+
+    clientListener.assertOpen();
+    WebSocket server = serverListener.assertOpen();
+
+    final RuntimeException e = new RuntimeException();
+    clientListener.setNextEventDelegate(new EmptyWebSocketListener() {
+      @Override public void onClose(int code, String reason) {
+        throw e;
+      }
+    });
+
+    server.close(1000, "bye");
+    clientListener.assertFailure(e);
+    serverListener.assertClose(1000, "bye");
   }
 
   @Test public void non101RetainsBody() throws IOException {
-    server.enqueue(new MockResponse().setResponseCode(200).setBody("Body"));
-    awaitWebSocket();
-    listener.assertFailure(ProtocolException.class, "Expected HTTP 101 response but was '200 OK'");
-    listener.assertResponse(200, "Body");
+    webServer.enqueue(new MockResponse().setResponseCode(200).setBody("Body"));
+    enqueueClientWebSocket();
+
+    clientListener.assertFailure(200, "Body", ProtocolException.class,
+        "Expected HTTP 101 response but was '200 OK'");
   }
 
   @Test public void notFound() throws IOException {
-    server.enqueue(new MockResponse().setStatus("HTTP/1.1 404 Not Found"));
-    awaitWebSocket();
-    listener.assertFailure(ProtocolException.class,
+    webServer.enqueue(new MockResponse().setStatus("HTTP/1.1 404 Not Found"));
+    enqueueClientWebSocket();
+
+    clientListener.assertFailure(404, null, ProtocolException.class,
         "Expected HTTP 101 response but was '404 Not Found'");
-    listener.assertResponse(404, "");
   }
 
   @Test public void clientTimeoutClosesBody() throws IOException {
-    server.enqueue(new MockResponse().setResponseCode(408));
-    WebSocketListener serverListener = new EmptyWebSocketListener();
-    server.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    webServer.enqueue(new MockResponse().setResponseCode(408));
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    enqueueClientWebSocket();
+
+    WebSocket client = clientListener.assertOpen();
 
-    WebSocket webSocket = awaitWebSocket();
-    webSocket.sendPing(new Buffer().writeUtf8("WebSockets are fun!"));
-    listener.assertPong(new Buffer().writeUtf8("WebSockets are fun!"));
+    client.sendPing(new Buffer().writeUtf8("WebSockets are fun!"));
+    clientListener.assertPong(new Buffer().writeUtf8("WebSockets are fun!"));
   }
 
-  @Test public void missingConnectionHeader() {
-    server.enqueue(new MockResponse()
+  @Test public void missingConnectionHeader() throws IOException {
+    webServer.enqueue(new MockResponse()
         .setResponseCode(101)
         .setHeader("Upgrade", "websocket")
         .setHeader("Sec-WebSocket-Accept", "ujmZX4KXZqjwy6vi1aQFH5p4Ygk="));
-    awaitWebSocket();
-    listener.assertFailure(ProtocolException.class,
+    enqueueClientWebSocket();
+
+    clientListener.assertFailure(101, null, ProtocolException.class,
         "Expected 'Connection' header value 'Upgrade' but was 'null'");
   }
 
-  @Test public void wrongConnectionHeader() {
-    server.enqueue(new MockResponse()
+  @Test public void wrongConnectionHeader() throws IOException {
+    webServer.enqueue(new MockResponse()
         .setResponseCode(101)
         .setHeader("Upgrade", "websocket")
         .setHeader("Connection", "Downgrade")
         .setHeader("Sec-WebSocket-Accept", "ujmZX4KXZqjwy6vi1aQFH5p4Ygk="));
-    awaitWebSocket();
-    listener.assertFailure(ProtocolException.class,
+    enqueueClientWebSocket();
+
+    clientListener.assertFailure(101, null, ProtocolException.class,
         "Expected 'Connection' header value 'Upgrade' but was 'Downgrade'");
   }
 
-  @Test public void missingUpgradeHeader() {
-    server.enqueue(new MockResponse()
+  @Test public void missingUpgradeHeader() throws IOException {
+    webServer.enqueue(new MockResponse()
         .setResponseCode(101)
         .setHeader("Connection", "Upgrade")
         .setHeader("Sec-WebSocket-Accept", "ujmZX4KXZqjwy6vi1aQFH5p4Ygk="));
-    awaitWebSocket();
-    listener.assertFailure(ProtocolException.class,
+    enqueueClientWebSocket();
+
+    clientListener.assertFailure(101, null, ProtocolException.class,
         "Expected 'Upgrade' header value 'websocket' but was 'null'");
   }
 
-  @Test public void wrongUpgradeHeader() {
-    server.enqueue(new MockResponse()
+  @Test public void wrongUpgradeHeader() throws IOException {
+    webServer.enqueue(new MockResponse()
         .setResponseCode(101)
         .setHeader("Connection", "Upgrade")
         .setHeader("Upgrade", "Pepsi")
         .setHeader("Sec-WebSocket-Accept", "ujmZX4KXZqjwy6vi1aQFH5p4Ygk="));
-    awaitWebSocket();
-    listener.assertFailure(ProtocolException.class,
+    enqueueClientWebSocket();
+
+    clientListener.assertFailure(101, null, ProtocolException.class,
         "Expected 'Upgrade' header value 'websocket' but was 'Pepsi'");
   }
 
-  @Test public void missingMagicHeader() {
-    server.enqueue(new MockResponse()
+  @Test public void missingMagicHeader() throws IOException {
+    webServer.enqueue(new MockResponse()
         .setResponseCode(101)
         .setHeader("Connection", "Upgrade")
         .setHeader("Upgrade", "websocket"));
-    awaitWebSocket();
-    listener.assertFailure(ProtocolException.class,
+    enqueueClientWebSocket();
+
+    clientListener.assertFailure(101, null, ProtocolException.class,
         "Expected 'Sec-WebSocket-Accept' header value 'ujmZX4KXZqjwy6vi1aQFH5p4Ygk=' but was 'null'");
   }
 
-  @Test public void wrongMagicHeader() {
-    server.enqueue(new MockResponse()
+  @Test public void wrongMagicHeader() throws IOException {
+    webServer.enqueue(new MockResponse()
         .setResponseCode(101)
         .setHeader("Connection", "Upgrade")
         .setHeader("Upgrade", "websocket")
         .setHeader("Sec-WebSocket-Accept", "magic"));
-    awaitWebSocket();
-    listener.assertFailure(ProtocolException.class,
+    enqueueClientWebSocket();
+
+    clientListener.assertFailure(101, null, ProtocolException.class,
         "Expected 'Sec-WebSocket-Accept' header value 'ujmZX4KXZqjwy6vi1aQFH5p4Ygk=' but was 'magic'");
   }
 
@@ -188,7 +341,7 @@
   }
 
   @Test public void wssScheme() throws IOException {
-    server.useHttps(sslClient.socketFactory, false);
+    webServer.useHttps(sslClient.socketFactory, false);
     client = client.newBuilder()
         .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
         .hostnameVerifier(new RecordingHostnameVerifier())
@@ -198,7 +351,7 @@
   }
 
   @Test public void httpsScheme() throws IOException {
-    server.useHttps(sslClient.socketFactory, false);
+    webServer.useHttps(sslClient.socketFactory, false);
     client = client.newBuilder()
         .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
         .hostnameVerifier(new RecordingHostnameVerifier())
@@ -208,80 +361,26 @@
   }
 
   private void websocketScheme(String scheme) throws IOException {
-    WebSocketRecorder serverListener = new WebSocketRecorder();
-    server.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
 
-    Request request1 = new Request.Builder()
-        .url(scheme + "://" + server.getHostName() + ":" + server.getPort() + "/")
+    Request request = new Request.Builder()
+        .url(scheme + "://" + webServer.getHostName() + ":" + webServer.getPort() + "/")
         .build();
 
-    WebSocket webSocket = awaitWebSocket(request1);
+    enqueueClientWebSocket(request);
+    WebSocket webSocket = clientListener.assertOpen();
+    serverListener.assertOpen();
+
     webSocket.sendMessage(RequestBody.create(TEXT, "abc"));
     serverListener.assertTextMessage("abc");
   }
 
-  private WebSocket awaitWebSocket() {
-    return awaitWebSocket(new Request.Builder().get().url(server.url("/")).build());
+  private void enqueueClientWebSocket() {
+    enqueueClientWebSocket(new Request.Builder().get().url(webServer.url("/")).build());
   }
 
-  private WebSocket awaitWebSocket(Request request) {
+  private void enqueueClientWebSocket(Request request) {
     WebSocketCall call = new RealWebSocketCall(client, request, random);
-
-    final AtomicReference<Response> responseRef = new AtomicReference<>();
-    final AtomicReference<WebSocket> webSocketRef = new AtomicReference<>();
-    final AtomicReference<IOException> failureRef = new AtomicReference<>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    call.enqueue(new WebSocketListener() {
-      @Override public void onOpen(WebSocket webSocket, Response response) {
-        webSocketRef.set(webSocket);
-        responseRef.set(response);
-        latch.countDown();
-      }
-
-      @Override public void onMessage(ResponseBody message) throws IOException {
-        listener.onMessage(message);
-      }
-
-      @Override public void onPong(Buffer payload) {
-        listener.onPong(payload);
-      }
-
-      @Override public void onClose(int code, String reason) {
-        listener.onClose(code, reason);
-      }
-
-      @Override public void onFailure(IOException e, Response response) {
-        listener.onFailure(e, response);
-        failureRef.set(e);
-        latch.countDown();
-      }
-    });
-
-    try {
-      if (!latch.await(10, TimeUnit.SECONDS)) {
-        throw new AssertionError("Timed out.");
-      }
-    } catch (InterruptedException e) {
-      throw new AssertionError(e);
-    }
-
-    return webSocketRef.get();
-  }
-
-  private static class EmptyWebSocketListener implements WebSocketListener {
-    @Override public void onOpen(WebSocket webSocket, Response response) {
-    }
-
-    @Override public void onMessage(ResponseBody message) throws IOException {
-    }
-
-    @Override public void onPong(Buffer payload) {
-    }
-
-    @Override public void onClose(int code, String reason) {
-    }
-
-    @Override public void onFailure(IOException e, Response response) {
-    }
+    call.enqueue(clientListener);
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/EmptyWebSocketListener.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/EmptyWebSocketListener.java
new file mode 100644
index 0000000000..39c2dd4109
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/ws/EmptyWebSocketListener.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.ws;
+
+import java.io.IOException;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+import okhttp3.WebSocket;
+import okhttp3.WebSocketListener;
+import okio.Buffer;
+
+public class EmptyWebSocketListener implements WebSocketListener {
+  @Override public void onOpen(WebSocket webSocket, Response response) {
+  }
+
+  @Override public void onMessage(ResponseBody message) throws IOException {
+  }
+
+  @Override public void onPong(Buffer payload) {
+  }
+
+  @Override public void onClose(int code, String reason) {
+  }
+
+  @Override public void onFailure(Throwable t, Response response) {
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
index d0c4d9d05b..d48b65895e 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
@@ -21,7 +21,10 @@
 import java.util.Random;
 import java.util.concurrent.Executor;
 import okhttp3.MediaType;
+import okhttp3.Protocol;
+import okhttp3.Request;
 import okhttp3.RequestBody;
+import okhttp3.Response;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -34,7 +37,6 @@
 import org.junit.Before;
 import org.junit.Test;
 
-import static okhttp3.WebSocket.BINARY;
 import static okhttp3.WebSocket.TEXT;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
@@ -52,34 +54,39 @@
   private boolean clientConnectionCloseThrows;
   private boolean clientConnectionClosed;
   private final MemorySocket client2Server = new MemorySocket();
-  private final WebSocketRecorder clientListener = new WebSocketRecorder();
+  private final WebSocketRecorder clientListener = new WebSocketRecorder("client");
 
   private final Executor serverExecutor = new SynchronousExecutor();
   private RealWebSocket server;
   private boolean serverConnectionClosed;
   private final MemorySocket server2client = new MemorySocket();
-  private final WebSocketRecorder serverListener = new WebSocketRecorder();
+  private final WebSocketRecorder serverListener = new WebSocketRecorder("server");
 
   @Before public void setUp() {
     Random random = new Random(0);
     String url = "http://example.com/websocket";
+    Response response = new Response.Builder()
+        .code(101)
+        .request(new Request.Builder().url(url).build())
+        .protocol(Protocol.HTTP_1_1)
+        .build();
 
     client = new RealWebSocket(true, server2client.source(), client2Server.sink(), random,
-        clientExecutor, clientListener, url) {
-      @Override protected void close() throws IOException {
+        clientExecutor, clientListener, response, url) {
+      @Override protected void shutdown() {
         if (clientConnectionClosed) {
           throw new AssertionError("Already closed");
         }
         clientConnectionClosed = true;
 
         if (clientConnectionCloseThrows) {
-          throw new IOException("Oops!");
+          throw new RuntimeException("Oops!");
         }
       }
     };
     server = new RealWebSocket(false, client2Server.source(), server2client.sink(), random,
-        serverExecutor, serverListener, url) {
-      @Override protected void close() throws IOException {
+        serverExecutor, serverListener, response, url) {
+      @Override protected void shutdown() {
         if (serverConnectionClosed) {
           throw new AssertionError("Already closed");
         }
@@ -93,48 +100,6 @@
     serverListener.assertExhausted();
   }
 
-  @Test public void nullMessageThrows() throws IOException {
-    try {
-      client.sendMessage(null);
-      fail();
-    } catch (NullPointerException e) {
-      assertEquals("message == null", e.getMessage());
-    }
-  }
-
-  @Test public void textMessage() throws IOException {
-    client.sendMessage(RequestBody.create(TEXT, "Hello!"));
-    server.readMessage();
-    serverListener.assertTextMessage("Hello!");
-  }
-
-  @Test public void binaryMessage() throws IOException {
-    client.sendMessage(RequestBody.create(BINARY, "Hello!"));
-    server.readMessage();
-    serverListener.assertBinaryMessage(new byte[] {'H', 'e', 'l', 'l', 'o', '!'});
-  }
-
-  @Test public void missingContentTypeThrows() throws IOException {
-    try {
-      client.sendMessage(RequestBody.create(null, "Hey!"));
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertEquals("Message content type was null. Must use WebSocket.TEXT or WebSocket.BINARY.",
-          e.getMessage());
-    }
-  }
-
-  @Test public void unknownContentTypeThrows() throws IOException {
-    try {
-      client.sendMessage(RequestBody.create(MediaType.parse("text/plain"), "Hey!"));
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertEquals(
-          "Unknown message content type: text/plain. Must use WebSocket.TEXT or WebSocket.BINARY.",
-          e.getMessage());
-    }
-  }
-
   @Test public void streamingMessage() throws IOException {
     RequestBody message = new RequestBody() {
       @Override public MediaType contentType() {
@@ -148,11 +113,11 @@
       }
     };
     client.sendMessage(message);
-    server.readMessage();
+    server.processNextFrame();
     serverListener.assertTextMessage("Hello!");
   }
 
-  @Test public void streamingMessageCanInterleavePing() throws IOException, InterruptedException {
+  @Test public void streamingMessageCanInterleavePing() throws IOException {
     RequestBody message = new RequestBody() {
       @Override public MediaType contentType() {
         return TEXT;
@@ -167,30 +132,30 @@
     };
 
     client.sendMessage(message);
-    server.readMessage();
+    server.processNextFrame();
     serverListener.assertTextMessage("Hello!");
-    client.readMessage();
+    client.processNextFrame();
     clientListener.assertPong(new Buffer().writeUtf8("Pong?"));
   }
 
-  @Test public void pingWritesPong() throws IOException, InterruptedException {
+  @Test public void pingWritesPong() throws IOException {
     client.sendPing(new Buffer().writeUtf8("Hello!"));
-    server.readMessage(); // Read the ping, write the pong.
-    client.readMessage(); // Read the pong.
+    server.processNextFrame(); // Read the ping, write the pong.
+    client.processNextFrame(); // Read the pong.
     clientListener.assertPong(new Buffer().writeUtf8("Hello!"));
   }
 
   @Test public void unsolicitedPong() throws IOException {
     client.sendPong(new Buffer().writeUtf8("Hello!"));
-    server.readMessage();
+    server.processNextFrame();
     serverListener.assertPong(new Buffer().writeUtf8("Hello!"));
   }
 
   @Test public void close() throws IOException {
     client.close(1000, "Hello!");
-    assertFalse(server.readMessage()); // This will trigger a close response.
+    assertFalse(server.processNextFrame()); // This will trigger a close response.
     serverListener.assertClose(1000, "Hello!");
-    assertFalse(client.readMessage());
+    assertFalse(client.processNextFrame());
     clientListener.assertClose(1000, "Hello!");
   }
 
@@ -267,7 +232,7 @@
 
   @Test public void serverCloseThenWritingPingThrows() throws IOException {
     server.close(1000, "Hello!");
-    client.readMessage();
+    client.processNextFrame();
     clientListener.assertClose(1000, "Hello!");
 
     try {
@@ -280,7 +245,7 @@
 
   @Test public void serverCloseThenWritingMessageThrows() throws IOException {
     server.close(1000, "Hello!");
-    client.readMessage();
+    client.processNextFrame();
     clientListener.assertClose(1000, "Hello!");
 
     try {
@@ -293,7 +258,7 @@
 
   @Test public void serverCloseThenWritingCloseThrows() throws IOException {
     server.close(1000, "Hello!");
-    client.readMessage();
+    client.processNextFrame();
     clientListener.assertClose(1000, "Hello!");
 
     try {
@@ -315,7 +280,7 @@
         sink.writeUtf8("Hel").flush();
 
         server.close(1000, "Hello!");
-        client.readMessage();
+        client.processNextFrame();
         clientListener.assertClose(1000, "Hello!");
 
         try {
@@ -338,10 +303,10 @@
   @Test public void clientCloseClosesConnection() throws IOException {
     client.close(1000, "Hello!");
     assertFalse(clientConnectionClosed);
-    server.readMessage(); // Read client close, send server close.
+    server.processNextFrame(); // Read client close, send server close.
     serverListener.assertClose(1000, "Hello!");
 
-    client.readMessage(); // Read server close, close connection.
+    client.processNextFrame(); // Read server close, close connection.
     assertTrue(clientConnectionClosed);
     clientListener.assertClose(1000, "Hello!");
   }
@@ -349,11 +314,11 @@
   @Test public void serverCloseClosesConnection() throws IOException {
     server.close(1000, "Hello!");
 
-    client.readMessage(); // Read server close, send client close, close connection.
+    client.processNextFrame(); // Read server close, send client close, close connection.
     assertTrue(clientConnectionClosed);
     clientListener.assertClose(1000, "Hello!");
 
-    server.readMessage();
+    server.processNextFrame();
     serverListener.assertClose(1000, "Hello!");
   }
 
@@ -363,11 +328,11 @@
     client.close(1000, "Hi!");
     assertFalse(clientConnectionClosed);
 
-    client.readMessage(); // Read close, close connection close.
+    client.processNextFrame(); // Read close, close connection close.
     assertTrue(clientConnectionClosed);
     clientListener.assertClose(1000, "Hello!");
 
-    server.readMessage();
+    server.processNextFrame();
     serverListener.assertClose(1000, "Hi!");
 
     serverListener.assertExhausted(); // Client should not have sent second close.
@@ -377,33 +342,50 @@
   @Test public void serverCloseBreaksReadMessageLoop() throws IOException {
     server.sendMessage(RequestBody.create(TEXT, "Hello!"));
     server.close(1000, "Bye!");
-    assertTrue(client.readMessage());
+    assertTrue(client.processNextFrame());
     clientListener.assertTextMessage("Hello!");
-    assertFalse(client.readMessage());
+    assertFalse(client.processNextFrame());
     clientListener.assertClose(1000, "Bye!");
   }
 
-  @Test public void protocolErrorBeforeCloseSendsClose() throws IOException {
+  @Test public void protocolErrorBeforeCloseSendsClose() {
     server2client.raw().write(ByteString.decodeHex("0a00")); // Invalid non-final ping frame.
 
-    client.readMessage(); // Detects error, send close, close connection.
+    client.processNextFrame(); // Detects error, send close, close connection.
     assertTrue(clientConnectionClosed);
     clientListener.assertFailure(ProtocolException.class, "Control frames must be final.");
 
-    server.readMessage();
+    server.processNextFrame();
     serverListener.assertClose(1002, "");
   }
 
+  @Test public void protocolErrorInCloseResponseClosesConnection() throws IOException {
+    client.close(1000, "Hello");
+    assertFalse(clientConnectionClosed); // Not closed until close reply is received.
+
+    // Manually write an invalid masked close frame.
+    server2client.raw().write(ByteString.decodeHex("888760b420bb635c68de0cd84f"));
+
+    client.processNextFrame(); // Detects error, closes connection immediately since close already sent.
+    assertTrue(clientConnectionClosed);
+    clientListener.assertFailure(ProtocolException.class, "Server-sent frames must not be masked.");
+
+    server.processNextFrame();
+    serverListener.assertClose(1000, "Hello");
+
+    serverListener.assertExhausted(); // Client should not have sent second close.
+  }
+
   @Test public void protocolErrorAfterCloseDoesNotSendClose() throws IOException {
     client.close(1000, "Hello!");
     assertFalse(clientConnectionClosed); // Not closed until close reply is received.
     server2client.raw().write(ByteString.decodeHex("0a00")); // Invalid non-final ping frame.
 
-    client.readMessage(); // Detects error, closes connection immediately since close already sent.
+    client.processNextFrame(); // Detects error, closes connection immediately since close already sent.
     assertTrue(clientConnectionClosed);
     clientListener.assertFailure(ProtocolException.class, "Control frames must be final.");
 
-    server.readMessage();
+    server.processNextFrame();
     serverListener.assertClose(1000, "Hello!");
 
     serverListener.assertExhausted(); // Client should not have sent second close.
@@ -420,7 +402,7 @@
     assertTrue(clientConnectionClosed);
   }
 
-  @Test public void closeMessageAndConnectionCloseThrowingDoesNotMaskOriginal() throws IOException {
+  @Test public void closeMessageAndConnectionCloseThrowingDoesNotMaskOriginal() {
     client2Server.close();
     clientConnectionCloseThrows = true;
 
@@ -437,11 +419,11 @@
     clientConnectionCloseThrows = true;
 
     server.close(1000, "Bye!");
-    client.readMessage();
+    client.processNextFrame();
     assertTrue(clientConnectionClosed);
     clientListener.assertClose(1000, "Bye!");
 
-    server.readMessage();
+    server.processNextFrame();
     serverListener.assertClose(1000, "Bye!");
   }
 
@@ -468,7 +450,7 @@ BufferedSource source() {
           return Timeout.NONE;
         }
 
-        @Override public void close() throws IOException {
+        @Override public void close() {
           closed = true;
         }
       });
@@ -481,14 +463,14 @@ BufferedSink sink() {
           buffer.write(source, byteCount);
         }
 
-        @Override public void flush() throws IOException {
+        @Override public void flush() {
         }
 
         @Override public Timeout timeout() {
           return Timeout.NONE;
         }
 
-        @Override public void close() throws IOException {
+        @Override public void close() {
           closed = true;
         }
       });
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
index 57f6ded762..2ca7f4f1e0 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
@@ -23,7 +23,6 @@
 import java.util.regex.Pattern;
 import okhttp3.ResponseBody;
 import okhttp3.internal.Util;
-import okhttp3.internal.ws.WebSocketRecorder.MessageDelegate;
 import okio.Buffer;
 import okio.BufferedSource;
 import okio.ByteString;
@@ -37,12 +36,12 @@
 
 public final class WebSocketReaderTest {
   private final Buffer data = new Buffer();
-  private final WebSocketRecorder callback = new WebSocketRecorder();
+  private final WebSocketRecorder callback = new WebSocketRecorder("client");
   private final Random random = new Random(0);
 
   // Mutually exclusive. Use the one corresponding to the peer whose behavior you wish to test.
-  private final WebSocketReader serverReader = new WebSocketReader(false, data, callback);
-  private final WebSocketReader clientReader = new WebSocketReader(true, data, callback);
+  final WebSocketReader serverReader = new WebSocketReader(false, data, callback.asFrameCallback());
+  final WebSocketReader clientReader = new WebSocketReader(true, data, callback.asFrameCallback());
 
   @After public void tearDown() {
     callback.assertExhausted();
@@ -90,7 +89,7 @@
       serverReader.processNextFrame();
       fail();
     } catch (ProtocolException e) {
-      assertEquals("Client-sent frames must be masked. Server sent must not.", e.getMessage());
+      assertEquals("Client-sent frames must be masked.", e.getMessage());
     }
   }
 
@@ -100,7 +99,7 @@
       clientReader.processNextFrame();
       fail();
     } catch (ProtocolException e) {
-      assertEquals("Client-sent frames must be masked. Server sent must not.", e.getMessage());
+      assertEquals("Server-sent frames must not be masked.", e.getMessage());
     }
   }
 
@@ -152,7 +151,7 @@
     data.write(ByteString.decodeHex("818537fa213d7f9f4d")); // Hel
 
     final Buffer sink = new Buffer();
-    callback.setNextMessageDelegate(new MessageDelegate() {
+    callback.setNextEventDelegate(new EmptyWebSocketListener() {
       @Override public void onMessage(ResponseBody message) throws IOException {
         BufferedSource source = message.source();
         source.readFully(sink, 3); // Read "Hel"
@@ -253,7 +252,7 @@
 
   @Test public void noCloseErrors() throws IOException {
     data.write(ByteString.decodeHex("810548656c6c6f")); // Hello
-    callback.setNextMessageDelegate(new MessageDelegate() {
+    callback.setNextEventDelegate(new EmptyWebSocketListener() {
       @Override public void onMessage(ResponseBody body) throws IOException {
         body.source().readAll(new Buffer());
       }
@@ -271,7 +270,7 @@
     data.write(ByteString.decodeHex("810448657921")); // Hey!
 
     final Buffer sink = new Buffer();
-    callback.setNextMessageDelegate(new MessageDelegate() {
+    callback.setNextEventDelegate(new EmptyWebSocketListener() {
       @Override public void onMessage(ResponseBody message) throws IOException {
         message.source().read(sink, 3);
         message.close();
@@ -293,7 +292,7 @@
     data.write(ByteString.decodeHex("810448657921")); // Hey!
 
     final Buffer sink = new Buffer();
-    callback.setNextMessageDelegate(new MessageDelegate() {
+    callback.setNextEventDelegate(new EmptyWebSocketListener() {
       @Override public void onMessage(ResponseBody message) throws IOException {
         message.source().read(sink, 2);
         message.close();
@@ -313,7 +312,7 @@
     data.write(ByteString.decodeHex("810548656c6c6f")); // Hello
 
     final AtomicReference<Exception> exception = new AtomicReference<>();
-    callback.setNextMessageDelegate(new MessageDelegate() {
+    callback.setNextEventDelegate(new EmptyWebSocketListener() {
       @Override public void onMessage(ResponseBody message) throws IOException {
         message.close();
         try {
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java
index deaf22f34a..d2a0625f16 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java
@@ -24,35 +24,49 @@
 import okhttp3.ResponseBody;
 import okhttp3.WebSocket;
 import okhttp3.WebSocketListener;
+import okhttp3.internal.platform.Platform;
 import okio.Buffer;
 
 import static okhttp3.WebSocket.BINARY;
 import static okhttp3.WebSocket.TEXT;
 import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 
-public final class WebSocketRecorder implements WebSocketReader.FrameCallback, WebSocketListener {
-  public interface MessageDelegate {
-    void onMessage(ResponseBody message) throws IOException;
-  }
-
+public final class WebSocketRecorder implements WebSocketListener {
+  private final String name;
   private final BlockingQueue<Object> events = new LinkedBlockingQueue<>();
-  private MessageDelegate delegate;
-  private Response response;
+  private WebSocketListener delegate;
+
+  public WebSocketRecorder(String name) {
+    this.name = name;
+  }
 
-  /** Sets a delegate for the next call to {@link #onMessage}. Cleared after invoked. */
-  public void setNextMessageDelegate(MessageDelegate delegate) {
+  /** Sets a delegate for handling the next callback to this listener. Cleared after invoked. */
+  public void setNextEventDelegate(WebSocketListener delegate) {
     this.delegate = delegate;
   }
 
   @Override public void onOpen(WebSocket webSocket, Response response) {
+    Platform.get().log(Platform.INFO, "[WS " + name + "] onOpen", null);
+
+    WebSocketListener delegate = this.delegate;
+    if (delegate != null) {
+      this.delegate = null;
+      delegate.onOpen(webSocket, response);
+    } else {
+      events.add(new Open(webSocket, response));
+    }
   }
 
   @Override public void onMessage(ResponseBody message) throws IOException {
+    Platform.get().log(Platform.INFO, "[WS " + name + "] onMessage", null);
+
+    WebSocketListener delegate = this.delegate;
     if (delegate != null) {
+      this.delegate = null;
       delegate.onMessage(message);
-      delegate = null;
     } else {
       Message event = new Message(message.contentType());
       message.source().readAll(event.buffer);
@@ -61,28 +75,47 @@ public void setNextMessageDelegate(MessageDelegate delegate) {
     }
   }
 
-  @Override public void onPing(Buffer buffer) {
-    events.add(new Ping(buffer));
-  }
-
   @Override public void onPong(Buffer buffer) {
-    events.add(new Pong(buffer));
+    Platform.get().log(Platform.INFO, "[WS " + name + "] onPong", null);
+
+    WebSocketListener delegate = this.delegate;
+    if (delegate != null) {
+      this.delegate = null;
+      delegate.onPong(buffer);
+    } else {
+      events.add(new Pong(buffer));
+    }
   }
 
   @Override public void onClose(int code, String reason) {
-    events.add(new Close(code, reason));
+    Platform.get().log(Platform.INFO, "[WS " + name + "] onClose " + code, null);
+
+    WebSocketListener delegate = this.delegate;
+    if (delegate != null) {
+      this.delegate = null;
+      delegate.onClose(code, reason);
+    } else {
+      events.add(new Close(code, reason));
+    }
   }
 
-  @Override public void onFailure(IOException e, Response response) {
-    events.add(e);
-    this.response = response;
+  @Override public void onFailure(Throwable t, Response response) {
+    Platform.get().log(Platform.INFO, "[WS " + name + "] onFailure", t);
+
+    WebSocketListener delegate = this.delegate;
+    if (delegate != null) {
+      this.delegate = null;
+      delegate.onFailure(t, response);
+    } else {
+      events.add(new Failure(t, response));
+    }
   }
 
   private Object nextEvent() {
     try {
       Object event = events.poll(10, TimeUnit.SECONDS);
       if (event == null) {
-        throw new AssertionError("Timed out.");
+        throw new AssertionError("Timed out waiting for event.");
       }
       return event;
     } catch (InterruptedException e) {
@@ -90,113 +123,129 @@ private Object nextEvent() {
     }
   }
 
-  public void assertTextMessage(String payload) throws IOException {
+  public void assertTextMessage(String payload) {
     Message message = new Message(TEXT);
     message.buffer.writeUtf8(payload);
     Object actual = nextEvent();
-    if (actual instanceof IOException) {
-      throw (IOException) actual;
-    }
     assertEquals(message, actual);
   }
 
-  public void assertBinaryMessage(byte[] payload) throws IOException {
+  public void assertBinaryMessage(byte[] payload) {
     Message message = new Message(BINARY);
     message.buffer.write(payload);
     Object actual = nextEvent();
-    if (actual instanceof IOException) {
-      throw (IOException) actual;
-    }
     assertEquals(message, actual);
   }
 
-  public void assertPing(Buffer payload) throws IOException {
+  public void assertPong(Buffer payload) {
     Object actual = nextEvent();
-    if (actual instanceof IOException) {
-      throw (IOException) actual;
-    }
-    assertEquals(new Ping(payload), actual);
+    assertEquals(new Pong(payload), actual);
   }
 
-  public void assertPong(Buffer payload) throws IOException {
+  public void assertClose(int code, String reason) {
     Object actual = nextEvent();
-    if (actual instanceof IOException) {
-      throw (IOException) actual;
-    }
-    assertEquals(new Pong(payload), actual);
+    assertEquals(new Close(code, reason), actual);
   }
 
-  public void assertClose(int code, String reason) throws IOException {
-    Object actual = nextEvent();
-    if (actual instanceof IOException) {
-      throw (IOException) actual;
+  public void assertExhausted() {
+    assertTrue("Remaining events: " + events, events.isEmpty());
+  }
+
+  public WebSocket assertOpen() {
+    Object event = nextEvent();
+    if (!(event instanceof Open)) {
+      throw new AssertionError("Expected Open but was " + event);
     }
-    assertEquals(new Close(code, reason), actual);
+    return ((Open) event).webSocket;
   }
 
-  public void assertFailure(Class<? extends IOException> cls, String message) {
+  public void assertFailure(Throwable t) {
     Object event = nextEvent();
-    String errorMessage =
-        "Expected [" + cls.getName() + ": " + message + "] but was [" + event + "].";
-    assertNotNull(errorMessage, event);
-    assertEquals(errorMessage, cls, event.getClass());
-    assertEquals(errorMessage, cls.cast(event).getMessage(), message);
+    if (!(event instanceof Failure)) {
+      throw new AssertionError("Expected Failure but was " + event);
+    }
+    Failure failure = (Failure) event;
+    assertNull(failure.response);
+    assertSame(t, failure.t);
   }
 
-  public void assertExhausted() {
-    assertTrue("Remaining events: " + events, events.isEmpty());
+  public void assertFailure(Class<? extends IOException> cls, String message) {
+    Object event = nextEvent();
+    if (!(event instanceof Failure)) {
+      throw new AssertionError("Expected Failure but was " + event);
+    }
+    Failure failure = (Failure) event;
+    assertNull(failure.response);
+    assertEquals(cls, failure.t.getClass());
+    assertEquals(message, failure.t.getMessage());
   }
 
-  public void assertResponse(int code, String body) throws IOException {
-    assertNotNull(response);
-    assertEquals(code, response.code());
-    assertEquals(body, response.body().string());
+  public void assertFailure(int code, String body, Class<? extends IOException> cls, String message)
+      throws IOException {
+    Object event = nextEvent();
+    if (!(event instanceof Failure)) {
+      throw new AssertionError("Expected Failure but was " + event);
+    }
+    Failure failure = (Failure) event;
+    assertEquals(code, failure.response.code());
+    if (body != null) {
+      assertEquals(body, failure.response.body().string());
+    }
+    assertEquals(cls, failure.t.getClass());
+    assertEquals(message, failure.t.getMessage());
   }
 
-  static final class Message {
-    public final MediaType mediaType;
-    public final Buffer buffer = new Buffer();
+  static final class Open {
+    final WebSocket webSocket;
+    final Response response;
 
-    Message(MediaType mediaType) {
-      this.mediaType = mediaType;
+    Open(WebSocket webSocket, Response response) {
+      this.webSocket = webSocket;
+      this.response = response;
     }
 
     @Override public String toString() {
-      return "Message[" + mediaType + " " + buffer + "]";
+      return "Open[" + response + "]";
     }
+  }
 
-    @Override public int hashCode() {
-      return mediaType.hashCode() * 37 + buffer.hashCode();
+  static final class Failure {
+    final Throwable t;
+    final Response response;
+
+    Failure(Throwable t, Response response) {
+      this.t = t;
+      this.response = response;
     }
 
-    @Override public boolean equals(Object obj) {
-      if (obj instanceof Message) {
-        Message other = (Message) obj;
-        return mediaType.equals(other.mediaType) && buffer.equals(other.buffer);
+    @Override public String toString() {
+      if (response == null) {
+        return "Failure[" + t + "]";
       }
-      return false;
+      return "Failure[" + response + "]";
     }
   }
 
-  static final class Ping {
-    public final Buffer buffer;
+  static final class Message {
+    public final MediaType mediaType;
+    public final Buffer buffer = new Buffer();
 
-    Ping(Buffer buffer) {
-      this.buffer = buffer;
+    Message(MediaType mediaType) {
+      this.mediaType = mediaType;
     }
 
     @Override public String toString() {
-      return "Ping[" + buffer + "]";
+      return "Message[" + mediaType + " " + buffer + "]";
     }
 
     @Override public int hashCode() {
-      return buffer.hashCode();
+      return mediaType.hashCode() * 37 + buffer.hashCode();
     }
 
     @Override public boolean equals(Object obj) {
-      if (obj instanceof Ping) {
-        Ping other = (Ping) obj;
-        return buffer == null ? other.buffer == null : buffer.equals(other.buffer);
+      if (obj instanceof Message) {
+        Message other = (Message) obj;
+        return mediaType.equals(other.mediaType) && buffer.equals(other.buffer);
       }
       return false;
     }
@@ -251,4 +300,54 @@ public void assertResponse(int code, String body) throws IOException {
       return false;
     }
   }
+
+  /** Expose this recorder as a frame callback and shim in "ping" events. */
+  WebSocketReader.FrameCallback asFrameCallback() {
+    return new WebSocketReader.FrameCallback() {
+      @Override public void onReadMessage(ResponseBody body) throws IOException {
+        onMessage(body);
+      }
+
+      @Override public void onReadPing(Buffer buffer) {
+        events.add(new Ping(buffer));
+      }
+
+      @Override public void onReadPong(Buffer buffer) {
+        onPong(buffer);
+      }
+
+      @Override public void onReadClose(int code, String reason) {
+        onClose(code, reason);
+      }
+    };
+  }
+
+  void assertPing(Buffer payload) {
+    Object actual = nextEvent();
+    assertEquals(new Ping(payload), actual);
+  }
+
+  static final class Ping {
+    public final Buffer buffer;
+
+    Ping(Buffer buffer) {
+      this.buffer = buffer;
+    }
+
+    @Override public String toString() {
+      return "Ping[" + buffer + "]";
+    }
+
+    @Override public int hashCode() {
+      return buffer.hashCode();
+    }
+
+    @Override public boolean equals(Object obj) {
+      if (obj instanceof Ping) {
+        Ping other = (Ping) obj;
+        return buffer == null ? other.buffer == null : buffer.equals(other.buffer);
+      }
+      return false;
+    }
+  }
 }
diff --git a/okhttp/src/main/java/okhttp3/RealCall.java b/okhttp/src/main/java/okhttp3/RealCall.java
index 877faa225c..3c027a2caf 100644
--- a/okhttp/src/main/java/okhttp3/RealCall.java
+++ b/okhttp/src/main/java/okhttp3/RealCall.java
@@ -31,18 +31,20 @@
 import static okhttp3.internal.platform.Platform.INFO;
 
 final class RealCall implements Call {
-  private final OkHttpClient client;
-  private final RetryAndFollowUpInterceptor retryAndFollowUpInterceptor;
+  final OkHttpClient client;
+  final RetryAndFollowUpInterceptor retryAndFollowUpInterceptor;
+
+  /** The application's original request unadulterated by redirects or auth headers. */
+  final Request originalRequest;
+  final boolean forWebSocket;
 
   // Guarded by this.
   private boolean executed;
 
-  /** The application's original request unadulterated by redirects or auth headers. */
-  Request originalRequest;
-
   RealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {
     this.client = client;
     this.originalRequest = originalRequest;
+    this.forWebSocket = forWebSocket;
     this.retryAndFollowUpInterceptor = new RetryAndFollowUpInterceptor(client, forWebSocket);
   }
 
@@ -94,7 +96,7 @@ private void captureCallStackTrace() {
 
   @SuppressWarnings("CloneDoesntCallSuperClone") // We are a final type & this saves clearing state.
   @Override public RealCall clone() {
-    return new RealCall(client, originalRequest, retryAndFollowUpInterceptor.isForWebSocket());
+    return new RealCall(client, originalRequest, forWebSocket);
   }
 
   StreamAllocation streamAllocation() {
@@ -104,7 +106,7 @@ StreamAllocation streamAllocation() {
   final class AsyncCall extends NamedRunnable {
     private final Callback responseCallback;
 
-    private AsyncCall(Callback responseCallback) {
+    AsyncCall(Callback responseCallback) {
       super("OkHttp %s", redactedUrl());
       this.responseCallback = responseCallback;
     }
@@ -149,16 +151,17 @@ RealCall get() {
    * Returns a string that describes this call. Doesn't include a full URL as that might contain
    * sensitive information.
    */
-  private String toLoggableString() {
-    String string = retryAndFollowUpInterceptor.isCanceled() ? "canceled call" : "call";
-    return string + " to " + redactedUrl();
+  String toLoggableString() {
+    return (isCanceled() ? "canceled " : "")
+        + (forWebSocket ? "web socket" : "call")
+        + " to " + redactedUrl();
   }
 
   String redactedUrl() {
     return originalRequest.url().redact().toString();
   }
 
-  private Response getResponseWithInterceptorChain() throws IOException {
+  Response getResponseWithInterceptorChain() throws IOException {
     // Build a full stack of interceptors.
     List<Interceptor> interceptors = new ArrayList<>();
     interceptors.addAll(client.interceptors());
@@ -166,11 +169,10 @@ private Response getResponseWithInterceptorChain() throws IOException {
     interceptors.add(new BridgeInterceptor(client.cookieJar()));
     interceptors.add(new CacheInterceptor(client.internalCache()));
     interceptors.add(new ConnectInterceptor(client));
-    if (!retryAndFollowUpInterceptor.isForWebSocket()) {
+    if (!forWebSocket) {
       interceptors.addAll(client.networkInterceptors());
     }
-    interceptors.add(new CallServerInterceptor(
-        retryAndFollowUpInterceptor.isForWebSocket()));
+    interceptors.add(new CallServerInterceptor(forWebSocket));
 
     Interceptor.Chain chain = new RealInterceptorChain(
         interceptors, null, null, null, 0, originalRequest);
diff --git a/okhttp/src/main/java/okhttp3/RealWebSocketCall.java b/okhttp/src/main/java/okhttp3/RealWebSocketCall.java
index 6173b5e477..6cb3e010f7 100644
--- a/okhttp/src/main/java/okhttp3/RealWebSocketCall.java
+++ b/okhttp/src/main/java/okhttp3/RealWebSocketCall.java
@@ -72,11 +72,15 @@
   @Override public void enqueue(final WebSocketListener listener) {
     Callback responseCallback = new Callback() {
       @Override public void onResponse(Call call, Response response) {
+        StreamWebSocket webSocket;
         try {
-          createWebSocket(response, listener);
+          webSocket = create(response, listener);
         } catch (IOException e) {
           listener.onFailure(e, response);
+          return;
         }
+
+        webSocket.loopReader();
       }
 
       @Override public void onFailure(Call call, IOException e) {
@@ -90,7 +94,7 @@
     call.cancel();
   }
 
-  private void createWebSocket(Response response, WebSocketListener listener) throws IOException {
+  StreamWebSocket create(Response response, WebSocketListener listener) throws IOException {
     if (response.code() != 101) {
       throw new ProtocolException("Expected HTTP 101 response but was '"
           + response.code()
@@ -119,42 +123,32 @@ private void createWebSocket(Response response, WebSocketListener listener) thro
           + "'");
     }
 
-    StreamAllocation streamAllocation = call.streamAllocation();
-    RealWebSocket webSocket = StreamWebSocket.create(streamAllocation, response, random, listener);
-
-    listener.onOpen(webSocket, response);
+    String name = response.request().url().redact().toString();
+    ThreadPoolExecutor replyExecutor =
+        new ThreadPoolExecutor(1, 1, 1, SECONDS, new LinkedBlockingDeque<Runnable>(),
+            Util.threadFactory(Util.format("OkHttp %s WebSocket Replier", name), true));
+    replyExecutor.allowCoreThreadTimeOut(true);
 
-    while (webSocket.readMessage()) {
-    }
+    StreamAllocation streamAllocation = call.streamAllocation();
+    streamAllocation.noNewStreams(); // Web socket connections can't be re-used.
+    return new StreamWebSocket(streamAllocation, random, replyExecutor, listener, response, name);
   }
 
   // Keep static so that the WebSocketCall instance can be garbage collected.
-  private static class StreamWebSocket extends RealWebSocket {
-    static RealWebSocket create(StreamAllocation streamAllocation, Response response,
-        Random random, WebSocketListener listener) {
-      String url = response.request().url().redact().toString();
-      ThreadPoolExecutor replyExecutor =
-          new ThreadPoolExecutor(1, 1, 1, SECONDS, new LinkedBlockingDeque<Runnable>(),
-              Util.threadFactory(Util.format("OkHttp %s WebSocket", url), true));
-      replyExecutor.allowCoreThreadTimeOut(true);
-
-      return new StreamWebSocket(streamAllocation, random, replyExecutor, listener, url);
-    }
-
+  static final class StreamWebSocket extends RealWebSocket {
     private final StreamAllocation streamAllocation;
-    private final ExecutorService replyExecutor;
+    private final ExecutorService executor;
 
-    private StreamWebSocket(StreamAllocation streamAllocation,
-        Random random, ExecutorService replyExecutor, WebSocketListener listener, String url) {
+    StreamWebSocket(StreamAllocation streamAllocation, Random random, ExecutorService executor,
+        WebSocketListener listener, Response response, String name) {
       super(true /* is client */, streamAllocation.connection().source,
-          streamAllocation.connection().sink, random, replyExecutor, listener, url);
+          streamAllocation.connection().sink, random, executor, listener, response, name);
       this.streamAllocation = streamAllocation;
-      this.replyExecutor = replyExecutor;
+      this.executor = executor;
     }
 
-    @Override protected void close() throws IOException {
-      replyExecutor.shutdown();
-      streamAllocation.noNewStreams();
+    @Override protected void shutdown() {
+      executor.shutdown();
       streamAllocation.streamFinished(true, streamAllocation.codec());
     }
   }
diff --git a/okhttp/src/main/java/okhttp3/WebSocketListener.java b/okhttp/src/main/java/okhttp3/WebSocketListener.java
index 2798b10e64..38ce997eb2 100644
--- a/okhttp/src/main/java/okhttp3/WebSocketListener.java
+++ b/okhttp/src/main/java/okhttp3/WebSocketListener.java
@@ -18,26 +18,33 @@
 import java.io.IOException;
 import okio.Buffer;
 
-/** Listener for server-initiated messages on a connected {@link WebSocket}. */
+/**
+ * Listener for server-initiated messages on a connected {@link WebSocket}. All callbacks will be
+ * called on a single thread.
+ *
+ * <h2>Lifecycle Rules</h2>
+ * <ul>
+ * <li>Either {@link #onOpen} or {@link #onFailure} will be called first depending on if the web
+ * socket was successfully opened or if there was an error connecting to the server or parsing its
+ * response.</li>
+ * <li>After {@link #onOpen} is called, {@link #onFailure} can be called at any time. No more
+ * callbacks will follow a call to {@link #onFailure}.</li>
+ * <li>After {@link #onOpen} is called, {@link #onMessage} and {@link #onPong} will be called for
+ * each message and pong frame, respectively. Note: {@link #onPong} may be called while {@link
+ * #onMessage} is reading the message because pong frames may interleave in the message body.</li>
+ * <li>After {@link #onOpen} is called, {@link #onClose} may be called once. No calls to {@link
+ * #onMessage} or {@link #onPong} will follow a call to {@link #onClose}.</li>
+ * <li>{@link #onFailure} will be called if any of the other callbacks throws an exception.</li>
+ * </ul>
+ */
 public interface WebSocketListener {
   /**
-   * Called when the request has successfully been upgraded to a web socket. This method is called
-   * on the message reading thread to allow setting up any state before the {@linkplain #onMessage
-   * message}, {@linkplain #onPong pong}, and {@link #onClose close} callbacks start.
-   *
-   * <p><b>Do not</b> use this callback to write to the web socket. Start a new thread or use
-   * another thread in your application.
+   * Called when the request has successfully been upgraded to a web socket. <b>Do not</b> use this
+   * callback to write to the web socket. Start a new thread or use another thread in your
+   * application.
    */
   void onOpen(WebSocket webSocket, Response response);
 
-  /**
-   * Called when the transport or protocol layer of this web socket errors during communication.
-   *
-   * @param response Present when the failure is a direct result of the response (e.g., failed
-   * upgrade, non-101 response code, etc.). {@code null} otherwise.
-   */
-  void onFailure(IOException e, Response response);
-
   /**
    * Called when a server message is received. The {@code type} indicates whether the {@code
    * payload} should be interpreted as UTF-8 text or binary data.
@@ -53,17 +60,31 @@
 
   /**
    * Called when a server pong is received. This is usually a result of calling {@link
-   * WebSocket#sendPing(Buffer)} but might also be unsolicited.
+   * WebSocket#sendPing(Buffer)} but might also be unsolicited directly from the server.
    */
   void onPong(Buffer payload);
 
   /**
    * Called when the server sends a close message. This may have been initiated from a call to
    * {@link WebSocket#close(int, String) close()} or as an unprompted message from the server.
+   * If you did not explicitly call {@link WebSocket#close(int, String) close()}, you do not need
+   * to do so in response to this callback. A matching close frame is automatically sent back to
+   * the server.
    *
    * @param code The <a href="http://tools.ietf.org/html/rfc6455#section-7.4.1">RFC-compliant</a>
    * status code.
    * @param reason Reason for close or an empty string.
    */
   void onClose(int code, String reason);
+
+  /**
+   * Called when the transport or protocol layer of this web socket errors during communication, or
+   * when another listener callback throws an exception. If the web socket was successfully
+   * {@linkplain #onOpen opened} before this callback, it will have been closed automatically and
+   * future interactions with it will throw {@link IOException}.
+   *
+   * @param response Non-null when the failure is because of an unexpected HTTP response (e.g.,
+   * failed upgrade, non-101 response code, etc.).
+   */
+  void onFailure(Throwable t, Response response);
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/Util.java b/okhttp/src/main/java/okhttp3/internal/Util.java
index fa9ee19c49..d31b55ae10 100644
--- a/okhttp/src/main/java/okhttp3/internal/Util.java
+++ b/okhttp/src/main/java/okhttp3/internal/Util.java
@@ -463,4 +463,11 @@ public static Charset bomAwareCharset(BufferedSource source, Charset charset) th
     }
     return charset;
   }
+
+  /** Re-throws {@code t} if it is a fatal exception which should not be handled. */
+  public static void throwIfFatal(Throwable t) {
+    if (t instanceof VirtualMachineError) throw (VirtualMachineError) t;
+    if (t instanceof ThreadDeath) throw (ThreadDeath) t;
+    if (t instanceof LinkageError) throw (LinkageError) t;
+  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
index 9d0f92f062..2a7cd13822 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
@@ -91,10 +91,6 @@ public boolean isCanceled() {
     return canceled;
   }
 
-  public boolean isForWebSocket() {
-    return forWebSocket;
-  }
-
   public void setCallStackTrace(Object callStackTrace) {
     this.callStackTrace = callStackTrace;
   }
diff --git a/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java b/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java
index 29b5e73055..61caff8221 100644
--- a/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java
+++ b/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java
@@ -22,92 +22,209 @@
 import java.util.concurrent.atomic.AtomicBoolean;
 import okhttp3.MediaType;
 import okhttp3.RequestBody;
+import okhttp3.Response;
 import okhttp3.ResponseBody;
 import okhttp3.WebSocket;
 import okhttp3.WebSocketListener;
 import okhttp3.internal.NamedRunnable;
+import okhttp3.internal.Util;
+import okhttp3.internal.platform.Platform;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
 import okio.Okio;
 
+import static okhttp3.internal.platform.Platform.INFO;
 import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_BINARY;
 import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_TEXT;
 import static okhttp3.internal.ws.WebSocketReader.FrameCallback;
 
+/**
+ * An implementation of {@link WebSocket} which sits on top of {@link WebSocketReader} and
+ * {@link WebSocketWriter}.
+ *
+ * <h2>Threading</h2>
+ * This class deals with three threads concurrently and care must be taken to only access the
+ * appropriate resources on each:
+ * <ul>
+ * <li><b>Reader</b>: This is the only thread allowed to access {@link #reader}. Methods from
+ * {@link FrameCallback} will happen on this thread as a result. This is the only thread that
+ * should invoke methods on the {@link #readerListener}.</li>
+ * <li><b>Replier</b>: Invoked on {@link #replier} to write responses from reading
+ * frames. Contends with the "Sender" thread for access to {@link #writer}.</li>
+ * <li><b>Sender</b>: Methods from {@link WebSocket} will happen on this thread. Contends with the
+ * "Replier" thread</li>
+ * </ul>
+ * Instance variables have prefixes matching the thread names based on the thread on which they can
+ * be accessed. A prefix of "writer" indicates both "Sender" and "Replier" threads can access.
+ */
 public abstract class RealWebSocket implements WebSocket, FrameCallback {
+  private static final int CLOSE_LISTENER_EXCEPTION = 1001;
   private static final int CLOSE_PROTOCOL_EXCEPTION = 1002;
 
-  private final Executor replyExecutor;
-  private final WebSocketListener listener;
-  private final String url;
-
-  private final WebSocketWriter writer;
   private final WebSocketReader reader;
+  private final WebSocketListener readerListener;
+  /** True after a close frame was read by the reader. No frames will follow it. */
+  private boolean readerSawClose;
+
+  final WebSocketWriter writer;
+  /** True after calling {@link WebSocketWriter#writeClose(int, String)} to send a close frame. */
+  final AtomicBoolean writerClosed = new AtomicBoolean();
+
+  /** Guarded by itself. Must check {@link #isShutdown} before enqueuing work. */
+  private final Executor replier;
 
   /** True after calling {@link #close(int, String)}. No writes are allowed afterward. */
-  private volatile boolean writerSentClose;
+  private boolean senderSentClose;
   /** True after {@link IOException}. {@link #close(int, String)} becomes only valid call. */
-  private boolean writerWantsClose;
-  /** True after a close frame was read by the reader. No frames will follow it. */
-  private boolean readerSentClose;
+  private boolean senderWantsClose;
+
+  private final Response response;
+  private final String name;
 
-  /** True after calling {@link #close()} to free connection resources. */
-  private final AtomicBoolean connectionClosed = new AtomicBoolean();
+  /** Guarded by {@link #replier}. True after calling {@link #shutdown()}. */
+  private boolean isShutdown;
 
   protected RealWebSocket(boolean isClient, BufferedSource source, BufferedSink sink, Random random,
-      Executor replyExecutor, WebSocketListener listener, String url) {
-    this.replyExecutor = replyExecutor;
-    this.listener = listener;
-    this.url = url;
+      Executor replier, WebSocketListener readerListener, Response response, String name) {
+    this.readerListener = readerListener;
+    this.replier = replier;
+    this.response = response;
+    this.name = name;
 
-    writer = new WebSocketWriter(isClient, sink, random);
     reader = new WebSocketReader(isClient, source, this);
+    writer = new WebSocketWriter(isClient, sink, random);
   }
 
-  @Override public final void onMessage(ResponseBody message) throws IOException {
-    listener.onMessage(message);
+  ////// READER THREAD
+
+  /** Read and process all socket messages delivering callbacks to the supplied listener. */
+  public final void loopReader() {
+    try {
+      readerListener.onOpen(this, response);
+    } catch (Throwable t) {
+      Util.throwIfFatal(t);
+      replyToReaderError(t);
+      readerListener.onFailure(t, null);
+      return;
+    }
+
+    while (processNextFrame()) {
+    }
   }
 
-  @Override public final void onPing(final Buffer buffer) {
-    replyExecutor.execute(new NamedRunnable("OkHttp %s WebSocket Pong Reply", url) {
-      @Override protected void execute() {
-        peerPing(buffer);
-      }
-    });
+  /**
+   * Read a single control frame or all frames of a message from the web socket and deliver any
+   * notifications to the listener. Returns false when no more messages can be read.
+   */
+  final boolean processNextFrame() {
+    try {
+      // This method call results in one or more onRead* methods being called on this thread.
+      reader.processNextFrame();
+
+      return !readerSawClose;
+    } catch (Throwable t) {
+      Util.throwIfFatal(t);
+      replyToReaderError(t);
+      readerListener.onFailure(t, null);
+      return false;
+    }
+  }
+
+  @Override public final void onReadMessage(ResponseBody message) throws IOException {
+    readerListener.onMessage(message);
+  }
+
+  @Override public final void onReadPing(Buffer buffer) {
+    replyToPeerPing(buffer);
+  }
+
+  @Override public final void onReadPong(Buffer buffer) {
+    readerListener.onPong(buffer);
   }
 
-  @Override public final void onPong(Buffer buffer) {
-    listener.onPong(buffer);
+  @Override public final void onReadClose(int code, String reason) {
+    replyToPeerClose(code, reason);
+    readerSawClose = true;
+    readerListener.onClose(code, reason);
   }
 
-  @Override public final void onClose(final int code, final String reason) {
-    readerSentClose = true;
-    replyExecutor.execute(new NamedRunnable("OkHttp %s WebSocket Close Reply", url) {
+  ///// REPLIER THREAD (executed on replier, contends with sender thread)
+
+  /** Replies with a pong when a ping frame is read from the peer. */
+  private void replyToPeerPing(final Buffer payload) {
+    Runnable replierPong = new NamedRunnable("OkHttp %s WebSocket Pong Reply", name) {
       @Override protected void execute() {
-        peerClose(code, reason);
+        try {
+          writer.writePong(payload);
+        } catch (IOException t) {
+          Platform.get().log(INFO, "Unable to send pong reply in response to peer ping.", t);
+        }
+      }
+    };
+    synchronized (replier) {
+      if (!isShutdown) {
+        replier.execute(replierPong);
       }
-    });
+    }
   }
 
-  /**
-   * Read a single message from the web socket and deliver it to the listener. This method should be
-   * called in a loop with the return value indicating whether looping should continue.
-   */
-  public final boolean readMessage() {
-    try {
-      reader.processNextFrame();
-      return !readerSentClose;
-    } catch (IOException e) {
-      readerErrorClose(e);
-      return false;
+  /** Replies and closes this web socket when a close frame is read from the peer. */
+  private void replyToPeerClose(final int code, final String reason) {
+    Runnable replierClose = new NamedRunnable("OkHttp %s WebSocket Close Reply", name) {
+      @Override protected void execute() {
+        if (writerClosed.compareAndSet(false, true)) {
+          try {
+            writer.writeClose(code, reason);
+          } catch (IOException t) {
+            Platform.get().log(INFO, "Unable to send close reply in response to peer close.", t);
+          }
+        }
+
+        quietlyCloseConnection();
+      }
+    };
+    synchronized (replier) {
+      if (!isShutdown) {
+        replier.execute(replierClose);
+      }
+    }
+  }
+
+  private void replyToReaderError(final Throwable t) {
+    Runnable replierClose = new NamedRunnable("OkHttp %s WebSocket Fatal Reply", name) {
+      @Override protected void execute() {
+        if (writerClosed.compareAndSet(false, true)) {
+          // For protocol and runtime exceptions, try to inform the server of such.
+          boolean protocolException = t instanceof ProtocolException;
+          boolean runtimeException = !(t instanceof IOException);
+          if (protocolException || runtimeException) {
+            int code = protocolException ? CLOSE_PROTOCOL_EXCEPTION : CLOSE_LISTENER_EXCEPTION;
+            try {
+              writer.writeClose(code, null);
+            } catch (IOException inner) {
+              Platform.get()
+                  .log(INFO, "Unable to send close in response to listener error.", inner);
+            }
+          }
+        }
+
+        quietlyCloseConnection();
+      }
+    };
+    synchronized (replier) {
+      if (!isShutdown) {
+        replier.execute(replierClose);
+      }
     }
   }
 
+  ////// SENDER THREAD (aka user thread)
+
   @Override public final void sendMessage(RequestBody message) throws IOException {
     if (message == null) throw new NullPointerException("message == null");
-    if (writerSentClose) throw new IllegalStateException("closed");
-    if (writerWantsClose) throw new IllegalStateException("must call close()");
+    if (senderSentClose) throw new IllegalStateException("closed");
+    if (senderWantsClose) throw new IllegalStateException("must call close()");
 
     MediaType contentType = message.contentType();
     if (contentType == null) {
@@ -132,101 +249,68 @@ public final boolean readMessage() {
       message.writeTo(sink);
       sink.close();
     } catch (IOException e) {
-      writerWantsClose = true;
+      senderWantsClose = true;
       throw e;
     }
   }
 
   @Override public final void sendPing(Buffer payload) throws IOException {
-    if (writerSentClose) throw new IllegalStateException("closed");
-    if (writerWantsClose) throw new IllegalStateException("must call close()");
+    if (senderSentClose) throw new IllegalStateException("closed");
+    if (senderWantsClose) throw new IllegalStateException("must call close()");
 
     try {
       writer.writePing(payload);
     } catch (IOException e) {
-      writerWantsClose = true;
+      senderWantsClose = true;
       throw e;
     }
   }
 
   /** Send an unsolicited pong with the specified payload. */
   final void sendPong(Buffer payload) throws IOException {
-    if (writerSentClose) throw new IllegalStateException("closed");
-    if (writerWantsClose) throw new IllegalStateException("must call close()");
+    if (senderSentClose) throw new IllegalStateException("closed");
+    if (senderWantsClose) throw new IllegalStateException("must call close()");
 
     try {
       writer.writePong(payload);
     } catch (IOException e) {
-      writerWantsClose = true;
+      senderWantsClose = true;
       throw e;
     }
   }
 
   @Override public final void close(int code, String reason) throws IOException {
-    if (writerSentClose) throw new IllegalStateException("closed");
-    writerSentClose = true;
+    if (senderSentClose) throw new IllegalStateException("closed");
+    senderSentClose = true;
+
+    // Not doing a CAS because we want writer to throw if already closed via peer close.
+    writerClosed.set(true);
 
     try {
       writer.writeClose(code, reason);
     } catch (IOException e) {
-      if (connectionClosed.compareAndSet(false, true)) {
-        // Try to close the connection without masking the original exception.
-        try {
-          close();
-        } catch (IOException ignored) {
-        }
-      }
+      quietlyCloseConnection();
       throw e;
     }
-  }
 
-  /** Replies with a pong when a ping frame is read from the peer. */
-  void peerPing(Buffer payload) {
-    try {
-      writer.writePong(payload);
-    } catch (IOException ignored) {
-    }
+    // NOTE: We do not close the connection here! That will happen when we read the close reply.
   }
 
-  /** Replies and closes this web socket when a close frame is read from the peer. */
-  void peerClose(int code, String reason) {
-    if (!writerSentClose) {
-      try {
-        writer.writeClose(code, reason);
-      } catch (IOException ignored) {
-      }
-    }
+  ////// ANY THREAD
 
-    if (connectionClosed.compareAndSet(false, true)) {
-      try {
-        close();
-      } catch (IOException ignored) {
-      }
+  void quietlyCloseConnection() {
+    synchronized (replier) {
+      if (isShutdown) return;
+      isShutdown = true;
     }
-
-    listener.onClose(code, reason);
-  }
-
-  /** Called on the reader thread when an error occurs. */
-  private void readerErrorClose(IOException e) {
-    // For protocol exceptions, try to inform the server of such.
-    if (!writerSentClose && e instanceof ProtocolException) {
-      try {
-        writer.writeClose(CLOSE_PROTOCOL_EXCEPTION, null);
-      } catch (IOException ignored) {
-      }
-    }
-
-    if (connectionClosed.compareAndSet(false, true)) {
-      try {
-        close();
-      } catch (IOException ignored) {
-      }
+    try {
+      shutdown();
+    } catch (Throwable inner) {
+      Util.throwIfFatal(inner);
+      Platform.get().log(INFO, "Unable to close web socket connection.", inner);
     }
-
-    listener.onFailure(e, null);
   }
 
   /** Perform any tear-down work (close the connection, shutdown executors). */
-  protected abstract void close() throws IOException;
+  protected abstract void shutdown();
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/ws/WebSocketReader.java b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketReader.java
index c50ca8cad1..44844a6147 100644
--- a/okhttp/src/main/java/okhttp3/internal/ws/WebSocketReader.java
+++ b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketReader.java
@@ -50,16 +50,15 @@
 
 /**
  * An <a href="http://tools.ietf.org/html/rfc6455">RFC 6455</a>-compatible WebSocket frame reader.
+ * <p>
+ * This class is not thread safe.
  */
 final class WebSocketReader {
   public interface FrameCallback {
-    void onMessage(ResponseBody body) throws IOException;
-
-    void onPing(Buffer buffer);
-
-    void onPong(Buffer buffer);
-
-    void onClose(int code, String reason);
+    void onReadMessage(ResponseBody body) throws IOException;
+    void onReadPing(Buffer buffer);
+    void onReadPong(Buffer buffer);
+    void onReadClose(int code, String reason);
   }
 
   final boolean isClient;
@@ -96,7 +95,7 @@
    * <ul>
    *     <li>If it is a control frame this will result in a single call to {@link FrameCallback}.
    *     <li>If it is a message frame this will result in a single call to {@link
-   *         FrameCallback#onMessage}. If the message spans multiple frames, each interleaved
+   *         FrameCallback#onReadMessage}. If the message spans multiple frames, each interleaved
    *         control frame will result in a corresponding call to {@link FrameCallback}.
    * </ul>
    */
@@ -136,7 +135,9 @@ private void readHeader() throws IOException {
     isMasked = (b1 & B1_FLAG_MASK) != 0;
     if (isMasked == isClient) {
       // Masked payloads must be read on the server. Unmasked payloads must be read on the client.
-      throw new ProtocolException("Client-sent frames must be masked. Server sent must not.");
+      throw new ProtocolException(isClient
+          ? "Server-sent frames must not be masked."
+          : "Client-sent frames must be masked.");
     }
 
     // Get frame length, optionally reading from follow-up bytes if indicated by special values.
@@ -183,10 +184,10 @@ private void readControlFrame() throws IOException {
 
     switch (opcode) {
       case OPCODE_CONTROL_PING:
-        frameCallback.onPing(buffer);
+        frameCallback.onReadPing(buffer);
         break;
       case OPCODE_CONTROL_PONG:
-        frameCallback.onPong(buffer);
+        frameCallback.onReadPong(buffer);
         break;
       case OPCODE_CONTROL_CLOSE:
         int code = 1000;
@@ -202,7 +203,7 @@ private void readControlFrame() throws IOException {
             reason = buffer.readUtf8();
           }
         }
-        frameCallback.onClose(code, reason);
+        frameCallback.onReadClose(code, reason);
         closed = true;
         break;
       default:
@@ -239,7 +240,7 @@ private void readMessageFrame() throws IOException {
     };
 
     messageClosed = false;
-    frameCallback.onMessage(body);
+    frameCallback.onReadMessage(body);
     if (!messageClosed) {
       throw new IllegalStateException("Listener failed to call close on message payload.");
     }
diff --git a/okhttp/src/main/java/okhttp3/internal/ws/WebSocketWriter.java b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketWriter.java
index f7e93fcdf9..75d875cb0f 100644
--- a/okhttp/src/main/java/okhttp3/internal/ws/WebSocketWriter.java
+++ b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketWriter.java
@@ -108,8 +108,11 @@ void writeClose(int code, String reason) throws IOException {
     }
 
     synchronized (this) {
-      writeControlFrameSynchronized(OPCODE_CONTROL_CLOSE, payload);
-      writerClosed = true;
+      try {
+        writeControlFrameSynchronized(OPCODE_CONTROL_CLOSE, payload);
+      } finally {
+        writerClosed = true;
+      }
     }
   }
 
@@ -149,7 +152,7 @@ private void writeControlFrameSynchronized(int opcode, Buffer payload) throws IO
       }
     }
 
-    sink.emit();
+    sink.flush();
   }
 
   /**
diff --git a/samples/guide/src/main/java/okhttp3/recipes/WebSocketEcho.java b/samples/guide/src/main/java/okhttp3/recipes/WebSocketEcho.java
index 882f37dc18..4d735dbe54 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/WebSocketEcho.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/WebSocketEcho.java
@@ -67,8 +67,8 @@ private void run() {
     writeExecutor.shutdown();
   }
 
-  @Override public void onFailure(IOException e, Response response) {
-    e.printStackTrace();
+  @Override public void onFailure(Throwable t, Response response) {
+    t.printStackTrace();
     writeExecutor.shutdown();
   }
 
