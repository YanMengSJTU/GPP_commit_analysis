diff --git a/.travis.yml b/.travis.yml
index 1835d337fb..f20f14fc6a 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,9 +1,13 @@
 language: java
 
 jdk:
-  - oraclejdk7
   - oraclejdk8
 
+addons:
+  apt:
+    packages:
+      - oracle-java8-installer # Updates JDK 8 to the latest available.
+
 after_success:
   - .buildscript/deploy_snapshot.sh
 
@@ -24,8 +28,3 @@ sudo: false
 cache:
   directories:
     - $HOME/.m2
-
-addons:
-  apt:
-    packages:
-      - oracle-java8-installer
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 44e754fe9f..a85ae84e5b 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,6 +1,319 @@
 Change Log
 ==========
 
+## Version 3.9.1
+
+_2017-11-18_
+
+ *  New: Recover gracefully when Android's DNS crashes with an unexpected
+    `NullPointerException`.
+ *  New: Recover gracefully when Android's socket connections crash with an
+    unexpected `ClassCastException`.
+ *  Fix: Don't include the URL's fragment in `encodedQuery()` when the query
+    itself is empty.
+
+## Version 3.9.0
+
+_2017-09-03_
+
+ *  **Interceptors are more capable.** The `Chain` interface now offers access
+    to the call and can adjust all call timeouts. Note that this change is
+    source-incompatible for code that implements the `Chain` interface.
+    We don't expect this to be a problem in practice!
+
+ *  **OkHttp has an experimental new API for tracking metrics.** The new
+    `EventListener` API is designed to help developers monitor HTTP requests'
+    size and duration. This feature is an unstable preview: the API is subject
+    to change, and the implementation is incomplete. This is a big new API we
+    are eager for feedback.
+
+ *  New: Support ALPN via Google Play Services' Dynamic Security Provider. This
+    expands HTTP/2 support to older Android devices that have Google Play
+    Services.
+ *  New: Consider all routes when looking for candidate coalesced connections.
+    This increases the likelihood that HTTP/2 connections will be shared.
+ *  New: Authentication challenges and credentials now use a charset. Use this in
+    your authenticator to support user names and passwords with non-ASCII
+    characters.
+ *  New: Accept a charset in `FormBody.Builder`. Previously form bodies were
+    always UTF-8.
+ *  New: Support the `immutable` cache-control directive.
+ *  Fix: Don't crash when an HTTP/2 call is redirected while the connection is
+    being shut down.
+ *  Fix: Don't drop headers of healthy streams that raced with `GOAWAY` frames.
+    This bug would cause HTTP/2 streams to occasional hang when the connection
+    was shutting down.
+ *  Fix: Honor `OkHttpClient.retryOnConnectionFailure()` when the response is a
+    HTTP 408 Request Timeout. If retries are enabled, OkHttp will retry exactly
+    once in response to a 408.
+ *  Fix: Don't crash when reading the empty `HEAD` response body if it specifies
+    a `Content-Length`.
+ *  Fix: Don't crash if the thread is interrupted while reading the public
+    suffix database.
+ *  Fix: Use relative resource path when loading the public suffix database.
+    Loading the resource using a path relative to the class prevents conflicts
+    when the OkHttp classes are relocated (shaded) by allowing multiple private
+    copies of the database.
+ *  Fix: Accept cookies for URLs that have an IPv6 address for a host.
+ *  Fix: Don't log the protocol (HTTP/1.1, h2) in HttpLoggingInterceptor if the
+    protocol isn't negotiated yet! Previously we'd log HTTP/1.1 by default, and
+    this was confusing.
+ *  Fix: Omit the message from MockWebServer's HTTP/2 `:status` header.
+ *  Fix: Handle 'Expect: 100 Continue' properly in MockWebServer.
+
+
+## Version 3.8.1
+
+_2017-06-18_
+
+ *  Fix: Recover gracefully from stale coalesced connections. We had a bug where
+    connection coalescing (introduced in OkHttp 3.7.0) and stale connection
+    recovery could interact to cause a `NoSuchElementException` crash in the
+    `RouteSelector`.
+
+
+## Version 3.8.0
+
+_2017-05-13_
+
+
+ *  **OkHttp now uses `@Nullable` to annotate all possibly-null values.** We've
+    added a compile-time dependency on the JSR 305 annotations. This is a
+    [provided][maven_provided] dependency and does not need to be included in
+    your build configuration, `.jar` file, or `.apk`. We use
+    `@ParametersAreNonnullByDefault` and all parameters and return types are
+    never null unless explicitly annotated `@Nullable`.
+
+ *  **Warning: this release is source-incompatible for Kotlin users.**
+    Nullability was previously ambiguous and lenient but now the compiler will
+    enforce strict null checks.
+
+ *  New: The response message is now non-null. This is the "Not Found" in the
+    status line "HTTP 404 Not Found". If you are building responses
+    programmatically (with `new Response.Builder()`) you must now always supply
+    a message. An empty string `""` is permitted. This value was never null on
+    responses returned by OkHttp itself, and it was an old mistake to permit
+    application code to omit a message.
+
+ *  The challenge's scheme and realm are now non-null. If you are calling
+    `new Challenge(scheme, realm)` you must provide non-null values. These were
+    never null in challenges created by OkHttp, but could have been null in
+    application code that creates challenges.
+
+ *  New: The `TlsVersion` of a `Handshake` is now non-null. If you are calling
+    `Handshake.get()` with a null TLS version, you must instead now provide a
+    non-null `TlsVersion`. Cache responses persisted prior to OkHttp 3.0 did not
+    store a TLS version; for these unknown values the handshake is defaulted to
+    `TlsVersion.SSL_3_0`.
+
+ *  New: Upgrade to Okio 1.13.0.
+
+     ```xml
+     <dependency>
+       <groupId>com.squareup.okio</groupId>
+       <artifactId>okio</artifactId>
+       <version>1.13.0</version>
+     </dependency>
+
+     com.squareup.okio:okio:1.13.0
+     ```
+
+ *  Fix: gracefully recover when Android 7.0's sockets throw an unexpected
+    `NullPointerException`.
+
+## Version 3.7.0
+
+_2017-04-15_
+
+ *  **OkHttp no longer recovers from TLS handshake failures by attempting a TLSv1 connection.**
+    The fallback was necessary for servers that implemented version negotiation incorrectly. Now
+    that 99.99% of servers do it right this fallback is obsolete.
+ *  Fix: Do not honor cookies set on a public domain. Previously a malicious site could inject
+    cookies on top-level domains like `co.uk` because our cookie parser didn't honor the [public
+    suffix][public_suffix] list. Alongside this fix is a new API, `HttpUrl.topPrivateDomain()`,
+    which returns the privately domain name if the URL has one.
+ *  Fix: Change `MediaType.charset()` to return null for unexpected charsets.
+ *  Fix: Don't skip cache invalidation if the invalidating response has no body.
+ *  Fix: Don't use a cryptographic random number generator for web sockets. Some Android devices
+    implement `SecureRandom` incorrectly!
+ *  Fix: Correctly canonicalize IPv6 addresses in `HttpUrl`. This prevented OkHttp from trusting
+    HTTPS certificates issued to certain IPv6 addresses.
+ *  Fix: Don't reuse connections after an unsuccessful `Expect: 100-continue`.
+ *  Fix: Handle either `TLS_` or `SSL_` prefixes for cipher suite names. This is necessary for
+    IBM JVMs that use the `SSL_` prefix exclusively.
+ *  Fix: Reject HTTP/2 data frames if the stream ID is 0.
+ *  New: Upgrade to Okio 1.12.0.
+
+     ```xml
+     <dependency>
+       <groupId>com.squareup.okio</groupId>
+       <artifactId>okio</artifactId>
+       <version>1.12.0</version>
+     </dependency>
+
+     com.squareup.okio:okio:1.12.0
+     ```
+
+ *  New: Connection coalescing. OkHttp may reuse HTTP/2 connections across calls that share an IP
+    address and HTTPS certificate, even if their domain names are different.
+ *  New: MockWebServer's `RecordedRequest` exposes the requested `HttpUrl` with `getRequestUrl()`.
+
+
+## Version 3.6.0
+
+_2017-01-29_
+
+ *  Fix: Don't crash with a "cache is closed" error when there is an error initializing the cache.
+ *  Fix: Calling `disconnect()` on a connecting `HttpUrlConnection` could cause it to retry in an
+    infinite loop! This regression was introduced in OkHttp 2.7.0.
+ *  Fix: Drop cookies that contain ASCII NULL and other bad characters. Previously such cookies
+    would cause OkHttp to crash when they were included in a request.
+ *  Fix: Release duplicated multiplexed connections. If we concurrently establish connections to an
+    HTTP/2 server, close all but the first connection.
+ *  Fix: Fail the HTTP/2 connection if first frame isn't `SETTINGS`.
+ *  Fix: Forbid spaces in header names.
+ *  Fix: Don't offer to do gzip if the request is partial.
+ *  Fix: MockWebServer is now usable with JUnit 5. That update [broke the rules][junit_5_rules].
+ *  New: Support `Expect: 100-continue` as a request header. Callers can use this header to
+    pessimistically hold off on transmitting a request body until a server gives the go-ahead.
+ *  New: Permit network interceptors to rewrite the host header for HTTP/2. This makes it possible
+    to do domain fronting.
+ *  New: charset support for `Credentials.basic()`.
+
+
+## Version 3.5.0
+
+_2016-11-30_
+
+ *  **Web Sockets are now a stable feature of OkHttp.** Since being introduced as a beta feature in
+    OkHttp 2.3 our web socket client has matured. Connect to a server's web socket with
+    `OkHttpClient.newWebSocket()`, send messages with `send()`, and receive messages with the
+    `WebSocketListener`.
+
+    The `okhttp-ws` submodule is no longer available and `okhttp-ws` artifacts from previous
+    releases of OkHttp are not compatible with OkHttp 3.5. When upgrading to the new package
+    please note that the `WebSocket` and `WebSocketCall` classes have been merged. Sending messages
+    is now asynchronous and they may be enqueued before the web socket is connected.
+
+ *  **OkHttp no longer attempts a direct connection if the system's HTTP proxy fails.** This
+    behavior was surprising because OkHttp was disregarding the user's specified configuration. If
+    you need to customize proxy fallback behavior, implement your own `java.net.ProxySelector`.
+
+ *  Fix: Support TLSv1.3 on devices that support it.
+
+ *  Fix: Share pooled connections across equivalent `OkHttpClient` instances. Previous releases had
+    a bug where a shared connection pool did not guarantee shared connections in some cases.
+ *  Fix: Prefer the server's response body on all conditional cache misses. Previously we would
+    return the cached response's body if it had a newer `Last-Modified` date.
+ *  Fix: Update the stored timestamp on conditional cache hits.
+ *  New: Optimized HTTP/2 request header encoding. More headers are HPACK-encoded and string
+    literals are now Huffman-encoded.
+ *  New: Expose `Part` headers and body in `Multipart`.
+ *  New: Make `ResponseBody.string()` and `ResponseBody.charStream()` BOM-aware. If your HTTP
+    response body begins with a [byte order mark][bom] it will be consumed and used to select a
+    charset for the remaining bytes. Most applications should not need a byte order mark.
+
+ *  New: Upgrade to Okio 1.11.0.
+
+     ```xml
+     <dependency>
+       <groupId>com.squareup.okio</groupId>
+       <artifactId>okio</artifactId>
+       <version>1.11.0</version>
+     </dependency>
+
+     com.squareup.okio:okio:1.11.0
+     ```
+
+ *  Fix: Avoid sending empty HTTP/2 data frames when there is no request body.
+ *  Fix: Add a leading `.` for better domain matching in `JavaNetCookieJar`.
+ *  Fix: Gracefully recover from HTTP/2 connection shutdowns at start of request.
+ *  Fix: Be lenient if a `MediaType`'s character set is `'single-quoted'`.
+ *  Fix: Allow horizontal tab characters in header values.
+ *  Fix: When parsing HTTP authentication headers permit challenge parameters in any order.
+
+
+## Version 3.4.2
+
+_2016-11-03_
+
+ *  Fix: Recover gracefully when an HTTP/2 connection is shutdown. We had a
+    bug where shutdown HTTP/2 connections were considered usable. This caused
+    infinite loops when calls attempted to recover.
+
+
+## Version 3.4.1
+
+_2016-07-10_
+
+ *  **Fix a major bug in encoding HTTP headers.** In 3.4.0 and 3.4.0-RC1 OkHttp
+    had an off-by-one bug in our HPACK encoder. This bug could have caused the
+    wrong headers to be emitted after a sequence of HTTP/2 requests! Everyone
+    who is using OkHttp 3.4.0 or 3.4.0-RC1 should upgrade for this bug fix.
+
+
+## Version 3.4.0
+
+_2016-07-08_
+
+ *  New: Support dynamic table size changes to HPACK Encoder.
+ *  Fix: Use `TreeMap` in `Headers.toMultimap()`. This makes string lookups on
+    the returned map case-insensitive.
+ *  Fix: Don't share the OkHttpClient's `Dispatcher` in `HttpURLConnection`.
+
+
+## Version 3.4.0-RC1
+
+_2016-07-02_
+
+ *  **We’ve rewritten HttpURLConnection and HttpsURLConnection.** Previously we
+    shared a single HTTP engine between two frontend APIs: `HttpURLConnection`
+    and `Call`. With this release we’ve rearranged things so that the
+    `HttpURLConnection` frontend now delegates to the `Call` APIs internally.
+    This has enabled substantial simplifications and optimizations in the OkHttp
+    core for both frontends.
+
+    For most HTTP requests the consequences of this change will be negligible.
+    If your application uses `HttpURLConnection.connect()`,
+    `setFixedLengthStreamingMode()`, or `setChunkedStreamingMode()`, OkHttp will
+    now use a async dispatcher thread to establish the HTTP connection.
+
+    We don’t expect this change to have any behavior or performance
+    consequences. Regardless, please exercise your `OkUrlFactory` and
+    `HttpURLConnection` code when applying this update.
+
+ *  **Cipher suites may now have arbitrary names.** Previously `CipherSuite` was
+    a Java enum and it was impossible to define new cipher suites without first
+    upgrading OkHttp. With this change it is now a regular Java class with
+    enum-like constants. Application code that uses enum methods on cipher
+    suites (`ordinal()`, `name()`, etc.) will break with this change.
+
+ *  Fix: `CertificatePinner` now matches canonicalized hostnames. Previously
+    this was case sensitive. This change should also make it easier to configure
+    certificate pinning for internationalized domain names.
+ *  Fix: Don’t crash on non-ASCII `ETag` headers. Previously OkHttp would reject
+    these headers when validating a cached response.
+ *  Fix: Don’t allow remote peer to arbitrarily size the HPACK decoder dynamic
+    table.
+ *  Fix: Honor per-host configuration in Android’s network security config.
+    Previously disabling cleartext for any host would disable cleartext for all
+    hosts. Note that this setting is only available on Android 24+.
+ *  New: HPACK compression is now dynamic. This should improve performance when
+    transmitting request headers over HTTP/2.
+ *  New: `Dispatcher.setIdleCallback()` can be used to signal when there are no
+    calls in flight. This is useful for [testing with
+    Espresso][okhttp_idling_resource].
+ *  New: Upgrade to Okio 1.9.0.
+
+     ```xml
+     <dependency>
+       <groupId>com.squareup.okio</groupId>
+       <artifactId>okio</artifactId>
+       <version>1.9.0</version>
+     </dependency>
+     ```
+
+
 ## Version 3.3.1
 
 _2016-05-28_
@@ -599,7 +912,7 @@ _2014-12-30_
  *  New: APIs to iterate and selectively clear the response cache.
  *  New: Support for SOCKS proxies.
  *  New: Support for `TLS_FALLBACK_SCSV`.
- *  New: Update HTTP/2 support to to `h2-16` and `hpack-10`.
+ *  New: Update HTTP/2 support to `h2-16` and `hpack-10`.
  *  New: APIs to prevent retrying non-idempotent requests.
  *  Fix: Drop NPN support. Going forward we support ALPN only.
  *  Fix: The hostname verifier is now strict. This is consistent with the hostname
@@ -1064,3 +1377,8 @@ Initial release.
  [webdav]: https://tools.ietf.org/html/rfc4918
  [major_versions]: http://jakewharton.com/java-interoperability-policy-for-major-version-updates/
  [nginx_959]: https://trac.nginx.org/nginx/ticket/959
+ [okhttp_idling_resource]: https://github.com/JakeWharton/okhttp-idling-resource
+ [bom]: https://en.wikipedia.org/wiki/Byte_order_mark
+ [junit_5_rules]: http://junit.org/junit5/docs/current/user-guide/#migrating-from-junit4-rulesupport
+ [public_suffix]: https://publicsuffix.org/
+ [maven_provided]: https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html
diff --git a/README.md b/README.md
index 2e40ffd9e9..7ae6ce68e8 100644
--- a/README.md
+++ b/README.md
@@ -11,12 +11,12 @@ Download [the latest JAR][3] or grab via Maven:
 <dependency>
   <groupId>com.squareup.okhttp3</groupId>
   <artifactId>okhttp</artifactId>
-  <version>3.3.1</version>
+  <version>3.9.1</version>
 </dependency>
 ```
 or Gradle:
 ```groovy
-compile 'com.squareup.okhttp3:okhttp:3.3.1'
+implementation 'com.squareup.okhttp3:okhttp:3.9.1'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
@@ -25,9 +25,9 @@ Snapshots of the development version are available in [Sonatype's `snapshots` re
 MockWebServer
 -------------
 
-A library for testing HTTP, HTTPS, HTTP/2.0, and SPDY clients.
+A library for testing HTTP, HTTPS, and HTTP/2 clients.
 
-MockWebServer coupling with OkHttp is essential for proper testing of HTTP/2.0 so that code can be shared.
+MockWebServer coupling with OkHttp is essential for proper testing of HTTP/2 so that code can be shared.
 
 ### Download
 
@@ -36,16 +36,27 @@ Download [the latest JAR][4] or grab via Maven:
 <dependency>
   <groupId>com.squareup.okhttp3</groupId>
   <artifactId>mockwebserver</artifactId>
-  <version>3.3.1</version>
+  <version>3.9.1</version>
   <scope>test</scope>
 </dependency>
 ```
 or Gradle:
 ```groovy
-testCompile 'com.squareup.okhttp3:mockwebserver:3.3.1'
+testImplementation 'com.squareup.okhttp3:mockwebserver:3.9.1'
 ```
 
+ProGuard
+--------
+
+If you are using ProGuard you might need to add the following options:
 
+```
+-dontwarn okhttp3.**
+-dontwarn okio.**
+-dontwarn javax.annotation.**
+# A resource is loaded with a relative path so the package of this class must be preserved.
+-keepnames class okhttp3.internal.publicsuffix.PublicSuffixDatabase
+```
 
 License
 -------
diff --git a/benchmarks/pom.xml b/benchmarks/pom.xml
index f97dc33ef7..36a9aee9d5 100644
--- a/benchmarks/pom.xml
+++ b/benchmarks/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.4.0-SNAPSHOT</version>
+    <version>3.10.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>benchmarks</artifactId>
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/ApacheHttpClient.java b/benchmarks/src/main/java/okhttp3/benchmarks/ApacheHttpClient.java
index a5c632fa0f..2fffd7cbf8 100644
--- a/benchmarks/src/main/java/okhttp3/benchmarks/ApacheHttpClient.java
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/ApacheHttpClient.java
@@ -55,7 +55,7 @@
   class ApacheHttpClientRequest implements Runnable {
     private final HttpUrl url;
 
-    public ApacheHttpClientRequest(HttpUrl url) {
+    ApacheHttpClientRequest(HttpUrl url) {
       this.url = url;
     }
 
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/Benchmark.java b/benchmarks/src/main/java/okhttp3/benchmarks/Benchmark.java
index 8d4d04386a..0ec59a0573 100644
--- a/benchmarks/src/main/java/okhttp3/benchmarks/Benchmark.java
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/Benchmark.java
@@ -68,7 +68,7 @@
   @Param
   boolean gzip;
 
-  /** Don't combine chunked with SPDY_3 or HTTP_2; that's not allowed. */
+  /** Don't combine chunked with HTTP_2; that's not allowed. */
   @Param
   boolean chunked;
 
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/NettyHttpClient.java b/benchmarks/src/main/java/okhttp3/benchmarks/NettyHttpClient.java
index 01e6f6e257..cd7286d374 100644
--- a/benchmarks/src/main/java/okhttp3/benchmarks/NettyHttpClient.java
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/NettyHttpClient.java
@@ -137,7 +137,7 @@ private void release(HttpChannel httpChannel) {
     int total;
     long start;
 
-    public HttpChannel(SocketChannel channel) {
+    HttpChannel(SocketChannel channel) {
       this.channel = channel;
     }
 
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/OkHttp.java b/benchmarks/src/main/java/okhttp3/benchmarks/OkHttp.java
index 7c90e5e6b5..7460aa66f6 100644
--- a/benchmarks/src/main/java/okhttp3/benchmarks/OkHttp.java
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/OkHttp.java
@@ -61,7 +61,7 @@
   class OkHttpRequest implements Runnable {
     private final Call call;
 
-    public OkHttpRequest(Call call) {
+    OkHttpRequest(Call call) {
       this.call = call;
     }
 
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/UrlConnection.java b/benchmarks/src/main/java/okhttp3/benchmarks/UrlConnection.java
index f75d160835..560534c829 100644
--- a/benchmarks/src/main/java/okhttp3/benchmarks/UrlConnection.java
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/UrlConnection.java
@@ -52,7 +52,7 @@
   static class UrlConnectionRequest implements Runnable {
     private final HttpUrl url;
 
-    public UrlConnectionRequest(HttpUrl url) {
+    UrlConnectionRequest(HttpUrl url) {
       this.url = url;
     }
 
diff --git a/checkstyle.xml b/checkstyle.xml
index d8540c6168..1e4d8e6d1d 100644
--- a/checkstyle.xml
+++ b/checkstyle.xml
@@ -1,9 +1,10 @@
 <?xml version="1.0"?>
 <!DOCTYPE module PUBLIC
-    "-//Puppy Crawl//DTD Check Configuration 1.2//EN"
-    "http://www.puppycrawl.com/dtds/configuration_1_2.dtd">
+    "-//Puppy Crawl//DTD Check Configuration 1.3//EN"
+    "http://www.puppycrawl.com/dtds/configuration_1_3.dtd">
 
 <module name="Checker">
+  <module name="SuppressWarningsFilter"/>
   <module name="NewlineAtEndOfFile"/>
   <module name="FileLength"/>
   <module name="FileTabCharacter"/>
@@ -120,7 +121,7 @@
     <!--module name="InnerAssignment"/-->
     <!--module name="MagicNumber"/-->
     <!--module name="MissingSwitchDefault"/-->
-    <module name="RedundantThrows"/>
+    <!--<module name="RedundantThrows"/>-->
     <module name="SimplifyBooleanExpression"/>
     <module name="SimplifyBooleanReturn"/>
 
@@ -139,5 +140,8 @@
     <!--module name="FinalParameters"/-->
     <!--module name="TodoComment"/-->
     <module name="UpperEll"/>
+
+    <!-- Make the @SuppressWarnings annotations available to Checkstyle -->
+    <module name="SuppressWarningsHolder"/>
   </module>
 </module>
diff --git a/mockwebserver/README.md b/mockwebserver/README.md
index 06cf0723f5..73503bb6d2 100644
--- a/mockwebserver/README.md
+++ b/mockwebserver/README.md
@@ -152,7 +152,7 @@ Get MockWebServer via Maven:
 
 or via Gradle 
 ```groovy
-testCompile 'com.squareup.okhttp3:mockwebserver:(insert latest version)'
+testImplementation 'com.squareup.okhttp3:mockwebserver:(insert latest version)'
 ```
 
 ### License
diff --git a/mockwebserver/pom.xml b/mockwebserver/pom.xml
index 555e19ddfc..de258420ef 100644
--- a/mockwebserver/pom.xml
+++ b/mockwebserver/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.4.0-SNAPSHOT</version>
+    <version>3.10.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>mockwebserver</artifactId>
@@ -24,11 +24,6 @@
       <version>${project.version}</version>
       <scope>test</scope>
     </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp-ws</artifactId>
-      <version>${project.version}</version>
-    </dependency>
     <dependency>
       <groupId>org.bouncycastle</groupId>
       <artifactId>bcprov-jdk15on</artifactId>
diff --git a/mockwebserver/src/main/java/okhttp3/internal/framed/FramedServer.java b/mockwebserver/src/main/java/okhttp3/internal/http2/Http2Server.java
similarity index 75%
rename from mockwebserver/src/main/java/okhttp3/internal/framed/FramedServer.java
rename to mockwebserver/src/main/java/okhttp3/internal/http2/Http2Server.java
index 2a555be68e..643ab1eb4c 100644
--- a/mockwebserver/src/main/java/okhttp3/internal/framed/FramedServer.java
+++ b/mockwebserver/src/main/java/okhttp3/internal/http2/Http2Server.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package okhttp3.internal.framed;
+package okhttp3.internal.http2;
 
 import java.io.File;
 import java.io.IOException;
@@ -22,32 +22,30 @@
 import java.net.ServerSocket;
 import java.net.Socket;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.List;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
 import okhttp3.Protocol;
-import okhttp3.internal.Platform;
 import okhttp3.internal.Util;
+import okhttp3.internal.platform.Platform;
 import okhttp3.internal.tls.SslClient;
 import okio.BufferedSink;
 import okio.Okio;
 import okio.Source;
 
-import static okhttp3.internal.Platform.INFO;
+import static okhttp3.internal.platform.Platform.INFO;
 
-/** A basic SPDY/HTTP_2 server that serves the contents of a local directory. */
-public final class FramedServer extends FramedConnection.Listener {
-  static final Logger logger = Logger.getLogger(FramedServer.class.getName());
-
-  private final List<Protocol> framedProtocols =
-      Util.immutableList(Protocol.HTTP_2, Protocol.SPDY_3);
+/** A basic HTTP/2 server that serves the contents of a local directory. */
+public final class Http2Server extends Http2Connection.Listener {
+  static final Logger logger = Logger.getLogger(Http2Server.class.getName());
 
   private final File baseDirectory;
   private final SSLSocketFactory sslSocketFactory;
 
-  public FramedServer(File baseDirectory, SSLSocketFactory sslSocketFactory) {
+  public Http2Server(File baseDirectory, SSLSocketFactory sslSocketFactory) {
     this.baseDirectory = baseDirectory;
     this.sslSocketFactory = sslSocketFactory;
   }
@@ -64,20 +62,19 @@ private void run() throws Exception {
         SSLSocket sslSocket = doSsl(socket);
         String protocolString = Platform.get().getSelectedProtocol(sslSocket);
         Protocol protocol = protocolString != null ? Protocol.get(protocolString) : null;
-        if (protocol == null || !framedProtocols.contains(protocol)) {
+        if (protocol != Protocol.HTTP_2) {
           throw new ProtocolException("Protocol " + protocol + " unsupported");
         }
-        FramedConnection framedConnection = new FramedConnection.Builder(false)
+        Http2Connection connection = new Http2Connection.Builder(false)
             .socket(sslSocket)
-            .protocol(protocol)
             .listener(this)
             .build();
-        framedConnection.start();
+        connection.start();
       } catch (IOException e) {
-        logger.log(Level.INFO, "FramedServer connection failure: " + e);
+        logger.log(Level.INFO, "Http2Server connection failure: " + e);
         Util.closeQuietly(socket);
       } catch (Exception e) {
-        logger.log(Level.WARNING, "FramedServer unexpected failure", e);
+        logger.log(Level.WARNING, "Http2Server unexpected failure", e);
         Util.closeQuietly(socket);
       }
     }
@@ -87,12 +84,13 @@ private SSLSocket doSsl(Socket socket) throws IOException {
     SSLSocket sslSocket = (SSLSocket) sslSocketFactory.createSocket(
         socket, socket.getInetAddress().getHostAddress(), socket.getPort(), true);
     sslSocket.setUseClientMode(false);
-    Platform.get().configureTlsExtensions(sslSocket, null, framedProtocols);
+    Platform.get().configureTlsExtensions(sslSocket, null,
+        Collections.singletonList(Protocol.HTTP_2));
     sslSocket.startHandshake();
     return sslSocket;
   }
 
-  @Override public void onStream(final FramedStream stream) throws IOException {
+  @Override public void onStream(Http2Stream stream) throws IOException {
     try {
       List<Header> requestHeaders = stream.getRequestHeaders();
       String path = null;
@@ -118,29 +116,29 @@ private SSLSocket doSsl(Socket socket) throws IOException {
         send404(stream, path);
       }
     } catch (IOException e) {
-      Platform.get().log(INFO, "Failure serving FramedStream: " + e.getMessage(), null);
+      Platform.get().log(INFO, "Failure serving Http2Stream: " + e.getMessage(), null);
     }
   }
 
-  private void send404(FramedStream stream, String path) throws IOException {
+  private void send404(Http2Stream stream, String path) throws IOException {
     List<Header> responseHeaders = Arrays.asList(
         new Header(":status", "404"),
         new Header(":version", "HTTP/1.1"),
         new Header("content-type", "text/plain")
     );
-    stream.reply(responseHeaders, true);
+    stream.sendResponseHeaders(responseHeaders, true);
     BufferedSink out = Okio.buffer(stream.getSink());
     out.writeUtf8("Not found: " + path);
     out.close();
   }
 
-  private void serveDirectory(FramedStream stream, File[] files) throws IOException {
+  private void serveDirectory(Http2Stream stream, File[] files) throws IOException {
     List<Header> responseHeaders = Arrays.asList(
         new Header(":status", "200"),
         new Header(":version", "HTTP/1.1"),
         new Header("content-type", "text/html; charset=UTF-8")
     );
-    stream.reply(responseHeaders, true);
+    stream.sendResponseHeaders(responseHeaders, true);
     BufferedSink out = Okio.buffer(stream.getSink());
     for (File file : files) {
       String target = file.isDirectory() ? (file.getName() + "/") : file.getName();
@@ -149,13 +147,13 @@ private void serveDirectory(FramedStream stream, File[] files) throws IOExceptio
     out.close();
   }
 
-  private void serveFile(FramedStream stream, File file) throws IOException {
+  private void serveFile(Http2Stream stream, File file) throws IOException {
     List<Header> responseHeaders = Arrays.asList(
         new Header(":status", "200"),
         new Header(":version", "HTTP/1.1"),
         new Header("content-type", contentType(file))
     );
-    stream.reply(responseHeaders, true);
+    stream.sendResponseHeaders(responseHeaders, true);
     Source source = Okio.source(file);
     try {
       BufferedSink out = Okio.buffer(stream.getSink());
@@ -179,11 +177,11 @@ private String contentType(File file) {
 
   public static void main(String... args) throws Exception {
     if (args.length != 1 || args[0].startsWith("-")) {
-      System.out.println("Usage: FramedServer <base directory>");
+      System.out.println("Usage: Http2Server <base directory>");
       return;
     }
 
-    FramedServer server = new FramedServer(new File(args[0]),
+    Http2Server server = new Http2Server(new File(args[0]),
         SslClient.localhost().sslContext.getSocketFactory());
     server.run();
   }
diff --git a/mockwebserver/src/main/java/okhttp3/internal/tls/HeldCertificate.java b/mockwebserver/src/main/java/okhttp3/internal/tls/HeldCertificate.java
index a7fe81f0ef..eedfc2a094 100644
--- a/mockwebserver/src/main/java/okhttp3/internal/tls/HeldCertificate.java
+++ b/mockwebserver/src/main/java/okhttp3/internal/tls/HeldCertificate.java
@@ -22,14 +22,21 @@
 import java.security.SecureRandom;
 import java.security.Security;
 import java.security.cert.X509Certificate;
+import java.util.ArrayList;
 import java.util.Date;
+import java.util.List;
 import java.util.UUID;
 import javax.security.auth.x500.X500Principal;
+import org.bouncycastle.asn1.ASN1Encodable;
+import org.bouncycastle.asn1.DERSequence;
 import org.bouncycastle.asn1.x509.BasicConstraints;
+import org.bouncycastle.asn1.x509.GeneralName;
 import org.bouncycastle.asn1.x509.X509Extensions;
 import org.bouncycastle.jce.provider.BouncyCastleProvider;
 import org.bouncycastle.x509.X509V3CertificateGenerator;
 
+import static okhttp3.internal.Util.verifyAsIpAddress;
+
 /**
  * A certificate and its private key. This can be used on the server side by HTTPS servers, or on
  * the client side to verify those HTTPS servers. A held certificate can also be used to sign other
@@ -51,6 +58,7 @@ public HeldCertificate(X509Certificate certificate, KeyPair keyPair) {
 
     private final long duration = 1000L * 60 * 60 * 24; // One day.
     private String hostname;
+    private List<String> altNames = new ArrayList<>();
     private String serialNumber = "1";
     private KeyPair keyPair;
     private HeldCertificate issuedBy;
@@ -93,6 +101,15 @@ public Builder ca(int maxIntermediateCas) {
       return this;
     }
 
+    /**
+     * Adds a subject alternative name to the certificate. This is usually a hostname or IP address.
+     * If no subject alternative names are added that extension will not be used.
+     */
+    public Builder subjectAlternativeName(String altName) {
+      altNames.add(altName);
+      return this;
+    }
+
     public HeldCertificate build() throws GeneralSecurityException {
       // Subject, public & private keys for this certificate.
       KeyPair heldKeyPair = keyPair != null
@@ -129,6 +146,19 @@ public HeldCertificate build() throws GeneralSecurityException {
             new BasicConstraints(maxIntermediateCas));
       }
 
+      if (!altNames.isEmpty()) {
+        ASN1Encodable[] encodableAltNames = new ASN1Encodable[altNames.size()];
+        for (int i = 0, size = altNames.size(); i < size; i++) {
+          String altName = altNames.get(i);
+          int tag = verifyAsIpAddress(altName)
+              ? GeneralName.iPAddress
+              : GeneralName.dNSName;
+          encodableAltNames[i] = new GeneralName(tag, altName);
+        }
+        generator.addExtension(X509Extensions.SubjectAlternativeName, true,
+            new DERSequence(encodableAltNames));
+      }
+
       X509Certificate certificate = generator.generateX509Certificate(
           signedByKeyPair.getPrivate(), "BC");
       return new HeldCertificate(certificate, heldKeyPair);
diff --git a/mockwebserver/src/main/java/okhttp3/internal/tls/SslClient.java b/mockwebserver/src/main/java/okhttp3/internal/tls/SslClient.java
index 7cc061b668..e86e8675ff 100644
--- a/mockwebserver/src/main/java/okhttp3/internal/tls/SslClient.java
+++ b/mockwebserver/src/main/java/okhttp3/internal/tls/SslClient.java
@@ -60,7 +60,7 @@ public static synchronized SslClient localhost() {
       // Generate a self-signed cert for the server to serve and the client to trust.
       HeldCertificate heldCertificate = new HeldCertificate.Builder()
           .serialNumber("1")
-          .commonName(InetAddress.getByName("localhost").getHostName())
+          .commonName(InetAddress.getByName("localhost").getCanonicalHostName())
           .build();
 
       localhost = new Builder()
@@ -78,21 +78,22 @@ public static synchronized SslClient localhost() {
     private final List<X509Certificate> chainCertificates = new ArrayList<>();
     private final List<X509Certificate> certificates = new ArrayList<>();
     private KeyPair keyPair;
+    private String keyStoreType = KeyStore.getDefaultType();
 
     /**
      * Configure the certificate chain to use when serving HTTPS responses. The first certificate is
      * the server's certificate, further certificates are included in the handshake so the client
      * can build a trusted path to a CA certificate.
      */
-    public Builder certificateChain(HeldCertificate serverCert, HeldCertificate... chain) {
+    public Builder certificateChain(HeldCertificate localCert, HeldCertificate... chain) {
       X509Certificate[] certificates = new X509Certificate[chain.length];
       for (int i = 0; i < chain.length; i++) {
         certificates[i] = chain[i].certificate;
       }
-      return certificateChain(serverCert.keyPair, serverCert.certificate, certificates);
+      return certificateChain(localCert.keyPair, localCert.certificate, certificates);
     }
 
-    public SslClient.Builder certificateChain(KeyPair keyPair, X509Certificate keyCert,
+    public Builder certificateChain(KeyPair keyPair, X509Certificate keyCert,
         X509Certificate... certificates) {
       this.keyPair = keyPair;
       this.chainCertificates.add(keyCert);
@@ -110,6 +111,11 @@ public Builder addTrustedCertificate(X509Certificate certificate) {
       return this;
     }
 
+    public Builder keyStoreType(String keyStoreType) {
+      this.keyStoreType = keyStoreType;
+      return this;
+    }
+
     public SslClient build() {
       try {
         // Put the certificate in a key store.
@@ -151,7 +157,7 @@ public SslClient build() {
 
     private KeyStore newEmptyKeyStore(char[] password) throws GeneralSecurityException {
       try {
-        KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
+        KeyStore keyStore = KeyStore.getInstance(keyStoreType);
         InputStream in = null; // By convention, 'null' creates an empty key store.
         keyStore.load(in, password);
         return keyStore;
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.java
index 1826aa4fff..36457229ed 100644
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.java
@@ -19,9 +19,9 @@
 import java.util.List;
 import java.util.concurrent.TimeUnit;
 import okhttp3.Headers;
+import okhttp3.WebSocketListener;
 import okhttp3.internal.Internal;
-import okhttp3.internal.framed.Settings;
-import okhttp3.ws.WebSocketListener;
+import okhttp3.internal.http2.Settings;
 import okio.Buffer;
 
 /** A scripted response to be replayed by the mock web server. */
@@ -43,6 +43,9 @@
   private long bodyDelayAmount = 0;
   private TimeUnit bodyDelayUnit = TimeUnit.MILLISECONDS;
 
+  private long headersDelayAmount = 0;
+  private TimeUnit headersDelayUnit = TimeUnit.MILLISECONDS;
+
   private List<PushPromise> promises = new ArrayList<>();
   private Settings settings;
   private WebSocketListener webSocketListener;
@@ -253,6 +256,16 @@ public long getBodyDelay(TimeUnit unit) {
     return unit.convert(bodyDelayAmount, bodyDelayUnit);
   }
 
+  public MockResponse setHeadersDelay(long delay, TimeUnit unit) {
+    headersDelayAmount = delay;
+    headersDelayUnit = unit;
+    return this;
+  }
+
+  public long getHeadersDelay(TimeUnit unit) {
+    return unit.convert(headersDelayAmount, headersDelayUnit);
+  }
+
   /**
    * When {@link MockWebServer#setProtocols(java.util.List) protocols} include {@linkplain
    * okhttp3.Protocol#HTTP_2}, this attaches a pushed stream to this response.
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
index 89df442534..677adbae7d 100644
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
@@ -17,6 +17,7 @@
 
 package okhttp3.mockwebserver;
 
+import java.io.Closeable;
 import java.io.IOException;
 import java.io.InterruptedIOException;
 import java.net.InetAddress;
@@ -40,9 +41,7 @@
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
-import java.util.concurrent.LinkedBlockingDeque;
 import java.util.concurrent.LinkedBlockingQueue;
-import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.logging.Level;
@@ -58,18 +57,18 @@
 import okhttp3.Protocol;
 import okhttp3.Request;
 import okhttp3.Response;
+import okhttp3.internal.Internal;
 import okhttp3.internal.NamedRunnable;
-import okhttp3.internal.Platform;
 import okhttp3.internal.Util;
-import okhttp3.internal.framed.ErrorCode;
-import okhttp3.internal.framed.FramedConnection;
-import okhttp3.internal.framed.FramedStream;
-import okhttp3.internal.framed.Header;
-import okhttp3.internal.framed.Settings;
 import okhttp3.internal.http.HttpMethod;
+import okhttp3.internal.http2.ErrorCode;
+import okhttp3.internal.http2.Header;
+import okhttp3.internal.http2.Http2Connection;
+import okhttp3.internal.http2.Http2Stream;
+import okhttp3.internal.http2.Settings;
+import okhttp3.internal.platform.Platform;
 import okhttp3.internal.ws.RealWebSocket;
 import okhttp3.internal.ws.WebSocketProtocol;
-import okhttp3.ws.WebSocketListener;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -77,16 +76,15 @@
 import okio.Okio;
 import okio.Sink;
 import okio.Timeout;
-import org.junit.rules.TestRule;
-import org.junit.runner.Description;
-import org.junit.runners.model.Statement;
+import org.junit.rules.ExternalResource;
 
-import static java.util.concurrent.TimeUnit.SECONDS;
+import static okhttp3.internal.Util.closeQuietly;
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_DURING_REQUEST_BODY;
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_DURING_RESPONSE_BODY;
+import static okhttp3.mockwebserver.SocketPolicy.EXPECT_CONTINUE;
 import static okhttp3.mockwebserver.SocketPolicy.FAIL_HANDSHAKE;
 import static okhttp3.mockwebserver.SocketPolicy.NO_RESPONSE;
 import static okhttp3.mockwebserver.SocketPolicy.RESET_STREAM_AT_START;
@@ -98,7 +96,11 @@
  * A scriptable web server. Callers supply canned responses and the server replays them upon request
  * in sequence.
  */
-public final class MockWebServer implements TestRule {
+public final class MockWebServer extends ExternalResource implements Closeable {
+  static {
+    Internal.initializeInstanceForTests();
+  }
+
   private static final X509TrustManager UNTRUSTED_TRUST_MANAGER = new X509TrustManager() {
     @Override public void checkClientTrusted(X509Certificate[] chain, String authType)
         throws CertificateException {
@@ -120,8 +122,8 @@
 
   private final Set<Socket> openClientSockets =
       Collections.newSetFromMap(new ConcurrentHashMap<Socket, Boolean>());
-  private final Set<FramedConnection> openFramedConnections =
-      Collections.newSetFromMap(new ConcurrentHashMap<FramedConnection, Boolean>());
+  private final Set<Http2Connection> openConnections =
+      Collections.newSetFromMap(new ConcurrentHashMap<Http2Connection, Boolean>());
   private final AtomicInteger requestCount = new AtomicInteger();
   private long bodyLimit = Long.MAX_VALUE;
   private ServerSocketFactory serverSocketFactory = ServerSocketFactory.getDefault();
@@ -134,12 +136,11 @@
   private int port = -1;
   private InetSocketAddress inetSocketAddress;
   private boolean protocolNegotiationEnabled = true;
-  private List<Protocol> protocols
-      = Util.immutableList(Protocol.HTTP_2, Protocol.SPDY_3, Protocol.HTTP_1_1);
+  private List<Protocol> protocols = Util.immutableList(Protocol.HTTP_2, Protocol.HTTP_1_1);
 
   private boolean started;
 
-  private synchronized void maybeStart() {
+  @Override protected synchronized void before() {
     if (started) return;
     try {
       start();
@@ -148,36 +149,20 @@ private synchronized void maybeStart() {
     }
   }
 
-  @Override public Statement apply(final Statement base, Description description) {
-    return new Statement() {
-      @Override public void evaluate() throws Throwable {
-        maybeStart();
-        try {
-          base.evaluate();
-        } finally {
-          try {
-            shutdown();
-          } catch (IOException e) {
-            logger.log(Level.WARNING, "MockWebServer shutdown failed", e);
-          }
-        }
-      }
-    };
-  }
-
   public int getPort() {
-    maybeStart();
+    before();
     return port;
   }
 
   public String getHostName() {
-    maybeStart();
-    return inetSocketAddress.getHostName();
+    before();
+    return inetSocketAddress.getAddress().getCanonicalHostName();
   }
 
   public Proxy toProxyAddress() {
-    maybeStart();
-    InetSocketAddress address = new InetSocketAddress(inetSocketAddress.getAddress(), getPort());
+    before();
+    InetSocketAddress address = new InetSocketAddress(inetSocketAddress.getAddress()
+            .getCanonicalHostName(), getPort());
     return new Proxy(Proxy.Type.HTTP, address);
   }
 
@@ -343,13 +328,13 @@ private synchronized void start(InetSocketAddress inetSocketAddress) throws IOEx
         }
 
         // Release all sockets and all threads, even if any close fails.
-        Util.closeQuietly(serverSocket);
+        closeQuietly(serverSocket);
         for (Iterator<Socket> s = openClientSockets.iterator(); s.hasNext(); ) {
-          Util.closeQuietly(s.next());
+          closeQuietly(s.next());
           s.remove();
         }
-        for (Iterator<FramedConnection> s = openFramedConnections.iterator(); s.hasNext(); ) {
-          Util.closeQuietly(s.next());
+        for (Iterator<Http2Connection> s = openConnections.iterator(); s.hasNext(); ) {
+          closeQuietly(s.next());
           s.remove();
         }
         dispatcher.shutdown();
@@ -395,6 +380,14 @@ public synchronized void shutdown() throws IOException {
     }
   }
 
+  @Override protected synchronized void after() {
+    try {
+      shutdown();
+    } catch (IOException e) {
+      logger.log(Level.WARNING, "MockWebServer shutdown failed", e);
+    }
+  }
+
   private void serveConnection(final Socket raw) {
     executor.execute(new NamedRunnable("MockWebServer %s", raw.getRemoteSocketAddress()) {
       int sequenceNumber = 0;
@@ -445,17 +438,18 @@ public void processConnection() throws Exception {
           socket = raw;
         }
 
-        if (protocol != Protocol.HTTP_1_1) {
-          FramedSocketHandler framedSocketListener = new FramedSocketHandler(socket, protocol);
-          FramedConnection framedConnection = new FramedConnection.Builder(false)
+        if (protocol == Protocol.HTTP_2) {
+          Http2SocketHandler http2SocketHandler = new Http2SocketHandler(socket, protocol);
+          Http2Connection connection = new Http2Connection.Builder(false)
               .socket(socket)
-              .protocol(protocol)
-              .listener(framedSocketListener)
+              .listener(http2SocketHandler)
               .build();
-          framedConnection.start();
-          openFramedConnections.add(framedConnection);
+          connection.start();
+          openConnections.add(connection);
           openClientSockets.remove(socket);
           return;
+        } else if (protocol != Protocol.HTTP_1_1) {
+          throw new AssertionError();
         }
 
         BufferedSource source = Okio.buffer(Okio.source(socket));
@@ -471,8 +465,6 @@ public void processConnection() throws Exception {
               + " didn't make a request");
         }
 
-        source.close();
-        sink.close();
         socket.close();
         openClientSockets.remove(socket);
       }
@@ -590,7 +582,7 @@ private RecordedRequest readRequest(Socket socket, BufferedSource source, Buffer
     boolean expectContinue = false;
     String header;
     while ((header = source.readUtf8LineStrict()).length() != 0) {
-      headers.add(header);
+      Internal.instance.addLenient(headers, header);
       String lowercaseHeader = header.toLowerCase(Locale.US);
       if (contentLength == -1 && lowercaseHeader.startsWith("content-length:")) {
         contentLength = Long.parseLong(header.substring(15).trim());
@@ -600,12 +592,12 @@ private RecordedRequest readRequest(Socket socket, BufferedSource source, Buffer
         chunked = true;
       }
       if (lowercaseHeader.startsWith("expect:")
-          && lowercaseHeader.substring(7).trim().equals("100-continue")) {
+          && lowercaseHeader.substring(7).trim().equalsIgnoreCase("100-continue")) {
         expectContinue = true;
       }
     }
 
-    if (expectContinue) {
+    if (expectContinue && dispatcher.peek().getSocketPolicy() == EXPECT_CONTINUE) {
       sink.writeUtf8("HTTP/1.1 100 Continue\r\n");
       sink.writeUtf8("Content-Length: 0\r\n");
       sink.writeUtf8("\r\n");
@@ -645,27 +637,10 @@ private RecordedRequest readRequest(Socket socket, BufferedSource source, Buffer
   private void handleWebSocketUpgrade(Socket socket, BufferedSource source, BufferedSink sink,
       RecordedRequest request, MockResponse response) throws IOException {
     String key = request.getHeader("Sec-WebSocket-Key");
-    String acceptKey = Util.shaBase64(key + WebSocketProtocol.ACCEPT_MAGIC);
-    response.setHeader("Sec-WebSocket-Accept", acceptKey);
+    response.setHeader("Sec-WebSocket-Accept", WebSocketProtocol.acceptHeader(key));
 
     writeHttpResponse(socket, sink, response);
 
-    final WebSocketListener listener = response.getWebSocketListener();
-    final CountDownLatch connectionClose = new CountDownLatch(1);
-
-    ThreadPoolExecutor replyExecutor =
-        new ThreadPoolExecutor(1, 1, 1, SECONDS, new LinkedBlockingDeque<Runnable>(),
-            Util.threadFactory(Util.format("MockWebServer %s WebSocket", request.getPath()),
-                true));
-    replyExecutor.allowCoreThreadTimeOut(true);
-    final RealWebSocket webSocket =
-        new RealWebSocket(false /* is server */, source, sink, new SecureRandom(), replyExecutor,
-            listener, request.getPath()) {
-          @Override protected void close() throws IOException {
-            connectionClose.countDown();
-          }
-        };
-
     // Adapt the request and response into our Request and Response domain model.
     String scheme = request.getTlsVersion() != null ? "https" : "http";
     String authority = request.getHeader("Host"); // Has host and port.
@@ -681,25 +656,36 @@ private void handleWebSocketUpgrade(Socket socket, BufferedSource source, Buffer
         .protocol(Protocol.HTTP_1_1)
         .build();
 
-    listener.onOpen(webSocket, fancyResponse);
+    final CountDownLatch connectionClose = new CountDownLatch(1);
+    RealWebSocket.Streams streams = new RealWebSocket.Streams(false, source, sink) {
+      @Override public void close() {
+        connectionClose.countDown();
+      }
+    };
+    RealWebSocket webSocket = new RealWebSocket(fancyRequest,
+        response.getWebSocketListener(), new SecureRandom());
+    response.getWebSocketListener().onOpen(webSocket, fancyResponse);
+    String name = "MockWebServer WebSocket " + request.getPath();
+    webSocket.initReaderAndWriter(name, 0, streams);
+    try {
+      webSocket.loopReader();
 
-    while (webSocket.readMessage()) {
-    }
+      // Even if messages are no longer being read we need to wait for the connection close signal.
+      try {
+        connectionClose.await();
+      } catch (InterruptedException ignored) {
+      }
 
-    // Even if messages are no longer being read we need to wait for the connection close signal.
-    try {
-      connectionClose.await();
-    } catch (InterruptedException e) {
-      throw new RuntimeException(e);
+    } catch (IOException e) {
+      webSocket.failWebSocket(e, null);
+    } finally {
+      closeQuietly(source);
     }
-
-    replyExecutor.shutdown();
-    Util.closeQuietly(sink);
-    Util.closeQuietly(source);
   }
 
   private void writeHttpResponse(Socket socket, BufferedSink sink, MockResponse response)
       throws IOException {
+    sleepIfDelayed(response.getBodyDelay(TimeUnit.MILLISECONDS));
     sink.writeUtf8(response.getStatus());
     sink.writeUtf8("\r\n");
 
@@ -715,12 +701,11 @@ private void writeHttpResponse(Socket socket, BufferedSink sink, MockResponse re
 
     Buffer body = response.getBody();
     if (body == null) return;
-    sleepIfDelayed(response);
+    sleepIfDelayed(response.getBodyDelay(TimeUnit.MILLISECONDS));
     throttledTransfer(response, socket, body, sink, body.size(), false);
   }
 
-  private void sleepIfDelayed(MockResponse response) {
-    long delayMs = response.getBodyDelay(TimeUnit.MILLISECONDS);
+  private void sleepIfDelayed(long delayMs) {
     if (delayMs != 0) {
       try {
         Thread.sleep(delayMs);
@@ -802,6 +787,10 @@ public void setDispatcher(Dispatcher dispatcher) {
     return "MockWebServer[" + port + "]";
   }
 
+  @Override public void close() throws IOException {
+    shutdown();
+  }
+
   /** A buffer wrapper that drops data after {@code bodyLimit} bytes. */
   private static class TruncatingBuffer implements Sink {
     private final Buffer buffer = new Buffer();
@@ -836,18 +825,18 @@ public void setDispatcher(Dispatcher dispatcher) {
     }
   }
 
-  /** Processes HTTP requests layered over framed protocols. */
-  private class FramedSocketHandler extends FramedConnection.Listener {
+  /** Processes HTTP requests layered over HTTP/2. */
+  private class Http2SocketHandler extends Http2Connection.Listener {
     private final Socket socket;
     private final Protocol protocol;
     private final AtomicInteger sequenceNumber = new AtomicInteger();
 
-    private FramedSocketHandler(Socket socket, Protocol protocol) {
+    private Http2SocketHandler(Socket socket, Protocol protocol) {
       this.socket = socket;
       this.protocol = protocol;
     }
 
-    @Override public void onStream(FramedStream stream) throws IOException {
+    @Override public void onStream(Http2Stream stream) throws IOException {
       MockResponse peekedResponse = dispatcher.peek();
       if (peekedResponse.getSocketPolicy() == RESET_STREAM_AT_START) {
         try {
@@ -862,25 +851,35 @@ private FramedSocketHandler(Socket socket, Protocol protocol) {
       RecordedRequest request = readRequest(stream);
       requestCount.incrementAndGet();
       requestQueue.add(request);
+
       MockResponse response;
       try {
         response = dispatcher.dispatch(request);
       } catch (InterruptedException e) {
         throw new AssertionError(e);
       }
+      if (response.getSocketPolicy() == DISCONNECT_AFTER_REQUEST) {
+        socket.close();
+        return;
+      }
       writeResponse(stream, response);
       if (logger.isLoggable(Level.INFO)) {
         logger.info(MockWebServer.this + " received request: " + request
             + " and responded: " + response + " protocol is " + protocol.toString());
       }
+
+      if (response.getSocketPolicy() == DISCONNECT_AT_END) {
+        Http2Connection connection = stream.getConnection();
+        connection.shutdown(ErrorCode.NO_ERROR);
+      }
     }
 
-    private RecordedRequest readRequest(FramedStream stream) throws IOException {
+    private RecordedRequest readRequest(Http2Stream stream) throws IOException {
       List<Header> streamHeaders = stream.getRequestHeaders();
       Headers.Builder httpHeaders = new Headers.Builder();
       String method = "<:method omitted>";
       String path = "<:path omitted>";
-      String version = protocol == Protocol.SPDY_3 ? "<:version omitted>" : "HTTP/1.1";
+      boolean readBody = true;
       for (int i = 0, size = streamHeaders.size(); i < size; i++) {
         ByteString name = streamHeaders.get(i).name;
         String value = streamHeaders.get(i).value.utf8();
@@ -888,30 +887,42 @@ private RecordedRequest readRequest(FramedStream stream) throws IOException {
           method = value;
         } else if (name.equals(Header.TARGET_PATH)) {
           path = value;
-        } else if (name.equals(Header.VERSION)) {
-          version = value;
-        } else if (protocol == Protocol.SPDY_3) {
-          for (String s : value.split("\u0000", -1)) {
-            httpHeaders.add(name.utf8(), s);
-          }
         } else if (protocol == Protocol.HTTP_2) {
           httpHeaders.add(name.utf8(), value);
         } else {
           throw new IllegalStateException();
         }
+        if (name.utf8().equals("expect") && value.equalsIgnoreCase("100-continue")) {
+          // Don't read the body unless we've invited the client to send it.
+          readBody = false;
+        }
+      }
+      Headers headers = httpHeaders.build();
+
+      MockResponse peek = dispatcher.peek();
+      if (!readBody && peek.getSocketPolicy() == EXPECT_CONTINUE) {
+        stream.sendResponseHeaders(Collections.singletonList(
+            new Header(Header.RESPONSE_STATUS, ByteString.encodeUtf8("100 Continue"))), true);
+        stream.getConnection().flush();
+        readBody = true;
       }
 
       Buffer body = new Buffer();
-      body.writeAll(stream.getSource());
-      body.close();
+      if (readBody) {
+        String contentLengthString = headers.get("content-length");
+        long byteCount = contentLengthString != null
+            ? Long.parseLong(contentLengthString)
+            : Long.MAX_VALUE;
+        throttledTransfer(peek, socket, Okio.buffer(stream.getSource()), body, byteCount, true);
+      }
 
-      String requestLine = method + ' ' + path + ' ' + version;
-      List<Integer> chunkSizes = Collections.emptyList(); // No chunked encoding for SPDY.
-      return new RecordedRequest(requestLine, httpHeaders.build(), chunkSizes, body.size(), body,
+      String requestLine = method + ' ' + path + " HTTP/1.1";
+      List<Integer> chunkSizes = Collections.emptyList(); // No chunked encoding for HTTP/2.
+      return new RecordedRequest(requestLine, headers, chunkSizes, body.size(), body,
           sequenceNumber.getAndIncrement(), socket);
     }
 
-    private void writeResponse(FramedStream stream, MockResponse response) throws IOException {
+    private void writeResponse(Http2Stream stream, MockResponse response) throws IOException {
       Settings settings = response.getSettings();
       if (settings != null) {
         stream.getConnection().setSettings(settings);
@@ -920,41 +931,38 @@ private void writeResponse(FramedStream stream, MockResponse response) throws IO
       if (response.getSocketPolicy() == NO_RESPONSE) {
         return;
       }
-      List<Header> spdyHeaders = new ArrayList<>();
-      String[] statusParts = response.getStatus().split(" ", 2);
-      if (statusParts.length != 2) {
+      List<Header> http2Headers = new ArrayList<>();
+      String[] statusParts = response.getStatus().split(" ", 3);
+      if (statusParts.length < 2) {
         throw new AssertionError("Unexpected status: " + response.getStatus());
       }
       // TODO: constants for well-known header names.
-      spdyHeaders.add(new Header(Header.RESPONSE_STATUS, statusParts[1]));
-      if (protocol == Protocol.SPDY_3) {
-        spdyHeaders.add(new Header(Header.VERSION, statusParts[0]));
-      }
+      http2Headers.add(new Header(Header.RESPONSE_STATUS, statusParts[1]));
       Headers headers = response.getHeaders();
       for (int i = 0, size = headers.size(); i < size; i++) {
-        spdyHeaders.add(new Header(headers.name(i), headers.value(i)));
+        http2Headers.add(new Header(headers.name(i), headers.value(i)));
       }
 
+      sleepIfDelayed(response.getHeadersDelay(TimeUnit.MILLISECONDS));
+
       Buffer body = response.getBody();
       boolean closeStreamAfterHeaders = body != null || !response.getPushPromises().isEmpty();
-      stream.reply(spdyHeaders, closeStreamAfterHeaders);
+      stream.sendResponseHeaders(http2Headers, closeStreamAfterHeaders);
       pushPromises(stream, response.getPushPromises());
       if (body != null) {
         BufferedSink sink = Okio.buffer(stream.getSink());
-        sleepIfDelayed(response);
-        throttledTransfer(response, socket, body, sink, bodyLimit, false);
+        sleepIfDelayed(response.getBodyDelay(TimeUnit.MILLISECONDS));
+        throttledTransfer(response, socket, body, sink, body.size(), false);
         sink.close();
       } else if (closeStreamAfterHeaders) {
         stream.close(ErrorCode.NO_ERROR);
       }
     }
 
-    private void pushPromises(FramedStream stream, List<PushPromise> promises) throws IOException {
+    private void pushPromises(Http2Stream stream, List<PushPromise> promises) throws IOException {
       for (PushPromise pushPromise : promises) {
         List<Header> pushedHeaders = new ArrayList<>();
-        pushedHeaders.add(new Header(stream.getConnection().getProtocol() == Protocol.SPDY_3
-            ? Header.TARGET_HOST
-            : Header.TARGET_AUTHORITY, url(pushPromise.path()).host()));
+        pushedHeaders.add(new Header(Header.TARGET_AUTHORITY, url(pushPromise.path()).host()));
         pushedHeaders.add(new Header(Header.TARGET_METHOD, pushPromise.method()));
         pushedHeaders.add(new Header(Header.TARGET_PATH, pushPromise.path()));
         Headers pushPromiseHeaders = pushPromise.headers();
@@ -962,11 +970,11 @@ private void pushPromises(FramedStream stream, List<PushPromise> promises) throw
           pushedHeaders.add(new Header(pushPromiseHeaders.name(i), pushPromiseHeaders.value(i)));
         }
         String requestLine = pushPromise.method() + ' ' + pushPromise.path() + " HTTP/1.1";
-        List<Integer> chunkSizes = Collections.emptyList(); // No chunked encoding for SPDY.
+        List<Integer> chunkSizes = Collections.emptyList(); // No chunked encoding for HTTP/2.
         requestQueue.add(new RecordedRequest(requestLine, pushPromise.headers(), chunkSizes, 0,
             new Buffer(), sequenceNumber.getAndIncrement(), socket));
         boolean hasBody = pushPromise.response().getBody() != null;
-        FramedStream pushedStream =
+        Http2Stream pushedStream =
             stream.getConnection().pushStream(stream.getId(), pushedHeaders, hasBody);
         writeResponse(pushedStream, pushPromise.response());
       }
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/RecordedRequest.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/RecordedRequest.java
index aa847001a2..672d42bc76 100644
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/RecordedRequest.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/RecordedRequest.java
@@ -20,6 +20,7 @@
 import java.util.List;
 import javax.net.ssl.SSLSocket;
 import okhttp3.Headers;
+import okhttp3.HttpUrl;
 import okhttp3.TlsVersion;
 import okio.Buffer;
 
@@ -34,6 +35,7 @@
   private final Buffer body;
   private final int sequenceNumber;
   private final TlsVersion tlsVersion;
+  private final HttpUrl requestUrl;
 
   public RecordedRequest(String requestLine, Headers headers, List<Integer> chunkSizes,
       long bodySize, Buffer body, int sequenceNumber, Socket socket) {
@@ -52,12 +54,22 @@ public RecordedRequest(String requestLine, Headers headers, List<Integer> chunkS
       int pathEnd = requestLine.indexOf(' ', methodEnd + 1);
       this.method = requestLine.substring(0, methodEnd);
       this.path = requestLine.substring(methodEnd + 1, pathEnd);
+
+      String scheme = socket instanceof SSLSocket ? "https" : "http";
+      String hostname = socket.getInetAddress().getHostName();
+      int port = socket.getLocalPort();
+      this.requestUrl = HttpUrl.parse(String.format("%s://%s:%s%s", scheme, hostname, port, path));
     } else {
+      this.requestUrl = null;
       this.method = null;
       this.path = null;
     }
   }
 
+  public HttpUrl getRequestUrl() {
+    return requestUrl;
+  }
+
   public String getRequestLine() {
     return requestLine;
   }
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/SocketPolicy.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/SocketPolicy.java
index eddb7557a4..521c5a0e58 100644
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/SocketPolicy.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/SocketPolicy.java
@@ -37,7 +37,10 @@
   KEEP_OPEN,
 
   /**
-   * Close the socket after the response. This is the default HTTP/1.0 behavior.
+   * Close the socket after the response. This is the default HTTP/1.0 behavior. For HTTP/2
+   * connections, this sends a <a href="https://tools.ietf.org/html/rfc7540#section-6.8">GOAWAY
+   * frame</a> immediately after the response and will close the connection when the client's socket
+   * is exhausted.
    *
    * <p>See {@link SocketPolicy} for reasons why this can cause test flakiness and how to avoid it.
    */
@@ -94,5 +97,12 @@
    * Fail HTTP/2 requests without processing them by sending an {@linkplain
    * MockResponse#getHttp2ErrorCode() HTTP/2 error code}.
    */
-  RESET_STREAM_AT_START
+  RESET_STREAM_AT_START,
+
+  /**
+   * Transmit a {@code HTTP/1.1 100 Continue} response before reading the HTTP request body.
+   * Typically this response is sent when a client makes a request with the header {@code
+   * Expect: 100-continue}.
+   */
+  EXPECT_CONTINUE
 }
diff --git a/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java b/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java
index fe96642940..0db518288a 100644
--- a/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java
+++ b/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java
@@ -16,6 +16,7 @@
 package okhttp3.mockwebserver;
 
 import java.io.BufferedReader;
+import java.io.Closeable;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
@@ -26,12 +27,14 @@
 import java.net.SocketTimeoutException;
 import java.net.URL;
 import java.net.URLConnection;
+import java.nio.charset.StandardCharsets;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 import okhttp3.Headers;
+import okhttp3.HttpUrl;
 import okhttp3.internal.Util;
 import org.junit.After;
 import org.junit.Rule;
@@ -104,6 +107,17 @@
     assertEquals(Arrays.asList("Cookies: delicious", "cookie: r=robot"), headersToList(response));
   }
 
+  @Test public void mockResponseSetHeaders() {
+    MockResponse response = new MockResponse()
+        .clearHeaders()
+        .addHeader("Cookie: s=square")
+        .addHeader("Cookies: delicious");
+
+    response.setHeaders(new Headers.Builder().add("Cookie", "a=android").build());
+
+    assertEquals(Arrays.asList("Cookie: a=android"), headersToList(response));
+  }
+
   @Test public void regularResponse() throws Exception {
     server.enqueue(new MockResponse().setBody("hello world"));
 
@@ -281,6 +295,9 @@
 
   @Test public void disconnectRequestHalfway() throws IOException {
     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_DURING_REQUEST_BODY));
+    // Limit the size of the request body that the server holds in memory to an arbitrary
+    // 3.5 MBytes so this test can pass on devices with little memory.
+    server.setBodyLimit(7 * 512 * 1024);
 
     HttpURLConnection connection = (HttpURLConnection) server.url("/").url().openConnection();
     connection.setRequestMethod("POST");
@@ -336,6 +353,11 @@
     server.shutdown();
   }
 
+  @Test public void closeViaClosable() throws IOException {
+    Closeable server = new MockWebServer();
+    server.close();
+  }
+
   @Test public void shutdownWithoutEnqueue() throws IOException {
     MockWebServer server = new MockWebServer();
     server.start();
@@ -396,4 +418,42 @@
     // Shutting down the server should unblock the dispatcher.
     server.shutdown();
   }
+
+  @Test public void requestUrlReconstructed() throws Exception {
+    server.enqueue(new MockResponse().setBody("hello world"));
+
+    URL url = server.url("/a/deep/path?key=foo%20bar").url();
+    HttpURLConnection connection = (HttpURLConnection) url.openConnection();
+    InputStream in = connection.getInputStream();
+    BufferedReader reader = new BufferedReader(new InputStreamReader(in));
+    assertEquals(HttpURLConnection.HTTP_OK, connection.getResponseCode());
+    assertEquals("hello world", reader.readLine());
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("GET /a/deep/path?key=foo%20bar HTTP/1.1", request.getRequestLine());
+
+    HttpUrl requestUrl = request.getRequestUrl();
+    assertEquals("http", requestUrl.scheme());
+    assertEquals(server.getHostName(), requestUrl.host());
+    assertEquals(server.getPort(), requestUrl.port());
+    assertEquals("/a/deep/path", requestUrl.encodedPath());
+    assertEquals("foo bar", requestUrl.queryParameter("key"));
+  }
+
+  @Test public void http100Continue() throws Exception {
+    server.enqueue(new MockResponse().setBody("response"));
+
+    URL url = server.url("/").url();
+    HttpURLConnection connection = (HttpURLConnection) url.openConnection();
+    connection.setDoOutput(true);
+    connection.setRequestProperty("Expect", "100-Continue");
+    connection.getOutputStream().write("request".getBytes(StandardCharsets.UTF_8));
+
+    InputStream in = connection.getInputStream();
+    BufferedReader reader = new BufferedReader(new InputStreamReader(in));
+    assertEquals("response", reader.readLine());
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("request", request.getBody().readUtf8());
+  }
 }
diff --git a/okcurl/README.md b/okcurl/README.md
index cea5be4064..4c65202b11 100644
--- a/okcurl/README.md
+++ b/okcurl/README.md
@@ -4,4 +4,4 @@ OkCurl
 _A curl for the next-generation web._
 
 OkCurl is an OkHttp-backed curl clone which allows you to test OkHttp's HTTP engine (including
-SPDY and HTTP/2) against web servers.
+HTTP/2) against web servers.
diff --git a/okcurl/pom.xml b/okcurl/pom.xml
index a12f1f43ac..c444a23b4d 100644
--- a/okcurl/pom.xml
+++ b/okcurl/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.4.0-SNAPSHOT</version>
+    <version>3.10.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okcurl</artifactId>
diff --git a/okcurl/src/main/java/okhttp3/curl/Main.java b/okcurl/src/main/java/okhttp3/curl/Main.java
index aa8f4872c1..ddff8e6790 100644
--- a/okcurl/src/main/java/okhttp3/curl/Main.java
+++ b/okcurl/src/main/java/okhttp3/curl/Main.java
@@ -45,8 +45,8 @@
 import okhttp3.RequestBody;
 import okhttp3.Response;
 import okhttp3.internal.Util;
-import okhttp3.internal.framed.Http2;
 import okhttp3.internal.http.StatusLine;
+import okhttp3.internal.http2.Http2;
 import okio.BufferedSource;
 import okio.Okio;
 import okio.Sink;
@@ -274,7 +274,7 @@ private static HostnameVerifier createInsecureHostnameVerifier() {
   }
 
   private static void enableHttp2FrameLogging() {
-    frameLogger = Logger.getLogger(Http2.class.getName() + "$FrameLogger");
+    frameLogger = Logger.getLogger(Http2.class.getName());
     frameLogger.setLevel(Level.FINE);
     ConsoleHandler handler = new ConsoleHandler();
     handler.setLevel(Level.FINE);
diff --git a/okhttp-android-support/pom.xml b/okhttp-android-support/pom.xml
index 6d26b36731..e2ff34c2e4 100644
--- a/okhttp-android-support/pom.xml
+++ b/okhttp-android-support/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.4.0-SNAPSHOT</version>
+    <version>3.10.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-android-support</artifactId>
@@ -16,6 +16,11 @@
   </description>
 
   <dependencies>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
     <dependency>
       <groupId>${project.groupId}</groupId>
       <artifactId>okhttp-testing-support</artifactId>
diff --git a/okhttp-android-support/src/main/java/okhttp3/AndroidShimResponseCache.java b/okhttp-android-support/src/main/java/okhttp3/AndroidShimResponseCache.java
index b0bb9fcf73..c46a0cb9fd 100644
--- a/okhttp-android-support/src/main/java/okhttp3/AndroidShimResponseCache.java
+++ b/okhttp-android-support/src/main/java/okhttp3/AndroidShimResponseCache.java
@@ -70,7 +70,7 @@ public Cache getCache() {
       // The URLConnection is not cacheable or could not be converted. Stop.
       return null;
     }
-    okhttp3.internal.http.CacheRequest okCacheRequest =
+    okhttp3.internal.cache.CacheRequest okCacheRequest =
         delegate.internalCache.put(okResponse);
     if (okCacheRequest == null) {
       return null;
diff --git a/okhttp-android-support/src/main/java/okhttp3/internal/huc/CacheAdapter.java b/okhttp-android-support/src/main/java/okhttp3/internal/huc/CacheAdapter.java
index 8e02239dea..5bca95b937 100644
--- a/okhttp-android-support/src/main/java/okhttp3/internal/huc/CacheAdapter.java
+++ b/okhttp-android-support/src/main/java/okhttp3/internal/huc/CacheAdapter.java
@@ -25,9 +25,9 @@
 import java.util.Map;
 import okhttp3.Request;
 import okhttp3.Response;
-import okhttp3.internal.InternalCache;
-import okhttp3.internal.http.CacheRequest;
-import okhttp3.internal.http.CacheStrategy;
+import okhttp3.internal.cache.CacheRequest;
+import okhttp3.internal.cache.CacheStrategy;
+import okhttp3.internal.cache.InternalCache;
 import okio.Okio;
 import okio.Sink;
 
@@ -78,7 +78,7 @@ public ResponseCache getDelegate() {
     // cacheable or the client should be careful about caching it.
   }
 
-  @Override public void update(Response cached, Response network) throws IOException {
+  @Override public void update(Response cached, Response network) {
     // This method is treated as optional and there is no obvious way of implementing it with
     // ResponseCache. Updating headers is useful if the server changes the metadata for a resource
     // (e.g. max age) to extend or truncate the life of that resource in the cache. If the metadata
diff --git a/okhttp-android-support/src/main/java/okhttp3/internal/huc/JavaApiConverter.java b/okhttp-android-support/src/main/java/okhttp3/internal/huc/JavaApiConverter.java
index 2465372a55..1dec85cdc0 100644
--- a/okhttp-android-support/src/main/java/okhttp3/internal/huc/JavaApiConverter.java
+++ b/okhttp-android-support/src/main/java/okhttp3/internal/huc/JavaApiConverter.java
@@ -42,13 +42,15 @@
 import okhttp3.RequestBody;
 import okhttp3.Response;
 import okhttp3.ResponseBody;
+import okhttp3.TlsVersion;
 import okhttp3.internal.Internal;
 import okhttp3.internal.JavaNetHeaders;
 import okhttp3.internal.Util;
-import okhttp3.internal.http.CacheRequest;
+import okhttp3.internal.cache.CacheRequest;
+import okhttp3.internal.http.HttpHeaders;
 import okhttp3.internal.http.HttpMethod;
-import okhttp3.internal.http.OkHeaders;
 import okhttp3.internal.http.StatusLine;
+import okhttp3.internal.platform.Platform;
 import okio.BufferedSource;
 import okio.Okio;
 import okio.Sink;
@@ -57,7 +59,11 @@
  * Helper methods that convert between Java and OkHttp representations.
  */
 public final class JavaApiConverter {
-  private static final RequestBody EMPTY_REQUEST_BODY = RequestBody.create(null, new byte[0]);
+  /** Synthetic response header: the local time when the request was sent. */
+  private static final String SENT_MILLIS = Platform.get().getPrefix() + "-Sent-Millis";
+
+  /** Synthetic response header: the local time when the response was received. */
+  private static final String RECEIVED_MILLIS = Platform.get().getPrefix() + "-Received-Millis";
 
   private JavaApiConverter() {
   }
@@ -85,7 +91,7 @@ public static Response createOkResponseForCachePut(URI uri, URLConnection urlCon
     // OkHttp's Call API requires a placeholder body; the real body will be streamed separately.
     String requestMethod = httpUrlConnection.getRequestMethod();
     RequestBody placeholderBody = HttpMethod.requiresRequestBody(requestMethod)
-        ? EMPTY_REQUEST_BODY
+        ? Util.EMPTY_REQUEST
         : null;
 
     Request okRequest = new Request.Builder()
@@ -128,7 +134,7 @@ public static Response createOkResponseForCachePut(URI uri, URLConnection urlCon
 
       String cipherSuiteString = httpsUrlConnection.getCipherSuite();
       CipherSuite cipherSuite = CipherSuite.forJavaName(cipherSuiteString);
-      Handshake handshake = Handshake.get(null, cipherSuite,
+      Handshake handshake = Handshake.get(TlsVersion.SSL_3_0, cipherSuite,
           nullSafeImmutableList(peerCertificates), nullSafeImmutableList(localCertificates));
       okResponseBuilder.handshake(handshake);
     }
@@ -155,11 +161,11 @@ private static Headers createHeaders(Map<String, List<String>> headers) {
   }
 
   private static Headers varyHeaders(URLConnection urlConnection, Headers responseHeaders) {
-    if (OkHeaders.hasVaryAll(responseHeaders)) {
+    if (HttpHeaders.hasVaryAll(responseHeaders)) {
       // "*" means that this will be treated as uncacheable anyway.
       return null;
     }
-    Set<String> varyFields = OkHeaders.varyFields(responseHeaders);
+    Set<String> varyFields = HttpHeaders.varyFields(responseHeaders);
     if (varyFields.isEmpty()) {
       return new Headers.Builder().build();
     }
@@ -205,11 +211,11 @@ static Response createOkResponseForCacheGet(Request request, CacheResponse javaR
     // Build a cache request for the response to use.
     Headers responseHeaders = createHeaders(javaResponse.getHeaders());
     Headers varyHeaders;
-    if (OkHeaders.hasVaryAll(responseHeaders)) {
+    if (HttpHeaders.hasVaryAll(responseHeaders)) {
       // "*" means that this will be treated as uncacheable anyway.
       varyHeaders = new Headers.Builder().build();
     } else {
-      varyHeaders = OkHeaders.varyHeaders(request.headers(), responseHeaders);
+      varyHeaders = HttpHeaders.varyHeaders(request.headers(), responseHeaders);
     }
 
     Request cacheRequest = new Request.Builder()
@@ -255,7 +261,8 @@ static Response createOkResponseForCacheGet(Request request, CacheResponse javaR
 
       String cipherSuiteString = javaSecureCacheResponse.getCipherSuite();
       CipherSuite cipherSuite = CipherSuite.forJavaName(cipherSuiteString);
-      Handshake handshake = Handshake.get(null, cipherSuite, peerCertificates, localCertificates);
+      Handshake handshake = Handshake.get(
+          TlsVersion.SSL_3_0, cipherSuite, peerCertificates, localCertificates);
       okResponseBuilder.handshake(handshake);
     }
 
@@ -273,7 +280,7 @@ public static Request createOkRequest(
       URI uri, String requestMethod, Map<String, List<String>> requestHeaders) {
     // OkHttp's Call API requires a placeholder body; the real body will be streamed separately.
     RequestBody placeholderBody = HttpMethod.requiresRequestBody(requestMethod)
-        ? EMPTY_REQUEST_BODY
+        ? Util.EMPTY_REQUEST
         : null;
 
     Request.Builder builder = new Request.Builder()
@@ -397,8 +404,8 @@ static HttpURLConnection createJavaUrlConnectionForCachePut(Response okResponse)
 
   private static Headers withSyntheticHeaders(Response okResponse) {
     return okResponse.headers().newBuilder()
-        .add(OkHeaders.SENT_MILLIS, Long.toString(okResponse.sentRequestAtMillis()))
-        .add(OkHeaders.RECEIVED_MILLIS, Long.toString(okResponse.receivedResponseAtMillis()))
+        .add(SENT_MILLIS, Long.toString(okResponse.sentRequestAtMillis()))
+        .add(RECEIVED_MILLIS, Long.toString(okResponse.receivedResponseAtMillis()))
         .build();
   }
 
@@ -448,11 +455,11 @@ static Headers extractOkHeaders(
         continue;
       }
       if (okResponseBuilder != null && javaHeader.getValue().size() == 1) {
-        if (name.equals(OkHeaders.SENT_MILLIS)) {
+        if (name.equals(SENT_MILLIS)) {
           okResponseBuilder.sentRequestAtMillis(Long.valueOf(javaHeader.getValue().get(0)));
           continue;
         }
-        if (name.equals(OkHeaders.RECEIVED_MILLIS)) {
+        if (name.equals(RECEIVED_MILLIS)) {
           okResponseBuilder.receivedResponseAtMillis(Long.valueOf(javaHeader.getValue().get(0)));
           continue;
         }
@@ -512,7 +519,7 @@ public MediaType contentType() {
 
       @Override
       public long contentLength() {
-        return OkHeaders.contentLength(okHeaders);
+        return HttpHeaders.contentLength(okHeaders);
       }
 
       @Override public BufferedSource source() {
@@ -561,7 +568,7 @@ private static ResponseBody createOkBody(final URLConnection urlConnection) thro
     private final Request request;
     private final Response response;
 
-    public CacheHttpURLConnection(Response response) {
+    CacheHttpURLConnection(Response response) {
       super(response.request().url().url());
       this.request = response.request();
       this.response = response;
@@ -828,7 +835,7 @@ public void setDefaultUseCaches(boolean defaultUseCaches) {
   private static final class CacheHttpsURLConnection extends DelegatingHttpsURLConnection {
     private final CacheHttpURLConnection delegate;
 
-    public CacheHttpsURLConnection(CacheHttpURLConnection delegate) {
+    CacheHttpsURLConnection(CacheHttpURLConnection delegate) {
       super(delegate);
       this.delegate = delegate;
     }
@@ -852,18 +859,6 @@ public CacheHttpsURLConnection(CacheHttpURLConnection delegate) {
     @Override public SSLSocketFactory getSSLSocketFactory() {
       throw throwRequestSslAccessException();
     }
-
-    @Override public long getContentLengthLong() {
-      return delegate.getContentLengthLong();
-    }
-
-    @Override public void setFixedLengthStreamingMode(long contentLength) {
-      delegate.setFixedLengthStreamingMode(contentLength);
-    }
-
-    @Override public long getHeaderFieldLong(String field, long defaultValue) {
-      return delegate.getHeaderFieldLong(field, defaultValue);
-    }
   }
 
   private static RuntimeException throwRequestModificationException() {
diff --git a/okhttp-android-support/src/test/java/okhttp3/internal/huc/CacheAdapterTest.java b/okhttp-android-support/src/test/java/okhttp3/internal/huc/CacheAdapterTest.java
index e24c7264ad..53470ce87b 100644
--- a/okhttp-android-support/src/test/java/okhttp3/internal/huc/CacheAdapterTest.java
+++ b/okhttp-android-support/src/test/java/okhttp3/internal/huc/CacheAdapterTest.java
@@ -34,7 +34,7 @@
 import okhttp3.OkUrlFactory;
 import okhttp3.RecordingHostnameVerifier;
 import okhttp3.internal.Internal;
-import okhttp3.internal.InternalCache;
+import okhttp3.internal.cache.InternalCache;
 import okhttp3.internal.tls.SslClient;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
@@ -83,11 +83,15 @@
     ResponseCache responseCache = new AbstractResponseCache() {
       @Override public CacheResponse get(
           URI uri, String method, Map<String, List<String>> headers) throws IOException {
-        assertEquals(toUri(serverUrl), uri);
-        assertEquals("GET", method);
-        assertTrue("Arbitrary standard header not present", headers.containsKey("User-Agent"));
-        assertEquals(Collections.singletonList("value1"), headers.get("key1"));
-        return null;
+        try {
+          assertEquals(toUri(serverUrl), uri);
+          assertEquals("GET", method);
+          assertTrue("Arbitrary standard header not present", headers.containsKey("User-Agent"));
+          assertEquals(Collections.singletonList("value1"), headers.get("key1"));
+          return null;
+        } catch (Throwable t) {
+          throw new IOException("unexpected cache failure", t);
+        }
       }
     };
     setInternalCache(new CacheAdapter(responseCache));
@@ -105,12 +109,16 @@
     ResponseCache responseCache = new AbstractResponseCache() {
       @Override public CacheResponse get(URI uri, String method, Map<String, List<String>> headers)
           throws IOException {
-        assertEquals("https", uri.getScheme());
-        assertEquals(toUri(serverUrl), uri);
-        assertEquals("GET", method);
-        assertTrue("Arbitrary standard header not present", headers.containsKey("User-Agent"));
-        assertEquals(Collections.singletonList("value1"), headers.get("key1"));
-        return null;
+        try {
+          assertEquals("https", uri.getScheme());
+          assertEquals(toUri(serverUrl), uri);
+          assertEquals("GET", method);
+          assertTrue("Arbitrary standard header not present", headers.containsKey("User-Agent"));
+          assertEquals(Collections.singletonList("value1"), headers.get("key1"));
+          return null;
+        } catch (Throwable t) {
+          throw new IOException("unexpected cache failure", t);
+        }
       }
     };
     setInternalCache(new CacheAdapter(responseCache));
@@ -136,27 +144,31 @@
 
     ResponseCache responseCache = new AbstractResponseCache() {
       @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
-        assertTrue(connection instanceof HttpURLConnection);
-        assertFalse(connection instanceof HttpsURLConnection);
-
-        assertEquals(response.length, connection.getContentLength());
-
-        HttpURLConnection httpUrlConnection = (HttpURLConnection) connection;
-        assertEquals("GET", httpUrlConnection.getRequestMethod());
-        assertTrue(httpUrlConnection.getDoInput());
-        assertFalse(httpUrlConnection.getDoOutput());
-
-        assertEquals("Fantastic", httpUrlConnection.getResponseMessage());
-        assertEquals(toUri(serverUrl), uri);
-        assertEquals(serverUrl, connection.getURL());
-        assertEquals("value", connection.getRequestProperty("key"));
-
-        // Check retrieval by string key.
-        assertEquals(statusLine, httpUrlConnection.getHeaderField(null));
-        assertEquals("c", httpUrlConnection.getHeaderField("A"));
-        // The RI and OkHttp supports case-insensitive matching for this method.
-        assertEquals("c", httpUrlConnection.getHeaderField("a"));
-        return null;
+        try {
+          assertTrue(connection instanceof HttpURLConnection);
+          assertFalse(connection instanceof HttpsURLConnection);
+
+          assertEquals(response.length, connection.getContentLength());
+
+          HttpURLConnection httpUrlConnection = (HttpURLConnection) connection;
+          assertEquals("GET", httpUrlConnection.getRequestMethod());
+          assertTrue(httpUrlConnection.getDoInput());
+          assertFalse(httpUrlConnection.getDoOutput());
+
+          assertEquals("Fantastic", httpUrlConnection.getResponseMessage());
+          assertEquals(toUri(serverUrl), uri);
+          assertEquals(serverUrl, connection.getURL());
+          assertEquals("value", connection.getRequestProperty("key"));
+
+          // Check retrieval by string key.
+          assertEquals(statusLine, httpUrlConnection.getHeaderField(null));
+          assertEquals("c", httpUrlConnection.getHeaderField("A"));
+          // The RI and OkHttp supports case-insensitive matching for this method.
+          assertEquals("c", httpUrlConnection.getHeaderField("a"));
+          return null;
+        } catch (Throwable t) {
+          throw new IOException("unexpected cache failure", t);
+        }
       }
     };
     setInternalCache(new CacheAdapter(responseCache));
@@ -175,27 +187,31 @@
 
     ResponseCache responseCache = new AbstractResponseCache() {
       @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
-        assertTrue(connection instanceof HttpURLConnection);
-        assertFalse(connection instanceof HttpsURLConnection);
-
-        assertEquals(0, connection.getContentLength());
-
-        HttpURLConnection httpUrlConnection = (HttpURLConnection) connection;
-        assertEquals("POST", httpUrlConnection.getRequestMethod());
-        assertTrue(httpUrlConnection.getDoInput());
-        assertTrue(httpUrlConnection.getDoOutput());
-
-        assertEquals("Fantastic", httpUrlConnection.getResponseMessage());
-        assertEquals(toUri(serverUrl), uri);
-        assertEquals(serverUrl, connection.getURL());
-        assertEquals("value", connection.getRequestProperty("key"));
-
-        // Check retrieval by string key.
-        assertEquals(statusLine, httpUrlConnection.getHeaderField(null));
-        assertEquals("c", httpUrlConnection.getHeaderField("A"));
-        // The RI and OkHttp supports case-insensitive matching for this method.
-        assertEquals("c", httpUrlConnection.getHeaderField("a"));
-        return null;
+        try {
+          assertTrue(connection instanceof HttpURLConnection);
+          assertFalse(connection instanceof HttpsURLConnection);
+
+          assertEquals(0, connection.getContentLength());
+
+          HttpURLConnection httpUrlConnection = (HttpURLConnection) connection;
+          assertEquals("POST", httpUrlConnection.getRequestMethod());
+          assertTrue(httpUrlConnection.getDoInput());
+          assertTrue(httpUrlConnection.getDoOutput());
+
+          assertEquals("Fantastic", httpUrlConnection.getResponseMessage());
+          assertEquals(toUri(serverUrl), uri);
+          assertEquals(serverUrl, connection.getURL());
+          assertEquals("value", connection.getRequestProperty("key"));
+
+          // Check retrieval by string key.
+          assertEquals(statusLine, httpUrlConnection.getHeaderField(null));
+          assertEquals("c", httpUrlConnection.getHeaderField("A"));
+          // The RI and OkHttp supports case-insensitive matching for this method.
+          assertEquals("c", httpUrlConnection.getHeaderField("a"));
+          return null;
+        } catch (Throwable t) {
+          throw new IOException("unexpected cache failure", t);
+        }
       }
     };
     setInternalCache(new CacheAdapter(responseCache));
@@ -211,24 +227,28 @@
 
     ResponseCache responseCache = new AbstractResponseCache() {
       @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
-        assertTrue(connection instanceof HttpsURLConnection);
-        assertEquals(toUri(serverUrl), uri);
-        assertEquals(serverUrl, connection.getURL());
-
-        HttpsURLConnection cacheHttpsUrlConnection = (HttpsURLConnection) connection;
-        HttpsURLConnection realHttpsUrlConnection =
-            (HttpsURLConnection) CacheAdapterTest.this.connection;
-        assertEquals(realHttpsUrlConnection.getCipherSuite(),
-            cacheHttpsUrlConnection.getCipherSuite());
-        assertEquals(realHttpsUrlConnection.getPeerPrincipal(),
-            cacheHttpsUrlConnection.getPeerPrincipal());
-        assertArrayEquals(realHttpsUrlConnection.getLocalCertificates(),
-            cacheHttpsUrlConnection.getLocalCertificates());
-        assertArrayEquals(realHttpsUrlConnection.getServerCertificates(),
-            cacheHttpsUrlConnection.getServerCertificates());
-        assertEquals(realHttpsUrlConnection.getLocalPrincipal(),
-            cacheHttpsUrlConnection.getLocalPrincipal());
-        return null;
+        try {
+          assertTrue(connection instanceof HttpsURLConnection);
+          assertEquals(toUri(serverUrl), uri);
+          assertEquals(serverUrl, connection.getURL());
+
+          HttpsURLConnection cacheHttpsUrlConnection = (HttpsURLConnection) connection;
+          HttpsURLConnection realHttpsUrlConnection =
+              (HttpsURLConnection) CacheAdapterTest.this.connection;
+          assertEquals(realHttpsUrlConnection.getCipherSuite(),
+              cacheHttpsUrlConnection.getCipherSuite());
+          assertEquals(realHttpsUrlConnection.getPeerPrincipal(),
+              cacheHttpsUrlConnection.getPeerPrincipal());
+          assertArrayEquals(realHttpsUrlConnection.getLocalCertificates(),
+              cacheHttpsUrlConnection.getLocalCertificates());
+          assertArrayEquals(realHttpsUrlConnection.getServerCertificates(),
+              cacheHttpsUrlConnection.getServerCertificates());
+          assertEquals(realHttpsUrlConnection.getLocalPrincipal(),
+              cacheHttpsUrlConnection.getLocalPrincipal());
+          return null;
+        } catch (Throwable t) {
+          throw new IOException("unexpected cache failure", t);
+        }
       }
     };
     setInternalCache(new CacheAdapter(responseCache));
diff --git a/okhttp-android-support/src/test/java/okhttp3/internal/huc/JavaApiConverterTest.java b/okhttp-android-support/src/test/java/okhttp3/internal/huc/JavaApiConverterTest.java
index f4c9b95dab..c14d6d57f4 100644
--- a/okhttp-android-support/src/test/java/okhttp3/internal/huc/JavaApiConverterTest.java
+++ b/okhttp-android-support/src/test/java/okhttp3/internal/huc/JavaApiConverterTest.java
@@ -31,7 +31,7 @@
 import java.security.cert.X509Certificate;
 import java.util.Arrays;
 import java.util.Collections;
-import java.util.HashMap;
+import java.util.LinkedHashMap;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
@@ -47,6 +47,7 @@
 import okhttp3.RequestBody;
 import okhttp3.Response;
 import okhttp3.ResponseBody;
+import okhttp3.TlsVersion;
 import okhttp3.internal.Internal;
 import okhttp3.internal.Util;
 import okhttp3.mockwebserver.MockWebServer;
@@ -106,7 +107,7 @@
     Request request = new Request.Builder().url(uri.toURL()).build();
     CacheResponse cacheResponse = new CacheResponse() {
       @Override public Map<String, List<String>> getHeaders() throws IOException {
-        Map<String, List<String>> headers = new HashMap<>();
+        Map<String, List<String>> headers = new LinkedHashMap<>();
         headers.put(null, Collections.singletonList(statusLine));
         headers.put("xyzzy", Arrays.asList("bar", "baz"));
         return headers;
@@ -138,7 +139,7 @@
     Request request = new Request.Builder().url(uri.toURL()).build();
     CacheResponse cacheResponse = new CacheResponse() {
       @Override public Map<String, List<String>> getHeaders() throws IOException {
-        Map<String, List<String>> headers = new HashMap<>();
+        Map<String, List<String>> headers = new LinkedHashMap<>();
         // Headers is deliberately missing an entry with a null key.
         headers.put("xyzzy", Arrays.asList("bar", "baz"));
         return headers;
@@ -166,7 +167,7 @@
     Request request = new Request.Builder().url(uri.toURL()).build();
     SecureCacheResponse cacheResponse = new SecureCacheResponse() {
       @Override public Map<String, List<String>> getHeaders() throws IOException {
-        Map<String, List<String>> headers = new HashMap<>();
+        Map<String, List<String>> headers = new LinkedHashMap<>();
         headers.put(null, Collections.singletonList(statusLine));
         headers.put("xyzzy", Arrays.asList("bar", "baz"));
         return headers;
@@ -235,7 +236,7 @@
   @Test public void createOkRequest_nonNullRequestHeaders() throws Exception {
     URI uri = new URI("https://foo/bar");
 
-    Map<String, List<String>> javaRequestHeaders = new HashMap<>();
+    Map<String, List<String>> javaRequestHeaders = new LinkedHashMap<>();
     javaRequestHeaders.put("Foo", Arrays.asList("Bar"));
     Request request = JavaApiConverter.createOkRequest(uri, "POST", javaRequestHeaders);
     assertTrue(request.isHttps());
@@ -253,7 +254,7 @@
   @Test public void createOkRequest_nullRequestHeaderKey() throws Exception {
     URI uri = new URI("https://foo/bar");
 
-    Map<String, List<String>> javaRequestHeaders = new HashMap<>();
+    Map<String, List<String>> javaRequestHeaders = new LinkedHashMap<>();
     javaRequestHeaders.put(null, Arrays.asList("GET / HTTP 1.1"));
     javaRequestHeaders.put("Foo", Arrays.asList("Bar"));
     Request request = JavaApiConverter.createOkRequest(uri, "POST", javaRequestHeaders);
@@ -464,7 +465,7 @@ private void assertHeadersContainsMapping(Map<String, List<String>> headers, Str
         .get()
         .url("https://secure/request")
         .build();
-    Handshake handshake = Handshake.get(null, CipherSuite.TLS_RSA_WITH_NULL_MD5,
+    Handshake handshake = Handshake.get(TlsVersion.SSL_3_0, CipherSuite.TLS_RSA_WITH_NULL_MD5,
         Arrays.<Certificate>asList(SERVER_CERT), Arrays.<Certificate>asList(LOCAL_CERT));
     Response okResponse = createArbitraryOkResponse(okRequest).newBuilder()
         .handshake(handshake)
@@ -554,7 +555,7 @@ private void assertHeadersContainsMapping(Map<String, List<String>> headers, Str
             .post(createRequestBody("RequestBody"))
             .build();
     ResponseBody responseBody = createResponseBody("ResponseBody");
-    Handshake handshake = Handshake.get(null, CipherSuite.TLS_RSA_WITH_NULL_MD5,
+    Handshake handshake = Handshake.get(TlsVersion.SSL_3_0, CipherSuite.TLS_RSA_WITH_NULL_MD5,
         Arrays.<Certificate>asList(SERVER_CERT), Arrays.<Certificate>asList(LOCAL_CERT));
     Response okResponse = createArbitraryOkResponse(okRequest).newBuilder()
         .protocol(Protocol.HTTP_1_1)
@@ -592,7 +593,7 @@ private void assertHeadersContainsMapping(Map<String, List<String>> headers, Str
   }
 
   @Test public void extractOkHeaders() {
-    Map<String, List<String>> javaResponseHeaders = new HashMap<>();
+    Map<String, List<String>> javaResponseHeaders = new LinkedHashMap<>();
     javaResponseHeaders.put(null, Arrays.asList("StatusLine"));
     javaResponseHeaders.put("key1", Arrays.asList("value1_1", "value1_2"));
     javaResponseHeaders.put("key2", Arrays.asList("value2"));
@@ -604,7 +605,7 @@ private void assertHeadersContainsMapping(Map<String, List<String>> headers, Str
   }
 
   @Test public void extractStatusLine() throws Exception {
-    Map<String, List<String>> javaResponseHeaders = new HashMap<>();
+    Map<String, List<String>> javaResponseHeaders = new LinkedHashMap<>();
     javaResponseHeaders.put(null, Arrays.asList("StatusLine"));
     javaResponseHeaders.put("key1", Arrays.asList("value1_1", "value1_2"));
     javaResponseHeaders.put("key2", Arrays.asList("value2"));
diff --git a/okhttp-android-support/src/test/java/okhttp3/internal/huc/ResponseCacheTest.java b/okhttp-android-support/src/test/java/okhttp3/internal/huc/ResponseCacheTest.java
index a533b919b7..51bf46cc88 100644
--- a/okhttp-android-support/src/test/java/okhttp3/internal/huc/ResponseCacheTest.java
+++ b/okhttp-android-support/src/test/java/okhttp3/internal/huc/ResponseCacheTest.java
@@ -43,7 +43,7 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Date;
-import java.util.HashMap;
+import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Locale;
 import java.util.Map;
@@ -62,7 +62,7 @@
 import okhttp3.OkUrlFactory;
 import okhttp3.RecordingHostnameVerifier;
 import okhttp3.internal.Internal;
-import okhttp3.internal.InternalCache;
+import okhttp3.internal.cache.InternalCache;
 import okhttp3.internal.tls.SslClient;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
@@ -84,6 +84,7 @@
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
+import static org.junit.Assume.assumeFalse;
 
 /**
  * Tests the interaction between OkHttp and {@link ResponseCache}. Based on okhttp3.CacheTest with
@@ -190,6 +191,9 @@ private void assertCached(boolean shouldPut, int responseCode) throws Exception
       mockResponse.addHeader("Proxy-Authenticate: Basic realm=\"protected area\"");
     } else if (responseCode == HttpURLConnection.HTTP_UNAUTHORIZED) {
       mockResponse.addHeader("WWW-Authenticate: Basic realm=\"protected area\"");
+    } else if (responseCode == HttpURLConnection.HTTP_NO_CONTENT
+        || responseCode == HttpURLConnection.HTTP_RESET) {
+      mockResponse.setBody(""); // We forbid bodies for 204 and 205.
     }
     server.enqueue(mockResponse);
 
@@ -266,6 +270,8 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
   }
 
   @Test public void secureResponseCaching() throws IOException {
+    assumeFalse(getPlatform().equals("jdk9"));
+
     server.useHttps(sslClient.socketFactory, false);
     server.enqueue(new MockResponse()
         .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
@@ -902,7 +908,7 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
     URL url = server.url("/").url();
 
     assertEquals("A", readAscii(openConnection(url)));
-    assertEquals("A", readAscii(openConnection(url)));
+    assertEquals("B", readAscii(openConnection(url)));
   }
 
   @Test public void clientSideNoStore() throws Exception {
@@ -1923,7 +1929,7 @@ public CacheResponse get(URI uri, String requestMethod,
         return new CacheResponse() {
           @Override public Map<String, List<String>> getHeaders() throws IOException {
             String contentType = "text/plain";
-            Map<String, List<String>> headers = new HashMap<>();
+            Map<String, List<String>> headers = new LinkedHashMap<>();
             headers.put("Content-Length", Arrays.asList(Integer.toString(cachedContent.length)));
             headers.put("Content-Type", Arrays.asList(contentType));
             headers.put("Expires", Arrays.asList(formatDate(-1, TimeUnit.HOURS)));
@@ -1980,6 +1986,8 @@ private InsecureResponseCache(ResponseCache delegate) {
   }
 
   @Test public void cacheReturnsInsecureResponseForSecureRequest() throws IOException {
+    assumeFalse(getPlatform().equals("jdk9"));
+
     server.useHttps(sslClient.socketFactory, false);
     server.enqueue(new MockResponse().setBody("ABC"));
     server.enqueue(new MockResponse().setBody("DEF"));
@@ -2099,11 +2107,11 @@ private InsecureResponseCache(ResponseCache delegate) {
 
     // Use the platform's HTTP stack.
     URLConnection connection = server.url("/").url().openConnection();
-    assertFalse(connection instanceof HttpURLConnectionImpl);
+    assertFalse(connection instanceof OkHttpURLConnection);
     assertEquals("A", readAscii(connection));
 
     URLConnection connection2 = server.url("/").url().openConnection();
-    assertFalse(connection2 instanceof HttpURLConnectionImpl);
+    assertFalse(connection2 instanceof OkHttpURLConnection);
     assertEquals("A", readAscii(connection2));
   }
 
@@ -2123,11 +2131,11 @@ private InsecureResponseCache(ResponseCache delegate) {
 
     // Use the platform's HTTP stack.
     URLConnection connection = server.url("/").url().openConnection();
-    assertFalse(connection instanceof HttpURLConnectionImpl);
+    assertFalse(connection instanceof OkHttpURLConnection);
     assertEquals("A", readAscii(connection));
 
     URLConnection connection2 = server.url("/").url().openConnection();
-    assertFalse(connection2 instanceof HttpURLConnectionImpl);
+    assertFalse(connection2 instanceof OkHttpURLConnection);
     assertEquals("B", readAscii(connection2));
   }
 
@@ -2147,12 +2155,12 @@ private InsecureResponseCache(ResponseCache delegate) {
 
     // Use the platform's HTTP stack.
     URLConnection connection = server.url("/").url().openConnection();
-    assertFalse(connection instanceof HttpURLConnectionImpl);
+    assertFalse(connection instanceof OkHttpURLConnection);
     connection.setRequestProperty("Accept-Language", "en-US");
     assertEquals("A", readAscii(connection));
 
     URLConnection connection2 = server.url("/").url().openConnection();
-    assertFalse(connection2 instanceof HttpURLConnectionImpl);
+    assertFalse(connection2 instanceof OkHttpURLConnection);
     assertEquals("B", readAscii(connection2));
   }
 
@@ -2172,11 +2180,11 @@ private InsecureResponseCache(ResponseCache delegate) {
 
     // Use the platform's HTTP stack.
     URLConnection connection = server.url("/").url().openConnection();
-    assertFalse(connection instanceof HttpURLConnectionImpl);
+    assertFalse(connection instanceof OkHttpURLConnection);
     assertEquals("A", readAscii(connection));
 
     URLConnection connection2 = server.url("/").url().openConnection();
-    assertFalse(connection2 instanceof HttpURLConnectionImpl);
+    assertFalse(connection2 instanceof OkHttpURLConnection);
     assertEquals("B", readAscii(connection2));
   }
 
@@ -2185,4 +2193,8 @@ private void setInternalCache(InternalCache internalCache) {
     Internal.instance.setCache(builder, internalCache);
     urlFactory.setClient(builder.build());
   }
+
+  private String getPlatform() {
+    return System.getProperty("okhttp.platform", "platform");
+  }
 }
diff --git a/okhttp-apache/pom.xml b/okhttp-apache/pom.xml
index 8ae2bc8c23..4cf6878138 100644
--- a/okhttp-apache/pom.xml
+++ b/okhttp-apache/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.4.0-SNAPSHOT</version>
+    <version>3.10.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-apache</artifactId>
diff --git a/okhttp-apache/src/main/java/okhttp3/apache/OkApacheClient.java b/okhttp-apache/src/main/java/okhttp3/apache/OkApacheClient.java
index a1af89f867..d1241d3d01 100644
--- a/okhttp-apache/src/main/java/okhttp3/apache/OkApacheClient.java
+++ b/okhttp-apache/src/main/java/okhttp3/apache/OkApacheClient.java
@@ -10,6 +10,7 @@
 import okhttp3.RequestBody;
 import okhttp3.Response;
 import okhttp3.ResponseBody;
+import okhttp3.internal.Util;
 import org.apache.http.Header;
 import org.apache.http.HttpEntity;
 import org.apache.http.HttpEntityEnclosingRequest;
@@ -66,7 +67,7 @@ private static Request transformRequest(HttpRequest request) {
           builder.header(encoding.getName(), encoding.getValue());
         }
       } else {
-        body = RequestBody.create(null, new byte[0]);
+        body = Util.EMPTY_REQUEST;
       }
     }
     builder.method(method, body);
@@ -74,7 +75,7 @@ private static Request transformRequest(HttpRequest request) {
     return builder.build();
   }
 
-  private static HttpResponse transformResponse(Response response) throws IOException {
+  private static HttpResponse transformResponse(Response response) {
     int code = response.code();
     String message = response.message();
     BasicHttpResponse httpResponse = new BasicHttpResponse(HTTP_1_1, code, message);
diff --git a/okhttp-hpacktests/pom.xml b/okhttp-hpacktests/pom.xml
index 7e8fb57ad7..12bc4e4b49 100644
--- a/okhttp-hpacktests/pom.xml
+++ b/okhttp-hpacktests/pom.xml
@@ -8,7 +8,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.3.0-SNAPSHOT</version>
+    <version>3.5.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-hpacktests</artifactId>
diff --git a/okhttp-hpacktests/src/test/java/okhttp3/internal/framed/HpackDecodeInteropTest.java b/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/HpackDecodeInteropTest.java
similarity index 87%
rename from okhttp-hpacktests/src/test/java/okhttp3/internal/framed/HpackDecodeInteropTest.java
rename to okhttp-hpacktests/src/test/java/okhttp3/internal/http2/HpackDecodeInteropTest.java
index e99c2a29cd..dbcc99f55f 100644
--- a/okhttp-hpacktests/src/test/java/okhttp3/internal/framed/HpackDecodeInteropTest.java
+++ b/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/HpackDecodeInteropTest.java
@@ -13,15 +13,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.framed;
+package okhttp3.internal.http2;
 
 import java.util.Collection;
-import okhttp3.internal.framed.hpackjson.Story;
+import okhttp3.internal.http2.hpackjson.Story;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
-import static okhttp3.internal.framed.hpackjson.HpackJsonUtil.storiesForCurrentDraft;
+import static okhttp3.internal.http2.hpackjson.HpackJsonUtil.storiesForCurrentDraft;
 
 @RunWith(Parameterized.class)
 public class HpackDecodeInteropTest extends HpackDecodeTestBase {
diff --git a/okhttp-hpacktests/src/test/java/okhttp3/internal/framed/HpackDecodeTestBase.java b/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/HpackDecodeTestBase.java
similarity index 93%
rename from okhttp-hpacktests/src/test/java/okhttp3/internal/framed/HpackDecodeTestBase.java
rename to okhttp-hpacktests/src/test/java/okhttp3/internal/http2/HpackDecodeTestBase.java
index a77c4d8a02..a3f69da38c 100644
--- a/okhttp-hpacktests/src/test/java/okhttp3/internal/framed/HpackDecodeTestBase.java
+++ b/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/HpackDecodeTestBase.java
@@ -13,15 +13,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.framed;
+package okhttp3.internal.http2;
 
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.LinkedHashSet;
 import java.util.List;
-import okhttp3.internal.framed.hpackjson.Case;
-import okhttp3.internal.framed.hpackjson.HpackJsonUtil;
-import okhttp3.internal.framed.hpackjson.Story;
+import okhttp3.internal.http2.hpackjson.Case;
+import okhttp3.internal.http2.hpackjson.HpackJsonUtil;
+import okhttp3.internal.http2.hpackjson.Story;
 import okio.Buffer;
 
 import static org.junit.Assert.assertEquals;
diff --git a/okhttp-hpacktests/src/test/java/okhttp3/internal/framed/HpackRoundTripTest.java b/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/HpackRoundTripTest.java
similarity index 93%
rename from okhttp-hpacktests/src/test/java/okhttp3/internal/framed/HpackRoundTripTest.java
rename to okhttp-hpacktests/src/test/java/okhttp3/internal/http2/HpackRoundTripTest.java
index 8405a1fd7f..55325ce53d 100644
--- a/okhttp-hpacktests/src/test/java/okhttp3/internal/framed/HpackRoundTripTest.java
+++ b/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/HpackRoundTripTest.java
@@ -13,11 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.framed;
+package okhttp3.internal.http2;
 
 import java.util.Collection;
-import okhttp3.internal.framed.hpackjson.Case;
-import okhttp3.internal.framed.hpackjson.Story;
+import okhttp3.internal.http2.hpackjson.Case;
+import okhttp3.internal.http2.hpackjson.Story;
 import okio.Buffer;
 import org.junit.Test;
 import org.junit.runner.RunWith;
diff --git a/okhttp-hpacktests/src/test/java/okhttp3/internal/framed/hpackjson/Case.java b/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/hpackjson/Case.java
similarity index 95%
rename from okhttp-hpacktests/src/test/java/okhttp3/internal/framed/hpackjson/Case.java
rename to okhttp-hpacktests/src/test/java/okhttp3/internal/http2/hpackjson/Case.java
index 4c931b7c0e..f1685f3800 100644
--- a/okhttp-hpacktests/src/test/java/okhttp3/internal/framed/hpackjson/Case.java
+++ b/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/hpackjson/Case.java
@@ -13,13 +13,13 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.framed.hpackjson;
+package okhttp3.internal.http2.hpackjson;
 
 import java.util.ArrayList;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
-import okhttp3.internal.framed.Header;
+import okhttp3.internal.http2.Header;
 import okio.ByteString;
 
 /**
diff --git a/okhttp-hpacktests/src/test/java/okhttp3/internal/framed/hpackjson/HpackJsonUtil.java b/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/hpackjson/HpackJsonUtil.java
similarity index 98%
rename from okhttp-hpacktests/src/test/java/okhttp3/internal/framed/hpackjson/HpackJsonUtil.java
rename to okhttp-hpacktests/src/test/java/okhttp3/internal/http2/hpackjson/HpackJsonUtil.java
index 1d38261c53..39b1489d4b 100644
--- a/okhttp-hpacktests/src/test/java/okhttp3/internal/framed/hpackjson/HpackJsonUtil.java
+++ b/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/hpackjson/HpackJsonUtil.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.framed.hpackjson;
+package okhttp3.internal.http2.hpackjson;
 
 import com.squareup.moshi.JsonAdapter;
 import com.squareup.moshi.Moshi;
diff --git a/okhttp-hpacktests/src/test/java/okhttp3/internal/framed/hpackjson/Story.java b/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/hpackjson/Story.java
similarity index 97%
rename from okhttp-hpacktests/src/test/java/okhttp3/internal/framed/hpackjson/Story.java
rename to okhttp-hpacktests/src/test/java/okhttp3/internal/http2/hpackjson/Story.java
index 3d14d5dab5..288a87b81f 100644
--- a/okhttp-hpacktests/src/test/java/okhttp3/internal/framed/hpackjson/Story.java
+++ b/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/hpackjson/Story.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.framed.hpackjson;
+package okhttp3.internal.http2.hpackjson;
 
 import java.util.ArrayList;
 import java.util.List;
diff --git a/okhttp-logging-interceptor/README.md b/okhttp-logging-interceptor/README.md
index 1c5dcd952a..f312938fd1 100644
--- a/okhttp-logging-interceptor/README.md
+++ b/okhttp-logging-interceptor/README.md
@@ -42,7 +42,7 @@ Get via Maven:
 
 or via Gradle 
 ```groovy
-compile 'com.squareup.okhttp3:logging-interceptor:(insert latest version)'
+implementation 'com.squareup.okhttp3:logging-interceptor:(insert latest version)'
 ```
 
 
diff --git a/okhttp-logging-interceptor/pom.xml b/okhttp-logging-interceptor/pom.xml
index 6a451bf7fa..275570d467 100644
--- a/okhttp-logging-interceptor/pom.xml
+++ b/okhttp-logging-interceptor/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.4.0-SNAPSHOT</version>
+    <version>3.10.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>logging-interceptor</artifactId>
@@ -18,6 +18,11 @@
       <artifactId>okhttp</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
diff --git a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java
index 309ebc3f30..2eb8100a45 100644
--- a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java
+++ b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java
@@ -18,24 +18,22 @@
 import java.io.EOFException;
 import java.io.IOException;
 import java.nio.charset.Charset;
-import java.nio.charset.UnsupportedCharsetException;
 import java.util.concurrent.TimeUnit;
 import okhttp3.Connection;
 import okhttp3.Headers;
 import okhttp3.Interceptor;
 import okhttp3.MediaType;
 import okhttp3.OkHttpClient;
-import okhttp3.Protocol;
 import okhttp3.Request;
 import okhttp3.RequestBody;
 import okhttp3.Response;
 import okhttp3.ResponseBody;
-import okhttp3.internal.Platform;
-import okhttp3.internal.http.HttpEngine;
+import okhttp3.internal.http.HttpHeaders;
+import okhttp3.internal.platform.Platform;
 import okio.Buffer;
 import okio.BufferedSource;
 
-import static okhttp3.internal.Platform.INFO;
+import static okhttp3.internal.platform.Platform.INFO;
 
 /**
  * An OkHttp interceptor which logs request and response information. Can be applied as an
@@ -90,7 +88,7 @@
      * Content-Length: 3
      *
      * Hi?
-     * --> END GET
+     * --> END POST
      *
      * <-- 200 OK (22ms)
      * Content-Type: plain/text
@@ -152,8 +150,10 @@ public Level getLevel() {
     boolean hasRequestBody = requestBody != null;
 
     Connection connection = chain.connection();
-    Protocol protocol = connection != null ? connection.protocol() : Protocol.HTTP_1_1;
-    String requestStartMessage = "--> " + request.method() + ' ' + request.url() + ' ' + protocol;
+    String requestStartMessage = "--> "
+        + request.method()
+        + ' ' + request.url()
+        + (connection != null ? " " + connection.protocol() : "");
     if (!logHeaders && hasRequestBody) {
       requestStartMessage += " (" + requestBody.contentLength() + "-byte body)";
     }
@@ -219,9 +219,11 @@ public Level getLevel() {
     ResponseBody responseBody = response.body();
     long contentLength = responseBody.contentLength();
     String bodySize = contentLength != -1 ? contentLength + "-byte" : "unknown-length";
-    logger.log("<-- " + response.code() + ' ' + response.message() + ' '
-        + response.request().url() + " (" + tookMs + "ms" + (!logHeaders ? ", "
-        + bodySize + " body" : "") + ')');
+    logger.log("<-- "
+        + response.code()
+        + (response.message().isEmpty() ? "" : ' ' + response.message())
+        + ' ' + response.request().url()
+        + " (" + tookMs + "ms" + (!logHeaders ? ", " + bodySize + " body" : "") + ')');
 
     if (logHeaders) {
       Headers headers = response.headers();
@@ -229,7 +231,7 @@ public Level getLevel() {
         logger.log(headers.name(i) + ": " + headers.value(i));
       }
 
-      if (!logBody || !HttpEngine.hasBody(response)) {
+      if (!logBody || !HttpHeaders.hasBody(response)) {
         logger.log("<-- END HTTP");
       } else if (bodyEncoded(response.headers())) {
         logger.log("<-- END HTTP (encoded body omitted)");
@@ -241,15 +243,7 @@ public Level getLevel() {
         Charset charset = UTF8;
         MediaType contentType = responseBody.contentType();
         if (contentType != null) {
-          try {
-            charset = contentType.charset(UTF8);
-          } catch (UnsupportedCharsetException e) {
-            logger.log("");
-            logger.log("Couldn't decode the response body; charset is likely malformed.");
-            logger.log("<-- END HTTP");
-
-            return response;
-          }
+          charset = contentType.charset(UTF8);
         }
 
         if (!isPlaintext(buffer)) {
@@ -274,7 +268,7 @@ public Level getLevel() {
    * Returns true if the body in question probably contains human readable text. Uses a small sample
    * of code points to detect unicode control characters commonly used in binary file signatures.
    */
-  static boolean isPlaintext(Buffer buffer) throws EOFException {
+  static boolean isPlaintext(Buffer buffer) {
     try {
       Buffer prefix = new Buffer();
       long byteCount = buffer.size() < 64 ? buffer.size() : 64;
diff --git a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/package-info.java b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/package-info.java
new file mode 100644
index 0000000000..39904701cf
--- /dev/null
+++ b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/package-info.java
@@ -0,0 +1,3 @@
+/** An OkHttp interceptor which logs HTTP request and response data. */
+@javax.annotation.ParametersAreNonnullByDefault
+package okhttp3.logging;
diff --git a/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java b/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java
index caa6cd72bd..108ab18a7d 100644
--- a/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java
+++ b/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java
@@ -21,13 +21,17 @@
 import java.util.ArrayList;
 import java.util.List;
 import java.util.regex.Pattern;
+import javax.net.ssl.HostnameVerifier;
 import okhttp3.Dns;
 import okhttp3.HttpUrl;
 import okhttp3.MediaType;
 import okhttp3.OkHttpClient;
+import okhttp3.Protocol;
+import okhttp3.RecordingHostnameVerifier;
 import okhttp3.Request;
 import okhttp3.RequestBody;
 import okhttp3.Response;
+import okhttp3.internal.tls.SslClient;
 import okhttp3.logging.HttpLoggingInterceptor.Level;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
@@ -39,17 +43,21 @@
 import org.junit.Rule;
 import org.junit.Test;
 
+import static org.hamcrest.CoreMatchers.equalTo;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
+import static org.junit.Assume.assumeThat;
 
 public final class HttpLoggingInterceptorTest {
   private static final MediaType PLAIN = MediaType.parse("text/plain; charset=utf-8");
 
   @Rule public final MockWebServer server = new MockWebServer();
 
+  private SslClient sslClient = SslClient.localhost();
+  private HostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
   private OkHttpClient client;
   private String host;
   private HttpUrl url;
@@ -71,6 +79,8 @@ private void setLevel(Level level) {
     client = new OkHttpClient.Builder()
         .addNetworkInterceptor(networkInterceptor)
         .addInterceptor(applicationInterceptor)
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(hostnameVerifier)
         .build();
 
     host = server.getHostName() + ":" + server.getPort();
@@ -117,7 +127,7 @@ private void setLevel(Level level) {
     client.newCall(request().build()).execute();
 
     applicationLogs
-        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("--> GET " + url)
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms, 0-byte body\\)")
         .assertNoMoreLogs();
 
@@ -134,7 +144,7 @@ private void setLevel(Level level) {
     client.newCall(request().post(RequestBody.create(PLAIN, "Hi?")).build()).execute();
 
     applicationLogs
-        .assertLogEqual("--> POST " + url + " http/1.1 (3-byte body)")
+        .assertLogEqual("--> POST " + url + " (3-byte body)")
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms, 0-byte body\\)")
         .assertNoMoreLogs();
 
@@ -154,7 +164,7 @@ private void setLevel(Level level) {
     response.body().close();
 
     applicationLogs
-        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("--> GET " + url)
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms, 6-byte body\\)")
         .assertNoMoreLogs();
 
@@ -174,7 +184,7 @@ private void setLevel(Level level) {
     response.body().close();
 
     applicationLogs
-        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("--> GET " + url)
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms, unknown-length body\\)")
         .assertNoMoreLogs();
 
@@ -192,7 +202,7 @@ private void setLevel(Level level) {
     response.body().close();
 
     applicationLogs
-        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("--> GET " + url)
         .assertLogEqual("--> END GET")
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
         .assertLogEqual("Content-Length: 0")
@@ -221,7 +231,7 @@ private void setLevel(Level level) {
     response.body().close();
 
     applicationLogs
-        .assertLogEqual("--> POST " + url + " http/1.1")
+        .assertLogEqual("--> POST " + url)
         .assertLogEqual("Content-Type: text/plain; charset=utf-8")
         .assertLogEqual("Content-Length: 3")
         .assertLogEqual("--> END POST")
@@ -254,7 +264,7 @@ private void setLevel(Level level) {
     response.body().close();
 
     applicationLogs
-        .assertLogEqual("--> POST " + url + " http/1.1")
+        .assertLogEqual("--> POST " + url)
         .assertLogEqual("Content-Length: 3")
         .assertLogEqual("--> END POST")
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
@@ -293,7 +303,7 @@ private void setLevel(Level level) {
     response.body().close();
 
     applicationLogs
-        .assertLogEqual("--> POST " + url + " http/1.1")
+        .assertLogEqual("--> POST " + url)
         .assertLogEqual("Content-Type: text/plain; charset=utf-8")
         .assertLogEqual("--> END POST")
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
@@ -326,7 +336,7 @@ private void setLevel(Level level) {
     response.body().close();
 
     applicationLogs
-        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("--> GET " + url)
         .assertLogEqual("--> END GET")
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
         .assertLogEqual("Content-Length: 6")
@@ -356,7 +366,7 @@ private void setLevel(Level level) {
     response.body().close();
 
     applicationLogs
-        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("--> GET " + url)
         .assertLogEqual("--> END GET")
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
         .assertLogEqual("Content-Length: 0")
@@ -393,7 +403,7 @@ private void bodyGetNoBody(int code) throws IOException {
     response.body().close();
 
     applicationLogs
-        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("--> GET " + url)
         .assertLogEqual("--> END GET")
         .assertLogMatch("<-- " + code + " No Content " + url + " \\(\\d+ms\\)")
         .assertLogEqual("Content-Length: 0")
@@ -422,7 +432,7 @@ private void bodyGetNoBody(int code) throws IOException {
     response.body().close();
 
     applicationLogs
-        .assertLogEqual("--> POST " + url + " http/1.1")
+        .assertLogEqual("--> POST " + url)
         .assertLogEqual("Content-Type: text/plain; charset=utf-8")
         .assertLogEqual("Content-Length: 3")
         .assertLogEqual("")
@@ -460,7 +470,7 @@ private void bodyGetNoBody(int code) throws IOException {
     response.body().close();
 
     applicationLogs
-        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("--> GET " + url)
         .assertLogEqual("--> END GET")
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
         .assertLogEqual("Content-Length: 6")
@@ -496,7 +506,7 @@ private void bodyGetNoBody(int code) throws IOException {
     response.body().close();
 
     applicationLogs
-        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("--> GET " + url)
         .assertLogEqual("--> END GET")
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
         .assertLogEqual("Transfer-encoding: chunked")
@@ -548,7 +558,7 @@ private void bodyGetNoBody(int code) throws IOException {
         .assertNoMoreLogs();
 
     applicationLogs
-        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("--> GET " + url)
         .assertLogEqual("--> END GET")
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
         .assertLogEqual("Content-Type: text/plain; charset=utf-8")
@@ -563,7 +573,7 @@ private void bodyGetNoBody(int code) throws IOException {
 
     server.enqueue(new MockResponse()
         .setHeader("Content-Type", "text/html; charset=0")
-        .setBody("Ignore This"));
+        .setBody("Body with unknown charset"));
     Response response = client.newCall(request().build()).execute();
     response.body().close();
 
@@ -578,19 +588,19 @@ private void bodyGetNoBody(int code) throws IOException {
         .assertLogEqual("Content-Type: text/html; charset=0")
         .assertLogMatch("Content-Length: \\d+")
         .assertLogMatch("")
-        .assertLogEqual("Couldn't decode the response body; charset is likely malformed.")
-        .assertLogEqual("<-- END HTTP")
+        .assertLogEqual("Body with unknown charset")
+        .assertLogEqual("<-- END HTTP (25-byte body)")
         .assertNoMoreLogs();
 
     applicationLogs
-        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("--> GET " + url)
         .assertLogEqual("--> END GET")
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
         .assertLogEqual("Content-Type: text/html; charset=0")
         .assertLogMatch("Content-Length: \\d+")
         .assertLogEqual("")
-        .assertLogEqual("Couldn't decode the response body; charset is likely malformed.")
-        .assertLogEqual("<-- END HTTP")
+        .assertLogEqual("Body with unknown charset")
+        .assertLogEqual("<-- END HTTP (25-byte body)")
         .assertNoMoreLogs();
   }
 
@@ -622,7 +632,7 @@ private void bodyGetNoBody(int code) throws IOException {
     response.body().close();
 
     applicationLogs
-        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("--> GET " + url)
         .assertLogEqual("--> END GET")
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
         .assertLogEqual("Content-Length: 9")
@@ -664,11 +674,32 @@ private void bodyGetNoBody(int code) throws IOException {
     }
 
     applicationLogs
-        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("--> GET " + url)
         .assertLogEqual("<-- HTTP FAILED: java.net.UnknownHostException: reason")
         .assertNoMoreLogs();
   }
 
+  @Test public void http2() throws Exception {
+    server.useHttps(sslClient.socketFactory, false);
+    url = server.url("/");
+
+    setLevel(Level.BASIC);
+
+    server.enqueue(new MockResponse());
+    Response response = client.newCall(request().build()).execute();
+    assumeThat(response.protocol(), equalTo(Protocol.HTTP_2));
+
+    applicationLogs
+        .assertLogEqual("--> GET " + url)
+        .assertLogMatch("<-- 200 " + url + " \\(\\d+ms, 0-byte body\\)")
+        .assertNoMoreLogs();
+
+    networkLogs
+        .assertLogEqual("--> GET " + url + " h2")
+        .assertLogMatch("<-- 200 " + url + " \\(\\d+ms, 0-byte body\\)")
+        .assertNoMoreLogs();
+  }
+
   private Request.Builder request() {
     return new Request.Builder().url(url);
   }
diff --git a/okhttp-testing-support/pom.xml b/okhttp-testing-support/pom.xml
index 943f53acb7..3605a66add 100644
--- a/okhttp-testing-support/pom.xml
+++ b/okhttp-testing-support/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.4.0-SNAPSHOT</version>
+    <version>3.10.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-testing-support</artifactId>
@@ -23,5 +23,10 @@
       <artifactId>okhttp</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
   </dependencies>
 </project>
diff --git a/okhttp-testing-support/src/main/java/okhttp3/FakeDns.java b/okhttp-testing-support/src/main/java/okhttp3/FakeDns.java
index f2edc75d66..e12ea9c622 100644
--- a/okhttp-testing-support/src/main/java/okhttp3/FakeDns.java
+++ b/okhttp-testing-support/src/main/java/okhttp3/FakeDns.java
@@ -19,39 +19,61 @@
 import java.net.UnknownHostException;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collections;
+import java.util.LinkedHashMap;
 import java.util.List;
+import java.util.Map;
 
 import static org.junit.Assert.assertEquals;
 
 public final class FakeDns implements Dns {
-  private List<String> requestedHosts = new ArrayList<>();
-  private List<InetAddress> addresses = Collections.emptyList();
+  private final Map<String, List<InetAddress>> hostAddresses = new LinkedHashMap<>();
+  private final List<String> requestedHosts = new ArrayList<>();
+  private int nextAddress = 100;
 
-  /** Sets the addresses to be returned by this fake DNS service. */
-  public FakeDns addresses(List<InetAddress> addresses) {
-    this.addresses = new ArrayList<>(addresses);
+  /** Sets the results for {@code hostname}. */
+  public FakeDns set(String hostname, List<InetAddress> addresses) {
+    hostAddresses.put(hostname, addresses);
     return this;
   }
 
-  /** Sets the service to throw when a hostname is requested. */
-  public FakeDns unknownHost() {
-    this.addresses = Collections.emptyList();
+  /** Clears the results for {@code hostname}. */
+  public FakeDns clear(String hostname) {
+    hostAddresses.remove(hostname);
     return this;
   }
 
-  public InetAddress address(int index) {
-    return addresses.get(index);
+  public InetAddress lookup(String hostname, int index) throws UnknownHostException {
+    return hostAddresses.get(hostname).get(index);
   }
 
   @Override public List<InetAddress> lookup(String hostname) throws UnknownHostException {
     requestedHosts.add(hostname);
-    if (addresses.isEmpty()) throw new UnknownHostException();
-    return addresses;
+
+    List<InetAddress> result = hostAddresses.get(hostname);
+    if (result != null) return result;
+
+    throw new UnknownHostException();
   }
 
   public void assertRequests(String... expectedHosts) {
     assertEquals(Arrays.asList(expectedHosts), requestedHosts);
     requestedHosts.clear();
   }
+
+  /** Allocates and returns {@code count} fake addresses like [255.0.0.100, 255.0.0.101]. */
+  public List<InetAddress> allocate(int count) {
+    try {
+      List<InetAddress> result = new ArrayList<>();
+      for (int i = 0; i < count; i++) {
+        if (nextAddress > 255) {
+          throw new AssertionError("too many addresses allocated");
+        }
+        result.add(InetAddress.getByAddress(
+            new byte[] {(byte) 255, (byte) 0, (byte) 0, (byte) nextAddress++}));
+      }
+      return result;
+    } catch (UnknownHostException e) {
+      throw new AssertionError();
+    }
+  }
 }
diff --git a/okhttp-ws-tests/fuzzingserver-config.json b/okhttp-tests/fuzzingserver-config.json
similarity index 98%
rename from okhttp-ws-tests/fuzzingserver-config.json
rename to okhttp-tests/fuzzingserver-config.json
index 99e06abb51..f9a3e1f597 100644
--- a/okhttp-ws-tests/fuzzingserver-config.json
+++ b/okhttp-tests/fuzzingserver-config.json
@@ -1,5 +1,5 @@
 {
-  "url": "ws://127.0.0.1:9001",
+  "url": "ws://127.0.0.1:9099",
   "outdir": "./target/fuzzingserver-report",
   "cases": ["*"],
   "exclude-cases": [
diff --git a/okhttp-ws-tests/fuzzingserver-expected.txt b/okhttp-tests/fuzzingserver-expected.txt
similarity index 99%
rename from okhttp-ws-tests/fuzzingserver-expected.txt
rename to okhttp-tests/fuzzingserver-expected.txt
index f4a3305f79..f0f6ed0bbd 100644
--- a/okhttp-ws-tests/fuzzingserver-expected.txt
+++ b/okhttp-tests/fuzzingserver-expected.txt
@@ -257,7 +257,7 @@
 "4.2.1 OK"
 "4.2.2 OK"
 "4.2.3 NON-STRICT"
-"4.2.4 NON-STRICT"
+"4.2.4 OK"
 "4.2.5 OK"
 "5.1 OK"
 "5.10 OK"
@@ -265,7 +265,7 @@
 "5.12 OK"
 "5.13 OK"
 "5.14 OK"
-"5.15 NON-STRICT"
+"5.15 OK"
 "5.16 OK"
 "5.17 OK"
 "5.18 OK"
@@ -283,7 +283,7 @@
 "7.1.2 OK"
 "7.1.3 OK"
 "7.1.4 OK"
-"7.1.5 FAILED"
+"7.1.5 OK"
 "7.1.6 INFORMATIONAL"
 "7.13.1 INFORMATIONAL"
 "7.13.2 INFORMATIONAL"
diff --git a/okhttp-ws-tests/fuzzingserver-test.sh b/okhttp-tests/fuzzingserver-test.sh
similarity index 90%
rename from okhttp-ws-tests/fuzzingserver-test.sh
rename to okhttp-tests/fuzzingserver-test.sh
index af89a42422..78ad71f59e 100755
--- a/okhttp-ws-tests/fuzzingserver-test.sh
+++ b/okhttp-tests/fuzzingserver-test.sh
@@ -21,7 +21,7 @@ set -ex
 wstest -m fuzzingserver -s fuzzingserver-config.json &
 sleep 2 # wait for wstest to start
 
-java -jar target/okhttp-ws-tests-*-jar-with-dependencies.jar
+java -jar target/okhttp-tests-*-jar-with-dependencies.jar
 
 jq '.[] as $in | $in | keys[] | . + " " + $in[.].behavior' target/fuzzingserver-report/index.json > target/fuzzingserver-actual.txt
 
diff --git a/okhttp-ws-tests/fuzzingserver-update-expected.sh b/okhttp-tests/fuzzingserver-update-expected.sh
similarity index 100%
rename from okhttp-ws-tests/fuzzingserver-update-expected.sh
rename to okhttp-tests/fuzzingserver-update-expected.sh
diff --git a/okhttp-tests/pom.xml b/okhttp-tests/pom.xml
index 5585632fc2..6959cd9a07 100644
--- a/okhttp-tests/pom.xml
+++ b/okhttp-tests/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.4.0-SNAPSHOT</version>
+    <version>3.10.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-tests</artifactId>
@@ -17,6 +17,11 @@
       <groupId>com.squareup.okio</groupId>
       <artifactId>okio</artifactId>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
     <dependency>
       <groupId>${project.groupId}</groupId>
       <artifactId>okhttp</artifactId>
@@ -49,6 +54,28 @@
 
   <build>
     <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-assembly-plugin</artifactId>
+        <configuration>
+          <descriptorRefs>
+            <descriptorRef>jar-with-dependencies</descriptorRef>
+          </descriptorRefs>
+          <archive>
+            <manifest>
+              <mainClass>okhttp3.AutobahnTester</mainClass>
+            </manifest>
+          </archive>
+        </configuration>
+        <executions>
+          <execution>
+            <phase>package</phase>
+            <goals>
+              <goal>single</goal>
+            </goals>
+          </execution>
+        </executions>
+      </plugin>
       <!-- Do not deploy this as an artifact to Maven central. -->
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
diff --git a/okhttp-tests/src/main/java/okhttp3/AutobahnTester.java b/okhttp-tests/src/main/java/okhttp3/AutobahnTester.java
new file mode 100644
index 0000000000..ab7b9c771d
--- /dev/null
+++ b/okhttp-tests/src/main/java/okhttp3/AutobahnTester.java
@@ -0,0 +1,152 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.concurrent.atomic.AtomicReference;
+import okhttp3.internal.Version;
+import okio.ByteString;
+
+/**
+ * Exercises the web socket implementation against the <a
+ * href="http://autobahn.ws/testsuite/">Autobahn Testsuite</a>.
+ */
+public final class AutobahnTester {
+  private static final String HOST = "ws://localhost:9099";
+
+  public static void main(String... args) throws IOException {
+    new AutobahnTester().run();
+  }
+
+  final OkHttpClient client = new OkHttpClient();
+
+  private WebSocket newWebSocket(String path, WebSocketListener listener) {
+    Request request = new Request.Builder().url(HOST + path).build();
+    return client.newWebSocket(request, listener);
+  }
+
+  public void run() throws IOException {
+    try {
+      long count = getTestCount();
+      System.out.println("Test count: " + count);
+
+      for (long number = 1; number <= count; number++) {
+        runTest(number, count);
+      }
+
+      updateReports();
+    } finally {
+      client.dispatcher().executorService().shutdown();
+    }
+  }
+
+  private void runTest(final long number, final long count) {
+    final CountDownLatch latch = new CountDownLatch(1);
+    final AtomicLong startNanos = new AtomicLong();
+    newWebSocket("/runCase?case=" + number + "&agent=okhttp", new WebSocketListener() {
+      @Override public void onOpen(WebSocket webSocket, Response response) {
+        System.out.println("Executing test case " + number + "/" + count);
+        startNanos.set(System.nanoTime());
+      }
+
+      @Override public void onMessage(final WebSocket webSocket, final ByteString bytes) {
+        webSocket.send(bytes);
+      }
+
+      @Override public void onMessage(final WebSocket webSocket, final String text) {
+        webSocket.send(text);
+      }
+
+      @Override public void onClosing(WebSocket webSocket, int code, String reason) {
+        webSocket.close(1000, null);
+        latch.countDown();
+      }
+
+      @Override public void onFailure(WebSocket webSocket, Throwable t, Response response) {
+        t.printStackTrace(System.out);
+        latch.countDown();
+      }
+    });
+    try {
+      if (!latch.await(30, TimeUnit.SECONDS)) {
+        throw new IllegalStateException("Timed out waiting for test " + number + " to finish.");
+      }
+    } catch (InterruptedException e) {
+      throw new AssertionError();
+    }
+
+    long endNanos = System.nanoTime();
+    long tookMs = TimeUnit.NANOSECONDS.toMillis(endNanos - startNanos.get());
+    System.out.println("Took " + tookMs + "ms");
+  }
+
+  private long getTestCount() throws IOException {
+    final CountDownLatch latch = new CountDownLatch(1);
+    final AtomicLong countRef = new AtomicLong();
+    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+    newWebSocket("/getCaseCount", new WebSocketListener() {
+      @Override public void onMessage(WebSocket webSocket, String text) {
+        countRef.set(Long.parseLong(text));
+      }
+
+      @Override public void onClosing(WebSocket webSocket, int code, String reason) {
+        webSocket.close(1000, null);
+        latch.countDown();
+      }
+
+      @Override public void onFailure(WebSocket webSocket, Throwable t, Response response) {
+        failureRef.set(t);
+        latch.countDown();
+      }
+    });
+    try {
+      if (!latch.await(10, TimeUnit.SECONDS)) {
+        throw new IllegalStateException("Timed out waiting for count.");
+      }
+    } catch (InterruptedException e) {
+      throw new AssertionError();
+    }
+    Throwable failure = failureRef.get();
+    if (failure != null) {
+      throw new RuntimeException(failure);
+    }
+    return countRef.get();
+  }
+
+  private void updateReports() {
+    final CountDownLatch latch = new CountDownLatch(1);
+    newWebSocket("/updateReports?agent=" + Version.userAgent(), new WebSocketListener() {
+      @Override public void onClosing(WebSocket webSocket, int code, String reason) {
+        webSocket.close(1000, null);
+        latch.countDown();
+      }
+
+      @Override public void onFailure(WebSocket webSocket, Throwable t, Response response) {
+        latch.countDown();
+      }
+    });
+    try {
+      if (!latch.await(10, TimeUnit.SECONDS)) {
+        throw new IllegalStateException("Timed out waiting for count.");
+      }
+    } catch (InterruptedException e) {
+      throw new AssertionError();
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/AddressTest.java b/okhttp-tests/src/test/java/okhttp3/AddressTest.java
index 30e376be5b..ad07b78241 100644
--- a/okhttp-tests/src/test/java/okhttp3/AddressTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/AddressTest.java
@@ -15,6 +15,7 @@
  */
 package okhttp3;
 
+import java.net.Proxy;
 import java.util.List;
 import javax.net.SocketFactory;
 import okhttp3.internal.Util;
@@ -48,4 +49,17 @@
         authenticator, null, protocols, connectionSpecs, new RecordingProxySelector());
     assertFalse(a.equals(b));
   }
+
+  @Test public void addressToString() throws Exception {
+    Address address = new Address("square.com", 80, dns, socketFactory, null, null, null,
+        authenticator, null, protocols, connectionSpecs, proxySelector);
+    assertEquals("Address{square.com:80, proxySelector=RecordingProxySelector}",
+        address.toString());
+  }
+
+  @Test public void addressWithProxyToString() throws Exception {
+    Address address = new Address("square.com", 80, dns, socketFactory, null, null, null,
+        authenticator, Proxy.NO_PROXY, protocols, connectionSpecs, proxySelector);
+    assertEquals("Address{square.com:80, proxy=" + Proxy.NO_PROXY + "}", address.toString());
+  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/CacheControlTest.java b/okhttp-tests/src/test/java/okhttp3/CacheControlTest.java
index ef15052a93..356f96ab46 100644
--- a/okhttp-tests/src/test/java/okhttp3/CacheControlTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CacheControlTest.java
@@ -51,15 +51,18 @@
         .minFresh(3, TimeUnit.SECONDS)
         .onlyIfCached()
         .noTransform()
+        .immutable()
         .build();
     assertEquals("no-cache, no-store, max-age=1, max-stale=2, min-fresh=3, only-if-cached, "
-        + "no-transform", cacheControl.toString());
+        + "no-transform, immutable", cacheControl.toString());
     assertTrue(cacheControl.noCache());
     assertTrue(cacheControl.noStore());
     assertEquals(1, cacheControl.maxAgeSeconds());
     assertEquals(2, cacheControl.maxStaleSeconds());
     assertEquals(3, cacheControl.minFreshSeconds());
     assertTrue(cacheControl.onlyIfCached());
+    assertTrue(cacheControl.noTransform());
+    assertTrue(cacheControl.immutable());
 
     // These members are accessible to response headers only.
     assertEquals(-1, cacheControl.sMaxAgeSeconds());
@@ -121,6 +124,7 @@
     assertEquals(-1, cacheControl.minFreshSeconds());
     assertFalse(cacheControl.onlyIfCached());
     assertFalse(cacheControl.noTransform());
+    assertFalse(cacheControl.immutable());
     assertEquals(header, cacheControl.toString());
   }
 
diff --git a/okhttp-tests/src/test/java/okhttp3/CacheTest.java b/okhttp-tests/src/test/java/okhttp3/CacheTest.java
index da64492d1a..83ce5c8b22 100644
--- a/okhttp-tests/src/test/java/okhttp3/CacheTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CacheTest.java
@@ -19,15 +19,12 @@
 import java.io.File;
 import java.io.IOException;
 import java.net.CookieManager;
-import java.net.HttpCookie;
 import java.net.HttpURLConnection;
 import java.net.ResponseCache;
 import java.security.Principal;
 import java.security.cert.Certificate;
 import java.text.DateFormat;
 import java.text.SimpleDateFormat;
-import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Date;
 import java.util.Iterator;
 import java.util.List;
@@ -39,8 +36,8 @@
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLSession;
 import okhttp3.internal.Internal;
-import okhttp3.internal.Util;
 import okhttp3.internal.io.InMemoryFileSystem;
+import okhttp3.internal.platform.Platform;
 import okhttp3.internal.tls.SslClient;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
@@ -55,6 +52,7 @@
 import org.junit.Rule;
 import org.junit.Test;
 
+import static okhttp3.TestUtil.defaultClient;
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
@@ -82,7 +80,7 @@
   @Before public void setUp() throws Exception {
     server.setProtocolNegotiationEnabled(false);
     cache = new Cache(new File("/cache/"), Integer.MAX_VALUE, fileSystem);
-    client = new OkHttpClient.Builder()
+    client = defaultClient().newBuilder()
         .cache(cache)
         .cookieJar(new JavaNetCookieJar(cookieManager))
         .build();
@@ -747,8 +745,8 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
   }
 
   private void testRequestMethod(String requestMethod, boolean expectCached) throws Exception {
-    // 1. seed the cache (potentially)
-    // 2. expect a cache hit or miss
+    // 1. Seed the cache (potentially).
+    // 2. Expect a cache hit or miss.
     server.enqueue(new MockResponse()
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .addHeader("X-Response-ID: 1"));
@@ -793,9 +791,9 @@ private RequestBody requestBodyOrNull(String requestMethod) {
   }
 
   private void testMethodInvalidates(String requestMethod) throws Exception {
-    // 1. seed the cache
-    // 2. invalidate it
-    // 3. expect a cache miss
+    // 1. Seed the cache.
+    // 2. Invalidate it.
+    // 3. Expect a cache miss.
     server.enqueue(new MockResponse()
         .setBody("A")
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
@@ -819,9 +817,9 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
   }
 
   @Test public void postInvalidatesCacheWithUncacheableResponse() throws Exception {
-    // 1. seed the cache
-    // 2. invalidate it with uncacheable response
-    // 3. expect a cache miss
+    // 1. Seed the cache.
+    // 2. Invalidate it with an uncacheable response.
+    // 3. Expect a cache miss.
     server.enqueue(new MockResponse()
         .setBody("A")
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
@@ -845,6 +843,33 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
     assertEquals("C", get(url).body().string());
   }
 
+  @Test public void putInvalidatesWithNoContentResponse() throws Exception {
+    // 1. Seed the cache.
+    // 2. Invalidate it.
+    // 3. Expect a cache miss.
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
+    server.enqueue(new MockResponse()
+        .clearHeaders()
+        .setResponseCode(HttpURLConnection.HTTP_NO_CONTENT));
+    server.enqueue(new MockResponse()
+        .setBody("C"));
+
+    HttpUrl url = server.url("/");
+
+    assertEquals("A", get(url).body().string());
+
+    Request request = new Request.Builder()
+        .url(url)
+        .put(RequestBody.create(MediaType.parse("text/plain"), "foo"))
+        .build();
+    Response invalidate = client.newCall(request).execute();
+    assertEquals("", invalidate.body().string());
+
+    assertEquals("C", get(url).body().string());
+  }
+
   @Test public void etag() throws Exception {
     RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
         .addHeader("ETag: v1"));
@@ -910,8 +935,8 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
   }
 
   @Test public void partialRangeResponsesDoNotCorruptCache() throws Exception {
-    // 1. request a range
-    // 2. request a full document, expecting a cache miss
+    // 1. Request a range.
+    // 2. Request a full document, expecting a cache miss.
     server.enqueue(new MockResponse()
         .setBody("AA")
         .setResponseCode(HttpURLConnection.HTTP_PARTIAL)
@@ -932,6 +957,13 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
     assertEquals("BB", get(url).body().string());
   }
 
+  /**
+   * When the server returns a full response body we will store it and return it regardless of what
+   * its Last-Modified date is. This behavior was different prior to OkHttp 3.5 when we would prefer
+   * the response with the later Last-Modified date.
+   *
+   * https://github.com/square/okhttp/issues/2886
+   */
   @Test public void serverReturnsDocumentOlderThanCache() throws Exception {
     server.enqueue(new MockResponse()
         .setBody("A")
@@ -940,11 +972,14 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
     server.enqueue(new MockResponse()
         .setBody("B")
         .addHeader("Last-Modified: " + formatDate(-4, TimeUnit.HOURS)));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
     HttpUrl url = server.url("/");
 
     assertEquals("A", get(url).body().string());
-    assertEquals("A", get(url).body().string());
+    assertEquals("B", get(url).body().string());
+    assertEquals("B", get(url).body().string());
   }
 
   @Test public void clientSideNoStore() throws Exception {
@@ -998,6 +1033,43 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     assertEquals("ABCABCABC", get(server.url("/")).body().string());
   }
 
+  @Test public void previouslyNotGzippedContentIsNotModifiedAndSpecifiesGzipEncoding() throws Exception {
+    server.enqueue(new MockResponse()
+            .setBody("ABCABCABC")
+            .addHeader("Content-Type: text/plain")
+            .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
+            .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
+    server.enqueue(new MockResponse()
+            .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED)
+            .addHeader("Content-Type: text/plain")
+            .addHeader("Content-Encoding: gzip"));
+    server.enqueue(new MockResponse()
+            .setBody("DEFDEFDEF"));
+
+    assertEquals("ABCABCABC", get(server.url("/")).body().string());
+    assertEquals("ABCABCABC", get(server.url("/")).body().string());
+    assertEquals("DEFDEFDEF", get(server.url("/")).body().string());
+  }
+
+  @Test public void changedGzippedContentIsNotModifiedAndSpecifiesNewEncoding() throws Exception {
+    server.enqueue(new MockResponse()
+            .setBody(gzip("ABCABCABC"))
+            .addHeader("Content-Type: text/plain")
+            .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
+            .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS))
+            .addHeader("Content-Encoding: gzip"));
+    server.enqueue(new MockResponse()
+            .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED)
+            .addHeader("Content-Type: text/plain")
+            .addHeader("Content-Encoding: identity"));
+    server.enqueue(new MockResponse()
+            .setBody("DEFDEFDEF"));
+
+    assertEquals("ABCABCABC", get(server.url("/")).body().string());
+    assertEquals("ABCABCABC", get(server.url("/")).body().string());
+    assertEquals("DEFDEFDEF", get(server.url("/")).body().string());
+  }
+
   @Test public void notModifiedSpecifiesEncoding() throws Exception {
     server.enqueue(new MockResponse()
         .setBody(gzip("ABCABCABC"))
@@ -1030,6 +1102,10 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
   }
 
   @Test public void conditionalCacheHitIsNotDoublePooled() throws Exception {
+    // Ensure that the (shared) connection pool is in a consistent state.
+    client.connectionPool().evictAll();
+    assertEquals(0, client.connectionPool().idleConnectionCount());
+
     server.enqueue(new MockResponse()
         .addHeader("ETag: v1")
         .setBody("A"));
@@ -1805,14 +1881,6 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     assertEquals("299 test danger", response2.header("Warning"));
   }
 
-  public void assertCookies(HttpUrl url, String... expectedCookies) throws Exception {
-    List<String> actualCookies = new ArrayList<>();
-    for (HttpCookie cookie : cookieManager.getCookieStore().get(url.uri())) {
-      actualCookies.add(cookie.toString());
-    }
-    assertEquals(Arrays.asList(expectedCookies), actualCookies);
-  }
-
   @Test public void doNotCachePartialResponse() throws Exception {
     assertNotCached(new MockResponse()
         .setResponseCode(HttpURLConnection.HTTP_PARTIAL)
@@ -1833,21 +1901,29 @@ public void assertCookies(HttpUrl url, String... expectedCookies) throws Excepti
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    // cache miss; seed the cache
+    // A cache miss writes the cache.
+    long t0 = System.currentTimeMillis();
     Response response1 = get(server.url("/a"));
     assertEquals("A", response1.body().string());
     assertEquals(null, response1.header("Allow"));
+    assertEquals(0, response1.receivedResponseAtMillis() - t0, 250.0);
 
-    // conditional cache hit; update the cache
+    // A conditional cache hit updates the cache.
+    Thread.sleep(500); // Make sure t0 and t1 are distinct.
+    long t1 = System.currentTimeMillis();
     Response response2 = get(server.url("/a"));
     assertEquals(HttpURLConnection.HTTP_OK, response2.code());
     assertEquals("A", response2.body().string());
     assertEquals("GET, HEAD", response2.header("Allow"));
+    assertEquals(0, response2.receivedResponseAtMillis() - t1, 250.0);
 
-    // full cache hit
+    // A full cache hit reads the cache.
+    Thread.sleep(500); // Make sure t1 and t2 are distinct.
+    long t2 = System.currentTimeMillis();
     Response response3 = get(server.url("/a"));
     assertEquals("A", response3.body().string());
     assertEquals("GET, HEAD", response3.header("Allow"));
+    assertEquals(0, response3.receivedResponseAtMillis() - t1, 250.0);
 
     assertEquals(2, server.getRequestCount());
   }
@@ -1929,7 +2005,7 @@ public void assertCookies(HttpUrl url, String... expectedCookies) throws Excepti
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
     HttpUrl url = server.url("/");
-    String urlKey = Util.md5Hex(url.toString());
+    String urlKey = Cache.key(url);
     String entryMetadata = ""
         + "" + url + "\n"
         + "GET\n"
@@ -1979,7 +2055,8 @@ public void assertCookies(HttpUrl url, String... expectedCookies) throws Excepti
   /** Exercise the cache format in OkHttp 2.7 and all earlier releases. */
   @Test public void testGoldenCacheHttpsResponseOkHttp27() throws Exception {
     HttpUrl url = server.url("/");
-    String urlKey = Util.md5Hex(url.toString());
+    String urlKey = Cache.key(url);
+    String prefix = Platform.get().getPrefix();
     String entryMetadata = ""
         + "" + url + "\n"
         + "GET\n"
@@ -1987,8 +2064,8 @@ public void assertCookies(HttpUrl url, String... expectedCookies) throws Excepti
         + "HTTP/1.1 200 OK\n"
         + "4\n"
         + "Content-Length: 3\n"
-        + "OkHttp-Received-Millis: " + System.currentTimeMillis() + "\n"
-        + "OkHttp-Sent-Millis: " + System.currentTimeMillis() + "\n"
+        + prefix + "-Received-Millis: " + System.currentTimeMillis() + "\n"
+        + prefix + "-Sent-Millis: " + System.currentTimeMillis() + "\n"
         + "Cache-Control: max-age=60\n"
         + "\n"
         + "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\n"
@@ -2027,7 +2104,8 @@ public void assertCookies(HttpUrl url, String... expectedCookies) throws Excepti
   /** The TLS version is present in OkHttp 3.0 and beyond. */
   @Test public void testGoldenCacheHttpsResponseOkHttp30() throws Exception {
     HttpUrl url = server.url("/");
-    String urlKey = Util.md5Hex(url.toString());
+    String urlKey = Cache.key(url);
+    String prefix = Platform.get().getPrefix();
     String entryMetadata = ""
         + "" + url + "\n"
         + "GET\n"
@@ -2035,8 +2113,8 @@ public void assertCookies(HttpUrl url, String... expectedCookies) throws Excepti
         + "HTTP/1.1 200 OK\n"
         + "4\n"
         + "Content-Length: 3\n"
-        + "OkHttp-Received-Millis: " + System.currentTimeMillis() + "\n"
-        + "OkHttp-Sent-Millis: " + System.currentTimeMillis() + "\n"
+        + prefix + "-Received-Millis: " + System.currentTimeMillis() + "\n"
+        + prefix + "-Sent-Millis: " + System.currentTimeMillis() + "\n"
         + "Cache-Control: max-age=60\n"
         + "\n"
         + "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\n"
@@ -2075,7 +2153,8 @@ public void assertCookies(HttpUrl url, String... expectedCookies) throws Excepti
 
   @Test public void testGoldenCacheHttpResponseOkHttp30() throws Exception {
     HttpUrl url = server.url("/");
-    String urlKey = Util.md5Hex(url.toString());
+    String urlKey = Cache.key(url);
+    String prefix = Platform.get().getPrefix();
     String entryMetadata = ""
         + "" + url + "\n"
         + "GET\n"
@@ -2084,8 +2163,8 @@ public void assertCookies(HttpUrl url, String... expectedCookies) throws Excepti
         + "4\n"
         + "Cache-Control: max-age=60\n"
         + "Content-Length: 3\n"
-        + "OkHttp-Received-Millis: " + System.currentTimeMillis() + "\n"
-        + "OkHttp-Sent-Millis: " + System.currentTimeMillis() + "\n";
+        + prefix + "-Received-Millis: " + System.currentTimeMillis() + "\n"
+        + prefix + "-Sent-Millis: " + System.currentTimeMillis() + "\n";
     String entryBody = "abc";
     String journalBody = ""
         + "libcore.io.DiskLruCache\n"
@@ -2344,6 +2423,25 @@ public void assertCookies(HttpUrl url, String... expectedCookies) throws Excepti
     assertEquals("Delta", response2.header("Δ"));
     assertEquals("abcd", response2.body().string());
   }
+
+  @Test public void etagConditionCanBeNonAscii() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeaderLenient("Etag", "α")
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("abcd"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    Response response1 = get(server.url("/"));
+    assertEquals("abcd", response1.body().string());
+
+    Response response2 = get(server.url("/"));
+    assertEquals("abcd", response2.body().string());
+
+    assertEquals(null, server.takeRequest().getHeader("If-None-Match"));
+    assertEquals("α", server.takeRequest().getHeader("If-None-Match"));
+  }
+
   private Response get(HttpUrl url) throws IOException {
     Request request = new Request.Builder()
         .url(url)
@@ -2419,6 +2517,33 @@ private RecordedRequest assertConditionallyCached(MockResponse response) throws
     return server.takeRequest(); // conditional get
   }
 
+  @Test public void immutableIsCached() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control", "immutable")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    HttpUrl url = server.url("/");
+    assertEquals("A", get(url).body().string());
+    assertEquals("A", get(url).body().string());
+  }
+
+  @Test public void immutableIsCachedAfterMultipleCalls() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control", "immutable")
+        .setBody("B"));
+    server.enqueue(new MockResponse()
+        .setBody("C"));
+
+    HttpUrl url = server.url("/");
+    assertEquals("A", get(url).body().string());
+    assertEquals("B", get(url).body().string());
+    assertEquals("B", get(url).body().string());
+  }
+
   private void assertFullyCached(MockResponse response) throws Exception {
     server.enqueue(response.setBody("A"));
     server.enqueue(response.setBody("B"));
diff --git a/okhttp-tests/src/test/java/okhttp3/CallTest.java b/okhttp-tests/src/test/java/okhttp3/CallTest.java
index c2470c920b..d10527018d 100644
--- a/okhttp-tests/src/test/java/okhttp3/CallTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CallTest.java
@@ -23,10 +23,8 @@
 import java.net.HttpCookie;
 import java.net.HttpURLConnection;
 import java.net.InetAddress;
-import java.net.InetSocketAddress;
 import java.net.ProtocolException;
 import java.net.Proxy;
-import java.net.ServerSocket;
 import java.net.SocketTimeoutException;
 import java.net.UnknownHostException;
 import java.net.UnknownServiceException;
@@ -34,7 +32,9 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
+import java.util.LinkedHashSet;
 import java.util.List;
+import java.util.Set;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.Callable;
 import java.util.concurrent.CountDownLatch;
@@ -45,8 +45,9 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicReference;
+import java.util.logging.Level;
 import java.util.logging.Logger;
-import javax.net.ServerSocketFactory;
+import java.util.logging.SimpleFormatter;
 import javax.net.ssl.SSLHandshakeException;
 import javax.net.ssl.SSLPeerUnverifiedException;
 import javax.net.ssl.SSLProtocolException;
@@ -59,6 +60,7 @@
 import okhttp3.internal.Version;
 import okhttp3.internal.http.RecordingProxySelector;
 import okhttp3.internal.io.InMemoryFileSystem;
+import okhttp3.internal.tls.HeldCertificate;
 import okhttp3.internal.tls.SslClient;
 import okhttp3.mockwebserver.Dispatcher;
 import okhttp3.mockwebserver.MockResponse;
@@ -79,7 +81,9 @@
 import org.junit.rules.Timeout;
 
 import static java.net.CookiePolicy.ACCEPT_ORIGINAL_SERVER;
+import static okhttp3.TestUtil.awaitGarbageCollection;
 import static okhttp3.TestUtil.defaultClient;
+import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotSame;
@@ -88,7 +92,7 @@
 import static org.junit.Assert.fail;
 
 public final class CallTest {
-  @Rule public final TestRule timeout = new Timeout(30_000);
+  @Rule public final TestRule timeout = new Timeout(30_000, TimeUnit.MILLISECONDS);
   @Rule public final MockWebServer server = new MockWebServer();
   @Rule public final MockWebServer server2 = new MockWebServer();
   @Rule public final InMemoryFileSystem fileSystem = new InMemoryFileSystem();
@@ -98,7 +102,7 @@
   private RecordingCallback callback = new RecordingCallback();
   private TestLogHandler logHandler = new TestLogHandler();
   private Cache cache = new Cache(new File("/cache/"), Integer.MAX_VALUE, fileSystem);
-  private ServerSocket nullServer;
+  private NullServer nullServer = new NullServer();
   private Logger logger = Logger.getLogger(OkHttpClient.class.getName());
 
   @Before public void setUp() throws Exception {
@@ -107,7 +111,7 @@
 
   @After public void tearDown() throws Exception {
     cache.delete();
-    Util.closeQuietly(nullServer);
+    nullServer.shutdown();
     logger.removeHandler(logHandler);
   }
 
@@ -181,11 +185,6 @@
     get();
   }
 
-  @Test public void get_SPDY_3() throws Exception {
-    enableProtocol(Protocol.SPDY_3);
-    get();
-  }
-
   @Test public void repeatedHeaderNames() throws Exception {
     server.enqueue(new MockResponse()
         .addHeader("B", "123")
@@ -199,11 +198,6 @@
     assertEquals(Arrays.asList("345", "456"), recordedRequest.getHeaders().values("A"));
   }
 
-  @Test public void repeatedHeaderNames_SPDY_3() throws Exception {
-    enableProtocol(Protocol.SPDY_3);
-    repeatedHeaderNames();
-  }
-
   @Test public void repeatedHeaderNames_HTTP_2() throws Exception {
     enableProtocol(Protocol.HTTP_2);
     repeatedHeaderNames();
@@ -239,6 +233,59 @@
     assertNull(recordedRequest.getHeader("Content-Length"));
   }
 
+  @Test public void headResponseContentLengthIsIgnored() throws Exception {
+    server.enqueue(new MockResponse()
+        .clearHeaders()
+        .addHeader("Content-Length", "100"));
+    server.enqueue(new MockResponse()
+        .setBody("abc"));
+
+    Request headRequest = new Request.Builder()
+        .url(server.url("/"))
+        .head()
+        .build();
+    Response response = client.newCall(headRequest).execute();
+    assertEquals(200, response.code());
+    assertArrayEquals(new byte[0], response.body().bytes());
+
+    Request getRequest = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    executeSynchronously(getRequest)
+        .assertCode(200)
+        .assertBody("abc");
+
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void headResponseContentEncodingIsIgnored() throws Exception {
+    server.enqueue(new MockResponse()
+        .clearHeaders()
+        .addHeader("Content-Encoding", "chunked"));
+    server.enqueue(new MockResponse()
+        .setBody("abc"));
+
+    Request headRequest = new Request.Builder()
+        .url(server.url("/"))
+        .head()
+        .build();
+    executeSynchronously(headRequest)
+        .assertCode(200)
+        .assertHeader("Content-Encoding", "chunked")
+        .assertBody("");
+
+    Request getRequest = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    executeSynchronously(getRequest)
+        .assertCode(200)
+        .assertBody("abc");
+
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+  }
+
   @Test public void head_HTTPS() throws Exception {
     enableTls();
     head();
@@ -249,11 +296,6 @@
     head();
   }
 
-  @Test public void head_SPDY_3() throws Exception {
-    enableProtocol(Protocol.SPDY_3);
-    head();
-  }
-
   @Test public void post() throws Exception {
     server.enqueue(new MockResponse().setBody("abc"));
 
@@ -283,11 +325,6 @@
     post();
   }
 
-  @Test public void post_SPDY_3() throws Exception {
-    enableProtocol(Protocol.SPDY_3);
-    post();
-  }
-
   @Test public void postZeroLength() throws Exception {
     server.enqueue(new MockResponse().setBody("abc"));
 
@@ -317,11 +354,6 @@
     postZeroLength();
   }
 
-  @Test public void postZeroLength_SPDY_3() throws Exception {
-    enableProtocol(Protocol.SPDY_3);
-    postZeroLength();
-  }
-
   @Test public void postBodyRetransmittedAfterAuthorizationFail() throws Exception {
     postBodyRetransmittedAfterAuthorizationFail("abc");
   }
@@ -336,11 +368,6 @@
     postBodyRetransmittedAfterAuthorizationFail("abc");
   }
 
-  @Test public void postBodyRetransmittedAfterAuthorizationFail_SPDY_3() throws Exception {
-    enableProtocol(Protocol.SPDY_3);
-    postBodyRetransmittedAfterAuthorizationFail("abc");
-  }
-
   /** Don't explode when resending an empty post. https://github.com/square/okhttp/issues/1131 */
   @Test public void postEmptyBodyRetransmittedAfterAuthorizationFail() throws Exception {
     postBodyRetransmittedAfterAuthorizationFail("");
@@ -356,11 +383,6 @@
     postBodyRetransmittedAfterAuthorizationFail("");
   }
 
-  @Test public void postEmptyBodyRetransmittedAfterAuthorizationFail_SPDY_3() throws Exception {
-    enableProtocol(Protocol.SPDY_3);
-    postBodyRetransmittedAfterAuthorizationFail("");
-  }
-
   private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exception {
     server.enqueue(new MockResponse().setResponseCode(401));
     server.enqueue(new MockResponse());
@@ -377,6 +399,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     Response response = client.newCall(request).execute();
     assertEquals(200, response.code());
+    response.body().close();
 
     RecordedRequest recordedRequest1 = server.takeRequest();
     assertEquals("POST", recordedRequest1.getMethod());
@@ -452,11 +475,6 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     delete();
   }
 
-  @Test public void delete_SPDY_3() throws Exception {
-    enableProtocol(Protocol.SPDY_3);
-    delete();
-  }
-
   @Test public void deleteWithRequestBody() throws Exception {
     server.enqueue(new MockResponse().setBody("abc"));
 
@@ -503,11 +521,6 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     put();
   }
 
-  @Test public void put_SPDY_3() throws Exception {
-    enableProtocol(Protocol.SPDY_3);
-    put();
-  }
-
   @Test public void patch() throws Exception {
     server.enqueue(new MockResponse().setBody("abc"));
 
@@ -537,9 +550,23 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     patch();
   }
 
-  @Test public void patch_SPDY_3() throws Exception {
-    enableProtocol(Protocol.SPDY_3);
-    patch();
+  @Test public void customMethodWithBody() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .method("CUSTOM", RequestBody.create(MediaType.parse("text/plain"), "def"))
+        .build();
+
+    executeSynchronously(request)
+        .assertCode(200)
+        .assertBody("abc");
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("CUSTOM", recordedRequest.getMethod());
+    assertEquals("def", recordedRequest.getBody().readUtf8());
+    assertEquals("3", recordedRequest.getHeader("Content-Length"));
+    assertEquals("text/plain; charset=utf-8", recordedRequest.getHeader("Content-Type"));
   }
 
   @Test public void unspecifiedRequestBodyContentTypeDoesNotGetDefault() throws Exception {
@@ -619,6 +646,49 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     assertEquals("SyncApiTest", server.takeRequest().getHeader("User-Agent"));
   }
 
+  @Test public void legalToExecuteTwiceCloning() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.enqueue(new MockResponse().setBody("def"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    Call call = client.newCall(request);
+    Response response1 = call.execute();
+
+    Call cloned = call.clone();
+    Response response2 = cloned.execute();
+
+    assertEquals(response1.body().string(), "abc");
+    assertEquals(response2.body().string(), "def");
+  }
+
+  @Test public void legalToExecuteTwiceCloning_Async() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.enqueue(new MockResponse().setBody("def"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    Call call = client.newCall(request);
+    call.enqueue(callback);
+
+    Call cloned = call.clone();
+    cloned.enqueue(callback);
+
+    RecordedResponse firstResponse = callback.await(request.url()).assertSuccessful();
+    RecordedResponse secondResponse = callback.await(request.url()).assertSuccessful();
+
+    Set<String> bodies = new LinkedHashSet<>();
+    bodies.add(firstResponse.getBody());
+    bodies.add(secondResponse.getBody());
+
+    assertTrue(bodies.contains("abc"));
+    assertTrue(bodies.contains("def"));
+  }
+
   @Test public void get_Async() throws Exception {
     server.enqueue(new MockResponse()
         .setBody("abc")
@@ -778,10 +848,8 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
    * special address that never connects. The automatic retry will succeed.
    */
   @Test public void connectTimeoutsAttemptsAlternateRoute() throws Exception {
-    InetSocketAddress unreachableAddress = new InetSocketAddress("10.255.255.1", 8080);
-
     RecordingProxySelector proxySelector = new RecordingProxySelector();
-    proxySelector.proxies.add(new Proxy(Proxy.Type.HTTP, unreachableAddress));
+    proxySelector.proxies.add(new Proxy(Proxy.Type.HTTP, TestUtil.UNREACHABLE_ADDRESS));
     proxySelector.proxies.add(server.toProxyAddress());
 
     server.enqueue(new MockResponse()
@@ -804,10 +872,10 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
    * never responds. The manual retry will succeed.
    */
   @Test public void readTimeoutFails() throws Exception {
-    InetSocketAddress nullServerAddress = startNullServer();
+    nullServer.start();
 
     RecordingProxySelector proxySelector = new RecordingProxySelector();
-    proxySelector.proxies.add(new Proxy(Proxy.Type.HTTP, nullServerAddress));
+    proxySelector.proxies.add(new Proxy(Proxy.Type.HTTP, nullServer.address()));
     proxySelector.proxies.add(server.toProxyAddress());
 
     server.enqueue(new MockResponse()
@@ -828,7 +896,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
   /** https://github.com/square/okhttp/issues/1801 */
   @Test public void asyncCallEngineInitialized() throws Exception {
-    OkHttpClient c = new OkHttpClient.Builder()
+    OkHttpClient c = defaultClient().newBuilder()
         .addInterceptor(new Interceptor() {
           @Override public Response intercept(Chain chain) throws IOException {
             throw new IOException();
@@ -946,6 +1014,11 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     executeSynchronously("/").assertBody("retry success");
   }
 
+  @Test public void recoverWhenRetryOnConnectionFailureIsTrue_HTTP2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    recoverWhenRetryOnConnectionFailureIsTrue();
+  }
+
   @Test public void noRecoverWhenRetryOnConnectionFailureIsFalse() throws Exception {
     server.enqueue(new MockResponse().setBody("seed connection pool"));
     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AFTER_REQUEST));
@@ -959,7 +1032,28 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     executeSynchronously("/").assertBody("seed connection pool");
 
     // If this succeeds, too many requests were made.
-    executeSynchronously("/").assertFailure(IOException.class);
+    executeSynchronously("/")
+        .assertFailure(IOException.class)
+        .assertFailureMatches("stream was reset: CANCEL",
+            "unexpected end of stream on Connection.*"
+                + server.getHostName() + ":" + server.getPort() + ".*");
+  }
+
+  @Test public void recoverWhenRetryOnConnectionFailureIsFalse_HTTP2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    noRecoverWhenRetryOnConnectionFailureIsFalse();
+  }
+
+  @Test public void tlsHandshakeFailure_noFallbackByDefault() throws Exception {
+    server.useHttps(sslClient.socketFactory, false);
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
+    server.enqueue(new MockResponse().setBody("response that will never be received"));
+    RecordedResponse response = executeSynchronously("/");
+    response.assertFailure(
+            SSLProtocolException.class, // RI response to the FAIL_HANDSHAKE
+            SSLHandshakeException.class // Android's response to the FAIL_HANDSHAKE
+    );
+    assertFalse(client.connectionSpecs().contains(ConnectionSpec.COMPATIBLE_TLS));
   }
 
   @Test public void recoverFromTlsHandshakeFailure() throws Exception {
@@ -970,6 +1064,8 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     client = client.newBuilder()
         .hostnameVerifier(new RecordingHostnameVerifier())
         .dns(new SingleInetAddressDns())
+        // opt-in to fallback to COMPATIBLE_TLS
+        .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS))
         .sslSocketFactory(suppressTlsFallbackClientSocketFactory(), sslClient.trustManager)
         .build();
 
@@ -992,6 +1088,8 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         new RecordingSSLSocketFactory(sslClient.socketFactory);
     client = client.newBuilder()
         .sslSocketFactory(clientSocketFactory, sslClient.trustManager)
+        // opt-in to fallback to COMPATIBLE_TLS
+        .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS))
         .hostnameVerifier(new RecordingHostnameVerifier())
         .dns(new SingleInetAddressDns())
         .build();
@@ -1017,6 +1115,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     client = client.newBuilder()
         .hostnameVerifier(new RecordingHostnameVerifier())
+        .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS))
         .sslSocketFactory(suppressTlsFallbackClientSocketFactory(), sslClient.trustManager)
         .build();
 
@@ -1063,7 +1162,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
       client.newCall(request).execute();
       fail();
     } catch (UnknownServiceException expected) {
-      assertTrue(expected.getMessage().contains("CLEARTEXT communication not supported"));
+      assertEquals("CLEARTEXT communication not enabled for client", expected.getMessage());
     }
   }
 
@@ -1176,6 +1275,11 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     assertEquals(0, post2.getSequenceNumber());
   }
 
+  @Test public void postBodyRetransmittedOnFailureRecovery_HTTP2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    postBodyRetransmittedOnFailureRecovery();
+  }
+
   @Test public void cacheHit() throws Exception {
     server.enqueue(new MockResponse()
         .addHeader("ETag: v1")
@@ -1250,7 +1354,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .build();
 
     // Store a response in the cache.
-    long request1At = System.currentTimeMillis();
+    long request1SentAt = System.currentTimeMillis();
     executeSynchronously("/", "Accept-Language", "fr-CA", "Accept-Charset", "UTF-8")
         .assertCode(200)
         .assertHeader("Donut", "a")
@@ -1274,8 +1378,8 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .assertRequestHeader("Accept-Language", "en-US")
         .assertRequestHeader("Accept-Charset", "UTF-8")
         .assertRequestHeader("If-None-Match") // No If-None-Match on the user's request.
-        .assertSentRequestAtMillis(request1At, request1ReceivedAt)
-        .assertReceivedResponseAtMillis(request1At, request1ReceivedAt);
+        .assertSentRequestAtMillis(request2SentAt, request2ReceivedAt)
+        .assertReceivedResponseAtMillis(request2SentAt, request2ReceivedAt);
 
     // Check the cached response. Its request contains only the saved Vary headers.
     cacheHit.cacheResponse()
@@ -1286,8 +1390,8 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .assertRequestHeader("Accept-Language") // No Vary on Accept-Language.
         .assertRequestHeader("Accept-Charset", "UTF-8") // Because of Vary on Accept-Charset.
         .assertRequestHeader("If-None-Match") // This wasn't present in the original request.
-        .assertSentRequestAtMillis(request1At, request1ReceivedAt)
-        .assertReceivedResponseAtMillis(request1At, request1ReceivedAt);
+        .assertSentRequestAtMillis(request1SentAt, request1ReceivedAt)
+        .assertReceivedResponseAtMillis(request1SentAt, request1ReceivedAt);
 
     // Check the network response. It has the caller's request, plus some caching headers.
     cacheHit.networkResponse()
@@ -1428,7 +1532,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     // Attempt conditional cache validation and a DNS miss.
     client.connectionPool().evictAll();
     client = client.newBuilder()
-        .dns(new FakeDns().unknownHost())
+        .dns(new FakeDns())
         .build();
     executeSynchronously("/").assertFailure(UnknownHostException.class);
   }
@@ -1483,30 +1587,50 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
   }
 
   @Test public void getClientRequestTimeout() throws Exception {
-    enqueueRequestTimeoutResponses();
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
+        .setResponseCode(408)
+        .setHeader("Connection", "Close")
+        .setBody("You took too long!"));
+    server.enqueue(new MockResponse().setBody("Body"));
 
-    Response response = client.newCall(new Request.Builder()
-        .url(server.url("/")).build()).execute();
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    Response response = client.newCall(request).execute();
 
     assertEquals("Body", response.body().string());
   }
 
-  private void enqueueRequestTimeoutResponses() {
+  @Test public void getClientRequestTimeoutWithBackPressure() throws Exception {
     server.enqueue(new MockResponse()
         .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
-        .setResponseCode(HttpURLConnection.HTTP_CLIENT_TIMEOUT)
+        .setResponseCode(408)
         .setHeader("Connection", "Close")
+        .setHeader("Retry-After", "1")
         .setBody("You took too long!"));
-    server.enqueue(new MockResponse().setBody("Body"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    Response response = client.newCall(request).execute();
+
+    assertEquals("You took too long!", response.body().string());
   }
 
   @Test public void requestBodyRetransmittedOnClientRequestTimeout() throws Exception {
-    enqueueRequestTimeoutResponses();
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
+        .setResponseCode(408)
+        .setHeader("Connection", "Close")
+        .setBody("You took too long!"));
+    server.enqueue(new MockResponse().setBody("Body"));
 
-    Response response = client.newCall(new Request.Builder()
+    Request request = new Request.Builder()
         .url(server.url("/"))
         .post(RequestBody.create(MediaType.parse("text/plain"), "Hello"))
-        .build()).execute();
+        .build();
+    Response response = client.newCall(request).execute();
 
     assertEquals("Body", response.body().string());
 
@@ -1517,17 +1641,106 @@ private void enqueueRequestTimeoutResponses() {
     assertEquals("Hello", request2.getBody().readUtf8());
   }
 
-  @Test public void propfindRedirectsToPropfind() throws Exception {
+  @Test public void disableClientRequestTimeoutRetry() throws IOException {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
+        .setResponseCode(408)
+        .setHeader("Connection", "Close")
+        .setBody("You took too long!"));
+
+    client = client.newBuilder()
+        .retryOnConnectionFailure(false)
+        .build();
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    Response response = client.newCall(request).execute();
+
+    assertEquals(408, response.code());
+    assertEquals("You took too long!", response.body().string());
+  }
+
+  @Test public void maxClientRequestTimeoutRetries() throws IOException {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
+        .setResponseCode(408)
+        .setHeader("Connection", "Close")
+        .setBody("You took too long!"));
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
+        .setResponseCode(408)
+        .setHeader("Connection", "Close")
+        .setBody("You took too long!"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    Response response = client.newCall(request).execute();
+
+    assertEquals(408, response.code());
+    assertEquals("You took too long!", response.body().string());
+
+    assertEquals(2, server.getRequestCount());
+  }
+
+  @Test public void maxUnavailableTimeoutRetries() throws IOException {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
+        .setResponseCode(503)
+        .setHeader("Connection", "Close")
+        .setHeader("Retry-After", "0")
+        .setBody("You took too long!"));
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
+        .setResponseCode(503)
+        .setHeader("Connection", "Close")
+        .setHeader("Retry-After", "0")
+        .setBody("You took too long!"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    Response response = client.newCall(request).execute();
+
+    assertEquals(503, response.code());
+    assertEquals("You took too long!", response.body().string());
+
+    assertEquals(2, server.getRequestCount());
+  }
+
+  @Test public void retryOnUnavailableWith0RetryAfter() throws IOException {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
+        .setResponseCode(503)
+        .setHeader("Connection", "Close")
+        .setHeader("Retry-After", "0")
+        .setBody("You took too long!"));
+    server.enqueue(new MockResponse().setBody("Body"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    Response response = client.newCall(request).execute();
+
+    assertEquals("Body", response.body().string());
+  }
+
+  @Test public void propfindRedirectsToPropfindAndMaintainsRequestBody() throws Exception {
+    // given
     server.enqueue(new MockResponse()
         .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
         .addHeader("Location: /page2")
         .setBody("This page has moved!"));
     server.enqueue(new MockResponse().setBody("Page 2"));
 
+    // when
     Response response = client.newCall(new Request.Builder()
         .url(server.url("/page1"))
         .method("PROPFIND", RequestBody.create(MediaType.parse("text/plain"), "Request Body"))
         .build()).execute();
+
+    // then
     assertEquals("Page 2", response.body().string());
 
     RecordedRequest page1 = server.takeRequest();
@@ -1536,6 +1749,7 @@ private void enqueueRequestTimeoutResponses() {
 
     RecordedRequest page2 = server.takeRequest();
     assertEquals("PROPFIND /page2 HTTP/1.1", page2.getRequestLine());
+    assertEquals("Request Body", page2.getBody().readUtf8());
   }
 
   @Test public void responseCookies() throws Exception {
@@ -1734,6 +1948,25 @@ private void enqueueRequestTimeoutResponses() {
         .assertFailure("HTTP 205 had non-zero Content-Length: 39");
   }
 
+  @Test public void httpWithExcessiveHeaders() throws IOException {
+    String longLine = "HTTP/1.1 200 " + stringFill('O', 256 * 1024) + "K";
+
+    server.setProtocols(Collections.singletonList(Protocol.HTTP_1_1));
+
+    server.enqueue(new MockResponse()
+        .setStatus(longLine)
+        .setBody("I'm not even supposed to be here today."));
+
+    executeSynchronously("/")
+        .assertFailureMatches(".*unexpected end of stream on Connection.*");
+  }
+
+  private String stringFill(char fillChar, int length) {
+    char[] value = new char[length];
+    Arrays.fill(value, fillChar);
+    return new String(value);
+  }
+
   @Test public void canceledBeforeExecute() throws Exception {
     Call call = client.newCall(new Request.Builder().url(server.url("/a")).build());
     call.cancel();
@@ -1756,16 +1989,12 @@ private void enqueueRequestTimeoutResponses() {
 
   /** Cancel a call that's waiting for connect to complete. */
   private void cancelDuringConnect(String scheme) throws Exception {
-    InetSocketAddress socketAddress = startNullServer();
-
-    HttpUrl url = new HttpUrl.Builder()
-        .scheme(scheme)
-        .host(socketAddress.getHostName())
-        .port(socketAddress.getPort())
-        .build();
+    nullServer.start();
 
     long cancelDelayMillis = 300L;
-    Call call = client.newCall(new Request.Builder().url(url).build());
+    Call call = client.newCall(new Request.Builder()
+        .url(nullServer.url(scheme))
+        .build());
     cancelLater(call, cancelDelayMillis);
 
     long startNanos = System.nanoTime();
@@ -1778,13 +2007,6 @@ private void cancelDuringConnect(String scheme) throws Exception {
     assertEquals(cancelDelayMillis, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 100f);
   }
 
-  private InetSocketAddress startNullServer() throws IOException {
-    InetSocketAddress address = new InetSocketAddress(InetAddress.getByName("localhost"), 0);
-    nullServer = ServerSocketFactory.getDefault().createServerSocket();
-    nullServer.bind(address);
-    return new InetSocketAddress(address.getAddress(), nullServer.getLocalPort());
-  }
-
   @Test public void cancelImmediatelyAfterEnqueue() throws Exception {
     server.enqueue(new MockResponse());
     Call call = client.newCall(new Request.Builder()
@@ -1792,7 +2014,7 @@ private InetSocketAddress startNullServer() throws IOException {
         .build());
     call.enqueue(callback);
     call.cancel();
-    callback.await(server.url("/a")).assertFailure("Canceled");
+    callback.await(server.url("/a")).assertFailure("Canceled", "Socket closed");
   }
 
   @Test public void cancelAll() throws Exception {
@@ -1801,7 +2023,7 @@ private InetSocketAddress startNullServer() throws IOException {
         .build());
     call.enqueue(callback);
     client.dispatcher().cancelAll();
-    callback.await(server.url("/")).assertFailure("Canceled");
+    callback.await(server.url("/")).assertFailure("Canceled", "Socket closed");
   }
 
   @Test public void cancelBeforeBodyIsRead() throws Exception {
@@ -1854,17 +2076,17 @@ private InetSocketAddress startNullServer() throws IOException {
     cancelInFlightBeforeResponseReadThrowsIOE();
   }
 
-  @Test public void cancelInFlightBeforeResponseReadThrowsIOE_SPDY_3() throws Exception {
-    enableProtocol(Protocol.SPDY_3);
-    cancelInFlightBeforeResponseReadThrowsIOE();
-  }
-
   /**
    * This test puts a request in front of one that is to be canceled, so that it is canceled before
    * I/O takes place.
    */
   @Test public void canceledBeforeIOSignalsOnFailure() throws Exception {
-    client.dispatcher().setMaxRequests(1); // Force requests to be executed serially.
+    // Force requests to be executed serially.
+    okhttp3.Dispatcher dispatcher = new okhttp3.Dispatcher(client.dispatcher().executorService());
+    dispatcher.setMaxRequests(1);
+    client = client.newBuilder()
+        .dispatcher(dispatcher)
+        .build();
 
     Request requestA = new Request.Builder().url(server.url("/a")).build();
     Request requestB = new Request.Builder().url(server.url("/b")).build();
@@ -1886,7 +2108,7 @@ private InetSocketAddress startNullServer() throws IOException {
 
     callback.await(requestA.url()).assertBody("A");
     // At this point we know the callback is ready, and that it will receive a cancel failure.
-    callback.await(requestB.url()).assertFailure("Canceled");
+    callback.await(requestB.url()).assertFailure("Canceled", "Socket closed");
   }
 
   @Test public void canceledBeforeIOSignalsOnFailure_HTTPS() throws Exception {
@@ -1899,11 +2121,6 @@ private InetSocketAddress startNullServer() throws IOException {
     canceledBeforeIOSignalsOnFailure();
   }
 
-  @Test public void canceledBeforeIOSignalsOnFailure_SPDY_3() throws Exception {
-    enableProtocol(Protocol.SPDY_3);
-    canceledBeforeIOSignalsOnFailure();
-  }
-
   @Test public void canceledBeforeResponseReadSignalsOnFailure() throws Exception {
     Request requestA = new Request.Builder().url(server.url("/a")).build();
     final Call call = client.newCall(requestA);
@@ -1931,11 +2148,6 @@ private InetSocketAddress startNullServer() throws IOException {
     canceledBeforeResponseReadSignalsOnFailure();
   }
 
-  @Test public void canceledBeforeResponseReadSignalsOnFailure_SPDY_3() throws Exception {
-    enableProtocol(Protocol.SPDY_3);
-    canceledBeforeResponseReadSignalsOnFailure();
-  }
-
   /**
    * There's a race condition where the cancel may apply after the stream has already been
    * processed.
@@ -1985,12 +2197,6 @@ private InetSocketAddress startNullServer() throws IOException {
     canceledAfterResponseIsDeliveredBreaksStreamButSignalsOnce();
   }
 
-  @Test public void canceledAfterResponseIsDeliveredBreaksStreamButSignalsOnce_SPDY_3()
-      throws Exception {
-    enableProtocol(Protocol.SPDY_3);
-    canceledAfterResponseIsDeliveredBreaksStreamButSignalsOnce();
-  }
-
   @Test public void cancelWithInterceptor() throws Exception {
     client = client.newBuilder()
         .addInterceptor(new Interceptor() {
@@ -2049,6 +2255,33 @@ private InetSocketAddress startNullServer() throws IOException {
     executeSynchronously("/").assertBody("abcabcabc");
   }
 
+  @Test public void rangeHeaderPreventsAutomaticGzip() throws Exception {
+    Buffer gzippedBody = gzip("abcabcabc");
+
+    // Enqueue a gzipped response. Our request isn't expecting it, but that's okay.
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_PARTIAL)
+        .setBody(gzippedBody)
+        .addHeader("Content-Encoding: gzip")
+        .addHeader("Content-Range: bytes 0-" + (gzippedBody.size() - 1)));
+
+    // Make a range request.
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .header("Range", "bytes=0-")
+        .build();
+    Call call = client.newCall(request);
+
+    // The response is not decompressed.
+    Response response = call.execute();
+    assertEquals("gzip", response.header("Content-Encoding"));
+    assertEquals(gzippedBody.snapshot(), response.body().source().readByteString());
+
+    // The request did not offer gzip support.
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertNull(recordedRequest.getHeader("Accept-Encoding"));
+  }
+
   @Test public void asyncResponseCanBeConsumedLater() throws Exception {
     server.enqueue(new MockResponse().setBody("abc"));
     server.enqueue(new MockResponse().setBody("def"));
@@ -2112,7 +2345,8 @@ private InetSocketAddress startNullServer() throws IOException {
   }
 
   @Test public void expect100ContinueNonEmptyRequestBody() throws Exception {
-    server.enqueue(new MockResponse());
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.EXPECT_CONTINUE));
 
     Request request = new Request.Builder()
         .url(server.url("/"))
@@ -2141,6 +2375,123 @@ private InetSocketAddress startNullServer() throws IOException {
         .assertSuccessful();
   }
 
+  @Test public void expect100ContinueEmptyRequestBody_HTTP2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    expect100ContinueEmptyRequestBody();
+  }
+
+  @Test public void expect100ContinueTimesOutWithoutContinue() throws Exception {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.NO_RESPONSE));
+
+    client = client.newBuilder()
+        .readTimeout(500, TimeUnit.MILLISECONDS)
+        .build();
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .header("Expect", "100-continue")
+        .post(RequestBody.create(MediaType.parse("text/plain"), "abc"))
+        .build();
+
+    Call call = client.newCall(request);
+    try {
+      call.execute();
+      fail();
+    } catch (SocketTimeoutException expected) {
+    }
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("", recordedRequest.getBody().readUtf8());
+  }
+
+  @Test public void expect100ContinueTimesOutWithoutContinue_HTTP2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    expect100ContinueTimesOutWithoutContinue();
+  }
+
+  @Test public void serverRespondsWithUnsolicited100Continue() throws Exception {
+    server.enqueue(new MockResponse()
+        .setStatus("HTTP/1.1 100 Continue"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .post(RequestBody.create(MediaType.parse("text/plain"), "abc"))
+        .build();
+
+    Call call = client.newCall(request);
+    Response response = call.execute();
+    assertEquals(100, response.code());
+    assertEquals("", response.body().string());
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("abc", recordedRequest.getBody().readUtf8());
+  }
+
+  @Test public void serverRespondsWithUnsolicited100Continue_HTTP2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    serverRespondsWithUnsolicited100Continue();
+  }
+
+  @Test public void successfulExpectContinuePermitsConnectionReuse() throws Exception {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.EXPECT_CONTINUE));
+    server.enqueue(new MockResponse());
+
+    executeSynchronously(new Request.Builder()
+        .url(server.url("/"))
+        .header("Expect", "100-continue")
+        .post(RequestBody.create(MediaType.parse("text/plain"), "abc"))
+        .build());
+    executeSynchronously(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void successfulExpectContinuePermitsConnectionReuseWithHttp2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    successfulExpectContinuePermitsConnectionReuse();
+  }
+
+  @Test public void unsuccessfulExpectContinuePreventsConnectionReuse() throws Exception {
+    server.enqueue(new MockResponse());
+    server.enqueue(new MockResponse());
+
+    executeSynchronously(new Request.Builder()
+        .url(server.url("/"))
+        .header("Expect", "100-continue")
+        .post(RequestBody.create(MediaType.parse("text/plain"), "abc"))
+        .build());
+    executeSynchronously(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void unsuccessfulExpectContinuePermitsConnectionReuseWithHttp2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+
+    server.enqueue(new MockResponse());
+    server.enqueue(new MockResponse());
+
+    executeSynchronously(new Request.Builder()
+        .url(server.url("/"))
+        .header("Expect", "100-continue")
+        .post(RequestBody.create(MediaType.parse("text/plain"), "abc"))
+        .build());
+    executeSynchronously(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+  }
+
   /** We forbid non-ASCII characters in outgoing request headers, but accept UTF-8. */
   @Test public void responseHeaderParsingIsLenient() throws Exception {
     Headers headers = new Headers.Builder()
@@ -2158,9 +2509,9 @@ private InetSocketAddress startNullServer() throws IOException {
   }
 
   @Test public void customDns() throws Exception {
-    // Configure a DNS that returns our MockWebServer for every hostname.
+    // Configure a DNS that returns our local MockWebServer for android.com.
     FakeDns dns = new FakeDns();
-    dns.addresses(Dns.SYSTEM.lookup(server.url("/").host()));
+    dns.set("android.com", Dns.SYSTEM.lookup(server.url("/").host()));
     client = client.newBuilder()
         .dns(dns)
         .build();
@@ -2173,6 +2524,23 @@ private InetSocketAddress startNullServer() throws IOException {
 
     dns.assertRequests("android.com");
   }
+  @Test public void dnsReturnsZeroIpAddresses() throws Exception {
+    // Configure a DNS that returns our local MockWebServer for android.com.
+    FakeDns dns = new FakeDns();
+    List<InetAddress> ipAddresses = new ArrayList<>();
+    dns.set("android.com", ipAddresses);
+    client = client.newBuilder()
+        .dns(dns)
+        .build();
+
+    server.enqueue(new MockResponse());
+    Request request = new Request.Builder()
+        .url(server.url("/").newBuilder().host("android.com").build())
+        .build();
+    executeSynchronously(request).assertFailure(dns + " returned no addresses for android.com");
+
+    dns.assertRequests("android.com");
+  }
 
   /** We had a bug where failed HTTP/2 calls could break the entire connection. */
   @Test public void failingCallsDoNotInterfereWithConnection() throws Exception {
@@ -2307,8 +2675,8 @@ private InetSocketAddress startNullServer() throws IOException {
   }
 
   /**
-   * OkHttp has a bug where a `Connection: close` response header is not honored when establishing
-   * a TLS tunnel. https://github.com/square/okhttp/issues/2426
+   * OkHttp has a bug where a `Connection: close` response header is not honored when establishing a
+   * TLS tunnel. https://github.com/square/okhttp/issues/2426
    */
   @Test public void proxyAuthenticateOnConnectWithConnectionClose() throws Exception {
     server.useHttps(sslClient.socketFactory, true);
@@ -2406,7 +2774,7 @@ private InetSocketAddress startNullServer() throws IOException {
     assertEquals("password", get.getHeader("Proxy-Authorization"));
   }
 
-  @Test public void interceptorGetsFramedProtocol() throws Exception {
+  @Test public void interceptorGetsHttp2() throws Exception {
     enableProtocol(Protocol.HTTP_2);
 
     // Capture the protocol as it is observed by the interceptor.
@@ -2459,6 +2827,46 @@ private InetSocketAddress startNullServer() throws IOException {
         .assertFailure("Unexpected status line:  HTTP/1.1 200 OK");
   }
 
+  @Test public void requestHeaderNameWithSpaceForbidden() throws Exception {
+    try {
+      new Request.Builder().addHeader("a b", "c");
+      fail();
+    } catch (IllegalArgumentException expected) {
+      assertEquals("Unexpected char 0x20 at 1 in header name: a b", expected.getMessage());
+    }
+  }
+
+  @Test public void requestHeaderNameWithTabForbidden() throws Exception {
+    try {
+      new Request.Builder().addHeader("a\tb", "c");
+      fail();
+    } catch (IllegalArgumentException expected) {
+      assertEquals("Unexpected char 0x09 at 1 in header name: a\tb", expected.getMessage());
+    }
+  }
+
+  @Test public void responseHeaderNameWithSpacePermitted() throws Exception {
+    server.enqueue(new MockResponse()
+        .clearHeaders()
+        .addHeader("content-length: 0")
+        .addHeaderLenient("a b", "c"));
+
+    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
+    Response response = call.execute();
+    assertEquals("c", response.header("a b"));
+  }
+
+  @Test public void responseHeaderNameWithTabPermitted() throws Exception {
+    server.enqueue(new MockResponse()
+        .clearHeaders()
+        .addHeader("content-length: 0")
+        .addHeaderLenient("a\tb", "c"));
+
+    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
+    Response response = call.execute();
+    assertEquals("c", response.header("a\tb"));
+  }
+
   @Test public void connectFails() throws Exception {
     server.shutdown();
 
@@ -2472,7 +2880,8 @@ private InetSocketAddress startNullServer() throws IOException {
     // Enable a misconfigured proxy selector to guarantee that the request is retried.
     client = client.newBuilder()
         .proxySelector(new FakeProxySelector()
-            .addProxy(server2.toProxyAddress()))
+            .addProxy(server2.toProxyAddress())
+            .addProxy(Proxy.NO_PROXY))
         .build();
     server2.shutdown();
 
@@ -2594,6 +3003,115 @@ private RequestBody requestBody(final boolean chunked, final long size, final in
         .assertBody("");
   }
 
+  @Test public void leakedResponseBodyLogsStackTrace() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("This gets leaked."));
+
+    client = defaultClient().newBuilder()
+        .connectionPool(new ConnectionPool(0, 10, TimeUnit.MILLISECONDS))
+        .build();
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    Level original = logger.getLevel();
+    logger.setLevel(Level.FINE);
+    logHandler.setFormatter(new SimpleFormatter());
+    try {
+      client.newCall(request).execute(); // Ignore the response so it gets leaked then GC'd.
+      awaitGarbageCollection();
+
+      String message = logHandler.take();
+      assertTrue(message.contains("A connection to " + server.url("/") + " was leaked."
+          + " Did you forget to close a response body?"));
+      assertTrue(message.contains("okhttp3.RealCall.execute("));
+      assertTrue(message.contains("okhttp3.CallTest.leakedResponseBodyLogsStackTrace("));
+    } finally {
+      logger.setLevel(original);
+    }
+  }
+
+  @Test public void asyncLeakedResponseBodyLogsStackTrace() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("This gets leaked."));
+
+    client = defaultClient().newBuilder()
+        .connectionPool(new ConnectionPool(0, 10, TimeUnit.MILLISECONDS))
+        .build();
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    Level original = logger.getLevel();
+    logger.setLevel(Level.FINE);
+    logHandler.setFormatter(new SimpleFormatter());
+    try {
+      final CountDownLatch latch = new CountDownLatch(1);
+      client.newCall(request).enqueue(new Callback() {
+        @Override public void onFailure(Call call, IOException e) {
+          fail();
+        }
+
+        @Override public void onResponse(Call call, Response response) throws IOException {
+          // Ignore the response so it gets leaked then GC'd.
+          latch.countDown();
+        }
+      });
+      latch.await();
+      // There's some flakiness when triggering a GC for objects in a separate thread. Adding a
+      // small delay appears to ensure the objects will get GC'd.
+      Thread.sleep(200);
+      awaitGarbageCollection();
+
+      String message = logHandler.take();
+      assertTrue(message.contains("A connection to " + server.url("/") + " was leaked."
+          + " Did you forget to close a response body?"));
+      assertTrue(message.contains("okhttp3.RealCall.enqueue("));
+      assertTrue(message.contains("okhttp3.CallTest.asyncLeakedResponseBodyLogsStackTrace("));
+    } finally {
+      logger.setLevel(original);
+    }
+  }
+
+  @Test public void httpsWithIpAddress() throws Exception {
+    String localIpAddress = InetAddress.getLoopbackAddress().getHostAddress();
+
+    // Create a certificate with an IP address in the subject alt name.
+    HeldCertificate heldCertificate = new HeldCertificate.Builder()
+        .commonName("example.com")
+        .subjectAlternativeName(localIpAddress)
+        .build();
+    SslClient sslClient = new SslClient.Builder()
+        .certificateChain(heldCertificate.keyPair, heldCertificate.certificate)
+        .addTrustedCertificate(heldCertificate.certificate)
+        .build();
+
+    // Use that certificate on the server and trust it on the client.
+    server.useHttps(sslClient.socketFactory, false);
+    client = client.newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .protocols(Collections.singletonList(Protocol.HTTP_1_1))
+        .build();
+
+    // Make a request.
+    server.enqueue(new MockResponse());
+    HttpUrl url = server.url("/").newBuilder()
+        .host(localIpAddress)
+        .build();
+    Request request = new Request.Builder()
+        .url(url)
+        .build();
+    executeSynchronously(request)
+        .assertCode(200);
+
+    // Confirm that the IP address was used in the host header.
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals(localIpAddress + ":" + server.getPort(), recordedRequest.getHeader("Host"));
+  }
+
   private void makeFailingCall() {
     RequestBody requestBody = new RequestBody() {
       @Override public MediaType contentType() {
diff --git a/okhttp-tests/src/test/java/okhttp3/CertificateChainCleanerTest.java b/okhttp-tests/src/test/java/okhttp3/CertificateChainCleanerTest.java
index 261c99f8b6..3c5267bcc9 100644
--- a/okhttp-tests/src/test/java/okhttp3/CertificateChainCleanerTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CertificateChainCleanerTest.java
@@ -21,14 +21,38 @@
 import java.util.ArrayList;
 import java.util.List;
 import javax.net.ssl.SSLPeerUnverifiedException;
-import okhttp3.internal.tls.HeldCertificate;
+import javax.net.ssl.SSLSocketFactory;
+import javax.net.ssl.X509TrustManager;
+import okhttp3.internal.platform.Platform;
 import okhttp3.internal.tls.CertificateChainCleaner;
+import okhttp3.internal.tls.HeldCertificate;
+import okhttp3.internal.tls.SslClient;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 
 public final class CertificateChainCleanerTest {
+  @Test public void equalsFromCertificate() throws Exception {
+    HeldCertificate rootA = new HeldCertificate.Builder()
+        .serialNumber("1")
+        .build();
+    HeldCertificate rootB = new HeldCertificate.Builder()
+        .serialNumber("2")
+        .build();
+    assertEquals(
+        CertificateChainCleaner.get(rootA.certificate, rootB.certificate),
+        CertificateChainCleaner.get(rootB.certificate, rootA.certificate));
+  }
+
+  @Test public void equalsFromTrustManager() throws Exception {
+    SslClient client = new SslClient.Builder().build();
+    X509TrustManager x509TrustManager = client.trustManager;
+    assertEquals(
+        CertificateChainCleaner.get(x509TrustManager),
+        CertificateChainCleaner.get(x509TrustManager));
+  }
+
   @Test public void normalizeSingleSelfSignedCertificate() throws Exception {
     HeldCertificate root = new HeldCertificate.Builder()
         .serialNumber("1")
diff --git a/okhttp-tests/src/test/java/okhttp3/CertificatePinnerTest.java b/okhttp-tests/src/test/java/okhttp3/CertificatePinnerTest.java
index 54a51b5d7d..0745982fb2 100644
--- a/okhttp-tests/src/test/java/okhttp3/CertificatePinnerTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CertificatePinnerTest.java
@@ -253,4 +253,54 @@
     assertEquals(Collections.emptyList(), certificatePinner.findMatchingPins("example.com"));
     assertEquals(Collections.emptyList(), certificatePinner.findMatchingPins("a.b.example.com"));
   }
+
+  @Test public void successfulFindMatchingPinsIgnoresCase() {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("EXAMPLE.com", certA1Sha256Pin)
+        .add("*.MyExample.Com", certB1Sha256Pin)
+        .build();
+
+    List<Pin> expectedPin1 = Arrays.asList(new Pin("EXAMPLE.com", certA1Sha256Pin));
+    assertEquals(expectedPin1, certificatePinner.findMatchingPins("example.com"));
+
+    List<Pin> expectedPin2 = Arrays.asList(new Pin("*.MyExample.Com", certB1Sha256Pin));
+    assertEquals(expectedPin2, certificatePinner.findMatchingPins("a.myexample.com"));
+  }
+
+  @Test public void successfulFindMatchingPinPunycode() {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("σkhttp.com", certA1Sha256Pin)
+        .build();
+
+    List<Pin> expectedPin = Arrays.asList(new Pin("σkhttp.com", certA1Sha256Pin));
+    assertEquals(expectedPin, certificatePinner.findMatchingPins("xn--khttp-fde.com"));
+  }
+
+  /** https://github.com/square/okhttp/issues/3324 */
+  @Test public void checkSubstringMatch() throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("*.example.com", certA1Sha256Pin)
+        .build();
+
+    assertEquals(Collections.emptyList(),
+        certificatePinner.findMatchingPins("a.example.com.notexample.com"));
+    assertEquals(Collections.emptyList(),
+        certificatePinner.findMatchingPins("example.com.notexample.com"));
+    assertEquals(Collections.emptyList(),
+        certificatePinner.findMatchingPins("notexample.com"));
+    assertEquals(Collections.emptyList(),
+        certificatePinner.findMatchingPins("example.com"));
+    assertEquals(Collections.emptyList(),
+        certificatePinner.findMatchingPins("a.b.example.com"));
+    assertEquals(Collections.emptyList(),
+        certificatePinner.findMatchingPins("ple.com"));
+    assertEquals(Collections.emptyList(),
+        certificatePinner.findMatchingPins("com"));
+
+    Pin expectedPin = new Pin("*.example.com", certA1Sha256Pin);
+    assertEquals(Collections.singletonList(expectedPin),
+        certificatePinner.findMatchingPins("a.example.com"));
+    assertEquals(Collections.singletonList(expectedPin),
+        certificatePinner.findMatchingPins("example.example.com"));
+  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/CipherSuiteTest.java b/okhttp-tests/src/test/java/okhttp3/CipherSuiteTest.java
new file mode 100644
index 0000000000..63b3023253
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/CipherSuiteTest.java
@@ -0,0 +1,220 @@
+/*
+ * Copyright (C) 2016 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import org.junit.Test;
+
+import static okhttp3.CipherSuite.TLS_KRB5_WITH_DES_CBC_MD5;
+import static okhttp3.CipherSuite.TLS_RSA_EXPORT_WITH_RC4_40_MD5;
+import static okhttp3.CipherSuite.TLS_RSA_WITH_AES_128_CBC_SHA256;
+import static okhttp3.CipherSuite.forJavaName;
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotEquals;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.fail;
+
+public class CipherSuiteTest {
+  @Test public void nullCipherName() {
+    try {
+      forJavaName(null);
+      fail("Should have thrown");
+    } catch (NullPointerException expected) {
+    }
+  }
+
+  @Test public void hashCode_usesIdentityHashCode_legacyCase() {
+    CipherSuite cs = TLS_RSA_EXPORT_WITH_RC4_40_MD5; // This one's javaName starts with "SSL_".
+    assertEquals(cs.toString(), System.identityHashCode(cs), cs.hashCode());
+  }
+
+  @Test public void hashCode_usesIdentityHashCode_regularCase() {
+    CipherSuite cs = TLS_RSA_WITH_AES_128_CBC_SHA256; // This one's javaName matches the identifier.
+    assertEquals(cs.toString(), System.identityHashCode(cs), cs.hashCode());
+  }
+
+  @Test public void instancesAreInterned() {
+    assertSame(forJavaName("TestCipherSuite"), forJavaName("TestCipherSuite"));
+    assertSame(CipherSuite.TLS_KRB5_WITH_DES_CBC_MD5,
+        forJavaName(TLS_KRB5_WITH_DES_CBC_MD5.javaName()));
+  }
+
+  /**
+   * Tests that interned CipherSuite instances remain the case across garbage collections, even if
+   * the String used to construct them is no longer strongly referenced outside of the CipherSuite.
+   */
+  @SuppressWarnings("RedundantStringConstructorCall")
+  @Test public void instancesAreInterned_survivesGarbageCollection() {
+    // We're not holding onto a reference to this String instance outside of the CipherSuite...
+    CipherSuite cs = forJavaName(new String("FakeCipherSuite_instancesAreInterned"));
+    System.gc(); // Unless cs references the String instance, it may now be garbage collected.
+    assertSame(cs, forJavaName(new String(cs.javaName())));
+  }
+
+  @Test public void equals() {
+    assertEquals(forJavaName("cipher"), forJavaName("cipher"));
+    assertNotEquals(forJavaName("cipherA"), forJavaName("cipherB"));
+    assertEquals(forJavaName("SSL_RSA_EXPORT_WITH_RC4_40_MD5"), TLS_RSA_EXPORT_WITH_RC4_40_MD5);
+    assertNotEquals(TLS_RSA_EXPORT_WITH_RC4_40_MD5, TLS_RSA_WITH_AES_128_CBC_SHA256);
+  }
+
+  @Test public void forJavaName_acceptsArbitraryStrings() {
+    // Shouldn't throw.
+    forJavaName("example CipherSuite name that is not in the whitelist");
+  }
+
+  @Test public void javaName_examples() {
+    assertEquals("SSL_RSA_EXPORT_WITH_RC4_40_MD5", TLS_RSA_EXPORT_WITH_RC4_40_MD5.javaName());
+    assertEquals("TLS_RSA_WITH_AES_128_CBC_SHA256", TLS_RSA_WITH_AES_128_CBC_SHA256.javaName());
+    assertEquals("TestCipherSuite", forJavaName("TestCipherSuite").javaName());
+  }
+
+  @Test public void javaName_equalsToString() {
+    assertEquals(TLS_RSA_EXPORT_WITH_RC4_40_MD5.javaName,
+        TLS_RSA_EXPORT_WITH_RC4_40_MD5.toString());
+    assertEquals(TLS_RSA_WITH_AES_128_CBC_SHA256.javaName,
+        TLS_RSA_WITH_AES_128_CBC_SHA256.toString());
+  }
+
+  /**
+   * On the Oracle JVM some older cipher suites have the "SSL_" prefix and others have the "TLS_"
+   * prefix. On the IBM JVM all cipher suites have the "SSL_" prefix.
+   *
+   * <p>Prior to OkHttp 3.3.1 we accepted either form and consider them equivalent. And since OkHttp
+   * 3.7.0 this is also true. But OkHttp 3.3.1 through 3.6.0 treated these as different.
+   */
+  @Test public void forJavaName_fromLegacyEnumName() {
+    // These would have been considered equal in OkHttp 3.3.1, but now aren't.
+    assertEquals(
+        forJavaName("TLS_RSA_EXPORT_WITH_RC4_40_MD5"),
+        forJavaName("SSL_RSA_EXPORT_WITH_RC4_40_MD5"));
+    assertEquals(
+        forJavaName("TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA"),
+        forJavaName("SSL_DH_RSA_EXPORT_WITH_DES40_CBC_SHA"));
+    assertEquals(
+        forJavaName("TLS_FAKE_NEW_CIPHER"),
+        forJavaName("SSL_FAKE_NEW_CIPHER"));
+  }
+
+  @Test public void applyIntersectionRetainsSslPrefixes() throws Exception {
+    FakeSslSocket socket = new FakeSslSocket();
+    socket.setEnabledProtocols(new String[] { "TLSv1" });
+    socket.setSupportedCipherSuites(new String[] { "SSL_A", "SSL_B", "SSL_C", "SSL_D", "SSL_E" });
+    socket.setEnabledCipherSuites(new String[] { "SSL_A", "SSL_B", "SSL_C" });
+
+    ConnectionSpec connectionSpec = new ConnectionSpec.Builder(true)
+        .tlsVersions(TlsVersion.TLS_1_0)
+        .cipherSuites("TLS_A", "TLS_C", "TLS_E")
+        .build();
+    connectionSpec.apply(socket, false);
+
+    assertArrayEquals(new String[] { "SSL_A", "SSL_C" }, socket.enabledCipherSuites);
+  }
+
+  @Test public void applyIntersectionRetainsTlsPrefixes() throws Exception {
+    FakeSslSocket socket = new FakeSslSocket();
+    socket.setEnabledProtocols(new String[] { "TLSv1" });
+    socket.setSupportedCipherSuites(new String[] { "TLS_A", "TLS_B", "TLS_C", "TLS_D", "TLS_E" });
+    socket.setEnabledCipherSuites(new String[] { "TLS_A", "TLS_B", "TLS_C" });
+
+    ConnectionSpec connectionSpec = new ConnectionSpec.Builder(true)
+        .tlsVersions(TlsVersion.TLS_1_0)
+        .cipherSuites("SSL_A", "SSL_C", "SSL_E")
+        .build();
+    connectionSpec.apply(socket, false);
+
+    assertArrayEquals(new String[] { "TLS_A", "TLS_C" }, socket.enabledCipherSuites);
+  }
+
+  @Test public void applyIntersectionAddsSslScsvForFallback() throws Exception {
+    FakeSslSocket socket = new FakeSslSocket();
+    socket.setEnabledProtocols(new String[] { "TLSv1" });
+    socket.setSupportedCipherSuites(new String[] { "SSL_A", "SSL_FALLBACK_SCSV" });
+    socket.setEnabledCipherSuites(new String[] { "SSL_A" });
+
+    ConnectionSpec connectionSpec = new ConnectionSpec.Builder(true)
+        .tlsVersions(TlsVersion.TLS_1_0)
+        .cipherSuites("SSL_A")
+        .build();
+    connectionSpec.apply(socket, true);
+
+    assertArrayEquals(new String[] { "SSL_A", "SSL_FALLBACK_SCSV" }, socket.enabledCipherSuites);
+  }
+
+  @Test public void applyIntersectionAddsTlsScsvForFallback() throws Exception {
+    FakeSslSocket socket = new FakeSslSocket();
+    socket.setEnabledProtocols(new String[] { "TLSv1" });
+    socket.setSupportedCipherSuites(new String[] { "TLS_A", "TLS_FALLBACK_SCSV" });
+    socket.setEnabledCipherSuites(new String[] { "TLS_A" });
+
+    ConnectionSpec connectionSpec = new ConnectionSpec.Builder(true)
+        .tlsVersions(TlsVersion.TLS_1_0)
+        .cipherSuites("TLS_A")
+        .build();
+    connectionSpec.apply(socket, true);
+
+    assertArrayEquals(new String[] { "TLS_A", "TLS_FALLBACK_SCSV" }, socket.enabledCipherSuites);
+  }
+
+  @Test public void applyIntersectionToProtocolVersion() throws Exception {
+    FakeSslSocket socket = new FakeSslSocket();
+    socket.setEnabledProtocols(new String[] { "TLSv1", "TLSv1.1", "TLSv1.2" });
+    socket.setSupportedCipherSuites(new String[] { "TLS_A" });
+    socket.setEnabledCipherSuites(new String[] { "TLS_A" });
+
+    ConnectionSpec connectionSpec = new ConnectionSpec.Builder(true)
+        .tlsVersions(TlsVersion.TLS_1_1, TlsVersion.TLS_1_2, TlsVersion.TLS_1_3)
+        .cipherSuites("TLS_A")
+        .build();
+    connectionSpec.apply(socket, false);
+
+    assertArrayEquals(new String[] { "TLSv1.1", "TLSv1.2" }, socket.enabledProtocols);
+  }
+
+  static final class FakeSslSocket extends DelegatingSSLSocket {
+    private String[] enabledProtocols;
+    private String[] supportedCipherSuites;
+    private String[] enabledCipherSuites;
+
+    FakeSslSocket() {
+      super(null);
+    }
+
+    @Override public String[] getEnabledProtocols() {
+      return enabledProtocols;
+    }
+
+    @Override public void setEnabledProtocols(String[] enabledProtocols) {
+      this.enabledProtocols = enabledProtocols;
+    }
+
+    @Override public String[] getSupportedCipherSuites() {
+      return supportedCipherSuites;
+    }
+
+    public void setSupportedCipherSuites(String[] supportedCipherSuites) {
+      this.supportedCipherSuites = supportedCipherSuites;
+    }
+
+    @Override public String[] getEnabledCipherSuites() {
+      return enabledCipherSuites;
+    }
+
+    @Override public void setEnabledCipherSuites(String[] enabledCipherSuites) {
+      this.enabledCipherSuites = enabledCipherSuites;
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/ConnectionCoalescingTest.java b/okhttp-tests/src/test/java/okhttp3/ConnectionCoalescingTest.java
new file mode 100644
index 0000000000..684a77fa18
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/ConnectionCoalescingTest.java
@@ -0,0 +1,335 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.Proxy;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicReference;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.SSLSession;
+import okhttp3.internal.tls.HeldCertificate;
+import okhttp3.internal.tls.SslClient;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Rule;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+public final class ConnectionCoalescingTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private OkHttpClient client;
+
+  private HeldCertificate rootCa;
+  private HeldCertificate certificate;
+  private FakeDns dns = new FakeDns();
+  private HttpUrl url;
+  private List<InetAddress> serverIps;
+
+  @Before public void setUp() throws Exception {
+    rootCa = new HeldCertificate.Builder()
+        .serialNumber("1")
+        .ca(3)
+        .commonName("root")
+        .build();
+    certificate = new HeldCertificate.Builder()
+        .issuedBy(rootCa)
+        .serialNumber("2")
+        .commonName(server.getHostName())
+        .subjectAlternativeName(server.getHostName())
+        .subjectAlternativeName("san.com")
+        .subjectAlternativeName("*.wildcard.com")
+        .subjectAlternativeName("differentdns.com")
+        .build();
+
+    serverIps = Dns.SYSTEM.lookup(server.getHostName());
+
+    dns.set(server.getHostName(), serverIps);
+    dns.set("san.com", serverIps);
+    dns.set("nonsan.com", serverIps);
+    dns.set("www.wildcard.com", serverIps);
+    dns.set("differentdns.com", Collections.<InetAddress>emptyList());
+
+    SslClient sslClient = new SslClient.Builder()
+        .addTrustedCertificate(rootCa.certificate)
+        .build();
+
+    client = new OkHttpClient.Builder().dns(dns)
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .build();
+
+    SslClient serverSslClient = new SslClient.Builder()
+        .certificateChain(certificate, rootCa)
+        .build();
+    server.useHttps(serverSslClient.socketFactory, false);
+
+    url = server.url("/robots.txt");
+  }
+
+  /**
+   * Test connecting to the main host then an alternative, although only subject alternative names
+   * are used if present no special consideration of common name.
+   */
+  @Test public void commonThenAlternative() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(200));
+    server.enqueue(new MockResponse().setResponseCode(200));
+
+    assert200Http2Response(execute(url), server.getHostName());
+
+    HttpUrl sanUrl = url.newBuilder().host("san.com").build();
+    assert200Http2Response(execute(sanUrl), "san.com");
+
+    assertEquals(1, client.connectionPool().connectionCount());
+  }
+
+  /**
+   * Test connecting to an alternative host then common name, although only subject alternative
+   * names are used if present no special consideration of common name.
+   */
+  @Test public void alternativeThenCommon() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(200));
+    server.enqueue(new MockResponse().setResponseCode(200));
+
+    HttpUrl sanUrl = url.newBuilder().host("san.com").build();
+    assert200Http2Response(execute(sanUrl), "san.com");
+
+    assert200Http2Response(execute(url), server.getHostName());
+
+    assertEquals(1, client.connectionPool().connectionCount());
+  }
+
+  /** Test a previously coalesced connection that's no longer healthy. */
+  @Test public void staleCoalescedConnection() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(200));
+    server.enqueue(new MockResponse().setResponseCode(200));
+
+    final AtomicReference<Connection> connection = new AtomicReference<>();
+    client = client.newBuilder()
+        .addNetworkInterceptor(new Interceptor() {
+          @Override public Response intercept(Chain chain) throws IOException {
+            connection.set(chain.connection());
+            return chain.proceed(chain.request());
+          }
+        })
+        .build();
+    dns.set("san.com", Dns.SYSTEM.lookup(server.getHostName()).subList(0, 1));
+
+    assert200Http2Response(execute(url), server.getHostName());
+
+    // Simulate a stale connection in the pool.
+    connection.get().socket().close();
+
+    HttpUrl sanUrl = url.newBuilder().host("san.com").build();
+    assert200Http2Response(execute(sanUrl), "san.com");
+
+    assertEquals(1, client.connectionPool().connectionCount());
+  }
+
+  /** If the existing connection matches a SAN but not a match for DNS then skip. */
+  @Test public void skipsWhenDnsDontMatch() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(200));
+
+    assert200Http2Response(execute(url), server.getHostName());
+
+    HttpUrl differentDnsUrl = url.newBuilder().host("differentdns.com").build();
+    try {
+      execute(differentDnsUrl);
+      fail("expected a failed attempt to connect");
+    } catch (IOException expected) {
+    }
+  }
+
+  /** Not in the certificate SAN. */
+  @Test public void skipsWhenNotSubjectAltName() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(200));
+
+    assert200Http2Response(execute(url), server.getHostName());
+
+    HttpUrl nonsanUrl = url.newBuilder().host("nonsan.com").build();
+
+    try {
+      execute(nonsanUrl);
+      fail("expected a failed attempt to connect");
+    } catch (IOException expected) {
+    }
+  }
+
+  /** Can still coalesce when pinning is used if pins match. */
+  @Test public void coalescesWhenCertificatePinsMatch() throws Exception {
+    CertificatePinner pinner = new CertificatePinner.Builder()
+        .add("san.com", "sha1/" + CertificatePinner.sha1(certificate.certificate).base64())
+        .build();
+    client = client.newBuilder().certificatePinner(pinner).build();
+
+    server.enqueue(new MockResponse().setResponseCode(200));
+    server.enqueue(new MockResponse().setResponseCode(200));
+
+    assert200Http2Response(execute(url), server.getHostName());
+
+    HttpUrl sanUrl = url.newBuilder().host("san.com").build();
+
+    assert200Http2Response(execute(sanUrl), "san.com");
+
+    assertEquals(1, client.connectionPool().connectionCount());
+  }
+
+  /** Certificate pinning used and not a match will avoid coalescing and try to connect. */
+  @Test public void skipsWhenCertificatePinningFails() throws Exception {
+    CertificatePinner pinner = new CertificatePinner.Builder()
+        .add("san.com", "sha1/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=")
+        .build();
+    client = client.newBuilder().certificatePinner(pinner).build();
+
+    server.enqueue(new MockResponse().setResponseCode(200));
+
+    assert200Http2Response(execute(url), server.getHostName());
+
+    HttpUrl sanUrl = url.newBuilder().host("san.com").build();
+
+    try {
+      execute(sanUrl);
+      fail("expected a failed attempt to connect");
+    } catch (IOException expected) {
+    }
+  }
+
+  /**
+   * Skips coalescing when hostname verifier is overridden since the intention of the hostname
+   * verification is a black box.
+   */
+  @Test public void skipsWhenHostnameVerifierUsed() throws Exception {
+    HostnameVerifier verifier = new HostnameVerifier() {
+      @Override public boolean verify(String s, SSLSession sslSession) {
+        return true;
+      }
+    };
+    client = client.newBuilder().hostnameVerifier(verifier).build();
+
+    server.enqueue(new MockResponse().setResponseCode(200));
+    server.enqueue(new MockResponse().setResponseCode(200));
+
+    assert200Http2Response(execute(url), server.getHostName());
+
+    HttpUrl sanUrl = url.newBuilder().host("san.com").build();
+
+    assert200Http2Response(execute(sanUrl), "san.com");
+
+    assertEquals(2, client.connectionPool().connectionCount());
+  }
+
+  /**
+   * Check we would use an existing connection to a later DNS result instead of connecting to the
+   * first DNS result for the first time.
+   */
+  @Test public void prefersExistingCompatible() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(200));
+    server.enqueue(new MockResponse().setResponseCode(200));
+
+    final AtomicInteger connectCount = new AtomicInteger();
+    EventListener listener = new EventListener() {
+      @Override public void connectStart(Call call, InetSocketAddress inetSocketAddress,
+          Proxy proxy) {
+        connectCount.getAndIncrement();
+      }
+    };
+    client = client.newBuilder()
+        .eventListener(listener)
+        .build();
+
+    assert200Http2Response(execute(url), server.getHostName());
+
+    HttpUrl sanUrl = url.newBuilder().host("san.com").build();
+    dns.set("san.com",
+        Arrays.asList(InetAddress.getByAddress("san.com", new byte[] {0, 0, 0, 0}),
+            serverIps.get(0)));
+    assert200Http2Response(execute(sanUrl), "san.com");
+
+    assertEquals(1, client.connectionPool().connectionCount());
+    assertEquals(1, connectCount.get());
+  }
+
+  /** Check that wildcard SANs are supported. */
+  @Test public void commonThenWildcard() throws Exception {
+
+    server.enqueue(new MockResponse().setResponseCode(200));
+    server.enqueue(new MockResponse().setResponseCode(200));
+
+    assert200Http2Response(execute(url), server.getHostName());
+
+    HttpUrl sanUrl = url.newBuilder().host("www.wildcard.com").build();
+    assert200Http2Response(execute(sanUrl), "www.wildcard.com");
+
+    assertEquals(1, client.connectionPool().connectionCount());
+  }
+
+  /** Network interceptors check for changes to target. */
+  @Test public void worksWithNetworkInterceptors() throws Exception {
+    client = client.newBuilder().addNetworkInterceptor(new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        return chain.proceed(chain.request());
+      }
+    }).build();
+
+    server.enqueue(new MockResponse().setResponseCode(200));
+    server.enqueue(new MockResponse().setResponseCode(200));
+
+    assert200Http2Response(execute(url), server.getHostName());
+
+    HttpUrl sanUrl = url.newBuilder().host("san.com").build();
+    assert200Http2Response(execute(sanUrl), "san.com");
+
+    assertEquals(1, client.connectionPool().connectionCount());
+  }
+
+  /** Run against public external sites, doesn't run by default. */
+  @Ignore
+  @Test public void coalescesConnectionsToRealSites() throws IOException {
+    client = new OkHttpClient();
+
+    assert200Http2Response(execute("https://graph.facebook.com/robots.txt"), "graph.facebook.com");
+    assert200Http2Response(execute("https://www.facebook.com/robots.txt"), "m.facebook.com");
+    assert200Http2Response(execute("https://fb.com/robots.txt"), "m.facebook.com");
+    assert200Http2Response(execute("https://messenger.com/robots.txt"), "messenger.com");
+    assert200Http2Response(execute("https://m.facebook.com/robots.txt"), "m.facebook.com");
+
+    assertEquals(3, client.connectionPool().connectionCount());
+  }
+
+  private Response execute(String url) throws IOException {
+    return execute(HttpUrl.parse(url));
+  }
+
+  private Response execute(HttpUrl url) throws IOException {
+    return client.newCall(new Request.Builder().url(url).build()).execute();
+  }
+
+  private void assert200Http2Response(Response response, String expectedHost) {
+    assertEquals(200, response.code());
+    assertEquals(expectedHost, response.request().url().host());
+    assertEquals(Protocol.HTTP_2, response.protocol());
+    response.body().close();
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/ConnectionPoolTest.java b/okhttp-tests/src/test/java/okhttp3/ConnectionPoolTest.java
index 84ebbc6824..ae8b0a2f6c 100644
--- a/okhttp-tests/src/test/java/okhttp3/ConnectionPoolTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/ConnectionPoolTest.java
@@ -24,10 +24,11 @@
 import javax.net.SocketFactory;
 import okhttp3.internal.Internal;
 import okhttp3.internal.RecordingOkAuthenticator;
-import okhttp3.internal.http.StreamAllocation;
-import okhttp3.internal.io.RealConnection;
+import okhttp3.internal.connection.RealConnection;
+import okhttp3.internal.connection.StreamAllocation;
 import org.junit.Test;
 
+import static okhttp3.TestUtil.awaitGarbageCollection;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
@@ -53,27 +54,27 @@
     // Running at time 50, the pool returns that nothing can be evicted until time 150.
     assertEquals(100L, pool.cleanup(50L));
     assertEquals(1, pool.connectionCount());
-    assertFalse(c1.socket.isClosed());
+    assertFalse(c1.socket().isClosed());
 
     // Running at time 60, the pool returns that nothing can be evicted until time 150.
     assertEquals(90L, pool.cleanup(60L));
     assertEquals(1, pool.connectionCount());
-    assertFalse(c1.socket.isClosed());
+    assertFalse(c1.socket().isClosed());
 
     // Running at time 149, the pool returns that nothing can be evicted until time 150.
     assertEquals(1L, pool.cleanup(149L));
     assertEquals(1, pool.connectionCount());
-    assertFalse(c1.socket.isClosed());
+    assertFalse(c1.socket().isClosed());
 
     // Running at time 150, the pool evicts.
     assertEquals(0, pool.cleanup(150L));
     assertEquals(0, pool.connectionCount());
-    assertTrue(c1.socket.isClosed());
+    assertTrue(c1.socket().isClosed());
 
     // Running again, the pool reports that no further runs are necessary.
     assertEquals(-1, pool.cleanup(150L));
     assertEquals(0, pool.connectionCount());
-    assertTrue(c1.socket.isClosed());
+    assertTrue(c1.socket().isClosed());
   }
 
   @Test public void inUseConnectionsNotEvicted() throws Exception {
@@ -81,23 +82,26 @@
     pool.cleanupRunning = true; // Prevent the cleanup runnable from being started.
 
     RealConnection c1 = newConnection(pool, routeA1, 50L);
-    StreamAllocation streamAllocation = new StreamAllocation(pool, addressA);
-    streamAllocation.acquire(c1);
+    synchronized (pool) {
+      StreamAllocation streamAllocation = new StreamAllocation(pool, addressA, null,
+          EventListener.NONE, null);
+      streamAllocation.acquire(c1, true);
+    }
 
     // Running at time 50, the pool returns that nothing can be evicted until time 150.
     assertEquals(100L, pool.cleanup(50L));
     assertEquals(1, pool.connectionCount());
-    assertFalse(c1.socket.isClosed());
+    assertFalse(c1.socket().isClosed());
 
     // Running at time 60, the pool returns that nothing can be evicted until time 160.
     assertEquals(100L, pool.cleanup(60L));
     assertEquals(1, pool.connectionCount());
-    assertFalse(c1.socket.isClosed());
+    assertFalse(c1.socket().isClosed());
 
     // Running at time 160, the pool returns that nothing can be evicted until time 260.
     assertEquals(100L, pool.cleanup(160L));
     assertEquals(1, pool.connectionCount());
-    assertFalse(c1.socket.isClosed());
+    assertFalse(c1.socket().isClosed());
   }
 
   @Test public void cleanupPrioritizesEarliestEviction() throws Exception {
@@ -118,8 +122,8 @@
     // Running at time 150, the pool evicts c2.
     assertEquals(0L, pool.cleanup(150L));
     assertEquals(1, pool.connectionCount());
-    assertFalse(c1.socket.isClosed());
-    assertTrue(c2.socket.isClosed());
+    assertFalse(c1.socket().isClosed());
+    assertTrue(c2.socket().isClosed());
 
     // Running at time 150, the pool returns that nothing can be evicted until time 175.
     assertEquals(25L, pool.cleanup(150L));
@@ -128,8 +132,8 @@
     // Running at time 175, the pool evicts c1.
     assertEquals(0L, pool.cleanup(175L));
     assertEquals(0, pool.connectionCount());
-    assertTrue(c1.socket.isClosed());
-    assertTrue(c2.socket.isClosed());
+    assertTrue(c1.socket().isClosed());
+    assertTrue(c2.socket().isClosed());
   }
 
   @Test public void oldestConnectionsEvictedIfIdleLimitExceeded() throws Exception {
@@ -142,8 +146,8 @@
     // With 2 connections, there's no need to evict until the connections time out.
     assertEquals(50L, pool.cleanup(100L));
     assertEquals(2, pool.connectionCount());
-    assertFalse(c1.socket.isClosed());
-    assertFalse(c2.socket.isClosed());
+    assertFalse(c1.socket().isClosed());
+    assertFalse(c2.socket().isClosed());
 
     // Add a third connection
     RealConnection c3 = newConnection(pool, routeC1, 75L);
@@ -151,9 +155,9 @@
     // The third connection bounces the first.
     assertEquals(0L, pool.cleanup(100L));
     assertEquals(2, pool.connectionCount());
-    assertTrue(c1.socket.isClosed());
-    assertFalse(c2.socket.isClosed());
-    assertFalse(c3.socket.isClosed());
+    assertTrue(c1.socket().isClosed());
+    assertFalse(c2.socket().isClosed());
+    assertFalse(c3.socket().isClosed());
   }
 
   @Test public void leakedAllocation() throws Exception {
@@ -172,29 +176,19 @@
 
   /** Use a helper method so there's no hidden reference remaining on the stack. */
   private void allocateAndLeakAllocation(ConnectionPool pool, RealConnection connection) {
-    StreamAllocation leak = new StreamAllocation(pool, connection.route().address());
-    leak.acquire(connection);
-  }
-
-  /**
-   * See FinalizationTester for discussion on how to best trigger GC in tests.
-   * https://android.googlesource.com/platform/libcore/+/master/support/src/test/java/libcore/
-   * java/lang/ref/FinalizationTester.java
-   */
-  private void awaitGarbageCollection() throws InterruptedException {
-    Runtime.getRuntime().gc();
-    Thread.sleep(100);
-    System.runFinalization();
+    synchronized (pool) {
+      StreamAllocation leak = new StreamAllocation(pool, connection.route().address(), null,
+          EventListener.NONE, null);
+      leak.acquire(connection, true);
+    }
   }
 
   private RealConnection newConnection(ConnectionPool pool, Route route, long idleAtNanos) {
-    RealConnection connection = new RealConnection(route);
-    connection.idleAtNanos = idleAtNanos;
-    connection.socket = new Socket();
+    RealConnection result = RealConnection.testConnection(pool, route, new Socket(), idleAtNanos);
     synchronized (pool) {
-      pool.put(connection);
+      pool.put(result);
     }
-    return connection;
+    return result;
   }
 
   private Address newAddress(String name) {
diff --git a/okhttp-tests/src/test/java/okhttp3/ConnectionReuseTest.java b/okhttp-tests/src/test/java/okhttp3/ConnectionReuseTest.java
index 5d45f0b721..533d8ab352 100644
--- a/okhttp-tests/src/test/java/okhttp3/ConnectionReuseTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/ConnectionReuseTest.java
@@ -15,12 +15,12 @@
  */
 package okhttp3;
 
+import java.io.Closeable;
 import java.io.IOException;
 import java.util.Arrays;
 import java.util.concurrent.TimeUnit;
-import javax.net.ssl.SSLContext;
+import java.util.concurrent.atomic.AtomicReference;
 import javax.net.ssl.SSLException;
-import javax.net.ssl.SSLSocketFactory;
 import okhttp3.internal.tls.SslClient;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
@@ -188,6 +188,9 @@
     assertEquals("a", responseA.body().string());
     assertEquals(0, server.takeRequest().getSequenceNumber());
 
+    // Give the socket a chance to become stale.
+    Thread.sleep(250);
+
     Request requestB = new Request.Builder()
         .url(server.url("/"))
         .post(RequestBody.create(MediaType.parse("text/plain"), "b"))
@@ -250,11 +253,9 @@
     response.body().close();
 
     // This client shares a connection pool but has a different SSL socket factory.
-    SSLContext sslContext2 = SSLContext.getInstance("TLS");
-    sslContext2.init(null, null, null);
-    SSLSocketFactory sslSocketFactory2 = sslContext2.getSocketFactory();
+    SslClient sslClient2 = new SslClient.Builder().build();
     OkHttpClient anotherClient = client.newBuilder()
-        .sslSocketFactory(sslSocketFactory2)
+        .sslSocketFactory(sslClient2.socketFactory, sslClient2.trustManager)
         .build();
 
     // This client fails to connect because the new SSL socket factory refuses.
@@ -295,6 +296,8 @@
    * them after the redirect has completed. This forces a connection to not be reused where it would
    * be otherwise.
    *
+   * <p>This test leaks a response body by not closing it.
+   *
    * https://github.com/square/okhttp/issues/2409
    */
   @Test public void connectionsAreNotReusedIfNetworkInterceptorInterferes() throws Exception {
@@ -317,8 +320,9 @@
     Request request = new Request.Builder()
         .url(server.url("/"))
         .build();
+    Call call = client.newCall(request);
     try {
-      client.newCall(request).execute();
+      call.execute();
       fail();
     } catch (IllegalStateException expected) {
       assertTrue(expected.getMessage().startsWith("Closing the body of"));
diff --git a/okhttp-tests/src/test/java/okhttp3/ConnectionSpecTest.java b/okhttp-tests/src/test/java/okhttp3/ConnectionSpecTest.java
index 7fbd08e628..c74a6b314c 100644
--- a/okhttp-tests/src/test/java/okhttp3/ConnectionSpecTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/ConnectionSpecTest.java
@@ -293,7 +293,7 @@
         .tlsVersions(TlsVersion.TLS_1_2)
         .cipherSuites(CipherSuite.TLS_RSA_WITH_RC4_128_MD5)
         .build();
-    assertEquals("ConnectionSpec(cipherSuites=[TLS_RSA_WITH_RC4_128_MD5], tlsVersions=[TLS_1_2], "
+    assertEquals("ConnectionSpec(cipherSuites=[SSL_RSA_WITH_RC4_128_MD5], tlsVersions=[TLS_1_2], "
         + "supportsTlsExtensions=true)", connectionSpec.toString());
   }
 
diff --git a/okhttp-tests/src/test/java/okhttp3/CookieTest.java b/okhttp-tests/src/test/java/okhttp3/CookieTest.java
index bee549dc7d..12f543fac0 100644
--- a/okhttp-tests/src/test/java/okhttp3/CookieTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CookieTest.java
@@ -27,6 +27,7 @@
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
@@ -50,6 +51,14 @@
     assertNull(Cookie.parse(url, "\r\t \n=b"));
   }
 
+  @Test public void spaceInName() throws Exception {
+    assertEquals("a b", Cookie.parse(url, "a b=cd").name());
+  }
+
+  @Test public void spaceInValue() throws Exception {
+    assertEquals("c d", Cookie.parse(url, "ab=c d").value());
+  }
+
   @Test public void trimLeadingAndTrailingWhitespaceFromName() throws Exception {
     assertEquals("a", Cookie.parse(url, " a=b").name());
     assertEquals("a", Cookie.parse(url, "a =b").name());
@@ -69,6 +78,23 @@
     assertEquals("b", Cookie.parse(url, "a=\r\t \nb\n\t \n").value());
   }
 
+  @Test public void invalidCharacters() throws Exception {
+    assertEquals(null, Cookie.parse(url, "a\u0000b=cd"));
+    assertEquals(null, Cookie.parse(url, "ab=c\u0000d"));
+    assertEquals(null, Cookie.parse(url, "a\u0001b=cd"));
+    assertEquals(null, Cookie.parse(url, "ab=c\u0001d"));
+    assertEquals(null, Cookie.parse(url, "a\u0009b=cd"));
+    assertEquals(null, Cookie.parse(url, "ab=c\u0009d"));
+    assertEquals(null, Cookie.parse(url, "a\u001fb=cd"));
+    assertEquals(null, Cookie.parse(url, "ab=c\u001fd"));
+    assertEquals(null, Cookie.parse(url, "a\u007fb=cd"));
+    assertEquals(null, Cookie.parse(url, "ab=c\u007fd"));
+    assertEquals(null, Cookie.parse(url, "a\u0080b=cd"));
+    assertEquals(null, Cookie.parse(url, "ab=c\u0080d"));
+    assertEquals(null, Cookie.parse(url, "a\u00ffb=cd"));
+    assertEquals(null, Cookie.parse(url, "ab=c\u00ffd"));
+  }
+
   @Test public void maxAge() throws Exception {
     assertEquals(51000L,
         Cookie.parse(50000L, url, "a=b; Max-Age=1").expiresAt());
@@ -241,6 +267,55 @@
     assertEquals("123.45.234.56", Cookie.parse(urlWithIp, "a=b; domain=123.45.234.56").domain());
   }
 
+  @Test public void domainMatchesIpv6Address() throws Exception {
+    Cookie cookie = Cookie.parse(HttpUrl.parse("http://[::1]/"), "a=b; domain=::1");
+    assertEquals("::1", cookie.domain());
+    assertTrue(cookie.matches(HttpUrl.parse("http://[::1]/")));
+  }
+
+  @Test public void domainMatchesIpv6AddressWithCompression() throws Exception {
+    Cookie cookie = Cookie.parse(HttpUrl.parse("http://[0001:0000::]/"), "a=b; domain=0001:0000::");
+    assertEquals("1::", cookie.domain());
+    assertTrue(cookie.matches(HttpUrl.parse("http://[1::]/")));
+  }
+
+  @Test public void domainMatchesIpv6AddressWithIpv4Suffix() throws Exception {
+    Cookie cookie = Cookie.parse(
+        HttpUrl.parse("http://[::1:ffff:ffff]/"), "a=b; domain=::1:255.255.255.255");
+    assertEquals("::1:ffff:ffff", cookie.domain());
+    assertTrue(cookie.matches(HttpUrl.parse("http://[::1:ffff:ffff]/")));
+  }
+
+  @Test public void ipv6AddressDoesntMatch() throws Exception {
+    Cookie cookie = Cookie.parse(HttpUrl.parse("http://[::1]/"), "a=b; domain=::2");
+    assertNull(cookie);
+  }
+
+  @Test public void ipv6AddressMalformed() throws Exception {
+    Cookie cookie = Cookie.parse(HttpUrl.parse("http://[::1]/"), "a=b; domain=::2::2");
+    assertEquals("::1", cookie.domain());
+  }
+
+  /**
+   * These public suffixes were selected by inspecting the publicsuffix.org list. It's possible they
+   * may change in the future. If this test begins to fail, please double check they are still
+   * present in the public suffix list.
+   */
+  @Test public void domainIsPublicSuffix() {
+    HttpUrl ascii = HttpUrl.parse("https://foo1.foo.bar.elb.amazonaws.com");
+    assertNotNull(Cookie.parse(ascii, "a=b; domain=foo.bar.elb.amazonaws.com"));
+    assertNull(Cookie.parse(ascii, "a=b; domain=bar.elb.amazonaws.com"));
+    assertNull(Cookie.parse(ascii, "a=b; domain=com"));
+
+    HttpUrl unicode = HttpUrl.parse("https://長.長.長崎.jp");
+    assertNotNull(Cookie.parse(unicode, "a=b; domain=長.長崎.jp"));
+    assertNull(Cookie.parse(unicode, "a=b; domain=長崎.jp"));
+
+    HttpUrl punycode = HttpUrl.parse("https://xn--ue5a.xn--ue5a.xn--8ltr62k.jp");
+    assertNotNull(Cookie.parse(punycode, "a=b; domain=xn--ue5a.xn--8ltr62k.jp"));
+    assertNull(Cookie.parse(punycode, "a=b; domain=xn--8ltr62k.jp"));
+  }
+
   @Test public void hostOnly() throws Exception {
     assertTrue(Cookie.parse(url, "a=b").hostOnly());
     assertFalse(Cookie.parse(url, "a=b; domain=example.com").hostOnly());
@@ -461,6 +536,15 @@
     assertEquals(true, cookie.httpOnly());
   }
 
+  @Test public void builderIpv6() throws Exception {
+    Cookie cookie = new Cookie.Builder()
+        .name("a")
+        .value("b")
+        .domain("0:0:0:0:0:0:0:1")
+        .build();
+    assertEquals("::1", cookie.domain());
+  }
+
   @Test public void equalsAndHashCode() throws Exception {
     List<String> cookieStrings = Arrays.asList(
         "a=b; Path=/c; Domain=example.com; Max-Age=5; Secure; HttpOnly",
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/CookiesTest.java b/okhttp-tests/src/test/java/okhttp3/CookiesTest.java
similarity index 80%
rename from okhttp-tests/src/test/java/okhttp3/internal/http/CookiesTest.java
rename to okhttp-tests/src/test/java/okhttp3/CookiesTest.java
index bf01f36fac..ab2a955273 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http/CookiesTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CookiesTest.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package okhttp3.internal.http;
+package okhttp3;
 
 import java.io.IOException;
 import java.net.CookieHandler;
@@ -23,16 +23,11 @@
 import java.net.HttpURLConnection;
 import java.net.InetAddress;
 import java.net.URI;
+import java.util.Arrays;
 import java.util.Collections;
-import java.util.HashMap;
+import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
-import okhttp3.Call;
-import okhttp3.HttpUrl;
-import okhttp3.JavaNetCookieJar;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.Response;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.RecordedRequest;
@@ -257,7 +252,7 @@ public void testNetscapeResponse() throws Exception {
         .cookieJar(new JavaNetCookieJar(new CookieManager() {
           @Override public Map<String, List<String>> get(URI uri,
               Map<String, List<String>> requestHeaders) throws IOException {
-            Map<String, List<String>> result = new HashMap<>();
+            Map<String, List<String>> result = new LinkedHashMap<>();
             result.put("COOKIE", Collections.singletonList("Bar=bar"));
             result.put("cooKIE2", Collections.singletonList("Baz=baz"));
             return result;
@@ -277,6 +272,58 @@ public void testNetscapeResponse() throws Exception {
     assertNull(request.getHeader("Quux"));
   }
 
+  @Test public void acceptOriginalServerMatchesSubdomain() throws Exception {
+    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
+    JavaNetCookieJar cookieJar = new JavaNetCookieJar(cookieManager);
+
+    HttpUrl url = HttpUrl.parse("https://www.squareup.com/");
+    cookieJar.saveFromResponse(url, Arrays.asList(
+        Cookie.parse(url, "a=android; Domain=squareup.com")));
+    List<Cookie> actualCookies = cookieJar.loadForRequest(url);
+    assertEquals(1, actualCookies.size());
+    assertEquals("a", actualCookies.get(0).name());
+    assertEquals("android", actualCookies.get(0).value());
+  }
+
+  @Test public void acceptOriginalServerMatchesRfc2965Dot() throws Exception {
+    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
+    JavaNetCookieJar cookieJar = new JavaNetCookieJar(cookieManager);
+
+    HttpUrl url = HttpUrl.parse("https://www.squareup.com/");
+    cookieJar.saveFromResponse(url, Arrays.asList(
+        Cookie.parse(url, "a=android; Domain=.squareup.com")));
+    List<Cookie> actualCookies = cookieJar.loadForRequest(url);
+    assertEquals(1, actualCookies.size());
+    assertEquals("a", actualCookies.get(0).name());
+    assertEquals("android", actualCookies.get(0).value());
+  }
+
+  @Test public void acceptOriginalServerMatchesExactly() throws Exception {
+    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
+    JavaNetCookieJar cookieJar = new JavaNetCookieJar(cookieManager);
+
+    HttpUrl url = HttpUrl.parse("https://squareup.com/");
+    cookieJar.saveFromResponse(url, Arrays.asList(
+        Cookie.parse(url, "a=android; Domain=squareup.com")));
+    List<Cookie> actualCookies = cookieJar.loadForRequest(url);
+    assertEquals(1, actualCookies.size());
+    assertEquals("a", actualCookies.get(0).name());
+    assertEquals("android", actualCookies.get(0).value());
+  }
+
+  @Test public void acceptOriginalServerDoesNotMatchDifferentServer() throws Exception {
+    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
+    JavaNetCookieJar cookieJar = new JavaNetCookieJar(cookieManager);
+
+    HttpUrl url1 = HttpUrl.parse("https://api.squareup.com/");
+    cookieJar.saveFromResponse(url1, Arrays.asList(
+        Cookie.parse(url1, "a=android; Domain=api.squareup.com")));
+
+    HttpUrl url2 = HttpUrl.parse("https://www.squareup.com/");
+    List<Cookie> actualCookies = cookieJar.loadForRequest(url2);
+    assertEquals(Collections.<Cookie>emptyList(), actualCookies);
+  }
+
   private HttpUrl urlWithIpAddress(MockWebServer server, String path) throws Exception {
     return server.url(path)
         .newBuilder()
diff --git a/okhttp-tests/src/test/java/okhttp3/DelegatingSSLSocketFactory.java b/okhttp-tests/src/test/java/okhttp3/DelegatingSSLSocketFactory.java
index 5a14d0fbd6..5a5a3dc20a 100644
--- a/okhttp-tests/src/test/java/okhttp3/DelegatingSSLSocketFactory.java
+++ b/okhttp-tests/src/test/java/okhttp3/DelegatingSSLSocketFactory.java
@@ -18,7 +18,6 @@
 import java.io.IOException;
 import java.net.InetAddress;
 import java.net.Socket;
-import java.net.UnknownHostException;
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
 
diff --git a/okhttp-tests/src/test/java/okhttp3/DelegatingSocketFactory.java b/okhttp-tests/src/test/java/okhttp3/DelegatingSocketFactory.java
index d21f37a31a..33ac2f4e1a 100644
--- a/okhttp-tests/src/test/java/okhttp3/DelegatingSocketFactory.java
+++ b/okhttp-tests/src/test/java/okhttp3/DelegatingSocketFactory.java
@@ -18,7 +18,6 @@
 import java.io.IOException;
 import java.net.InetAddress;
 import java.net.Socket;
-import java.net.UnknownHostException;
 import javax.net.SocketFactory;
 
 /**
@@ -26,41 +25,35 @@
  * overriding {@link #configureSocket(java.net.Socket)}.
  */
 public class DelegatingSocketFactory extends SocketFactory {
-
   private final SocketFactory delegate;
 
   public DelegatingSocketFactory(SocketFactory delegate) {
     this.delegate = delegate;
   }
 
-  @Override
-  public Socket createSocket() throws IOException {
+  @Override public Socket createSocket() throws IOException {
     Socket socket = delegate.createSocket();
     return configureSocket(socket);
   }
 
-  @Override
-  public Socket createSocket(String host, int port) throws IOException, UnknownHostException {
+  @Override public Socket createSocket(String host, int port) throws IOException {
     Socket socket = delegate.createSocket(host, port);
     return configureSocket(socket);
   }
 
-  @Override
-  public Socket createSocket(String host, int port, InetAddress localAddress, int localPort)
-      throws IOException, UnknownHostException {
+  @Override public Socket createSocket(String host, int port, InetAddress localAddress,
+      int localPort) throws IOException {
     Socket socket = delegate.createSocket(host, port, localAddress, localPort);
     return configureSocket(socket);
   }
 
-  @Override
-  public Socket createSocket(InetAddress host, int port) throws IOException {
+  @Override public Socket createSocket(InetAddress host, int port) throws IOException {
     Socket socket = delegate.createSocket(host, port);
     return configureSocket(socket);
   }
 
-  @Override
-  public Socket createSocket(InetAddress host, int port, InetAddress localAddress, int localPort)
-      throws IOException {
+  @Override public Socket createSocket(InetAddress host, int port, InetAddress localAddress,
+      int localPort) throws IOException {
     Socket socket = delegate.createSocket(host, port, localAddress, localPort);
     return configureSocket(socket);
   }
diff --git a/okhttp-tests/src/test/java/okhttp3/DispatcherTest.java b/okhttp-tests/src/test/java/okhttp3/DispatcherTest.java
index 6c04901464..e4896a94d1 100644
--- a/okhttp-tests/src/test/java/okhttp3/DispatcherTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/DispatcherTest.java
@@ -1,7 +1,6 @@
 package okhttp3;
 
 import java.io.IOException;
-import java.io.InterruptedIOException;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
@@ -18,6 +17,7 @@
 import org.junit.Test;
 
 import static java.util.concurrent.TimeUnit.SECONDS;
+import static okhttp3.TestUtil.defaultClient;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
@@ -27,7 +27,7 @@
   RecordingExecutor executor = new RecordingExecutor();
   RecordingCallback callback = new RecordingCallback();
   Dispatcher dispatcher = new Dispatcher(executor);
-  OkHttpClient client = new OkHttpClient.Builder()
+  OkHttpClient client = defaultClient().newBuilder()
       .dispatcher(dispatcher)
       .build();
 
diff --git a/okhttp-tests/src/test/java/okhttp3/EventListenerTest.java b/okhttp-tests/src/test/java/okhttp3/EventListenerTest.java
new file mode 100644
index 0000000000..07f0ca694c
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/EventListenerTest.java
@@ -0,0 +1,1034 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.Proxy;
+import java.net.UnknownHostException;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import javax.annotation.Nullable;
+import okhttp3.RecordingEventListener.CallEnd;
+import okhttp3.RecordingEventListener.CallFailed;
+import okhttp3.RecordingEventListener.ConnectEnd;
+import okhttp3.RecordingEventListener.ConnectFailed;
+import okhttp3.RecordingEventListener.ConnectStart;
+import okhttp3.RecordingEventListener.ConnectionAcquired;
+import okhttp3.RecordingEventListener.DnsEnd;
+import okhttp3.RecordingEventListener.DnsStart;
+import okhttp3.RecordingEventListener.RequestBodyEnd;
+import okhttp3.RecordingEventListener.RequestHeadersEnd;
+import okhttp3.RecordingEventListener.ResponseBodyEnd;
+import okhttp3.RecordingEventListener.ResponseHeadersEnd;
+import okhttp3.RecordingEventListener.SecureConnectEnd;
+import okhttp3.RecordingEventListener.SecureConnectStart;
+import okhttp3.internal.DoubleInetAddressDns;
+import okhttp3.internal.RecordingOkAuthenticator;
+import okhttp3.internal.SingleInetAddressDns;
+import okhttp3.internal.tls.SslClient;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.SocketPolicy;
+import okio.Buffer;
+import okio.BufferedSink;
+import org.hamcrest.BaseMatcher;
+import org.hamcrest.CoreMatchers;
+import org.hamcrest.Description;
+import org.hamcrest.Matcher;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Rule;
+import org.junit.Test;
+
+import static java.util.Arrays.asList;
+import static okhttp3.TestUtil.defaultClient;
+import static org.hamcrest.CoreMatchers.any;
+import static org.hamcrest.CoreMatchers.either;
+import static org.hamcrest.CoreMatchers.equalTo;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertThat;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+import static org.junit.Assume.assumeThat;
+
+public final class EventListenerTest {
+  public static final Matcher<Response> anyResponse = CoreMatchers.any(Response.class);
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private final SingleInetAddressDns singleDns = new SingleInetAddressDns();
+  private final RecordingEventListener listener = new RecordingEventListener();
+  private final SslClient sslClient = SslClient.localhost();
+
+  private OkHttpClient client;
+  private SocksProxy socksProxy;
+
+  @Before public void setUp() throws IOException {
+    client = defaultClient().newBuilder()
+        .dns(singleDns)
+        .eventListener(listener)
+        .build();
+
+    listener.forbidLock(client.connectionPool());
+    listener.forbidLock(client.dispatcher());
+  }
+
+  @After public void tearDown() throws Exception {
+    if (socksProxy != null) {
+      socksProxy.shutdown();
+    }
+  }
+
+  @Test public void successfulCallEventSequence() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("abc"));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals(200, response.code());
+    assertEquals("abc", response.body().string());
+    response.body().close();
+
+    List<String> expectedEvents = Arrays.asList("CallStart", "DnsStart", "DnsEnd",
+        "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
+        "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
+        "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
+    assertEquals(expectedEvents, listener.recordedEventTypes());
+  }
+
+  @Test public void successfulCallEventSequenceForEnqueue() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("abc"));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+
+    final CountDownLatch completionLatch = new CountDownLatch(1);
+    Callback callback = new Callback() {
+      @Override public void onFailure(Call call, IOException e) {
+        completionLatch.countDown();
+      }
+
+      @Override public void onResponse(Call call, Response response) throws IOException {
+        response.close();
+        completionLatch.countDown();
+      }
+    };
+
+    call.enqueue(callback);
+
+    completionLatch.await();
+
+    List<String> expectedEvents = Arrays.asList("CallStart", "DnsStart", "DnsEnd",
+        "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
+        "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
+        "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
+    assertEquals(expectedEvents, listener.recordedEventTypes());
+  }
+
+  @Test public void failedCallEventSequence() throws IOException {
+    server.enqueue(new MockResponse().setBodyDelay(2, TimeUnit.SECONDS));
+
+    client = client.newBuilder().readTimeout(250, TimeUnit.MILLISECONDS).build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    try {
+      call.execute();
+      fail();
+    } catch (IOException expected) {
+      assertThat(expected.getMessage(), either(equalTo("timeout")).or(equalTo("Read timed out")));
+    }
+
+    List<String> expectedEvents = Arrays.asList("CallStart", "DnsStart", "DnsEnd",
+        "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
+        "RequestHeadersEnd", "ResponseHeadersStart", "ConnectionReleased", "CallFailed");
+    assertEquals(expectedEvents, listener.recordedEventTypes());
+  }
+
+  @Test public void canceledCallEventSequence() throws IOException {
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    call.cancel();
+    try {
+      call.execute();
+      fail();
+    } catch (IOException expected) {
+      assertEquals("Canceled", expected.getMessage());
+    }
+
+    List<String> expectedEvents = Arrays.asList("CallStart", "CallFailed");
+    assertEquals(expectedEvents, listener.recordedEventTypes());
+  }
+
+  private void assertSuccessfulEventOrder(Matcher<Response> responseMatcher) throws IOException {
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals(200, response.code());
+    response.body().string();
+    response.body().close();
+
+    assumeThat(response, responseMatcher);
+
+    List<String> expectedEvents = asList("CallStart", "DnsStart", "DnsEnd", "ConnectStart",
+        "SecureConnectStart", "SecureConnectEnd", "ConnectEnd", "ConnectionAcquired",
+        "RequestHeadersStart", "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd",
+        "ResponseBodyStart", "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
+
+    assertEquals(expectedEvents, listener.recordedEventTypes());
+  }
+
+  @Test public void secondCallEventSequence() throws IOException {
+    enableTlsWithTunnel(false);
+    server.setProtocols(Arrays.asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
+    server.enqueue(new MockResponse());
+    server.enqueue(new MockResponse());
+
+    client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build()).execute().close();
+
+    listener.removeUpToEvent(CallEnd.class);
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    response.close();
+
+    List<String> expectedEvents = asList("CallStart", "ConnectionAcquired",
+        "RequestHeadersStart", "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd",
+        "ResponseBodyStart", "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
+
+    assertEquals(expectedEvents, listener.recordedEventTypes());
+  }
+
+  private void assertBytesReadWritten(RecordingEventListener listener,
+      @Nullable Matcher<Long> requestHeaderLength, @Nullable Matcher<Long> requestBodyBytes,
+      @Nullable Matcher<Long> responseHeaderLength, @Nullable Matcher<Long> responseBodyBytes) {
+
+    if (requestHeaderLength != null) {
+      RequestHeadersEnd responseHeadersEnd = listener.removeUpToEvent(RequestHeadersEnd.class);
+      assertThat("request header length", responseHeadersEnd.headerLength, requestHeaderLength);
+    } else {
+      assertFalse("Found RequestHeadersEnd",
+          listener.recordedEventTypes().contains("RequestHeadersEnd"));
+    }
+
+    if (requestBodyBytes != null) {
+      RequestBodyEnd responseBodyEnd = listener.removeUpToEvent(RequestBodyEnd.class);
+      assertThat("request body bytes", responseBodyEnd.bytesWritten, requestBodyBytes);
+    } else {
+      assertFalse("Found RequestBodyEnd", listener.recordedEventTypes().contains("RequestBodyEnd"));
+    }
+
+    if (responseHeaderLength != null) {
+      ResponseHeadersEnd responseHeadersEnd = listener.removeUpToEvent(ResponseHeadersEnd.class);
+      assertThat("response header length", responseHeadersEnd.headerLength, responseHeaderLength);
+    } else {
+      assertFalse("Found ResponseHeadersEnd",
+          listener.recordedEventTypes().contains("ResponseHeadersEnd"));
+    }
+
+    if (responseBodyBytes != null) {
+      ResponseBodyEnd responseBodyEnd = listener.removeUpToEvent(ResponseBodyEnd.class);
+      assertThat("response body bytes", responseBodyEnd.bytesRead, responseBodyBytes);
+    } else {
+      assertFalse("Found ResponseBodyEnd",
+          listener.recordedEventTypes().contains("ResponseBodyEnd"));
+    }
+  }
+
+  private Matcher<Long> greaterThan(final long value) {
+    return new BaseMatcher<Long>() {
+      @Override public void describeTo(Description description) {
+        description.appendText("> " + value);
+      }
+
+      @Override public boolean matches(Object o) {
+        return ((Long)o) > value;
+      }
+    };
+  }
+
+  private Matcher<Long> lessThan(final long value) {
+    return new BaseMatcher<Long>() {
+      @Override public void describeTo(Description description) {
+        description.appendText("< " + value);
+      }
+
+      @Override public boolean matches(Object o) {
+        return ((Long)o) < value;
+      }
+    };
+  }
+
+  private Matcher<Response> matchesProtocol(final Protocol protocol) {
+    return new BaseMatcher<Response>() {
+      @Override public void describeTo(Description description) {
+        description.appendText("is HTTP/2");
+      }
+
+      @Override public boolean matches(Object o) {
+        return ((Response)o).protocol == protocol;
+      }
+    };
+  }
+
+  @Test public void successfulEmptyH2CallEventSequence() throws IOException {
+    enableTlsWithTunnel(false);
+    server.setProtocols(Arrays.asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
+    server.enqueue(new MockResponse());
+
+    assertSuccessfulEventOrder(matchesProtocol(Protocol.HTTP_2));
+
+    assertBytesReadWritten(listener, any(Long.class), null, greaterThan(0L),
+        equalTo(0L));
+  }
+
+  @Test public void successfulEmptyHttpsCallEventSequence() throws IOException {
+    enableTlsWithTunnel(false);
+    server.setProtocols(Arrays.asList(Protocol.HTTP_1_1));
+    server.enqueue(new MockResponse()
+        .setBody("abc"));
+
+    assertSuccessfulEventOrder(anyResponse);
+
+    assertBytesReadWritten(listener, any(Long.class), null, greaterThan(0L),
+        equalTo(3L));
+  }
+
+  @Test public void successfulChunkedHttpsCallEventSequence() throws IOException {
+    enableTlsWithTunnel(false);
+    server.setProtocols(Arrays.asList(Protocol.HTTP_1_1));
+    server.enqueue(
+        new MockResponse().setBodyDelay(100, TimeUnit.MILLISECONDS).setChunkedBody("Hello!", 2));
+
+    assertSuccessfulEventOrder(anyResponse);
+
+    assertBytesReadWritten(listener, any(Long.class), null, greaterThan(0L),
+        equalTo(6L));
+  }
+
+  @Test public void successfulChunkedH2CallEventSequence() throws IOException {
+    enableTlsWithTunnel(false);
+    server.setProtocols(Arrays.asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
+    server.enqueue(
+        new MockResponse().setBodyDelay(100, TimeUnit.MILLISECONDS).setChunkedBody("Hello!", 2));
+
+    assertSuccessfulEventOrder(matchesProtocol(Protocol.HTTP_2));
+
+    assertBytesReadWritten(listener, any(Long.class), null, equalTo(0L),
+        greaterThan(6L));
+  }
+
+  @Test public void successfulDnsLookup() throws IOException {
+    server.enqueue(new MockResponse());
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals(200, response.code());
+    response.body().close();
+
+    DnsStart dnsStart = listener.removeUpToEvent(DnsStart.class);
+    assertSame(call, dnsStart.call);
+    assertEquals(server.getHostName(), dnsStart.domainName);
+
+    DnsEnd dnsEnd = listener.removeUpToEvent(DnsEnd.class);
+    assertSame(call, dnsEnd.call);
+    assertEquals(server.getHostName(), dnsEnd.domainName);
+    assertEquals(1, dnsEnd.inetAddressList.size());
+  }
+
+  @Test public void noDnsLookupOnPooledConnection() throws IOException {
+    server.enqueue(new MockResponse());
+    server.enqueue(new MockResponse());
+
+    // Seed the pool.
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response1 = call1.execute();
+    assertEquals(200, response1.code());
+    response1.body().close();
+
+    listener.clearAllEvents();
+
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+    assertEquals(200, response2.code());
+    response2.body().close();
+
+    List<String> recordedEvents = listener.recordedEventTypes();
+    assertFalse(recordedEvents.contains("DnsStart"));
+    assertFalse(recordedEvents.contains("DnsEnd"));
+  }
+
+  @Test public void multipleDnsLookupsForSingleCall() throws IOException {
+    server.enqueue(new MockResponse()
+        .setResponseCode(301)
+        .setHeader("Location", "http://www.fakeurl:" + server.getPort()));
+    server.enqueue(new MockResponse());
+
+    FakeDns dns = new FakeDns();
+    dns.set("fakeurl", singleDns.lookup(server.getHostName()));
+    dns.set("www.fakeurl", singleDns.lookup(server.getHostName()));
+
+    client = client.newBuilder()
+        .dns(dns)
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url("http://fakeurl:" + server.getPort())
+        .build());
+    Response response = call.execute();
+    assertEquals(200, response.code());
+    response.body().close();
+
+    listener.removeUpToEvent(DnsStart.class);
+    listener.removeUpToEvent(DnsEnd.class);
+    listener.removeUpToEvent(DnsStart.class);
+    listener.removeUpToEvent(DnsEnd.class);
+  }
+
+  @Test public void failedDnsLookup() {
+    client = client.newBuilder()
+        .dns(new FakeDns())
+        .build();
+    Call call = client.newCall(new Request.Builder()
+        .url("http://fakeurl/")
+        .build());
+    try {
+      call.execute();
+      fail();
+    } catch (IOException expected) {
+    }
+
+    listener.removeUpToEvent(DnsStart.class);
+
+    CallFailed callFailed = listener.removeUpToEvent(CallFailed.class);
+    assertSame(call, callFailed.call);
+    assertTrue(callFailed.ioe instanceof UnknownHostException);
+  }
+
+  @Test public void emptyDnsLookup() {
+    Dns emptyDns = new Dns() {
+      @Override public List<InetAddress> lookup(String hostname) throws UnknownHostException {
+        return Collections.emptyList();
+      }
+    };
+
+    client = client.newBuilder()
+        .dns(emptyDns)
+        .build();
+    Call call = client.newCall(new Request.Builder()
+        .url("http://fakeurl/")
+        .build());
+    try {
+      call.execute();
+      fail();
+    } catch (IOException expected) {
+    }
+
+    listener.removeUpToEvent(DnsStart.class);
+
+    CallFailed callFailed = listener.removeUpToEvent(CallFailed.class);
+    assertSame(call, callFailed.call);
+    assertTrue(callFailed.ioe instanceof UnknownHostException);
+  }
+
+  @Test public void successfulConnect() throws IOException {
+    server.enqueue(new MockResponse());
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals(200, response.code());
+    response.body().close();
+
+    InetAddress address = singleDns.lookup(server.getHostName()).get(0);
+    InetSocketAddress expectedAddress = new InetSocketAddress(address, server.getPort());
+
+    ConnectStart connectStart = listener.removeUpToEvent(ConnectStart.class);
+    assertSame(call, connectStart.call);
+    assertEquals(expectedAddress, connectStart.inetSocketAddress);
+    assertEquals(Proxy.NO_PROXY, connectStart.proxy);
+
+    ConnectEnd connectEnd = listener.removeUpToEvent(ConnectEnd.class);
+    assertSame(call, connectEnd.call);
+    assertEquals(expectedAddress, connectEnd.inetSocketAddress);
+    assertEquals(Protocol.HTTP_1_1, connectEnd.protocol);
+  }
+
+  @Test public void failedConnect() throws UnknownHostException {
+    enableTlsWithTunnel(false);
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    try {
+      call.execute();
+      fail();
+    } catch (IOException expected) {
+    }
+
+    InetAddress address = singleDns.lookup(server.getHostName()).get(0);
+    InetSocketAddress expectedAddress = new InetSocketAddress(address, server.getPort());
+
+    ConnectStart connectStart = listener.removeUpToEvent(ConnectStart.class);
+    assertSame(call, connectStart.call);
+    assertEquals(expectedAddress, connectStart.inetSocketAddress);
+    assertEquals(Proxy.NO_PROXY, connectStart.proxy);
+
+    ConnectFailed connectFailed = listener.removeUpToEvent(ConnectFailed.class);
+    assertSame(call, connectFailed.call);
+    assertEquals(expectedAddress, connectFailed.inetSocketAddress);
+    assertNull(connectFailed.protocol);
+    assertNotNull(connectFailed.ioe);
+  }
+
+  @Test public void multipleConnectsForSingleCall() throws IOException {
+    enableTlsWithTunnel(false);
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
+    server.enqueue(new MockResponse());
+
+    client = client.newBuilder()
+        .dns(new DoubleInetAddressDns())
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals(200, response.code());
+    response.body().close();
+
+    listener.removeUpToEvent(ConnectStart.class);
+    listener.removeUpToEvent(ConnectFailed.class);
+    listener.removeUpToEvent(ConnectStart.class);
+    listener.removeUpToEvent(ConnectEnd.class);
+  }
+
+  @Test public void successfulHttpProxyConnect() throws IOException {
+    server.enqueue(new MockResponse());
+
+    client = client.newBuilder()
+        .proxy(server.toProxyAddress())
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url("http://www.fakeurl")
+        .build());
+    Response response = call.execute();
+    assertEquals(200, response.code());
+    response.body().close();
+
+    InetAddress address = singleDns.lookup(server.getHostName()).get(0);
+    InetSocketAddress expectedAddress = new InetSocketAddress(address, server.getPort());
+
+    ConnectStart connectStart = listener.removeUpToEvent(ConnectStart.class);
+    assertSame(call, connectStart.call);
+    assertEquals(expectedAddress, connectStart.inetSocketAddress);
+    assertEquals(server.toProxyAddress(), connectStart.proxy);
+
+    ConnectEnd connectEnd = listener.removeUpToEvent(ConnectEnd.class);
+    assertSame(call, connectEnd.call);
+    assertEquals(expectedAddress, connectEnd.inetSocketAddress);
+    assertEquals(Protocol.HTTP_1_1, connectEnd.protocol);
+  }
+
+  @Test public void successfulSocksProxyConnect() throws Exception {
+    server.enqueue(new MockResponse());
+
+    socksProxy = new SocksProxy();
+    socksProxy.play();
+    Proxy proxy = socksProxy.proxy();
+
+    client = client.newBuilder()
+        .proxy(proxy)
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url("http://" + SocksProxy.HOSTNAME_THAT_ONLY_THE_PROXY_KNOWS + ":" + server.getPort())
+        .build());
+    Response response = call.execute();
+    assertEquals(200, response.code());
+    response.body().close();
+
+    InetSocketAddress expectedAddress = InetSocketAddress.createUnresolved(
+        SocksProxy.HOSTNAME_THAT_ONLY_THE_PROXY_KNOWS, server.getPort());
+
+    ConnectStart connectStart = listener.removeUpToEvent(ConnectStart.class);
+    assertSame(call, connectStart.call);
+    assertEquals(expectedAddress, connectStart.inetSocketAddress);
+    assertEquals(proxy, connectStart.proxy);
+
+    ConnectEnd connectEnd = listener.removeUpToEvent(ConnectEnd.class);
+    assertSame(call, connectEnd.call);
+    assertEquals(expectedAddress, connectEnd.inetSocketAddress);
+    assertEquals(Protocol.HTTP_1_1, connectEnd.protocol);
+  }
+
+  @Test public void authenticatingTunnelProxyConnect() throws IOException {
+    enableTlsWithTunnel(true);
+    server.enqueue(new MockResponse()
+        .setResponseCode(407)
+        .addHeader("Proxy-Authenticate: Basic realm=\"localhost\"")
+        .addHeader("Connection: close"));
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END));
+    server.enqueue(new MockResponse());
+
+    client = client.newBuilder()
+        .proxy(server.toProxyAddress())
+        .proxyAuthenticator(new RecordingOkAuthenticator("password"))
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals(200, response.code());
+    response.body().close();
+
+    listener.removeUpToEvent(ConnectStart.class);
+
+    ConnectEnd connectEnd = listener.removeUpToEvent(ConnectEnd.class);
+    assertNull(connectEnd.protocol);
+
+    listener.removeUpToEvent(ConnectStart.class);
+    listener.removeUpToEvent(ConnectEnd.class);
+  }
+
+  @Test public void successfulSecureConnect() throws IOException {
+    enableTlsWithTunnel(false);
+    server.enqueue(new MockResponse());
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals(200, response.code());
+    response.body().close();
+
+    SecureConnectStart secureStart = listener.removeUpToEvent(SecureConnectStart.class);
+    assertSame(call, secureStart.call);
+
+    SecureConnectEnd secureEnd = listener.removeUpToEvent(SecureConnectEnd.class);
+    assertSame(call, secureEnd.call);
+    assertNotNull(secureEnd.handshake);
+  }
+
+  @Test public void failedSecureConnect() {
+    enableTlsWithTunnel(false);
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    try {
+      call.execute();
+      fail();
+    } catch (IOException expected) {
+    }
+
+    SecureConnectStart secureStart = listener.removeUpToEvent(SecureConnectStart.class);
+    assertSame(call, secureStart.call);
+
+    CallFailed callFailed = listener.removeUpToEvent(CallFailed.class);
+    assertSame(call, callFailed.call);
+    assertNotNull(callFailed.ioe);
+  }
+
+  @Test public void secureConnectWithTunnel() throws IOException {
+    enableTlsWithTunnel(true);
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END));
+    server.enqueue(new MockResponse());
+
+    client = client.newBuilder()
+        .proxy(server.toProxyAddress())
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals(200, response.code());
+    response.body().close();
+
+    SecureConnectStart secureStart = listener.removeUpToEvent(SecureConnectStart.class);
+    assertSame(call, secureStart.call);
+
+    SecureConnectEnd secureEnd = listener.removeUpToEvent(SecureConnectEnd.class);
+    assertSame(call, secureEnd.call);
+    assertNotNull(secureEnd.handshake);
+  }
+
+  @Test public void multipleSecureConnectsForSingleCall() throws IOException {
+    enableTlsWithTunnel(false);
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
+    server.enqueue(new MockResponse());
+
+    client = client.newBuilder()
+        .dns(new DoubleInetAddressDns())
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals(200, response.code());
+    response.body().close();
+
+    listener.removeUpToEvent(SecureConnectStart.class);
+    listener.removeUpToEvent(ConnectFailed.class);
+
+    listener.removeUpToEvent(SecureConnectStart.class);
+    listener.removeUpToEvent(SecureConnectEnd.class);
+  }
+
+  @Test public void noSecureConnectsOnPooledConnection() throws IOException {
+    enableTlsWithTunnel(false);
+    server.enqueue(new MockResponse());
+    server.enqueue(new MockResponse());
+
+    client = client.newBuilder()
+        .dns(new DoubleInetAddressDns())
+        .build();
+
+    // Seed the pool.
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response1 = call1.execute();
+    assertEquals(200, response1.code());
+    response1.body().close();
+
+    listener.clearAllEvents();
+
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+    assertEquals(200, response2.code());
+    response2.body().close();
+
+    List<String> recordedEvents = listener.recordedEventTypes();
+    assertFalse(recordedEvents.contains("SecureConnectStart"));
+    assertFalse(recordedEvents.contains("SecureConnectEnd"));
+  }
+
+  @Test public void successfulConnectionFound() throws IOException {
+    server.enqueue(new MockResponse());
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals(200, response.code());
+    response.body().close();
+
+    ConnectionAcquired connectionAcquired = listener.removeUpToEvent(ConnectionAcquired.class);
+    assertSame(call, connectionAcquired.call);
+    assertNotNull(connectionAcquired.connection);
+  }
+
+  @Test public void noConnectionFoundOnFollowUp() throws IOException {
+    server.enqueue(new MockResponse()
+        .setResponseCode(301)
+        .addHeader("Location", "/foo"));
+    server.enqueue(new MockResponse()
+        .setBody("ABC"));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals("ABC", response.body().string());
+
+    listener.removeUpToEvent(ConnectionAcquired.class);
+
+    List<String> remainingEvents = listener.recordedEventTypes();
+    assertFalse(remainingEvents.contains("ConnectionAcquired"));
+  }
+
+  @Test public void pooledConnectionFound() throws IOException {
+    server.enqueue(new MockResponse());
+    server.enqueue(new MockResponse());
+
+    // Seed the pool.
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response1 = call1.execute();
+    assertEquals(200, response1.code());
+    response1.body().close();
+
+    ConnectionAcquired connectionAcquired1 = listener.removeUpToEvent(ConnectionAcquired.class);
+    listener.clearAllEvents();
+
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+    assertEquals(200, response2.code());
+    response2.body().close();
+
+    ConnectionAcquired connectionAcquired2 = listener.removeUpToEvent(ConnectionAcquired.class);
+    assertSame(connectionAcquired1.connection, connectionAcquired2.connection);
+  }
+
+  @Test public void multipleConnectionsFoundForSingleCall() throws IOException {
+    server.enqueue(new MockResponse()
+        .setResponseCode(301)
+        .addHeader("Location", "/foo")
+        .addHeader("Connection", "Close"));
+    server.enqueue(new MockResponse()
+        .setBody("ABC"));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals("ABC", response.body().string());
+
+    listener.removeUpToEvent(ConnectionAcquired.class);
+    listener.removeUpToEvent(ConnectionAcquired.class);
+  }
+
+  @Test public void responseBodyFailHttp1OverHttps() throws IOException {
+    enableTlsWithTunnel(false);
+    server.setProtocols(Arrays.asList(Protocol.HTTP_1_1));
+    responseBodyFail(Protocol.HTTP_1_1);
+  }
+
+  @Test public void responseBodyFailHttp2OverHttps() throws IOException {
+    enableTlsWithTunnel(false);
+    server.setProtocols(Arrays.asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
+    responseBodyFail(Protocol.HTTP_2);
+  }
+
+  @Test public void responseBodyFailHttp() throws IOException {
+    responseBodyFail(Protocol.HTTP_1_1);
+  }
+
+  private void responseBodyFail(Protocol expectedProtocol) throws IOException {
+    // Use a 2 MiB body so the disconnect won't happen until the client has read some data.
+    int responseBodySize = 2 * 1024 * 1024; // 2 MiB
+    server.enqueue(new MockResponse()
+        .setBody(new Buffer().write(new byte[responseBodySize]))
+        .setSocketPolicy(SocketPolicy.DISCONNECT_DURING_RESPONSE_BODY));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    if (expectedProtocol == Protocol.HTTP_2) {
+      // soft failure since client may not support depending on Platform
+      assumeThat(response, matchesProtocol(Protocol.HTTP_2));
+    }
+    assertEquals(expectedProtocol, response.protocol());
+    try {
+      response.body.string();
+      fail();
+    } catch (IOException expected) {
+    }
+
+    CallFailed callFailed = listener.removeUpToEvent(CallFailed.class);
+    assertNotNull(callFailed.ioe);
+  }
+
+  @Ignore("the CallEnd event is omitted")
+  @Test public void emptyResponseBody() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("")
+        .setBodyDelay(1, TimeUnit.SECONDS)
+        .setSocketPolicy(SocketPolicy.DISCONNECT_DURING_RESPONSE_BODY));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    response.body().close();
+
+    List<String> expectedEvents = Arrays.asList("CallStart", "DnsStart", "DnsEnd",
+        "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
+        "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
+        "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
+    assertEquals(expectedEvents, listener.recordedEventTypes());
+  }
+
+  @Ignore("this reports CallFailed not CallEnd")
+  @Test public void responseBodyClosedClosedWithoutReadingAllData() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .setBodyDelay(1, TimeUnit.SECONDS)
+        .setSocketPolicy(SocketPolicy.DISCONNECT_DURING_RESPONSE_BODY));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    response.body().close();
+
+    List<String> expectedEvents = Arrays.asList("CallStart", "DnsStart", "DnsEnd",
+        "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
+        "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
+        "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
+    assertEquals(expectedEvents, listener.recordedEventTypes());
+  }
+
+  @Test public void requestBodyFailHttp1OverHttps() throws IOException {
+    enableTlsWithTunnel(false);
+    server.setProtocols(Arrays.asList(Protocol.HTTP_1_1));
+    requestBodyFail();
+  }
+
+  @Test public void requestBodyFailHttp2OverHttps() throws IOException {
+    enableTlsWithTunnel(false);
+    server.setProtocols(Arrays.asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
+    requestBodyFail();
+  }
+
+  @Test public void requestBodyFailHttp() throws IOException {
+    requestBodyFail();
+  }
+
+  private void requestBodyFail() throws IOException {
+    // Stream a 8 MiB body so the disconnect will happen before the server has read everything.
+    RequestBody requestBody = new RequestBody() {
+      @Override public MediaType contentType() {
+        return MediaType.parse("text/plain");
+      }
+
+      @Override public long contentLength() throws IOException {
+        return 1024 * 8192;
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        for (int i = 0; i < 1024; i++) {
+          sink.write(new byte[8192]);
+          sink.flush();
+        }
+      }
+    };
+
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.DISCONNECT_DURING_REQUEST_BODY));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .post(requestBody)
+        .build());
+    try {
+      call.execute();
+      fail();
+    } catch (IOException expected) {
+    }
+
+    CallFailed callFailed = listener.removeUpToEvent(CallFailed.class);
+    assertNotNull(callFailed.ioe);
+  }
+
+  @Test public void requestBodySuccessHttp1OverHttps() throws IOException {
+    enableTlsWithTunnel(false);
+    server.setProtocols(Arrays.asList(Protocol.HTTP_1_1));
+    requestBodySuccess(RequestBody.create(MediaType.parse("text/plain"), "Hello"), equalTo(5L),
+        equalTo(19L));
+  }
+
+  @Test public void requestBodySuccessHttp2OverHttps() throws IOException {
+    enableTlsWithTunnel(false);
+    server.setProtocols(Arrays.asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
+    requestBodySuccess(RequestBody.create(MediaType.parse("text/plain"), "Hello"), equalTo(5L),
+        equalTo(19L));
+  }
+
+  @Test public void requestBodySuccessHttp() throws IOException {
+    requestBodySuccess(RequestBody.create(MediaType.parse("text/plain"), "Hello"), equalTo(5L),
+        equalTo(19L));
+  }
+
+  @Test public void requestBodySuccessStreaming() throws IOException {
+    RequestBody requestBody = new RequestBody() {
+      @Override public MediaType contentType() {
+        return MediaType.parse("text/plain");
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        sink.write(new byte[8192]);
+        sink.flush();
+      }
+    };
+
+    requestBodySuccess(requestBody, equalTo(8192L), equalTo(19L));
+  }
+
+  @Test public void requestBodySuccessEmpty() throws IOException {
+    requestBodySuccess(RequestBody.create(MediaType.parse("text/plain"), ""), equalTo(0L),
+        equalTo(19L));
+  }
+
+  private void requestBodySuccess(RequestBody body, Matcher<Long> requestBodyBytes,
+      Matcher<Long> responseHeaderLength) throws IOException {
+    server.enqueue(new MockResponse().setResponseCode(200).setBody("World!"));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .post(body)
+        .build());
+    Response response = call.execute();
+    assertEquals("World!", response.body().string());
+
+    assertBytesReadWritten(listener, any(Long.class), requestBodyBytes, responseHeaderLength,
+        equalTo(6L));
+  }
+
+  private void enableTlsWithTunnel(boolean tunnelProxy) {
+    client = client.newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build();
+    server.useHttps(sslClient.socketFactory, tunnelProxy);
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/FallbackTestClientSocketFactory.java b/okhttp-tests/src/test/java/okhttp3/FallbackTestClientSocketFactory.java
index eb9aaaa2d3..d829566e20 100644
--- a/okhttp-tests/src/test/java/okhttp3/FallbackTestClientSocketFactory.java
+++ b/okhttp-tests/src/test/java/okhttp3/FallbackTestClientSocketFactory.java
@@ -49,7 +49,7 @@ public TlsFallbackScsvDisabledSSLSocket(SSLSocket socket) {
     }
 
     @Override public void setEnabledCipherSuites(String[] suites) {
-      List<String> enabledCipherSuites = new ArrayList<String>(suites.length);
+      List<String> enabledCipherSuites = new ArrayList<>(suites.length);
       for (String suite : suites) {
         if (!suite.equals(TLS_FALLBACK_SCSV)) {
           enabledCipherSuites.add(suite);
diff --git a/okhttp-tests/src/test/java/okhttp3/FormBodyTest.java b/okhttp-tests/src/test/java/okhttp3/FormBodyTest.java
index 34e40b96f7..b0cb8a6d0f 100644
--- a/okhttp-tests/src/test/java/okhttp3/FormBodyTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/FormBodyTest.java
@@ -18,6 +18,7 @@
 import java.io.IOException;
 import okio.Buffer;
 import org.junit.Test;
+import java.nio.charset.Charset;
 
 import static org.junit.Assert.assertEquals;
 
@@ -196,4 +197,17 @@ private String formEncode(int codePoint) throws IOException {
     buffer.skip(3); // Skip "a=b" prefix.
     return buffer.readUtf8(buffer.size() - 1); // Skip the "c" suffix.
   }
+
+  @Test public void manualCharset() throws Exception {
+    FormBody body = new FormBody.Builder(Charset.forName("ISO-8859-1"))
+        .add("name", "Nicolás")
+        .build();
+
+    String expected = "name=Nicol%E1s";
+    assertEquals(expected.length(), body.contentLength());
+
+    Buffer out = new Buffer();
+    body.writeTo(out);
+    assertEquals(expected, out.readUtf8());
+  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/HeadersTest.java b/okhttp-tests/src/test/java/okhttp3/HeadersTest.java
similarity index 57%
rename from okhttp-tests/src/test/java/okhttp3/internal/http/HeadersTest.java
rename to okhttp-tests/src/test/java/okhttp3/HeadersTest.java
index 84f37d13a3..24dfe878d1 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http/HeadersTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/HeadersTest.java
@@ -13,64 +13,30 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.http;
+package okhttp3;
 
 import java.io.IOException;
 import java.util.Arrays;
 import java.util.Collections;
-import java.util.HashMap;
+import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
-import okhttp3.Headers;
-import okhttp3.Protocol;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.internal.framed.Header;
-import org.junit.Assert;
+import okhttp3.internal.Internal;
+import okhttp3.internal.Util;
+import okhttp3.internal.http.HttpHeaders;
+import okhttp3.internal.http2.Header;
+import okhttp3.internal.http2.Http2Codec;
 import org.junit.Test;
 
 import static okhttp3.TestUtil.headerEntries;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 public final class HeadersTest {
-  @Test public void parseNameValueBlock() throws IOException {
-    List<Header> headerBlock = headerEntries(
-        "cache-control", "no-cache, no-store",
-        "set-cookie", "Cookie1\u0000Cookie2",
-        ":status", "200 OK",
-        ":version", "HTTP/1.1");
-    Request request = new Request.Builder().url("http://square.com/").build();
-    Response response = Http2xStream.readSpdy3HeadersList(headerBlock).request(request).build();
-    Headers headers = response.headers();
-    assertEquals(3, headers.size());
-    Assert.assertEquals(Protocol.SPDY_3, response.protocol());
-    assertEquals(200, response.code());
-    assertEquals("OK", response.message());
-    assertEquals("no-cache, no-store", headers.get("cache-control"));
-    assertEquals("Cookie2", headers.get("set-cookie"));
-    assertEquals("cache-control", headers.name(0));
-    assertEquals("no-cache, no-store", headers.value(0));
-    assertEquals("set-cookie", headers.name(1));
-    assertEquals("Cookie1", headers.value(1));
-    assertEquals("set-cookie", headers.name(2));
-    assertEquals("Cookie2", headers.value(2));
-    assertNull(headers.get(":status"));
-    assertNull(headers.get(":version"));
-  }
-
-  @Test public void readNameValueBlockDropsForbiddenHeadersSpdy3() throws IOException {
-    List<Header> headerBlock = headerEntries(
-        ":status", "200 OK",
-        ":version", "HTTP/1.1",
-        "connection", "close");
-    Request request = new Request.Builder().url("http://square.com/").build();
-    Response response = Http2xStream.readSpdy3HeadersList(headerBlock).request(request).build();
-    Headers headers = response.headers();
-    assertEquals(0, headers.size());
+  static {
+    Internal.initializeInstanceForTests();
   }
 
   @Test public void readNameValueBlockDropsForbiddenHeadersHttp2() throws IOException {
@@ -79,61 +45,26 @@
         ":version", "HTTP/1.1",
         "connection", "close");
     Request request = new Request.Builder().url("http://square.com/").build();
-    Response response = Http2xStream.readHttp2HeadersList(headerBlock).request(request).build();
+    Response response = Http2Codec.readHttp2HeadersList(headerBlock).request(request).build();
     Headers headers = response.headers();
     assertEquals(1, headers.size());
     assertEquals(":version", headers.name(0));
     assertEquals("HTTP/1.1", headers.value(0));
   }
 
-  @Test public void spdy3HeadersList() {
-    Request request = new Request.Builder()
-        .url("http://square.com/")
-        .header("cache-control", "no-cache, no-store")
-        .addHeader("set-cookie", "Cookie1")
-        .addHeader("set-cookie", "Cookie2")
-        .header(":status", "200 OK")
-        .build();
-    List<Header> headerBlock = Http2xStream.spdy3HeadersList(request);
-    List<Header> expected = headerEntries(
-        ":method", "GET",
-        ":path", "/",
-        ":version", "HTTP/1.1",
-        ":host", "square.com",
-        ":scheme", "http",
-        "cache-control", "no-cache, no-store",
-        "set-cookie", "Cookie1\u0000Cookie2",
-        ":status", "200 OK");
-    assertEquals(expected, headerBlock);
-  }
-
-  @Test public void spdy3HeadersListDropsForbiddenHeadersSpdy3() {
-    Request request = new Request.Builder()
-        .url("http://square.com/")
-        .header("Connection", "close")
-        .header("Transfer-Encoding", "chunked")
-        .build();
-    List<Header> expected = headerEntries(
-        ":method", "GET",
-        ":path", "/",
-        ":version", "HTTP/1.1",
-        ":host", "square.com",
-        ":scheme", "http");
-    assertEquals(expected, Http2xStream.spdy3HeadersList(request));
-  }
-
   @Test public void http2HeadersListDropsForbiddenHeadersHttp2() {
     Request request = new Request.Builder()
         .url("http://square.com/")
         .header("Connection", "upgrade")
         .header("Upgrade", "websocket")
+        .header("Host", "square.com")
         .build();
     List<Header> expected = headerEntries(
         ":method", "GET",
         ":path", "/",
         ":authority", "square.com",
         ":scheme", "http");
-    assertEquals(expected, Http2xStream.http2HeadersList(request));
+    assertEquals(expected, Http2Codec.http2HeadersList(request));
   }
 
   @Test public void ofTrims() {
@@ -147,10 +78,12 @@
         .add("foo: bar")
         .add(" foo: baz") // Name leading whitespace is trimmed.
         .add("foo : bak") // Name trailing whitespace is trimmed.
+        .add("\tkey\t:\tvalue\t") // '\t' also counts as whitespace
         .add("ping:  pong  ") // Value whitespace is trimmed.
         .add("kit:kat") // Space after colon is not required.
         .build();
     assertEquals(Arrays.asList("bar", "baz", "bak"), headers.values("foo"));
+    assertEquals(Arrays.asList("value"), headers.values("key"));
     assertEquals(Arrays.asList("pong"), headers.values("ping"));
     assertEquals(Arrays.asList("kat"), headers.values("kit"));
   }
@@ -271,7 +204,7 @@
   }
 
   @Test public void ofMapMakesDefensiveCopy() {
-    Map<String, String> namesAndValues = new HashMap<>();
+    Map<String, String> namesAndValues = new LinkedHashMap<>();
     namesAndValues.put("User-Agent", "OkHttp");
 
     Headers headers = Headers.of(namesAndValues);
@@ -315,6 +248,15 @@
     assertEquals(1, headerMap.get("user-agent").size());
   }
 
+  @Test public void toMultimapAllowsCaseInsensitiveGet() {
+    Headers headers = Headers.of(
+            "cache-control", "no-store",
+            "Cache-Control", "no-cache");
+    Map<String, List<String>> headerMap = headers.toMultimap();
+    assertEquals(2, headerMap.get("cache-control").size());
+    assertEquals(2, headerMap.get("Cache-Control").size());
+  }
+
   @Test public void nameIndexesAreStrict() {
     Headers headers = Headers.of("a", "b", "c", "d");
     try {
@@ -392,4 +334,141 @@
     assertFalse(headers1.equals(headers2));
     assertFalse(headers1.hashCode() == headers2.hashCode());
   }
+
+  @Test public void headersToString() {
+    Headers headers = new Headers.Builder()
+        .add("A", "a")
+        .add("B", "bb")
+        .build();
+    assertEquals("A: a\nB: bb\n", headers.toString());
+  }
+
+  /** See https://github.com/square/okhttp/issues/2780. */
+  @Test public void testDigestChallenges() {
+    // Strict RFC 2617 header.
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Digest realm=\"myrealm\", nonce=\"fjalskdflwejrlaskdfjlaskdjflaks"
+            + "jdflkasdf\", qop=\"auth\", stale=\"FALSE\"")
+        .build();
+    List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
+    assertEquals(1, challenges.size());
+    assertEquals("Digest", challenges.get(0).scheme());
+    assertEquals("myrealm", challenges.get(0).realm());
+
+    // Not strict RFC 2617 header.
+    headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Digest qop=\"auth\", realm=\"myrealm\", nonce=\"fjalskdflwejrlask"
+            + "dfjlaskdjflaksjdflkasdf\", stale=\"FALSE\"")
+        .build();
+    challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
+    assertEquals(1, challenges.size());
+    assertEquals("Digest", challenges.get(0).scheme());
+    assertEquals("myrealm", challenges.get(0).realm());
+
+    // Not strict RFC 2617 header #2.
+    headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Digest qop=\"auth\", nonce=\"fjalskdflwejrlaskdfjlaskdjflaksjdflk"
+            + "asdf\", realm=\"myrealm\", stale=\"FALSE\"")
+        .build();
+    challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
+    assertEquals(1, challenges.size());
+    assertEquals("Digest", challenges.get(0).scheme());
+    assertEquals("myrealm", challenges.get(0).realm());
+
+    // Wrong header.
+    headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Digest qop=\"auth\", underrealm=\"myrealm\", nonce=\"fjalskdflwej"
+            + "rlaskdfjlaskdjflaksjdflkasdf\", stale=\"FALSE\"")
+        .build();
+    challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
+    assertEquals(0, challenges.size());
+
+    // Not strict RFC 2617 header with some spaces.
+    headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Digest qop=\"auth\",    realm=\"myrealm\", nonce=\"fjalskdflwejrl"
+            + "askdfjlaskdjflaksjdflkasdf\", stale=\"FALSE\"")
+        .build();
+    challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
+    assertEquals(1, challenges.size());
+    assertEquals("Digest", challenges.get(0).scheme());
+    assertEquals("myrealm", challenges.get(0).realm());
+
+    // Strict RFC 2617 header with some spaces.
+    headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Digest    realm=\"myrealm\", nonce=\"fjalskdflwejrlaskdfjlaskdjfl"
+            + "aksjdflkasdf\", qop=\"auth\", stale=\"FALSE\"")
+        .build();
+    challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
+    assertEquals(1, challenges.size());
+    assertEquals("Digest", challenges.get(0).scheme());
+    assertEquals("myrealm", challenges.get(0).realm());
+
+    // Not strict RFC 2617 camelcased.
+    headers = new Headers.Builder()
+        .add("WWW-Authenticate", "DiGeSt qop=\"auth\", rEaLm=\"myrealm\", nonce=\"fjalskdflwejrlask"
+            + "dfjlaskdjflaksjdflkasdf\", stale=\"FALSE\"")
+        .build();
+    challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
+    assertEquals(1, challenges.size());
+    assertEquals("DiGeSt", challenges.get(0).scheme());
+    assertEquals("myrealm", challenges.get(0).realm());
+
+    // Strict RFC 2617 camelcased.
+    headers = new Headers.Builder()
+        .add("WWW-Authenticate", "DIgEsT rEaLm=\"myrealm\", nonce=\"fjalskdflwejrlaskdfjlaskdjflaks"
+            + "jdflkasdf\", qop=\"auth\", stale=\"FALSE\"")
+        .build();
+    challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
+    assertEquals(1, challenges.size());
+    assertEquals("DIgEsT", challenges.get(0).scheme());
+    assertEquals("myrealm", challenges.get(0).realm());
+
+    // Unquoted.
+    headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Digest realm=myrealm").build();
+    challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
+    assertEquals(0, challenges.size());
+
+    // Scheme only.
+    headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Digest").build();
+    challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
+    assertEquals(0, challenges.size());
+  }
+
+  @Test public void basicChallenge() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate: Basic realm=\"protected area\"")
+        .build();
+    assertEquals(Arrays.asList(new Challenge("Basic", "protected area")),
+        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Test public void basicChallengeWithCharset() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate: Basic realm=\"protected area\", charset=\"UTF-8\"")
+        .build();
+    assertEquals(Arrays.asList(new Challenge("Basic", "protected area").withCharset(Util.UTF_8)),
+        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Test public void basicChallengeWithUnexpectedCharset() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate: Basic realm=\"protected area\", charset=\"US-ASCII\"")
+        .build();
+    assertEquals(Collections.emptyList(), HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Test public void byteCount() {
+    assertEquals(0L, new Headers.Builder().build().byteCount());
+    assertEquals(10L, new Headers.Builder()
+        .add("abc", "def")
+        .build()
+        .byteCount());
+    assertEquals(20L, new Headers.Builder()
+        .add("abc", "def")
+        .add("ghi", "jkl")
+        .build()
+        .byteCount());
+  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java b/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java
index f7d655dbf0..a51830e78c 100644
--- a/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java
@@ -124,6 +124,15 @@
     assertEquals(null, base.newBuilder("ht.tp://b"));
   }
 
+  @Test public void redactedUrl() {
+    HttpUrl baseWithPasswordAndUsername = HttpUrl.parse("http://username:password@host/a/b#fragment");
+    HttpUrl baseWithUsernameOnly = HttpUrl.parse("http://username@host/a/b#fragment");
+    HttpUrl baseWithPasswordOnly = HttpUrl.parse("http://password@host/a/b#fragment");
+    assertEquals("http://host/...", baseWithPasswordAndUsername.redact());
+    assertEquals("http://host/...", baseWithUsernameOnly.redact());
+    assertEquals("http://host/...", baseWithPasswordOnly.redact());
+  }
+
   @Test public void resolveNoScheme() throws Exception {
     HttpUrl base = HttpUrl.parse("http://host/a/b");
     assertEquals(HttpUrl.parse("http://host2/"), base.resolve("//host2"));
@@ -151,6 +160,58 @@
     assertEquals(HttpUrl.parse("http://a/ht.tp//b/"), base.resolve("ht.tp//b/"));
   }
 
+  /** https://tools.ietf.org/html/rfc3986#section-5.4.1 */
+  @Test public void rfc3886NormalExamples() {
+    HttpUrl url = HttpUrl.parse("http://a/b/c/d;p?q");
+    assertEquals(null, url.resolve("g:h")); // No 'g:' scheme in HttpUrl.
+    assertEquals(HttpUrl.parse("http://a/b/c/g"), url.resolve("g"));
+    assertEquals(HttpUrl.parse("http://a/b/c/g"), url.resolve("./g"));
+    assertEquals(HttpUrl.parse("http://a/b/c/g/"), url.resolve("g/"));
+    assertEquals(HttpUrl.parse("http://a/g"), url.resolve("/g"));
+    assertEquals(HttpUrl.parse("http://g"), url.resolve("//g"));
+    assertEquals(HttpUrl.parse("http://a/b/c/d;p?y"), url.resolve("?y"));
+    assertEquals(HttpUrl.parse("http://a/b/c/g?y"), url.resolve("g?y"));
+    assertEquals(HttpUrl.parse("http://a/b/c/d;p?q#s"), url.resolve("#s"));
+    assertEquals(HttpUrl.parse("http://a/b/c/g#s"), url.resolve("g#s"));
+    assertEquals(HttpUrl.parse("http://a/b/c/g?y#s"), url.resolve("g?y#s"));
+    assertEquals(HttpUrl.parse("http://a/b/c/;x"), url.resolve(";x"));
+    assertEquals(HttpUrl.parse("http://a/b/c/g;x"), url.resolve("g;x"));
+    assertEquals(HttpUrl.parse("http://a/b/c/g;x?y#s"), url.resolve("g;x?y#s"));
+    assertEquals(HttpUrl.parse("http://a/b/c/d;p?q"), url.resolve(""));
+    assertEquals(HttpUrl.parse("http://a/b/c/"), url.resolve("."));
+    assertEquals(HttpUrl.parse("http://a/b/c/"), url.resolve("./"));
+    assertEquals(HttpUrl.parse("http://a/b/"), url.resolve(".."));
+    assertEquals(HttpUrl.parse("http://a/b/"), url.resolve("../"));
+    assertEquals(HttpUrl.parse("http://a/b/g"), url.resolve("../g"));
+    assertEquals(HttpUrl.parse("http://a/"), url.resolve("../.."));
+    assertEquals(HttpUrl.parse("http://a/"), url.resolve("../../"));
+    assertEquals(HttpUrl.parse("http://a/g"), url.resolve("../../g"));
+  }
+
+  /** https://tools.ietf.org/html/rfc3986#section-5.4.2 */
+  @Test public void rfc3886AbnormalExamples() {
+    HttpUrl url = HttpUrl.parse("http://a/b/c/d;p?q");
+    assertEquals(HttpUrl.parse("http://a/g"), url.resolve("../../../g"));
+    assertEquals(HttpUrl.parse("http://a/g"), url.resolve("../../../../g"));
+    assertEquals(HttpUrl.parse("http://a/g"), url.resolve("/./g"));
+    assertEquals(HttpUrl.parse("http://a/g"), url.resolve("/../g"));
+    assertEquals(HttpUrl.parse("http://a/b/c/g."), url.resolve("g."));
+    assertEquals(HttpUrl.parse("http://a/b/c/.g"), url.resolve(".g"));
+    assertEquals(HttpUrl.parse("http://a/b/c/g.."), url.resolve("g.."));
+    assertEquals(HttpUrl.parse("http://a/b/c/..g"), url.resolve("..g"));
+    assertEquals(HttpUrl.parse("http://a/b/g"), url.resolve("./../g"));
+    assertEquals(HttpUrl.parse("http://a/b/c/g/"), url.resolve("./g/."));
+    assertEquals(HttpUrl.parse("http://a/b/c/g/h"), url.resolve("g/./h"));
+    assertEquals(HttpUrl.parse("http://a/b/c/h"), url.resolve("g/../h"));
+    assertEquals(HttpUrl.parse("http://a/b/c/g;x=1/y"), url.resolve("g;x=1/./y"));
+    assertEquals(HttpUrl.parse("http://a/b/c/y"), url.resolve("g;x=1/../y"));
+    assertEquals(HttpUrl.parse("http://a/b/c/g?y/./x"), url.resolve("g?y/./x"));
+    assertEquals(HttpUrl.parse("http://a/b/c/g?y/../x"), url.resolve("g?y/../x"));
+    assertEquals(HttpUrl.parse("http://a/b/c/g#s/./x"), url.resolve("g#s/./x"));
+    assertEquals(HttpUrl.parse("http://a/b/c/g#s/../x"), url.resolve("g#s/../x"));
+    assertEquals(HttpUrl.parse("http://a/b/c/g"), url.resolve("http:g")); // "http:g" also okay.
+  }
+
   @Test public void parseAuthoritySlashCountDoesntMatter() throws Exception {
     assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:host/path"));
     assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:/host/path"));
@@ -365,11 +426,11 @@
     assertEquals(null, HttpUrl.parse("http://[1:]"));
     assertEquals(null, HttpUrl.parse("http://[1:::]"));
     assertEquals(null, HttpUrl.parse("http://[1:::1]"));
-    assertEquals(null, HttpUrl.parse("http://[00000:0000:0000:0000::0000:0000:0000:0001]"));
+    assertEquals(null, HttpUrl.parse("http://[0000:0000:0000:0000::0000:0000:0000:0001]"));
   }
 
   @Test public void hostIpv6AddressTooManyGroups() throws Exception {
-    assertEquals(null, HttpUrl.parse("http://[00000:0000:0000:0000:0000:0000:0000:0000:0001]"));
+    assertEquals(null, HttpUrl.parse("http://[0000:0000:0000:0000:0000:0000:0000:0000:0001]"));
   }
 
   @Test public void hostIpv6AddressTooMuchCompression() throws Exception {
@@ -430,9 +491,14 @@
     assertEquals("a::b:0:0:0", HttpUrl.parse("http://[a:0:0:0:b:0:0:0]/").host());
     assertEquals("::a:b:0:0:0", HttpUrl.parse("http://[0:0:0:a:b:0:0:0]/").host());
     assertEquals("::a:0:0:0:b", HttpUrl.parse("http://[0:0:0:a:0:0:0:b]/").host());
-    assertEquals("::a:b:c:d:e:f:1", HttpUrl.parse("http://[0:a:b:c:d:e:f:1]/").host());
-    assertEquals("a:b:c:d:e:f:1::", HttpUrl.parse("http://[a:b:c:d:e:f:1:0]/").host());
+    assertEquals("0:a:b:c:d:e:f:1", HttpUrl.parse("http://[0:a:b:c:d:e:f:1]/").host());
+    assertEquals("a:b:c:d:e:f:1:0", HttpUrl.parse("http://[a:b:c:d:e:f:1:0]/").host());
     assertEquals("ff01::101", HttpUrl.parse("http://[FF01:0:0:0:0:0:0:101]/").host());
+    assertEquals("2001:db8::1", HttpUrl.parse("http://[2001:db8::1]/").host());
+    assertEquals("2001:db8::2:1", HttpUrl.parse("http://[2001:db8:0:0:0:0:2:1]/").host());
+    assertEquals("2001:db8:0:1:1:1:1:1", HttpUrl.parse("http://[2001:db8:0:1:1:1:1:1]/").host());
+    assertEquals("2001:db8::1:0:0:1", HttpUrl.parse("http://[2001:db8:0:0:1:0:0:1]/").host());
+    assertEquals("2001:0:0:1::1", HttpUrl.parse("http://[2001:0:0:1:0:0:0:1]/").host());
     assertEquals("1::", HttpUrl.parse("http://[1:0:0:0:0:0:0:0]/").host());
     assertEquals("::1", HttpUrl.parse("http://[0:0:0:0:0:0:0:1]/").host());
     assertEquals("::", HttpUrl.parse("http://[0:0:0:0:0:0:0:0]/").host());
@@ -1374,6 +1440,13 @@
     assertEquals(" ", url.queryParameter(" "));
   }
 
+  @Test public void parsedQueryDoesntIncludeFragment() {
+    HttpUrl url = HttpUrl.parse("http://host/?#fragment");
+    assertEquals("fragment", url.fragment());
+    assertEquals("", url.query());
+    assertEquals("", url.encodedQuery());
+  }
+
   @Test public void roundTripBuilder() throws Exception {
     HttpUrl url = new HttpUrl.Builder()
         .scheme("http")
@@ -1426,4 +1499,19 @@
     assertEquals(null, url.fragment());
     assertEquals(null, url.encodedFragment());
   }
+
+  @Test public void topPrivateDomain() {
+    assertEquals("google.com", HttpUrl.parse("https://google.com").topPrivateDomain());
+    assertEquals("google.co.uk", HttpUrl.parse("https://adwords.google.co.uk").topPrivateDomain());
+    assertEquals("xn--ewv.xn--4pvxs.jp", HttpUrl.parse("https://栃.栃木.jp").topPrivateDomain());
+    assertEquals("xn--ewv.xn--4pvxs.jp",
+        HttpUrl.parse("https://xn--ewv.xn--4pvxs.jp").topPrivateDomain());
+
+    assertNull(HttpUrl.parse("https://co.uk").topPrivateDomain());
+    assertNull(HttpUrl.parse("https://square").topPrivateDomain());
+    assertNull(HttpUrl.parse("https://栃木.jp").topPrivateDomain());
+    assertNull(HttpUrl.parse("https://xn--4pvxs.jp").topPrivateDomain());
+    assertNull(HttpUrl.parse("https://localhost").topPrivateDomain());
+    assertNull(HttpUrl.parse("https://127.0.0.1").topPrivateDomain());
+  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/InterceptorTest.java b/okhttp-tests/src/test/java/okhttp3/InterceptorTest.java
index 287f12a317..e01a360b9b 100644
--- a/okhttp-tests/src/test/java/okhttp3/InterceptorTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/InterceptorTest.java
@@ -16,6 +16,7 @@
 package okhttp3;
 
 import java.io.IOException;
+import java.net.SocketTimeoutException;
 import java.util.Arrays;
 import java.util.Locale;
 import java.util.concurrent.BlockingQueue;
@@ -23,6 +24,7 @@
 import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicReference;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.RecordedRequest;
@@ -40,9 +42,11 @@
 
 import static okhttp3.TestUtil.defaultClient;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 public final class InterceptorTest {
@@ -597,8 +601,7 @@ private void interceptorThrowsRuntimeExceptionAsynchronous(boolean network) thro
       client.newCall(request).execute();
       fail();
     } catch (NullPointerException expected) {
-      assertEquals("application interceptor " + interceptor
-          + " returned null", expected.getMessage());
+      assertEquals("interceptor " + interceptor + " returned null", expected.getMessage());
     }
   }
 
@@ -627,7 +630,7 @@ private void interceptorThrowsRuntimeExceptionAsynchronous(boolean network) thro
       client.newCall(request).execute();
       fail();
     } catch (NullPointerException expected) {
-      assertEquals("network interceptor " + interceptor + " returned null", expected.getMessage());
+      assertEquals("interceptor " + interceptor + " returned null", expected.getMessage());
     }
   }
 
@@ -656,6 +659,210 @@ private void interceptorThrowsRuntimeExceptionAsynchronous(boolean network) thro
     response.body().close();
   }
 
+  @Test public void applicationInterceptorResponseMustHaveBody() throws Exception {
+    server.enqueue(new MockResponse());
+
+    Interceptor interceptor = new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        return chain.proceed(chain.request()).newBuilder().body(null).build();
+      }
+    };
+    client = client.newBuilder()
+        .addInterceptor(interceptor)
+        .build();
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    try {
+      client.newCall(request).execute();
+      fail();
+    } catch (IllegalStateException expected) {
+      assertEquals("interceptor " + interceptor + " returned a response with no body",
+          expected.getMessage());
+    }
+  }
+
+  @Test public void networkInterceptorResponseMustHaveBody() throws Exception {
+    server.enqueue(new MockResponse());
+
+    Interceptor interceptor = new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        return chain.proceed(chain.request()).newBuilder().body(null).build();
+      }
+    };
+    client = client.newBuilder()
+        .addNetworkInterceptor(interceptor)
+        .build();
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    try {
+      client.newCall(request).execute();
+      fail();
+    } catch (IllegalStateException expected) {
+      assertEquals("interceptor " + interceptor + " returned a response with no body",
+          expected.getMessage());
+    }
+  }
+
+  @Test public void connectTimeout() throws Exception {
+    Interceptor interceptor1 = new Interceptor() {
+      @Override public Response intercept(Chain chainA) throws IOException {
+        assertEquals(5000, chainA.connectTimeoutMillis());
+
+        Chain chainB = chainA.withConnectTimeout(100, TimeUnit.MILLISECONDS);
+        assertEquals(100, chainB.connectTimeoutMillis());
+
+        return chainB.proceed(chainA.request());
+      }
+    };
+
+    Interceptor interceptor2 = new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        assertEquals(100, chain.connectTimeoutMillis());
+        return chain.proceed(chain.request());
+      }
+    };
+
+    client = client.newBuilder()
+        .connectTimeout(5, TimeUnit.SECONDS)
+        .addInterceptor(interceptor1)
+        .addInterceptor(interceptor2)
+        .build();
+
+    Request request1 = new Request.Builder()
+        .url("http://" + TestUtil.UNREACHABLE_ADDRESS)
+        .build();
+    Call call = client.newCall(request1);
+
+    try {
+      call.execute();
+      fail();
+    } catch (SocketTimeoutException expected) {
+    }
+  }
+
+  @Test public void chainWithReadTimeout() throws Exception {
+    Interceptor interceptor1 = new Interceptor() {
+      @Override public Response intercept(Chain chainA) throws IOException {
+        assertEquals(5000, chainA.readTimeoutMillis());
+
+        Chain chainB = chainA.withReadTimeout(100, TimeUnit.MILLISECONDS);
+        assertEquals(100, chainB.readTimeoutMillis());
+
+        return chainB.proceed(chainA.request());
+      }
+    };
+
+    Interceptor interceptor2 = new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        assertEquals(100, chain.readTimeoutMillis());
+        return chain.proceed(chain.request());
+      }
+    };
+
+    client = client.newBuilder()
+        .readTimeout(5, TimeUnit.SECONDS)
+        .addInterceptor(interceptor1)
+        .addInterceptor(interceptor2)
+        .build();
+
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .throttleBody(1, 1, TimeUnit.SECONDS));
+
+    Request request1 = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    Call call = client.newCall(request1);
+    Response response = call.execute();
+    ResponseBody body = response.body();
+    try {
+      body.string();
+      fail();
+    } catch (SocketTimeoutException expected) {
+    }
+  }
+
+  @Test public void chainWithWriteTimeout() throws Exception {
+    Interceptor interceptor1 = new Interceptor() {
+      @Override public Response intercept(Chain chainA) throws IOException {
+        assertEquals(5000, chainA.writeTimeoutMillis());
+
+        Chain chainB = chainA.withWriteTimeout(100, TimeUnit.MILLISECONDS);
+        assertEquals(100, chainB.writeTimeoutMillis());
+
+        return chainB.proceed(chainA.request());
+      }
+    };
+
+    Interceptor interceptor2 = new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        assertEquals(100, chain.writeTimeoutMillis());
+        return chain.proceed(chain.request());
+      }
+    };
+
+    client = client.newBuilder()
+        .writeTimeout(5, TimeUnit.SECONDS)
+        .addInterceptor(interceptor1)
+        .addInterceptor(interceptor2)
+        .build();
+
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .throttleBody(1, 1, TimeUnit.SECONDS));
+
+    byte[] data = new byte[2 * 1024 * 1024]; // 2 MiB.
+    Request request1 = new Request.Builder()
+        .url(server.url("/"))
+        .post(RequestBody.create(MediaType.parse("text/plain"), data))
+        .build();
+    Call call = client.newCall(request1);
+
+    try {
+      call.execute(); // we want this call to throw a SocketTimeoutException
+      fail();
+    } catch (SocketTimeoutException expected) {
+    }
+  }
+
+  @Test public void chainCanCancelCall() throws Exception {
+    final AtomicReference<Call> callRef = new AtomicReference<>();
+
+    Interceptor interceptor = new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        Call call = chain.call();
+        callRef.set(call);
+
+        assertFalse(call.isCanceled());
+        call.cancel();
+        assertTrue(call.isCanceled());
+
+        return chain.proceed(chain.request());
+      }
+    };
+
+    client = client.newBuilder()
+        .addInterceptor(interceptor)
+        .build();
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    Call call = client.newCall(request);
+
+    try {
+      call.execute();
+      fail();
+    } catch (IOException expected) {
+    }
+
+    assertSame(call, callRef.get());
+  }
+
   private RequestBody uppercase(final RequestBody original) {
     return new RequestBody() {
       @Override public MediaType contentType() {
diff --git a/okhttp-tests/src/test/java/okhttp3/MediaTypeTest.java b/okhttp-tests/src/test/java/okhttp3/MediaTypeTest.java
index b4e9c2ec2a..b2d3f396fa 100644
--- a/okhttp-tests/src/test/java/okhttp3/MediaTypeTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/MediaTypeTest.java
@@ -17,15 +17,12 @@
 package okhttp3;
 
 import java.nio.charset.Charset;
-import java.nio.charset.IllegalCharsetNameException;
-import java.nio.charset.UnsupportedCharsetException;
 import okhttp3.internal.Util;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
 
 /**
  * Test MediaType API and parsing.
@@ -87,6 +84,16 @@
     assertInvalid("text/plain ; a=1");
   }
 
+  @Test public void testDoubleQuotesAreSpecial() throws Exception {
+    MediaType mediaType = MediaType.parse("text/plain;a=\";charset=utf-8;b=\"");
+    assertNull(mediaType.charset());
+  }
+
+  @Test public void testSingleQuotesAreNotSpecial() throws Exception {
+    MediaType mediaType = MediaType.parse("text/plain;a=';charset=utf-8;b='");
+    assertEquals("UTF-8", mediaType.charset().name());
+  }
+
   @Test public void testParseWithSpecialCharacters() throws Exception {
     MediaType mediaType = MediaType.parse(
         "!#$%&'*+-.{|}~/!#$%&'*+-.{|}~; !#$%&'*+-.{|}~=!#$%&'*+-.{|}~");
@@ -113,29 +120,36 @@
   }
 
   @Test public void testMultipleCharsets() {
-    try {
-      MediaType.parse("text/plain; charset=utf-8; charset=utf-16");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
+    assertNull(MediaType.parse("text/plain; charset=utf-8; charset=utf-16"));
   }
 
   @Test public void testIllegalCharsetName() {
     MediaType mediaType = MediaType.parse("text/plain; charset=\"!@#$%^&*()\"");
-    try {
-      mediaType.charset();
-      fail();
-    } catch (IllegalCharsetNameException expected) {
-    }
+    assertNull(mediaType.charset());
   }
 
   @Test public void testUnsupportedCharset() {
     MediaType mediaType = MediaType.parse("text/plain; charset=utf-wtf");
-    try {
-      mediaType.charset();
-      fail();
-    } catch (UnsupportedCharsetException expected) {
-    }
+    assertNull(mediaType.charset());
+  }
+
+  /**
+   * This is invalid according to RFC 822. But it's what Chrome does and it avoids a potentially
+   * unpleasant IllegalCharsetNameException.
+   */
+  @Test public void testCharsetNameIsSingleQuoted() throws Exception {
+    MediaType mediaType = MediaType.parse("text/plain;charset='utf-8'");
+    assertEquals("UTF-8", mediaType.charset().name());
+  }
+
+  @Test public void testCharsetNameIsDoubleQuotedAndSingleQuoted() throws Exception {
+    MediaType mediaType = MediaType.parse("text/plain;charset=\"'utf-8'\"");
+    assertNull(mediaType.charset());
+  }
+
+  @Test public void testCharsetNameIsDoubleQuotedSingleQuote() throws Exception {
+    MediaType mediaType = MediaType.parse("text/plain;charset=\"'\"");
+    assertNull(mediaType.charset());
   }
 
   @Test public void testDefaultCharset() throws Exception {
@@ -152,7 +166,7 @@
     MediaType mediaType = MediaType.parse("text/plain;");
     assertEquals("text", mediaType.type());
     assertEquals("plain", mediaType.subtype());
-    assertEquals(null, mediaType.charset());
+    assertNull(mediaType.charset());
     assertEquals("text/plain;", mediaType.toString());
   }
 
diff --git a/okhttp-tests/src/test/java/okhttp3/MultipartBodyTest.java b/okhttp-tests/src/test/java/okhttp3/MultipartBodyTest.java
index a5a8664a87..35d2f67906 100644
--- a/okhttp-tests/src/test/java/okhttp3/MultipartBodyTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/MultipartBodyTest.java
@@ -258,4 +258,17 @@
     } catch (IllegalArgumentException expected) {
     }
   }
+
+  @Test public void partAccessors() throws IOException {
+    MultipartBody body = new MultipartBody.Builder()
+        .addPart(Headers.of("Foo", "Bar"), RequestBody.create(null, "Baz"))
+        .build();
+    assertEquals(1, body.parts().size());
+
+    Buffer part1Buffer = new Buffer();
+    MultipartBody.Part part1 = body.part(0);
+    part1.body().writeTo(part1Buffer);
+    assertEquals(Headers.of("Foo", "Bar"), part1.headers());
+    assertEquals("Baz", part1Buffer.readUtf8());
+  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/NullServer.java b/okhttp-tests/src/test/java/okhttp3/NullServer.java
new file mode 100644
index 0000000000..30a84f8ead
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/NullServer.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.ServerSocket;
+import javax.net.ServerSocketFactory;
+import okhttp3.internal.Util;
+
+public final class NullServer {
+  private InetSocketAddress address;
+  private ServerSocket nullServer;
+
+  public void start() throws Exception {
+    nullServer = ServerSocketFactory.getDefault().createServerSocket();
+    nullServer.bind(address, 0);
+    address = new InetSocketAddress(InetAddress.getByName("localhost"), nullServer.getLocalPort());
+  }
+
+  public void shutdown() {
+    Util.closeQuietly(nullServer);
+  }
+
+  public HttpUrl url(String scheme) {
+    return new HttpUrl.Builder()
+        .scheme(scheme)
+        .host(address.getHostName())
+        .port(nullServer.getLocalPort())
+        .build();
+  }
+
+  public InetSocketAddress address() {
+    return address;
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/OkHttpClientTest.java b/okhttp-tests/src/test/java/okhttp3/OkHttpClientTest.java
index e369a4d4b1..5582f3ce83 100644
--- a/okhttp-tests/src/test/java/okhttp3/OkHttpClientTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/OkHttpClientTest.java
@@ -42,11 +42,12 @@
     ResponseCache.setDefault(DEFAULT_RESPONSE_CACHE);
   }
 
-  @Test public void timeoutDefaults() {
+  @Test public void durationDefaults() {
     OkHttpClient client = defaultClient();
     assertEquals(10_000, client.connectTimeoutMillis());
     assertEquals(10_000, client.readTimeoutMillis());
     assertEquals(10_000, client.writeTimeoutMillis());
+    assertEquals(0, client.pingIntervalMillis());
   }
 
   @Test public void timeoutValidRange() {
@@ -120,4 +121,52 @@
     } catch (IllegalArgumentException expected) {
     }
   }
+
+  @Test public void certificatePinnerEquality() {
+    OkHttpClient clientA = TestUtil.defaultClient();
+    OkHttpClient clientB = TestUtil.defaultClient();
+    assertEquals(clientA.certificatePinner(), clientB.certificatePinner());
+  }
+
+  @Test public void nullInterceptor() {
+    OkHttpClient.Builder builder = new OkHttpClient.Builder();
+    try {
+      builder.addInterceptor(null);
+      fail();
+    } catch (IllegalArgumentException expected) {
+      assertEquals("interceptor == null", expected.getMessage());
+    }
+  }
+
+  @Test public void nullNetworkInterceptor() {
+    OkHttpClient.Builder builder = new OkHttpClient.Builder();
+    try {
+      builder.addNetworkInterceptor(null);
+      fail();
+    } catch (IllegalArgumentException expected) {
+      assertEquals("interceptor == null", expected.getMessage());
+    }
+  }
+
+  @Test public void nullInterceptorInList() {
+    OkHttpClient.Builder builder = new OkHttpClient.Builder();
+    builder.interceptors().add(null);
+    try {
+      builder.build();
+      fail();
+    } catch (IllegalStateException expected) {
+      assertEquals("Null interceptor: [null]", expected.getMessage());
+    }
+  }
+
+  @Test public void nullNetworkInterceptorInList() {
+    OkHttpClient.Builder builder = new OkHttpClient.Builder();
+    builder.networkInterceptors().add(null);
+    try {
+      builder.build();
+      fail();
+    } catch (IllegalStateException expected) {
+      assertEquals("Null network interceptor: [null]", expected.getMessage());
+    }
+  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/RecordedResponse.java b/okhttp-tests/src/test/java/okhttp3/RecordedResponse.java
index ae7afa98df..d34380cc4f 100644
--- a/okhttp-tests/src/test/java/okhttp3/RecordedResponse.java
+++ b/okhttp-tests/src/test/java/okhttp3/RecordedResponse.java
@@ -19,7 +19,6 @@
 import java.text.SimpleDateFormat;
 import java.util.Arrays;
 import java.util.Date;
-import okhttp3.ws.WebSocket;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
@@ -144,17 +143,33 @@ public RecordedResponse cacheResponse() {
     return new RecordedResponse(cacheResponse.request(), cacheResponse, null, null, null);
   }
 
-  public RecordedResponse assertFailure(Class<?> exceptionClass) {
-    assertTrue(exceptionClass.isInstance(failure));
+  public RecordedResponse assertFailure(Class<?>... allowedExceptionTypes) {
+    boolean found = false;
+    for (Class expectedClass : allowedExceptionTypes) {
+      if (expectedClass.isInstance(failure)) {
+        found = true;
+        break;
+      }
+    }
+    assertTrue("Expected exception type among " + Arrays.toString(allowedExceptionTypes)
+            + ", got " + failure, found);
     return this;
   }
 
   public RecordedResponse assertFailure(String... messages) {
-    assertNotNull(failure);
+    assertNotNull("No failure found", failure);
     assertTrue(failure.getMessage(), Arrays.asList(messages).contains(failure.getMessage()));
     return this;
   }
 
+  public RecordedResponse assertFailureMatches(String... patterns) {
+    assertNotNull(failure);
+    for (String pattern : patterns) {
+      if (failure.getMessage().matches(pattern)) return this;
+    }
+    throw new AssertionError(failure.getMessage());
+  }
+
   public RecordedResponse assertSentRequestAtMillis(long minimum, long maximum) {
     assertDateInRange(minimum, response.sentRequestAtMillis(), maximum);
     return this;
@@ -173,4 +188,8 @@ private void assertDateInRange(long minimum, long actual, long maximum) {
   private String format(long time) {
     return new SimpleDateFormat("HH:mm:ss.SSS").format(new Date(time));
   }
+
+  public String getBody() {
+    return body;
+  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/RecordingEventListener.java b/okhttp-tests/src/test/java/okhttp3/RecordingEventListener.java
new file mode 100644
index 0000000000..c945b7addd
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/RecordingEventListener.java
@@ -0,0 +1,414 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.Proxy;
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Deque;
+import java.util.List;
+import javax.annotation.Nullable;
+
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+public final class RecordingEventListener extends EventListener {
+  final Deque<CallEvent> eventSequence = new ArrayDeque<>();
+
+  final List<Object> forbiddenLocks = new ArrayList<>();
+
+  /** Confirm that the thread does not hold a lock on {@code lock} during the callback. */
+  public void forbidLock(Object lock) {
+    forbiddenLocks.add(lock);
+  }
+
+  /**
+   * Removes recorded events up to (and including) an event is found whose class equals
+   * {@code eventClass} and returns it.
+   */
+  public <T> T removeUpToEvent(Class<T> eventClass) {
+    Object event = eventSequence.poll();
+    while (event != null && !eventClass.isInstance(event)) {
+      event = eventSequence.poll();
+    }
+    if (event == null) throw new AssertionError();
+    return eventClass.cast(event);
+  }
+
+  public List<String> recordedEventTypes() {
+    List<String> eventTypes = new ArrayList<>();
+    for (CallEvent event : eventSequence) {
+      eventTypes.add(event.getName());
+    }
+    return eventTypes;
+  }
+
+  public void clearAllEvents() {
+    eventSequence.clear();
+  }
+
+  private void logEvent(CallEvent e) {
+    for (Object lock : forbiddenLocks) {
+      assertFalse(lock.toString(), Thread.holdsLock(lock));
+    }
+
+    CallEvent startEvent = e.closes();
+
+    if (startEvent != null) {
+      assertTrue(e.getName() + " without matching " + startEvent.getName(),
+          eventSequence.contains(startEvent));
+    }
+
+    eventSequence.offer(e);
+  }
+
+  @Override public void dnsStart(Call call, String domainName) {
+    logEvent(new DnsStart(call, domainName));
+  }
+
+  @Override public void dnsEnd(Call call, String domainName, List<InetAddress> inetAddressList) {
+    logEvent(new DnsEnd(call, domainName, inetAddressList));
+  }
+
+  @Override public void connectStart(Call call, InetSocketAddress inetSocketAddress,
+      Proxy proxy) {
+    logEvent(new ConnectStart(call, inetSocketAddress, proxy));
+  }
+
+  @Override public void secureConnectStart(Call call) {
+    logEvent(new SecureConnectStart(call));
+  }
+
+  @Override public void secureConnectEnd(Call call, Handshake handshake) {
+    logEvent(new SecureConnectEnd(call, handshake));
+  }
+
+  @Override public void connectEnd(Call call, InetSocketAddress inetSocketAddress,
+      @Nullable Proxy proxy, Protocol protocol) {
+    logEvent(new ConnectEnd(call, inetSocketAddress, proxy, protocol));
+  }
+
+  @Override public void connectFailed(Call call, InetSocketAddress inetSocketAddress,
+      @Nullable Proxy proxy, @Nullable Protocol protocol, @Nullable IOException ioe) {
+    logEvent(new ConnectFailed(call, inetSocketAddress, proxy, protocol, ioe));
+  }
+
+  @Override public void connectionAcquired(Call call, Connection connection) {
+    logEvent(new ConnectionAcquired(call, connection));
+  }
+
+  @Override public void connectionReleased(Call call, Connection connection) {
+    logEvent(new ConnectionReleased(call, connection));
+  }
+
+  @Override public void callStart(Call call) {
+    logEvent(new CallStart(call));
+  }
+
+  @Override public void requestHeadersStart(Call call) {
+    logEvent(new RequestHeadersStart(call));
+  }
+
+  @Override public void requestHeadersEnd(Call call, Request request) {
+    logEvent(new RequestHeadersEnd(call, request.headers.byteCount()));
+  }
+
+  @Override public void requestBodyStart(Call call) {
+    logEvent(new RequestBodyStart(call));
+  }
+
+  @Override public void requestBodyEnd(Call call, long byteCount) {
+    logEvent(new RequestBodyEnd(call, byteCount));
+  }
+
+  @Override public void responseHeadersStart(Call call) {
+    logEvent(new ResponseHeadersStart(call));
+  }
+
+  @Override public void responseHeadersEnd(Call call, Response response) {
+    logEvent(new ResponseHeadersEnd(call, response.headers.byteCount()));
+  }
+
+  @Override public void responseBodyStart(Call call) {
+    logEvent(new ResponseBodyStart(call));
+  }
+
+  @Override public void responseBodyEnd(Call call, long byteCount) {
+    logEvent(new ResponseBodyEnd(call, byteCount));
+  }
+
+  @Override public void callEnd(Call call) {
+    logEvent(new CallEnd(call));
+  }
+
+  @Override public void callFailed(Call call, IOException ioe) {
+    logEvent(new CallFailed(call, ioe));
+  }
+
+  static class CallEvent {
+    final Call call;
+    final List<Object> params;
+
+    CallEvent(Call call, Object... params) {
+      this.call = call;
+      this.params = Arrays.asList(params);
+    }
+
+    public String getName() {
+      return getClass().getSimpleName();
+    }
+
+    @Override public boolean equals(Object o) {
+      if (this == o) return true;
+      if (!(o instanceof CallEvent)) return false;
+
+      CallEvent callEvent = (CallEvent) o;
+
+      if (!getName().equals(callEvent.getName())) return false;
+      if (!call.equals(callEvent.call)) return false;
+      return params.equals(callEvent.params);
+    }
+
+    @Override public int hashCode() {
+      int result = call.hashCode();
+      result = 31 * result + getName().hashCode();
+      result = 31 * result + params.hashCode();
+      return result;
+    }
+
+    public @Nullable CallEvent closes() {
+      return null;
+    }
+  }
+
+  static final class DnsStart extends CallEvent {
+    final String domainName;
+
+    DnsStart(Call call, String domainName) {
+      super(call, domainName);
+      this.domainName = domainName;
+    }
+  }
+
+  static final class DnsEnd extends CallEvent {
+    final String domainName;
+    final List<InetAddress> inetAddressList;
+
+    DnsEnd(Call call, String domainName, List<InetAddress> inetAddressList) {
+      super(call, domainName, inetAddressList);
+      this.domainName = domainName;
+      this.inetAddressList = inetAddressList;
+    }
+
+    @Nullable @Override public CallEvent closes() {
+      return new DnsStart(call, domainName);
+    }
+  }
+
+  static final class ConnectStart extends CallEvent {
+    final InetSocketAddress inetSocketAddress;
+    final Proxy proxy;
+
+    ConnectStart(Call call, InetSocketAddress inetSocketAddress, Proxy proxy) {
+      super(call, inetSocketAddress, proxy);
+      this.inetSocketAddress = inetSocketAddress;
+      this.proxy = proxy;
+    }
+  }
+
+  static final class ConnectEnd extends CallEvent {
+    final InetSocketAddress inetSocketAddress;
+    final Protocol protocol;
+    final Proxy proxy;
+
+    ConnectEnd(Call call, InetSocketAddress inetSocketAddress, Proxy proxy, Protocol protocol) {
+      super(call, inetSocketAddress, proxy, protocol);
+      this.inetSocketAddress = inetSocketAddress;
+      this.proxy = proxy;
+      this.protocol = protocol;
+    }
+
+    @Override public CallEvent closes() {
+      return new ConnectStart(call, inetSocketAddress, proxy);
+    }
+  }
+
+  static final class ConnectFailed extends CallEvent {
+    final InetSocketAddress inetSocketAddress;
+    final Protocol protocol;
+    final Proxy proxy;
+    final IOException ioe;
+
+    ConnectFailed(Call call, InetSocketAddress inetSocketAddress, Proxy proxy, Protocol protocol,
+        IOException ioe) {
+      super(call, inetSocketAddress, proxy, protocol, ioe);
+      this.inetSocketAddress = inetSocketAddress;
+      this.proxy = proxy;
+      this.protocol = protocol;
+      this.ioe = ioe;
+    }
+
+    @Nullable @Override public CallEvent closes() {
+      return new ConnectStart(call, inetSocketAddress, proxy);
+    }
+  }
+
+  static final class SecureConnectStart extends CallEvent {
+    SecureConnectStart(Call call) {
+      super(call);
+    }
+  }
+
+  static final class SecureConnectEnd extends CallEvent {
+    final Handshake handshake;
+
+    SecureConnectEnd(Call call, Handshake handshake) {
+      super(call, handshake);
+      this.handshake = handshake;
+    }
+
+    @Nullable @Override public CallEvent closes() {
+      return new SecureConnectStart(call);
+    }
+  }
+
+  static final class ConnectionAcquired extends CallEvent {
+    final Connection connection;
+
+    ConnectionAcquired(Call call, Connection connection) {
+      super(call, connection);
+      this.connection = connection;
+    }
+  }
+
+  static final class ConnectionReleased extends CallEvent {
+    final Connection connection;
+
+    ConnectionReleased(Call call, Connection connection) {
+      super(call, connection);
+      this.connection = connection;
+    }
+
+    @Nullable @Override public CallEvent closes() {
+      return new ConnectionAcquired(call, connection);
+    }
+  }
+
+  static final class CallStart extends CallEvent {
+    CallStart(Call call) {
+      super(call);
+    }
+  }
+
+  static final class CallEnd extends CallEvent {
+    CallEnd(Call call) {
+      super(call);
+    }
+
+    @Nullable @Override public CallEvent closes() {
+      return new CallStart(call);
+    }
+  }
+
+  static final class CallFailed extends CallEvent {
+    final IOException ioe;
+
+    CallFailed(Call call, IOException ioe) {
+      super(call, ioe);
+      this.ioe = ioe;
+    }
+  }
+
+  static final class RequestHeadersStart extends CallEvent {
+    RequestHeadersStart(Call call) {
+      super(call);
+    }
+  }
+
+  static final class RequestHeadersEnd extends CallEvent {
+    final long headerLength;
+
+    RequestHeadersEnd(Call call, long headerLength) {
+      super(call, headerLength);
+      this.headerLength = headerLength;
+    }
+
+    @Nullable @Override public CallEvent closes() {
+      return new RequestHeadersStart(call);
+    }
+  }
+
+  static final class RequestBodyStart extends CallEvent {
+    RequestBodyStart(Call call) {
+      super(call);
+    }
+  }
+
+  static final class RequestBodyEnd extends CallEvent {
+    final long bytesWritten;
+
+    RequestBodyEnd(Call call, long bytesWritten) {
+      super(call, bytesWritten);
+      this.bytesWritten = bytesWritten;
+    }
+
+    @Nullable @Override public CallEvent closes() {
+      return new RequestBodyStart(call);
+    }
+  }
+
+  static final class ResponseHeadersStart extends CallEvent {
+    ResponseHeadersStart(Call call) {
+      super(call);
+    }
+  }
+
+  static final class ResponseHeadersEnd extends CallEvent {
+    final long headerLength;
+
+    ResponseHeadersEnd(Call call, long headerLength) {
+      super(call, headerLength);
+      this.headerLength = headerLength;
+    }
+
+    @Nullable @Override public CallEvent closes() {
+      return new RequestHeadersStart(call);
+    }
+  }
+
+  static final class ResponseBodyStart extends CallEvent {
+    ResponseBodyStart(Call call) {
+      super(call);
+    }
+  }
+
+  static final class ResponseBodyEnd extends CallEvent {
+    final long bytesRead;
+
+    ResponseBodyEnd(Call call, long bytesRead) {
+      super(call, bytesRead);
+      this.bytesRead = bytesRead;
+    }
+
+    @Nullable @Override public CallEvent closes() {
+      return new ResponseBodyStart(call);
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/RequestTest.java b/okhttp-tests/src/test/java/okhttp3/RequestTest.java
index 4668f6005d..5c205d7031 100644
--- a/okhttp-tests/src/test/java/okhttp3/RequestTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/RequestTest.java
@@ -156,8 +156,8 @@
 
   @Test public void headerAcceptsPermittedCharacters() throws Exception {
     Request.Builder builder = new Request.Builder();
-    builder.header("AZab09 ~", "AZab09 ~");
-    builder.addHeader("AZab09 ~", "AZab09 ~");
+    builder.header("AZab09~", "AZab09 ~");
+    builder.addHeader("AZab09~", "AZab09 ~");
   }
 
   @Test public void emptyNameForbidden() throws Exception {
@@ -198,11 +198,20 @@
     }
   }
 
+  @Test public void headerAllowsTabOnlyInValues() throws Exception {
+    Request.Builder builder = new Request.Builder();
+    builder.header("key", "sample\tvalue");
+    try {
+      builder.header("sample\tkey", "value");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
   @Test public void headerForbidsControlCharacters() throws Exception {
     assertForbiddenHeader("\u0000");
     assertForbiddenHeader("\r");
     assertForbiddenHeader("\n");
-    assertForbiddenHeader("\t");
     assertForbiddenHeader("\u001f");
     assertForbiddenHeader("\u007f");
     assertForbiddenHeader("\u0080");
diff --git a/okhttp-tests/src/test/java/okhttp3/ResponseBodyTest.java b/okhttp-tests/src/test/java/okhttp3/ResponseBodyTest.java
new file mode 100644
index 0000000000..47feecacb6
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/ResponseBodyTest.java
@@ -0,0 +1,412 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.Reader;
+import java.util.concurrent.atomic.AtomicBoolean;
+import okio.Buffer;
+import okio.BufferedSource;
+import okio.ByteString;
+import okio.ForwardingSource;
+import okio.Okio;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class ResponseBodyTest {
+  @Test public void stringEmpty() throws IOException {
+    ResponseBody body = body("");
+    assertEquals("", body.string());
+  }
+
+  @Test public void stringLooksLikeBomButTooShort() throws IOException {
+    ResponseBody body = body("000048");
+    assertEquals("\0\0H", body.string());
+  }
+
+  @Test public void stringDefaultsToUtf8() throws IOException {
+    ResponseBody body = body("68656c6c6f");
+    assertEquals("hello", body.string());
+  }
+
+  @Test public void stringExplicitCharset() throws IOException {
+    ResponseBody body = body("00000068000000650000006c0000006c0000006f", "utf-32be");
+    assertEquals("hello", body.string());
+  }
+
+  @Test public void stringBomOverridesExplicitCharset() throws IOException {
+    ResponseBody body = body("0000ffff00000068000000650000006c0000006c0000006f", "utf-8");
+    assertEquals("hello", body.string());
+  }
+
+  @Test public void stringBomUtf8() throws IOException {
+    ResponseBody body = body("efbbbf68656c6c6f");
+    assertEquals("hello", body.string());
+  }
+
+  @Test public void stringBomUtf16Be() throws IOException {
+    ResponseBody body = body("feff00680065006c006c006f");
+    assertEquals("hello", body.string());
+  }
+
+  @Test public void stringBomUtf16Le() throws IOException {
+    ResponseBody body = body("fffe680065006c006c006f00");
+    assertEquals("hello", body.string());
+  }
+
+  @Test public void stringBomUtf32Be() throws IOException {
+    ResponseBody body = body("0000ffff00000068000000650000006c0000006c0000006f");
+    assertEquals("hello", body.string());
+  }
+
+  @Test public void stringBomUtf32Le() throws IOException {
+    ResponseBody body = body("ffff000068000000650000006c0000006c0000006f000000");
+    assertEquals("hello", body.string());
+  }
+
+  @Test public void stringClosesUnderlyingSource() throws IOException {
+    final AtomicBoolean closed = new AtomicBoolean();
+    ResponseBody body = new ResponseBody() {
+      @Override public MediaType contentType() {
+        return null;
+      }
+
+      @Override public long contentLength() {
+        return 5;
+      }
+
+      @Override public BufferedSource source() {
+        Buffer source = new Buffer().writeUtf8("hello");
+        return Okio.buffer(new ForwardingSource(source) {
+          @Override public void close() throws IOException {
+            closed.set(true);
+            super.close();
+          }
+        });
+      }
+    };
+    assertEquals("hello", body.string());
+    assertTrue(closed.get());
+  }
+
+  @Test public void readerEmpty() throws IOException {
+    ResponseBody body = body("");
+    assertEquals("", exhaust(body.charStream()));
+  }
+
+  @Test public void readerLooksLikeBomButTooShort() throws IOException {
+    ResponseBody body = body("000048");
+    assertEquals("\0\0H", exhaust(body.charStream()));
+  }
+
+  @Test public void readerDefaultsToUtf8() throws IOException {
+    ResponseBody body = body("68656c6c6f");
+    assertEquals("hello", exhaust(body.charStream()));
+  }
+
+  @Test public void readerExplicitCharset() throws IOException {
+    ResponseBody body = body("00000068000000650000006c0000006c0000006f", "utf-32be");
+    assertEquals("hello", exhaust(body.charStream()));
+  }
+
+  @Test public void readerBomUtf8() throws IOException {
+    ResponseBody body = body("efbbbf68656c6c6f");
+    assertEquals("hello", exhaust(body.charStream()));
+  }
+
+  @Test public void readerBomUtf16Be() throws IOException {
+    ResponseBody body = body("feff00680065006c006c006f");
+    assertEquals("hello", exhaust(body.charStream()));
+  }
+
+  @Test public void readerBomUtf16Le() throws IOException {
+    ResponseBody body = body("fffe680065006c006c006f00");
+    assertEquals("hello", exhaust(body.charStream()));
+  }
+
+  @Test public void readerBomUtf32Be() throws IOException {
+    ResponseBody body = body("0000ffff00000068000000650000006c0000006c0000006f");
+    assertEquals("hello", exhaust(body.charStream()));
+  }
+
+  @Test public void readerBomUtf32Le() throws IOException {
+    ResponseBody body = body("ffff000068000000650000006c0000006c0000006f000000");
+    assertEquals("hello", exhaust(body.charStream()));
+  }
+
+  @Test public void readerClosedBeforeBomClosesUnderlyingSource() throws IOException {
+    final AtomicBoolean closed = new AtomicBoolean();
+    ResponseBody body = new ResponseBody() {
+      @Override public MediaType contentType() {
+        return null;
+      }
+
+      @Override public long contentLength() {
+        return 5;
+      }
+
+      @Override public BufferedSource source() {
+        ResponseBody body = body("fffe680065006c006c006f00");
+        return Okio.buffer(new ForwardingSource(body.source()) {
+          @Override public void close() throws IOException {
+            closed.set(true);
+            super.close();
+          }
+        });
+      }
+    };
+    body.charStream().close();
+    assertTrue(closed.get());
+  }
+
+  @Test public void readerClosedAfterBomClosesUnderlyingSource() throws IOException {
+    final AtomicBoolean closed = new AtomicBoolean();
+    ResponseBody body = new ResponseBody() {
+      @Override public MediaType contentType() {
+        return null;
+      }
+
+      @Override public long contentLength() {
+        return 5;
+      }
+
+      @Override public BufferedSource source() {
+        ResponseBody body = body("fffe680065006c006c006f00");
+        return Okio.buffer(new ForwardingSource(body.source()) {
+          @Override public void close() throws IOException {
+            closed.set(true);
+            super.close();
+          }
+        });
+      }
+    };
+    Reader reader = body.charStream();
+    assertEquals('h', reader.read());
+    reader.close();
+    assertTrue(closed.get());
+  }
+
+  @Test public void sourceEmpty() throws IOException {
+    ResponseBody body = body("");
+    BufferedSource source = body.source();
+    assertTrue(source.exhausted());
+    assertEquals("", source.readUtf8());
+  }
+
+  @Test public void sourceSeesBom() throws IOException {
+    ResponseBody body = body("efbbbf68656c6c6f");
+    BufferedSource source = body.source();
+    assertEquals(0xef, source.readByte() & 0xff);
+    assertEquals(0xbb, source.readByte() & 0xff);
+    assertEquals(0xbf, source.readByte() & 0xff);
+    assertEquals("hello", source.readUtf8());
+  }
+
+  @Test public void sourceClosesUnderlyingSource() throws IOException {
+    final AtomicBoolean closed = new AtomicBoolean();
+    ResponseBody body = new ResponseBody() {
+      @Override public MediaType contentType() {
+        return null;
+      }
+
+      @Override public long contentLength() {
+        return 5;
+      }
+
+      @Override public BufferedSource source() {
+        Buffer source = new Buffer().writeUtf8("hello");
+        return Okio.buffer(new ForwardingSource(source) {
+          @Override public void close() throws IOException {
+            closed.set(true);
+            super.close();
+          }
+        });
+      }
+    };
+    body.source().close();
+    assertTrue(closed.get());
+  }
+
+  @Test public void bytesEmpty() throws IOException {
+    ResponseBody body = body("");
+    assertEquals(0, body.bytes().length);
+  }
+
+  @Test public void bytesSeesBom() throws IOException {
+    ResponseBody body = body("efbbbf68656c6c6f");
+    byte[] bytes = body.bytes();
+    assertEquals(0xef, bytes[0] & 0xff);
+    assertEquals(0xbb, bytes[1] & 0xff);
+    assertEquals(0xbf, bytes[2] & 0xff);
+    assertEquals("hello", new String(bytes, 3, 5, "UTF-8"));
+  }
+
+  @Test public void bytesClosesUnderlyingSource() throws IOException {
+    final AtomicBoolean closed = new AtomicBoolean();
+    ResponseBody body = new ResponseBody() {
+      @Override public MediaType contentType() {
+        return null;
+      }
+
+      @Override public long contentLength() {
+        return 5;
+      }
+
+      @Override public BufferedSource source() {
+        Buffer source = new Buffer().writeUtf8("hello");
+        return Okio.buffer(new ForwardingSource(source) {
+          @Override public void close() throws IOException {
+            closed.set(true);
+            super.close();
+          }
+        });
+      }
+    };
+    assertEquals(5, body.bytes().length);
+    assertTrue(closed.get());
+  }
+
+  @Test public void bytesThrowsWhenLengthsDisagree() {
+    ResponseBody body = new ResponseBody() {
+      @Override public MediaType contentType() {
+        return null;
+      }
+
+      @Override public long contentLength() {
+        return 10;
+      }
+
+      @Override public BufferedSource source() {
+        return new Buffer().writeUtf8("hello");
+      }
+    };
+    try {
+      body.bytes();
+      fail();
+    } catch (IOException e) {
+      assertEquals("Content-Length (10) and stream length (5) disagree", e.getMessage());
+    }
+  }
+
+  @Test public void bytesThrowsMoreThanIntMaxValue() {
+    ResponseBody body = new ResponseBody() {
+      @Override public MediaType contentType() {
+        return null;
+      }
+
+      @Override public long contentLength() {
+        return Integer.MAX_VALUE + 1L;
+      }
+
+      @Override public BufferedSource source() {
+        throw new AssertionError();
+      }
+    };
+    try {
+      body.bytes();
+      fail();
+    } catch (IOException e) {
+      assertEquals("Cannot buffer entire body for content length: 2147483648", e.getMessage());
+    }
+  }
+
+  @Test public void byteStreamEmpty() throws IOException {
+    ResponseBody body = body("");
+    InputStream bytes = body.byteStream();
+    assertEquals(-1, bytes.read());
+  }
+
+  @Test public void byteStreamSeesBom() throws IOException {
+    ResponseBody body = body("efbbbf68656c6c6f");
+    InputStream bytes = body.byteStream();
+    assertEquals(0xef, bytes.read());
+    assertEquals(0xbb, bytes.read());
+    assertEquals(0xbf, bytes.read());
+    assertEquals("hello", exhaust(new InputStreamReader(bytes, "utf-8")));
+  }
+
+  @Test public void byteStreamClosesUnderlyingSource() throws IOException {
+    final AtomicBoolean closed = new AtomicBoolean();
+    ResponseBody body = new ResponseBody() {
+      @Override public MediaType contentType() {
+        return null;
+      }
+
+      @Override public long contentLength() {
+        return 5;
+      }
+
+      @Override public BufferedSource source() {
+        Buffer source = new Buffer().writeUtf8("hello");
+        return Okio.buffer(new ForwardingSource(source) {
+          @Override public void close() throws IOException {
+            closed.set(true);
+            super.close();
+          }
+        });
+      }
+    };
+    body.byteStream().close();
+    assertTrue(closed.get());
+  }
+
+  @Test public void throwingUnderlyingSourceClosesQuietly() throws IOException {
+    ResponseBody body = new ResponseBody() {
+      @Override public MediaType contentType() {
+        return null;
+      }
+
+      @Override public long contentLength() {
+        return 5;
+      }
+
+      @Override public BufferedSource source() {
+        Buffer source = new Buffer().writeUtf8("hello");
+        return Okio.buffer(new ForwardingSource(source) {
+          @Override public void close() throws IOException {
+            throw new IOException("Broken!");
+          }
+        });
+      }
+    };
+    assertEquals("hello", body.source().readUtf8());
+    body.close();
+  }
+
+  static ResponseBody body(String hex) {
+    return body(hex, null);
+  }
+
+  static ResponseBody body(String hex, String charset) {
+    MediaType mediaType = charset == null ? null : MediaType.parse("any/thing; charset=" + charset);
+    return ResponseBody.create(mediaType, ByteString.decodeHex(hex).toByteArray());
+  }
+
+  static String exhaust(Reader reader) throws IOException {
+    StringBuilder builder = new StringBuilder();
+    char[] buf = new char[10];
+    int read;
+    while ((read = reader.read(buf)) != -1) {
+      builder.append(buf, 0, read);
+    }
+    return builder.toString();
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/ResponseTest.java b/okhttp-tests/src/test/java/okhttp3/ResponseTest.java
index 8977fdf441..5d77a02a26 100644
--- a/okhttp-tests/src/test/java/okhttp3/ResponseTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/ResponseTest.java
@@ -95,6 +95,7 @@ private Response newResponse(ResponseBody responseBody) {
             .build())
         .protocol(Protocol.HTTP_1_1)
         .code(200)
+        .message("OK")
         .body(responseBody)
         .build();
   }
diff --git a/okhttp-tests/src/test/java/okhttp3/SocksProxy.java b/okhttp-tests/src/test/java/okhttp3/SocksProxy.java
index 9c1b5a83cb..d56241ac91 100644
--- a/okhttp-tests/src/test/java/okhttp3/SocksProxy.java
+++ b/okhttp-tests/src/test/java/okhttp3/SocksProxy.java
@@ -23,6 +23,9 @@
 import java.net.ServerSocket;
 import java.net.Socket;
 import java.net.SocketException;
+import java.util.Collections;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.TimeUnit;
@@ -41,7 +44,7 @@
  * See <a href="https://www.ietf.org/rfc/rfc1928.txt">RFC 1928</a>.
  */
 public final class SocksProxy {
-  public final String HOSTNAME_THAT_ONLY_THE_PROXY_KNOWS = "onlyProxyCanResolveMe.org";
+  public static final String HOSTNAME_THAT_ONLY_THE_PROXY_KNOWS = "onlyProxyCanResolveMe.org";
 
   private static final int VERSION_5 = 5;
   private static final int METHOD_NONE = 0xff;
@@ -58,6 +61,8 @@
 
   private ServerSocket serverSocket;
   private AtomicInteger connectionCount = new AtomicInteger();
+  private final Set<Socket> openSockets =
+      Collections.newSetFromMap(new ConcurrentHashMap<Socket, Boolean>());
 
   public void play() throws IOException {
     serverSocket = new ServerSocket(0);
@@ -73,6 +78,10 @@ public void play() throws IOException {
           logger.info(name + " done accepting connections: " + e.getMessage());
         } catch (IOException e) {
           logger.log(Level.WARNING, name + " failed unexpectedly", e);
+        } finally {
+          for (Socket socket : openSockets) {
+            Util.closeQuietly(socket);
+          }
         }
       }
     });
@@ -103,6 +112,7 @@ private void service(final Socket from) {
           BufferedSink fromSink = Okio.buffer(Okio.sink(from));
           hello(fromSource, fromSink);
           acceptCommand(from.getInetAddress(), fromSource, fromSink);
+          openSockets.add(from);
         } catch (IOException e) {
           logger.log(Level.WARNING, name + " failed", e);
           Util.closeQuietly(from);
@@ -160,7 +170,7 @@ private void acceptCommand(InetAddress fromAddress, BufferedSource fromSource,
         String domainName = fromSource.readUtf8(domainNameLength);
         // Resolve HOSTNAME_THAT_ONLY_THE_PROXY_KNOWS to localhost.
         toAddress = domainName.equalsIgnoreCase(HOSTNAME_THAT_ONLY_THE_PROXY_KNOWS)
-            ? InetAddress.getLoopbackAddress()
+            ? InetAddress.getByName("localhost")
             : InetAddress.getByName(domainName);
         break;
 
@@ -192,6 +202,8 @@ private void acceptCommand(InetAddress fromAddress, BufferedSource fromSource,
         // Copy sources to sinks in both directions.
         BufferedSource toSource = Okio.buffer(Okio.source(toSocket));
         BufferedSink toSink = Okio.buffer(Okio.sink(toSocket));
+        openSockets.add(toSocket);
+
         transfer(fromAddress, toAddress, fromSource, toSink);
         transfer(fromAddress, toAddress, toSource, fromSink);
         break;
diff --git a/okhttp-tests/src/test/java/okhttp3/SocksProxyTest.java b/okhttp-tests/src/test/java/okhttp3/SocksProxyTest.java
index f74cb6f075..83a6617b90 100644
--- a/okhttp-tests/src/test/java/okhttp3/SocksProxyTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/SocksProxyTest.java
@@ -28,6 +28,7 @@
 import org.junit.Before;
 import org.junit.Test;
 
+import static okhttp3.TestUtil.defaultClient;
 import static org.junit.Assert.assertEquals;
 
 public final class SocksProxyTest {
@@ -48,7 +49,7 @@
     server.enqueue(new MockResponse().setBody("abc"));
     server.enqueue(new MockResponse().setBody("def"));
 
-    OkHttpClient client = new OkHttpClient.Builder()
+    OkHttpClient client = defaultClient().newBuilder()
         .proxy(socksProxy.proxy())
         .build();
 
@@ -77,7 +78,7 @@
       }
     };
 
-    OkHttpClient client = new OkHttpClient.Builder()
+    OkHttpClient client = defaultClient().newBuilder()
         .proxySelector(proxySelector)
         .build();
 
@@ -92,13 +93,13 @@
     // This testcase will fail if the target is resolved locally instead of through the proxy.
     server.enqueue(new MockResponse().setBody("abc"));
 
-    OkHttpClient client = new OkHttpClient.Builder()
+    OkHttpClient client = defaultClient().newBuilder()
         .proxy(socksProxy.proxy())
         .build();
 
     HttpUrl url = server.url("/")
         .newBuilder()
-        .host(socksProxy.HOSTNAME_THAT_ONLY_THE_PROXY_KNOWS)
+        .host(SocksProxy.HOSTNAME_THAT_ONLY_THE_PROXY_KNOWS)
         .build();
 
     Request request = new Request.Builder().url(url).build();
diff --git a/okhttp-tests/src/test/java/okhttp3/TestLogHandler.java b/okhttp-tests/src/test/java/okhttp3/TestLogHandler.java
index 10f3cbb9d2..0ec9bc34fb 100644
--- a/okhttp-tests/src/test/java/okhttp3/TestLogHandler.java
+++ b/okhttp-tests/src/test/java/okhttp3/TestLogHandler.java
@@ -15,8 +15,9 @@
  */
 package okhttp3;
 
-import java.util.ArrayList;
-import java.util.List;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.TimeUnit;
 import java.util.logging.Handler;
 import java.util.logging.LogRecord;
 
@@ -25,23 +26,27 @@
  * assertions about them.
  */
 public final class TestLogHandler extends Handler {
-  private final List<String> logs = new ArrayList<>();
+  private final BlockingQueue<String> logs = new LinkedBlockingQueue<>();
 
-  @Override public synchronized void publish(LogRecord logRecord) {
-    logs.add(logRecord.getLevel() + ": " + logRecord.getMessage());
-    notifyAll();
+  @Override public void publish(LogRecord logRecord) {
+    if (getFormatter() == null) {
+      logs.add(logRecord.getLevel() + ": " + logRecord.getMessage());
+    } else {
+      logs.add(getFormatter().format(logRecord));
+    }
   }
 
   @Override public void flush() {
   }
 
-  @Override public void close() throws SecurityException {
+  @Override public void close() {
   }
 
-  public synchronized String take() throws InterruptedException {
-    while (logs.isEmpty()) {
-      wait();
+  public String take() throws InterruptedException {
+    String message = logs.poll(10, TimeUnit.SECONDS);
+    if (message == null) {
+      throw new AssertionError("Timed out waiting for log message.");
     }
-    return logs.remove(0);
+    return message;
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/TestUtil.java b/okhttp-tests/src/test/java/okhttp3/TestUtil.java
index a4581960eb..fa7435ffc3 100644
--- a/okhttp-tests/src/test/java/okhttp3/TestUtil.java
+++ b/okhttp-tests/src/test/java/okhttp3/TestUtil.java
@@ -1,19 +1,21 @@
 package okhttp3;
 
+import java.net.InetSocketAddress;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collection;
-import java.util.LinkedHashSet;
 import java.util.List;
-import java.util.Set;
 import okhttp3.internal.SingleInetAddressDns;
-import okhttp3.internal.framed.Header;
+import okhttp3.internal.http2.Header;
 
 public final class TestUtil {
+  public static final InetSocketAddress UNREACHABLE_ADDRESS
+      = new InetSocketAddress("198.51.100.1", 8080);
+
   private TestUtil() {
   }
 
   private static final ConnectionPool connectionPool = new ConnectionPool();
+  private static final Dispatcher dispatcher = new Dispatcher();
 
   /**
    * Returns an OkHttpClient for all tests to use as a starting point.
@@ -27,6 +29,7 @@ private TestUtil() {
   public static OkHttpClient defaultClient() {
     return new OkHttpClient.Builder()
         .connectionPool(connectionPool)
+        .dispatcher(dispatcher)
         .dns(new SingleInetAddressDns()) // Prevent unexpected fallback addresses.
         .build();
   }
@@ -39,17 +42,20 @@ public static OkHttpClient defaultClient() {
     return result;
   }
 
-  public static <T> Set<T> setOf(T... elements) {
-    return setOf(Arrays.asList(elements));
-  }
-
-  public static <T> Set<T> setOf(Collection<T> elements) {
-    return new LinkedHashSet<>(elements);
-  }
-
   public static String repeat(char c, int count) {
     char[] array = new char[count];
     Arrays.fill(array, c);
     return new String(array);
   }
+
+  /**
+   * See FinalizationTester for discussion on how to best trigger GC in tests.
+   * https://android.googlesource.com/platform/libcore/+/master/support/src/test/java/libcore/
+   * java/lang/ref/FinalizationTester.java
+   */
+  public static void awaitGarbageCollection() throws InterruptedException {
+    Runtime.getRuntime().gc();
+    Thread.sleep(100);
+    System.runFinalization();
+  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java b/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
index cdfc26a76d..29558b123f 100644
--- a/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
@@ -20,9 +20,11 @@
 import java.io.OutputStream;
 import java.net.Authenticator;
 import java.net.ConnectException;
+import java.net.CookieManager;
 import java.net.HttpRetryException;
 import java.net.HttpURLConnection;
 import java.net.InetAddress;
+import java.net.PasswordAuthentication;
 import java.net.ProtocolException;
 import java.net.Proxy;
 import java.net.ProxySelector;
@@ -47,6 +49,7 @@
 import java.util.Random;
 import java.util.Set;
 import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicReference;
 import java.util.zip.GZIPInputStream;
 import javax.net.ServerSocketFactory;
 import javax.net.SocketFactory;
@@ -54,6 +57,7 @@
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLException;
 import javax.net.ssl.SSLHandshakeException;
+import javax.net.ssl.SSLProtocolException;
 import javax.net.ssl.SSLSocketFactory;
 import javax.net.ssl.TrustManager;
 import javax.net.ssl.TrustManagerFactory;
@@ -65,6 +69,7 @@
 import okhttp3.internal.SingleInetAddressDns;
 import okhttp3.internal.Util;
 import okhttp3.internal.Version;
+import okhttp3.internal.huc.OkHttpURLConnection;
 import okhttp3.internal.tls.SslClient;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
@@ -85,9 +90,9 @@
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
 import static okhttp3.TestUtil.defaultClient;
 import static okhttp3.internal.Util.UTF_8;
-import static okhttp3.internal.http.OkHeaders.SELECTED_PROTOCOL;
 import static okhttp3.internal.http.StatusLine.HTTP_PERM_REDIRECT;
 import static okhttp3.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
+import static okhttp3.internal.huc.OkHttpURLConnection.SELECTED_PROTOCOL;
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
@@ -309,7 +314,8 @@ private void testRequestBodySurvivesRetries(TransferKind transferKind) throws Ex
     // Use a misconfigured proxy to guarantee that the request is retried.
     urlFactory.setClient(urlFactory.client().newBuilder()
         .proxySelector(new FakeProxySelector()
-            .addProxy(server2.toProxyAddress()))
+            .addProxy(server2.toProxyAddress())
+            .addProxy(Proxy.NO_PROXY))
         .build());
     server2.shutdown();
 
@@ -322,6 +328,29 @@ private void testRequestBodySurvivesRetries(TransferKind transferKind) throws Ex
     assertEquals("body", server.takeRequest().getBody().readUtf8());
   }
 
+  @Test public void streamedBodyIsNotRetried() throws Exception {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AFTER_REQUEST));
+
+    urlFactory = new OkUrlFactory(defaultClient().newBuilder()
+        .dns(new DoubleInetAddressDns())
+        .build());
+    HttpURLConnection connection = urlFactory.open(server.url("/").url());
+    connection.setDoOutput(true);
+    connection.setChunkedStreamingMode(100);
+    OutputStream os = connection.getOutputStream();
+    os.write("OutputStream is no fun.".getBytes("UTF-8"));
+    os.close();
+
+    try {
+      connection.getResponseCode();
+      fail();
+    } catch (IOException expected) {
+    }
+
+    assertEquals(1, server.getRequestCount());
+  }
+
   @Test public void getErrorStreamOnSuccessfulRequest() throws Exception {
     server.enqueue(new MockResponse().setBody("A"));
     connection = urlFactory.open(server.url("/").url());
@@ -405,6 +434,9 @@ private void testRequestBodySurvivesRetries(TransferKind transferKind) throws Ex
   @Test public void invalidHost() throws Exception {
     // Note that 1234.1.1.1 is an invalid host in a URI, but URL isn't as strict.
     URL url = new URL("http://1234.1.1.1/index.html");
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .dns(new FakeDns())
+        .build());
     HttpURLConnection connection = urlFactory.open(url);
     try {
       connection.connect();
@@ -567,7 +599,15 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
     assertNotNull(httpsConnection.getCipherSuite());
   }
 
-  @Test public void connectViaHttpsReusingConnections() throws IOException, InterruptedException {
+  @Test public void connectViaHttpsReusingConnections() throws Exception {
+    connectViaHttpsReusingConnections(false);
+  }
+
+  @Test public void connectViaHttpsReusingConnectionsAfterRebuildingClient() throws Exception {
+    connectViaHttpsReusingConnections(true);
+  }
+
+  private void connectViaHttpsReusingConnections(boolean rebuildClient) throws Exception {
     server.useHttps(sslClient.socketFactory, false);
     server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
     server.enqueue(new MockResponse().setBody("another response via HTTPS"));
@@ -576,13 +616,29 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
     SSLSocketFactory clientSocketFactory = sslClient.socketFactory;
     RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
 
-    urlFactory.setClient(urlFactory.client().newBuilder()
+    CookieJar cookieJar = new JavaNetCookieJar(new CookieManager());
+    ConnectionPool connectionPool = new ConnectionPool();
+
+    urlFactory.setClient(new OkHttpClient.Builder()
+        .cache(cache)
+        .connectionPool(connectionPool)
+        .cookieJar(cookieJar)
         .sslSocketFactory(clientSocketFactory, sslClient.trustManager)
         .hostnameVerifier(hostnameVerifier)
         .build());
     connection = urlFactory.open(server.url("/").url());
     assertContent("this response comes via HTTPS", connection);
 
+    if (rebuildClient) {
+      urlFactory.setClient(new OkHttpClient.Builder()
+          .cache(cache)
+          .connectionPool(connectionPool)
+          .cookieJar(cookieJar)
+          .sslSocketFactory(clientSocketFactory, sslClient.trustManager)
+          .hostnameVerifier(hostnameVerifier)
+          .build());
+    }
+
     connection = urlFactory.open(server.url("/").url());
     assertContent("another response via HTTPS", connection);
 
@@ -632,6 +688,7 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
 
     urlFactory.setClient(urlFactory.client().newBuilder()
         .hostnameVerifier(new RecordingHostnameVerifier())
+        .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS))
         .sslSocketFactory(suppressTlsFallbackClientSocketFactory(), sslClient.trustManager)
         .build());
     connection = urlFactory.open(server.url("/foo").url());
@@ -653,6 +710,7 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
 
     urlFactory.setClient(urlFactory.client().newBuilder()
         .dns(new SingleInetAddressDns())
+        .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS))
         .hostnameVerifier(new RecordingHostnameVerifier())
         .sslSocketFactory(suppressTlsFallbackClientSocketFactory(), sslClient.trustManager)
         .build());
@@ -1102,6 +1160,33 @@ private void initResponseCache() throws IOException {
     in.close();
   }
 
+  @Test public void disconnectDuringConnect_cookieJar() throws Exception {
+    final AtomicReference<HttpURLConnection> connectionHolder = new AtomicReference<>();
+    class DisconnectingCookieJar implements CookieJar {
+      @Override public void saveFromResponse(HttpUrl url, List<Cookie> cookies) { }
+      @Override
+      public List<Cookie> loadForRequest(HttpUrl url) {
+        connectionHolder.get().disconnect();
+        return Collections.emptyList();
+      }
+    }
+    OkHttpClient client = new okhttp3.OkHttpClient.Builder()
+            .cookieJar(new DisconnectingCookieJar())
+            .build();
+
+    URL url = server.url("path that should never be accessed").url();
+    HttpURLConnection connection = new OkHttpURLConnection(url, client);
+    connectionHolder.set(connection);
+    try {
+      connection.getInputStream();
+      fail("Connection should not be established");
+    } catch (IOException expected) {
+      assertEquals("Canceled", expected.getMessage());
+    } finally {
+      connection.disconnect();
+    }
+  }
+
   @Test public void disconnectBeforeConnect() throws IOException {
     server.enqueue(new MockResponse().setBody("A"));
 
@@ -1493,11 +1578,6 @@ private void testAuthenticateWithStreamingPost(StreamingMode streamingMode) thro
     postBodyRetransmittedAfterAuthorizationFail("abc");
   }
 
-  @Test public void postBodyRetransmittedAfterAuthorizationFail_SPDY_3() throws Exception {
-    enableProtocol(Protocol.SPDY_3);
-    postBodyRetransmittedAfterAuthorizationFail("abc");
-  }
-
   @Test public void postBodyRetransmittedAfterAuthorizationFail_HTTP_2() throws Exception {
     enableProtocol(Protocol.HTTP_2);
     postBodyRetransmittedAfterAuthorizationFail("abc");
@@ -1508,11 +1588,6 @@ private void testAuthenticateWithStreamingPost(StreamingMode streamingMode) thro
     postBodyRetransmittedAfterAuthorizationFail("");
   }
 
-  @Test public void postEmptyBodyRetransmittedAfterAuthorizationFail_SPDY_3() throws Exception {
-    enableProtocol(Protocol.SPDY_3);
-    postBodyRetransmittedAfterAuthorizationFail("");
-  }
-
   @Test public void postEmptyBodyRetransmittedAfterAuthorizationFail_HTTP_2() throws Exception {
     enableProtocol(Protocol.HTTP_2);
     postBodyRetransmittedAfterAuthorizationFail("");
@@ -1533,6 +1608,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     outputStream.write(body.getBytes("UTF-8"));
     outputStream.close();
     assertEquals(200, connection.getResponseCode());
+    connection.getInputStream().close();
 
     RecordedRequest recordedRequest1 = server.takeRequest();
     assertEquals("POST", recordedRequest1.getMethod());
@@ -1853,6 +1929,37 @@ private void testSecureStreamingPost(StreamingMode streamingMode) throws Excepti
     }
   }
 
+  @Test public void authenticateWithCharset() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(401)
+        .addHeader("WWW-Authenticate: Basic realm=\"protected area\", charset=\"UTF-8\"")
+        .setBody("Please authenticate with UTF-8."));
+    server.enqueue(new MockResponse().setResponseCode(401)
+        .addHeader("WWW-Authenticate: Basic realm=\"protected area\"")
+        .setBody("Please authenticate with ISO-8859-1."));
+    server.enqueue(new MockResponse()
+        .setBody("Successful auth!"));
+
+    Authenticator.setDefault(new RecordingAuthenticator(
+        new PasswordAuthentication("username", "mötorhead".toCharArray())));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .authenticator(new JavaNetAuthenticator())
+        .build());
+    connection = urlFactory.open(server.url("/").url());
+    assertEquals("Successful auth!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
+
+    // No authorization header for the first request...
+    RecordedRequest request1 = server.takeRequest();
+    assertNull(request1.getHeader("Authorization"));
+
+    // UTF-8 encoding for the first credential.
+    RecordedRequest request2 = server.takeRequest();
+    assertEquals("Basic dXNlcm5hbWU6bcO2dG9yaGVhZA==", request2.getHeader("Authorization"));
+
+    // ISO-8859-1 encoding for the second credential.
+    RecordedRequest request3 = server.takeRequest();
+    assertEquals("Basic dXNlcm5hbWU6bfZ0b3JoZWFk", request3.getHeader("Authorization"));
+  }
+
   /** https://code.google.com/p/android/issues/detail?id=74026 */
   @Test public void authenticateWithGetAndTransparentGzip() throws Exception {
     MockResponse pleaseAuthenticate = new MockResponse().setResponseCode(401)
@@ -2068,7 +2175,7 @@ private void redirectToAnotherOriginServer(boolean https) throws Exception {
   }
 
   @Test public void redirectWithProxySelector() throws Exception {
-    final List<URI> proxySelectionRequests = new ArrayList<URI>();
+    final List<URI> proxySelectionRequests = new ArrayList<>();
     urlFactory.setClient(urlFactory.client().newBuilder()
         .proxySelector(new ProxySelector() {
           @Override public List<Proxy> select(URI uri) {
@@ -2309,7 +2416,6 @@ private void testRedirect(boolean temporary, String method) throws Exception {
     } catch (ProtocolException expected) {
       assertEquals(HttpURLConnection.HTTP_MOVED_TEMP, connection.getResponseCode());
       assertEquals("Too many follow-up requests: 21", expected.getMessage());
-      assertContent("Redirecting to /21", connection);
       assertEquals(server.url("/20").url(), connection.getURL());
     }
   }
@@ -2384,6 +2490,7 @@ private void enqueueClientRequestTimeoutResponses() {
 
     assertEquals(408, connection.getResponseCode());
     assertEquals(1, server.getRequestCount());
+    connection.getErrorStream().close();
   }
 
   @Test public void readTimeouts() throws IOException {
@@ -2518,9 +2625,8 @@ protected ServerSocket configureServerSocket(ServerSocket serverSocket)
    * https://code.google.com/p/android/issues/detail?id=41576
    */
   @Test public void sameConnectionRedirectAndReuse() throws Exception {
-    // TODO(jwilson): this behavior shouldn't rely on having another IP address to attempt.
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .dns(new DoubleInetAddressDns())
+        .dns(new SingleInetAddressDns())
         .build());
     server.enqueue(new MockResponse()
         .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
@@ -2536,12 +2642,17 @@ protected ServerSocket configureServerSocket(ServerSocket serverSocket)
   }
 
   @Test public void responseCodeDisagreesWithHeaders() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NO_CONTENT)
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NO_CONTENT)
         .setBody("This body is not allowed!"));
 
     URLConnection connection = urlFactory.open(server.url("/").url());
-    assertEquals("This body is not allowed!",
-        readAscii(connection.getInputStream(), Integer.MAX_VALUE));
+    try {
+      connection.getInputStream();
+      fail();
+    } catch (IOException expected) {
+      assertEquals("HTTP 204 had non-zero Content-Length: 25", expected.getMessage());
+    }
   }
 
   @Test public void singleByteReadIsSigned() throws IOException {
@@ -2614,6 +2725,9 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
   }
 
   @Test public void dnsFailureThrowsIOException() throws IOException {
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .dns(new FakeDns())
+        .build());
     connection = urlFactory.open(new URL("http://host.unlikelytld"));
     try {
       connection.connect();
@@ -2949,16 +3063,6 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
     fail("TODO");
   }
 
-  @Test @Ignore public void headerNamesContainingNullCharacter() {
-    // This is relevant for SPDY
-    fail("TODO");
-  }
-
-  @Test @Ignore public void headerValuesContainingNullCharacter() {
-    // This is relevant for SPDY
-    fail("TODO");
-  }
-
   @Test public void emptyRequestHeaderValueIsAllowed() throws Exception {
     server.enqueue(new MockResponse().setBody("body"));
     connection = urlFactory.open(server.url("/").url());
@@ -3153,10 +3257,6 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
     }
   }
 
-  @Test public void setsNegotiatedProtocolHeader_SPDY_3() throws Exception {
-    setsNegotiatedProtocolHeader(Protocol.SPDY_3);
-  }
-
   @Test public void setsNegotiatedProtocolHeader_HTTP_2() throws Exception {
     setsNegotiatedProtocolHeader(Protocol.HTTP_2);
   }
@@ -3192,11 +3292,6 @@ private void setsNegotiatedProtocolHeader(Protocol protocol) throws IOException
     zeroLengthPayload("POST");
   }
 
-  @Test public void zeroLengthPost_SPDY_3() throws Exception {
-    enableProtocol(Protocol.SPDY_3);
-    zeroLengthPost();
-  }
-
   @Test public void zeroLengthPost_HTTP_2() throws Exception {
     enableProtocol(Protocol.HTTP_2);
     zeroLengthPost();
@@ -3207,11 +3302,6 @@ private void setsNegotiatedProtocolHeader(Protocol protocol) throws IOException
     zeroLengthPayload("PUT");
   }
 
-  @Test public void zeroLengthPut_SPDY_3() throws Exception {
-    enableProtocol(Protocol.SPDY_3);
-    zeroLengthPut();
-  }
-
   @Test public void zeroLengthPut_HTTP_2() throws Exception {
     enableProtocol(Protocol.HTTP_2);
     zeroLengthPut();
@@ -3256,7 +3346,7 @@ private void zeroLengthPayload(String method)
 
   @Test public void setProtocolsWithoutHttp11() throws Exception {
     try {
-      new OkHttpClient.Builder().protocols(Arrays.asList(Protocol.SPDY_3));
+      new OkHttpClient.Builder().protocols(Arrays.asList(Protocol.HTTP_2));
       fail();
     } catch (IllegalArgumentException expected) {
     }
@@ -3291,6 +3381,23 @@ private void zeroLengthPayload(String method)
     assertEquals(Long.toString(contentLength), request.getHeader("Content-Length"));
   }
 
+  @Test public void testNoSslFallback() throws Exception {
+    server.useHttps(sslClient.socketFactory, false /* tunnelProxy */);
+    server.enqueue(new MockResponse().setSocketPolicy(FAIL_HANDSHAKE));
+    server.enqueue(new MockResponse().setBody("Response that would have needed fallbacks"));
+
+    HttpsURLConnection connection = (HttpsURLConnection) server.url("/").url().openConnection();
+    connection.setSSLSocketFactory(sslClient.socketFactory);
+    try {
+      connection.getInputStream();
+      fail();
+    } catch (SSLProtocolException expected) {
+      // RI response to the FAIL_HANDSHAKE
+    } catch (SSLHandshakeException expected) {
+      // Android's response to the FAIL_HANDSHAKE
+    }
+  }
+
   /**
    * We had a bug where we attempted to gunzip responses that didn't have a body. This only came up
    * with 304s since that response code can include headers (like "Content-Encoding") without any
@@ -3461,6 +3568,7 @@ private void zeroLengthPayload(String method)
   @Test public void setSslSocketFactoryFailsOnJdk9() throws Exception {
     assumeTrue(getPlatform().equals("jdk9"));
 
+    enableProtocol(Protocol.HTTP_2);
     URL url = server.url("/").url();
     HttpsURLConnection connection = (HttpsURLConnection) urlFactory.open(url);
     try {
@@ -3470,6 +3578,98 @@ private void zeroLengthPayload(String method)
     }
   }
 
+  /** Confirm that runtime exceptions thrown inside of OkHttp propagate to the caller. */
+  @Test public void unexpectedExceptionSync() throws Exception {
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .dns(new Dns() {
+          @Override public List<InetAddress> lookup(String hostname) {
+            throw new RuntimeException("boom!");
+          }
+        })
+        .build());
+
+    server.enqueue(new MockResponse());
+
+    HttpURLConnection connection = urlFactory.open(server.url("/").url());
+    try {
+      connection.getResponseCode(); // Use the synchronous implementation.
+      fail();
+    } catch (RuntimeException expected) {
+      assertEquals("boom!", expected.getMessage());
+    }
+  }
+
+  /** Confirm that runtime exceptions thrown inside of OkHttp propagate to the caller. */
+  @Test public void unexpectedExceptionAsync() throws Exception {
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .dns(new Dns() {
+          @Override public List<InetAddress> lookup(String hostname) {
+            throw new RuntimeException("boom!");
+          }
+        })
+        .build());
+
+    server.enqueue(new MockResponse());
+
+    HttpURLConnection connection = urlFactory.open(server.url("/").url());
+    try {
+      connection.connect(); // Force the async implementation.
+      fail();
+    } catch (RuntimeException expected) {
+      assertEquals("boom!", expected.getMessage());
+    }
+  }
+
+  @Test public void callsNotManagedByDispatcher() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("abc"));
+
+    Dispatcher dispatcher = urlFactory.client().dispatcher();
+    assertEquals(0, dispatcher.runningCallsCount());
+
+    connection = urlFactory.open(server.url("/").url());
+    assertEquals(0, dispatcher.runningCallsCount());
+
+    connection.connect();
+    assertEquals(0, dispatcher.runningCallsCount());
+
+    assertContent("abc", connection);
+    assertEquals(0, dispatcher.runningCallsCount());
+  }
+
+  @Test public void streamedBodyIsRetriedOnHttp2Shutdown() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
+        .setBody("abc"));
+    server.enqueue(new MockResponse()
+        .setBody("def"));
+
+    HttpURLConnection connection1 = urlFactory.open(server.url("/").url());
+    connection1.setChunkedStreamingMode(4096);
+    connection1.setRequestMethod("POST");
+    connection1.connect(); // Establish healthy HTTP/2 connection, but don't write yet.
+
+    // Send a separate request which will trigger a GOAWAY frame on the healthy connection.
+    HttpURLConnection connection2 = urlFactory.open(server.url("/").url());
+    assertContent("abc", connection2);
+
+    // Ensure the GOAWAY frame has time to be read and processed.
+    Thread.sleep(500);
+
+    OutputStream os = connection1.getOutputStream();
+    os.write(new byte[] { '1', '2', '3' });
+    os.close();
+    assertContent("def", connection1);
+
+    RecordedRequest request1 = server.takeRequest();
+    assertEquals(0, request1.getSequenceNumber());
+
+    RecordedRequest request2 = server.takeRequest();
+    assertEquals("123", request2.getBody().readUtf8());
+    assertEquals(0, request2.getSequenceNumber());
+  }
+
   private void testInstanceFollowsRedirects(String spec) throws Exception {
     URL url = new URL(spec);
     HttpURLConnection urlConnection = urlFactory.open(url);
@@ -3605,7 +3805,7 @@ public abstract HttpURLConnection connect(
   }
 
   private static class RecordingTrustManager implements X509TrustManager {
-    private final List<String> calls = new ArrayList<String>();
+    private final List<String> calls = new ArrayList<>();
     private final X509TrustManager delegate;
 
     public RecordingTrustManager(X509TrustManager delegate) {
@@ -3627,7 +3827,7 @@ public void checkServerTrusted(X509Certificate[] chain, String authType)
     }
 
     private String certificatesToString(X509Certificate[] certificates) {
-      List<String> result = new ArrayList<String>();
+      List<String> result = new ArrayList<>();
       for (X509Certificate certificate : certificates) {
         result.add(certificate.getSubjectDN() + " " + certificate.getSerialNumber());
       }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/SocketRecorder.java b/okhttp-tests/src/test/java/okhttp3/internal/SocketRecorder.java
new file mode 100644
index 0000000000..ba3b84f91e
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/SocketRecorder.java
@@ -0,0 +1,206 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.net.Socket;
+import java.util.Deque;
+import java.util.concurrent.LinkedBlockingDeque;
+import javax.net.ssl.SSLSocket;
+import javax.net.ssl.SSLSocketFactory;
+import okhttp3.DelegatingSSLSocket;
+import okhttp3.DelegatingSSLSocketFactory;
+import okio.Buffer;
+import okio.ByteString;
+
+/** Records all bytes written and read from a socket and makes them available for inspection. */
+public final class SocketRecorder {
+  private final Deque<RecordedSocket> recordedSockets = new LinkedBlockingDeque<>();
+
+  /** Returns an SSLSocketFactory whose sockets will record all transmitted bytes. */
+  public SSLSocketFactory sslSocketFactory(SSLSocketFactory delegate) {
+    return new DelegatingSSLSocketFactory(delegate) {
+      @Override protected SSLSocket configureSocket(SSLSocket sslSocket) throws IOException {
+        RecordedSocket recordedSocket = new RecordedSocket();
+        recordedSockets.add(recordedSocket);
+        return new RecordingSSLSocket(sslSocket, recordedSocket);
+      }
+    };
+  }
+
+  public RecordedSocket takeSocket() {
+    return recordedSockets.remove();
+  }
+
+  /** A bidirectional transfer of unadulterated bytes over a socket. */
+  public static final class RecordedSocket {
+    private final Buffer bytesWritten = new Buffer();
+    private final Buffer bytesRead = new Buffer();
+
+    synchronized void byteWritten(int b) {
+      bytesWritten.writeByte(b);
+    }
+
+    synchronized void byteRead(int b) {
+      bytesRead.writeByte(b);
+    }
+
+    synchronized void bytesWritten(byte[] bytes, int offset, int length) {
+      bytesWritten.write(bytes, offset, length);
+    }
+
+    synchronized void bytesRead(byte[] bytes, int offset, int length) {
+      bytesRead.write(bytes, offset, length);
+    }
+
+    /** Returns all bytes that have been written to this socket. */
+    public synchronized ByteString bytesWritten() {
+      return bytesWritten.readByteString();
+    }
+
+    /** Returns all bytes that have been read from this socket. */
+    public synchronized ByteString bytesRead() {
+      return bytesRead.readByteString();
+    }
+  }
+
+  static final class RecordingInputStream extends InputStream {
+    private final Socket socket;
+    private final RecordedSocket recordedSocket;
+
+    RecordingInputStream(Socket socket, RecordedSocket recordedSocket) {
+      this.socket = socket;
+      this.recordedSocket = recordedSocket;
+    }
+
+    @Override public int read() throws IOException {
+      int b = socket.getInputStream().read();
+      if (b == -1) return -1;
+      recordedSocket.byteRead(b);
+      return b;
+    }
+
+    @Override public int read(byte[] b, int off, int len) throws IOException {
+      int read = socket.getInputStream().read(b, off, len);
+      if (read == -1) return -1;
+      recordedSocket.bytesRead(b, off, read);
+      return read;
+    }
+
+    @Override public void close() throws IOException {
+      socket.getInputStream().close();
+    }
+  }
+
+  static final class RecordingOutputStream extends OutputStream {
+    private final Socket socket;
+    private final RecordedSocket recordedSocket;
+
+    RecordingOutputStream(Socket socket, RecordedSocket recordedSocket) {
+      this.socket = socket;
+      this.recordedSocket = recordedSocket;
+    }
+
+    @Override public void write(int b) throws IOException {
+      socket.getOutputStream().write(b);
+      recordedSocket.byteWritten(b);
+    }
+
+    @Override public void write(byte[] b, int off, int len) throws IOException {
+      socket.getOutputStream().write(b, off, len);
+      recordedSocket.bytesWritten(b, off, len);
+    }
+
+    @Override public void close() throws IOException {
+      socket.getOutputStream().close();
+    }
+
+    @Override public void flush() throws IOException {
+      socket.getOutputStream().flush();
+    }
+  }
+
+  static final class RecordingSSLSocket extends DelegatingSSLSocket {
+    private final InputStream inputStream;
+    private final OutputStream outputStream;
+
+    RecordingSSLSocket(SSLSocket delegate, RecordedSocket recordedSocket) {
+      super(delegate);
+      inputStream = new RecordingInputStream(delegate, recordedSocket);
+      outputStream = new RecordingOutputStream(delegate, recordedSocket);
+    }
+
+    @Override public void startHandshake() throws IOException {
+      // Intercept the handshake to properly configure TLS extensions with Jetty ALPN. Jetty ALPN
+      // expects the real SSLSocket to be placed in the global map. Because we are wrapping the real
+      // SSLSocket, it confuses Jetty ALPN. This patches that up so things work as expected.
+      Class<?> alpn = null;
+      Class<?> provider = null;
+      try {
+        alpn = Class.forName("org.eclipse.jetty.alpn.ALPN");
+        provider = Class.forName("org.eclipse.jetty.alpn.ALPN$Provider");
+      } catch (ClassNotFoundException ignored) {
+      }
+
+      if (alpn == null || provider == null) {
+        // No Jetty, so nothing to worry about.
+        super.startHandshake();
+        return;
+      }
+
+      Object providerInstance = null;
+      Method putMethod = null;
+      try {
+        Method getMethod = alpn.getMethod("get", SSLSocket.class);
+        putMethod = alpn.getMethod("put", SSLSocket.class, provider);
+        providerInstance = getMethod.invoke(null, this);
+        if (providerInstance == null) {
+          // Jetty's on the classpath but TLS extensions weren't used.
+          super.startHandshake();
+          return;
+        }
+
+        // TLS extensions were used; replace with the real SSLSocket to make Jetty ALPN happy.
+        putMethod.invoke(null, delegate, providerInstance);
+        super.startHandshake();
+      } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {
+        throw new AssertionError();
+      } finally {
+        // If we replaced the SSLSocket in the global map, we must put the original back for
+        // everything to work inside OkHttp.
+        if (providerInstance != null) {
+          try {
+            putMethod.invoke(null, this, providerInstance);
+          } catch (IllegalAccessException | InvocationTargetException e) {
+            throw new AssertionError();
+          }
+        }
+      }
+    }
+
+    @Override public InputStream getInputStream() throws IOException {
+      return inputStream;
+    }
+
+    @Override public OutputStream getOutputStream() throws IOException {
+      return outputStream;
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/UtilTest.java b/okhttp-tests/src/test/java/okhttp3/internal/UtilTest.java
new file mode 100644
index 0000000000..47c97fff2d
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/UtilTest.java
@@ -0,0 +1,31 @@
+ /*
+  * Copyright (C) 2012 The Android Open Source Project
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at
+  *
+  *      http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  */
+package okhttp3.internal;
+
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertSame;
+
+public class UtilTest {
+  @Test
+  public void testAssertionError() {
+    NullPointerException nullPointerException = new NullPointerException();
+    AssertionError ae = Util.assertionError("npe", nullPointerException);
+    assertSame(nullPointerException, ae.getCause());
+    assertEquals("npe", ae.getMessage());
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/DiskLruCacheTest.java b/okhttp-tests/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java
similarity index 97%
rename from okhttp-tests/src/test/java/okhttp3/internal/DiskLruCacheTest.java
rename to okhttp-tests/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java
index be2d0be61d..04ba57126b 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/DiskLruCacheTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal;
+package okhttp3.internal.cache;
 
 import java.io.File;
 import java.io.IOException;
@@ -25,6 +25,7 @@
 import java.util.List;
 import java.util.NoSuchElementException;
 import java.util.concurrent.Executor;
+import okhttp3.internal.io.FaultyFileSystem;
 import okhttp3.internal.io.FileSystem;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -32,15 +33,16 @@
 import okio.Source;
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.TemporaryFolder;
 import org.junit.rules.Timeout;
 
-import static okhttp3.internal.DiskLruCache.JOURNAL_FILE;
-import static okhttp3.internal.DiskLruCache.JOURNAL_FILE_BACKUP;
-import static okhttp3.internal.DiskLruCache.MAGIC;
-import static okhttp3.internal.DiskLruCache.VERSION_1;
+import static okhttp3.internal.cache.DiskLruCache.JOURNAL_FILE;
+import static okhttp3.internal.cache.DiskLruCache.JOURNAL_FILE_BACKUP;
+import static okhttp3.internal.cache.DiskLruCache.MAGIC;
+import static okhttp3.internal.cache.DiskLruCache.VERSION_1;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNull;
@@ -92,6 +94,36 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     assertJournalEquals();
   }
 
+  @Test public void recoverFromInitializationFailure() throws IOException {
+    // Add an uncommitted entry. This will get detected on initialization, and the cache will
+    // attempt to delete the file. Do not explicitly close the cache here so the entry is left as
+    // incomplete.
+    DiskLruCache.Editor creator = cache.edit("k1");
+    BufferedSink sink = Okio.buffer(creator.newSink(0));
+    sink.writeUtf8("Hello");
+    sink.close();
+
+    // Simulate a severe filesystem failure on the first initialization.
+    fileSystem.setFaultyDelete(new File(cacheDir, "k1.0.tmp"), true);
+    fileSystem.setFaultyDelete(cacheDir, true);
+
+    cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, Integer.MAX_VALUE, executor);
+    toClose.add(cache);
+
+    try {
+      cache.get("k1");
+      fail();
+    } catch (IOException expected) {
+    }
+
+    // Now let it operate normally.
+    fileSystem.setFaultyDelete(new File(cacheDir, "k1.0.tmp"), false);
+    fileSystem.setFaultyDelete(cacheDir, false);
+
+    DiskLruCache.Snapshot snapshot = cache.get("k1");
+    assertNull(snapshot);
+  }
+
   @Test public void validateKey() throws Exception {
     String key = null;
     try {
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/cache2/FileOperatorTest.java b/okhttp-tests/src/test/java/okhttp3/internal/cache2/FileOperatorTest.java
new file mode 100644
index 0000000000..21bbd49358
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/cache2/FileOperatorTest.java
@@ -0,0 +1,200 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.cache2;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.RandomAccessFile;
+import java.util.Random;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.ByteString;
+import okio.Okio;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+public final class FileOperatorTest {
+  @Rule public final TemporaryFolder tempDir = new TemporaryFolder();
+
+  private File file;
+  private RandomAccessFile randomAccessFile;
+
+  @Before public void setUp() throws Exception {
+    file = tempDir.newFile();
+    randomAccessFile = new RandomAccessFile(file, "rw");
+  }
+
+  @After public void tearDown() throws Exception {
+    randomAccessFile.close();
+  }
+
+  @Test public void read() throws Exception {
+    write(ByteString.encodeUtf8("Hello, World"));
+
+    FileOperator operator = new FileOperator(randomAccessFile.getChannel());
+
+    Buffer buffer = new Buffer();
+    operator.read(0, buffer, 5);
+    assertEquals("Hello", buffer.readUtf8());
+
+    operator.read(4, buffer, 5);
+    assertEquals("o, Wo", buffer.readUtf8());
+  }
+
+  @Test public void write() throws Exception {
+    FileOperator operator = new FileOperator(randomAccessFile.getChannel());
+
+    Buffer buffer1 = new Buffer().writeUtf8("Hello, World");
+    operator.write(0, buffer1, 5);
+    assertEquals(", World", buffer1.readUtf8());
+
+    Buffer buffer2 = new Buffer().writeUtf8("icopter!");
+    operator.write(3, buffer2, 7);
+    assertEquals("!", buffer2.readUtf8());
+
+    assertEquals(ByteString.encodeUtf8("Helicopter"), snapshot());
+  }
+
+  @Test public void readAndWrite() throws Exception {
+    FileOperator operator = new FileOperator(randomAccessFile.getChannel());
+
+    write(ByteString.encodeUtf8("woman god creates dinosaurs destroys. "));
+    Buffer buffer = new Buffer();
+    operator.read(6, buffer, 21);
+    operator.read(36, buffer, 1);
+    operator.read(5, buffer, 5);
+    operator.read(28, buffer, 8);
+    operator.read(17, buffer, 10);
+    operator.read(36, buffer, 2);
+    operator.read(2, buffer, 4);
+    operator.write(0, buffer, buffer.size());
+    operator.read(0, buffer, 12);
+    operator.read(47, buffer, 3);
+    operator.read(45, buffer, 2);
+    operator.read(47, buffer, 3);
+    operator.read(26, buffer, 10);
+    operator.read(23, buffer, 3);
+    operator.write(47, buffer, buffer.size());
+    operator.read(62, buffer, 6);
+    operator.read(4, buffer, 19);
+    operator.write(80, buffer, buffer.size());
+
+    assertEquals(snapshot(), ByteString.encodeUtf8(""
+        + "god creates dinosaurs. "
+        + "god destroys dinosaurs. "
+        + "god creates man. "
+        + "man destroys god. "
+        + "man creates dinosaurs. "));
+  }
+
+  @Test public void multipleOperatorsShareOneFile() throws Exception {
+    FileOperator operatorA = new FileOperator(randomAccessFile.getChannel());
+    FileOperator operatorB = new FileOperator(randomAccessFile.getChannel());
+
+    Buffer bufferA = new Buffer();
+    Buffer bufferB = new Buffer();
+
+    bufferA.writeUtf8("Dodgson!\n");
+    operatorA.write(0, bufferA, 9);
+
+    bufferB.writeUtf8("You shouldn't use my name.\n");
+    operatorB.write(9, bufferB, 27);
+
+    bufferA.writeUtf8("Dodgson, we've got Dodgson here!\n");
+    operatorA.write(36, bufferA, 33);
+
+    operatorB.read(0, bufferB, 9);
+    assertEquals("Dodgson!\n", bufferB.readUtf8());
+
+    operatorA.read(9, bufferA, 27);
+    assertEquals("You shouldn't use my name.\n", bufferA.readUtf8());
+
+    operatorB.read(36, bufferB, 33);
+    assertEquals("Dodgson, we've got Dodgson here!\n", bufferB.readUtf8());
+  }
+
+  @Test public void largeRead() throws Exception {
+    ByteString data = randomByteString(1000000);
+    write(data);
+
+    FileOperator operator = new FileOperator(randomAccessFile.getChannel());
+
+    Buffer buffer = new Buffer();
+    operator.read(0, buffer, data.size());
+    assertEquals(data, buffer.readByteString());
+  }
+
+  @Test public void largeWrite() throws Exception {
+    ByteString data = randomByteString(1000000);
+
+    FileOperator operator = new FileOperator(randomAccessFile.getChannel());
+
+    Buffer buffer = new Buffer().write(data);
+    operator.write(0, buffer, data.size());
+
+    assertEquals(data, snapshot());
+  }
+
+  @Test public void readBounds() throws Exception {
+    FileOperator operator = new FileOperator(randomAccessFile.getChannel());
+    Buffer buffer = new Buffer();
+    try {
+      operator.read(0, buffer, -1L);
+      fail();
+    } catch (IndexOutOfBoundsException expected) {
+    }
+  }
+
+  @Test public void writeBounds() throws Exception {
+    FileOperator operator = new FileOperator(randomAccessFile.getChannel());
+    Buffer buffer = new Buffer().writeUtf8("abc");
+    try {
+      operator.write(0, buffer, -1L);
+      fail();
+    } catch (IndexOutOfBoundsException expected) {
+    }
+    try {
+      operator.write(0, buffer, 4L);
+      fail();
+    } catch (IndexOutOfBoundsException expected) {
+    }
+  }
+
+  private ByteString randomByteString(int byteCount) {
+    byte[] bytes = new byte[byteCount];
+    new Random(0).nextBytes(bytes);
+    return ByteString.of(bytes);
+  }
+
+  private ByteString snapshot() throws IOException {
+    randomAccessFile.getChannel().force(false);
+    BufferedSource source = Okio.buffer(Okio.source(file));
+    return source.readByteString();
+  }
+
+  private void write(ByteString data) throws IOException {
+    BufferedSink sink = Okio.buffer(Okio.sink(file));
+    sink.write(data);
+    sink.close();
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/cache2/RelayTest.java b/okhttp-tests/src/test/java/okhttp3/internal/cache2/RelayTest.java
new file mode 100644
index 0000000000..cbffa87d09
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/cache2/RelayTest.java
@@ -0,0 +1,255 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.cache2;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.ByteString;
+import okio.Okio;
+import okio.Pipe;
+import okio.Source;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class RelayTest {
+  @Rule public final TemporaryFolder tempDir = new TemporaryFolder();
+
+  private ExecutorService executor = Executors.newCachedThreadPool();
+  private ByteString metadata = ByteString.encodeUtf8("great metadata!");
+  private File file;
+
+  @Before public void setUp() throws Exception {
+    file = tempDir.newFile();
+  }
+
+  @After public void tearDown() throws Exception {
+    executor.shutdown();
+  }
+
+  @Test public void singleSource() throws Exception {
+    Buffer upstream = new Buffer();
+    upstream.writeUtf8("abcdefghijklm");
+
+    Relay relay = Relay.edit(file, upstream, metadata, 1024);
+    Source source = relay.newSource();
+    Buffer sourceBuffer = new Buffer();
+
+    assertEquals(5, source.read(sourceBuffer, 5));
+    assertEquals("abcde", sourceBuffer.readUtf8());
+
+    assertEquals(8, source.read(sourceBuffer, 1024));
+    assertEquals("fghijklm", sourceBuffer.readUtf8());
+
+    assertEquals(-1, source.read(sourceBuffer, 1024));
+    assertEquals(0, sourceBuffer.size());
+
+    source.close();
+    assertTrue(relay.isClosed());
+    assertFile(Relay.PREFIX_CLEAN, 13L, metadata.size(), "abcdefghijklm", metadata);
+  }
+
+  @Test public void multipleSources() throws Exception {
+    Buffer upstream = new Buffer();
+    upstream.writeUtf8("abcdefghijklm");
+
+    Relay relay = Relay.edit(file, upstream, metadata, 1024);
+    BufferedSource source1 = Okio.buffer(relay.newSource());
+    BufferedSource source2 = Okio.buffer(relay.newSource());
+
+    assertEquals("abcdefghijklm", source1.readUtf8());
+    assertEquals("abcdefghijklm", source2.readUtf8());
+    source1.close();
+    source2.close();
+    assertTrue(relay.isClosed());
+
+    assertFile(Relay.PREFIX_CLEAN, 13L, metadata.size(), "abcdefghijklm", metadata);
+  }
+
+  @Test public void readFromBuffer() throws Exception {
+    Buffer upstream = new Buffer();
+    upstream.writeUtf8("abcdefghij");
+
+    Relay relay = Relay.edit(file, upstream, metadata, 5);
+    BufferedSource source1 = Okio.buffer(relay.newSource());
+    BufferedSource source2 = Okio.buffer(relay.newSource());
+
+    assertEquals("abcde", source1.readUtf8(5));
+    assertEquals("abcde", source2.readUtf8(5));
+    assertEquals("fghij", source2.readUtf8(5));
+    assertEquals("fghij", source1.readUtf8(5));
+    assertTrue(source1.exhausted());
+    assertTrue(source2.exhausted());
+    source1.close();
+    source2.close();
+    assertTrue(relay.isClosed());
+
+    assertFile(Relay.PREFIX_CLEAN, 10L, metadata.size(), "abcdefghij", metadata);
+  }
+
+  @Test public void readFromFile() throws Exception {
+    Buffer upstream = new Buffer();
+    upstream.writeUtf8("abcdefghijklmnopqrst");
+
+    Relay relay = Relay.edit(file, upstream, metadata, 5);
+    BufferedSource source1 = Okio.buffer(relay.newSource());
+    BufferedSource source2 = Okio.buffer(relay.newSource());
+
+    assertEquals("abcdefghij", source1.readUtf8(10));
+    assertEquals("abcdefghij", source2.readUtf8(10));
+    assertEquals("klmnopqrst", source2.readUtf8(10));
+    assertEquals("klmnopqrst", source1.readUtf8(10));
+    assertTrue(source1.exhausted());
+    assertTrue(source2.exhausted());
+    source1.close();
+    source2.close();
+    assertTrue(relay.isClosed());
+
+    assertFile(Relay.PREFIX_CLEAN, 20L, metadata.size(), "abcdefghijklmnopqrst", metadata);
+  }
+
+  @Test public void readAfterEdit() throws Exception {
+    Buffer upstream = new Buffer();
+    upstream.writeUtf8("abcdefghij");
+
+    Relay relay1 = Relay.edit(file, upstream, metadata, 5);
+    BufferedSource source1 = Okio.buffer(relay1.newSource());
+    assertEquals("abcdefghij", source1.readUtf8(10));
+    assertTrue(source1.exhausted());
+    source1.close();
+    assertTrue(relay1.isClosed());
+
+    // Since relay1 is closed, new sources cannot be created.
+    assertNull(relay1.newSource());
+
+    Relay relay2 = Relay.read(file);
+    assertEquals(metadata, relay2.metadata());
+    BufferedSource source2 = Okio.buffer(relay2.newSource());
+    assertEquals("abcdefghij", source2.readUtf8(10));
+    assertTrue(source2.exhausted());
+    source2.close();
+    assertTrue(relay2.isClosed());
+
+    // Since relay2 is closed, new sources cannot be created.
+    assertNull(relay2.newSource());
+
+    assertFile(Relay.PREFIX_CLEAN, 10L, metadata.size(), "abcdefghij", metadata);
+  }
+
+  @Test public void closeBeforeExhaustLeavesDirtyFile() throws Exception {
+    Buffer upstream = new Buffer();
+    upstream.writeUtf8("abcdefghij");
+
+    Relay relay1 = Relay.edit(file, upstream, metadata, 5);
+    BufferedSource source1 = Okio.buffer(relay1.newSource());
+    assertEquals("abcdefghij", source1.readUtf8(10));
+    source1.close(); // Not exhausted!
+    assertTrue(relay1.isClosed());
+
+    try {
+      Relay.read(file);
+      fail();
+    } catch (IOException expected) {
+      assertEquals("unreadable cache file", expected.getMessage());
+    }
+
+    assertFile(Relay.PREFIX_DIRTY, -1L, -1, null, null);
+  }
+
+  @Test public void redundantCallsToCloseAreIgnored() throws Exception {
+    Buffer upstream = new Buffer();
+    upstream.writeUtf8("abcde");
+
+    Relay relay = Relay.edit(file, upstream, metadata, 1024);
+    Source source1 = relay.newSource();
+    Source source2 = relay.newSource();
+
+    source1.close();
+    source1.close(); // Unnecessary. Shouldn't decrement the reference count.
+    assertFalse(relay.isClosed());
+
+    source2.close();
+    assertTrue(relay.isClosed());
+    assertFile(Relay.PREFIX_DIRTY, -1L, -1, null, null);
+  }
+
+  @Test public void racingReaders() throws Exception {
+    Pipe pipe = new Pipe(1024);
+    BufferedSink sink = Okio.buffer(pipe.sink());
+
+    Relay relay = Relay.edit(file, pipe.source(), metadata, 5);
+
+    Future<ByteString> future1 = executor.submit(sourceReader(relay.newSource()));
+    Future<ByteString> future2 = executor.submit(sourceReader(relay.newSource()));
+
+    Thread.sleep(500);
+    sink.writeUtf8("abcdefghij");
+
+    Thread.sleep(500);
+    sink.writeUtf8("klmnopqrst");
+    sink.close();
+
+    assertEquals(ByteString.encodeUtf8("abcdefghijklmnopqrst"), future1.get());
+    assertEquals(ByteString.encodeUtf8("abcdefghijklmnopqrst"), future2.get());
+
+    assertTrue(relay.isClosed());
+
+    assertFile(Relay.PREFIX_CLEAN, 20L, metadata.size(), "abcdefghijklmnopqrst", metadata);
+  }
+
+  /** Returns a callable that reads all of source, closes it, and returns the bytes. */
+  private Callable<ByteString> sourceReader(final Source source) {
+    return new Callable<ByteString>() {
+      @Override public ByteString call() throws Exception {
+        Buffer buffer = new Buffer();
+        while (source.read(buffer, 16384) != -1) {
+        }
+        source.close();
+        return buffer.readByteString();
+      }
+    };
+  }
+
+  private void assertFile(ByteString prefix, long upstreamSize, int metadataSize, String upstream,
+      ByteString metadata) throws IOException {
+    BufferedSource source = Okio.buffer(Okio.source(file));
+    assertEquals(prefix, source.readByteString(prefix.size()));
+    assertEquals(upstreamSize, source.readLong());
+    assertEquals(metadataSize, source.readLong());
+    if (upstream != null) {
+      assertEquals(upstream, source.readUtf8(upstreamSize));
+    }
+    if (metadata != null) {
+      assertEquals(metadata, source.readByteString(metadataSize));
+    }
+    source.close();
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ConnectionSpecSelectorTest.java b/okhttp-tests/src/test/java/okhttp3/internal/connection/ConnectionSpecSelectorTest.java
similarity index 98%
rename from okhttp-tests/src/test/java/okhttp3/internal/ConnectionSpecSelectorTest.java
rename to okhttp-tests/src/test/java/okhttp3/internal/connection/ConnectionSpecSelectorTest.java
index 96c6585a34..b0b06e9f87 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/ConnectionSpecSelectorTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/connection/ConnectionSpecSelectorTest.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal;
+package okhttp3.internal.connection;
 
 import java.io.IOException;
 import java.security.cert.CertificateException;
@@ -24,6 +24,7 @@
 import javax.net.ssl.SSLSocket;
 import okhttp3.ConnectionSpec;
 import okhttp3.TlsVersion;
+import okhttp3.internal.Internal;
 import okhttp3.internal.tls.SslClient;
 import org.junit.Test;
 
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/RouteExceptionTest.java b/okhttp-tests/src/test/java/okhttp3/internal/connection/RouteExceptionTest.java
similarity index 97%
rename from okhttp-tests/src/test/java/okhttp3/internal/http/RouteExceptionTest.java
rename to okhttp-tests/src/test/java/okhttp3/internal/connection/RouteExceptionTest.java
index 1a0c2d8f02..209d79d5c5 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http/RouteExceptionTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/connection/RouteExceptionTest.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.http;
+package okhttp3.internal.connection;
 
 import java.io.IOException;
 import org.junit.Test;
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/RouteSelectorTest.java b/okhttp-tests/src/test/java/okhttp3/internal/connection/RouteSelectorTest.java
similarity index 57%
rename from okhttp-tests/src/test/java/okhttp3/internal/http/RouteSelectorTest.java
rename to okhttp-tests/src/test/java/okhttp3/internal/connection/RouteSelectorTest.java
index b1e3fca305..9d81d30e91 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http/RouteSelectorTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/connection/RouteSelectorTest.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.http;
+package okhttp3.internal.connection;
 
 import java.io.IOException;
 import java.net.InetAddress;
@@ -34,11 +34,12 @@
 import okhttp3.Address;
 import okhttp3.Authenticator;
 import okhttp3.ConnectionSpec;
+import okhttp3.EventListener;
 import okhttp3.FakeDns;
 import okhttp3.Protocol;
 import okhttp3.Route;
-import okhttp3.internal.RouteDatabase;
 import okhttp3.internal.Util;
+import okhttp3.internal.http.RecordingProxySelector;
 import okhttp3.internal.tls.SslClient;
 import org.junit.Before;
 import org.junit.Test;
@@ -46,6 +47,7 @@
 import static java.net.Proxy.NO_PROXY;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
@@ -84,12 +86,20 @@
 
   @Test public void singleRoute() throws Exception {
     Address address = httpAddress();
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase);
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+        EventListener.NONE);
 
     assertTrue(routeSelector.hasNext());
-    dns.addresses(makeFakeAddresses(255, 1));
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.address(0), uriPort);
+    dns.set(uriHost, dns.allocate(1));
+    RouteSelector.Selection selection = routeSelector.next();
+    assertRoute(selection.next(), address, NO_PROXY, dns.lookup(uriHost, 0), uriPort);
     dns.assertRequests(uriHost);
+    assertFalse(selection.hasNext());
+    try {
+      selection.next();
+      fail();
+    } catch (NoSuchElementException expected) {
+    }
 
     assertFalse(routeSelector.hasNext());
     try {
@@ -101,14 +111,25 @@
 
   @Test public void singleRouteReturnsFailedRoute() throws Exception {
     Address address = httpAddress();
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase);
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+        EventListener.NONE);
 
     assertTrue(routeSelector.hasNext());
-    dns.addresses(makeFakeAddresses(255, 1));
-    Route route = routeSelector.next();
+    dns.set(uriHost, dns.allocate(1));
+    RouteSelector.Selection selection = routeSelector.next();
+    Route route = selection.next();
     routeDatabase.failed(route);
-    routeSelector = new RouteSelector(address, routeDatabase);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.address(0), uriPort);
+    routeSelector = new RouteSelector(address, routeDatabase, null, EventListener.NONE);
+    selection = routeSelector.next();
+    assertRoute(selection.next(), address, NO_PROXY, dns.lookup(uriHost, 0), uriPort);
+    assertFalse(selection.hasNext());
+
+    try {
+      selection.next();
+      fail();
+    } catch (NoSuchElementException expected) {
+    }
+
     assertFalse(routeSelector.hasNext());
     try {
       routeSelector.next();
@@ -120,13 +141,16 @@
   @Test public void explicitProxyTriesThatProxysAddressesOnly() throws Exception {
     Address address = new Address(uriHost, uriPort, dns, socketFactory, null, null, null,
         authenticator, proxyA, protocols, connectionSpecs, proxySelector);
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase);
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+        EventListener.NONE);
 
     assertTrue(routeSelector.hasNext());
-    dns.addresses(makeFakeAddresses(255, 2));
-    assertRoute(routeSelector.next(), address, proxyA, dns.address(0), proxyAPort);
-    assertRoute(routeSelector.next(), address, proxyA, dns.address(1), proxyAPort);
+    dns.set(proxyAHost, dns.allocate(2));
+    RouteSelector.Selection selection = routeSelector.next();
+    assertRoute(selection.next(), address, proxyA, dns.lookup(proxyAHost, 0), proxyAPort);
+    assertRoute(selection.next(), address, proxyA, dns.lookup(proxyAHost, 1), proxyAPort);
 
+    assertFalse(selection.hasNext());
     assertFalse(routeSelector.hasNext());
     dns.assertRequests(proxyAHost);
     proxySelector.assertRequests(); // No proxy selector requests!
@@ -135,13 +159,16 @@
   @Test public void explicitDirectProxy() throws Exception {
     Address address = new Address(uriHost, uriPort, dns, socketFactory, null, null, null,
         authenticator, NO_PROXY, protocols, connectionSpecs, proxySelector);
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase);
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+        EventListener.NONE);
 
     assertTrue(routeSelector.hasNext());
-    dns.addresses(makeFakeAddresses(255, 2));
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.address(0), uriPort);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.address(1), uriPort);
+    dns.set(uriHost, dns.allocate(2));
+    RouteSelector.Selection selection = routeSelector.next();
+    assertRoute(selection.next(), address, NO_PROXY, dns.lookup(uriHost, 0), uriPort);
+    assertRoute(selection.next(), address, NO_PROXY, dns.lookup(uriHost, 1), uriPort);
 
+    assertFalse(selection.hasNext());
     assertFalse(routeSelector.hasNext());
     dns.assertRequests(uriHost);
     proxySelector.assertRequests(); // No proxy selector requests!
@@ -162,24 +189,30 @@
 
     Address address = new Address(uriHost, uriPort, dns, socketFactory, null, null, null,
         authenticator, null, protocols, connectionSpecs, nullProxySelector);
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase);
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+        EventListener.NONE);
     assertTrue(routeSelector.hasNext());
-    dns.addresses(makeFakeAddresses(255, 1));
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.address(0), uriPort);
+    dns.set(uriHost, dns.allocate(1));
+    RouteSelector.Selection selection = routeSelector.next();
+    assertRoute(selection.next(), address, NO_PROXY, dns.lookup(uriHost, 0), uriPort);
     dns.assertRequests(uriHost);
 
+    assertFalse(selection.hasNext());
     assertFalse(routeSelector.hasNext());
   }
 
   @Test public void proxySelectorReturnsNoProxies() throws Exception {
     Address address = httpAddress();
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase);
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+        EventListener.NONE);
 
     assertTrue(routeSelector.hasNext());
-    dns.addresses(makeFakeAddresses(255, 2));
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.address(0), uriPort);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.address(1), uriPort);
+    dns.set(uriHost, dns.allocate(2));
+    RouteSelector.Selection selection = routeSelector.next();
+    assertRoute(selection.next(), address, NO_PROXY, dns.lookup(uriHost, 0), uriPort);
+    assertRoute(selection.next(), address, NO_PROXY, dns.lookup(uriHost, 1), uriPort);
 
+    assertFalse(selection.hasNext());
     assertFalse(routeSelector.hasNext());
     dns.assertRequests(uriHost);
     proxySelector.assertRequests(address.url().uri());
@@ -190,28 +223,28 @@
 
     proxySelector.proxies.add(proxyA);
     proxySelector.proxies.add(proxyB);
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase);
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+        EventListener.NONE);
     proxySelector.assertRequests(address.url().uri());
 
     // First try the IP addresses of the first proxy, in sequence.
     assertTrue(routeSelector.hasNext());
-    dns.addresses(makeFakeAddresses(255, 2));
-    assertRoute(routeSelector.next(), address, proxyA, dns.address(0), proxyAPort);
-    assertRoute(routeSelector.next(), address, proxyA, dns.address(1), proxyAPort);
+    dns.set(proxyAHost, dns.allocate(2));
+    RouteSelector.Selection selection1 = routeSelector.next();
+    assertRoute(selection1.next(), address, proxyA, dns.lookup(proxyAHost, 0), proxyAPort);
+    assertRoute(selection1.next(), address, proxyA, dns.lookup(proxyAHost, 1), proxyAPort);
     dns.assertRequests(proxyAHost);
+    assertFalse(selection1.hasNext());
 
     // Next try the IP address of the second proxy.
     assertTrue(routeSelector.hasNext());
-    dns.addresses(makeFakeAddresses(254, 1));
-    assertRoute(routeSelector.next(), address, proxyB, dns.address(0), proxyBPort);
+    dns.set(proxyBHost, dns.allocate(1));
+    RouteSelector.Selection selection2 = routeSelector.next();
+    assertRoute(selection2.next(), address, proxyB, dns.lookup(proxyBHost, 0), proxyBPort);
     dns.assertRequests(proxyBHost);
+    assertFalse(selection2.hasNext());
 
-    // Finally try the only IP address of the origin server.
-    assertTrue(routeSelector.hasNext());
-    dns.addresses(makeFakeAddresses(253, 1));
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.address(0), uriPort);
-    dns.assertRequests(uriHost);
-
+    // No more proxies to try.
     assertFalse(routeSelector.hasNext());
   }
 
@@ -219,15 +252,18 @@
     Address address = httpAddress();
 
     proxySelector.proxies.add(NO_PROXY);
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase);
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+        EventListener.NONE);
     proxySelector.assertRequests(address.url().uri());
 
     // Only the origin server will be attempted.
     assertTrue(routeSelector.hasNext());
-    dns.addresses(makeFakeAddresses(255, 1));
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.address(0), uriPort);
+    dns.set(uriHost, dns.allocate(1));
+    RouteSelector.Selection selection = routeSelector.next();
+    assertRoute(selection.next(), address, NO_PROXY, dns.lookup(uriHost, 0), uriPort);
     dns.assertRequests(uriHost);
 
+    assertFalse(selection.hasNext());
     assertFalse(routeSelector.hasNext());
   }
 
@@ -237,16 +273,19 @@
     proxySelector.proxies.add(proxyA);
     proxySelector.proxies.add(proxyB);
     proxySelector.proxies.add(proxyA);
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase);
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+        EventListener.NONE);
     proxySelector.assertRequests(address.url().uri());
 
     assertTrue(routeSelector.hasNext());
-    dns.addresses(makeFakeAddresses(255, 1));
-    assertRoute(routeSelector.next(), address, proxyA, dns.address(0), proxyAPort);
+    dns.set(proxyAHost, dns.allocate(1));
+    RouteSelector.Selection selection1 = routeSelector.next();
+    assertRoute(selection1.next(), address, proxyA, dns.lookup(proxyAHost, 0), proxyAPort);
     dns.assertRequests(proxyAHost);
+    assertFalse(selection1.hasNext());
 
     assertTrue(routeSelector.hasNext());
-    dns.unknownHost();
+    dns.clear(proxyBHost);
     try {
       routeSelector.next();
       fail();
@@ -255,15 +294,12 @@
     dns.assertRequests(proxyBHost);
 
     assertTrue(routeSelector.hasNext());
-    dns.addresses(makeFakeAddresses(255, 1));
-    assertRoute(routeSelector.next(), address, proxyA, dns.address(0), proxyAPort);
+    dns.set(proxyAHost, dns.allocate(1));
+    RouteSelector.Selection selection2 = routeSelector.next();
+    assertRoute(selection2.next(), address, proxyA, dns.lookup(proxyAHost, 0), proxyAPort);
     dns.assertRequests(proxyAHost);
 
-    assertTrue(routeSelector.hasNext());
-    dns.addresses(makeFakeAddresses(254, 1));
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.address(0), uriPort);
-    dns.assertRequests(uriHost);
-
+    assertFalse(selection2.hasNext());
     assertFalse(routeSelector.hasNext());
   }
 
@@ -271,57 +307,112 @@
     Address address = httpsAddress();
     proxySelector.proxies.add(proxyA);
     proxySelector.proxies.add(proxyB);
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase);
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+        EventListener.NONE);
 
     // Proxy A
-    dns.addresses(makeFakeAddresses(255, 2));
-    assertRoute(routeSelector.next(), address, proxyA, dns.address(0), proxyAPort);
+    dns.set(proxyAHost, dns.allocate(2));
+    RouteSelector.Selection selection1 = routeSelector.next();
+    assertRoute(selection1.next(), address, proxyA, dns.lookup(proxyAHost, 0), proxyAPort);
     dns.assertRequests(proxyAHost);
-    assertRoute(routeSelector.next(), address, proxyA, dns.address(1), proxyAPort);
+    assertRoute(selection1.next(), address, proxyA, dns.lookup(proxyAHost, 1), proxyAPort);
+    assertFalse(selection1.hasNext());
 
     // Proxy B
-    dns.addresses(makeFakeAddresses(254, 2));
-    assertRoute(routeSelector.next(), address, proxyB, dns.address(0), proxyBPort);
+    dns.set(proxyBHost, dns.allocate(2));
+    RouteSelector.Selection selection2 = routeSelector.next();
+    assertRoute(selection2.next(), address, proxyB, dns.lookup(proxyBHost, 0), proxyBPort);
     dns.assertRequests(proxyBHost);
-    assertRoute(routeSelector.next(), address, proxyB, dns.address(1), proxyBPort);
-
-    // Origin
-    dns.addresses(makeFakeAddresses(253, 2));
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.address(0), uriPort);
-    dns.assertRequests(uriHost);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.address(1), uriPort);
+    assertRoute(selection2.next(), address, proxyB, dns.lookup(proxyBHost, 1), proxyBPort);
+    assertFalse(selection2.hasNext());
 
+    // No more proxies to attempt.
     assertFalse(routeSelector.hasNext());
   }
 
-  @Test public void failedRoutesAreLast() throws Exception {
+  @Test public void failedRouteWithSingleProxy() throws Exception {
     Address address = httpsAddress();
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase);
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+        EventListener.NONE);
 
     final int numberOfAddresses = 2;
-    dns.addresses(makeFakeAddresses(255, numberOfAddresses));
+    dns.set(uriHost, dns.allocate(numberOfAddresses));
 
     // Extract the regular sequence of routes from selector.
-    List<Route> regularRoutes = new ArrayList<>();
-    while (routeSelector.hasNext()) {
-      regularRoutes.add(routeSelector.next());
-    }
+    RouteSelector.Selection selection1 = routeSelector.next();
+    List<Route> regularRoutes = selection1.getAll();
 
     // Check that we do indeed have more than one route.
     assertEquals(numberOfAddresses, regularRoutes.size());
     // Add first regular route as failed.
     routeDatabase.failed(regularRoutes.get(0));
     // Reset selector
-    routeSelector = new RouteSelector(address, routeDatabase);
+    routeSelector = new RouteSelector(address, routeDatabase, null, EventListener.NONE);
 
-    List<Route> routesWithFailedRoute = new ArrayList<>();
-    while (routeSelector.hasNext()) {
-      routesWithFailedRoute.add(routeSelector.next());
-    }
+    // The first selection prioritizes the non-failed routes.
+    RouteSelector.Selection selection2 = routeSelector.next();
+    assertEquals(regularRoutes.get(1), selection2.next());
+    assertFalse(selection2.hasNext());
 
-    assertEquals(regularRoutes.get(0),
-        routesWithFailedRoute.get(routesWithFailedRoute.size() - 1));
-    assertEquals(regularRoutes.size(), routesWithFailedRoute.size());
+    // The second selection will contain all failed routes.
+    RouteSelector.Selection selection3 = routeSelector.next();
+    assertEquals(regularRoutes.get(0), selection3.next());
+    assertFalse(selection3.hasNext());
+
+    assertFalse(routeSelector.hasNext());
+  }
+
+  @Test public void failedRouteWithMultipleProxies() throws IOException {
+    Address address = httpsAddress();
+    proxySelector.proxies.add(proxyA);
+    proxySelector.proxies.add(proxyB);
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+        EventListener.NONE);
+
+    dns.set(proxyAHost, dns.allocate(1));
+    dns.set(proxyBHost, dns.allocate(1));
+
+    // Mark the ProxyA route as failed.
+    RouteSelector.Selection selection = routeSelector.next();
+    dns.assertRequests(proxyAHost);
+    Route route = selection.next();
+    assertRoute(route, address, proxyA, dns.lookup(proxyAHost, 0), proxyAPort);
+    routeDatabase.failed(route);
+
+    routeSelector = new RouteSelector(address, routeDatabase, null, EventListener.NONE);
+
+    // Confirm we enumerate both proxies, giving preference to the route from ProxyB.
+    RouteSelector.Selection selection2 = routeSelector.next();
+    dns.assertRequests(proxyAHost, proxyBHost);
+    assertRoute(selection2.next(), address, proxyB, dns.lookup(proxyBHost, 0), proxyBPort);
+    assertFalse(selection2.hasNext());
+
+    // Confirm the last selection contains the postponed route from ProxyA.
+    RouteSelector.Selection selection3 = routeSelector.next();
+    dns.assertRequests();
+    assertRoute(selection3.next(), address, proxyA, dns.lookup(proxyAHost, 0), proxyAPort);
+    assertFalse(selection3.hasNext());
+
+    assertFalse(routeSelector.hasNext());
+  }
+
+  @Test public void queryForAllSelectedRoutes() throws IOException {
+    Address address = httpAddress();
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+        EventListener.NONE);
+
+    dns.set(uriHost, dns.allocate(2));
+    RouteSelector.Selection selection = routeSelector.next();
+    dns.assertRequests(uriHost);
+
+    List<Route> routes = selection.getAll();
+    assertRoute(routes.get(0), address, NO_PROXY, dns.lookup(uriHost, 0), uriPort);
+    assertRoute(routes.get(1), address, NO_PROXY, dns.lookup(uriHost, 1), uriPort);
+
+    assertSame(routes.get(0), selection.next());
+    assertSame(routes.get(1), selection.next());
+    assertFalse(selection.hasNext());
+    assertFalse(routeSelector.hasNext());
   }
 
   @Test public void getHostString() throws Exception {
@@ -342,6 +433,12 @@
     assertEquals("127.0.0.1", RouteSelector.getHostString(socketAddress));
   }
 
+  @Test public void routeToString() throws Exception {
+    Route route = new Route(httpAddress(), Proxy.NO_PROXY,
+        InetSocketAddress.createUnresolved("host", 1234));
+    assertEquals("Route{host:1234}", route.toString());
+  }
+
   private void assertRoute(Route route, Address address, Proxy proxy, InetAddress socketAddress,
       int socketPort) {
     assertEquals(address, route.address());
@@ -360,17 +457,4 @@ private Address httpsAddress() {
     return new Address(uriHost, uriPort, dns, socketFactory, sslSocketFactory,
         hostnameVerifier, null, authenticator, null, protocols, connectionSpecs, proxySelector);
   }
-
-  private static List<InetAddress> makeFakeAddresses(int prefix, int count) {
-    try {
-      List<InetAddress> result = new ArrayList<>();
-      for (int i = 0; i < count; i++) {
-        result.add(InetAddress.getByAddress(
-            new byte[] {(byte) prefix, (byte) 0, (byte) 0, (byte) i}));
-      }
-      return result;
-    } catch (UnknownHostException e) {
-      throw new AssertionError();
-    }
-  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/framed/Http2ConnectionTest.java b/okhttp-tests/src/test/java/okhttp3/internal/framed/Http2ConnectionTest.java
deleted file mode 100644
index 67d6964d7f..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/framed/Http2ConnectionTest.java
+++ /dev/null
@@ -1,612 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.framed;
-
-import java.io.IOException;
-import java.net.Socket;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import java.util.concurrent.TimeUnit;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.Okio;
-import okio.Source;
-import org.junit.After;
-import org.junit.Test;
-
-import static okhttp3.TestUtil.headerEntries;
-import static okhttp3.TestUtil.repeat;
-import static okhttp3.internal.Util.EMPTY_BYTE_ARRAY;
-import static okhttp3.internal.framed.ErrorCode.CANCEL;
-import static okhttp3.internal.framed.ErrorCode.PROTOCOL_ERROR;
-import static okhttp3.internal.framed.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
-import static okhttp3.internal.framed.Settings.ENABLE_PUSH;
-import static okhttp3.internal.framed.Settings.HEADER_TABLE_SIZE;
-import static okhttp3.internal.framed.Settings.INITIAL_WINDOW_SIZE;
-import static okhttp3.internal.framed.Settings.MAX_FRAME_SIZE;
-import static okhttp3.internal.framed.Settings.PERSIST_VALUE;
-import static okhttp3.internal.framed.Spdy3.TYPE_DATA;
-import static okhttp3.internal.framed.Spdy3.TYPE_HEADERS;
-import static okhttp3.internal.framed.Spdy3.TYPE_PING;
-import static okhttp3.internal.framed.Spdy3.TYPE_RST_STREAM;
-import static okhttp3.internal.framed.Spdy3.TYPE_SETTINGS;
-import static okhttp3.internal.framed.Spdy3.TYPE_WINDOW_UPDATE;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-public final class Http2ConnectionTest {
-  private static final Variant HTTP_2 = new Http2();
-  private final MockSpdyPeer peer = new MockSpdyPeer();
-
-  @After public void tearDown() throws Exception {
-    peer.close();
-  }
-
-  @Test public void serverPingsClientHttp2() throws Exception {
-    peer.setVariantAndClient(HTTP_2, false);
-
-    // write the mocking script
-    peer.sendFrame().ping(false, 2, 3);
-    peer.acceptFrame(); // PING
-    peer.play();
-
-    // play it back
-    connection(peer, HTTP_2);
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame ping = peer.takeFrame();
-    assertEquals(TYPE_PING, ping.type);
-    assertEquals(0, ping.streamId);
-    assertEquals(2, ping.payload1);
-    assertEquals(3, ping.payload2);
-    assertTrue(ping.ack);
-  }
-
-  @Test public void clientPingsServerHttp2() throws Exception {
-    peer.setVariantAndClient(HTTP_2, false);
-
-    // write the mocking script
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 5);
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, HTTP_2);
-    Ping ping = connection.ping();
-    assertTrue(ping.roundTripTime() > 0);
-    assertTrue(ping.roundTripTime() < TimeUnit.SECONDS.toNanos(1));
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame pingFrame = peer.takeFrame();
-    assertEquals(0, pingFrame.streamId);
-    assertEquals(1, pingFrame.payload1);
-    assertEquals(0x4f4b6f6b, pingFrame.payload2); // connection.ping() sets this.
-    assertFalse(pingFrame.ack);
-  }
-
-  @Test public void peerHttp2ServerLowersInitialWindowSize() throws Exception {
-    peer.setVariantAndClient(HTTP_2, false);
-
-    Settings initial = new Settings();
-    initial.set(INITIAL_WINDOW_SIZE, PERSIST_VALUE, 1684);
-    Settings shouldntImpactConnection = new Settings();
-    shouldntImpactConnection.set(INITIAL_WINDOW_SIZE, PERSIST_VALUE, 3368);
-
-    peer.sendFrame().settings(initial);
-    peer.acceptFrame(); // ACK
-    peer.sendFrame().settings(shouldntImpactConnection);
-    peer.acceptFrame(); // ACK 2
-    peer.acceptFrame(); // HEADERS
-    peer.play();
-
-    FramedConnection connection = connection(peer, HTTP_2);
-
-    // Default is 64KiB - 1.
-    assertEquals(65535, connection.peerSettings.getInitialWindowSize(-1));
-
-    // Verify the peer received the ACK.
-    MockSpdyPeer.InFrame ackFrame = peer.takeFrame();
-    assertEquals(TYPE_SETTINGS, ackFrame.type);
-    assertEquals(0, ackFrame.streamId);
-    assertTrue(ackFrame.ack);
-    ackFrame = peer.takeFrame();
-    assertEquals(TYPE_SETTINGS, ackFrame.type);
-    assertEquals(0, ackFrame.streamId);
-    assertTrue(ackFrame.ack);
-
-    // This stream was created *after* the connection settings were adjusted.
-    FramedStream stream = connection.newStream(headerEntries("a", "android"), false, true);
-
-    assertEquals(3368, connection.peerSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE));
-    assertEquals(1684, connection.bytesLeftInWriteWindow); // initial wasn't affected.
-    // New Stream is has the most recent initial window size.
-    assertEquals(3368, stream.bytesLeftInWriteWindow);
-  }
-
-  @Test public void peerHttp2ServerZerosCompressionTable() throws Exception {
-    boolean client = false; // Peer is server, so we are client.
-    Settings settings = new Settings();
-    settings.set(HEADER_TABLE_SIZE, PERSIST_VALUE, 0);
-
-    FramedConnection connection = sendHttp2SettingsAndCheckForAck(client, settings);
-
-    // verify the peer's settings were read and applied.
-    assertEquals(0, connection.peerSettings.getHeaderTableSize());
-    Http2.Reader frameReader = (Http2.Reader) connection.readerRunnable.frameReader;
-    assertEquals(0, frameReader.hpackReader.maxDynamicTableByteCount());
-    // TODO: when supported, check the frameWriter's compression table is unaffected.
-  }
-
-  @Test public void peerHttp2ClientDisablesPush() throws Exception {
-    boolean client = false; // Peer is client, so we are server.
-    Settings settings = new Settings();
-    settings.set(ENABLE_PUSH, 0, 0); // The peer client disables push.
-
-    FramedConnection connection = sendHttp2SettingsAndCheckForAck(client, settings);
-
-    // verify the peer's settings were read and applied.
-    assertFalse(connection.peerSettings.getEnablePush(true));
-  }
-
-  @Test public void peerIncreasesMaxFrameSize() throws Exception {
-    int newMaxFrameSize = 0x4001;
-    Settings settings = new Settings();
-    settings.set(MAX_FRAME_SIZE, 0, newMaxFrameSize);
-
-    FramedConnection connection = sendHttp2SettingsAndCheckForAck(true, settings);
-
-    // verify the peer's settings were read and applied.
-    assertEquals(newMaxFrameSize, connection.peerSettings.getMaxFrameSize(-1));
-    assertEquals(newMaxFrameSize, connection.frameWriter.maxDataLength());
-  }
-
-  /**
-   * Webservers may set the initial window size to zero, which is a special case because it means
-   * that we have to flush headers immediately before any request body can be sent.
-   * https://github.com/square/okhttp/issues/2543
-   */
-  @Test public void peerSetsZeroFlowControl() throws Exception {
-    peer.setVariantAndClient(HTTP_2, true);
-
-    // Write the mocking script.
-    peer.sendFrame().settings(new Settings().set(INITIAL_WINDOW_SIZE, 0, 0));
-    peer.sendFrame().windowUpdate(0, 10); // Increase the connection window size.
-    peer.acceptFrame(); // PING or SETTINGS ACK
-    peer.acceptFrame(); // PING or SETTINGS ACK
-    peer.sendFrame().ping(true, 1, 0);
-    peer.acceptFrame(); // HEADERS STREAM 3
-    peer.sendFrame().windowUpdate(3, 5);
-    peer.acceptFrame(); // DATA STREAM 3 "abcde"
-    peer.sendFrame().windowUpdate(3, 5);
-    peer.acceptFrame(); // DATA STREAM 3 "fghi"
-    peer.play();
-
-    // Play it back.
-    FramedConnection connection = connection(peer, HTTP_2);
-    connection.ping().roundTripTime(); // Ensure the SETTINGS have been received.
-    FramedStream stream = connection.newStream(headerEntries("a", "android"), true, true);
-    BufferedSink sink = Okio.buffer(stream.getSink());
-    sink.writeUtf8("abcdefghi");
-    sink.flush();
-
-    // Verify the peer received what was expected.
-    peer.takeFrame(); // PING or SETTINGS ACK
-    peer.takeFrame(); // PING or SETTINGS ACK
-    MockSpdyPeer.InFrame headers = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, headers.type);
-    MockSpdyPeer.InFrame data1 = peer.takeFrame();
-    assertEquals(TYPE_DATA, data1.type);
-    assertEquals(3, data1.streamId);
-    assertTrue(Arrays.equals("abcde".getBytes("UTF-8"), data1.data));
-    MockSpdyPeer.InFrame data2 = peer.takeFrame();
-    assertEquals(TYPE_DATA, data2.type);
-    assertEquals(3, data2.streamId);
-    assertTrue(Arrays.equals("fghi".getBytes("UTF-8"), data2.data));
-  }
-
-  @Test public void receiveGoAwayHttp2() throws Exception {
-    peer.setVariantAndClient(HTTP_2, false);
-
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM 3
-    peer.acceptFrame(); // SYN_STREAM 5
-    peer.sendFrame().goAway(3, PROTOCOL_ERROR, EMPTY_BYTE_ARRAY);
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 0);
-    peer.acceptFrame(); // DATA STREAM 3
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, HTTP_2);
-    FramedStream stream1 = connection.newStream(headerEntries("a", "android"), true, true);
-    FramedStream stream2 = connection.newStream(headerEntries("b", "banana"), true, true);
-    connection.ping().roundTripTime(); // Ensure the GO_AWAY that resets stream2 has been received.
-    BufferedSink sink1 = Okio.buffer(stream1.getSink());
-    BufferedSink sink2 = Okio.buffer(stream2.getSink());
-    sink1.writeUtf8("abc");
-    try {
-      sink2.writeUtf8("abc");
-      sink2.flush();
-      fail();
-    } catch (IOException expected) {
-      assertEquals("stream was reset: REFUSED_STREAM", expected.getMessage());
-    }
-    sink1.writeUtf8("def");
-    sink1.close();
-    try {
-      connection.newStream(headerEntries("c", "cola"), true, true);
-      fail();
-    } catch (IOException expected) {
-      assertEquals("shutdown", expected.getMessage());
-    }
-    assertTrue(stream1.isOpen());
-    assertFalse(stream2.isOpen());
-    assertEquals(1, connection.openStreamCount());
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame synStream1 = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream1.type);
-    MockSpdyPeer.InFrame synStream2 = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream2.type);
-    MockSpdyPeer.InFrame ping = peer.takeFrame();
-    assertEquals(TYPE_PING, ping.type);
-    MockSpdyPeer.InFrame data1 = peer.takeFrame();
-    assertEquals(TYPE_DATA, data1.type);
-    assertEquals(3, data1.streamId);
-    assertTrue(Arrays.equals("abcdef".getBytes("UTF-8"), data1.data));
-  }
-
-  @Test public void readSendsWindowUpdateHttp2() throws Exception {
-    peer.setVariantAndClient(HTTP_2, false);
-
-    int windowSize = 100;
-    int windowUpdateThreshold = 50;
-
-    // Write the mocking script.
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
-    for (int i = 0; i < 3; i++) {
-      // Send frames of summing to size 50, which is windowUpdateThreshold.
-      peer.sendFrame().data(false, 3, data(24), 24);
-      peer.sendFrame().data(false, 3, data(25), 25);
-      peer.sendFrame().data(false, 3, data(1), 1);
-      peer.acceptFrame(); // connection WINDOW UPDATE
-      peer.acceptFrame(); // stream WINDOW UPDATE
-    }
-    peer.sendFrame().data(true, 3, data(0), 0);
-    peer.play();
-
-    // Play it back.
-    FramedConnection connection = connection(peer, HTTP_2);
-    connection.okHttpSettings.set(INITIAL_WINDOW_SIZE, 0, windowSize);
-    FramedStream stream = connection.newStream(headerEntries("b", "banana"), false, true);
-    assertEquals(0, stream.unacknowledgedBytesRead);
-    assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
-    Source in = stream.getSource();
-    Buffer buffer = new Buffer();
-    buffer.writeAll(in);
-    assertEquals(-1, in.read(buffer, 1));
-    assertEquals(150, buffer.size());
-
-    MockSpdyPeer.InFrame synStream = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream.type);
-    for (int i = 0; i < 3; i++) {
-      List<Integer> windowUpdateStreamIds = new ArrayList<>(2);
-      for (int j = 0; j < 2; j++) {
-        MockSpdyPeer.InFrame windowUpdate = peer.takeFrame();
-        assertEquals(TYPE_WINDOW_UPDATE, windowUpdate.type);
-        windowUpdateStreamIds.add(windowUpdate.streamId);
-        assertEquals(windowUpdateThreshold, windowUpdate.windowSizeIncrement);
-      }
-      assertTrue(windowUpdateStreamIds.contains(0)); // connection
-      assertTrue(windowUpdateStreamIds.contains(3)); // stream
-    }
-  }
-
-  private Buffer data(int byteCount) {
-    return new Buffer().write(new byte[byteCount]);
-  }
-
-  @Test public void serverSendsEmptyDataClientDoesntSendWindowUpdateHttp2() throws Exception {
-    peer.setVariantAndClient(HTTP_2, false);
-
-    // Write the mocking script.
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
-    peer.sendFrame().data(true, 3, data(0), 0);
-    peer.play();
-
-    // Play it back.
-    FramedConnection connection = connection(peer, HTTP_2);
-    FramedStream client = connection.newStream(headerEntries("b", "banana"), false, true);
-    assertEquals(-1, client.getSource().read(new Buffer(), 1));
-
-    // Verify the peer received what was expected.
-    MockSpdyPeer.InFrame synStream = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream.type);
-    assertEquals(3, peer.frameCount());
-  }
-
-  @Test public void clientSendsEmptyDataServerDoesntSendWindowUpdateHttp2() throws Exception {
-    peer.setVariantAndClient(HTTP_2, false);
-
-    // Write the mocking script.
-    peer.acceptFrame(); // SYN_STREAM
-    peer.acceptFrame(); // DATA
-    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
-    peer.play();
-
-    // Play it back.
-    FramedConnection connection = connection(peer, HTTP_2);
-    FramedStream client = connection.newStream(headerEntries("b", "banana"), true, true);
-    BufferedSink out = Okio.buffer(client.getSink());
-    out.write(EMPTY_BYTE_ARRAY);
-    out.flush();
-    out.close();
-
-    // Verify the peer received what was expected.
-    assertEquals(TYPE_HEADERS, peer.takeFrame().type);
-    assertEquals(TYPE_DATA, peer.takeFrame().type);
-    assertEquals(3, peer.frameCount());
-  }
-
-  @Test public void maxFrameSizeHonored() throws Exception {
-    peer.setVariantAndClient(HTTP_2, false);
-
-    byte[] buff = new byte[peer.maxOutboundDataLength() + 1];
-    Arrays.fill(buff, (byte) '*');
-
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
-    peer.acceptFrame(); // DATA
-    peer.acceptFrame(); // DATA
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, HTTP_2);
-    FramedStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
-    BufferedSink out = Okio.buffer(stream.getSink());
-    out.write(buff);
-    out.flush();
-    out.close();
-
-    MockSpdyPeer.InFrame synStream = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream.type);
-    MockSpdyPeer.InFrame data = peer.takeFrame();
-    assertEquals(peer.maxOutboundDataLength(), data.data.length);
-    data = peer.takeFrame();
-    assertEquals(1, data.data.length);
-  }
-
-  @Test public void pushPromiseStream() throws Exception {
-    peer.setVariantAndClient(HTTP_2, false);
-
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
-    final List<Header> expectedRequestHeaders = Arrays.asList(
-        new Header(Header.TARGET_METHOD, "GET"),
-        new Header(Header.TARGET_SCHEME, "https"),
-        new Header(Header.TARGET_AUTHORITY, "squareup.com"),
-        new Header(Header.TARGET_PATH, "/cached")
-    );
-    peer.sendFrame().pushPromise(3, 2, expectedRequestHeaders);
-    final List<Header> expectedResponseHeaders = Arrays.asList(
-        new Header(Header.RESPONSE_STATUS, "200")
-    );
-    peer.sendFrame().synReply(true, 2, expectedResponseHeaders);
-    peer.sendFrame().data(true, 3, data(0), 0);
-    peer.play();
-
-    RecordingPushObserver observer = new RecordingPushObserver();
-
-    // play it back
-    FramedConnection connection = connectionBuilder(peer, HTTP_2)
-        .pushObserver(observer)
-        .build();
-    connection.start(false);
-    FramedStream client = connection.newStream(headerEntries("b", "banana"), false, true);
-    assertEquals(-1, client.getSource().read(new Buffer(), 1));
-
-    // verify the peer received what was expected
-    assertEquals(TYPE_HEADERS, peer.takeFrame().type);
-
-    assertEquals(expectedRequestHeaders, observer.takeEvent());
-    assertEquals(expectedResponseHeaders, observer.takeEvent());
-  }
-
-  @Test public void doublePushPromise() throws Exception {
-    peer.setVariantAndClient(HTTP_2, false);
-
-    // write the mocking script
-    peer.sendFrame().pushPromise(3, 2, headerEntries("a", "android"));
-    peer.acceptFrame(); // SYN_REPLY
-    peer.sendFrame().pushPromise(3, 2, headerEntries("b", "banana"));
-    peer.acceptFrame(); // RST_STREAM
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connectionBuilder(peer, HTTP_2).build();
-    connection.start(false);
-    connection.newStream(headerEntries("b", "banana"), false, true);
-
-    // verify the peer received what was expected
-    assertEquals(TYPE_HEADERS, peer.takeFrame().type);
-    assertEquals(PROTOCOL_ERROR, peer.takeFrame().errorCode);
-  }
-
-  @Test public void pushPromiseStreamsAutomaticallyCancel() throws Exception {
-    peer.setVariantAndClient(HTTP_2, false);
-
-    // write the mocking script
-    peer.sendFrame().pushPromise(3, 2, Arrays.asList(
-        new Header(Header.TARGET_METHOD, "GET"),
-        new Header(Header.TARGET_SCHEME, "https"),
-        new Header(Header.TARGET_AUTHORITY, "squareup.com"),
-        new Header(Header.TARGET_PATH, "/cached")
-    ));
-    peer.sendFrame().synReply(true, 2, Arrays.asList(
-        new Header(Header.RESPONSE_STATUS, "200")
-    ));
-    peer.acceptFrame(); // RST_STREAM
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connectionBuilder(peer, HTTP_2)
-        .pushObserver(PushObserver.CANCEL)
-        .build();
-    connection.start(false);
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame rstStream = peer.takeFrame();
-    assertEquals(TYPE_RST_STREAM, rstStream.type);
-    assertEquals(2, rstStream.streamId);
-    assertEquals(CANCEL, rstStream.errorCode);
-  }
-
-  /**
-   * When writing a set of headers fails due to an {@code IOException}, make sure the writer is left
-   * in a consistent state so the next writer also gets an {@code IOException} also instead of
-   * something worse (like an {@link IllegalStateException}.
-   *
-   * <p>See https://github.com/square/okhttp/issues/1651
-   */
-  @Test public void socketExceptionWhileWritingHeaders() throws Exception {
-    peer.setVariantAndClient(HTTP_2, false);
-    peer.acceptFrame(); // SYN_STREAM.
-    peer.play();
-
-    String longString = repeat('a', Http2.INITIAL_MAX_FRAME_SIZE + 1);
-    Socket socket = peer.openSocket();
-    FramedConnection connection = new FramedConnection.Builder(true)
-        .socket(socket)
-        .pushObserver(IGNORE)
-        .protocol(HTTP_2.getProtocol())
-        .build();
-    connection.start(false);
-    socket.shutdownOutput();
-    try {
-      connection.newStream(headerEntries("a", longString), false, true);
-      fail();
-    } catch (IOException expected) {
-    }
-    try {
-      connection.newStream(headerEntries("b", longString), false, true);
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  private FramedConnection sendHttp2SettingsAndCheckForAck(boolean client, Settings settings)
-      throws IOException, InterruptedException {
-    peer.setVariantAndClient(HTTP_2, client);
-    peer.sendFrame().settings(settings);
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 0);
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, HTTP_2);
-
-    // verify the peer received the ACK
-    MockSpdyPeer.InFrame ackFrame = peer.takeFrame();
-    assertEquals(TYPE_SETTINGS, ackFrame.type);
-    assertEquals(0, ackFrame.streamId);
-    assertTrue(ackFrame.ack);
-
-    connection.ping().roundTripTime(); // Ensure that settings have been applied before returning.
-    return connection;
-  }
-
-  private FramedConnection connection(MockSpdyPeer peer, Variant variant) throws IOException {
-    FramedConnection connection = connectionBuilder(peer, variant).build();
-    connection.start(false);
-    return connection;
-  }
-
-  private FramedConnection.Builder connectionBuilder(MockSpdyPeer peer, Variant variant)
-      throws IOException {
-    return new FramedConnection.Builder(true)
-        .socket(peer.openSocket())
-        .pushObserver(IGNORE)
-        .protocol(variant.getProtocol());
-  }
-
-  static final PushObserver IGNORE = new PushObserver() {
-
-    @Override public boolean onRequest(int streamId, List<Header> requestHeaders) {
-      return false;
-    }
-
-    @Override public boolean onHeaders(int streamId, List<Header> responseHeaders, boolean last) {
-      return false;
-    }
-
-    @Override public boolean onData(int streamId, BufferedSource source, int byteCount,
-        boolean last) throws IOException {
-      source.skip(byteCount);
-      return false;
-    }
-
-    @Override public void onReset(int streamId, ErrorCode errorCode) {
-    }
-  };
-
-  private static class RecordingPushObserver implements PushObserver {
-    final List<Object> events = new ArrayList<>();
-
-    public synchronized Object takeEvent() throws InterruptedException {
-      while (events.isEmpty()) {
-        wait();
-      }
-      return events.remove(0);
-    }
-
-    @Override public synchronized boolean onRequest(int streamId, List<Header> requestHeaders) {
-      assertEquals(2, streamId);
-      events.add(requestHeaders);
-      notifyAll();
-      return false;
-    }
-
-    @Override public synchronized boolean onHeaders(
-        int streamId, List<Header> responseHeaders, boolean last) {
-      assertEquals(2, streamId);
-      assertTrue(last);
-      events.add(responseHeaders);
-      notifyAll();
-      return false;
-    }
-
-    @Override public synchronized boolean onData(
-        int streamId, BufferedSource source, int byteCount, boolean last) {
-      events.add(new AssertionError("onData"));
-      notifyAll();
-      return false;
-    }
-
-    @Override public synchronized void onReset(int streamId, ErrorCode errorCode) {
-      events.add(new AssertionError("onReset"));
-      notifyAll();
-    }
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/framed/HttpOverHttp2Test.java b/okhttp-tests/src/test/java/okhttp3/internal/framed/HttpOverHttp2Test.java
deleted file mode 100644
index c747f0b7a4..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/framed/HttpOverHttp2Test.java
+++ /dev/null
@@ -1,137 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.framed;
-
-import okhttp3.Call;
-import okhttp3.Headers;
-import okhttp3.Protocol;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.PushPromise;
-import okhttp3.mockwebserver.RecordedRequest;
-import org.junit.Test;
-
-import static org.junit.Assert.assertEquals;
-
-public class HttpOverHttp2Test extends HttpOverSpdyTest {
-
-  public HttpOverHttp2Test() {
-    super(Protocol.HTTP_2);
-    this.hostHeader = ":authority";
-  }
-
-  @Test public void serverSendsPushPromise_GET() throws Exception {
-    PushPromise pushPromise = new PushPromise("GET", "/foo/bar", Headers.of("foo", "bar"),
-        new MockResponse().setBody("bar").setStatus("HTTP/1.1 200 Sweet"));
-    server.enqueue(new MockResponse()
-        .setBody("ABCDE")
-        .setStatus("HTTP/1.1 200 Sweet")
-        .withPush(pushPromise));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/foo"))
-        .build());
-    Response response = call.execute();
-
-    assertEquals("ABCDE", response.body().string());
-    assertEquals(200, response.code());
-    assertEquals("Sweet", response.message());
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
-    assertEquals("https", request.getHeader(":scheme"));
-    assertEquals(server.getHostName() + ":" + server.getPort(), request.getHeader(hostHeader));
-
-    RecordedRequest pushedRequest = server.takeRequest();
-    assertEquals("GET /foo/bar HTTP/1.1", pushedRequest.getRequestLine());
-    assertEquals("bar", pushedRequest.getHeader("foo"));
-  }
-
-  @Test public void serverSendsPushPromise_HEAD() throws Exception {
-    PushPromise pushPromise = new PushPromise("HEAD", "/foo/bar", Headers.of("foo", "bar"),
-        new MockResponse().setStatus("HTTP/1.1 204 Sweet"));
-    server.enqueue(new MockResponse()
-        .setBody("ABCDE")
-        .setStatus("HTTP/1.1 200 Sweet")
-        .withPush(pushPromise));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/foo"))
-        .build());
-    Response response = call.execute();
-    assertEquals("ABCDE", response.body().string());
-    assertEquals(200, response.code());
-    assertEquals("Sweet", response.message());
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
-    assertEquals("https", request.getHeader(":scheme"));
-    assertEquals(server.getHostName() + ":" + server.getPort(), request.getHeader(hostHeader));
-
-    RecordedRequest pushedRequest = server.takeRequest();
-    assertEquals("HEAD /foo/bar HTTP/1.1", pushedRequest.getRequestLine());
-    assertEquals("bar", pushedRequest.getHeader("foo"));
-  }
-
-  /**
-   * Push a setting that permits up to 2 concurrent streams, then make 3 concurrent requests and
-   * confirm that the third concurrent request prepared a new connection.
-   */
-  @Test public void settingsLimitsMaxConcurrentStreams() throws Exception {
-    Settings settings = new Settings();
-    settings.set(Settings.MAX_CONCURRENT_STREAMS, 0, 2);
-
-    // Read & write a full request to confirm settings are accepted.
-    server.enqueue(new MockResponse().withSettings(settings));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    assertEquals("", response.body().string());
-
-    server.enqueue(new MockResponse()
-        .setBody("ABC"));
-    server.enqueue(new MockResponse()
-        .setBody("DEF"));
-    server.enqueue(new MockResponse()
-        .setBody("GHI"));
-
-    Call call1 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response1 = call1.execute();
-
-    Call call2 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response2 = call2.execute();
-
-    Call call3 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response3 = call3.execute();
-
-    assertEquals("ABC", response1.body().string());
-    assertEquals("DEF", response2.body().string());
-    assertEquals("GHI", response3.body().string());
-    assertEquals(0, server.takeRequest().getSequenceNumber()); // Settings connection.
-    assertEquals(1, server.takeRequest().getSequenceNumber()); // Reuse settings connection.
-    assertEquals(2, server.takeRequest().getSequenceNumber()); // Reuse settings connection.
-    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection!
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/framed/SettingsTest.java b/okhttp-tests/src/test/java/okhttp3/internal/framed/SettingsTest.java
deleted file mode 100644
index 9eae7f89db..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/framed/SettingsTest.java
+++ /dev/null
@@ -1,176 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.framed;
-
-import org.junit.Test;
-
-import static okhttp3.internal.framed.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
-import static okhttp3.internal.framed.Settings.DOWNLOAD_BANDWIDTH;
-import static okhttp3.internal.framed.Settings.DOWNLOAD_RETRANS_RATE;
-import static okhttp3.internal.framed.Settings.MAX_CONCURRENT_STREAMS;
-import static okhttp3.internal.framed.Settings.PERSISTED;
-import static okhttp3.internal.framed.Settings.PERSIST_VALUE;
-import static okhttp3.internal.framed.Settings.UPLOAD_BANDWIDTH;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-
-public final class SettingsTest {
-  @Test public void unsetField() {
-    Settings settings = new Settings();
-    assertEquals(-3, settings.getUploadBandwidth(-3));
-  }
-
-  @Test public void setFields() {
-    Settings settings = new Settings();
-
-    // WARNING: clash on flags between spdy/3 and HTTP/2!
-    assertEquals(-3, settings.getUploadBandwidth(-3));
-    assertEquals(-1, settings.getHeaderTableSize());
-    settings.set(UPLOAD_BANDWIDTH, 0, 42);
-    assertEquals(42, settings.getUploadBandwidth(-3));
-    settings.set(Settings.HEADER_TABLE_SIZE, 0, 8096);
-    assertEquals(8096, settings.getHeaderTableSize());
-
-    // WARNING: clash on flags between spdy/3 and HTTP/2!
-    assertEquals(true, settings.getEnablePush(true));
-    settings.set(Settings.ENABLE_PUSH, 0, 1);
-    assertEquals(true, settings.getEnablePush(false));
-    settings.clear();
-    assertEquals(-3, settings.getDownloadBandwidth(-3));
-    settings.set(DOWNLOAD_BANDWIDTH, 0, 53);
-    assertEquals(53, settings.getDownloadBandwidth(-3));
-
-    assertEquals(-3, settings.getRoundTripTime(-3));
-    settings.set(Settings.ROUND_TRIP_TIME, 0, 64);
-    assertEquals(64, settings.getRoundTripTime(-3));
-
-    assertEquals(-3, settings.getMaxConcurrentStreams(-3));
-    settings.set(MAX_CONCURRENT_STREAMS, 0, 75);
-    assertEquals(75, settings.getMaxConcurrentStreams(-3));
-
-    // WARNING: clash on flags between spdy/3 and HTTP/2!
-    assertEquals(-3, settings.getCurrentCwnd(-3));
-    settings.set(Settings.CURRENT_CWND, 0, 86);
-    assertEquals(86, settings.getCurrentCwnd(-3));
-    settings.clear();
-    assertEquals(16384, settings.getMaxFrameSize(16384));
-    settings.set(Settings.MAX_FRAME_SIZE, 0, 16777215);
-    assertEquals(16777215, settings.getMaxFrameSize(16384));
-
-    // WARNING: clash on flags between spdy/3 and HTTP/2!
-    assertEquals(-3, settings.getDownloadRetransRate(-3));
-    settings.set(DOWNLOAD_RETRANS_RATE, 0, 97);
-    assertEquals(97, settings.getDownloadRetransRate(-3));
-    settings.clear();
-    assertEquals(-1, settings.getMaxHeaderListSize(-1));
-    settings.set(Settings.MAX_HEADER_LIST_SIZE, 0, 16777215);
-    assertEquals(16777215, settings.getMaxHeaderListSize(-1));
-
-    assertEquals(DEFAULT_INITIAL_WINDOW_SIZE,
-        settings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE));
-    settings.set(Settings.INITIAL_WINDOW_SIZE, 0, 108);
-    assertEquals(108, settings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE));
-
-    assertEquals(-3, settings.getClientCertificateVectorSize(-3));
-    settings.set(Settings.CLIENT_CERTIFICATE_VECTOR_SIZE, 0, 117);
-    assertEquals(117, settings.getClientCertificateVectorSize(-3));
-  }
-
-  @Test public void isPersisted() {
-    Settings settings = new Settings();
-
-    // Initially false.
-    assertFalse(settings.isPersisted(Settings.ROUND_TRIP_TIME));
-
-    // Set no flags.
-    settings.set(Settings.ROUND_TRIP_TIME, 0, 0);
-    assertFalse(settings.isPersisted(Settings.ROUND_TRIP_TIME));
-
-    // Set the wrong flag.
-    settings.set(Settings.ROUND_TRIP_TIME, PERSIST_VALUE, 0);
-    assertFalse(settings.isPersisted(Settings.ROUND_TRIP_TIME));
-
-    // Set the right flag.
-    settings.set(Settings.ROUND_TRIP_TIME, PERSISTED, 0);
-    assertTrue(settings.isPersisted(Settings.ROUND_TRIP_TIME));
-
-    // Set multiple flags.
-    settings.set(Settings.ROUND_TRIP_TIME, PERSIST_VALUE | PERSISTED, 0);
-    assertTrue(settings.isPersisted(Settings.ROUND_TRIP_TIME));
-
-    // Clear the flag.
-    settings.set(Settings.ROUND_TRIP_TIME, PERSIST_VALUE, 0);
-    assertFalse(settings.isPersisted(Settings.ROUND_TRIP_TIME));
-
-    // Clear all flags.
-    settings.set(Settings.ROUND_TRIP_TIME, 0, 0);
-    assertFalse(settings.isPersisted(Settings.ROUND_TRIP_TIME));
-  }
-
-  @Test public void persistValue() {
-    Settings settings = new Settings();
-
-    // Initially false.
-    assertFalse(settings.persistValue(Settings.ROUND_TRIP_TIME));
-
-    // Set no flags.
-    settings.set(Settings.ROUND_TRIP_TIME, 0, 0);
-    assertFalse(settings.persistValue(Settings.ROUND_TRIP_TIME));
-
-    // Set the wrong flag.
-    settings.set(Settings.ROUND_TRIP_TIME, PERSISTED, 0);
-    assertFalse(settings.persistValue(Settings.ROUND_TRIP_TIME));
-
-    // Set the right flag.
-    settings.set(Settings.ROUND_TRIP_TIME, PERSIST_VALUE, 0);
-    assertTrue(settings.persistValue(Settings.ROUND_TRIP_TIME));
-
-    // Set multiple flags.
-    settings.set(Settings.ROUND_TRIP_TIME, PERSIST_VALUE | PERSISTED, 0);
-    assertTrue(settings.persistValue(Settings.ROUND_TRIP_TIME));
-
-    // Clear the flag.
-    settings.set(Settings.ROUND_TRIP_TIME, PERSISTED, 0);
-    assertFalse(settings.persistValue(Settings.ROUND_TRIP_TIME));
-
-    // Clear all flags.
-    settings.set(Settings.ROUND_TRIP_TIME, 0, 0);
-    assertFalse(settings.persistValue(Settings.ROUND_TRIP_TIME));
-  }
-
-  @Test public void merge() {
-    Settings a = new Settings();
-    a.set(UPLOAD_BANDWIDTH, PERSIST_VALUE, 100);
-    a.set(DOWNLOAD_BANDWIDTH, PERSIST_VALUE, 200);
-    a.set(DOWNLOAD_RETRANS_RATE, 0, 300);
-
-    Settings b = new Settings();
-    b.set(DOWNLOAD_BANDWIDTH, 0, 400);
-    b.set(DOWNLOAD_RETRANS_RATE, PERSIST_VALUE, 500);
-    b.set(MAX_CONCURRENT_STREAMS, PERSIST_VALUE, 600);
-
-    a.merge(b);
-    assertEquals(100, a.getUploadBandwidth(-1));
-    assertEquals(PERSIST_VALUE, a.flags(UPLOAD_BANDWIDTH));
-    assertEquals(400, a.getDownloadBandwidth(-1));
-    assertEquals(0, a.flags(DOWNLOAD_BANDWIDTH));
-    assertEquals(500, a.getDownloadRetransRate(-1));
-    assertEquals(PERSIST_VALUE, a.flags(DOWNLOAD_RETRANS_RATE));
-    assertEquals(600, a.getMaxConcurrentStreams(-1));
-    assertEquals(PERSIST_VALUE, a.flags(MAX_CONCURRENT_STREAMS));
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/framed/Spdy3ConnectionTest.java b/okhttp-tests/src/test/java/okhttp3/internal/framed/Spdy3ConnectionTest.java
deleted file mode 100644
index 96a6fb4288..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/framed/Spdy3ConnectionTest.java
+++ /dev/null
@@ -1,1422 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.framed;
-
-import java.io.IOException;
-import java.io.InterruptedIOException;
-import java.net.Socket;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import java.util.Random;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicInteger;
-import okhttp3.internal.Util;
-import okio.AsyncTimeout;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.ByteString;
-import okio.Okio;
-import okio.Sink;
-import okio.Source;
-import org.junit.After;
-import org.junit.Test;
-
-import static okhttp3.TestUtil.headerEntries;
-import static okhttp3.internal.framed.ErrorCode.CANCEL;
-import static okhttp3.internal.framed.ErrorCode.INTERNAL_ERROR;
-import static okhttp3.internal.framed.ErrorCode.INVALID_STREAM;
-import static okhttp3.internal.framed.ErrorCode.PROTOCOL_ERROR;
-import static okhttp3.internal.framed.ErrorCode.REFUSED_STREAM;
-import static okhttp3.internal.framed.ErrorCode.STREAM_IN_USE;
-import static okhttp3.internal.framed.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
-import static okhttp3.internal.framed.Settings.DOWNLOAD_BANDWIDTH;
-import static okhttp3.internal.framed.Settings.DOWNLOAD_RETRANS_RATE;
-import static okhttp3.internal.framed.Settings.INITIAL_WINDOW_SIZE;
-import static okhttp3.internal.framed.Settings.MAX_CONCURRENT_STREAMS;
-import static okhttp3.internal.framed.Settings.PERSIST_VALUE;
-import static okhttp3.internal.framed.Settings.UPLOAD_BANDWIDTH;
-import static okhttp3.internal.framed.Spdy3.TYPE_DATA;
-import static okhttp3.internal.framed.Spdy3.TYPE_GOAWAY;
-import static okhttp3.internal.framed.Spdy3.TYPE_HEADERS;
-import static okhttp3.internal.framed.Spdy3.TYPE_PING;
-import static okhttp3.internal.framed.Spdy3.TYPE_RST_STREAM;
-import static okhttp3.internal.framed.Spdy3.TYPE_WINDOW_UPDATE;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-public final class Spdy3ConnectionTest {
-  private static final Variant SPDY3 = new Spdy3();
-  private final MockSpdyPeer peer = new MockSpdyPeer();
-
-  @After public void tearDown() throws Exception {
-    peer.close();
-  }
-
-  @Test public void clientCreatesStreamAndServerReplies() throws Exception {
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame()
-        .synReply(false, 1, headerEntries("a", "android"));
-    peer.sendFrame().data(true, 1, new Buffer().writeUtf8("robot"), 5);
-    peer.acceptFrame(); // DATA
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
-    assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
-    assertStreamData("robot", stream.getSource());
-    BufferedSink out = Okio.buffer(stream.getSink());
-    out.writeUtf8("c3po");
-    out.close();
-    assertEquals(0, connection.openStreamCount());
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame synStream = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream.type);
-    assertEquals(HeadersMode.SPDY_SYN_STREAM, synStream.headersMode);
-    assertFalse(synStream.inFinished);
-    assertFalse(synStream.outFinished);
-    assertEquals(1, synStream.streamId);
-    assertEquals(0, synStream.associatedStreamId);
-    assertEquals(headerEntries("b", "banana"), synStream.headerBlock);
-    MockSpdyPeer.InFrame requestData = peer.takeFrame();
-    assertTrue(Arrays.equals("c3po".getBytes("UTF-8"), requestData.data));
-  }
-
-  @Test public void headersOnlyStreamIsClosedAfterReplyHeaders() throws Exception {
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, headerEntries("b", "banana"));
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 0);
-    peer.play();
-
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream stream = connection.newStream(headerEntries("a", "android"), false, false);
-    assertEquals(headerEntries("b", "banana"), stream.getResponseHeaders());
-    connection.ping().roundTripTime(); // Ensure that inFinished has been received.
-    assertEquals(0, connection.openStreamCount());
-  }
-
-  @Test public void clientCreatesStreamAndServerRepliesWithFin() throws Exception {
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM
-    peer.acceptFrame(); // PING
-    peer.sendFrame().synReply(true, 1, headerEntries("a", "android"));
-    peer.sendFrame().ping(true, 1, 0);
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    connection.newStream(headerEntries("b", "banana"), false, true);
-    assertEquals(1, connection.openStreamCount());
-    connection.ping().roundTripTime(); // Ensure that the SYN_REPLY has been received.
-    assertEquals(0, connection.openStreamCount());
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame synStream = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream.type);
-    assertEquals(HeadersMode.SPDY_SYN_STREAM, synStream.headersMode);
-    MockSpdyPeer.InFrame ping = peer.takeFrame();
-    assertEquals(TYPE_PING, ping.type);
-  }
-
-  @Test public void serverCreatesStreamAndClientReplies() throws Exception {
-    final List<Header> pushHeaders = headerEntries(
-        ":scheme", "https",
-        ":host", "localhost:8888",
-        ":method", "GET",
-        ":path", "/index.html",
-        ":status", "200",
-        ":version", "HTTP/1.1",
-        "content-type", "text/html");
-    // write the mocking script
-    peer.sendFrame().synStream(false, false, 2, 0, pushHeaders);
-    peer.acceptFrame(); // SYN_REPLY
-    peer.play();
-
-    // play it back
-    final AtomicInteger receiveCount = new AtomicInteger();
-    FramedConnection.Listener handler = new FramedConnection.Listener() {
-      @Override public void onStream(FramedStream stream) throws IOException {
-        receiveCount.incrementAndGet();
-        assertEquals(pushHeaders, stream.getRequestHeaders());
-        assertEquals(null, stream.getErrorCode());
-        stream.reply(headerEntries("b", "banana"), true);
-      }
-    };
-    FramedConnection connection = new FramedConnection.Builder(true)
-        .socket(peer.openSocket())
-        .listener(handler)
-        .build();
-    connection.start(false);
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame reply = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, reply.type);
-    assertEquals(HeadersMode.SPDY_REPLY, reply.headersMode);
-    assertFalse(reply.inFinished);
-    assertEquals(2, reply.streamId);
-    assertEquals(headerEntries("b", "banana"), reply.headerBlock);
-    assertEquals(1, receiveCount.get());
-  }
-
-  @Test public void replyWithNoData() throws Exception {
-    // write the mocking script
-    peer.sendFrame().synStream(false, false, 2, 0, headerEntries("a", "android"));
-    peer.acceptFrame(); // SYN_REPLY
-    peer.play();
-
-    // play it back
-    final AtomicInteger receiveCount = new AtomicInteger();
-    FramedConnection.Listener listener = new FramedConnection.Listener() {
-      @Override public void onStream(FramedStream stream) throws IOException {
-        stream.reply(headerEntries("b", "banana"), false);
-        receiveCount.incrementAndGet();
-      }
-    };
-
-    FramedConnection connection = connectionBuilder(peer, SPDY3)
-        .listener(listener)
-        .build();
-    connection.start(false);
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame reply = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, reply.type);
-    assertTrue(reply.inFinished);
-    assertEquals(headerEntries("b", "banana"), reply.headerBlock);
-    assertEquals(1, receiveCount.get());
-    assertEquals(HeadersMode.SPDY_REPLY, reply.headersMode);
-  }
-
-  @Test public void serverPingsClient() throws Exception {
-    // write the mocking script
-    peer.sendFrame().ping(false, 2, 0);
-    peer.acceptFrame(); // PING
-    peer.play();
-
-    // play it back
-    connection(peer, SPDY3);
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame ping = peer.takeFrame();
-    assertEquals(0, ping.streamId);
-    assertEquals(2, ping.payload1);
-    assertEquals(0, ping.payload2); // ignored in spdy!
-    assertTrue(ping.ack);
-  }
-
-  @Test public void clientPingsServer() throws Exception {
-    // write the mocking script
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 5); // payload2 ignored in spdy!
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    Ping ping = connection.ping();
-    assertTrue(ping.roundTripTime() > 0);
-    assertTrue(ping.roundTripTime() < TimeUnit.SECONDS.toNanos(1));
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame pingFrame = peer.takeFrame();
-    assertEquals(TYPE_PING, pingFrame.type);
-    assertEquals(1, pingFrame.payload1);
-    assertEquals(0, pingFrame.payload2);
-    assertFalse(pingFrame.ack);
-  }
-
-  @Test public void unexpectedPingIsNotReturned() throws Exception {
-    // write the mocking script
-    peer.sendFrame().ping(false, 2, 0);
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 3, 0); // This ping will not be returned.
-    peer.sendFrame().ping(false, 4, 0);
-    peer.acceptFrame(); // PING
-    peer.play();
-
-    // play it back
-    connection(peer, SPDY3);
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame ping2 = peer.takeFrame();
-    assertEquals(2, ping2.payload1);
-    MockSpdyPeer.InFrame ping4 = peer.takeFrame();
-    assertEquals(4, ping4.payload1);
-  }
-
-  @Test public void serverSendsSettingsToClient() throws Exception {
-    // write the mocking script
-    final Settings settings = new Settings();
-    settings.set(MAX_CONCURRENT_STREAMS, PERSIST_VALUE, 10);
-    peer.sendFrame().settings(settings);
-    peer.sendFrame().ping(false, 2, 0);
-    peer.acceptFrame(); // PING
-    peer.play();
-
-    // play it back
-    final AtomicInteger maxConcurrentStreams = new AtomicInteger();
-    FramedConnection.Listener listener = new FramedConnection.Listener() {
-      @Override public void onStream(FramedStream stream) throws IOException {
-        throw new AssertionError();
-      }
-
-      @Override public void onSettings(FramedConnection connection) {
-        maxConcurrentStreams.set(connection.maxConcurrentStreams());
-      }
-    };
-    FramedConnection connection = connectionBuilder(peer, SPDY3)
-        .listener(listener)
-        .build();
-    connection.start(false);
-
-    peer.takeFrame(); // Guarantees that the peer Settings frame has been processed.
-    synchronized (connection) {
-      assertEquals(10, connection.peerSettings.getMaxConcurrentStreams(-1));
-    }
-    assertEquals(10, maxConcurrentStreams.get());
-  }
-
-  @Test public void multipleSettingsFramesAreMerged() throws Exception {
-    // write the mocking script
-    Settings settings1 = new Settings();
-    settings1.set(UPLOAD_BANDWIDTH, PERSIST_VALUE, 100);
-    settings1.set(DOWNLOAD_BANDWIDTH, PERSIST_VALUE, 200);
-    settings1.set(DOWNLOAD_RETRANS_RATE, 0, 300);
-    peer.sendFrame().settings(settings1);
-    Settings settings2 = new Settings();
-    settings2.set(DOWNLOAD_BANDWIDTH, 0, 400);
-    settings2.set(DOWNLOAD_RETRANS_RATE, PERSIST_VALUE, 500);
-    settings2.set(MAX_CONCURRENT_STREAMS, PERSIST_VALUE, 600);
-    peer.sendFrame().settings(settings2);
-    peer.sendFrame().ping(false, 2, 0);
-    peer.acceptFrame();
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-
-    peer.takeFrame(); // Guarantees that the Settings frame has been processed.
-    synchronized (connection) {
-      assertEquals(100, connection.peerSettings.getUploadBandwidth(-1));
-      assertEquals(PERSIST_VALUE, connection.peerSettings.flags(UPLOAD_BANDWIDTH));
-      assertEquals(400, connection.peerSettings.getDownloadBandwidth(-1));
-      assertEquals(0, connection.peerSettings.flags(DOWNLOAD_BANDWIDTH));
-      assertEquals(500, connection.peerSettings.getDownloadRetransRate(-1));
-      assertEquals(PERSIST_VALUE, connection.peerSettings.flags(DOWNLOAD_RETRANS_RATE));
-      assertEquals(600, connection.peerSettings.getMaxConcurrentStreams(-1));
-      assertEquals(PERSIST_VALUE, connection.peerSettings.flags(MAX_CONCURRENT_STREAMS));
-    }
-  }
-
-  @Test public void clearSettingsBeforeMerge() throws Exception {
-    // write the mocking script
-    Settings settings1 = new Settings();
-    settings1.set(UPLOAD_BANDWIDTH, PERSIST_VALUE, 100);
-    settings1.set(DOWNLOAD_BANDWIDTH, PERSIST_VALUE, 200);
-    settings1.set(DOWNLOAD_RETRANS_RATE, 0, 300);
-    peer.sendFrame().settings(settings1);
-    peer.sendFrame().ping(false, 2, 0);
-    peer.acceptFrame();
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-
-    peer.takeFrame(); // Guarantees that the Settings frame has been processed.
-
-    // fake a settings frame with clear flag set.
-    Settings settings2 = new Settings();
-    settings2.set(MAX_CONCURRENT_STREAMS, PERSIST_VALUE, 600);
-    connection.readerRunnable.settings(true, settings2);
-
-    synchronized (connection) {
-      assertEquals(-1, connection.peerSettings.getUploadBandwidth(-1));
-      assertEquals(-1, connection.peerSettings.getDownloadBandwidth(-1));
-      assertEquals(-1, connection.peerSettings.getDownloadRetransRate(-1));
-      assertEquals(600, connection.peerSettings.getMaxConcurrentStreams(-1));
-    }
-  }
-
-  @Test public void bogusDataFrameDoesNotDisruptConnection() throws Exception {
-    // write the mocking script
-    peer.sendFrame().data(true, 41, new Buffer().writeUtf8("bogus"), 5);
-    peer.acceptFrame(); // RST_STREAM
-    peer.sendFrame().ping(false, 2, 0);
-    peer.acceptFrame(); // PING
-    peer.play();
-
-    // play it back
-    connection(peer, SPDY3);
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame rstStream = peer.takeFrame();
-    assertEquals(TYPE_RST_STREAM, rstStream.type);
-    assertEquals(41, rstStream.streamId);
-    assertEquals(INVALID_STREAM, rstStream.errorCode);
-    MockSpdyPeer.InFrame ping = peer.takeFrame();
-    assertEquals(2, ping.payload1);
-  }
-
-  @Test public void bogusReplyFrameDoesNotDisruptConnection() throws Exception {
-    // write the mocking script
-    peer.sendFrame().synReply(false, 41, headerEntries("a", "android"));
-    peer.acceptFrame(); // RST_STREAM
-    peer.sendFrame().ping(false, 2, 0);
-    peer.acceptFrame(); // PING
-    peer.play();
-
-    // play it back
-    connection(peer, SPDY3);
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame rstStream = peer.takeFrame();
-    assertEquals(TYPE_RST_STREAM, rstStream.type);
-    assertEquals(41, rstStream.streamId);
-    assertEquals(INVALID_STREAM, rstStream.errorCode);
-    MockSpdyPeer.InFrame ping = peer.takeFrame();
-    assertEquals(2, ping.payload1);
-  }
-
-  @Test public void clientClosesClientOutputStream() throws Exception {
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, headerEntries("b", "banana"));
-    peer.acceptFrame(); // TYPE_DATA
-    peer.acceptFrame(); // TYPE_DATA with FLAG_FIN
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 0);
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream stream = connection.newStream(headerEntries("a", "android"), true, false);
-    BufferedSink out = Okio.buffer(stream.getSink());
-    out.writeUtf8("square");
-    out.flush();
-    assertEquals(1, connection.openStreamCount());
-    out.close();
-    try {
-      out.writeUtf8("round");
-      fail();
-    } catch (Exception expected) {
-      assertEquals("closed", expected.getMessage());
-    }
-    connection.ping().roundTripTime(); // Ensure that the SYN_REPLY has been received.
-    assertEquals(0, connection.openStreamCount());
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame synStream = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream.type);
-    assertEquals(HeadersMode.SPDY_SYN_STREAM, synStream.headersMode);
-    assertFalse(synStream.inFinished);
-    assertTrue(synStream.outFinished);
-    MockSpdyPeer.InFrame data = peer.takeFrame();
-    assertEquals(TYPE_DATA, data.type);
-    assertFalse(data.inFinished);
-    assertTrue(Arrays.equals("square".getBytes("UTF-8"), data.data));
-    MockSpdyPeer.InFrame fin = peer.takeFrame();
-    assertEquals(TYPE_DATA, fin.type);
-    assertTrue(fin.inFinished);
-    MockSpdyPeer.InFrame ping = peer.takeFrame();
-    assertEquals(TYPE_PING, ping.type);
-    assertEquals(1, ping.payload1);
-  }
-
-  @Test public void serverClosesClientOutputStream() throws Exception {
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().rstStream(1, CANCEL);
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 0);
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream stream = connection.newStream(headerEntries("a", "android"), true, true);
-    BufferedSink out = Okio.buffer(stream.getSink());
-    connection.ping().roundTripTime(); // Ensure that the RST_CANCEL has been received.
-    try {
-      out.writeUtf8("square");
-      out.flush();
-      fail();
-    } catch (IOException expected) {
-      assertEquals("stream was reset: CANCEL", expected.getMessage());
-    }
-    try {
-      out.close();
-      fail();
-    } catch (IOException expected) {
-      // Close throws because buffered data wasn't flushed.
-    }
-    assertEquals(0, connection.openStreamCount());
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame synStream = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream.type);
-    assertEquals(HeadersMode.SPDY_SYN_STREAM, synStream.headersMode);
-    assertFalse(synStream.inFinished);
-    assertFalse(synStream.outFinished);
-    MockSpdyPeer.InFrame ping = peer.takeFrame();
-    assertEquals(TYPE_PING, ping.type);
-    assertEquals(1, ping.payload1);
-  }
-
-  /**
-   * Test that the client sends a RST_STREAM if doing so won't disrupt the output stream.
-   */
-  @Test public void clientClosesClientInputStream() throws Exception {
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM
-    peer.acceptFrame(); // RST_STREAM
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream stream = connection.newStream(headerEntries("a", "android"), false, true);
-    Source in = stream.getSource();
-    BufferedSink out = Okio.buffer(stream.getSink());
-    in.close();
-    try {
-      in.read(new Buffer(), 1);
-      fail();
-    } catch (IOException expected) {
-      assertEquals("stream closed", expected.getMessage());
-    }
-    try {
-      out.writeUtf8("a");
-      out.flush();
-      fail();
-    } catch (IOException expected) {
-      assertEquals("stream finished", expected.getMessage());
-    }
-    assertEquals(0, connection.openStreamCount());
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame synStream = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream.type);
-    assertEquals(HeadersMode.SPDY_SYN_STREAM, synStream.headersMode);
-    assertTrue(synStream.inFinished);
-    assertFalse(synStream.outFinished);
-    MockSpdyPeer.InFrame rstStream = peer.takeFrame();
-    assertEquals(TYPE_RST_STREAM, rstStream.type);
-    assertEquals(CANCEL, rstStream.errorCode);
-  }
-
-  /**
-   * Test that the client doesn't send a RST_STREAM if doing so will disrupt the output stream.
-   */
-  @Test public void clientClosesClientInputStreamIfOutputStreamIsClosed() throws Exception {
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM
-    peer.acceptFrame(); // DATA
-    peer.acceptFrame(); // DATA with FLAG_FIN
-    peer.acceptFrame(); // RST_STREAM
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream stream = connection.newStream(headerEntries("a", "android"), true, true);
-    Source source = stream.getSource();
-    BufferedSink out = Okio.buffer(stream.getSink());
-    source.close();
-    try {
-      source.read(new Buffer(), 1);
-      fail();
-    } catch (IOException expected) {
-      assertEquals("stream closed", expected.getMessage());
-    }
-    out.writeUtf8("square");
-    out.flush();
-    out.close();
-    assertEquals(0, connection.openStreamCount());
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame synStream = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream.type);
-    assertEquals(HeadersMode.SPDY_SYN_STREAM, synStream.headersMode);
-    assertFalse(synStream.inFinished);
-    assertFalse(synStream.outFinished);
-    MockSpdyPeer.InFrame data = peer.takeFrame();
-    assertEquals(TYPE_DATA, data.type);
-    assertTrue(Arrays.equals("square".getBytes("UTF-8"), data.data));
-    MockSpdyPeer.InFrame fin = peer.takeFrame();
-    assertEquals(TYPE_DATA, fin.type);
-    assertTrue(fin.inFinished);
-    assertFalse(fin.outFinished);
-    MockSpdyPeer.InFrame rstStream = peer.takeFrame();
-    assertEquals(TYPE_RST_STREAM, rstStream.type);
-    assertEquals(CANCEL, rstStream.errorCode);
-  }
-
-  @Test public void serverClosesClientInputStream() throws Exception {
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, headerEntries("b", "banana"));
-    peer.sendFrame().data(true, 1, new Buffer().writeUtf8("square"), 6);
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 0);
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream stream = connection.newStream(headerEntries("a", "android"), false, true);
-    Source source = stream.getSource();
-    assertStreamData("square", source);
-    connection.ping().roundTripTime(); // Ensure that inFinished has been received.
-    assertEquals(0, connection.openStreamCount());
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame synStream = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream.type);
-    assertEquals(HeadersMode.SPDY_SYN_STREAM, synStream.headersMode);
-    assertTrue(synStream.inFinished);
-    assertFalse(synStream.outFinished);
-  }
-
-  @Test public void remoteDoubleSynReply() throws Exception {
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
-    peer.acceptFrame(); // PING
-    peer.sendFrame().synReply(false, 1, headerEntries("b", "banana"));
-    peer.sendFrame().ping(true, 1, 0);
-    peer.acceptFrame(); // RST_STREAM
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream stream = connection.newStream(headerEntries("c", "cola"), true, true);
-    assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
-    connection.ping().roundTripTime(); // Ensure that the 2nd SYN REPLY has been received.
-    try {
-      stream.getSource().read(new Buffer(), 1);
-      fail();
-    } catch (IOException expected) {
-      assertEquals("stream was reset: STREAM_IN_USE", expected.getMessage());
-    }
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame synStream = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream.type);
-    assertEquals(HeadersMode.SPDY_SYN_STREAM, synStream.headersMode);
-    MockSpdyPeer.InFrame ping = peer.takeFrame();
-    assertEquals(TYPE_PING, ping.type);
-    MockSpdyPeer.InFrame rstStream = peer.takeFrame();
-    assertEquals(TYPE_RST_STREAM, rstStream.type);
-    assertEquals(1, rstStream.streamId);
-    assertEquals(STREAM_IN_USE, rstStream.errorCode);
-  }
-
-  @Test public void remoteDoubleSynStream() throws Exception {
-    // write the mocking script
-    peer.sendFrame().synStream(false, false, 2, 0, headerEntries("a", "android"));
-    peer.acceptFrame(); // SYN_REPLY
-    peer.sendFrame().synStream(false, false, 2, 0, headerEntries("b", "banana"));
-    peer.acceptFrame(); // RST_STREAM
-    peer.play();
-
-    // play it back
-    final AtomicInteger receiveCount = new AtomicInteger();
-    FramedConnection.Listener listener = new FramedConnection.Listener() {
-      @Override public void onStream(FramedStream stream) throws IOException {
-        receiveCount.incrementAndGet();
-        assertEquals(headerEntries("a", "android"), stream.getRequestHeaders());
-        assertEquals(null, stream.getErrorCode());
-        stream.reply(headerEntries("c", "cola"), true);
-      }
-    };
-    FramedConnection connection = new FramedConnection.Builder(true)
-        .socket(peer.openSocket())
-        .listener(listener)
-        .build();
-    connection.start(false);
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame reply = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, reply.type);
-    assertEquals(HeadersMode.SPDY_REPLY, reply.headersMode);
-    MockSpdyPeer.InFrame rstStream = peer.takeFrame();
-    assertEquals(TYPE_RST_STREAM, rstStream.type);
-    assertEquals(2, rstStream.streamId);
-    assertEquals(PROTOCOL_ERROR, rstStream.errorCode);
-    assertEquals(1, receiveCount.intValue());
-  }
-
-  @Test public void remoteSendsDataAfterInFinished() throws Exception {
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
-    peer.sendFrame().data(true, 1, new Buffer().writeUtf8("robot"), 5);
-    peer.sendFrame().data(true, 1, new Buffer().writeUtf8("c3po"), 4); // Ignored.
-    peer.sendFrame().ping(false, 2, 0); // Ping just to make sure the stream was fastforwarded.
-    peer.acceptFrame(); // PING
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
-    assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
-    assertStreamData("robot", stream.getSource());
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame synStream = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream.type);
-    assertEquals(HeadersMode.SPDY_SYN_STREAM, synStream.headersMode);
-    MockSpdyPeer.InFrame ping = peer.takeFrame();
-    assertEquals(TYPE_PING, ping.type);
-    assertEquals(2, ping.payload1);
-  }
-
-  @Test public void clientDoesNotLimitFlowControl() throws Exception {
-    int dataLength = 64 * 1024 + 1;
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, headerEntries("b", "banana"));
-    peer.sendFrame().data(false, 1, new Buffer().write(new byte[dataLength]), dataLength);
-    peer.sendFrame().ping(false, 2, 0); // Ping just to make sure the stream was fastforwarded.
-    peer.acceptFrame(); // PING
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream stream = connection.newStream(headerEntries("a", "android"), true, true);
-    assertEquals(headerEntries("b", "banana"), stream.getResponseHeaders());
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame synStream = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream.type);
-    assertEquals(HeadersMode.SPDY_SYN_STREAM, synStream.headersMode);
-    MockSpdyPeer.InFrame ping = peer.takeFrame();
-    assertEquals(TYPE_PING, ping.type);
-    assertEquals(2, ping.payload1);
-  }
-
-  @Test public void remoteSendsRefusedStreamBeforeReplyHeaders() throws Exception {
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().rstStream(1, REFUSED_STREAM);
-    peer.sendFrame().ping(false, 2, 0);
-    peer.acceptFrame(); // PING
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream stream = connection.newStream(headerEntries("a", "android"), true, true);
-    try {
-      stream.getResponseHeaders();
-      fail();
-    } catch (IOException expected) {
-      assertEquals("stream was reset: REFUSED_STREAM", expected.getMessage());
-    }
-    assertEquals(0, connection.openStreamCount());
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame synStream = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream.type);
-    assertEquals(HeadersMode.SPDY_SYN_STREAM, synStream.headersMode);
-    MockSpdyPeer.InFrame ping = peer.takeFrame();
-    assertEquals(TYPE_PING, ping.type);
-    assertEquals(2, ping.payload1);
-  }
-
-  @Test public void receiveGoAway() throws Exception {
-    peer.setVariantAndClient(SPDY3, false);
-
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM 1
-    peer.acceptFrame(); // SYN_STREAM 3
-    peer.acceptFrame(); // PING.
-    peer.sendFrame().goAway(1, PROTOCOL_ERROR, Util.EMPTY_BYTE_ARRAY);
-    peer.sendFrame().ping(true, 1, 0);
-    peer.acceptFrame(); // DATA STREAM 1
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream stream1 = connection.newStream(headerEntries("a", "android"), true, true);
-    FramedStream stream2 = connection.newStream(headerEntries("b", "banana"), true, true);
-    connection.ping().roundTripTime(); // Ensure the GO_AWAY that resets stream2 has been received.
-    BufferedSink sink1 = Okio.buffer(stream1.getSink());
-    BufferedSink sink2 = Okio.buffer(stream2.getSink());
-    sink1.writeUtf8("abc");
-    try {
-      sink2.writeUtf8("abc");
-      sink2.flush();
-      fail();
-    } catch (IOException expected) {
-      assertEquals("stream was reset: REFUSED_STREAM", expected.getMessage());
-    }
-    sink1.writeUtf8("def");
-    sink1.close();
-    try {
-      connection.newStream(headerEntries("c", "cola"), true, true);
-      fail();
-    } catch (IOException expected) {
-      assertEquals("shutdown", expected.getMessage());
-    }
-    assertTrue(stream1.isOpen());
-    assertFalse(stream2.isOpen());
-    assertEquals(1, connection.openStreamCount());
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame synStream1 = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream1.type);
-    MockSpdyPeer.InFrame synStream2 = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream2.type);
-    MockSpdyPeer.InFrame ping = peer.takeFrame();
-    assertEquals(TYPE_PING, ping.type);
-    MockSpdyPeer.InFrame data1 = peer.takeFrame();
-    assertEquals(TYPE_DATA, data1.type);
-    assertEquals(1, data1.streamId);
-    assertTrue(Arrays.equals("abcdef".getBytes("UTF-8"), data1.data));
-  }
-
-  @Test public void sendGoAway() throws Exception {
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM 1
-    peer.acceptFrame(); // GOAWAY
-    peer.acceptFrame(); // PING
-    peer.sendFrame().synStream(false, false, 2, 0, headerEntries("b", "b")); // Should be ignored!
-    peer.sendFrame().ping(true, 1, 0);
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    connection.newStream(headerEntries("a", "android"), true, true);
-    Ping ping = connection.ping();
-    connection.shutdown(PROTOCOL_ERROR);
-    assertEquals(1, connection.openStreamCount());
-    ping.roundTripTime(); // Prevent the peer from exiting prematurely.
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame synStream1 = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream1.type);
-    MockSpdyPeer.InFrame pingFrame = peer.takeFrame();
-    assertEquals(TYPE_PING, pingFrame.type);
-    MockSpdyPeer.InFrame goaway = peer.takeFrame();
-    assertEquals(TYPE_GOAWAY, goaway.type);
-    assertEquals(0, goaway.streamId);
-    assertEquals(PROTOCOL_ERROR, goaway.errorCode);
-  }
-
-  @Test public void noPingsAfterShutdown() throws Exception {
-    // write the mocking script
-    peer.acceptFrame(); // GOAWAY
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    connection.shutdown(INTERNAL_ERROR);
-    try {
-      connection.ping();
-      fail();
-    } catch (IOException expected) {
-      assertEquals("shutdown", expected.getMessage());
-    }
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame goaway = peer.takeFrame();
-    assertEquals(TYPE_GOAWAY, goaway.type);
-    assertEquals(INTERNAL_ERROR, goaway.errorCode);
-  }
-
-  @Test public void close() throws Exception {
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM
-    peer.acceptFrame(); // GOAWAY
-    peer.acceptFrame(); // RST_STREAM
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream stream = connection.newStream(headerEntries("a", "android"), true, true);
-    assertEquals(1, connection.openStreamCount());
-    connection.close();
-    assertEquals(0, connection.openStreamCount());
-    try {
-      connection.newStream(headerEntries("b", "banana"), true, true);
-      fail();
-    } catch (IOException expected) {
-      assertEquals("shutdown", expected.getMessage());
-    }
-    BufferedSink sink = Okio.buffer(stream.getSink());
-    try {
-      sink.writeByte(0);
-      sink.flush();
-      fail();
-    } catch (IOException expected) {
-      assertEquals("stream was reset: CANCEL", expected.getMessage());
-    }
-    try {
-      stream.getSource().read(new Buffer(), 1);
-      fail();
-    } catch (IOException expected) {
-      assertEquals("stream was reset: CANCEL", expected.getMessage());
-    }
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame synStream = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream.type);
-    assertEquals(HeadersMode.SPDY_SYN_STREAM, synStream.headersMode);
-    MockSpdyPeer.InFrame goaway = peer.takeFrame();
-    assertEquals(TYPE_GOAWAY, goaway.type);
-    MockSpdyPeer.InFrame rstStream = peer.takeFrame();
-    assertEquals(TYPE_RST_STREAM, rstStream.type);
-    assertEquals(1, rstStream.streamId);
-  }
-
-  @Test public void closeCancelsPings() throws Exception {
-    // write the mocking script
-    peer.acceptFrame(); // PING
-    peer.acceptFrame(); // GOAWAY
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    Ping ping = connection.ping();
-    connection.close();
-    assertEquals(-1, ping.roundTripTime());
-  }
-
-  @Test public void getResponseHeadersTimesOut() throws Exception {
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM
-    peer.acceptFrame(); // RST_STREAM
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
-    stream.readTimeout().timeout(500, TimeUnit.MILLISECONDS);
-    long startNanos = System.nanoTime();
-    try {
-      stream.getResponseHeaders();
-      fail();
-    } catch (InterruptedIOException expected) {
-    }
-    long elapsedNanos = System.nanoTime() - startNanos;
-    awaitWatchdogIdle();
-    assertEquals(500d, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 200d /* 200ms delta */);
-    assertEquals(0, connection.openStreamCount());
-
-    // verify the peer received what was expected
-    assertEquals(TYPE_HEADERS, peer.takeFrame().type);
-    assertEquals(TYPE_RST_STREAM, peer.takeFrame().type);
-  }
-
-  @Test public void readTimesOut() throws Exception {
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
-    peer.acceptFrame(); // RST_STREAM
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
-    stream.readTimeout().timeout(500, TimeUnit.MILLISECONDS);
-    Source source = stream.getSource();
-    long startNanos = System.nanoTime();
-    try {
-      source.read(new Buffer(), 1);
-      fail();
-    } catch (InterruptedIOException expected) {
-    }
-    long elapsedNanos = System.nanoTime() - startNanos;
-    awaitWatchdogIdle();
-    assertEquals(500d, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 200d /* 200ms delta */);
-    assertEquals(0, connection.openStreamCount());
-
-    // verify the peer received what was expected
-    assertEquals(TYPE_HEADERS, peer.takeFrame().type);
-    assertEquals(TYPE_RST_STREAM, peer.takeFrame().type);
-  }
-
-  @Test public void writeTimesOutAwaitingStreamWindow() throws Exception {
-    // Set the peer's receive window to 5 bytes!
-    Settings peerSettings = new Settings().set(INITIAL_WINDOW_SIZE, PERSIST_VALUE, 5);
-
-    // write the mocking script
-    peer.sendFrame().settings(peerSettings);
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 0);
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
-    peer.acceptFrame(); // DATA
-    peer.acceptFrame(); // RST_STREAM
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    connection.ping().roundTripTime(); // Make sure settings have been received.
-    FramedStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
-    Sink sink = stream.getSink();
-    sink.write(new Buffer().writeUtf8("abcde"), 5);
-    stream.writeTimeout().timeout(500, TimeUnit.MILLISECONDS);
-    long startNanos = System.nanoTime();
-    sink.write(new Buffer().writeUtf8("f"), 1);
-    try {
-      sink.flush(); // This will time out waiting on the write window.
-      fail();
-    } catch (InterruptedIOException expected) {
-    }
-    long elapsedNanos = System.nanoTime() - startNanos;
-    awaitWatchdogIdle();
-    assertEquals(500d, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 200d /* 200ms delta */);
-    assertEquals(0, connection.openStreamCount());
-
-    // verify the peer received what was expected
-    assertEquals(TYPE_PING, peer.takeFrame().type);
-    assertEquals(TYPE_HEADERS, peer.takeFrame().type);
-    assertEquals(TYPE_DATA, peer.takeFrame().type);
-    assertEquals(TYPE_RST_STREAM, peer.takeFrame().type);
-  }
-
-  @Test public void writeTimesOutAwaitingConnectionWindow() throws Exception {
-    // Set the peer's receive window to 5 bytes. Give the stream 5 bytes back, so only the
-    // connection-level window is applicable.
-    Settings peerSettings = new Settings().set(INITIAL_WINDOW_SIZE, PERSIST_VALUE, 5);
-
-    // write the mocking script
-    peer.sendFrame().settings(peerSettings);
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
-    peer.sendFrame().windowUpdate(1, 5);
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 0);
-    peer.acceptFrame(); // DATA
-    peer.acceptFrame(); // RST_STREAM
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
-    connection.ping().roundTripTime(); // Make sure the window update has been received.
-    Sink sink = stream.getSink();
-    stream.writeTimeout().timeout(500, TimeUnit.MILLISECONDS);
-    sink.write(new Buffer().writeUtf8("abcdef"), 6);
-    long startNanos = System.nanoTime();
-    try {
-      sink.flush(); // This will time out waiting on the write window.
-      fail();
-    } catch (InterruptedIOException expected) {
-    }
-    long elapsedNanos = System.nanoTime() - startNanos;
-    awaitWatchdogIdle();
-    assertEquals(500d, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 200d /* 200ms delta */);
-    assertEquals(0, connection.openStreamCount());
-
-    // verify the peer received what was expected
-    assertEquals(TYPE_HEADERS, peer.takeFrame().type);
-    assertEquals(TYPE_PING, peer.takeFrame().type);
-    assertEquals(TYPE_DATA, peer.takeFrame().type);
-    assertEquals(TYPE_RST_STREAM, peer.takeFrame().type);
-  }
-
-  @Test public void outgoingWritesAreBatched() throws Exception {
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
-    peer.acceptFrame(); // DATA
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
-
-    // two outgoing writes
-    Sink sink = stream.getSink();
-    sink.write(new Buffer().writeUtf8("abcde"), 5);
-    sink.write(new Buffer().writeUtf8("fghij"), 5);
-    sink.close();
-
-    // verify the peer received one incoming frame
-    assertEquals(TYPE_HEADERS, peer.takeFrame().type);
-    MockSpdyPeer.InFrame data = peer.takeFrame();
-    assertEquals(TYPE_DATA, data.type);
-    assertTrue(Arrays.equals("abcdefghij".getBytes("UTF-8"), data.data));
-    assertTrue(data.inFinished);
-  }
-
-  @Test public void headers() throws Exception {
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM
-    peer.acceptFrame(); // PING
-    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
-    peer.sendFrame().headers(1, headerEntries("c", "c3po"));
-    peer.sendFrame().ping(true, 1, 0);
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
-    connection.ping().roundTripTime(); // Ensure that the HEADERS has been received.
-    assertEquals(headerEntries("a", "android", "c", "c3po"), stream.getResponseHeaders());
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame synStream = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream.type);
-    assertEquals(HeadersMode.SPDY_SYN_STREAM, synStream.headersMode);
-    MockSpdyPeer.InFrame ping = peer.takeFrame();
-    assertEquals(TYPE_PING, ping.type);
-  }
-
-  @Test public void headersBeforeReply() throws Exception {
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM
-    peer.acceptFrame(); // PING
-    peer.sendFrame().headers(1, headerEntries("c", "c3po"));
-    peer.acceptFrame(); // RST_STREAM
-    peer.sendFrame().ping(true, 1, 0);
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
-    connection.ping().roundTripTime(); // Ensure that the HEADERS has been received.
-    try {
-      stream.getResponseHeaders();
-      fail();
-    } catch (IOException expected) {
-      assertEquals("stream was reset: PROTOCOL_ERROR", expected.getMessage());
-    }
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame synStream = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream.type);
-    assertEquals(HeadersMode.SPDY_SYN_STREAM, synStream.headersMode);
-    MockSpdyPeer.InFrame ping = peer.takeFrame();
-    assertEquals(TYPE_PING, ping.type);
-    MockSpdyPeer.InFrame rstStream = peer.takeFrame();
-    assertEquals(TYPE_RST_STREAM, rstStream.type);
-    assertEquals(PROTOCOL_ERROR, rstStream.errorCode);
-  }
-
-  @Test public void readSendsWindowUpdate() throws Exception {
-    peer.setVariantAndClient(SPDY3, false);
-
-    int windowSize = 100;
-    int windowUpdateThreshold = 50;
-
-    // Write the mocking script.
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
-    for (int i = 0; i < 3; i++) {
-      // Send frames of summing to size 50, which is windowUpdateThreshold.
-      peer.sendFrame().data(false, 1, data(24), 24);
-      peer.sendFrame().data(false, 1, data(25), 25);
-      peer.sendFrame().data(false, 1, data(1), 1);
-      peer.acceptFrame(); // connection WINDOW UPDATE
-      peer.acceptFrame(); // stream WINDOW UPDATE
-    }
-    peer.sendFrame().data(true, 1, data(0), 0);
-    peer.play();
-
-    // Play it back.
-    FramedConnection connection = connection(peer, SPDY3);
-    connection.okHttpSettings.set(INITIAL_WINDOW_SIZE, 0, windowSize);
-    FramedStream stream = connection.newStream(headerEntries("b", "banana"), false, true);
-    assertEquals(0, stream.unacknowledgedBytesRead);
-    assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
-    Source in = stream.getSource();
-    Buffer buffer = new Buffer();
-    buffer.writeAll(in);
-    assertEquals(-1, in.read(buffer, 1));
-    assertEquals(150, buffer.size());
-
-    MockSpdyPeer.InFrame synStream = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream.type);
-    for (int i = 0; i < 3; i++) {
-      List<Integer> windowUpdateStreamIds = new ArrayList<>(2);
-      for (int j = 0; j < 2; j++) {
-        MockSpdyPeer.InFrame windowUpdate = peer.takeFrame();
-        assertEquals(TYPE_WINDOW_UPDATE, windowUpdate.type);
-        windowUpdateStreamIds.add(windowUpdate.streamId);
-        assertEquals(windowUpdateThreshold, windowUpdate.windowSizeIncrement);
-      }
-      assertTrue(windowUpdateStreamIds.contains(0)); // connection
-      assertTrue(windowUpdateStreamIds.contains(1)); // stream
-    }
-  }
-
-  private Buffer data(int byteCount) {
-    return new Buffer().write(new byte[byteCount]);
-  }
-
-  @Test public void serverSendsEmptyDataClientDoesntSendWindowUpdate() throws Exception {
-    peer.setVariantAndClient(SPDY3, false);
-
-    // Write the mocking script.
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
-    peer.sendFrame().data(true, 1, data(0), 0);
-    peer.play();
-
-    // Play it back.
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream client = connection.newStream(headerEntries("b", "banana"), false, true);
-    assertEquals(-1, client.getSource().read(new Buffer(), 1));
-
-    // Verify the peer received what was expected.
-    MockSpdyPeer.InFrame synStream = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream.type);
-    assertEquals(3, peer.frameCount());
-  }
-
-  @Test public void clientSendsEmptyDataServerDoesntSendWindowUpdate() throws Exception {
-    peer.setVariantAndClient(SPDY3, false);
-
-    // Write the mocking script.
-    peer.acceptFrame(); // SYN_STREAM
-    peer.acceptFrame(); // DATA
-    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
-    peer.play();
-
-    // Play it back.
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream client = connection.newStream(headerEntries("b", "banana"), true, true);
-    BufferedSink out = Okio.buffer(client.getSink());
-    out.write(Util.EMPTY_BYTE_ARRAY);
-    out.flush();
-    out.close();
-
-    // Verify the peer received what was expected.
-    assertEquals(TYPE_HEADERS, peer.takeFrame().type);
-    assertEquals(TYPE_DATA, peer.takeFrame().type);
-    assertEquals(3, peer.frameCount());
-  }
-
-  @Test public void testTruncatedDataFrame() throws Exception {
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
-    peer.sendFrame().data(false, 1, data(1024), 1024);
-    peer.truncateLastFrame(8 + 100);
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
-    assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
-    Source in = stream.getSource();
-    try {
-      Okio.buffer(in).readByteString(101);
-      fail();
-    } catch (IOException expected) {
-      assertEquals("stream was reset: PROTOCOL_ERROR", expected.getMessage());
-    }
-  }
-
-  @Test public void blockedStreamDoesntStarveNewStream() throws Exception {
-    int framesThatFillWindow = roundUp(DEFAULT_INITIAL_WINDOW_SIZE, peer.maxOutboundDataLength());
-
-    // Write the mocking script. This accepts more data frames than necessary!
-    peer.acceptFrame(); // SYN_STREAM on stream 1
-    for (int i = 0; i < framesThatFillWindow; i++) {
-      peer.acceptFrame(); // DATA on stream 1
-    }
-    peer.acceptFrame(); // SYN_STREAM on stream 2
-    peer.acceptFrame(); // DATA on stream 2
-    peer.play();
-
-    // Play it back.
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream stream1 = connection.newStream(headerEntries("a", "apple"), true, true);
-    BufferedSink out1 = Okio.buffer(stream1.getSink());
-    out1.write(new byte[DEFAULT_INITIAL_WINDOW_SIZE]);
-    out1.flush();
-
-    // Check that we've filled the window for both the stream and also the connection.
-    assertEquals(0, connection.bytesLeftInWriteWindow);
-    assertEquals(0, connection.getStream(1).bytesLeftInWriteWindow);
-
-    // receiving a window update on the the connection will unblock new streams.
-    connection.readerRunnable.windowUpdate(0, 3);
-
-    assertEquals(3, connection.bytesLeftInWriteWindow);
-    assertEquals(0, connection.getStream(1).bytesLeftInWriteWindow);
-
-    // Another stream should be able to send data even though 1 is blocked.
-    FramedStream stream2 = connection.newStream(headerEntries("b", "banana"), true, true);
-    BufferedSink out2 = Okio.buffer(stream2.getSink());
-    out2.writeUtf8("foo");
-    out2.flush();
-
-    assertEquals(0, connection.bytesLeftInWriteWindow);
-    assertEquals(0, connection.getStream(1).bytesLeftInWriteWindow);
-    assertEquals(DEFAULT_INITIAL_WINDOW_SIZE - 3, connection.getStream(3).bytesLeftInWriteWindow);
-  }
-
-  /** https://github.com/square/okhttp/issues/333 */
-  @Test public void headerBlockHasTrailingCompressedBytes512() throws Exception {
-    // This specially-formatted frame has trailing deflated bytes after the name value block.
-    String frame = "gAMAAgAAAgkAAAABeLvjxqfCYgAAAAD//2IAAAAA//9iAAAAAP//YgQAAAD//2IAAAAA//9iAAAAAP/"
-        + "/YgAAAAD//2IEAAAA//9KBAAAAP//YgAAAAD//2IAAAAA//9iAAAAAP//sgEAAAD//2IAAAAA\n//9iBAAAAP//Y"
-        + "gIAAAD//2IGAAAA//9iAQAAAP//YgUAAAD//2IDAAAA//9iBwAAAP//4gAAAAD//+IEAAAA///iAgAAAP//4gYAA"
-        + "AD//+IBAAAA///iBQAAAP//4gMAAAD//+IHAAAA//8SAAAAAP//EgQAAAD//xICAAAA//8SBgAAAP//EgEAAAD//"
-        + "xIFAAAA//8SAwAAAP//EgcAAAD//5IAAAAA//+SBAAAAP//kgIAAAD//5IGAAAA//+SAQAAAP//kgUAAAD//5IDA"
-        + "AAA//+SBwAAAP//UgAAAAD//1IEAAAA//9SAgAAAP//UgYAAAD//1IBAAAA//9SBQAAAP//UgMAAAD//1IHAAAA/"
-        + "//SAAAAAP//0gQAAAD//9ICAAAA///SBgAAAP//0gEAAAD//9IFAAAA///SAwAAAP//0gcAAAD//zIAAAAA//8yB"
-        + "AAAAP//MgIAAAD//zIGAAAA//8yAQAAAP//MgUAAAD//zIDAAAA//8yBwAAAP//sgAAAAD//7IEAAAA//+yAgAAA"
-        + "P//sgYAAAD//w==";
-    headerBlockHasTrailingCompressedBytes(frame, 60);
-  }
-
-  @Test public void headerBlockHasTrailingCompressedBytes2048() throws Exception {
-    // This specially-formatted frame has trailing deflated bytes after the name value block.
-    String frame = "gAMAAgAAB/sAAAABeLvjxqfCAqYjRhAGJmxGxUQAAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAA"
-        + "AAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP/"
-        + "/SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQ"
-        + "AAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD"
-        + "//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0o"
-        + "EAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAA"
-        + "A//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9"
-        + "KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAA"
-        + "AAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP/"
-        + "/SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQ"
-        + "AAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD"
-        + "//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0o"
-        + "EAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAA"
-        + "A//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9"
-        + "KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAA"
-        + "AAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP/"
-        + "/SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQ"
-        + "AAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD"
-        + "//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0o"
-        + "EAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAA"
-        + "A//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9"
-        + "KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAA"
-        + "AAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP/"
-        + "/SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQ"
-        + "AAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD"
-        + "//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0o"
-        + "EAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAA"
-        + "A//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9"
-        + "KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAA"
-        + "AAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP/"
-        + "/SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQ"
-        + "AAAD//0oEAAAA//8=";
-    headerBlockHasTrailingCompressedBytes(frame, 289);
-  }
-
-  private void headerBlockHasTrailingCompressedBytes(String frame, int length) throws IOException {
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM
-    byte[] trailingCompressedBytes = ByteString.decodeBase64(frame).toByteArray();
-    trailingCompressedBytes[11] = 1; // Set SPDY/3 stream ID to 3.
-    peer.sendFrame(trailingCompressedBytes);
-    peer.sendFrame().data(true, 1, new Buffer().writeUtf8("robot"), 5);
-    peer.acceptFrame(); // DATA
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
-    assertEquals("a", stream.getResponseHeaders().get(0).name.utf8());
-    assertEquals(length, stream.getResponseHeaders().get(0).value.size());
-    assertStreamData("robot", stream.getSource());
-  }
-
-  @Test public void socketExceptionWhileWritingHeaders() throws Exception {
-    peer.acceptFrame(); // SYN_STREAM.
-    peer.play();
-
-    String longString = ByteString.of(randomBytes(2048)).base64();
-    Socket socket = peer.openSocket();
-    FramedConnection connection = new FramedConnection.Builder(true)
-        .socket(socket)
-        .protocol(SPDY3.getProtocol())
-        .build();
-    connection.start(false);
-    socket.shutdownOutput();
-    try {
-      connection.newStream(headerEntries("a", longString), false, true);
-      fail();
-    } catch (IOException expected) {
-    }
-    try {
-      connection.newStream(headerEntries("b", longString), false, true);
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  private byte[] randomBytes(int length) {
-    byte[] bytes = new byte[length];
-    new Random(0).nextBytes(bytes);
-    return bytes;
-  }
-
-  private FramedConnection connection(MockSpdyPeer peer, Variant variant) throws IOException {
-    FramedConnection connection = connectionBuilder(peer, variant).build();
-    connection.start(false);
-    return connection;
-  }
-
-  private FramedConnection.Builder connectionBuilder(MockSpdyPeer peer, Variant variant)
-      throws IOException {
-    return new FramedConnection.Builder(true)
-        .socket(peer.openSocket())
-        .protocol(variant.getProtocol());
-  }
-
-  private void assertStreamData(String expected, Source source) throws IOException {
-    String actual = Okio.buffer(source).readUtf8();
-    assertEquals(expected, actual);
-  }
-
-  /** Interrupts the current thread after {@code delayMillis}. */
-  private void interruptAfterDelay(final long delayMillis) {
-    final Thread toInterrupt = Thread.currentThread();
-    new Thread("interrupting cow") {
-      @Override public void run() {
-        try {
-          Thread.sleep(delayMillis);
-          toInterrupt.interrupt();
-        } catch (InterruptedException e) {
-          throw new AssertionError();
-        }
-      }
-    }.start();
-  }
-
-  /**
-   * Returns true when all work currently in progress by the watchdog have completed. This method
-   * creates more work for the watchdog and waits for that work to be executed. When it is, we know
-   * work that preceded this call is complete.
-   */
-  private void awaitWatchdogIdle() throws InterruptedException {
-    final CountDownLatch latch = new CountDownLatch(1);
-    AsyncTimeout watchdogJob = new AsyncTimeout() {
-      @Override protected void timedOut() {
-        latch.countDown();
-      }
-    };
-    watchdogJob.deadlineNanoTime(System.nanoTime()); // Due immediately!
-    watchdogJob.enter();
-    latch.await();
-  }
-
-  static int roundUp(int num, int divisor) {
-    return (num + divisor - 1) / divisor;
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/framed/Spdy3Test.java b/okhttp-tests/src/test/java/okhttp3/internal/framed/Spdy3Test.java
deleted file mode 100644
index 953009ffc1..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/framed/Spdy3Test.java
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.framed;
-
-import java.io.IOException;
-import okhttp3.internal.Util;
-import okio.Buffer;
-import okio.ByteString;
-import org.junit.Test;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
-
-public class Spdy3Test {
-  static final int expectedStreamId = 15;
-
-  @Test public void tooLargeDataFrame() throws IOException {
-    try {
-      sendDataFrame(new Buffer().write(new byte[0x1000000]));
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertEquals("FRAME_TOO_LARGE max size is 16Mib: " + 0x1000000L, e.getMessage());
-    }
-  }
-
-  @Test public void badWindowSizeIncrement() throws IOException {
-    try {
-      windowUpdate(0);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertEquals("windowSizeIncrement must be between 1 and 0x7fffffff: 0", e.getMessage());
-    }
-    try {
-      windowUpdate(0x80000000L);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertEquals("windowSizeIncrement must be between 1 and 0x7fffffff: 2147483648",
-          e.getMessage());
-    }
-  }
-
-  @Test public void goAwayRoundTrip() throws IOException {
-    Buffer frame = new Buffer();
-
-    final ErrorCode expectedError = ErrorCode.PROTOCOL_ERROR;
-
-    // Compose the expected GOAWAY frame without debug data
-    // |C| Version(15bits) | Type(16bits) |
-    frame.writeInt(0x80000000 | (Spdy3.VERSION & 0x7fff) << 16 | Spdy3.TYPE_GOAWAY & 0xffff);
-    // | Flags (8)  |  Length (24 bits)   |
-    frame.writeInt(8); // no flags and length is 8.
-    frame.writeInt(expectedStreamId); // last good stream.
-    frame.writeInt(expectedError.spdyGoAwayCode);
-
-    // Check writer sends the same bytes.
-    assertEquals(frame, sendGoAway(expectedStreamId, expectedError, Util.EMPTY_BYTE_ARRAY));
-
-    // SPDY/3 does not send debug data, so bytes should be same!
-    assertEquals(frame, sendGoAway(expectedStreamId, expectedError, new byte[8]));
-
-    FrameReader fr = new Spdy3.Reader(frame, false);
-
-    fr.nextFrame(new BaseTestHandler() { // Consume the goAway frame.
-      @Override public void goAway(
-          int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {
-        assertEquals(expectedStreamId, lastGoodStreamId);
-        assertEquals(expectedError, errorCode);
-        assertEquals(0, debugData.size());
-      }
-    });
-  }
-
-  private void sendDataFrame(Buffer source) throws IOException {
-    Spdy3.Writer writer = new Spdy3.Writer(new Buffer(), true);
-    writer.sendDataFrame(expectedStreamId, 0, source, (int) source.size());
-  }
-
-  private void windowUpdate(long increment) throws IOException {
-    new Spdy3.Writer(new Buffer(), true).windowUpdate(expectedStreamId, increment);
-  }
-
-  private Buffer sendGoAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData)
-      throws IOException {
-    Buffer out = new Buffer();
-    new Spdy3.Writer(out, true).goAway(lastGoodStreamId, errorCode, debugData);
-    return out;
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/DisconnectTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http/DisconnectTest.java
index eb85913192..aad2bfc8dd 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http/DisconnectTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http/DisconnectTest.java
@@ -34,6 +34,7 @@
 import org.junit.Before;
 import org.junit.Test;
 
+import static okhttp3.TestUtil.defaultClient;
 import static org.junit.Assert.fail;
 
 public final class DisconnectTest {
@@ -56,7 +57,7 @@
             return serverSocket;
           }
         });
-    client = new OkHttpClient.Builder()
+    client = defaultClient().newBuilder()
         .socketFactory(new DelegatingSocketFactory(SocketFactory.getDefault()) {
           @Override protected Socket configureSocket(Socket socket) throws IOException {
             socket.setSendBufferSize(SOCKET_BUFFER_SIZE);
@@ -113,7 +114,7 @@
     } catch (IOException expected) {
     }
 
-    connection.disconnect();
+    responseBody.close();
   }
 
   private void disconnectLater(final HttpURLConnection connection, final int delayMillis) {
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/ExternalSpdyExample.java b/okhttp-tests/src/test/java/okhttp3/internal/http/ExternalSpdyExample.java
deleted file mode 100644
index c1598480ec..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/http/ExternalSpdyExample.java
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- * Copyright (C) 2009 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package okhttp3.internal.http;
-
-import okhttp3.Call;
-import okhttp3.OkHttpClient;
-import okhttp3.Protocol;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.internal.Util;
-
-public final class ExternalSpdyExample {
-  public static void main(String[] args) throws Exception {
-    OkHttpClient client = new OkHttpClient.Builder()
-        .protocols(Util.immutableList(Protocol.SPDY_3, Protocol.HTTP_1_1))
-        .build();
-
-    Call call = client.newCall(new Request.Builder()
-        .url("https://www.google.ca/")
-        .build());
-
-    Response response = call.execute();
-    try {
-      System.out.println(response.code());
-      System.out.println("PROTOCOL " + response.protocol());
-
-      String line;
-      while ((line = response.body().source().readUtf8Line()) != null) {
-        System.out.println(line);
-      }
-    } finally {
-      response.body().close();
-    }
-
-    client.connectionPool().evictAll();
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/RecordingProxySelector.java b/okhttp-tests/src/test/java/okhttp3/internal/http/RecordingProxySelector.java
index 33a51500e0..fb37e7e491 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http/RecordingProxySelector.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http/RecordingProxySelector.java
@@ -45,8 +45,11 @@ public void assertRequests(URI... expectedUris) {
 
   @Override public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {
     InetSocketAddress socketAddress = (InetSocketAddress) sa;
-    failures.add(
-        Util.format("%s %s:%d %s", uri, socketAddress.getHostName(), socketAddress.getPort(),
-            ioe.getMessage()));
+    failures.add(Util.format("%s %s:%d %s",
+        uri, socketAddress, socketAddress.getPort(), ioe.getMessage()));
+  }
+
+  @Override public String toString() {
+    return "RecordingProxySelector";
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/ThreadInterruptTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http/ThreadInterruptTest.java
index 47f4f0fc6b..9ac3b93ecc 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http/ThreadInterruptTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http/ThreadInterruptTest.java
@@ -35,6 +35,7 @@
 import org.junit.Before;
 import org.junit.Test;
 
+import static okhttp3.TestUtil.defaultClient;
 import static org.junit.Assert.fail;
 
 public final class ThreadInterruptTest {
@@ -58,7 +59,7 @@ protected ServerSocket configureServerSocket(ServerSocket serverSocket)
             return serverSocket;
           }
         });
-    client = new OkHttpClient.Builder()
+    client = defaultClient().newBuilder()
         .socketFactory(new DelegatingSocketFactory(SocketFactory.getDefault()) {
           @Override
           protected Socket configureSocket(Socket socket) throws IOException {
@@ -116,7 +117,7 @@ protected Socket configureSocket(Socket socket) throws IOException {
     } catch (InterruptedIOException expected) {
     }
 
-    connection.disconnect();
+    responseBody.close();
   }
 
   private void interruptLater(final int delayMillis) {
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/framed/BaseTestHandler.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/BaseTestHandler.java
similarity index 87%
rename from okhttp-tests/src/test/java/okhttp3/internal/framed/BaseTestHandler.java
rename to okhttp-tests/src/test/java/okhttp3/internal/http2/BaseTestHandler.java
index d619feff7c..b0b552b937 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/framed/BaseTestHandler.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/BaseTestHandler.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.framed;
+package okhttp3.internal.http2;
 
 import java.io.IOException;
 import java.util.List;
@@ -22,15 +22,14 @@
 
 import static org.junit.Assert.fail;
 
-class BaseTestHandler implements FrameReader.Handler {
+class BaseTestHandler implements Http2Reader.Handler {
   @Override public void data(boolean inFinished, int streamId, BufferedSource source, int length)
       throws IOException {
     fail();
   }
 
-  @Override
-  public void headers(boolean outFinished, boolean inFinished, int streamId, int associatedStreamId,
-      List<Header> headerBlock, HeadersMode headersMode) {
+  @Override public void headers(boolean inFinished, int streamId, int associatedStreamId,
+      List<Header> headerBlock) {
     fail();
   }
 
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/framed/Http2FrameLoggerTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/FrameLogTest.java
similarity index 65%
rename from okhttp-tests/src/test/java/okhttp3/internal/framed/Http2FrameLoggerTest.java
rename to okhttp-tests/src/test/java/okhttp3/internal/http2/FrameLogTest.java
index 864a368774..94e5e83581 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/framed/Http2FrameLoggerTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/FrameLogTest.java
@@ -13,77 +13,75 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.framed;
+package okhttp3.internal.http2;
 
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
 import org.junit.Test;
 
-import static okhttp3.internal.framed.Http2.FLAG_ACK;
-import static okhttp3.internal.framed.Http2.FLAG_END_HEADERS;
-import static okhttp3.internal.framed.Http2.FLAG_END_STREAM;
-import static okhttp3.internal.framed.Http2.FLAG_NONE;
-import static okhttp3.internal.framed.Http2.FrameLogger.formatFlags;
-import static okhttp3.internal.framed.Http2.FrameLogger.formatHeader;
-import static okhttp3.internal.framed.Http2.TYPE_CONTINUATION;
-import static okhttp3.internal.framed.Http2.TYPE_DATA;
-import static okhttp3.internal.framed.Http2.TYPE_GOAWAY;
-import static okhttp3.internal.framed.Http2.TYPE_HEADERS;
-import static okhttp3.internal.framed.Http2.TYPE_PING;
-import static okhttp3.internal.framed.Http2.TYPE_PUSH_PROMISE;
-import static okhttp3.internal.framed.Http2.TYPE_SETTINGS;
+import static okhttp3.internal.http2.Http2.FLAG_ACK;
+import static okhttp3.internal.http2.Http2.FLAG_END_HEADERS;
+import static okhttp3.internal.http2.Http2.FLAG_END_STREAM;
+import static okhttp3.internal.http2.Http2.FLAG_NONE;
+import static okhttp3.internal.http2.Http2.TYPE_CONTINUATION;
+import static okhttp3.internal.http2.Http2.TYPE_DATA;
+import static okhttp3.internal.http2.Http2.TYPE_GOAWAY;
+import static okhttp3.internal.http2.Http2.TYPE_HEADERS;
+import static okhttp3.internal.http2.Http2.TYPE_PING;
+import static okhttp3.internal.http2.Http2.TYPE_PUSH_PROMISE;
+import static okhttp3.internal.http2.Http2.TYPE_SETTINGS;
+import static okhttp3.internal.http2.Http2.frameLog;
 import static org.junit.Assert.assertEquals;
 
-public class Http2FrameLoggerTest {
-
+public final class FrameLogTest {
   /** Real stream traffic applied to the log format. */
   @Test public void exampleStream() {
     assertEquals(">> 0x00000000     5 SETTINGS      ",
-        formatHeader(false, 0, 5, TYPE_SETTINGS, FLAG_NONE));
+        frameLog(false, 0, 5, TYPE_SETTINGS, FLAG_NONE));
     assertEquals(">> 0x00000003   100 HEADERS       END_HEADERS",
-        formatHeader(false, 3, 100, TYPE_HEADERS, FLAG_END_HEADERS));
+        frameLog(false, 3, 100, TYPE_HEADERS, FLAG_END_HEADERS));
     assertEquals(">> 0x00000003     0 DATA          END_STREAM",
-        formatHeader(false, 3, 0, TYPE_DATA, FLAG_END_STREAM));
+        frameLog(false, 3, 0, TYPE_DATA, FLAG_END_STREAM));
     assertEquals("<< 0x00000000    15 SETTINGS      ",
-        formatHeader(true, 0, 15, TYPE_SETTINGS, FLAG_NONE));
+        frameLog(true, 0, 15, TYPE_SETTINGS, FLAG_NONE));
     assertEquals(">> 0x00000000     0 SETTINGS      ACK",
-        formatHeader(false, 0, 0, TYPE_SETTINGS, FLAG_ACK));
+        frameLog(false, 0, 0, TYPE_SETTINGS, FLAG_ACK));
     assertEquals("<< 0x00000000     0 SETTINGS      ACK",
-        formatHeader(true, 0, 0, TYPE_SETTINGS, FLAG_ACK));
+        frameLog(true, 0, 0, TYPE_SETTINGS, FLAG_ACK));
     assertEquals("<< 0x00000003    22 HEADERS       END_HEADERS",
-        formatHeader(true, 3, 22, TYPE_HEADERS, FLAG_END_HEADERS));
+        frameLog(true, 3, 22, TYPE_HEADERS, FLAG_END_HEADERS));
     assertEquals("<< 0x00000003   226 DATA          END_STREAM",
-        formatHeader(true, 3, 226, TYPE_DATA, FLAG_END_STREAM));
+        frameLog(true, 3, 226, TYPE_DATA, FLAG_END_STREAM));
     assertEquals(">> 0x00000000     8 GOAWAY        ",
-        formatHeader(false, 0, 8, TYPE_GOAWAY, FLAG_NONE));
+        frameLog(false, 0, 8, TYPE_GOAWAY, FLAG_NONE));
   }
 
   @Test public void flagOverlapOn0x1() {
     assertEquals("<< 0x00000000     0 SETTINGS      ACK",
-        formatHeader(true, 0, 0, TYPE_SETTINGS, (byte) 0x1));
+        frameLog(true, 0, 0, TYPE_SETTINGS, (byte) 0x1));
     assertEquals("<< 0x00000000     8 PING          ACK",
-        formatHeader(true, 0, 8, TYPE_PING, (byte) 0x1));
+        frameLog(true, 0, 8, TYPE_PING, (byte) 0x1));
     assertEquals("<< 0x00000003     0 HEADERS       END_STREAM",
-        formatHeader(true, 3, 0, TYPE_HEADERS, (byte) 0x1));
+        frameLog(true, 3, 0, TYPE_HEADERS, (byte) 0x1));
     assertEquals("<< 0x00000003     0 DATA          END_STREAM",
-        formatHeader(true, 3, 0, TYPE_DATA, (byte) 0x1));
+        frameLog(true, 3, 0, TYPE_DATA, (byte) 0x1));
   }
 
   @Test public void flagOverlapOn0x4() {
     assertEquals("<< 0x00000003 10000 HEADERS       END_HEADERS",
-        formatHeader(true, 3, 10000, TYPE_HEADERS, (byte) 0x4));
+        frameLog(true, 3, 10000, TYPE_HEADERS, (byte) 0x4));
     assertEquals("<< 0x00000003 10000 CONTINUATION  END_HEADERS",
-        formatHeader(true, 3, 10000, TYPE_CONTINUATION, (byte) 0x4));
+        frameLog(true, 3, 10000, TYPE_CONTINUATION, (byte) 0x4));
     assertEquals("<< 0x00000004 10000 PUSH_PROMISE  END_PUSH_PROMISE",
-        formatHeader(true, 4, 10000, TYPE_PUSH_PROMISE, (byte) 0x4));
+        frameLog(true, 4, 10000, TYPE_PUSH_PROMISE, (byte) 0x4));
   }
 
   @Test public void flagOverlapOn0x20() {
     assertEquals("<< 0x00000003 10000 HEADERS       PRIORITY",
-        formatHeader(true, 3, 10000, TYPE_HEADERS, (byte) 0x20));
+        frameLog(true, 3, 10000, TYPE_HEADERS, (byte) 0x20));
     assertEquals("<< 0x00000003 10000 DATA          COMPRESSED",
-        formatHeader(true, 3, 10000, TYPE_DATA, (byte) 0x20));
+        frameLog(true, 3, 10000, TYPE_DATA, (byte) 0x20));
   }
 
   /**
@@ -92,7 +90,7 @@
    */
   @Test public void allFormattedFlagsWithValidBits() {
     List<String> formattedFlags = new ArrayList<>(0x40); // Highest valid flag is 0x20.
-    for (byte i = 0; i < 0x40; i++) formattedFlags.add(formatFlags(TYPE_HEADERS, i));
+    for (byte i = 0; i < 0x40; i++) formattedFlags.add(Http2.formatFlags(TYPE_HEADERS, i));
 
     assertEquals(Arrays.asList(
         "",
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/framed/HpackTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/HpackTest.java
similarity index 63%
rename from okhttp-tests/src/test/java/okhttp3/internal/framed/HpackTest.java
rename to okhttp-tests/src/test/java/okhttp3/internal/http2/HpackTest.java
index 068ab647e7..6a90ac0458 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/framed/HpackTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/HpackTest.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.framed;
+package okhttp3.internal.http2;
 
 import java.io.IOException;
 import java.util.Arrays;
@@ -28,8 +28,7 @@
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 
-public class HpackTest {
-
+public final class HpackTest {
   private final Buffer bytesIn = new Buffer();
   private Hpack.Reader hpackReader;
   private Buffer bytesOut = new Buffer();
@@ -37,7 +36,7 @@
 
   @Before public void reset() {
     hpackReader = newReader(bytesIn);
-    hpackWriter = new Hpack.Writer(bytesOut);
+    hpackWriter = new Hpack.Writer(4096, false, bytesOut);
   }
 
   /**
@@ -65,6 +64,7 @@
    * larger header content is not lost.
    */
   @Test public void tooLargeToHPackIsStillEmitted() throws IOException {
+    bytesIn.writeByte(0x21); // Dynamic table size update (size = 1).
     bytesIn.writeByte(0x00); // Literal indexed
     bytesIn.writeByte(0x0a); // Literal name (len = 10)
     bytesIn.writeUtf8("custom-key");
@@ -72,7 +72,6 @@
     bytesIn.writeByte(0x0d); // Literal value (len = 13)
     bytesIn.writeUtf8("custom-header");
 
-    hpackReader.headerTableSizeSetting(1);
     hpackReader.readHeaders();
 
     assertEquals(0, hpackReader.headerCount);
@@ -81,7 +80,13 @@
   }
 
   /** Oldest entries are evicted to support newer ones. */
-  @Test public void testEviction() throws IOException {
+  @Test public void writerEviction() throws IOException {
+    List<Header> headerBlock =
+        headerEntries(
+            "custom-foo", "custom-header",
+            "custom-bar", "custom-header",
+            "custom-baz", "custom-header");
+
     bytesIn.writeByte(0x40); // Literal indexed
     bytesIn.writeByte(0x0a); // Literal name (len = 10)
     bytesIn.writeUtf8("custom-foo");
@@ -104,33 +109,83 @@
     bytesIn.writeUtf8("custom-header");
 
     // Set to only support 110 bytes (enough for 2 headers).
-    hpackReader.headerTableSizeSetting(110);
-    hpackReader.readHeaders();
+    // Use a new Writer because we don't support change the dynamic table
+    // size after Writer constructed.
+    Hpack.Writer writer = new Hpack.Writer(110, false, bytesOut);
+    writer.writeHeaders(headerBlock);
 
-    assertEquals(2, hpackReader.headerCount);
+    assertEquals(bytesIn, bytesOut);
+    assertEquals(2, writer.headerCount);
 
-    Header entry = hpackReader.dynamicTable[headerTableLength() - 1];
+    int tableLength = writer.dynamicTable.length;
+    Header entry = writer.dynamicTable[tableLength - 1];
     checkEntry(entry, "custom-bar", "custom-header", 55);
 
-    entry = hpackReader.dynamicTable[headerTableLength() - 2];
+    entry = writer.dynamicTable[tableLength - 2];
     checkEntry(entry, "custom-baz", "custom-header", 55);
+  }
 
-    // Once a header field is decoded and added to the reconstructed header
-    // list, it cannot be removed from it. Hence, foo is here.
-    assertEquals(
+  @Test public void readerEviction() throws IOException {
+    List<Header> headerBlock =
         headerEntries(
             "custom-foo", "custom-header",
             "custom-bar", "custom-header",
-            "custom-baz", "custom-header"),
-        hpackReader.getAndResetHeaderList());
+            "custom-baz", "custom-header");
+
+    // Set to only support 110 bytes (enough for 2 headers).
+    bytesIn.writeByte(0x3F); // Dynamic table size update (size = 110).
+    bytesIn.writeByte(0x4F);
+
+    bytesIn.writeByte(0x40); // Literal indexed
+    bytesIn.writeByte(0x0a); // Literal name (len = 10)
+    bytesIn.writeUtf8("custom-foo");
+
+    bytesIn.writeByte(0x0d); // Literal value (len = 13)
+    bytesIn.writeUtf8("custom-header");
+
+    bytesIn.writeByte(0x40); // Literal indexed
+    bytesIn.writeByte(0x0a); // Literal name (len = 10)
+    bytesIn.writeUtf8("custom-bar");
+
+    bytesIn.writeByte(0x0d); // Literal value (len = 13)
+    bytesIn.writeUtf8("custom-header");
+
+    bytesIn.writeByte(0x40); // Literal indexed
+    bytesIn.writeByte(0x0a); // Literal name (len = 10)
+    bytesIn.writeUtf8("custom-baz");
+
+    bytesIn.writeByte(0x0d); // Literal value (len = 13)
+    bytesIn.writeUtf8("custom-header");
+
+    hpackReader.readHeaders();
+
+    assertEquals(2, hpackReader.headerCount);
+
+    Header entry1 = hpackReader.dynamicTable[readerHeaderTableLength() - 1];
+    checkEntry(entry1, "custom-bar", "custom-header", 55);
+
+    Header entry2 = hpackReader.dynamicTable[readerHeaderTableLength() - 2];
+    checkEntry(entry2, "custom-baz", "custom-header", 55);
+
+    // Once a header field is decoded and added to the reconstructed header
+    // list, it cannot be removed from it. Hence, foo is here.
+    assertEquals(headerBlock, hpackReader.getAndResetHeaderList());
 
-    // Simulate receiving a small settings frame, that implies eviction.
-    hpackReader.headerTableSizeSetting(55);
+    // Simulate receiving a small dynamic table size update, that implies eviction.
+    bytesIn.writeByte(0x3F); // Dynamic table size update (size = 55).
+    bytesIn.writeByte(0x18);
+    hpackReader.readHeaders();
     assertEquals(1, hpackReader.headerCount);
   }
 
   /** Header table backing array is initially 8 long, let's ensure it grows. */
   @Test public void dynamicallyGrowsBeyond64Entries() throws IOException {
+    // Lots of headers need more room!
+    hpackReader = new Hpack.Reader(16384, 4096, bytesIn);
+    bytesIn.writeByte(0x3F); // Dynamic table size update (size = 16384).
+    bytesIn.writeByte(0xE1);
+    bytesIn.writeByte(0x7F);
+
     for (int i = 0; i < 256; i++) {
       bytesIn.writeByte(0x40); // Literal indexed
       bytesIn.writeByte(0x0a); // Literal name (len = 10)
@@ -140,7 +195,6 @@
       bytesIn.writeUtf8("custom-header");
     }
 
-    hpackReader.headerTableSizeSetting(16384); // Lots of headers need more room!
     hpackReader.readHeaders();
 
     assertEquals(256, hpackReader.headerCount);
@@ -158,7 +212,7 @@
     assertEquals(1, hpackReader.headerCount);
     assertEquals(52, hpackReader.dynamicTableByteCount);
 
-    Header entry = hpackReader.dynamicTable[headerTableLength() - 1];
+    Header entry = hpackReader.dynamicTable[readerHeaderTableLength() - 1];
     checkEntry(entry, ":path", "www.example.com", 52);
   }
 
@@ -178,7 +232,7 @@
     assertEquals(1, hpackReader.headerCount);
     assertEquals(55, hpackReader.dynamicTableByteCount);
 
-    Header entry = hpackReader.dynamicTable[headerTableLength() - 1];
+    Header entry = hpackReader.dynamicTable[readerHeaderTableLength() - 1];
     checkEntry(entry, "custom-key", "custom-header", 55);
 
     assertEquals(headerEntries("custom-key", "custom-header"), hpackReader.getAndResetHeaderList());
@@ -215,9 +269,6 @@
     bytesIn.writeByte(0x0d); // Literal value (len = 13)
     bytesIn.writeUtf8("custom-header");
 
-    hpackWriter.writeHeaders(headerBlock);
-    assertEquals(bytesIn, bytesOut);
-
     hpackReader.readHeaders();
 
     assertEquals(0, hpackReader.headerCount);
@@ -239,6 +290,8 @@
   }
 
   @Test public void literalHeaderFieldNeverIndexedNewName() throws IOException {
+    List<Header> headerBlock = headerEntries("custom-key", "custom-header");
+
     bytesIn.writeByte(0x10); // Never indexed
     bytesIn.writeByte(0x0a); // Literal name (len = 10)
     bytesIn.writeUtf8("custom-key");
@@ -250,7 +303,76 @@
 
     assertEquals(0, hpackReader.headerCount);
 
-    assertEquals(headerEntries("custom-key", "custom-header"), hpackReader.getAndResetHeaderList());
+    assertEquals(headerBlock, hpackReader.getAndResetHeaderList());
+  }
+
+  @Test public void literalHeaderFieldWithIncrementalIndexingIndexedName() throws IOException {
+    List<Header> headerBlock = headerEntries(":path", "/sample/path");
+
+    bytesIn.writeByte(0x44); // Indexed name (idx = 4) -> :path
+    bytesIn.writeByte(0x0c); // Literal value (len = 12)
+    bytesIn.writeUtf8("/sample/path");
+
+    hpackReader.readHeaders();
+
+    assertEquals(1, hpackReader.headerCount);
+
+    assertEquals(headerBlock, hpackReader.getAndResetHeaderList());
+  }
+
+  @Test public void literalHeaderFieldWithIncrementalIndexingNewName() throws IOException {
+    List<Header> headerBlock = headerEntries("custom-key", "custom-header");
+
+    bytesIn.writeByte(0x40); // Never indexed
+    bytesIn.writeByte(0x0a); // Literal name (len = 10)
+    bytesIn.writeUtf8("custom-key");
+
+    bytesIn.writeByte(0x0d); // Literal value (len = 13)
+    bytesIn.writeUtf8("custom-header");
+
+    hpackWriter.writeHeaders(headerBlock);
+    assertEquals(bytesIn, bytesOut);
+
+    assertEquals(1, hpackWriter.headerCount);
+
+    Header entry = hpackWriter.dynamicTable[hpackWriter.dynamicTable.length - 1];
+    checkEntry(entry, "custom-key", "custom-header", 55);
+
+    hpackReader.readHeaders();
+
+    assertEquals(1, hpackReader.headerCount);
+
+    assertEquals(headerBlock, hpackReader.getAndResetHeaderList());
+  }
+
+  @Test public void theSameHeaderAfterOneIncrementalIndexed() throws IOException {
+    List<Header> headerBlock =
+        headerEntries(
+            "custom-key", "custom-header",
+            "custom-key", "custom-header");
+
+    bytesIn.writeByte(0x40); // Never indexed
+    bytesIn.writeByte(0x0a); // Literal name (len = 10)
+    bytesIn.writeUtf8("custom-key");
+
+    bytesIn.writeByte(0x0d); // Literal value (len = 13)
+    bytesIn.writeUtf8("custom-header");
+
+    bytesIn.writeByte(0xbe); // Indexed name and value (idx = 63)
+
+    hpackWriter.writeHeaders(headerBlock);
+    assertEquals(bytesIn, bytesOut);
+
+    assertEquals(1, hpackWriter.headerCount);
+
+    Header entry = hpackWriter.dynamicTable[hpackWriter.dynamicTable.length - 1];
+    checkEntry(entry, "custom-key", "custom-header", 55);
+
+    hpackReader.readHeaders();
+
+    assertEquals(1, hpackReader.headerCount);
+
+    assertEquals(headerBlock, hpackReader.getAndResetHeaderList());
   }
 
   @Test public void staticHeaderIsNotCopiedIntoTheIndexedTable() throws IOException {
@@ -262,7 +384,7 @@
     assertEquals(0, hpackReader.headerCount);
     assertEquals(0, hpackReader.dynamicTableByteCount);
 
-    assertEquals(null, hpackReader.dynamicTable[headerTableLength() - 1]);
+    assertEquals(null, hpackReader.dynamicTable[readerHeaderTableLength() - 1]);
 
     assertEquals(headerEntries(":method", "GET"), hpackReader.getAndResetHeaderList());
   }
@@ -350,10 +472,10 @@
    * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#appendix-C.2.4
    */
   @Test public void readIndexedHeaderFieldFromStaticTableWithoutBuffering() throws IOException {
+    bytesIn.writeByte(0x20); // Dynamic table size update (size = 0).
     bytesIn.writeByte(0x82); // == Indexed - Add ==
                              // idx = 2 -> :method: GET
 
-    hpackReader.headerTableSizeSetting(0); // SETTINGS_HEADER_TABLE_SIZE == 0
     hpackReader.readHeaders();
 
     // Not buffered in header table.
@@ -396,7 +518,7 @@ private void checkReadFirstRequestWithoutHuffman() {
     assertEquals(1, hpackReader.headerCount);
 
     // [  1] (s =  57) :authority: www.example.com
-    Header entry = hpackReader.dynamicTable[headerTableLength() - 1];
+    Header entry = hpackReader.dynamicTable[readerHeaderTableLength() - 1];
     checkEntry(entry, ":authority", "www.example.com", 57);
 
     // Table size: 57
@@ -429,11 +551,11 @@ private void checkReadSecondRequestWithoutHuffman() {
     assertEquals(2, hpackReader.headerCount);
 
     // [  1] (s =  53) cache-control: no-cache
-    Header entry = hpackReader.dynamicTable[headerTableLength() - 2];
+    Header entry = hpackReader.dynamicTable[readerHeaderTableLength() - 2];
     checkEntry(entry, "cache-control", "no-cache", 53);
 
     // [  2] (s =  57) :authority: www.example.com
-    entry = hpackReader.dynamicTable[headerTableLength() - 1];
+    entry = hpackReader.dynamicTable[readerHeaderTableLength() - 1];
     checkEntry(entry, ":authority", "www.example.com", 57);
 
     // Table size: 110
@@ -468,15 +590,15 @@ private void checkReadThirdRequestWithoutHuffman() {
     assertEquals(3, hpackReader.headerCount);
 
     // [  1] (s =  54) custom-key: custom-value
-    Header entry = hpackReader.dynamicTable[headerTableLength() - 3];
+    Header entry = hpackReader.dynamicTable[readerHeaderTableLength() - 3];
     checkEntry(entry, "custom-key", "custom-value", 54);
 
     // [  2] (s =  53) cache-control: no-cache
-    entry = hpackReader.dynamicTable[headerTableLength() - 2];
+    entry = hpackReader.dynamicTable[readerHeaderTableLength() - 2];
     checkEntry(entry, "cache-control", "no-cache", 53);
 
     // [  3] (s =  57) :authority: www.example.com
-    entry = hpackReader.dynamicTable[headerTableLength() - 1];
+    entry = hpackReader.dynamicTable[readerHeaderTableLength() - 1];
     checkEntry(entry, ":authority", "www.example.com", 57);
 
     // Table size: 164
@@ -526,7 +648,7 @@ private void checkReadFirstRequestWithHuffman() {
     assertEquals(1, hpackReader.headerCount);
 
     // [  1] (s =  57) :authority: www.example.com
-    Header entry = hpackReader.dynamicTable[headerTableLength() - 1];
+    Header entry = hpackReader.dynamicTable[readerHeaderTableLength() - 1];
     checkEntry(entry, ":authority", "www.example.com", 57);
 
     // Table size: 57
@@ -560,11 +682,11 @@ private void checkReadSecondRequestWithHuffman() {
     assertEquals(2, hpackReader.headerCount);
 
     // [  1] (s =  53) cache-control: no-cache
-    Header entry = hpackReader.dynamicTable[headerTableLength() - 2];
+    Header entry = hpackReader.dynamicTable[readerHeaderTableLength() - 2];
     checkEntry(entry, "cache-control", "no-cache", 53);
 
     // [  2] (s =  57) :authority: www.example.com
-    entry = hpackReader.dynamicTable[headerTableLength() - 1];
+    entry = hpackReader.dynamicTable[readerHeaderTableLength() - 1];
     checkEntry(entry, ":authority", "www.example.com", 57);
 
     // Table size: 110
@@ -601,15 +723,15 @@ private void checkReadThirdRequestWithHuffman() {
     assertEquals(3, hpackReader.headerCount);
 
     // [  1] (s =  54) custom-key: custom-value
-    Header entry = hpackReader.dynamicTable[headerTableLength() - 3];
+    Header entry = hpackReader.dynamicTable[readerHeaderTableLength() - 3];
     checkEntry(entry, "custom-key", "custom-value", 54);
 
     // [  2] (s =  53) cache-control: no-cache
-    entry = hpackReader.dynamicTable[headerTableLength() - 2];
+    entry = hpackReader.dynamicTable[readerHeaderTableLength() - 2];
     checkEntry(entry, "cache-control", "no-cache", 53);
 
     // [  3] (s =  57) :authority: www.example.com
-    entry = hpackReader.dynamicTable[headerTableLength() - 1];
+    entry = hpackReader.dynamicTable[readerHeaderTableLength() - 1];
     checkEntry(entry, ":authority", "www.example.com", 57);
 
     // Table size: 164
@@ -674,7 +796,7 @@ private void checkReadThirdRequestWithHuffman() {
 
   @Test public void lowercaseHeaderNameBeforeEmit() throws IOException {
     hpackWriter.writeHeaders(Arrays.asList(new Header("FoO", "BaR")));
-    assertBytes(0, 3, 'f', 'o', 'o', 3, 'B', 'a', 'R');
+    assertBytes(0x40, 3, 'f', 'o', 'o', 3, 'B', 'a', 'R');
   }
 
   @Test public void mixedCaseHeaderNameIsMalformed() throws IOException {
@@ -692,6 +814,208 @@ private void checkReadThirdRequestWithHuffman() {
     assertEquals(ByteString.EMPTY, newReader(byteStream(0)).readByteString());
   }
 
+  @Test public void emitsDynamicTableSizeUpdate() throws IOException {
+    hpackWriter.setHeaderTableSizeSetting(2048);
+    hpackWriter.writeHeaders(Arrays.asList(new Header("foo", "bar")));
+    assertBytes(
+        0x3F, 0xE1, 0xF, // Dynamic table size update (size = 2048).
+        0x40, 3, 'f', 'o', 'o', 3, 'b', 'a', 'r');
+
+    hpackWriter.setHeaderTableSizeSetting(8192);
+    hpackWriter.writeHeaders(Arrays.asList(new Header("bar", "foo")));
+    assertBytes(
+        0x3F, 0xE1, 0x3F, // Dynamic table size update (size = 8192).
+        0x40, 3, 'b', 'a', 'r', 3, 'f', 'o', 'o');
+
+    // No more dynamic table updates should be emitted.
+    hpackWriter.writeHeaders(Arrays.asList(new Header("far", "boo")));
+    assertBytes(0x40, 3, 'f', 'a', 'r', 3, 'b', 'o', 'o');
+  }
+
+  @Test public void noDynamicTableSizeUpdateWhenSizeIsEqual() throws IOException {
+    int currentSize = hpackWriter.headerTableSizeSetting;
+    hpackWriter.setHeaderTableSizeSetting(currentSize);
+    hpackWriter.writeHeaders(Arrays.asList(new Header("foo", "bar")));
+
+    assertBytes(0x40, 3, 'f', 'o', 'o', 3, 'b', 'a', 'r');
+  }
+
+  @Test public void growDynamicTableSize() throws IOException {
+    hpackWriter.setHeaderTableSizeSetting(8192);
+    hpackWriter.setHeaderTableSizeSetting(16384);
+    hpackWriter.writeHeaders(Arrays.asList(new Header("foo", "bar")));
+
+    assertBytes(
+        0x3F, 0xE1, 0x7F, // Dynamic table size update (size = 16384).
+        0x40, 3, 'f', 'o', 'o', 3, 'b', 'a', 'r');
+  }
+
+  @Test public void shrinkDynamicTableSize() throws IOException {
+    hpackWriter.setHeaderTableSizeSetting(2048);
+    hpackWriter.setHeaderTableSizeSetting(0);
+    hpackWriter.writeHeaders(Arrays.asList(new Header("foo", "bar")));
+
+    assertBytes(
+        0x20, // Dynamic size update (size = 0).
+        0x40, 3, 'f', 'o', 'o', 3, 'b', 'a', 'r');
+  }
+
+  @Test public void manyDynamicTableSizeChanges() throws IOException {
+    hpackWriter.setHeaderTableSizeSetting(16384);
+    hpackWriter.setHeaderTableSizeSetting(8096);
+    hpackWriter.setHeaderTableSizeSetting(0);
+    hpackWriter.setHeaderTableSizeSetting(4096);
+    hpackWriter.setHeaderTableSizeSetting(2048);
+    hpackWriter.writeHeaders(Arrays.asList(new Header("foo", "bar")));
+
+    assertBytes(
+        0x20, // Dynamic size update (size = 0).
+        0x3F, 0xE1, 0xF, // Dynamic size update (size = 2048).
+        0x40, 3, 'f', 'o', 'o', 3, 'b', 'a', 'r');
+  }
+
+  @Test public void dynamicTableEvictionWhenSizeLowered() throws IOException {
+    List<Header> headerBlock =
+        headerEntries(
+            "custom-key1", "custom-header",
+            "custom-key2", "custom-header");
+    hpackWriter.writeHeaders(headerBlock);
+    assertEquals(2, hpackWriter.headerCount);
+
+    hpackWriter.setHeaderTableSizeSetting(56);
+    assertEquals(1, hpackWriter.headerCount);
+
+    hpackWriter.setHeaderTableSizeSetting(0);
+    assertEquals(0, hpackWriter.headerCount);
+  }
+
+  @Test public void noEvictionOnDynamicTableSizeIncrease() throws IOException {
+    List<Header> headerBlock =
+        headerEntries(
+            "custom-key1", "custom-header",
+            "custom-key2", "custom-header");
+    hpackWriter.writeHeaders(headerBlock);
+    assertEquals(2, hpackWriter.headerCount);
+
+    hpackWriter.setHeaderTableSizeSetting(8192);
+    assertEquals(2, hpackWriter.headerCount);
+  }
+
+  @Test public void dynamicTableSizeHasAnUpperBound() {
+    hpackWriter.setHeaderTableSizeSetting(1048576);
+    assertEquals(16384, hpackWriter.maxDynamicTableByteCount);
+  }
+
+  @Test public void huffmanEncode() throws IOException {
+    hpackWriter = new Hpack.Writer(4096, true, bytesOut);
+    hpackWriter.writeHeaders(headerEntries("foo", "bar"));
+
+    ByteString expected = new Buffer()
+        .writeByte(0x40) // Literal header, new name.
+        .writeByte(0x82) // String literal is Huffman encoded (len = 2).
+        .writeByte(0x94) // 'foo' Huffman encoded.
+        .writeByte(0xE7)
+        .writeByte(3) // String literal not Huffman encoded (len = 3).
+        .writeByte('b')
+        .writeByte('a')
+        .writeByte('r')
+        .readByteString();
+
+    ByteString actual = bytesOut.readByteString();
+    assertEquals(expected, actual);
+  }
+
+  @Test public void staticTableIndexedHeaders() throws IOException {
+    hpackWriter.writeHeaders(headerEntries(":method", "GET"));
+    assertBytes(0x82);
+    assertEquals(0, hpackWriter.headerCount);
+
+    hpackWriter.writeHeaders(headerEntries(":method", "POST"));
+    assertBytes(0x83);
+    assertEquals(0, hpackWriter.headerCount);
+
+    hpackWriter.writeHeaders(headerEntries(":path", "/"));
+    assertBytes(0x84);
+    assertEquals(0, hpackWriter.headerCount);
+
+    hpackWriter.writeHeaders(headerEntries(":path", "/index.html"));
+    assertBytes(0x85);
+    assertEquals(0, hpackWriter.headerCount);
+
+    hpackWriter.writeHeaders(headerEntries(":scheme", "http"));
+    assertBytes(0x86);
+    assertEquals(0, hpackWriter.headerCount);
+
+    hpackWriter.writeHeaders(headerEntries(":scheme", "https"));
+    assertBytes(0x87);
+    assertEquals(0, hpackWriter.headerCount);
+  }
+
+  @Test public void dynamicTableIndexedHeader() throws IOException {
+    hpackWriter.writeHeaders(headerEntries("custom-key", "custom-header"));
+    assertBytes(0x40,
+        10, 'c', 'u', 's', 't', 'o', 'm', '-', 'k', 'e', 'y',
+        13, 'c', 'u', 's', 't', 'o', 'm', '-', 'h', 'e', 'a', 'd', 'e', 'r');
+    assertEquals(1, hpackWriter.headerCount);
+
+    hpackWriter.writeHeaders(headerEntries("custom-key", "custom-header"));
+    assertBytes(0xbe);
+    assertEquals(1, hpackWriter.headerCount);
+  }
+
+  @Test public void doNotIndexPseudoHeaders() throws IOException {
+    hpackWriter.writeHeaders(headerEntries(":method", "PUT"));
+    assertBytes(0x02, 3, 'P', 'U', 'T');
+    assertEquals(0, hpackWriter.headerCount);
+
+    hpackWriter.writeHeaders(headerEntries(":path", "/okhttp"));
+    assertBytes(0x04, 7, '/', 'o', 'k', 'h', 't', 't', 'p');
+    assertEquals(0, hpackWriter.headerCount);
+  }
+
+  @Test public void incrementalIndexingWithAuthorityPseudoHeader() throws IOException {
+    hpackWriter.writeHeaders(headerEntries(":authority", "foo.com"));
+    assertBytes(0x41, 7, 'f', 'o', 'o', '.', 'c', 'o', 'm');
+    assertEquals(1, hpackWriter.headerCount);
+
+    hpackWriter.writeHeaders(headerEntries(":authority", "foo.com"));
+    assertBytes(0xbe);
+    assertEquals(1, hpackWriter.headerCount);
+
+    // If the :authority header somehow changes, it should be re-added to the dynamic table.
+    hpackWriter.writeHeaders(headerEntries(":authority", "bar.com"));
+    assertBytes(0x41, 7, 'b', 'a', 'r', '.', 'c', 'o', 'm');
+    assertEquals(2, hpackWriter.headerCount);
+
+    hpackWriter.writeHeaders(headerEntries(":authority", "bar.com"));
+    assertBytes(0xbe);
+    assertEquals(2, hpackWriter.headerCount);
+  }
+
+  @Test public void incrementalIndexingWithStaticTableIndexedName() throws IOException {
+    hpackWriter.writeHeaders(headerEntries("accept-encoding", "gzip"));
+    assertBytes(0x50, 4, 'g', 'z', 'i', 'p');
+    assertEquals(1, hpackWriter.headerCount);
+
+    hpackWriter.writeHeaders(headerEntries("accept-encoding", "gzip"));
+    assertBytes(0xbe);
+    assertEquals(1, hpackWriter.headerCount);
+  }
+
+  @Test public void incrementalIndexingWithDynamcTableIndexedName() throws IOException {
+    hpackWriter.writeHeaders(headerEntries("foo", "bar"));
+    assertBytes(0x40, 3, 'f', 'o', 'o', 3, 'b', 'a', 'r');
+    assertEquals(1, hpackWriter.headerCount);
+
+    hpackWriter.writeHeaders(headerEntries("foo", "bar1"));
+    assertBytes(0x7e, 4, 'b', 'a', 'r', '1');
+    assertEquals(2, hpackWriter.headerCount);
+
+    hpackWriter.writeHeaders(headerEntries("foo", "bar1"));
+    assertBytes(0xbe);
+    assertEquals(2, hpackWriter.headerCount);
+  }
+
   private Hpack.Reader newReader(Buffer source) {
     return new Hpack.Reader(4096, source);
   }
@@ -720,7 +1044,7 @@ private ByteString intArrayToByteArray(int[] bytes) {
     return ByteString.of(data);
   }
 
-  private int headerTableLength() {
+  private int readerHeaderTableLength() {
     return hpackReader.dynamicTable.length;
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java
new file mode 100644
index 0000000000..c8af96913b
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java
@@ -0,0 +1,1701 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http2;
+
+import java.io.IOException;
+import java.io.InterruptedIOException;
+import java.net.Socket;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+import okhttp3.internal.Util;
+import okhttp3.internal.http2.MockHttp2Peer.InFrame;
+import okio.AsyncTimeout;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.Okio;
+import okio.Sink;
+import okio.Source;
+import org.junit.After;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import org.junit.rules.Timeout;
+
+import static okhttp3.TestUtil.headerEntries;
+import static okhttp3.TestUtil.repeat;
+import static okhttp3.internal.Util.EMPTY_BYTE_ARRAY;
+import static okhttp3.internal.http2.Http2Connection.Listener.REFUSE_INCOMING_STREAMS;
+import static okhttp3.internal.http2.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
+import static okhttp3.internal.http2.Settings.ENABLE_PUSH;
+import static okhttp3.internal.http2.Settings.HEADER_TABLE_SIZE;
+import static okhttp3.internal.http2.Settings.INITIAL_WINDOW_SIZE;
+import static okhttp3.internal.http2.Settings.MAX_CONCURRENT_STREAMS;
+import static okhttp3.internal.http2.Settings.MAX_FRAME_SIZE;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class Http2ConnectionTest {
+  private final MockHttp2Peer peer = new MockHttp2Peer();
+
+  @Rule public final TestRule timeout = new Timeout(5_000);
+
+  @After public void tearDown() throws Exception {
+    peer.close();
+  }
+
+  @Test public void serverPingsClientHttp2() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.sendFrame().ping(false, 2, 3);
+    peer.acceptFrame(); // PING
+    peer.play();
+
+    // play it back
+    connect(peer);
+
+    // verify the peer received what was expected
+    InFrame ping = peer.takeFrame();
+    assertEquals(Http2.TYPE_PING, ping.type);
+    assertEquals(0, ping.streamId);
+    assertEquals(2, ping.payload1);
+    assertEquals(3, ping.payload2);
+    assertTrue(ping.ack);
+  }
+
+  @Test public void clientPingsServerHttp2() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 5);
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    Ping ping = connection.ping();
+    assertTrue(ping.roundTripTime() > 0);
+    assertTrue(ping.roundTripTime() < TimeUnit.SECONDS.toNanos(1));
+
+    // verify the peer received what was expected
+    InFrame pingFrame = peer.takeFrame();
+    assertEquals(0, pingFrame.streamId);
+    assertEquals(1, pingFrame.payload1);
+    assertEquals(0x4f4b6f6b, pingFrame.payload2); // connection.ping() sets this.
+    assertFalse(pingFrame.ack);
+  }
+
+  @Test public void peerHttp2ServerLowersInitialWindowSize() throws Exception {
+    Settings initial = new Settings();
+    initial.set(INITIAL_WINDOW_SIZE, 1684);
+    Settings shouldntImpactConnection = new Settings();
+    shouldntImpactConnection.set(INITIAL_WINDOW_SIZE, 3368);
+
+    peer.sendFrame().settings(initial);
+    peer.acceptFrame(); // ACK
+    peer.sendFrame().settings(shouldntImpactConnection);
+    peer.acceptFrame(); // ACK 2
+    peer.acceptFrame(); // HEADERS
+    peer.play();
+
+    Http2Connection connection = connect(peer);
+
+    // Verify the peer received the second ACK.
+    InFrame ackFrame = peer.takeFrame();
+    assertEquals(Http2.TYPE_SETTINGS, ackFrame.type);
+    assertEquals(0, ackFrame.streamId);
+    assertTrue(ackFrame.ack);
+
+    // This stream was created *after* the connection settings were adjusted.
+    Http2Stream stream = connection.newStream(headerEntries("a", "android"), false);
+
+    assertEquals(3368, connection.peerSettings.getInitialWindowSize());
+    assertEquals(1684, connection.bytesLeftInWriteWindow); // initial wasn't affected.
+    // New Stream is has the most recent initial window size.
+    assertEquals(3368, stream.bytesLeftInWriteWindow);
+  }
+
+  @Test public void peerHttp2ServerZerosCompressionTable() throws Exception {
+    boolean client = false; // Peer is server, so we are client.
+    Settings settings = new Settings();
+    settings.set(HEADER_TABLE_SIZE, 0);
+
+    Http2Connection connection = connectWithSettings(client, settings);
+
+    // Verify the peer's settings were read and applied.
+    assertEquals(0, connection.peerSettings.getHeaderTableSize());
+    Http2Writer writer = connection.writer;
+    assertEquals(0, writer.hpackWriter.dynamicTableByteCount);
+    assertEquals(0, writer.hpackWriter.headerTableSizeSetting);
+  }
+
+  @Test public void peerHttp2ClientDisablesPush() throws Exception {
+    boolean client = false; // Peer is client, so we are server.
+    Settings settings = new Settings();
+    settings.set(ENABLE_PUSH, 0); // The peer client disables push.
+
+    Http2Connection connection = connectWithSettings(client, settings);
+
+    // verify the peer's settings were read and applied.
+    assertFalse(connection.peerSettings.getEnablePush(true));
+  }
+
+  @Test public void peerIncreasesMaxFrameSize() throws Exception {
+    int newMaxFrameSize = 0x4001;
+    Settings settings = new Settings();
+    settings.set(MAX_FRAME_SIZE, newMaxFrameSize);
+
+    Http2Connection connection = connectWithSettings(true, settings);
+
+    // verify the peer's settings were read and applied.
+    assertEquals(newMaxFrameSize, connection.peerSettings.getMaxFrameSize(-1));
+    assertEquals(newMaxFrameSize, connection.writer.maxDataLength());
+  }
+
+  /**
+   * Webservers may set the initial window size to zero, which is a special case because it means
+   * that we have to flush headers immediately before any request body can be sent.
+   * https://github.com/square/okhttp/issues/2543
+   */
+  @Test public void peerSetsZeroFlowControl() throws Exception {
+    peer.setClient(true);
+
+    // Write the mocking script.
+    peer.sendFrame().settings(new Settings().set(INITIAL_WINDOW_SIZE, 0));
+    peer.acceptFrame(); // ACK
+    peer.sendFrame().windowUpdate(0, 10); // Increase the connection window size.
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 0);
+    peer.acceptFrame(); // HEADERS STREAM 3
+    peer.sendFrame().windowUpdate(3, 5);
+    peer.acceptFrame(); // DATA STREAM 3 "abcde"
+    peer.sendFrame().windowUpdate(3, 5);
+    peer.acceptFrame(); // DATA STREAM 3 "fghi"
+    peer.play();
+
+    // Play it back.
+    Http2Connection connection = connect(peer);
+    connection.ping().roundTripTime(); // Ensure the SETTINGS have been received.
+    Http2Stream stream = connection.newStream(headerEntries("a", "android"), true);
+    BufferedSink sink = Okio.buffer(stream.getSink());
+    sink.writeUtf8("abcdefghi");
+    sink.flush();
+
+    // Verify the peer received what was expected.
+    peer.takeFrame(); // PING
+    InFrame headers = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, headers.type);
+    InFrame data1 = peer.takeFrame();
+    assertEquals(Http2.TYPE_DATA, data1.type);
+    assertEquals(3, data1.streamId);
+    assertTrue(Arrays.equals("abcde".getBytes("UTF-8"), data1.data));
+    InFrame data2 = peer.takeFrame();
+    assertEquals(Http2.TYPE_DATA, data2.type);
+    assertEquals(3, data2.streamId);
+    assertTrue(Arrays.equals("fghi".getBytes("UTF-8"), data2.data));
+  }
+
+  @Test public void receiveGoAwayHttp2() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM 3
+    peer.acceptFrame(); // SYN_STREAM 5
+    peer.sendFrame().goAway(3, ErrorCode.PROTOCOL_ERROR, EMPTY_BYTE_ARRAY);
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 0);
+    peer.acceptFrame(); // DATA STREAM 3
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    Http2Stream stream1 = connection.newStream(headerEntries("a", "android"), true);
+    Http2Stream stream2 = connection.newStream(headerEntries("b", "banana"), true);
+    connection.ping().roundTripTime(); // Ensure the GO_AWAY that resets stream2 has been received.
+    BufferedSink sink1 = Okio.buffer(stream1.getSink());
+    BufferedSink sink2 = Okio.buffer(stream2.getSink());
+    sink1.writeUtf8("abc");
+    try {
+      sink2.writeUtf8("abc");
+      sink2.flush();
+      fail();
+    } catch (IOException expected) {
+      assertEquals("stream was reset: REFUSED_STREAM", expected.getMessage());
+    }
+    sink1.writeUtf8("def");
+    sink1.close();
+    try {
+      connection.newStream(headerEntries("c", "cola"), true);
+      fail();
+    } catch (ConnectionShutdownException expected) {
+    }
+    assertTrue(stream1.isOpen());
+    assertFalse(stream2.isOpen());
+    assertEquals(1, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    InFrame synStream1 = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream1.type);
+    InFrame synStream2 = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream2.type);
+    InFrame ping = peer.takeFrame();
+    assertEquals(Http2.TYPE_PING, ping.type);
+    InFrame data1 = peer.takeFrame();
+    assertEquals(Http2.TYPE_DATA, data1.type);
+    assertEquals(3, data1.streamId);
+    assertTrue(Arrays.equals("abcdef".getBytes("UTF-8"), data1.data));
+  }
+
+  @Test public void readSendsWindowUpdateHttp2() throws Exception {
+    int windowSize = 100;
+    int windowUpdateThreshold = 50;
+
+    // Write the mocking script.
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    for (int i = 0; i < 3; i++) {
+      // Send frames of summing to size 50, which is windowUpdateThreshold.
+      peer.sendFrame().data(false, 3, data(24), 24);
+      peer.sendFrame().data(false, 3, data(25), 25);
+      peer.sendFrame().data(false, 3, data(1), 1);
+      peer.acceptFrame(); // connection WINDOW UPDATE
+      peer.acceptFrame(); // stream WINDOW UPDATE
+    }
+    peer.sendFrame().data(true, 3, data(0), 0);
+    peer.play();
+
+    // Play it back.
+    Http2Connection connection = connect(peer);
+    connection.okHttpSettings.set(INITIAL_WINDOW_SIZE, windowSize);
+    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
+    assertEquals(0, stream.unacknowledgedBytesRead);
+    assertEquals(headerEntries("a", "android"), stream.takeResponseHeaders());
+    Source in = stream.getSource();
+    Buffer buffer = new Buffer();
+    buffer.writeAll(in);
+    assertEquals(-1, in.read(buffer, 1));
+    assertEquals(150, buffer.size());
+
+    InFrame synStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    for (int i = 0; i < 3; i++) {
+      List<Integer> windowUpdateStreamIds = new ArrayList<>(2);
+      for (int j = 0; j < 2; j++) {
+        InFrame windowUpdate = peer.takeFrame();
+        assertEquals(Http2.TYPE_WINDOW_UPDATE, windowUpdate.type);
+        windowUpdateStreamIds.add(windowUpdate.streamId);
+        assertEquals(windowUpdateThreshold, windowUpdate.windowSizeIncrement);
+      }
+      assertTrue(windowUpdateStreamIds.contains(0)); // connection
+      assertTrue(windowUpdateStreamIds.contains(3)); // stream
+    }
+  }
+
+  @Test public void serverSendsEmptyDataClientDoesntSendWindowUpdateHttp2() throws Exception {
+    // Write the mocking script.
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().data(true, 3, data(0), 0);
+    peer.play();
+
+    // Play it back.
+    Http2Connection connection = connect(peer);
+    Http2Stream client = connection.newStream(headerEntries("b", "banana"), false);
+    assertEquals(-1, client.getSource().read(new Buffer(), 1));
+
+    // Verify the peer received what was expected.
+    InFrame synStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    assertEquals(5, peer.frameCount());
+  }
+
+  @Test public void clientSendsEmptyDataServerDoesntSendWindowUpdateHttp2() throws Exception {
+    // Write the mocking script.
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.acceptFrame(); // DATA
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.play();
+
+    // Play it back.
+    Http2Connection connection = connect(peer);
+    Http2Stream client = connection.newStream(headerEntries("b", "banana"), true);
+    BufferedSink out = Okio.buffer(client.getSink());
+    out.write(EMPTY_BYTE_ARRAY);
+    out.flush();
+    out.close();
+
+    // Verify the peer received what was expected.
+    assertEquals(Http2.TYPE_HEADERS, peer.takeFrame().type);
+    assertEquals(Http2.TYPE_DATA, peer.takeFrame().type);
+    assertEquals(5, peer.frameCount());
+  }
+
+  @Test public void maxFrameSizeHonored() throws Exception {
+    byte[] buff = new byte[peer.maxOutboundDataLength() + 1];
+    Arrays.fill(buff, (byte) '*');
+
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.acceptFrame(); // DATA
+    peer.acceptFrame(); // DATA
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
+    BufferedSink out = Okio.buffer(stream.getSink());
+    out.write(buff);
+    out.flush();
+    out.close();
+
+    InFrame synStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    InFrame data = peer.takeFrame();
+    assertEquals(peer.maxOutboundDataLength(), data.data.length);
+    data = peer.takeFrame();
+    assertEquals(1, data.data.length);
+  }
+
+  @Test public void pushPromiseStream() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    final List<Header> expectedRequestHeaders = Arrays.asList(
+        new Header(Header.TARGET_METHOD, "GET"),
+        new Header(Header.TARGET_SCHEME, "https"),
+        new Header(Header.TARGET_AUTHORITY, "squareup.com"),
+        new Header(Header.TARGET_PATH, "/cached")
+    );
+    peer.sendFrame().pushPromise(3, 2, expectedRequestHeaders);
+    final List<Header> expectedResponseHeaders = Arrays.asList(
+        new Header(Header.RESPONSE_STATUS, "200")
+    );
+    peer.sendFrame().synReply(true, 2, expectedResponseHeaders);
+    peer.sendFrame().data(true, 3, data(0), 0);
+    peer.play();
+
+    RecordingPushObserver observer = new RecordingPushObserver();
+
+    // play it back
+    Http2Connection connection = connect(peer, observer, REFUSE_INCOMING_STREAMS);
+    Http2Stream client = connection.newStream(headerEntries("b", "banana"), false);
+    assertEquals(-1, client.getSource().read(new Buffer(), 1));
+
+    // verify the peer received what was expected
+    assertEquals(Http2.TYPE_HEADERS, peer.takeFrame().type);
+
+    assertEquals(expectedRequestHeaders, observer.takeEvent());
+    assertEquals(expectedResponseHeaders, observer.takeEvent());
+  }
+
+  @Test public void doublePushPromise() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.sendFrame().pushPromise(3, 2, headerEntries("a", "android"));
+    peer.acceptFrame(); // SYN_REPLY
+    peer.sendFrame().pushPromise(3, 2, headerEntries("b", "banana"));
+    peer.acceptFrame(); // RST_STREAM
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    connection.newStream(headerEntries("b", "banana"), false);
+
+    // verify the peer received what was expected
+    assertEquals(Http2.TYPE_HEADERS, peer.takeFrame().type);
+    assertEquals(ErrorCode.PROTOCOL_ERROR, peer.takeFrame().errorCode);
+  }
+
+  @Test public void pushPromiseStreamsAutomaticallyCancel() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.sendFrame().pushPromise(3, 2, Arrays.asList(
+        new Header(Header.TARGET_METHOD, "GET"),
+        new Header(Header.TARGET_SCHEME, "https"),
+        new Header(Header.TARGET_AUTHORITY, "squareup.com"),
+        new Header(Header.TARGET_PATH, "/cached")
+    ));
+    peer.sendFrame().synReply(true, 2, Arrays.asList(
+        new Header(Header.RESPONSE_STATUS, "200")
+    ));
+    peer.acceptFrame(); // RST_STREAM
+    peer.play();
+
+    // play it back
+    connect(peer, PushObserver.CANCEL, REFUSE_INCOMING_STREAMS);
+
+    // verify the peer received what was expected
+    InFrame rstStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_RST_STREAM, rstStream.type);
+    assertEquals(2, rstStream.streamId);
+    assertEquals(ErrorCode.CANCEL, rstStream.errorCode);
+  }
+
+  /**
+   * When writing a set of headers fails due to an {@code IOException}, make sure the writer is left
+   * in a consistent state so the next writer also gets an {@code IOException} also instead of
+   * something worse (like an {@link IllegalStateException}.
+   *
+   * <p>See https://github.com/square/okhttp/issues/1651
+   */
+  @Test public void socketExceptionWhileWritingHeaders() throws Exception {
+    peer.acceptFrame(); // SYN_STREAM.
+    peer.play();
+
+    String longString = repeat('a', Http2.INITIAL_MAX_FRAME_SIZE + 1);
+    Socket socket = peer.openSocket();
+    Http2Connection connection = new Http2Connection.Builder(true)
+        .socket(socket)
+        .pushObserver(IGNORE)
+        .build();
+    connection.start(false);
+    socket.shutdownOutput();
+    try {
+      connection.newStream(headerEntries("a", longString), false);
+      fail();
+    } catch (IOException expected) {
+    }
+    try {
+      connection.newStream(headerEntries("b", longString), false);
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  @Test public void clientCreatesStreamAndServerReplies() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.acceptFrame(); // DATA
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().data(true, 3, new Buffer().writeUtf8("robot"), 5);
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 0); // PING
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
+    BufferedSink out = Okio.buffer(stream.getSink());
+    out.writeUtf8("c3po");
+    out.close();
+    assertEquals(headerEntries("a", "android"), stream.takeResponseHeaders());
+    assertStreamData("robot", stream.getSource());
+    connection.ping().roundTripTime();
+    assertEquals(0, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    InFrame synStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    assertFalse(synStream.outFinished);
+    assertEquals(3, synStream.streamId);
+    assertEquals(-1, synStream.associatedStreamId);
+    assertEquals(headerEntries("b", "banana"), synStream.headerBlock);
+    InFrame requestData = peer.takeFrame();
+    assertTrue(Arrays.equals("c3po".getBytes("UTF-8"), requestData.data));
+  }
+
+  @Test public void clientCreatesStreamAndServerRepliesWithFin() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.acceptFrame(); // PING
+    peer.sendFrame().synReply(true, 3, headerEntries("a", "android"));
+    peer.sendFrame().ping(true, 1, 0);
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    connection.newStream(headerEntries("b", "banana"), false);
+    assertEquals(1, connection.openStreamCount());
+    connection.ping().roundTripTime(); // Ensure that the SYN_REPLY has been received.
+    assertEquals(0, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    InFrame synStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    InFrame ping = peer.takeFrame();
+    assertEquals(Http2.TYPE_PING, ping.type);
+  }
+
+  @Test public void serverPingsClient() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.sendFrame().ping(false, 2, 0);
+    peer.acceptFrame(); // PING
+    peer.play();
+
+    // play it back
+    connect(peer);
+
+    // verify the peer received what was expected
+    InFrame ping = peer.takeFrame();
+    assertEquals(0, ping.streamId);
+    assertEquals(2, ping.payload1);
+    assertEquals(0, ping.payload2);
+    assertTrue(ping.ack);
+  }
+
+  @Test public void clientPingsServer() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 5);
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    Ping ping = connection.ping();
+    assertTrue(ping.roundTripTime() > 0);
+    assertTrue(ping.roundTripTime() < TimeUnit.SECONDS.toNanos(1));
+
+    // verify the peer received what was expected
+    InFrame pingFrame = peer.takeFrame();
+    assertEquals(Http2.TYPE_PING, pingFrame.type);
+    assertEquals(1, pingFrame.payload1);
+    assertEquals(new Buffer().writeUtf8("OKok").readInt(), pingFrame.payload2);
+    assertFalse(pingFrame.ack);
+  }
+
+  @Test public void unexpectedPingIsNotReturned() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.sendFrame().ping(false, 2, 0);
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 3, 0); // This ping will not be returned.
+    peer.sendFrame().ping(false, 4, 0);
+    peer.acceptFrame(); // PING
+    peer.play();
+
+    // play it back
+    connect(peer);
+
+    // verify the peer received what was expected
+    InFrame ping2 = peer.takeFrame();
+    assertEquals(2, ping2.payload1);
+    InFrame ping4 = peer.takeFrame();
+    assertEquals(4, ping4.payload1);
+  }
+
+  @Test public void serverSendsSettingsToClient() throws Exception {
+    // write the mocking script
+    final Settings settings = new Settings();
+    settings.set(MAX_CONCURRENT_STREAMS, 10);
+    peer.sendFrame().settings(settings);
+    peer.acceptFrame(); // ACK
+    peer.sendFrame().ping(false, 2, 0);
+    peer.acceptFrame(); // PING
+    peer.play();
+
+    // play it back
+    final CountDownLatch maxConcurrentStreamsUpdated = new CountDownLatch(1);
+    final AtomicInteger maxConcurrentStreams = new AtomicInteger();
+    Http2Connection.Listener listener = new Http2Connection.Listener() {
+      @Override public void onStream(Http2Stream stream) throws IOException {
+        throw new AssertionError();
+      }
+
+      @Override public void onSettings(Http2Connection connection) {
+        maxConcurrentStreams.set(connection.maxConcurrentStreams());
+        maxConcurrentStreamsUpdated.countDown();
+      }
+    };
+    Http2Connection connection = connect(peer, IGNORE, listener);
+
+    synchronized (connection) {
+      assertEquals(10, connection.peerSettings.getMaxConcurrentStreams(-1));
+    }
+    maxConcurrentStreamsUpdated.await();
+    assertEquals(10, maxConcurrentStreams.get());
+  }
+
+  @Test public void multipleSettingsFramesAreMerged() throws Exception {
+    // write the mocking script
+    Settings settings1 = new Settings();
+    settings1.set(HEADER_TABLE_SIZE, 10000);
+    settings1.set(INITIAL_WINDOW_SIZE, 20000);
+    settings1.set(MAX_FRAME_SIZE, 30000);
+    peer.sendFrame().settings(settings1);
+    peer.acceptFrame(); // ACK SETTINGS
+    Settings settings2 = new Settings();
+    settings2.set(INITIAL_WINDOW_SIZE, 40000);
+    settings2.set(MAX_FRAME_SIZE, 50000);
+    settings2.set(MAX_CONCURRENT_STREAMS, 60000);
+    peer.sendFrame().settings(settings2);
+    peer.acceptFrame(); // ACK SETTINGS
+    peer.sendFrame().ping(false, 2, 0);
+    peer.acceptFrame(); // PING
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+
+    assertEquals(Http2.TYPE_SETTINGS, peer.takeFrame().type);
+    assertEquals(Http2.TYPE_PING, peer.takeFrame().type);
+    synchronized (connection) {
+      assertEquals(10000, connection.peerSettings.getHeaderTableSize());
+      assertEquals(40000, connection.peerSettings.getInitialWindowSize());
+      assertEquals(50000, connection.peerSettings.getMaxFrameSize(-1));
+      assertEquals(60000, connection.peerSettings.getMaxConcurrentStreams(-1));
+    }
+  }
+
+  @Test public void clearSettingsBeforeMerge() throws Exception {
+    // write the mocking script
+    Settings settings1 = new Settings();
+    settings1.set(HEADER_TABLE_SIZE, 10000);
+    settings1.set(INITIAL_WINDOW_SIZE, 20000);
+    settings1.set(MAX_FRAME_SIZE, 30000);
+    peer.sendFrame().settings(settings1);
+    peer.acceptFrame(); // ACK
+    peer.sendFrame().ping(false, 2, 0);
+    peer.acceptFrame();
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+
+    // fake a settings frame with clear flag set.
+    Settings settings2 = new Settings();
+    settings2.set(MAX_CONCURRENT_STREAMS, 60000);
+    connection.readerRunnable.settings(true, settings2);
+
+    synchronized (connection) {
+      assertEquals(-1, connection.peerSettings.getHeaderTableSize());
+      assertEquals(DEFAULT_INITIAL_WINDOW_SIZE, connection.peerSettings.getInitialWindowSize());
+      assertEquals(-1, connection.peerSettings.getMaxFrameSize(-1));
+      assertEquals(60000, connection.peerSettings.getMaxConcurrentStreams(-1));
+    }
+  }
+
+  @Test public void bogusDataFrameDoesNotDisruptConnection() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.sendFrame().data(true, 41, new Buffer().writeUtf8("bogus"), 5);
+    peer.acceptFrame(); // RST_STREAM
+    peer.sendFrame().ping(false, 2, 0);
+    peer.acceptFrame(); // PING
+    peer.play();
+
+    // play it back
+    connect(peer);
+
+    // verify the peer received what was expected
+    InFrame rstStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_RST_STREAM, rstStream.type);
+    assertEquals(41, rstStream.streamId);
+    assertEquals(ErrorCode.PROTOCOL_ERROR, rstStream.errorCode);
+    InFrame ping = peer.takeFrame();
+    assertEquals(2, ping.payload1);
+  }
+
+  @Test public void bogusReplySilentlyIgnored() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.sendFrame().synReply(false, 41, headerEntries("a", "android"));
+    peer.sendFrame().ping(false, 2, 0);
+    peer.acceptFrame(); // PING
+    peer.play();
+
+    // play it back
+    connect(peer);
+
+    // verify the peer received what was expected
+    InFrame ping = peer.takeFrame();
+    assertEquals(2, ping.payload1);
+  }
+
+  @Test public void serverClosesClientOutputStream() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().rstStream(3, ErrorCode.CANCEL);
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 0);
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    Http2Stream stream = connection.newStream(headerEntries("a", "android"), true);
+    BufferedSink out = Okio.buffer(stream.getSink());
+    connection.ping().roundTripTime(); // Ensure that the RST_CANCEL has been received.
+    try {
+      out.writeUtf8("square");
+      out.flush();
+      fail();
+    } catch (IOException expected) {
+      assertEquals("stream was reset: CANCEL", expected.getMessage());
+    }
+    try {
+      out.close();
+      fail();
+    } catch (IOException expected) {
+      // Close throws because buffered data wasn't flushed.
+    }
+    assertEquals(0, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    InFrame synStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    assertFalse(synStream.inFinished);
+    assertFalse(synStream.outFinished);
+    InFrame ping = peer.takeFrame();
+    assertEquals(Http2.TYPE_PING, ping.type);
+    assertEquals(1, ping.payload1);
+  }
+
+  /**
+   * Test that the client sends a RST_STREAM if doing so won't disrupt the output stream.
+   */
+  @Test public void clientClosesClientInputStream() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.acceptFrame(); // RST_STREAM
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    Http2Stream stream = connection.newStream(headerEntries("a", "android"), false);
+    Source in = stream.getSource();
+    BufferedSink out = Okio.buffer(stream.getSink());
+    in.close();
+    try {
+      in.read(new Buffer(), 1);
+      fail();
+    } catch (IOException expected) {
+      assertEquals("stream closed", expected.getMessage());
+    }
+    try {
+      out.writeUtf8("a");
+      out.flush();
+      fail();
+    } catch (IOException expected) {
+      assertEquals("stream finished", expected.getMessage());
+    }
+    assertEquals(0, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    InFrame synStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    assertTrue(synStream.inFinished);
+    assertFalse(synStream.outFinished);
+    InFrame rstStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_RST_STREAM, rstStream.type);
+    assertEquals(ErrorCode.CANCEL, rstStream.errorCode);
+  }
+
+  /**
+   * Test that the client doesn't send a RST_STREAM if doing so will disrupt the output stream.
+   */
+  @Test public void clientClosesClientInputStreamIfOutputStreamIsClosed() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.acceptFrame(); // DATA
+    peer.acceptFrame(); // DATA with FLAG_FIN
+    peer.acceptFrame(); // RST_STREAM
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    Http2Stream stream = connection.newStream(headerEntries("a", "android"), true);
+    Source source = stream.getSource();
+    BufferedSink out = Okio.buffer(stream.getSink());
+    source.close();
+    try {
+      source.read(new Buffer(), 1);
+      fail();
+    } catch (IOException expected) {
+      assertEquals("stream closed", expected.getMessage());
+    }
+    out.writeUtf8("square");
+    out.flush();
+    out.close();
+    assertEquals(0, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    InFrame synStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    assertFalse(synStream.inFinished);
+    assertFalse(synStream.outFinished);
+    InFrame data = peer.takeFrame();
+    assertEquals(Http2.TYPE_DATA, data.type);
+    assertTrue(Arrays.equals("square".getBytes("UTF-8"), data.data));
+    InFrame fin = peer.takeFrame();
+    assertEquals(Http2.TYPE_DATA, fin.type);
+    assertTrue(fin.inFinished);
+    assertFalse(fin.outFinished);
+    InFrame rstStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_RST_STREAM, rstStream.type);
+    assertEquals(ErrorCode.CANCEL, rstStream.errorCode);
+  }
+
+  @Test public void serverClosesClientInputStream() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("b", "banana"));
+    peer.sendFrame().data(true, 3, new Buffer().writeUtf8("square"), 6);
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 0);
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    Http2Stream stream = connection.newStream(headerEntries("a", "android"), false);
+    Source source = stream.getSource();
+    assertStreamData("square", source);
+    connection.ping().roundTripTime(); // Ensure that inFinished has been received.
+    assertEquals(0, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    InFrame synStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    assertTrue(synStream.inFinished);
+    assertFalse(synStream.outFinished);
+  }
+
+  @Test public void remoteDoubleSynReply() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.acceptFrame(); // PING
+    peer.sendFrame().synReply(false, 3, headerEntries("b", "banana"));
+    peer.sendFrame().ping(true, 1, 0);
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    Http2Stream stream = connection.newStream(headerEntries("c", "cola"), false);
+    assertEquals(headerEntries("a", "android"), stream.takeResponseHeaders());
+    connection.ping().roundTripTime(); // Ensure that the 2nd SYN REPLY has been received.
+
+    // verify the peer received what was expected
+    InFrame synStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    InFrame ping = peer.takeFrame();
+    assertEquals(Http2.TYPE_PING, ping.type);
+  }
+
+  @Test public void remoteSendsDataAfterInFinished() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().data(true, 3, new Buffer().writeUtf8("robot"), 5);
+    peer.sendFrame().data(true, 3, new Buffer().writeUtf8("c3po"), 4);
+    peer.acceptFrame(); // RST_STREAM
+    peer.sendFrame().ping(false, 2, 0); // Ping just to make sure the stream was fastforwarded.
+    peer.acceptFrame(); // PING
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
+    assertEquals(headerEntries("a", "android"), stream.takeResponseHeaders());
+    assertStreamData("robot", stream.getSource());
+
+    // verify the peer received what was expected
+    InFrame synStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    InFrame rstStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_RST_STREAM, rstStream.type);
+    assertEquals(3, rstStream.streamId);
+    InFrame ping = peer.takeFrame();
+    assertEquals(Http2.TYPE_PING, ping.type);
+    assertEquals(2, ping.payload1);
+  }
+
+  @Test public void clientDoesNotLimitFlowControl() throws Exception {
+    int dataLength = 16384;
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("b", "banana"));
+    peer.sendFrame().data(false, 3, new Buffer().write(new byte[dataLength]), dataLength);
+    peer.sendFrame().data(false, 3, new Buffer().write(new byte[dataLength]), dataLength);
+    peer.sendFrame().data(false, 3, new Buffer().write(new byte[dataLength]), dataLength);
+    peer.sendFrame().data(false, 3, new Buffer().write(new byte[dataLength]), dataLength);
+    peer.sendFrame().data(false, 3, new Buffer().write(new byte[1]), 1);
+    peer.sendFrame().ping(false, 2, 0); // Ping just to make sure the stream was fastforwarded.
+    peer.acceptFrame(); // PING
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    Http2Stream stream = connection.newStream(headerEntries("a", "android"), false);
+    assertEquals(headerEntries("b", "banana"), stream.takeResponseHeaders());
+
+    // verify the peer received what was expected
+    InFrame synStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    InFrame ping = peer.takeFrame();
+    assertEquals(Http2.TYPE_PING, ping.type);
+    assertEquals(2, ping.payload1);
+  }
+
+  @Test public void remoteSendsRefusedStreamBeforeReplyHeaders() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().rstStream(3, ErrorCode.REFUSED_STREAM);
+    peer.sendFrame().ping(false, 2, 0);
+    peer.acceptFrame(); // PING
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    Http2Stream stream = connection.newStream(headerEntries("a", "android"), false);
+    try {
+      stream.takeResponseHeaders();
+      fail();
+    } catch (IOException expected) {
+      assertEquals("stream was reset: REFUSED_STREAM", expected.getMessage());
+    }
+    assertEquals(0, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    InFrame synStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    InFrame ping = peer.takeFrame();
+    assertEquals(Http2.TYPE_PING, ping.type);
+    assertEquals(2, ping.payload1);
+  }
+
+  @Test public void receiveGoAway() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM 1
+    peer.acceptFrame(); // SYN_STREAM 3
+    peer.acceptFrame(); // PING.
+    peer.sendFrame().goAway(3, ErrorCode.PROTOCOL_ERROR, Util.EMPTY_BYTE_ARRAY);
+    peer.sendFrame().ping(true, 1, 0);
+    peer.acceptFrame(); // DATA STREAM 1
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    Http2Stream stream1 = connection.newStream(headerEntries("a", "android"), true);
+    Http2Stream stream2 = connection.newStream(headerEntries("b", "banana"), true);
+    connection.ping().roundTripTime(); // Ensure the GO_AWAY that resets stream2 has been received.
+    BufferedSink sink1 = Okio.buffer(stream1.getSink());
+    BufferedSink sink2 = Okio.buffer(stream2.getSink());
+    sink1.writeUtf8("abc");
+    try {
+      sink2.writeUtf8("abc");
+      sink2.flush();
+      fail();
+    } catch (IOException expected) {
+      assertEquals("stream was reset: REFUSED_STREAM", expected.getMessage());
+    }
+    sink1.writeUtf8("def");
+    sink1.close();
+    try {
+      connection.newStream(headerEntries("c", "cola"), false);
+      fail();
+    } catch (ConnectionShutdownException expected) {
+    }
+    assertTrue(stream1.isOpen());
+    assertFalse(stream2.isOpen());
+    assertEquals(1, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    InFrame synStream1 = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream1.type);
+    InFrame synStream2 = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream2.type);
+    InFrame ping = peer.takeFrame();
+    assertEquals(Http2.TYPE_PING, ping.type);
+    InFrame data1 = peer.takeFrame();
+    assertEquals(Http2.TYPE_DATA, data1.type);
+    assertEquals(3, data1.streamId);
+    assertTrue(Arrays.equals("abcdef".getBytes("UTF-8"), data1.data));
+  }
+
+  @Test public void sendGoAway() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM 1
+    peer.acceptFrame(); // GOAWAY
+    peer.acceptFrame(); // PING
+    peer.sendFrame().synStream(false, 2, 0, headerEntries("b", "b")); // Should be ignored!
+    peer.sendFrame().ping(true, 1, 0);
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    connection.newStream(headerEntries("a", "android"), false);
+    Ping ping = connection.ping();
+    connection.shutdown(ErrorCode.PROTOCOL_ERROR);
+    assertEquals(1, connection.openStreamCount());
+    ping.roundTripTime(); // Prevent the peer from exiting prematurely.
+
+    // verify the peer received what was expected
+    InFrame synStream1 = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream1.type);
+    InFrame pingFrame = peer.takeFrame();
+    assertEquals(Http2.TYPE_PING, pingFrame.type);
+    InFrame goaway = peer.takeFrame();
+    assertEquals(Http2.TYPE_GOAWAY, goaway.type);
+    assertEquals(0, goaway.streamId);
+    assertEquals(ErrorCode.PROTOCOL_ERROR, goaway.errorCode);
+  }
+
+  @Test public void noPingsAfterShutdown() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // GOAWAY
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    connection.shutdown(ErrorCode.INTERNAL_ERROR);
+    try {
+      connection.ping();
+      fail();
+    } catch (ConnectionShutdownException expected) {
+    }
+
+    // verify the peer received what was expected
+    InFrame goaway = peer.takeFrame();
+    assertEquals(Http2.TYPE_GOAWAY, goaway.type);
+    assertEquals(ErrorCode.INTERNAL_ERROR, goaway.errorCode);
+  }
+
+  @Test public void close() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.acceptFrame(); // GOAWAY
+    peer.acceptFrame(); // RST_STREAM
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    Http2Stream stream = connection.newStream(headerEntries("a", "android"), false);
+    assertEquals(1, connection.openStreamCount());
+    connection.close();
+    assertEquals(0, connection.openStreamCount());
+    try {
+      connection.newStream(headerEntries("b", "banana"), false);
+      fail();
+    } catch (ConnectionShutdownException expected) {
+    }
+    BufferedSink sink = Okio.buffer(stream.getSink());
+    try {
+      sink.writeByte(0);
+      sink.flush();
+      fail();
+    } catch (IOException expected) {
+      assertEquals("stream finished", expected.getMessage());
+    }
+    try {
+      stream.getSource().read(new Buffer(), 1);
+      fail();
+    } catch (IOException expected) {
+      assertEquals("stream was reset: CANCEL", expected.getMessage());
+    }
+
+    // verify the peer received what was expected
+    InFrame synStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    InFrame goaway = peer.takeFrame();
+    assertEquals(Http2.TYPE_GOAWAY, goaway.type);
+    InFrame rstStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_RST_STREAM, rstStream.type);
+    assertEquals(3, rstStream.streamId);
+  }
+
+  @Test public void closeCancelsPings() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // PING
+    peer.acceptFrame(); // GOAWAY
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    Ping ping = connection.ping();
+    connection.close();
+    assertEquals(-1, ping.roundTripTime());
+  }
+
+  @Test public void getResponseHeadersTimesOut() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.acceptFrame(); // RST_STREAM
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
+    stream.readTimeout().timeout(500, TimeUnit.MILLISECONDS);
+    long startNanos = System.nanoTime();
+    try {
+      stream.takeResponseHeaders();
+      fail();
+    } catch (InterruptedIOException expected) {
+    }
+    long elapsedNanos = System.nanoTime() - startNanos;
+    awaitWatchdogIdle();
+    assertEquals(500d, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 200d /* 200ms delta */);
+    assertEquals(0, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    assertEquals(Http2.TYPE_HEADERS, peer.takeFrame().type);
+    assertEquals(Http2.TYPE_RST_STREAM, peer.takeFrame().type);
+  }
+
+  @Test public void readTimesOut() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.acceptFrame(); // RST_STREAM
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
+    stream.readTimeout().timeout(500, TimeUnit.MILLISECONDS);
+    Source source = stream.getSource();
+    long startNanos = System.nanoTime();
+    try {
+      source.read(new Buffer(), 1);
+      fail();
+    } catch (InterruptedIOException expected) {
+    }
+    long elapsedNanos = System.nanoTime() - startNanos;
+    awaitWatchdogIdle();
+    assertEquals(500d, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 200d /* 200ms delta */);
+    assertEquals(0, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    assertEquals(Http2.TYPE_HEADERS, peer.takeFrame().type);
+    assertEquals(Http2.TYPE_RST_STREAM, peer.takeFrame().type);
+  }
+
+  @Test public void writeTimesOutAwaitingStreamWindow() throws Exception {
+    // Set the peer's receive window to 5 bytes!
+    Settings peerSettings = new Settings().set(INITIAL_WINDOW_SIZE, 5);
+
+    // write the mocking script
+    peer.sendFrame().settings(peerSettings);
+    peer.acceptFrame(); // ACK SETTINGS
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 0);
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.acceptFrame(); // DATA
+    peer.acceptFrame(); // RST_STREAM
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    connection.ping().roundTripTime(); // Make sure settings have been received.
+    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
+    Sink sink = stream.getSink();
+    sink.write(new Buffer().writeUtf8("abcde"), 5);
+    stream.writeTimeout().timeout(500, TimeUnit.MILLISECONDS);
+    long startNanos = System.nanoTime();
+    sink.write(new Buffer().writeUtf8("f"), 1);
+    try {
+      sink.flush(); // This will time out waiting on the write window.
+      fail();
+    } catch (InterruptedIOException expected) {
+    }
+    long elapsedNanos = System.nanoTime() - startNanos;
+    awaitWatchdogIdle();
+    assertEquals(500d, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 200d /* 200ms delta */);
+    assertEquals(0, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    assertEquals(Http2.TYPE_PING, peer.takeFrame().type);
+    assertEquals(Http2.TYPE_HEADERS, peer.takeFrame().type);
+    assertEquals(Http2.TYPE_DATA, peer.takeFrame().type);
+    assertEquals(Http2.TYPE_RST_STREAM, peer.takeFrame().type);
+  }
+
+  @Test public void writeTimesOutAwaitingConnectionWindow() throws Exception {
+    // Set the peer's receive window to 5 bytes. Give the stream 5 bytes back, so only the
+    // connection-level window is applicable.
+    Settings peerSettings = new Settings().set(INITIAL_WINDOW_SIZE, 5);
+
+    // write the mocking script
+    peer.sendFrame().settings(peerSettings);
+    peer.acceptFrame(); // ACK SETTINGS
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 0);
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().windowUpdate(3, 5);
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 3, 0);
+    peer.acceptFrame(); // DATA
+    peer.acceptFrame(); // RST_STREAM
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    connection.ping().roundTripTime(); // Make sure settings have been acked.
+    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
+    connection.ping().roundTripTime(); // Make sure the window update has been received.
+    Sink sink = stream.getSink();
+    stream.writeTimeout().timeout(500, TimeUnit.MILLISECONDS);
+    sink.write(new Buffer().writeUtf8("abcdef"), 6);
+    long startNanos = System.nanoTime();
+    try {
+      sink.flush(); // This will time out waiting on the write window.
+      fail();
+    } catch (InterruptedIOException expected) {
+    }
+    long elapsedNanos = System.nanoTime() - startNanos;
+    awaitWatchdogIdle();
+    assertEquals(500d, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 200d /* 200ms delta */);
+    assertEquals(0, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    assertEquals(Http2.TYPE_PING, peer.takeFrame().type);
+    assertEquals(Http2.TYPE_HEADERS, peer.takeFrame().type);
+    assertEquals(Http2.TYPE_PING, peer.takeFrame().type);
+    assertEquals(Http2.TYPE_DATA, peer.takeFrame().type);
+    assertEquals(Http2.TYPE_RST_STREAM, peer.takeFrame().type);
+  }
+
+  @Test public void outgoingWritesAreBatched() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.acceptFrame(); // DATA
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
+
+    // two outgoing writes
+    Sink sink = stream.getSink();
+    sink.write(new Buffer().writeUtf8("abcde"), 5);
+    sink.write(new Buffer().writeUtf8("fghij"), 5);
+    sink.close();
+
+    // verify the peer received one incoming frame
+    assertEquals(Http2.TYPE_HEADERS, peer.takeFrame().type);
+    InFrame data = peer.takeFrame();
+    assertEquals(Http2.TYPE_DATA, data.type);
+    assertTrue(Arrays.equals("abcdefghij".getBytes("UTF-8"), data.data));
+    assertTrue(data.inFinished);
+  }
+
+  @Test public void headers() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.acceptFrame(); // PING
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().headers(3, headerEntries("c", "c3po"));
+    peer.sendFrame().ping(true, 1, 0);
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
+    connection.ping().roundTripTime(); // Ensure that the HEADERS has been received.
+    assertEquals(Arrays.asList(new Header("a", "android"), null, new Header("c", "c3po")),
+        stream.takeResponseHeaders());
+
+    // verify the peer received what was expected
+    InFrame synStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    InFrame ping = peer.takeFrame();
+    assertEquals(Http2.TYPE_PING, ping.type);
+  }
+
+  @Test public void readMultipleSetsOfResponseHeaders() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 0); // PING
+    peer.sendFrame().synReply(true, 3, headerEntries("c", "cola"));
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
+    stream.getConnection().flush();
+    assertEquals(headerEntries("a", "android"), stream.takeResponseHeaders());
+    connection.ping().roundTripTime();
+    assertEquals(headerEntries("c", "cola"), stream.takeResponseHeaders());
+
+    // verify the peer received what was expected
+    assertEquals(Http2.TYPE_HEADERS, peer.takeFrame().type);
+    assertEquals(Http2.TYPE_PING, peer.takeFrame().type);
+  }
+
+  @Test public void readSendsWindowUpdate() throws Exception {
+    int windowSize = 100;
+    int windowUpdateThreshold = 50;
+
+    // Write the mocking script.
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    for (int i = 0; i < 3; i++) {
+      // Send frames of summing to size 50, which is windowUpdateThreshold.
+      peer.sendFrame().data(false, 3, data(24), 24);
+      peer.sendFrame().data(false, 3, data(25), 25);
+      peer.sendFrame().data(false, 3, data(1), 1);
+      peer.acceptFrame(); // connection WINDOW UPDATE
+      peer.acceptFrame(); // stream WINDOW UPDATE
+    }
+    peer.sendFrame().data(true, 3, data(0), 0);
+    peer.play();
+
+    // Play it back.
+    Http2Connection connection = connect(peer);
+    connection.okHttpSettings.set(INITIAL_WINDOW_SIZE, windowSize);
+    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
+    assertEquals(0, stream.unacknowledgedBytesRead);
+    assertEquals(headerEntries("a", "android"), stream.takeResponseHeaders());
+    Source in = stream.getSource();
+    Buffer buffer = new Buffer();
+    buffer.writeAll(in);
+    assertEquals(-1, in.read(buffer, 1));
+    assertEquals(150, buffer.size());
+
+    InFrame synStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    for (int i = 0; i < 3; i++) {
+      List<Integer> windowUpdateStreamIds = new ArrayList<>(2);
+      for (int j = 0; j < 2; j++) {
+        InFrame windowUpdate = peer.takeFrame();
+        assertEquals(Http2.TYPE_WINDOW_UPDATE, windowUpdate.type);
+        windowUpdateStreamIds.add(windowUpdate.streamId);
+        assertEquals(windowUpdateThreshold, windowUpdate.windowSizeIncrement);
+      }
+      assertTrue(windowUpdateStreamIds.contains(0)); // connection
+      assertTrue(windowUpdateStreamIds.contains(3)); // stream
+    }
+  }
+
+  @Test public void serverSendsEmptyDataClientDoesntSendWindowUpdate() throws Exception {
+    // Write the mocking script.
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().data(true, 3, data(0), 0);
+    peer.play();
+
+    // Play it back.
+    Http2Connection connection = connect(peer);
+    Http2Stream client = connection.newStream(headerEntries("b", "banana"), false);
+    assertEquals(-1, client.getSource().read(new Buffer(), 1));
+
+    // Verify the peer received what was expected.
+    InFrame synStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    assertEquals(5, peer.frameCount());
+  }
+
+  @Test public void clientSendsEmptyDataServerDoesntSendWindowUpdate() throws Exception {
+    // Write the mocking script.
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.acceptFrame(); // DATA
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.play();
+
+    // Play it back.
+    Http2Connection connection = connect(peer);
+    Http2Stream client = connection.newStream(headerEntries("b", "banana"), true);
+    BufferedSink out = Okio.buffer(client.getSink());
+    out.write(Util.EMPTY_BYTE_ARRAY);
+    out.flush();
+    out.close();
+
+    // Verify the peer received what was expected.
+    assertEquals(Http2.TYPE_HEADERS, peer.takeFrame().type);
+    assertEquals(Http2.TYPE_DATA, peer.takeFrame().type);
+    assertEquals(5, peer.frameCount());
+  }
+
+  @Test public void testTruncatedDataFrame() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().data(false, 3, data(1024), 1024);
+    peer.truncateLastFrame(8 + 100);
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
+    assertEquals(headerEntries("a", "android"), stream.takeResponseHeaders());
+    Source in = stream.getSource();
+    try {
+      Okio.buffer(in).readByteString(101);
+      fail();
+    } catch (IOException expected) {
+      assertEquals("stream was reset: PROTOCOL_ERROR", expected.getMessage());
+    }
+  }
+
+  @Test public void blockedStreamDoesntStarveNewStream() throws Exception {
+    int framesThatFillWindow = roundUp(DEFAULT_INITIAL_WINDOW_SIZE, peer.maxOutboundDataLength());
+
+    // Write the mocking script. This accepts more data frames than necessary!
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // SETTINGS ACK
+    peer.acceptFrame(); // SYN_STREAM on stream 1
+    for (int i = 0; i < framesThatFillWindow; i++) {
+      peer.acceptFrame(); // DATA on stream 1
+    }
+    peer.acceptFrame(); // SYN_STREAM on stream 2
+    peer.acceptFrame(); // DATA on stream 2
+    peer.play();
+
+    // Play it back.
+    Http2Connection connection = connect(peer);
+    Http2Stream stream1 = connection.newStream(headerEntries("a", "apple"), true);
+    BufferedSink out1 = Okio.buffer(stream1.getSink());
+    out1.write(new byte[DEFAULT_INITIAL_WINDOW_SIZE]);
+    out1.flush();
+
+    // Check that we've filled the window for both the stream and also the connection.
+    assertEquals(0, connection.bytesLeftInWriteWindow);
+    assertEquals(0, connection.getStream(3).bytesLeftInWriteWindow);
+
+    // receiving a window update on the connection will unblock new streams.
+    connection.readerRunnable.windowUpdate(0, 3);
+
+    assertEquals(3, connection.bytesLeftInWriteWindow);
+    assertEquals(0, connection.getStream(3).bytesLeftInWriteWindow);
+
+    // Another stream should be able to send data even though 1 is blocked.
+    Http2Stream stream2 = connection.newStream(headerEntries("b", "banana"), true);
+    BufferedSink out2 = Okio.buffer(stream2.getSink());
+    out2.writeUtf8("foo");
+    out2.flush();
+
+    assertEquals(0, connection.bytesLeftInWriteWindow);
+    assertEquals(0, connection.getStream(3).bytesLeftInWriteWindow);
+    assertEquals(DEFAULT_INITIAL_WINDOW_SIZE - 3, connection.getStream(5).bytesLeftInWriteWindow);
+  }
+
+  @Test public void remoteOmitsInitialSettings() throws Exception {
+    // Write the mocking script. Note no SETTINGS frame is sent or acknowledged.
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.acceptFrame(); // GOAWAY
+    peer.play();
+
+    Http2Connection connection = new Http2Connection.Builder(true)
+        .socket(peer.openSocket())
+        .build();
+    connection.start(false);
+
+    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
+    try {
+      stream.takeResponseHeaders();
+      fail();
+    } catch (IOException expected) {
+      assertEquals("stream was reset: PROTOCOL_ERROR", expected.getMessage());
+    }
+
+    // verify the peer received what was expected
+    InFrame synStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    InFrame goaway = peer.takeFrame();
+    assertEquals(Http2.TYPE_GOAWAY, goaway.type);
+    assertEquals(ErrorCode.PROTOCOL_ERROR, goaway.errorCode);
+  }
+
+  private Buffer data(int byteCount) {
+    return new Buffer().write(new byte[byteCount]);
+  }
+
+  private void assertStreamData(String expected, Source source) throws IOException {
+    String actual = Okio.buffer(source).readUtf8();
+    assertEquals(expected, actual);
+  }
+
+  /**
+   * Returns true when all work currently in progress by the watchdog have completed. This method
+   * creates more work for the watchdog and waits for that work to be executed. When it is, we know
+   * work that preceded this call is complete.
+   */
+  private void awaitWatchdogIdle() throws InterruptedException {
+    final CountDownLatch latch = new CountDownLatch(1);
+    AsyncTimeout watchdogJob = new AsyncTimeout() {
+      @Override protected void timedOut() {
+        latch.countDown();
+      }
+    };
+    watchdogJob.deadlineNanoTime(System.nanoTime()); // Due immediately!
+    watchdogJob.enter();
+    latch.await();
+  }
+
+  static int roundUp(int num, int divisor) {
+    return (num + divisor - 1) / divisor;
+  }
+
+  private Http2Connection connectWithSettings(boolean client, Settings settings) throws Exception {
+    peer.setClient(client);
+    peer.sendFrame().settings(settings);
+    peer.acceptFrame(); // ACK
+    peer.play();
+    return connect(peer);
+  }
+
+  private Http2Connection connect(MockHttp2Peer peer) throws Exception {
+    return connect(peer, IGNORE, REFUSE_INCOMING_STREAMS);
+  }
+
+  /** Builds a new connection to {@code peer} with settings acked. */
+  private Http2Connection connect(MockHttp2Peer peer, PushObserver pushObserver,
+      Http2Connection.Listener listener) throws Exception {
+    Http2Connection connection = new Http2Connection.Builder(true)
+        .socket(peer.openSocket())
+        .pushObserver(pushObserver)
+        .listener(listener)
+        .build();
+    connection.start(false);
+
+    // verify the peer received the ACK
+    InFrame ackFrame = peer.takeFrame();
+    assertEquals(Http2.TYPE_SETTINGS, ackFrame.type);
+    assertEquals(0, ackFrame.streamId);
+    assertTrue(ackFrame.ack);
+
+    return connection;
+  }
+
+  static final PushObserver IGNORE = new PushObserver() {
+
+    @Override public boolean onRequest(int streamId, List<Header> requestHeaders) {
+      return false;
+    }
+
+    @Override public boolean onHeaders(int streamId, List<Header> responseHeaders, boolean last) {
+      return false;
+    }
+
+    @Override public boolean onData(int streamId, BufferedSource source, int byteCount,
+        boolean last) throws IOException {
+      source.skip(byteCount);
+      return false;
+    }
+
+    @Override public void onReset(int streamId, ErrorCode errorCode) {
+    }
+  };
+
+  private static class RecordingPushObserver implements PushObserver {
+    final List<Object> events = new ArrayList<>();
+
+    public synchronized Object takeEvent() throws InterruptedException {
+      while (events.isEmpty()) {
+        wait();
+      }
+      return events.remove(0);
+    }
+
+    @Override public synchronized boolean onRequest(int streamId, List<Header> requestHeaders) {
+      assertEquals(2, streamId);
+      events.add(requestHeaders);
+      notifyAll();
+      return false;
+    }
+
+    @Override public synchronized boolean onHeaders(
+        int streamId, List<Header> responseHeaders, boolean last) {
+      assertEquals(2, streamId);
+      assertTrue(last);
+      events.add(responseHeaders);
+      notifyAll();
+      return false;
+    }
+
+    @Override public synchronized boolean onData(
+        int streamId, BufferedSource source, int byteCount, boolean last) {
+      events.add(new AssertionError("onData"));
+      notifyAll();
+      return false;
+    }
+
+    @Override public synchronized void onReset(int streamId, ErrorCode errorCode) {
+      events.add(new AssertionError("onReset"));
+      notifyAll();
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/framed/Http2Test.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2Test.java
similarity index 84%
rename from okhttp-tests/src/test/java/okhttp3/internal/framed/Http2Test.java
rename to okhttp-tests/src/test/java/okhttp3/internal/http2/Http2Test.java
index 0ae2f31c78..24ec759c2d 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/framed/Http2Test.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2Test.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.framed;
+package okhttp3.internal.http2;
 
 import java.io.IOException;
 import java.util.Arrays;
@@ -29,20 +29,20 @@
 import org.junit.Test;
 
 import static okhttp3.TestUtil.headerEntries;
-import static okhttp3.internal.framed.Http2.FLAG_COMPRESSED;
-import static okhttp3.internal.framed.Http2.FLAG_END_HEADERS;
-import static okhttp3.internal.framed.Http2.FLAG_END_STREAM;
-import static okhttp3.internal.framed.Http2.FLAG_NONE;
-import static okhttp3.internal.framed.Http2.FLAG_PADDED;
-import static okhttp3.internal.framed.Http2.FLAG_PRIORITY;
+import static okhttp3.internal.http2.Http2.FLAG_COMPRESSED;
+import static okhttp3.internal.http2.Http2.FLAG_END_HEADERS;
+import static okhttp3.internal.http2.Http2.FLAG_END_STREAM;
+import static okhttp3.internal.http2.Http2.FLAG_NONE;
+import static okhttp3.internal.http2.Http2.FLAG_PADDED;
+import static okhttp3.internal.http2.Http2.FLAG_PRIORITY;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
-public class Http2Test {
+public final class Http2Test {
   final Buffer frame = new Buffer();
-  final FrameReader fr = new Http2.Reader(frame, 4096, false);
+  final Http2Reader reader = new Http2Reader(frame, false);
   final int expectedStreamId = 15;
 
   @Test public void unknownFrameTypeSkipped() throws IOException {
@@ -52,7 +52,7 @@
     frame.writeInt(expectedStreamId);
     frame.writeInt(111111111); // custom data
 
-    fr.nextFrame(new BaseTestHandler()); // Should not callback.
+    reader.nextFrame(false, new BaseTestHandler()); // Should not callback.
   }
 
   @Test public void onlyOneLiteralHeadersFrame() throws IOException {
@@ -67,16 +67,13 @@
 
     assertEquals(frame, sendHeaderFrames(true, sentHeaders)); // Check writer sends the same bytes.
 
-    fr.nextFrame(new BaseTestHandler() {
-      @Override
-      public void headers(boolean outFinished, boolean inFinished, int streamId,
-          int associatedStreamId, List<Header> headerBlock, HeadersMode headersMode) {
-        assertFalse(outFinished);
+    reader.nextFrame(false, new BaseTestHandler() {
+      @Override public void headers(boolean inFinished, int streamId,
+          int associatedStreamId, List<Header> headerBlock) {
         assertTrue(inFinished);
         assertEquals(expectedStreamId, streamId);
         assertEquals(-1, associatedStreamId);
         assertEquals(sentHeaders, headerBlock);
-        assertEquals(HeadersMode.HTTP_20_HEADERS, headersMode);
       }
     });
   }
@@ -93,7 +90,7 @@ public void headers(boolean outFinished, boolean inFinished, int streamId,
     frame.writeByte(255); // Heaviest weight, zero-indexed.
     frame.writeAll(headerBytes);
 
-    fr.nextFrame(new BaseTestHandler() {
+    reader.nextFrame(false, new BaseTestHandler() {
       @Override public void priority(int streamId, int streamDependency, int weight,
           boolean exclusive) {
         assertEquals(0, streamDependency);
@@ -101,15 +98,12 @@ public void headers(boolean outFinished, boolean inFinished, int streamId,
         assertFalse(exclusive);
       }
 
-      @Override public void headers(boolean outFinished, boolean inFinished, int streamId,
-          int associatedStreamId, List<Header> nameValueBlock,
-          HeadersMode headersMode) {
-        assertFalse(outFinished);
+      @Override public void headers(boolean inFinished, int streamId,
+          int associatedStreamId, List<Header> nameValueBlock) {
         assertFalse(inFinished);
         assertEquals(expectedStreamId, streamId);
         assertEquals(-1, associatedStreamId);
         assertEquals(sentHeaders, nameValueBlock);
-        assertEquals(HeadersMode.HTTP_20_HEADERS, headersMode);
       }
     });
   }
@@ -137,15 +131,13 @@ public void headers(boolean outFinished, boolean inFinished, int streamId,
     assertEquals(frame, sendHeaderFrames(false, sentHeaders)); // Check writer sends the same bytes.
 
     // Reading the above frames should result in a concatenated headerBlock.
-    fr.nextFrame(new BaseTestHandler() {
-      @Override public void headers(boolean outFinished, boolean inFinished, int streamId,
-          int associatedStreamId, List<Header> headerBlock, HeadersMode headersMode) {
-        assertFalse(outFinished);
+    reader.nextFrame(false, new BaseTestHandler() {
+      @Override public void headers(boolean inFinished, int streamId,
+          int associatedStreamId, List<Header> headerBlock) {
         assertFalse(inFinished);
         assertEquals(expectedStreamId, streamId);
         assertEquals(-1, associatedStreamId);
         assertEquals(sentHeaders, headerBlock);
-        assertEquals(HeadersMode.HTTP_20_HEADERS, headersMode);
       }
     });
   }
@@ -171,7 +163,7 @@ public void headers(boolean outFinished, boolean inFinished, int streamId,
 
     assertEquals(frame, sendPushPromiseFrames(expectedPromisedStreamId, pushPromise));
 
-    fr.nextFrame(new BaseTestHandler() {
+    reader.nextFrame(false, new BaseTestHandler() {
       @Override
       public void pushPromise(int streamId, int promisedStreamId, List<Header> headerBlock) {
         assertEquals(expectedStreamId, streamId);
@@ -207,7 +199,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     assertEquals(frame, sendPushPromiseFrames(expectedPromisedStreamId, pushPromise));
 
     // Reading the above frames should result in a concatenated headerBlock.
-    fr.nextFrame(new BaseTestHandler() {
+    reader.nextFrame(false, new BaseTestHandler() {
       @Override
       public void pushPromise(int streamId, int promisedStreamId, List<Header> headerBlock) {
         assertEquals(expectedStreamId, streamId);
@@ -222,12 +214,12 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.writeByte(Http2.TYPE_RST_STREAM);
     frame.writeByte(Http2.FLAG_NONE);
     frame.writeInt(expectedStreamId & 0x7fffffff);
-    frame.writeInt(ErrorCode.COMPRESSION_ERROR.httpCode);
+    frame.writeInt(ErrorCode.PROTOCOL_ERROR.httpCode);
 
-    fr.nextFrame(new BaseTestHandler() {
+    reader.nextFrame(false, new BaseTestHandler() {
       @Override public void rstStream(int streamId, ErrorCode errorCode) {
         assertEquals(expectedStreamId, streamId);
-        assertEquals(ErrorCode.COMPRESSION_ERROR, errorCode);
+        assertEquals(ErrorCode.PROTOCOL_ERROR, errorCode);
       }
     });
   }
@@ -244,7 +236,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.writeShort(2); // SETTINGS_ENABLE_PUSH
     frame.writeInt(0);
 
-    fr.nextFrame(new BaseTestHandler() {
+    reader.nextFrame(false, new BaseTestHandler() {
       @Override public void settings(boolean clearPrevious, Settings settings) {
         assertFalse(clearPrevious); // No clearPrevious in HTTP/2.
         assertEquals(reducedTableSizeBytes, settings.getHeaderTableSize());
@@ -262,7 +254,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.writeInt(2);
 
     try {
-      fr.nextFrame(new BaseTestHandler());
+      reader.nextFrame(false, new BaseTestHandler());
       fail();
     } catch (IOException e) {
       assertEquals("PROTOCOL_ERROR SETTINGS_ENABLE_PUSH != 0 or 1", e.getMessage());
@@ -278,7 +270,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.writeInt(1);
 
     final AtomicInteger settingValue = new AtomicInteger();
-    fr.nextFrame(new BaseTestHandler() {
+    reader.nextFrame(false, new BaseTestHandler() {
       @Override public void settings(boolean clearPrevious, Settings settings) {
         settingValue.set(settings.get(7));
       }
@@ -286,6 +278,21 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     assertEquals(settingValue.intValue(), 1);
   }
 
+  @Test public void readSettingsFrameExperimentalId() throws IOException {
+    writeMedium(frame, 6); // 2 for the code and 4 for the value
+    frame.writeByte(Http2.TYPE_SETTINGS);
+    frame.writeByte(Http2.FLAG_NONE);
+    frame.writeInt(0); // Settings are always on the connection stream 0.
+    frame.write(ByteString.decodeHex("f000")); // Id reserved for experimental use.
+    frame.writeInt(1);
+
+    reader.nextFrame(false, new BaseTestHandler() {
+      @Override public void settings(boolean clearPrevious, Settings settings) {
+        // no-op
+      }
+    });
+  }
+
   @Test public void readSettingsFrameNegativeWindowSize() throws IOException {
     writeMedium(frame, 6); // 2 for the code and 4 for the value
     frame.writeByte(Http2.TYPE_SETTINGS);
@@ -295,7 +302,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.writeInt(Integer.MIN_VALUE);
 
     try {
-      fr.nextFrame(new BaseTestHandler());
+      reader.nextFrame(false, new BaseTestHandler());
       fail();
     } catch (IOException e) {
       assertEquals("PROTOCOL_ERROR SETTINGS_INITIAL_WINDOW_SIZE > 2^31 - 1", e.getMessage());
@@ -311,7 +318,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.writeInt(Integer.MIN_VALUE);
 
     try {
-      fr.nextFrame(new BaseTestHandler());
+      reader.nextFrame(false, new BaseTestHandler());
       fail();
     } catch (IOException e) {
       assertEquals("PROTOCOL_ERROR SETTINGS_MAX_FRAME_SIZE: -2147483648", e.getMessage());
@@ -327,7 +334,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.writeInt((int) Math.pow(2, 14) - 1);
 
     try {
-      fr.nextFrame(new BaseTestHandler());
+      reader.nextFrame(false, new BaseTestHandler());
       fail();
     } catch (IOException e) {
       assertEquals("PROTOCOL_ERROR SETTINGS_MAX_FRAME_SIZE: 16383", e.getMessage());
@@ -343,7 +350,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.writeInt((int) Math.pow(2, 24));
 
     try {
-      fr.nextFrame(new BaseTestHandler());
+      reader.nextFrame(false, new BaseTestHandler());
       fail();
     } catch (IOException e) {
       assertEquals("PROTOCOL_ERROR SETTINGS_MAX_FRAME_SIZE: 16777216", e.getMessage());
@@ -364,7 +371,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     // Check writer sends the same bytes.
     assertEquals(frame, sendPingFrame(true, expectedPayload1, expectedPayload2));
 
-    fr.nextFrame(new BaseTestHandler() {
+    reader.nextFrame(false, new BaseTestHandler() {
       @Override public void ping(boolean ack, int payload1, int payload2) {
         assertTrue(ack);
         assertEquals(expectedPayload1, payload1);
@@ -386,7 +393,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     // Check writer sends the same bytes.
     assertEquals(frame, sendDataFrame(new Buffer().write(expectedData)));
 
-    fr.nextFrame(new BaseTestHandler() {
+    reader.nextFrame(false, new BaseTestHandler() {
       @Override public void data(boolean inFinished, int streamId, BufferedSource source,
           int length) throws IOException {
         assertFalse(inFinished);
@@ -400,6 +407,23 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     });
   }
 
+  @Test public void dataFrameNotAssociateWithStream() throws IOException {
+    byte[] payload = new byte[] {0x01, 0x02};
+
+    writeMedium(frame, payload.length);
+    frame.writeByte(Http2.TYPE_DATA);
+    frame.writeByte(Http2.FLAG_NONE);
+    frame.writeInt(0);
+    frame.write(payload);
+
+    try {
+      reader.nextFrame(false, new BaseTestHandler());
+      fail();
+    } catch (IOException e) {
+      assertEquals("PROTOCOL_ERROR: TYPE_DATA streamId == 0", e.getMessage());
+    }
+  }
+
   /** We do not send SETTINGS_COMPRESS_DATA = 1, nor want to. Let's make sure we error. */
   @Test public void compressedDataFrameWhenSettingDisabled() throws IOException {
     byte[] expectedData = new byte[Http2.INITIAL_MAX_FRAME_SIZE];
@@ -414,7 +438,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     zipped.readAll(frame);
 
     try {
-      fr.nextFrame(new BaseTestHandler());
+      reader.nextFrame(false, new BaseTestHandler());
       fail();
     } catch (IOException e) {
       assertEquals("PROTOCOL_ERROR: FLAG_COMPRESSED without SETTINGS_COMPRESS_DATA",
@@ -439,7 +463,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.write(expectedData);
     frame.write(padding);
 
-    fr.nextFrame(assertData());
+    reader.nextFrame(false, assertData());
     assertTrue(frame.exhausted()); // Padding was skipped.
   }
 
@@ -455,7 +479,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.writeByte(0);
     frame.write(expectedData);
 
-    fr.nextFrame(assertData());
+    reader.nextFrame(false, assertData());
   }
 
   @Test public void readPaddedHeadersFrame() throws IOException {
@@ -472,7 +496,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.writeAll(headerBlock);
     frame.write(padding);
 
-    fr.nextFrame(assertHeaderBlock());
+    reader.nextFrame(false, assertHeaderBlock());
     assertTrue(frame.exhausted()); // Padding was skipped.
   }
 
@@ -485,7 +509,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.writeByte(0);
     frame.writeAll(headerBlock);
 
-    fr.nextFrame(assertHeaderBlock());
+    reader.nextFrame(false, assertHeaderBlock());
   }
 
   /** Headers are compressed, then framed. */
@@ -513,7 +537,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.writeInt(expectedStreamId & 0x7fffffff);
     frame.writeAll(headerBlock);
 
-    fr.nextFrame(assertHeaderBlock());
+    reader.nextFrame(false, assertHeaderBlock());
     assertTrue(frame.exhausted());
   }
 
@@ -538,7 +562,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     // Check writer sends the same bytes.
     assertEquals(frame, windowUpdate(expectedWindowSizeIncrement));
 
-    fr.nextFrame(new BaseTestHandler() {
+    reader.nextFrame(false, new BaseTestHandler() {
       @Override public void windowUpdate(int streamId, long windowSizeIncrement) {
         assertEquals(expectedStreamId, streamId);
         assertEquals(expectedWindowSizeIncrement, windowSizeIncrement);
@@ -576,7 +600,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     // Check writer sends the same bytes.
     assertEquals(frame, sendGoAway(expectedStreamId, expectedError, Util.EMPTY_BYTE_ARRAY));
 
-    fr.nextFrame(new BaseTestHandler() {
+    reader.nextFrame(false, new BaseTestHandler() {
       @Override public void goAway(
           int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {
         assertEquals(expectedStreamId, lastGoodStreamId);
@@ -602,7 +626,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     // Check writer sends the same bytes.
     assertEquals(frame, sendGoAway(0, expectedError, expectedData.toByteArray()));
 
-    fr.nextFrame(new BaseTestHandler() {
+    reader.nextFrame(false, new BaseTestHandler() {
       @Override public void goAway(
           int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {
         assertEquals(0, lastGoodStreamId);
@@ -613,7 +637,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
   }
 
   @Test public void frameSizeError() throws IOException {
-    Http2.Writer writer = new Http2.Writer(new Buffer(), true);
+    Http2Writer writer = new Http2Writer(new Buffer(), true);
 
     try {
       writer.frameHeader(0, 16777216, Http2.TYPE_DATA, FLAG_NONE);
@@ -627,16 +651,16 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
   @Test public void ackSettingsAppliesMaxFrameSize() throws IOException {
     int newMaxFrameSize = 16777215;
 
-    Http2.Writer writer = new Http2.Writer(new Buffer(), true);
+    Http2Writer writer = new Http2Writer(new Buffer(), true);
 
-    writer.ackSettings(new Settings().set(Settings.MAX_FRAME_SIZE, 0, newMaxFrameSize));
+    writer.applyAndAckSettings(new Settings().set(Settings.MAX_FRAME_SIZE, newMaxFrameSize));
 
     assertEquals(newMaxFrameSize, writer.maxDataLength());
     writer.frameHeader(0, newMaxFrameSize, Http2.TYPE_DATA, FLAG_NONE);
   }
 
   @Test public void streamIdHasReservedBit() throws IOException {
-    Http2.Writer writer = new Http2.Writer(new Buffer(), true);
+    Http2Writer writer = new Http2Writer(new Buffer(), true);
 
     try {
       int streamId = 3;
@@ -656,57 +680,55 @@ private Buffer literalHeaders(List<Header> sentHeaders) throws IOException {
 
   private Buffer sendHeaderFrames(boolean outFinished, List<Header> headers) throws IOException {
     Buffer out = new Buffer();
-    new Http2.Writer(out, true).headers(outFinished, expectedStreamId, headers);
+    new Http2Writer(out, true).headers(outFinished, expectedStreamId, headers);
     return out;
   }
 
   private Buffer sendPushPromiseFrames(int streamId, List<Header> headers) throws IOException {
     Buffer out = new Buffer();
-    new Http2.Writer(out, true).pushPromise(expectedStreamId, streamId, headers);
+    new Http2Writer(out, true).pushPromise(expectedStreamId, streamId, headers);
     return out;
   }
 
   private Buffer sendPingFrame(boolean ack, int payload1, int payload2) throws IOException {
     Buffer out = new Buffer();
-    new Http2.Writer(out, true).ping(ack, payload1, payload2);
+    new Http2Writer(out, true).ping(ack, payload1, payload2);
     return out;
   }
 
   private Buffer sendGoAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData)
       throws IOException {
     Buffer out = new Buffer();
-    new Http2.Writer(out, true).goAway(lastGoodStreamId, errorCode, debugData);
+    new Http2Writer(out, true).goAway(lastGoodStreamId, errorCode, debugData);
     return out;
   }
 
   private Buffer sendDataFrame(Buffer data) throws IOException {
     Buffer out = new Buffer();
-    new Http2.Writer(out, true).dataFrame(expectedStreamId, FLAG_NONE, data,
+    new Http2Writer(out, true).dataFrame(expectedStreamId, FLAG_NONE, data,
         (int) data.size());
     return out;
   }
 
   private Buffer windowUpdate(long windowSizeIncrement) throws IOException {
     Buffer out = new Buffer();
-    new Http2.Writer(out, true).windowUpdate(expectedStreamId, windowSizeIncrement);
+    new Http2Writer(out, true).windowUpdate(expectedStreamId, windowSizeIncrement);
     return out;
   }
 
-  private FrameReader.Handler assertHeaderBlock() {
+  private Http2Reader.Handler assertHeaderBlock() {
     return new BaseTestHandler() {
-      @Override public void headers(boolean outFinished, boolean inFinished, int streamId,
-          int associatedStreamId, List<Header> headerBlock, HeadersMode headersMode) {
-        assertFalse(outFinished);
+      @Override public void headers(boolean inFinished, int streamId,
+          int associatedStreamId, List<Header> headerBlock) {
         assertFalse(inFinished);
         assertEquals(expectedStreamId, streamId);
         assertEquals(-1, associatedStreamId);
         assertEquals(headerEntries("foo", "barrr", "baz", "qux"), headerBlock);
-        assertEquals(HeadersMode.HTTP_20_HEADERS, headersMode);
       }
     };
   }
 
-  private FrameReader.Handler assertData() {
+  private Http2Reader.Handler assertData() {
     return new BaseTestHandler() {
       @Override public void data(boolean inFinished, int streamId, BufferedSource source,
           int length) throws IOException {
@@ -727,7 +749,7 @@ private static Buffer gzip(byte[] data) throws IOException {
     return buffer;
   }
 
-  /** Create a sufficiently large header set to overflow Http20Draft12.INITIAL_MAX_FRAME_SIZE bytes. */
+  /** Create a sufficiently large header set to overflow INITIAL_MAX_FRAME_SIZE bytes. */
   private static List<Header> largeHeaders() {
     String[] nameValues = new String[32];
     char[] chars = new char[512];
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/framed/HttpOverSpdyTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
similarity index 51%
rename from okhttp-tests/src/test/java/okhttp3/internal/framed/HttpOverSpdyTest.java
rename to okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
index da09b4c91d..4e9267eae3 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/framed/HttpOverSpdyTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
@@ -13,22 +13,30 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.framed;
+package okhttp3.internal.http2;
 
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.Authenticator;
 import java.net.HttpURLConnection;
 import java.net.SocketTimeoutException;
+import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
+import java.util.concurrent.SynchronousQueue;
 import javax.net.ssl.HostnameVerifier;
 import okhttp3.Cache;
 import okhttp3.Call;
+import okhttp3.Callback;
 import okhttp3.Cookie;
 import okhttp3.Credentials;
+import okhttp3.Headers;
+import okhttp3.Interceptor;
 import okhttp3.MediaType;
 import okhttp3.OkHttpClient;
 import okhttp3.Protocol;
@@ -37,17 +45,25 @@
 import okhttp3.Request;
 import okhttp3.RequestBody;
 import okhttp3.Response;
+import okhttp3.Route;
+import okhttp3.TestUtil;
 import okhttp3.internal.DoubleInetAddressDns;
 import okhttp3.internal.RecordingOkAuthenticator;
 import okhttp3.internal.SingleInetAddressDns;
+import okhttp3.internal.SocketRecorder;
 import okhttp3.internal.Util;
+import okhttp3.internal.connection.RealConnection;
 import okhttp3.internal.tls.SslClient;
+import okhttp3.mockwebserver.Dispatcher;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.PushPromise;
+import okhttp3.mockwebserver.QueueDispatcher;
 import okhttp3.mockwebserver.RecordedRequest;
 import okhttp3.mockwebserver.SocketPolicy;
 import okio.Buffer;
 import okio.BufferedSink;
+import okio.BufferedSource;
 import okio.GzipSink;
 import okio.Okio;
 import org.junit.After;
@@ -59,34 +75,28 @@
 
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static java.util.concurrent.TimeUnit.SECONDS;
+import static okhttp3.TestUtil.defaultClient;
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
-/** Test how SPDY interacts with HTTP features. */
-public abstract class HttpOverSpdyTest {
+/** Test how SPDY interacts with HTTP/2 features. */
+public final class HttpOverHttp2Test {
   @Rule public final TemporaryFolder tempDir = new TemporaryFolder();
   @Rule public final MockWebServer server = new MockWebServer();
 
-  /** Protocol to test, for example {@link Protocol#SPDY_3} */
-  private final Protocol protocol;
-  protected String hostHeader = ":host";
-
-  protected SslClient sslClient = SslClient.localhost();
-  protected HostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-  protected OkHttpClient client;
-  protected Cache cache;
-
-  protected HttpOverSpdyTest(Protocol protocol) {
-    this.protocol = protocol;
-  }
+  private SslClient sslClient = SslClient.localhost();
+  private HostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
+  private OkHttpClient client;
+  private Cache cache;
 
   @Before public void setUp() throws Exception {
     server.useHttps(sslClient.socketFactory, false);
     cache = new Cache(tempDir.getRoot(), Integer.MAX_VALUE);
-    client = new OkHttpClient.Builder()
-        .protocols(Arrays.asList(protocol, Protocol.HTTP_1_1))
+    client = defaultClient().newBuilder()
+        .protocols(Arrays.asList(Protocol.HTTP_2, Protocol.HTTP_1_1))
         .dns(new SingleInetAddressDns())
         .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
         .hostnameVerifier(hostnameVerifier)
@@ -109,12 +119,12 @@ protected HttpOverSpdyTest(Protocol protocol) {
 
     assertEquals("ABCDE", response.body().string());
     assertEquals(200, response.code());
-    assertEquals("Sweet", response.message());
+    assertEquals("", response.message());
 
     RecordedRequest request = server.takeRequest();
     assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
     assertEquals("https", request.getHeader(":scheme"));
-    assertEquals(server.getHostName() + ":" + server.getPort(), request.getHeader(hostHeader));
+    assertEquals(server.getHostName() + ":" + server.getPort(), request.getHeader(":authority"));
   }
 
   @Test public void emptyResponse() throws IOException {
@@ -129,9 +139,9 @@ protected HttpOverSpdyTest(Protocol protocol) {
     response.body().close();
   }
 
-  byte[] postBytes = "FGHIJ".getBytes(Util.UTF_8);
-
   @Test public void noDefaultContentLengthOnStreamingPost() throws Exception {
+    final byte[] postBytes = "FGHIJ".getBytes(Util.UTF_8);
+
     server.enqueue(new MockResponse().setBody("ABCDE"));
 
     Call call = client.newCall(new Request.Builder()
@@ -157,6 +167,8 @@ protected HttpOverSpdyTest(Protocol protocol) {
   }
 
   @Test public void userSuppliedContentLengthHeader() throws Exception {
+    final byte[] postBytes = "FGHIJ".getBytes(Util.UTF_8);
+
     server.enqueue(new MockResponse().setBody("ABCDE"));
 
     Call call = client.newCall(new Request.Builder()
@@ -186,6 +198,8 @@ protected HttpOverSpdyTest(Protocol protocol) {
   }
 
   @Test public void closeAfterFlush() throws Exception {
+    final byte[] postBytes = "FGHIJ".getBytes(Util.UTF_8);
+
     server.enqueue(new MockResponse().setBody("ABCDE"));
 
     Call call = client.newCall(new Request.Builder()
@@ -200,9 +214,9 @@ protected HttpOverSpdyTest(Protocol protocol) {
           }
 
           @Override public void writeTo(BufferedSink sink) throws IOException {
-            sink.write(postBytes);  // push bytes into SpdyDataOutputStream.buffer
-            sink.flush(); // FramedConnection.writeData subject to write window
-            sink.close(); // FramedConnection.writeData empty frame
+            sink.write(postBytes);  // push bytes into the stream's buffer
+            sink.flush(); // Http2Connection.writeData subject to write window
+            sink.close(); // Http2Connection.writeData empty frame
           }
         })
         .build());
@@ -216,7 +230,7 @@ protected HttpOverSpdyTest(Protocol protocol) {
     assertEquals(postBytes.length, Integer.parseInt(request.getHeader("Content-Length")));
   }
 
-  @Test public void spdyConnectionReuse() throws Exception {
+  @Test public void connectionReuse() throws Exception {
     server.enqueue(new MockResponse().setBody("ABCDEF"));
     server.enqueue(new MockResponse().setBody("GHIJKL"));
 
@@ -235,16 +249,20 @@ protected HttpOverSpdyTest(Protocol protocol) {
     assertEquals("JKL", response2.body().source().readUtf8(3));
     assertEquals(0, server.takeRequest().getSequenceNumber());
     assertEquals(1, server.takeRequest().getSequenceNumber());
+
+    response1.close();
+    response2.close();
   }
 
-  @Test @Ignore public void synchronousSpdyRequest() throws Exception {
+  /** https://github.com/square/okhttp/issues/373 */
+  @Test @Ignore public void synchronousRequest() throws Exception {
     server.enqueue(new MockResponse().setBody("A"));
     server.enqueue(new MockResponse().setBody("A"));
 
     ExecutorService executor = Executors.newCachedThreadPool();
     CountDownLatch countDownLatch = new CountDownLatch(2);
-    executor.execute(new SpdyRequest("/r1", countDownLatch));
-    executor.execute(new SpdyRequest("/r2", countDownLatch));
+    executor.execute(new AsyncRequest("/r1", countDownLatch));
+    executor.execute(new AsyncRequest("/r2", countDownLatch));
     countDownLatch.await();
     assertEquals(0, server.takeRequest().getSequenceNumber());
     assertEquals(1, server.takeRequest().getSequenceNumber());
@@ -322,10 +340,11 @@ protected HttpOverSpdyTest(Protocol protocol) {
     assertEquals('C', in.read());
     assertEquals(-1, in.read());
     assertEquals(-1, in.read());
+
+    in.close();
   }
 
-  @Ignore // See https://github.com/square/okhttp/issues/578
-  @Test(timeout = 3000) public void readResponseHeaderTimeout() throws Exception {
+  @Test public void readResponseHeaderTimeout() throws Exception {
     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.NO_RESPONSE));
     server.enqueue(new MockResponse().setBody("A"));
 
@@ -333,11 +352,27 @@ protected HttpOverSpdyTest(Protocol protocol) {
         .readTimeout(1000, MILLISECONDS)
         .build();
 
-    Call call = client.newCall(new Request.Builder()
+    // Make a call expecting a timeout reading the response headers.
+    Call call1 = client.newCall(new Request.Builder()
         .url(server.url("/"))
         .build());
-    Response response = call.execute();
-    assertEquals("A", response.body().string());
+    try {
+      call1.execute();
+      fail("Should have timed out!");
+    } catch (SocketTimeoutException expected) {
+      assertEquals("timeout", expected.getMessage());
+    }
+
+    // Confirm that a subsequent request on the same connection is not impacted.
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+    assertEquals("A", response2.body().string());
+
+    // Confirm that the connection was reused.
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
   }
 
   /**
@@ -370,30 +405,42 @@ protected HttpOverSpdyTest(Protocol protocol) {
    * time.
    */
   @Test public void readTimeoutOnSlowConnection() throws Exception {
-    char[] body = new char[2048]; // 2KiB to read.
-    Arrays.fill(body, 'y');
+    String body = TestUtil.repeat('y', 2048);
     server.enqueue(new MockResponse()
-        .setBody(new String(body))
+        .setBody(body)
         .throttleBody(1024, 1, SECONDS)); // Slow connection 1KiB/second.
+    server.enqueue(new MockResponse()
+        .setBody(body));
 
     client = client.newBuilder()
         .readTimeout(500, MILLISECONDS) // Half a second to read something.
         .build();
 
-    Call call = client.newCall(new Request.Builder()
+    // Make a call expecting a timeout reading the response body.
+    Call call1 = client.newCall(new Request.Builder()
         .url(server.url("/"))
         .build());
-    Response response = call.execute();
-
+    Response response1 = call1.execute();
     try {
-      response.body().string();
+      response1.body().string();
       fail("Should have timed out!");
     } catch (SocketTimeoutException expected) {
       assertEquals("timeout", expected.getMessage());
     }
+
+    // Confirm that a subsequent request on the same connection is not impacted.
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+    assertEquals(body, response2.body().string());
+
+    // Confirm that the connection was reused.
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
   }
 
-  @Test public void spdyConnectionTimeout() throws Exception {
+  @Test public void connectionTimeout() throws Exception {
     server.enqueue(new MockResponse()
         .setBody("A")
         .setBodyDelay(1, SECONDS));
@@ -422,6 +469,10 @@ protected HttpOverSpdyTest(Protocol protocol) {
       fail();
     } catch (IOException expected) {
     }
+
+    // Confirm that the connection was reused.
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
   }
 
   @Test public void responsesAreCached() throws IOException {
@@ -561,7 +612,12 @@ protected HttpOverSpdyTest(Protocol protocol) {
   }
 
   /** https://github.com/square/okhttp/issues/1191 */
+  @Ignore // TODO: recover gracefully when a connection is shutdown.
   @Test public void cancelWithStreamNotCompleted() throws Exception {
+    // Ensure that the (shared) connection pool is in a consistent state.
+    client.connectionPool().evictAll();
+    assertEquals(0, client.connectionPool().connectionCount());
+
     server.enqueue(new MockResponse()
         .setBody("abc"));
     server.enqueue(new MockResponse()
@@ -571,7 +627,7 @@ protected HttpOverSpdyTest(Protocol protocol) {
     Call call1 = client.newCall(new Request.Builder()
         .url(server.url("/"))
         .build());
-    call1.execute();
+    Response response = call1.execute();
     call1.cancel();
 
     // That connection is pooled, and it works.
@@ -582,6 +638,9 @@ protected HttpOverSpdyTest(Protocol protocol) {
     Response response2 = call2.execute();
     assertEquals("def", response2.body().string());
     assertEquals(0, server.takeRequest().getSequenceNumber());
+
+    // Clean up the connection.
+    response.close();
   }
 
   @Test public void recoverFromOneRefusedStreamReusesConnection() throws Exception {
@@ -677,6 +736,74 @@ private void noRecoveryFromErrorWithRetryDisabled(ErrorCode errorCode) throws Ex
     }
   }
 
+  @Test public void recoverFromConnectionNoNewStreamsOnFollowUp() throws InterruptedException {
+    server.enqueue(new MockResponse()
+        .setResponseCode(401));
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.RESET_STREAM_AT_START)
+        .setHttp2ErrorCode(ErrorCode.CANCEL.httpCode));
+    server.enqueue(new MockResponse()
+        .setBody("DEF"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(301)
+        .addHeader("Location", "/foo"));
+    server.enqueue(new MockResponse()
+        .setBody("ABC"));
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    final BlockingQueue<String> responses = new SynchronousQueue<>();
+    okhttp3.Authenticator authenticator = new okhttp3.Authenticator() {
+      @Override public Request authenticate(Route route, Response response) throws IOException {
+        responses.offer(response.body().string());
+        try {
+          latch.await();
+        } catch (InterruptedException e) {
+          throw new AssertionError();
+        }
+        return response.request();
+      }
+    };
+
+    OkHttpClient blockingAuthClient = client.newBuilder()
+        .authenticator(authenticator)
+        .build();
+
+    Callback callback = new Callback() {
+      @Override public void onFailure(Call call, IOException e) {
+        fail();
+      }
+
+      @Override public void onResponse(Call call, Response response) throws IOException {
+        responses.offer(response.body().string());
+      }
+    };
+
+    // Make the first request waiting until we get our auth challenge.
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    blockingAuthClient.newCall(request).enqueue(callback);
+    String response1 = responses.take();
+    assertEquals("", response1);
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+
+    // Now make the second request which will restrict the first HTTP/2 connection from creating new
+    // streams.
+    client.newCall(request).enqueue(callback);
+    String response2 = responses.take();
+    assertEquals("DEF", response2);
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+
+    // Let the first request proceed. It should discard the the held HTTP/2 connection and get a new
+    // one.
+    latch.countDown();
+    String response3 = responses.take();
+    assertEquals("ABC", response3);
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+    assertEquals(2, server.takeRequest().getSequenceNumber());
+  }
+
   @Test public void nonAsciiResponseHeader() throws Exception {
     server.enqueue(new MockResponse()
         .addHeaderLenient("Alpha", "α")
@@ -686,11 +813,383 @@ private void noRecoveryFromErrorWithRetryDisabled(ErrorCode errorCode) throws Ex
         .url(server.url("/"))
         .build());
     Response response = call.execute();
+    response.close();
 
     assertEquals("α", response.header("Alpha"));
     assertEquals("Beta", response.header("β"));
   }
 
+  @Test public void serverSendsPushPromise_GET() throws Exception {
+    PushPromise pushPromise = new PushPromise("GET", "/foo/bar", Headers.of("foo", "bar"),
+        new MockResponse().setBody("bar").setStatus("HTTP/1.1 200 Sweet"));
+    server.enqueue(new MockResponse()
+        .setBody("ABCDE")
+        .setStatus("HTTP/1.1 200 Sweet")
+        .withPush(pushPromise));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/foo"))
+        .build());
+    Response response = call.execute();
+
+    assertEquals("ABCDE", response.body().string());
+    assertEquals(200, response.code());
+    assertEquals("", response.message());
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
+    assertEquals("https", request.getHeader(":scheme"));
+    assertEquals(server.getHostName() + ":" + server.getPort(), request.getHeader(":authority"));
+
+    RecordedRequest pushedRequest = server.takeRequest();
+    assertEquals("GET /foo/bar HTTP/1.1", pushedRequest.getRequestLine());
+    assertEquals("bar", pushedRequest.getHeader("foo"));
+  }
+
+  @Test public void serverSendsPushPromise_HEAD() throws Exception {
+    PushPromise pushPromise = new PushPromise("HEAD", "/foo/bar", Headers.of("foo", "bar"),
+        new MockResponse().setStatus("HTTP/1.1 204 Sweet"));
+    server.enqueue(new MockResponse()
+        .setBody("ABCDE")
+        .setStatus("HTTP/1.1 200 Sweet")
+        .withPush(pushPromise));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/foo"))
+        .build());
+    Response response = call.execute();
+    assertEquals("ABCDE", response.body().string());
+    assertEquals(200, response.code());
+    assertEquals("", response.message());
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
+    assertEquals("https", request.getHeader(":scheme"));
+    assertEquals(server.getHostName() + ":" + server.getPort(), request.getHeader(":authority"));
+
+    RecordedRequest pushedRequest = server.takeRequest();
+    assertEquals("HEAD /foo/bar HTTP/1.1", pushedRequest.getRequestLine());
+    assertEquals("bar", pushedRequest.getHeader("foo"));
+  }
+
+  @Test public void noDataFramesSentWithNullRequestBody() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("ABC"));
+
+    SocketRecorder socketRecorder = new SocketRecorder();
+    client = client.newBuilder()
+        .sslSocketFactory(socketRecorder.sslSocketFactory(sslClient.socketFactory),
+            sslClient.trustManager)
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .method("DELETE", null)
+        .build());
+    Response response = call.execute();
+    assertEquals("ABC", response.body().string());
+
+    // Replay the bytes written by the client to confirm no data frames were sent.
+    SocketRecorder.RecordedSocket recordedSocket = socketRecorder.takeSocket();
+    Buffer buffer = new Buffer();
+    buffer.write(recordedSocket.bytesWritten());
+
+    RecordingHandler handler = new RecordingHandler();
+    Http2Reader reader = new Http2Reader(buffer, false);
+    reader.readConnectionPreface(null);
+    while (reader.nextFrame(false, handler)) {
+    }
+
+    assertEquals(1, handler.headerFrameCount);
+    assertTrue(handler.dataFrames.isEmpty());
+  }
+
+  @Test public void emptyDataFrameSentWithEmptyBody() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("ABC"));
+
+    SocketRecorder socketRecorder = new SocketRecorder();
+    client = client.newBuilder()
+        .sslSocketFactory(socketRecorder.sslSocketFactory(sslClient.socketFactory),
+            sslClient.trustManager)
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .method("DELETE", Util.EMPTY_REQUEST)
+        .build());
+    Response response = call.execute();
+    assertEquals("ABC", response.body().string());
+
+    // Replay the bytes written by the client to confirm an empty data frame was sent.
+    SocketRecorder.RecordedSocket recordedSocket = socketRecorder.takeSocket();
+    Buffer buffer = new Buffer();
+    buffer.write(recordedSocket.bytesWritten());
+
+    RecordingHandler handler = new RecordingHandler();
+    Http2Reader reader = new Http2Reader(buffer, false);
+    reader.readConnectionPreface(null);
+    while (reader.nextFrame(false, handler)) {
+    }
+
+    assertEquals(1, handler.headerFrameCount);
+    assertEquals(Collections.singletonList(0), handler.dataFrames);
+  }
+
+  /**
+   * Push a setting that permits up to 2 concurrent streams, then make 3 concurrent requests and
+   * confirm that the third concurrent request prepared a new connection.
+   */
+  @Test public void settingsLimitsMaxConcurrentStreams() throws Exception {
+    Settings settings = new Settings();
+    settings.set(Settings.MAX_CONCURRENT_STREAMS, 2);
+
+    // Read & write a full request to confirm settings are accepted.
+    server.enqueue(new MockResponse().withSettings(settings));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals("", response.body().string());
+
+    server.enqueue(new MockResponse()
+        .setBody("ABC"));
+    server.enqueue(new MockResponse()
+        .setBody("DEF"));
+    server.enqueue(new MockResponse()
+        .setBody("GHI"));
+
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response1 = call1.execute();
+
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+
+    Call call3 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response3 = call3.execute();
+
+    assertEquals("ABC", response1.body().string());
+    assertEquals("DEF", response2.body().string());
+    assertEquals("GHI", response3.body().string());
+    assertEquals(0, server.takeRequest().getSequenceNumber()); // Settings connection.
+    assertEquals(1, server.takeRequest().getSequenceNumber()); // Reuse settings connection.
+    assertEquals(2, server.takeRequest().getSequenceNumber()); // Reuse settings connection.
+    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection!
+  }
+
+  @Test public void connectionNotReusedAfterShutdown() throws Exception {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
+        .setBody("ABC"));
+    server.enqueue(new MockResponse()
+        .setBody("DEF"));
+
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response1 = call1.execute();
+    assertEquals("ABC", response1.body().string());
+
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+    assertEquals("DEF", response2.body().string());
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+  }
+
+  /**
+   * This simulates a race condition where we receive a healthy HTTP/2 connection and just prior to
+   * writing our request, we get a GOAWAY frame from the server.
+   */
+  @Test public void connectionShutdownAfterHealthCheck() throws Exception {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
+        .setBody("ABC"));
+    server.enqueue(new MockResponse()
+        .setBody("DEF"));
+
+    OkHttpClient client2 = client.newBuilder()
+        .addNetworkInterceptor(new Interceptor() {
+          boolean executedCall;
+
+          @Override public Response intercept(Chain chain) throws IOException {
+            if (!executedCall) {
+              // At this point, we have a healthy HTTP/2 connection. This call will trigger the
+              // server to send a GOAWAY frame, leaving the connection in a shutdown state.
+              executedCall = true;
+              Call call = client.newCall(new Request.Builder()
+                  .url(server.url("/"))
+                  .build());
+              Response response = call.execute();
+              assertEquals("ABC", response.body().string());
+              // Wait until the GOAWAY has been processed.
+              RealConnection connection = (RealConnection) chain.connection();
+              while (connection.isHealthy(false)) ;
+            }
+            return chain.proceed(chain.request());
+          }
+        })
+        .build();
+
+    Call call = client2.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals("DEF", response.body().string());
+
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void responseHeadersAfterGoaway() throws Exception {
+    server.enqueue(new MockResponse()
+        .setHeadersDelay(1, SECONDS)
+        .setBody("ABC"));
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
+        .setBody("DEF"));
+
+    final BlockingQueue<String> bodies = new SynchronousQueue<>();
+    Callback callback = new Callback() {
+      @Override public void onResponse(Call call, Response response) throws IOException {
+        bodies.add(response.body().string());
+      }
+      @Override public void onFailure(Call call, IOException e) {
+        System.out.println(e);
+      }
+    };
+    client.newCall(new Request.Builder().url(server.url("/")).build()).enqueue(callback);
+    client.newCall(new Request.Builder().url(server.url("/")).build()).enqueue(callback);
+
+    assertEquals("DEF", bodies.poll(2, SECONDS));
+    assertEquals("ABC", bodies.poll(2, SECONDS));
+    assertEquals(2, server.getRequestCount());
+  }
+
+  /**
+   * We don't know if the connection will support HTTP/2 until after we've connected. When multiple
+   * connections are requested concurrently OkHttp will pessimistically connect multiple times, then
+   * close any unnecessary connections. This test confirms that behavior works as intended.
+   *
+   * <p>This test uses proxy tunnels to get a hook while a connection is being established.
+   */
+  @Test public void concurrentHttp2ConnectionsDeduplicated() throws Exception {
+    server.useHttps(sslClient.socketFactory, true);
+
+    // Force a fresh connection pool for the test.
+    client.connectionPool().evictAll();
+
+    final QueueDispatcher queueDispatcher = new QueueDispatcher();
+    queueDispatcher.enqueueResponse(new MockResponse()
+        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
+        .clearHeaders());
+    queueDispatcher.enqueueResponse(new MockResponse()
+        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
+        .clearHeaders());
+    queueDispatcher.enqueueResponse(new MockResponse()
+        .setBody("call2 response"));
+    queueDispatcher.enqueueResponse(new MockResponse()
+        .setBody("call1 response"));
+
+    // We use a re-entrant dispatcher to initiate one HTTPS connection while the other is in flight.
+    server.setDispatcher(new Dispatcher() {
+      int requestCount;
+
+      @Override public MockResponse dispatch(RecordedRequest request) throws InterruptedException {
+        MockResponse result = queueDispatcher.dispatch(request);
+
+        requestCount++;
+        if (requestCount == 1) {
+          // Before handling call1's CONNECT we do all of call2. This part re-entrant!
+          try {
+            Call call2 = client.newCall(new Request.Builder()
+                .url("https://android.com/call2")
+                .build());
+            Response response2 = call2.execute();
+            assertEquals("call2 response", response2.body().string());
+          } catch (IOException e) {
+            throw new RuntimeException(e);
+          }
+        }
+
+        return result;
+      }
+
+      @Override public MockResponse peek() {
+        return queueDispatcher.peek();
+      }
+
+      @Override public void shutdown() {
+        queueDispatcher.shutdown();
+      }
+    });
+
+    client = client.newBuilder()
+        .proxy(server.toProxyAddress())
+        .build();
+
+    Call call1 = client.newCall(new Request.Builder()
+        .url("https://android.com/call1")
+        .build());
+    Response response2 = call1.execute();
+    assertEquals("call1 response", response2.body().string());
+
+    RecordedRequest call1Connect = server.takeRequest();
+    assertEquals("CONNECT", call1Connect.getMethod());
+    assertEquals(0, call1Connect.getSequenceNumber());
+
+    RecordedRequest call2Connect = server.takeRequest();
+    assertEquals("CONNECT", call2Connect.getMethod());
+    assertEquals(0, call2Connect.getSequenceNumber());
+
+    RecordedRequest call2Get = server.takeRequest();
+    assertEquals("GET", call2Get.getMethod());
+    assertEquals("/call2", call2Get.getPath());
+    assertEquals(0, call2Get.getSequenceNumber());
+
+    RecordedRequest call1Get = server.takeRequest();
+    assertEquals("GET", call1Get.getMethod());
+    assertEquals("/call1", call1Get.getPath());
+    assertEquals(1, call1Get.getSequenceNumber());
+
+    assertEquals(1, client.connectionPool().connectionCount());
+  }
+
+  /** https://github.com/square/okhttp/issues/3103 */
+  @Test public void domainFronting() throws Exception {
+    client = client.newBuilder()
+        .addNetworkInterceptor(new Interceptor() {
+          @Override public Response intercept(Chain chain) throws IOException {
+            Request request = chain.request().newBuilder()
+                .header("Host", "privateobject.com")
+                .build();
+            return chain.proceed(request);
+          }
+        })
+        .build();
+
+    server.enqueue(new MockResponse());
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+
+    Response response = call.execute();
+    assertEquals("", response.body().string());
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("privateobject.com", recordedRequest.getHeader(":authority"));
+  }
+
   public Buffer gzip(String bytes) throws IOException {
     Buffer bytesOut = new Buffer();
     BufferedSink sink = Okio.buffer(new GzipSink(bytesOut));
@@ -699,11 +1198,11 @@ public Buffer gzip(String bytes) throws IOException {
     return bytesOut;
   }
 
-  class SpdyRequest implements Runnable {
+  class AsyncRequest implements Runnable {
     String path;
     CountDownLatch countDownLatch;
 
-    public SpdyRequest(String path, CountDownLatch countDownLatch) {
+    public AsyncRequest(String path, CountDownLatch countDownLatch) {
       this.path = path;
       this.countDownLatch = countDownLatch;
     }
@@ -721,4 +1220,28 @@ public SpdyRequest(String path, CountDownLatch countDownLatch) {
       }
     }
   }
+
+  static final class RecordingHandler extends BaseTestHandler {
+    int headerFrameCount;
+    final List<Integer> dataFrames = new ArrayList<>();
+
+    @Override public void settings(boolean clearPrevious, Settings settings) {
+    }
+
+    @Override public void ackSettings() {
+    }
+
+    @Override public void windowUpdate(int streamId, long windowSizeIncrement) {
+    }
+
+    @Override public void data(boolean inFinished, int streamId, BufferedSource source, int length)
+        throws IOException {
+      dataFrames.add(length);
+    }
+
+    @Override public void headers(boolean inFinished, int streamId, int associatedStreamId,
+        List<Header> headerBlock) {
+      headerFrameCount++;
+    }
+  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/framed/HuffmanTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/HuffmanTest.java
similarity index 61%
rename from okhttp-tests/src/test/java/okhttp3/internal/framed/HuffmanTest.java
rename to okhttp-tests/src/test/java/okhttp3/internal/http2/HuffmanTest.java
index b85a1b35b7..53642c0ea0 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/framed/HuffmanTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/HuffmanTest.java
@@ -13,43 +13,38 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.framed;
+package okhttp3.internal.http2;
 
-import java.io.ByteArrayOutputStream;
-import java.io.DataOutputStream;
 import java.io.IOException;
 import java.util.Arrays;
 import java.util.Random;
+import okio.Buffer;
+import okio.ByteString;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 
-/**
- * Original version of this class was lifted from {@code com.twitter.hpack.HuffmanTest}.
- */
-public class HuffmanTest {
-
+/** Original version of this class was lifted from {@code com.twitter.hpack.HuffmanTest}. */
+public final class HuffmanTest {
   @Test public void roundTripForRequestAndResponse() throws IOException {
     String s = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
     for (int i = 0; i < s.length(); i++) {
-      assertRoundTrip(s.substring(0, i).getBytes());
+      assertRoundTrip(ByteString.encodeUtf8(s.substring(0, i)));
     }
 
     Random random = new Random(123456789L);
     byte[] buf = new byte[4096];
     random.nextBytes(buf);
-    assertRoundTrip(buf);
+    assertRoundTrip(ByteString.of(buf));
   }
 
-  private void assertRoundTrip(byte[] buf) throws IOException {
-    ByteArrayOutputStream baos = new ByteArrayOutputStream();
-    DataOutputStream dos = new DataOutputStream(baos);
-
-    Huffman.get().encode(buf, dos);
-    assertEquals(baos.size(), Huffman.get().encodedLength(buf));
+  private void assertRoundTrip(ByteString data) throws IOException {
+    Buffer buffer = new Buffer();
+    Huffman.get().encode(data, buffer);
+    assertEquals(buffer.size(), Huffman.get().encodedLength(data));
 
-    byte[] decodedBytes = Huffman.get().decode(baos.toByteArray());
-    assertTrue(Arrays.equals(buf, decodedBytes));
+    byte[] decodedBytes = Huffman.get().decode(buffer.readByteArray());
+    assertTrue(Arrays.equals(data.toByteArray(), decodedBytes));
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/framed/MockSpdyPeer.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/MockHttp2Peer.java
similarity index 80%
rename from okhttp-tests/src/test/java/okhttp3/internal/framed/MockSpdyPeer.java
rename to okhttp-tests/src/test/java/okhttp3/internal/http2/MockHttp2Peer.java
index edc8f41c30..fe5f82fd4a 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/framed/MockSpdyPeer.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/MockHttp2Peer.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package okhttp3.internal.framed;
+package okhttp3.internal.http2;
 
 import java.io.Closeable;
 import java.io.IOException;
@@ -38,29 +38,27 @@
 import okio.Okio;
 
 /** Replays prerecorded outgoing frames and records incoming frames. */
-public final class MockSpdyPeer implements Closeable {
-  private static final Logger logger = Logger.getLogger(MockSpdyPeer.class.getName());
+public final class MockHttp2Peer implements Closeable {
+  private static final Logger logger = Logger.getLogger(MockHttp2Peer.class.getName());
 
   private int frameCount = 0;
   private boolean client = false;
-  private Variant variant = new Spdy3();
   private final Buffer bytesOut = new Buffer();
-  private FrameWriter frameWriter = variant.newWriter(bytesOut, client);
+  private Http2Writer writer = new Http2Writer(bytesOut, client);
   private final List<OutFrame> outFrames = new ArrayList<>();
   private final BlockingQueue<InFrame> inFrames = new LinkedBlockingQueue<>();
   private int port;
   private final ExecutorService executor = Executors.newSingleThreadExecutor(
-      Util.threadFactory("MockSpdyPeer", false));
+      Util.threadFactory("MockHttp2Peer", false));
   private ServerSocket serverSocket;
   private Socket socket;
 
-  public void setVariantAndClient(Variant variant, boolean client) {
-    if (this.variant.getProtocol() == variant.getProtocol() && this.client == client) {
+  public void setClient(boolean client) {
+    if (this.client == client) {
       return;
     }
     this.client = client;
-    this.variant = variant;
-    this.frameWriter = variant.newWriter(bytesOut, client);
+    this.writer = new Http2Writer(bytesOut, client);
   }
 
   public void acceptFrame() {
@@ -69,7 +67,7 @@ public void acceptFrame() {
 
   /** Maximum length of an outbound data frame. */
   public int maxOutboundDataLength() {
-    return frameWriter.maxDataLength();
+    return writer.maxDataLength();
   }
 
   /** Count of frames sent or received. */
@@ -77,18 +75,9 @@ public int frameCount() {
     return frameCount;
   }
 
-  public FrameWriter sendFrame() {
+  public Http2Writer sendFrame() {
     outFrames.add(new OutFrame(frameCount++, bytesOut.size(), false));
-    return frameWriter;
-  }
-
-  /**
-   * Sends a manually-constructed frame. This is useful to test frames that won't be generated
-   * naturally.
-   */
-  public void sendFrame(byte[] frame) throws IOException {
-    outFrames.add(new OutFrame(frameCount++, bytesOut.size(), false));
-    bytesOut.write(frame);
+    return writer;
   }
 
   /**
@@ -96,7 +85,7 @@ public void sendFrame(byte[] frame) throws IOException {
    * close the socket as soon as this frame has been written; otherwise the peer stays open until
    * explicitly closed.
    */
-  public FrameWriter truncateLastFrame(int length) {
+  public Http2Writer truncateLastFrame(int length) {
     OutFrame lastFrame = outFrames.remove(outFrames.size() - 1);
     if (length >= bytesOut.size() - lastFrame.start) throw new IllegalArgumentException();
 
@@ -108,7 +97,7 @@ public FrameWriter truncateLastFrame(int length) {
     fullBuffer.read(bytesOut, lastFrame.start + length);
 
     outFrames.add(new OutFrame(lastFrame.sequence, lastFrame.start, true));
-    return frameWriter;
+    return writer;
   }
 
   public InFrame takeFrame() throws InterruptedException {
@@ -126,8 +115,8 @@ public void play() throws IOException {
         try {
           readAndWriteFrames();
         } catch (IOException e) {
-          Util.closeQuietly(MockSpdyPeer.this);
-          logger.info(MockSpdyPeer.this + " done: " + e.getMessage());
+          Util.closeQuietly(MockHttp2Peer.this);
+          logger.info(MockHttp2Peer.this + " done: " + e.getMessage());
         }
       }
     });
@@ -147,7 +136,7 @@ private void readAndWriteFrames() throws IOException {
 
     OutputStream out = socket.getOutputStream();
     InputStream in = socket.getInputStream();
-    FrameReader reader = variant.newReader(Okio.buffer(Okio.source(in)), client);
+    Http2Reader reader = new Http2Reader(Okio.buffer(Okio.source(in)), client);
 
     Iterator<OutFrame> outFramesIterator = outFrames.iterator();
     byte[] outBytes = bytesOut.readByteArray();
@@ -182,7 +171,7 @@ private void readAndWriteFrames() throws IOException {
       } else {
         // read a frame
         InFrame inFrame = new InFrame(i, reader);
-        reader.nextFrame(inFrame);
+        reader.nextFrame(false, inFrame);
         inFrames.add(inFrame);
       }
     }
@@ -199,7 +188,7 @@ public Socket openSocket() throws IOException {
   }
 
   @Override public String toString() {
-    return "MockSpdyPeer[" + port + "]";
+    return "MockHttp2Peer[" + port + "]";
   }
 
   private static class OutFrame {
@@ -214,9 +203,9 @@ private OutFrame(int sequence, long start, boolean truncated) {
     }
   }
 
-  public static class InFrame implements FrameReader.Handler {
+  public static class InFrame implements Http2Reader.Handler {
     public final int sequence;
-    public final FrameReader reader;
+    public final Http2Reader reader;
     public int type = -1;
     public boolean clearPrevious;
     public boolean outFinished;
@@ -228,45 +217,42 @@ private OutFrame(int sequence, long start, boolean truncated) {
     public List<Header> headerBlock;
     public byte[] data;
     public Settings settings;
-    public HeadersMode headersMode;
     public boolean ack;
     public int payload1;
     public int payload2;
 
-    public InFrame(int sequence, FrameReader reader) {
+    public InFrame(int sequence, Http2Reader reader) {
       this.sequence = sequence;
       this.reader = reader;
     }
 
     @Override public void settings(boolean clearPrevious, Settings settings) {
       if (this.type != -1) throw new IllegalStateException();
-      this.type = Spdy3.TYPE_SETTINGS;
+      this.type = Http2.TYPE_SETTINGS;
       this.clearPrevious = clearPrevious;
       this.settings = settings;
     }
 
     @Override public void ackSettings() {
       if (this.type != -1) throw new IllegalStateException();
-      this.type = Spdy3.TYPE_SETTINGS;
+      this.type = Http2.TYPE_SETTINGS;
       this.ack = true;
     }
 
-    @Override public void headers(boolean outFinished, boolean inFinished, int streamId,
-        int associatedStreamId, List<Header> headerBlock, HeadersMode headersMode) {
+    @Override public void headers(boolean inFinished, int streamId,
+        int associatedStreamId, List<Header> headerBlock) {
       if (this.type != -1) throw new IllegalStateException();
-      this.type = Spdy3.TYPE_HEADERS;
-      this.outFinished = outFinished;
+      this.type = Http2.TYPE_HEADERS;
       this.inFinished = inFinished;
       this.streamId = streamId;
       this.associatedStreamId = associatedStreamId;
       this.headerBlock = headerBlock;
-      this.headersMode = headersMode;
     }
 
     @Override public void data(boolean inFinished, int streamId, BufferedSource source, int length)
         throws IOException {
       if (this.type != -1) throw new IllegalStateException();
-      this.type = Spdy3.TYPE_DATA;
+      this.type = Http2.TYPE_DATA;
       this.inFinished = inFinished;
       this.streamId = streamId;
       this.data = source.readByteString(length).toByteArray();
@@ -274,14 +260,14 @@ public InFrame(int sequence, FrameReader reader) {
 
     @Override public void rstStream(int streamId, ErrorCode errorCode) {
       if (this.type != -1) throw new IllegalStateException();
-      this.type = Spdy3.TYPE_RST_STREAM;
+      this.type = Http2.TYPE_RST_STREAM;
       this.streamId = streamId;
       this.errorCode = errorCode;
     }
 
     @Override public void ping(boolean ack, int payload1, int payload2) {
       if (this.type != -1) throw new IllegalStateException();
-      this.type = Spdy3.TYPE_PING;
+      this.type = Http2.TYPE_PING;
       this.ack = ack;
       this.payload1 = payload1;
       this.payload2 = payload2;
@@ -289,7 +275,7 @@ public InFrame(int sequence, FrameReader reader) {
 
     @Override public void goAway(int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {
       if (this.type != -1) throw new IllegalStateException();
-      this.type = Spdy3.TYPE_GOAWAY;
+      this.type = Http2.TYPE_GOAWAY;
       this.streamId = lastGoodStreamId;
       this.errorCode = errorCode;
       this.data = debugData.toByteArray();
@@ -297,7 +283,7 @@ public InFrame(int sequence, FrameReader reader) {
 
     @Override public void windowUpdate(int streamId, long windowSizeIncrement) {
       if (this.type != -1) throw new IllegalStateException();
-      this.type = Spdy3.TYPE_WINDOW_UPDATE;
+      this.type = Http2.TYPE_WINDOW_UPDATE;
       this.streamId = streamId;
       this.windowSizeIncrement = windowSizeIncrement;
     }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/SettingsTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/SettingsTest.java
new file mode 100644
index 0000000000..a26506ca27
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/SettingsTest.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http2;
+
+import org.junit.Test;
+
+import static okhttp3.internal.http2.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
+import static okhttp3.internal.http2.Settings.MAX_CONCURRENT_STREAMS;
+import static org.junit.Assert.assertEquals;
+
+public final class SettingsTest {
+  @Test public void unsetField() {
+    Settings settings = new Settings();
+    assertEquals(-3, settings.getMaxConcurrentStreams(-3));
+  }
+
+  @Test public void setFields() {
+    Settings settings = new Settings();
+
+    settings.set(Settings.HEADER_TABLE_SIZE, 8096);
+    assertEquals(8096, settings.getHeaderTableSize());
+
+    assertEquals(true, settings.getEnablePush(true));
+    settings.set(Settings.ENABLE_PUSH, 1);
+    assertEquals(true, settings.getEnablePush(false));
+    settings.clear();
+
+    assertEquals(-3, settings.getMaxConcurrentStreams(-3));
+    settings.set(MAX_CONCURRENT_STREAMS, 75);
+    assertEquals(75, settings.getMaxConcurrentStreams(-3));
+
+    settings.clear();
+    assertEquals(16384, settings.getMaxFrameSize(16384));
+    settings.set(Settings.MAX_FRAME_SIZE, 16777215);
+    assertEquals(16777215, settings.getMaxFrameSize(16384));
+
+    assertEquals(-1, settings.getMaxHeaderListSize(-1));
+    settings.set(Settings.MAX_HEADER_LIST_SIZE, 16777215);
+    assertEquals(16777215, settings.getMaxHeaderListSize(-1));
+
+    assertEquals(DEFAULT_INITIAL_WINDOW_SIZE,
+        settings.getInitialWindowSize());
+    settings.set(Settings.INITIAL_WINDOW_SIZE, 108);
+    assertEquals(108, settings.getInitialWindowSize());
+  }
+
+  @Test public void merge() {
+    Settings a = new Settings();
+    a.set(Settings.HEADER_TABLE_SIZE, 10000);
+    a.set(Settings.MAX_HEADER_LIST_SIZE, 20000);
+    a.set(Settings.INITIAL_WINDOW_SIZE, 30000);
+
+    Settings b = new Settings();
+    b.set(Settings.MAX_HEADER_LIST_SIZE, 40000);
+    b.set(Settings.INITIAL_WINDOW_SIZE, 50000);
+    b.set(Settings.MAX_CONCURRENT_STREAMS, 60000);
+
+    a.merge(b);
+    assertEquals(10000, a.getHeaderTableSize());
+    assertEquals(40000, a.getMaxHeaderListSize(-1));
+    assertEquals(50000, a.getInitialWindowSize());
+    assertEquals(60000, a.getMaxConcurrentStreams(-1));
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/FaultyFileSystem.java b/okhttp-tests/src/test/java/okhttp3/internal/io/FaultyFileSystem.java
similarity index 96%
rename from okhttp-tests/src/test/java/okhttp3/internal/FaultyFileSystem.java
rename to okhttp-tests/src/test/java/okhttp3/internal/io/FaultyFileSystem.java
index 3f237d0ad0..bc0263d830 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/FaultyFileSystem.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/io/FaultyFileSystem.java
@@ -13,14 +13,13 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal;
+package okhttp3.internal.io;
 
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.util.LinkedHashSet;
 import java.util.Set;
-import okhttp3.internal.io.FileSystem;
 import okio.Buffer;
 import okio.ForwardingSink;
 import okio.Sink;
@@ -91,6 +90,7 @@ public void setFaultyRename(File file, boolean faulty) {
   }
 
   @Override public void deleteContents(File directory) throws IOException {
+    if (deleteFaults.contains(directory)) throw new IOException("boom!");
     delegate.deleteContents(directory);
   }
 
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/Jdk9PlatformTest.java b/okhttp-tests/src/test/java/okhttp3/internal/platform/Jdk9PlatformTest.java
similarity index 92%
rename from okhttp-tests/src/test/java/okhttp3/internal/Jdk9PlatformTest.java
rename to okhttp-tests/src/test/java/okhttp3/internal/platform/Jdk9PlatformTest.java
index ed6deba9c7..ada8f78969 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/Jdk9PlatformTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/platform/Jdk9PlatformTest.java
@@ -13,11 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal;
+package okhttp3.internal.platform;
 
 import org.junit.Test;
 
-import static okhttp3.internal.PlatformTest.getPlatform;
+import static okhttp3.internal.platform.PlatformTest.getPlatform;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assume.assumeTrue;
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/JdkWithJettyBootPlatformTest.java b/okhttp-tests/src/test/java/okhttp3/internal/platform/JdkWithJettyBootPlatformTest.java
similarity index 90%
rename from okhttp-tests/src/test/java/okhttp3/internal/JdkWithJettyBootPlatformTest.java
rename to okhttp-tests/src/test/java/okhttp3/internal/platform/JdkWithJettyBootPlatformTest.java
index 04853ac106..afe7145a01 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/JdkWithJettyBootPlatformTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/platform/JdkWithJettyBootPlatformTest.java
@@ -13,11 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal;
+package okhttp3.internal.platform;
 
 import org.junit.Test;
 
-import static okhttp3.internal.PlatformTest.getPlatform;
+import static okhttp3.internal.platform.PlatformTest.getPlatform;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assume.assumeTrue;
 
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/OptionalMethodTest.java b/okhttp-tests/src/test/java/okhttp3/internal/platform/OptionalMethodTest.java
similarity index 93%
rename from okhttp-tests/src/test/java/okhttp3/internal/OptionalMethodTest.java
rename to okhttp-tests/src/test/java/okhttp3/internal/platform/OptionalMethodTest.java
index 08e025c5d9..7e249bd61f 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/OptionalMethodTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/platform/OptionalMethodTest.java
@@ -15,10 +15,11 @@
  *  limitations under the License.
  */
 
-package okhttp3.internal;
+package okhttp3.internal.platform;
 
 import java.io.IOException;
 import java.lang.reflect.InvocationTargetException;
+import org.junit.Ignore;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
@@ -75,32 +76,32 @@ protected void nonPublic() {
   }
 
   private final static OptionalMethod<BaseClass> STRING_METHOD_RETURNS_ANY =
-      new OptionalMethod<BaseClass>(null, "stringMethod");
+      new OptionalMethod<>(null, "stringMethod");
   private final static OptionalMethod<BaseClass> STRING_METHOD_RETURNS_STRING =
-      new OptionalMethod<BaseClass>(String.class, "stringMethod");
+      new OptionalMethod<>(String.class, "stringMethod");
   private final static OptionalMethod<BaseClass> STRING_METHOD_RETURNS_INT =
-      new OptionalMethod<BaseClass>(Integer.TYPE, "stringMethod");
+      new OptionalMethod<>(Integer.TYPE, "stringMethod");
   private final static OptionalMethod<BaseClass> VOID_METHOD_RETURNS_ANY =
-      new OptionalMethod<BaseClass>(null, "voidMethod");
+      new OptionalMethod<>(null, "voidMethod");
   private final static OptionalMethod<BaseClass> VOID_METHOD_RETURNS_VOID =
-      new OptionalMethod<BaseClass>(Void.TYPE, "voidMethod");
+      new OptionalMethod<>(Void.TYPE, "voidMethod");
   private final static OptionalMethod<BaseClass> SUBCLASS_METHOD_RETURNS_ANY =
-      new OptionalMethod<BaseClass>(null, "subclassMethod");
+      new OptionalMethod<>(null, "subclassMethod");
   private final static OptionalMethod<BaseClass> SUBCLASS_METHOD_RETURNS_STRING =
-      new OptionalMethod<BaseClass>(String.class, "subclassMethod");
+      new OptionalMethod<>(String.class, "subclassMethod");
   private final static OptionalMethod<BaseClass> SUBCLASS_METHOD_RETURNS_INT =
-      new OptionalMethod<BaseClass>(Integer.TYPE, "subclassMethod");
+      new OptionalMethod<>(Integer.TYPE, "subclassMethod");
   private final static OptionalMethod<BaseClass> METHOD_WITH_ARGS_WRONG_PARAMS =
-      new OptionalMethod<BaseClass>(null, "methodWithArgs", Integer.class);
+      new OptionalMethod<>(null, "methodWithArgs", Integer.class);
   private final static OptionalMethod<BaseClass> METHOD_WITH_ARGS_CORRECT_PARAMS =
-      new OptionalMethod<BaseClass>(null, "methodWithArgs", String.class);
+      new OptionalMethod<>(null, "methodWithArgs", String.class);
 
   private final static OptionalMethod<BaseClass> THROWS_EXCEPTION =
-      new OptionalMethod<BaseClass>(null, "throwsException");
+      new OptionalMethod<>(null, "throwsException");
   private final static OptionalMethod<BaseClass> THROWS_RUNTIME_EXCEPTION =
-      new OptionalMethod<BaseClass>(null, "throwsRuntimeException");
+      new OptionalMethod<>(null, "throwsRuntimeException");
   private final static OptionalMethod<BaseClass> NON_PUBLIC =
-      new OptionalMethod<BaseClass>(null, "nonPublic");
+      new OptionalMethod<>(null, "nonPublic");
 
   @Test
   public void isSupported() throws Exception {
@@ -299,6 +300,7 @@ public void invokeOptionalWithException() throws Exception {
   }
 
   @Test
+  @Ignore("Despite returning false for isSupported, invocation actually succeeds.")
   public void invokeOptionalNonPublic() throws Exception {
     SubClass2 subClass2 = new SubClass2();
     assertFalse(NON_PUBLIC.isSupported(subClass2));
@@ -309,9 +311,10 @@ public void invokeOptionalNonPublic() throws Exception {
       OptionalMethod<T> optionalMethod, T base, Object... args) throws Exception {
     try {
       optionalMethod.invoke(base, args);
-      fail();
     } catch (Error expected) {
+      return;
     }
+    fail();
   }
 
   private static <T> void assertIllegalArgumentExceptionOnInvoke(
@@ -327,9 +330,10 @@ public void invokeOptionalNonPublic() throws Exception {
       OptionalMethod<T> optionalMethod, T base, Object... args) throws Exception {
     try {
       optionalMethod.invokeOptional(base, args);
-      fail();
     } catch (Error expected) {
+      return;
     }
+    fail();
   }
 
   private static <T> void assertIllegalArgumentExceptionOnInvokeOptional(
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/PlatformTest.java b/okhttp-tests/src/test/java/okhttp3/internal/platform/PlatformTest.java
similarity index 73%
rename from okhttp-tests/src/test/java/okhttp3/internal/PlatformTest.java
rename to okhttp-tests/src/test/java/okhttp3/internal/platform/PlatformTest.java
index 43e205d7dc..ffd5842e83 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/PlatformTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/platform/PlatformTest.java
@@ -13,16 +13,22 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal;
+package okhttp3.internal.platform;
 
 import org.junit.Test;
 
+import static org.junit.Assert.assertEquals;
+
 public class PlatformTest {
-  @Test
-  public void alwaysBuilds() {
+  @Test public void alwaysBuilds() {
     new Platform();
   }
 
+  /** Guard against the default value changing by accident. */
+  @Test public void defaultPrefix() {
+    assertEquals("OkHttp", new Platform().getPrefix());
+  }
+
   public static String getPlatform() {
     return System.getProperty("okhttp.platform", "platform");
   }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/publicsuffix/PublicSuffixDatabaseTest.java b/okhttp-tests/src/test/java/okhttp3/internal/publicsuffix/PublicSuffixDatabaseTest.java
new file mode 100644
index 0000000000..e999890991
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/publicsuffix/PublicSuffixDatabaseTest.java
@@ -0,0 +1,284 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.publicsuffix;
+
+import java.io.IOException;
+import java.io.InputStream;
+import okhttp3.internal.Util;
+import okio.Buffer;
+import okio.BufferedSource;
+import okio.GzipSource;
+import okio.Okio;
+import org.junit.Test;
+
+import static okhttp3.internal.publicsuffix.PublicSuffixDatabase.PUBLIC_SUFFIX_RESOURCE;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class PublicSuffixDatabaseTest {
+  private final PublicSuffixDatabase publicSuffixDatabase = new PublicSuffixDatabase();
+
+  @Test public void longestMatchWins() {
+    Buffer buffer = new Buffer()
+        .writeUtf8("com\n")
+        .writeUtf8("my.square.com\n")
+        .writeUtf8("square.com\n");
+    publicSuffixDatabase.setListBytes(buffer.readByteArray(), new byte[]{});
+
+    assertEquals("example.com", publicSuffixDatabase.getEffectiveTldPlusOne("example.com"));
+    assertEquals("example.com", publicSuffixDatabase.getEffectiveTldPlusOne("foo.example.com"));
+    assertEquals("bar.square.com",
+        publicSuffixDatabase.getEffectiveTldPlusOne("foo.bar.square.com"));
+    assertEquals("foo.my.square.com",
+        publicSuffixDatabase.getEffectiveTldPlusOne("foo.my.square.com"));
+  }
+
+  @Test public void wildcardMatch() {
+    Buffer buffer = new Buffer()
+        .writeUtf8("*.square.com\n")
+        .writeUtf8("com\n")
+        .writeUtf8("example.com\n");
+    publicSuffixDatabase.setListBytes(buffer.readByteArray(), new byte[]{});
+
+    assertNull(publicSuffixDatabase.getEffectiveTldPlusOne("my.square.com"));
+    assertEquals("foo.my.square.com",
+        publicSuffixDatabase.getEffectiveTldPlusOne("foo.my.square.com"));
+    assertEquals("foo.my.square.com",
+        publicSuffixDatabase.getEffectiveTldPlusOne("bar.foo.my.square.com"));
+  }
+
+  @Test public void boundarySearches() {
+    Buffer buffer = new Buffer()
+        .writeUtf8("bbb\n")
+        .writeUtf8("ddd\n")
+        .writeUtf8("fff\n");
+    publicSuffixDatabase.setListBytes(buffer.readByteArray(), new byte[]{});
+
+    assertNull(publicSuffixDatabase.getEffectiveTldPlusOne("aaa"));
+    assertNull(publicSuffixDatabase.getEffectiveTldPlusOne("ggg"));
+    assertNull(publicSuffixDatabase.getEffectiveTldPlusOne("ccc"));
+    assertNull(publicSuffixDatabase.getEffectiveTldPlusOne("eee"));
+  }
+
+  @Test public void exceptionRule() {
+    Buffer exception = new Buffer()
+        .writeUtf8("my.square.jp\n");
+    Buffer buffer = new Buffer()
+        .writeUtf8("*.jp\n")
+        .writeUtf8("*.square.jp\n")
+        .writeUtf8("example.com\n")
+        .writeUtf8("square.com\n");
+    publicSuffixDatabase.setListBytes(buffer.readByteArray(), exception.readByteArray());
+
+    assertEquals("my.square.jp", publicSuffixDatabase.getEffectiveTldPlusOne("my.square.jp"));
+    assertEquals("my.square.jp", publicSuffixDatabase.getEffectiveTldPlusOne("foo.my.square.jp"));
+    assertNull(publicSuffixDatabase.getEffectiveTldPlusOne("my1.square.jp"));
+  }
+
+  @Test public void noEffectiveTldPlusOne() {
+    Buffer exception = new Buffer()
+        .writeUtf8("my.square.jp\n");
+    Buffer buffer = new Buffer()
+        .writeUtf8("*.jp\n")
+        .writeUtf8("*.square.jp\n")
+        .writeUtf8("example.com\n")
+        .writeUtf8("square.com\n");
+    publicSuffixDatabase.setListBytes(buffer.readByteArray(), exception.readByteArray());
+
+    assertNull(publicSuffixDatabase.getEffectiveTldPlusOne("example.com"));
+    assertNull(publicSuffixDatabase.getEffectiveTldPlusOne("foo.square.jp"));
+  }
+
+  @Test public void allPublicSuffixes() throws IOException {
+    InputStream resource = PublicSuffixDatabaseTest.class
+        .getResourceAsStream(PUBLIC_SUFFIX_RESOURCE);
+    BufferedSource source = Okio.buffer(new GzipSource(Okio.source(resource)));
+    int length = source.readInt();
+    Buffer buffer = new Buffer();
+    buffer.write(source, length);
+    resource.close();
+
+    while (!buffer.exhausted()) {
+      String publicSuffix = buffer.readUtf8LineStrict();
+      if (publicSuffix.contains("*")) {
+        // A wildcard rule, let's replace the wildcard with a value.
+        publicSuffix = publicSuffix.replaceAll("\\*", "square");
+      }
+      assertNull(publicSuffixDatabase.getEffectiveTldPlusOne(publicSuffix));
+
+      String test = "foobar." + publicSuffix;
+      assertEquals(test, publicSuffixDatabase.getEffectiveTldPlusOne(test));
+    }
+  }
+
+  @Test public void publicSuffixExceptions() throws IOException {
+    InputStream resource = PublicSuffixDatabaseTest.class
+        .getResourceAsStream(PUBLIC_SUFFIX_RESOURCE);
+    BufferedSource source = Okio.buffer(new GzipSource(Okio.source(resource)));
+    int length = source.readInt();
+    source.skip(length);
+
+    length = source.readInt();
+    Buffer buffer = new Buffer();
+    buffer.write(source, length);
+    resource.close();
+
+    while (!buffer.exhausted()) {
+      String exception = buffer.readUtf8LineStrict();
+      assertEquals(exception, publicSuffixDatabase.getEffectiveTldPlusOne(exception));
+
+      String test = "foobar." + exception;
+      assertEquals(exception, publicSuffixDatabase.getEffectiveTldPlusOne(test));
+    }
+  }
+
+  @Test public void threadIsInterruptedOnFirstRead() {
+    Thread.currentThread().interrupt();
+    try {
+      String result = publicSuffixDatabase.getEffectiveTldPlusOne("squareup.com");
+      assertEquals("squareup.com", result);
+    } finally {
+      assertTrue(Thread.interrupted());
+    }
+  }
+
+  /**
+   * These tests are provided by <a href="https://publicsuffix.org/list/">publicsuffix.org</a>.
+   */
+  @Test public void publicSuffixDotOrgTestCases() {
+    // Any copyright is dedicated to the Public Domain.
+    // https://creativecommons.org/publicdomain/zero/1.0/
+
+    // null input.
+    checkPublicSuffix(null, null);
+    // Mixed case.
+    checkPublicSuffix("COM", null);
+    checkPublicSuffix("example.COM", "example.com");
+    checkPublicSuffix("WwW.example.COM", "example.com");
+    // Leading dot.
+    checkPublicSuffix(".com", null);
+    checkPublicSuffix(".example", null);
+    checkPublicSuffix(".example.com", null);
+    checkPublicSuffix(".example.example", null);
+    // Unlisted TLD.
+    checkPublicSuffix("example", null);
+    checkPublicSuffix("example.example", "example.example");
+    checkPublicSuffix("b.example.example", "example.example");
+    checkPublicSuffix("a.b.example.example", "example.example");
+    // Listed, but non-Internet, TLD.
+    //checkPublicSuffix("local", null);
+    //checkPublicSuffix("example.local", null);
+    //checkPublicSuffix("b.example.local", null);
+    //checkPublicSuffix("a.b.example.local", null);
+    // TLD with only 1 rule.
+    checkPublicSuffix("biz", null);
+    checkPublicSuffix("domain.biz", "domain.biz");
+    checkPublicSuffix("b.domain.biz", "domain.biz");
+    checkPublicSuffix("a.b.domain.biz", "domain.biz");
+    // TLD with some 2-level rules.
+    checkPublicSuffix("com", null);
+    checkPublicSuffix("example.com", "example.com");
+    checkPublicSuffix("b.example.com", "example.com");
+    checkPublicSuffix("a.b.example.com", "example.com");
+    checkPublicSuffix("uk.com", null);
+    checkPublicSuffix("example.uk.com", "example.uk.com");
+    checkPublicSuffix("b.example.uk.com", "example.uk.com");
+    checkPublicSuffix("a.b.example.uk.com", "example.uk.com");
+    checkPublicSuffix("test.ac", "test.ac");
+    // TLD with only 1 (wildcard) rule.
+    checkPublicSuffix("mm", null);
+    checkPublicSuffix("c.mm", null);
+    checkPublicSuffix("b.c.mm", "b.c.mm");
+    checkPublicSuffix("a.b.c.mm", "b.c.mm");
+    // More complex TLD.
+    checkPublicSuffix("jp", null);
+    checkPublicSuffix("test.jp", "test.jp");
+    checkPublicSuffix("www.test.jp", "test.jp");
+    checkPublicSuffix("ac.jp", null);
+    checkPublicSuffix("test.ac.jp", "test.ac.jp");
+    checkPublicSuffix("www.test.ac.jp", "test.ac.jp");
+    checkPublicSuffix("kyoto.jp", null);
+    checkPublicSuffix("test.kyoto.jp", "test.kyoto.jp");
+    checkPublicSuffix("ide.kyoto.jp", null);
+    checkPublicSuffix("b.ide.kyoto.jp", "b.ide.kyoto.jp");
+    checkPublicSuffix("a.b.ide.kyoto.jp", "b.ide.kyoto.jp");
+    checkPublicSuffix("c.kobe.jp", null);
+    checkPublicSuffix("b.c.kobe.jp", "b.c.kobe.jp");
+    checkPublicSuffix("a.b.c.kobe.jp", "b.c.kobe.jp");
+    checkPublicSuffix("city.kobe.jp", "city.kobe.jp");
+    checkPublicSuffix("www.city.kobe.jp", "city.kobe.jp");
+    // TLD with a wildcard rule and exceptions.
+    checkPublicSuffix("ck", null);
+    checkPublicSuffix("test.ck", null);
+    checkPublicSuffix("b.test.ck", "b.test.ck");
+    checkPublicSuffix("a.b.test.ck", "b.test.ck");
+    checkPublicSuffix("www.ck", "www.ck");
+    checkPublicSuffix("www.www.ck", "www.ck");
+    // US K12.
+    checkPublicSuffix("us", null);
+    checkPublicSuffix("test.us", "test.us");
+    checkPublicSuffix("www.test.us", "test.us");
+    checkPublicSuffix("ak.us", null);
+    checkPublicSuffix("test.ak.us", "test.ak.us");
+    checkPublicSuffix("www.test.ak.us", "test.ak.us");
+    checkPublicSuffix("k12.ak.us", null);
+    checkPublicSuffix("test.k12.ak.us", "test.k12.ak.us");
+    checkPublicSuffix("www.test.k12.ak.us", "test.k12.ak.us");
+    // IDN labels.
+    checkPublicSuffix("食狮.com.cn", "食狮.com.cn");
+    checkPublicSuffix("食狮.公司.cn", "食狮.公司.cn");
+    checkPublicSuffix("www.食狮.公司.cn", "食狮.公司.cn");
+    checkPublicSuffix("shishi.公司.cn", "shishi.公司.cn");
+    checkPublicSuffix("公司.cn", null);
+    checkPublicSuffix("食狮.中国", "食狮.中国");
+    checkPublicSuffix("www.食狮.中国", "食狮.中国");
+    checkPublicSuffix("shishi.中国", "shishi.中国");
+    checkPublicSuffix("中国", null);
+    // Same as above, but punycoded.
+    checkPublicSuffix("xn--85x722f.com.cn", "xn--85x722f.com.cn");
+    checkPublicSuffix("xn--85x722f.xn--55qx5d.cn", "xn--85x722f.xn--55qx5d.cn");
+    checkPublicSuffix("www.xn--85x722f.xn--55qx5d.cn", "xn--85x722f.xn--55qx5d.cn");
+    checkPublicSuffix("shishi.xn--55qx5d.cn", "shishi.xn--55qx5d.cn");
+    checkPublicSuffix("xn--55qx5d.cn", null);
+    checkPublicSuffix("xn--85x722f.xn--fiqs8s", "xn--85x722f.xn--fiqs8s");
+    checkPublicSuffix("www.xn--85x722f.xn--fiqs8s", "xn--85x722f.xn--fiqs8s");
+    checkPublicSuffix("shishi.xn--fiqs8s", "shishi.xn--fiqs8s");
+    checkPublicSuffix("xn--fiqs8s", null);
+  }
+
+  private void checkPublicSuffix(String domain, String registrablePart) {
+    if (domain == null) {
+      try {
+        publicSuffixDatabase.getEffectiveTldPlusOne(null);
+        fail();
+      } catch (NullPointerException expected) {
+      }
+      return;
+    }
+
+    String canonicalDomain = Util.canonicalizeHost(domain);
+    if (canonicalDomain == null) return;
+
+    String result = publicSuffixDatabase.getEffectiveTldPlusOne(canonicalDomain);
+    if (registrablePart == null) {
+      assertNull(result);
+    } else {
+      assertEquals(Util.canonicalizeHost(registrablePart), result);
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/tls/CertificatePinnerChainValidationTest.java b/okhttp-tests/src/test/java/okhttp3/internal/tls/CertificatePinnerChainValidationTest.java
index 4b59edbf6e..27b1c7783f 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/tls/CertificatePinnerChainValidationTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/tls/CertificatePinnerChainValidationTest.java
@@ -29,6 +29,8 @@
 import org.junit.Rule;
 import org.junit.Test;
 
+import static okhttp3.TestUtil.defaultClient;
+import static okhttp3.internal.platform.PlatformTest.getPlatform;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
@@ -60,7 +62,7 @@
     SslClient sslClient = new SslClient.Builder()
         .addTrustedCertificate(rootCa.certificate)
         .build();
-    OkHttpClient client = new OkHttpClient.Builder()
+    OkHttpClient client = defaultClient().newBuilder()
         .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
         .hostnameVerifier(new RecordingHostnameVerifier())
         .certificatePinner(certificatePinner)
@@ -116,7 +118,7 @@
     SslClient contextBuilder = new SslClient.Builder()
         .addTrustedCertificate(rootCa.certificate)
         .build();
-    OkHttpClient client = new OkHttpClient.Builder()
+    OkHttpClient client = defaultClient().newBuilder()
         .sslSocketFactory(contextBuilder.socketFactory, contextBuilder.trustManager)
         .hostnameVerifier(new RecordingHostnameVerifier())
         .certificatePinner(certificatePinner)
@@ -136,6 +138,10 @@
         .build());
     Response response1 = call1.execute();
     assertEquals("abc", response1.body().string());
+    response1.close();
+
+    // Force a fresh connection for the next request.
+    client.connectionPool().evictAll();
 
     // Confirm that a second request also succeeds. This should detect caching problems.
     server.enqueue(new MockResponse()
@@ -146,6 +152,7 @@
         .build());
     Response response2 = call2.execute();
     assertEquals("def", response2.body().string());
+    response2.close();
   }
 
   @Test public void unrelatedPinnedLeafCertificateInChain() throws Exception {
@@ -176,7 +183,7 @@
     SslClient clientContextBuilder = new SslClient.Builder()
         .addTrustedCertificate(rootCa.certificate)
         .build();
-    OkHttpClient client = new OkHttpClient.Builder()
+    OkHttpClient client = defaultClient().newBuilder()
         .sslSocketFactory(clientContextBuilder.socketFactory, clientContextBuilder.trustManager)
         .hostnameVerifier(new RecordingHostnameVerifier())
         .certificatePinner(certificatePinner)
@@ -197,8 +204,20 @@
         .issuedBy(compromisedIntermediateCa)
         .commonName(server.getHostName())
         .build();
-    SslClient serverSslContext = new SslClient.Builder()
-        .certificateChain(rogueCertificate.keyPair, rogueCertificate.certificate, compromisedIntermediateCa.certificate, goodCertificate.certificate, rootCa.certificate)
+
+    SslClient.Builder sslBuilder = new SslClient.Builder();
+
+    // Test setup fails on JDK9
+    // java.security.KeyStoreException: Certificate chain is not valid
+    // at sun.security.pkcs12.PKCS12KeyStore.setKeyEntry
+    // http://openjdk.java.net/jeps/229
+    // http://hg.openjdk.java.net/jdk9/jdk9/jdk/file/2c1c21d11e58/src/share/classes/sun/security/pkcs12/PKCS12KeyStore.java#l596
+    if (getPlatform().equals("jdk9")) {
+      sslBuilder.keyStoreType("JKS");
+    }
+
+    SslClient serverSslContext = sslBuilder.certificateChain(
+        rogueCertificate.keyPair, rogueCertificate.certificate, compromisedIntermediateCa.certificate, goodCertificate.certificate, rootCa.certificate)
         .build();
     server.useHttps(serverSslContext.socketFactory, false);
     server.enqueue(new MockResponse()
@@ -250,7 +269,7 @@
         .addTrustedCertificate(rootCa.certificate)
         .addTrustedCertificate(compromisedRootCa.certificate)
         .build();
-    OkHttpClient client = new OkHttpClient.Builder()
+    OkHttpClient client = defaultClient().newBuilder()
         .sslSocketFactory(clientContextBuilder.socketFactory, clientContextBuilder.trustManager)
         .hostnameVerifier(new RecordingHostnameVerifier())
         .certificatePinner(certificatePinner)
@@ -271,8 +290,19 @@
         .issuedBy(compromisedIntermediateCa)
         .commonName(server.getHostName())
         .build();
-    SslClient serverSslContext = new SslClient.Builder()
-        .certificateChain(
+
+    SslClient.Builder sslBuilder = new SslClient.Builder();
+
+    // Test setup fails on JDK9
+    // java.security.KeyStoreException: Certificate chain is not valid
+    // at sun.security.pkcs12.PKCS12KeyStore.setKeyEntry
+    // http://openjdk.java.net/jeps/229
+    // http://hg.openjdk.java.net/jdk9/jdk9/jdk/file/2c1c21d11e58/src/share/classes/sun/security/pkcs12/PKCS12KeyStore.java#l596
+    if (getPlatform().equals("jdk9")) {
+      sslBuilder.keyStoreType("JKS");
+    }
+
+    SslClient serverSslContext = sslBuilder.certificateChain(
             rogueCertificate.keyPair, rogueCertificate.certificate, goodIntermediateCa.certificate, compromisedIntermediateCa.certificate, compromisedRootCa.certificate)
         .build();
     server.useHttps(serverSslContext.socketFactory, false);
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/tls/ClientAuthTest.java b/okhttp-tests/src/test/java/okhttp3/internal/tls/ClientAuthTest.java
new file mode 100644
index 0000000000..55e82e9cf9
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/tls/ClientAuthTest.java
@@ -0,0 +1,257 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.tls;
+
+import java.io.IOException;
+import java.net.SocketException;
+import java.security.GeneralSecurityException;
+import javax.net.ssl.SSLHandshakeException;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import javax.net.ssl.SSLSocket;
+import javax.net.ssl.SSLSocketFactory;
+import javax.security.auth.x500.X500Principal;
+import okhttp3.Call;
+import okhttp3.DelegatingSSLSocketFactory;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+
+import static okhttp3.TestUtil.defaultClient;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+public final class ClientAuthTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  public enum ClientAuth {
+    NONE, WANTS, NEEDS
+  }
+
+  private HeldCertificate serverRootCa;
+  private HeldCertificate serverIntermediateCa;
+  private HeldCertificate serverCert;
+  private HeldCertificate clientRootCa;
+  private HeldCertificate clientIntermediateCa;
+  private HeldCertificate clientCert;
+
+  @Before
+  public void setUp() throws GeneralSecurityException {
+    serverRootCa = new HeldCertificate.Builder()
+        .serialNumber("1")
+        .ca(3)
+        .commonName("root")
+        .subjectAlternativeName("root_ca.com")
+        .build();
+    serverIntermediateCa = new HeldCertificate.Builder()
+        .issuedBy(serverRootCa)
+        .ca(2)
+        .serialNumber("2")
+        .commonName("intermediate_ca")
+        .subjectAlternativeName("intermediate_ca.com")
+        .build();
+
+    serverCert = new HeldCertificate.Builder()
+        .issuedBy(serverIntermediateCa)
+        .serialNumber("3")
+        .commonName("Local Host")
+        .subjectAlternativeName(server.getHostName())
+        .build();
+
+    clientRootCa = new HeldCertificate.Builder()
+        .serialNumber("1")
+        .ca(13)
+        .commonName("root")
+        .subjectAlternativeName("root_ca.com")
+        .build();
+    clientIntermediateCa = new HeldCertificate.Builder()
+        .issuedBy(serverRootCa)
+        .ca(12)
+        .serialNumber("2")
+        .commonName("intermediate_ca")
+        .subjectAlternativeName("intermediate_ca.com")
+        .build();
+
+    clientCert = new HeldCertificate.Builder()
+        .issuedBy(clientIntermediateCa)
+        .serialNumber("4")
+        .commonName("Jethro Willis")
+        .subjectAlternativeName("jethrowillis.com")
+        .build();
+  }
+
+  @Test public void clientAuthForWants() throws Exception {
+    OkHttpClient client = buildClient(clientCert, clientIntermediateCa);
+
+    SSLSocketFactory socketFactory = buildServerSslSocketFactory(ClientAuth.WANTS);
+
+    server.useHttps(socketFactory, false);
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
+    Response response = call.execute();
+    assertEquals(new X500Principal("CN=Local Host"), response.handshake().peerPrincipal());
+    assertEquals(new X500Principal("CN=Jethro Willis"), response.handshake().localPrincipal());
+    assertEquals("abc", response.body().string());
+  }
+
+  @Test public void clientAuthForNeeds() throws Exception {
+    OkHttpClient client = buildClient(clientCert, clientIntermediateCa);
+
+    SSLSocketFactory socketFactory = buildServerSslSocketFactory(ClientAuth.NEEDS);
+
+    server.useHttps(socketFactory, false);
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
+    Response response = call.execute();
+    assertEquals(new X500Principal("CN=Local Host"), response.handshake().peerPrincipal());
+    assertEquals(new X500Principal("CN=Jethro Willis"), response.handshake().localPrincipal());
+    assertEquals("abc", response.body().string());
+  }
+
+  @Test public void clientAuthSkippedForNone() throws Exception {
+    OkHttpClient client = buildClient(clientCert, clientIntermediateCa);
+
+    SSLSocketFactory socketFactory = buildServerSslSocketFactory(ClientAuth.NONE);
+
+    server.useHttps(socketFactory, false);
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
+    Response response = call.execute();
+    assertEquals(new X500Principal("CN=Local Host"), response.handshake().peerPrincipal());
+    assertEquals(null, response.handshake().localPrincipal());
+    assertEquals("abc", response.body().string());
+  }
+
+  @Test public void missingClientAuthSkippedForWantsOnly() throws Exception {
+    OkHttpClient client = buildClient(null, clientIntermediateCa);
+
+    SSLSocketFactory socketFactory = buildServerSslSocketFactory(ClientAuth.WANTS);
+
+    server.useHttps(socketFactory, false);
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
+    Response response = call.execute();
+    assertEquals(new X500Principal("CN=Local Host"), response.handshake().peerPrincipal());
+    assertEquals(null, response.handshake().localPrincipal());
+    assertEquals("abc", response.body().string());
+  }
+
+  @Test public void missingClientAuthFailsForNeeds() throws Exception {
+    OkHttpClient client = buildClient(null, clientIntermediateCa);
+
+    SSLSocketFactory socketFactory = buildServerSslSocketFactory(ClientAuth.NEEDS);
+
+    server.useHttps(socketFactory, false);
+
+    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
+
+    try {
+      call.execute();
+      fail();
+    } catch (SSLHandshakeException expected) {
+    } catch (SocketException expected) {
+      // JDK 9
+    }
+  }
+
+  @Test public void commonNameIsNotTrusted() throws Exception {
+    serverCert = new HeldCertificate.Builder()
+        .issuedBy(serverIntermediateCa)
+        .serialNumber("3")
+        .commonName(server.getHostName())
+        .subjectAlternativeName("different-host.com")
+        .build();
+
+    OkHttpClient client = buildClient(clientCert, clientIntermediateCa);
+
+    SSLSocketFactory socketFactory = buildServerSslSocketFactory(ClientAuth.NEEDS);
+
+    server.useHttps(socketFactory, false);
+
+    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
+
+    try {
+      call.execute();
+      fail();
+    } catch (SSLPeerUnverifiedException expected) {
+    }
+  }
+
+  @Test public void invalidClientAuthFails() throws Throwable {
+    HeldCertificate clientCert2 = new HeldCertificate.Builder()
+        .serialNumber("4")
+        .commonName("Jethro Willis")
+        .build();
+
+    OkHttpClient client = buildClient(clientCert2);
+
+    SSLSocketFactory socketFactory = buildServerSslSocketFactory(ClientAuth.NEEDS);
+
+    server.useHttps(socketFactory, false);
+
+    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
+
+    try {
+      call.execute();
+      fail();
+    } catch (SSLHandshakeException expected) {
+    } catch (SocketException expected) {
+      // JDK 9
+    }
+  }
+
+  public OkHttpClient buildClient(HeldCertificate cert, HeldCertificate... chain) {
+    SslClient.Builder sslClientBuilder = new SslClient.Builder()
+        .addTrustedCertificate(serverRootCa.certificate);
+
+    if (cert != null) {
+      sslClientBuilder.certificateChain(cert, chain);
+    }
+
+    SslClient sslClient = sslClientBuilder.build();
+    return defaultClient().newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .build();
+  }
+
+  public SSLSocketFactory buildServerSslSocketFactory(final ClientAuth clientAuth) {
+    SslClient serverSslClient = new SslClient.Builder()
+        .addTrustedCertificate(serverRootCa.certificate)
+        .addTrustedCertificate(clientRootCa.certificate)
+        .certificateChain(serverCert, serverIntermediateCa)
+        .build();
+
+    return new DelegatingSSLSocketFactory(serverSslClient.socketFactory) {
+      @Override protected SSLSocket configureSocket(SSLSocket sslSocket) throws IOException {
+        if (clientAuth == ClientAuth.NEEDS) {
+          sslSocket.setNeedClientAuth(true);
+        } else if (clientAuth == ClientAuth.WANTS) {
+          sslSocket.setWantClientAuth(true);
+        }
+
+        return super.configureSocket(sslSocket);
+      }
+    };
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/tls/DistinguishedNameParserTest.java b/okhttp-tests/src/test/java/okhttp3/internal/tls/DistinguishedNameParserTest.java
new file mode 100644
index 0000000000..09c22b8594
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/tls/DistinguishedNameParserTest.java
@@ -0,0 +1,134 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.tls;
+
+
+import javax.security.auth.x500.X500Principal;
+
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+public final class DistinguishedNameParserTest {
+  @Test public void regularCases() {
+    assertCn("xxx", "ou=xxx,cn=xxx");
+    assertCn("yyy", "ou=xxx+cn=yyy,cn=zzz+cn=abc");
+    assertCn("a", "cn=a,cn=b");
+    assertCn("a   c", "cn=a   c,cn=b");
+    assertCn("Cc", "cn=Cc,cn=Bb,cn=Aa");
+    assertCn("imap.gmail.com", "cn=imap.gmail.com");
+    assertCn("c", "l=\"abcn=a,b\", cn=c");
+    assertCn("c", "l=\"abcn=a,b\", cn=c");
+    assertCn("c", "l=\"abcn=a,b\", cn= c");
+    assertCn("a b", "cn=a b");
+    assertCn("a b", "cn   =a b");
+    assertCn("a b", "Cn=a b");
+    assertCn("a b", "cN=a b");
+    assertCn("a b", "CN=a b");
+    assertCn("a#b", "cn=a#b");
+    assertCn("a", "cn=#130161");
+    assertCn("p", "l=q\t+cn=p");
+    assertCn("p", "l=q\n+cn=p");
+    assertCn("p", "l=q\n,cn=p");
+    assertCn("p", "l=,cn=p");
+    assertCn("\tp", "l=\tq\n,cn=\tp");
+  }
+
+  @Test public void emptyValues() {
+    assertCn(null, "");
+    assertCn(null, "ou=xxx");
+    assertCn("", "l=,cn=+cn=q");
+    assertCn("", "l=,cn=,cn=q");
+    assertCn(null, "l=,cn=");
+    assertCn("q", "l=,cn=q,cn=   ");
+    assertCn("q", "l=,cn=q  ,cn=   ");
+    assertCn(null, "l=,cn=\"\"");
+    assertCn("", "l=,cn=  ,cn=  ");
+    assertCn("", "l=,cn=,cn=  ,cn=  ");
+  }
+
+  @Test public void escapedChars() {
+    assertCn(",", "cn=\\,");
+    assertCn("#", "cn=\\#");
+    assertCn("+", "cn=\\+");
+    assertCn("\"", "cn=\\\"");
+    assertCn("\\", "cn=\\\\");
+    assertCn("<", "cn=\\<");
+    assertCn(">", "cn=\\>");
+    assertCn(";", "cn=\\;");
+    assertCn("+", "cn=\\+");
+    assertCn("+", "cn=\"\\+\"");
+    assertCn(",", "cn=\"\\,\"");
+    assertCn("a =", "cn= a =");
+    assertCn("=", "cn==");
+  }
+
+  @Test public void whitespace() {
+    assertCn("p", "cn= p");
+    assertCn("p", "cn=\np");
+    assertCn("\tp", "cn=\tp");
+  }
+
+  @Test public void withOid() {
+    assertCn("a", "2.5.4.3=a,ou=xxx");
+    assertCn("a", "2.5.4.3=\" a \",ou=xxx");
+    assertCn("b", "2.5.5.3=a,ou=xxx,cn=b");
+  }
+
+  @Test public void quotedStrings() {
+    assertCn("\" a ,=<>#;", "cn=\"\\\" a ,=<>#;\"");
+    assertCn("abc,def", "cn=abc\\,def");
+    assertCn("\" a ,=<>#;", "cn=\"\\\" a ,\\=<>\\#;\"");
+  }
+
+  @Test public void utf8() {
+    assertCn("\u004c\u0075\u010d\u0069\u0107", "cn=\"Lu\\C4\\8Di\\C4\\87\"");
+    assertCn("\u004c\u0075\u010d\u0069\u0107", "cn=Lu\\C4\\8Di\\C4\\87");
+    assertCn("\u004c\u0075\u010d\u0069\u0107", "cn=Lu\\C4\\8di\\c4\\87");
+    assertCn("\u004c\u0075\u010d\u0069\u0107", "cn=\"Lu\\C4\\8di\\c4\\87\"");
+    assertCn("\u004c\u0075\u010d\u0069\u0107", "cn=\u004c\u0075\u010d\u0069\u0107");
+    // \63=c
+    expectExceptionInPrincipal("\\63n=ab");
+    expectExceptionInPrincipal("cn=\\a");
+  }
+
+  @Test public void trailingWhitespace() {
+    assertCn("a  b", "ou=a, cn=  a  b  ,o=x");
+    assertCn("a  b", "cn=\"  a  b  \" ,o=x");
+    assertCn("a", "cn=a   ,cn=b");
+    assertCn("", "l=,cn=\"  \",cn=\"  \"");
+  }
+
+  /**
+   * @param expected the value of the first "cn=" argument in {@code dn},
+   *                 or null if none is expected
+   */
+  private void assertCn(String expected, String dn) {
+    X500Principal principal = new X500Principal(dn);
+    DistinguishedNameParser parser = new DistinguishedNameParser(principal);
+    assertEquals(dn, expected, parser.findMostSpecific("cn"));
+  }
+
+  private void expectExceptionInPrincipal(String dn) {
+    try {
+      new X500Principal(dn);
+      fail("Expected " + IllegalArgumentException.class.getName()
+          + " because of incorrect input name");
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/tls/HostnameVerifierTest.java b/okhttp-tests/src/test/java/okhttp3/internal/tls/HostnameVerifierTest.java
index f03f197d94..6dd5bbbd7c 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/tls/HostnameVerifierTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/tls/HostnameVerifierTest.java
@@ -72,7 +72,7 @@
         + "HwlNrAu8jlZ2UqSgskSWlhYdMTAP9CPHiUv9N7FcT58Itv/I4fKREINQYjDpvQcx\n"
         + "SaTYb9dr5sB4WLNglk7zxDtM80H518VvihTcP7FHL+Gn6g4j5fkI98+S\n"
         + "-----END CERTIFICATE-----\n");
-    assertTrue(verifier.verify("foo.com", session));
+    assertFalse(verifier.verify("foo.com", session));
     assertFalse(verifier.verify("a.foo.com", session));
     assertFalse(verifier.verify("bar.com", session));
   }
@@ -105,7 +105,7 @@
         + "9BsO7qe46hidgn39hKh1WjKK2VcL/3YRsC4wUi0PBtFW6ScMCuMhgIRXSPU55Rae\n"
         + "UIlOdPjjr1SUNWGId1rD7W16Scpwnknn310FNxFMHVI0GTGFkNdkilNCFJcIoRA=\n"
         + "-----END CERTIFICATE-----\n");
-    assertTrue(verifier.verify("\u82b1\u5b50.co.jp", session));
+    assertFalse(verifier.verify("\u82b1\u5b50.co.jp", session));
     assertFalse(verifier.verify("a.\u82b1\u5b50.co.jp", session));
   }
 
@@ -258,7 +258,7 @@
     assertFalse(verifier.verify("a.foo.com", session));
     assertFalse(verifier.verify("bar.com", session));
     assertFalse(verifier.verify("a.bar.com", session));
-    assertTrue(verifier.verify("\u82b1\u5b50.co.jp", session));
+    assertFalse(verifier.verify("\u82b1\u5b50.co.jp", session));
     assertFalse(verifier.verify("a.\u82b1\u5b50.co.jp", session));
   }
 
@@ -291,8 +291,8 @@
         + "l3Q/RK95bnA6cuRClGusLad0e6bjkBzx/VQ3VarDEpAkTLUGVAa0CLXtnyc=\n"
         + "-----END CERTIFICATE-----\n");
     assertFalse(verifier.verify("foo.com", session));
-    assertTrue(verifier.verify("www.foo.com", session));
-    assertTrue(verifier.verify("\u82b1\u5b50.foo.com", session));
+    assertFalse(verifier.verify("www.foo.com", session));
+    assertFalse(verifier.verify("\u82b1\u5b50.foo.com", session));
     assertFalse(verifier.verify("a.b.foo.com", session));
   }
 
@@ -325,8 +325,8 @@
         + "UGPLEUDzRHMPHLnSqT1n5UU5UDRytbjJPXzF+l/+WZIsanefWLsxnkgAuZe/oMMF\n"
         + "EJMryEzOjg4Tfuc5qM0EXoPcQ/JlheaxZ40p2IyHqbsWV4MRYuFH4bkM\n"
         + "-----END CERTIFICATE-----\n");
-    assertTrue(verifier.verify("foo.co.jp", session));
-    assertTrue(verifier.verify("\u82b1\u5b50.co.jp", session));
+    assertFalse(verifier.verify("foo.co.jp", session));
+    assertFalse(verifier.verify("\u82b1\u5b50.co.jp", session));
   }
 
   /**
@@ -451,7 +451,7 @@
         + "U6LFxmZr31lFyis2/T68PpjAppc0DpNQuA2m/Y7oTHBDi55Fw6HVHCw3lucuWZ5d\n"
         + "qUYo4ES548JdpQtcLrW2sA==\n"
         + "-----END CERTIFICATE-----");
-    assertTrue(verifier.verify("google.com", session));
+    assertFalse(verifier.verify("google.com", session));
   }
 
   @Test public void subjectAltName() throws Exception {
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
new file mode 100644
index 0000000000..af26aa095c
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
@@ -0,0 +1,350 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.ws;
+
+import java.io.EOFException;
+import java.io.IOException;
+import java.net.ProtocolException;
+import java.util.Random;
+import java.util.concurrent.TimeUnit;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.Response;
+import okio.ByteString;
+import okio.Okio;
+import okio.Pipe;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class RealWebSocketTest {
+  // NOTE: Fields are named 'client' and 'server' for cognitive simplicity. This differentiation has
+  // zero effect on the behavior of the WebSocket API which is why tests are only written once
+  // from the perspective of a single peer.
+
+  private final Random random = new Random(0);
+  private final Pipe client2Server = new Pipe(1024L);
+  private final Pipe server2client = new Pipe(1024L);
+
+  private TestStreams client = new TestStreams(true, server2client, client2Server);
+  private TestStreams server = new TestStreams(false, client2Server, server2client);
+
+  @Before public void setUp() throws IOException {
+    client.initWebSocket(random, 0);
+    server.initWebSocket(random, 0);
+  }
+
+  @After public void tearDown() throws Exception {
+    client.listener.assertExhausted();
+    server.listener.assertExhausted();
+    server.source.close();
+    client.source.close();
+    server.webSocket.tearDown();
+    client.webSocket.tearDown();
+  }
+
+  @Test public void close() throws IOException {
+    client.webSocket.close(1000, "Hello!");
+    assertFalse(server.processNextFrame()); // This will trigger a close response.
+    server.listener.assertClosing(1000, "Hello!");
+    server.webSocket.close(1000, "Goodbye!");
+    assertFalse(client.processNextFrame());
+    client.listener.assertClosing(1000, "Goodbye!");
+    server.listener.assertClosed(1000, "Hello!");
+    client.listener.assertClosed(1000, "Goodbye!");
+  }
+
+  @Test public void clientCloseThenMethodsReturnFalse() throws IOException {
+    client.webSocket.close(1000, "Hello!");
+
+    assertFalse(client.webSocket.close(1000, "Hello!"));
+    assertFalse(client.webSocket.send("Hello!"));
+  }
+
+  @Test public void clientCloseWith0Fails() throws IOException {
+    try {
+      client.webSocket.close(0, null);
+      fail();
+    } catch (IllegalArgumentException expected) {
+      assertEquals(expected.getMessage(), "Code must be in range [1000,5000): 0");
+    }
+  }
+
+  @Test public void afterSocketClosedPingFailsWebSocket() throws IOException {
+    client2Server.source().close();
+    client.webSocket.pong(ByteString.encodeUtf8("Ping!"));
+    client.listener.assertFailure(IOException.class, "source is closed");
+
+    assertFalse(client.webSocket.send("Hello!"));
+  }
+
+  @Test public void socketClosedDuringMessageKillsWebSocket() throws IOException {
+    client2Server.source().close();
+
+    assertTrue(client.webSocket.send("Hello!"));
+    client.listener.assertFailure(IOException.class, "source is closed");
+
+    // A failed write prevents further use of the WebSocket instance.
+    assertFalse(client.webSocket.send("Hello!"));
+    assertFalse(client.webSocket.pong(ByteString.encodeUtf8("Ping!")));
+  }
+
+  @Test public void serverCloseThenWritingPingSucceeds() throws IOException {
+    server.webSocket.close(1000, "Hello!");
+    client.processNextFrame();
+    client.listener.assertClosing(1000, "Hello!");
+
+    assertTrue(client.webSocket.pong(ByteString.encodeUtf8("Pong?")));
+  }
+
+  @Test public void clientCanWriteMessagesAfterServerClose() throws IOException {
+    server.webSocket.close(1000, "Hello!");
+    client.processNextFrame();
+    client.listener.assertClosing(1000, "Hello!");
+
+    assertTrue(client.webSocket.send("Hi!"));
+    server.processNextFrame();
+    server.listener.assertTextMessage("Hi!");
+  }
+
+  @Test public void serverCloseThenClientClose() throws IOException {
+    server.webSocket.close(1000, "Hello!");
+    client.processNextFrame();
+    client.listener.assertClosing(1000, "Hello!");
+    assertTrue(client.webSocket.close(1000, "Bye!"));
+  }
+
+  @Test public void emptyCloseInitiatesShutdown() throws IOException {
+    server.sink.write(ByteString.decodeHex("8800")).emit(); // Close without code.
+    client.processNextFrame();
+    client.listener.assertClosing(1005, "");
+
+    assertTrue(client.webSocket.close(1000, "Bye!"));
+    server.processNextFrame();
+    server.listener.assertClosing(1000, "Bye!");
+
+    client.listener.assertClosed(1005, "");
+  }
+
+  @Test public void clientCloseClosesConnection() throws IOException {
+    client.webSocket.close(1000, "Hello!");
+    assertFalse(client.closed);
+    server.processNextFrame(); // Read client closing, send server close.
+    server.listener.assertClosing(1000, "Hello!");
+
+    server.webSocket.close(1000, "Goodbye!");
+    client.processNextFrame(); // Read server closing, close connection.
+    assertTrue(client.closed);
+    client.listener.assertClosing(1000, "Goodbye!");
+
+    // Server and client both finished closing, connection is closed.
+    server.listener.assertClosed(1000, "Hello!");
+    client.listener.assertClosed(1000, "Goodbye!");
+  }
+
+  @Test public void serverCloseClosesConnection() throws IOException {
+    server.webSocket.close(1000, "Hello!");
+
+    client.processNextFrame(); // Read server close, send client close, close connection.
+    assertFalse(client.closed);
+    client.listener.assertClosing(1000, "Hello!");
+
+    client.webSocket.close(1000, "Hello!");
+    server.processNextFrame();
+    server.listener.assertClosing(1000, "Hello!");
+
+    client.listener.assertClosed(1000, "Hello!");
+    server.listener.assertClosed(1000, "Hello!");
+  }
+
+  @Test public void clientAndServerCloseClosesConnection() throws Exception {
+    // Send close from both sides at the same time.
+    server.webSocket.close(1000, "Hello!");
+    client.processNextFrame(); // Read close, close connection close.
+
+    assertFalse(client.closed);
+    client.webSocket.close(1000, "Hi!");
+    server.processNextFrame();
+
+    client.listener.assertClosing(1000, "Hello!");
+    server.listener.assertClosing(1000, "Hi!");
+    client.listener.assertClosed(1000, "Hello!");
+    server.listener.assertClosed(1000, "Hi!");
+    client.webSocket.awaitTermination(5, TimeUnit.SECONDS);
+    assertTrue(client.closed);
+
+    server.listener.assertExhausted(); // Client should not have sent second close.
+    client.listener.assertExhausted(); // Server should not have sent second close.
+  }
+
+  @Test public void serverCloseBreaksReadMessageLoop() throws IOException {
+    server.webSocket.send("Hello!");
+    server.webSocket.close(1000, "Bye!");
+    assertTrue(client.processNextFrame());
+    client.listener.assertTextMessage("Hello!");
+    assertFalse(client.processNextFrame());
+    client.listener.assertClosing(1000, "Bye!");
+  }
+
+  @Test public void protocolErrorBeforeCloseSendsFailure() throws IOException {
+    server.sink.write(ByteString.decodeHex("0a00")).emit(); // Invalid non-final ping frame.
+
+    client.processNextFrame(); // Detects error, send close, close connection.
+    assertTrue(client.closed);
+    client.listener.assertFailure(ProtocolException.class, "Control frames must be final.");
+
+    server.processNextFrame();
+    server.listener.assertFailure(EOFException.class);
+  }
+
+  @Test public void protocolErrorInCloseResponseClosesConnection() throws IOException {
+    client.webSocket.close(1000, "Hello");
+    server.processNextFrame();
+    assertFalse(client.closed); // Not closed until close reply is received.
+
+    // Manually write an invalid masked close frame.
+    server.sink.write(ByteString.decodeHex("888760b420bb635c68de0cd84f")).emit();
+
+    client.processNextFrame();// Detects error, disconnects immediately since close already sent.
+    assertTrue(client.closed);
+    client.listener.assertFailure(
+        ProtocolException.class, "Server-sent frames must not be masked.");
+
+    server.listener.assertClosing(1000, "Hello");
+    server.listener.assertExhausted(); // Client should not have sent second close.
+  }
+
+  @Test public void protocolErrorAfterCloseDoesNotSendClose() throws IOException {
+    client.webSocket.close(1000, "Hello!");
+    server.processNextFrame();
+
+    assertFalse(client.closed); // Not closed until close reply is received.
+    server.sink.write(ByteString.decodeHex("0a00")).emit(); // Invalid non-final ping frame.
+
+    client.processNextFrame(); // Detects error, disconnects immediately since close already sent.
+    assertTrue(client.closed);
+    client.listener.assertFailure(ProtocolException.class, "Control frames must be final.");
+
+    server.listener.assertClosing(1000, "Hello!");
+
+    server.listener.assertExhausted(); // Client should not have sent second close.
+  }
+
+  @Test public void networkErrorReportedAsFailure() throws IOException {
+    server.sink.close();
+    client.processNextFrame();
+    client.listener.assertFailure(EOFException.class);
+  }
+
+  @Test public void closeThrowingFailsConnection() throws IOException {
+    client2Server.source().close();
+    client.webSocket.close(1000, null);
+    client.listener.assertFailure(IOException.class, "source is closed");
+  }
+
+  @Ignore // TODO(jwilson): come up with a way to test unchecked exceptions on the writer thread.
+  @Test public void closeMessageAndConnectionCloseThrowingDoesNotMaskOriginal() throws IOException {
+    client.sink.close();
+    client.closeThrows = true;
+
+    client.webSocket.close(1000, "Bye!");
+    client.listener.assertFailure(IOException.class, "failure");
+    assertTrue(client.closed);
+  }
+
+  @Ignore // TODO(jwilson): come up with a way to test unchecked exceptions on the writer thread.
+  @Test public void peerConnectionCloseThrowingPropagates() throws IOException {
+    client.closeThrows = true;
+
+    server.webSocket.close(1000, "Bye from Server!");
+    client.processNextFrame();
+    client.listener.assertClosing(1000, "Bye from Server!");
+
+    client.webSocket.close(1000, "Bye from Client!");
+    server.processNextFrame();
+    server.listener.assertClosing(1000, "Bye from Client!");
+  }
+
+  @Test public void pingOnInterval() throws IOException {
+    long startNanos = System.nanoTime();
+    client.initWebSocket(random, 500);
+
+    server.processNextFrame(); // Ping.
+    client.processNextFrame(); // Pong.
+    long elapsedUntilPing1 = System.nanoTime() - startNanos;
+    assertEquals(500, TimeUnit.NANOSECONDS.toMillis(elapsedUntilPing1), 250d);
+
+    server.processNextFrame(); // Ping.
+    client.processNextFrame(); // Pong.
+    long elapsedUntilPing2 = System.nanoTime() - startNanos;
+    assertEquals(1000, TimeUnit.NANOSECONDS.toMillis(elapsedUntilPing2), 250d);
+
+    server.processNextFrame(); // Ping.
+    client.processNextFrame(); // Pong.
+    long elapsedUntilPing3 = System.nanoTime() - startNanos;
+    assertEquals(1500, TimeUnit.NANOSECONDS.toMillis(elapsedUntilPing3), 250d);
+  }
+
+  /** One peer's streams, listener, and web socket in the test. */
+  private static class TestStreams extends RealWebSocket.Streams {
+    private final String name;
+    private final WebSocketRecorder listener;
+    private RealWebSocket webSocket;
+    boolean closeThrows;
+    boolean closed;
+
+    public TestStreams(boolean client, Pipe source, Pipe sink) {
+      super(client, Okio.buffer(source.source()), Okio.buffer(sink.sink()));
+      this.name = client ? "client" : "server";
+      this.listener = new WebSocketRecorder(name);
+    }
+
+    public void initWebSocket(Random random, int pingIntervalMillis) throws IOException {
+      String url = "http://example.com/websocket";
+      Response response = new Response.Builder()
+          .code(101)
+          .message("OK")
+          .request(new Request.Builder().url(url).build())
+          .protocol(Protocol.HTTP_1_1)
+          .build();
+      webSocket = new RealWebSocket(response.request(), listener, random);
+      webSocket.initReaderAndWriter(name, pingIntervalMillis, this);
+    }
+
+    public boolean processNextFrame() throws IOException {
+      return webSocket.processNextFrame();
+    }
+
+    @Override public void close() throws IOException {
+      source.close();
+      sink.close();
+      if (closed) {
+        throw new AssertionError("Already closed");
+      }
+      closed = true;
+
+      if (closeThrows) {
+        throw new RuntimeException("Oops!");
+      }
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketHttpTest.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketHttpTest.java
new file mode 100644
index 0000000000..617a5a22e9
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketHttpTest.java
@@ -0,0 +1,673 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.ws;
+
+import java.io.EOFException;
+import java.io.IOException;
+import java.net.ProtocolException;
+import java.net.SocketTimeoutException;
+import java.util.Collections;
+import java.util.Random;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.logging.Logger;
+import okhttp3.Interceptor;
+import okhttp3.OkHttpClient;
+import okhttp3.RecordingEventListener;
+import okhttp3.RecordingHostnameVerifier;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.TestLogHandler;
+import okhttp3.WebSocket;
+import okhttp3.WebSocketListener;
+import okhttp3.internal.tls.SslClient;
+import okhttp3.mockwebserver.Dispatcher;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
+import okhttp3.mockwebserver.SocketPolicy;
+import okio.Buffer;
+import okio.ByteString;
+import org.junit.After;
+import org.junit.Ignore;
+import org.junit.Rule;
+import org.junit.Test;
+
+import static okhttp3.TestUtil.defaultClient;
+import static okhttp3.TestUtil.repeat;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class WebSocketHttpTest {
+  @Rule public final MockWebServer webServer = new MockWebServer();
+
+  private final SslClient sslClient = SslClient.localhost();
+  private final WebSocketRecorder clientListener = new WebSocketRecorder("client");
+  private final WebSocketRecorder serverListener = new WebSocketRecorder("server");
+  private final Random random = new Random(0);
+  private OkHttpClient client = defaultClient().newBuilder()
+      .writeTimeout(500, TimeUnit.MILLISECONDS)
+      .readTimeout(500, TimeUnit.MILLISECONDS)
+      .addInterceptor(new Interceptor() {
+        @Override public Response intercept(Chain chain) throws IOException {
+          Response response = chain.proceed(chain.request());
+          assertNotNull(response.body()); // Ensure application interceptors never see a null body.
+          return response;
+        }
+      })
+      .build();
+
+  @After public void tearDown() {
+    clientListener.assertExhausted();
+  }
+
+  @Test public void textMessage() throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    WebSocket webSocket = newWebSocket();
+
+    clientListener.assertOpen();
+    serverListener.assertOpen();
+
+    webSocket.send("Hello, WebSockets!");
+    serverListener.assertTextMessage("Hello, WebSockets!");
+  }
+
+  @Test public void binaryMessage() throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    WebSocket webSocket = newWebSocket();
+
+    clientListener.assertOpen();
+    serverListener.assertOpen();
+
+    webSocket.send(ByteString.encodeUtf8("Hello!"));
+    serverListener.assertBinaryMessage(ByteString.of(new byte[] {'H', 'e', 'l', 'l', 'o', '!'}));
+  }
+
+  @Test public void nullStringThrows() throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    WebSocket webSocket = newWebSocket();
+
+    clientListener.assertOpen();
+    try {
+      webSocket.send((String) null);
+      fail();
+    } catch (NullPointerException e) {
+      assertEquals("text == null", e.getMessage());
+    }
+  }
+
+  @Test public void nullByteStringThrows() throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    WebSocket webSocket = newWebSocket();
+
+    clientListener.assertOpen();
+    try {
+      webSocket.send((ByteString) null);
+      fail();
+    } catch (NullPointerException e) {
+      assertEquals("bytes == null", e.getMessage());
+    }
+  }
+
+  @Test public void serverMessage() throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    newWebSocket();
+
+    clientListener.assertOpen();
+    WebSocket server = serverListener.assertOpen();
+
+    server.send("Hello, WebSockets!");
+    clientListener.assertTextMessage("Hello, WebSockets!");
+  }
+
+  @Test public void throwingOnOpenFailsImmediately() {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+
+    final RuntimeException e = new RuntimeException();
+    clientListener.setNextEventDelegate(new WebSocketListener() {
+      @Override public void onOpen(WebSocket webSocket, Response response) {
+        throw e;
+      }
+    });
+    newWebSocket();
+
+    serverListener.assertOpen();
+    serverListener.assertExhausted();
+    clientListener.assertFailure(e);
+  }
+
+  @Ignore("AsyncCall currently lets runtime exceptions propagate.")
+  @Test public void throwingOnFailLogs() throws InterruptedException {
+    TestLogHandler logs = new TestLogHandler();
+    Logger logger = Logger.getLogger(OkHttpClient.class.getName());
+    logger.addHandler(logs);
+
+    webServer.enqueue(new MockResponse().setResponseCode(200).setBody("Body"));
+
+    final RuntimeException e = new RuntimeException();
+    clientListener.setNextEventDelegate(new WebSocketListener() {
+      @Override public void onFailure(WebSocket webSocket, Throwable t, Response response) {
+        throw e;
+      }
+    });
+
+    newWebSocket();
+
+    assertEquals("", logs.take());
+    logger.removeHandler(logs);
+  }
+
+  @Test public void throwingOnMessageClosesImmediatelyAndFails() throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    newWebSocket();
+
+    clientListener.assertOpen();
+    WebSocket server = serverListener.assertOpen();
+
+    final RuntimeException e = new RuntimeException();
+    clientListener.setNextEventDelegate(new WebSocketListener() {
+      @Override public void onMessage(WebSocket webSocket, String text) {
+        throw e;
+      }
+    });
+
+    server.send("Hello, WebSockets!");
+    clientListener.assertFailure(e);
+    serverListener.assertFailure(EOFException.class);
+    serverListener.assertExhausted();
+  }
+
+  @Test public void throwingOnClosingClosesImmediatelyAndFails() throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    newWebSocket();
+
+    clientListener.assertOpen();
+    WebSocket server = serverListener.assertOpen();
+
+    final RuntimeException e = new RuntimeException();
+    clientListener.setNextEventDelegate(new WebSocketListener() {
+      @Override public void onClosing(WebSocket webSocket, int code, String reason) {
+        throw e;
+      }
+    });
+
+    server.close(1000, "bye");
+    clientListener.assertFailure(e);
+    serverListener.assertFailure();
+    serverListener.assertExhausted();
+  }
+
+  @Test public void unplannedCloseHandledByCloseWithoutFailure() {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    newWebSocket();
+
+    clientListener.assertOpen();
+    WebSocket server = serverListener.assertOpen();
+    clientListener.setNextEventDelegate(new WebSocketListener() {
+      @Override public void onClosing(WebSocket webSocket, int code, String reason) {
+        webSocket.close(1000, null);
+      }
+    });
+
+    server.close(1001, "bye");
+    clientListener.assertClosed(1001, "bye");
+    clientListener.assertExhausted();
+    serverListener.assertClosing(1000,  "");
+    serverListener.assertClosed(1000,  "");
+    serverListener.assertExhausted();
+  }
+
+  @Test public void unplannedCloseHandledWithoutFailure() {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    newWebSocket();
+
+    clientListener.assertOpen();
+    WebSocket server = serverListener.assertOpen();
+
+    server.close(1001, "bye");
+    clientListener.assertClosing(1001, "bye");
+    clientListener.assertExhausted();
+    serverListener.assertExhausted();
+  }
+
+  @Test public void non101RetainsBody() throws IOException {
+    webServer.enqueue(new MockResponse().setResponseCode(200).setBody("Body"));
+    newWebSocket();
+
+    clientListener.assertFailure(200, "Body", ProtocolException.class,
+        "Expected HTTP 101 response but was '200 OK'");
+  }
+
+  @Test public void notFound() throws IOException {
+    webServer.enqueue(new MockResponse().setStatus("HTTP/1.1 404 Not Found"));
+    newWebSocket();
+
+    clientListener.assertFailure(404, null, ProtocolException.class,
+        "Expected HTTP 101 response but was '404 Not Found'");
+  }
+
+  @Test public void clientTimeoutClosesBody() {
+    webServer.enqueue(new MockResponse().setResponseCode(408));
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    WebSocket webSocket = newWebSocket();
+
+    clientListener.assertOpen();
+    WebSocket server = serverListener.assertOpen();
+
+    webSocket.send("abc");
+    serverListener.assertTextMessage("abc");
+
+    server.send("def");
+    clientListener.assertTextMessage("def");
+  }
+
+  @Test public void missingConnectionHeader() throws IOException {
+    webServer.enqueue(new MockResponse()
+        .setResponseCode(101)
+        .setHeader("Upgrade", "websocket")
+        .setHeader("Sec-WebSocket-Accept", "ujmZX4KXZqjwy6vi1aQFH5p4Ygk="));
+    newWebSocket();
+
+    clientListener.assertFailure(101, null, ProtocolException.class,
+        "Expected 'Connection' header value 'Upgrade' but was 'null'");
+  }
+
+  @Test public void wrongConnectionHeader() throws IOException {
+    webServer.enqueue(new MockResponse()
+        .setResponseCode(101)
+        .setHeader("Upgrade", "websocket")
+        .setHeader("Connection", "Downgrade")
+        .setHeader("Sec-WebSocket-Accept", "ujmZX4KXZqjwy6vi1aQFH5p4Ygk="));
+    newWebSocket();
+
+    clientListener.assertFailure(101, null, ProtocolException.class,
+        "Expected 'Connection' header value 'Upgrade' but was 'Downgrade'");
+  }
+
+  @Test public void missingUpgradeHeader() throws IOException {
+    webServer.enqueue(new MockResponse()
+        .setResponseCode(101)
+        .setHeader("Connection", "Upgrade")
+        .setHeader("Sec-WebSocket-Accept", "ujmZX4KXZqjwy6vi1aQFH5p4Ygk="));
+    newWebSocket();
+
+    clientListener.assertFailure(101, null, ProtocolException.class,
+        "Expected 'Upgrade' header value 'websocket' but was 'null'");
+  }
+
+  @Test public void wrongUpgradeHeader() throws IOException {
+    webServer.enqueue(new MockResponse()
+        .setResponseCode(101)
+        .setHeader("Connection", "Upgrade")
+        .setHeader("Upgrade", "Pepsi")
+        .setHeader("Sec-WebSocket-Accept", "ujmZX4KXZqjwy6vi1aQFH5p4Ygk="));
+    newWebSocket();
+
+    clientListener.assertFailure(101, null, ProtocolException.class,
+        "Expected 'Upgrade' header value 'websocket' but was 'Pepsi'");
+  }
+
+  @Test public void missingMagicHeader() throws IOException {
+    webServer.enqueue(new MockResponse()
+        .setResponseCode(101)
+        .setHeader("Connection", "Upgrade")
+        .setHeader("Upgrade", "websocket"));
+    newWebSocket();
+
+    clientListener.assertFailure(101, null, ProtocolException.class,
+        "Expected 'Sec-WebSocket-Accept' header value 'ujmZX4KXZqjwy6vi1aQFH5p4Ygk=' but was 'null'");
+  }
+
+  @Test public void wrongMagicHeader() throws IOException {
+    webServer.enqueue(new MockResponse()
+        .setResponseCode(101)
+        .setHeader("Connection", "Upgrade")
+        .setHeader("Upgrade", "websocket")
+        .setHeader("Sec-WebSocket-Accept", "magic"));
+    newWebSocket();
+
+    clientListener.assertFailure(101, null, ProtocolException.class,
+        "Expected 'Sec-WebSocket-Accept' header value 'ujmZX4KXZqjwy6vi1aQFH5p4Ygk=' but was 'magic'");
+  }
+
+  @Test public void webSocketAndApplicationInterceptors() throws IOException {
+    final AtomicInteger interceptedCount = new AtomicInteger();
+
+    client = client.newBuilder()
+        .addInterceptor(new Interceptor() {
+          @Override public Response intercept(Chain chain) throws IOException {
+            assertNull(chain.request().body());
+            Response response = chain.proceed(chain.request());
+            assertEquals("Upgrade", response.header("Connection"));
+            assertTrue(response.body().source().exhausted());
+            interceptedCount.incrementAndGet();
+            return response;
+          }
+        }).build();
+
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+
+    WebSocket webSocket = newWebSocket();
+    clientListener.assertOpen();
+    assertEquals(1, interceptedCount.get());
+    webSocket.close(1000, null);
+
+    WebSocket server = serverListener.assertOpen();
+    server.close(1000, null);
+  }
+
+  @Test public void webSocketAndNetworkInterceptors() throws IOException {
+    client = client.newBuilder()
+        .addNetworkInterceptor(new Interceptor() {
+          @Override public Response intercept(Chain chain) throws IOException {
+            throw new AssertionError(); // Network interceptors don't execute.
+          }
+        }).build();
+
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+
+    WebSocket webSocket = newWebSocket();
+    clientListener.assertOpen();
+    webSocket.close(1000, null);
+
+    WebSocket server = serverListener.assertOpen();
+    server.close(1000, null);
+  }
+
+  @Test public void overflowOutgoingQueue() throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+
+    WebSocket webSocket = newWebSocket();
+    clientListener.assertOpen();
+
+    // Send messages until the client's outgoing buffer overflows!
+    ByteString message = ByteString.of(new byte[1024 * 1024]);
+    int messageCount = 0;
+    while (true) {
+      boolean success = webSocket.send(message);
+      if (!success) break;
+
+      messageCount++;
+      long queueSize = webSocket.queueSize();
+      assertTrue(queueSize >= 0 && queueSize <= messageCount * message.size());
+      assertTrue(messageCount < 32); // Expect to fail before enqueueing 32 MiB.
+    }
+
+    // Confirm all sent messages were received, followed by a client-initiated close.
+    WebSocket server = serverListener.assertOpen();
+    for (int i = 0; i < messageCount; i++) {
+      serverListener.assertBinaryMessage(message);
+    }
+    serverListener.assertClosing(1001, "");
+
+    // When the server acknowledges the close the connection shuts down gracefully.
+    server.close(1000, null);
+    clientListener.assertClosing(1000, "");
+    clientListener.assertClosed(1000, "");
+    serverListener.assertClosed(1001, "");
+  }
+
+  @Test public void closeReasonMaximumLength() throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+
+    String clientReason = repeat('C', 123);
+    String serverReason = repeat('S', 123);
+
+    WebSocket webSocket = newWebSocket();
+    WebSocket server = serverListener.assertOpen();
+
+    clientListener.assertOpen();
+    webSocket.close(1000, clientReason);
+    serverListener.assertClosing(1000, clientReason);
+
+    server.close(1000, serverReason);
+    clientListener.assertClosing(1000, serverReason);
+    clientListener.assertClosed(1000, serverReason);
+
+    serverListener.assertClosed(1000, clientReason);
+  }
+
+  @Test public void closeReasonTooLong() throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+
+    WebSocket webSocket = newWebSocket();
+    WebSocket server = serverListener.assertOpen();
+
+    clientListener.assertOpen();
+    String reason = repeat('X', 124);
+    try {
+      webSocket.close(1000, reason);
+      fail();
+    } catch (IllegalArgumentException expected) {
+      assertEquals("reason.size() > 123: " + reason, expected.getMessage());
+    }
+
+    webSocket.close(1000, null);
+    serverListener.assertClosing(1000, "");
+
+    server.close(1000, null);
+    clientListener.assertClosing(1000, "");
+    clientListener.assertClosed(1000, "");
+
+    serverListener.assertClosed(1000, "");
+  }
+
+  @Test public void wsScheme() throws IOException {
+    websocketScheme("ws");
+  }
+
+  @Test public void wsUppercaseScheme() throws IOException {
+    websocketScheme("WS");
+  }
+
+  @Test public void wssScheme() throws IOException {
+    webServer.useHttps(sslClient.socketFactory, false);
+    client = client.newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build();
+
+    websocketScheme("wss");
+  }
+
+  @Test public void httpsScheme() throws IOException {
+    webServer.useHttps(sslClient.socketFactory, false);
+    client = client.newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build();
+
+    websocketScheme("https");
+  }
+
+  @Test public void readTimeoutAppliesToHttpRequest() throws IOException {
+    webServer.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.NO_RESPONSE));
+
+    WebSocket webSocket = newWebSocket();
+
+    clientListener.assertFailure(SocketTimeoutException.class, "timeout", "Read timed out");
+    assertFalse(webSocket.close(1000, null));
+  }
+
+  /**
+   * There's no read timeout when reading the first byte of a new frame. But as soon as we start
+   * reading a frame we enable the read timeout. In this test we have the server returning the first
+   * byte of a frame but no more frames.
+   */
+  @Test public void readTimeoutAppliesWithinFrames() throws IOException {
+    webServer.setDispatcher(new Dispatcher() {
+      @Override public MockResponse dispatch(RecordedRequest request) throws InterruptedException {
+        return upgradeResponse(request)
+            .setBody(new Buffer().write(ByteString.decodeHex("81"))) // Truncated frame.
+            .removeHeader("Content-Length")
+            .setSocketPolicy(SocketPolicy.KEEP_OPEN);
+      }
+    });
+
+    WebSocket webSocket = newWebSocket();
+    clientListener.assertOpen();
+
+    clientListener.assertFailure(SocketTimeoutException.class, "timeout", "Read timed out");
+    assertFalse(webSocket.close(1000, null));
+  }
+
+  @Test public void readTimeoutDoesNotApplyAcrossFrames() throws Exception {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    newWebSocket();
+
+    clientListener.assertOpen();
+    WebSocket server = serverListener.assertOpen();
+
+    // Sleep longer than the HTTP client's read timeout.
+    Thread.sleep(client.readTimeoutMillis() + 500);
+
+    server.send("abc");
+    clientListener.assertTextMessage("abc");
+  }
+
+  @Test public void clientPingsServerOnInterval() throws Exception {
+    client = client.newBuilder()
+        .pingInterval(500, TimeUnit.MILLISECONDS)
+        .build();
+
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    RealWebSocket webSocket = newWebSocket();
+
+    clientListener.assertOpen();
+    RealWebSocket server = (RealWebSocket) serverListener.assertOpen();
+
+    long startNanos = System.nanoTime();
+    while (webSocket.pongCount() < 3) {
+      Thread.sleep(50);
+    }
+
+    long elapsedUntilPong3 = System.nanoTime() - startNanos;
+    assertEquals(1500, TimeUnit.NANOSECONDS.toMillis(elapsedUntilPong3), 250d);
+
+    // The client pinged the server 3 times, and it has ponged back 3 times.
+    assertEquals(3, server.pingCount());
+    assertEquals(3, webSocket.pongCount());
+
+    // The server has never pinged the client.
+    assertEquals(0, server.pongCount());
+    assertEquals(0, webSocket.pingCount());
+  }
+
+  @Test public void clientDoesNotPingServerByDefault() throws Exception {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    RealWebSocket webSocket = newWebSocket();
+
+    clientListener.assertOpen();
+    RealWebSocket server = (RealWebSocket) serverListener.assertOpen();
+
+    Thread.sleep(1000);
+
+    // No pings and no pongs.
+    assertEquals(0, server.pingCount());
+    assertEquals(0, webSocket.pongCount());
+    assertEquals(0, server.pongCount());
+    assertEquals(0, webSocket.pingCount());
+  }
+
+  /** https://github.com/square/okhttp/issues/2788 */
+  @Test public void clientCancelsIfCloseIsNotAcknowledged() throws Exception {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    RealWebSocket webSocket = newWebSocket();
+
+    clientListener.assertOpen();
+    WebSocket server = serverListener.assertOpen();
+
+    // Initiate a close on the client, which will schedule a hard cancel in 500 ms.
+    long closeAtNanos = System.nanoTime();
+    webSocket.close(1000, "goodbye", 500);
+    serverListener.assertClosing(1000, "goodbye");
+
+    // Confirm that the hard cancel occurred after 500 ms.
+    clientListener.assertFailure();
+    long elapsedUntilFailure = System.nanoTime() - closeAtNanos;
+    assertEquals(500, TimeUnit.NANOSECONDS.toMillis(elapsedUntilFailure), 250d);
+
+    // Close the server and confirm it saw what we expected.
+    server.close(1000, null);
+    serverListener.assertClosed(1000, "goodbye");
+  }
+
+  @Test public void webSocketsDontTriggerEventListener() throws IOException {
+    RecordingEventListener listener = new RecordingEventListener();
+
+    client = client.newBuilder()
+        .eventListener(listener)
+        .build();
+
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    WebSocket webSocket = newWebSocket();
+
+    clientListener.assertOpen();
+    WebSocket server = serverListener.assertOpen();
+
+    webSocket.send("Web Sockets and Events?!");
+    serverListener.assertTextMessage("Web Sockets and Events?!");
+
+    webSocket.close(1000, "");
+    serverListener.assertClosing(1000, "");
+
+    server.close(1000, "");
+    clientListener.assertClosing(1000, "");
+    clientListener.assertClosed(1000, "");
+    serverListener.assertClosed(1000, "");
+
+    assertEquals(Collections.emptyList(), listener.recordedEventTypes());
+  }
+
+  private MockResponse upgradeResponse(RecordedRequest request) {
+    String key = request.getHeader("Sec-WebSocket-Key");
+    return new MockResponse()
+        .setStatus("HTTP/1.1 101 Switching Protocols")
+        .setHeader("Connection", "Upgrade")
+        .setHeader("Upgrade", "websocket")
+        .setHeader("Sec-WebSocket-Accept", WebSocketProtocol.acceptHeader(key));
+  }
+
+  private void websocketScheme(String scheme) throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+
+    Request request = new Request.Builder()
+        .url(scheme + "://" + webServer.getHostName() + ":" + webServer.getPort() + "/")
+        .build();
+
+    RealWebSocket webSocket = newWebSocket(request);
+    clientListener.assertOpen();
+    serverListener.assertOpen();
+
+    webSocket.send("abc");
+    serverListener.assertTextMessage("abc");
+  }
+
+  private RealWebSocket newWebSocket() {
+    return newWebSocket(new Request.Builder().get().url(webServer.url("/")).build());
+  }
+
+  private RealWebSocket newWebSocket(Request request) {
+    RealWebSocket webSocket = new RealWebSocket(request, clientListener, random);
+    webSocket.connect(client);
+    return webSocket;
+  }
+}
diff --git a/okhttp-ws-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
similarity index 71%
rename from okhttp-ws-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
rename to okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
index 6bb7ef86d8..9fa5d1d9dc 100644
--- a/okhttp-ws-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
@@ -19,31 +19,25 @@
 import java.io.IOException;
 import java.net.ProtocolException;
 import java.util.Random;
-import java.util.concurrent.atomic.AtomicReference;
 import java.util.regex.Pattern;
-import okhttp3.ResponseBody;
 import okhttp3.internal.Util;
-import okhttp3.ws.WebSocketRecorder;
-import okhttp3.ws.WebSocketRecorder.MessageDelegate;
 import okio.Buffer;
-import okio.BufferedSource;
 import okio.ByteString;
 import org.junit.After;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 public final class WebSocketReaderTest {
   private final Buffer data = new Buffer();
-  private final WebSocketRecorder callback = new WebSocketRecorder();
+  private final WebSocketRecorder callback = new WebSocketRecorder("client");
   private final Random random = new Random(0);
 
   // Mutually exclusive. Use the one corresponding to the peer whose behavior you wish to test.
-  private final WebSocketReader serverReader = new WebSocketReader(false, data, callback);
-  private final WebSocketReader clientReader = new WebSocketReader(true, data, callback);
+  final WebSocketReader serverReader = new WebSocketReader(false, data, callback.asFrameCallback());
+  final WebSocketReader clientReader = new WebSocketReader(true, data, callback.asFrameCallback());
 
   @After public void tearDown() {
     callback.assertExhausted();
@@ -91,7 +85,7 @@
       serverReader.processNextFrame();
       fail();
     } catch (ProtocolException e) {
-      assertEquals("Client-sent frames must be masked. Server sent must not.", e.getMessage());
+      assertEquals("Client-sent frames must be masked.", e.getMessage());
     }
   }
 
@@ -101,7 +95,7 @@
       clientReader.processNextFrame();
       fail();
     } catch (ProtocolException e) {
-      assertEquals("Client-sent frames must be masked. Server sent must not.", e.getMessage());
+      assertEquals("Server-sent frames must not be masked.", e.getMessage());
     }
   }
 
@@ -151,20 +145,11 @@
 
   @Test public void serverHelloTwoChunks() throws IOException {
     data.write(ByteString.decodeHex("818537fa213d7f9f4d")); // Hel
+    data.write(ByteString.decodeHex("5158")); // lo
 
-    final Buffer sink = new Buffer();
-    callback.setNextMessageDelegate(new MessageDelegate() {
-      @Override public void onMessage(ResponseBody message) throws IOException {
-        BufferedSource source = message.source();
-        source.readFully(sink, 3); // Read "Hel"
-        data.write(ByteString.decodeHex("5158")); // lo
-        source.readFully(sink, 2); // Read "lo"
-        source.close();
-      }
-    });
     serverReader.processNextFrame();
 
-    assertEquals("Hello", sink.readUtf8());
+    callback.assertTextMessage("Hello");
   }
 
   @Test public void clientTwoFrameHello() throws IOException {
@@ -182,10 +167,10 @@
     data.write(ByteString.decodeHex("8a00")); // Pong
     data.write(ByteString.decodeHex("80026c6f")); // lo
     clientReader.processNextFrame();
-    callback.assertPong(null);
-    callback.assertPong(null);
-    callback.assertPong(null);
-    callback.assertPong(null);
+    callback.assertPong(ByteString.EMPTY);
+    callback.assertPong(ByteString.EMPTY);
+    callback.assertPong(ByteString.EMPTY);
+    callback.assertPong(ByteString.EMPTY);
     callback.assertTextMessage("Hello");
   }
 
@@ -229,7 +214,7 @@
     byte[] bytes = binaryData(256);
     data.write(ByteString.decodeHex("827E0100")).write(bytes);
     clientReader.processNextFrame();
-    callback.assertBinaryMessage(bytes);
+    callback.assertBinaryMessage(ByteString.of(bytes));
   }
 
   @Test public void clientTwoFrameBinary() throws IOException {
@@ -237,7 +222,7 @@
     data.write(ByteString.decodeHex("0264")).write(bytes, 0, 100);
     data.write(ByteString.decodeHex("8064")).write(bytes, 100, 100);
     clientReader.processNextFrame();
-    callback.assertBinaryMessage(bytes);
+    callback.assertBinaryMessage(ByteString.of(bytes));
   }
 
   @Test public void twoFrameNotContinuation() throws IOException {
@@ -252,100 +237,22 @@
     }
   }
 
-  @Test public void noCloseErrors() throws IOException {
-    data.write(ByteString.decodeHex("810548656c6c6f")); // Hello
-    callback.setNextMessageDelegate(new MessageDelegate() {
-      @Override public void onMessage(ResponseBody body) throws IOException {
-        body.source().readAll(new Buffer());
-      }
-    });
-    try {
-      clientReader.processNextFrame();
-      fail();
-    } catch (IllegalStateException e) {
-      assertEquals("Listener failed to call close on message payload.", e.getMessage());
-    }
-  }
-
-  @Test public void closeExhaustsMessage() throws IOException {
-    data.write(ByteString.decodeHex("810548656c6c6f")); // Hello
-    data.write(ByteString.decodeHex("810448657921")); // Hey!
-
-    final Buffer sink = new Buffer();
-    callback.setNextMessageDelegate(new MessageDelegate() {
-      @Override public void onMessage(ResponseBody message) throws IOException {
-        message.source().read(sink, 3);
-        message.close();
-      }
-    });
-
-    clientReader.processNextFrame();
-    assertEquals("Hel", sink.readUtf8());
-
-    clientReader.processNextFrame();
-    callback.assertTextMessage("Hey!");
-  }
-
-  @Test public void closeExhaustsMessageOverControlFrames() throws IOException {
-    data.write(ByteString.decodeHex("010348656c")); // Hel
-    data.write(ByteString.decodeHex("8a00")); // Pong
-    data.write(ByteString.decodeHex("8a00")); // Pong
-    data.write(ByteString.decodeHex("80026c6f")); // lo
-    data.write(ByteString.decodeHex("810448657921")); // Hey!
-
-    final Buffer sink = new Buffer();
-    callback.setNextMessageDelegate(new MessageDelegate() {
-      @Override public void onMessage(ResponseBody message) throws IOException {
-        message.source().read(sink, 2);
-        message.close();
-      }
-    });
-
-    clientReader.processNextFrame();
-    assertEquals("He", sink.readUtf8());
-    callback.assertPong(null);
-    callback.assertPong(null);
-
-    clientReader.processNextFrame();
-    callback.assertTextMessage("Hey!");
-  }
-
-  @Test public void closedMessageSourceThrows() throws IOException {
-    data.write(ByteString.decodeHex("810548656c6c6f")); // Hello
-
-    final AtomicReference<Exception> exception = new AtomicReference<>();
-    callback.setNextMessageDelegate(new MessageDelegate() {
-      @Override public void onMessage(ResponseBody message) throws IOException {
-        message.close();
-        try {
-          message.source().readAll(new Buffer());
-          fail();
-        } catch (IllegalStateException e) {
-          exception.set(e);
-        }
-      }
-    });
-    clientReader.processNextFrame();
-
-    assertNotNull(exception.get());
-  }
-
   @Test public void emptyPingCallsCallback() throws IOException {
     data.write(ByteString.decodeHex("8900")); // Empty ping
     clientReader.processNextFrame();
-    callback.assertPing(null);
+    callback.assertPing(ByteString.EMPTY);
   }
 
   @Test public void pingCallsCallback() throws IOException {
     data.write(ByteString.decodeHex("890548656c6c6f")); // Ping with "Hello"
     clientReader.processNextFrame();
-    callback.assertPing(new Buffer().writeUtf8("Hello"));
+    callback.assertPing(ByteString.encodeUtf8("Hello"));
   }
 
   @Test public void emptyCloseCallsCallback() throws IOException {
     data.write(ByteString.decodeHex("8800")); // Empty close
     clientReader.processNextFrame();
-    callback.assertClose(1000, "");
+    callback.assertClosing(1005, "");
   }
 
   @Test public void closeLengthOfOneThrows() throws IOException {
@@ -361,7 +268,14 @@
   @Test public void closeCallsCallback() throws IOException {
     data.write(ByteString.decodeHex("880703e848656c6c6f")); // Close with code and reason
     clientReader.processNextFrame();
-    callback.assertClose(1000, "Hello");
+    callback.assertClosing(1000, "Hello");
+  }
+
+  @Test public void closeIncompleteCallsCallback() throws IOException {
+    data.write(ByteString.decodeHex("880703e948656c6c6f")); // Close with code and reason
+    data.close();
+    clientReader.processNextFrame();
+    callback.assertClosing(1001, "Hello");
   }
 
   @Test public void closeOutOfRangeThrows() throws IOException {
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java
new file mode 100644
index 0000000000..f6256ac42f
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java
@@ -0,0 +1,406 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.ws;
+
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.TimeUnit;
+import javax.annotation.Nullable;
+import okhttp3.Response;
+import okhttp3.WebSocket;
+import okhttp3.WebSocketListener;
+import okhttp3.internal.Util;
+import okhttp3.internal.platform.Platform;
+import okio.ByteString;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
+
+public final class WebSocketRecorder extends WebSocketListener {
+  private final String name;
+  private final BlockingQueue<Object> events = new LinkedBlockingQueue<>();
+  private WebSocketListener delegate;
+
+  public WebSocketRecorder(String name) {
+    this.name = name;
+  }
+
+  /** Sets a delegate for handling the next callback to this listener. Cleared after invoked. */
+  public void setNextEventDelegate(WebSocketListener delegate) {
+    this.delegate = delegate;
+  }
+
+  @Override public void onOpen(WebSocket webSocket, Response response) {
+    Platform.get().log(Platform.INFO, "[WS " + name + "] onOpen", null);
+
+    WebSocketListener delegate = this.delegate;
+    if (delegate != null) {
+      this.delegate = null;
+      delegate.onOpen(webSocket, response);
+    } else {
+      events.add(new Open(webSocket, response));
+    }
+  }
+
+  @Override public void onMessage(WebSocket webSocket, ByteString bytes) {
+    Platform.get().log(Platform.INFO, "[WS " + name + "] onMessage", null);
+
+    WebSocketListener delegate = this.delegate;
+    if (delegate != null) {
+      this.delegate = null;
+      delegate.onMessage(webSocket, bytes);
+    } else {
+      Message event = new Message(bytes);
+      events.add(event);
+    }
+  }
+
+  @Override public void onMessage(WebSocket webSocket, String text) {
+    Platform.get().log(Platform.INFO, "[WS " + name + "] onMessage", null);
+
+    WebSocketListener delegate = this.delegate;
+    if (delegate != null) {
+      this.delegate = null;
+      delegate.onMessage(webSocket, text);
+    } else {
+      Message event = new Message(text);
+      events.add(event);
+    }
+  }
+
+  @Override public void onClosing(WebSocket webSocket, int code, String reason) {
+    Platform.get().log(Platform.INFO, "[WS " + name + "] onClose " + code, null);
+
+    WebSocketListener delegate = this.delegate;
+    if (delegate != null) {
+      this.delegate = null;
+      delegate.onClosing(webSocket, code, reason);
+    } else {
+      events.add(new Closing(code, reason));
+    }
+  }
+
+  @Override public void onClosed(WebSocket webSocket, int code, String reason) {
+    Platform.get().log(Platform.INFO, "[WS " + name + "] onClose " + code, null);
+
+    WebSocketListener delegate = this.delegate;
+    if (delegate != null) {
+      this.delegate = null;
+      delegate.onClosed(webSocket, code, reason);
+    } else {
+      events.add(new Closed(code, reason));
+    }
+  }
+
+  @Override public void onFailure(WebSocket webSocket, Throwable t, @Nullable Response response)  {
+    Platform.get().log(Platform.INFO, "[WS " + name + "] onFailure", t);
+
+    WebSocketListener delegate = this.delegate;
+    if (delegate != null) {
+      this.delegate = null;
+      delegate.onFailure(webSocket, t, response);
+    } else {
+      events.add(new Failure(t, response));
+    }
+  }
+
+  private Object nextEvent() {
+    try {
+      Object event = events.poll(10, TimeUnit.SECONDS);
+      if (event == null) {
+        throw new AssertionError("Timed out waiting for event.");
+      }
+      return event;
+    } catch (InterruptedException e) {
+      throw new AssertionError(e);
+    }
+  }
+
+  public void assertTextMessage(String payload) {
+    Object actual = nextEvent();
+    assertEquals(new Message(payload), actual);
+  }
+
+  public void assertBinaryMessage(ByteString payload) {
+    Object actual = nextEvent();
+    assertEquals(new Message(payload), actual);
+  }
+
+  public void assertPing(ByteString payload) {
+    Object actual = nextEvent();
+    assertEquals(new Ping(payload), actual);
+  }
+
+  public void assertPong(ByteString payload) {
+    Object actual = nextEvent();
+    assertEquals(new Pong(payload), actual);
+  }
+
+  public void assertClosing(int code, String reason) {
+    Object actual = nextEvent();
+    assertEquals(new Closing(code, reason), actual);
+  }
+
+  public void assertClosed(int code, String reason) {
+    Object actual = nextEvent();
+    assertEquals(new Closed(code, reason), actual);
+  }
+
+  public void assertExhausted() {
+    assertTrue("Remaining events: " + events, events.isEmpty());
+  }
+
+  public WebSocket assertOpen() {
+    Object event = nextEvent();
+    if (!(event instanceof Open)) {
+      throw new AssertionError("Expected Open but was " + event);
+    }
+    return ((Open) event).webSocket;
+  }
+
+  public void assertFailure(Throwable t) {
+    Object event = nextEvent();
+    if (!(event instanceof Failure)) {
+      throw new AssertionError("Expected Failure but was " + event);
+    }
+    Failure failure = (Failure) event;
+    assertNull(failure.response);
+    assertSame(t, failure.t);
+  }
+
+  public void assertFailure(Class<? extends IOException> cls, String... messages) {
+    Object event = nextEvent();
+    if (!(event instanceof Failure)) {
+      throw new AssertionError("Expected Failure but was " + event);
+    }
+    Failure failure = (Failure) event;
+    assertNull(failure.response);
+    assertEquals(cls, failure.t.getClass());
+    if (messages.length > 0) {
+      assertTrue(failure.t.getMessage(), Arrays.asList(messages).contains(failure.t.getMessage()));
+    }
+  }
+
+  public void assertFailure() {
+    Object event = nextEvent();
+    if (!(event instanceof Failure)) {
+      throw new AssertionError("Expected Failure but was " + event);
+    }
+  }
+
+  public void assertFailure(int code, String body, Class<? extends IOException> cls, String message)
+      throws IOException {
+    Object event = nextEvent();
+    if (!(event instanceof Failure)) {
+      throw new AssertionError("Expected Failure but was " + event);
+    }
+    Failure failure = (Failure) event;
+    assertEquals(code, failure.response.code());
+    if (body != null) {
+      assertEquals(body, failure.responseBody);
+    }
+    assertEquals(cls, failure.t.getClass());
+    assertEquals(message, failure.t.getMessage());
+  }
+
+  /** Expose this recorder as a frame callback and shim in "ping" events. */
+  public WebSocketReader.FrameCallback asFrameCallback() {
+    return new WebSocketReader.FrameCallback() {
+      @Override public void onReadMessage(String text) throws IOException {
+        onMessage(null, text);
+      }
+
+      @Override public void onReadMessage(ByteString bytes) throws IOException {
+        onMessage(null, bytes);
+      }
+
+      @Override public void onReadPing(ByteString payload) {
+        events.add(new Ping(payload));
+      }
+
+      @Override public void onReadPong(ByteString payload) {
+        events.add(new Pong(payload));
+      }
+
+      @Override public void onReadClose(int code, String reason) {
+        onClosing(null, code, reason);
+      }
+    };
+  }
+
+  static final class Open {
+    final WebSocket webSocket;
+    final Response response;
+
+    Open(WebSocket webSocket, Response response) {
+      this.webSocket = webSocket;
+      this.response = response;
+    }
+
+    @Override public String toString() {
+      return "Open[" + response + "]";
+    }
+  }
+
+  static final class Failure {
+    final Throwable t;
+    final Response response;
+    final String responseBody;
+
+    Failure(Throwable t, Response response) {
+      this.t = t;
+      this.response = response;
+      String responseBody = null;
+      if (response != null) {
+        try {
+          responseBody = response.body().string();
+        } catch (IOException ignored) {
+        }
+      }
+      this.responseBody = responseBody;
+    }
+
+    @Override public String toString() {
+      if (response == null) {
+        return "Failure[" + t + "]";
+      }
+      return "Failure[" + response + "]";
+    }
+  }
+
+  static final class Message {
+    public final ByteString bytes;
+    public final String string;
+
+    public Message(ByteString bytes) {
+      this.bytes = bytes;
+      this.string = null;
+    }
+
+    public Message(String string) {
+      this.bytes = null;
+      this.string = string;
+    }
+
+    @Override public String toString() {
+      return "Message[" + (bytes != null ? bytes : string) + "]";
+    }
+
+    @Override public int hashCode() {
+      return (bytes != null ? bytes : string).hashCode();
+    }
+
+    @Override public boolean equals(Object other) {
+      return other instanceof Message
+          && Util.equal(((Message) other).bytes, bytes)
+          && Util.equal(((Message) other).string, string);
+    }
+  }
+
+  static final class Ping {
+    public final ByteString payload;
+
+    public Ping(ByteString payload) {
+      this.payload = payload;
+    }
+
+    @Override public String toString() {
+      return "Ping[" + payload + "]";
+    }
+
+    @Override public int hashCode() {
+      return payload.hashCode();
+    }
+
+    @Override public boolean equals(Object other) {
+      return other instanceof Ping
+          && ((Ping) other).payload.equals(payload);
+    }
+  }
+
+  static final class Pong {
+    public final ByteString payload;
+
+    public Pong(ByteString payload) {
+      this.payload = payload;
+    }
+
+    @Override public String toString() {
+      return "Pong[" + payload + "]";
+    }
+
+    @Override public int hashCode() {
+      return payload.hashCode();
+    }
+
+    @Override public boolean equals(Object other) {
+      return other instanceof Pong
+          && ((Pong) other).payload.equals(payload);
+    }
+  }
+
+  static final class Closing {
+    public final int code;
+    public final String reason;
+
+    Closing(int code, String reason) {
+      this.code = code;
+      this.reason = reason;
+    }
+
+    @Override public String toString() {
+      return "Closing[" + code + " " + reason + "]";
+    }
+
+    @Override public int hashCode() {
+      return code * 37 + reason.hashCode();
+    }
+
+    @Override public boolean equals(Object other) {
+      return other instanceof Closing
+          && ((Closing) other).code == code
+          && ((Closing) other).reason.equals(reason);
+    }
+  }
+
+  static final class Closed {
+    public final int code;
+    public final String reason;
+
+    Closed(int code, String reason) {
+      this.code = code;
+      this.reason = reason;
+    }
+
+    @Override public String toString() {
+      return "Closed[" + code + " " + reason + "]";
+    }
+
+    @Override public int hashCode() {
+      return code * 37 + reason.hashCode();
+    }
+
+    @Override public boolean equals(Object other) {
+      return other instanceof Closed
+          && ((Closed) other).code == code
+          && ((Closed) other).reason.equals(reason);
+    }
+  }
+}
diff --git a/okhttp-ws-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java
similarity index 92%
rename from okhttp-ws-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java
rename to okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java
index 384151cf4a..a303cc1052 100644
--- a/okhttp-ws-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java
@@ -31,6 +31,7 @@
 import org.junit.runner.Description;
 import org.junit.runners.model.Statement;
 
+import static okhttp3.TestUtil.repeat;
 import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_BINARY;
 import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_TEXT;
 import static okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_BYTE_MAX;
@@ -263,7 +264,7 @@
   }
 
   @Test public void serverCloseWithCodeAndReason() throws IOException {
-    serverWriter.writeClose(1001, "Hello");
+    serverWriter.writeClose(1001, ByteString.encodeUtf8("Hello"));
     assertData("880703e948656c6c6f");
   }
 
@@ -278,18 +279,18 @@
   }
 
   @Test public void clientCloseWithCodeAndReason() throws IOException {
-    clientWriter.writeClose(1001, "Hello");
+    clientWriter.writeClose(1001, ByteString.encodeUtf8("Hello"));
     assertData("888760b420bb635d68de0cd84f");
   }
 
   @Test public void closeWithOnlyReasonThrows() throws IOException {
-    clientWriter.writeClose(0, "Hello");
+    clientWriter.writeClose(0, ByteString.encodeUtf8("Hello"));
     assertData("888760b420bb60b468de0cd84f");
   }
 
   @Test public void closeCodeOutOfRangeThrows() throws IOException {
     try {
-      clientWriter.writeClose(98724976, "Hello");
+      clientWriter.writeClose(98724976, ByteString.encodeUtf8("Hello"));
       fail();
     } catch (IllegalArgumentException e) {
       assertEquals("Code must be in range [1000,5000): 98724976", e.getMessage());
@@ -298,7 +299,7 @@
 
   @Test public void closeReservedThrows() throws IOException {
     try {
-      clientWriter.writeClose(1005, "Hello");
+      clientWriter.writeClose(1005, ByteString.encodeUtf8("Hello"));
       fail();
     } catch (IllegalArgumentException e) {
       assertEquals("Code 1005 is reserved and may not be used.", e.getMessage());
@@ -306,48 +307,48 @@
   }
 
   @Test public void serverEmptyPing() throws IOException {
-    serverWriter.writePing(null);
+    serverWriter.writePing(ByteString.EMPTY);
     assertData("8900");
   }
 
   @Test public void clientEmptyPing() throws IOException {
-    clientWriter.writePing(null);
+    clientWriter.writePing(ByteString.EMPTY);
     assertData("898060b420bb");
   }
 
   @Test public void serverPingWithPayload() throws IOException {
-    serverWriter.writePing(new Buffer().writeUtf8("Hello"));
+    serverWriter.writePing(ByteString.encodeUtf8("Hello"));
     assertData("890548656c6c6f");
   }
 
   @Test public void clientPingWithPayload() throws IOException {
-    clientWriter.writePing(new Buffer().writeUtf8("Hello"));
+    clientWriter.writePing(ByteString.encodeUtf8("Hello"));
     assertData("898560b420bb28d14cd70f");
   }
 
   @Test public void serverEmptyPong() throws IOException {
-    serverWriter.writePong(null);
+    serverWriter.writePong(ByteString.EMPTY);
     assertData("8a00");
   }
 
   @Test public void clientEmptyPong() throws IOException {
-    clientWriter.writePong(null);
+    clientWriter.writePong(ByteString.EMPTY);
     assertData("8a8060b420bb");
   }
 
   @Test public void serverPongWithPayload() throws IOException {
-    serverWriter.writePong(new Buffer().writeUtf8("Hello"));
+    serverWriter.writePong(ByteString.encodeUtf8("Hello"));
     assertData("8a0548656c6c6f");
   }
 
   @Test public void clientPongWithPayload() throws IOException {
-    clientWriter.writePong(new Buffer().writeUtf8("Hello"));
+    clientWriter.writePong(ByteString.encodeUtf8("Hello"));
     assertData("8a8560b420bb28d14cd70f");
   }
 
   @Test public void pingTooLongThrows() throws IOException {
     try {
-      serverWriter.writePing(new Buffer().write(binaryData(1000)));
+      serverWriter.writePing(ByteString.of(binaryData(1000)));
       fail();
     } catch (IllegalArgumentException e) {
       assertEquals("Payload size must be less than or equal to 125", e.getMessage());
@@ -356,7 +357,7 @@
 
   @Test public void pongTooLongThrows() throws IOException {
     try {
-      serverWriter.writePong(new Buffer().write(binaryData(1000)));
+      serverWriter.writePong(ByteString.of(binaryData(1000)));
       fail();
     } catch (IllegalArgumentException e) {
       assertEquals("Payload size must be less than or equal to 125", e.getMessage());
@@ -365,8 +366,8 @@
 
   @Test public void closeTooLongThrows() throws IOException {
     try {
-      String longString = ByteString.of(binaryData(75)).hex();
-      serverWriter.writeClose(1000, longString);
+      ByteString longReason = ByteString.encodeUtf8(repeat('X', 124));
+      serverWriter.writeClose(1000, longReason);
       fail();
     } catch (IllegalArgumentException e) {
       assertEquals("Payload size must be less than or equal to 125", e.getMessage());
diff --git a/okhttp-urlconnection/pom.xml b/okhttp-urlconnection/pom.xml
index 3aaa66dbdd..3894bbcd83 100644
--- a/okhttp-urlconnection/pom.xml
+++ b/okhttp-urlconnection/pom.xml
@@ -6,13 +6,24 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.4.0-SNAPSHOT</version>
+    <version>3.10.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-urlconnection</artifactId>
   <name>OkHttp URLConnection</name>
 
   <dependencies>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.codehaus.mojo</groupId>
+      <artifactId>animal-sniffer-annotations</artifactId>
+      <version>${animal.sniffer.version}</version>
+      <optional>true</optional>
+    </dependency>
     <dependency>
       <groupId>${project.groupId}</groupId>
       <artifactId>okhttp</artifactId>
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/JavaNetAuthenticator.java b/okhttp-urlconnection/src/main/java/okhttp3/JavaNetAuthenticator.java
index b5440a4d02..2649510d35 100644
--- a/okhttp-urlconnection/src/main/java/okhttp3/JavaNetAuthenticator.java
+++ b/okhttp-urlconnection/src/main/java/okhttp3/JavaNetAuthenticator.java
@@ -54,7 +54,8 @@
       }
 
       if (auth != null) {
-        String credential = Credentials.basic(auth.getUserName(), new String(auth.getPassword()));
+        String credential = Credentials.basic(
+            auth.getUserName(), new String(auth.getPassword()), challenge.charset());
         return request.newBuilder()
             .header(proxyAuthorization ? "Proxy-Authorization" : "Authorization", credential)
             .build();
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/JavaNetCookieJar.java b/okhttp-urlconnection/src/main/java/okhttp3/JavaNetCookieJar.java
index 6af8a69b65..5d4f671a31 100644
--- a/okhttp-urlconnection/src/main/java/okhttp3/JavaNetCookieJar.java
+++ b/okhttp-urlconnection/src/main/java/okhttp3/JavaNetCookieJar.java
@@ -22,11 +22,11 @@
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
-import okhttp3.internal.Platform;
+import okhttp3.internal.platform.Platform;
 
-import static okhttp3.internal.Platform.WARN;
 import static okhttp3.internal.Util.delimiterOffset;
 import static okhttp3.internal.Util.trimSubstring;
+import static okhttp3.internal.platform.Platform.WARN;
 
 /** A cookie jar that delegates to a {@link java.net.CookieHandler}. */
 public final class JavaNetCookieJar implements CookieJar {
@@ -40,7 +40,7 @@ public JavaNetCookieJar(CookieHandler cookieHandler) {
     if (cookieHandler != null) {
       List<String> cookieStrings = new ArrayList<>();
       for (Cookie cookie : cookies) {
-        cookieStrings.add(cookie.toString());
+        cookieStrings.add(cookie.toString(true));
       }
       Map<String, List<String>> multimap = Collections.singletonMap("Set-Cookie", cookieStrings);
       try {
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/OkUrlFactory.java b/okhttp-urlconnection/src/main/java/okhttp3/OkUrlFactory.java
index 973c70578b..0bbe613492 100644
--- a/okhttp-urlconnection/src/main/java/okhttp3/OkUrlFactory.java
+++ b/okhttp-urlconnection/src/main/java/okhttp3/OkUrlFactory.java
@@ -22,8 +22,8 @@
 import java.net.URLStreamHandler;
 import java.net.URLStreamHandlerFactory;
 import okhttp3.internal.URLFilter;
-import okhttp3.internal.huc.HttpURLConnectionImpl;
-import okhttp3.internal.huc.HttpsURLConnectionImpl;
+import okhttp3.internal.huc.OkHttpURLConnection;
+import okhttp3.internal.huc.OkHttpsURLConnection;
 
 /**
  * @deprecated OkHttp will be dropping its ability to be used with {@link HttpURLConnection} in an
@@ -69,8 +69,8 @@ HttpURLConnection open(URL url, Proxy proxy) {
         .proxy(proxy)
         .build();
 
-    if (protocol.equals("http")) return new HttpURLConnectionImpl(url, copy, urlFilter);
-    if (protocol.equals("https")) return new HttpsURLConnectionImpl(url, copy, urlFilter);
+    if (protocol.equals("http")) return new OkHttpURLConnection(url, copy, urlFilter);
+    if (protocol.equals("https")) return new OkHttpsURLConnection(url, copy, urlFilter);
     throw new IllegalArgumentException("Unexpected protocol: " + protocol);
   }
 
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/SystemPropertiesConnectionPool.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/SystemPropertiesConnectionPool.java
deleted file mode 100644
index e0c9523fb0..0000000000
--- a/okhttp-urlconnection/src/main/java/okhttp3/internal/SystemPropertiesConnectionPool.java
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package okhttp3.internal;
-
-import java.util.concurrent.TimeUnit;
-import okhttp3.ConnectionPool;
-
-/**
- * A shared connection pool that uses system properties for tuning parameters:
- *
- * <ul>
- *     <li>{@code http.keepAlive} true if HTTP and SPDY connections should be pooled at all. Default
- *         is true.
- *     <li>{@code http.maxConnections} maximum number of idle connections to each to keep in the
- *         pool. Default is 5.
- *     <li>{@code http.keepAliveDuration} Time in milliseconds to keep the connection alive in the
- *         pool before closing it. Default is 5 minutes. This property isn't used by {@code
- *         HttpURLConnection}.
- * </ul>
- *
- * <p>The default instance <i>doesn't</i> adjust its configuration as system properties are changed.
- * This assumes that the applications that set these parameters do so before making HTTP
- * connections, and that this class is initialized lazily.
- */
-public final class SystemPropertiesConnectionPool {
-  private static final long DEFAULT_KEEP_ALIVE_DURATION_MS = 5 * 60 * 1000; // 5 min
-
-  public static final ConnectionPool INSTANCE;
-  static {
-    String keepAlive = System.getProperty("http.keepAlive");
-    int maxIdleConnections;
-    if (keepAlive != null && !Boolean.parseBoolean(keepAlive)) {
-      maxIdleConnections = 0;
-    } else {
-      String maxIdleConnectionsString = System.getProperty("http.maxConnections");
-      if (maxIdleConnectionsString != null) {
-        maxIdleConnections = Integer.parseInt(maxIdleConnectionsString);
-      } else {
-        maxIdleConnections = 5;
-      }
-    }
-
-    String keepAliveDurationString = System.getProperty("http.keepAliveDuration");
-    long keepAliveDurationMs = keepAliveDurationString != null
-        ? Long.parseLong(keepAliveDurationString)
-        : DEFAULT_KEEP_ALIVE_DURATION_MS;
-
-    INSTANCE = new ConnectionPool(maxIdleConnections, keepAliveDurationMs, TimeUnit.MILLISECONDS);
-  }
-
-  private SystemPropertiesConnectionPool() {
-  }
-}
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/BufferedRequestBody.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/BufferedRequestBody.java
new file mode 100644
index 0000000000..b4b2f68347
--- /dev/null
+++ b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/BufferedRequestBody.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.huc;
+
+import java.io.IOException;
+import okhttp3.Request;
+import okio.Buffer;
+import okio.BufferedSink;
+
+/**
+ * This request body involves an application thread only. First all bytes are written to the buffer.
+ * Only once that is complete are bytes then copied to the network.
+ *
+ * <p>This body has two special powers. First, it can retransmit the same request body multiple
+ * times in order to recover from failures or cope with redirects. Second, it can compute the total
+ * length of the request body by measuring it after it has been written to the output stream.
+ */
+final class BufferedRequestBody extends OutputStreamRequestBody {
+  final Buffer buffer = new Buffer();
+  long contentLength = -1L;
+
+  BufferedRequestBody(long expectedContentLength) {
+    initOutputStream(buffer, expectedContentLength);
+  }
+
+  @Override public long contentLength() throws IOException {
+    return contentLength;
+  }
+
+  /**
+   * Now that we've buffered the entire request body, update the request headers and the body
+   * itself. This happens late to enable HttpURLConnection users to complete the socket connection
+   * before sending request body bytes.
+   */
+  @Override public Request prepareToSendRequest(Request request) throws IOException {
+    if (request.header("Content-Length") != null) return request;
+
+    outputStream().close();
+    contentLength = buffer.size();
+    return request.newBuilder()
+        .removeHeader("Transfer-Encoding")
+        .header("Content-Length", Long.toString(buffer.size()))
+        .build();
+  }
+
+  @Override public void writeTo(BufferedSink sink) throws IOException {
+    buffer.copyTo(sink.buffer(), 0, buffer.size());
+  }
+}
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/DelegatingHttpsURLConnection.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/DelegatingHttpsURLConnection.java
index 86f4aa7807..a051bf2198 100644
--- a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/DelegatingHttpsURLConnection.java
+++ b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/DelegatingHttpsURLConnection.java
@@ -32,6 +32,7 @@
 import javax.net.ssl.SSLPeerUnverifiedException;
 import javax.net.ssl.SSLSocketFactory;
 import okhttp3.Handshake;
+import org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement;
 
 /**
  * Implement an HTTPS connection by delegating to an HTTP connection for everything but the
@@ -40,7 +41,7 @@
 abstract class DelegatingHttpsURLConnection extends HttpsURLConnection {
   private final HttpURLConnection delegate;
 
-  public DelegatingHttpsURLConnection(HttpURLConnection delegate) {
+  DelegatingHttpsURLConnection(HttpURLConnection delegate) {
     super(delegate.getURL());
     this.delegate = delegate;
   }
@@ -146,6 +147,11 @@ public DelegatingHttpsURLConnection(HttpURLConnection delegate) {
     return delegate.getContentLength();
   }
 
+  @IgnoreJRERequirement // Should only be invoked on Java 7+.
+  @Override public long getContentLengthLong() {
+    return delegate.getContentLengthLong();
+  }
+
   @Override public String getContentType() {
     return delegate.getContentType();
   }
@@ -190,6 +196,11 @@ public DelegatingHttpsURLConnection(HttpURLConnection delegate) {
     return delegate.getHeaderField(key);
   }
 
+  @IgnoreJRERequirement // Should only be invoked on Java 7+.
+  @Override public long getHeaderFieldLong(String field, long defaultValue) {
+    return delegate.getHeaderFieldLong(field, defaultValue);
+  }
+
   @Override public long getHeaderFieldDate(String field, long defaultValue) {
     return delegate.getHeaderFieldDate(field, defaultValue);
   }
@@ -250,6 +261,11 @@ public DelegatingHttpsURLConnection(HttpURLConnection delegate) {
     delegate.setDoOutput(newValue);
   }
 
+  @IgnoreJRERequirement // Should only be invoked on Java 7+.
+  @Override public void setFixedLengthStreamingMode(long contentLength) {
+    delegate.setFixedLengthStreamingMode(contentLength);
+  }
+
   @Override public void setIfModifiedSince(long newValue) {
     delegate.setIfModifiedSince(newValue);
   }
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/HttpURLConnectionImpl.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/HttpURLConnectionImpl.java
deleted file mode 100644
index 08f73710dd..0000000000
--- a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/HttpURLConnectionImpl.java
+++ /dev/null
@@ -1,654 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package okhttp3.internal.huc;
-
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.net.HttpRetryException;
-import java.net.HttpURLConnection;
-import java.net.InetSocketAddress;
-import java.net.MalformedURLException;
-import java.net.ProtocolException;
-import java.net.Proxy;
-import java.net.SocketPermission;
-import java.net.URL;
-import java.net.UnknownHostException;
-import java.security.Permission;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.Date;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.concurrent.TimeUnit;
-import okhttp3.Connection;
-import okhttp3.Handshake;
-import okhttp3.Headers;
-import okhttp3.HttpUrl;
-import okhttp3.OkHttpClient;
-import okhttp3.Protocol;
-import okhttp3.Request;
-import okhttp3.RequestBody;
-import okhttp3.Response;
-import okhttp3.Route;
-import okhttp3.internal.Internal;
-import okhttp3.internal.JavaNetHeaders;
-import okhttp3.internal.Platform;
-import okhttp3.internal.URLFilter;
-import okhttp3.internal.Util;
-import okhttp3.internal.Version;
-import okhttp3.internal.http.HttpDate;
-import okhttp3.internal.http.HttpEngine;
-import okhttp3.internal.http.HttpMethod;
-import okhttp3.internal.http.OkHeaders;
-import okhttp3.internal.http.RequestException;
-import okhttp3.internal.http.RetryableSink;
-import okhttp3.internal.http.RouteException;
-import okhttp3.internal.http.StatusLine;
-import okhttp3.internal.http.StreamAllocation;
-import okio.BufferedSink;
-import okio.Sink;
-
-import static okhttp3.internal.Platform.WARN;
-
-/**
- * This implementation uses HttpEngine to send requests and receive responses. This class may use
- * multiple HttpEngines to follow redirects, authentication retries, etc. to retrieve the final
- * response body.
- *
- * <h3>What does 'connected' mean?</h3> This class inherits a {@code connected} field from the
- * superclass. That field is <strong>not</strong> used to indicate whether this URLConnection is
- * currently connected. Instead, it indicates whether a connection has ever been attempted. Once a
- * connection has been attempted, certain properties (request header fields, request method, etc.)
- * are immutable.
- */
-public class HttpURLConnectionImpl extends HttpURLConnection {
-  private static final Set<String> METHODS = new LinkedHashSet<>(
-      Arrays.asList("OPTIONS", "GET", "HEAD", "POST", "PUT", "DELETE", "TRACE", "PATCH"));
-  private static final RequestBody EMPTY_REQUEST_BODY = RequestBody.create(null, new byte[0]);
-
-  OkHttpClient client;
-
-  private Headers.Builder requestHeaders = new Headers.Builder();
-
-  /** Like the superclass field of the same name, but a long and available on all platforms. */
-  private long fixedContentLength = -1;
-  private int followUpCount;
-  protected IOException httpEngineFailure;
-  protected HttpEngine httpEngine;
-  /** Lazily created (with synthetic headers) on first call to getHeaders(). */
-  private Headers responseHeaders;
-
-  /**
-   * The most recently attempted route. This will be null if we haven't sent a request yet, or if
-   * the response comes from a cache.
-   */
-  private Route route;
-
-  /**
-   * The most recently received TLS handshake. This will be null if we haven't connected yet, or if
-   * the most recent connection was HTTP (and not HTTPS).
-   */
-  Handshake handshake;
-
-  private URLFilter urlFilter;
-
-  public HttpURLConnectionImpl(URL url, OkHttpClient client) {
-    super(url);
-    this.client = client;
-  }
-
-  public HttpURLConnectionImpl(URL url, OkHttpClient client, URLFilter urlFilter) {
-    this(url, client);
-    this.urlFilter = urlFilter;
-  }
-
-  @Override public final void connect() throws IOException {
-    initHttpEngine();
-    boolean success;
-    do {
-      success = execute(false);
-    } while (!success);
-  }
-
-  @Override public final void disconnect() {
-    // Calling disconnect() before a connection exists should have no effect.
-    if (httpEngine == null) return;
-
-    httpEngine.cancel();
-
-    // This doesn't close the stream because doing so would require all stream
-    // access to be synchronized. It's expected that the thread using the
-    // connection will close its streams directly. If it doesn't, the worst
-    // case is that the GzipSource's Inflater won't be released until it's
-    // finalized. (This logs a warning on Android.)
-  }
-
-  /**
-   * Returns an input stream from the server in the case of error such as the requested file (txt,
-   * htm, html) is not found on the remote server.
-   */
-  @Override public final InputStream getErrorStream() {
-    try {
-      HttpEngine response = getResponse();
-      if (HttpEngine.hasBody(response.getResponse())
-          && response.getResponse().code() >= HTTP_BAD_REQUEST) {
-        return response.getResponse().body().byteStream();
-      }
-      return null;
-    } catch (IOException e) {
-      return null;
-    }
-  }
-
-  private Headers getHeaders() throws IOException {
-    if (responseHeaders == null) {
-      Response response = getResponse().getResponse();
-      Headers headers = response.headers();
-      responseHeaders = headers.newBuilder()
-          .add(OkHeaders.SELECTED_PROTOCOL, response.protocol().toString())
-          .add(OkHeaders.RESPONSE_SOURCE, responseSourceHeader(response))
-          .build();
-    }
-    return responseHeaders;
-  }
-
-  private static String responseSourceHeader(Response response) {
-    if (response.networkResponse() == null) {
-      if (response.cacheResponse() == null) {
-        return "NONE";
-      }
-      return "CACHE " + response.code();
-    }
-    if (response.cacheResponse() == null) {
-      return "NETWORK " + response.code();
-    }
-    return "CONDITIONAL_CACHE " + response.networkResponse().code();
-  }
-
-  /**
-   * Returns the value of the field at {@code position}. Returns null if there are fewer than {@code
-   * position} headers.
-   */
-  @Override public final String getHeaderField(int position) {
-    try {
-      Headers headers = getHeaders();
-      if (position < 0 || position >= headers.size()) return null;
-      return headers.value(position);
-    } catch (IOException e) {
-      return null;
-    }
-  }
-
-  /**
-   * Returns the value of the field corresponding to the {@code fieldName}, or null if there is no
-   * such field. If the field has multiple values, the last value is returned.
-   */
-  @Override public final String getHeaderField(String fieldName) {
-    try {
-      return fieldName == null
-          ? StatusLine.get(getResponse().getResponse()).toString()
-          : getHeaders().get(fieldName);
-    } catch (IOException e) {
-      return null;
-    }
-  }
-
-  @Override public final String getHeaderFieldKey(int position) {
-    try {
-      Headers headers = getHeaders();
-      if (position < 0 || position >= headers.size()) return null;
-      return headers.name(position);
-    } catch (IOException e) {
-      return null;
-    }
-  }
-
-  @Override public final Map<String, List<String>> getHeaderFields() {
-    try {
-      return JavaNetHeaders.toMultimap(getHeaders(),
-          StatusLine.get(getResponse().getResponse()).toString());
-    } catch (IOException e) {
-      return Collections.emptyMap();
-    }
-  }
-
-  @Override public final Map<String, List<String>> getRequestProperties() {
-    if (connected) {
-      throw new IllegalStateException(
-          "Cannot access request header fields after connection is set");
-    }
-
-    return JavaNetHeaders.toMultimap(requestHeaders.build(), null);
-  }
-
-  @Override public final InputStream getInputStream() throws IOException {
-    if (!doInput) {
-      throw new ProtocolException("This protocol does not support input");
-    }
-
-    HttpEngine response = getResponse();
-
-    // if the requested file does not exist, throw an exception formerly the
-    // Error page from the server was returned if the requested file was
-    // text/html this has changed to return FileNotFoundException for all
-    // file types
-    if (getResponseCode() >= HTTP_BAD_REQUEST) {
-      throw new FileNotFoundException(url.toString());
-    }
-
-    return response.getResponse().body().byteStream();
-  }
-
-  @Override public final OutputStream getOutputStream() throws IOException {
-    connect();
-
-    BufferedSink sink = httpEngine.getBufferedRequestBody();
-    if (sink == null) {
-      throw new ProtocolException("method does not support a request body: " + method);
-    } else if (httpEngine.hasResponse()) {
-      throw new ProtocolException("cannot write request body after response has been read");
-    }
-
-    return sink.outputStream();
-  }
-
-  @Override public final Permission getPermission() throws IOException {
-    URL url = getURL();
-    String hostname = url.getHost();
-    int hostPort = url.getPort() != -1
-        ? url.getPort()
-        : HttpUrl.defaultPort(url.getProtocol());
-    if (usingProxy()) {
-      InetSocketAddress proxyAddress = (InetSocketAddress) client.proxy().address();
-      hostname = proxyAddress.getHostName();
-      hostPort = proxyAddress.getPort();
-    }
-    return new SocketPermission(hostname + ":" + hostPort, "connect, resolve");
-  }
-
-  @Override public final String getRequestProperty(String field) {
-    if (field == null) return null;
-    return requestHeaders.get(field);
-  }
-
-  @Override public void setConnectTimeout(int timeoutMillis) {
-    client = client.newBuilder()
-        .connectTimeout(timeoutMillis, TimeUnit.MILLISECONDS)
-        .build();
-  }
-
-  @Override
-  public void setInstanceFollowRedirects(boolean followRedirects) {
-    client = client.newBuilder()
-        .followRedirects(followRedirects)
-        .build();
-  }
-
-  @Override public boolean getInstanceFollowRedirects() {
-    return client.followRedirects();
-  }
-
-  @Override public int getConnectTimeout() {
-    return client.connectTimeoutMillis();
-  }
-
-  @Override public void setReadTimeout(int timeoutMillis) {
-    client = client.newBuilder()
-        .readTimeout(timeoutMillis, TimeUnit.MILLISECONDS)
-        .build();
-  }
-
-  @Override public int getReadTimeout() {
-    return client.readTimeoutMillis();
-  }
-
-  private void initHttpEngine() throws IOException {
-    if (httpEngineFailure != null) {
-      throw httpEngineFailure;
-    } else if (httpEngine != null) {
-      return;
-    }
-
-    connected = true;
-    try {
-      if (doOutput) {
-        if (method.equals("GET")) {
-          // they are requesting a stream to write to. This implies a POST method
-          method = "POST";
-        } else if (!HttpMethod.permitsRequestBody(method)) {
-          throw new ProtocolException(method + " does not support writing");
-        }
-      }
-      // If the user set content length to zero, we know there will not be a request body.
-      httpEngine = newHttpEngine(method, null, null, null);
-    } catch (IOException e) {
-      httpEngineFailure = e;
-      throw e;
-    }
-  }
-
-  private HttpEngine newHttpEngine(String method, StreamAllocation streamAllocation,
-      RetryableSink requestBody, Response priorResponse)
-      throws MalformedURLException, UnknownHostException {
-    // OkHttp's Call API requires a placeholder body; the real body will be streamed separately.
-    RequestBody placeholderBody = HttpMethod.requiresRequestBody(method)
-        ? EMPTY_REQUEST_BODY
-        : null;
-    URL url = getURL();
-    HttpUrl httpUrl = Internal.instance.getHttpUrlChecked(url.toString());
-    Request.Builder builder = new Request.Builder()
-        .url(httpUrl)
-        .method(method, placeholderBody);
-    Headers headers = requestHeaders.build();
-    for (int i = 0, size = headers.size(); i < size; i++) {
-      builder.addHeader(headers.name(i), headers.value(i));
-    }
-
-    boolean bufferRequestBody = false;
-    if (HttpMethod.permitsRequestBody(method)) {
-      // Specify how the request body is terminated.
-      if (fixedContentLength != -1) {
-        builder.header("Content-Length", Long.toString(fixedContentLength));
-      } else if (chunkLength > 0) {
-        builder.header("Transfer-Encoding", "chunked");
-      } else {
-        bufferRequestBody = true;
-      }
-
-      // Add a content type for the request body, if one isn't already present.
-      if (headers.get("Content-Type") == null) {
-        builder.header("Content-Type", "application/x-www-form-urlencoded");
-      }
-    }
-
-    if (headers.get("User-Agent") == null) {
-      builder.header("User-Agent", defaultUserAgent());
-    }
-
-    Request request = builder.build();
-
-    // If we're currently not using caches, make sure the engine's client doesn't have one.
-    OkHttpClient engineClient = client;
-    if (Internal.instance.internalCache(engineClient) != null && !getUseCaches()) {
-      engineClient = client.newBuilder()
-          .cache(null)
-          .build();
-    }
-
-    return new HttpEngine(engineClient, request, bufferRequestBody, true, false, streamAllocation,
-        requestBody, priorResponse);
-  }
-
-  private String defaultUserAgent() {
-    String agent = System.getProperty("http.agent");
-    return agent != null ? Util.toHumanReadableAscii(agent) : Version.userAgent();
-  }
-
-  /**
-   * Aggressively tries to get the final HTTP response, potentially making many HTTP requests in the
-   * process in order to cope with redirects and authentication.
-   */
-  private HttpEngine getResponse() throws IOException {
-    initHttpEngine();
-
-    if (httpEngine.hasResponse()) {
-      return httpEngine;
-    }
-
-    while (true) {
-      if (!execute(true)) {
-        continue;
-      }
-
-      Response response = httpEngine.getResponse();
-      Request followUp = httpEngine.followUpRequest();
-
-      if (followUp == null) {
-        httpEngine.releaseStreamAllocation();
-        return httpEngine;
-      }
-
-      if (++followUpCount > HttpEngine.MAX_FOLLOW_UPS) {
-        throw new ProtocolException("Too many follow-up requests: " + followUpCount);
-      }
-
-      // The first request was insufficient. Prepare for another...
-      url = followUp.url().url();
-      requestHeaders = followUp.headers().newBuilder();
-
-      // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM redirect
-      // should keep the same method, Chrome, Firefox and the RI all issue GETs
-      // when following any redirect.
-      Sink requestBody = httpEngine.getRequestBody();
-      if (!followUp.method().equals(method)) {
-        requestBody = null;
-      }
-
-      if (requestBody != null && !(requestBody instanceof RetryableSink)) {
-        throw new HttpRetryException("Cannot retry streamed HTTP body", responseCode);
-      }
-
-      StreamAllocation streamAllocation = httpEngine.close();
-      if (!httpEngine.sameConnection(followUp.url())) {
-        streamAllocation.release();
-        streamAllocation = null;
-      }
-
-      httpEngine = newHttpEngine(followUp.method(), streamAllocation, (RetryableSink) requestBody,
-          response);
-    }
-  }
-
-  /**
-   * Sends a request and optionally reads a response. Returns true if the request was successfully
-   * executed, and false if the request can be retried. Throws an exception if the request failed
-   * permanently.
-   */
-  private boolean execute(boolean readResponse) throws IOException {
-    boolean releaseConnection = true;
-    if (urlFilter != null) {
-      urlFilter.checkURLPermitted(httpEngine.getRequest().url().url());
-    }
-    try {
-      httpEngine.sendRequest();
-      Connection connection = httpEngine.getConnection();
-      if (connection != null) {
-        route = connection.route();
-        handshake = connection.handshake();
-      } else {
-        route = null;
-        handshake = null;
-      }
-      if (readResponse) {
-        httpEngine.readResponse();
-      }
-      releaseConnection = false;
-
-      return true;
-    } catch (RequestException e) {
-      // An attempt to interpret a request failed.
-      IOException toThrow = e.getCause();
-      httpEngineFailure = toThrow;
-      throw toThrow;
-    } catch (RouteException e) {
-      // The attempt to connect via a route failed. The request will not have been sent.
-      HttpEngine retryEngine = httpEngine.recover(e.getLastConnectException(), true);
-      if (retryEngine != null) {
-        releaseConnection = false;
-        httpEngine = retryEngine;
-        return false;
-      }
-
-      // Give up; recovery is not possible.
-      IOException toThrow = e.getLastConnectException();
-      httpEngineFailure = toThrow;
-      throw toThrow;
-    } catch (IOException e) {
-      // An attempt to communicate with a server failed. The request may have been sent.
-      HttpEngine retryEngine = httpEngine.recover(e, false);
-      if (retryEngine != null) {
-        releaseConnection = false;
-        httpEngine = retryEngine;
-        return false;
-      }
-
-      // Give up; recovery is not possible.
-      httpEngineFailure = e;
-      throw e;
-    } finally {
-      // We're throwing an unchecked exception. Release any resources.
-      if (releaseConnection) {
-        StreamAllocation streamAllocation = httpEngine.close();
-        streamAllocation.release();
-      }
-    }
-  }
-
-  /**
-   * Returns true if either:
-   *
-   * <ul>
-   *   <li>A specific proxy was explicitly configured for this connection.
-   *   <li>The response has already been retrieved, and a proxy was {@link
-   *       java.net.ProxySelector selected} in order to get it.
-   * </ul>
-   *
-   * <p><strong>Warning:</strong> This method may return false before attempting to connect and true
-   * afterwards.
-   */
-  @Override public final boolean usingProxy() {
-    Proxy proxy = route != null
-        ? route.proxy()
-        : client.proxy();
-    return proxy != null && proxy.type() != Proxy.Type.DIRECT;
-  }
-
-  @Override public String getResponseMessage() throws IOException {
-    return getResponse().getResponse().message();
-  }
-
-  @Override public final int getResponseCode() throws IOException {
-    return getResponse().getResponse().code();
-  }
-
-  @Override public final void setRequestProperty(String field, String newValue) {
-    if (connected) {
-      throw new IllegalStateException("Cannot set request property after connection is made");
-    }
-    if (field == null) {
-      throw new NullPointerException("field == null");
-    }
-    if (newValue == null) {
-      // Silently ignore null header values for backwards compatibility with older
-      // android versions as well as with other URLConnection implementations.
-      //
-      // Some implementations send a malformed HTTP header when faced with
-      // such requests, we respect the spec and ignore the header.
-      Platform.get().log(WARN, "Ignoring header " + field + " because its value was null.", null);
-      return;
-    }
-
-    // TODO: Deprecate use of X-Android-Transports header?
-    if ("X-Android-Transports".equals(field) || "X-Android-Protocols".equals(field)) {
-      setProtocols(newValue, false /* append */);
-    } else {
-      requestHeaders.set(field, newValue);
-    }
-  }
-
-  @Override public void setIfModifiedSince(long newValue) {
-    super.setIfModifiedSince(newValue);
-    if (ifModifiedSince != 0) {
-      requestHeaders.set("If-Modified-Since", HttpDate.format(new Date(ifModifiedSince)));
-    } else {
-      requestHeaders.removeAll("If-Modified-Since");
-    }
-  }
-
-  @Override public final void addRequestProperty(String field, String value) {
-    if (connected) {
-      throw new IllegalStateException("Cannot add request property after connection is made");
-    }
-    if (field == null) {
-      throw new NullPointerException("field == null");
-    }
-    if (value == null) {
-      // Silently ignore null header values for backwards compatibility with older
-      // android versions as well as with other URLConnection implementations.
-      //
-      // Some implementations send a malformed HTTP header when faced with
-      // such requests, we respect the spec and ignore the header.
-      Platform.get().log(WARN, "Ignoring header " + field + " because its value was null.", null);
-      return;
-    }
-
-    // TODO: Deprecate use of X-Android-Transports header?
-    if ("X-Android-Transports".equals(field) || "X-Android-Protocols".equals(field)) {
-      setProtocols(value, true /* append */);
-    } else {
-      requestHeaders.add(field, value);
-    }
-  }
-
-  /*
-   * Splits and validates a comma-separated string of protocols.
-   * When append == false, we require that the transport list contains "http/1.1".
-   * Throws {@link IllegalStateException} when one of the protocols isn't
-   * defined in {@link Protocol OkHttp's protocol enumeration}.
-   */
-  private void setProtocols(String protocolsString, boolean append) {
-    List<Protocol> protocolsList = new ArrayList<>();
-    if (append) {
-      protocolsList.addAll(client.protocols());
-    }
-    for (String protocol : protocolsString.split(",", -1)) {
-      try {
-        protocolsList.add(Protocol.get(protocol));
-      } catch (IOException e) {
-        throw new IllegalStateException(e);
-      }
-    }
-    client = client.newBuilder()
-        .protocols(protocolsList)
-        .build();
-  }
-
-  @Override public void setRequestMethod(String method) throws ProtocolException {
-    if (!METHODS.contains(method)) {
-      throw new ProtocolException("Expected one of " + METHODS + " but was " + method);
-    }
-    this.method = method;
-  }
-
-  @Override public void setFixedLengthStreamingMode(int contentLength) {
-    setFixedLengthStreamingMode((long) contentLength);
-  }
-
-  @Override public void setFixedLengthStreamingMode(long contentLength) {
-    if (super.connected) throw new IllegalStateException("Already connected");
-    if (chunkLength > 0) throw new IllegalStateException("Already in chunked mode");
-    if (contentLength < 0) throw new IllegalArgumentException("contentLength < 0");
-    this.fixedContentLength = contentLength;
-    super.fixedContentLength = (int) Math.min(contentLength, Integer.MAX_VALUE);
-  }
-}
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpURLConnection.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpURLConnection.java
new file mode 100644
index 0000000000..344a61e446
--- /dev/null
+++ b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpURLConnection.java
@@ -0,0 +1,639 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package okhttp3.internal.huc;
+
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InterruptedIOException;
+import java.io.OutputStream;
+import java.net.HttpURLConnection;
+import java.net.InetSocketAddress;
+import java.net.ProtocolException;
+import java.net.Proxy;
+import java.net.SocketPermission;
+import java.net.URL;
+import java.security.Permission;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.Date;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.TimeUnit;
+import okhttp3.Call;
+import okhttp3.Callback;
+import okhttp3.Dispatcher;
+import okhttp3.Handshake;
+import okhttp3.Headers;
+import okhttp3.HttpUrl;
+import okhttp3.Interceptor;
+import okhttp3.OkHttpClient;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.internal.Internal;
+import okhttp3.internal.JavaNetHeaders;
+import okhttp3.internal.URLFilter;
+import okhttp3.internal.Util;
+import okhttp3.internal.Version;
+import okhttp3.internal.http.HttpDate;
+import okhttp3.internal.http.HttpHeaders;
+import okhttp3.internal.http.HttpMethod;
+import okhttp3.internal.http.StatusLine;
+import okhttp3.internal.platform.Platform;
+
+import static okhttp3.internal.platform.Platform.WARN;
+
+/**
+ * This implementation uses {@linkplain Call} to send requests and receive responses.
+ *
+ * <h3>What does 'connected' mean?</h3> This class inherits a {@code connected} field from the
+ * superclass. That field is <strong>not</strong> used to indicate whether this URLConnection is
+ * currently connected. Instead, it indicates whether a connection has ever been attempted. Once a
+ * connection has been attempted, certain properties (request header fields, request method, etc.)
+ * are immutable.
+ */
+public final class OkHttpURLConnection extends HttpURLConnection implements Callback {
+  /**
+   * Synthetic response header: the selected {@link Protocol protocol} ("spdy/3.1", "http/1.1",
+   * etc).
+   */
+  public static final String SELECTED_PROTOCOL = Platform.get().getPrefix() + "-Selected-Protocol";
+
+  /** Synthetic response header: the location from which the response was loaded. */
+  public static final String RESPONSE_SOURCE = Platform.get().getPrefix() + "-Response-Source";
+
+  private static final Set<String> METHODS = new LinkedHashSet<>(
+      Arrays.asList("OPTIONS", "GET", "HEAD", "POST", "PUT", "DELETE", "TRACE", "PATCH"));
+
+  // These fields are confined to the application thread that uses HttpURLConnection.
+
+  OkHttpClient client;
+  private final NetworkInterceptor networkInterceptor = new NetworkInterceptor();
+  private Headers.Builder requestHeaders = new Headers.Builder();
+  private boolean executed;
+  Call call;
+  URLFilter urlFilter;
+
+  /** Lazily created (with synthetic headers) on first call to getHeaders(). */
+  private Headers responseHeaders;
+
+  /** Like the superclass field of the same name, but a long and available on all platforms. */
+  private long fixedContentLength = -1L;
+
+  // These fields are guarded by lock.
+  private final Object lock = new Object();
+  private Response response;
+  private Throwable callFailure;
+  Response networkResponse;
+  boolean connectPending = true;
+  Proxy proxy;
+  Handshake handshake;
+
+  public OkHttpURLConnection(URL url, OkHttpClient client) {
+    super(url);
+    this.client = client;
+  }
+
+  public OkHttpURLConnection(URL url, OkHttpClient client, URLFilter urlFilter) {
+    this(url, client);
+    this.urlFilter = urlFilter;
+  }
+
+  @Override public void connect() throws IOException {
+    if (executed) return;
+
+    Call call = buildCall();
+    executed = true;
+    call.enqueue(this);
+
+    synchronized (lock) {
+      try {
+        while (connectPending && response == null && callFailure == null) {
+          lock.wait(); // Wait 'til the network interceptor is reached or the call fails.
+        }
+        if (callFailure != null) {
+          throw propagate(callFailure);
+        }
+      } catch (InterruptedException e) {
+        throw new InterruptedIOException();
+      }
+    }
+  }
+
+  @Override public void disconnect() {
+    // Calling disconnect() before a connection exists should have no effect.
+    if (call == null) return;
+
+    networkInterceptor.proceed(); // Unblock any waiting async thread.
+    call.cancel();
+  }
+
+  /**
+   * Returns an input stream from the server in the case of error such as the requested file (txt,
+   * htm, html) is not found on the remote server.
+   */
+  @Override public InputStream getErrorStream() {
+    try {
+      Response response = getResponse(true);
+      if (HttpHeaders.hasBody(response) && response.code() >= HTTP_BAD_REQUEST) {
+        return response.body().byteStream();
+      }
+      return null;
+    } catch (IOException e) {
+      return null;
+    }
+  }
+
+  private Headers getHeaders() throws IOException {
+    if (responseHeaders == null) {
+      Response response = getResponse(true);
+      Headers headers = response.headers();
+      responseHeaders = headers.newBuilder()
+          .add(SELECTED_PROTOCOL, response.protocol().toString())
+          .add(RESPONSE_SOURCE, responseSourceHeader(response))
+          .build();
+    }
+    return responseHeaders;
+  }
+
+  private static String responseSourceHeader(Response response) {
+    if (response.networkResponse() == null) {
+      if (response.cacheResponse() == null) {
+        return "NONE";
+      }
+      return "CACHE " + response.code();
+    }
+    if (response.cacheResponse() == null) {
+      return "NETWORK " + response.code();
+    }
+    return "CONDITIONAL_CACHE " + response.networkResponse().code();
+  }
+
+  /**
+   * Returns the value of the field at {@code position}. Returns null if there are fewer than {@code
+   * position} headers.
+   */
+  @Override public String getHeaderField(int position) {
+    try {
+      Headers headers = getHeaders();
+      if (position < 0 || position >= headers.size()) return null;
+      return headers.value(position);
+    } catch (IOException e) {
+      return null;
+    }
+  }
+
+  /**
+   * Returns the value of the field corresponding to the {@code fieldName}, or null if there is no
+   * such field. If the field has multiple values, the last value is returned.
+   */
+  @Override public String getHeaderField(String fieldName) {
+    try {
+      return fieldName == null
+          ? StatusLine.get(getResponse(true)).toString()
+          : getHeaders().get(fieldName);
+    } catch (IOException e) {
+      return null;
+    }
+  }
+
+  @Override public String getHeaderFieldKey(int position) {
+    try {
+      Headers headers = getHeaders();
+      if (position < 0 || position >= headers.size()) return null;
+      return headers.name(position);
+    } catch (IOException e) {
+      return null;
+    }
+  }
+
+  @Override public Map<String, List<String>> getHeaderFields() {
+    try {
+      return JavaNetHeaders.toMultimap(getHeaders(),
+          StatusLine.get(getResponse(true)).toString());
+    } catch (IOException e) {
+      return Collections.emptyMap();
+    }
+  }
+
+  @Override public Map<String, List<String>> getRequestProperties() {
+    if (connected) {
+      throw new IllegalStateException(
+          "Cannot access request header fields after connection is set");
+    }
+
+    return JavaNetHeaders.toMultimap(requestHeaders.build(), null);
+  }
+
+  @Override public InputStream getInputStream() throws IOException {
+    if (!doInput) {
+      throw new ProtocolException("This protocol does not support input");
+    }
+
+    Response response = getResponse(false);
+
+    if (response.code() >= HTTP_BAD_REQUEST) {
+      throw new FileNotFoundException(url.toString());
+    }
+
+    return response.body().byteStream();
+  }
+
+  @Override public OutputStream getOutputStream() throws IOException {
+    OutputStreamRequestBody requestBody = (OutputStreamRequestBody) buildCall().request().body();
+    if (requestBody == null) {
+      throw new ProtocolException("method does not support a request body: " + method);
+    }
+
+    // If this request needs to stream bytes to the server, build a physical connection immediately
+    // and start streaming those bytes over that connection.
+    if (requestBody instanceof StreamedRequestBody) {
+      connect();
+      networkInterceptor.proceed();
+    }
+
+    if (requestBody.isClosed()) {
+      throw new ProtocolException("cannot write request body after response has been read");
+    }
+
+    return requestBody.outputStream();
+  }
+
+  @Override public Permission getPermission() throws IOException {
+    URL url = getURL();
+    String hostname = url.getHost();
+    int hostPort = url.getPort() != -1
+        ? url.getPort()
+        : HttpUrl.defaultPort(url.getProtocol());
+    if (usingProxy()) {
+      InetSocketAddress proxyAddress = (InetSocketAddress) client.proxy().address();
+      hostname = proxyAddress.getHostName();
+      hostPort = proxyAddress.getPort();
+    }
+    return new SocketPermission(hostname + ":" + hostPort, "connect, resolve");
+  }
+
+  @Override public String getRequestProperty(String field) {
+    if (field == null) return null;
+    return requestHeaders.get(field);
+  }
+
+  @Override public void setConnectTimeout(int timeoutMillis) {
+    client = client.newBuilder()
+        .connectTimeout(timeoutMillis, TimeUnit.MILLISECONDS)
+        .build();
+  }
+
+  @Override public void setInstanceFollowRedirects(boolean followRedirects) {
+    client = client.newBuilder()
+        .followRedirects(followRedirects)
+        .build();
+  }
+
+  @Override public boolean getInstanceFollowRedirects() {
+    return client.followRedirects();
+  }
+
+  @Override public int getConnectTimeout() {
+    return client.connectTimeoutMillis();
+  }
+
+  @Override public void setReadTimeout(int timeoutMillis) {
+    client = client.newBuilder()
+        .readTimeout(timeoutMillis, TimeUnit.MILLISECONDS)
+        .build();
+  }
+
+  @Override public int getReadTimeout() {
+    return client.readTimeoutMillis();
+  }
+
+  private Call buildCall() throws IOException {
+    if (call != null) {
+      return call;
+    }
+
+    connected = true;
+    if (doOutput) {
+      if (method.equals("GET")) {
+        // they are requesting a stream to write to. This implies a POST method
+        method = "POST";
+      } else if (!HttpMethod.permitsRequestBody(method)) {
+        throw new ProtocolException(method + " does not support writing");
+      }
+    }
+
+    if (requestHeaders.get("User-Agent") == null) {
+      requestHeaders.add("User-Agent", defaultUserAgent());
+    }
+
+    OutputStreamRequestBody requestBody = null;
+    if (HttpMethod.permitsRequestBody(method)) {
+      // Add a content type for the request body, if one isn't already present.
+      String contentType = requestHeaders.get("Content-Type");
+      if (contentType == null) {
+        contentType = "application/x-www-form-urlencoded";
+        requestHeaders.add("Content-Type", contentType);
+      }
+
+      boolean stream = fixedContentLength != -1L || chunkLength > 0;
+
+      long contentLength = -1L;
+      String contentLengthString = requestHeaders.get("Content-Length");
+      if (fixedContentLength != -1L) {
+        contentLength = fixedContentLength;
+      } else if (contentLengthString != null) {
+        contentLength = Long.parseLong(contentLengthString);
+      }
+
+      requestBody = stream
+          ? new StreamedRequestBody(contentLength)
+          : new BufferedRequestBody(contentLength);
+      requestBody.timeout().timeout(client.writeTimeoutMillis(), TimeUnit.MILLISECONDS);
+    }
+
+    Request request = new Request.Builder()
+        .url(Internal.instance.getHttpUrlChecked(getURL().toString()))
+        .headers(requestHeaders.build())
+        .method(method, requestBody)
+        .build();
+
+    if (urlFilter != null) {
+      urlFilter.checkURLPermitted(request.url().url());
+    }
+
+    OkHttpClient.Builder clientBuilder = client.newBuilder();
+    clientBuilder.interceptors().clear();
+    clientBuilder.interceptors().add(UnexpectedException.INTERCEPTOR);
+    clientBuilder.networkInterceptors().clear();
+    clientBuilder.networkInterceptors().add(networkInterceptor);
+
+    // Use a separate dispatcher so that limits aren't impacted. But use the same executor service!
+    clientBuilder.dispatcher(new Dispatcher(client.dispatcher().executorService()));
+
+    // If we're currently not using caches, make sure the engine's client doesn't have one.
+    if (!getUseCaches()) {
+      clientBuilder.cache(null);
+    }
+
+    return call = clientBuilder.build().newCall(request);
+  }
+
+  private String defaultUserAgent() {
+    String agent = System.getProperty("http.agent");
+    return agent != null ? Util.toHumanReadableAscii(agent) : Version.userAgent();
+  }
+
+  /**
+   * Aggressively tries to get the final HTTP response, potentially making many HTTP requests in the
+   * process in order to cope with redirects and authentication.
+   */
+  private Response getResponse(boolean networkResponseOnError) throws IOException {
+    synchronized (lock) {
+      if (response != null) return response;
+      if (callFailure != null) {
+        if (networkResponseOnError && networkResponse != null) return networkResponse;
+        throw propagate(callFailure);
+      }
+    }
+
+    Call call = buildCall();
+    networkInterceptor.proceed();
+
+    OutputStreamRequestBody requestBody = (OutputStreamRequestBody) call.request().body();
+    if (requestBody != null) requestBody.outputStream().close();
+
+    if (executed) {
+      synchronized (lock) {
+        try {
+          while (response == null && callFailure == null) {
+            lock.wait(); // Wait until the response is returned or the call fails.
+          }
+        } catch (InterruptedException e) {
+          throw new InterruptedIOException();
+        }
+      }
+    } else {
+      executed = true;
+      try {
+        onResponse(call, call.execute());
+      } catch (IOException e) {
+        onFailure(call, e);
+      }
+    }
+
+    synchronized (lock) {
+      if (callFailure != null) throw propagate(callFailure);
+      if (response != null) return response;
+    }
+
+    throw new AssertionError();
+  }
+
+  /**
+   * Returns true if either:
+   *
+   * <ul>
+   *   <li>A specific proxy was explicitly configured for this connection.
+   *   <li>The response has already been retrieved, and a proxy was {@link
+   *       java.net.ProxySelector selected} in order to get it.
+   * </ul>
+   *
+   * <p><strong>Warning:</strong> This method may return false before attempting to connect and true
+   * afterwards.
+   */
+  @Override public boolean usingProxy() {
+    if (proxy != null) return true;
+    Proxy clientProxy = client.proxy();
+    return clientProxy != null && clientProxy.type() != Proxy.Type.DIRECT;
+  }
+
+  @Override public String getResponseMessage() throws IOException {
+    return getResponse(true).message();
+  }
+
+  @Override public int getResponseCode() throws IOException {
+    return getResponse(true).code();
+  }
+
+  @Override public void setRequestProperty(String field, String newValue) {
+    if (connected) {
+      throw new IllegalStateException("Cannot set request property after connection is made");
+    }
+    if (field == null) {
+      throw new NullPointerException("field == null");
+    }
+    if (newValue == null) {
+      // Silently ignore null header values for backwards compatibility with older
+      // android versions as well as with other URLConnection implementations.
+      //
+      // Some implementations send a malformed HTTP header when faced with
+      // such requests, we respect the spec and ignore the header.
+      Platform.get().log(WARN, "Ignoring header " + field + " because its value was null.", null);
+      return;
+    }
+
+    requestHeaders.set(field, newValue);
+  }
+
+  @Override public void setIfModifiedSince(long newValue) {
+    super.setIfModifiedSince(newValue);
+    if (ifModifiedSince != 0) {
+      requestHeaders.set("If-Modified-Since", HttpDate.format(new Date(ifModifiedSince)));
+    } else {
+      requestHeaders.removeAll("If-Modified-Since");
+    }
+  }
+
+  @Override public void addRequestProperty(String field, String value) {
+    if (connected) {
+      throw new IllegalStateException("Cannot add request property after connection is made");
+    }
+    if (field == null) {
+      throw new NullPointerException("field == null");
+    }
+    if (value == null) {
+      // Silently ignore null header values for backwards compatibility with older
+      // android versions as well as with other URLConnection implementations.
+      //
+      // Some implementations send a malformed HTTP header when faced with
+      // such requests, we respect the spec and ignore the header.
+      Platform.get().log(WARN, "Ignoring header " + field + " because its value was null.", null);
+      return;
+    }
+
+    requestHeaders.add(field, value);
+  }
+
+  @Override public void setRequestMethod(String method) throws ProtocolException {
+    if (!METHODS.contains(method)) {
+      throw new ProtocolException("Expected one of " + METHODS + " but was " + method);
+    }
+    this.method = method;
+  }
+
+  @Override public void setFixedLengthStreamingMode(int contentLength) {
+    setFixedLengthStreamingMode((long) contentLength);
+  }
+
+  @Override public void setFixedLengthStreamingMode(long contentLength) {
+    if (super.connected) throw new IllegalStateException("Already connected");
+    if (chunkLength > 0) throw new IllegalStateException("Already in chunked mode");
+    if (contentLength < 0) throw new IllegalArgumentException("contentLength < 0");
+    this.fixedContentLength = contentLength;
+    super.fixedContentLength = (int) Math.min(contentLength, Integer.MAX_VALUE);
+  }
+
+  @Override public void onFailure(Call call, IOException e) {
+    synchronized (lock) {
+      this.callFailure = (e instanceof UnexpectedException) ? e.getCause() : e;
+      lock.notifyAll();
+    }
+  }
+
+  @Override public void onResponse(Call call, Response response) {
+    synchronized (lock) {
+      this.response = response;
+      this.handshake = response.handshake();
+      this.url = response.request().url().url();
+      lock.notifyAll();
+    }
+  }
+
+  static final class UnexpectedException extends IOException {
+    static final Interceptor INTERCEPTOR = new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        try {
+          return chain.proceed(chain.request());
+        } catch (Error | RuntimeException e) {
+          throw new UnexpectedException(e);
+        }
+      }
+    };
+
+    UnexpectedException(Throwable cause) {
+      super(cause);
+    }
+  }
+
+  /** Throws {@code throwable} as either an IOException, RuntimeException, or Error. */
+  private static IOException propagate(Throwable throwable) throws IOException {
+    if (throwable instanceof IOException) throw (IOException) throwable;
+    if (throwable instanceof Error) throw (Error) throwable;
+    if (throwable instanceof RuntimeException) throw (RuntimeException) throwable;
+    throw new AssertionError();
+  }
+
+  /**
+   * The HttpURLConnection gives the application control between establishing the connection and
+   * transmitting the request body. This interceptor stalls async calls right at this point. The
+   * call will remain stalled until {@link #proceed()} is called.
+   */
+  final class NetworkInterceptor implements Interceptor {
+    // Guarded by HttpUrlConnection.this.
+    private boolean proceed;
+
+    public void proceed() {
+      synchronized (lock) {
+        this.proceed = true;
+        lock.notifyAll();
+      }
+    }
+
+    @Override public Response intercept(Chain chain) throws IOException {
+      Request request = chain.request();
+
+      // Double-check the URL filter to prevent redirects from hitting filtered URLs.
+      if (urlFilter != null) {
+        urlFilter.checkURLPermitted(request.url().url());
+      }
+
+      synchronized (lock) {
+        connectPending = false;
+        proxy = chain.connection().route().proxy();
+        handshake = chain.connection().handshake();
+        lock.notifyAll();
+
+        try {
+          while (!proceed) {
+            lock.wait(); // Wait until proceed() is called.
+          }
+        } catch (InterruptedException e) {
+          throw new InterruptedIOException();
+        }
+      }
+
+      // Try to lock in the Content-Length before transmitting the request body.
+      if (request.body() instanceof OutputStreamRequestBody) {
+        OutputStreamRequestBody requestBody = (OutputStreamRequestBody) request.body();
+        request = requestBody.prepareToSendRequest(request);
+      }
+
+      Response response = chain.proceed(request);
+
+      synchronized (lock) {
+        networkResponse = response;
+        url = response.request().url().url();
+      }
+
+      return response;
+    }
+  }
+}
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/HttpsURLConnectionImpl.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpsURLConnection.java
similarity index 62%
rename from okhttp-urlconnection/src/main/java/okhttp3/internal/huc/HttpsURLConnectionImpl.java
rename to okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpsURLConnection.java
index 05e26353c4..0057174226 100644
--- a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/HttpsURLConnectionImpl.java
+++ b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpsURLConnection.java
@@ -23,33 +23,28 @@
 import okhttp3.OkHttpClient;
 import okhttp3.internal.URLFilter;
 
-public final class HttpsURLConnectionImpl extends DelegatingHttpsURLConnection {
-  private final HttpURLConnectionImpl delegate;
+public final class OkHttpsURLConnection extends DelegatingHttpsURLConnection {
+  private final OkHttpURLConnection delegate;
 
-  public HttpsURLConnectionImpl(URL url, OkHttpClient client) {
-    this(new HttpURLConnectionImpl(url, client));
+  public OkHttpsURLConnection(URL url, OkHttpClient client) {
+    this(new OkHttpURLConnection(url, client));
   }
 
-  public HttpsURLConnectionImpl(URL url, OkHttpClient client, URLFilter filter) {
-    this(new HttpURLConnectionImpl(url, client, filter));
+  public OkHttpsURLConnection(URL url, OkHttpClient client, URLFilter filter) {
+    this(new OkHttpURLConnection(url, client, filter));
   }
 
-  public HttpsURLConnectionImpl(HttpURLConnectionImpl delegate) {
+  public OkHttpsURLConnection(OkHttpURLConnection delegate) {
     super(delegate);
     this.delegate = delegate;
   }
 
   @Override protected Handshake handshake() {
-    if (delegate.httpEngine == null) {
+    if (delegate.call == null) {
       throw new IllegalStateException("Connection has not yet been established");
     }
 
-    // If there's a response, get the handshake from there so that caching
-    // works. Otherwise get the handshake from the connection because we might
-    // have not connected yet.
-    return delegate.httpEngine.hasResponse()
-        ? delegate.httpEngine.getResponse().handshake()
-        : delegate.handshake;
+    return delegate.handshake;
   }
 
   @Override public void setHostnameVerifier(HostnameVerifier hostnameVerifier) {
@@ -73,15 +68,4 @@ public HttpsURLConnectionImpl(HttpURLConnectionImpl delegate) {
     return delegate.client.sslSocketFactory();
   }
 
-  @Override public long getContentLengthLong() {
-    return delegate.getContentLengthLong();
-  }
-
-  @Override public void setFixedLengthStreamingMode(long contentLength) {
-    delegate.setFixedLengthStreamingMode(contentLength);
-  }
-
-  @Override public long getHeaderFieldLong(String field, long defaultValue) {
-    return delegate.getHeaderFieldLong(field, defaultValue);
-  }
 }
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OutputStreamRequestBody.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OutputStreamRequestBody.java
new file mode 100644
index 0000000000..6f4e8ef9e9
--- /dev/null
+++ b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OutputStreamRequestBody.java
@@ -0,0 +1,111 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.huc;
+
+import java.io.IOException;
+import java.io.InterruptedIOException;
+import java.io.OutputStream;
+import java.net.ProtocolException;
+import java.net.SocketTimeoutException;
+import okhttp3.MediaType;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okio.BufferedSink;
+import okio.Timeout;
+
+/**
+ * A request body that's populated by blocking writes to an output stream. The output data is either
+ * fully buffered (with {@link BufferedRequestBody}) or streamed (with {@link StreamedRequestBody}).
+ * In either case the bytes of the body aren't known until the caller writes them to the output
+ * stream.
+ */
+abstract class OutputStreamRequestBody extends RequestBody {
+  private Timeout timeout;
+  private long expectedContentLength;
+  private OutputStream outputStream;
+  boolean closed;
+
+  protected void initOutputStream(final BufferedSink sink, final long expectedContentLength) {
+    this.timeout = sink.timeout();
+    this.expectedContentLength = expectedContentLength;
+
+    // An output stream that writes to sink. If expectedContentLength is not -1, then this expects
+    // exactly that many bytes to be written.
+    this.outputStream = new OutputStream() {
+      private long bytesReceived;
+
+      @Override public void write(int b) throws IOException {
+        write(new byte[] {(byte) b}, 0, 1);
+      }
+
+      @Override public void write(byte[] source, int offset, int byteCount) throws IOException {
+        if (closed) throw new IOException("closed"); // Not IllegalStateException!
+
+        if (expectedContentLength != -1L && bytesReceived + byteCount > expectedContentLength) {
+          throw new ProtocolException("expected " + expectedContentLength
+              + " bytes but received " + bytesReceived + byteCount);
+        }
+
+        bytesReceived += byteCount;
+        try {
+          sink.write(source, offset, byteCount);
+        } catch (InterruptedIOException e) {
+          throw new SocketTimeoutException(e.getMessage());
+        }
+      }
+
+      @Override public void flush() throws IOException {
+        if (closed) return; // Weird, but consistent with historical behavior.
+        sink.flush();
+      }
+
+      @Override public void close() throws IOException {
+        closed = true;
+
+        if (expectedContentLength != -1L && bytesReceived < expectedContentLength) {
+          throw new ProtocolException("expected " + expectedContentLength
+              + " bytes but received " + bytesReceived);
+        }
+
+        sink.close();
+      }
+    };
+  }
+
+  public final OutputStream outputStream() {
+    return outputStream;
+  }
+
+  public final Timeout timeout() {
+    return timeout;
+  }
+
+  public final boolean isClosed() {
+    return closed;
+  }
+
+  @Override public long contentLength() throws IOException {
+    return expectedContentLength;
+  }
+
+  @Override public final MediaType contentType() {
+    return null; // Let the caller provide this in a regular header.
+  }
+
+  public Request prepareToSendRequest(Request request) throws IOException {
+    return request;
+  }
+}
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/StreamedRequestBody.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/StreamedRequestBody.java
new file mode 100644
index 0000000000..201ab09b66
--- /dev/null
+++ b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/StreamedRequestBody.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.huc;
+
+import java.io.IOException;
+import okhttp3.internal.http.UnrepeatableRequestBody;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.Okio;
+import okio.Pipe;
+
+/**
+ * This request body streams bytes from an application thread to an OkHttp dispatcher thread via a
+ * pipe. Because the data is not buffered it can only be transmitted once.
+ */
+final class StreamedRequestBody extends OutputStreamRequestBody implements UnrepeatableRequestBody {
+  private final Pipe pipe = new Pipe(8192);
+
+  StreamedRequestBody(long expectedContentLength) {
+    initOutputStream(Okio.buffer(pipe.sink()), expectedContentLength);
+  }
+
+  @Override public void writeTo(BufferedSink sink) throws IOException {
+    Buffer buffer = new Buffer();
+    while (pipe.source().read(buffer, 8192) != -1L) {
+      sink.write(buffer, buffer.size());
+    }
+  }
+}
diff --git a/okhttp-urlconnection/src/test/java/okhttp3/OkUrlFactoryTest.java b/okhttp-urlconnection/src/test/java/okhttp3/OkUrlFactoryTest.java
index 985e545c7f..d0f706f0d0 100644
--- a/okhttp-urlconnection/src/test/java/okhttp3/OkUrlFactoryTest.java
+++ b/okhttp-urlconnection/src/test/java/okhttp3/OkUrlFactoryTest.java
@@ -12,7 +12,7 @@
 import java.util.concurrent.TimeUnit;
 import javax.net.ssl.HttpsURLConnection;
 import okhttp3.internal.URLFilter;
-import okhttp3.internal.http.OkHeaders;
+import okhttp3.internal.huc.OkHttpURLConnection;
 import okhttp3.internal.io.InMemoryFileSystem;
 import okhttp3.internal.tls.SslClient;
 import okhttp3.mockwebserver.MockResponse;
@@ -207,8 +207,7 @@ public void checkURLPermitted(URL url) throws IOException {
       HttpsURLConnection httpsConnection = (HttpsURLConnection) factory.open(destination);
       httpsConnection.getInputStream();
       fail("Connection was successful");
-    } catch (IOException e) {
-      assertEquals("Blocked", e.getMessage());
+    } catch (IOException expected) {
     }
   }
 
@@ -220,7 +219,7 @@ private void assertResponseBody(HttpURLConnection connection, String expected) t
   }
 
   private void assertResponseHeader(HttpURLConnection connection, String expected) {
-    assertEquals(expected, connection.getHeaderField(OkHeaders.RESPONSE_SOURCE));
+    assertEquals(expected, connection.getHeaderField(OkHttpURLConnection.RESPONSE_SOURCE));
   }
 
   private void assertResponseCode(HttpURLConnection connection, int expected) throws IOException {
diff --git a/okhttp-urlconnection/src/test/java/okhttp3/UrlConnectionCacheTest.java b/okhttp-urlconnection/src/test/java/okhttp3/UrlConnectionCacheTest.java
index 693af67443..ab4af9a350 100644
--- a/okhttp-urlconnection/src/test/java/okhttp3/UrlConnectionCacheTest.java
+++ b/okhttp-urlconnection/src/test/java/okhttp3/UrlConnectionCacheTest.java
@@ -42,8 +42,8 @@
 import javax.net.ssl.HttpsURLConnection;
 import javax.net.ssl.SSLSession;
 import okhttp3.internal.Internal;
-import okhttp3.internal.Util;
 import okhttp3.internal.io.InMemoryFileSystem;
+import okhttp3.internal.platform.Platform;
 import okhttp3.internal.tls.SslClient;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
@@ -174,6 +174,9 @@ private void assertCached(boolean shouldPut, int responseCode) throws Exception
       response.addHeader("Proxy-Authenticate: Basic realm=\"protected area\"");
     } else if (responseCode == HttpURLConnection.HTTP_UNAUTHORIZED) {
       response.addHeader("WWW-Authenticate: Basic realm=\"protected area\"");
+    } else if (responseCode == HttpURLConnection.HTTP_NO_CONTENT
+        || responseCode == HttpURLConnection.HTTP_RESET) {
+      response.setBody(""); // We forbid bodies for 204 and 205.
     }
     server.enqueue(response);
 
@@ -800,7 +803,7 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
     URL url = server.url("/").url();
 
     assertEquals("A", readAscii(urlFactory.open(url)));
-    assertEquals("A", readAscii(urlFactory.open(url)));
+    assertEquals("B", readAscii(urlFactory.open(url)));
   }
 
   @Test public void nonIdentityEncodingAndConditionalCache() throws Exception {
@@ -1615,7 +1618,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
     URL url = server.url("/").url();
-    String urlKey = Util.md5Hex(url.toString());
+    String urlKey = Cache.key(HttpUrl.get(url));
+    String prefix = Platform.get().getPrefix();
     String entryMetadata = ""
         + "" + url + "\n"
         + "GET\n"
@@ -1626,7 +1630,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         + ":version: HTTP/1.1\n"
         + "etag: foo\n"
         + "content-length: 3\n"
-        + "OkHttp-Received-Millis: " + System.currentTimeMillis() + "\n"
+        + prefix + "-Received-Millis: " + System.currentTimeMillis() + "\n"
         + "X-Android-Response-Source: NETWORK 200\n"
         + "OkHttp-Sent-Millis: " + System.currentTimeMillis() + "\n"
         + "\n"
diff --git a/okhttp-urlconnection/src/test/java/okhttp3/internal/huc/URLEncodingTest.java b/okhttp-urlconnection/src/test/java/okhttp3/internal/huc/URLEncodingTest.java
index 1cc63d8f34..ec0de83e52 100644
--- a/okhttp-urlconnection/src/test/java/okhttp3/internal/huc/URLEncodingTest.java
+++ b/okhttp-urlconnection/src/test/java/okhttp3/internal/huc/URLEncodingTest.java
@@ -27,9 +27,9 @@
 import okhttp3.Request;
 import okhttp3.Response;
 import okhttp3.internal.Internal;
-import okhttp3.internal.InternalCache;
-import okhttp3.internal.http.CacheRequest;
-import okhttp3.internal.http.CacheStrategy;
+import okhttp3.internal.cache.CacheRequest;
+import okhttp3.internal.cache.CacheStrategy;
+import okhttp3.internal.cache.InternalCache;
 import org.junit.Ignore;
 import org.junit.Test;
 
@@ -137,7 +137,7 @@ private URI backdoorUrlToUri(URL url) throws Exception {
       @Override public void remove(Request request) throws IOException {
       }
 
-      @Override public void update(Response cached, Response network) throws IOException {
+      @Override public void update(Response cached, Response network) {
       }
 
       @Override public void trackConditionalCacheHit() {
diff --git a/okhttp-ws-tests/pom.xml b/okhttp-ws-tests/pom.xml
deleted file mode 100644
index cef5759623..0000000000
--- a/okhttp-ws-tests/pom.xml
+++ /dev/null
@@ -1,76 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.okhttp3</groupId>
-    <artifactId>parent</artifactId>
-    <version>3.4.0-SNAPSHOT</version>
-  </parent>
-
-  <artifactId>okhttp-ws-tests</artifactId>
-  <name>OkHttp Web Socket Tests</name>
-
-  <dependencies>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp-ws</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp-testing-support</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>mockwebserver</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
-
-  <build>
-    <plugins>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-assembly-plugin</artifactId>
-        <configuration>
-          <descriptorRefs>
-            <descriptorRef>jar-with-dependencies</descriptorRef>
-          </descriptorRefs>
-          <archive>
-            <manifest>
-              <mainClass>okhttp3.ws.AutobahnTester</mainClass>
-            </manifest>
-          </archive>
-        </configuration>
-        <executions>
-          <execution>
-            <phase>package</phase>
-            <goals>
-              <goal>single</goal>
-            </goals>
-          </execution>
-        </executions>
-      </plugin>
-      <!-- Do not deploy this as an artifact to Maven central. -->
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-deploy-plugin</artifactId>
-        <configuration>
-          <skip>true</skip>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/okhttp-ws-tests/src/main/java/okhttp3/ws/AutobahnTester.java b/okhttp-ws-tests/src/main/java/okhttp3/ws/AutobahnTester.java
deleted file mode 100644
index 707f58c116..0000000000
--- a/okhttp-ws-tests/src/main/java/okhttp3/ws/AutobahnTester.java
+++ /dev/null
@@ -1,198 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.ws;
-
-import java.io.IOException;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicLong;
-import java.util.concurrent.atomic.AtomicReference;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.RequestBody;
-import okhttp3.Response;
-import okhttp3.ResponseBody;
-import okhttp3.internal.Version;
-import okio.Buffer;
-import okio.BufferedSource;
-
-import static okhttp3.ws.WebSocket.BINARY;
-import static okhttp3.ws.WebSocket.TEXT;
-
-/**
- * Exercises the web socket implementation against the <a
- * href="http://autobahn.ws/testsuite/">Autobahn Testsuite</a>.
- */
-public final class AutobahnTester {
-  private static final String HOST = "ws://localhost:9001";
-
-  public static void main(String... args) throws IOException {
-    new AutobahnTester().run();
-  }
-
-  final OkHttpClient client = new OkHttpClient();
-
-  private WebSocketCall newWebSocket(String path) {
-    Request request = new Request.Builder().url(HOST + path).build();
-    return WebSocketCall.create(client, request);
-  }
-
-  public void run() throws IOException {
-    try {
-      long count = getTestCount();
-      System.out.println("Test count: " + count);
-
-      for (long number = 1; number <= count; number++) {
-        runTest(number, count);
-      }
-
-      updateReports();
-    } finally {
-      client.dispatcher().executorService().shutdown();
-    }
-  }
-
-  private void runTest(final long number, final long count) throws IOException {
-    final CountDownLatch latch = new CountDownLatch(1);
-    final AtomicLong startNanos = new AtomicLong();
-    newWebSocket("/runCase?case=" + number + "&agent=okhttp") //
-        .enqueue(new WebSocketListener() {
-          private final ExecutorService sendExecutor = Executors.newSingleThreadExecutor();
-          private WebSocket webSocket;
-
-          @Override public void onOpen(WebSocket webSocket, Response response) {
-            this.webSocket = webSocket;
-
-            System.out.println("Executing test case " + number + "/" + count);
-            startNanos.set(System.nanoTime());
-          }
-
-          @Override public void onMessage(final ResponseBody message) throws IOException {
-            final RequestBody response;
-            if (message.contentType() == TEXT) {
-              response = RequestBody.create(TEXT, message.string());
-            } else {
-              BufferedSource source = message.source();
-              response = RequestBody.create(BINARY, source.readByteString());
-              source.close();
-            }
-            sendExecutor.execute(new Runnable() {
-              @Override public void run() {
-                try {
-                  webSocket.sendMessage(response);
-                } catch (IOException e) {
-                  e.printStackTrace(System.out);
-                }
-              }
-            });
-          }
-
-          @Override public void onPong(Buffer payload) {
-          }
-
-          @Override public void onClose(int code, String reason) {
-            sendExecutor.shutdown();
-            latch.countDown();
-          }
-
-          @Override public void onFailure(IOException e, Response response) {
-            e.printStackTrace(System.out);
-            latch.countDown();
-          }
-        });
-    try {
-      if (!latch.await(30, TimeUnit.SECONDS)) {
-        throw new IllegalStateException("Timed out waiting for test " + number + " to finish.");
-      }
-    } catch (InterruptedException e) {
-      throw new AssertionError();
-    }
-
-    long endNanos = System.nanoTime();
-    long tookMs = TimeUnit.NANOSECONDS.toMillis(endNanos - startNanos.get());
-    System.out.println("Took " + tookMs + "ms");
-  }
-
-  private long getTestCount() throws IOException {
-    final CountDownLatch latch = new CountDownLatch(1);
-    final AtomicLong countRef = new AtomicLong();
-    final AtomicReference<IOException> failureRef = new AtomicReference<>();
-    newWebSocket("/getCaseCount").enqueue(new WebSocketListener() {
-      @Override public void onOpen(WebSocket webSocket, Response response) {
-      }
-
-      @Override public void onMessage(ResponseBody message) throws IOException {
-        countRef.set(message.source().readDecimalLong());
-        message.close();
-      }
-
-      @Override public void onPong(Buffer payload) {
-      }
-
-      @Override public void onClose(int code, String reason) {
-        latch.countDown();
-      }
-
-      @Override public void onFailure(IOException e, Response response) {
-        failureRef.set(e);
-        latch.countDown();
-      }
-    });
-    try {
-      if (!latch.await(10, TimeUnit.SECONDS)) {
-        throw new IllegalStateException("Timed out waiting for count.");
-      }
-    } catch (InterruptedException e) {
-      throw new AssertionError();
-    }
-    IOException failure = failureRef.get();
-    if (failure != null) {
-      throw failure;
-    }
-    return countRef.get();
-  }
-
-  private void updateReports() {
-    final CountDownLatch latch = new CountDownLatch(1);
-    newWebSocket("/updateReports?agent=" + Version.userAgent()).enqueue(new WebSocketListener() {
-      @Override public void onOpen(WebSocket webSocket, Response response) {
-      }
-
-      @Override public void onMessage(ResponseBody message) throws IOException {
-      }
-
-      @Override public void onPong(Buffer payload) {
-      }
-
-      @Override public void onClose(int code, String reason) {
-        latch.countDown();
-      }
-
-      @Override public void onFailure(IOException e, Response response) {
-        latch.countDown();
-      }
-    });
-    try {
-      if (!latch.await(10, TimeUnit.SECONDS)) {
-        throw new IllegalStateException("Timed out waiting for count.");
-      }
-    } catch (InterruptedException e) {
-      throw new AssertionError();
-    }
-  }
-}
diff --git a/okhttp-ws-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java b/okhttp-ws-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
deleted file mode 100644
index 90a803ec14..0000000000
--- a/okhttp-ws-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
+++ /dev/null
@@ -1,504 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.ws;
-
-import java.io.Closeable;
-import java.io.IOException;
-import java.net.ProtocolException;
-import java.util.Random;
-import java.util.concurrent.Executor;
-import okhttp3.MediaType;
-import okhttp3.RequestBody;
-import okhttp3.ws.WebSocketRecorder;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.ByteString;
-import okio.Okio;
-import okio.Sink;
-import okio.Source;
-import okio.Timeout;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-
-import static okhttp3.ws.WebSocket.BINARY;
-import static okhttp3.ws.WebSocket.TEXT;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotEquals;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-public final class RealWebSocketTest {
-  // NOTE: Fields are named 'client' and 'server' for cognitive simplicity. This differentiation has
-  // zero effect on the behavior of the WebSocket API which is why tests are only written once
-  // from the perspective of a single peer.
-
-  private final Executor clientExecutor = new SynchronousExecutor();
-  private RealWebSocket client;
-  private boolean clientConnectionCloseThrows;
-  private boolean clientConnectionClosed;
-  private final MemorySocket client2Server = new MemorySocket();
-  private final WebSocketRecorder clientListener = new WebSocketRecorder();
-
-  private final Executor serverExecutor = new SynchronousExecutor();
-  private RealWebSocket server;
-  private boolean serverConnectionClosed;
-  private final MemorySocket server2client = new MemorySocket();
-  private final WebSocketRecorder serverListener = new WebSocketRecorder();
-
-  @Before public void setUp() {
-    Random random = new Random(0);
-    String url = "http://example.com/websocket";
-
-    client = new RealWebSocket(true, server2client.source(), client2Server.sink(), random,
-        clientExecutor, clientListener, url) {
-      @Override protected void close() throws IOException {
-        if (clientConnectionClosed) {
-          throw new AssertionError("Already closed");
-        }
-        clientConnectionClosed = true;
-
-        if (clientConnectionCloseThrows) {
-          throw new IOException("Oops!");
-        }
-      }
-    };
-    server = new RealWebSocket(false, client2Server.source(), server2client.sink(), random,
-        serverExecutor, serverListener, url) {
-      @Override protected void close() throws IOException {
-        if (serverConnectionClosed) {
-          throw new AssertionError("Already closed");
-        }
-        serverConnectionClosed = true;
-      }
-    };
-  }
-
-  @After public void tearDown() {
-    clientListener.assertExhausted();
-    serverListener.assertExhausted();
-  }
-
-  @Test public void nullMessageThrows() throws IOException {
-    try {
-      client.sendMessage(null);
-      fail();
-    } catch (NullPointerException e) {
-      assertEquals("message == null", e.getMessage());
-    }
-  }
-
-  @Test public void textMessage() throws IOException {
-    client.sendMessage(RequestBody.create(TEXT, "Hello!"));
-    server.readMessage();
-    serverListener.assertTextMessage("Hello!");
-  }
-
-  @Test public void binaryMessage() throws IOException {
-    client.sendMessage(RequestBody.create(BINARY, "Hello!"));
-    server.readMessage();
-    serverListener.assertBinaryMessage(new byte[] {'H', 'e', 'l', 'l', 'o', '!'});
-  }
-
-  @Test public void missingContentTypeThrows() throws IOException {
-    try {
-      client.sendMessage(RequestBody.create(null, "Hey!"));
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertEquals("Message content type was null. Must use WebSocket.TEXT or WebSocket.BINARY.",
-          e.getMessage());
-    }
-  }
-
-  @Test public void unknownContentTypeThrows() throws IOException {
-    try {
-      client.sendMessage(RequestBody.create(MediaType.parse("text/plain"), "Hey!"));
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertEquals(
-          "Unknown message content type: text/plain. Must use WebSocket.TEXT or WebSocket.BINARY.",
-          e.getMessage());
-    }
-  }
-
-  @Test public void streamingMessage() throws IOException {
-    RequestBody message = new RequestBody() {
-      @Override public MediaType contentType() {
-        return TEXT;
-      }
-
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        sink.writeUtf8("Hel").flush();
-        sink.writeUtf8("lo!").flush();
-        sink.close();
-      }
-    };
-    client.sendMessage(message);
-    server.readMessage();
-    serverListener.assertTextMessage("Hello!");
-  }
-
-  @Test public void streamingMessageCanInterleavePing() throws IOException, InterruptedException {
-    RequestBody message = new RequestBody() {
-      @Override public MediaType contentType() {
-        return TEXT;
-      }
-
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        sink.writeUtf8("Hel").flush();
-        client.sendPing(new Buffer().writeUtf8("Pong?"));
-        sink.writeUtf8("lo!").flush();
-        sink.close();
-      }
-    };
-
-    client.sendMessage(message);
-    server.readMessage();
-    serverListener.assertTextMessage("Hello!");
-    client.readMessage();
-    clientListener.assertPong(new Buffer().writeUtf8("Pong?"));
-  }
-
-  @Test public void pingWritesPong() throws IOException, InterruptedException {
-    client.sendPing(new Buffer().writeUtf8("Hello!"));
-    server.readMessage(); // Read the ping, write the pong.
-    client.readMessage(); // Read the pong.
-    clientListener.assertPong(new Buffer().writeUtf8("Hello!"));
-  }
-
-  @Test public void unsolicitedPong() throws IOException {
-    client.sendPong(new Buffer().writeUtf8("Hello!"));
-    server.readMessage();
-    serverListener.assertPong(new Buffer().writeUtf8("Hello!"));
-  }
-
-  @Test public void close() throws IOException {
-    client.close(1000, "Hello!");
-    assertFalse(server.readMessage()); // This will trigger a close response.
-    serverListener.assertClose(1000, "Hello!");
-    assertFalse(client.readMessage());
-    clientListener.assertClose(1000, "Hello!");
-  }
-
-  @Test public void clientCloseThenMethodsThrow() throws IOException {
-    client.close(1000, "Hello!");
-
-    try {
-      client.sendPing(new Buffer().writeUtf8("Pong?"));
-      fail();
-    } catch (IllegalStateException e) {
-      assertEquals("closed", e.getMessage());
-    }
-    try {
-      client.close(1000, "Hello!");
-      fail();
-    } catch (IllegalStateException e) {
-      assertEquals("closed", e.getMessage());
-    }
-    try {
-      client.sendMessage(RequestBody.create(TEXT, "Hello!"));
-      fail();
-    } catch (IllegalStateException e) {
-      assertEquals("closed", e.getMessage());
-    }
-  }
-
-  @Test public void socketClosedDuringPingKillsWebSocket() throws IOException {
-    client2Server.close();
-
-    try {
-      client.sendPing(new Buffer().writeUtf8("Ping!"));
-      fail();
-    } catch (IOException ignored) {
-    }
-
-    // A failed write prevents further use of the WebSocket instance.
-    try {
-      client.sendMessage(RequestBody.create(TEXT, "Hello!"));
-      fail();
-    } catch (IllegalStateException e) {
-      assertEquals("must call close()", e.getMessage());
-    }
-    try {
-      client.sendPing(new Buffer().writeUtf8("Ping!"));
-      fail();
-    } catch (IllegalStateException e) {
-      assertEquals("must call close()", e.getMessage());
-    }
-  }
-
-  @Test public void socketClosedDuringMessageKillsWebSocket() throws IOException {
-    client2Server.close();
-
-    try {
-      client.sendMessage(RequestBody.create(TEXT, "Hello!"));
-      fail();
-    } catch (IOException ignored) {
-    }
-
-    // A failed write prevents further use of the WebSocket instance.
-    try {
-      client.sendMessage(RequestBody.create(TEXT, "Hello!"));
-      fail();
-    } catch (IllegalStateException e) {
-      assertEquals("must call close()", e.getMessage());
-    }
-    try {
-      client.sendPing(new Buffer().writeUtf8("Ping!"));
-      fail();
-    } catch (IllegalStateException e) {
-      assertEquals("must call close()", e.getMessage());
-    }
-  }
-
-  @Test public void serverCloseThenWritingPingThrows() throws IOException {
-    server.close(1000, "Hello!");
-    client.readMessage();
-    clientListener.assertClose(1000, "Hello!");
-
-    try {
-      client.sendPing(new Buffer().writeUtf8("Pong?"));
-      fail();
-    } catch (IOException e) {
-      assertEquals("closed", e.getMessage());
-    }
-  }
-
-  @Test public void serverCloseThenWritingMessageThrows() throws IOException {
-    server.close(1000, "Hello!");
-    client.readMessage();
-    clientListener.assertClose(1000, "Hello!");
-
-    try {
-      client.sendMessage(RequestBody.create(TEXT, "Hi!"));
-      fail();
-    } catch (IOException e) {
-      assertEquals("closed", e.getMessage());
-    }
-  }
-
-  @Test public void serverCloseThenWritingCloseThrows() throws IOException {
-    server.close(1000, "Hello!");
-    client.readMessage();
-    clientListener.assertClose(1000, "Hello!");
-
-    try {
-      client.close(1000, "Bye!");
-      fail();
-    } catch (IOException e) {
-      assertEquals("closed", e.getMessage());
-    }
-  }
-
-  @Test public void serverCloseWhileWritingThrows() throws IOException {
-    RequestBody message = new RequestBody() {
-      @Override public MediaType contentType() {
-        return TEXT;
-      }
-
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        // Start writing data.
-        sink.writeUtf8("Hel").flush();
-
-        server.close(1000, "Hello!");
-        client.readMessage();
-        clientListener.assertClose(1000, "Hello!");
-
-        try {
-          sink.flush(); // No flushing.
-          fail();
-        } catch (IOException e) {
-          assertEquals("closed", e.getMessage());
-        }
-        try {
-          sink.close(); // No closing because this requires writing a frame.
-          fail();
-        } catch (IOException e) {
-          assertEquals("closed", e.getMessage());
-        }
-      }
-    };
-    client.sendMessage(message);
-  }
-
-  @Test public void clientCloseClosesConnection() throws IOException {
-    client.close(1000, "Hello!");
-    assertFalse(clientConnectionClosed);
-    server.readMessage(); // Read client close, send server close.
-    serverListener.assertClose(1000, "Hello!");
-
-    client.readMessage(); // Read server close, close connection.
-    assertTrue(clientConnectionClosed);
-    clientListener.assertClose(1000, "Hello!");
-  }
-
-  @Test public void serverCloseClosesConnection() throws IOException {
-    server.close(1000, "Hello!");
-
-    client.readMessage(); // Read server close, send client close, close connection.
-    assertTrue(clientConnectionClosed);
-    clientListener.assertClose(1000, "Hello!");
-
-    server.readMessage();
-    serverListener.assertClose(1000, "Hello!");
-  }
-
-  @Test public void clientAndServerCloseClosesConnection() throws IOException {
-    // Send close from both sides at the same time.
-    server.close(1000, "Hello!");
-    client.close(1000, "Hi!");
-    assertFalse(clientConnectionClosed);
-
-    client.readMessage(); // Read close, close connection close.
-    assertTrue(clientConnectionClosed);
-    clientListener.assertClose(1000, "Hello!");
-
-    server.readMessage();
-    serverListener.assertClose(1000, "Hi!");
-
-    serverListener.assertExhausted(); // Client should not have sent second close.
-    clientListener.assertExhausted(); // Server should not have sent second close.
-  }
-
-  @Test public void serverCloseBreaksReadMessageLoop() throws IOException {
-    server.sendMessage(RequestBody.create(TEXT, "Hello!"));
-    server.close(1000, "Bye!");
-    assertTrue(client.readMessage());
-    clientListener.assertTextMessage("Hello!");
-    assertFalse(client.readMessage());
-    clientListener.assertClose(1000, "Bye!");
-  }
-
-  @Test public void protocolErrorBeforeCloseSendsClose() throws IOException {
-    server2client.raw().write(ByteString.decodeHex("0a00")); // Invalid non-final ping frame.
-
-    client.readMessage(); // Detects error, send close, close connection.
-    assertTrue(clientConnectionClosed);
-    clientListener.assertFailure(ProtocolException.class, "Control frames must be final.");
-
-    server.readMessage();
-    serverListener.assertClose(1002, "");
-  }
-
-  @Test public void protocolErrorAfterCloseDoesNotSendClose() throws IOException {
-    client.close(1000, "Hello!");
-    assertFalse(clientConnectionClosed); // Not closed until close reply is received.
-    server2client.raw().write(ByteString.decodeHex("0a00")); // Invalid non-final ping frame.
-
-    client.readMessage(); // Detects error, closes connection immediately since close already sent.
-    assertTrue(clientConnectionClosed);
-    clientListener.assertFailure(ProtocolException.class, "Control frames must be final.");
-
-    server.readMessage();
-    serverListener.assertClose(1000, "Hello!");
-
-    serverListener.assertExhausted(); // Client should not have sent second close.
-  }
-
-  @Test public void closeThrowingClosesConnection() {
-    client2Server.close();
-
-    try {
-      client.close(1000, null);
-      fail();
-    } catch (IOException ignored) {
-    }
-    assertTrue(clientConnectionClosed);
-  }
-
-  @Test public void closeMessageAndConnectionCloseThrowingDoesNotMaskOriginal() throws IOException {
-    client2Server.close();
-    clientConnectionCloseThrows = true;
-
-    try {
-      client.close(1000, "Bye!");
-      fail();
-    } catch (IOException e) {
-      assertNotEquals("Oops!", e.getMessage());
-    }
-    assertTrue(clientConnectionClosed);
-  }
-
-  @Test public void peerConnectionCloseThrowingDoesNotPropagate() throws IOException {
-    clientConnectionCloseThrows = true;
-
-    server.close(1000, "Bye!");
-    client.readMessage();
-    assertTrue(clientConnectionClosed);
-    clientListener.assertClose(1000, "Bye!");
-
-    server.readMessage();
-    serverListener.assertClose(1000, "Bye!");
-  }
-
-  static final class MemorySocket implements Closeable {
-    private final Buffer buffer = new Buffer();
-    private boolean closed;
-
-    @Override public void close() {
-      closed = true;
-    }
-
-    Buffer raw() {
-      return buffer;
-    }
-
-    BufferedSource source() {
-      return Okio.buffer(new Source() {
-        @Override public long read(Buffer sink, long byteCount) throws IOException {
-          if (closed) throw new IOException("closed");
-          return buffer.read(sink, byteCount);
-        }
-
-        @Override public Timeout timeout() {
-          return Timeout.NONE;
-        }
-
-        @Override public void close() throws IOException {
-          closed = true;
-        }
-      });
-    }
-
-    BufferedSink sink() {
-      return Okio.buffer(new Sink() {
-        @Override public void write(Buffer source, long byteCount) throws IOException {
-          if (closed) throw new IOException("closed");
-          buffer.write(source, byteCount);
-        }
-
-        @Override public void flush() throws IOException {
-        }
-
-        @Override public Timeout timeout() {
-          return Timeout.NONE;
-        }
-
-        @Override public void close() throws IOException {
-          closed = true;
-        }
-      });
-    }
-  }
-
-  static final class SynchronousExecutor implements Executor {
-    @Override public void execute(Runnable command) {
-      command.run();
-    }
-  }
-}
diff --git a/okhttp-ws-tests/src/test/java/okhttp3/ws/WebSocketCallTest.java b/okhttp-ws-tests/src/test/java/okhttp3/ws/WebSocketCallTest.java
deleted file mode 100644
index 06dd4a2e28..0000000000
--- a/okhttp-ws-tests/src/test/java/okhttp3/ws/WebSocketCallTest.java
+++ /dev/null
@@ -1,283 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.ws;
-
-import java.io.IOException;
-import java.net.ProtocolException;
-import java.util.Random;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicReference;
-import okhttp3.OkHttpClient;
-import okhttp3.RecordingHostnameVerifier;
-import okhttp3.Request;
-import okhttp3.RequestBody;
-import okhttp3.Response;
-import okhttp3.ResponseBody;
-import okhttp3.internal.tls.SslClient;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okio.Buffer;
-import org.junit.After;
-import org.junit.Rule;
-import org.junit.Test;
-
-import static okhttp3.ws.WebSocket.TEXT;
-
-public final class WebSocketCallTest {
-  @Rule public final MockWebServer server = new MockWebServer();
-
-  private final SslClient sslClient = SslClient.localhost();
-  private final WebSocketRecorder listener = new WebSocketRecorder();
-  private final Random random = new Random(0);
-  private OkHttpClient client = new OkHttpClient();
-
-  @After public void tearDown() {
-    listener.assertExhausted();
-  }
-
-  @Test public void clientPingPong() throws IOException {
-    WebSocketListener serverListener = new EmptyWebSocketListener();
-    server.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-
-    WebSocket webSocket = awaitWebSocket();
-    webSocket.sendPing(new Buffer().writeUtf8("Hello, WebSockets!"));
-    listener.assertPong(new Buffer().writeUtf8("Hello, WebSockets!"));
-  }
-
-  @Test public void clientMessage() throws IOException {
-    WebSocketRecorder serverListener = new WebSocketRecorder();
-    server.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-
-    WebSocket webSocket = awaitWebSocket();
-    webSocket.sendMessage(RequestBody.create(TEXT, "Hello, WebSockets!"));
-    serverListener.assertTextMessage("Hello, WebSockets!");
-  }
-
-  @Test public void serverMessage() throws IOException {
-    WebSocketListener serverListener = new EmptyWebSocketListener() {
-      @Override public void onOpen(final WebSocket webSocket, Response response) {
-        new Thread() {
-          @Override public void run() {
-            try {
-              webSocket.sendMessage(RequestBody.create(TEXT, "Hello, WebSockets!"));
-            } catch (IOException e) {
-              throw new AssertionError(e);
-            }
-          }
-        }.start();
-      }
-    };
-    server.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-
-    awaitWebSocket();
-    listener.assertTextMessage("Hello, WebSockets!");
-  }
-
-  @Test public void non101RetainsBody() throws IOException {
-    server.enqueue(new MockResponse().setResponseCode(200).setBody("Body"));
-    awaitWebSocket();
-    listener.assertFailure(ProtocolException.class, "Expected HTTP 101 response but was '200 OK'");
-    listener.assertResponse(200, "Body");
-  }
-
-  @Test public void notFound() throws IOException {
-    server.enqueue(new MockResponse().setStatus("HTTP/1.1 404 Not Found"));
-    awaitWebSocket();
-    listener.assertFailure(ProtocolException.class,
-        "Expected HTTP 101 response but was '404 Not Found'");
-    listener.assertResponse(404, "");
-  }
-
-  @Test public void clientTimeoutClosesBody() throws IOException {
-    server.enqueue(new MockResponse().setResponseCode(408));
-    WebSocketListener serverListener = new EmptyWebSocketListener();
-    server.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-
-    WebSocket webSocket = awaitWebSocket();
-    webSocket.sendPing(new Buffer().writeUtf8("WebSockets are fun!"));
-    listener.assertPong(new Buffer().writeUtf8("WebSockets are fun!"));
-  }
-
-  @Test public void missingConnectionHeader() {
-    server.enqueue(new MockResponse()
-        .setResponseCode(101)
-        .setHeader("Upgrade", "websocket")
-        .setHeader("Sec-WebSocket-Accept", "ujmZX4KXZqjwy6vi1aQFH5p4Ygk="));
-    awaitWebSocket();
-    listener.assertFailure(ProtocolException.class,
-        "Expected 'Connection' header value 'Upgrade' but was 'null'");
-  }
-
-  @Test public void wrongConnectionHeader() {
-    server.enqueue(new MockResponse()
-        .setResponseCode(101)
-        .setHeader("Upgrade", "websocket")
-        .setHeader("Connection", "Downgrade")
-        .setHeader("Sec-WebSocket-Accept", "ujmZX4KXZqjwy6vi1aQFH5p4Ygk="));
-    awaitWebSocket();
-    listener.assertFailure(ProtocolException.class,
-        "Expected 'Connection' header value 'Upgrade' but was 'Downgrade'");
-  }
-
-  @Test public void missingUpgradeHeader() {
-    server.enqueue(new MockResponse()
-        .setResponseCode(101)
-        .setHeader("Connection", "Upgrade")
-        .setHeader("Sec-WebSocket-Accept", "ujmZX4KXZqjwy6vi1aQFH5p4Ygk="));
-    awaitWebSocket();
-    listener.assertFailure(ProtocolException.class,
-        "Expected 'Upgrade' header value 'websocket' but was 'null'");
-  }
-
-  @Test public void wrongUpgradeHeader() {
-    server.enqueue(new MockResponse()
-        .setResponseCode(101)
-        .setHeader("Connection", "Upgrade")
-        .setHeader("Upgrade", "Pepsi")
-        .setHeader("Sec-WebSocket-Accept", "ujmZX4KXZqjwy6vi1aQFH5p4Ygk="));
-    awaitWebSocket();
-    listener.assertFailure(ProtocolException.class,
-        "Expected 'Upgrade' header value 'websocket' but was 'Pepsi'");
-  }
-
-  @Test public void missingMagicHeader() {
-    server.enqueue(new MockResponse()
-        .setResponseCode(101)
-        .setHeader("Connection", "Upgrade")
-        .setHeader("Upgrade", "websocket"));
-    awaitWebSocket();
-    listener.assertFailure(ProtocolException.class,
-        "Expected 'Sec-WebSocket-Accept' header value 'ujmZX4KXZqjwy6vi1aQFH5p4Ygk=' but was 'null'");
-  }
-
-  @Test public void wrongMagicHeader() {
-    server.enqueue(new MockResponse()
-        .setResponseCode(101)
-        .setHeader("Connection", "Upgrade")
-        .setHeader("Upgrade", "websocket")
-        .setHeader("Sec-WebSocket-Accept", "magic"));
-    awaitWebSocket();
-    listener.assertFailure(ProtocolException.class,
-        "Expected 'Sec-WebSocket-Accept' header value 'ujmZX4KXZqjwy6vi1aQFH5p4Ygk=' but was 'magic'");
-  }
-
-  @Test public void wsScheme() throws IOException {
-    websocketScheme("ws");
-  }
-
-  @Test public void wsUppercaseScheme() throws IOException {
-    websocketScheme("WS");
-  }
-
-  @Test public void wssScheme() throws IOException {
-    server.useHttps(sslClient.socketFactory, false);
-    client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build();
-
-    websocketScheme("wss");
-  }
-
-  @Test public void httpsScheme() throws IOException {
-    server.useHttps(sslClient.socketFactory, false);
-    client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build();
-
-    websocketScheme("https");
-  }
-
-  private void websocketScheme(String scheme) throws IOException {
-    WebSocketRecorder serverListener = new WebSocketRecorder();
-    server.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-
-    Request request1 = new Request.Builder()
-        .url(scheme + "://" + server.getHostName() + ":" + server.getPort() + "/")
-        .build();
-
-    WebSocket webSocket = awaitWebSocket(request1);
-    webSocket.sendMessage(RequestBody.create(TEXT, "abc"));
-    serverListener.assertTextMessage("abc");
-  }
-
-  private WebSocket awaitWebSocket() {
-    return awaitWebSocket(new Request.Builder().get().url(server.url("/")).build());
-  }
-
-  private WebSocket awaitWebSocket(Request request) {
-    WebSocketCall call = new WebSocketCall(client, request, random);
-
-    final AtomicReference<Response> responseRef = new AtomicReference<>();
-    final AtomicReference<WebSocket> webSocketRef = new AtomicReference<>();
-    final AtomicReference<IOException> failureRef = new AtomicReference<>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    call.enqueue(new WebSocketListener() {
-      @Override public void onOpen(WebSocket webSocket, Response response) {
-        webSocketRef.set(webSocket);
-        responseRef.set(response);
-        latch.countDown();
-      }
-
-      @Override public void onMessage(ResponseBody message) throws IOException {
-        listener.onMessage(message);
-      }
-
-      @Override public void onPong(Buffer payload) {
-        listener.onPong(payload);
-      }
-
-      @Override public void onClose(int code, String reason) {
-        listener.onClose(code, reason);
-      }
-
-      @Override public void onFailure(IOException e, Response response) {
-        listener.onFailure(e, response);
-        failureRef.set(e);
-        latch.countDown();
-      }
-    });
-
-    try {
-      if (!latch.await(10, TimeUnit.SECONDS)) {
-        throw new AssertionError("Timed out.");
-      }
-    } catch (InterruptedException e) {
-      throw new AssertionError(e);
-    }
-
-    return webSocketRef.get();
-  }
-
-  private static class EmptyWebSocketListener implements WebSocketListener {
-    @Override public void onOpen(WebSocket webSocket, Response response) {
-    }
-
-    @Override public void onMessage(ResponseBody message) throws IOException {
-    }
-
-    @Override public void onPong(Buffer payload) {
-    }
-
-    @Override public void onClose(int code, String reason) {
-    }
-
-    @Override public void onFailure(IOException e, Response response) {
-    }
-  }
-}
diff --git a/okhttp-ws-tests/src/test/java/okhttp3/ws/WebSocketRecorder.java b/okhttp-ws-tests/src/test/java/okhttp3/ws/WebSocketRecorder.java
deleted file mode 100644
index 485a4a1e88..0000000000
--- a/okhttp-ws-tests/src/test/java/okhttp3/ws/WebSocketRecorder.java
+++ /dev/null
@@ -1,253 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.ws;
-
-import java.io.IOException;
-import java.util.concurrent.BlockingQueue;
-import java.util.concurrent.LinkedBlockingQueue;
-import java.util.concurrent.TimeUnit;
-import okhttp3.MediaType;
-import okhttp3.Response;
-import okhttp3.ResponseBody;
-import okhttp3.internal.ws.WebSocketReader;
-import okio.Buffer;
-
-import static okhttp3.ws.WebSocket.BINARY;
-import static okhttp3.ws.WebSocket.TEXT;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertTrue;
-
-public final class WebSocketRecorder implements WebSocketReader.FrameCallback, WebSocketListener {
-  public interface MessageDelegate {
-    void onMessage(ResponseBody message) throws IOException;
-  }
-
-  private final BlockingQueue<Object> events = new LinkedBlockingQueue<>();
-  private MessageDelegate delegate;
-  private Response response;
-
-  /** Sets a delegate for the next call to {@link #onMessage}. Cleared after invoked. */
-  public void setNextMessageDelegate(MessageDelegate delegate) {
-    this.delegate = delegate;
-  }
-
-  @Override public void onOpen(WebSocket webSocket, Response response) {
-  }
-
-  @Override public void onMessage(ResponseBody message) throws IOException {
-    if (delegate != null) {
-      delegate.onMessage(message);
-      delegate = null;
-    } else {
-      Message event = new Message(message.contentType());
-      message.source().readAll(event.buffer);
-      message.close();
-      events.add(event);
-    }
-  }
-
-  @Override public void onPing(Buffer buffer) {
-    events.add(new Ping(buffer));
-  }
-
-  @Override public void onPong(Buffer buffer) {
-    events.add(new Pong(buffer));
-  }
-
-  @Override public void onClose(int code, String reason) {
-    events.add(new Close(code, reason));
-  }
-
-  @Override public void onFailure(IOException e, Response response) {
-    events.add(e);
-    this.response = response;
-  }
-
-  private Object nextEvent() {
-    try {
-      Object event = events.poll(10, TimeUnit.SECONDS);
-      if (event == null) {
-        throw new AssertionError("Timed out.");
-      }
-      return event;
-    } catch (InterruptedException e) {
-      throw new AssertionError(e);
-    }
-  }
-
-  public void assertTextMessage(String payload) throws IOException {
-    Message message = new Message(TEXT);
-    message.buffer.writeUtf8(payload);
-    Object actual = nextEvent();
-    if (actual instanceof IOException) {
-      throw (IOException) actual;
-    }
-    assertEquals(message, actual);
-  }
-
-  public void assertBinaryMessage(byte[] payload) throws IOException {
-    Message message = new Message(BINARY);
-    message.buffer.write(payload);
-    Object actual = nextEvent();
-    if (actual instanceof IOException) {
-      throw (IOException) actual;
-    }
-    assertEquals(message, actual);
-  }
-
-  public void assertPing(Buffer payload) throws IOException {
-    Object actual = nextEvent();
-    if (actual instanceof IOException) {
-      throw (IOException) actual;
-    }
-    assertEquals(new Ping(payload), actual);
-  }
-
-  public void assertPong(Buffer payload) throws IOException {
-    Object actual = nextEvent();
-    if (actual instanceof IOException) {
-      throw (IOException) actual;
-    }
-    assertEquals(new Pong(payload), actual);
-  }
-
-  public void assertClose(int code, String reason) throws IOException {
-    Object actual = nextEvent();
-    if (actual instanceof IOException) {
-      throw (IOException) actual;
-    }
-    assertEquals(new Close(code, reason), actual);
-  }
-
-  public void assertFailure(Class<? extends IOException> cls, String message) {
-    Object event = nextEvent();
-    String errorMessage =
-        "Expected [" + cls.getName() + ": " + message + "] but was [" + event + "].";
-    assertNotNull(errorMessage, event);
-    assertEquals(errorMessage, cls, event.getClass());
-    assertEquals(errorMessage, cls.cast(event).getMessage(), message);
-  }
-
-  public void assertExhausted() {
-    assertTrue("Remaining events: " + events, events.isEmpty());
-  }
-
-  public void assertResponse(int code, String body) throws IOException {
-    assertNotNull(response);
-    assertEquals(code, response.code());
-    assertEquals(body, response.body().string());
-  }
-
-  private static class Message {
-    public final MediaType mediaType;
-    public final Buffer buffer = new Buffer();
-
-    private Message(MediaType mediaType) {
-      this.mediaType = mediaType;
-    }
-
-    @Override public String toString() {
-      return "Message[" + mediaType + " " + buffer + "]";
-    }
-
-    @Override public int hashCode() {
-      return mediaType.hashCode() * 37 + buffer.hashCode();
-    }
-
-    @Override public boolean equals(Object obj) {
-      if (obj instanceof Message) {
-        Message other = (Message) obj;
-        return mediaType.equals(other.mediaType) && buffer.equals(other.buffer);
-      }
-      return false;
-    }
-  }
-
-  private static class Ping {
-    public final Buffer buffer;
-
-    private Ping(Buffer buffer) {
-      this.buffer = buffer;
-    }
-
-    @Override public String toString() {
-      return "Ping[" + buffer + "]";
-    }
-
-    @Override public int hashCode() {
-      return buffer.hashCode();
-    }
-
-    @Override public boolean equals(Object obj) {
-      if (obj instanceof Ping) {
-        Ping other = (Ping) obj;
-        return buffer == null ? other.buffer == null : buffer.equals(other.buffer);
-      }
-      return false;
-    }
-  }
-
-  private static class Pong {
-    public final Buffer buffer;
-
-    private Pong(Buffer buffer) {
-      this.buffer = buffer;
-    }
-
-    @Override public String toString() {
-      return "Pong[" + buffer + "]";
-    }
-
-    @Override public int hashCode() {
-      return buffer.hashCode();
-    }
-
-    @Override public boolean equals(Object obj) {
-      if (obj instanceof Pong) {
-        Pong other = (Pong) obj;
-        return buffer == null ? other.buffer == null : buffer.equals(other.buffer);
-      }
-      return false;
-    }
-  }
-
-  private static class Close {
-    public final int code;
-    public final String reason;
-
-    private Close(int code, String reason) {
-      this.code = code;
-      this.reason = reason;
-    }
-
-    @Override public String toString() {
-      return "Close[" + code + " " + reason + "]";
-    }
-
-    @Override public int hashCode() {
-      return code * 37 + reason.hashCode();
-    }
-
-    @Override public boolean equals(Object obj) {
-      if (obj instanceof Close) {
-        Close other = (Close) obj;
-        return code == other.code && reason.equals(other.reason);
-      }
-      return false;
-    }
-  }
-}
diff --git a/okhttp-ws/README.md b/okhttp-ws/README.md
deleted file mode 100644
index 054ea91fbf..0000000000
--- a/okhttp-ws/README.md
+++ /dev/null
@@ -1,22 +0,0 @@
-OkHttp Web Sockets
-==================
-
-RFC6455-compliant web socket implementation.
-
-Create a `WebSocketCall` with a `Request` and an `OkHttpClient` instance.
-```java
-WebSocketCall call = WebSocketCall.create(client, request);
-```
-
-A `WebSocketListener` will notify of the initial connection, server-sent messages, and any failures
-on the connection.
-
-Start the web socket by calling `enqueue` on `WebSocketCall` with the `WebSocketListener`.
-```java
-call.enqueue(new WebSocketListener() {
-  // ...
-});
-```
-
-*Note: This module's API should be considered experimental and may be subject to breaking changes
-in future releases.*
diff --git a/okhttp-ws/pom.xml b/okhttp-ws/pom.xml
deleted file mode 100644
index 7cbfab9e5b..0000000000
--- a/okhttp-ws/pom.xml
+++ /dev/null
@@ -1,37 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.okhttp3</groupId>
-    <artifactId>parent</artifactId>
-    <version>3.4.0-SNAPSHOT</version>
-  </parent>
-
-  <artifactId>okhttp-ws</artifactId>
-  <name>OkHttp Web Sockets</name>
-
-  <dependencies>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-  </dependencies>
-
-  <build>
-    <plugins>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-javadoc-plugin</artifactId>
-        <configuration>
-          <excludePackageNames>okhttp3.internal.*</excludePackageNames>
-          <links>
-            <link>http://square.github.io/okhttp/javadoc/</link>
-          </links>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/okhttp-ws/src/main/java/okhttp3/internal/ws/RealWebSocket.java b/okhttp-ws/src/main/java/okhttp3/internal/ws/RealWebSocket.java
deleted file mode 100644
index b9af6bdd65..0000000000
--- a/okhttp-ws/src/main/java/okhttp3/internal/ws/RealWebSocket.java
+++ /dev/null
@@ -1,222 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.ws;
-
-import java.io.IOException;
-import java.net.ProtocolException;
-import java.util.Random;
-import java.util.concurrent.Executor;
-import java.util.concurrent.atomic.AtomicBoolean;
-import okhttp3.MediaType;
-import okhttp3.RequestBody;
-import okhttp3.ResponseBody;
-import okhttp3.internal.NamedRunnable;
-import okhttp3.ws.WebSocket;
-import okhttp3.ws.WebSocketListener;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.Okio;
-
-import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_BINARY;
-import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_TEXT;
-import static okhttp3.internal.ws.WebSocketReader.FrameCallback;
-
-public abstract class RealWebSocket implements WebSocket {
-  private static final int CLOSE_PROTOCOL_EXCEPTION = 1002;
-
-  private final WebSocketWriter writer;
-  private final WebSocketReader reader;
-  private final WebSocketListener listener;
-
-  /** True after calling {@link #close(int, String)}. No writes are allowed afterward. */
-  private volatile boolean writerSentClose;
-  /** True after {@link IOException}. {@link #close(int, String)} becomes only valid call. */
-  private boolean writerWantsClose;
-  /** True after a close frame was read by the reader. No frames will follow it. */
-  private boolean readerSentClose;
-
-  /** True after calling {@link #close()} to free connection resources. */
-  private final AtomicBoolean connectionClosed = new AtomicBoolean();
-
-  public RealWebSocket(boolean isClient, BufferedSource source, BufferedSink sink, Random random,
-      final Executor replyExecutor, final WebSocketListener listener, final String url) {
-    this.listener = listener;
-
-    writer = new WebSocketWriter(isClient, sink, random);
-    reader = new WebSocketReader(isClient, source, new FrameCallback() {
-      @Override public void onMessage(ResponseBody message) throws IOException {
-        listener.onMessage(message);
-      }
-
-      @Override public void onPing(final Buffer buffer) {
-        replyExecutor.execute(new NamedRunnable("OkHttp %s WebSocket Pong Reply", url) {
-          @Override protected void execute() {
-            try {
-              writer.writePong(buffer);
-            } catch (IOException ignored) {
-            }
-          }
-        });
-      }
-
-      @Override public void onPong(Buffer buffer) {
-        listener.onPong(buffer);
-      }
-
-      @Override public void onClose(final int code, final String reason) {
-        readerSentClose = true;
-        replyExecutor.execute(new NamedRunnable("OkHttp %s WebSocket Close Reply", url) {
-          @Override protected void execute() {
-            peerClose(code, reason);
-          }
-        });
-      }
-    });
-  }
-
-  /**
-   * Read a single message from the web socket and deliver it to the listener. This method should be
-   * called in a loop with the return value indicating whether looping should continue.
-   */
-  public boolean readMessage() {
-    try {
-      reader.processNextFrame();
-      return !readerSentClose;
-    } catch (IOException e) {
-      readerErrorClose(e);
-      return false;
-    }
-  }
-
-  @Override public void sendMessage(RequestBody message) throws IOException {
-    if (message == null) throw new NullPointerException("message == null");
-    if (writerSentClose) throw new IllegalStateException("closed");
-    if (writerWantsClose) throw new IllegalStateException("must call close()");
-
-    MediaType contentType = message.contentType();
-    if (contentType == null) {
-      throw new IllegalArgumentException(
-          "Message content type was null. Must use WebSocket.TEXT or WebSocket.BINARY.");
-    }
-    String contentSubtype = contentType.subtype();
-
-    int formatOpcode;
-    if (WebSocket.TEXT.subtype().equals(contentSubtype)) {
-      formatOpcode = OPCODE_TEXT;
-    } else if (WebSocket.BINARY.subtype().equals(contentSubtype)) {
-      formatOpcode = OPCODE_BINARY;
-    } else {
-      throw new IllegalArgumentException("Unknown message content type: "
-          + contentType.type() + "/" + contentType.subtype() // Omit any implicitly added charset.
-          + ". Must use WebSocket.TEXT or WebSocket.BINARY.");
-    }
-
-    BufferedSink sink = Okio.buffer(writer.newMessageSink(formatOpcode, message.contentLength()));
-    try {
-      message.writeTo(sink);
-      sink.close();
-    } catch (IOException e) {
-      writerWantsClose = true;
-      throw e;
-    }
-  }
-
-  @Override public void sendPing(Buffer payload) throws IOException {
-    if (writerSentClose) throw new IllegalStateException("closed");
-    if (writerWantsClose) throw new IllegalStateException("must call close()");
-
-    try {
-      writer.writePing(payload);
-    } catch (IOException e) {
-      writerWantsClose = true;
-      throw e;
-    }
-  }
-
-  /** Send an unsolicited pong with the specified payload. */
-  public void sendPong(Buffer payload) throws IOException {
-    if (writerSentClose) throw new IllegalStateException("closed");
-    if (writerWantsClose) throw new IllegalStateException("must call close()");
-
-    try {
-      writer.writePong(payload);
-    } catch (IOException e) {
-      writerWantsClose = true;
-      throw e;
-    }
-  }
-
-  @Override public void close(int code, String reason) throws IOException {
-    if (writerSentClose) throw new IllegalStateException("closed");
-    writerSentClose = true;
-
-    try {
-      writer.writeClose(code, reason);
-    } catch (IOException e) {
-      if (connectionClosed.compareAndSet(false, true)) {
-        // Try to close the connection without masking the original exception.
-        try {
-          close();
-        } catch (IOException ignored) {
-        }
-      }
-      throw e;
-    }
-  }
-
-  /** Replies and closes this web socket when a close frame is read from the peer. */
-  private void peerClose(int code, String reason) {
-    if (!writerSentClose) {
-      try {
-        writer.writeClose(code, reason);
-      } catch (IOException ignored) {
-      }
-    }
-
-    if (connectionClosed.compareAndSet(false, true)) {
-      try {
-        close();
-      } catch (IOException ignored) {
-      }
-    }
-
-    listener.onClose(code, reason);
-  }
-
-  /** Called on the reader thread when an error occurs. */
-  private void readerErrorClose(IOException e) {
-    // For protocol exceptions, try to inform the server of such.
-    if (!writerSentClose && e instanceof ProtocolException) {
-      try {
-        writer.writeClose(CLOSE_PROTOCOL_EXCEPTION, null);
-      } catch (IOException ignored) {
-      }
-    }
-
-    if (connectionClosed.compareAndSet(false, true)) {
-      try {
-        close();
-      } catch (IOException ignored) {
-      }
-    }
-
-    listener.onFailure(e, null);
-  }
-
-  /** Perform any tear-down work (close the connection, shutdown executors). */
-  protected abstract void close() throws IOException;
-}
diff --git a/okhttp-ws/src/main/java/okhttp3/ws/WebSocket.java b/okhttp-ws/src/main/java/okhttp3/ws/WebSocket.java
deleted file mode 100644
index 7435c01d7f..0000000000
--- a/okhttp-ws/src/main/java/okhttp3/ws/WebSocket.java
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.ws;
-
-import java.io.IOException;
-import okhttp3.MediaType;
-import okhttp3.RequestBody;
-import okio.Buffer;
-
-/** Blocking interface to connect and write to a web socket. */
-public interface WebSocket {
-  /** A {@link MediaType} indicating UTF-8 text frames should be used when sending the message. */
-  MediaType TEXT = MediaType.parse("application/vnd.okhttp.websocket+text; charset=utf-8");
-  /** A {@link MediaType} indicating binary frames should be used when sending the message. */
-  MediaType BINARY = MediaType.parse("application/vnd.okhttp.websocket+binary");
-
-  /**
-   * Send a message payload to the server.
-   *
-   * <p>The {@linkplain RequestBody#contentType() content type} of {@code message} should be either
-   * {@link #TEXT} or {@link #BINARY}.
-   *
-   * @throws IOException if unable to write the message. Clients must call {@link #close} when this
-   * happens to ensure resources are cleaned up.
-   * @throws IllegalStateException if not connected, already closed, or another writer is active.
-   */
-  void sendMessage(RequestBody message) throws IOException;
-
-  /**
-   * Send a ping to the server with optional payload.
-   *
-   * @throws IOException if unable to write the ping.  Clients must call {@link #close} when this
-   * happens to ensure resources are cleaned up.
-   * @throws IllegalStateException if already closed.
-   */
-  void sendPing(Buffer payload) throws IOException;
-
-  /**
-   * Send a close frame to the server.
-   *
-   * <p>The corresponding {@link WebSocketListener} will continue to get messages until its {@link
-   * WebSocketListener#onClose onClose()} method is called.
-   *
-   * <p>It is an error to call this method before calling close on an active writer. Calling this
-   * method more than once has no effect.
-   *
-   * @throws IOException if unable to write the close message. Resources will still be freed.
-   * @throws IllegalStateException if already closed.
-   */
-  void close(int code, String reason) throws IOException;
-}
diff --git a/okhttp-ws/src/main/java/okhttp3/ws/WebSocketCall.java b/okhttp-ws/src/main/java/okhttp3/ws/WebSocketCall.java
deleted file mode 100644
index 7293392083..0000000000
--- a/okhttp-ws/src/main/java/okhttp3/ws/WebSocketCall.java
+++ /dev/null
@@ -1,185 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.ws;
-
-import java.io.IOException;
-import java.net.ProtocolException;
-import java.security.SecureRandom;
-import java.util.Collections;
-import java.util.Random;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.LinkedBlockingDeque;
-import java.util.concurrent.ThreadPoolExecutor;
-import okhttp3.Call;
-import okhttp3.Callback;
-import okhttp3.OkHttpClient;
-import okhttp3.Protocol;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.internal.Internal;
-import okhttp3.internal.Util;
-import okhttp3.internal.http.StreamAllocation;
-import okhttp3.internal.ws.RealWebSocket;
-import okhttp3.internal.ws.WebSocketProtocol;
-import okio.ByteString;
-
-import static java.util.concurrent.TimeUnit.SECONDS;
-
-public final class WebSocketCall {
-  /**
-   * Prepares the {@code request} to create a web socket at some point in the future.
-   */
-  public static WebSocketCall create(OkHttpClient client, Request request) {
-    return new WebSocketCall(client, request);
-  }
-
-  private final Call call;
-  private final Random random;
-  private final String key;
-
-  WebSocketCall(OkHttpClient client, Request request) {
-    this(client, request, new SecureRandom());
-  }
-
-  WebSocketCall(OkHttpClient client, Request request, Random random) {
-    if (!"GET".equals(request.method())) {
-      throw new IllegalArgumentException("Request must be GET: " + request.method());
-    }
-    this.random = random;
-
-    byte[] nonce = new byte[16];
-    random.nextBytes(nonce);
-    key = ByteString.of(nonce).base64();
-
-    client = client.newBuilder()
-        .protocols(Collections.singletonList(Protocol.HTTP_1_1))
-        .build();
-
-    request = request.newBuilder()
-        .header("Upgrade", "websocket")
-        .header("Connection", "Upgrade")
-        .header("Sec-WebSocket-Key", key)
-        .header("Sec-WebSocket-Version", "13")
-        .build();
-
-    call = client.newCall(request);
-  }
-
-  /**
-   * Schedules the request to be executed at some point in the future.
-   *
-   * <p>The {@link OkHttpClient#dispatcher dispatcher} defines when the request will run: usually
-   * immediately unless there are several other requests currently being executed.
-   *
-   * <p>This client will later call back {@code responseCallback} with either an HTTP response or a
-   * failure exception. If you {@link #cancel} a request before it completes the callback will not
-   * be invoked.
-   *
-   * @throws IllegalStateException when the call has already been executed.
-   */
-  public void enqueue(final WebSocketListener listener) {
-    Callback responseCallback = new Callback() {
-      @Override public void onResponse(Call call, Response response) throws IOException {
-        try {
-          createWebSocket(response, listener);
-        } catch (IOException e) {
-          listener.onFailure(e, response);
-        }
-      }
-
-      @Override public void onFailure(Call call, IOException e) {
-        listener.onFailure(e, null);
-      }
-    };
-    // TODO call.enqueue(responseCallback, true);
-    Internal.instance.callEnqueue(call, responseCallback, true);
-  }
-
-  /** Cancels the request, if possible. Requests that are already complete cannot be canceled. */
-  public void cancel() {
-    call.cancel();
-  }
-
-  private void createWebSocket(Response response, WebSocketListener listener) throws IOException {
-    if (response.code() != 101) {
-      throw new ProtocolException("Expected HTTP 101 response but was '"
-          + response.code()
-          + " "
-          + response.message()
-          + "'");
-    }
-
-    String headerConnection = response.header("Connection");
-    if (!"Upgrade".equalsIgnoreCase(headerConnection)) {
-      throw new ProtocolException(
-          "Expected 'Connection' header value 'Upgrade' but was '" + headerConnection + "'");
-    }
-    String headerUpgrade = response.header("Upgrade");
-    if (!"websocket".equalsIgnoreCase(headerUpgrade)) {
-      throw new ProtocolException(
-          "Expected 'Upgrade' header value 'websocket' but was '" + headerUpgrade + "'");
-    }
-    String headerAccept = response.header("Sec-WebSocket-Accept");
-    String acceptExpected = Util.shaBase64(key + WebSocketProtocol.ACCEPT_MAGIC);
-    if (!acceptExpected.equals(headerAccept)) {
-      throw new ProtocolException("Expected 'Sec-WebSocket-Accept' header value '"
-          + acceptExpected
-          + "' but was '"
-          + headerAccept
-          + "'");
-    }
-
-    StreamAllocation streamAllocation = Internal.instance.callEngineGetStreamAllocation(call);
-    RealWebSocket webSocket = StreamWebSocket.create(
-        streamAllocation, response, random, listener);
-
-    listener.onOpen(webSocket, response);
-
-    while (webSocket.readMessage()) {
-    }
-  }
-
-  // Keep static so that the WebSocketCall instance can be garbage collected.
-  private static class StreamWebSocket extends RealWebSocket {
-    static RealWebSocket create(StreamAllocation streamAllocation, Response response,
-        Random random, WebSocketListener listener) {
-      String url = response.request().url().toString();
-      ThreadPoolExecutor replyExecutor =
-          new ThreadPoolExecutor(1, 1, 1, SECONDS, new LinkedBlockingDeque<Runnable>(),
-              Util.threadFactory(Util.format("OkHttp %s WebSocket", url), true));
-      replyExecutor.allowCoreThreadTimeOut(true);
-
-      return new StreamWebSocket(streamAllocation, random, replyExecutor, listener, url);
-    }
-
-    private final StreamAllocation streamAllocation;
-    private final ExecutorService replyExecutor;
-
-    private StreamWebSocket(StreamAllocation streamAllocation,
-        Random random, ExecutorService replyExecutor, WebSocketListener listener, String url) {
-      super(true /* is client */, streamAllocation.connection().source,
-          streamAllocation.connection().sink, random, replyExecutor, listener, url);
-      this.streamAllocation = streamAllocation;
-      this.replyExecutor = replyExecutor;
-    }
-
-    @Override protected void close() throws IOException {
-      replyExecutor.shutdown();
-      streamAllocation.noNewStreams();
-      streamAllocation.streamFinished(true, streamAllocation.stream());
-    }
-  }
-}
diff --git a/okhttp-ws/src/main/java/okhttp3/ws/WebSocketListener.java b/okhttp-ws/src/main/java/okhttp3/ws/WebSocketListener.java
deleted file mode 100644
index 12d5e66aab..0000000000
--- a/okhttp-ws/src/main/java/okhttp3/ws/WebSocketListener.java
+++ /dev/null
@@ -1,71 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.ws;
-
-import java.io.IOException;
-import okhttp3.Response;
-import okhttp3.ResponseBody;
-import okio.Buffer;
-
-/** Listener for server-initiated messages on a connected {@link WebSocket}. */
-public interface WebSocketListener {
-  /**
-   * Called when the request has successfully been upgraded to a web socket. This method is called
-   * on the message reading thread to allow setting up any state before the {@linkplain #onMessage
-   * message}, {@linkplain #onPong pong}, and {@link #onClose close} callbacks start.
-   *
-   * <p><b>Do not</b> use this callback to write to the web socket. Start a new thread or use
-   * another thread in your application.
-   */
-  void onOpen(WebSocket webSocket, Response response);
-
-  /**
-   * Called when the transport or protocol layer of this web socket errors during communication.
-   *
-   * @param response Present when the failure is a direct result of the response (e.g., failed
-   * upgrade, non-101 response code, etc.). {@code null} otherwise.
-   */
-  void onFailure(IOException e, Response response);
-
-  /**
-   * Called when a server message is received. The {@code type} indicates whether the {@code
-   * payload} should be interpreted as UTF-8 text or binary data.
-   *
-   * <p>Implementations <strong>must</strong> call {@code source.close()} before returning. This
-   * indicates completion of parsing the message payload and will consume any remaining bytes in the
-   * message.
-   *
-   * <p>The {@linkplain ResponseBody#contentType() content type} of {@code message} will be either
-   * {@link WebSocket#TEXT} or {@link WebSocket#BINARY} which indicates the format of the message.
-   */
-  void onMessage(ResponseBody message) throws IOException;
-
-  /**
-   * Called when a server pong is received. This is usually a result of calling {@link
-   * WebSocket#sendPing(Buffer)} but might also be unsolicited.
-   */
-  void onPong(Buffer payload);
-
-  /**
-   * Called when the server sends a close message. This may have been initiated from a call to
-   * {@link WebSocket#close(int, String) close()} or as an unprompted message from the server.
-   *
-   * @param code The <a href="http://tools.ietf.org/html/rfc6455#section-7.4.1">RFC-compliant</a>
-   * status code.
-   * @param reason Reason for close or an empty string.
-   */
-  void onClose(int code, String reason);
-}
diff --git a/okhttp/pom.xml b/okhttp/pom.xml
index a26e988b27..09015c18e0 100644
--- a/okhttp/pom.xml
+++ b/okhttp/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.4.0-SNAPSHOT</version>
+    <version>3.10.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp</artifactId>
@@ -22,6 +22,11 @@
       <artifactId>android</artifactId>
       <scope>provided</scope>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
   </dependencies>
 
   <build>
diff --git a/okhttp/src/main/java/okhttp3/Address.java b/okhttp/src/main/java/okhttp3/Address.java
index 4fd97764a3..9df666ad78 100644
--- a/okhttp/src/main/java/okhttp3/Address.java
+++ b/okhttp/src/main/java/okhttp3/Address.java
@@ -18,6 +18,7 @@
 import java.net.Proxy;
 import java.net.ProxySelector;
 import java.util.List;
+import javax.annotation.Nullable;
 import javax.net.SocketFactory;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLSocketFactory;
@@ -42,15 +43,16 @@
   final List<Protocol> protocols;
   final List<ConnectionSpec> connectionSpecs;
   final ProxySelector proxySelector;
-  final Proxy proxy;
-  final SSLSocketFactory sslSocketFactory;
-  final HostnameVerifier hostnameVerifier;
-  final CertificatePinner certificatePinner;
+  final @Nullable Proxy proxy;
+  final @Nullable SSLSocketFactory sslSocketFactory;
+  final @Nullable HostnameVerifier hostnameVerifier;
+  final @Nullable CertificatePinner certificatePinner;
 
   public Address(String uriHost, int uriPort, Dns dns, SocketFactory socketFactory,
-      SSLSocketFactory sslSocketFactory, HostnameVerifier hostnameVerifier,
-      CertificatePinner certificatePinner, Authenticator proxyAuthenticator, Proxy proxy,
-      List<Protocol> protocols, List<ConnectionSpec> connectionSpecs, ProxySelector proxySelector) {
+      @Nullable SSLSocketFactory sslSocketFactory, @Nullable HostnameVerifier hostnameVerifier,
+      @Nullable CertificatePinner certificatePinner, Authenticator proxyAuthenticator,
+      @Nullable Proxy proxy, List<Protocol> protocols, List<ConnectionSpec> connectionSpecs,
+      ProxySelector proxySelector) {
     this.url = new HttpUrl.Builder()
         .scheme(sslSocketFactory != null ? "https" : "http")
         .host(uriHost)
@@ -130,40 +132,29 @@ public ProxySelector proxySelector() {
    * Returns this address's explicitly-specified HTTP proxy, or null to delegate to the {@linkplain
    * #proxySelector proxy selector}.
    */
-  public Proxy proxy() {
+  public @Nullable Proxy proxy() {
     return proxy;
   }
 
   /** Returns the SSL socket factory, or null if this is not an HTTPS address. */
-  public SSLSocketFactory sslSocketFactory() {
+  public @Nullable SSLSocketFactory sslSocketFactory() {
     return sslSocketFactory;
   }
 
   /** Returns the hostname verifier, or null if this is not an HTTPS address. */
-  public HostnameVerifier hostnameVerifier() {
+  public @Nullable HostnameVerifier hostnameVerifier() {
     return hostnameVerifier;
   }
 
   /** Returns this address's certificate pinner, or null if this is not an HTTPS address. */
-  public CertificatePinner certificatePinner() {
+  public @Nullable CertificatePinner certificatePinner() {
     return certificatePinner;
   }
 
-  @Override public boolean equals(Object other) {
-    if (other instanceof Address) {
-      Address that = (Address) other;
-      return this.url.equals(that.url)
-          && this.dns.equals(that.dns)
-          && this.proxyAuthenticator.equals(that.proxyAuthenticator)
-          && this.protocols.equals(that.protocols)
-          && this.connectionSpecs.equals(that.connectionSpecs)
-          && this.proxySelector.equals(that.proxySelector)
-          && equal(this.proxy, that.proxy)
-          && equal(this.sslSocketFactory, that.sslSocketFactory)
-          && equal(this.hostnameVerifier, that.hostnameVerifier)
-          && equal(this.certificatePinner, that.certificatePinner);
-    }
-    return false;
+  @Override public boolean equals(@Nullable Object other) {
+    return other instanceof Address
+        && url.equals(((Address) other).url)
+        && equalsNonHost((Address) other);
   }
 
   @Override public int hashCode() {
@@ -180,4 +171,32 @@ public CertificatePinner certificatePinner() {
     result = 31 * result + (certificatePinner != null ? certificatePinner.hashCode() : 0);
     return result;
   }
+
+  boolean equalsNonHost(Address that) {
+    return this.dns.equals(that.dns)
+        && this.proxyAuthenticator.equals(that.proxyAuthenticator)
+        && this.protocols.equals(that.protocols)
+        && this.connectionSpecs.equals(that.connectionSpecs)
+        && this.proxySelector.equals(that.proxySelector)
+        && equal(this.proxy, that.proxy)
+        && equal(this.sslSocketFactory, that.sslSocketFactory)
+        && equal(this.hostnameVerifier, that.hostnameVerifier)
+        && equal(this.certificatePinner, that.certificatePinner)
+        && this.url().port() == that.url().port();
+  }
+
+  @Override public String toString() {
+    StringBuilder result = new StringBuilder()
+        .append("Address{")
+        .append(url.host()).append(":").append(url.port());
+
+    if (proxy != null) {
+      result.append(", proxy=").append(proxy);
+    } else {
+      result.append(", proxySelector=").append(proxySelector);
+    }
+
+    result.append("}");
+    return result.toString();
+  }
 }
diff --git a/okhttp/src/main/java/okhttp3/Authenticator.java b/okhttp/src/main/java/okhttp3/Authenticator.java
index 3463690f7b..9e34bc9706 100644
--- a/okhttp/src/main/java/okhttp3/Authenticator.java
+++ b/okhttp/src/main/java/okhttp3/Authenticator.java
@@ -16,6 +16,7 @@
 package okhttp3;
 
 import java.io.IOException;
+import javax.annotation.Nullable;
 
 /**
  * Responds to an authentication challenge from either a remote web server or a proxy server.
@@ -23,10 +24,18 @@
  * an authorization header, or they may refuse the challenge by returning null. In this case the
  * unauthenticated response will be returned to the caller that triggered it.
  *
+ * <p>Implementations should check if the initial request already included an attempt to
+ * authenticate. If so it is likely that further attempts will not be useful and the authenticator
+ * should give up.
+ *
  * <p>When authentication is requested by an origin server, the response code is 401 and the
  * implementation should respond with a new request that sets the "Authorization" header.
  * <pre>   {@code
  *
+ *    if (response.request().header("Authorization") != null) {
+ *      return null; // Give up, we've already failed to authenticate.
+ *    }
+ *
  *    String credential = Credentials.basic(...)
  *    return response.request().newBuilder()
  *        .header("Authorization", credential)
@@ -37,6 +46,10 @@
  * implementation should respond with a new request that sets the "Proxy-Authorization" header.
  * <pre>   {@code
  *
+ *    if (response.request().header("Proxy-Authorization") != null) {
+ *      return null; // Give up, we've already failed to authenticate.
+ *    }
+ *
  *    String credential = Credentials.basic(...)
  *    return response.request().newBuilder()
  *        .header("Proxy-Authorization", credential)
@@ -58,5 +71,5 @@
    * Returns a request that includes a credential to satisfy an authentication challenge in {@code
    * response}. Returns null if the challenge cannot be satisfied.
    */
-  Request authenticate(Route route, Response response) throws IOException;
+  @Nullable Request authenticate(Route route, Response response) throws IOException;
 }
diff --git a/okhttp/src/main/java/okhttp3/Cache.java b/okhttp/src/main/java/okhttp3/Cache.java
index 7473edef75..d43d91d257 100644
--- a/okhttp/src/main/java/okhttp3/Cache.java
+++ b/okhttp/src/main/java/okhttp3/Cache.java
@@ -28,15 +28,17 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.NoSuchElementException;
-import okhttp3.internal.DiskLruCache;
-import okhttp3.internal.InternalCache;
+import javax.annotation.Nullable;
 import okhttp3.internal.Util;
-import okhttp3.internal.http.CacheRequest;
-import okhttp3.internal.http.CacheStrategy;
+import okhttp3.internal.cache.CacheRequest;
+import okhttp3.internal.cache.CacheStrategy;
+import okhttp3.internal.cache.DiskLruCache;
+import okhttp3.internal.cache.InternalCache;
+import okhttp3.internal.http.HttpHeaders;
 import okhttp3.internal.http.HttpMethod;
-import okhttp3.internal.http.OkHeaders;
 import okhttp3.internal.http.StatusLine;
 import okhttp3.internal.io.FileSystem;
+import okhttp3.internal.platform.Platform;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -151,7 +153,7 @@
       Cache.this.remove(request);
     }
 
-    @Override public void update(Response cached, Response network) throws IOException {
+    @Override public void update(Response cached, Response network) {
       Cache.this.update(cached, network);
     }
 
@@ -164,11 +166,11 @@
     }
   };
 
-  private final DiskLruCache cache;
+  final DiskLruCache cache;
 
   /* read and write statistics, all guarded by 'this' */
-  private int writeSuccessCount;
-  private int writeAbortCount;
+  int writeSuccessCount;
+  int writeAbortCount;
   private int networkCount;
   private int hitCount;
   private int requestCount;
@@ -181,12 +183,12 @@ public Cache(File directory, long maxSize) {
     this.cache = DiskLruCache.create(fileSystem, directory, VERSION, ENTRY_COUNT, maxSize);
   }
 
-  private static String urlToKey(Request request) {
-    return Util.md5Hex(request.url().toString());
+  public static String key(HttpUrl url) {
+    return ByteString.encodeUtf8(url.toString()).md5().hex();
   }
 
-  Response get(Request request) {
-    String key = urlToKey(request);
+  @Nullable Response get(Request request) {
+    String key = key(request.url());
     DiskLruCache.Snapshot snapshot;
     Entry entry;
     try {
@@ -216,7 +218,7 @@ Response get(Request request) {
     return response;
   }
 
-  private CacheRequest put(Response response) throws IOException {
+  @Nullable CacheRequest put(Response response) {
     String requestMethod = response.request().method();
 
     if (HttpMethod.invalidatesCache(response.request().method())) {
@@ -234,14 +236,14 @@ private CacheRequest put(Response response) throws IOException {
       return null;
     }
 
-    if (OkHeaders.hasVaryAll(response)) {
+    if (HttpHeaders.hasVaryAll(response)) {
       return null;
     }
 
     Entry entry = new Entry(response);
     DiskLruCache.Editor editor = null;
     try {
-      editor = cache.edit(urlToKey(response.request()));
+      editor = cache.edit(key(response.request().url()));
       if (editor == null) {
         return null;
       }
@@ -253,11 +255,11 @@ private CacheRequest put(Response response) throws IOException {
     }
   }
 
-  private void remove(Request request) throws IOException {
-    cache.remove(urlToKey(request));
+  void remove(Request request) throws IOException {
+    cache.remove(key(request.url()));
   }
 
-  private void update(Response cached, Response network) {
+  void update(Response cached, Response network) {
     Entry entry = new Entry(network);
     DiskLruCache.Snapshot snapshot = ((CacheResponseBody) cached.body()).snapshot;
     DiskLruCache.Editor editor = null;
@@ -272,7 +274,7 @@ private void update(Response cached, Response network) {
     }
   }
 
-  private void abortQuietly(DiskLruCache.Editor editor) {
+  private void abortQuietly(@Nullable DiskLruCache.Editor editor) {
     // Give up because the cache cannot be written.
     try {
       if (editor != null) {
@@ -326,7 +328,7 @@ public void evictAll() throws IOException {
     return new Iterator<String>() {
       final Iterator<DiskLruCache.Snapshot> delegate = cache.snapshots();
 
-      String nextUrl;
+      @Nullable String nextUrl;
       boolean canRemove;
 
       @Override public boolean hasNext() {
@@ -397,7 +399,7 @@ public boolean isClosed() {
     return cache.isClosed();
   }
 
-  private synchronized void trackResponse(CacheStrategy cacheStrategy) {
+  synchronized void trackResponse(CacheStrategy cacheStrategy) {
     requestCount++;
 
     if (cacheStrategy.networkRequest != null) {
@@ -409,7 +411,7 @@ private synchronized void trackResponse(CacheStrategy cacheStrategy) {
     }
   }
 
-  private synchronized void trackConditionalCacheHit() {
+  synchronized void trackConditionalCacheHit() {
     hitCount++;
   }
 
@@ -428,10 +430,10 @@ public synchronized int requestCount() {
   private final class CacheRequestImpl implements CacheRequest {
     private final DiskLruCache.Editor editor;
     private Sink cacheOut;
-    private boolean done;
     private Sink body;
+    boolean done;
 
-    public CacheRequestImpl(final DiskLruCache.Editor editor) throws IOException {
+    CacheRequestImpl(final DiskLruCache.Editor editor) {
       this.editor = editor;
       this.cacheOut = editor.newSink(ENTRY_BODY);
       this.body = new ForwardingSink(cacheOut) {
@@ -470,6 +472,12 @@ public CacheRequestImpl(final DiskLruCache.Editor editor) throws IOException {
   }
 
   private static final class Entry {
+    /** Synthetic response header: the local time when the request was sent. */
+    private static final String SENT_MILLIS = Platform.get().getPrefix() + "-Sent-Millis";
+
+    /** Synthetic response header: the local time when the response was received. */
+    private static final String RECEIVED_MILLIS = Platform.get().getPrefix() + "-Received-Millis";
+
     private final String url;
     private final Headers varyHeaders;
     private final String requestMethod;
@@ -477,7 +485,7 @@ public CacheRequestImpl(final DiskLruCache.Editor editor) throws IOException {
     private final int code;
     private final String message;
     private final Headers responseHeaders;
-    private final Handshake handshake;
+    private final @Nullable Handshake handshake;
     private final long sentRequestMillis;
     private final long receivedResponseMillis;
 
@@ -529,7 +537,7 @@ public CacheRequestImpl(final DiskLruCache.Editor editor) throws IOException {
      * base64-encoded and appear each on their own line. A length of -1 is used to encode a null
      * array. The last line is optional. If present, it contains the TLS version.
      */
-    public Entry(Source in) throws IOException {
+    Entry(Source in) throws IOException {
       try {
         BufferedSource source = Okio.buffer(in);
         url = source.readUtf8LineStrict();
@@ -550,10 +558,10 @@ public Entry(Source in) throws IOException {
         for (int i = 0; i < responseHeaderLineCount; i++) {
           responseHeadersBuilder.addLenient(source.readUtf8LineStrict());
         }
-        String sendRequestMillisString = responseHeadersBuilder.get(OkHeaders.SENT_MILLIS);
-        String receivedResponseMillisString = responseHeadersBuilder.get(OkHeaders.RECEIVED_MILLIS);
-        responseHeadersBuilder.removeAll(OkHeaders.SENT_MILLIS);
-        responseHeadersBuilder.removeAll(OkHeaders.RECEIVED_MILLIS);
+        String sendRequestMillisString = responseHeadersBuilder.get(SENT_MILLIS);
+        String receivedResponseMillisString = responseHeadersBuilder.get(RECEIVED_MILLIS);
+        responseHeadersBuilder.removeAll(SENT_MILLIS);
+        responseHeadersBuilder.removeAll(RECEIVED_MILLIS);
         sentRequestMillis = sendRequestMillisString != null
             ? Long.parseLong(sendRequestMillisString)
             : 0L;
@@ -573,7 +581,7 @@ public Entry(Source in) throws IOException {
           List<Certificate> localCertificates = readCertificateList(source);
           TlsVersion tlsVersion = !source.exhausted()
               ? TlsVersion.forJavaName(source.readUtf8LineStrict())
-              : null;
+              : TlsVersion.SSL_3_0;
           handshake = Handshake.get(tlsVersion, cipherSuite, peerCertificates, localCertificates);
         } else {
           handshake = null;
@@ -583,9 +591,9 @@ public Entry(Source in) throws IOException {
       }
     }
 
-    public Entry(Response response) {
+    Entry(Response response) {
       this.url = response.request().url().toString();
-      this.varyHeaders = OkHeaders.varyHeaders(response);
+      this.varyHeaders = HttpHeaders.varyHeaders(response);
       this.requestMethod = response.request().method();
       this.protocol = response.protocol();
       this.code = response.code();
@@ -622,11 +630,11 @@ public void writeTo(DiskLruCache.Editor editor) throws IOException {
             .writeUtf8(responseHeaders.value(i))
             .writeByte('\n');
       }
-      sink.writeUtf8(OkHeaders.SENT_MILLIS)
+      sink.writeUtf8(SENT_MILLIS)
           .writeUtf8(": ")
           .writeDecimalLong(sentRequestMillis)
           .writeByte('\n');
-      sink.writeUtf8(OkHeaders.RECEIVED_MILLIS)
+      sink.writeUtf8(RECEIVED_MILLIS)
           .writeUtf8(": ")
           .writeDecimalLong(receivedResponseMillis)
           .writeByte('\n');
@@ -637,11 +645,7 @@ public void writeTo(DiskLruCache.Editor editor) throws IOException {
             .writeByte('\n');
         writeCertList(sink, handshake.peerCertificates());
         writeCertList(sink, handshake.localCertificates());
-        // The handshake’s TLS version is null on HttpsURLConnection and on older cached responses.
-        if (handshake.tlsVersion() != null) {
-          sink.writeUtf8(handshake.tlsVersion().javaName())
-              .writeByte('\n');
-        }
+        sink.writeUtf8(handshake.tlsVersion().javaName()).writeByte('\n');
       }
       sink.close();
     }
@@ -688,7 +692,7 @@ private void writeCertList(BufferedSink sink, List<Certificate> certificates)
     public boolean matches(Request request, Response response) {
       return url.equals(request.url().toString())
           && requestMethod.equals(request.method())
-          && OkHeaders.varyMatches(response, varyHeaders, request);
+          && HttpHeaders.varyMatches(response, varyHeaders, request);
     }
 
     public Response response(DiskLruCache.Snapshot snapshot) {
@@ -713,7 +717,7 @@ public Response response(DiskLruCache.Snapshot snapshot) {
     }
   }
 
-  private static int readInt(BufferedSource source) throws IOException {
+  static int readInt(BufferedSource source) throws IOException {
     try {
       long result = source.readDecimalLong();
       String line = source.readUtf8LineStrict();
@@ -727,12 +731,12 @@ private static int readInt(BufferedSource source) throws IOException {
   }
 
   private static class CacheResponseBody extends ResponseBody {
-    private final DiskLruCache.Snapshot snapshot;
+    final DiskLruCache.Snapshot snapshot;
     private final BufferedSource bodySource;
-    private final String contentType;
-    private final String contentLength;
+    private final @Nullable String contentType;
+    private final @Nullable String contentLength;
 
-    public CacheResponseBody(final DiskLruCache.Snapshot snapshot,
+    CacheResponseBody(final DiskLruCache.Snapshot snapshot,
         String contentType, String contentLength) {
       this.snapshot = snapshot;
       this.contentType = contentType;
diff --git a/okhttp/src/main/java/okhttp3/CacheControl.java b/okhttp/src/main/java/okhttp3/CacheControl.java
index d8eb446149..a32add5f97 100644
--- a/okhttp/src/main/java/okhttp3/CacheControl.java
+++ b/okhttp/src/main/java/okhttp3/CacheControl.java
@@ -1,14 +1,14 @@
 package okhttp3;
 
 import java.util.concurrent.TimeUnit;
-import okhttp3.internal.http.HeaderParser;
+import javax.annotation.Nullable;
+import okhttp3.internal.http.HttpHeaders;
 
 /**
  * A Cache-Control header with cache directives from a server or client. These directives set policy
  * on what responses can be stored, and which requests can be satisfied by those stored responses.
  *
- * <p>See <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9">RFC 2616,
- * 14.9</a>.
+ * <p>See <a href="https://tools.ietf.org/html/rfc7234#section-5.2">RFC 7234, 5.2</a>.
  */
 public final class CacheControl {
   /**
@@ -38,12 +38,14 @@
   private final int minFreshSeconds;
   private final boolean onlyIfCached;
   private final boolean noTransform;
+  private final boolean immutable;
 
-  String headerValue; // Lazily computed, null if absent.
+  @Nullable String headerValue; // Lazily computed, null if absent.
 
   private CacheControl(boolean noCache, boolean noStore, int maxAgeSeconds, int sMaxAgeSeconds,
       boolean isPrivate, boolean isPublic, boolean mustRevalidate, int maxStaleSeconds,
-      int minFreshSeconds, boolean onlyIfCached, boolean noTransform, String headerValue) {
+      int minFreshSeconds, boolean onlyIfCached, boolean noTransform, boolean immutable,
+      @Nullable String headerValue) {
     this.noCache = noCache;
     this.noStore = noStore;
     this.maxAgeSeconds = maxAgeSeconds;
@@ -55,10 +57,11 @@ private CacheControl(boolean noCache, boolean noStore, int maxAgeSeconds, int sM
     this.minFreshSeconds = minFreshSeconds;
     this.onlyIfCached = onlyIfCached;
     this.noTransform = noTransform;
+    this.immutable = immutable;
     this.headerValue = headerValue;
   }
 
-  private CacheControl(Builder builder) {
+  CacheControl(Builder builder) {
     this.noCache = builder.noCache;
     this.noStore = builder.noStore;
     this.maxAgeSeconds = builder.maxAgeSeconds;
@@ -70,6 +73,7 @@ private CacheControl(Builder builder) {
     this.minFreshSeconds = builder.minFreshSeconds;
     this.onlyIfCached = builder.onlyIfCached;
     this.noTransform = builder.noTransform;
+    this.immutable = builder.immutable;
   }
 
   /**
@@ -137,6 +141,10 @@ public boolean noTransform() {
     return noTransform;
   }
 
+  public boolean immutable() {
+    return immutable;
+  }
+
   /**
    * Returns the cache directives of {@code headers}. This honors both Cache-Control and Pragma
    * headers if they are present.
@@ -153,6 +161,7 @@ public static CacheControl parse(Headers headers) {
     int minFreshSeconds = -1;
     boolean onlyIfCached = false;
     boolean noTransform = false;
+    boolean immutable = false;
 
     boolean canUseHeaderValue = true;
     String headerValue = null;
@@ -178,7 +187,7 @@ public static CacheControl parse(Headers headers) {
       int pos = 0;
       while (pos < value.length()) {
         int tokenStart = pos;
-        pos = HeaderParser.skipUntil(value, pos, "=,;");
+        pos = HttpHeaders.skipUntil(value, pos, "=,;");
         String directive = value.substring(tokenStart, pos).trim();
         String parameter;
 
@@ -187,20 +196,20 @@ public static CacheControl parse(Headers headers) {
           parameter = null;
         } else {
           pos++; // consume '='
-          pos = HeaderParser.skipWhitespace(value, pos);
+          pos = HttpHeaders.skipWhitespace(value, pos);
 
           // quoted string
           if (pos < value.length() && value.charAt(pos) == '\"') {
             pos++; // consume '"' open quote
             int parameterStart = pos;
-            pos = HeaderParser.skipUntil(value, pos, "\"");
+            pos = HttpHeaders.skipUntil(value, pos, "\"");
             parameter = value.substring(parameterStart, pos);
             pos++; // consume '"' close quote (if necessary)
 
             // unquoted string
           } else {
             int parameterStart = pos;
-            pos = HeaderParser.skipUntil(value, pos, ",;");
+            pos = HttpHeaders.skipUntil(value, pos, ",;");
             parameter = value.substring(parameterStart, pos).trim();
           }
         }
@@ -210,9 +219,9 @@ public static CacheControl parse(Headers headers) {
         } else if ("no-store".equalsIgnoreCase(directive)) {
           noStore = true;
         } else if ("max-age".equalsIgnoreCase(directive)) {
-          maxAgeSeconds = HeaderParser.parseSeconds(parameter, -1);
+          maxAgeSeconds = HttpHeaders.parseSeconds(parameter, -1);
         } else if ("s-maxage".equalsIgnoreCase(directive)) {
-          sMaxAgeSeconds = HeaderParser.parseSeconds(parameter, -1);
+          sMaxAgeSeconds = HttpHeaders.parseSeconds(parameter, -1);
         } else if ("private".equalsIgnoreCase(directive)) {
           isPrivate = true;
         } else if ("public".equalsIgnoreCase(directive)) {
@@ -220,13 +229,15 @@ public static CacheControl parse(Headers headers) {
         } else if ("must-revalidate".equalsIgnoreCase(directive)) {
           mustRevalidate = true;
         } else if ("max-stale".equalsIgnoreCase(directive)) {
-          maxStaleSeconds = HeaderParser.parseSeconds(parameter, Integer.MAX_VALUE);
+          maxStaleSeconds = HttpHeaders.parseSeconds(parameter, Integer.MAX_VALUE);
         } else if ("min-fresh".equalsIgnoreCase(directive)) {
-          minFreshSeconds = HeaderParser.parseSeconds(parameter, -1);
+          minFreshSeconds = HttpHeaders.parseSeconds(parameter, -1);
         } else if ("only-if-cached".equalsIgnoreCase(directive)) {
           onlyIfCached = true;
         } else if ("no-transform".equalsIgnoreCase(directive)) {
           noTransform = true;
+        } else if ("immutable".equalsIgnoreCase(directive)) {
+          immutable = true;
         }
       }
     }
@@ -235,7 +246,8 @@ public static CacheControl parse(Headers headers) {
       headerValue = null;
     }
     return new CacheControl(noCache, noStore, maxAgeSeconds, sMaxAgeSeconds, isPrivate, isPublic,
-        mustRevalidate, maxStaleSeconds, minFreshSeconds, onlyIfCached, noTransform, headerValue);
+        mustRevalidate, maxStaleSeconds, minFreshSeconds, onlyIfCached, noTransform, immutable,
+        headerValue);
   }
 
   @Override public String toString() {
@@ -256,6 +268,7 @@ private String headerValue() {
     if (minFreshSeconds != -1) result.append("min-fresh=").append(minFreshSeconds).append(", ");
     if (onlyIfCached) result.append("only-if-cached, ");
     if (noTransform) result.append("no-transform, ");
+    if (immutable) result.append("immutable, ");
     if (result.length() == 0) return "";
     result.delete(result.length() - 2, result.length());
     return result.toString();
@@ -270,6 +283,7 @@ private String headerValue() {
     int minFreshSeconds = -1;
     boolean onlyIfCached;
     boolean noTransform;
+    boolean immutable;
 
     /** Don't accept an unvalidated cached response. */
     public Builder noCache() {
@@ -347,6 +361,11 @@ public Builder noTransform() {
       return this;
     }
 
+    public Builder immutable() {
+      this.immutable = true;
+      return this;
+    }
+
     public CacheControl build() {
       return new CacheControl(this);
     }
diff --git a/okhttp/src/main/java/okhttp3/Call.java b/okhttp/src/main/java/okhttp3/Call.java
index 02b8976e6a..5b4669ad21 100644
--- a/okhttp/src/main/java/okhttp3/Call.java
+++ b/okhttp/src/main/java/okhttp3/Call.java
@@ -21,7 +21,7 @@
  * A call is a request that has been prepared for execution. A call can be canceled. As this object
  * represents a single request/response pair (stream), it cannot be executed twice.
  */
-public interface Call {
+public interface Call extends Cloneable {
   /** Returns the original request that initiated this call. */
   Request request();
 
@@ -29,8 +29,21 @@
    * Invokes the request immediately, and blocks until the response can be processed or is in
    * error.
    *
+   * <p>To avoid leaking resources callers should close the {@link Response} which in turn will
+   * close the underlying {@link ResponseBody}.
+   *
+   * <pre>@{code
+   *
+   *   // ensure the response (and underlying response body) is closed
+   *   try (Response response = client.newCall(request).execute()) {
+   *     ...
+   *   }
+   *
+   * }</pre>
+   *
    * <p>The caller may read the response body with the response's {@link Response#body} method. To
-   * avoid leaking resources callers must {@linkplain ResponseBody close the response body}.
+   * avoid leaking resources callers must {@linkplain ResponseBody close the response body} or the
+   * Response.
    *
    * <p>Note that transport-layer success (receiving a HTTP response code, headers and body) does
    * not necessarily indicate application-layer success: {@code response} may still indicate an
@@ -67,6 +80,12 @@
 
   boolean isCanceled();
 
+  /**
+   * Create a new, identical call to this one which can be enqueued or executed even if this call
+   * has already been.
+   */
+  Call clone();
+
   interface Factory {
     Call newCall(Request request);
   }
diff --git a/okhttp/src/main/java/okhttp3/CertificatePinner.java b/okhttp/src/main/java/okhttp3/CertificatePinner.java
index 2d90224922..6fab2cf1d1 100644
--- a/okhttp/src/main/java/okhttp3/CertificatePinner.java
+++ b/okhttp/src/main/java/okhttp3/CertificatePinner.java
@@ -20,12 +20,16 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
+import java.util.LinkedHashSet;
 import java.util.List;
+import java.util.Set;
+import javax.annotation.Nullable;
 import javax.net.ssl.SSLPeerUnverifiedException;
-import okhttp3.internal.Util;
 import okhttp3.internal.tls.CertificateChainCleaner;
 import okio.ByteString;
 
+import static okhttp3.internal.Util.equal;
+
 /**
  * Constrains which certificates are trusted. Pinning certificates defends against attacks on
  * certificate authorities. It also prevents connections through man-in-the-middle certificate
@@ -124,14 +128,27 @@
 public final class CertificatePinner {
   public static final CertificatePinner DEFAULT = new Builder().build();
 
-  private final List<Pin> pins;
-  private final CertificateChainCleaner certificateChainCleaner;
+  private final Set<Pin> pins;
+  private final @Nullable CertificateChainCleaner certificateChainCleaner;
 
-  private CertificatePinner(List<Pin> pins, CertificateChainCleaner certificateChainCleaner) {
+  CertificatePinner(Set<Pin> pins, @Nullable CertificateChainCleaner certificateChainCleaner) {
     this.pins = pins;
     this.certificateChainCleaner = certificateChainCleaner;
   }
 
+  @Override public boolean equals(@Nullable Object other) {
+    if (other == this) return true;
+    return other instanceof CertificatePinner
+        && (equal(certificateChainCleaner, ((CertificatePinner) other).certificateChainCleaner)
+        && pins.equals(((CertificatePinner) other).pins));
+  }
+
+  @Override public int hashCode() {
+    int result = certificateChainCleaner != null ? certificateChainCleaner.hashCode() : 0;
+    result = 31 * result + pins.hashCode();
+    return result;
+  }
+
   /**
    * Confirms that at least one of the certificates pinned for {@code hostname} is in {@code
    * peerCertificates}. Does nothing if there are no certificates pinned for {@code hostname}.
@@ -165,7 +182,7 @@ public void check(String hostname, List<Certificate> peerCertificates)
           if (sha1 == null) sha1 = sha1(x509Certificate);
           if (pin.hash.equals(sha1)) return; // Success!
         } else {
-          throw new AssertionError();
+          throw new AssertionError("unsupported hashAlgorithm: " + pin.hashAlgorithm);
         }
       }
     }
@@ -209,10 +226,11 @@ public void check(String hostname, Certificate... peerCertificates)
   }
 
   /** Returns a certificate pinner that uses {@code certificateChainCleaner}. */
-  CertificatePinner withCertificateChainCleaner(CertificateChainCleaner certificateChainCleaner) {
-    return this.certificateChainCleaner != certificateChainCleaner
-        ? new CertificatePinner(pins, certificateChainCleaner)
-        : this;
+  CertificatePinner withCertificateChainCleaner(
+      @Nullable CertificateChainCleaner certificateChainCleaner) {
+    return equal(this.certificateChainCleaner, certificateChainCleaner)
+        ? this
+        : new CertificatePinner(pins, certificateChainCleaner);
   }
 
   /**
@@ -229,16 +247,19 @@ public static String pin(Certificate certificate) {
   }
 
   static ByteString sha1(X509Certificate x509Certificate) {
-    return Util.sha1(ByteString.of(x509Certificate.getPublicKey().getEncoded()));
+    return ByteString.of(x509Certificate.getPublicKey().getEncoded()).sha1();
   }
 
   static ByteString sha256(X509Certificate x509Certificate) {
-    return Util.sha256(ByteString.of(x509Certificate.getPublicKey().getEncoded()));
+    return ByteString.of(x509Certificate.getPublicKey().getEncoded()).sha256();
   }
 
   static final class Pin {
+    private static final String WILDCARD = "*.";
     /** A hostname like {@code example.com} or a pattern like {@code *.example.com}. */
     final String pattern;
+    /** The canonical hostname, i.e. {@code EXAMPLE.com} becomes {@code example.com}. */
+    final String canonicalHostname;
     /** Either {@code sha1/} or {@code sha256/}. */
     final String hashAlgorithm;
     /** The hash of the pinned certificate using {@link #hashAlgorithm}. */
@@ -246,6 +267,9 @@ static ByteString sha256(X509Certificate x509Certificate) {
 
     Pin(String pattern, String pin) {
       this.pattern = pattern;
+      this.canonicalHostname = pattern.startsWith(WILDCARD)
+          ? HttpUrl.parse("http://" + pattern.substring(WILDCARD.length())).host()
+          : HttpUrl.parse("http://" + pattern).host();
       if (pin.startsWith("sha1/")) {
         this.hashAlgorithm = "sha1/";
         this.hash = ByteString.decodeBase64(pin.substring("sha1/".length()));
@@ -262,11 +286,14 @@ static ByteString sha256(X509Certificate x509Certificate) {
     }
 
     boolean matches(String hostname) {
-      if (pattern.equals(hostname)) return true;
+      if (pattern.startsWith(WILDCARD)) {
+        int firstDot = hostname.indexOf('.');
+        return (hostname.length() - firstDot - 1) == canonicalHostname.length()
+            && hostname.regionMatches(false, firstDot + 1, canonicalHostname, 0,
+            canonicalHostname.length());
+      }
 
-      int firstDot = hostname.indexOf('.');
-      return pattern.startsWith("*.")
-          && hostname.regionMatches(false, firstDot + 1, pattern, 2, pattern.length() - 2);
+      return hostname.equals(canonicalHostname);
     }
 
     @Override public boolean equals(Object other) {
@@ -311,7 +338,7 @@ public Builder add(String pattern, String... pins) {
     }
 
     public CertificatePinner build() {
-      return new CertificatePinner(Util.immutableList(pins), null);
+      return new CertificatePinner(new LinkedHashSet<>(pins), null);
     }
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/Challenge.java b/okhttp/src/main/java/okhttp3/Challenge.java
index f4bb369c45..4b000eceda 100644
--- a/okhttp/src/main/java/okhttp3/Challenge.java
+++ b/okhttp/src/main/java/okhttp3/Challenge.java
@@ -15,16 +15,33 @@
  */
 package okhttp3;
 
-import okhttp3.internal.Util;
+import java.nio.charset.Charset;
+import javax.annotation.Nullable;
 
-/** An RFC 2617 challenge. */
+import static okhttp3.internal.Util.ISO_8859_1;
+
+/** An RFC 7617 challenge. */
 public final class Challenge {
   private final String scheme;
   private final String realm;
+  private final Charset charset;
 
   public Challenge(String scheme, String realm) {
+    this(scheme, realm, ISO_8859_1);
+  }
+
+  private Challenge(String scheme, String realm, Charset charset) {
+    if (scheme == null) throw new NullPointerException("scheme == null");
+    if (realm == null) throw new NullPointerException("realm == null");
+    if (charset == null) throw new NullPointerException("charset == null");
     this.scheme = scheme;
     this.realm = realm;
+    this.charset = charset;
+  }
+
+  /** Returns a copy of this charset that expects a credential encoded with {@code charset}. */
+  public Challenge withCharset(Charset charset) {
+    return new Challenge(scheme, realm, charset);
   }
 
   /** Returns the authentication scheme, like {@code Basic}. */
@@ -37,20 +54,29 @@ public String realm() {
     return realm;
   }
 
-  @Override public boolean equals(Object o) {
-    return o instanceof Challenge
-        && Util.equal(scheme, ((Challenge) o).scheme)
-        && Util.equal(realm, ((Challenge) o).realm);
+  /** Returns the charset that should be used to encode the credential. */
+  public Charset charset() {
+    return charset;
+  }
+
+  @Override public boolean equals(@Nullable Object other) {
+    return other instanceof Challenge
+        && ((Challenge) other).scheme.equals(scheme)
+        && ((Challenge) other).realm.equals(realm)
+        && ((Challenge) other).charset.equals(charset);
   }
 
   @Override public int hashCode() {
     int result = 29;
-    result = 31 * result + (realm != null ? realm.hashCode() : 0);
-    result = 31 * result + (scheme != null ? scheme.hashCode() : 0);
+    result = 31 * result + realm.hashCode();
+    result = 31 * result + scheme.hashCode();
+    result = 31 * result + charset.hashCode();
     return result;
   }
 
   @Override public String toString() {
-    return scheme + " realm=\"" + realm + "\"";
+    return scheme
+        + " realm=\"" + realm + "\""
+        + " charset=\"" + charset + "\"";
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/CipherSuite.java b/okhttp/src/main/java/okhttp3/CipherSuite.java
index 6697cad846..a71ddc5ed9 100644
--- a/okhttp/src/main/java/okhttp3/CipherSuite.java
+++ b/okhttp/src/main/java/okhttp3/CipherSuite.java
@@ -15,7 +15,12 @@
  */
 package okhttp3;
 
-import static java.lang.Integer.MAX_VALUE;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.List;
+import java.util.Map;
+import java.util.TreeMap;
 
 /**
  * <a href="https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml">TLS cipher
@@ -29,356 +34,411 @@
  * <p>See also <a href="https://android.googlesource.com/platform/external/conscrypt/+/master/src/main/java/org/conscrypt/NativeCrypto.java">NativeCrypto.java</a>
  * from conscrypt, which lists the cipher suites supported by Android.
  */
-public enum CipherSuite {
-  // Last updated 2014-11-11 using cipher suites from Android 21 and Java 8.
+public final class CipherSuite {
+  /**
+   * Compares cipher suites names like "TLS_RSA_WITH_NULL_MD5" and "SSL_RSA_WITH_NULL_MD5", ignoring
+   * the "TLS_" or "SSL_" prefix which is not consistent across platforms. In particular some IBM
+   * JVMs use the "SSL_" prefix everywhere whereas Oracle JVMs mix "TLS_" and "SSL_".
+   */
+  static final Comparator<String> ORDER_BY_NAME = new Comparator<String>() {
+    @Override public int compare(String a, String b) {
+      for (int i = 4, limit = Math.min(a.length(), b.length()); i < limit; i++) {
+        char charA = a.charAt(i);
+        char charB = b.charAt(i);
+        if (charA != charB) return charA < charB ? -1 : 1;
+      }
+      int lengthA = a.length();
+      int lengthB = b.length();
+      if (lengthA != lengthB) return lengthA < lengthB ? -1 : 1;
+      return 0;
+    }
+  };
+
+  /**
+   * Holds interned instances. This needs to be above the of() calls below so that it's
+   * initialized by the time those parts of {@code <clinit>()} run. Guarded by CipherSuite.class.
+   */
+  private static final Map<String, CipherSuite> INSTANCES = new TreeMap<>(ORDER_BY_NAME);
 
-  // TLS_NULL_WITH_NULL_NULL("TLS_NULL_WITH_NULL_NULL", 0x0000, 5246, MAX_VALUE, MAX_VALUE),
-  TLS_RSA_WITH_NULL_MD5("SSL_RSA_WITH_NULL_MD5", 0x0001, 5246, 6, 10),
-  TLS_RSA_WITH_NULL_SHA("SSL_RSA_WITH_NULL_SHA", 0x0002, 5246, 6, 10),
-  TLS_RSA_EXPORT_WITH_RC4_40_MD5("SSL_RSA_EXPORT_WITH_RC4_40_MD5", 0x0003, 4346, 6, 10),
-  TLS_RSA_WITH_RC4_128_MD5("SSL_RSA_WITH_RC4_128_MD5", 0x0004, 5246, 6, 10),
-  TLS_RSA_WITH_RC4_128_SHA("SSL_RSA_WITH_RC4_128_SHA", 0x0005, 5246, 6, 10),
-  // TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5("SSL_RSA_EXPORT_WITH_RC2_CBC_40_MD5", 0x0006, 4346, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_WITH_IDEA_CBC_SHA("TLS_RSA_WITH_IDEA_CBC_SHA", 0x0007, 5469, MAX_VALUE, MAX_VALUE),
-  TLS_RSA_EXPORT_WITH_DES40_CBC_SHA("SSL_RSA_EXPORT_WITH_DES40_CBC_SHA", 0x0008, 4346, 6, 10),
-  TLS_RSA_WITH_DES_CBC_SHA("SSL_RSA_WITH_DES_CBC_SHA", 0x0009, 5469, 6, 10),
-  TLS_RSA_WITH_3DES_EDE_CBC_SHA("SSL_RSA_WITH_3DES_EDE_CBC_SHA", 0x000a, 5246, 6, 10),
-  // TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA("SSL_DH_DSS_EXPORT_WITH_DES40_CBC_SHA", 0x000b, 4346, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_DSS_WITH_DES_CBC_SHA("TLS_DH_DSS_WITH_DES_CBC_SHA", 0x000c, 5469, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA("TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA", 0x000d, 5246, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA("SSL_DH_RSA_EXPORT_WITH_DES40_CBC_SHA", 0x000e, 4346, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_RSA_WITH_DES_CBC_SHA("TLS_DH_RSA_WITH_DES_CBC_SHA", 0x000f, 5469, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA("TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA", 0x0010, 5246, MAX_VALUE, MAX_VALUE),
-  TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA("SSL_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA", 0x0011, 4346, 6, 10),
-  TLS_DHE_DSS_WITH_DES_CBC_SHA("SSL_DHE_DSS_WITH_DES_CBC_SHA", 0x0012, 5469, 6, 10),
-  TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA("SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA", 0x0013, 5246, 6, 10),
-  TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA("SSL_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA", 0x0014, 4346, 6, 10),
-  TLS_DHE_RSA_WITH_DES_CBC_SHA("SSL_DHE_RSA_WITH_DES_CBC_SHA", 0x0015, 5469, 6, 10),
-  TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA("SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA", 0x0016, 5246, 6, 10),
-  TLS_DH_anon_EXPORT_WITH_RC4_40_MD5("SSL_DH_anon_EXPORT_WITH_RC4_40_MD5", 0x0017, 4346, 6, 10),
-  TLS_DH_anon_WITH_RC4_128_MD5("SSL_DH_anon_WITH_RC4_128_MD5", 0x0018, 5246, 6, 10),
-  TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA("SSL_DH_anon_EXPORT_WITH_DES40_CBC_SHA", 0x0019, 4346, 6, 10),
-  TLS_DH_anon_WITH_DES_CBC_SHA("SSL_DH_anon_WITH_DES_CBC_SHA", 0x001a, 5469, 6, 10),
-  TLS_DH_anon_WITH_3DES_EDE_CBC_SHA("SSL_DH_anon_WITH_3DES_EDE_CBC_SHA", 0x001b, 5246, 6, 10),
-  TLS_KRB5_WITH_DES_CBC_SHA("TLS_KRB5_WITH_DES_CBC_SHA", 0x001e, 2712, 6, MAX_VALUE),
-  TLS_KRB5_WITH_3DES_EDE_CBC_SHA("TLS_KRB5_WITH_3DES_EDE_CBC_SHA", 0x001f, 2712, 6, MAX_VALUE),
-  TLS_KRB5_WITH_RC4_128_SHA("TLS_KRB5_WITH_RC4_128_SHA", 0x0020, 2712, 6, MAX_VALUE),
-  // TLS_KRB5_WITH_IDEA_CBC_SHA("TLS_KRB5_WITH_IDEA_CBC_SHA", 0x0021, 2712, MAX_VALUE, MAX_VALUE),
-  TLS_KRB5_WITH_DES_CBC_MD5("TLS_KRB5_WITH_DES_CBC_MD5", 0x0022, 2712, 6, MAX_VALUE),
-  TLS_KRB5_WITH_3DES_EDE_CBC_MD5("TLS_KRB5_WITH_3DES_EDE_CBC_MD5", 0x0023, 2712, 6, MAX_VALUE),
-  TLS_KRB5_WITH_RC4_128_MD5("TLS_KRB5_WITH_RC4_128_MD5", 0x0024, 2712, 6, MAX_VALUE),
-  // TLS_KRB5_WITH_IDEA_CBC_MD5("TLS_KRB5_WITH_IDEA_CBC_MD5", 0x0025, 2712, MAX_VALUE, MAX_VALUE),
-  TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA("TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA", 0x0026, 2712, 6, MAX_VALUE),
-  // TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA("TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA", 0x0027, 2712, MAX_VALUE, MAX_VALUE),
-  TLS_KRB5_EXPORT_WITH_RC4_40_SHA("TLS_KRB5_EXPORT_WITH_RC4_40_SHA", 0x0028, 2712, 6, MAX_VALUE),
-  TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5("TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5", 0x0029, 2712, 6, MAX_VALUE),
-  // TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5("TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5", 0x002a, 2712, MAX_VALUE, MAX_VALUE),
-  TLS_KRB5_EXPORT_WITH_RC4_40_MD5("TLS_KRB5_EXPORT_WITH_RC4_40_MD5", 0x002b, 2712, 6, MAX_VALUE),
-  // TLS_PSK_WITH_NULL_SHA("TLS_PSK_WITH_NULL_SHA", 0x002c, 4785, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_PSK_WITH_NULL_SHA("TLS_DHE_PSK_WITH_NULL_SHA", 0x002d, 4785, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_PSK_WITH_NULL_SHA("TLS_RSA_PSK_WITH_NULL_SHA", 0x002e, 4785, MAX_VALUE, MAX_VALUE),
-  TLS_RSA_WITH_AES_128_CBC_SHA("TLS_RSA_WITH_AES_128_CBC_SHA", 0x002f, 5246, 6, 10),
-  // TLS_DH_DSS_WITH_AES_128_CBC_SHA("TLS_DH_DSS_WITH_AES_128_CBC_SHA", 0x0030, 5246, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_RSA_WITH_AES_128_CBC_SHA("TLS_DH_RSA_WITH_AES_128_CBC_SHA", 0x0031, 5246, MAX_VALUE, MAX_VALUE),
-  TLS_DHE_DSS_WITH_AES_128_CBC_SHA("TLS_DHE_DSS_WITH_AES_128_CBC_SHA", 0x0032, 5246, 6, 10),
-  TLS_DHE_RSA_WITH_AES_128_CBC_SHA("TLS_DHE_RSA_WITH_AES_128_CBC_SHA", 0x0033, 5246, 6, 10),
-  TLS_DH_anon_WITH_AES_128_CBC_SHA("TLS_DH_anon_WITH_AES_128_CBC_SHA", 0x0034, 5246, 6, 10),
-  TLS_RSA_WITH_AES_256_CBC_SHA("TLS_RSA_WITH_AES_256_CBC_SHA", 0x0035, 5246, 6, 10),
-  // TLS_DH_DSS_WITH_AES_256_CBC_SHA("TLS_DH_DSS_WITH_AES_256_CBC_SHA", 0x0036, 5246, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_RSA_WITH_AES_256_CBC_SHA("TLS_DH_RSA_WITH_AES_256_CBC_SHA", 0x0037, 5246, MAX_VALUE, MAX_VALUE),
-  TLS_DHE_DSS_WITH_AES_256_CBC_SHA("TLS_DHE_DSS_WITH_AES_256_CBC_SHA", 0x0038, 5246, 6, 10),
-  TLS_DHE_RSA_WITH_AES_256_CBC_SHA("TLS_DHE_RSA_WITH_AES_256_CBC_SHA", 0x0039, 5246, 6, 10),
-  TLS_DH_anon_WITH_AES_256_CBC_SHA("TLS_DH_anon_WITH_AES_256_CBC_SHA", 0x003a, 5246, 6, 10),
-  TLS_RSA_WITH_NULL_SHA256("TLS_RSA_WITH_NULL_SHA256", 0x003b, 5246, 7, 21),
-  TLS_RSA_WITH_AES_128_CBC_SHA256("TLS_RSA_WITH_AES_128_CBC_SHA256", 0x003c, 5246, 7, 21),
-  TLS_RSA_WITH_AES_256_CBC_SHA256("TLS_RSA_WITH_AES_256_CBC_SHA256", 0x003d, 5246, 7, 21),
-  // TLS_DH_DSS_WITH_AES_128_CBC_SHA256("TLS_DH_DSS_WITH_AES_128_CBC_SHA256", 0x003e, 5246, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_RSA_WITH_AES_128_CBC_SHA256("TLS_DH_RSA_WITH_AES_128_CBC_SHA256", 0x003f, 5246, MAX_VALUE, MAX_VALUE),
-  TLS_DHE_DSS_WITH_AES_128_CBC_SHA256("TLS_DHE_DSS_WITH_AES_128_CBC_SHA256", 0x0040, 5246, 7, 21),
-  // TLS_RSA_WITH_CAMELLIA_128_CBC_SHA("TLS_RSA_WITH_CAMELLIA_128_CBC_SHA", 0x0041, 5932, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA("TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA", 0x0042, 5932, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA("TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA", 0x0043, 5932, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA("TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA", 0x0044, 5932, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA("TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA", 0x0045, 5932, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA("TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA", 0x0046, 5932, MAX_VALUE, MAX_VALUE),
-  TLS_DHE_RSA_WITH_AES_128_CBC_SHA256("TLS_DHE_RSA_WITH_AES_128_CBC_SHA256", 0x0067, 5246, 7, 21),
-  // TLS_DH_DSS_WITH_AES_256_CBC_SHA256("TLS_DH_DSS_WITH_AES_256_CBC_SHA256", 0x0068, 5246, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_RSA_WITH_AES_256_CBC_SHA256("TLS_DH_RSA_WITH_AES_256_CBC_SHA256", 0x0069, 5246, MAX_VALUE, MAX_VALUE),
-  TLS_DHE_DSS_WITH_AES_256_CBC_SHA256("TLS_DHE_DSS_WITH_AES_256_CBC_SHA256", 0x006a, 5246, 7, 21),
-  TLS_DHE_RSA_WITH_AES_256_CBC_SHA256("TLS_DHE_RSA_WITH_AES_256_CBC_SHA256", 0x006b, 5246, 7, 21),
-  TLS_DH_anon_WITH_AES_128_CBC_SHA256("TLS_DH_anon_WITH_AES_128_CBC_SHA256", 0x006c, 5246, 7, 21),
-  TLS_DH_anon_WITH_AES_256_CBC_SHA256("TLS_DH_anon_WITH_AES_256_CBC_SHA256", 0x006d, 5246, 7, 21),
-  // TLS_RSA_WITH_CAMELLIA_256_CBC_SHA("TLS_RSA_WITH_CAMELLIA_256_CBC_SHA", 0x0084, 5932, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA("TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA", 0x0085, 5932, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA("TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA", 0x0086, 5932, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA("TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA", 0x0087, 5932, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA("TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA", 0x0088, 5932, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA("TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA", 0x0089, 5932, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_WITH_RC4_128_SHA("TLS_PSK_WITH_RC4_128_SHA", 0x008a, 4279, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_WITH_3DES_EDE_CBC_SHA("TLS_PSK_WITH_3DES_EDE_CBC_SHA", 0x008b, 4279, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_WITH_AES_128_CBC_SHA("TLS_PSK_WITH_AES_128_CBC_SHA", 0x008c, 4279, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_WITH_AES_256_CBC_SHA("TLS_PSK_WITH_AES_256_CBC_SHA", 0x008d, 4279, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_PSK_WITH_RC4_128_SHA("TLS_DHE_PSK_WITH_RC4_128_SHA", 0x008e, 4279, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA("TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA", 0x008f, 4279, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_PSK_WITH_AES_128_CBC_SHA("TLS_DHE_PSK_WITH_AES_128_CBC_SHA", 0x0090, 4279, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_PSK_WITH_AES_256_CBC_SHA("TLS_DHE_PSK_WITH_AES_256_CBC_SHA", 0x0091, 4279, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_PSK_WITH_RC4_128_SHA("TLS_RSA_PSK_WITH_RC4_128_SHA", 0x0092, 4279, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA("TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA", 0x0093, 4279, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_PSK_WITH_AES_128_CBC_SHA("TLS_RSA_PSK_WITH_AES_128_CBC_SHA", 0x0094, 4279, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_PSK_WITH_AES_256_CBC_SHA("TLS_RSA_PSK_WITH_AES_256_CBC_SHA", 0x0095, 4279, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_WITH_SEED_CBC_SHA("TLS_RSA_WITH_SEED_CBC_SHA", 0x0096, 4162, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_DSS_WITH_SEED_CBC_SHA("TLS_DH_DSS_WITH_SEED_CBC_SHA", 0x0097, 4162, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_RSA_WITH_SEED_CBC_SHA("TLS_DH_RSA_WITH_SEED_CBC_SHA", 0x0098, 4162, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_DSS_WITH_SEED_CBC_SHA("TLS_DHE_DSS_WITH_SEED_CBC_SHA", 0x0099, 4162, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_RSA_WITH_SEED_CBC_SHA("TLS_DHE_RSA_WITH_SEED_CBC_SHA", 0x009a, 4162, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_anon_WITH_SEED_CBC_SHA("TLS_DH_anon_WITH_SEED_CBC_SHA", 0x009b, 4162, MAX_VALUE, MAX_VALUE),
-  TLS_RSA_WITH_AES_128_GCM_SHA256("TLS_RSA_WITH_AES_128_GCM_SHA256", 0x009c, 5288, 8, 21),
-  TLS_RSA_WITH_AES_256_GCM_SHA384("TLS_RSA_WITH_AES_256_GCM_SHA384", 0x009d, 5288, 8, 21),
-  TLS_DHE_RSA_WITH_AES_128_GCM_SHA256("TLS_DHE_RSA_WITH_AES_128_GCM_SHA256", 0x009e, 5288, 8, 21),
-  TLS_DHE_RSA_WITH_AES_256_GCM_SHA384("TLS_DHE_RSA_WITH_AES_256_GCM_SHA384", 0x009f, 5288, 8, 21),
-  // TLS_DH_RSA_WITH_AES_128_GCM_SHA256("TLS_DH_RSA_WITH_AES_128_GCM_SHA256", 0x00a0, 5288, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_RSA_WITH_AES_256_GCM_SHA384("TLS_DH_RSA_WITH_AES_256_GCM_SHA384", 0x00a1, 5288, MAX_VALUE, MAX_VALUE),
-  TLS_DHE_DSS_WITH_AES_128_GCM_SHA256("TLS_DHE_DSS_WITH_AES_128_GCM_SHA256", 0x00a2, 5288, 8, 21),
-  TLS_DHE_DSS_WITH_AES_256_GCM_SHA384("TLS_DHE_DSS_WITH_AES_256_GCM_SHA384", 0x00a3, 5288, 8, 21),
-  // TLS_DH_DSS_WITH_AES_128_GCM_SHA256("TLS_DH_DSS_WITH_AES_128_GCM_SHA256", 0x00a4, 5288, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_DSS_WITH_AES_256_GCM_SHA384("TLS_DH_DSS_WITH_AES_256_GCM_SHA384", 0x00a5, 5288, MAX_VALUE, MAX_VALUE),
-  TLS_DH_anon_WITH_AES_128_GCM_SHA256("TLS_DH_anon_WITH_AES_128_GCM_SHA256", 0x00a6, 5288, 8, 21),
-  TLS_DH_anon_WITH_AES_256_GCM_SHA384("TLS_DH_anon_WITH_AES_256_GCM_SHA384", 0x00a7, 5288, 8, 21),
-  // TLS_PSK_WITH_AES_128_GCM_SHA256("TLS_PSK_WITH_AES_128_GCM_SHA256", 0x00a8, 5487, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_WITH_AES_256_GCM_SHA384("TLS_PSK_WITH_AES_256_GCM_SHA384", 0x00a9, 5487, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_PSK_WITH_AES_128_GCM_SHA256("TLS_DHE_PSK_WITH_AES_128_GCM_SHA256", 0x00aa, 5487, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_PSK_WITH_AES_256_GCM_SHA384("TLS_DHE_PSK_WITH_AES_256_GCM_SHA384", 0x00ab, 5487, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_PSK_WITH_AES_128_GCM_SHA256("TLS_RSA_PSK_WITH_AES_128_GCM_SHA256", 0x00ac, 5487, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_PSK_WITH_AES_256_GCM_SHA384("TLS_RSA_PSK_WITH_AES_256_GCM_SHA384", 0x00ad, 5487, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_WITH_AES_128_CBC_SHA256("TLS_PSK_WITH_AES_128_CBC_SHA256", 0x00ae, 5487, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_WITH_AES_256_CBC_SHA384("TLS_PSK_WITH_AES_256_CBC_SHA384", 0x00af, 5487, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_WITH_NULL_SHA256("TLS_PSK_WITH_NULL_SHA256", 0x00b0, 5487, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_WITH_NULL_SHA384("TLS_PSK_WITH_NULL_SHA384", 0x00b1, 5487, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_PSK_WITH_AES_128_CBC_SHA256("TLS_DHE_PSK_WITH_AES_128_CBC_SHA256", 0x00b2, 5487, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_PSK_WITH_AES_256_CBC_SHA384("TLS_DHE_PSK_WITH_AES_256_CBC_SHA384", 0x00b3, 5487, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_PSK_WITH_NULL_SHA256("TLS_DHE_PSK_WITH_NULL_SHA256", 0x00b4, 5487, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_PSK_WITH_NULL_SHA384("TLS_DHE_PSK_WITH_NULL_SHA384", 0x00b5, 5487, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_PSK_WITH_AES_128_CBC_SHA256("TLS_RSA_PSK_WITH_AES_128_CBC_SHA256", 0x00b6, 5487, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_PSK_WITH_AES_256_CBC_SHA384("TLS_RSA_PSK_WITH_AES_256_CBC_SHA384", 0x00b7, 5487, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_PSK_WITH_NULL_SHA256("TLS_RSA_PSK_WITH_NULL_SHA256", 0x00b8, 5487, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_PSK_WITH_NULL_SHA384("TLS_RSA_PSK_WITH_NULL_SHA384", 0x00b9, 5487, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256("TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0x00ba, 5932, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256("TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256", 0x00bb, 5932, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256("TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0x00bc, 5932, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256("TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256", 0x00bd, 5932, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256("TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0x00be, 5932, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256("TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256", 0x00bf, 5932, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256("TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256", 0x00c0, 5932, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256("TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256", 0x00c1, 5932, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256("TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256", 0x00c2, 5932, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256("TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256", 0x00c3, 5932, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256("TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256", 0x00c4, 5932, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256("TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256", 0x00c5, 5932, MAX_VALUE, MAX_VALUE),
-  TLS_EMPTY_RENEGOTIATION_INFO_SCSV("TLS_EMPTY_RENEGOTIATION_INFO_SCSV", 0x00ff, 5746, 6, 14),
-  TLS_ECDH_ECDSA_WITH_NULL_SHA("TLS_ECDH_ECDSA_WITH_NULL_SHA", 0xc001, 4492, 7, 14),
-  TLS_ECDH_ECDSA_WITH_RC4_128_SHA("TLS_ECDH_ECDSA_WITH_RC4_128_SHA", 0xc002, 4492, 7, 14),
-  TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA("TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA", 0xc003, 4492, 7, 14),
-  TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA("TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA", 0xc004, 4492, 7, 14),
-  TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA("TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA", 0xc005, 4492, 7, 14),
-  TLS_ECDHE_ECDSA_WITH_NULL_SHA("TLS_ECDHE_ECDSA_WITH_NULL_SHA", 0xc006, 4492, 7, 14),
-  TLS_ECDHE_ECDSA_WITH_RC4_128_SHA("TLS_ECDHE_ECDSA_WITH_RC4_128_SHA", 0xc007, 4492, 7, 14),
-  TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA("TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA", 0xc008, 4492, 7, 14),
-  TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA("TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA", 0xc009, 4492, 7, 14),
-  TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA("TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA", 0xc00a, 4492, 7, 14),
-  TLS_ECDH_RSA_WITH_NULL_SHA("TLS_ECDH_RSA_WITH_NULL_SHA", 0xc00b, 4492, 7, 14),
-  TLS_ECDH_RSA_WITH_RC4_128_SHA("TLS_ECDH_RSA_WITH_RC4_128_SHA", 0xc00c, 4492, 7, 14),
-  TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA("TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA", 0xc00d, 4492, 7, 14),
-  TLS_ECDH_RSA_WITH_AES_128_CBC_SHA("TLS_ECDH_RSA_WITH_AES_128_CBC_SHA", 0xc00e, 4492, 7, 14),
-  TLS_ECDH_RSA_WITH_AES_256_CBC_SHA("TLS_ECDH_RSA_WITH_AES_256_CBC_SHA", 0xc00f, 4492, 7, 14),
-  TLS_ECDHE_RSA_WITH_NULL_SHA("TLS_ECDHE_RSA_WITH_NULL_SHA", 0xc010, 4492, 7, 14),
-  TLS_ECDHE_RSA_WITH_RC4_128_SHA("TLS_ECDHE_RSA_WITH_RC4_128_SHA", 0xc011, 4492, 7, 14),
-  TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA("TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA", 0xc012, 4492, 7, 14),
-  TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA("TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA", 0xc013, 4492, 7, 14),
-  TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA("TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA", 0xc014, 4492, 7, 14),
-  TLS_ECDH_anon_WITH_NULL_SHA("TLS_ECDH_anon_WITH_NULL_SHA", 0xc015, 4492, 7, 14),
-  TLS_ECDH_anon_WITH_RC4_128_SHA("TLS_ECDH_anon_WITH_RC4_128_SHA", 0xc016, 4492, 7, 14),
-  TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA("TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA", 0xc017, 4492, 7, 14),
-  TLS_ECDH_anon_WITH_AES_128_CBC_SHA("TLS_ECDH_anon_WITH_AES_128_CBC_SHA", 0xc018, 4492, 7, 14),
-  TLS_ECDH_anon_WITH_AES_256_CBC_SHA("TLS_ECDH_anon_WITH_AES_256_CBC_SHA", 0xc019, 4492, 7, 14),
-  // TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA("TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA", 0xc01a, 5054, MAX_VALUE, MAX_VALUE),
-  // TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA("TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA", 0xc01b, 5054, MAX_VALUE, MAX_VALUE),
-  // TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA("TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA", 0xc01c, 5054, MAX_VALUE, MAX_VALUE),
-  // TLS_SRP_SHA_WITH_AES_128_CBC_SHA("TLS_SRP_SHA_WITH_AES_128_CBC_SHA", 0xc01d, 5054, MAX_VALUE, MAX_VALUE),
-  // TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA("TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA", 0xc01e, 5054, MAX_VALUE, MAX_VALUE),
-  // TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA("TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA", 0xc01f, 5054, MAX_VALUE, MAX_VALUE),
-  // TLS_SRP_SHA_WITH_AES_256_CBC_SHA("TLS_SRP_SHA_WITH_AES_256_CBC_SHA", 0xc020, 5054, MAX_VALUE, MAX_VALUE),
-  // TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA("TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA", 0xc021, 5054, MAX_VALUE, MAX_VALUE),
-  // TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA("TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA", 0xc022, 5054, MAX_VALUE, MAX_VALUE),
-  TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256("TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256", 0xc023, 5289, 7, 21),
-  TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384("TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384", 0xc024, 5289, 7, 21),
-  TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256("TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256", 0xc025, 5289, 7, 21),
-  TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384("TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384", 0xc026, 5289, 7, 21),
-  TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256("TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256", 0xc027, 5289, 7, 21),
-  TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384("TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384", 0xc028, 5289, 7, 21),
-  TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256("TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256", 0xc029, 5289, 7, 21),
-  TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384("TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384", 0xc02a, 5289, 7, 21),
-  TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256("TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256", 0xc02b, 5289, 8, 21),
-  TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384("TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384", 0xc02c, 5289, 8, 21),
-  TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256("TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256", 0xc02d, 5289, 8, 21),
-  TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384("TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384", 0xc02e, 5289, 8, 21),
-  TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256("TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256", 0xc02f, 5289, 8, 21),
-  TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384("TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384", 0xc030, 5289, 8, 21),
-  TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256("TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256", 0xc031, 5289, 8, 21),
-  TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384("TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384", 0xc032, 5289, 8, 21),
-  // TLS_ECDHE_PSK_WITH_RC4_128_SHA("TLS_ECDHE_PSK_WITH_RC4_128_SHA", 0xc033, 5489, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA("TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA", 0xc034, 5489, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA("TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA", 0xc035, 5489, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA("TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA", 0xc036, 5489, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256("TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256", 0xc037, 5489, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384("TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384", 0xc038, 5489, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_PSK_WITH_NULL_SHA("TLS_ECDHE_PSK_WITH_NULL_SHA", 0xc039, 5489, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_PSK_WITH_NULL_SHA256("TLS_ECDHE_PSK_WITH_NULL_SHA256", 0xc03a, 5489, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_PSK_WITH_NULL_SHA384("TLS_ECDHE_PSK_WITH_NULL_SHA384", 0xc03b, 5489, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_WITH_ARIA_128_CBC_SHA256("TLS_RSA_WITH_ARIA_128_CBC_SHA256", 0xc03c, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_WITH_ARIA_256_CBC_SHA384("TLS_RSA_WITH_ARIA_256_CBC_SHA384", 0xc03d, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256("TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256", 0xc03e, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384("TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384", 0xc03f, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256("TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256", 0xc040, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384("TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384", 0xc041, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256("TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256", 0xc042, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384("TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384", 0xc043, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256("TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256", 0xc044, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384("TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384", 0xc045, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_anon_WITH_ARIA_128_CBC_SHA256("TLS_DH_anon_WITH_ARIA_128_CBC_SHA256", 0xc046, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_anon_WITH_ARIA_256_CBC_SHA384("TLS_DH_anon_WITH_ARIA_256_CBC_SHA384", 0xc047, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256("TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256", 0xc048, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384("TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384", 0xc049, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256("TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256", 0xc04a, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384("TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384", 0xc04b, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256("TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256", 0xc04c, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384("TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384", 0xc04d, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256("TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256", 0xc04e, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384("TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384", 0xc04f, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_WITH_ARIA_128_GCM_SHA256("TLS_RSA_WITH_ARIA_128_GCM_SHA256", 0xc050, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_WITH_ARIA_256_GCM_SHA384("TLS_RSA_WITH_ARIA_256_GCM_SHA384", 0xc051, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256("TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256", 0xc052, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384("TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384", 0xc053, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256("TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256", 0xc054, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384("TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384", 0xc055, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256("TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256", 0xc056, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384("TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384", 0xc057, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256("TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256", 0xc058, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384("TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384", 0xc059, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_anon_WITH_ARIA_128_GCM_SHA256("TLS_DH_anon_WITH_ARIA_128_GCM_SHA256", 0xc05a, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_anon_WITH_ARIA_256_GCM_SHA384("TLS_DH_anon_WITH_ARIA_256_GCM_SHA384", 0xc05b, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256("TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256", 0xc05c, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384("TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384", 0xc05d, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256("TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256", 0xc05e, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384("TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384", 0xc05f, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256("TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256", 0xc060, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384("TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384", 0xc061, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256("TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256", 0xc062, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384("TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384", 0xc063, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_WITH_ARIA_128_CBC_SHA256("TLS_PSK_WITH_ARIA_128_CBC_SHA256", 0xc064, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_WITH_ARIA_256_CBC_SHA384("TLS_PSK_WITH_ARIA_256_CBC_SHA384", 0xc065, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256("TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256", 0xc066, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384("TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384", 0xc067, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256("TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256", 0xc068, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384("TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384", 0xc069, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_WITH_ARIA_128_GCM_SHA256("TLS_PSK_WITH_ARIA_128_GCM_SHA256", 0xc06a, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_WITH_ARIA_256_GCM_SHA384("TLS_PSK_WITH_ARIA_256_GCM_SHA384", 0xc06b, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256("TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256", 0xc06c, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384("TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384", 0xc06d, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256("TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256", 0xc06e, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384("TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384", 0xc06f, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256("TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256", 0xc070, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384("TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384", 0xc071, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256("TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc072, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384("TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc073, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256("TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc074, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384("TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc075, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256("TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc076, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384("TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc077, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256("TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc078, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384("TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc079, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256("TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc07a, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384("TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc07b, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256("TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc07c, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384("TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc07d, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256("TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc07e, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384("TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc07f, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256("TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256", 0xc080, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384("TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384", 0xc081, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256("TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256", 0xc082, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384("TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384", 0xc083, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256("TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256", 0xc084, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384("TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384", 0xc085, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256("TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc086, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384("TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc087, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256("TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc088, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384("TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc089, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256("TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc08a, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384("TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc08b, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256("TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc08c, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384("TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc08d, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256("TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256", 0xc08e, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384("TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384", 0xc08f, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256("TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256", 0xc090, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384("TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384", 0xc091, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256("TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256", 0xc092, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384("TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384", 0xc093, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256("TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc094, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384("TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc095, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256("TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc096, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384("TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc097, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256("TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc098, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384("TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc099, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256("TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc09a, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384("TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc09b, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_WITH_AES_128_CCM("TLS_RSA_WITH_AES_128_CCM", 0xc09c, 6655, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_WITH_AES_256_CCM("TLS_RSA_WITH_AES_256_CCM", 0xc09d, 6655, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_RSA_WITH_AES_128_CCM("TLS_DHE_RSA_WITH_AES_128_CCM", 0xc09e, 6655, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_RSA_WITH_AES_256_CCM("TLS_DHE_RSA_WITH_AES_256_CCM", 0xc09f, 6655, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_WITH_AES_128_CCM_8("TLS_RSA_WITH_AES_128_CCM_8", 0xc0a0, 6655, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_WITH_AES_256_CCM_8("TLS_RSA_WITH_AES_256_CCM_8", 0xc0a1, 6655, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_RSA_WITH_AES_128_CCM_8("TLS_DHE_RSA_WITH_AES_128_CCM_8", 0xc0a2, 6655, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_RSA_WITH_AES_256_CCM_8("TLS_DHE_RSA_WITH_AES_256_CCM_8", 0xc0a3, 6655, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_WITH_AES_128_CCM("TLS_PSK_WITH_AES_128_CCM", 0xc0a4, 6655, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_WITH_AES_256_CCM("TLS_PSK_WITH_AES_256_CCM", 0xc0a5, 6655, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_PSK_WITH_AES_128_CCM("TLS_DHE_PSK_WITH_AES_128_CCM", 0xc0a6, 6655, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_PSK_WITH_AES_256_CCM("TLS_DHE_PSK_WITH_AES_256_CCM", 0xc0a7, 6655, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_WITH_AES_128_CCM_8("TLS_PSK_WITH_AES_128_CCM_8", 0xc0a8, 6655, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_WITH_AES_256_CCM_8("TLS_PSK_WITH_AES_256_CCM_8", 0xc0a9, 6655, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_DHE_WITH_AES_128_CCM_8("TLS_PSK_DHE_WITH_AES_128_CCM_8", 0xc0aa, 6655, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_DHE_WITH_AES_256_CCM_8("TLS_PSK_DHE_WITH_AES_256_CCM_8", 0xc0ab, 6655, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_ECDSA_WITH_AES_128_CCM("TLS_ECDHE_ECDSA_WITH_AES_128_CCM", 0xc0ac, 7251, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_ECDSA_WITH_AES_256_CCM("TLS_ECDHE_ECDSA_WITH_AES_256_CCM", 0xc0ad, 7251, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8("TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8", 0xc0ae, 7251, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8("TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8", 0xc0af, 7251, MAX_VALUE, MAX_VALUE),
-  ;
+  // Last updated 2016-07-03 using cipher suites from Android 24 and Java 9.
+
+  // public static final CipherSuite TLS_NULL_WITH_NULL_NULL = of("TLS_NULL_WITH_NULL_NULL", 0x0000);
+  public static final CipherSuite TLS_RSA_WITH_NULL_MD5 = of("SSL_RSA_WITH_NULL_MD5", 0x0001);
+  public static final CipherSuite TLS_RSA_WITH_NULL_SHA = of("SSL_RSA_WITH_NULL_SHA", 0x0002);
+  public static final CipherSuite TLS_RSA_EXPORT_WITH_RC4_40_MD5 = of("SSL_RSA_EXPORT_WITH_RC4_40_MD5", 0x0003);
+  public static final CipherSuite TLS_RSA_WITH_RC4_128_MD5 = of("SSL_RSA_WITH_RC4_128_MD5", 0x0004);
+  public static final CipherSuite TLS_RSA_WITH_RC4_128_SHA = of("SSL_RSA_WITH_RC4_128_SHA", 0x0005);
+  // public static final CipherSuite TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5 = of("SSL_RSA_EXPORT_WITH_RC2_CBC_40_MD5", 0x0006);
+  // public static final CipherSuite TLS_RSA_WITH_IDEA_CBC_SHA = of("TLS_RSA_WITH_IDEA_CBC_SHA", 0x0007);
+  public static final CipherSuite TLS_RSA_EXPORT_WITH_DES40_CBC_SHA = of("SSL_RSA_EXPORT_WITH_DES40_CBC_SHA", 0x0008);
+  public static final CipherSuite TLS_RSA_WITH_DES_CBC_SHA = of("SSL_RSA_WITH_DES_CBC_SHA", 0x0009);
+  public static final CipherSuite TLS_RSA_WITH_3DES_EDE_CBC_SHA = of("SSL_RSA_WITH_3DES_EDE_CBC_SHA", 0x000a);
+  // public static final CipherSuite TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA = of("SSL_DH_DSS_EXPORT_WITH_DES40_CBC_SHA", 0x000b);
+  // public static final CipherSuite TLS_DH_DSS_WITH_DES_CBC_SHA = of("TLS_DH_DSS_WITH_DES_CBC_SHA", 0x000c);
+  // public static final CipherSuite TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA = of("TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA", 0x000d);
+  // public static final CipherSuite TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA = of("SSL_DH_RSA_EXPORT_WITH_DES40_CBC_SHA", 0x000e);
+  // public static final CipherSuite TLS_DH_RSA_WITH_DES_CBC_SHA = of("TLS_DH_RSA_WITH_DES_CBC_SHA", 0x000f);
+  // public static final CipherSuite TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA = of("TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA", 0x0010);
+  public static final CipherSuite TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA = of("SSL_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA", 0x0011);
+  public static final CipherSuite TLS_DHE_DSS_WITH_DES_CBC_SHA = of("SSL_DHE_DSS_WITH_DES_CBC_SHA", 0x0012);
+  public static final CipherSuite TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA = of("SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA", 0x0013);
+  public static final CipherSuite TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA = of("SSL_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA", 0x0014);
+  public static final CipherSuite TLS_DHE_RSA_WITH_DES_CBC_SHA = of("SSL_DHE_RSA_WITH_DES_CBC_SHA", 0x0015);
+  public static final CipherSuite TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA = of("SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA", 0x0016);
+  public static final CipherSuite TLS_DH_anon_EXPORT_WITH_RC4_40_MD5 = of("SSL_DH_anon_EXPORT_WITH_RC4_40_MD5", 0x0017);
+  public static final CipherSuite TLS_DH_anon_WITH_RC4_128_MD5 = of("SSL_DH_anon_WITH_RC4_128_MD5", 0x0018);
+  public static final CipherSuite TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA = of("SSL_DH_anon_EXPORT_WITH_DES40_CBC_SHA", 0x0019);
+  public static final CipherSuite TLS_DH_anon_WITH_DES_CBC_SHA = of("SSL_DH_anon_WITH_DES_CBC_SHA", 0x001a);
+  public static final CipherSuite TLS_DH_anon_WITH_3DES_EDE_CBC_SHA = of("SSL_DH_anon_WITH_3DES_EDE_CBC_SHA", 0x001b);
+  public static final CipherSuite TLS_KRB5_WITH_DES_CBC_SHA = of("TLS_KRB5_WITH_DES_CBC_SHA", 0x001e);
+  public static final CipherSuite TLS_KRB5_WITH_3DES_EDE_CBC_SHA = of("TLS_KRB5_WITH_3DES_EDE_CBC_SHA", 0x001f);
+  public static final CipherSuite TLS_KRB5_WITH_RC4_128_SHA = of("TLS_KRB5_WITH_RC4_128_SHA", 0x0020);
+  // public static final CipherSuite TLS_KRB5_WITH_IDEA_CBC_SHA = of("TLS_KRB5_WITH_IDEA_CBC_SHA", 0x0021);
+  public static final CipherSuite TLS_KRB5_WITH_DES_CBC_MD5 = of("TLS_KRB5_WITH_DES_CBC_MD5", 0x0022);
+  public static final CipherSuite TLS_KRB5_WITH_3DES_EDE_CBC_MD5 = of("TLS_KRB5_WITH_3DES_EDE_CBC_MD5", 0x0023);
+  public static final CipherSuite TLS_KRB5_WITH_RC4_128_MD5 = of("TLS_KRB5_WITH_RC4_128_MD5", 0x0024);
+  // public static final CipherSuite TLS_KRB5_WITH_IDEA_CBC_MD5 = of("TLS_KRB5_WITH_IDEA_CBC_MD5", 0x0025);
+  public static final CipherSuite TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA = of("TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA", 0x0026);
+  // public static final CipherSuite TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA = of("TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA", 0x0027);
+  public static final CipherSuite TLS_KRB5_EXPORT_WITH_RC4_40_SHA = of("TLS_KRB5_EXPORT_WITH_RC4_40_SHA", 0x0028);
+  public static final CipherSuite TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5 = of("TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5", 0x0029);
+  // public static final CipherSuite TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5 = of("TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5", 0x002a);
+  public static final CipherSuite TLS_KRB5_EXPORT_WITH_RC4_40_MD5 = of("TLS_KRB5_EXPORT_WITH_RC4_40_MD5", 0x002b);
+  // public static final CipherSuite TLS_PSK_WITH_NULL_SHA = of("TLS_PSK_WITH_NULL_SHA", 0x002c);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_NULL_SHA = of("TLS_DHE_PSK_WITH_NULL_SHA", 0x002d);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_NULL_SHA = of("TLS_RSA_PSK_WITH_NULL_SHA", 0x002e);
+  public static final CipherSuite TLS_RSA_WITH_AES_128_CBC_SHA = of("TLS_RSA_WITH_AES_128_CBC_SHA", 0x002f);
+  // public static final CipherSuite TLS_DH_DSS_WITH_AES_128_CBC_SHA = of("TLS_DH_DSS_WITH_AES_128_CBC_SHA", 0x0030);
+  // public static final CipherSuite TLS_DH_RSA_WITH_AES_128_CBC_SHA = of("TLS_DH_RSA_WITH_AES_128_CBC_SHA", 0x0031);
+  public static final CipherSuite TLS_DHE_DSS_WITH_AES_128_CBC_SHA = of("TLS_DHE_DSS_WITH_AES_128_CBC_SHA", 0x0032);
+  public static final CipherSuite TLS_DHE_RSA_WITH_AES_128_CBC_SHA = of("TLS_DHE_RSA_WITH_AES_128_CBC_SHA", 0x0033);
+  public static final CipherSuite TLS_DH_anon_WITH_AES_128_CBC_SHA = of("TLS_DH_anon_WITH_AES_128_CBC_SHA", 0x0034);
+  public static final CipherSuite TLS_RSA_WITH_AES_256_CBC_SHA = of("TLS_RSA_WITH_AES_256_CBC_SHA", 0x0035);
+  // public static final CipherSuite TLS_DH_DSS_WITH_AES_256_CBC_SHA = of("TLS_DH_DSS_WITH_AES_256_CBC_SHA", 0x0036);
+  // public static final CipherSuite TLS_DH_RSA_WITH_AES_256_CBC_SHA = of("TLS_DH_RSA_WITH_AES_256_CBC_SHA", 0x0037);
+  public static final CipherSuite TLS_DHE_DSS_WITH_AES_256_CBC_SHA = of("TLS_DHE_DSS_WITH_AES_256_CBC_SHA", 0x0038);
+  public static final CipherSuite TLS_DHE_RSA_WITH_AES_256_CBC_SHA = of("TLS_DHE_RSA_WITH_AES_256_CBC_SHA", 0x0039);
+  public static final CipherSuite TLS_DH_anon_WITH_AES_256_CBC_SHA = of("TLS_DH_anon_WITH_AES_256_CBC_SHA", 0x003a);
+  public static final CipherSuite TLS_RSA_WITH_NULL_SHA256 = of("TLS_RSA_WITH_NULL_SHA256", 0x003b);
+  public static final CipherSuite TLS_RSA_WITH_AES_128_CBC_SHA256 = of("TLS_RSA_WITH_AES_128_CBC_SHA256", 0x003c);
+  public static final CipherSuite TLS_RSA_WITH_AES_256_CBC_SHA256 = of("TLS_RSA_WITH_AES_256_CBC_SHA256", 0x003d);
+  // public static final CipherSuite TLS_DH_DSS_WITH_AES_128_CBC_SHA256 = of("TLS_DH_DSS_WITH_AES_128_CBC_SHA256", 0x003e);
+  // public static final CipherSuite TLS_DH_RSA_WITH_AES_128_CBC_SHA256 = of("TLS_DH_RSA_WITH_AES_128_CBC_SHA256", 0x003f);
+  public static final CipherSuite TLS_DHE_DSS_WITH_AES_128_CBC_SHA256 = of("TLS_DHE_DSS_WITH_AES_128_CBC_SHA256", 0x0040);
+  public static final CipherSuite TLS_RSA_WITH_CAMELLIA_128_CBC_SHA = of("TLS_RSA_WITH_CAMELLIA_128_CBC_SHA", 0x0041);
+  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA = of("TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA", 0x0042);
+  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA = of("TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA", 0x0043);
+  public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA = of("TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA", 0x0044);
+  public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA = of("TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA", 0x0045);
+  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA = of("TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA", 0x0046);
+  public static final CipherSuite TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 = of("TLS_DHE_RSA_WITH_AES_128_CBC_SHA256", 0x0067);
+  // public static final CipherSuite TLS_DH_DSS_WITH_AES_256_CBC_SHA256 = of("TLS_DH_DSS_WITH_AES_256_CBC_SHA256", 0x0068);
+  // public static final CipherSuite TLS_DH_RSA_WITH_AES_256_CBC_SHA256 = of("TLS_DH_RSA_WITH_AES_256_CBC_SHA256", 0x0069);
+  public static final CipherSuite TLS_DHE_DSS_WITH_AES_256_CBC_SHA256 = of("TLS_DHE_DSS_WITH_AES_256_CBC_SHA256", 0x006a);
+  public static final CipherSuite TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 = of("TLS_DHE_RSA_WITH_AES_256_CBC_SHA256", 0x006b);
+  public static final CipherSuite TLS_DH_anon_WITH_AES_128_CBC_SHA256 = of("TLS_DH_anon_WITH_AES_128_CBC_SHA256", 0x006c);
+  public static final CipherSuite TLS_DH_anon_WITH_AES_256_CBC_SHA256 = of("TLS_DH_anon_WITH_AES_256_CBC_SHA256", 0x006d);
+  public static final CipherSuite TLS_RSA_WITH_CAMELLIA_256_CBC_SHA = of("TLS_RSA_WITH_CAMELLIA_256_CBC_SHA", 0x0084);
+  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA = of("TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA", 0x0085);
+  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA = of("TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA", 0x0086);
+  public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA = of("TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA", 0x0087);
+  public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA = of("TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA", 0x0088);
+  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA = of("TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA", 0x0089);
+  public static final CipherSuite TLS_PSK_WITH_RC4_128_SHA = of("TLS_PSK_WITH_RC4_128_SHA", 0x008a);
+  public static final CipherSuite TLS_PSK_WITH_3DES_EDE_CBC_SHA = of("TLS_PSK_WITH_3DES_EDE_CBC_SHA", 0x008b);
+  public static final CipherSuite TLS_PSK_WITH_AES_128_CBC_SHA = of("TLS_PSK_WITH_AES_128_CBC_SHA", 0x008c);
+  public static final CipherSuite TLS_PSK_WITH_AES_256_CBC_SHA = of("TLS_PSK_WITH_AES_256_CBC_SHA", 0x008d);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_RC4_128_SHA = of("TLS_DHE_PSK_WITH_RC4_128_SHA", 0x008e);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA = of("TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA", 0x008f);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_128_CBC_SHA = of("TLS_DHE_PSK_WITH_AES_128_CBC_SHA", 0x0090);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_256_CBC_SHA = of("TLS_DHE_PSK_WITH_AES_256_CBC_SHA", 0x0091);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_RC4_128_SHA = of("TLS_RSA_PSK_WITH_RC4_128_SHA", 0x0092);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA = of("TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA", 0x0093);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_128_CBC_SHA = of("TLS_RSA_PSK_WITH_AES_128_CBC_SHA", 0x0094);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_256_CBC_SHA = of("TLS_RSA_PSK_WITH_AES_256_CBC_SHA", 0x0095);
+  public static final CipherSuite TLS_RSA_WITH_SEED_CBC_SHA = of("TLS_RSA_WITH_SEED_CBC_SHA", 0x0096);
+  // public static final CipherSuite TLS_DH_DSS_WITH_SEED_CBC_SHA = of("TLS_DH_DSS_WITH_SEED_CBC_SHA", 0x0097);
+  // public static final CipherSuite TLS_DH_RSA_WITH_SEED_CBC_SHA = of("TLS_DH_RSA_WITH_SEED_CBC_SHA", 0x0098);
+  // public static final CipherSuite TLS_DHE_DSS_WITH_SEED_CBC_SHA = of("TLS_DHE_DSS_WITH_SEED_CBC_SHA", 0x0099);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_SEED_CBC_SHA = of("TLS_DHE_RSA_WITH_SEED_CBC_SHA", 0x009a);
+  // public static final CipherSuite TLS_DH_anon_WITH_SEED_CBC_SHA = of("TLS_DH_anon_WITH_SEED_CBC_SHA", 0x009b);
+  public static final CipherSuite TLS_RSA_WITH_AES_128_GCM_SHA256 = of("TLS_RSA_WITH_AES_128_GCM_SHA256", 0x009c);
+  public static final CipherSuite TLS_RSA_WITH_AES_256_GCM_SHA384 = of("TLS_RSA_WITH_AES_256_GCM_SHA384", 0x009d);
+  public static final CipherSuite TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 = of("TLS_DHE_RSA_WITH_AES_128_GCM_SHA256", 0x009e);
+  public static final CipherSuite TLS_DHE_RSA_WITH_AES_256_GCM_SHA384 = of("TLS_DHE_RSA_WITH_AES_256_GCM_SHA384", 0x009f);
+  // public static final CipherSuite TLS_DH_RSA_WITH_AES_128_GCM_SHA256 = of("TLS_DH_RSA_WITH_AES_128_GCM_SHA256", 0x00a0);
+  // public static final CipherSuite TLS_DH_RSA_WITH_AES_256_GCM_SHA384 = of("TLS_DH_RSA_WITH_AES_256_GCM_SHA384", 0x00a1);
+  public static final CipherSuite TLS_DHE_DSS_WITH_AES_128_GCM_SHA256 = of("TLS_DHE_DSS_WITH_AES_128_GCM_SHA256", 0x00a2);
+  public static final CipherSuite TLS_DHE_DSS_WITH_AES_256_GCM_SHA384 = of("TLS_DHE_DSS_WITH_AES_256_GCM_SHA384", 0x00a3);
+  // public static final CipherSuite TLS_DH_DSS_WITH_AES_128_GCM_SHA256 = of("TLS_DH_DSS_WITH_AES_128_GCM_SHA256", 0x00a4);
+  // public static final CipherSuite TLS_DH_DSS_WITH_AES_256_GCM_SHA384 = of("TLS_DH_DSS_WITH_AES_256_GCM_SHA384", 0x00a5);
+  public static final CipherSuite TLS_DH_anon_WITH_AES_128_GCM_SHA256 = of("TLS_DH_anon_WITH_AES_128_GCM_SHA256", 0x00a6);
+  public static final CipherSuite TLS_DH_anon_WITH_AES_256_GCM_SHA384 = of("TLS_DH_anon_WITH_AES_256_GCM_SHA384", 0x00a7);
+  // public static final CipherSuite TLS_PSK_WITH_AES_128_GCM_SHA256 = of("TLS_PSK_WITH_AES_128_GCM_SHA256", 0x00a8);
+  // public static final CipherSuite TLS_PSK_WITH_AES_256_GCM_SHA384 = of("TLS_PSK_WITH_AES_256_GCM_SHA384", 0x00a9);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_128_GCM_SHA256 = of("TLS_DHE_PSK_WITH_AES_128_GCM_SHA256", 0x00aa);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_256_GCM_SHA384 = of("TLS_DHE_PSK_WITH_AES_256_GCM_SHA384", 0x00ab);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_128_GCM_SHA256 = of("TLS_RSA_PSK_WITH_AES_128_GCM_SHA256", 0x00ac);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_256_GCM_SHA384 = of("TLS_RSA_PSK_WITH_AES_256_GCM_SHA384", 0x00ad);
+  // public static final CipherSuite TLS_PSK_WITH_AES_128_CBC_SHA256 = of("TLS_PSK_WITH_AES_128_CBC_SHA256", 0x00ae);
+  // public static final CipherSuite TLS_PSK_WITH_AES_256_CBC_SHA384 = of("TLS_PSK_WITH_AES_256_CBC_SHA384", 0x00af);
+  // public static final CipherSuite TLS_PSK_WITH_NULL_SHA256 = of("TLS_PSK_WITH_NULL_SHA256", 0x00b0);
+  // public static final CipherSuite TLS_PSK_WITH_NULL_SHA384 = of("TLS_PSK_WITH_NULL_SHA384", 0x00b1);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_128_CBC_SHA256 = of("TLS_DHE_PSK_WITH_AES_128_CBC_SHA256", 0x00b2);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_256_CBC_SHA384 = of("TLS_DHE_PSK_WITH_AES_256_CBC_SHA384", 0x00b3);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_NULL_SHA256 = of("TLS_DHE_PSK_WITH_NULL_SHA256", 0x00b4);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_NULL_SHA384 = of("TLS_DHE_PSK_WITH_NULL_SHA384", 0x00b5);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_128_CBC_SHA256 = of("TLS_RSA_PSK_WITH_AES_128_CBC_SHA256", 0x00b6);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_256_CBC_SHA384 = of("TLS_RSA_PSK_WITH_AES_256_CBC_SHA384", 0x00b7);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_NULL_SHA256 = of("TLS_RSA_PSK_WITH_NULL_SHA256", 0x00b8);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_NULL_SHA384 = of("TLS_RSA_PSK_WITH_NULL_SHA384", 0x00b9);
+  // public static final CipherSuite TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0x00ba);
+  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256", 0x00bb);
+  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0x00bc);
+  // public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256", 0x00bd);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0x00be);
+  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256", 0x00bf);
+  // public static final CipherSuite TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256 = of("TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256", 0x00c0);
+  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256 = of("TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256", 0x00c1);
+  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256 = of("TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256", 0x00c2);
+  // public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256 = of("TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256", 0x00c3);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256 = of("TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256", 0x00c4);
+  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256 = of("TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256", 0x00c5);
+  public static final CipherSuite TLS_EMPTY_RENEGOTIATION_INFO_SCSV = of("TLS_EMPTY_RENEGOTIATION_INFO_SCSV", 0x00ff);
+  public static final CipherSuite TLS_FALLBACK_SCSV = of("TLS_FALLBACK_SCSV", 0x5600);
+  public static final CipherSuite TLS_ECDH_ECDSA_WITH_NULL_SHA = of("TLS_ECDH_ECDSA_WITH_NULL_SHA", 0xc001);
+  public static final CipherSuite TLS_ECDH_ECDSA_WITH_RC4_128_SHA = of("TLS_ECDH_ECDSA_WITH_RC4_128_SHA", 0xc002);
+  public static final CipherSuite TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA = of("TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA", 0xc003);
+  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA = of("TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA", 0xc004);
+  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA = of("TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA", 0xc005);
+  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_NULL_SHA = of("TLS_ECDHE_ECDSA_WITH_NULL_SHA", 0xc006);
+  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_RC4_128_SHA = of("TLS_ECDHE_ECDSA_WITH_RC4_128_SHA", 0xc007);
+  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA = of("TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA", 0xc008);
+  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA = of("TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA", 0xc009);
+  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA = of("TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA", 0xc00a);
+  public static final CipherSuite TLS_ECDH_RSA_WITH_NULL_SHA = of("TLS_ECDH_RSA_WITH_NULL_SHA", 0xc00b);
+  public static final CipherSuite TLS_ECDH_RSA_WITH_RC4_128_SHA = of("TLS_ECDH_RSA_WITH_RC4_128_SHA", 0xc00c);
+  public static final CipherSuite TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA = of("TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA", 0xc00d);
+  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_128_CBC_SHA = of("TLS_ECDH_RSA_WITH_AES_128_CBC_SHA", 0xc00e);
+  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_256_CBC_SHA = of("TLS_ECDH_RSA_WITH_AES_256_CBC_SHA", 0xc00f);
+  public static final CipherSuite TLS_ECDHE_RSA_WITH_NULL_SHA = of("TLS_ECDHE_RSA_WITH_NULL_SHA", 0xc010);
+  public static final CipherSuite TLS_ECDHE_RSA_WITH_RC4_128_SHA = of("TLS_ECDHE_RSA_WITH_RC4_128_SHA", 0xc011);
+  public static final CipherSuite TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA = of("TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA", 0xc012);
+  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA = of("TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA", 0xc013);
+  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA = of("TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA", 0xc014);
+  public static final CipherSuite TLS_ECDH_anon_WITH_NULL_SHA = of("TLS_ECDH_anon_WITH_NULL_SHA", 0xc015);
+  public static final CipherSuite TLS_ECDH_anon_WITH_RC4_128_SHA = of("TLS_ECDH_anon_WITH_RC4_128_SHA", 0xc016);
+  public static final CipherSuite TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA = of("TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA", 0xc017);
+  public static final CipherSuite TLS_ECDH_anon_WITH_AES_128_CBC_SHA = of("TLS_ECDH_anon_WITH_AES_128_CBC_SHA", 0xc018);
+  public static final CipherSuite TLS_ECDH_anon_WITH_AES_256_CBC_SHA = of("TLS_ECDH_anon_WITH_AES_256_CBC_SHA", 0xc019);
+  // public static final CipherSuite TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA = of("TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA", 0xc01a);
+  // public static final CipherSuite TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA = of("TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA", 0xc01b);
+  // public static final CipherSuite TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA = of("TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA", 0xc01c);
+  // public static final CipherSuite TLS_SRP_SHA_WITH_AES_128_CBC_SHA = of("TLS_SRP_SHA_WITH_AES_128_CBC_SHA", 0xc01d);
+  // public static final CipherSuite TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA = of("TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA", 0xc01e);
+  // public static final CipherSuite TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA = of("TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA", 0xc01f);
+  // public static final CipherSuite TLS_SRP_SHA_WITH_AES_256_CBC_SHA = of("TLS_SRP_SHA_WITH_AES_256_CBC_SHA", 0xc020);
+  // public static final CipherSuite TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA = of("TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA", 0xc021);
+  // public static final CipherSuite TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA = of("TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA", 0xc022);
+  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 = of("TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256", 0xc023);
+  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 = of("TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384", 0xc024);
+  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256 = of("TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256", 0xc025);
+  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384 = of("TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384", 0xc026);
+  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 = of("TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256", 0xc027);
+  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 = of("TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384", 0xc028);
+  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256 = of("TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256", 0xc029);
+  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384 = of("TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384", 0xc02a);
+  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 = of("TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256", 0xc02b);
+  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 = of("TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384", 0xc02c);
+  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256 = of("TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256", 0xc02d);
+  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384 = of("TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384", 0xc02e);
+  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 = of("TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256", 0xc02f);
+  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 = of("TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384", 0xc030);
+  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256 = of("TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256", 0xc031);
+  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384 = of("TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384", 0xc032);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_RC4_128_SHA = of("TLS_ECDHE_PSK_WITH_RC4_128_SHA", 0xc033);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA = of("TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA", 0xc034);
+  public static final CipherSuite TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA = of("TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA", 0xc035);
+  public static final CipherSuite TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA = of("TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA", 0xc036);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256 = of("TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256", 0xc037);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384 = of("TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384", 0xc038);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_NULL_SHA = of("TLS_ECDHE_PSK_WITH_NULL_SHA", 0xc039);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_NULL_SHA256 = of("TLS_ECDHE_PSK_WITH_NULL_SHA256", 0xc03a);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_NULL_SHA384 = of("TLS_ECDHE_PSK_WITH_NULL_SHA384", 0xc03b);
+  // public static final CipherSuite TLS_RSA_WITH_ARIA_128_CBC_SHA256 = of("TLS_RSA_WITH_ARIA_128_CBC_SHA256", 0xc03c);
+  // public static final CipherSuite TLS_RSA_WITH_ARIA_256_CBC_SHA384 = of("TLS_RSA_WITH_ARIA_256_CBC_SHA384", 0xc03d);
+  // public static final CipherSuite TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256 = of("TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256", 0xc03e);
+  // public static final CipherSuite TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384 = of("TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384", 0xc03f);
+  // public static final CipherSuite TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256 = of("TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256", 0xc040);
+  // public static final CipherSuite TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384 = of("TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384", 0xc041);
+  // public static final CipherSuite TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256 = of("TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256", 0xc042);
+  // public static final CipherSuite TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384 = of("TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384", 0xc043);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256 = of("TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256", 0xc044);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384 = of("TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384", 0xc045);
+  // public static final CipherSuite TLS_DH_anon_WITH_ARIA_128_CBC_SHA256 = of("TLS_DH_anon_WITH_ARIA_128_CBC_SHA256", 0xc046);
+  // public static final CipherSuite TLS_DH_anon_WITH_ARIA_256_CBC_SHA384 = of("TLS_DH_anon_WITH_ARIA_256_CBC_SHA384", 0xc047);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256 = of("TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256", 0xc048);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384 = of("TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384", 0xc049);
+  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256 = of("TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256", 0xc04a);
+  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384 = of("TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384", 0xc04b);
+  // public static final CipherSuite TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256 = of("TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256", 0xc04c);
+  // public static final CipherSuite TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384 = of("TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384", 0xc04d);
+  // public static final CipherSuite TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256 = of("TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256", 0xc04e);
+  // public static final CipherSuite TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384 = of("TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384", 0xc04f);
+  // public static final CipherSuite TLS_RSA_WITH_ARIA_128_GCM_SHA256 = of("TLS_RSA_WITH_ARIA_128_GCM_SHA256", 0xc050);
+  // public static final CipherSuite TLS_RSA_WITH_ARIA_256_GCM_SHA384 = of("TLS_RSA_WITH_ARIA_256_GCM_SHA384", 0xc051);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256 = of("TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256", 0xc052);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384 = of("TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384", 0xc053);
+  // public static final CipherSuite TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256 = of("TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256", 0xc054);
+  // public static final CipherSuite TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384 = of("TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384", 0xc055);
+  // public static final CipherSuite TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256 = of("TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256", 0xc056);
+  // public static final CipherSuite TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384 = of("TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384", 0xc057);
+  // public static final CipherSuite TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256 = of("TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256", 0xc058);
+  // public static final CipherSuite TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384 = of("TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384", 0xc059);
+  // public static final CipherSuite TLS_DH_anon_WITH_ARIA_128_GCM_SHA256 = of("TLS_DH_anon_WITH_ARIA_128_GCM_SHA256", 0xc05a);
+  // public static final CipherSuite TLS_DH_anon_WITH_ARIA_256_GCM_SHA384 = of("TLS_DH_anon_WITH_ARIA_256_GCM_SHA384", 0xc05b);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256 = of("TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256", 0xc05c);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384 = of("TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384", 0xc05d);
+  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256 = of("TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256", 0xc05e);
+  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384 = of("TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384", 0xc05f);
+  // public static final CipherSuite TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256 = of("TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256", 0xc060);
+  // public static final CipherSuite TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384 = of("TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384", 0xc061);
+  // public static final CipherSuite TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256 = of("TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256", 0xc062);
+  // public static final CipherSuite TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384 = of("TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384", 0xc063);
+  // public static final CipherSuite TLS_PSK_WITH_ARIA_128_CBC_SHA256 = of("TLS_PSK_WITH_ARIA_128_CBC_SHA256", 0xc064);
+  // public static final CipherSuite TLS_PSK_WITH_ARIA_256_CBC_SHA384 = of("TLS_PSK_WITH_ARIA_256_CBC_SHA384", 0xc065);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256 = of("TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256", 0xc066);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384 = of("TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384", 0xc067);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256 = of("TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256", 0xc068);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384 = of("TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384", 0xc069);
+  // public static final CipherSuite TLS_PSK_WITH_ARIA_128_GCM_SHA256 = of("TLS_PSK_WITH_ARIA_128_GCM_SHA256", 0xc06a);
+  // public static final CipherSuite TLS_PSK_WITH_ARIA_256_GCM_SHA384 = of("TLS_PSK_WITH_ARIA_256_GCM_SHA384", 0xc06b);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256 = of("TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256", 0xc06c);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384 = of("TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384", 0xc06d);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256 = of("TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256", 0xc06e);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384 = of("TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384", 0xc06f);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256 = of("TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256", 0xc070);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384 = of("TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384", 0xc071);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc072);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 = of("TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc073);
+  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc074);
+  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 = of("TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc075);
+  // public static final CipherSuite TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc076);
+  // public static final CipherSuite TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384 = of("TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc077);
+  // public static final CipherSuite TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc078);
+  // public static final CipherSuite TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384 = of("TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc079);
+  // public static final CipherSuite TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc07a);
+  // public static final CipherSuite TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc07b);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc07c);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc07d);
+  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc07e);
+  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc07f);
+  // public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256", 0xc080);
+  // public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384", 0xc081);
+  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256", 0xc082);
+  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384", 0xc083);
+  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256", 0xc084);
+  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384", 0xc085);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc086);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc087);
+  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc088);
+  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc089);
+  // public static final CipherSuite TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc08a);
+  // public static final CipherSuite TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc08b);
+  // public static final CipherSuite TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc08c);
+  // public static final CipherSuite TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc08d);
+  // public static final CipherSuite TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256", 0xc08e);
+  // public static final CipherSuite TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384", 0xc08f);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256", 0xc090);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384", 0xc091);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256", 0xc092);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384", 0xc093);
+  // public static final CipherSuite TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc094);
+  // public static final CipherSuite TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384 = of("TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc095);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc096);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 = of("TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc097);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc098);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384 = of("TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc099);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc09a);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 = of("TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc09b);
+  // public static final CipherSuite TLS_RSA_WITH_AES_128_CCM = of("TLS_RSA_WITH_AES_128_CCM", 0xc09c);
+  // public static final CipherSuite TLS_RSA_WITH_AES_256_CCM = of("TLS_RSA_WITH_AES_256_CCM", 0xc09d);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_AES_128_CCM = of("TLS_DHE_RSA_WITH_AES_128_CCM", 0xc09e);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_AES_256_CCM = of("TLS_DHE_RSA_WITH_AES_256_CCM", 0xc09f);
+  // public static final CipherSuite TLS_RSA_WITH_AES_128_CCM_8 = of("TLS_RSA_WITH_AES_128_CCM_8", 0xc0a0);
+  // public static final CipherSuite TLS_RSA_WITH_AES_256_CCM_8 = of("TLS_RSA_WITH_AES_256_CCM_8", 0xc0a1);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_AES_128_CCM_8 = of("TLS_DHE_RSA_WITH_AES_128_CCM_8", 0xc0a2);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_AES_256_CCM_8 = of("TLS_DHE_RSA_WITH_AES_256_CCM_8", 0xc0a3);
+  // public static final CipherSuite TLS_PSK_WITH_AES_128_CCM = of("TLS_PSK_WITH_AES_128_CCM", 0xc0a4);
+  // public static final CipherSuite TLS_PSK_WITH_AES_256_CCM = of("TLS_PSK_WITH_AES_256_CCM", 0xc0a5);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_128_CCM = of("TLS_DHE_PSK_WITH_AES_128_CCM", 0xc0a6);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_256_CCM = of("TLS_DHE_PSK_WITH_AES_256_CCM", 0xc0a7);
+  // public static final CipherSuite TLS_PSK_WITH_AES_128_CCM_8 = of("TLS_PSK_WITH_AES_128_CCM_8", 0xc0a8);
+  // public static final CipherSuite TLS_PSK_WITH_AES_256_CCM_8 = of("TLS_PSK_WITH_AES_256_CCM_8", 0xc0a9);
+  // public static final CipherSuite TLS_PSK_DHE_WITH_AES_128_CCM_8 = of("TLS_PSK_DHE_WITH_AES_128_CCM_8", 0xc0aa);
+  // public static final CipherSuite TLS_PSK_DHE_WITH_AES_256_CCM_8 = of("TLS_PSK_DHE_WITH_AES_256_CCM_8", 0xc0ab);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CCM = of("TLS_ECDHE_ECDSA_WITH_AES_128_CCM", 0xc0ac);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CCM = of("TLS_ECDHE_ECDSA_WITH_AES_256_CCM", 0xc0ad);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8 = of("TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8", 0xc0ae);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8 = of("TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8", 0xc0af);
+  public static final CipherSuite TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 = of("TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256", 0xcca8);
+  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 = of("TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256", 0xcca9);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256 = of("TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256", 0xccaa);
+  // public static final CipherSuite TLS_PSK_WITH_CHACHA20_POLY1305_SHA256 = of("TLS_PSK_WITH_CHACHA20_POLY1305_SHA256", 0xccab);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256 = of("TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256", 0xccac);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256 = of("TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256", 0xccad);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256 = of("TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256", 0xccae);
 
   final String javaName;
 
   /**
    * @param javaName the name used by Java APIs for this cipher suite. Different than the IANA name
-   * for older cipher suites because the prefix is {@code SSL_} instead of {@code TLS_}.
-   * @param value the integer identifier for this cipher suite. (Documentation only.)
-   * @param rfc the RFC describing this cipher suite. (Documentation only.)
-   * @param sinceJavaVersion the first major Java release supporting this cipher suite.
-   * @param sinceAndroidVersion the first Android SDK version supporting this cipher suite.
+   *     for older cipher suites because the prefix is {@code SSL_} instead of {@code TLS_}.
    */
-  private CipherSuite(
-      String javaName, int value, int rfc, int sinceJavaVersion, int sinceAndroidVersion) {
+  public static synchronized CipherSuite forJavaName(String javaName) {
+    CipherSuite result = INSTANCES.get(javaName);
+    if (result == null) {
+      result = new CipherSuite(javaName);
+      INSTANCES.put(javaName, result);
+    }
+    return result;
+  }
+
+  static List<CipherSuite> forJavaNames(String... cipherSuites) {
+    List<CipherSuite> result = new ArrayList<>(cipherSuites.length);
+    for (String cipherSuite : cipherSuites) {
+      result.add(forJavaName(cipherSuite));
+    }
+    return Collections.unmodifiableList(result);
+  }
+
+  private CipherSuite(String javaName) {
+    if (javaName == null) {
+      throw new NullPointerException();
+    }
     this.javaName = javaName;
   }
 
+  /**
+   * @param javaName the name used by Java APIs for this cipher suite. Different than the IANA name
+   *     for older cipher suites because the prefix is {@code SSL_} instead of {@code TLS_}.
+   * @param value the integer identifier for this cipher suite. (Documentation only.)
+   */
+  private static CipherSuite of(String javaName, int value) {
+    return forJavaName(javaName);
+  }
+
   /**
    * Returns the Java name of this cipher suite. For some older cipher suites the Java name has the
-   * prefix {@code SSL_}, causing the Java name to be different from the {@linkplain #name() enum
-   * name} which is always prefixed {@code TLS_}.
+   * prefix {@code SSL_}, causing the Java name to be different from the instance name which is
+   * always prefixed {@code TLS_}. For example, {@code TLS_RSA_EXPORT_WITH_RC4_40_MD5.javaName()}
+   * is {@code "SSL_RSA_EXPORT_WITH_RC4_40_MD5"}.
    */
   public String javaName() {
     return javaName;
   }
 
-  public static CipherSuite forJavaName(String javaName) {
-    return javaName.startsWith("SSL_")
-        ? valueOf("TLS_" + javaName.substring(4))
-        : valueOf(javaName);
+  @Override public String toString() {
+    return javaName;
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/Connection.java b/okhttp/src/main/java/okhttp3/Connection.java
index de3c22d98b..cb6d70996d 100644
--- a/okhttp/src/main/java/okhttp3/Connection.java
+++ b/okhttp/src/main/java/okhttp3/Connection.java
@@ -17,9 +17,10 @@
 package okhttp3;
 
 import java.net.Socket;
+import javax.annotation.Nullable;
 
 /**
- * The sockets and streams of an HTTP, HTTPS, or HTTPS+SPDY connection. May be used for multiple
+ * The sockets and streams of an HTTP, HTTPS, or HTTPS+HTTP/2 connection. May be used for multiple
  * HTTP request/response exchanges. Connections may be direct to the origin server or via a proxy.
  *
  * <p>Typically instances of this class are created, connected and exercised automatically by the
@@ -37,8 +38,8 @@
  * <ul>
  *     <li>Server Name Indication (SNI) enables one IP address to negotiate secure connections for
  *         multiple domain names.
- *     <li>Application Layer Protocol Negotiation (ALPN) enables the HTTPS port (443) to be used for
- *         different HTTP and SPDY protocols.
+ *     <li>Application Layer Protocol Negotiation (ALPN) enables the HTTPS port (443) to be used to
+ *         negotiate HTTP/2.
  * </ul>
  *
  * <p>Unfortunately, older HTTPS servers refuse to connect when such options are presented. Rather
@@ -47,11 +48,11 @@
  *
  * <h3>Connection Reuse</h3>
  *
- * <p>Each connection can carry a varying number streams, depending on the underlying protocol being
- * used. HTTP/1.x connections can carry either zero or one streams. HTTP/2 connections can carry any
- * number of streams, dynamically configured with {@code SETTINGS_MAX_CONCURRENT_STREAMS}. A
- * connection currently carrying zero streams is an idle stream. We keep it alive because reusing an
- * existing connection is typically faster than establishing a new one.
+ * <p>Each connection can carry a varying number of streams, depending on the underlying protocol
+ * being used. HTTP/1.x connections can carry either zero or one streams. HTTP/2 connections can
+ * carry any number of streams, dynamically configured with {@code SETTINGS_MAX_CONCURRENT_STREAMS}.
+ * A connection currently carrying zero streams is an idle stream. We keep it alive because reusing
+ * an existing connection is typically faster than establishing a new one.
  *
  * <p>When a single logical call requires multiple streams due to redirects or authorization
  * challenges, we prefer to use the same physical connection for all streams in the sequence. There
@@ -73,7 +74,7 @@
 
   /**
    * Returns the socket that this connection is using. Returns an {@linkplain
-   * javax.net.ssl.SSLSocket SSL socket} if this connection is HTTPS. If this is an HTTP/2 or SPDY
+   * javax.net.ssl.SSLSocket SSL socket} if this connection is HTTPS. If this is an HTTP/2
    * connection the socket may be shared by multiple concurrent calls.
    */
   Socket socket();
@@ -82,7 +83,7 @@
    * Returns the TLS handshake used to establish this connection, or null if the connection is not
    * HTTPS.
    */
-  Handshake handshake();
+  @Nullable Handshake handshake();
 
   /**
    * Returns the protocol negotiated by this connection, or {@link Protocol#HTTP_1_1} if no protocol
diff --git a/okhttp/src/main/java/okhttp3/ConnectionPool.java b/okhttp/src/main/java/okhttp3/ConnectionPool.java
index d6391c3f83..605f275661 100644
--- a/okhttp/src/main/java/okhttp3/ConnectionPool.java
+++ b/okhttp/src/main/java/okhttp3/ConnectionPool.java
@@ -17,6 +17,7 @@
 package okhttp3;
 
 import java.lang.ref.Reference;
+import java.net.Socket;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Deque;
@@ -26,19 +27,19 @@
 import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
-import okhttp3.internal.Platform;
-import okhttp3.internal.RouteDatabase;
+import javax.annotation.Nullable;
 import okhttp3.internal.Util;
-import okhttp3.internal.http.StreamAllocation;
-import okhttp3.internal.io.RealConnection;
+import okhttp3.internal.connection.RealConnection;
+import okhttp3.internal.connection.RouteDatabase;
+import okhttp3.internal.connection.StreamAllocation;
+import okhttp3.internal.platform.Platform;
 
-import static okhttp3.internal.Platform.WARN;
 import static okhttp3.internal.Util.closeQuietly;
 
 /**
- * Manages reuse of HTTP and SPDY connections for reduced network latency. HTTP requests that share
- * the same {@link Address} may share a {@link Connection}. This class implements the policy of
- * which connections to keep open for future use.
+ * Manages reuse of HTTP and HTTP/2 connections for reduced network latency. HTTP requests that
+ * share the same {@link Address} may share a {@link Connection}. This class implements the policy
+ * of which connections to keep open for future use.
  */
 public final class ConnectionPool {
   /**
@@ -106,7 +107,7 @@ public synchronized int idleConnectionCount() {
 
   /**
    * Returns total number of connections in the pool. Note that prior to OkHttp 2.7 this included
-   * only idle connections and SPDY connections. Since OkHttp 2.7 this includes all connections,
+   * only idle connections and HTTP/2 connections. Since OkHttp 2.7 this includes all connections,
    * both active and inactive. Use {@link #idleConnectionCount()} to count connections not currently
    * in use.
    */
@@ -114,20 +115,37 @@ public synchronized int connectionCount() {
     return connections.size();
   }
 
-  /** Returns a recycled connection to {@code address}, or null if no such connection exists. */
-  RealConnection get(Address address, StreamAllocation streamAllocation) {
+  /**
+   * Returns a recycled connection to {@code address}, or null if no such connection exists. The
+   * route is null if the address has not yet been routed.
+   */
+  @Nullable RealConnection get(Address address, StreamAllocation streamAllocation, Route route) {
     assert (Thread.holdsLock(this));
     for (RealConnection connection : connections) {
-      if (connection.allocations.size() < connection.allocationLimit
-          && address.equals(connection.route().address)
-          && !connection.noNewStreams) {
-        streamAllocation.acquire(connection);
+      if (connection.isEligible(address, route)) {
+        streamAllocation.acquire(connection, true);
         return connection;
       }
     }
     return null;
   }
 
+  /**
+   * Replaces the connection held by {@code streamAllocation} with a shared connection if possible.
+   * This recovers when multiple multiplexed connections are created concurrently.
+   */
+  @Nullable Socket deduplicate(Address address, StreamAllocation streamAllocation) {
+    assert (Thread.holdsLock(this));
+    for (RealConnection connection : connections) {
+      if (connection.isEligible(address, null)
+          && connection.isMultiplexed()
+          && connection != streamAllocation.connection()) {
+        return streamAllocation.releaseAndAcquire(connection);
+      }
+    }
+    return null;
+  }
+
   void put(RealConnection connection) {
     assert (Thread.holdsLock(this));
     if (!cleanupRunning) {
@@ -246,8 +264,12 @@ private int pruneAndGetAllocationCount(RealConnection connection, long now) {
       }
 
       // We've discovered a leaked allocation. This is an application bug.
-      Platform.get().log(WARN, "A connection to " + connection.route().address().url()
-          + " was leaked. Did you forget to close a response body?", null);
+      StreamAllocation.StreamAllocationReference streamAllocRef =
+          (StreamAllocation.StreamAllocationReference) reference;
+      String message = "A connection to " + connection.route().address().url()
+          + " was leaked. Did you forget to close a response body?";
+      Platform.get().logCloseableLeak(message, streamAllocRef.callStackTrace);
+
       references.remove(i);
       connection.noNewStreams = true;
 
diff --git a/okhttp/src/main/java/okhttp3/ConnectionSpec.java b/okhttp/src/main/java/okhttp3/ConnectionSpec.java
index 8c99932f9e..25b9ee328b 100644
--- a/okhttp/src/main/java/okhttp3/ConnectionSpec.java
+++ b/okhttp/src/main/java/okhttp3/ConnectionSpec.java
@@ -17,12 +17,14 @@
 
 import java.util.Arrays;
 import java.util.List;
+import javax.annotation.Nullable;
 import javax.net.ssl.SSLSocket;
+import okhttp3.internal.Util;
 
 import static okhttp3.internal.Util.concat;
-import static okhttp3.internal.Util.contains;
-import static okhttp3.internal.Util.immutableList;
+import static okhttp3.internal.Util.indexOf;
 import static okhttp3.internal.Util.intersect;
+import static okhttp3.internal.Util.nonEmptyIntersection;
 
 /**
  * Specifies configuration for the socket connection that HTTP traffic travels through. For {@code
@@ -30,7 +32,7 @@
  * connection.
  *
  * <p>The TLS versions configured in a connection spec are only be used if they are also enabled in
- * the SSL socket. For example, if an SSL socket does not have TLS 1.2 enabled, it will not be used
+ * the SSL socket. For example, if an SSL socket does not have TLS 1.3 enabled, it will not be used
  * even if it is present on the connection spec. The same policy also applies to cipher suites.
  *
  * <p>Use {@link Builder#allEnabledTlsVersions()} and {@link Builder#allEnabledCipherSuites} to
@@ -38,24 +40,26 @@
  */
 public final class ConnectionSpec {
 
-  // This is a subset of the cipher suites supported in Chrome 46, current as of 2015-11-05.
-  // All of these suites are available on Android 5.0; earlier releases support a subset of
-  // these suites. https://github.com/square/okhttp/issues/330
+  // This is nearly equal to the cipher suites supported in Chrome 51, current as of 2016-05-25.
+  // All of these suites are available on Android 7.0; earlier releases support a subset of these
+  // suites. https://github.com/square/okhttp/issues/1972
   private static final CipherSuite[] APPROVED_CIPHER_SUITES = new CipherSuite[] {
       CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
       CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
-      CipherSuite.TLS_DHE_RSA_WITH_AES_128_GCM_SHA256,
+      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
+      CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
+      CipherSuite.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256,
+      CipherSuite.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256,
 
       // Note that the following cipher suites are all on HTTP/2's bad cipher suites list. We'll
       // continue to include them until better suites are commonly available. For example, none
       // of the better cipher suites listed above shipped with Android 4.4 or Java 7.
-      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,
       CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,
       CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,
+      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,
       CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,
-      CipherSuite.TLS_DHE_RSA_WITH_AES_128_CBC_SHA,
-      CipherSuite.TLS_DHE_RSA_WITH_AES_256_CBC_SHA,
       CipherSuite.TLS_RSA_WITH_AES_128_GCM_SHA256,
+      CipherSuite.TLS_RSA_WITH_AES_256_GCM_SHA384,
       CipherSuite.TLS_RSA_WITH_AES_128_CBC_SHA,
       CipherSuite.TLS_RSA_WITH_AES_256_CBC_SHA,
       CipherSuite.TLS_RSA_WITH_3DES_EDE_CBC_SHA,
@@ -64,7 +68,7 @@
   /** A modern TLS connection with extensions like SNI and ALPN available. */
   public static final ConnectionSpec MODERN_TLS = new Builder(true)
       .cipherSuites(APPROVED_CIPHER_SUITES)
-      .tlsVersions(TlsVersion.TLS_1_2, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0)
+      .tlsVersions(TlsVersion.TLS_1_3, TlsVersion.TLS_1_2, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0)
       .supportsTlsExtensions(true)
       .build();
 
@@ -77,12 +81,12 @@
   /** Unencrypted, unauthenticated connections for {@code http:} URLs. */
   public static final ConnectionSpec CLEARTEXT = new Builder(false).build();
 
-  private final boolean tls;
-  private final boolean supportsTlsExtensions;
-  private final String[] cipherSuites;
-  private final String[] tlsVersions;
+  final boolean tls;
+  final boolean supportsTlsExtensions;
+  final @Nullable String[] cipherSuites;
+  final @Nullable String[] tlsVersions;
 
-  private ConnectionSpec(Builder builder) {
+  ConnectionSpec(Builder builder) {
     this.tls = builder.tls;
     this.cipherSuites = builder.cipherSuites;
     this.tlsVersions = builder.tlsVersions;
@@ -94,31 +98,19 @@ public boolean isTls() {
   }
 
   /**
-   * Returns the cipher suites to use for a connection. Returns {@code null} if all of the SSL
-   * socket's enabled cipher suites should be used.
+   * Returns the cipher suites to use for a connection. Returns null if all of the SSL socket's
+   * enabled cipher suites should be used.
    */
-  public List<CipherSuite> cipherSuites() {
-    if (cipherSuites == null) return null;
-
-    CipherSuite[] result = new CipherSuite[cipherSuites.length];
-    for (int i = 0; i < cipherSuites.length; i++) {
-      result[i] = CipherSuite.forJavaName(cipherSuites[i]);
-    }
-    return immutableList(result);
+  public @Nullable List<CipherSuite> cipherSuites() {
+    return cipherSuites != null ? CipherSuite.forJavaNames(cipherSuites) : null;
   }
 
   /**
-   * Returns the TLS versions to use when negotiating a connection. Returns {@code null} if all of
-   * the SSL socket's enabled TLS versions should be used.
+   * Returns the TLS versions to use when negotiating a connection. Returns null if all of the SSL
+   * socket's enabled TLS versions should be used.
    */
-  public List<TlsVersion> tlsVersions() {
-    if (tlsVersions == null) return null;
-
-    TlsVersion[] result = new TlsVersion[tlsVersions.length];
-    for (int i = 0; i < tlsVersions.length; i++) {
-      result[i] = TlsVersion.forJavaName(tlsVersions[i]);
-    }
-    return immutableList(result);
+  public @Nullable List<TlsVersion> tlsVersions() {
+    return tlsVersions != null ? TlsVersion.forJavaNames(tlsVersions) : null;
   }
 
   public boolean supportsTlsExtensions() {
@@ -143,16 +135,20 @@ void apply(SSLSocket sslSocket, boolean isFallback) {
    */
   private ConnectionSpec supportedSpec(SSLSocket sslSocket, boolean isFallback) {
     String[] cipherSuitesIntersection = cipherSuites != null
-        ? intersect(String.class, cipherSuites, sslSocket.getEnabledCipherSuites())
+        ? intersect(CipherSuite.ORDER_BY_NAME, sslSocket.getEnabledCipherSuites(), cipherSuites)
         : sslSocket.getEnabledCipherSuites();
     String[] tlsVersionsIntersection = tlsVersions != null
-        ? intersect(String.class, tlsVersions, sslSocket.getEnabledProtocols())
+        ? intersect(Util.NATURAL_ORDER, sslSocket.getEnabledProtocols(), tlsVersions)
         : sslSocket.getEnabledProtocols();
 
     // In accordance with https://tools.ietf.org/html/draft-ietf-tls-downgrade-scsv-00
     // the SCSV cipher is added to signal that a protocol fallback has taken place.
-    if (isFallback && contains(sslSocket.getSupportedCipherSuites(), "TLS_FALLBACK_SCSV")) {
-      cipherSuitesIntersection = concat(cipherSuitesIntersection, "TLS_FALLBACK_SCSV");
+    String[] supportedCipherSuites = sslSocket.getSupportedCipherSuites();
+    int indexOfFallbackScsv = indexOf(
+        CipherSuite.ORDER_BY_NAME, supportedCipherSuites, "TLS_FALLBACK_SCSV");
+    if (isFallback && indexOfFallbackScsv != -1) {
+      cipherSuitesIntersection = concat(
+          cipherSuitesIntersection, supportedCipherSuites[indexOfFallbackScsv]);
     }
 
     return new Builder(this)
@@ -177,37 +173,20 @@ public boolean isCompatible(SSLSocket socket) {
       return false;
     }
 
-    if (tlsVersions != null
-        && !nonEmptyIntersection(tlsVersions, socket.getEnabledProtocols())) {
+    if (tlsVersions != null && !nonEmptyIntersection(
+        Util.NATURAL_ORDER, tlsVersions, socket.getEnabledProtocols())) {
       return false;
     }
 
-    if (cipherSuites != null
-        && !nonEmptyIntersection(cipherSuites, socket.getEnabledCipherSuites())) {
+    if (cipherSuites != null && !nonEmptyIntersection(
+        CipherSuite.ORDER_BY_NAME, cipherSuites, socket.getEnabledCipherSuites())) {
       return false;
     }
 
     return true;
   }
 
-  /**
-   * An N*M intersection that terminates if any intersection is found. The sizes of both arguments
-   * are assumed to be so small, and the likelihood of an intersection so great, that it is not
-   * worth the CPU cost of sorting or the memory cost of hashing.
-   */
-  private static boolean nonEmptyIntersection(String[] a, String[] b) {
-    if (a == null || b == null || a.length == 0 || b.length == 0) {
-      return false;
-    }
-    for (String toFind : a) {
-      if (contains(b, toFind)) {
-        return true;
-      }
-    }
-    return false;
-  }
-
-  @Override public boolean equals(Object other) {
+  @Override public boolean equals(@Nullable Object other) {
     if (!(other instanceof ConnectionSpec)) return false;
     if (other == this) return true;
 
@@ -248,10 +227,10 @@ private static boolean nonEmptyIntersection(String[] a, String[] b) {
   }
 
   public static final class Builder {
-    private boolean tls;
-    private String[] cipherSuites;
-    private String[] tlsVersions;
-    private boolean supportsTlsExtensions;
+    boolean tls;
+    @Nullable String[] cipherSuites;
+    @Nullable String[] tlsVersions;
+    boolean supportsTlsExtensions;
 
     Builder(boolean tls) {
       this.tls = tls;
diff --git a/okhttp/src/main/java/okhttp3/Cookie.java b/okhttp/src/main/java/okhttp3/Cookie.java
index 29a4bf84d1..fbfa99c26d 100644
--- a/okhttp/src/main/java/okhttp3/Cookie.java
+++ b/okhttp/src/main/java/okhttp3/Cookie.java
@@ -24,12 +24,15 @@
 import java.util.Locale;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
+import javax.annotation.Nullable;
 import okhttp3.internal.Util;
 import okhttp3.internal.http.HttpDate;
+import okhttp3.internal.publicsuffix.PublicSuffixDatabase;
 
 import static okhttp3.internal.Util.UTC;
+import static okhttp3.internal.Util.canonicalizeHost;
 import static okhttp3.internal.Util.delimiterOffset;
-import static okhttp3.internal.Util.domainToAscii;
+import static okhttp3.internal.Util.indexOfControlOrNonAscii;
 import static okhttp3.internal.Util.trimSubstring;
 import static okhttp3.internal.Util.verifyAsIpAddress;
 
@@ -74,7 +77,7 @@ private Cookie(String name, String value, long expiresAt, String domain, String
     this.persistent = persistent;
   }
 
-  private Cookie(Builder builder) {
+  Cookie(Builder builder) {
     if (builder.name == null) throw new NullPointerException("builder.name == null");
     if (builder.value == null) throw new NullPointerException("builder.value == null");
     if (builder.domain == null) throw new NullPointerException("builder.domain == null");
@@ -100,7 +103,7 @@ public String value() {
     return value;
   }
 
-  /** Returns true if this cookie expires at the end of the current session. */
+  /** Returns true if this cookie does not expire at the end of the current session. */
   public boolean persistent() {
     return persistent;
   }
@@ -169,7 +172,7 @@ public boolean secure() {
   public boolean matches(HttpUrl url) {
     boolean domainMatch = hostOnly
         ? url.host().equals(domain)
-        : domainMatch(url, domain);
+        : domainMatch(url.host(), domain);
     if (!domainMatch) return false;
 
     if (!pathMatch(url, path)) return false;
@@ -179,9 +182,7 @@ public boolean matches(HttpUrl url) {
     return true;
   }
 
-  private static boolean domainMatch(HttpUrl url, String domain) {
-    String urlHost = url.host();
-
+  private static boolean domainMatch(String urlHost, String domain) {
     if (urlHost.equals(domain)) {
       return true; // As in 'example.com' matching 'example.com'.
     }
@@ -214,11 +215,11 @@ private static boolean pathMatch(HttpUrl url, String path) {
    * Attempt to parse a {@code Set-Cookie} HTTP header value {@code setCookie} as a cookie. Returns
    * null if {@code setCookie} is not a well-formed cookie.
    */
-  public static Cookie parse(HttpUrl url, String setCookie) {
+  public static @Nullable Cookie parse(HttpUrl url, String setCookie) {
     return parse(System.currentTimeMillis(), url, setCookie);
   }
 
-  static Cookie parse(long currentTimeMillis, HttpUrl url, String setCookie) {
+  static @Nullable Cookie parse(long currentTimeMillis, HttpUrl url, String setCookie) {
     int pos = 0;
     int limit = setCookie.length();
     int cookiePairEnd = delimiterOffset(setCookie, pos, limit, ';');
@@ -227,9 +228,10 @@ static Cookie parse(long currentTimeMillis, HttpUrl url, String setCookie) {
     if (pairEqualsSign == cookiePairEnd) return null;
 
     String cookieName = trimSubstring(setCookie, pos, pairEqualsSign);
-    if (cookieName.isEmpty()) return null;
+    if (cookieName.isEmpty() || indexOfControlOrNonAscii(cookieName) != -1) return null;
 
     String cookieValue = trimSubstring(setCookie, pairEqualsSign + 1, cookiePairEnd);
+    if (indexOfControlOrNonAscii(cookieValue) != -1) return null;
 
     long expiresAt = HttpDate.MAX_DATE;
     long deltaSeconds = -1L;
@@ -297,12 +299,19 @@ static Cookie parse(long currentTimeMillis, HttpUrl url, String setCookie) {
     }
 
     // If the domain is present, it must domain match. Otherwise we have a host-only cookie.
+    String urlHost = url.host();
     if (domain == null) {
-      domain = url.host();
-    } else if (!domainMatch(url, domain)) {
+      domain = urlHost;
+    } else if (!domainMatch(urlHost, domain)) {
       return null; // No domain match? This is either incompetence or malice!
     }
 
+    // If the domain is a suffix of the url host, it must not be a public suffix.
+    if (urlHost.length() != domain.length()
+        && PublicSuffixDatabase.get().getEffectiveTldPlusOne(domain) == null) {
+      return null;
+    }
+
     // If the path is absent or didn't start with '/', use the default path. It's a string like
     // '/foo/bar' for a URL like 'http://example.com/foo/bar/baz'. It always starts with '/'.
     if (path == null || !path.startsWith("/")) {
@@ -420,7 +429,7 @@ private static String parseDomain(String s) {
     if (s.startsWith(".")) {
       s = s.substring(1);
     }
-    String canonicalDomain = domainToAscii(s);
+    String canonicalDomain = canonicalizeHost(s);
     if (canonicalDomain == null) {
       throw new IllegalArgumentException();
     }
@@ -499,7 +508,7 @@ public Builder hostOnlyDomain(String domain) {
 
     private Builder domain(String domain, boolean hostOnly) {
       if (domain == null) throw new NullPointerException("domain == null");
-      String canonicalDomain = Util.domainToAscii(domain);
+      String canonicalDomain = Util.canonicalizeHost(domain);
       if (canonicalDomain == null) {
         throw new IllegalArgumentException("unexpected domain: " + domain);
       }
@@ -530,6 +539,15 @@ public Cookie build() {
   }
 
   @Override public String toString() {
+    return toString(false);
+  }
+
+  /**
+   * @param forObsoleteRfc2965 true to include a leading {@code .} on the domain pattern. This is
+   *     necessary for {@code example.com} to match {@code www.example.com} under RFC 2965. This
+   *     extra dot is ignored by more recent specifications.
+   */
+  String toString(boolean forObsoleteRfc2965) {
     StringBuilder result = new StringBuilder();
     result.append(name);
     result.append('=');
@@ -544,7 +562,11 @@ public Cookie build() {
     }
 
     if (!hostOnly) {
-      result.append("; domain=").append(domain);
+      result.append("; domain=");
+      if (forObsoleteRfc2965) {
+        result.append(".");
+      }
+      result.append(domain);
     }
 
     result.append("; path=").append(path);
@@ -560,7 +582,7 @@ public Cookie build() {
     return result.toString();
   }
 
-  @Override public boolean equals(Object other) {
+  @Override public boolean equals(@Nullable Object other) {
     if (!(other instanceof Cookie)) return false;
     Cookie that = (Cookie) other;
     return that.name.equals(name)
diff --git a/okhttp/src/main/java/okhttp3/CookieJar.java b/okhttp/src/main/java/okhttp3/CookieJar.java
index d2cdfce22a..bdb3cd552e 100644
--- a/okhttp/src/main/java/okhttp3/CookieJar.java
+++ b/okhttp/src/main/java/okhttp3/CookieJar.java
@@ -22,7 +22,7 @@
  * Provides <strong>policy</strong> and <strong>persistence</strong> for HTTP cookies.
  *
  * <p>As policy, implementations of this interface are responsible for selecting which cookies to
- * accept and which to reject. A reasonable policy is to reject all cookies, though that may be
+ * accept and which to reject. A reasonable policy is to reject all cookies, though that may
  * interfere with session-based authentication schemes that require cookies.
  *
  * <p>As persistence, implementations of this interface must also provide storage of cookies. Simple
diff --git a/okhttp/src/main/java/okhttp3/Credentials.java b/okhttp/src/main/java/okhttp3/Credentials.java
index 9be4e6a22f..a27ecae001 100644
--- a/okhttp/src/main/java/okhttp3/Credentials.java
+++ b/okhttp/src/main/java/okhttp3/Credentials.java
@@ -15,9 +15,11 @@
  */
 package okhttp3;
 
-import java.io.UnsupportedEncodingException;
+import java.nio.charset.Charset;
 import okio.ByteString;
 
+import static okhttp3.internal.Util.ISO_8859_1;
+
 /** Factory for HTTP authorization credentials. */
 public final class Credentials {
   private Credentials() {
@@ -25,13 +27,12 @@ private Credentials() {
 
   /** Returns an auth credential for the Basic scheme. */
   public static String basic(String userName, String password) {
-    try {
-      String usernameAndPassword = userName + ":" + password;
-      byte[] bytes = usernameAndPassword.getBytes("ISO-8859-1");
-      String encoded = ByteString.of(bytes).base64();
-      return "Basic " + encoded;
-    } catch (UnsupportedEncodingException e) {
-      throw new AssertionError();
-    }
+    return basic(userName, password, ISO_8859_1);
+  }
+
+  public static String basic(String userName, String password, Charset charset) {
+    String usernameAndPassword = userName + ":" + password;
+    String encoded = ByteString.encodeString(usernameAndPassword, charset).base64();
+    return "Basic " + encoded;
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/Dispatcher.java b/okhttp/src/main/java/okhttp3/Dispatcher.java
index 0d30547afb..43f5aa48e7 100644
--- a/okhttp/src/main/java/okhttp3/Dispatcher.java
+++ b/okhttp/src/main/java/okhttp3/Dispatcher.java
@@ -25,6 +25,7 @@
 import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
+import javax.annotation.Nullable;
 import okhttp3.RealCall.AsyncCall;
 import okhttp3.internal.Util;
 
@@ -38,10 +39,10 @@
 public final class Dispatcher {
   private int maxRequests = 64;
   private int maxRequestsPerHost = 5;
-  private Runnable idleCallback;
+  private @Nullable Runnable idleCallback;
 
   /** Executes calls. Created lazily. */
-  private ExecutorService executorService;
+  private @Nullable ExecutorService executorService;
 
   /** Ready async calls in the order they'll be run. */
   private final Deque<AsyncCall> readyAsyncCalls = new ArrayDeque<>();
@@ -119,7 +120,7 @@ public synchronized int getMaxRequestsPerHost() {
    * means that if you are doing synchronous calls the network layer will not truly be idle until
    * every returned {@link Response} has been closed.
    */
-  public synchronized void setIdleCallback(Runnable idleCallback) {
+  public synchronized void setIdleCallback(@Nullable Runnable idleCallback) {
     this.idleCallback = idleCallback;
   }
 
@@ -138,11 +139,11 @@ synchronized void enqueue(AsyncCall call) {
    */
   public synchronized void cancelAll() {
     for (AsyncCall call : readyAsyncCalls) {
-      call.cancel();
+      call.get().cancel();
     }
 
     for (AsyncCall call : runningAsyncCalls) {
-      call.cancel();
+      call.get().cancel();
     }
 
     for (RealCall call : runningSyncCalls) {
diff --git a/okhttp/src/main/java/okhttp3/Dns.java b/okhttp/src/main/java/okhttp3/Dns.java
index a2e6db591c..de3b4cb215 100644
--- a/okhttp/src/main/java/okhttp3/Dns.java
+++ b/okhttp/src/main/java/okhttp3/Dns.java
@@ -36,7 +36,14 @@
   Dns SYSTEM = new Dns() {
     @Override public List<InetAddress> lookup(String hostname) throws UnknownHostException {
       if (hostname == null) throw new UnknownHostException("hostname == null");
-      return Arrays.asList(InetAddress.getAllByName(hostname));
+      try {
+        return Arrays.asList(InetAddress.getAllByName(hostname));
+      } catch (NullPointerException e) {
+        UnknownHostException unknownHostException =
+            new UnknownHostException("Broken system behaviour for dns lookup of " + hostname);
+        unknownHostException.initCause(e);
+        throw unknownHostException;
+      }
     }
   };
 
diff --git a/okhttp/src/main/java/okhttp3/EventListener.java b/okhttp/src/main/java/okhttp3/EventListener.java
new file mode 100644
index 0000000000..1feebd3ad0
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/EventListener.java
@@ -0,0 +1,307 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.Proxy;
+import java.util.List;
+import javax.annotation.Nullable;
+
+/**
+ * Listener for metrics events. Extend this class to monitor the quantity, size, and duration of
+ * your application's HTTP calls.
+ *
+ * <h3>Warning: This is a non-final API.</h3>
+ *
+ * <p><strong>As of OkHttp 3.9, this feature is an unstable preview: the API is subject to change,
+ * and the implementation is incomplete. We expect that OkHttp 3.10 or 3.11 will finalize this API.
+ * Until then, expect API and behavior changes when you update your OkHttp dependency.</strong>
+ *
+ * <p>All start/connect/acquire events will eventually receive a matching end/release event,
+ * either successful (non-null parameters), or failed (non-null throwable).  The first common
+ * parameters of each event pair are used to link the event in case of concurrent or repeated
+ * events e.g. dnsStart(call, domainName) -&gt; dnsEnd(call, domainName, inetAddressList).
+ *
+ * <p>Nesting is as follows
+ * <ul>
+ *   <li>call -&gt; (dns -&gt; connect -&gt; secure connect)* -&gt; request events</li>
+ *   <li>call -&gt; (connection acquire/release)*</li>
+ * </ul>
+ *
+ * <p>Request events are ordered:
+ * requestHeaders -&gt; requestBody -&gt; responseHeaders -&gt; responseBody
+ *
+ * <p>Since connections may be reused, the dns and connect events may not be present for a call,
+ * or may be repeated in case of failure retries, even concurrently in case of happy eyeballs type
+ * scenarios. A redirect cross domain, or to use https may cause additional connection and request
+ * events.
+ *
+ * <p>All event methods must execute fast, without external locking, cannot throw exceptions,
+ * attempt to mutate the event parameters, or be reentrant back into the client.
+ * Any IO - writing to files or network should be done asynchronously.
+ */
+public abstract class EventListener {
+  public static final EventListener NONE = new EventListener() {
+  };
+
+  static EventListener.Factory factory(final EventListener listener) {
+    return new EventListener.Factory() {
+      public EventListener create(Call call) {
+        return listener;
+      }
+    };
+  }
+
+  /**
+   * Invoked as soon as a call is enqueued or executed by a client. In case of thread or stream
+   * limits, this call may be executed well before processing the request is able to begin.
+   *
+   * <p>This will be invoked only once for a single {@link Call}. Retries of different routes
+   * or redirects will be handled within the boundaries of a single callStart and {@link
+   * #callEnd}/{@link #callFailed} pair.
+   */
+  public void callStart(Call call) {
+  }
+
+  /**
+   * Invoked just prior to a DNS lookup. See {@link Dns#lookup(String)}.
+   *
+   * <p>This can be invoked more than 1 time for a single {@link Call}. For example, if the response
+   * to the {@link Call#request()} is a redirect to a different host.
+   *
+   * <p>If the {@link Call} is able to reuse an existing pooled connection, this method will not be
+   * invoked. See {@link ConnectionPool}.
+   */
+  public void dnsStart(Call call, String domainName) {
+  }
+
+  /**
+   * Invoked immediately after a DNS lookup.
+   *
+   * <p>This method is invoked after {@link #dnsStart}.
+   */
+  public void dnsEnd(Call call, String domainName, @Nullable List<InetAddress> inetAddressList) {
+  }
+
+  /**
+   * Invoked just prior to initiating a socket connection.
+   *
+   * <p>This method will be invoked if no existing connection in the {@link ConnectionPool} can be
+   * reused.
+   *
+   * <p>This can be invoked more than 1 time for a single {@link Call}. For example, if the response
+   * to the {@link Call#request()} is a redirect to a different address, or a connection is retried.
+   */
+  public void connectStart(Call call, InetSocketAddress inetSocketAddress, Proxy proxy) {
+  }
+
+  /**
+   * Invoked just prior to initiating a TLS connection.
+   *
+   * <p>This method is invoked if the following conditions are met:
+   * <ul>
+   * <li>The {@link Call#request()} requires TLS.</li>
+   * <li>No existing connection from the {@link ConnectionPool} can be reused.</li>
+   * </ul>
+   *
+   * <p>This can be invoked more than 1 time for a single {@link Call}. For example, if the response
+   * to the {@link Call#request()} is a redirect to a different address, or a connection is retried.
+   */
+  public void secureConnectStart(Call call) {
+  }
+
+  /**
+   * Invoked immediately after a TLS connection was attempted.
+   *
+   * <p>This method is invoked after {@link #secureConnectStart}.
+   */
+  public void secureConnectEnd(Call call, @Nullable Handshake handshake) {
+  }
+
+  /**
+   * Invoked immediately after a socket connection was attempted.
+   *
+   * <p>If the {@code call} uses HTTPS, this will be invoked after
+   * {@link #secureConnectEnd(Call, Handshake)}, otherwise it will invoked after
+   * {@link #connectStart(Call, InetSocketAddress, Proxy)}.
+   */
+  public void connectEnd(Call call, InetSocketAddress inetSocketAddress,
+      @Nullable Proxy proxy, @Nullable Protocol protocol) {
+  }
+
+  /**
+   * Invoked when a connection attempt fails. This failure is not terminal if further routes are
+   * available and failure recovery is enabled.
+   *
+   * <p>If the {@code call} uses HTTPS, this will be invoked after {@link #secureConnectEnd(Call,
+   * Handshake)}, otherwise it will invoked after {@link #connectStart(Call, InetSocketAddress,
+   * Proxy)}.
+   */
+  public void connectFailed(Call call, InetSocketAddress inetSocketAddress,
+      @Nullable Proxy proxy, @Nullable Protocol protocol, @Nullable IOException ioe) {
+  }
+
+  /**
+   * Invoked after a connection has been acquired for the {@code call}.
+   *
+   * <p>This can be invoked more than 1 time for a single {@link Call}. For example, if the response
+   * to the {@link Call#request()} is a redirect to a different address.
+   */
+  public void connectionAcquired(Call call, Connection connection) {
+  }
+
+  /**
+   * Invoked after a connection has been released for the {@code call}.
+   *
+   * <p>This method is always invoked after {@link #connectionAcquired(Call, Connection)}.
+   *
+   * <p>This can be invoked more than 1 time for a single {@link Call}. For example, if the response
+   * to the {@link Call#request()} is a redirect to a different address.
+   */
+  public void connectionReleased(Call call, Connection connection) {
+  }
+
+  /**
+   * Invoked just prior to sending request headers.
+   *
+   * <p>The connection is implicit, and will generally relate to the last
+   * {@link #connectionAcquired(Call, Connection)} event.
+   *
+   * <p>This can be invoked more than 1 time for a single {@link Call}. For example, if the response
+   * to the {@link Call#request()} is a redirect to a different address.
+   */
+  public void requestHeadersStart(Call call) {
+  }
+
+  /**
+   * Invoked immediately after sending request headers.
+   *
+   * <p>This method is always invoked after {@link #requestHeadersStart(Call)}.
+   *
+   * @param request the request sent over the network. It is an error to access the body of this
+   *     request.
+   */
+  public void requestHeadersEnd(Call call, Request request) {
+  }
+
+  /**
+   * Invoked just prior to sending a request body.  Will only be invoked for request allowing and
+   * having a request body to send.
+   *
+   * <p>The connection is implicit, and will generally relate to the last
+   * {@link #connectionAcquired(Call, Connection)} event.
+   *
+   * <p>This can be invoked more than 1 time for a single {@link Call}. For example, if the response
+   * to the {@link Call#request()} is a redirect to a different address.
+   */
+  public void requestBodyStart(Call call) {
+  }
+
+  /**
+   * Invoked immediately after sending a request body.
+   *
+   * <p>This method is always invoked after {@link #requestBodyStart(Call)}.
+   */
+  public void requestBodyEnd(Call call, long byteCount) {
+  }
+
+  /**
+   * Invoked just prior to receiving response headers.
+   *
+   * <p>The connection is implicit, and will generally relate to the last
+   * {@link #connectionAcquired(Call, Connection)} event.
+   *
+   * <p>This can be invoked more than 1 time for a single {@link Call}. For example, if the response
+   * to the {@link Call#request()} is a redirect to a different address.
+   */
+  public void responseHeadersStart(Call call) {
+  }
+
+  /**
+   * Invoked immediately after receiving response headers.
+   *
+   * <p>This method is always invoked after {@link #responseHeadersStart}.
+   *
+   * @param response the response received over the network. It is an error to access the body of
+   *     this response.
+   */
+  public void responseHeadersEnd(Call call, Response response) {
+  }
+
+  /**
+   * Invoked just prior to receiving the response body.
+   *
+   * <p>The connection is implicit, and will generally relate to the last
+   * {@link #connectionAcquired(Call, Connection)} event.
+   *
+   * <p>This will usually be invoked only 1 time for a single {@link Call},
+   * exceptions are a limited set of cases including failure recovery.
+   */
+  public void responseBodyStart(Call call) {
+  }
+
+  /**
+   * Invoked immediately after receiving a response body and completing reading it.
+   *
+   * <p>Will only be invoked for requests having a response body e.g. won't be invoked for a
+   * websocket upgrade.
+   *
+   * <p>This method is always invoked after {@link #requestBodyStart(Call)}.
+   */
+  public void responseBodyEnd(Call call, long byteCount) {
+  }
+
+  /**
+   * Invoked immediately after a call has completely ended.  This includes delayed consumption
+   * of response body by the caller.
+   *
+   * <p>This method is always invoked after {@link #callStart(Call)}.
+   */
+  public void callEnd(Call call) {
+  }
+
+  /**
+   * Invoked when a call fails permanently.
+   *
+   * <p>This method is always invoked after {@link #callStart(Call)}.
+   */
+  public void callFailed(Call call, IOException ioe) {
+  }
+
+  /**
+   * <h3>Warning: This is a non-final API.</h3>
+   *
+   * <p><strong>As of OkHttp 3.9, this feature is an unstable preview: the API is subject to change,
+   * and the implementation is incomplete. We expect that OkHttp 3.10 or 3.11 will finalize this
+   * API. Until then, expect API and behavior changes when you update your OkHttp
+   * dependency.</strong>
+   */
+  public interface Factory {
+    /**
+     * Creates an instance of the {@link EventListener} for a particular {@link Call}. The returned
+     * {@link EventListener} instance will be used during the lifecycle of the {@code call}.
+     *
+     * <p>This method is invoked after the {@code call} is created. See
+     * {@link OkHttpClient#newCall(Request)}.
+     *
+     * <p><strong>It is an error for implementations to issue any mutating operations on the
+     * {@code call} instance from this method.</strong>
+     */
+    EventListener create(Call call);
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/FormBody.java b/okhttp/src/main/java/okhttp3/FormBody.java
index 95181b1f76..ff9a8c2572 100644
--- a/okhttp/src/main/java/okhttp3/FormBody.java
+++ b/okhttp/src/main/java/okhttp3/FormBody.java
@@ -16,8 +16,10 @@
 package okhttp3;
 
 import java.io.IOException;
+import java.nio.charset.Charset;
 import java.util.ArrayList;
 import java.util.List;
+import javax.annotation.Nullable;
 import okhttp3.internal.Util;
 import okio.Buffer;
 import okio.BufferedSink;
@@ -32,7 +34,7 @@
   private final List<String> encodedNames;
   private final List<String> encodedValues;
 
-  private FormBody(List<String> encodedNames, List<String> encodedValues) {
+  FormBody(List<String> encodedNames, List<String> encodedValues) {
     this.encodedNames = Util.immutableList(encodedNames);
     this.encodedValues = Util.immutableList(encodedValues);
   }
@@ -76,7 +78,7 @@ public String value(int index) {
    * to awkward operations like measuring the encoded length of header strings, or the
    * length-in-digits of an encoded integer.
    */
-  private long writeOrCountBytes(BufferedSink sink, boolean countBytes) {
+  private long writeOrCountBytes(@Nullable BufferedSink sink, boolean countBytes) {
     long byteCount = 0L;
 
     Buffer buffer;
@@ -104,16 +106,25 @@ private long writeOrCountBytes(BufferedSink sink, boolean countBytes) {
   public static final class Builder {
     private final List<String> names = new ArrayList<>();
     private final List<String> values = new ArrayList<>();
+    private final Charset charset;
+
+    public Builder() {
+      this(null);
+    }
+
+    public Builder(Charset charset) {
+      this.charset = charset;
+    }
 
     public Builder add(String name, String value) {
-      names.add(HttpUrl.canonicalize(name, FORM_ENCODE_SET, false, false, true, true));
-      values.add(HttpUrl.canonicalize(value, FORM_ENCODE_SET, false, false, true, true));
+      names.add(HttpUrl.canonicalize(name, FORM_ENCODE_SET, false, false, true, true, charset));
+      values.add(HttpUrl.canonicalize(value, FORM_ENCODE_SET, false, false, true, true, charset));
       return this;
     }
 
     public Builder addEncoded(String name, String value) {
-      names.add(HttpUrl.canonicalize(name, FORM_ENCODE_SET, true, false, true, true));
-      values.add(HttpUrl.canonicalize(value, FORM_ENCODE_SET, true, false, true, true));
+      names.add(HttpUrl.canonicalize(name, FORM_ENCODE_SET, true, false, true, true, charset));
+      values.add(HttpUrl.canonicalize(value, FORM_ENCODE_SET, true, false, true, true, charset));
       return this;
     }
 
diff --git a/okhttp/src/main/java/okhttp3/Handshake.java b/okhttp/src/main/java/okhttp3/Handshake.java
index d2c08be57e..59a5418b86 100644
--- a/okhttp/src/main/java/okhttp3/Handshake.java
+++ b/okhttp/src/main/java/okhttp3/Handshake.java
@@ -20,6 +20,7 @@
 import java.security.cert.X509Certificate;
 import java.util.Collections;
 import java.util.List;
+import javax.annotation.Nullable;
 import javax.net.ssl.SSLPeerUnverifiedException;
 import javax.net.ssl.SSLSession;
 import okhttp3.internal.Util;
@@ -74,14 +75,15 @@ public static Handshake get(SSLSession session) {
 
   public static Handshake get(TlsVersion tlsVersion, CipherSuite cipherSuite,
       List<Certificate> peerCertificates, List<Certificate> localCertificates) {
+    if (tlsVersion == null) throw new NullPointerException("tlsVersion == null");
     if (cipherSuite == null) throw new NullPointerException("cipherSuite == null");
     return new Handshake(tlsVersion, cipherSuite, Util.immutableList(peerCertificates),
         Util.immutableList(localCertificates));
   }
 
   /**
-   * Returns the TLS version used for this connection. May return null if the response was cached
-   * with a version of OkHttp prior to 3.0.
+   * Returns the TLS version used for this connection. This value wasn't tracked prior to OkHttp
+   * 3.0. For responses cached by preceding versions this returns {@link TlsVersion#SSL_3_0}.
    */
   public TlsVersion tlsVersion() {
     return tlsVersion;
@@ -98,7 +100,7 @@ public CipherSuite cipherSuite() {
   }
 
   /** Returns the remote peer's principle, or null if that peer is anonymous. */
-  public Principal peerPrincipal() {
+  public @Nullable Principal peerPrincipal() {
     return !peerCertificates.isEmpty()
         ? ((X509Certificate) peerCertificates.get(0)).getSubjectX500Principal()
         : null;
@@ -110,16 +112,16 @@ public Principal peerPrincipal() {
   }
 
   /** Returns the local principle, or null if this peer is anonymous. */
-  public Principal localPrincipal() {
+  public @Nullable Principal localPrincipal() {
     return !localCertificates.isEmpty()
         ? ((X509Certificate) localCertificates.get(0)).getSubjectX500Principal()
         : null;
   }
 
-  @Override public boolean equals(Object other) {
+  @Override public boolean equals(@Nullable Object other) {
     if (!(other instanceof Handshake)) return false;
     Handshake that = (Handshake) other;
-    return Util.equal(cipherSuite, that.cipherSuite)
+    return tlsVersion.equals(that.tlsVersion)
         && cipherSuite.equals(that.cipherSuite)
         && peerCertificates.equals(that.peerCertificates)
         && localCertificates.equals(that.localCertificates);
@@ -127,7 +129,7 @@ public Principal localPrincipal() {
 
   @Override public int hashCode() {
     int result = 17;
-    result = 31 * result + (tlsVersion != null ? tlsVersion.hashCode() : 0);
+    result = 31 * result + tlsVersion.hashCode();
     result = 31 * result + cipherSuite.hashCode();
     result = 31 * result + peerCertificates.hashCode();
     result = 31 * result + localCertificates.hashCode();
diff --git a/okhttp/src/main/java/okhttp3/Headers.java b/okhttp/src/main/java/okhttp3/Headers.java
index 5080883af7..d5ef33aa70 100644
--- a/okhttp/src/main/java/okhttp3/Headers.java
+++ b/okhttp/src/main/java/okhttp3/Headers.java
@@ -21,12 +21,13 @@
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.Date;
-import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Locale;
 import java.util.Map;
 import java.util.Set;
+import java.util.TreeMap;
 import java.util.TreeSet;
+import javax.annotation.Nullable;
 import okhttp3.internal.Util;
 import okhttp3.internal.http.HttpDate;
 
@@ -49,7 +50,7 @@
 public final class Headers {
   private final String[] namesAndValues;
 
-  private Headers(Builder builder) {
+  Headers(Builder builder) {
     this.namesAndValues = builder.namesAndValues.toArray(new String[builder.namesAndValues.size()]);
   }
 
@@ -58,7 +59,7 @@ private Headers(String[] namesAndValues) {
   }
 
   /** Returns the last value corresponding to the specified field, or null. */
-  public String get(String name) {
+  public @Nullable String get(String name) {
     return get(namesAndValues, name);
   }
 
@@ -66,7 +67,7 @@ public String get(String name) {
    * Returns the last value corresponding to the specified field parsed as an HTTP date, or null if
    * either the field is absent or cannot be parsed as a date.
    */
-  public Date getDate(String name) {
+  public @Nullable Date getDate(String name) {
     String value = get(name);
     return value != null ? HttpDate.parse(value) : null;
   }
@@ -109,6 +110,23 @@ public String value(int index) {
         : Collections.<String>emptyList();
   }
 
+  /**
+   * Returns the number of bytes required to encode these headers using HTTP/1.1. This is also the
+   * approximate size of HTTP/2 headers before they are compressed with HPACK. This value is
+   * intended to be used as a metric: smaller headers are more efficient to encode and transmit.
+   */
+  public long byteCount() {
+    // Each header name has 2 bytes of overhead for ': ' and every header value has 2 bytes of
+    // overhead for '\r\n'.
+    long result = namesAndValues.length * 2;
+
+    for (int i = 0, size = namesAndValues.length; i < size; i++) {
+      result += namesAndValues[i].length();
+    }
+
+    return result;
+  }
+
   public Builder newBuilder() {
     Builder result = new Builder();
     Collections.addAll(result.namesAndValues, namesAndValues);
@@ -141,7 +159,7 @@ public Builder newBuilder() {
    * Applications that require semantically equal headers should convert them into a canonical form
    * before comparing them for equality.
    */
-  @Override public boolean equals(Object other) {
+  @Override public boolean equals(@Nullable Object other) {
     return other instanceof Headers
         && Arrays.equals(((Headers) other).namesAndValues, namesAndValues);
   }
@@ -159,7 +177,7 @@ public Builder newBuilder() {
   }
 
   public Map<String, List<String>> toMultimap() {
-    Map<String, List<String>> result = new LinkedHashMap<>();
+    Map<String, List<String>> result = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);
     for (int i = 0, size = size(); i < size; i++) {
       String name = name(i).toLowerCase(Locale.US);
       List<String> values = result.get(name);
@@ -237,7 +255,7 @@ public static Headers of(Map<String, String> headers) {
   }
 
   public static final class Builder {
-    private final List<String> namesAndValues = new ArrayList<>(20);
+    final List<String> namesAndValues = new ArrayList<>(20);
 
     /**
      * Add a header line without any validation. Only appropriate for headers from the remote peer
@@ -308,15 +326,15 @@ private void checkNameAndValue(String name, String value) {
       if (name.isEmpty()) throw new IllegalArgumentException("name is empty");
       for (int i = 0, length = name.length(); i < length; i++) {
         char c = name.charAt(i);
-        if (c <= '\u001f' || c >= '\u007f') {
+        if (c <= '\u0020' || c >= '\u007f') {
           throw new IllegalArgumentException(Util.format(
               "Unexpected char %#04x at %d in header name: %s", (int) c, i, name));
         }
       }
-      if (value == null) throw new NullPointerException("value == null");
+      if (value == null) throw new NullPointerException("value for name " + name + " == null");
       for (int i = 0, length = value.length(); i < length; i++) {
         char c = value.charAt(i);
-        if (c <= '\u001f' || c >= '\u007f') {
+        if ((c <= '\u001f' && c != '\t') || c >= '\u007f') {
           throw new IllegalArgumentException(Util.format(
               "Unexpected char %#04x at %d in %s value: %s", (int) c, i, name, value));
         }
diff --git a/okhttp/src/main/java/okhttp3/HttpUrl.java b/okhttp/src/main/java/okhttp3/HttpUrl.java
index 45effb8f6d..85292eec88 100644
--- a/okhttp/src/main/java/okhttp3/HttpUrl.java
+++ b/okhttp/src/main/java/okhttp3/HttpUrl.java
@@ -21,18 +21,22 @@
 import java.net.URISyntaxException;
 import java.net.URL;
 import java.net.UnknownHostException;
+import java.nio.charset.Charset;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Collections;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Set;
+import javax.annotation.Nullable;
+import okhttp3.internal.Util;
+import okhttp3.internal.publicsuffix.PublicSuffixDatabase;
 import okio.Buffer;
 
+import static okhttp3.internal.Util.decodeHexDigit;
 import static okhttp3.internal.Util.delimiterOffset;
-import static okhttp3.internal.Util.domainToAscii;
 import static okhttp3.internal.Util.skipLeadingAsciiWhitespace;
 import static okhttp3.internal.Util.skipTrailingAsciiWhitespace;
+import static okhttp3.internal.Util.verifyAsIpAddress;
 
 /**
  * A uniform resource locator (URL) with a scheme of either {@code http} or {@code https}. Use this
@@ -121,10 +125,16 @@
  * <h4>Path</h4>
  *
  * <p>The path identifies a specific resource on the host. Paths have a hierarchical structure like
- * "/square/okhttp/issues/1486". Each path segment is prefixed with "/". This class offers methods
- * to compose and decompose paths by segment. If a path's last segment is the empty string, then the
- * path ends with "/". This class always builds non-empty paths: if the path is omitted it defaults
- * to "/", which is a path whose only segment is the empty string.
+ * "/square/okhttp/issues/1486" and decompose into a list of segments like ["square", "okhttp",
+ * "issues", "1486"].
+ *
+ * <p>This class offers methods to compose and decompose paths by segment. It composes each path
+ * from a list of segments by alternating between "/" and the encoded segment. For example the
+ * segments ["a", "b"] build "/a/b" and the segments ["a", "b", ""] build "/a/b/".
+ *
+ * <p>If a path's last segment is the empty string then the path ends with "/". This class always
+ * builds non-empty paths: if the path is omitted it defaults to "/". The default path's segment
+ * list is a single empty string: [""].
  *
  * <h4>Query</h4>
  *
@@ -233,7 +243,7 @@
  *   String attack = "http://example.com/static/images/../../../../../etc/passwd";
  *   System.out.println(new URL(attack).getPath());
  *   System.out.println(new URI(attack).getPath());
- *   System.out.println(HttpUrl.parse(attack).path());
+ *   System.out.println(HttpUrl.parse(attack).encodedPath());
  * }</pre>
  *
  * By canonicalizing the input paths, they are complicit in directory traversal attacks. Code that
@@ -290,7 +300,7 @@
   static final String FRAGMENT_ENCODE_SET_URI = " \"#<>\\^`{|}";
 
   /** Either "http" or "https". */
-  private final String scheme;
+  final String scheme;
 
   /** Decoded username. */
   private final String username;
@@ -299,10 +309,10 @@
   private final String password;
 
   /** Canonical hostname. */
-  private final String host;
+  final String host;
 
   /** Either 80, 443 or a user-specified port. In range [1..65535]. */
-  private final int port;
+  final int port;
 
   /**
    * A list of canonical path segments. This list always contains at least one element, which may be
@@ -316,15 +326,15 @@
    * non-empty, but never null. Values are null if the name has no corresponding '=' separator, or
    * empty, or non-empty.
    */
-  private final List<String> queryNamesAndValues;
+  private final @Nullable List<String> queryNamesAndValues;
 
   /** Decoded fragment. */
-  private final String fragment;
+  private final @Nullable String fragment;
 
   /** Canonical URL. */
   private final String url;
 
-  private HttpUrl(Builder builder) {
+  HttpUrl(Builder builder) {
     this.scheme = builder.scheme;
     this.username = percentDecode(builder.encodedUsername, false);
     this.password = percentDecode(builder.encodedPassword, false);
@@ -359,7 +369,7 @@ public URL url() {
    *     <li>Whitespace and control characters in the fragment will be stripped.
    * </ul>
    *
-   * <p>These differences may have a significant consequence when the URI is interpretted by a
+   * <p>These differences may have a significant consequence when the URI is interpreted by a
    * webserver. For this reason the {@linkplain URI URI class} and this method should be avoided.
    */
   public URI uri() {
@@ -386,7 +396,17 @@ public boolean isHttps() {
     return scheme.equals("https");
   }
 
-  /** Returns the username, or an empty string if none is set. */
+  /**
+   * Returns the username, or an empty string if none is set.
+   *
+   * <p><table summary="">
+   *   <tr><th>URL</th><th>{@code encodedUsername()}</th></tr>
+   *   <tr><td>{@code http://host/}</td><td>{@code ""}</td></tr>
+   *   <tr><td>{@code http://username@host/}</td><td>{@code "username"}</td></tr>
+   *   <tr><td>{@code http://username:password@host/}</td><td>{@code "username"}</td></tr>
+   *   <tr><td>{@code http://a%20b:c%20d@host/}</td><td>{@code "a%20b"}</td></tr>
+   * </table>
+   */
   public String encodedUsername() {
     if (username.isEmpty()) return "";
     int usernameStart = scheme.length() + 3; // "://".length() == 3.
@@ -394,11 +414,32 @@ public String encodedUsername() {
     return url.substring(usernameStart, usernameEnd);
   }
 
+  /**
+   * Returns the decoded username, or an empty string if none is present.
+   *
+   * <p><table summary="">
+   *   <tr><th>URL</th><th>{@code username()}</th></tr>
+   *   <tr><td>{@code http://host/}</td><td>{@code ""}</td></tr>
+   *   <tr><td>{@code http://username@host/}</td><td>{@code "username"}</td></tr>
+   *   <tr><td>{@code http://username:password@host/}</td><td>{@code "username"}</td></tr>
+   *   <tr><td>{@code http://a%20b:c%20d@host/}</td><td>{@code "a b"}</td></tr>
+   * </table>
+   */
   public String username() {
     return username;
   }
 
-  /** Returns the password, or an empty string if none is set. */
+  /**
+   * Returns the password, or an empty string if none is set.
+   *
+   * <p><table summary="">
+   *   <tr><th>URL</th><th>{@code encodedPassword()}</th></tr>
+   *   <tr><td>{@code http://host/}</td><td>{@code ""}</td></tr>
+   *   <tr><td>{@code http://username@host/}</td><td>{@code ""}</td></tr>
+   *   <tr><td>{@code http://username:password@host/}</td><td>{@code "password"}</td></tr>
+   *   <tr><td>{@code http://a%20b:c%20d@host/}</td><td>{@code "c%20d"}</td></tr>
+   * </table>
+   */
   public String encodedPassword() {
     if (password.isEmpty()) return "";
     int passwordStart = url.indexOf(':', scheme.length() + 3) + 1;
@@ -406,7 +447,17 @@ public String encodedPassword() {
     return url.substring(passwordStart, passwordEnd);
   }
 
-  /** Returns the decoded password, or an empty string if none is present. */
+  /**
+   * Returns the decoded password, or an empty string if none is present.
+   *
+   * <p><table summary="">
+   *   <tr><th>URL</th><th>{@code password()}</th></tr>
+   *   <tr><td>{@code http://host/}</td><td>{@code ""}</td></tr>
+   *   <tr><td>{@code http://username@host/}</td><td>{@code ""}</td></tr>
+   *   <tr><td>{@code http://username:password@host/}</td><td>{@code "password"}</td></tr>
+   *   <tr><td>{@code http://a%20b:c%20d@host/}</td><td>{@code "c d"}</td></tr>
+   * </table>
+   */
   public String password() {
     return password;
   }
@@ -421,6 +472,14 @@ public String password() {
    *   <li>An IPv6 address, like {@code ::1}. Note that there are no square braces.
    *   <li>An encoded IDN, like {@code xn--n3h.net}.
    * </ul>
+   *
+   * <p><table summary="">
+   *   <tr><th>URL</th><th>{@code host()}</th></tr>
+   *   <tr><td>{@code http://android.com/}</td><td>{@code "android.com"}</td></tr>
+   *   <tr><td>{@code http://127.0.0.1/}</td><td>{@code "127.0.0.1"}</td></tr>
+   *   <tr><td>{@code http://[::1]/}</td><td>{@code "::1"}</td></tr>
+   *   <tr><td>{@code http://xn--n3h.net/}</td><td>{@code "xn--n3h.net"}</td></tr>
+   * </table>
    */
   public String host() {
     return host;
@@ -430,6 +489,13 @@ public String host() {
    * Returns the explicitly-specified port if one was provided, or the default port for this URL's
    * scheme. For example, this returns 8443 for {@code https://square.com:8443/} and 443 for {@code
    * https://square.com/}. The result is in {@code [1..65535]}.
+   *
+   * <p><table summary="">
+   *   <tr><th>URL</th><th>{@code port()}</th></tr>
+   *   <tr><td>{@code http://host/}</td><td>{@code 80}</td></tr>
+   *   <tr><td>{@code http://host:8000/}</td><td>{@code 8000}</td></tr>
+   *   <tr><td>{@code https://host/}</td><td>{@code 443}</td></tr>
+   * </table>
    */
   public int port() {
     return port;
@@ -449,13 +515,31 @@ public static int defaultPort(String scheme) {
     }
   }
 
+  /**
+   * Returns the number of segments in this URL's path. This is also the number of slashes in the
+   * URL's path, like 3 in {@code http://host/a/b/c}. This is always at least 1.
+   *
+   * <p><table summary="">
+   *   <tr><th>URL</th><th>{@code pathSize()}</th></tr>
+   *   <tr><td>{@code http://host/}</td><td>{@code 1}</td></tr>
+   *   <tr><td>{@code http://host/a/b/c}</td><td>{@code 3}</td></tr>
+   *   <tr><td>{@code http://host/a/b/c/}</td><td>{@code 4}</td></tr>
+   * </table>
+   */
   public int pathSize() {
     return pathSegments.size();
   }
 
   /**
-   * Returns the entire path of this URL, encoded for use in HTTP resource resolution. The returned
-   * path is always nonempty and is prefixed with {@code /}.
+   * Returns the entire path of this URL encoded for use in HTTP resource resolution. The returned
+   * path will start with {@code "/"}.
+   *
+   * <p><table summary="">
+   *   <tr><th>URL</th><th>{@code encodedPath()}</th></tr>
+   *   <tr><td>{@code http://host/}</td><td>{@code "/"}</td></tr>
+   *   <tr><td>{@code http://host/a/b/c}</td><td>{@code "/a/b/c"}</td></tr>
+   *   <tr><td>{@code http://host/a/b%20c/d}</td><td>{@code "/a/b%20c/d"}</td></tr>
+   * </table>
    */
   public String encodedPath() {
     int pathStart = url.indexOf('/', scheme.length() + 3); // "://".length() == 3.
@@ -470,6 +554,17 @@ static void pathSegmentsToString(StringBuilder out, List<String> pathSegments) {
     }
   }
 
+  /**
+   * Returns a list of encoded path segments like {@code ["a", "b", "c"]} for the URL {@code
+   * http://host/a/b/c}. This list is never empty though it may contain a single empty string.
+   *
+   * <p><table summary="">
+   *   <tr><th>URL</th><th>{@code encodedPathSegments()}</th></tr>
+   *   <tr><td>{@code http://host/}</td><td>{@code [""]}</td></tr>
+   *   <tr><td>{@code http://host/a/b/c}</td><td>{@code ["a", "b", "c"]}</td></tr>
+   *   <tr><td>{@code http://host/a/b%20c/d}</td><td>{@code ["a", "b%20c", "d"]}</td></tr>
+   * </table>
+   */
   public List<String> encodedPathSegments() {
     int pathStart = url.indexOf('/', scheme.length() + 3);
     int pathEnd = delimiterOffset(url, pathStart, url.length(), "?#");
@@ -483,6 +578,17 @@ static void pathSegmentsToString(StringBuilder out, List<String> pathSegments) {
     return result;
   }
 
+  /**
+   * Returns a list of path segments like {@code ["a", "b", "c"]} for the URL {@code
+   * http://host/a/b/c}. This list is never empty though it may contain a single empty string.
+   *
+   * <p><table summary="">
+   *   <tr><th>URL</th><th>{@code pathSegments()}</th></tr>
+   *   <tr><td>{@code http://host/}</td><td>{@code [""]}</td></tr>
+   *   <tr><td>{@code http://host/a/b/c"}</td><td>{@code ["a", "b", "c"]}</td></tr>
+   *   <tr><td>{@code http://host/a/b%20c/d"}</td><td>{@code ["a", "b c", "d"]}</td></tr>
+   * </table>
+   */
   public List<String> pathSegments() {
     return pathSegments;
   }
@@ -491,11 +597,21 @@ static void pathSegmentsToString(StringBuilder out, List<String> pathSegments) {
    * Returns the query of this URL, encoded for use in HTTP resource resolution. The returned string
    * may be null (for URLs with no query), empty (for URLs with an empty query) or non-empty (all
    * other URLs).
+   *
+   * <p><table summary="">
+   *   <tr><th>URL</th><th>{@code encodedQuery()}</th></tr>
+   *   <tr><td>{@code http://host/}</td><td>null</td></tr>
+   *   <tr><td>{@code http://host/?}</td><td>{@code ""}</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&k=key+lime}</td><td>{@code
+   *       "a=apple&k=key+lime"}</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&a=apricot}</td><td>{@code "a=apple&a=apricot"}</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&b}</td><td>{@code "a=apple&b"}</td></tr>
+   * </table>
    */
-  public String encodedQuery() {
+  public @Nullable String encodedQuery() {
     if (queryNamesAndValues == null) return null; // No query.
     int queryStart = url.indexOf('?') + 1;
-    int queryEnd = delimiterOffset(url, queryStart + 1, url.length(), '#');
+    int queryEnd = delimiterOffset(url, queryStart, url.length(), '#');
     return url.substring(queryStart, queryEnd);
   }
 
@@ -537,13 +653,42 @@ static void namesAndValuesToQueryString(StringBuilder out, List<String> namesAnd
     return result;
   }
 
-  public String query() {
+  /**
+   * Returns this URL's query, like {@code "abc"} for {@code http://host/?abc}. Most callers should
+   * prefer {@link #queryParameterName} and {@link #queryParameterValue} because these methods offer
+   * direct access to individual query parameters.
+   *
+   * <p><table summary="">
+   *   <tr><th>URL</th><th>{@code query()}</th></tr>
+   *   <tr><td>{@code http://host/}</td><td>null</td></tr>
+   *   <tr><td>{@code http://host/?}</td><td>{@code ""}</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&k=key+lime}</td><td>{@code "a=apple&k=key
+   *       lime"}</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&a=apricot}</td><td>{@code "a=apple&a=apricot"}</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&b}</td><td>{@code "a=apple&b"}</td></tr>
+   * </table>
+   */
+  public @Nullable String query() {
     if (queryNamesAndValues == null) return null; // No query.
     StringBuilder result = new StringBuilder();
     namesAndValuesToQueryString(result, queryNamesAndValues);
     return result.toString();
   }
 
+  /**
+   * Returns the number of query parameters in this URL, like 2 for {@code
+   * http://host/?a=apple&b=banana}. If this URL has no query this returns 0. Otherwise it returns
+   * one more than the number of {@code "&"} separators in the query.
+   *
+   * <p><table summary="">
+   *   <tr><th>URL</th><th>{@code querySize()}</th></tr>
+   *   <tr><td>{@code http://host/}</td><td>{@code 0}</td></tr>
+   *   <tr><td>{@code http://host/?}</td><td>{@code 1}</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&k=key+lime}</td><td>{@code 2}</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&a=apricot}</td><td>{@code 2}</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&b}</td><td>{@code 2}</td></tr>
+   * </table>
+   */
   public int querySize() {
     return queryNamesAndValues != null ? queryNamesAndValues.size() / 2 : 0;
   }
@@ -551,8 +696,17 @@ public int querySize() {
   /**
    * Returns the first query parameter named {@code name} decoded using UTF-8, or null if there is
    * no such query parameter.
+   *
+   * <p><table summary="">
+   *   <tr><th>URL</th><th>{@code queryParameter("a")}</th></tr>
+   *   <tr><td>{@code http://host/}</td><td>null</td></tr>
+   *   <tr><td>{@code http://host/?}</td><td>null</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&k=key+lime}</td><td>{@code "apple"}</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&a=apricot}</td><td>{@code "apple"}</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&b}</td><td>{@code "apple"}</td></tr>
+   * </table>
    */
-  public String queryParameter(String name) {
+  public @Nullable String queryParameter(String name) {
     if (queryNamesAndValues == null) return null;
     for (int i = 0, size = queryNamesAndValues.size(); i < size; i += 2) {
       if (name.equals(queryNamesAndValues.get(i))) {
@@ -562,6 +716,19 @@ public String queryParameter(String name) {
     return null;
   }
 
+  /**
+   * Returns the distinct query parameter names in this URL, like {@code ["a", "b"]} for {@code
+   * http://host/?a=apple&b=banana}. If this URL has no query this returns the empty set.
+   *
+   * <p><table summary="">
+   *   <tr><th>URL</th><th>{@code queryParameterNames()}</th></tr>
+   *   <tr><td>{@code http://host/}</td><td>{@code []}</td></tr>
+   *   <tr><td>{@code http://host/?}</td><td>{@code [""]}</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&k=key+lime}</td><td>{@code ["a", "k"]}</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&a=apricot}</td><td>{@code ["a"]}</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&b}</td><td>{@code ["a", "b"]}</td></tr>
+   * </table>
+   */
   public Set<String> queryParameterNames() {
     if (queryNamesAndValues == null) return Collections.emptySet();
     Set<String> result = new LinkedHashSet<>();
@@ -571,6 +738,24 @@ public String queryParameter(String name) {
     return Collections.unmodifiableSet(result);
   }
 
+  /**
+   * Returns all values for the query parameter {@code name} ordered by their appearance in this
+   * URL. For example this returns {@code ["banana"]} for {@code queryParameterValue("b")} on {@code
+   * http://host/?a=apple&b=banana}.
+   *
+   * <p><table summary="">
+   *   <tr><th>URL</th><th>{@code queryParameterValues("a")}</th><th>{@code
+   *       queryParameterValues("b")}</th></tr>
+   *   <tr><td>{@code http://host/}</td><td>{@code []}</td><td>{@code []}</td></tr>
+   *   <tr><td>{@code http://host/?}</td><td>{@code []}</td><td>{@code []}</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&k=key+lime}</td><td>{@code ["apple"]}</td><td>{@code
+   *       []}</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&a=apricot}</td><td>{@code ["apple",
+   *       "apricot"]}</td><td>{@code []}</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&b}</td><td>{@code ["apple"]}</td><td>{@code
+   *       [null]}</td></tr>
+   * </table>
+   */
   public List<String> queryParameterValues(String name) {
     if (queryNamesAndValues == null) return Collections.emptyList();
     List<String> result = new ArrayList<>();
@@ -582,29 +767,102 @@ public String queryParameter(String name) {
     return Collections.unmodifiableList(result);
   }
 
+  /**
+   * Returns the name of the query parameter at {@code index}. For example this returns {@code "a"}
+   * for {@code queryParameterName(0)} on {@code http://host/?a=apple&b=banana}. This throws if
+   * {@code index} is not less than the {@linkplain #querySize query size}.
+   *
+   * <p><table summary="">
+   *   <tr><th>URL</th><th>{@code queryParameterName(0)}</th><th>{@code
+   *       queryParameterName(1)}</th></tr>
+   *   <tr><td>{@code http://host/}</td><td>exception</td><td>exception</td></tr>
+   *   <tr><td>{@code http://host/?}</td><td>{@code ""}</td><td>exception</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&k=key+lime}</td><td>{@code "a"}</td><td>{@code
+   *       "k"}</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&a=apricot}</td><td>{@code "a"}</td><td>{@code
+   *       "a"}</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&b}</td><td>{@code "a"}</td><td>{@code "b"}</td></tr>
+   * </table>
+   */
   public String queryParameterName(int index) {
+    if (queryNamesAndValues == null) throw new IndexOutOfBoundsException();
     return queryNamesAndValues.get(index * 2);
   }
 
+  /**
+   * Returns the value of the query parameter at {@code index}. For example this returns {@code
+   * "apple"} for {@code queryParameterName(0)} on {@code http://host/?a=apple&b=banana}. This
+   * throws if {@code index} is not less than the {@linkplain #querySize query size}.
+   *
+   * <p><table summary="">
+   *   <tr><th>URL</th><th>{@code queryParameterValue(0)}</th><th>{@code
+   *       queryParameterValue(1)}</th></tr>
+   *   <tr><td>{@code http://host/}</td><td>exception</td><td>exception</td></tr>
+   *   <tr><td>{@code http://host/?}</td><td>null</td><td>exception</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&k=key+lime}</td><td>{@code "apple"}</td><td>{@code
+   *       "key lime"}</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&a=apricot}</td><td>{@code "apple"}</td><td>{@code
+   *       "apricot"}</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&b}</td><td>{@code "apple"}</td><td>null</td></tr>
+   * </table>
+   */
   public String queryParameterValue(int index) {
+    if (queryNamesAndValues == null) throw new IndexOutOfBoundsException();
     return queryNamesAndValues.get(index * 2 + 1);
   }
 
-  public String encodedFragment() {
+  /**
+   * Returns this URL's encoded fragment, like {@code "abc"} for {@code http://host/#abc}. This
+   * returns null if the URL has no fragment.
+   *
+   * <p><table summary="">
+   *   <tr><th>URL</th><th>{@code encodedFragment()}</th></tr>
+   *   <tr><td>{@code http://host/}</td><td>null</td></tr>
+   *   <tr><td>{@code http://host/#}</td><td>{@code ""}</td></tr>
+   *   <tr><td>{@code http://host/#abc}</td><td>{@code "abc"}</td></tr>
+   *   <tr><td>{@code http://host/#abc|def}</td><td>{@code "abc|def"}</td></tr>
+   * </table>
+   */
+  public @Nullable String encodedFragment() {
     if (fragment == null) return null;
     int fragmentStart = url.indexOf('#') + 1;
     return url.substring(fragmentStart);
   }
 
-  public String fragment() {
+  /**
+   * Returns this URL's fragment, like {@code "abc"} for {@code http://host/#abc}. This returns null
+   * if the URL has no fragment.
+   *
+   * <p><table summary="">
+   *   <tr><th>URL</th><th>{@code fragment()}</th></tr>
+   *   <tr><td>{@code http://host/}</td><td>null</td></tr>
+   *   <tr><td>{@code http://host/#}</td><td>{@code ""}</td></tr>
+   *   <tr><td>{@code http://host/#abc}</td><td>{@code "abc"}</td></tr>
+   *   <tr><td>{@code http://host/#abc|def}</td><td>{@code "abc|def"}</td></tr>
+   * </table>
+   */
+  public @Nullable String fragment() {
     return fragment;
   }
 
+  /**
+   * Returns a string with containing this URL with its username, password, query, and fragment
+   * stripped, and its path replaced with {@code /...}. For example, redacting {@code
+   * http://username:password@example.com/path} returns {@code http://example.com/...}.
+   */
+  public String redact() {
+    return newBuilder("/...")
+        .username("")
+        .password("")
+        .build()
+        .toString();
+  }
+
   /**
    * Returns the URL that would be retrieved by following {@code link} from this URL, or null if
    * the resulting URL is not well-formed.
    */
-  public HttpUrl resolve(String link) {
+  public @Nullable HttpUrl resolve(String link) {
     Builder builder = newBuilder(link);
     return builder != null ? builder.build() : null;
   }
@@ -628,7 +886,7 @@ public Builder newBuilder() {
    * Returns a builder for the URL that would be retrieved by following {@code link} from this URL,
    * or null if the resulting URL is not well-formed.
    */
-  public Builder newBuilder(String link) {
+  public @Nullable Builder newBuilder(String link) {
     Builder builder = new Builder();
     Builder.ParseResult result = builder.parse(this, link);
     return result == Builder.ParseResult.SUCCESS ? builder : null;
@@ -638,7 +896,7 @@ public Builder newBuilder(String link) {
    * Returns a new {@code HttpUrl} representing {@code url} if it is a well-formed HTTP or HTTPS
    * URL, or null if it isn't.
    */
-  public static HttpUrl parse(String url) {
+  public static @Nullable HttpUrl parse(String url) {
     Builder builder = new Builder();
     Builder.ParseResult result = builder.parse(null, url);
     return result == Builder.ParseResult.SUCCESS ? builder.build() : null;
@@ -648,7 +906,7 @@ public static HttpUrl parse(String url) {
    * Returns an {@link HttpUrl} for {@code url} if its protocol is {@code http} or {@code https}, or
    * null if it has any other protocol.
    */
-  public static HttpUrl get(URL url) {
+  public static @Nullable HttpUrl get(URL url) {
     return parse(url.toString());
   }
 
@@ -675,12 +933,12 @@ static HttpUrl getChecked(String url) throws MalformedURLException, UnknownHostE
     }
   }
 
-  public static HttpUrl get(URI uri) {
+  public static @Nullable HttpUrl get(URI uri) {
     return parse(uri.toString());
   }
 
-  @Override public boolean equals(Object o) {
-    return o instanceof HttpUrl && ((HttpUrl) o).url.equals(url);
+  @Override public boolean equals(@Nullable Object other) {
+    return other instanceof HttpUrl && ((HttpUrl) other).url.equals(url);
   }
 
   @Override public int hashCode() {
@@ -691,15 +949,39 @@ public static HttpUrl get(URI uri) {
     return url;
   }
 
+  /**
+   * Returns the domain name of this URL's {@link #host()} that is one level beneath the public
+   * suffix by consulting the <a href="https://publicsuffix.org">public suffix list</a>. Returns
+   * null if this URL's {@link #host()} is an IP address or is considered a public suffix by the
+   * public suffix list.
+   *
+   * <p>In general this method <strong>should not</strong> be used to test whether a domain is valid
+   * or routable. Instead, DNS is the recommended source for that information.
+   *
+   * <p><table summary="">
+   *   <tr><th>URL</th><th>{@code topPrivateDomain()}</th></tr>
+   *   <tr><td>{@code http://google.com}</td><td>{@code "google.com"}</td></tr>
+   *   <tr><td>{@code http://adwords.google.co.uk}</td><td>{@code "google.co.uk"}</td></tr>
+   *   <tr><td>{@code http://square}</td><td>null</td></tr>
+   *   <tr><td>{@code http://co.uk}</td><td>null</td></tr>
+   *   <tr><td>{@code http://localhost}</td><td>null</td></tr>
+   *   <tr><td>{@code http://127.0.0.1}</td><td>null</td></tr>
+   * </table>
+   */
+  public @Nullable String topPrivateDomain() {
+    if (verifyAsIpAddress(host)) return null;
+    return PublicSuffixDatabase.get().getEffectiveTldPlusOne(host);
+  }
+
   public static final class Builder {
-    String scheme;
+    @Nullable String scheme;
     String encodedUsername = "";
     String encodedPassword = "";
-    String host;
+    @Nullable String host;
     int port = -1;
     final List<String> encodedPathSegments = new ArrayList<>();
-    List<String> encodedQueryNamesAndValues;
-    String encodedFragment;
+    @Nullable List<String> encodedQueryNamesAndValues;
+    @Nullable String encodedFragment;
 
     public Builder() {
       encodedPathSegments.add(""); // The default path is '/' which needs a trailing space.
@@ -815,7 +1097,8 @@ private Builder addPathSegments(String pathSegments, boolean alreadyEncoded) {
     public Builder setPathSegment(int index, String pathSegment) {
       if (pathSegment == null) throw new NullPointerException("pathSegment == null");
       String canonicalPathSegment = canonicalize(
-          pathSegment, 0, pathSegment.length(), PATH_SEGMENT_ENCODE_SET, false, false, false, true);
+          pathSegment, 0, pathSegment.length(), PATH_SEGMENT_ENCODE_SET, false, false, false, true,
+              null);
       if (isDot(canonicalPathSegment) || isDotDot(canonicalPathSegment)) {
         throw new IllegalArgumentException("unexpected path segment: " + pathSegment);
       }
@@ -828,7 +1111,8 @@ public Builder setEncodedPathSegment(int index, String encodedPathSegment) {
         throw new NullPointerException("encodedPathSegment == null");
       }
       String canonicalPathSegment = canonicalize(encodedPathSegment,
-          0, encodedPathSegment.length(), PATH_SEGMENT_ENCODE_SET, true, false, false, true);
+          0, encodedPathSegment.length(), PATH_SEGMENT_ENCODE_SET, true, false, false, true,
+          null);
       encodedPathSegments.set(index, canonicalPathSegment);
       if (isDot(canonicalPathSegment) || isDotDot(canonicalPathSegment)) {
         throw new IllegalArgumentException("unexpected path segment: " + encodedPathSegment);
@@ -853,7 +1137,7 @@ public Builder encodedPath(String encodedPath) {
       return this;
     }
 
-    public Builder query(String query) {
+    public Builder query(@Nullable String query) {
       this.encodedQueryNamesAndValues = query != null
           ? queryStringToNamesAndValues(canonicalize(
           query, QUERY_ENCODE_SET, false, false, true, true))
@@ -861,7 +1145,7 @@ public Builder query(String query) {
       return this;
     }
 
-    public Builder encodedQuery(String encodedQuery) {
+    public Builder encodedQuery(@Nullable String encodedQuery) {
       this.encodedQueryNamesAndValues = encodedQuery != null
           ? queryStringToNamesAndValues(
           canonicalize(encodedQuery, QUERY_ENCODE_SET, true, false, true, true))
@@ -870,7 +1154,7 @@ public Builder encodedQuery(String encodedQuery) {
     }
 
     /** Encodes the query parameter using UTF-8 and adds it to this URL's query string. */
-    public Builder addQueryParameter(String name, String value) {
+    public Builder addQueryParameter(String name, @Nullable String value) {
       if (name == null) throw new NullPointerException("name == null");
       if (encodedQueryNamesAndValues == null) encodedQueryNamesAndValues = new ArrayList<>();
       encodedQueryNamesAndValues.add(
@@ -882,7 +1166,7 @@ public Builder addQueryParameter(String name, String value) {
     }
 
     /** Adds the pre-encoded query parameter to this URL's query string. */
-    public Builder addEncodedQueryParameter(String encodedName, String encodedValue) {
+    public Builder addEncodedQueryParameter(String encodedName, @Nullable String encodedValue) {
       if (encodedName == null) throw new NullPointerException("encodedName == null");
       if (encodedQueryNamesAndValues == null) encodedQueryNamesAndValues = new ArrayList<>();
       encodedQueryNamesAndValues.add(
@@ -893,13 +1177,13 @@ public Builder addEncodedQueryParameter(String encodedName, String encodedValue)
       return this;
     }
 
-    public Builder setQueryParameter(String name, String value) {
+    public Builder setQueryParameter(String name, @Nullable String value) {
       removeAllQueryParameters(name);
       addQueryParameter(name, value);
       return this;
     }
 
-    public Builder setEncodedQueryParameter(String encodedName, String encodedValue) {
+    public Builder setEncodedQueryParameter(String encodedName, @Nullable String encodedValue) {
       removeAllEncodedQueryParameters(encodedName);
       addEncodedQueryParameter(encodedName, encodedValue);
       return this;
@@ -935,14 +1219,14 @@ private void removeAllCanonicalQueryParameters(String canonicalName) {
       }
     }
 
-    public Builder fragment(String fragment) {
+    public Builder fragment(@Nullable String fragment) {
       this.encodedFragment = fragment != null
           ? canonicalize(fragment, FRAGMENT_ENCODE_SET, false, false, false, false)
           : null;
       return this;
     }
 
-    public Builder encodedFragment(String encodedFragment) {
+    public Builder encodedFragment(@Nullable String encodedFragment) {
       this.encodedFragment = encodedFragment != null
           ? canonicalize(encodedFragment, FRAGMENT_ENCODE_SET, true, false, false, false)
           : null;
@@ -1033,7 +1317,7 @@ public HttpUrl build() {
       INVALID_HOST,
     }
 
-    ParseResult parse(HttpUrl base, String input) {
+    ParseResult parse(@Nullable HttpUrl base, String input) {
       int pos = skipLeadingAsciiWhitespace(input, 0, input.length());
       int limit = skipTrailingAsciiWhitespace(input, pos, input.length());
 
@@ -1083,19 +1367,22 @@ ParseResult parse(HttpUrl base, String input) {
                 int passwordColonOffset = delimiterOffset(
                     input, pos, componentDelimiterOffset, ':');
                 String canonicalUsername = canonicalize(
-                    input, pos, passwordColonOffset, USERNAME_ENCODE_SET, true, false, false, true);
+                    input, pos, passwordColonOffset, USERNAME_ENCODE_SET, true, false, false, true,
+                    null);
                 this.encodedUsername = hasUsername
                     ? this.encodedUsername + "%40" + canonicalUsername
                     : canonicalUsername;
                 if (passwordColonOffset != componentDelimiterOffset) {
                   hasPassword = true;
                   this.encodedPassword = canonicalize(input, passwordColonOffset + 1,
-                      componentDelimiterOffset, PASSWORD_ENCODE_SET, true, false, false, true);
+                      componentDelimiterOffset, PASSWORD_ENCODE_SET, true, false, false, true,
+                      null);
                 }
                 hasUsername = true;
               } else {
                 this.encodedPassword = this.encodedPassword + "%40" + canonicalize(input, pos,
-                    componentDelimiterOffset, PASSWORD_ENCODE_SET, true, false, false, true);
+                    componentDelimiterOffset, PASSWORD_ENCODE_SET, true, false, false, true,
+                    null);
               }
               pos = componentDelimiterOffset + 1;
               break;
@@ -1142,14 +1429,14 @@ ParseResult parse(HttpUrl base, String input) {
       if (pos < limit && input.charAt(pos) == '?') {
         int queryDelimiterOffset = delimiterOffset(input, pos, limit, '#');
         this.encodedQueryNamesAndValues = queryStringToNamesAndValues(canonicalize(
-            input, pos + 1, queryDelimiterOffset, QUERY_ENCODE_SET, true, false, true, true));
+            input, pos + 1, queryDelimiterOffset, QUERY_ENCODE_SET, true, false, true, true, null));
         pos = queryDelimiterOffset;
       }
 
       // Fragment.
       if (pos < limit && input.charAt(pos) == '#') {
         this.encodedFragment = canonicalize(
-            input, pos + 1, limit, FRAGMENT_ENCODE_SET, true, false, false, false);
+            input, pos + 1, limit, FRAGMENT_ENCODE_SET, true, false, false, false, null);
       }
 
       return ParseResult.SUCCESS;
@@ -1186,7 +1473,7 @@ private void resolvePath(String input, int pos, int limit) {
     private void push(String input, int pos, int limit, boolean addTrailingSlash,
         boolean alreadyEncoded) {
       String segment = canonicalize(
-          input, pos, limit, PATH_SEGMENT_ENCODE_SET, alreadyEncoded, false, false, true);
+          input, pos, limit, PATH_SEGMENT_ENCODE_SET, alreadyEncoded, false, false, true, null);
       if (isDot(segment)) {
         return; // Skip '.' path segments.
       }
@@ -1301,165 +1588,13 @@ private static String canonicalizeHost(String input, int pos, int limit) {
       // Start by percent decoding the host. The WHATWG spec suggests doing this only after we've
       // checked for IPv6 square braces. But Chrome does it first, and that's more lenient.
       String percentDecoded = percentDecode(input, pos, limit, false);
-
-      // If the input contains a :, it’s an IPv6 address.
-      if (percentDecoded.contains(":")) {
-        // If the input is encased in square braces "[...]", drop 'em.
-        InetAddress inetAddress = percentDecoded.startsWith("[") && percentDecoded.endsWith("]")
-            ? decodeIpv6(percentDecoded, 1, percentDecoded.length() - 1)
-            : decodeIpv6(percentDecoded, 0, percentDecoded.length());
-        if (inetAddress == null) return null;
-        byte[] address = inetAddress.getAddress();
-        if (address.length == 16) return inet6AddressToAscii(address);
-        throw new AssertionError();
-      }
-
-      return domainToAscii(percentDecoded);
-    }
-
-    /** Decodes an IPv6 address like 1111:2222:3333:4444:5555:6666:7777:8888 or ::1. */
-    private static InetAddress decodeIpv6(String input, int pos, int limit) {
-      byte[] address = new byte[16];
-      int b = 0;
-      int compress = -1;
-      int groupOffset = -1;
-
-      for (int i = pos; i < limit; ) {
-        if (b == address.length) return null; // Too many groups.
-
-        // Read a delimiter.
-        if (i + 2 <= limit && input.regionMatches(i, "::", 0, 2)) {
-          // Compression "::" delimiter, which is anywhere in the input, including its prefix.
-          if (compress != -1) return null; // Multiple "::" delimiters.
-          i += 2;
-          b += 2;
-          compress = b;
-          if (i == limit) break;
-        } else if (b != 0) {
-          // Group separator ":" delimiter.
-          if (input.regionMatches(i, ":", 0, 1)) {
-            i++;
-          } else if (input.regionMatches(i, ".", 0, 1)) {
-            // If we see a '.', rewind to the beginning of the previous group and parse as IPv4.
-            if (!decodeIpv4Suffix(input, groupOffset, limit, address, b - 2)) return null;
-            b += 2; // We rewound two bytes and then added four.
-            break;
-          } else {
-            return null; // Wrong delimiter.
-          }
-        }
-
-        // Read a group, one to four hex digits.
-        int value = 0;
-        groupOffset = i;
-        for (; i < limit; i++) {
-          char c = input.charAt(i);
-          int hexDigit = decodeHexDigit(c);
-          if (hexDigit == -1) break;
-          value = (value << 4) + hexDigit;
-        }
-        int groupLength = i - groupOffset;
-        if (groupLength == 0 || groupLength > 4) return null; // Group is the wrong size.
-
-        // We've successfully read a group. Assign its value to our byte array.
-        address[b++] = (byte) ((value >>> 8) & 0xff);
-        address[b++] = (byte) (value & 0xff);
-      }
-
-      // All done. If compression happened, we need to move bytes to the right place in the
-      // address. Here's a sample:
-      //
-      //      input: "1111:2222:3333::7777:8888"
-      //     before: { 11, 11, 22, 22, 33, 33, 00, 00, 77, 77, 88, 88, 00, 00, 00, 00  }
-      //   compress: 6
-      //          b: 10
-      //      after: { 11, 11, 22, 22, 33, 33, 00, 00, 00, 00, 00, 00, 77, 77, 88, 88 }
-      //
-      if (b != address.length) {
-        if (compress == -1) return null; // Address didn't have compression or enough groups.
-        System.arraycopy(address, compress, address, address.length - (b - compress), b - compress);
-        Arrays.fill(address, compress, compress + (address.length - b), (byte) 0);
-      }
-
-      try {
-        return InetAddress.getByAddress(address);
-      } catch (UnknownHostException e) {
-        throw new AssertionError();
-      }
-    }
-
-    /** Decodes an IPv4 address suffix of an IPv6 address, like 1111::5555:6666:192.168.0.1. */
-    private static boolean decodeIpv4Suffix(
-        String input, int pos, int limit, byte[] address, int addressOffset) {
-      int b = addressOffset;
-
-      for (int i = pos; i < limit; ) {
-        if (b == address.length) return false; // Too many groups.
-
-        // Read a delimiter.
-        if (b != addressOffset) {
-          if (input.charAt(i) != '.') return false; // Wrong delimiter.
-          i++;
-        }
-
-        // Read 1 or more decimal digits for a value in 0..255.
-        int value = 0;
-        int groupOffset = i;
-        for (; i < limit; i++) {
-          char c = input.charAt(i);
-          if (c < '0' || c > '9') break;
-          if (value == 0 && groupOffset != i) return false; // Reject unnecessary leading '0's.
-          value = (value * 10) + c - '0';
-          if (value > 255) return false; // Value out of range.
-        }
-        int groupLength = i - groupOffset;
-        if (groupLength == 0) return false; // No digits.
-
-        // We've successfully read a byte.
-        address[b++] = (byte) value;
-      }
-
-      if (b != addressOffset + 4) return false; // Too few groups. We wanted exactly four.
-      return true; // Success.
-    }
-
-    private static String inet6AddressToAscii(byte[] address) {
-      // Go through the address looking for the longest run of 0s. Each group is 2-bytes.
-      int longestRunOffset = -1;
-      int longestRunLength = 0;
-      for (int i = 0; i < address.length; i += 2) {
-        int currentRunOffset = i;
-        while (i < 16 && address[i] == 0 && address[i + 1] == 0) {
-          i += 2;
-        }
-        int currentRunLength = i - currentRunOffset;
-        if (currentRunLength > longestRunLength) {
-          longestRunOffset = currentRunOffset;
-          longestRunLength = currentRunLength;
-        }
-      }
-
-      // Emit each 2-byte group in hex, separated by ':'. The longest run of zeroes is "::".
-      Buffer result = new Buffer();
-      for (int i = 0; i < address.length; ) {
-        if (i == longestRunOffset) {
-          result.writeByte(':');
-          i += longestRunLength;
-          if (i == 16) result.writeByte(':');
-        } else {
-          if (i > 0) result.writeByte(':');
-          int group = (address[i] & 0xff) << 8 | address[i + 1] & 0xff;
-          result.writeHexadecimalUnsignedLong(group);
-          i += 2;
-        }
-      }
-      return result.readUtf8();
+      return Util.canonicalizeHost(percentDecoded);
     }
 
     private static int parsePort(String input, int pos, int limit) {
       try {
         // Canonicalize the port string to skip '\n' etc.
-        String portString = canonicalize(input, pos, limit, "", false, false, false, true);
+        String portString = canonicalize(input, pos, limit, "", false, false, false, true, null);
         int i = Integer.parseInt(portString);
         if (i > 0 && i <= 65535) return i;
         return -1;
@@ -1474,8 +1609,10 @@ static String percentDecode(String encoded, boolean plusIsSpace) {
   }
 
   private List<String> percentDecode(List<String> list, boolean plusIsSpace) {
-    List<String> result = new ArrayList<>(list.size());
-    for (String s : list) {
+    int size = list.size();
+    List<String> result = new ArrayList<>(size);
+    for (int i = 0; i < size; i++) {
+      String s = list.get(i);
       result.add(s != null ? percentDecode(s, plusIsSpace) : null);
     }
     return Collections.unmodifiableList(result);
@@ -1524,13 +1661,6 @@ static boolean percentEncoded(String encoded, int pos, int limit) {
         && decodeHexDigit(encoded.charAt(pos + 2)) != -1;
   }
 
-  static int decodeHexDigit(char c) {
-    if (c >= '0' && c <= '9') return c - '0';
-    if (c >= 'a' && c <= 'f') return c - 'a' + 10;
-    if (c >= 'A' && c <= 'F') return c - 'A' + 10;
-    return -1;
-  }
-
   /**
    * Returns a substring of {@code input} on the range {@code [pos..limit)} with the following
    * transformations:
@@ -1546,9 +1676,11 @@ static int decodeHexDigit(char c) {
    * @param strict true to encode '%' if it is not the prefix of a valid percent encoding.
    * @param plusIsSpace true to encode '+' as "%2B" if it is not already encoded.
    * @param asciiOnly true to encode all non-ASCII codepoints.
+   * @param charset which charset to use, null equals UTF-8.
    */
   static String canonicalize(String input, int pos, int limit, String encodeSet,
-      boolean alreadyEncoded, boolean strict, boolean plusIsSpace, boolean asciiOnly) {
+      boolean alreadyEncoded, boolean strict, boolean plusIsSpace, boolean asciiOnly,
+      Charset charset) {
     int codePoint;
     for (int i = pos; i < limit; i += Character.charCount(codePoint)) {
       codePoint = input.codePointAt(i);
@@ -1562,7 +1694,7 @@ static String canonicalize(String input, int pos, int limit, String encodeSet,
         Buffer out = new Buffer();
         out.writeUtf8(input, pos, i);
         canonicalize(out, input, i, limit, encodeSet, alreadyEncoded, strict, plusIsSpace,
-            asciiOnly);
+            asciiOnly, charset);
         return out.readUtf8();
       }
     }
@@ -1572,8 +1704,9 @@ static String canonicalize(String input, int pos, int limit, String encodeSet,
   }
 
   static void canonicalize(Buffer out, String input, int pos, int limit, String encodeSet,
-      boolean alreadyEncoded, boolean strict, boolean plusIsSpace, boolean asciiOnly) {
-    Buffer utf8Buffer = null; // Lazily allocated.
+      boolean alreadyEncoded, boolean strict, boolean plusIsSpace, boolean asciiOnly,
+      Charset charset) {
+    Buffer encodedCharBuffer = null; // Lazily allocated.
     int codePoint;
     for (int i = pos; i < limit; i += Character.charCount(codePoint)) {
       codePoint = input.codePointAt(i);
@@ -1589,12 +1722,18 @@ static void canonicalize(Buffer out, String input, int pos, int limit, String en
           || encodeSet.indexOf(codePoint) != -1
           || codePoint == '%' && (!alreadyEncoded || strict && !percentEncoded(input, i, limit))) {
         // Percent encode this character.
-        if (utf8Buffer == null) {
-          utf8Buffer = new Buffer();
+        if (encodedCharBuffer == null) {
+          encodedCharBuffer = new Buffer();
+        }
+
+        if (charset == null || charset.equals(Util.UTF_8)) {
+          encodedCharBuffer.writeUtf8CodePoint(codePoint);
+        } else {
+          encodedCharBuffer.writeString(input, i, i + Character.charCount(codePoint), charset);
         }
-        utf8Buffer.writeUtf8CodePoint(codePoint);
-        while (!utf8Buffer.exhausted()) {
-          int b = utf8Buffer.readByte() & 0xff;
+
+        while (!encodedCharBuffer.exhausted()) {
+          int b = encodedCharBuffer.readByte() & 0xff;
           out.writeByte('%');
           out.writeByte(HEX_DIGITS[(b >> 4) & 0xf]);
           out.writeByte(HEX_DIGITS[b & 0xf]);
@@ -1607,8 +1746,15 @@ static void canonicalize(Buffer out, String input, int pos, int limit, String en
   }
 
   static String canonicalize(String input, String encodeSet, boolean alreadyEncoded, boolean strict,
-      boolean plusIsSpace, boolean asciiOnly) {
+      boolean plusIsSpace, boolean asciiOnly, Charset charset) {
     return canonicalize(
-        input, 0, input.length(), encodeSet, alreadyEncoded, strict, plusIsSpace, asciiOnly);
+        input, 0, input.length(), encodeSet, alreadyEncoded, strict, plusIsSpace, asciiOnly,
+            charset);
+  }
+
+  static String canonicalize(String input, String encodeSet, boolean alreadyEncoded, boolean strict,
+      boolean plusIsSpace, boolean asciiOnly) {
+   return canonicalize(
+        input, 0, input.length(), encodeSet, alreadyEncoded, strict, plusIsSpace, asciiOnly, null);
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/Interceptor.java b/okhttp/src/main/java/okhttp3/Interceptor.java
index c1f8840a3c..1005592697 100644
--- a/okhttp/src/main/java/okhttp3/Interceptor.java
+++ b/okhttp/src/main/java/okhttp3/Interceptor.java
@@ -16,6 +16,8 @@
 package okhttp3;
 
 import java.io.IOException;
+import java.util.concurrent.TimeUnit;
+import javax.annotation.Nullable;
 
 /**
  * Observes, modifies, and potentially short-circuits requests going out and the corresponding
@@ -30,6 +32,24 @@
 
     Response proceed(Request request) throws IOException;
 
-    Connection connection();
+    /**
+     * Returns the connection the request will be executed on. This is only available in the chains
+     * of network interceptors; for application interceptors this is always null.
+     */
+    @Nullable Connection connection();
+
+    Call call();
+
+    int connectTimeoutMillis();
+
+    Chain withConnectTimeout(int timeout, TimeUnit unit);
+
+    int readTimeoutMillis();
+
+    Chain withReadTimeout(int timeout, TimeUnit unit);
+
+    int writeTimeoutMillis();
+
+    Chain withWriteTimeout(int timeout, TimeUnit unit);
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/MediaType.java b/okhttp/src/main/java/okhttp3/MediaType.java
index bbdcedf686..95194c5711 100644
--- a/okhttp/src/main/java/okhttp3/MediaType.java
+++ b/okhttp/src/main/java/okhttp3/MediaType.java
@@ -19,6 +19,7 @@
 import java.util.Locale;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
+import javax.annotation.Nullable;
 
 /**
  * An <a href="http://tools.ietf.org/html/rfc2045">RFC 2045</a> Media Type, appropriate to describe
@@ -34,9 +35,9 @@
   private final String mediaType;
   private final String type;
   private final String subtype;
-  private final String charset;
+  private final @Nullable String charset;
 
-  private MediaType(String mediaType, String type, String subtype, String charset) {
+  private MediaType(String mediaType, String type, String subtype, @Nullable String charset) {
     this.mediaType = mediaType;
     this.type = type;
     this.subtype = subtype;
@@ -47,7 +48,7 @@ private MediaType(String mediaType, String type, String subtype, String charset)
    * Returns a media type for {@code string}, or null if {@code string} is not a well-formed media
    * type.
    */
-  public static MediaType parse(String string) {
+  public static @Nullable MediaType parse(String string) {
     Matcher typeSubtype = TYPE_SUBTYPE.matcher(string);
     if (!typeSubtype.lookingAt()) return null;
     String type = typeSubtype.group(1).toLowerCase(Locale.US);
@@ -61,11 +62,19 @@ public static MediaType parse(String string) {
 
       String name = parameter.group(1);
       if (name == null || !name.equalsIgnoreCase("charset")) continue;
-      String charsetParameter = parameter.group(2) != null
-          ? parameter.group(2)  // Value is a token.
-          : parameter.group(3); // Value is a quoted string.
+      String charsetParameter;
+      String token = parameter.group(2);
+      if (token != null) {
+        // If the token is 'single-quoted' it's invalid! But we're lenient and strip the quotes.
+        charsetParameter = (token.startsWith("'") && token.endsWith("'") && token.length() > 2)
+            ? token.substring(1, token.length() - 1)
+            : token;
+      } else {
+        // Value is "double-quoted". That's valid and our regex group already strips the quotes.
+        charsetParameter = parameter.group(3);
+      }
       if (charset != null && !charsetParameter.equalsIgnoreCase(charset)) {
-        throw new IllegalArgumentException("Multiple different charsets: " + string);
+        return null; // Multiple different charsets!
       }
       charset = charsetParameter;
     }
@@ -91,16 +100,20 @@ public String subtype() {
   /**
    * Returns the charset of this media type, or null if this media type doesn't specify a charset.
    */
-  public Charset charset() {
-    return charset != null ? Charset.forName(charset) : null;
+  public @Nullable Charset charset() {
+    return charset(null);
   }
 
   /**
-   * Returns the charset of this media type, or {@code defaultValue} if this media type doesn't
-   * specify a charset.
+   * Returns the charset of this media type, or {@code defaultValue} if either this media type
+   * doesn't specify a charset, of it its charset is unsupported by the current runtime.
    */
-  public Charset charset(Charset defaultValue) {
-    return charset != null ? Charset.forName(charset) : defaultValue;
+  public @Nullable Charset charset(@Nullable Charset defaultValue) {
+    try {
+      return charset != null ? Charset.forName(charset) : defaultValue;
+    } catch (IllegalArgumentException e) {
+      return defaultValue; // This charset is invalid or unsupported. Give up.
+    }
   }
 
   /**
@@ -111,8 +124,8 @@ public Charset charset(Charset defaultValue) {
     return mediaType;
   }
 
-  @Override public boolean equals(Object o) {
-    return o instanceof MediaType && ((MediaType) o).mediaType.equals(mediaType);
+  @Override public boolean equals(@Nullable Object other) {
+    return other instanceof MediaType && ((MediaType) other).mediaType.equals(mediaType);
   }
 
   @Override public int hashCode() {
diff --git a/okhttp/src/main/java/okhttp3/MultipartBody.java b/okhttp/src/main/java/okhttp3/MultipartBody.java
index 7ac584d1d9..09c1eaf2fe 100644
--- a/okhttp/src/main/java/okhttp3/MultipartBody.java
+++ b/okhttp/src/main/java/okhttp3/MultipartBody.java
@@ -19,6 +19,7 @@
 import java.util.ArrayList;
 import java.util.List;
 import java.util.UUID;
+import javax.annotation.Nullable;
 import okhttp3.internal.Util;
 import okio.Buffer;
 import okio.BufferedSink;
@@ -119,7 +120,8 @@ public Part part(int index) {
    * to awkward operations like measuring the encoded length of header strings, or the
    * length-in-digits of an encoded integer.
    */
-  private long writeOrCountBytes(BufferedSink sink, boolean countBytes) throws IOException {
+  private long writeOrCountBytes(
+      @Nullable BufferedSink sink, boolean countBytes) throws IOException {
     long byteCount = 0L;
 
     Buffer byteCountBuffer = null;
@@ -225,7 +227,7 @@ public static Part create(RequestBody body) {
       return create(null, body);
     }
 
-    public static Part create(Headers headers, RequestBody body) {
+    public static Part create(@Nullable Headers headers, RequestBody body) {
       if (body == null) {
         throw new NullPointerException("body == null");
       }
@@ -242,7 +244,7 @@ public static Part createFormData(String name, String value) {
       return createFormData(name, null, RequestBody.create(null, value));
     }
 
-    public static Part createFormData(String name, String filename, RequestBody body) {
+    public static Part createFormData(String name, @Nullable String filename, RequestBody body) {
       if (name == null) {
         throw new NullPointerException("name == null");
       }
@@ -257,13 +259,21 @@ public static Part createFormData(String name, String filename, RequestBody body
       return create(Headers.of("Content-Disposition", disposition.toString()), body);
     }
 
-    private final Headers headers;
-    private final RequestBody body;
+    final @Nullable Headers headers;
+    final RequestBody body;
 
-    private Part(Headers headers, RequestBody body) {
+    private Part(@Nullable Headers headers, RequestBody body) {
       this.headers = headers;
       this.body = body;
     }
+
+    public @Nullable Headers headers() {
+      return headers;
+    }
+
+    public RequestBody body() {
+      return body;
+    }
   }
 
   public static final class Builder {
@@ -300,7 +310,7 @@ public Builder addPart(RequestBody body) {
     }
 
     /** Add a part to the body. */
-    public Builder addPart(Headers headers, RequestBody body) {
+    public Builder addPart(@Nullable Headers headers, RequestBody body) {
       return addPart(Part.create(headers, body));
     }
 
@@ -310,7 +320,7 @@ public Builder addFormDataPart(String name, String value) {
     }
 
     /** Add a form data part to the body. */
-    public Builder addFormDataPart(String name, String filename, RequestBody body) {
+    public Builder addFormDataPart(String name, @Nullable String filename, RequestBody body) {
       return addPart(Part.createFormData(name, filename, body));
     }
 
diff --git a/okhttp/src/main/java/okhttp3/OkHttpClient.java b/okhttp/src/main/java/okhttp3/OkHttpClient.java
index b23e6a2212..476651696e 100644
--- a/okhttp/src/main/java/okhttp3/OkHttpClient.java
+++ b/okhttp/src/main/java/okhttp3/OkHttpClient.java
@@ -18,13 +18,18 @@
 import java.net.MalformedURLException;
 import java.net.Proxy;
 import java.net.ProxySelector;
+import java.net.Socket;
 import java.net.UnknownHostException;
 import java.security.GeneralSecurityException;
 import java.security.KeyStore;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.List;
+import java.util.Random;
+import java.util.concurrent.ExecutorService;
 import java.util.concurrent.TimeUnit;
+import javax.annotation.Nullable;
 import javax.net.SocketFactory;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLContext;
@@ -34,47 +39,99 @@
 import javax.net.ssl.TrustManagerFactory;
 import javax.net.ssl.X509TrustManager;
 import okhttp3.internal.Internal;
-import okhttp3.internal.InternalCache;
-import okhttp3.internal.Platform;
-import okhttp3.internal.RouteDatabase;
 import okhttp3.internal.Util;
-import okhttp3.internal.http.StreamAllocation;
-import okhttp3.internal.io.RealConnection;
+import okhttp3.internal.cache.InternalCache;
+import okhttp3.internal.connection.RealConnection;
+import okhttp3.internal.connection.RouteDatabase;
+import okhttp3.internal.connection.StreamAllocation;
+import okhttp3.internal.platform.Platform;
 import okhttp3.internal.tls.CertificateChainCleaner;
 import okhttp3.internal.tls.OkHostnameVerifier;
+import okhttp3.internal.ws.RealWebSocket;
+import okio.Sink;
+import okio.Source;
+
+import static okhttp3.internal.Util.assertionError;
+import static okhttp3.internal.Util.checkDuration;
 
 /**
  * Factory for {@linkplain Call calls}, which can be used to send HTTP requests and read their
- * responses. Most applications can use a single OkHttpClient for all of their HTTP requests,
- * benefiting from a shared response cache, thread pool, connection re-use, etc.
+ * responses.
+ *
+ * <h3>OkHttpClients should be shared</h3>
+ *
+ * <p>OkHttp performs best when you create a single {@code OkHttpClient} instance and reuse it for
+ * all of your HTTP calls. This is because each client holds its own connection pool and thread
+ * pools. Reusing connections and threads reduces latency and saves memory. Conversely, creating a
+ * client for each request wastes resources on idle pools.
  *
- * <p>To create an {@code OkHttpClient} with the default settings, use the {@linkplain
- * #OkHttpClient() default constructor}. Or create a configured instance with {@link
- * OkHttpClient.Builder}. To adjust an existing client before making a request, use {@link
- * #newBuilder()}. This example shows a call with a 30 second timeout:
+ * <p>Use {@code new OkHttpClient()} to create a shared instance with the default settings:
  * <pre>   {@code
  *
- *   OkHttpClient client = ...
- *   OkHttpClient clientWith30sTimeout = client.newBuilder()
- *       .readTimeout(30, TimeUnit.SECONDS)
+ *   // The singleton HTTP client.
+ *   public final OkHttpClient client = new OkHttpClient();
+ * }</pre>
+ *
+ * <p>Or use {@code new OkHttpClient.Builder()} to create a shared instance with custom settings:
+ * <pre>   {@code
+ *
+ *   // The singleton HTTP client.
+ *   public final OkHttpClient client = new OkHttpClient.Builder()
+ *       .addInterceptor(new HttpLoggingInterceptor())
+ *       .cache(new Cache(cacheDir, cacheSize))
  *       .build();
- *   Response response = clientWith30sTimeout.newCall(request).execute();
  * }</pre>
+ *
+ * <h3>Customize your client with newBuilder()</h3>
+ *
+ * <p>You can customize a shared OkHttpClient instance with {@link #newBuilder()}. This builds a
+ * client that shares the same connection pool, thread pools, and configuration. Use the builder
+ * methods to configure the derived client for a specific purpose.
+ *
+ * <p>This example shows a call with a short 500 millisecond timeout: <pre>   {@code
+ *
+ *   OkHttpClient eagerClient = client.newBuilder()
+ *       .readTimeout(500, TimeUnit.MILLISECONDS)
+ *       .build();
+ *   Response response = eagerClient.newCall(request).execute();
+ * }</pre>
+ *
+ * <h3>Shutdown isn't necessary</h3>
+ *
+ * <p>The threads and connections that are held will be released automatically if they remain idle.
+ * But if you are writing a application that needs to aggressively release unused resources you may
+ * do so.
+ *
+ * <p>Shutdown the dispatcher's executor service with {@link ExecutorService#shutdown shutdown()}.
+ * This will also cause future calls to the client to be rejected. <pre>   {@code
+ *
+ *     client.dispatcher().executorService().shutdown();
+ * }</pre>
+ *
+ * <p>Clear the connection pool with {@link ConnectionPool#evictAll() evictAll()}. Note that the
+ * connection pool's daemon thread may not exit immediately. <pre>   {@code
+ *
+ *     client.connectionPool().evictAll();
+ * }</pre>
+ *
+ * <p>If your client has a cache, call {@link Cache#close close()}. Note that it is an error to
+ * create calls against a cache that is closed, and doing so will cause the call to crash.
+ * <pre>   {@code
+ *
+ *     client.cache().close();
+ * }</pre>
+ *
+ * <p>OkHttp also uses daemon threads for HTTP/2 connections. These will exit automatically if they
+ * remain idle.
  */
-public class OkHttpClient implements Cloneable, Call.Factory {
-  private static final List<Protocol> DEFAULT_PROTOCOLS = Util.immutableList(
-      Protocol.HTTP_2, Protocol.SPDY_3, Protocol.HTTP_1_1);
+public class OkHttpClient implements Cloneable, Call.Factory, WebSocket.Factory {
+  static final List<Protocol> DEFAULT_PROTOCOLS = Util.immutableList(
+      Protocol.HTTP_2, Protocol.HTTP_1_1);
 
-  private static final List<ConnectionSpec> DEFAULT_CONNECTION_SPECS;
+  static final List<ConnectionSpec> DEFAULT_CONNECTION_SPECS = Util.immutableList(
+      ConnectionSpec.MODERN_TLS, ConnectionSpec.CLEARTEXT);
 
   static {
-    List<ConnectionSpec> connSpecs = new ArrayList<>(Arrays.asList(ConnectionSpec.MODERN_TLS,
-        ConnectionSpec.COMPATIBLE_TLS));
-    if (Platform.get().isCleartextTrafficPermitted()) {
-      connSpecs.add(ConnectionSpec.CLEARTEXT);
-    }
-    DEFAULT_CONNECTION_SPECS = Util.immutableList(connSpecs);
-
     Internal.instance = new Internal() {
       @Override public void addLenient(Headers.Builder builder, String line) {
         builder.addLenient(line);
@@ -88,18 +145,23 @@
         builder.setInternalCache(internalCache);
       }
 
-      @Override public InternalCache internalCache(OkHttpClient client) {
-        return client.internalCache();
-      }
-
       @Override public boolean connectionBecameIdle(
           ConnectionPool pool, RealConnection connection) {
         return pool.connectionBecameIdle(connection);
       }
 
-      @Override public RealConnection get(
+      @Override public RealConnection get(ConnectionPool pool, Address address,
+          StreamAllocation streamAllocation, Route route) {
+        return pool.get(address, streamAllocation, route);
+      }
+
+      @Override public boolean equalsNonHost(Address a, Address b) {
+        return a.equalsNonHost(b);
+      }
+
+      @Override public Socket deduplicate(
           ConnectionPool pool, Address address, StreamAllocation streamAllocation) {
-        return pool.get(address, streamAllocation);
+        return pool.deduplicate(address, streamAllocation);
       }
 
       @Override public void put(ConnectionPool pool, RealConnection connection) {
@@ -110,13 +172,8 @@
         return connectionPool.routeDatabase;
       }
 
-      @Override
-      public void callEnqueue(Call call, Callback responseCallback, boolean forWebSocket) {
-        ((RealCall) call).enqueue(responseCallback, forWebSocket);
-      }
-
-      @Override public StreamAllocation callEngineGetStreamAllocation(Call call) {
-        return ((RealCall) call).engine.streamAllocation;
+      @Override public int code(Response.Builder responseBuilder) {
+        return responseBuilder.code;
       }
 
       @Override
@@ -128,22 +185,31 @@ public void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket, boolean
           throws MalformedURLException, UnknownHostException {
         return HttpUrl.getChecked(url);
       }
+
+      @Override public StreamAllocation streamAllocation(Call call) {
+        return ((RealCall) call).streamAllocation();
+      }
+
+      @Override public Call newWebSocketCall(OkHttpClient client, Request originalRequest) {
+        return RealCall.newRealCall(client, originalRequest, true);
+      }
     };
   }
 
   final Dispatcher dispatcher;
-  final Proxy proxy;
+  final @Nullable Proxy proxy;
   final List<Protocol> protocols;
   final List<ConnectionSpec> connectionSpecs;
   final List<Interceptor> interceptors;
   final List<Interceptor> networkInterceptors;
+  final EventListener.Factory eventListenerFactory;
   final ProxySelector proxySelector;
   final CookieJar cookieJar;
-  final Cache cache;
-  final InternalCache internalCache;
+  final @Nullable Cache cache;
+  final @Nullable InternalCache internalCache;
   final SocketFactory socketFactory;
-  final SSLSocketFactory sslSocketFactory;
-  final CertificateChainCleaner certificateChainCleaner;
+  final @Nullable SSLSocketFactory sslSocketFactory;
+  final @Nullable CertificateChainCleaner certificateChainCleaner;
   final HostnameVerifier hostnameVerifier;
   final CertificatePinner certificatePinner;
   final Authenticator proxyAuthenticator;
@@ -156,18 +222,20 @@ public void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket, boolean
   final int connectTimeout;
   final int readTimeout;
   final int writeTimeout;
+  final int pingInterval;
 
   public OkHttpClient() {
     this(new Builder());
   }
 
-  private OkHttpClient(Builder builder) {
+  OkHttpClient(Builder builder) {
     this.dispatcher = builder.dispatcher;
     this.proxy = builder.proxy;
     this.protocols = builder.protocols;
     this.connectionSpecs = builder.connectionSpecs;
     this.interceptors = Util.immutableList(builder.interceptors);
     this.networkInterceptors = Util.immutableList(builder.networkInterceptors);
+    this.eventListenerFactory = builder.eventListenerFactory;
     this.proxySelector = builder.proxySelector;
     this.cookieJar = builder.cookieJar;
     this.cache = builder.cache;
@@ -201,6 +269,14 @@ private OkHttpClient(Builder builder) {
     this.connectTimeout = builder.connectTimeout;
     this.readTimeout = builder.readTimeout;
     this.writeTimeout = builder.writeTimeout;
+    this.pingInterval = builder.pingInterval;
+
+    if (interceptors.contains(null)) {
+      throw new IllegalStateException("Null interceptor: " + interceptors);
+    }
+    if (networkInterceptors.contains(null)) {
+      throw new IllegalStateException("Null network interceptor: " + networkInterceptors);
+    }
   }
 
   private X509TrustManager systemDefaultTrustManager() {
@@ -215,7 +291,7 @@ private X509TrustManager systemDefaultTrustManager() {
       }
       return (X509TrustManager) trustManagers[0];
     } catch (GeneralSecurityException e) {
-      throw new AssertionError(); // The system has no TLS. Just give up.
+      throw assertionError("No System TLS", e); // The system has no TLS. Just give up.
     }
   }
 
@@ -225,7 +301,7 @@ private SSLSocketFactory systemDefaultSslSocketFactory(X509TrustManager trustMan
       sslContext.init(null, new TrustManager[] { trustManager }, null);
       return sslContext.getSocketFactory();
     } catch (GeneralSecurityException e) {
-      throw new AssertionError(); // The system has no TLS. Just give up.
+      throw assertionError("No System TLS", e); // The system has no TLS. Just give up.
     }
   }
 
@@ -244,6 +320,11 @@ public int writeTimeoutMillis() {
     return writeTimeout;
   }
 
+  /** Web socket ping interval (in milliseconds). */
+  public int pingIntervalMillis() {
+    return pingInterval;
+  }
+
   public Proxy proxy() {
     return proxy;
   }
@@ -338,11 +419,24 @@ public Dispatcher dispatcher() {
     return networkInterceptors;
   }
 
+  public EventListener.Factory eventListenerFactory() {
+    return eventListenerFactory;
+  }
+
   /**
    * Prepares the {@code request} to be executed at some point in the future.
    */
   @Override public Call newCall(Request request) {
-    return new RealCall(this, request);
+    return RealCall.newRealCall(this, request, false /* for web socket */);
+  }
+
+  /**
+   * Uses {@code request} to connect a new web socket.
+   */
+  @Override public WebSocket newWebSocket(Request request, WebSocketListener listener) {
+    RealWebSocket webSocket = new RealWebSocket(request, listener, new Random());
+    webSocket.connect(this);
+    return webSocket;
   }
 
   public Builder newBuilder() {
@@ -351,18 +445,19 @@ public Builder newBuilder() {
 
   public static final class Builder {
     Dispatcher dispatcher;
-    Proxy proxy;
+    @Nullable Proxy proxy;
     List<Protocol> protocols;
     List<ConnectionSpec> connectionSpecs;
     final List<Interceptor> interceptors = new ArrayList<>();
     final List<Interceptor> networkInterceptors = new ArrayList<>();
+    EventListener.Factory eventListenerFactory;
     ProxySelector proxySelector;
     CookieJar cookieJar;
-    Cache cache;
-    InternalCache internalCache;
+    @Nullable Cache cache;
+    @Nullable InternalCache internalCache;
     SocketFactory socketFactory;
-    SSLSocketFactory sslSocketFactory;
-    CertificateChainCleaner certificateChainCleaner;
+    @Nullable SSLSocketFactory sslSocketFactory;
+    @Nullable CertificateChainCleaner certificateChainCleaner;
     HostnameVerifier hostnameVerifier;
     CertificatePinner certificatePinner;
     Authenticator proxyAuthenticator;
@@ -375,11 +470,13 @@ public Builder newBuilder() {
     int connectTimeout;
     int readTimeout;
     int writeTimeout;
+    int pingInterval;
 
     public Builder() {
       dispatcher = new Dispatcher();
       protocols = DEFAULT_PROTOCOLS;
       connectionSpecs = DEFAULT_CONNECTION_SPECS;
+      eventListenerFactory = EventListener.factory(EventListener.NONE);
       proxySelector = ProxySelector.getDefault();
       cookieJar = CookieJar.NO_COOKIES;
       socketFactory = SocketFactory.getDefault();
@@ -395,6 +492,7 @@ public Builder() {
       connectTimeout = 10_000;
       readTimeout = 10_000;
       writeTimeout = 10_000;
+      pingInterval = 0;
     }
 
     Builder(OkHttpClient okHttpClient) {
@@ -404,6 +502,7 @@ public Builder() {
       this.connectionSpecs = okHttpClient.connectionSpecs;
       this.interceptors.addAll(okHttpClient.interceptors);
       this.networkInterceptors.addAll(okHttpClient.networkInterceptors);
+      this.eventListenerFactory = okHttpClient.eventListenerFactory;
       this.proxySelector = okHttpClient.proxySelector;
       this.cookieJar = okHttpClient.cookieJar;
       this.internalCache = okHttpClient.internalCache;
@@ -423,48 +522,61 @@ public Builder() {
       this.connectTimeout = okHttpClient.connectTimeout;
       this.readTimeout = okHttpClient.readTimeout;
       this.writeTimeout = okHttpClient.writeTimeout;
+      this.pingInterval = okHttpClient.pingInterval;
     }
 
     /**
      * Sets the default connect timeout for new connections. A value of 0 means no timeout,
      * otherwise values must be between 1 and {@link Integer#MAX_VALUE} when converted to
      * milliseconds.
+     *
+     * <p>The connectTimeout is applied when connecting a TCP socket to the target host.
+     * The default value is 10 seconds.
      */
     public Builder connectTimeout(long timeout, TimeUnit unit) {
-      if (timeout < 0) throw new IllegalArgumentException("timeout < 0");
-      if (unit == null) throw new NullPointerException("unit == null");
-      long millis = unit.toMillis(timeout);
-      if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException("Timeout too large.");
-      if (millis == 0 && timeout > 0) throw new IllegalArgumentException("Timeout too small.");
-      connectTimeout = (int) millis;
+      connectTimeout = checkDuration("timeout", timeout, unit);
       return this;
     }
 
     /**
      * Sets the default read timeout for new connections. A value of 0 means no timeout, otherwise
      * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
+     *
+     * <p>The read timeout is applied to both the TCP socket and for individual read IO operations
+     * including on {@link Source} of the {@link Response}. The default value is 10 seconds.
+     *
+     * @see Socket#setSoTimeout(int)
+     * @see Source#timeout()
      */
     public Builder readTimeout(long timeout, TimeUnit unit) {
-      if (timeout < 0) throw new IllegalArgumentException("timeout < 0");
-      if (unit == null) throw new NullPointerException("unit == null");
-      long millis = unit.toMillis(timeout);
-      if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException("Timeout too large.");
-      if (millis == 0 && timeout > 0) throw new IllegalArgumentException("Timeout too small.");
-      readTimeout = (int) millis;
+      readTimeout = checkDuration("timeout", timeout, unit);
       return this;
     }
 
     /**
      * Sets the default write timeout for new connections. A value of 0 means no timeout, otherwise
      * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
+     *
+     * <p>The write timeout is applied for individual write IO operations.
+     * The default value is 10 seconds.
+     *
+     * @see Sink#timeout()
      */
     public Builder writeTimeout(long timeout, TimeUnit unit) {
-      if (timeout < 0) throw new IllegalArgumentException("timeout < 0");
-      if (unit == null) throw new NullPointerException("unit == null");
-      long millis = unit.toMillis(timeout);
-      if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException("Timeout too large.");
-      if (millis == 0 && timeout > 0) throw new IllegalArgumentException("Timeout too small.");
-      writeTimeout = (int) millis;
+      writeTimeout = checkDuration("timeout", timeout, unit);
+      return this;
+    }
+
+    /**
+     * Sets the interval between web socket pings initiated by this client. Use this to
+     * automatically send web socket ping frames until either the web socket fails or it is closed.
+     * This keeps the connection alive and may detect connectivity failures early. No timeouts are
+     * enforced on the acknowledging pongs.
+     *
+     * <p>The default value of 0 disables client-initiated pings.
+     */
+    public Builder pingInterval(long interval, TimeUnit unit) {
+      pingInterval = checkDuration("interval", interval, unit);
       return this;
     }
 
@@ -473,7 +585,7 @@ public Builder writeTimeout(long timeout, TimeUnit unit) {
      * precedence over {@link #proxySelector}, which is only honored when this proxy is null (which
      * it is by default). To disable proxy use completely, call {@code setProxy(Proxy.NO_PROXY)}.
      */
-    public Builder proxy(Proxy proxy) {
+    public Builder proxy(@Nullable Proxy proxy) {
       this.proxy = proxy;
       return this;
     }
@@ -504,12 +616,13 @@ public Builder cookieJar(CookieJar cookieJar) {
     }
 
     /** Sets the response cache to be used to read and write cached responses. */
-    void setInternalCache(InternalCache internalCache) {
+    void setInternalCache(@Nullable InternalCache internalCache) {
       this.internalCache = internalCache;
       this.cache = null;
     }
 
-    public Builder cache(Cache cache) {
+    /** Sets the response cache to be used to read and write cached responses. */
+    public Builder cache(@Nullable Cache cache) {
       this.cache = cache;
       this.internalCache = null;
       return this;
@@ -551,13 +664,8 @@ public Builder socketFactory(SocketFactory socketFactory) {
      */
     public Builder sslSocketFactory(SSLSocketFactory sslSocketFactory) {
       if (sslSocketFactory == null) throw new NullPointerException("sslSocketFactory == null");
-      X509TrustManager trustManager = Platform.get().trustManager(sslSocketFactory);
-      if (trustManager == null) {
-        throw new IllegalStateException("Unable to extract the trust manager on " + Platform.get()
-            + ", sslSocketFactory is " + sslSocketFactory.getClass());
-      }
       this.sslSocketFactory = sslSocketFactory;
-      this.certificateChainCleaner = CertificateChainCleaner.get(trustManager);
+      this.certificateChainCleaner = Platform.get().buildCertificateChainCleaner(sslSocketFactory);
       return this;
     }
 
@@ -669,7 +777,7 @@ public Builder followSslRedirects(boolean followProtocolRedirects) {
       return this;
     }
 
-    /** Configure this client to follow redirects. If unset, redirects be followed. */
+    /** Configure this client to follow redirects. If unset, redirects will be followed. */
     public Builder followRedirects(boolean followRedirects) {
       this.followRedirects = followRedirects;
       return this;
@@ -711,14 +819,12 @@ public Builder dispatcher(Dispatcher dispatcher) {
      * Configure the protocols used by this client to communicate with remote servers. By default
      * this client will prefer the most efficient transport available, falling back to more
      * ubiquitous protocols. Applications should only call this method to avoid specific
-     * compatibility problems, such as web servers that behave incorrectly when SPDY is enabled.
+     * compatibility problems, such as web servers that behave incorrectly when HTTP/2 is enabled.
      *
      * <p>The following protocols are currently supported:
      *
      * <ul>
      *     <li><a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html">http/1.1</a>
-     *     <li><a
-     *         href="http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1">spdy/3.1</a>
      *     <li><a href="http://tools.ietf.org/html/draft-ietf-httpbis-http2-17">h2</a>
      * </ul>
      *
@@ -737,7 +843,10 @@ public Builder dispatcher(Dispatcher dispatcher) {
      * Protocol#HTTP_1_1}. It must not contain null or {@link Protocol#HTTP_1_0}.
      */
     public Builder protocols(List<Protocol> protocols) {
-      protocols = Util.immutableList(protocols);
+      // Create a private copy of the list.
+      protocols = new ArrayList<>(protocols);
+
+      // Validate that the list has everything we require and nothing we forbid.
       if (!protocols.contains(Protocol.HTTP_1_1)) {
         throw new IllegalArgumentException("protocols doesn't contain http/1.1: " + protocols);
       }
@@ -747,7 +856,12 @@ public Builder protocols(List<Protocol> protocols) {
       if (protocols.contains(null)) {
         throw new IllegalArgumentException("protocols must not contain null");
       }
-      this.protocols = Util.immutableList(protocols);
+
+      // Remove protocols that we no longer support.
+      protocols.remove(Protocol.SPDY_3);
+
+      // Assign as an unmodifiable list. This is effectively immutable.
+      this.protocols = Collections.unmodifiableList(protocols);
       return this;
     }
 
@@ -766,6 +880,7 @@ public Builder connectionSpecs(List<ConnectionSpec> connectionSpecs) {
     }
 
     public Builder addInterceptor(Interceptor interceptor) {
+      if (interceptor == null) throw new IllegalArgumentException("interceptor == null");
       interceptors.add(interceptor);
       return this;
     }
@@ -780,10 +895,37 @@ public Builder addInterceptor(Interceptor interceptor) {
     }
 
     public Builder addNetworkInterceptor(Interceptor interceptor) {
+      if (interceptor == null) throw new IllegalArgumentException("interceptor == null");
       networkInterceptors.add(interceptor);
       return this;
     }
 
+    /**
+     * Configure a single client scoped listener that will receive all analytic events
+     * for this client.
+     *
+     * @see EventListener for semantics and restrictions on listener implementations.
+     */
+    public Builder eventListener(EventListener eventListener) {
+      if (eventListener == null) throw new NullPointerException("eventListener == null");
+      this.eventListenerFactory = EventListener.factory(eventListener);
+      return this;
+    }
+
+    /**
+     * Configure a factory to provide per-call scoped listeners that will receive analytic events
+     * for this client.
+     *
+     * @see EventListener for semantics and restrictions on listener implementations.
+     */
+    public Builder eventListenerFactory(EventListener.Factory eventListenerFactory) {
+      if (eventListenerFactory == null) {
+        throw new NullPointerException("eventListenerFactory == null");
+      }
+      this.eventListenerFactory = eventListenerFactory;
+      return this;
+    }
+
     public OkHttpClient build() {
       return new OkHttpClient(this);
     }
diff --git a/okhttp/src/main/java/okhttp3/Protocol.java b/okhttp/src/main/java/okhttp3/Protocol.java
index eec1c1219c..0c20bb8bc0 100644
--- a/okhttp/src/main/java/okhttp3/Protocol.java
+++ b/okhttp/src/main/java/okhttp3/Protocol.java
@@ -35,8 +35,8 @@
   /**
    * A plaintext framing that includes persistent connections.
    *
-   * <p>This version of OkHttp implements <a href="http://www.ietf.org/rfc/rfc2616.txt">RFC
-   * 2616</a>, and tracks revisions to that spec.
+   * <p>This version of OkHttp implements <a href="https://tools.ietf.org/html/rfc7230">RFC
+   * 7230</a>, and tracks revisions to that spec.
    */
   HTTP_1_1("http/1.1"),
 
@@ -44,9 +44,9 @@
    * Chromium's binary-framed protocol that includes header compression, multiplexing multiple
    * requests on the same socket, and server-push. HTTP/1.1 semantics are layered on SPDY/3.
    *
-   * <p>This version of OkHttp implements SPDY 3 <a
-   * href="http://dev.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1">draft 3.1</a>. Future
-   * releases of OkHttp may use this identifier for a newer draft of the SPDY spec.
+   * <p>Current versions of OkHttp do not support this protocol.
+   *
+   * @deprecated OkHttp has dropped support for SPDY. Prefer {@link #HTTP_2}.
    */
   SPDY_3("spdy/3.1"),
 
@@ -59,7 +59,17 @@
    * that enforce this may send an exception message including the string {@code
    * INADEQUATE_SECURITY}.
    */
-  HTTP_2("h2");
+  HTTP_2("h2"),
+
+  /**
+   * QUIC (Quick UDP Internet Connection) is a new multiplexed and secure transport atop UDP,
+   * designed from the ground up and optimized for HTTP/2 semantics.
+   * HTTP/1.1 semantics are layered on HTTP/2.
+   *
+   * <p>QUIC is not natively supported by OkHttp, but provided to allow a theoretical
+   * interceptor that provides support.
+   */
+  QUIC("quic");
 
   private final String protocol;
 
@@ -78,12 +88,15 @@ public static Protocol get(String protocol) throws IOException {
     if (protocol.equals(HTTP_1_1.protocol)) return HTTP_1_1;
     if (protocol.equals(HTTP_2.protocol)) return HTTP_2;
     if (protocol.equals(SPDY_3.protocol)) return SPDY_3;
+    if (protocol.equals(QUIC.protocol)) return QUIC;
     throw new IOException("Unexpected protocol: " + protocol);
   }
 
   /**
    * Returns the string used to identify this protocol for ALPN, like "http/1.1", "spdy/3.1" or
    * "h2".
+   *
+   * @link https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml
    */
   @Override public String toString() {
     return protocol;
diff --git a/okhttp/src/main/java/okhttp3/RealCall.java b/okhttp/src/main/java/okhttp3/RealCall.java
index ade7418065..808b3dc7ba 100644
--- a/okhttp/src/main/java/okhttp3/RealCall.java
+++ b/okhttp/src/main/java/okhttp3/RealCall.java
@@ -16,31 +16,49 @@
 package okhttp3;
 
 import java.io.IOException;
-import java.net.ProtocolException;
+import java.util.ArrayList;
+import java.util.List;
 import okhttp3.internal.NamedRunnable;
-import okhttp3.internal.Platform;
-import okhttp3.internal.http.HttpEngine;
-import okhttp3.internal.http.RequestException;
-import okhttp3.internal.http.RouteException;
-import okhttp3.internal.http.StreamAllocation;
+import okhttp3.internal.cache.CacheInterceptor;
+import okhttp3.internal.connection.ConnectInterceptor;
+import okhttp3.internal.connection.StreamAllocation;
+import okhttp3.internal.http.BridgeInterceptor;
+import okhttp3.internal.http.CallServerInterceptor;
+import okhttp3.internal.http.RealInterceptorChain;
+import okhttp3.internal.http.RetryAndFollowUpInterceptor;
+import okhttp3.internal.platform.Platform;
 
-import static okhttp3.internal.Platform.INFO;
-import static okhttp3.internal.http.HttpEngine.MAX_FOLLOW_UPS;
+import static okhttp3.internal.platform.Platform.INFO;
 
 final class RealCall implements Call {
-  private final OkHttpClient client;
+  final OkHttpClient client;
+  final RetryAndFollowUpInterceptor retryAndFollowUpInterceptor;
 
-  // Guarded by this.
-  private boolean executed;
-  volatile boolean canceled;
+  /**
+   * There is a cycle between the {@link Call} and {@link EventListener} that makes this awkward.
+   * This will be set after we create the call instance then create the event listener instance.
+   */
+  private EventListener eventListener;
 
   /** The application's original request unadulterated by redirects or auth headers. */
-  Request originalRequest;
-  HttpEngine engine;
+  final Request originalRequest;
+  final boolean forWebSocket;
 
-  protected RealCall(OkHttpClient client, Request originalRequest) {
+  // Guarded by this.
+  private boolean executed;
+
+  private RealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {
     this.client = client;
     this.originalRequest = originalRequest;
+    this.forWebSocket = forWebSocket;
+    this.retryAndFollowUpInterceptor = new RetryAndFollowUpInterceptor(client, forWebSocket);
+  }
+
+  static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {
+    // Safely publish the Call instance to the EventListener.
+    RealCall call = new RealCall(client, originalRequest, forWebSocket);
+    call.eventListener = client.eventListenerFactory().create(call);
+    return call;
   }
 
   @Override public Request request() {
@@ -52,31 +70,38 @@ protected RealCall(OkHttpClient client, Request originalRequest) {
       if (executed) throw new IllegalStateException("Already Executed");
       executed = true;
     }
+    captureCallStackTrace();
+    eventListener.callStart(this);
     try {
       client.dispatcher().executed(this);
-      Response result = getResponseWithInterceptorChain(false);
+      Response result = getResponseWithInterceptorChain();
       if (result == null) throw new IOException("Canceled");
       return result;
+    } catch (IOException e) {
+      eventListener.callFailed(this, e);
+      throw e;
     } finally {
       client.dispatcher().finished(this);
     }
   }
 
-  @Override public void enqueue(Callback responseCallback) {
-    enqueue(responseCallback, false);
+  private void captureCallStackTrace() {
+    Object callStackTrace = Platform.get().getStackTraceForCloseable("response.body().close()");
+    retryAndFollowUpInterceptor.setCallStackTrace(callStackTrace);
   }
 
-  void enqueue(Callback responseCallback, boolean forWebSocket) {
+  @Override public void enqueue(Callback responseCallback) {
     synchronized (this) {
       if (executed) throw new IllegalStateException("Already Executed");
       executed = true;
     }
-    client.dispatcher().enqueue(new AsyncCall(responseCallback, forWebSocket));
+    captureCallStackTrace();
+    eventListener.callStart(this);
+    client.dispatcher().enqueue(new AsyncCall(responseCallback));
   }
 
   @Override public void cancel() {
-    canceled = true;
-    if (engine != null) engine.cancel();
+    retryAndFollowUpInterceptor.cancel();
   }
 
   @Override public synchronized boolean isExecuted() {
@@ -84,17 +109,24 @@ void enqueue(Callback responseCallback, boolean forWebSocket) {
   }
 
   @Override public boolean isCanceled() {
-    return canceled;
+    return retryAndFollowUpInterceptor.isCanceled();
+  }
+
+  @SuppressWarnings("CloneDoesntCallSuperClone") // We are a final type & this saves clearing state.
+  @Override public RealCall clone() {
+    return RealCall.newRealCall(client, originalRequest, forWebSocket);
+  }
+
+  StreamAllocation streamAllocation() {
+    return retryAndFollowUpInterceptor.streamAllocation();
   }
 
   final class AsyncCall extends NamedRunnable {
     private final Callback responseCallback;
-    private final boolean forWebSocket;
 
-    private AsyncCall(Callback responseCallback, boolean forWebSocket) {
-      super("OkHttp %s", redactedUrl().toString());
+    AsyncCall(Callback responseCallback) {
+      super("OkHttp %s", redactedUrl());
       this.responseCallback = responseCallback;
-      this.forWebSocket = forWebSocket;
     }
 
     String host() {
@@ -105,10 +137,6 @@ Request request() {
       return originalRequest;
     }
 
-    void cancel() {
-      RealCall.this.cancel();
-    }
-
     RealCall get() {
       return RealCall.this;
     }
@@ -116,8 +144,8 @@ RealCall get() {
     @Override protected void execute() {
       boolean signalledCallback = false;
       try {
-        Response response = getResponseWithInterceptorChain(forWebSocket);
-        if (canceled) {
+        Response response = getResponseWithInterceptorChain();
+        if (retryAndFollowUpInterceptor.isCanceled()) {
           signalledCallback = true;
           responseCallback.onFailure(RealCall.this, new IOException("Canceled"));
         } else {
@@ -129,6 +157,7 @@ RealCall get() {
           // Do not signal the callback twice!
           Platform.get().log(INFO, "Callback failure for " + toLoggableString(), e);
         } else {
+          eventListener.callFailed(RealCall.this, e);
           responseCallback.onFailure(RealCall.this, e);
         }
       } finally {
@@ -141,160 +170,33 @@ RealCall get() {
    * Returns a string that describes this call. Doesn't include a full URL as that might contain
    * sensitive information.
    */
-  private String toLoggableString() {
-    String string = canceled ? "canceled call" : "call";
-    return string + " to " + redactedUrl();
-  }
-
-  HttpUrl redactedUrl() {
-    return originalRequest.url().resolve("/...");
-  }
-
-  private Response getResponseWithInterceptorChain(boolean forWebSocket) throws IOException {
-    Interceptor.Chain chain = new ApplicationInterceptorChain(0, originalRequest, forWebSocket);
-    return chain.proceed(originalRequest);
+  String toLoggableString() {
+    return (isCanceled() ? "canceled " : "")
+        + (forWebSocket ? "web socket" : "call")
+        + " to " + redactedUrl();
   }
 
-  class ApplicationInterceptorChain implements Interceptor.Chain {
-    private final int index;
-    private final Request request;
-    private final boolean forWebSocket;
-
-    ApplicationInterceptorChain(int index, Request request, boolean forWebSocket) {
-      this.index = index;
-      this.request = request;
-      this.forWebSocket = forWebSocket;
-    }
-
-    @Override public Connection connection() {
-      return null;
-    }
-
-    @Override public Request request() {
-      return request;
-    }
-
-    @Override public Response proceed(Request request) throws IOException {
-      // If there's another interceptor in the chain, call that.
-      if (index < client.interceptors().size()) {
-        Interceptor.Chain chain = new ApplicationInterceptorChain(index + 1, request, forWebSocket);
-        Interceptor interceptor = client.interceptors().get(index);
-        Response interceptedResponse = interceptor.intercept(chain);
-
-        if (interceptedResponse == null) {
-          throw new NullPointerException("application interceptor " + interceptor
-              + " returned null");
-        }
-
-        return interceptedResponse;
-      }
-
-      // No more interceptors. Do HTTP.
-      return getResponse(request, forWebSocket);
-    }
+  String redactedUrl() {
+    return originalRequest.url().redact();
   }
 
-  /**
-   * Performs the request and returns the response. May return null if this call was canceled.
-   */
-  Response getResponse(Request request, boolean forWebSocket) throws IOException {
-    // Copy body metadata to the appropriate request headers.
-    RequestBody body = request.body();
-    if (body != null) {
-      Request.Builder requestBuilder = request.newBuilder();
-
-      MediaType contentType = body.contentType();
-      if (contentType != null) {
-        requestBuilder.header("Content-Type", contentType.toString());
-      }
-
-      long contentLength = body.contentLength();
-      if (contentLength != -1) {
-        requestBuilder.header("Content-Length", Long.toString(contentLength));
-        requestBuilder.removeHeader("Transfer-Encoding");
-      } else {
-        requestBuilder.header("Transfer-Encoding", "chunked");
-        requestBuilder.removeHeader("Content-Length");
-      }
-
-      request = requestBuilder.build();
+  Response getResponseWithInterceptorChain() throws IOException {
+    // Build a full stack of interceptors.
+    List<Interceptor> interceptors = new ArrayList<>();
+    interceptors.addAll(client.interceptors());
+    interceptors.add(retryAndFollowUpInterceptor);
+    interceptors.add(new BridgeInterceptor(client.cookieJar()));
+    interceptors.add(new CacheInterceptor(client.internalCache()));
+    interceptors.add(new ConnectInterceptor(client));
+    if (!forWebSocket) {
+      interceptors.addAll(client.networkInterceptors());
     }
+    interceptors.add(new CallServerInterceptor(forWebSocket));
 
-    // Create the initial HTTP engine. Retries and redirects need new engine for each attempt.
-    engine = new HttpEngine(client, request, false, false, forWebSocket, null, null, null);
-
-    int followUpCount = 0;
-    while (true) {
-      if (canceled) {
-        engine.releaseStreamAllocation();
-        throw new IOException("Canceled");
-      }
-
-      boolean releaseConnection = true;
-      try {
-        engine.sendRequest();
-        engine.readResponse();
-        releaseConnection = false;
-      } catch (RequestException e) {
-        // The attempt to interpret the request failed. Give up.
-        throw e.getCause();
-      } catch (RouteException e) {
-        // The attempt to connect via a route failed. The request will not have been sent.
-        HttpEngine retryEngine = engine.recover(e.getLastConnectException(), true, null);
-        if (retryEngine != null) {
-          releaseConnection = false;
-          engine = retryEngine;
-          continue;
-        }
-        // Give up; recovery is not possible.
-        throw e.getLastConnectException();
-      } catch (IOException e) {
-        // An attempt to communicate with a server failed. The request may have been sent.
-        HttpEngine retryEngine = engine.recover(e, false, null);
-        if (retryEngine != null) {
-          releaseConnection = false;
-          engine = retryEngine;
-          continue;
-        }
-
-        // Give up; recovery is not possible.
-        throw e;
-      } finally {
-        // We're throwing an unchecked exception. Release any resources.
-        if (releaseConnection) {
-          StreamAllocation streamAllocation = engine.close();
-          streamAllocation.release();
-        }
-      }
-
-      Response response = engine.getResponse();
-      Request followUp = engine.followUpRequest();
-
-      if (followUp == null) {
-        if (!forWebSocket) {
-          engine.releaseStreamAllocation();
-        }
-        return response;
-      }
-
-      StreamAllocation streamAllocation = engine.close();
-
-      if (++followUpCount > MAX_FOLLOW_UPS) {
-        streamAllocation.release();
-        throw new ProtocolException("Too many follow-up requests: " + followUpCount);
-      }
-
-      if (!engine.sameConnection(followUp.url())) {
-        streamAllocation.release();
-        streamAllocation = null;
-      } else if (streamAllocation.stream() != null) {
-        throw new IllegalStateException("Closing the body of " + response
-            + " didn't close its backing stream. Bad interceptor?");
-      }
+    Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0,
+        originalRequest, this, eventListener, client.connectTimeoutMillis(),
+        client.readTimeoutMillis(), client.writeTimeoutMillis());
 
-      request = followUp;
-      engine = new HttpEngine(client, request, false, false, forWebSocket, streamAllocation, null,
-          response);
-    }
+    return chain.proceed(originalRequest);
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/Request.java b/okhttp/src/main/java/okhttp3/Request.java
index 89188ec587..6687dd3f9a 100644
--- a/okhttp/src/main/java/okhttp3/Request.java
+++ b/okhttp/src/main/java/okhttp3/Request.java
@@ -17,6 +17,8 @@
 
 import java.net.URL;
 import java.util.List;
+import javax.annotation.Nullable;
+import okhttp3.internal.Util;
 import okhttp3.internal.http.HttpMethod;
 
 /**
@@ -24,15 +26,15 @@
  * immutable.
  */
 public final class Request {
-  private final HttpUrl url;
-  private final String method;
-  private final Headers headers;
-  private final RequestBody body;
-  private final Object tag;
+  final HttpUrl url;
+  final String method;
+  final Headers headers;
+  final @Nullable RequestBody body;
+  final Object tag;
 
   private volatile CacheControl cacheControl; // Lazily initialized.
 
-  private Request(Builder builder) {
+  Request(Builder builder) {
     this.url = builder.url;
     this.method = builder.method;
     this.headers = builder.headers.build();
@@ -52,7 +54,7 @@ public Headers headers() {
     return headers;
   }
 
-  public String header(String name) {
+  public @Nullable String header(String name) {
     return headers.get(name);
   }
 
@@ -60,7 +62,7 @@ public String header(String name) {
     return headers.values(name);
   }
 
-  public RequestBody body() {
+  public @Nullable RequestBody body() {
     return body;
   }
 
@@ -96,18 +98,18 @@ public boolean isHttps() {
   }
 
   public static class Builder {
-    private HttpUrl url;
-    private String method;
-    private Headers.Builder headers;
-    private RequestBody body;
-    private Object tag;
+    HttpUrl url;
+    String method;
+    Headers.Builder headers;
+    RequestBody body;
+    Object tag;
 
     public Builder() {
       this.method = "GET";
       this.headers = new Headers.Builder();
     }
 
-    private Builder(Request request) {
+    Builder(Request request) {
       this.url = request.url;
       this.method = request.method;
       this.body = request.body;
@@ -130,7 +132,7 @@ public Builder url(HttpUrl url) {
     public Builder url(String url) {
       if (url == null) throw new NullPointerException("url == null");
 
-      // Silently replace websocket URLs with HTTP URLs.
+      // Silently replace web socket URLs with HTTP URLs.
       if (url.regionMatches(true, 0, "ws:", 0, 3)) {
         url = "http:" + url.substring(3);
       } else if (url.regionMatches(true, 0, "wss:", 0, 4)) {
@@ -210,12 +212,12 @@ public Builder post(RequestBody body) {
       return method("POST", body);
     }
 
-    public Builder delete(RequestBody body) {
+    public Builder delete(@Nullable RequestBody body) {
       return method("DELETE", body);
     }
 
     public Builder delete() {
-      return delete(RequestBody.create(null, new byte[0]));
+      return delete(Util.EMPTY_REQUEST);
     }
 
     public Builder put(RequestBody body) {
@@ -226,7 +228,7 @@ public Builder patch(RequestBody body) {
       return method("PATCH", body);
     }
 
-    public Builder method(String method, RequestBody body) {
+    public Builder method(String method, @Nullable RequestBody body) {
       if (method == null) throw new NullPointerException("method == null");
       if (method.length() == 0) throw new IllegalArgumentException("method.length() == 0");
       if (body != null && !HttpMethod.permitsRequestBody(method)) {
diff --git a/okhttp/src/main/java/okhttp3/RequestBody.java b/okhttp/src/main/java/okhttp3/RequestBody.java
index 136cfdc4e3..3cb29477d3 100644
--- a/okhttp/src/main/java/okhttp3/RequestBody.java
+++ b/okhttp/src/main/java/okhttp3/RequestBody.java
@@ -18,6 +18,7 @@
 import java.io.File;
 import java.io.IOException;
 import java.nio.charset.Charset;
+import javax.annotation.Nullable;
 import okhttp3.internal.Util;
 import okio.BufferedSink;
 import okio.ByteString;
@@ -26,24 +27,24 @@
 
 public abstract class RequestBody {
   /** Returns the Content-Type header for this body. */
-  public abstract MediaType contentType();
+  public abstract @Nullable MediaType contentType();
 
   /**
-   * Returns the number of bytes that will be written to {@code out} in a call to {@link #writeTo},
+   * Returns the number of bytes that will be written to {@code sink} in a call to {@link #writeTo},
    * or -1 if that count is unknown.
    */
   public long contentLength() throws IOException {
     return -1;
   }
 
-  /** Writes the content of this request to {@code out}. */
+  /** Writes the content of this request to {@code sink}. */
   public abstract void writeTo(BufferedSink sink) throws IOException;
 
   /**
    * Returns a new request body that transmits {@code content}. If {@code contentType} is non-null
    * and lacks a charset, this will use UTF-8.
    */
-  public static RequestBody create(MediaType contentType, String content) {
+  public static RequestBody create(@Nullable MediaType contentType, String content) {
     Charset charset = Util.UTF_8;
     if (contentType != null) {
       charset = contentType.charset();
@@ -57,9 +58,10 @@ public static RequestBody create(MediaType contentType, String content) {
   }
 
   /** Returns a new request body that transmits {@code content}. */
-  public static RequestBody create(final MediaType contentType, final ByteString content) {
+  public static RequestBody create(
+      final @Nullable MediaType contentType, final ByteString content) {
     return new RequestBody() {
-      @Override public MediaType contentType() {
+      @Override public @Nullable MediaType contentType() {
         return contentType;
       }
 
@@ -74,17 +76,17 @@ public static RequestBody create(final MediaType contentType, final ByteString c
   }
 
   /** Returns a new request body that transmits {@code content}. */
-  public static RequestBody create(final MediaType contentType, final byte[] content) {
+  public static RequestBody create(final @Nullable MediaType contentType, final byte[] content) {
     return create(contentType, content, 0, content.length);
   }
 
   /** Returns a new request body that transmits {@code content}. */
-  public static RequestBody create(final MediaType contentType, final byte[] content,
+  public static RequestBody create(final @Nullable MediaType contentType, final byte[] content,
       final int offset, final int byteCount) {
     if (content == null) throw new NullPointerException("content == null");
     Util.checkOffsetAndCount(content.length, offset, byteCount);
     return new RequestBody() {
-      @Override public MediaType contentType() {
+      @Override public @Nullable MediaType contentType() {
         return contentType;
       }
 
@@ -99,11 +101,11 @@ public static RequestBody create(final MediaType contentType, final byte[] conte
   }
 
   /** Returns a new request body that transmits the content of {@code file}. */
-  public static RequestBody create(final MediaType contentType, final File file) {
+  public static RequestBody create(final @Nullable MediaType contentType, final File file) {
     if (file == null) throw new NullPointerException("content == null");
 
     return new RequestBody() {
-      @Override public MediaType contentType() {
+      @Override public @Nullable MediaType contentType() {
         return contentType;
       }
 
diff --git a/okhttp/src/main/java/okhttp3/Response.java b/okhttp/src/main/java/okhttp3/Response.java
index 4b1928404b..1e3ab454a5 100644
--- a/okhttp/src/main/java/okhttp3/Response.java
+++ b/okhttp/src/main/java/okhttp3/Response.java
@@ -19,7 +19,8 @@
 import java.io.IOException;
 import java.util.Collections;
 import java.util.List;
-import okhttp3.internal.http.OkHeaders;
+import javax.annotation.Nullable;
+import okhttp3.internal.http.HttpHeaders;
 import okio.Buffer;
 import okio.BufferedSource;
 
@@ -40,22 +41,22 @@
  * {@link ResponseBody} for an explanation and examples.
  */
 public final class Response implements Closeable {
-  private final Request request;
-  private final Protocol protocol;
-  private final int code;
-  private final String message;
-  private final Handshake handshake;
-  private final Headers headers;
-  private final ResponseBody body;
-  private final Response networkResponse;
-  private final Response cacheResponse;
-  private final Response priorResponse;
-  private final long sentRequestAtMillis;
-  private final long receivedResponseAtMillis;
+  final Request request;
+  final Protocol protocol;
+  final int code;
+  final String message;
+  final @Nullable Handshake handshake;
+  final Headers headers;
+  final @Nullable ResponseBody body;
+  final @Nullable Response networkResponse;
+  final @Nullable Response cacheResponse;
+  final @Nullable Response priorResponse;
+  final long sentRequestAtMillis;
+  final long receivedResponseAtMillis;
 
   private volatile CacheControl cacheControl; // Lazily initialized.
 
-  private Response(Builder builder) {
+  Response(Builder builder) {
     this.request = builder.request;
     this.protocol = builder.protocol;
     this.code = builder.code;
@@ -71,15 +72,14 @@ private Response(Builder builder) {
   }
 
   /**
-   * The wire-level request that initiated this HTTP response. This is not
-   * necessarily the same request issued by the application:
+   * The wire-level request that initiated this HTTP response. This is not necessarily the same
+   * request issued by the application:
    *
    * <ul>
-   *     <li>It may be transformed by the HTTP client. For example, the client
-   *         may copy headers like {@code Content-Length} from the request body.
-   *     <li>It may be the request generated in response to an HTTP redirect or
-   *         authentication challenge. In this case the request URL may be
-   *         different than the initial request URL.
+   *     <li>It may be transformed by the HTTP client. For example, the client may copy headers like
+   *         {@code Content-Length} from the request body.
+   *     <li>It may be the request generated in response to an HTTP redirect or authentication
+   *         challenge. In this case the request URL may be different than the initial request URL.
    * </ul>
    */
   public Request request() {
@@ -106,7 +106,7 @@ public boolean isSuccessful() {
     return code >= 200 && code < 300;
   }
 
-  /** Returns the HTTP status message or null if it is unknown. */
+  /** Returns the HTTP status message. */
   public String message() {
     return message;
   }
@@ -123,11 +123,11 @@ public Handshake handshake() {
     return headers.values(name);
   }
 
-  public String header(String name) {
+  public @Nullable String header(String name) {
     return header(name, null);
   }
 
-  public String header(String name, String defaultValue) {
+  public @Nullable String header(String name, @Nullable String defaultValue) {
     String result = headers.get(name);
     return result != null ? result : defaultValue;
   }
@@ -166,9 +166,14 @@ public ResponseBody peekBody(long byteCount) throws IOException {
   }
 
   /**
-   * Never {@code null}, must be closed after consumption, can be consumed only once.
+   * Returns a non-null value if this response was passed to {@link Callback#onResponse} or returned
+   * from {@link Call#execute()}. Response bodies must be {@linkplain ResponseBody closed} and may
+   * be consumed only once.
+   *
+   * <p>This always returns null on responses returned from {@link #cacheResponse}, {@link
+   * #networkResponse}, and {@link #priorResponse()}.
    */
-  public ResponseBody body() {
+  public @Nullable ResponseBody body() {
     return body;
   }
 
@@ -196,7 +201,7 @@ public boolean isRedirect() {
    * the network, such as when the response is fully cached. The body of the returned response
    * should not be read.
    */
-  public Response networkResponse() {
+  public @Nullable Response networkResponse() {
     return networkResponse;
   }
 
@@ -205,7 +210,7 @@ public Response networkResponse() {
    * cache. For conditional get requests the cache response and network response may both be
    * non-null. The body of the returned response should not be read.
    */
-  public Response cacheResponse() {
+  public @Nullable Response cacheResponse() {
     return cacheResponse;
   }
 
@@ -215,7 +220,7 @@ public Response cacheResponse() {
    * returned response should not be read because it has already been consumed by the redirecting
    * client.
    */
-  public Response priorResponse() {
+  public @Nullable Response priorResponse() {
     return priorResponse;
   }
 
@@ -234,7 +239,7 @@ public Response priorResponse() {
     } else {
       return Collections.emptyList();
     }
-    return OkHeaders.parseChallenges(headers(), responseField);
+    return HttpHeaders.parseChallenges(headers(), responseField);
   }
 
   /**
@@ -264,8 +269,17 @@ public long receivedResponseAtMillis() {
     return receivedResponseAtMillis;
   }
 
-  /** Closes the response body. Equivalent to {@code body().close()}. */
+  /**
+   * Closes the response body. Equivalent to {@code body().close()}.
+   *
+   * <p>It is an error to close a response that is not eligible for a body. This includes the
+   * responses returned from {@link #cacheResponse}, {@link #networkResponse}, and {@link
+   * #priorResponse()}.
+   */
   @Override public void close() {
+    if (body == null) {
+      throw new IllegalStateException("response is not eligible for a body and must not be closed");
+    }
     body.close();
   }
 
@@ -282,24 +296,24 @@ public long receivedResponseAtMillis() {
   }
 
   public static class Builder {
-    private Request request;
-    private Protocol protocol;
-    private int code = -1;
-    private String message;
-    private Handshake handshake;
-    private Headers.Builder headers;
-    private ResponseBody body;
-    private Response networkResponse;
-    private Response cacheResponse;
-    private Response priorResponse;
-    private long sentRequestAtMillis;
-    private long receivedResponseAtMillis;
+    Request request;
+    Protocol protocol;
+    int code = -1;
+    String message;
+    @Nullable Handshake handshake;
+    Headers.Builder headers;
+    ResponseBody body;
+    Response networkResponse;
+    Response cacheResponse;
+    Response priorResponse;
+    long sentRequestAtMillis;
+    long receivedResponseAtMillis;
 
     public Builder() {
       headers = new Headers.Builder();
     }
 
-    private Builder(Response response) {
+    Builder(Response response) {
       this.request = response.request;
       this.protocol = response.protocol;
       this.code = response.code;
@@ -334,7 +348,7 @@ public Builder message(String message) {
       return this;
     }
 
-    public Builder handshake(Handshake handshake) {
+    public Builder handshake(@Nullable Handshake handshake) {
       this.handshake = handshake;
       return this;
     }
@@ -368,18 +382,18 @@ public Builder headers(Headers headers) {
       return this;
     }
 
-    public Builder body(ResponseBody body) {
+    public Builder body(@Nullable ResponseBody body) {
       this.body = body;
       return this;
     }
 
-    public Builder networkResponse(Response networkResponse) {
+    public Builder networkResponse(@Nullable Response networkResponse) {
       if (networkResponse != null) checkSupportResponse("networkResponse", networkResponse);
       this.networkResponse = networkResponse;
       return this;
     }
 
-    public Builder cacheResponse(Response cacheResponse) {
+    public Builder cacheResponse(@Nullable Response cacheResponse) {
       if (cacheResponse != null) checkSupportResponse("cacheResponse", cacheResponse);
       this.cacheResponse = cacheResponse;
       return this;
@@ -397,7 +411,7 @@ private void checkSupportResponse(String name, Response response) {
       }
     }
 
-    public Builder priorResponse(Response priorResponse) {
+    public Builder priorResponse(@Nullable Response priorResponse) {
       if (priorResponse != null) checkPriorResponse(priorResponse);
       this.priorResponse = priorResponse;
       return this;
@@ -423,6 +437,7 @@ public Response build() {
       if (request == null) throw new IllegalStateException("request == null");
       if (protocol == null) throw new IllegalStateException("protocol == null");
       if (code < 0) throw new IllegalStateException("code < 0: " + code);
+      if (message == null) throw new IllegalStateException("message == null");
       return new Response(this);
     }
   }
diff --git a/okhttp/src/main/java/okhttp3/ResponseBody.java b/okhttp/src/main/java/okhttp3/ResponseBody.java
index acc383be27..17447f3d64 100644
--- a/okhttp/src/main/java/okhttp3/ResponseBody.java
+++ b/okhttp/src/main/java/okhttp3/ResponseBody.java
@@ -21,6 +21,7 @@
 import java.io.InputStreamReader;
 import java.io.Reader;
 import java.nio.charset.Charset;
+import javax.annotation.Nullable;
 import okhttp3.internal.Util;
 import okio.Buffer;
 import okio.BufferedSource;
@@ -102,7 +103,7 @@
   /** Multiple calls to {@link #charStream()} must return the same instance. */
   private Reader reader;
 
-  public abstract MediaType contentType();
+  public abstract @Nullable MediaType contentType();
 
   /**
    * Returns the number of bytes in that will returned by {@link #bytes}, or {@link #byteStream}, or
@@ -116,6 +117,13 @@ public final InputStream byteStream() {
 
   public abstract BufferedSource source();
 
+  /**
+   * Returns the response as a byte array.
+   *
+   * <p>This method loads entire response body into memory. If the response body is very large this
+   * may trigger an {@link OutOfMemoryError}. Prefer to stream the response body if this is a
+   * possibility for your response.
+   */
   public final byte[] bytes() throws IOException {
     long contentLength = contentLength();
     if (contentLength > Integer.MAX_VALUE) {
@@ -130,7 +138,11 @@ public final InputStream byteStream() {
       Util.closeQuietly(source);
     }
     if (contentLength != -1 && contentLength != bytes.length) {
-      throw new IOException("Content-Length and stream length disagree");
+      throw new IOException("Content-Length ("
+          + contentLength
+          + ") and stream length ("
+          + bytes.length
+          + ") disagree");
     }
     return bytes;
   }
@@ -138,20 +150,32 @@ public final InputStream byteStream() {
   /**
    * Returns the response as a character stream decoded with the charset of the Content-Type header.
    * If that header is either absent or lacks a charset, this will attempt to decode the response
-   * body as UTF-8.
+   * body in accordance to <a href="https://en.wikipedia.org/wiki/Byte_order_mark">its BOM</a> or
+   * UTF-8.
    */
   public final Reader charStream() {
     Reader r = reader;
-    return r != null ? r : (reader = new InputStreamReader(byteStream(), charset()));
+    return r != null ? r : (reader = new BomAwareReader(source(), charset()));
   }
 
   /**
    * Returns the response as a string decoded with the charset of the Content-Type header. If that
-   * header is either absent or lacks a charset, this will attempt to decode the response body as
-   * UTF-8.
+   * header is either absent or lacks a charset, this will attempt to decode the response body in
+   * accordance to <a href="https://en.wikipedia.org/wiki/Byte_order_mark">its BOM</a> or UTF-8.
+   * Closes {@link ResponseBody} automatically.
+   *
+   * <p>This method loads entire response body into memory. If the response body is very large this
+   * may trigger an {@link OutOfMemoryError}. Prefer to stream the response body if this is a
+   * possibility for your response.
    */
   public final String string() throws IOException {
-    return new String(bytes(), charset().name());
+    BufferedSource source = source();
+    try {
+      Charset charset = Util.bomAwareCharset(source, charset());
+      return source.readString(charset);
+    } finally {
+      Util.closeQuietly(source);
+    }
   }
 
   private Charset charset() {
@@ -167,7 +191,7 @@ private Charset charset() {
    * Returns a new response body that transmits {@code content}. If {@code contentType} is non-null
    * and lacks a charset, this will use UTF-8.
    */
-  public static ResponseBody create(MediaType contentType, String content) {
+  public static ResponseBody create(@Nullable MediaType contentType, String content) {
     Charset charset = UTF_8;
     if (contentType != null) {
       charset = contentType.charset();
@@ -181,17 +205,17 @@ public static ResponseBody create(MediaType contentType, String content) {
   }
 
   /** Returns a new response body that transmits {@code content}. */
-  public static ResponseBody create(final MediaType contentType, byte[] content) {
+  public static ResponseBody create(final @Nullable MediaType contentType, byte[] content) {
     Buffer buffer = new Buffer().write(content);
     return create(contentType, content.length, buffer);
   }
 
   /** Returns a new response body that transmits {@code content}. */
-  public static ResponseBody create(
-      final MediaType contentType, final long contentLength, final BufferedSource content) {
+  public static ResponseBody create(final @Nullable MediaType contentType,
+      final long contentLength, final BufferedSource content) {
     if (content == null) throw new NullPointerException("source == null");
     return new ResponseBody() {
-      @Override public MediaType contentType() {
+      @Override public @Nullable MediaType contentType() {
         return contentType;
       }
 
@@ -204,4 +228,37 @@ public static ResponseBody create(
       }
     };
   }
+
+  static final class BomAwareReader extends Reader {
+    private final BufferedSource source;
+    private final Charset charset;
+
+    private boolean closed;
+    private Reader delegate;
+
+    BomAwareReader(BufferedSource source, Charset charset) {
+      this.source = source;
+      this.charset = charset;
+    }
+
+    @Override public int read(char[] cbuf, int off, int len) throws IOException {
+      if (closed) throw new IOException("Stream closed");
+
+      Reader delegate = this.delegate;
+      if (delegate == null) {
+        Charset charset = Util.bomAwareCharset(source, this.charset);
+        delegate = this.delegate = new InputStreamReader(source.inputStream(), charset);
+      }
+      return delegate.read(cbuf, off, len);
+    }
+
+    @Override public void close() throws IOException {
+      closed = true;
+      if (delegate != null) {
+        delegate.close();
+      } else {
+        source.close();
+      }
+    }
+  }
 }
diff --git a/okhttp/src/main/java/okhttp3/Route.java b/okhttp/src/main/java/okhttp3/Route.java
index 8aaa0f5b85..14158673ca 100644
--- a/okhttp/src/main/java/okhttp3/Route.java
+++ b/okhttp/src/main/java/okhttp3/Route.java
@@ -17,6 +17,7 @@
 
 import java.net.InetSocketAddress;
 import java.net.Proxy;
+import javax.annotation.Nullable;
 
 /**
  * The concrete route used by a connection to reach an abstract origin server. When creating a
@@ -79,14 +80,11 @@ public boolean requiresTunnel() {
     return address.sslSocketFactory != null && proxy.type() == Proxy.Type.HTTP;
   }
 
-  @Override public boolean equals(Object obj) {
-    if (obj instanceof Route) {
-      Route other = (Route) obj;
-      return address.equals(other.address)
-          && proxy.equals(other.proxy)
-          && inetSocketAddress.equals(other.inetSocketAddress);
-    }
-    return false;
+  @Override public boolean equals(@Nullable Object other) {
+    return other instanceof Route
+        && ((Route) other).address.equals(address)
+        && ((Route) other).proxy.equals(proxy)
+        && ((Route) other).inetSocketAddress.equals(inetSocketAddress);
   }
 
   @Override public int hashCode() {
@@ -96,4 +94,8 @@ public boolean requiresTunnel() {
     result = 31 * result + inetSocketAddress.hashCode();
     return result;
   }
+
+  @Override public String toString() {
+    return "Route{" + inetSocketAddress + "}";
+  }
 }
diff --git a/okhttp/src/main/java/okhttp3/TlsVersion.java b/okhttp/src/main/java/okhttp3/TlsVersion.java
index 668cd9732b..02cbeca3d1 100644
--- a/okhttp/src/main/java/okhttp3/TlsVersion.java
+++ b/okhttp/src/main/java/okhttp3/TlsVersion.java
@@ -15,11 +15,16 @@
  */
 package okhttp3;
 
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
 /**
  * Versions of TLS that can be offered when negotiating a secure socket. See {@link
  * javax.net.ssl.SSLSocket#setEnabledProtocols}.
  */
 public enum TlsVersion {
+  TLS_1_3("TLSv1.3"), // 2016.
   TLS_1_2("TLSv1.2"), // 2008.
   TLS_1_1("TLSv1.1"), // 2006.
   TLS_1_0("TLSv1"),   // 1999.
@@ -34,6 +39,8 @@
 
   public static TlsVersion forJavaName(String javaName) {
     switch (javaName) {
+      case "TLSv1.3":
+        return TLS_1_3;
       case "TLSv1.2":
         return TLS_1_2;
       case "TLSv1.1":
@@ -46,6 +53,14 @@ public static TlsVersion forJavaName(String javaName) {
     throw new IllegalArgumentException("Unexpected TLS version: " + javaName);
   }
 
+  static List<TlsVersion> forJavaNames(String... tlsVersions) {
+    List<TlsVersion> result = new ArrayList<>(tlsVersions.length);
+    for (String tlsVersion : tlsVersions) {
+      result.add(forJavaName(tlsVersion));
+    }
+    return Collections.unmodifiableList(result);
+  }
+
   public String javaName() {
     return javaName;
   }
diff --git a/okhttp/src/main/java/okhttp3/WebSocket.java b/okhttp/src/main/java/okhttp3/WebSocket.java
new file mode 100644
index 0000000000..46d95dec3a
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/WebSocket.java
@@ -0,0 +1,123 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import javax.annotation.Nullable;
+import okio.ByteString;
+
+/**
+ * A non-blocking interface to a web socket. Use the {@linkplain WebSocket.Factory factory} to
+ * create instances; usually this is {@link OkHttpClient}.
+ *
+ * <h3>Web Socket Lifecycle</h3>
+ *
+ * Upon normal operation each web socket progresses through a sequence of states:
+ *
+ * <ul>
+ *   <li><strong>Connecting:</strong> the initial state of each web socket. Messages may be enqueued
+ *       but they won't be transmitted until the web socket is open.
+ *   <li><strong>Open:</strong> the web socket has been accepted by the remote peer and is fully
+ *       operational. Messages in either direction are enqueued for immediate transmission.
+ *   <li><strong>Closing:</strong> one of the peers on the web socket has initiated a graceful
+ *       shutdown. The web socket will continue to transmit already-enqueued messages but will
+ *       refuse to enqueue new ones.
+ *   <li><strong>Closed:</strong> the web socket has transmitted all of its messages and has
+ *       received all messages from the peer.
+ * </ul>
+ *
+ * Web sockets may fail due to HTTP upgrade problems, connectivity problems, or if either peer
+ * chooses to short-circuit the graceful shutdown process:
+ *
+ * <ul>
+ *   <li><strong>Canceled:</strong> the web socket connection failed. Messages that were
+ *       successfully enqueued by either peer may not have been transmitted to the other.
+ * </ul>
+ *
+ * Note that the state progression is independent for each peer. Arriving at a gracefully-closed
+ * state indicates that a peer has sent all of its outgoing messages and received all of its
+ * incoming messages. But it does not guarantee that the other peer will successfully receive all of
+ * its incoming messages.
+ */
+public interface WebSocket {
+  /** Returns the original request that initiated this web socket. */
+  Request request();
+
+  /**
+   * Returns the size in bytes of all messages enqueued to be transmitted to the server. This
+   * doesn't include framing overhead. It also doesn't include any bytes buffered by the operating
+   * system or network intermediaries. This method returns 0 if no messages are waiting
+   * in the queue. If may return a nonzero value after the web socket has been canceled; this
+   * indicates that enqueued messages were not transmitted.
+   */
+  long queueSize();
+
+  /**
+   * Attempts to enqueue {@code text} to be UTF-8 encoded and sent as a the data of a text (type
+   * {@code 0x1}) message.
+   *
+   * <p>This method returns true if the message was enqueued. Messages that would overflow the
+   * outgoing message buffer will be rejected and trigger a {@linkplain #close graceful shutdown} of
+   * this web socket. This method returns false in that case, and in any other case where this
+   * web socket is closing, closed, or canceled.
+   *
+   * <p>This method returns immediately.
+   */
+  boolean send(String text);
+
+  /**
+   * Attempts to enqueue {@code bytes} to be sent as a the data of a binary (type {@code 0x2})
+   * message.
+   *
+   * <p>This method returns true if the message was enqueued. Messages that would overflow the
+   * outgoing message buffer (16 MiB) will be rejected and trigger a
+   * {@linkplain #close graceful shutdown} of this web socket. This method returns false in that
+   * case, and in any other case where this web socket is closing, closed, or canceled.
+   *
+   * <p>This method returns immediately.
+   */
+  boolean send(ByteString bytes);
+
+  /**
+   * Attempts to initiate a graceful shutdown of this web socket. Any already-enqueued messages will
+   * be transmitted before the close message is sent but subsequent calls to {@link #send} will
+   * return false and their messages will not be enqueued.
+   *
+   * <p>This returns true if a graceful shutdown was initiated by this call. It returns false and if
+   * a graceful shutdown was already underway or if the web socket is already closed or canceled.
+   *
+   * @param code Status code as defined by <a
+   * href="http://tools.ietf.org/html/rfc6455#section-7.4">Section 7.4 of RFC 6455</a>.
+   * @param reason Reason for shutting down or {@code null}.
+   * @throws IllegalArgumentException if code is invalid.
+   */
+  boolean close(int code, @Nullable String reason);
+
+  /**
+   * Immediately and violently release resources held by this web socket, discarding any enqueued
+   * messages. This does nothing if the web socket has already been closed or canceled.
+   */
+  void cancel();
+
+  interface Factory {
+    /**
+     * Creates a new web socket and immediately returns it. Creating a web socket initiates an
+     * asynchronous process to connect the socket. Once that succeeds or fails, {@code listener}
+     * will be notified. The caller must either close or cancel the returned web socket when it is
+     * no longer in use.
+     */
+    WebSocket newWebSocket(Request request, WebSocketListener listener);
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/WebSocketListener.java b/okhttp/src/main/java/okhttp3/WebSocketListener.java
new file mode 100644
index 0000000000..69276d933b
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/WebSocketListener.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import javax.annotation.Nullable;
+import okio.ByteString;
+
+public abstract class WebSocketListener {
+  /**
+   * Invoked when a web socket has been accepted by the remote peer and may begin transmitting
+   * messages.
+   */
+  public void onOpen(WebSocket webSocket, Response response) {
+  }
+
+  /** Invoked when a text (type {@code 0x1}) message has been received. */
+  public void onMessage(WebSocket webSocket, String text) {
+  }
+
+  /** Invoked when a binary (type {@code 0x2}) message has been received. */
+  public void onMessage(WebSocket webSocket, ByteString bytes) {
+  }
+
+  /**
+   * Invoked when the remote peer has indicated that no more incoming messages will be
+   * transmitted.
+   */
+  public void onClosing(WebSocket webSocket, int code, String reason) {
+  }
+
+  /**
+   * Invoked when both peers have indicated that no more messages will be transmitted and the
+   * connection has been successfully released. No further calls to this listener will be made.
+   */
+  public void onClosed(WebSocket webSocket, int code, String reason) {
+  }
+
+  /**
+   * Invoked when a web socket has been closed due to an error reading from or writing to the
+   * network. Both outgoing and incoming messages may have been lost. No further calls to this
+   * listener will be made.
+   */
+  public void onFailure(WebSocket webSocket, Throwable t, @Nullable Response response) {
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/Internal.java b/okhttp/src/main/java/okhttp3/internal/Internal.java
index 5ed594eacf..1be96fd3e7 100644
--- a/okhttp/src/main/java/okhttp3/internal/Internal.java
+++ b/okhttp/src/main/java/okhttp3/internal/Internal.java
@@ -16,18 +16,23 @@
 package okhttp3.internal;
 
 import java.net.MalformedURLException;
+import java.net.Socket;
 import java.net.UnknownHostException;
 import javax.net.ssl.SSLSocket;
 import okhttp3.Address;
 import okhttp3.Call;
-import okhttp3.Callback;
 import okhttp3.ConnectionPool;
 import okhttp3.ConnectionSpec;
 import okhttp3.Headers;
 import okhttp3.HttpUrl;
 import okhttp3.OkHttpClient;
-import okhttp3.internal.http.StreamAllocation;
-import okhttp3.internal.io.RealConnection;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.Route;
+import okhttp3.internal.cache.InternalCache;
+import okhttp3.internal.connection.RealConnection;
+import okhttp3.internal.connection.RouteDatabase;
+import okhttp3.internal.connection.StreamAllocation;
 
 /**
  * Escalate internal APIs in {@code okhttp3} so they can be used from OkHttp's implementation
@@ -48,9 +53,12 @@ public static void initializeInstanceForTests() {
 
   public abstract void setCache(OkHttpClient.Builder builder, InternalCache internalCache);
 
-  public abstract InternalCache internalCache(OkHttpClient client);
+  public abstract RealConnection get(ConnectionPool pool, Address address,
+      StreamAllocation streamAllocation, Route route);
 
-  public abstract RealConnection get(
+  public abstract boolean equalsNonHost(Address a, Address b);
+
+  public abstract Socket deduplicate(
       ConnectionPool pool, Address address, StreamAllocation streamAllocation);
 
   public abstract void put(ConnectionPool pool, RealConnection connection);
@@ -59,14 +67,15 @@ public abstract RealConnection get(
 
   public abstract RouteDatabase routeDatabase(ConnectionPool connectionPool);
 
+  public abstract int code(Response.Builder responseBuilder);
+
   public abstract void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket,
       boolean isFallback);
 
   public abstract HttpUrl getHttpUrlChecked(String url)
       throws MalformedURLException, UnknownHostException;
 
-  // TODO delete the following when web sockets move into the main package.
-  public abstract void callEnqueue(Call call, Callback responseCallback, boolean forWebSocket);
+  public abstract StreamAllocation streamAllocation(Call call);
 
-  public abstract StreamAllocation callEngineGetStreamAllocation(Call call);
+  public abstract Call newWebSocketCall(OkHttpClient client, Request request);
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/Util.java b/okhttp/src/main/java/okhttp3/internal/Util.java
index 0d72116405..85c6cabcf1 100644
--- a/okhttp/src/main/java/okhttp3/internal/Util.java
+++ b/okhttp/src/main/java/okhttp3/internal/Util.java
@@ -18,27 +18,28 @@
 import java.io.Closeable;
 import java.io.IOException;
 import java.io.InterruptedIOException;
-import java.io.UnsupportedEncodingException;
-import java.lang.reflect.Array;
 import java.net.IDN;
+import java.net.InetAddress;
 import java.net.ServerSocket;
 import java.net.Socket;
+import java.net.UnknownHostException;
 import java.nio.charset.Charset;
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
-import java.util.LinkedHashMap;
+import java.util.Comparator;
 import java.util.List;
 import java.util.Locale;
-import java.util.Map;
 import java.util.TimeZone;
 import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.TimeUnit;
 import java.util.regex.Pattern;
+import javax.annotation.Nullable;
 import okhttp3.HttpUrl;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
 import okio.Buffer;
+import okio.BufferedSource;
 import okio.ByteString;
 import okio.Source;
 
@@ -47,12 +48,31 @@
   public static final byte[] EMPTY_BYTE_ARRAY = new byte[0];
   public static final String[] EMPTY_STRING_ARRAY = new String[0];
 
-  /** A cheap and type-safe constant for the UTF-8 Charset. */
+  public static final ResponseBody EMPTY_RESPONSE = ResponseBody.create(null, EMPTY_BYTE_ARRAY);
+  public static final RequestBody EMPTY_REQUEST = RequestBody.create(null, EMPTY_BYTE_ARRAY);
+
+  private static final ByteString UTF_8_BOM = ByteString.decodeHex("efbbbf");
+  private static final ByteString UTF_16_BE_BOM = ByteString.decodeHex("feff");
+  private static final ByteString UTF_16_LE_BOM = ByteString.decodeHex("fffe");
+  private static final ByteString UTF_32_BE_BOM = ByteString.decodeHex("0000ffff");
+  private static final ByteString UTF_32_LE_BOM = ByteString.decodeHex("ffff0000");
+
   public static final Charset UTF_8 = Charset.forName("UTF-8");
+  public static final Charset ISO_8859_1 = Charset.forName("ISO-8859-1");
+  private static final Charset UTF_16_BE = Charset.forName("UTF-16BE");
+  private static final Charset UTF_16_LE = Charset.forName("UTF-16LE");
+  private static final Charset UTF_32_BE = Charset.forName("UTF-32BE");
+  private static final Charset UTF_32_LE = Charset.forName("UTF-32LE");
 
   /** GMT and UTC are equivalent for our purposes. */
   public static final TimeZone UTC = TimeZone.getTimeZone("GMT");
 
+  public static final Comparator<String> NATURAL_ORDER = new Comparator<String>() {
+    @Override public int compare(String a, String b) {
+      return a.compareTo(b);
+    }
+  };
+
   /**
    * Quick and dirty pattern to differentiate IP addresses from hostnames. This is an approximation
    * of Android's private InetAddress#isNumeric API.
@@ -127,29 +147,6 @@ public static void closeQuietly(ServerSocket serverSocket) {
     }
   }
 
-  /**
-   * Closes {@code a} and {@code b}. If either close fails, this completes the other close and
-   * rethrows the first encountered exception.
-   */
-  public static void closeAll(Closeable a, Closeable b) throws IOException {
-    Throwable thrown = null;
-    try {
-      a.close();
-    } catch (Throwable e) {
-      thrown = e;
-    }
-    try {
-      b.close();
-    } catch (Throwable e) {
-      if (thrown == null) thrown = e;
-    }
-    if (thrown == null) return;
-    if (thrown instanceof IOException) throw (IOException) thrown;
-    if (thrown instanceof RuntimeException) throw (RuntimeException) thrown;
-    if (thrown instanceof Error) throw (Error) thrown;
-    throw new AssertionError(thrown);
-  }
-
   /**
    * Attempts to exhaust {@code source}, returning true if successful. This is useful when reading a
    * complete source is helpful, such as when doing so completes a cache body or frees a socket
@@ -190,50 +187,6 @@ public static boolean skipAll(Source source, int duration, TimeUnit timeUnit) th
     }
   }
 
-  /** Returns a 32 character string containing an MD5 hash of {@code s}. */
-  public static String md5Hex(String s) {
-    try {
-      MessageDigest messageDigest = MessageDigest.getInstance("MD5");
-      byte[] md5bytes = messageDigest.digest(s.getBytes("UTF-8"));
-      return ByteString.of(md5bytes).hex();
-    } catch (NoSuchAlgorithmException | UnsupportedEncodingException e) {
-      throw new AssertionError(e);
-    }
-  }
-
-  /** Returns a Base 64-encoded string containing a SHA-1 hash of {@code s}. */
-  public static String shaBase64(String s) {
-    try {
-      MessageDigest messageDigest = MessageDigest.getInstance("SHA-1");
-      byte[] sha1Bytes = messageDigest.digest(s.getBytes("UTF-8"));
-      return ByteString.of(sha1Bytes).base64();
-    } catch (NoSuchAlgorithmException | UnsupportedEncodingException e) {
-      throw new AssertionError(e);
-    }
-  }
-
-  /** Returns a SHA-1 hash of {@code s}. */
-  public static ByteString sha1(ByteString s) {
-    try {
-      MessageDigest messageDigest = MessageDigest.getInstance("SHA-1");
-      byte[] sha1Bytes = messageDigest.digest(s.toByteArray());
-      return ByteString.of(sha1Bytes);
-    } catch (NoSuchAlgorithmException e) {
-      throw new AssertionError(e);
-    }
-  }
-
-  /** Returns a SHA-256 hash of {@code s}. */
-  public static ByteString sha256(ByteString s) {
-    try {
-      MessageDigest messageDigest = MessageDigest.getInstance("SHA-256");
-      byte[] sha1Bytes = messageDigest.digest(s.toByteArray());
-      return ByteString.of(sha1Bytes);
-    } catch (NoSuchAlgorithmException e) {
-      throw new AssertionError(e);
-    }
-  }
-
   /** Returns an immutable copy of {@code list}. */
   public static <T> List<T> immutableList(List<T> list) {
     return Collections.unmodifiableList(new ArrayList<>(list));
@@ -244,11 +197,6 @@ public static ByteString sha256(ByteString s) {
     return Collections.unmodifiableList(Arrays.asList(elements.clone()));
   }
 
-  /** Returns an immutable copy of {@code map}. */
-  public static <K, V> Map<K, V> immutableMap(Map<K, V> map) {
-    return Collections.unmodifiableMap(new LinkedHashMap<>(map));
-  }
-
   public static ThreadFactory threadFactory(final String name, final boolean daemon) {
     return new ThreadFactory() {
       @Override public Thread newThread(Runnable runnable) {
@@ -260,30 +208,43 @@ public static ThreadFactory threadFactory(final String name, final boolean daemo
   }
 
   /**
-   * Returns an array containing containing only elements found in {@code first}  and also in {@code
+   * Returns an array containing only elements found in {@code first} and also in {@code
    * second}. The returned elements are in the same order as in {@code first}.
    */
   @SuppressWarnings("unchecked")
-  public static <T> T[] intersect(Class<T> arrayType, T[] first, T[] second) {
-    List<T> result = intersect(first, second);
-    return result.toArray((T[]) Array.newInstance(arrayType, result.size()));
+  public static String[] intersect(
+      Comparator<? super String> comparator, String[] first, String[] second) {
+    List<String> result = new ArrayList<>();
+    for (String a : first) {
+      for (String b : second) {
+        if (comparator.compare(a, b) == 0) {
+          result.add(a);
+          break;
+        }
+      }
+    }
+    return result.toArray(new String[result.size()]);
   }
 
   /**
-   * Returns a list containing containing only elements found in {@code first}  and also in {@code
-   * second}. The returned elements are in the same order as in {@code first}.
+   * Returns true if there is an element in {@code first} that is also in {@code second}. This
+   * method terminates if any intersection is found. The sizes of both arguments are assumed to be
+   * so small, and the likelihood of an intersection so great, that it is not worth the CPU cost of
+   * sorting or the memory cost of hashing.
    */
-  private static <T> List<T> intersect(T[] first, T[] second) {
-    List<T> result = new ArrayList<>();
-    for (T a : first) {
-      for (T b : second) {
-        if (a.equals(b)) {
-          result.add(b);
-          break;
+  public static boolean nonEmptyIntersection(
+      Comparator<String> comparator, String[] first, String[] second) {
+    if (first == null || second == null || first.length == 0 || second.length == 0) {
+      return false;
+    }
+    for (String a : first) {
+      for (String b : second) {
+        if (comparator.compare(a, b) == 0) {
+          return true;
         }
       }
     }
-    return result;
+    return false;
   }
 
   public static String hostHeader(HttpUrl url, boolean includeDefaultPort) {
@@ -321,8 +282,11 @@ public static boolean isAndroidGetsocknameError(AssertionError e) {
         && e.getMessage().contains("getsockname failed");
   }
 
-  public static boolean contains(String[] array, String value) {
-    return Arrays.asList(array).contains(value);
+  public static int indexOf(Comparator<String> comparator, String[] array, String value) {
+    for (int i = 0, size = array.length; i < size; i++) {
+      if (comparator.compare(array[i], value) == 0) return i;
+    }
+    return -1;
   }
 
   public static String[] concat(String[] array, String value) {
@@ -402,14 +366,28 @@ public static int delimiterOffset(String input, int pos, int limit, char delimit
   }
 
   /**
-   * Performs IDN ToASCII encoding and canonicalize the result to lowercase. e.g. This converts
-   * {@code ☃.net} to {@code xn--n3h.net}, and {@code WwW.GoOgLe.cOm} to {@code www.google.com}.
-   * {@code null} will be returned if the input cannot be ToASCII encoded or if the result
-   * contains unsupported ASCII characters.
+   * If {@code host} is an IP address, this returns the IP address in canonical form.
+   *
+   * <p>Otherwise this performs IDN ToASCII encoding and canonicalize the result to lowercase. For
+   * example this converts {@code ☃.net} to {@code xn--n3h.net}, and {@code WwW.GoOgLe.cOm} to
+   * {@code www.google.com}. {@code null} will be returned if the host cannot be ToASCII encoded or
+   * if the result contains unsupported ASCII characters.
    */
-  public static String domainToAscii(String input) {
+  public static String canonicalizeHost(String host) {
+    // If the input contains a :, it’s an IPv6 address.
+    if (host.contains(":")) {
+      // If the input is encased in square braces "[...]", drop 'em.
+      InetAddress inetAddress = host.startsWith("[") && host.endsWith("]")
+          ? decodeIpv6(host, 1, host.length() - 1)
+          : decodeIpv6(host, 0, host.length());
+      if (inetAddress == null) return null;
+      byte[] address = inetAddress.getAddress();
+      if (address.length == 16) return inet6AddressToAscii(address);
+      throw new AssertionError("Invalid IPv6 address: '" + host + "'");
+    }
+
     try {
-      String result = IDN.toASCII(input).toLowerCase(Locale.US);
+      String result = IDN.toASCII(host).toLowerCase(Locale.US);
       if (result.isEmpty()) return null;
 
       // Confirm that the IDN ToASCII result doesn't contain any illegal characters.
@@ -442,6 +420,21 @@ private static boolean containsInvalidHostnameAsciiCodes(String hostnameAscii) {
     return false;
   }
 
+  /**
+   * Returns the index of the first character in {@code input} that is either a control character
+   * (like {@code \u0000 or \n}) or a non-ASCII character. Returns -1 if {@code input} has no such
+   * characters.
+   */
+  public static int indexOfControlOrNonAscii(String input) {
+    for (int i = 0, length = input.length(); i < length; i++) {
+      char c = input.charAt(i);
+      if (c <= '\u001f' || c >= '\u007f') {
+        return i;
+      }
+    }
+    return -1;
+  }
+
   /** Returns true if {@code host} is not a host name and might be an IP address. */
   public static boolean verifyAsIpAddress(String host) {
     return VERIFY_AS_IP_ADDRESS.matcher(host).matches();
@@ -451,4 +444,196 @@ public static boolean verifyAsIpAddress(String host) {
   public static String format(String format, Object... args) {
     return String.format(Locale.US, format, args);
   }
+
+  public static Charset bomAwareCharset(BufferedSource source, Charset charset) throws IOException {
+    if (source.rangeEquals(0, UTF_8_BOM)) {
+      source.skip(UTF_8_BOM.size());
+      return UTF_8;
+    }
+    if (source.rangeEquals(0, UTF_16_BE_BOM)) {
+      source.skip(UTF_16_BE_BOM.size());
+      return UTF_16_BE;
+    }
+    if (source.rangeEquals(0, UTF_16_LE_BOM)) {
+      source.skip(UTF_16_LE_BOM.size());
+      return UTF_16_LE;
+    }
+    if (source.rangeEquals(0, UTF_32_BE_BOM)) {
+      source.skip(UTF_32_BE_BOM.size());
+      return UTF_32_BE;
+    }
+    if (source.rangeEquals(0, UTF_32_LE_BOM)) {
+      source.skip(UTF_32_LE_BOM.size());
+      return UTF_32_LE;
+    }
+    return charset;
+  }
+
+  public static int checkDuration(String name, long duration, TimeUnit unit) {
+    if (duration < 0) throw new IllegalArgumentException(name + " < 0");
+    if (unit == null) throw new NullPointerException("unit == null");
+    long millis = unit.toMillis(duration);
+    if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException(name + " too large.");
+    if (millis == 0 && duration > 0) throw new IllegalArgumentException(name + " too small.");
+    return (int) millis;
+  }
+
+  public static AssertionError assertionError(String message, Exception e) {
+    AssertionError assertionError = new AssertionError(message);
+    try {
+      assertionError.initCause(e);
+    } catch (IllegalStateException ise) {
+      // ignored, shouldn't happen
+    }
+    return assertionError;
+  }
+
+  public static int decodeHexDigit(char c) {
+    if (c >= '0' && c <= '9') return c - '0';
+    if (c >= 'a' && c <= 'f') return c - 'a' + 10;
+    if (c >= 'A' && c <= 'F') return c - 'A' + 10;
+    return -1;
+  }
+
+  /** Decodes an IPv6 address like 1111:2222:3333:4444:5555:6666:7777:8888 or ::1. */
+  private static @Nullable InetAddress decodeIpv6(String input, int pos, int limit) {
+    byte[] address = new byte[16];
+    int b = 0;
+    int compress = -1;
+    int groupOffset = -1;
+
+    for (int i = pos; i < limit; ) {
+      if (b == address.length) return null; // Too many groups.
+
+      // Read a delimiter.
+      if (i + 2 <= limit && input.regionMatches(i, "::", 0, 2)) {
+        // Compression "::" delimiter, which is anywhere in the input, including its prefix.
+        if (compress != -1) return null; // Multiple "::" delimiters.
+        i += 2;
+        b += 2;
+        compress = b;
+        if (i == limit) break;
+      } else if (b != 0) {
+        // Group separator ":" delimiter.
+        if (input.regionMatches(i, ":", 0, 1)) {
+          i++;
+        } else if (input.regionMatches(i, ".", 0, 1)) {
+          // If we see a '.', rewind to the beginning of the previous group and parse as IPv4.
+          if (!decodeIpv4Suffix(input, groupOffset, limit, address, b - 2)) return null;
+          b += 2; // We rewound two bytes and then added four.
+          break;
+        } else {
+          return null; // Wrong delimiter.
+        }
+      }
+
+      // Read a group, one to four hex digits.
+      int value = 0;
+      groupOffset = i;
+      for (; i < limit; i++) {
+        char c = input.charAt(i);
+        int hexDigit = decodeHexDigit(c);
+        if (hexDigit == -1) break;
+        value = (value << 4) + hexDigit;
+      }
+      int groupLength = i - groupOffset;
+      if (groupLength == 0 || groupLength > 4) return null; // Group is the wrong size.
+
+      // We've successfully read a group. Assign its value to our byte array.
+      address[b++] = (byte) ((value >>> 8) & 0xff);
+      address[b++] = (byte) (value & 0xff);
+    }
+
+    // All done. If compression happened, we need to move bytes to the right place in the
+    // address. Here's a sample:
+    //
+    //      input: "1111:2222:3333::7777:8888"
+    //     before: { 11, 11, 22, 22, 33, 33, 00, 00, 77, 77, 88, 88, 00, 00, 00, 00  }
+    //   compress: 6
+    //          b: 10
+    //      after: { 11, 11, 22, 22, 33, 33, 00, 00, 00, 00, 00, 00, 77, 77, 88, 88 }
+    //
+    if (b != address.length) {
+      if (compress == -1) return null; // Address didn't have compression or enough groups.
+      System.arraycopy(address, compress, address, address.length - (b - compress), b - compress);
+      Arrays.fill(address, compress, compress + (address.length - b), (byte) 0);
+    }
+
+    try {
+      return InetAddress.getByAddress(address);
+    } catch (UnknownHostException e) {
+      throw new AssertionError();
+    }
+  }
+
+  /** Decodes an IPv4 address suffix of an IPv6 address, like 1111::5555:6666:192.168.0.1. */
+  private static boolean decodeIpv4Suffix(
+      String input, int pos, int limit, byte[] address, int addressOffset) {
+    int b = addressOffset;
+
+    for (int i = pos; i < limit; ) {
+      if (b == address.length) return false; // Too many groups.
+
+      // Read a delimiter.
+      if (b != addressOffset) {
+        if (input.charAt(i) != '.') return false; // Wrong delimiter.
+        i++;
+      }
+
+      // Read 1 or more decimal digits for a value in 0..255.
+      int value = 0;
+      int groupOffset = i;
+      for (; i < limit; i++) {
+        char c = input.charAt(i);
+        if (c < '0' || c > '9') break;
+        if (value == 0 && groupOffset != i) return false; // Reject unnecessary leading '0's.
+        value = (value * 10) + c - '0';
+        if (value > 255) return false; // Value out of range.
+      }
+      int groupLength = i - groupOffset;
+      if (groupLength == 0) return false; // No digits.
+
+      // We've successfully read a byte.
+      address[b++] = (byte) value;
+    }
+
+    if (b != addressOffset + 4) return false; // Too few groups. We wanted exactly four.
+    return true; // Success.
+  }
+
+  /** Encodes an IPv6 address in canonical form according to RFC 5952. */
+  private static String inet6AddressToAscii(byte[] address) {
+    // Go through the address looking for the longest run of 0s. Each group is 2-bytes.
+    // A run must be longer than one group (section 4.2.2).
+    // If there are multiple equal runs, the first one must be used (section 4.2.3).
+    int longestRunOffset = -1;
+    int longestRunLength = 0;
+    for (int i = 0; i < address.length; i += 2) {
+      int currentRunOffset = i;
+      while (i < 16 && address[i] == 0 && address[i + 1] == 0) {
+        i += 2;
+      }
+      int currentRunLength = i - currentRunOffset;
+      if (currentRunLength > longestRunLength && currentRunLength >= 4) {
+        longestRunOffset = currentRunOffset;
+        longestRunLength = currentRunLength;
+      }
+    }
+
+    // Emit each 2-byte group in hex, separated by ':'. The longest run of zeroes is "::".
+    Buffer result = new Buffer();
+    for (int i = 0; i < address.length; ) {
+      if (i == longestRunOffset) {
+        result.writeByte(':');
+        i += longestRunLength;
+        if (i == 16) result.writeByte(':');
+      } else {
+        if (i > 0) result.writeByte(':');
+        int group = (address[i] & 0xff) << 8 | address[i + 1] & 0xff;
+        result.writeHexadecimalUnsignedLong(group);
+        i += 2;
+      }
+    }
+    return result.readUtf8();
+  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java b/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java
new file mode 100644
index 0000000000..d46494d95b
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java
@@ -0,0 +1,267 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package okhttp3.internal.cache;
+
+import java.io.IOException;
+import okhttp3.Headers;
+import okhttp3.Interceptor;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.internal.Internal;
+import okhttp3.internal.Util;
+import okhttp3.internal.http.HttpCodec;
+import okhttp3.internal.http.HttpHeaders;
+import okhttp3.internal.http.HttpMethod;
+import okhttp3.internal.http.RealResponseBody;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.Okio;
+import okio.Sink;
+import okio.Source;
+import okio.Timeout;
+
+import static java.net.HttpURLConnection.HTTP_NOT_MODIFIED;
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static okhttp3.internal.Util.closeQuietly;
+import static okhttp3.internal.Util.discard;
+
+/** Serves requests from the cache and writes responses to the cache. */
+public final class CacheInterceptor implements Interceptor {
+  final InternalCache cache;
+
+  public CacheInterceptor(InternalCache cache) {
+    this.cache = cache;
+  }
+
+  @Override public Response intercept(Chain chain) throws IOException {
+    Response cacheCandidate = cache != null
+        ? cache.get(chain.request())
+        : null;
+
+    long now = System.currentTimeMillis();
+
+    CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();
+    Request networkRequest = strategy.networkRequest;
+    Response cacheResponse = strategy.cacheResponse;
+
+    if (cache != null) {
+      cache.trackResponse(strategy);
+    }
+
+    if (cacheCandidate != null && cacheResponse == null) {
+      closeQuietly(cacheCandidate.body()); // The cache candidate wasn't applicable. Close it.
+    }
+
+    // If we're forbidden from using the network and the cache is insufficient, fail.
+    if (networkRequest == null && cacheResponse == null) {
+      return new Response.Builder()
+          .request(chain.request())
+          .protocol(Protocol.HTTP_1_1)
+          .code(504)
+          .message("Unsatisfiable Request (only-if-cached)")
+          .body(Util.EMPTY_RESPONSE)
+          .sentRequestAtMillis(-1L)
+          .receivedResponseAtMillis(System.currentTimeMillis())
+          .build();
+    }
+
+    // If we don't need the network, we're done.
+    if (networkRequest == null) {
+      return cacheResponse.newBuilder()
+          .cacheResponse(stripBody(cacheResponse))
+          .build();
+    }
+
+    Response networkResponse = null;
+    try {
+      networkResponse = chain.proceed(networkRequest);
+    } finally {
+      // If we're crashing on I/O or otherwise, don't leak the cache body.
+      if (networkResponse == null && cacheCandidate != null) {
+        closeQuietly(cacheCandidate.body());
+      }
+    }
+
+    // If we have a cache response too, then we're doing a conditional get.
+    if (cacheResponse != null) {
+      if (networkResponse.code() == HTTP_NOT_MODIFIED) {
+        Response response = cacheResponse.newBuilder()
+            .headers(combine(cacheResponse.headers(), networkResponse.headers()))
+            .sentRequestAtMillis(networkResponse.sentRequestAtMillis())
+            .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())
+            .cacheResponse(stripBody(cacheResponse))
+            .networkResponse(stripBody(networkResponse))
+            .build();
+        networkResponse.body().close();
+
+        // Update the cache after combining headers but before stripping the
+        // Content-Encoding header (as performed by initContentStream()).
+        cache.trackConditionalCacheHit();
+        cache.update(cacheResponse, response);
+        return response;
+      } else {
+        closeQuietly(cacheResponse.body());
+      }
+    }
+
+    Response response = networkResponse.newBuilder()
+        .cacheResponse(stripBody(cacheResponse))
+        .networkResponse(stripBody(networkResponse))
+        .build();
+
+    if (cache != null) {
+      if (HttpHeaders.hasBody(response) && CacheStrategy.isCacheable(response, networkRequest)) {
+        // Offer this request to the cache.
+        CacheRequest cacheRequest = cache.put(response);
+        return cacheWritingResponse(cacheRequest, response);
+      }
+
+      if (HttpMethod.invalidatesCache(networkRequest.method())) {
+        try {
+          cache.remove(networkRequest);
+        } catch (IOException ignored) {
+          // The cache cannot be written.
+        }
+      }
+    }
+
+    return response;
+  }
+
+  private static Response stripBody(Response response) {
+    return response != null && response.body() != null
+        ? response.newBuilder().body(null).build()
+        : response;
+  }
+
+  /**
+   * Returns a new source that writes bytes to {@code cacheRequest} as they are read by the source
+   * consumer. This is careful to discard bytes left over when the stream is closed; otherwise we
+   * may never exhaust the source stream and therefore not complete the cached response.
+   */
+  private Response cacheWritingResponse(final CacheRequest cacheRequest, Response response)
+      throws IOException {
+    // Some apps return a null body; for compatibility we treat that like a null cache request.
+    if (cacheRequest == null) return response;
+    Sink cacheBodyUnbuffered = cacheRequest.body();
+    if (cacheBodyUnbuffered == null) return response;
+
+    final BufferedSource source = response.body().source();
+    final BufferedSink cacheBody = Okio.buffer(cacheBodyUnbuffered);
+
+    Source cacheWritingSource = new Source() {
+      boolean cacheRequestClosed;
+
+      @Override public long read(Buffer sink, long byteCount) throws IOException {
+        long bytesRead;
+        try {
+          bytesRead = source.read(sink, byteCount);
+        } catch (IOException e) {
+          if (!cacheRequestClosed) {
+            cacheRequestClosed = true;
+            cacheRequest.abort(); // Failed to write a complete cache response.
+          }
+          throw e;
+        }
+
+        if (bytesRead == -1) {
+          if (!cacheRequestClosed) {
+            cacheRequestClosed = true;
+            cacheBody.close(); // The cache response is complete!
+          }
+          return -1;
+        }
+
+        sink.copyTo(cacheBody.buffer(), sink.size() - bytesRead, bytesRead);
+        cacheBody.emitCompleteSegments();
+        return bytesRead;
+      }
+
+      @Override public Timeout timeout() {
+        return source.timeout();
+      }
+
+      @Override public void close() throws IOException {
+        if (!cacheRequestClosed
+            && !discard(this, HttpCodec.DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
+          cacheRequestClosed = true;
+          cacheRequest.abort();
+        }
+        source.close();
+      }
+    };
+
+    String contentType = response.header("Content-Type");
+    long contentLength = response.body().contentLength();
+    return response.newBuilder()
+        .body(new RealResponseBody(contentType, contentLength, Okio.buffer(cacheWritingSource)))
+        .build();
+  }
+
+  /** Combines cached headers with a network headers as defined by RFC 7234, 4.3.4. */
+  private static Headers combine(Headers cachedHeaders, Headers networkHeaders) {
+    Headers.Builder result = new Headers.Builder();
+
+    for (int i = 0, size = cachedHeaders.size(); i < size; i++) {
+      String fieldName = cachedHeaders.name(i);
+      String value = cachedHeaders.value(i);
+      if ("Warning".equalsIgnoreCase(fieldName) && value.startsWith("1")) {
+        continue; // Drop 100-level freshness warnings.
+      }
+      if (isContentSpecificHeader(fieldName) || !isEndToEnd(fieldName)
+              || networkHeaders.get(fieldName) == null) {
+        Internal.instance.addLenient(result, fieldName, value);
+      }
+    }
+
+    for (int i = 0, size = networkHeaders.size(); i < size; i++) {
+      String fieldName = networkHeaders.name(i);
+      if (!isContentSpecificHeader(fieldName) && isEndToEnd(fieldName)) {
+        Internal.instance.addLenient(result, fieldName, networkHeaders.value(i));
+      }
+    }
+
+    return result.build();
+  }
+
+  /**
+   * Returns true if {@code fieldName} is an end-to-end HTTP header, as defined by RFC 2616,
+   * 13.5.1.
+   */
+  static boolean isEndToEnd(String fieldName) {
+    return !"Connection".equalsIgnoreCase(fieldName)
+        && !"Keep-Alive".equalsIgnoreCase(fieldName)
+        && !"Proxy-Authenticate".equalsIgnoreCase(fieldName)
+        && !"Proxy-Authorization".equalsIgnoreCase(fieldName)
+        && !"TE".equalsIgnoreCase(fieldName)
+        && !"Trailers".equalsIgnoreCase(fieldName)
+        && !"Transfer-Encoding".equalsIgnoreCase(fieldName)
+        && !"Upgrade".equalsIgnoreCase(fieldName);
+  }
+
+  /**
+   * Returns true if {@code fieldName} is content specific and therefore should always be used
+   * from cached headers.
+   */
+  static boolean isContentSpecificHeader(String fieldName) {
+    return "Content-Length".equalsIgnoreCase(fieldName)
+        || "Content-Encoding".equalsIgnoreCase(fieldName)
+        || "Content-Type".equalsIgnoreCase(fieldName);
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/CacheRequest.java b/okhttp/src/main/java/okhttp3/internal/cache/CacheRequest.java
similarity index 95%
rename from okhttp/src/main/java/okhttp3/internal/http/CacheRequest.java
rename to okhttp/src/main/java/okhttp3/internal/cache/CacheRequest.java
index 12c3134e8a..b4432b4e1d 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/CacheRequest.java
+++ b/okhttp/src/main/java/okhttp3/internal/cache/CacheRequest.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.http;
+package okhttp3.internal.cache;
 
 import java.io.IOException;
 import okio.Sink;
diff --git a/okhttp/src/main/java/okhttp3/internal/http/CacheStrategy.java b/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java
similarity index 88%
rename from okhttp/src/main/java/okhttp3/internal/http/CacheStrategy.java
rename to okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java
index 7aa8af1a4b..3ae1926650 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/CacheStrategy.java
+++ b/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java
@@ -13,13 +13,18 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.http;
+package okhttp3.internal.cache;
 
 import java.util.Date;
+import javax.annotation.Nullable;
 import okhttp3.CacheControl;
 import okhttp3.Headers;
 import okhttp3.Request;
 import okhttp3.Response;
+import okhttp3.internal.Internal;
+import okhttp3.internal.http.HttpDate;
+import okhttp3.internal.http.HttpHeaders;
+import okhttp3.internal.http.StatusLine;
 
 import static java.net.HttpURLConnection.HTTP_BAD_METHOD;
 import static java.net.HttpURLConnection.HTTP_GONE;
@@ -44,12 +49,12 @@
  */
 public final class CacheStrategy {
   /** The request to send on the network, or null if this call doesn't use the network. */
-  public final Request networkRequest;
+  public final @Nullable Request networkRequest;
 
   /** The cached response to return or validate; or null if this call doesn't use a cache. */
-  public final Response cacheResponse;
+  public final @Nullable Response cacheResponse;
 
-  private CacheStrategy(Request networkRequest, Response cacheResponse) {
+  CacheStrategy(Request networkRequest, Response cacheResponse) {
     this.networkRequest = networkRequest;
     this.cacheResponse = cacheResponse;
   }
@@ -155,7 +160,7 @@ public Factory(long nowMillis, Request request, Response cacheResponse) {
           } else if ("ETag".equalsIgnoreCase(fieldName)) {
             etag = value;
           } else if ("Age".equalsIgnoreCase(fieldName)) {
-            ageSeconds = HeaderParser.parseSeconds(value, -1);
+            ageSeconds = HttpHeaders.parseSeconds(value, -1);
           }
         }
       }
@@ -199,6 +204,11 @@ private CacheStrategy getCandidate() {
         return new CacheStrategy(request, null);
       }
 
+      CacheControl responseCaching = cacheResponse.cacheControl();
+      if (responseCaching.immutable()) {
+        return new CacheStrategy(null, cacheResponse);
+      }
+
       long ageMillis = cacheResponseAge();
       long freshMillis = computeFreshnessLifetime();
 
@@ -212,7 +222,6 @@ private CacheStrategy getCandidate() {
       }
 
       long maxStaleMillis = 0;
-      CacheControl responseCaching = cacheResponse.cacheControl();
       if (!responseCaching.mustRevalidate() && requestCaching.maxStaleSeconds() != -1) {
         maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds());
       }
@@ -229,20 +238,30 @@ private CacheStrategy getCandidate() {
         return new CacheStrategy(null, builder.build());
       }
 
-      Request.Builder conditionalRequestBuilder = request.newBuilder();
-
+      // Find a condition to add to the request. If the condition is satisfied, the response body
+      // will not be transmitted.
+      String conditionName;
+      String conditionValue;
       if (etag != null) {
-        conditionalRequestBuilder.header("If-None-Match", etag);
+        conditionName = "If-None-Match";
+        conditionValue = etag;
       } else if (lastModified != null) {
-        conditionalRequestBuilder.header("If-Modified-Since", lastModifiedString);
+        conditionName = "If-Modified-Since";
+        conditionValue = lastModifiedString;
       } else if (servedDate != null) {
-        conditionalRequestBuilder.header("If-Modified-Since", servedDateString);
+        conditionName = "If-Modified-Since";
+        conditionValue = servedDateString;
+      } else {
+        return new CacheStrategy(request, null); // No condition! Make a regular request.
       }
 
-      Request conditionalRequest = conditionalRequestBuilder.build();
-      return hasConditions(conditionalRequest)
-          ? new CacheStrategy(conditionalRequest, cacheResponse)
-          : new CacheStrategy(conditionalRequest, null);
+      Headers.Builder conditionalRequestHeaders = request.headers().newBuilder();
+      Internal.instance.addLenient(conditionalRequestHeaders, conditionName, conditionValue);
+
+      Request conditionalRequest = request.newBuilder()
+          .headers(conditionalRequestHeaders.build())
+          .build();
+      return new CacheStrategy(conditionalRequest, cacheResponse);
     }
 
     /**
@@ -276,7 +295,7 @@ private long computeFreshnessLifetime() {
 
     /**
      * Returns the current age of the response, in milliseconds. The calculation is specified by RFC
-     * 2616, 13.2.3 Age Calculations.
+     * 7234, 4.2.3 Calculating Age.
      */
     private long cacheResponseAge() {
       long apparentReceivedAge = servedDate != null
diff --git a/okhttp/src/main/java/okhttp3/internal/DiskLruCache.java b/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.java
similarity index 93%
rename from okhttp/src/main/java/okhttp3/internal/DiskLruCache.java
rename to okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.java
index 097686bf28..c3fb740e28 100644
--- a/okhttp/src/main/java/okhttp3/internal/DiskLruCache.java
+++ b/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal;
+package okhttp3.internal.cache;
 
 import java.io.Closeable;
 import java.io.EOFException;
@@ -32,16 +32,17 @@
 import java.util.concurrent.TimeUnit;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
+import javax.annotation.Nullable;
+import okhttp3.internal.Util;
 import okhttp3.internal.io.FileSystem;
-import okio.Buffer;
+import okhttp3.internal.platform.Platform;
 import okio.BufferedSink;
 import okio.BufferedSource;
 import okio.Okio;
 import okio.Sink;
 import okio.Source;
-import okio.Timeout;
 
-import static okhttp3.internal.Platform.WARN;
+import static okhttp3.internal.platform.Platform.WARN;
 
 /**
  * A cache that uses a bounded amount of space on a filesystem. Each cache entry has a string key
@@ -136,25 +137,25 @@
      * it exists when the cache is opened.
      */
 
-  private final FileSystem fileSystem;
-  private final File directory;
+  final FileSystem fileSystem;
+  final File directory;
   private final File journalFile;
   private final File journalFileTmp;
   private final File journalFileBackup;
   private final int appVersion;
   private long maxSize;
-  private final int valueCount;
+  final int valueCount;
   private long size = 0;
-  private BufferedSink journalWriter;
-  private final LinkedHashMap<String, Entry> lruEntries = new LinkedHashMap<>(0, 0.75f, true);
-  private int redundantOpCount;
-  private boolean hasJournalErrors;
+  BufferedSink journalWriter;
+  final LinkedHashMap<String, Entry> lruEntries = new LinkedHashMap<>(0, 0.75f, true);
+  int redundantOpCount;
+  boolean hasJournalErrors;
 
   // Must be read and written when synchronized on 'this'.
-  private boolean initialized;
-  private boolean closed;
-  private boolean mostRecentTrimFailed;
-  private boolean mostRecentRebuildFailed;
+  boolean initialized;
+  boolean closed;
+  boolean mostRecentTrimFailed;
+  boolean mostRecentRebuildFailed;
 
   /**
    * To differentiate between old and current snapshots, each entry is given a sequence number each
@@ -185,7 +186,7 @@ public void run() {
           }
         } catch (IOException e) {
           mostRecentRebuildFailed = true;
-          journalWriter = Okio.buffer(NULL_SINK);
+          journalWriter = Okio.buffer(Okio.blackhole());
         }
       }
     }
@@ -231,7 +232,13 @@ public synchronized void initialize() throws IOException {
       } catch (IOException journalIsCorrupt) {
         Platform.get().log(WARN, "DiskLruCache " + directory + " is corrupt: "
             + journalIsCorrupt.getMessage() + ", removing", journalIsCorrupt);
+      }
+
+      // The cache is corrupted, attempt to delete the contents of the directory. This can throw and
+      // we'll let that propagate out as it likely means there is a severe filesystem problem.
+      try {
         delete();
+      } finally {
         closed = false;
       }
     }
@@ -381,7 +388,7 @@ private void processJournal() throws IOException {
    * Creates a new journal that omits redundant information. This replaces the current journal if it
    * exists.
    */
-  private synchronized void rebuildJournal() throws IOException {
+  synchronized void rebuildJournal() throws IOException {
     if (journalWriter != null) {
       journalWriter.close();
     }
@@ -448,11 +455,11 @@ public synchronized Snapshot get(String key) throws IOException {
   /**
    * Returns an editor for the entry named {@code key}, or null if another edit is in progress.
    */
-  public Editor edit(String key) throws IOException {
+  public @Nullable Editor edit(String key) throws IOException {
     return edit(key, ANY_SEQUENCE_NUMBER);
   }
 
-  private synchronized Editor edit(String key, long expectedSequenceNumber) throws IOException {
+  synchronized Editor edit(String key, long expectedSequenceNumber) throws IOException {
     initialize();
 
     checkNotClosed();
@@ -524,7 +531,7 @@ public synchronized long size() throws IOException {
     return size;
   }
 
-  private synchronized void completeEdit(Editor editor, boolean success) throws IOException {
+  synchronized void completeEdit(Editor editor, boolean success) throws IOException {
     Entry entry = editor.entry;
     if (entry.currentEditor != editor) {
       throw new IllegalStateException();
@@ -588,7 +595,7 @@ private synchronized void completeEdit(Editor editor, boolean success) throws IO
    * We only rebuild the journal when it will halve the size of the journal and eliminate at least
    * 2000 ops.
    */
-  private boolean journalRebuildRequired() {
+  boolean journalRebuildRequired() {
     final int redundantOpCompactThreshold = 2000;
     return redundantOpCount >= redundantOpCompactThreshold
         && redundantOpCount >= lruEntries.size();
@@ -612,7 +619,7 @@ public synchronized boolean remove(String key) throws IOException {
     return removed;
   }
 
-  private boolean removeEntry(Entry entry) throws IOException {
+  boolean removeEntry(Entry entry) throws IOException {
     if (entry.currentEditor != null) {
       entry.currentEditor.detach(); // Prevent the edit from completing normally.
     }
@@ -672,7 +679,7 @@ private synchronized void checkNotClosed() {
     closed = true;
   }
 
-  private void trimToSize() throws IOException {
+  void trimToSize() throws IOException {
     while (size > maxSize) {
       Entry toEvict = lruEntries.values().iterator().next();
       removeEntry(toEvict);
@@ -784,7 +791,7 @@ private void validateKey(String key) {
     private final Source[] sources;
     private final long[] lengths;
 
-    private Snapshot(String key, long sequenceNumber, Source[] sources, long[] lengths) {
+    Snapshot(String key, long sequenceNumber, Source[] sources, long[] lengths) {
       this.key = key;
       this.sequenceNumber = sequenceNumber;
       this.sources = sources;
@@ -799,7 +806,7 @@ public String key() {
      * Returns an editor for this snapshot's entry, or null if either the entry has changed since
      * this snapshot was created or if another edit is in progress.
      */
-    public Editor edit() throws IOException {
+    public @Nullable Editor edit() throws IOException {
       return DiskLruCache.this.edit(key, sequenceNumber);
     }
 
@@ -820,29 +827,13 @@ public void close() {
     }
   }
 
-  private static final Sink NULL_SINK = new Sink() {
-    @Override public void write(Buffer source, long byteCount) throws IOException {
-      source.skip(byteCount);
-    }
-
-    @Override public void flush() throws IOException {
-    }
-
-    @Override public Timeout timeout() {
-      return Timeout.NONE;
-    }
-
-    @Override public void close() throws IOException {
-    }
-  };
-
   /** Edits the values for an entry. */
   public final class Editor {
-    private final Entry entry;
-    private final boolean[] written;
+    final Entry entry;
+    final boolean[] written;
     private boolean done;
 
-    private Editor(Entry entry) {
+    Editor(Entry entry) {
       this.entry = entry;
       this.written = (entry.readable) ? null : new boolean[valueCount];
     }
@@ -870,7 +861,7 @@ void detach() {
      * Returns an unbuffered input stream to read the last committed value, or null if no value has
      * been committed.
      */
-    public Source newSource(int index) throws IOException {
+    public Source newSource(int index) {
       synchronized (DiskLruCache.this) {
         if (done) {
           throw new IllegalStateException();
@@ -891,13 +882,13 @@ public Source newSource(int index) throws IOException {
      * output stream encounters errors when writing to the filesystem, this edit will be aborted
      * when {@link #commit} is called. The returned output stream does not throw IOExceptions.
      */
-    public Sink newSink(int index) throws IOException {
+    public Sink newSink(int index) {
       synchronized (DiskLruCache.this) {
         if (done) {
           throw new IllegalStateException();
         }
         if (entry.currentEditor != this) {
-          return NULL_SINK;
+          return Okio.blackhole();
         }
         if (!entry.readable) {
           written[index] = true;
@@ -907,7 +898,7 @@ public Sink newSink(int index) throws IOException {
         try {
           sink = fileSystem.sink(dirtyFile);
         } catch (FileNotFoundException e) {
-          return NULL_SINK;
+          return Okio.blackhole();
         }
         return new FaultHidingSink(sink) {
           @Override protected void onException(IOException e) {
@@ -964,23 +955,23 @@ public void abortUnlessCommitted() {
   }
 
   private final class Entry {
-    private final String key;
+    final String key;
 
     /** Lengths of this entry's files. */
-    private final long[] lengths;
-    private final File[] cleanFiles;
-    private final File[] dirtyFiles;
+    final long[] lengths;
+    final File[] cleanFiles;
+    final File[] dirtyFiles;
 
     /** True if this entry has ever been published. */
-    private boolean readable;
+    boolean readable;
 
     /** The ongoing edit or null if this entry is not being edited. */
-    private Editor currentEditor;
+    Editor currentEditor;
 
     /** The sequence number of the most recently committed edit to this entry. */
-    private long sequenceNumber;
+    long sequenceNumber;
 
-    private Entry(String key) {
+    Entry(String key) {
       this.key = key;
 
       lengths = new long[valueCount];
@@ -1000,7 +991,7 @@ private Entry(String key) {
     }
 
     /** Set lengths using decimal numbers like "10123". */
-    private void setLengths(String[] strings) throws IOException {
+    void setLengths(String[] strings) throws IOException {
       if (strings.length != valueCount) {
         throw invalidLengths(strings);
       }
diff --git a/okhttp/src/main/java/okhttp3/internal/FaultHidingSink.java b/okhttp/src/main/java/okhttp3/internal/cache/FaultHidingSink.java
similarity index 95%
rename from okhttp/src/main/java/okhttp3/internal/FaultHidingSink.java
rename to okhttp/src/main/java/okhttp3/internal/cache/FaultHidingSink.java
index e77f6bb448..561a30507e 100644
--- a/okhttp/src/main/java/okhttp3/internal/FaultHidingSink.java
+++ b/okhttp/src/main/java/okhttp3/internal/cache/FaultHidingSink.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal;
+package okhttp3.internal.cache;
 
 import java.io.IOException;
 import okio.Buffer;
@@ -24,7 +24,7 @@
 class FaultHidingSink extends ForwardingSink {
   private boolean hasErrors;
 
-  public FaultHidingSink(Sink delegate) {
+  FaultHidingSink(Sink delegate) {
     super(delegate);
   }
 
diff --git a/okhttp/src/main/java/okhttp3/internal/InternalCache.java b/okhttp/src/main/java/okhttp3/internal/cache/InternalCache.java
similarity index 90%
rename from okhttp/src/main/java/okhttp3/internal/InternalCache.java
rename to okhttp/src/main/java/okhttp3/internal/cache/InternalCache.java
index 9752002bc5..6c70465b59 100644
--- a/okhttp/src/main/java/okhttp3/internal/InternalCache.java
+++ b/okhttp/src/main/java/okhttp3/internal/cache/InternalCache.java
@@ -13,13 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal;
+package okhttp3.internal.cache;
 
 import java.io.IOException;
 import okhttp3.Request;
 import okhttp3.Response;
-import okhttp3.internal.http.CacheRequest;
-import okhttp3.internal.http.CacheStrategy;
 
 /**
  * OkHttp's internal cache interface. Applications shouldn't implement this: instead use {@link
@@ -41,7 +39,7 @@
    * {@code network}. The cached response body is not updated. If the stored response has changed
    * since {@code cached} was returned, this does nothing.
    */
-  void update(Response cached, Response network) throws IOException;
+  void update(Response cached, Response network);
 
   /** Track an conditional GET that was satisfied by this cache. */
   void trackConditionalCacheHit();
diff --git a/okhttp/src/main/java/okhttp3/internal/cache2/FileOperator.java b/okhttp/src/main/java/okhttp3/internal/cache2/FileOperator.java
new file mode 100644
index 0000000000..b1326cddc9
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/cache2/FileOperator.java
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.cache2;
+
+import java.io.EOFException;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.channels.FileChannel;
+import okio.Buffer;
+import okio.Okio;
+
+/**
+ * Read and write a target file. Unlike Okio's built-in {@linkplain Okio#source(java.io.File) file
+ * source} and {@linkplain Okio#sink(java.io.File) file sink} this class offers:
+ *
+ * <ul>
+ *   <li><strong>Read/write:</strong> read and write using the same operator.
+ *   <li><strong>Random access:</strong> access any position within the file.
+ *   <li><strong>Shared channels:</strong> read and write a file channel that's shared between
+ *       multiple operators. Note that although the underlying {@code FileChannel} may be shared,
+ *       each {@code FileOperator} should not be.
+ * </ul>
+ */
+final class FileOperator {
+  private static final int BUFFER_SIZE = 8192;
+
+  private final byte[] byteArray = new byte[BUFFER_SIZE];
+  private final ByteBuffer byteBuffer = ByteBuffer.wrap(byteArray);
+  private final FileChannel fileChannel;
+
+  FileOperator(FileChannel fileChannel) {
+    this.fileChannel = fileChannel;
+  }
+
+  /** Write {@code byteCount} bytes from {@code source} to the file at {@code pos}. */
+  public void write(long pos, Buffer source, long byteCount) throws IOException {
+    if (byteCount < 0 || byteCount > source.size()) throw new IndexOutOfBoundsException();
+
+    while (byteCount > 0L) {
+      try {
+        // Write bytes to the byte[], and tell the ByteBuffer wrapper about 'em.
+        int toWrite = (int) Math.min(BUFFER_SIZE, byteCount);
+        source.read(byteArray, 0, toWrite);
+        byteBuffer.limit(toWrite);
+
+        // Copy bytes from the ByteBuffer to the file.
+        do {
+          int bytesWritten = fileChannel.write(byteBuffer, pos);
+          pos += bytesWritten;
+        } while (byteBuffer.hasRemaining());
+
+        byteCount -= toWrite;
+      } finally {
+        byteBuffer.clear();
+      }
+    }
+  }
+
+  /**
+   * Copy {@code byteCount} bytes from the file at {@code pos} into to {@code source}. It is the
+   * caller's responsibility to make sure there are sufficient bytes to read: if there aren't this
+   * method throws an {@link EOFException}.
+   */
+  public void read(long pos, Buffer sink, long byteCount) throws IOException {
+    if (byteCount < 0) throw new IndexOutOfBoundsException();
+
+    while (byteCount > 0L) {
+      try {
+        // Read up to byteCount bytes.
+        byteBuffer.limit((int) Math.min(BUFFER_SIZE, byteCount));
+        if (fileChannel.read(byteBuffer, pos) == -1) throw new EOFException();
+        int bytesRead = byteBuffer.position();
+
+        // Write those bytes to sink.
+        sink.write(byteArray, 0, bytesRead);
+        pos += bytesRead;
+        byteCount -= bytesRead;
+      } finally {
+        byteBuffer.clear();
+      }
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/cache2/Relay.java b/okhttp/src/main/java/okhttp3/internal/cache2/Relay.java
new file mode 100644
index 0000000000..5131e6cd16
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/cache2/Relay.java
@@ -0,0 +1,361 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.cache2;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.RandomAccessFile;
+import okio.Buffer;
+import okio.ByteString;
+import okio.Source;
+import okio.Timeout;
+
+import static okhttp3.internal.Util.closeQuietly;
+
+/**
+ * Replicates a single upstream source into multiple downstream sources. Each downstream source
+ * returns the same bytes as the upstream source. Downstream sources may read data either as it
+ * is returned by upstream, or after the upstream source has been exhausted.
+ *
+ * <p>As bytes are returned from upstream they are written to a local file. Downstream sources read
+ * from this file as necessary.
+ *
+ * <p>This class also keeps a small buffer of bytes recently read from upstream. This is intended to
+ * save a small amount of file I/O and data copying.
+ */
+// TODO(jwilson): what to do about timeouts? They could be different and unfortunately when any
+//     timeout is hit we like to tear down the whole stream.
+final class Relay {
+  private static final int SOURCE_UPSTREAM = 1;
+  private static final int SOURCE_FILE = 2;
+
+  static final ByteString PREFIX_CLEAN = ByteString.encodeUtf8("OkHttp cache v1\n");
+  static final ByteString PREFIX_DIRTY = ByteString.encodeUtf8("OkHttp DIRTY :(\n");
+  private static final long FILE_HEADER_SIZE = 32L;
+
+  /**
+   * Read/write persistence of the upstream source and its metadata. Its layout is as follows:
+   *
+   * <ul>
+   *   <li>16 bytes: either {@code OkHttp cache v1\n} if the persisted file is complete. This is
+   *       another sequence of bytes if the file is incomplete and should not be used.
+   *   <li>8 bytes: <i>n</i>: upstream data size
+   *   <li>8 bytes: <i>m</i>: metadata size
+   *   <li><i>n</i> bytes: upstream data
+   *   <li><i>m</i> bytes: metadata
+   * </ul>
+   *
+   * <p>This is closed and assigned to null when the last source is closed and no further sources
+   * are permitted.
+   */
+  RandomAccessFile file;
+
+  /** The thread that currently has access to upstream. Possibly null. Guarded by this. */
+  Thread upstreamReader;
+
+  /**
+   * Null once the file has a complete copy of the upstream bytes. Only the {@code upstreamReader}
+   * thread may access this source.
+   */
+  Source upstream;
+
+  /**
+   * A buffer for {@code upstreamReader} to use when pulling bytes from upstream. Only the {@code
+   * upstreamReader} thread may access this buffer.
+   */
+  final Buffer upstreamBuffer = new Buffer();
+
+  /** The number of bytes consumed from {@link #upstream}. Guarded by this. */
+  long upstreamPos;
+
+  /** True if there are no further bytes to read from {@code upstream}. Guarded by this. */
+  boolean complete;
+
+  /** User-supplied additional data persisted with the source data. */
+  private final ByteString metadata;
+
+  /**
+   * The most recently read bytes from {@link #upstream}. This is a suffix of {@link #file}. Guarded
+   * by this.
+   */
+  final Buffer buffer = new Buffer();
+
+  /** The maximum size of {@code buffer}. */
+  final long bufferMaxSize;
+
+  /**
+   * Reference count of the number of active sources reading this stream. When decremented to 0
+   * resources are released and all following calls to {@link #newSource} return null. Guarded by
+   * this.
+   */
+  int sourceCount;
+
+  private Relay(RandomAccessFile file, Source upstream, long upstreamPos, ByteString metadata,
+      long bufferMaxSize) {
+    this.file = file;
+    this.upstream = upstream;
+    this.complete = upstream == null;
+    this.upstreamPos = upstreamPos;
+    this.metadata = metadata;
+    this.bufferMaxSize = bufferMaxSize;
+  }
+
+  /**
+   * Creates a new relay that reads a live stream from {@code upstream}, using {@code file} to share
+   * that data with other sources.
+   *
+   * <p><strong>Warning:</strong> callers to this method must immediately call {@link #newSource} to
+   * create a source and close that when they're done. Otherwise a handle to {@code file} will be
+   * leaked.
+   */
+  public static Relay edit(
+      File file, Source upstream, ByteString metadata, long bufferMaxSize) throws IOException {
+    RandomAccessFile randomAccessFile = new RandomAccessFile(file, "rw");
+    Relay result = new Relay(randomAccessFile, upstream, 0L, metadata, bufferMaxSize);
+
+    // Write a dirty header. That way if we crash we won't attempt to recover this.
+    randomAccessFile.setLength(0L);
+    result.writeHeader(PREFIX_DIRTY, -1L, -1L);
+
+    return result;
+  }
+
+  /**
+   * Creates a relay that reads a recorded stream from {@code file}.
+   *
+   * <p><strong>Warning:</strong> callers to this method must immediately call {@link #newSource} to
+   * create a source and close that when they're done. Otherwise a handle to {@code file} will be
+   * leaked.
+   */
+  public static Relay read(File file) throws IOException {
+    RandomAccessFile randomAccessFile = new RandomAccessFile(file, "rw");
+    FileOperator fileOperator = new FileOperator(randomAccessFile.getChannel());
+
+    // Read the header.
+    Buffer header = new Buffer();
+    fileOperator.read(0, header, FILE_HEADER_SIZE);
+    ByteString prefix = header.readByteString(PREFIX_CLEAN.size());
+    if (!prefix.equals(PREFIX_CLEAN)) throw new IOException("unreadable cache file");
+    long upstreamSize = header.readLong();
+    long metadataSize = header.readLong();
+
+    // Read the metadata.
+    Buffer metadataBuffer = new Buffer();
+    fileOperator.read(FILE_HEADER_SIZE + upstreamSize, metadataBuffer, metadataSize);
+    ByteString metadata = metadataBuffer.readByteString();
+
+    // Return the result.
+    return new Relay(randomAccessFile, null, upstreamSize, metadata, 0L);
+  }
+
+  private void writeHeader(
+      ByteString prefix, long upstreamSize, long metadataSize) throws IOException {
+    Buffer header = new Buffer();
+    header.write(prefix);
+    header.writeLong(upstreamSize);
+    header.writeLong(metadataSize);
+    if (header.size() != FILE_HEADER_SIZE) throw new IllegalArgumentException();
+
+    FileOperator fileOperator = new FileOperator(file.getChannel());
+    fileOperator.write(0, header, FILE_HEADER_SIZE);
+  }
+
+  private void writeMetadata(long upstreamSize) throws IOException {
+    Buffer metadataBuffer = new Buffer();
+    metadataBuffer.write(metadata);
+
+    FileOperator fileOperator = new FileOperator(file.getChannel());
+    fileOperator.write(FILE_HEADER_SIZE + upstreamSize, metadataBuffer, metadata.size());
+  }
+
+  void commit(long upstreamSize) throws IOException {
+    // Write metadata to the end of the file.
+    writeMetadata(upstreamSize);
+    file.getChannel().force(false);
+
+    // Once everything else is in place we can swap the dirty header for a clean one.
+    writeHeader(PREFIX_CLEAN, upstreamSize, metadata.size());
+    file.getChannel().force(false);
+
+    // This file is complete.
+    synchronized (Relay.this) {
+      complete = true;
+    }
+
+    closeQuietly(upstream);
+    upstream = null;
+  }
+
+  boolean isClosed() {
+    return file == null;
+  }
+
+  public ByteString metadata() {
+    return metadata;
+  }
+
+  /**
+   * Returns a new source that returns the same bytes as upstream. Returns null if this relay has
+   * been closed and no further sources are possible. In that case callers should retry after
+   * building a new relay with {@link #read}.
+   */
+  public Source newSource() {
+    synchronized (Relay.this) {
+      if (file == null) return null;
+      sourceCount++;
+    }
+
+    return new RelaySource();
+  }
+
+  class RelaySource implements Source {
+    private final Timeout timeout = new Timeout();
+
+    /** The operator to read and write the shared file. Null if this source is closed. */
+    private FileOperator fileOperator = new FileOperator(file.getChannel());
+
+    /** The next byte to read. This is always less than or equal to {@code upstreamPos}. */
+    private long sourcePos;
+
+    /**
+     * Selects where to find the bytes for a read and read them. This is one of three sources.
+     *
+     * <h3>Upstream:</h3>
+     * In this case the current thread is assigned as the upstream reader. We read bytes from
+     * upstream and copy them to both the file and to the buffer. Finally we release the upstream
+     * reader lock and return the new bytes.
+     *
+     * <h3>The file</h3>
+     * In this case we copy bytes from the file to the {@code sink}.
+     *
+     * <h3>The buffer</h3>
+     * In this case the bytes are immediately copied into {@code sink} and the number of bytes
+     * copied is returned.
+     *
+     * <p>If upstream would be selected but another thread is already reading upstream this will
+     * block until that read completes. It is possible to time out while waiting for that.
+     */
+    @Override public long read(Buffer sink, long byteCount) throws IOException {
+      if (fileOperator == null) throw new IllegalStateException("closed");
+
+      long upstreamPos;
+      int source;
+
+      selectSource:
+      synchronized (Relay.this) {
+        // We need new data from upstream.
+        while (sourcePos == (upstreamPos = Relay.this.upstreamPos)) {
+          // No more data upstream. We're done.
+          if (complete) return -1L;
+
+          // Another thread is already reading. Wait for that.
+          if (upstreamReader != null) {
+            timeout.waitUntilNotified(Relay.this);
+            continue;
+          }
+
+          // We will do the read.
+          upstreamReader = Thread.currentThread();
+          source = SOURCE_UPSTREAM;
+          break selectSource;
+        }
+
+        long bufferPos = upstreamPos - buffer.size();
+
+        // Bytes of the read precede the buffer. Read from the file.
+        if (sourcePos < bufferPos) {
+          source = SOURCE_FILE;
+          break selectSource;
+        }
+
+        // The buffer has the data we need. Read from there and return immediately.
+        long bytesToRead = Math.min(byteCount, upstreamPos - sourcePos);
+        buffer.copyTo(sink, sourcePos - bufferPos, bytesToRead);
+        sourcePos += bytesToRead;
+        return bytesToRead;
+      }
+
+      // Read from the file.
+      if (source == SOURCE_FILE) {
+        long bytesToRead = Math.min(byteCount, upstreamPos - sourcePos);
+        fileOperator.read(FILE_HEADER_SIZE + sourcePos, sink, bytesToRead);
+        sourcePos += bytesToRead;
+        return bytesToRead;
+      }
+
+      // Read from upstream. This always reads a full buffer: that might be more than what the
+      // current call to Source.read() has requested.
+      try {
+        long upstreamBytesRead = upstream.read(upstreamBuffer, bufferMaxSize);
+
+        // If we've exhausted upstream, we're done.
+        if (upstreamBytesRead == -1L) {
+          commit(upstreamPos);
+          return -1L;
+        }
+
+        // Update this source and prepare this call's result.
+        long bytesRead = Math.min(upstreamBytesRead, byteCount);
+        upstreamBuffer.copyTo(sink, 0, bytesRead);
+        sourcePos += bytesRead;
+
+        // Append the upstream bytes to the file.
+        fileOperator.write(
+            FILE_HEADER_SIZE + upstreamPos, upstreamBuffer.clone(), upstreamBytesRead);
+
+        synchronized (Relay.this) {
+          // Append new upstream bytes into the buffer. Trim it to its max size.
+          buffer.write(upstreamBuffer, upstreamBytesRead);
+          if (buffer.size() > bufferMaxSize) {
+            buffer.skip(buffer.size() - bufferMaxSize);
+          }
+
+          // Now that the file and buffer have bytes, adjust upstreamPos.
+          Relay.this.upstreamPos += upstreamBytesRead;
+        }
+
+        return bytesRead;
+      } finally {
+        synchronized (Relay.this) {
+          upstreamReader = null;
+          Relay.this.notifyAll();
+        }
+      }
+    }
+
+    @Override public Timeout timeout() {
+      return timeout;
+    }
+
+    @Override public void close() throws IOException {
+      if (fileOperator == null) return; // Already closed.
+      fileOperator = null;
+
+      RandomAccessFile fileToClose = null;
+      synchronized (Relay.this) {
+        sourceCount--;
+        if (sourceCount == 0) {
+          fileToClose = file;
+          file = null;
+        }
+      }
+
+      if (fileToClose != null) {
+        closeQuietly(fileToClose);
+      }
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/ConnectInterceptor.java b/okhttp/src/main/java/okhttp3/internal/connection/ConnectInterceptor.java
new file mode 100644
index 0000000000..b8a346c03a
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/connection/ConnectInterceptor.java
@@ -0,0 +1,47 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package okhttp3.internal.connection;
+
+import java.io.IOException;
+import okhttp3.Interceptor;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.internal.http.HttpCodec;
+import okhttp3.internal.http.RealInterceptorChain;
+
+/** Opens a connection to the target server and proceeds to the next interceptor. */
+public final class ConnectInterceptor implements Interceptor {
+  public final OkHttpClient client;
+
+  public ConnectInterceptor(OkHttpClient client) {
+    this.client = client;
+  }
+
+  @Override public Response intercept(Chain chain) throws IOException {
+    RealInterceptorChain realChain = (RealInterceptorChain) chain;
+    Request request = realChain.request();
+    StreamAllocation streamAllocation = realChain.streamAllocation();
+
+    // We need the network to satisfy this request. Possibly for validating a conditional GET.
+    boolean doExtensiveHealthChecks = !request.method().equals("GET");
+    HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks);
+    RealConnection connection = streamAllocation.connection();
+
+    return realChain.proceed(request, streamAllocation, httpCodec, connection);
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/ConnectionSpecSelector.java b/okhttp/src/main/java/okhttp3/internal/connection/ConnectionSpecSelector.java
similarity index 98%
rename from okhttp/src/main/java/okhttp3/internal/ConnectionSpecSelector.java
rename to okhttp/src/main/java/okhttp3/internal/connection/ConnectionSpecSelector.java
index 1393910b1b..0b438bfa1f 100644
--- a/okhttp/src/main/java/okhttp3/internal/ConnectionSpecSelector.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/ConnectionSpecSelector.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal;
+package okhttp3.internal.connection;
 
 import java.io.IOException;
 import java.io.InterruptedIOException;
@@ -27,6 +27,7 @@
 import javax.net.ssl.SSLProtocolException;
 import javax.net.ssl.SSLSocket;
 import okhttp3.ConnectionSpec;
+import okhttp3.internal.Internal;
 
 /**
  * Handles the connection spec fallback strategy: When a secure socket connection fails due to a
diff --git a/okhttp/src/main/java/okhttp3/internal/io/RealConnection.java b/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
similarity index 53%
rename from okhttp/src/main/java/okhttp3/internal/io/RealConnection.java
rename to okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
index ef6e8f84d9..b3d8924ae8 100644
--- a/okhttp/src/main/java/okhttp3/internal/io/RealConnection.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
@@ -14,7 +14,7 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package okhttp3.internal.io;
+package okhttp3.internal.connection;
 
 import java.io.IOException;
 import java.lang.ref.Reference;
@@ -22,37 +22,46 @@
 import java.net.ProtocolException;
 import java.net.Proxy;
 import java.net.Socket;
+import java.net.SocketException;
 import java.net.SocketTimeoutException;
 import java.net.UnknownServiceException;
 import java.security.cert.X509Certificate;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.TimeUnit;
+import javax.annotation.Nullable;
 import javax.net.ssl.SSLPeerUnverifiedException;
+import javax.net.ssl.SSLSession;
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
 import okhttp3.Address;
+import okhttp3.Call;
 import okhttp3.CertificatePinner;
 import okhttp3.Connection;
+import okhttp3.ConnectionPool;
 import okhttp3.ConnectionSpec;
+import okhttp3.EventListener;
 import okhttp3.Handshake;
 import okhttp3.HttpUrl;
+import okhttp3.Interceptor;
+import okhttp3.OkHttpClient;
 import okhttp3.Protocol;
 import okhttp3.Request;
 import okhttp3.Response;
 import okhttp3.Route;
-import okhttp3.internal.ConnectionSpecSelector;
-import okhttp3.internal.Platform;
+import okhttp3.internal.Internal;
 import okhttp3.internal.Util;
 import okhttp3.internal.Version;
-import okhttp3.internal.framed.ErrorCode;
-import okhttp3.internal.framed.FramedConnection;
-import okhttp3.internal.framed.FramedStream;
-import okhttp3.internal.http.Http1xStream;
-import okhttp3.internal.http.OkHeaders;
-import okhttp3.internal.http.RouteException;
-import okhttp3.internal.http.StreamAllocation;
+import okhttp3.internal.http.HttpCodec;
+import okhttp3.internal.http.HttpHeaders;
+import okhttp3.internal.http1.Http1Codec;
+import okhttp3.internal.http2.ErrorCode;
+import okhttp3.internal.http2.Http2Codec;
+import okhttp3.internal.http2.Http2Connection;
+import okhttp3.internal.http2.Http2Stream;
+import okhttp3.internal.platform.Platform;
 import okhttp3.internal.tls.OkHostnameVerifier;
+import okhttp3.internal.ws.RealWebSocket;
 import okio.BufferedSink;
 import okio.BufferedSource;
 import okio.Okio;
@@ -63,9 +72,15 @@
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static okhttp3.internal.Util.closeQuietly;
 
-public final class RealConnection extends FramedConnection.Listener implements Connection {
+public final class RealConnection extends Http2Connection.Listener implements Connection {
+  private static final String NPE_THROW_WITH_NULL = "throw with null exception";
+  private static final int MAX_TUNNEL_ATTEMPTS = 21;
+
+  private final ConnectionPool connectionPool;
   private final Route route;
 
+  // The fields below are initialized by connect() and never reassigned.
+
   /** The low-level TCP socket. */
   private Socket rawSocket;
 
@@ -73,43 +88,79 @@
    * The application layer socket. Either an {@link SSLSocket} layered over {@link #rawSocket}, or
    * {@link #rawSocket} itself if this connection does not use SSL.
    */
-  public Socket socket;
+  private Socket socket;
   private Handshake handshake;
   private Protocol protocol;
-  public volatile FramedConnection framedConnection;
+  private Http2Connection http2Connection;
+  private BufferedSource source;
+  private BufferedSink sink;
+
+  // The fields below track connection state and are guarded by connectionPool.
+
+  /** If true, no new streams can be created on this connection. Once true this is always true. */
+  public boolean noNewStreams;
+
   public int successCount;
-  public BufferedSource source;
-  public BufferedSink sink;
-  public int allocationLimit;
+
+  /**
+   * The maximum number of concurrent streams that can be carried by this connection. If {@code
+   * allocations.size() < allocationLimit} then new streams can be created on this connection.
+   */
+  public int allocationLimit = 1;
+
+  /** Current streams carried by this connection. */
   public final List<Reference<StreamAllocation>> allocations = new ArrayList<>();
-  public boolean noNewStreams;
+
+  /** Nanotime timestamp when {@code allocations.size()} reached zero. */
   public long idleAtNanos = Long.MAX_VALUE;
 
-  public RealConnection(Route route) {
+  public RealConnection(ConnectionPool connectionPool, Route route) {
+    this.connectionPool = connectionPool;
     this.route = route;
   }
 
+  public static RealConnection testConnection(
+      ConnectionPool connectionPool, Route route, Socket socket, long idleAtNanos) {
+    RealConnection result = new RealConnection(connectionPool, route);
+    result.socket = socket;
+    result.idleAtNanos = idleAtNanos;
+    return result;
+  }
+
   public void connect(int connectTimeout, int readTimeout, int writeTimeout,
-      List<ConnectionSpec> connectionSpecs, boolean connectionRetryEnabled) throws RouteException {
+      boolean connectionRetryEnabled, Call call, EventListener eventListener) {
     if (protocol != null) throw new IllegalStateException("already connected");
 
     RouteException routeException = null;
+    List<ConnectionSpec> connectionSpecs = route.address().connectionSpecs();
     ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);
 
-    if (route.address().sslSocketFactory() == null
-        && !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {
-      throw new RouteException(new UnknownServiceException(
-          "CLEARTEXT communication not supported: " + connectionSpecs));
+    if (route.address().sslSocketFactory() == null) {
+      if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {
+        throw new RouteException(new UnknownServiceException(
+            "CLEARTEXT communication not enabled for client"));
+      }
+      String host = route.address().url().host();
+      if (!Platform.get().isCleartextTrafficPermitted(host)) {
+        throw new RouteException(new UnknownServiceException(
+            "CLEARTEXT communication to " + host + " not permitted by network security policy"));
+      }
     }
 
-    while (protocol == null) {
+    while (true) {
       try {
         if (route.requiresTunnel()) {
-          buildTunneledConnection(connectTimeout, readTimeout, writeTimeout,
-              connectionSpecSelector);
+          connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener);
+          if (rawSocket == null) {
+            // We were unable to connect the tunnel but properly closed down our resources.
+            break;
+          }
         } else {
-          buildConnection(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);
+          connectSocket(connectTimeout, readTimeout, call, eventListener);
         }
+        establishProtocol(connectionSpecSelector, call, eventListener);
+        eventListener.connectEnd(call, route.socketAddress(), route.proxy(), protocol);
+        break;
       } catch (IOException e) {
         closeQuietly(socket);
         closeQuietly(rawSocket);
@@ -119,6 +170,9 @@ public void connect(int connectTimeout, int readTimeout, int writeTimeout,
         sink = null;
         handshake = null;
         protocol = null;
+        http2Connection = null;
+
+        eventListener.connectFailed(call, route.socketAddress(), route.proxy(), null, e);
 
         if (routeException == null) {
           routeException = new RouteException(e);
@@ -131,24 +185,30 @@ public void connect(int connectTimeout, int readTimeout, int writeTimeout,
         }
       }
     }
+
+    if (route.requiresTunnel() && rawSocket == null) {
+      ProtocolException exception = new ProtocolException("Too many tunnel connections attempted: "
+          + MAX_TUNNEL_ATTEMPTS);
+      throw new RouteException(exception);
+    }
+
+    if (http2Connection != null) {
+      synchronized (connectionPool) {
+        allocationLimit = http2Connection.maxConcurrentStreams();
+      }
+    }
   }
 
   /**
    * Does all the work to build an HTTPS connection over a proxy tunnel. The catch here is that a
    * proxy server can issue an auth challenge and then close the connection.
    */
-  private void buildTunneledConnection(int connectTimeout, int readTimeout, int writeTimeout,
-      ConnectionSpecSelector connectionSpecSelector) throws IOException {
+  private void connectTunnel(int connectTimeout, int readTimeout, int writeTimeout, Call call,
+      EventListener eventListener) throws IOException {
     Request tunnelRequest = createTunnelRequest();
     HttpUrl url = tunnelRequest.url();
-    int attemptedConnections = 0;
-    int maxAttempts = 21;
-    while (true) {
-      if (++attemptedConnections > maxAttempts) {
-        throw new ProtocolException("Too many tunnel connections attempted: " + maxAttempts);
-      }
-
-      connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);
+    for (int i = 0; i < MAX_TUNNEL_ATTEMPTS; i++) {
+      connectSocket(connectTimeout, readTimeout, call, eventListener);
       tunnelRequest = createTunnel(readTimeout, writeTimeout, tunnelRequest, url);
 
       if (tunnelRequest == null) break; // Tunnel successfully created.
@@ -159,20 +219,13 @@ private void buildTunneledConnection(int connectTimeout, int readTimeout, int wr
       rawSocket = null;
       sink = null;
       source = null;
+      eventListener.connectEnd(call, route.socketAddress(), route.proxy(), null);
     }
-
-    establishProtocol(readTimeout, writeTimeout, connectionSpecSelector);
   }
 
   /** Does all the work necessary to build a full HTTP or HTTPS connection on a raw socket. */
-  private void buildConnection(int connectTimeout, int readTimeout, int writeTimeout,
-      ConnectionSpecSelector connectionSpecSelector) throws IOException {
-    connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);
-    establishProtocol(readTimeout, writeTimeout, connectionSpecSelector);
-  }
-
-  private void connectSocket(int connectTimeout, int readTimeout, int writeTimeout,
-      ConnectionSpecSelector connectionSpecSelector) throws IOException {
+  private void connectSocket(int connectTimeout, int readTimeout, Call call,
+      EventListener eventListener) throws IOException {
     Proxy proxy = route.proxy();
     Address address = route.address();
 
@@ -180,45 +233,53 @@ private void connectSocket(int connectTimeout, int readTimeout, int writeTimeout
         ? address.socketFactory().createSocket()
         : new Socket(proxy);
 
+    eventListener.connectStart(call, route.socketAddress(), proxy);
     rawSocket.setSoTimeout(readTimeout);
     try {
       Platform.get().connectSocket(rawSocket, route.socketAddress(), connectTimeout);
     } catch (ConnectException e) {
-      throw new ConnectException("Failed to connect to " + route.socketAddress());
+      ConnectException ce = new ConnectException("Failed to connect to " + route.socketAddress());
+      ce.initCause(e);
+      throw ce;
+    }
+
+    // The following try/catch block is a pseudo hacky way to get around a crash on Android 7.0
+    // More details:
+    // https://github.com/square/okhttp/issues/3245
+    // https://android-review.googlesource.com/#/c/271775/
+    try {
+      source = Okio.buffer(Okio.source(rawSocket));
+      sink = Okio.buffer(Okio.sink(rawSocket));
+    } catch (NullPointerException npe) {
+      if (NPE_THROW_WITH_NULL.equals(npe.getMessage())) {
+        throw new IOException(npe);
+      }
     }
-    source = Okio.buffer(Okio.source(rawSocket));
-    sink = Okio.buffer(Okio.sink(rawSocket));
   }
 
-  private void establishProtocol(int readTimeout, int writeTimeout,
-      ConnectionSpecSelector connectionSpecSelector) throws IOException {
-    if (route.address().sslSocketFactory() != null) {
-      connectTls(readTimeout, writeTimeout, connectionSpecSelector);
-    } else {
+  private void establishProtocol(ConnectionSpecSelector connectionSpecSelector, Call call,
+      EventListener eventListener) throws IOException {
+    if (route.address().sslSocketFactory() == null) {
       protocol = Protocol.HTTP_1_1;
       socket = rawSocket;
+      return;
     }
 
-    if (protocol == Protocol.SPDY_3 || protocol == Protocol.HTTP_2) {
-      socket.setSoTimeout(0); // Framed connection timeouts are set per-stream.
+    eventListener.secureConnectStart(call);
+    connectTls(connectionSpecSelector);
+    eventListener.secureConnectEnd(call, handshake);
 
-      FramedConnection framedConnection = new FramedConnection.Builder(true)
+    if (protocol == Protocol.HTTP_2) {
+      socket.setSoTimeout(0); // HTTP/2 connection timeouts are set per-stream.
+      http2Connection = new Http2Connection.Builder(true)
           .socket(socket, route.address().url().host(), source, sink)
-          .protocol(protocol)
           .listener(this)
           .build();
-      framedConnection.start();
-
-      // Only assign the framed connection once the preface has been sent successfully.
-      this.allocationLimit = framedConnection.maxConcurrentStreams();
-      this.framedConnection = framedConnection;
-    } else {
-      this.allocationLimit = 1;
+      http2Connection.start();
     }
   }
 
-  private void connectTls(int readTimeout, int writeTimeout,
-      ConnectionSpecSelector connectionSpecSelector) throws IOException {
+  private void connectTls(ConnectionSpecSelector connectionSpecSelector) throws IOException {
     Address address = route.address();
     SSLSocketFactory sslSocketFactory = address.sslSocketFactory();
     boolean success = false;
@@ -237,7 +298,12 @@ private void connectTls(int readTimeout, int writeTimeout,
 
       // Force handshake. This can throw!
       sslSocket.startHandshake();
-      Handshake unverifiedHandshake = Handshake.get(sslSocket.getSession());
+      // block for session establishment
+      SSLSession sslSocketSession = sslSocket.getSession();
+      if (!isValid(sslSocketSession)) {
+        throw new IOException("a valid ssl session was not established");
+      }
+      Handshake unverifiedHandshake = Handshake.get(sslSocketSession);
 
       // Verify that the socket's certificates are acceptable for the target host.
       if (!address.hostnameVerifier().verify(address.url().host(), sslSocket.getSession())) {
@@ -277,6 +343,12 @@ private void connectTls(int readTimeout, int writeTimeout,
     }
   }
 
+  private boolean isValid(SSLSession sslSocketSession) {
+    // don't use SslSocket.getSession since for failed results it returns SSL_NULL_WITH_NULL_NULL
+    return !"NONE".equals(sslSocketSession.getProtocol()) && !"SSL_NULL_WITH_NULL_NULL".equals(
+        sslSocketSession.getCipherSuite());
+  }
+
   /**
    * To make an HTTPS connection over an HTTP proxy, send an unencrypted CONNECT request to create
    * the proxy connection. This may need to be retried if the proxy requires authorization.
@@ -286,15 +358,17 @@ private Request createTunnel(int readTimeout, int writeTimeout, Request tunnelRe
     // Make an SSL Tunnel on the first message pair of each SSL + proxy connection.
     String requestLine = "CONNECT " + Util.hostHeader(url, true) + " HTTP/1.1";
     while (true) {
-      Http1xStream tunnelConnection = new Http1xStream(null, source, sink);
+      Http1Codec tunnelConnection = new Http1Codec(null, null, source, sink);
       source.timeout().timeout(readTimeout, MILLISECONDS);
       sink.timeout().timeout(writeTimeout, MILLISECONDS);
       tunnelConnection.writeRequest(tunnelRequest.headers(), requestLine);
       tunnelConnection.finishRequest();
-      Response response = tunnelConnection.readResponse().request(tunnelRequest).build();
+      Response response = tunnelConnection.readResponseHeaders(false)
+          .request(tunnelRequest)
+          .build();
       // The response body from a CONNECT should be empty, but if it is not then we should consume
       // it before proceeding.
-      long contentLength = OkHeaders.contentLength(response);
+      long contentLength = HttpHeaders.contentLength(response);
       if (contentLength == -1L) {
         contentLength = 0L;
       }
@@ -334,18 +408,93 @@ private Request createTunnel(int readTimeout, int writeTimeout, Request tunnelRe
    * is sent unencrypted to the proxy server, so tunnels include only the minimum set of headers.
    * This avoids sending potentially sensitive data like HTTP cookies to the proxy unencrypted.
    */
-  private Request createTunnelRequest() throws IOException {
+  private Request createTunnelRequest() {
     return new Request.Builder()
         .url(route.address().url())
         .header("Host", Util.hostHeader(route.address().url(), true))
-        .header("Proxy-Connection", "Keep-Alive")
-        .header("User-Agent", Version.userAgent()) // For HTTP/1.0 proxies like Squid.
+        .header("Proxy-Connection", "Keep-Alive") // For HTTP/1.0 proxies like Squid.
+        .header("User-Agent", Version.userAgent())
         .build();
   }
 
-  /** Returns true if {@link #connect} has been attempted on this connection. */
-  boolean isConnected() {
-    return protocol != null;
+  /**
+   * Returns true if this connection can carry a stream allocation to {@code address}. If non-null
+   * {@code route} is the resolved route for a connection.
+   */
+  public boolean isEligible(Address address, @Nullable Route route) {
+    // If this connection is not accepting new streams, we're done.
+    if (allocations.size() >= allocationLimit || noNewStreams) return false;
+
+    // If the non-host fields of the address don't overlap, we're done.
+    if (!Internal.instance.equalsNonHost(this.route.address(), address)) return false;
+
+    // If the host exactly matches, we're done: this connection can carry the address.
+    if (address.url().host().equals(this.route().address().url().host())) {
+      return true; // This connection is a perfect match.
+    }
+
+    // At this point we don't have a hostname match. But we still be able to carry the request if
+    // our connection coalescing requirements are met. See also:
+    // https://hpbn.co/optimizing-application-delivery/#eliminate-domain-sharding
+    // https://daniel.haxx.se/blog/2016/08/18/http2-connection-coalescing/
+
+    // 1. This connection must be HTTP/2.
+    if (http2Connection == null) return false;
+
+    // 2. The routes must share an IP address. This requires us to have a DNS address for both
+    // hosts, which only happens after route planning. We can't coalesce connections that use a
+    // proxy, since proxies don't tell us the origin server's IP address.
+    if (route == null) return false;
+    if (route.proxy().type() != Proxy.Type.DIRECT) return false;
+    if (this.route.proxy().type() != Proxy.Type.DIRECT) return false;
+    if (!this.route.socketAddress().equals(route.socketAddress())) return false;
+
+    // 3. This connection's server certificate's must cover the new host.
+    if (route.address().hostnameVerifier() != OkHostnameVerifier.INSTANCE) return false;
+    if (!supportsUrl(address.url())) return false;
+
+    // 4. Certificate pinning must match the host.
+    try {
+      address.certificatePinner().check(address.url().host(), handshake().peerCertificates());
+    } catch (SSLPeerUnverifiedException e) {
+      return false;
+    }
+
+    return true; // The caller's address can be carried by this connection.
+  }
+
+  public boolean supportsUrl(HttpUrl url) {
+    if (url.port() != route.address().url().port()) {
+      return false; // Port mismatch.
+    }
+
+    if (!url.host().equals(route.address().url().host())) {
+      // We have a host mismatch. But if the certificate matches, we're still good.
+      return handshake != null && OkHostnameVerifier.INSTANCE.verify(
+          url.host(), (X509Certificate) handshake.peerCertificates().get(0));
+    }
+
+    return true; // Success. The URL is supported.
+  }
+
+  public HttpCodec newCodec(OkHttpClient client, Interceptor.Chain chain,
+      StreamAllocation streamAllocation) throws SocketException {
+    if (http2Connection != null) {
+      return new Http2Codec(client, chain, streamAllocation, http2Connection);
+    } else {
+      socket.setSoTimeout(chain.readTimeoutMillis());
+      source.timeout().timeout(chain.readTimeoutMillis(), MILLISECONDS);
+      sink.timeout().timeout(chain.writeTimeoutMillis(), MILLISECONDS);
+      return new Http1Codec(client, streamAllocation, source, sink);
+    }
+  }
+
+  public RealWebSocket.Streams newWebSocketStreams(final StreamAllocation streamAllocation) {
+    return new RealWebSocket.Streams(true, source, sink) {
+      @Override public void close() throws IOException {
+        streamAllocation.streamFinished(true, streamAllocation.codec(), -1L, null);
+      }
+    };
   }
 
   @Override public Route route() {
@@ -367,8 +516,8 @@ public boolean isHealthy(boolean doExtensiveChecks) {
       return false;
     }
 
-    if (framedConnection != null) {
-      return true; // TODO: check framedConnection.shutdown.
+    if (http2Connection != null) {
+      return !http2Connection.isShutdown();
     }
 
     if (doExtensiveChecks) {
@@ -394,13 +543,15 @@ public boolean isHealthy(boolean doExtensiveChecks) {
   }
 
   /** Refuse incoming streams. */
-  @Override public void onStream(FramedStream stream) throws IOException {
+  @Override public void onStream(Http2Stream stream) throws IOException {
     stream.close(ErrorCode.REFUSED_STREAM);
   }
 
   /** When settings are received, adjust the allocation limit. */
-  @Override public void onSettings(FramedConnection connection) {
-    allocationLimit = connection.maxConcurrentStreams();
+  @Override public void onSettings(Http2Connection connection) {
+    synchronized (connectionPool) {
+      allocationLimit = connection.maxConcurrentStreams();
+    }
   }
 
   @Override public Handshake handshake() {
@@ -408,19 +559,15 @@ public boolean isHealthy(boolean doExtensiveChecks) {
   }
 
   /**
-   * Returns true if this is a SPDY connection. Such connections can be used in multiple HTTP
+   * Returns true if this is an HTTP/2 connection. Such connections can be used in multiple HTTP
    * requests simultaneously.
    */
   public boolean isMultiplexed() {
-    return framedConnection != null;
+    return http2Connection != null;
   }
 
   @Override public Protocol protocol() {
-    if (framedConnection == null) {
-      return protocol != null ? protocol : Protocol.HTTP_1_1;
-    } else {
-      return framedConnection.getProtocol();
-    }
+    return protocol;
   }
 
   @Override public String toString() {
diff --git a/okhttp/src/main/java/okhttp3/internal/RouteDatabase.java b/okhttp/src/main/java/okhttp3/internal/connection/RouteDatabase.java
similarity index 89%
rename from okhttp/src/main/java/okhttp3/internal/RouteDatabase.java
rename to okhttp/src/main/java/okhttp3/internal/connection/RouteDatabase.java
index 613e0bf215..d0c1a9d79e 100644
--- a/okhttp/src/main/java/okhttp3/internal/RouteDatabase.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/RouteDatabase.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal;
+package okhttp3.internal.connection;
 
 import java.util.LinkedHashSet;
 import java.util.Set;
@@ -33,7 +33,7 @@ public synchronized void failed(Route failedRoute) {
     failedRoutes.add(failedRoute);
   }
 
-  /** Records success connecting to {@code failedRoute}. */
+  /** Records success connecting to {@code route}. */
   public synchronized void connected(Route route) {
     failedRoutes.remove(route);
   }
@@ -42,8 +42,4 @@ public synchronized void connected(Route route) {
   public synchronized boolean shouldPostpone(Route route) {
     return failedRoutes.contains(route);
   }
-
-  public synchronized int failedRoutesCount() {
-    return failedRoutes.size();
-  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RouteException.java b/okhttp/src/main/java/okhttp3/internal/connection/RouteException.java
similarity index 94%
rename from okhttp/src/main/java/okhttp3/internal/http/RouteException.java
rename to okhttp/src/main/java/okhttp3/internal/connection/RouteException.java
index 030b346a5a..5f50576611 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/RouteException.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/RouteException.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.http;
+package okhttp3.internal.connection;
 
 import java.io.IOException;
 import java.lang.reflect.InvocationTargetException;
@@ -23,7 +23,7 @@
  * An exception thrown to indicate a problem connecting via a single Route. Multiple attempts may
  * have been made with alternative protocols, none of which were successful.
  */
-public final class RouteException extends Exception {
+public final class RouteException extends RuntimeException {
   private static final Method addSuppressedExceptionMethod;
 
   static {
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RouteSelector.java b/okhttp/src/main/java/okhttp3/internal/connection/RouteSelector.java
similarity index 69%
rename from okhttp/src/main/java/okhttp3/internal/http/RouteSelector.java
rename to okhttp/src/main/java/okhttp3/internal/connection/RouteSelector.java
index 3b5725cbe6..40752ce23d 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/RouteSelector.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/RouteSelector.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.http;
+package okhttp3.internal.connection;
 
 import java.io.IOException;
 import java.net.InetAddress;
@@ -21,14 +21,17 @@
 import java.net.Proxy;
 import java.net.SocketAddress;
 import java.net.SocketException;
+import java.net.UnknownHostException;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 import java.util.NoSuchElementException;
 import okhttp3.Address;
+import okhttp3.Call;
+import okhttp3.EventListener;
 import okhttp3.HttpUrl;
 import okhttp3.Route;
-import okhttp3.internal.RouteDatabase;
+import okhttp3.internal.Util;
 
 /**
  * Selects routes to connect to an origin server. Each connection requires a choice of proxy server,
@@ -37,10 +40,8 @@
 public final class RouteSelector {
   private final Address address;
   private final RouteDatabase routeDatabase;
-
-  /* The most recently attempted route. */
-  private Proxy lastProxy;
-  private InetSocketAddress lastInetSocketAddress;
+  private final Call call;
+  private final EventListener eventListener;
 
   /* State for negotiating the next proxy to use. */
   private List<Proxy> proxies = Collections.emptyList();
@@ -48,48 +49,60 @@
 
   /* State for negotiating the next socket address to use. */
   private List<InetSocketAddress> inetSocketAddresses = Collections.emptyList();
-  private int nextInetSocketAddressIndex;
 
   /* State for negotiating failed routes */
   private final List<Route> postponedRoutes = new ArrayList<>();
 
-  public RouteSelector(Address address, RouteDatabase routeDatabase) {
+  public RouteSelector(Address address, RouteDatabase routeDatabase, Call call,
+      EventListener eventListener) {
     this.address = address;
     this.routeDatabase = routeDatabase;
+    this.call = call;
+    this.eventListener = eventListener;
 
     resetNextProxy(address.url(), address.proxy());
   }
 
   /**
-   * Returns true if there's another route to attempt. Every address has at least one route.
+   * Returns true if there's another set of routes to attempt. Every address has at least one route.
    */
   public boolean hasNext() {
-    return hasNextInetSocketAddress()
-        || hasNextProxy()
-        || hasNextPostponed();
+    return hasNextProxy() || !postponedRoutes.isEmpty();
   }
 
-  public Route next() throws IOException {
-    // Compute the next route to attempt.
-    if (!hasNextInetSocketAddress()) {
-      if (!hasNextProxy()) {
-        if (!hasNextPostponed()) {
-          throw new NoSuchElementException();
+  public Selection next() throws IOException {
+    if (!hasNext()) {
+      throw new NoSuchElementException();
+    }
+
+    // Compute the next set of routes to attempt.
+    List<Route> routes = new ArrayList<>();
+    while (hasNextProxy()) {
+      // Postponed routes are always tried last. For example, if we have 2 proxies and all the
+      // routes for proxy1 should be postponed, we'll move to proxy2. Only after we've exhausted
+      // all the good routes will we attempt the postponed routes.
+      Proxy proxy = nextProxy();
+      for (int i = 0, size = inetSocketAddresses.size(); i < size; i++) {
+        Route route = new Route(address, proxy, inetSocketAddresses.get(i));
+        if (routeDatabase.shouldPostpone(route)) {
+          postponedRoutes.add(route);
+        } else {
+          routes.add(route);
         }
-        return nextPostponed();
       }
-      lastProxy = nextProxy();
+
+      if (!routes.isEmpty()) {
+        break;
+      }
     }
-    lastInetSocketAddress = nextInetSocketAddress();
 
-    Route route = new Route(address, lastProxy, lastInetSocketAddress);
-    if (routeDatabase.shouldPostpone(route)) {
-      postponedRoutes.add(route);
-      // We will only recurse in order to skip previously failed routes. They will be tried last.
-      return next();
+    if (routes.isEmpty()) {
+      // We've exhausted all Proxies so fallback to the postponed routes.
+      routes.addAll(postponedRoutes);
+      postponedRoutes.clear();
     }
 
-    return route;
+    return new Selection(routes);
   }
 
   /**
@@ -112,14 +125,11 @@ private void resetNextProxy(HttpUrl url, Proxy proxy) {
       // If the user specifies a proxy, try that and only that.
       proxies = Collections.singletonList(proxy);
     } else {
-      // Try each of the ProxySelector choices until one connection succeeds. If none succeed
-      // then we'll try a direct connection below.
-      proxies = new ArrayList<>();
-      List<Proxy> selectedProxies = address.proxySelector().select(url.uri());
-      if (selectedProxies != null) proxies.addAll(selectedProxies);
-      // Finally try a direct connection. We only try it once!
-      proxies.removeAll(Collections.singleton(Proxy.NO_PROXY));
-      proxies.add(Proxy.NO_PROXY);
+      // Try each of the ProxySelector choices until one connection succeeds.
+      List<Proxy> proxiesOrNull = address.proxySelector().select(url.uri());
+      proxies = proxiesOrNull != null && !proxiesOrNull.isEmpty()
+          ? Util.immutableList(proxiesOrNull)
+          : Util.immutableList(Proxy.NO_PROXY);
     }
     nextProxyIndex = 0;
   }
@@ -169,15 +179,21 @@ private void resetNextInetSocketAddress(Proxy proxy) throws IOException {
     if (proxy.type() == Proxy.Type.SOCKS) {
       inetSocketAddresses.add(InetSocketAddress.createUnresolved(socketHost, socketPort));
     } else {
+      eventListener.dnsStart(call, socketHost);
+
       // Try each address for best behavior in mixed IPv4/IPv6 environments.
       List<InetAddress> addresses = address.dns().lookup(socketHost);
+      if (addresses.isEmpty()) {
+        throw new UnknownHostException(address.dns() + " returned no addresses for " + socketHost);
+      }
+
+      eventListener.dnsEnd(call, socketHost, addresses);
+
       for (int i = 0, size = addresses.size(); i < size; i++) {
         InetAddress inetAddress = addresses.get(i);
         inetSocketAddresses.add(new InetSocketAddress(inetAddress, socketPort));
       }
     }
-
-    nextInetSocketAddressIndex = 0;
   }
 
   /**
@@ -198,27 +214,28 @@ static String getHostString(InetSocketAddress socketAddress) {
     return address.getHostAddress();
   }
 
-  /** Returns true if there's another socket address to try. */
-  private boolean hasNextInetSocketAddress() {
-    return nextInetSocketAddressIndex < inetSocketAddresses.size();
-  }
+  /** A set of selected Routes. */
+  public static final class Selection {
+    private final List<Route> routes;
+    private int nextRouteIndex = 0;
 
-  /** Returns the next socket address to try. */
-  private InetSocketAddress nextInetSocketAddress() throws IOException {
-    if (!hasNextInetSocketAddress()) {
-      throw new SocketException("No route to " + address.url().host()
-          + "; exhausted inet socket addresses: " + inetSocketAddresses);
+    Selection(List<Route> routes) {
+      this.routes = routes;
     }
-    return inetSocketAddresses.get(nextInetSocketAddressIndex++);
-  }
 
-  /** Returns true if there is another postponed route to try. */
-  private boolean hasNextPostponed() {
-    return !postponedRoutes.isEmpty();
-  }
+    public boolean hasNext() {
+      return nextRouteIndex < routes.size();
+    }
 
-  /** Returns the next postponed route to try. */
-  private Route nextPostponed() {
-    return postponedRoutes.remove(0);
+    public Route next() {
+      if (!hasNext()) {
+        throw new NoSuchElementException();
+      }
+      return routes.get(nextRouteIndex++);
+    }
+
+    public List<Route> getAll() {
+      return new ArrayList<>(routes);
+    }
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java b/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
new file mode 100644
index 0000000000..2e5e043a15
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
@@ -0,0 +1,529 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.connection;
+
+import java.io.IOException;
+import java.lang.ref.Reference;
+import java.lang.ref.WeakReference;
+import java.net.Socket;
+import java.util.List;
+import okhttp3.Address;
+import okhttp3.Call;
+import okhttp3.Connection;
+import okhttp3.ConnectionPool;
+import okhttp3.EventListener;
+import okhttp3.Interceptor;
+import okhttp3.OkHttpClient;
+import okhttp3.Route;
+import okhttp3.internal.Internal;
+import okhttp3.internal.Util;
+import okhttp3.internal.http.HttpCodec;
+import okhttp3.internal.http2.ConnectionShutdownException;
+import okhttp3.internal.http2.ErrorCode;
+import okhttp3.internal.http2.StreamResetException;
+
+import static okhttp3.internal.Util.closeQuietly;
+
+/**
+ * This class coordinates the relationship between three entities:
+ *
+ * <ul>
+ *     <li><strong>Connections:</strong> physical socket connections to remote servers. These are
+ *         potentially slow to establish so it is necessary to be able to cancel a connection
+ *         currently being connected.
+ *     <li><strong>Streams:</strong> logical HTTP request/response pairs that are layered on
+ *         connections. Each connection has its own allocation limit, which defines how many
+ *         concurrent streams that connection can carry. HTTP/1.x connections can carry 1 stream
+ *         at a time, HTTP/2 typically carry multiple.
+ *     <li><strong>Calls:</strong> a logical sequence of streams, typically an initial request and
+ *         its follow up requests. We prefer to keep all streams of a single call on the same
+ *         connection for better behavior and locality.
+ * </ul>
+ *
+ * <p>Instances of this class act on behalf of the call, using one or more streams over one or more
+ * connections. This class has APIs to release each of the above resources:
+ *
+ * <ul>
+ *     <li>{@link #noNewStreams()} prevents the connection from being used for new streams in the
+ *         future. Use this after a {@code Connection: close} header, or when the connection may be
+ *         inconsistent.
+ *     <li>{@link #streamFinished streamFinished()} releases the active stream from this allocation.
+ *         Note that only one stream may be active at a given time, so it is necessary to call
+ *         {@link #streamFinished streamFinished()} before creating a subsequent stream with {@link
+ *         #newStream newStream()}.
+ *     <li>{@link #release()} removes the call's hold on the connection. Note that this won't
+ *         immediately free the connection if there is a stream still lingering. That happens when a
+ *         call is complete but its response body has yet to be fully consumed.
+ * </ul>
+ *
+ * <p>This class supports {@linkplain #cancel asynchronous canceling}. This is intended to have the
+ * smallest blast radius possible. If an HTTP/2 stream is active, canceling will cancel that stream
+ * but not the other streams sharing its connection. But if the TLS handshake is still in progress
+ * then canceling may break the entire connection.
+ */
+public final class StreamAllocation {
+  public final Address address;
+  private RouteSelector.Selection routeSelection;
+  private Route route;
+  private final ConnectionPool connectionPool;
+  public final Call call;
+  public final EventListener eventListener;
+  private final Object callStackTrace;
+
+  // State guarded by connectionPool.
+  private final RouteSelector routeSelector;
+  private int refusedStreamCount;
+  private RealConnection connection;
+  private boolean reportedAcquired;
+  private boolean released;
+  private boolean canceled;
+  private HttpCodec codec;
+
+  public StreamAllocation(ConnectionPool connectionPool, Address address, Call call,
+      EventListener eventListener, Object callStackTrace) {
+    this.connectionPool = connectionPool;
+    this.address = address;
+    this.call = call;
+    this.eventListener = eventListener;
+    this.routeSelector = new RouteSelector(address, routeDatabase(), call, eventListener);
+    this.callStackTrace = callStackTrace;
+  }
+
+  public HttpCodec newStream(
+      OkHttpClient client, Interceptor.Chain chain, boolean doExtensiveHealthChecks) {
+    int connectTimeout = chain.connectTimeoutMillis();
+    int readTimeout = chain.readTimeoutMillis();
+    int writeTimeout = chain.writeTimeoutMillis();
+    boolean connectionRetryEnabled = client.retryOnConnectionFailure();
+
+    try {
+      RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,
+          writeTimeout, connectionRetryEnabled, doExtensiveHealthChecks);
+      HttpCodec resultCodec = resultConnection.newCodec(client, chain, this);
+
+      synchronized (connectionPool) {
+        codec = resultCodec;
+        return resultCodec;
+      }
+    } catch (IOException e) {
+      throw new RouteException(e);
+    }
+  }
+
+  /**
+   * Finds a connection and returns it if it is healthy. If it is unhealthy the process is repeated
+   * until a healthy connection is found.
+   */
+  private RealConnection findHealthyConnection(int connectTimeout, int readTimeout,
+      int writeTimeout, boolean connectionRetryEnabled, boolean doExtensiveHealthChecks)
+      throws IOException {
+    while (true) {
+      RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,
+          connectionRetryEnabled);
+
+      // If this is a brand new connection, we can skip the extensive health checks.
+      synchronized (connectionPool) {
+        if (candidate.successCount == 0) {
+          return candidate;
+        }
+      }
+
+      // Do a (potentially slow) check to confirm that the pooled connection is still good. If it
+      // isn't, take it out of the pool and start again.
+      if (!candidate.isHealthy(doExtensiveHealthChecks)) {
+        noNewStreams();
+        continue;
+      }
+
+      return candidate;
+    }
+  }
+
+  /**
+   * Returns a connection to host a new stream. This prefers the existing connection if it exists,
+   * then the pool, finally building a new connection.
+   */
+  private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout,
+      boolean connectionRetryEnabled) throws IOException {
+    boolean foundPooledConnection = false;
+    RealConnection result = null;
+    Route selectedRoute = null;
+    Connection releasedConnection;
+    Socket toClose;
+    synchronized (connectionPool) {
+      if (released) throw new IllegalStateException("released");
+      if (codec != null) throw new IllegalStateException("codec != null");
+      if (canceled) throw new IOException("Canceled");
+
+      // Attempt to use an already-allocated connection. We need to be careful here because our
+      // already-allocated connection may have been restricted from creating new streams.
+      releasedConnection = this.connection;
+      toClose = releaseIfNoNewStreams();
+      if (this.connection != null) {
+        // We had an already-allocated connection and it's good.
+        result = this.connection;
+        releasedConnection = null;
+      }
+      if (!reportedAcquired) {
+        // If the connection was never reported acquired, don't report it as released!
+        releasedConnection = null;
+      }
+
+      if (result == null) {
+        // Attempt to get a connection from the pool.
+        Internal.instance.get(connectionPool, address, this, null);
+        if (connection != null) {
+          foundPooledConnection = true;
+          result = connection;
+        } else {
+          selectedRoute = route;
+        }
+      }
+    }
+    closeQuietly(toClose);
+
+    if (releasedConnection != null) {
+      eventListener.connectionReleased(call, releasedConnection);
+    }
+    if (foundPooledConnection) {
+      eventListener.connectionAcquired(call, result);
+    }
+    if (result != null) {
+      // If we found an already-allocated or pooled connection, we're done.
+      return result;
+    }
+
+    // If we need a route selection, make one. This is a blocking operation.
+    boolean newRouteSelection = false;
+    if (selectedRoute == null && (routeSelection == null || !routeSelection.hasNext())) {
+      newRouteSelection = true;
+      routeSelection = routeSelector.next();
+    }
+
+    synchronized (connectionPool) {
+      if (canceled) throw new IOException("Canceled");
+
+      if (newRouteSelection) {
+        // Now that we have a set of IP addresses, make another attempt at getting a connection from
+        // the pool. This could match due to connection coalescing.
+        List<Route> routes = routeSelection.getAll();
+        for (int i = 0, size = routes.size(); i < size; i++) {
+          Route route = routes.get(i);
+          Internal.instance.get(connectionPool, address, this, route);
+          if (connection != null) {
+            foundPooledConnection = true;
+            result = connection;
+            this.route = route;
+            break;
+          }
+        }
+      }
+
+      if (!foundPooledConnection) {
+        if (selectedRoute == null) {
+          selectedRoute = routeSelection.next();
+        }
+
+        // Create a connection and assign it to this allocation immediately. This makes it possible
+        // for an asynchronous cancel() to interrupt the handshake we're about to do.
+        route = selectedRoute;
+        refusedStreamCount = 0;
+        result = new RealConnection(connectionPool, selectedRoute);
+        acquire(result, false);
+      }
+    }
+
+    // If we found a pooled connection on the 2nd time around, we're done.
+    if (foundPooledConnection) {
+      eventListener.connectionAcquired(call, result);
+      return result;
+    }
+
+    // Do TCP + TLS handshakes. This is a blocking operation.
+    result.connect(
+        connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled, call, eventListener);
+    routeDatabase().connected(result.route());
+
+    Socket socket = null;
+    synchronized (connectionPool) {
+      reportedAcquired = true;
+
+      // Pool the connection.
+      Internal.instance.put(connectionPool, result);
+
+      // If another multiplexed connection to the same address was created concurrently, then
+      // release this connection and acquire that one.
+      if (result.isMultiplexed()) {
+        socket = Internal.instance.deduplicate(connectionPool, address, this);
+        result = connection;
+      }
+    }
+    closeQuietly(socket);
+
+    eventListener.connectionAcquired(call, result);
+    return result;
+  }
+
+  /**
+   * Releases the currently held connection and returns a socket to close if the held connection
+   * restricts new streams from being created. With HTTP/2 multiple requests share the same
+   * connection so it's possible that our connection is restricted from creating new streams during
+   * a follow-up request.
+   */
+  private Socket releaseIfNoNewStreams() {
+    assert (Thread.holdsLock(connectionPool));
+    RealConnection allocatedConnection = this.connection;
+    if (allocatedConnection != null && allocatedConnection.noNewStreams) {
+      return deallocate(false, false, true);
+    }
+    return null;
+  }
+
+  public void streamFinished(boolean noNewStreams, HttpCodec codec, long bytesRead, IOException e) {
+    eventListener.responseBodyEnd(call, bytesRead);
+
+    Socket socket;
+    Connection releasedConnection;
+    boolean callEnd;
+    synchronized (connectionPool) {
+      if (codec == null || codec != this.codec) {
+        throw new IllegalStateException("expected " + this.codec + " but was " + codec);
+      }
+      if (!noNewStreams) {
+        connection.successCount++;
+      }
+      releasedConnection = connection;
+      socket = deallocate(noNewStreams, false, true);
+      if (connection != null) releasedConnection = null;
+      callEnd = this.released;
+    }
+    closeQuietly(socket);
+    if (releasedConnection != null) {
+      eventListener.connectionReleased(call, releasedConnection);
+    }
+
+    if (e != null) {
+      eventListener.callFailed(call, e);
+    } else if (callEnd) {
+      eventListener.callEnd(call);
+    }
+  }
+
+  public HttpCodec codec() {
+    synchronized (connectionPool) {
+      return codec;
+    }
+  }
+
+  private RouteDatabase routeDatabase() {
+    return Internal.instance.routeDatabase(connectionPool);
+  }
+
+  public synchronized RealConnection connection() {
+    return connection;
+  }
+
+  public void release() {
+    Socket socket;
+    Connection releasedConnection;
+    synchronized (connectionPool) {
+      releasedConnection = connection;
+      socket = deallocate(false, true, false);
+      if (connection != null) releasedConnection = null;
+    }
+    closeQuietly(socket);
+    if (releasedConnection != null) {
+      eventListener.connectionReleased(call, releasedConnection);
+    }
+  }
+
+  /** Forbid new streams from being created on the connection that hosts this allocation. */
+  public void noNewStreams() {
+    Socket socket;
+    Connection releasedConnection;
+    synchronized (connectionPool) {
+      releasedConnection = connection;
+      socket = deallocate(true, false, false);
+      if (connection != null) releasedConnection = null;
+    }
+    closeQuietly(socket);
+    if (releasedConnection != null) {
+      eventListener.connectionReleased(call, releasedConnection);
+    }
+  }
+
+  /**
+   * Releases resources held by this allocation. If sufficient resources are allocated, the
+   * connection will be detached or closed. Callers must be synchronized on the connection pool.
+   *
+   * <p>Returns a closeable that the caller should pass to {@link Util#closeQuietly} upon completion
+   * of the synchronized block. (We don't do I/O while synchronized on the connection pool.)
+   */
+  private Socket deallocate(boolean noNewStreams, boolean released, boolean streamFinished) {
+    assert (Thread.holdsLock(connectionPool));
+
+    if (streamFinished) {
+      this.codec = null;
+    }
+    if (released) {
+      this.released = true;
+    }
+    Socket socket = null;
+    if (connection != null) {
+      if (noNewStreams) {
+        connection.noNewStreams = true;
+      }
+      if (this.codec == null && (this.released || connection.noNewStreams)) {
+        release(connection);
+        if (connection.allocations.isEmpty()) {
+          connection.idleAtNanos = System.nanoTime();
+          if (Internal.instance.connectionBecameIdle(connectionPool, connection)) {
+            socket = connection.socket();
+          }
+        }
+        connection = null;
+      }
+    }
+    return socket;
+  }
+
+  public void cancel() {
+    HttpCodec codecToCancel;
+    RealConnection connectionToCancel;
+    synchronized (connectionPool) {
+      canceled = true;
+      codecToCancel = codec;
+      connectionToCancel = connection;
+    }
+    if (codecToCancel != null) {
+      codecToCancel.cancel();
+    } else if (connectionToCancel != null) {
+      connectionToCancel.cancel();
+    }
+  }
+
+  public void streamFailed(IOException e) {
+    Socket socket;
+    Connection releasedConnection;
+    boolean noNewStreams = false;
+
+    synchronized (connectionPool) {
+      if (e instanceof StreamResetException) {
+        StreamResetException streamResetException = (StreamResetException) e;
+        if (streamResetException.errorCode == ErrorCode.REFUSED_STREAM) {
+          refusedStreamCount++;
+        }
+        // On HTTP/2 stream errors, retry REFUSED_STREAM errors once on the same connection. All
+        // other errors must be retried on a new connection.
+        if (streamResetException.errorCode != ErrorCode.REFUSED_STREAM || refusedStreamCount > 1) {
+          noNewStreams = true;
+          route = null;
+        }
+      } else if (connection != null
+          && (!connection.isMultiplexed() || e instanceof ConnectionShutdownException)) {
+        noNewStreams = true;
+
+        // If this route hasn't completed a call, avoid it for new connections.
+        if (connection.successCount == 0) {
+          if (route != null && e != null) {
+            routeSelector.connectFailed(route, e);
+          }
+          route = null;
+        }
+      }
+      releasedConnection = connection;
+      socket = deallocate(noNewStreams, false, true);
+      if (connection != null || !reportedAcquired) releasedConnection = null;
+    }
+
+    closeQuietly(socket);
+    if (releasedConnection != null) {
+      eventListener.connectionReleased(call, releasedConnection);
+    }
+  }
+
+  /**
+   * Use this allocation to hold {@code connection}. Each call to this must be paired with a call to
+   * {@link #release} on the same connection.
+   */
+  public void acquire(RealConnection connection, boolean reportedAcquired) {
+    assert (Thread.holdsLock(connectionPool));
+    if (this.connection != null) throw new IllegalStateException();
+
+    this.connection = connection;
+    this.reportedAcquired = reportedAcquired;
+    connection.allocations.add(new StreamAllocationReference(this, callStackTrace));
+  }
+
+  /** Remove this allocation from the connection's list of allocations. */
+  private void release(RealConnection connection) {
+    for (int i = 0, size = connection.allocations.size(); i < size; i++) {
+      Reference<StreamAllocation> reference = connection.allocations.get(i);
+      if (reference.get() == this) {
+        connection.allocations.remove(i);
+        return;
+      }
+    }
+    throw new IllegalStateException();
+  }
+
+  /**
+   * Release the connection held by this connection and acquire {@code newConnection} instead. It is
+   * only safe to call this if the held connection is newly connected but duplicated by {@code
+   * newConnection}. Typically this occurs when concurrently connecting to an HTTP/2 webserver.
+   *
+   * <p>Returns a closeable that the caller should pass to {@link Util#closeQuietly} upon completion
+   * of the synchronized block. (We don't do I/O while synchronized on the connection pool.)
+   */
+  public Socket releaseAndAcquire(RealConnection newConnection) {
+    assert (Thread.holdsLock(connectionPool));
+    if (codec != null || connection.allocations.size() != 1) throw new IllegalStateException();
+
+    // Release the old connection.
+    Reference<StreamAllocation> onlyAllocation = connection.allocations.get(0);
+    Socket socket = deallocate(true, false, false);
+
+    // Acquire the new connection.
+    this.connection = newConnection;
+    newConnection.allocations.add(onlyAllocation);
+
+    return socket;
+  }
+
+  public boolean hasMoreRoutes() {
+    return route != null
+        || (routeSelection != null && routeSelection.hasNext())
+        || routeSelector.hasNext();
+  }
+
+  @Override public String toString() {
+    RealConnection connection = connection();
+    return connection != null ? connection.toString() : address.toString();
+  }
+
+  public static final class StreamAllocationReference extends WeakReference<StreamAllocation> {
+    /**
+     * Captures the stack trace at the time the Call is executed or enqueued. This is helpful for
+     * identifying the origin of connection leaks.
+     */
+    public final Object callStackTrace;
+
+    StreamAllocationReference(StreamAllocation referent, Object callStackTrace) {
+      super(referent);
+      this.callStackTrace = callStackTrace;
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/ErrorCode.java b/okhttp/src/main/java/okhttp3/internal/framed/ErrorCode.java
deleted file mode 100644
index 1142319d7e..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/framed/ErrorCode.java
+++ /dev/null
@@ -1,91 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.framed;
-
-// http://tools.ietf.org/html/draft-ietf-httpbis-http2-17#section-7
-public enum ErrorCode {
-  /** Not an error! For SPDY stream resets, prefer null over NO_ERROR. */
-  NO_ERROR(0, -1, 0),
-
-  PROTOCOL_ERROR(1, 1, 1),
-
-  /** A subtype of PROTOCOL_ERROR used by SPDY. */
-  INVALID_STREAM(1, 2, -1),
-
-  /** A subtype of PROTOCOL_ERROR used by SPDY. */
-  UNSUPPORTED_VERSION(1, 4, -1),
-
-  /** A subtype of PROTOCOL_ERROR used by SPDY. */
-  STREAM_IN_USE(1, 8, -1),
-
-  /** A subtype of PROTOCOL_ERROR used by SPDY. */
-  STREAM_ALREADY_CLOSED(1, 9, -1),
-
-  INTERNAL_ERROR(2, 6, 2),
-
-  FLOW_CONTROL_ERROR(3, 7, -1),
-
-  STREAM_CLOSED(5, -1, -1),
-
-  FRAME_TOO_LARGE(6, 11, -1),
-
-  REFUSED_STREAM(7, 3, -1),
-
-  CANCEL(8, 5, -1),
-
-  COMPRESSION_ERROR(9, -1, -1),
-
-  CONNECT_ERROR(10, -1, -1),
-
-  ENHANCE_YOUR_CALM(11, -1, -1),
-
-  INADEQUATE_SECURITY(12, -1, -1),
-
-  HTTP_1_1_REQUIRED(13, -1, -1),
-
-  INVALID_CREDENTIALS(-1, 10, -1);
-
-  public final int httpCode;
-  public final int spdyRstCode;
-  public final int spdyGoAwayCode;
-
-  private ErrorCode(int httpCode, int spdyRstCode, int spdyGoAwayCode) {
-    this.httpCode = httpCode;
-    this.spdyRstCode = spdyRstCode;
-    this.spdyGoAwayCode = spdyGoAwayCode;
-  }
-
-  public static ErrorCode fromSpdy3Rst(int code) {
-    for (ErrorCode errorCode : ErrorCode.values()) {
-      if (errorCode.spdyRstCode == code) return errorCode;
-    }
-    return null;
-  }
-
-  public static ErrorCode fromHttp2(int code) {
-    for (ErrorCode errorCode : ErrorCode.values()) {
-      if (errorCode.httpCode == code) return errorCode;
-    }
-    return null;
-  }
-
-  public static ErrorCode fromSpdyGoAway(int code) {
-    for (ErrorCode errorCode : ErrorCode.values()) {
-      if (errorCode.spdyGoAwayCode == code) return errorCode;
-    }
-    return null;
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/FrameReader.java b/okhttp/src/main/java/okhttp3/internal/framed/FrameReader.java
deleted file mode 100644
index 741a568c0d..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/framed/FrameReader.java
+++ /dev/null
@@ -1,129 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.framed;
-
-import java.io.Closeable;
-import java.io.IOException;
-import java.util.List;
-import okio.BufferedSource;
-import okio.ByteString;
-
-/** Reads transport frames for SPDY/3 or HTTP/2. */
-public interface FrameReader extends Closeable {
-  void readConnectionPreface() throws IOException;
-
-  boolean nextFrame(Handler handler) throws IOException;
-
-  interface Handler {
-    void data(boolean inFinished, int streamId, BufferedSource source, int length)
-        throws IOException;
-
-    /**
-     * Create or update incoming headers, creating the corresponding streams if necessary. Frames
-     * that trigger this are SPDY SYN_STREAM, HEADERS, and SYN_REPLY, and HTTP/2 HEADERS and
-     * PUSH_PROMISE.
-     *
-     * @param outFinished true if the receiver should not send further frames.
-     * @param inFinished true if the sender will not send further frames.
-     * @param streamId the stream owning these headers.
-     * @param associatedStreamId the stream that triggered the sender to create this stream.
-     */
-    void headers(boolean outFinished, boolean inFinished, int streamId, int associatedStreamId,
-        List<Header> headerBlock, HeadersMode headersMode);
-
-    void rstStream(int streamId, ErrorCode errorCode);
-
-    void settings(boolean clearPrevious, Settings settings);
-
-    /** HTTP/2 only. */
-    void ackSettings();
-
-    /**
-     * Read a connection-level ping from the peer.  {@code ack} indicates this is a reply.  Payload
-     * parameters are different between SPDY/3 and HTTP/2.
-     *
-     * <p>In SPDY/3, only the first {@code payload1} parameter is set.  If the reader is a client,
-     * it is an unsigned even number. Likewise, a server will receive an odd number.
-     *
-     * <p>In HTTP/2, both {@code payload1} and {@code payload2} parameters are set. The data is
-     * opaque binary, and there are no rules on the content.
-     */
-    void ping(boolean ack, int payload1, int payload2);
-
-    /**
-     * The peer tells us to stop creating streams.  It is safe to replay streams with {@code ID >
-     * lastGoodStreamId} on a new connection.  In- flight streams with {@code ID <=
-     * lastGoodStreamId} can only be replayed on a new connection if they are idempotent.
-     *
-     * @param lastGoodStreamId the last stream ID the peer processed before sending this message. If
-     * {@code lastGoodStreamId} is zero, the peer processed no frames.
-     * @param errorCode reason for closing the connection.
-     * @param debugData only valid for HTTP/2; opaque debug data to send.
-     */
-    void goAway(int lastGoodStreamId, ErrorCode errorCode, ByteString debugData);
-
-    /**
-     * Notifies that an additional {@code windowSizeIncrement} bytes can be sent on {@code
-     * streamId}, or the connection if {@code streamId} is zero.
-     */
-    void windowUpdate(int streamId, long windowSizeIncrement);
-
-    /**
-     * Called when reading a headers or priority frame. This may be used to change the stream's
-     * weight from the default (16) to a new value.
-     *
-     * @param streamId stream which has a priority change.
-     * @param streamDependency the stream ID this stream is dependent on.
-     * @param weight relative proportion of priority in [1..256].
-     * @param exclusive inserts this stream ID as the sole child of {@code streamDependency}.
-     */
-    void priority(int streamId, int streamDependency, int weight, boolean exclusive);
-
-    /**
-     * HTTP/2 only. Receive a push promise header block. <p> A push promise contains all the headers
-     * that pertain to a server-initiated request, and a {@code promisedStreamId} to which response
-     * frames will be delivered. Push promise frames are sent as a part of the response to {@code
-     * streamId}.
-     *
-     * @param streamId client-initiated stream ID.  Must be an odd number.
-     * @param promisedStreamId server-initiated stream ID.  Must be an even number.
-     * @param requestHeaders minimally includes {@code :method}, {@code :scheme}, {@code
-     * :authority}, and (@code :path}.
-     */
-    void pushPromise(int streamId, int promisedStreamId, List<Header> requestHeaders)
-        throws IOException;
-
-    /**
-     * HTTP/2 only. Expresses that resources for the connection or a client- initiated stream are
-     * available from a different network location or protocol configuration.
-     *
-     * <p>See <a href="http://tools.ietf.org/html/draft-ietf-httpbis-alt-svc-01">alt-svc</a>
-     *
-     * @param streamId when a client-initiated stream ID (odd number), the origin of this alternate
-     * service is the origin of the stream. When zero, the origin is specified in the {@code origin}
-     * parameter.
-     * @param origin when present, the <a href="http://tools.ietf.org/html/rfc6454">origin</a> is
-     * typically represented as a combination of scheme, host and port. When empty, the origin is
-     * that of the {@code streamId}.
-     * @param protocol an ALPN protocol, such as {@code h2}.
-     * @param host an IP address or hostname.
-     * @param port the IP port associated with the service.
-     * @param maxAge time in seconds that this alternative is considered fresh.
-     */
-    void alternateService(int streamId, String origin, ByteString protocol, String host, int port,
-        long maxAge);
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/FrameWriter.java b/okhttp/src/main/java/okhttp3/internal/framed/FrameWriter.java
deleted file mode 100644
index 5e8c7ebef9..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/framed/FrameWriter.java
+++ /dev/null
@@ -1,103 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.framed;
-
-import java.io.Closeable;
-import java.io.IOException;
-import java.util.List;
-import okio.Buffer;
-
-/** Writes transport frames for SPDY/3 or HTTP/2. */
-public interface FrameWriter extends Closeable {
-  /** HTTP/2 only. */
-  void connectionPreface() throws IOException;
-
-  /** Informs the peer that we've applied its latest settings. */
-  void ackSettings(Settings peerSettings) throws IOException;
-
-  /**
-   * HTTP/2 only. Send a push promise header block.
-   *
-   * <p>A push promise contains all the headers that pertain to a server-initiated request, and a
-   * {@code promisedStreamId} to which response frames will be delivered. Push promise frames are
-   * sent as a part of the response to {@code streamId}. The {@code promisedStreamId} has a priority
-   * of one greater than {@code streamId}.
-   *
-   * @param streamId client-initiated stream ID.  Must be an odd number.
-   * @param promisedStreamId server-initiated stream ID.  Must be an even number.
-   * @param requestHeaders minimally includes {@code :method}, {@code :scheme}, {@code :authority},
-   * and (@code :path}.
-   */
-  void pushPromise(int streamId, int promisedStreamId, List<Header> requestHeaders)
-      throws IOException;
-
-  /** SPDY/3 only. */
-  void flush() throws IOException;
-
-  void synStream(boolean outFinished, boolean inFinished, int streamId, int associatedStreamId,
-      List<Header> headerBlock) throws IOException;
-
-  void synReply(boolean outFinished, int streamId, List<Header> headerBlock)
-      throws IOException;
-
-  void headers(int streamId, List<Header> headerBlock) throws IOException;
-
-  void rstStream(int streamId, ErrorCode errorCode) throws IOException;
-
-  /** The maximum size of bytes that may be sent in a single call to {@link #data}. */
-  int maxDataLength();
-
-  /**
-   * {@code source.length} may be longer than the max length of the variant's data frame.
-   * Implementations must send multiple frames as necessary.
-   *
-   * @param source the buffer to draw bytes from. May be null if byteCount is 0.
-   * @param byteCount must be between 0 and the minimum of {code source.length} and {@link
-   * #maxDataLength}.
-   */
-  void data(boolean outFinished, int streamId, Buffer source, int byteCount) throws IOException;
-
-  /** Write okhttp's settings to the peer. */
-  void settings(Settings okHttpSettings) throws IOException;
-
-  /**
-   * Send a connection-level ping to the peer.  {@code ack} indicates this is a reply.  Payload
-   * parameters are different between SPDY/3 and HTTP/2.
-   *
-   * <p>In SPDY/3, only the first {@code payload1} parameter is sent.  If the sender is a client, it
-   * is an unsigned odd number. Likewise, a server will send an even number.
-   *
-   * <p>In HTTP/2, both {@code payload1} and {@code payload2} parameters are sent.  The data is
-   * opaque binary, and there are no rules on the content.
-   */
-  void ping(boolean ack, int payload1, int payload2) throws IOException;
-
-  /**
-   * Tell the peer to stop creating streams and that we last processed {@code lastGoodStreamId}, or
-   * zero if no streams were processed.
-   *
-   * @param lastGoodStreamId the last stream ID processed, or zero if no streams were processed.
-   * @param errorCode reason for closing the connection.
-   * @param debugData only valid for HTTP/2; opaque debug data to send.
-   */
-  void goAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData) throws IOException;
-
-  /**
-   * Inform peer that an additional {@code windowSizeIncrement} bytes can be sent on {@code
-   * streamId}, or the connection if {@code streamId} is zero.
-   */
-  void windowUpdate(int streamId, long windowSizeIncrement) throws IOException;
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/HeadersMode.java b/okhttp/src/main/java/okhttp3/internal/framed/HeadersMode.java
deleted file mode 100644
index bc851ed784..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/framed/HeadersMode.java
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.framed;
-
-public enum HeadersMode {
-  SPDY_SYN_STREAM,
-  SPDY_REPLY,
-  SPDY_HEADERS,
-  HTTP_20_HEADERS;
-
-  /** Returns true if it is an error these headers to create a new stream. */
-  public boolean failIfStreamAbsent() {
-    return this == SPDY_REPLY || this == SPDY_HEADERS;
-  }
-
-  /** Returns true if it is an error these headers to update an existing stream. */
-  public boolean failIfStreamPresent() {
-    return this == SPDY_SYN_STREAM;
-  }
-
-  /**
-   * Returns true if it is an error these headers to be the initial headers of a response.
-   */
-  public boolean failIfHeadersAbsent() {
-    return this == SPDY_HEADERS;
-  }
-
-  /**
-   * Returns true if it is an error these headers to be update existing headers of a response.
-   */
-  public boolean failIfHeadersPresent() {
-    return this == SPDY_REPLY;
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/Http2.java b/okhttp/src/main/java/okhttp3/internal/framed/Http2.java
deleted file mode 100644
index 8ad6c5224e..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/framed/Http2.java
+++ /dev/null
@@ -1,770 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.framed;
-
-import java.io.IOException;
-import java.util.List;
-import java.util.logging.Logger;
-import okhttp3.Protocol;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.ByteString;
-import okio.Source;
-import okio.Timeout;
-
-import static java.util.logging.Level.FINE;
-import static okhttp3.internal.Util.format;
-import static okhttp3.internal.framed.Http2.FrameLogger.formatHeader;
-import static okio.ByteString.EMPTY;
-
-/**
- * Read and write HTTP/2 frames.
- *
- * <p>This implementation assumes we do not send an increased {@link Settings#getMaxFrameSize frame
- * size setting} to the peer. Hence, we expect all frames to have a max length of {@link
- * #INITIAL_MAX_FRAME_SIZE}. <p>http://tools.ietf.org/html/draft-ietf-httpbis-http2-17
- */
-public final class Http2 implements Variant {
-  private static final Logger logger = Logger.getLogger(FrameLogger.class.getName());
-
-  @Override public Protocol getProtocol() {
-    return Protocol.HTTP_2;
-  }
-
-  private static final ByteString CONNECTION_PREFACE
-      = ByteString.encodeUtf8("PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n");
-
-  /** The initial max frame size, applied independently writing to, or reading from the peer. */
-  static final int INITIAL_MAX_FRAME_SIZE = 0x4000; // 16384
-
-  static final byte TYPE_DATA = 0x0;
-  static final byte TYPE_HEADERS = 0x1;
-  static final byte TYPE_PRIORITY = 0x2;
-  static final byte TYPE_RST_STREAM = 0x3;
-  static final byte TYPE_SETTINGS = 0x4;
-  static final byte TYPE_PUSH_PROMISE = 0x5;
-  static final byte TYPE_PING = 0x6;
-  static final byte TYPE_GOAWAY = 0x7;
-  static final byte TYPE_WINDOW_UPDATE = 0x8;
-  static final byte TYPE_CONTINUATION = 0x9;
-
-  static final byte FLAG_NONE = 0x0;
-  static final byte FLAG_ACK = 0x1; // Used for settings and ping.
-  static final byte FLAG_END_STREAM = 0x1; // Used for headers and data.
-  static final byte FLAG_END_HEADERS = 0x4; // Used for headers and continuation.
-  static final byte FLAG_END_PUSH_PROMISE = 0x4;
-  static final byte FLAG_PADDED = 0x8; // Used for headers and data.
-  static final byte FLAG_PRIORITY = 0x20; // Used for headers.
-  static final byte FLAG_COMPRESSED = 0x20; // Used for data.
-
-  /**
-   * Creates a frame reader with max header table size of 4096 and data frame compression disabled.
-   */
-  @Override public FrameReader newReader(BufferedSource source, boolean client) {
-    return new Reader(source, 4096, client);
-  }
-
-  @Override public FrameWriter newWriter(BufferedSink sink, boolean client) {
-    return new Writer(sink, client);
-  }
-
-  static final class Reader implements FrameReader {
-    private final BufferedSource source;
-    private final ContinuationSource continuation;
-    private final boolean client;
-
-    // Visible for testing.
-    final Hpack.Reader hpackReader;
-
-    Reader(BufferedSource source, int headerTableSize, boolean client) {
-      this.source = source;
-      this.client = client;
-      this.continuation = new ContinuationSource(this.source);
-      this.hpackReader = new Hpack.Reader(headerTableSize, continuation);
-    }
-
-    @Override public void readConnectionPreface() throws IOException {
-      if (client) return; // Nothing to read; servers doesn't send a connection preface!
-      ByteString connectionPreface = source.readByteString(CONNECTION_PREFACE.size());
-      if (logger.isLoggable(FINE)) logger.fine(format("<< CONNECTION %s", connectionPreface.hex()));
-      if (!CONNECTION_PREFACE.equals(connectionPreface)) {
-        throw ioException("Expected a connection header but was %s", connectionPreface.utf8());
-      }
-    }
-
-    @Override public boolean nextFrame(Handler handler) throws IOException {
-      try {
-        source.require(9); // Frame header size
-      } catch (IOException e) {
-        return false; // This might be a normal socket close.
-      }
-
-      /*  0                   1                   2                   3
-       *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
-       * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-       * |                 Length (24)                   |
-       * +---------------+---------------+---------------+
-       * |   Type (8)    |   Flags (8)   |
-       * +-+-+-----------+---------------+-------------------------------+
-       * |R|                 Stream Identifier (31)                      |
-       * +=+=============================================================+
-       * |                   Frame Payload (0...)                      ...
-       * +---------------------------------------------------------------+
-       */
-      int length = readMedium(source);
-      if (length < 0 || length > INITIAL_MAX_FRAME_SIZE) {
-        throw ioException("FRAME_SIZE_ERROR: %s", length);
-      }
-      byte type = (byte) (source.readByte() & 0xff);
-      byte flags = (byte) (source.readByte() & 0xff);
-      int streamId = (source.readInt() & 0x7fffffff); // Ignore reserved bit.
-      if (logger.isLoggable(FINE)) logger.fine(formatHeader(true, streamId, length, type, flags));
-
-      switch (type) {
-        case TYPE_DATA:
-          readData(handler, length, flags, streamId);
-          break;
-
-        case TYPE_HEADERS:
-          readHeaders(handler, length, flags, streamId);
-          break;
-
-        case TYPE_PRIORITY:
-          readPriority(handler, length, flags, streamId);
-          break;
-
-        case TYPE_RST_STREAM:
-          readRstStream(handler, length, flags, streamId);
-          break;
-
-        case TYPE_SETTINGS:
-          readSettings(handler, length, flags, streamId);
-          break;
-
-        case TYPE_PUSH_PROMISE:
-          readPushPromise(handler, length, flags, streamId);
-          break;
-
-        case TYPE_PING:
-          readPing(handler, length, flags, streamId);
-          break;
-
-        case TYPE_GOAWAY:
-          readGoAway(handler, length, flags, streamId);
-          break;
-
-        case TYPE_WINDOW_UPDATE:
-          readWindowUpdate(handler, length, flags, streamId);
-          break;
-
-        default:
-          // Implementations MUST discard frames that have unknown or unsupported types.
-          source.skip(length);
-      }
-      return true;
-    }
-
-    private void readHeaders(Handler handler, int length, byte flags, int streamId)
-        throws IOException {
-      if (streamId == 0) throw ioException("PROTOCOL_ERROR: TYPE_HEADERS streamId == 0");
-
-      boolean endStream = (flags & FLAG_END_STREAM) != 0;
-
-      short padding = (flags & FLAG_PADDED) != 0 ? (short) (source.readByte() & 0xff) : 0;
-
-      if ((flags & FLAG_PRIORITY) != 0) {
-        readPriority(handler, streamId);
-        length -= 5; // account for above read.
-      }
-
-      length = lengthWithoutPadding(length, flags, padding);
-
-      List<Header> headerBlock = readHeaderBlock(length, padding, flags, streamId);
-
-      handler.headers(false, endStream, streamId, -1, headerBlock, HeadersMode.HTTP_20_HEADERS);
-    }
-
-    private List<Header> readHeaderBlock(int length, short padding, byte flags, int streamId)
-        throws IOException {
-      continuation.length = continuation.left = length;
-      continuation.padding = padding;
-      continuation.flags = flags;
-      continuation.streamId = streamId;
-
-      // TODO: Concat multi-value headers with 0x0, except COOKIE, which uses 0x3B, 0x20.
-      // http://tools.ietf.org/html/draft-ietf-httpbis-http2-17#section-8.1.2.5
-      hpackReader.readHeaders();
-      return hpackReader.getAndResetHeaderList();
-    }
-
-    private void readData(Handler handler, int length, byte flags, int streamId)
-        throws IOException {
-      // TODO: checkState open or half-closed (local) or raise STREAM_CLOSED
-      boolean inFinished = (flags & FLAG_END_STREAM) != 0;
-      boolean gzipped = (flags & FLAG_COMPRESSED) != 0;
-      if (gzipped) {
-        throw ioException("PROTOCOL_ERROR: FLAG_COMPRESSED without SETTINGS_COMPRESS_DATA");
-      }
-
-      short padding = (flags & FLAG_PADDED) != 0 ? (short) (source.readByte() & 0xff) : 0;
-      length = lengthWithoutPadding(length, flags, padding);
-
-      handler.data(inFinished, streamId, source, length);
-      source.skip(padding);
-    }
-
-    private void readPriority(Handler handler, int length, byte flags, int streamId)
-        throws IOException {
-      if (length != 5) throw ioException("TYPE_PRIORITY length: %d != 5", length);
-      if (streamId == 0) throw ioException("TYPE_PRIORITY streamId == 0");
-      readPriority(handler, streamId);
-    }
-
-    private void readPriority(Handler handler, int streamId) throws IOException {
-      int w1 = source.readInt();
-      boolean exclusive = (w1 & 0x80000000) != 0;
-      int streamDependency = (w1 & 0x7fffffff);
-      int weight = (source.readByte() & 0xff) + 1;
-      handler.priority(streamId, streamDependency, weight, exclusive);
-    }
-
-    private void readRstStream(Handler handler, int length, byte flags, int streamId)
-        throws IOException {
-      if (length != 4) throw ioException("TYPE_RST_STREAM length: %d != 4", length);
-      if (streamId == 0) throw ioException("TYPE_RST_STREAM streamId == 0");
-      int errorCodeInt = source.readInt();
-      ErrorCode errorCode = ErrorCode.fromHttp2(errorCodeInt);
-      if (errorCode == null) {
-        throw ioException("TYPE_RST_STREAM unexpected error code: %d", errorCodeInt);
-      }
-      handler.rstStream(streamId, errorCode);
-    }
-
-    private void readSettings(Handler handler, int length, byte flags, int streamId)
-        throws IOException {
-      if (streamId != 0) throw ioException("TYPE_SETTINGS streamId != 0");
-      if ((flags & FLAG_ACK) != 0) {
-        if (length != 0) throw ioException("FRAME_SIZE_ERROR ack frame should be empty!");
-        handler.ackSettings();
-        return;
-      }
-
-      if (length % 6 != 0) throw ioException("TYPE_SETTINGS length %% 6 != 0: %s", length);
-      Settings settings = new Settings();
-      for (int i = 0; i < length; i += 6) {
-        short id = source.readShort();
-        int value = source.readInt();
-
-        switch (id) {
-          case 1: // SETTINGS_HEADER_TABLE_SIZE
-            break;
-          case 2: // SETTINGS_ENABLE_PUSH
-            if (value != 0 && value != 1) {
-              throw ioException("PROTOCOL_ERROR SETTINGS_ENABLE_PUSH != 0 or 1");
-            }
-            break;
-          case 3: // SETTINGS_MAX_CONCURRENT_STREAMS
-            id = 4; // Renumbered in draft 10.
-            break;
-          case 4: // SETTINGS_INITIAL_WINDOW_SIZE
-            id = 7; // Renumbered in draft 10.
-            if (value < 0) {
-              throw ioException("PROTOCOL_ERROR SETTINGS_INITIAL_WINDOW_SIZE > 2^31 - 1");
-            }
-            break;
-          case 5: // SETTINGS_MAX_FRAME_SIZE
-            if (value < INITIAL_MAX_FRAME_SIZE || value > 16777215) {
-              throw ioException("PROTOCOL_ERROR SETTINGS_MAX_FRAME_SIZE: %s", value);
-            }
-            break;
-          case 6: // SETTINGS_MAX_HEADER_LIST_SIZE
-            break; // Advisory only, so ignored.
-          default:
-            break; // Must ignore setting with unknown id.
-        }
-        settings.set(id, 0, value);
-      }
-      handler.settings(false, settings);
-      if (settings.getHeaderTableSize() >= 0) {
-        hpackReader.headerTableSizeSetting(settings.getHeaderTableSize());
-      }
-    }
-
-    private void readPushPromise(Handler handler, int length, byte flags, int streamId)
-        throws IOException {
-      if (streamId == 0) {
-        throw ioException("PROTOCOL_ERROR: TYPE_PUSH_PROMISE streamId == 0");
-      }
-      short padding = (flags & FLAG_PADDED) != 0 ? (short) (source.readByte() & 0xff) : 0;
-      int promisedStreamId = source.readInt() & 0x7fffffff;
-      length -= 4; // account for above read.
-      length = lengthWithoutPadding(length, flags, padding);
-      List<Header> headerBlock = readHeaderBlock(length, padding, flags, streamId);
-      handler.pushPromise(streamId, promisedStreamId, headerBlock);
-    }
-
-    private void readPing(Handler handler, int length, byte flags, int streamId)
-        throws IOException {
-      if (length != 8) throw ioException("TYPE_PING length != 8: %s", length);
-      if (streamId != 0) throw ioException("TYPE_PING streamId != 0");
-      int payload1 = source.readInt();
-      int payload2 = source.readInt();
-      boolean ack = (flags & FLAG_ACK) != 0;
-      handler.ping(ack, payload1, payload2);
-    }
-
-    private void readGoAway(Handler handler, int length, byte flags, int streamId)
-        throws IOException {
-      if (length < 8) throw ioException("TYPE_GOAWAY length < 8: %s", length);
-      if (streamId != 0) throw ioException("TYPE_GOAWAY streamId != 0");
-      int lastStreamId = source.readInt();
-      int errorCodeInt = source.readInt();
-      int opaqueDataLength = length - 8;
-      ErrorCode errorCode = ErrorCode.fromHttp2(errorCodeInt);
-      if (errorCode == null) {
-        throw ioException("TYPE_GOAWAY unexpected error code: %d", errorCodeInt);
-      }
-      ByteString debugData = EMPTY;
-      if (opaqueDataLength > 0) { // Must read debug data in order to not corrupt the connection.
-        debugData = source.readByteString(opaqueDataLength);
-      }
-      handler.goAway(lastStreamId, errorCode, debugData);
-    }
-
-    private void readWindowUpdate(Handler handler, int length, byte flags, int streamId)
-        throws IOException {
-      if (length != 4) throw ioException("TYPE_WINDOW_UPDATE length !=4: %s", length);
-      long increment = (source.readInt() & 0x7fffffffL);
-      if (increment == 0) throw ioException("windowSizeIncrement was 0", increment);
-      handler.windowUpdate(streamId, increment);
-    }
-
-    @Override public void close() throws IOException {
-      source.close();
-    }
-  }
-
-  static final class Writer implements FrameWriter {
-    private final BufferedSink sink;
-    private final boolean client;
-    private final Buffer hpackBuffer;
-    private final Hpack.Writer hpackWriter;
-    private int maxFrameSize;
-    private boolean closed;
-
-    Writer(BufferedSink sink, boolean client) {
-      this.sink = sink;
-      this.client = client;
-      this.hpackBuffer = new Buffer();
-      this.hpackWriter = new Hpack.Writer(hpackBuffer);
-      this.maxFrameSize = INITIAL_MAX_FRAME_SIZE;
-    }
-
-    @Override public synchronized void flush() throws IOException {
-      if (closed) throw new IOException("closed");
-      sink.flush();
-    }
-
-    @Override public synchronized void ackSettings(Settings peerSettings) throws IOException {
-      if (closed) throw new IOException("closed");
-      this.maxFrameSize = peerSettings.getMaxFrameSize(maxFrameSize);
-      int length = 0;
-      byte type = TYPE_SETTINGS;
-      byte flags = FLAG_ACK;
-      int streamId = 0;
-      frameHeader(streamId, length, type, flags);
-      sink.flush();
-    }
-
-    @Override public synchronized void connectionPreface() throws IOException {
-      if (closed) throw new IOException("closed");
-      if (!client) return; // Nothing to write; servers don't send connection headers!
-      if (logger.isLoggable(FINE)) {
-        logger.fine(format(">> CONNECTION %s", CONNECTION_PREFACE.hex()));
-      }
-      sink.write(CONNECTION_PREFACE.toByteArray());
-      sink.flush();
-    }
-
-    @Override public synchronized void synStream(boolean outFinished, boolean inFinished,
-        int streamId, int associatedStreamId, List<Header> headerBlock)
-        throws IOException {
-      if (inFinished) throw new UnsupportedOperationException();
-      if (closed) throw new IOException("closed");
-      headers(outFinished, streamId, headerBlock);
-    }
-
-    @Override public synchronized void synReply(boolean outFinished, int streamId,
-        List<Header> headerBlock) throws IOException {
-      if (closed) throw new IOException("closed");
-      headers(outFinished, streamId, headerBlock);
-    }
-
-    @Override public synchronized void headers(int streamId, List<Header> headerBlock)
-        throws IOException {
-      if (closed) throw new IOException("closed");
-      headers(false, streamId, headerBlock);
-    }
-
-    @Override public synchronized void pushPromise(int streamId, int promisedStreamId,
-        List<Header> requestHeaders) throws IOException {
-      if (closed) throw new IOException("closed");
-      hpackWriter.writeHeaders(requestHeaders);
-
-      long byteCount = hpackBuffer.size();
-      int length = (int) Math.min(maxFrameSize - 4, byteCount);
-      byte type = TYPE_PUSH_PROMISE;
-      byte flags = byteCount == length ? FLAG_END_HEADERS : 0;
-      frameHeader(streamId, length + 4, type, flags);
-      sink.writeInt(promisedStreamId & 0x7fffffff);
-      sink.write(hpackBuffer, length);
-
-      if (byteCount > length) writeContinuationFrames(streamId, byteCount - length);
-    }
-
-    void headers(boolean outFinished, int streamId, List<Header> headerBlock) throws IOException {
-      if (closed) throw new IOException("closed");
-      hpackWriter.writeHeaders(headerBlock);
-
-      long byteCount = hpackBuffer.size();
-      int length = (int) Math.min(maxFrameSize, byteCount);
-      byte type = TYPE_HEADERS;
-      byte flags = byteCount == length ? FLAG_END_HEADERS : 0;
-      if (outFinished) flags |= FLAG_END_STREAM;
-      frameHeader(streamId, length, type, flags);
-      sink.write(hpackBuffer, length);
-
-      if (byteCount > length) writeContinuationFrames(streamId, byteCount - length);
-    }
-
-    private void writeContinuationFrames(int streamId, long byteCount) throws IOException {
-      while (byteCount > 0) {
-        int length = (int) Math.min(maxFrameSize, byteCount);
-        byteCount -= length;
-        frameHeader(streamId, length, TYPE_CONTINUATION, byteCount == 0 ? FLAG_END_HEADERS : 0);
-        sink.write(hpackBuffer, length);
-      }
-    }
-
-    @Override public synchronized void rstStream(int streamId, ErrorCode errorCode)
-        throws IOException {
-      if (closed) throw new IOException("closed");
-      if (errorCode.httpCode == -1) throw new IllegalArgumentException();
-
-      int length = 4;
-      byte type = TYPE_RST_STREAM;
-      byte flags = FLAG_NONE;
-      frameHeader(streamId, length, type, flags);
-      sink.writeInt(errorCode.httpCode);
-      sink.flush();
-    }
-
-    @Override public int maxDataLength() {
-      return maxFrameSize;
-    }
-
-    @Override public synchronized void data(boolean outFinished, int streamId, Buffer source,
-        int byteCount) throws IOException {
-      if (closed) throw new IOException("closed");
-      byte flags = FLAG_NONE;
-      if (outFinished) flags |= FLAG_END_STREAM;
-      dataFrame(streamId, flags, source, byteCount);
-    }
-
-    void dataFrame(int streamId, byte flags, Buffer buffer, int byteCount) throws IOException {
-      byte type = TYPE_DATA;
-      frameHeader(streamId, byteCount, type, flags);
-      if (byteCount > 0) {
-        sink.write(buffer, byteCount);
-      }
-    }
-
-    @Override public synchronized void settings(Settings settings) throws IOException {
-      if (closed) throw new IOException("closed");
-      int length = settings.size() * 6;
-      byte type = TYPE_SETTINGS;
-      byte flags = FLAG_NONE;
-      int streamId = 0;
-      frameHeader(streamId, length, type, flags);
-      for (int i = 0; i < Settings.COUNT; i++) {
-        if (!settings.isSet(i)) continue;
-        int id = i;
-        if (id == 4) {
-          id = 3; // SETTINGS_MAX_CONCURRENT_STREAMS renumbered.
-        } else if (id == 7) {
-          id = 4; // SETTINGS_INITIAL_WINDOW_SIZE renumbered.
-        }
-        sink.writeShort(id);
-        sink.writeInt(settings.get(i));
-      }
-      sink.flush();
-    }
-
-    @Override public synchronized void ping(boolean ack, int payload1, int payload2)
-        throws IOException {
-      if (closed) throw new IOException("closed");
-      int length = 8;
-      byte type = TYPE_PING;
-      byte flags = ack ? FLAG_ACK : FLAG_NONE;
-      int streamId = 0;
-      frameHeader(streamId, length, type, flags);
-      sink.writeInt(payload1);
-      sink.writeInt(payload2);
-      sink.flush();
-    }
-
-    @Override public synchronized void goAway(int lastGoodStreamId, ErrorCode errorCode,
-        byte[] debugData) throws IOException {
-      if (closed) throw new IOException("closed");
-      if (errorCode.httpCode == -1) throw illegalArgument("errorCode.httpCode == -1");
-      int length = 8 + debugData.length;
-      byte type = TYPE_GOAWAY;
-      byte flags = FLAG_NONE;
-      int streamId = 0;
-      frameHeader(streamId, length, type, flags);
-      sink.writeInt(lastGoodStreamId);
-      sink.writeInt(errorCode.httpCode);
-      if (debugData.length > 0) {
-        sink.write(debugData);
-      }
-      sink.flush();
-    }
-
-    @Override public synchronized void windowUpdate(int streamId, long windowSizeIncrement)
-        throws IOException {
-      if (closed) throw new IOException("closed");
-      if (windowSizeIncrement == 0 || windowSizeIncrement > 0x7fffffffL) {
-        throw illegalArgument("windowSizeIncrement == 0 || windowSizeIncrement > 0x7fffffffL: %s",
-            windowSizeIncrement);
-      }
-      int length = 4;
-      byte type = TYPE_WINDOW_UPDATE;
-      byte flags = FLAG_NONE;
-      frameHeader(streamId, length, type, flags);
-      sink.writeInt((int) windowSizeIncrement);
-      sink.flush();
-    }
-
-    @Override public synchronized void close() throws IOException {
-      closed = true;
-      sink.close();
-    }
-
-    void frameHeader(int streamId, int length, byte type, byte flags) throws IOException {
-      if (logger.isLoggable(FINE)) logger.fine(formatHeader(false, streamId, length, type, flags));
-      if (length > maxFrameSize) {
-        throw illegalArgument("FRAME_SIZE_ERROR length > %d: %d", maxFrameSize, length);
-      }
-      if ((streamId & 0x80000000) != 0) throw illegalArgument("reserved bit set: %s", streamId);
-      writeMedium(sink, length);
-      sink.writeByte(type & 0xff);
-      sink.writeByte(flags & 0xff);
-      sink.writeInt(streamId & 0x7fffffff);
-    }
-  }
-
-  private static IllegalArgumentException illegalArgument(String message, Object... args) {
-    throw new IllegalArgumentException(format(message, args));
-  }
-
-  private static IOException ioException(String message, Object... args) throws IOException {
-    throw new IOException(format(message, args));
-  }
-
-  /**
-   * Decompression of the header block occurs above the framing layer. This class lazily reads
-   * continuation frames as they are needed by {@link Hpack.Reader#readHeaders()}.
-   */
-  static final class ContinuationSource implements Source {
-    private final BufferedSource source;
-
-    int length;
-    byte flags;
-    int streamId;
-
-    int left;
-    short padding;
-
-    public ContinuationSource(BufferedSource source) {
-      this.source = source;
-    }
-
-    @Override public long read(Buffer sink, long byteCount) throws IOException {
-      while (left == 0) {
-        source.skip(padding);
-        padding = 0;
-        if ((flags & FLAG_END_HEADERS) != 0) return -1;
-        readContinuationHeader();
-        // TODO: test case for empty continuation header?
-      }
-
-      long read = source.read(sink, Math.min(byteCount, left));
-      if (read == -1) return -1;
-      left -= read;
-      return read;
-    }
-
-    @Override public Timeout timeout() {
-      return source.timeout();
-    }
-
-    @Override public void close() throws IOException {
-    }
-
-    private void readContinuationHeader() throws IOException {
-      int previousStreamId = streamId;
-
-      length = left = readMedium(source);
-      byte type = (byte) (source.readByte() & 0xff);
-      flags = (byte) (source.readByte() & 0xff);
-      if (logger.isLoggable(FINE)) logger.fine(formatHeader(true, streamId, length, type, flags));
-      streamId = (source.readInt() & 0x7fffffff);
-      if (type != TYPE_CONTINUATION) throw ioException("%s != TYPE_CONTINUATION", type);
-      if (streamId != previousStreamId) throw ioException("TYPE_CONTINUATION streamId changed");
-    }
-  }
-
-  private static int lengthWithoutPadding(int length, byte flags, short padding)
-      throws IOException {
-    if ((flags & FLAG_PADDED) != 0) length--; // Account for reading the padding length.
-    if (padding > length) {
-      throw ioException("PROTOCOL_ERROR padding %s > remaining length %s", padding, length);
-    }
-    return (short) (length - padding);
-  }
-
-  /**
-   * Logs a human-readable representation of HTTP/2 frame headers.
-   *
-   * <p>The format is:
-   *
-   * <pre>
-   *   direction streamID length type flags
-   * </pre>
-   * Where direction is {@code <<} for inbound and {@code >>} for outbound.
-   *
-   * <p>For example, the following would indicate a HEAD request sent from the client.
-   * <pre>
-   * {@code
-   *   << 0x0000000f    12 HEADERS       END_HEADERS|END_STREAM
-   * }
-   * </pre>
-   */
-  static final class FrameLogger {
-
-    static String formatHeader(boolean inbound, int streamId, int length, byte type, byte flags) {
-      String formattedType = type < TYPES.length ? TYPES[type] : format("0x%02x", type);
-      String formattedFlags = formatFlags(type, flags);
-      return format("%s 0x%08x %5d %-13s %s", inbound ? "<<" : ">>", streamId, length,
-          formattedType, formattedFlags);
-    }
-
-    /**
-     * Looks up valid string representing flags from the table. Invalid combinations are represented
-     * in binary.
-     */
-    // Visible for testing.
-    static String formatFlags(byte type, byte flags) {
-      if (flags == 0) return "";
-      switch (type) { // Special case types that have 0 or 1 flag.
-        case TYPE_SETTINGS:
-        case TYPE_PING:
-          return flags == FLAG_ACK ? "ACK" : BINARY[flags];
-        case TYPE_PRIORITY:
-        case TYPE_RST_STREAM:
-        case TYPE_GOAWAY:
-        case TYPE_WINDOW_UPDATE:
-          return BINARY[flags];
-      }
-      String result = flags < FLAGS.length ? FLAGS[flags] : BINARY[flags];
-      // Special case types that have overlap flag values.
-      if (type == TYPE_PUSH_PROMISE && (flags & FLAG_END_PUSH_PROMISE) != 0) {
-        return result.replace("HEADERS", "PUSH_PROMISE"); // TODO: Avoid allocation.
-      } else if (type == TYPE_DATA && (flags & FLAG_COMPRESSED) != 0) {
-        return result.replace("PRIORITY", "COMPRESSED"); // TODO: Avoid allocation.
-      }
-      return result;
-    }
-
-    /** Lookup table for valid frame types. */
-    private static final String[] TYPES = new String[] {
-        "DATA",
-        "HEADERS",
-        "PRIORITY",
-        "RST_STREAM",
-        "SETTINGS",
-        "PUSH_PROMISE",
-        "PING",
-        "GOAWAY",
-        "WINDOW_UPDATE",
-        "CONTINUATION"
-    };
-
-    /**
-     * Lookup table for valid flags for DATA, HEADERS, CONTINUATION. Invalid combinations are
-     * represented in binary.
-     */
-    private static final String[] FLAGS = new String[0x40]; // Highest bit flag is 0x20.
-    private static final String[] BINARY = new String[256];
-
-    static {
-      for (int i = 0; i < BINARY.length; i++) {
-        BINARY[i] = format("%8s", Integer.toBinaryString(i)).replace(' ', '0');
-      }
-
-      FLAGS[FLAG_NONE] = "";
-      FLAGS[FLAG_END_STREAM] = "END_STREAM";
-
-      int[] prefixFlags = new int[] {FLAG_END_STREAM};
-
-      FLAGS[FLAG_PADDED] = "PADDED";
-      for (int prefixFlag : prefixFlags) {
-        FLAGS[prefixFlag | FLAG_PADDED] = FLAGS[prefixFlag] + "|PADDED";
-      }
-
-      FLAGS[FLAG_END_HEADERS] = "END_HEADERS"; // Same as END_PUSH_PROMISE.
-      FLAGS[FLAG_PRIORITY] = "PRIORITY"; // Same as FLAG_COMPRESSED.
-      FLAGS[FLAG_END_HEADERS | FLAG_PRIORITY] = "END_HEADERS|PRIORITY"; // Only valid on HEADERS.
-      int[] frameFlags =
-          new int[] {FLAG_END_HEADERS, FLAG_PRIORITY, FLAG_END_HEADERS | FLAG_PRIORITY};
-
-      for (int frameFlag : frameFlags) {
-        for (int prefixFlag : prefixFlags) {
-          FLAGS[prefixFlag | frameFlag] = FLAGS[prefixFlag] + '|' + FLAGS[frameFlag];
-          FLAGS[prefixFlag | frameFlag | FLAG_PADDED] =
-              FLAGS[prefixFlag] + '|' + FLAGS[frameFlag] + "|PADDED";
-        }
-      }
-
-      for (int i = 0; i < FLAGS.length; i++) { // Fill in holes with binary representation.
-        if (FLAGS[i] == null) FLAGS[i] = BINARY[i];
-      }
-    }
-  }
-
-  private static int readMedium(BufferedSource source) throws IOException {
-    return (source.readByte() & 0xff) << 16
-        | (source.readByte() & 0xff) << 8
-        | (source.readByte() & 0xff);
-  }
-
-  private static void writeMedium(BufferedSink sink, int i) throws IOException {
-    sink.writeByte((i >>> 16) & 0xff);
-    sink.writeByte((i >>> 8) & 0xff);
-    sink.writeByte(i & 0xff);
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/NameValueBlockReader.java b/okhttp/src/main/java/okhttp3/internal/framed/NameValueBlockReader.java
deleted file mode 100644
index 75cd9594f7..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/framed/NameValueBlockReader.java
+++ /dev/null
@@ -1,117 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.framed;
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.zip.DataFormatException;
-import java.util.zip.Inflater;
-import okio.Buffer;
-import okio.BufferedSource;
-import okio.ByteString;
-import okio.ForwardingSource;
-import okio.InflaterSource;
-import okio.Okio;
-import okio.Source;
-
-/**
- * Reads a SPDY/3 Name/Value header block. This class is made complicated by the requirement that
- * we're strict with which bytes we put in the compressed bytes buffer. We need to put all
- * compressed bytes into that buffer -- but no other bytes.
- */
-class NameValueBlockReader {
-  /** This source transforms compressed bytes into uncompressed bytes. */
-  private final InflaterSource inflaterSource;
-
-  /**
-   * How many compressed bytes must be read into inflaterSource before {@link #readNameValueBlock}
-   * returns.
-   */
-  private int compressedLimit;
-
-  /** This source holds inflated bytes. */
-  private final BufferedSource source;
-
-  public NameValueBlockReader(BufferedSource source) {
-    // Limit the inflater input stream to only those bytes in the Name/Value
-    // block. We cut the inflater off at its source because we can't predict the
-    // ratio of compressed bytes to uncompressed bytes.
-    Source throttleSource = new ForwardingSource(source) {
-      @Override public long read(Buffer sink, long byteCount) throws IOException {
-        if (compressedLimit == 0) return -1; // Out of data for the current block.
-        long read = super.read(sink, Math.min(byteCount, compressedLimit));
-        if (read == -1) return -1;
-        compressedLimit -= read;
-        return read;
-      }
-    };
-
-    // Subclass inflater to install a dictionary when it's needed.
-    Inflater inflater = new Inflater() {
-      @Override public int inflate(byte[] buffer, int offset, int count)
-          throws DataFormatException {
-        int result = super.inflate(buffer, offset, count);
-        if (result == 0 && needsDictionary()) {
-          setDictionary(Spdy3.DICTIONARY);
-          result = super.inflate(buffer, offset, count);
-        }
-        return result;
-      }
-    };
-
-    this.inflaterSource = new InflaterSource(throttleSource, inflater);
-    this.source = Okio.buffer(inflaterSource);
-  }
-
-  public List<Header> readNameValueBlock(int length) throws IOException {
-    this.compressedLimit += length;
-
-    int numberOfPairs = source.readInt();
-    if (numberOfPairs < 0) throw new IOException("numberOfPairs < 0: " + numberOfPairs);
-    if (numberOfPairs > 1024) throw new IOException("numberOfPairs > 1024: " + numberOfPairs);
-
-    List<Header> entries = new ArrayList<>(numberOfPairs);
-    for (int i = 0; i < numberOfPairs; i++) {
-      ByteString name = readByteString().toAsciiLowercase();
-      ByteString values = readByteString();
-      if (name.size() == 0) throw new IOException("name.size == 0");
-      entries.add(new Header(name, values));
-    }
-
-    doneReading();
-    return entries;
-  }
-
-  private ByteString readByteString() throws IOException {
-    int length = source.readInt();
-    return source.readByteString(length);
-  }
-
-  private void doneReading() throws IOException {
-    // Move any outstanding unread bytes into the inflater. One side-effect of
-    // deflate compression is that sometimes there are bytes remaining in the
-    // stream after we've consumed all of the content.
-    if (compressedLimit > 0) {
-      inflaterSource.refill();
-      if (compressedLimit != 0) throw new IOException("compressedLimit > 0: " + compressedLimit);
-    }
-  }
-
-  public void close() throws IOException {
-    source.close();
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/Settings.java b/okhttp/src/main/java/okhttp3/internal/framed/Settings.java
deleted file mode 100644
index f4eab01731..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/framed/Settings.java
+++ /dev/null
@@ -1,239 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.framed;
-
-import java.util.Arrays;
-
-/**
- * Settings describe characteristics of the sending peer, which are used by the receiving peer.
- * Settings are {@link FramedConnection connection} scoped.
- */
-public final class Settings {
-  /**
-   * From the SPDY/3 and HTTP/2 specs, the default initial window size for all streams is 64 KiB.
-   * (Chrome 25 uses 10 MiB).
-   */
-  static final int DEFAULT_INITIAL_WINDOW_SIZE = 64 * 1024;
-
-  /** Peer request to clear durable settings. */
-  static final int FLAG_CLEAR_PREVIOUSLY_PERSISTED_SETTINGS = 0x1;
-
-  /** Sent by servers only. The peer requests this setting persisted for future connections. */
-  static final int PERSIST_VALUE = 0x1;
-  /** Sent by clients only. The client is reminding the server of a persisted value. */
-  static final int PERSISTED = 0x2;
-
-  /** spdy/3: Sender's estimate of max incoming kbps. */
-  static final int UPLOAD_BANDWIDTH = 1;
-  /** HTTP/2: Size in bytes of the table used to decode the sender's header blocks. */
-  static final int HEADER_TABLE_SIZE = 1;
-  /** spdy/3: Sender's estimate of max outgoing kbps. */
-  static final int DOWNLOAD_BANDWIDTH = 2;
-  /** HTTP/2: The peer must not send a PUSH_PROMISE frame when this is 0. */
-  static final int ENABLE_PUSH = 2;
-  /** spdy/3: Sender's estimate of millis between sending a request and receiving a response. */
-  static final int ROUND_TRIP_TIME = 3;
-  /** Sender's maximum number of concurrent streams. */
-  static final int MAX_CONCURRENT_STREAMS = 4;
-  /** spdy/3: Current CWND in Packets. */
-  static final int CURRENT_CWND = 5;
-  /** HTTP/2: Size in bytes of the largest frame payload the sender will accept. */
-  static final int MAX_FRAME_SIZE = 5;
-  /** spdy/3: Retransmission rate. Percentage */
-  static final int DOWNLOAD_RETRANS_RATE = 6;
-  /** HTTP/2: Advisory only. Size in bytes of the largest header list the sender will accept. */
-  static final int MAX_HEADER_LIST_SIZE = 6;
-  /** Window size in bytes. */
-  static final int INITIAL_WINDOW_SIZE = 7;
-  /** spdy/3: Size of the client certificate vector. Unsupported. */
-  static final int CLIENT_CERTIFICATE_VECTOR_SIZE = 8;
-  /** Flow control options. */
-  static final int FLOW_CONTROL_OPTIONS = 10;
-
-  /** Total number of settings. */
-  static final int COUNT = 10;
-
-  /** If set, flow control is disabled for streams directed to the sender of these settings. */
-  static final int FLOW_CONTROL_OPTIONS_DISABLED = 0x1;
-
-  /** Bitfield of which flags that values. */
-  private int set;
-
-  /** Bitfield of flags that have {@link #PERSIST_VALUE}. */
-  private int persistValue;
-
-  /** Bitfield of flags that have {@link #PERSISTED}. */
-  private int persisted;
-
-  /** Flag values. */
-  private final int[] values = new int[COUNT];
-
-  void clear() {
-    set = persistValue = persisted = 0;
-    Arrays.fill(values, 0);
-  }
-
-  Settings set(int id, int idFlags, int value) {
-    if (id >= values.length) {
-      return this; // Discard unknown settings.
-    }
-
-    int bit = 1 << id;
-    set |= bit;
-    if ((idFlags & PERSIST_VALUE) != 0) {
-      persistValue |= bit;
-    } else {
-      persistValue &= ~bit;
-    }
-    if ((idFlags & PERSISTED) != 0) {
-      persisted |= bit;
-    } else {
-      persisted &= ~bit;
-    }
-
-    values[id] = value;
-    return this;
-  }
-
-  /** Returns true if a value has been assigned for the setting {@code id}. */
-  boolean isSet(int id) {
-    int bit = 1 << id;
-    return (set & bit) != 0;
-  }
-
-  /** Returns the value for the setting {@code id}, or 0 if unset. */
-  int get(int id) {
-    return values[id];
-  }
-
-  /** Returns the flags for the setting {@code id}, or 0 if unset. */
-  int flags(int id) {
-    int result = 0;
-    if (isPersisted(id)) result |= Settings.PERSISTED;
-    if (persistValue(id)) result |= Settings.PERSIST_VALUE;
-    return result;
-  }
-
-  /** Returns the number of settings that have values assigned. */
-  int size() {
-    return Integer.bitCount(set);
-  }
-
-  /** spdy/3 only. */
-  int getUploadBandwidth(int defaultValue) {
-    int bit = 1 << UPLOAD_BANDWIDTH;
-    return (bit & set) != 0 ? values[UPLOAD_BANDWIDTH] : defaultValue;
-  }
-
-  /** HTTP/2 only. Returns -1 if unset. */
-  int getHeaderTableSize() {
-    int bit = 1 << HEADER_TABLE_SIZE;
-    return (bit & set) != 0 ? values[HEADER_TABLE_SIZE] : -1;
-  }
-
-  /** spdy/3 only. */
-  int getDownloadBandwidth(int defaultValue) {
-    int bit = 1 << DOWNLOAD_BANDWIDTH;
-    return (bit & set) != 0 ? values[DOWNLOAD_BANDWIDTH] : defaultValue;
-  }
-
-  /** HTTP/2 only. */
-  // TODO: honor this setting in HTTP/2.
-  boolean getEnablePush(boolean defaultValue) {
-    int bit = 1 << ENABLE_PUSH;
-    return ((bit & set) != 0 ? values[ENABLE_PUSH] : defaultValue ? 1 : 0) == 1;
-  }
-
-  /** spdy/3 only. */
-  int getRoundTripTime(int defaultValue) {
-    int bit = 1 << ROUND_TRIP_TIME;
-    return (bit & set) != 0 ? values[ROUND_TRIP_TIME] : defaultValue;
-  }
-
-  // TODO: honor this setting in spdy/3 and HTTP/2.
-  int getMaxConcurrentStreams(int defaultValue) {
-    int bit = 1 << MAX_CONCURRENT_STREAMS;
-    return (bit & set) != 0 ? values[MAX_CONCURRENT_STREAMS] : defaultValue;
-  }
-
-  /** spdy/3 only. */
-  int getCurrentCwnd(int defaultValue) {
-    int bit = 1 << CURRENT_CWND;
-    return (bit & set) != 0 ? values[CURRENT_CWND] : defaultValue;
-  }
-
-  /** HTTP/2 only. */
-  int getMaxFrameSize(int defaultValue) {
-    int bit = 1 << MAX_FRAME_SIZE;
-    return (bit & set) != 0 ? values[MAX_FRAME_SIZE] : defaultValue;
-  }
-
-  /** spdy/3 only. */
-  int getDownloadRetransRate(int defaultValue) {
-    int bit = 1 << DOWNLOAD_RETRANS_RATE;
-    return (bit & set) != 0 ? values[DOWNLOAD_RETRANS_RATE] : defaultValue;
-  }
-
-  /** HTTP/2 only. */
-  int getMaxHeaderListSize(int defaultValue) {
-    int bit = 1 << MAX_HEADER_LIST_SIZE;
-    return (bit & set) != 0 ? values[MAX_HEADER_LIST_SIZE] : defaultValue;
-  }
-
-  int getInitialWindowSize(int defaultValue) {
-    int bit = 1 << INITIAL_WINDOW_SIZE;
-    return (bit & set) != 0 ? values[INITIAL_WINDOW_SIZE] : defaultValue;
-  }
-
-  /** spdy/3 only. */
-  int getClientCertificateVectorSize(int defaultValue) {
-    int bit = 1 << CLIENT_CERTIFICATE_VECTOR_SIZE;
-    return (bit & set) != 0 ? values[CLIENT_CERTIFICATE_VECTOR_SIZE] : defaultValue;
-  }
-
-  // TODO: honor this setting in spdy/3 and HTTP/2.
-  boolean isFlowControlDisabled() {
-    int bit = 1 << FLOW_CONTROL_OPTIONS;
-    int value = (bit & set) != 0 ? values[FLOW_CONTROL_OPTIONS] : 0;
-    return (value & FLOW_CONTROL_OPTIONS_DISABLED) != 0;
-  }
-
-  /**
-   * Returns true if this user agent should use this setting in future spdy/3 connections to the
-   * same host.
-   */
-  boolean persistValue(int id) {
-    int bit = 1 << id;
-    return (persistValue & bit) != 0;
-  }
-
-  /** Returns true if this setting was persisted. */
-  boolean isPersisted(int id) {
-    int bit = 1 << id;
-    return (persisted & bit) != 0;
-  }
-
-  /**
-   * Writes {@code other} into this. If any setting is populated by this and {@code other}, the
-   * value and flags from {@code other} will be kept.
-   */
-  void merge(Settings other) {
-    for (int i = 0; i < COUNT; i++) {
-      if (!other.isSet(i)) continue;
-      set(i, other.flags(i), other.get(i));
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/Spdy3.java b/okhttp/src/main/java/okhttp3/internal/framed/Spdy3.java
deleted file mode 100644
index 37e1796c5c..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/framed/Spdy3.java
+++ /dev/null
@@ -1,491 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.framed;
-
-import java.io.IOException;
-import java.io.UnsupportedEncodingException;
-import java.net.ProtocolException;
-import java.util.List;
-import java.util.zip.Deflater;
-import okhttp3.Protocol;
-import okhttp3.internal.Util;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.ByteString;
-import okio.DeflaterSink;
-import okio.Okio;
-
-/**
- * Read and write spdy/3.1 frames. http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1
- */
-public final class Spdy3 implements Variant {
-
-  @Override public Protocol getProtocol() {
-    return Protocol.SPDY_3;
-  }
-
-  static final int TYPE_DATA = 0x0;
-  static final int TYPE_SYN_STREAM = 0x1;
-  static final int TYPE_SYN_REPLY = 0x2;
-  static final int TYPE_RST_STREAM = 0x3;
-  static final int TYPE_SETTINGS = 0x4;
-  static final int TYPE_PING = 0x6;
-  static final int TYPE_GOAWAY = 0x7;
-  static final int TYPE_HEADERS = 0x8;
-  static final int TYPE_WINDOW_UPDATE = 0x9;
-
-  static final int FLAG_FIN = 0x1;
-  static final int FLAG_UNIDIRECTIONAL = 0x2;
-
-  static final int VERSION = 3;
-
-  static final byte[] DICTIONARY;
-
-  static {
-    try {
-      DICTIONARY = ("\u0000\u0000\u0000\u0007options\u0000\u0000\u0000\u0004hea"
-          + "d\u0000\u0000\u0000\u0004post\u0000\u0000\u0000\u0003put\u0000\u0000\u0000\u0006dele"
-          + "te\u0000\u0000\u0000\u0005trace\u0000\u0000\u0000\u0006accept\u0000\u0000\u0000"
-          + "\u000Eaccept-charset\u0000\u0000\u0000\u000Faccept-encoding\u0000\u0000\u0000\u000Fa"
-          + "ccept-language\u0000\u0000\u0000\raccept-ranges\u0000\u0000\u0000\u0003age\u0000"
-          + "\u0000\u0000\u0005allow\u0000\u0000\u0000\rauthorization\u0000\u0000\u0000\rcache-co"
-          + "ntrol\u0000\u0000\u0000\nconnection\u0000\u0000\u0000\fcontent-base\u0000\u0000"
-          + "\u0000\u0010content-encoding\u0000\u0000\u0000\u0010content-language\u0000\u0000"
-          + "\u0000\u000Econtent-length\u0000\u0000\u0000\u0010content-location\u0000\u0000\u0000"
-          + "\u000Bcontent-md5\u0000\u0000\u0000\rcontent-range\u0000\u0000\u0000\fcontent-type"
-          + "\u0000\u0000\u0000\u0004date\u0000\u0000\u0000\u0004etag\u0000\u0000\u0000\u0006expe"
-          + "ct\u0000\u0000\u0000\u0007expires\u0000\u0000\u0000\u0004from\u0000\u0000\u0000"
-          + "\u0004host\u0000\u0000\u0000\bif-match\u0000\u0000\u0000\u0011if-modified-since"
-          + "\u0000\u0000\u0000\rif-none-match\u0000\u0000\u0000\bif-range\u0000\u0000\u0000"
-          + "\u0013if-unmodified-since\u0000\u0000\u0000\rlast-modified\u0000\u0000\u0000\blocati"
-          + "on\u0000\u0000\u0000\fmax-forwards\u0000\u0000\u0000\u0006pragma\u0000\u0000\u0000"
-          + "\u0012proxy-authenticate\u0000\u0000\u0000\u0013proxy-authorization\u0000\u0000"
-          + "\u0000\u0005range\u0000\u0000\u0000\u0007referer\u0000\u0000\u0000\u000Bretry-after"
-          + "\u0000\u0000\u0000\u0006server\u0000\u0000\u0000\u0002te\u0000\u0000\u0000\u0007trai"
-          + "ler\u0000\u0000\u0000\u0011transfer-encoding\u0000\u0000\u0000\u0007upgrade\u0000"
-          + "\u0000\u0000\nuser-agent\u0000\u0000\u0000\u0004vary\u0000\u0000\u0000\u0003via"
-          + "\u0000\u0000\u0000\u0007warning\u0000\u0000\u0000\u0010www-authenticate\u0000\u0000"
-          + "\u0000\u0006method\u0000\u0000\u0000\u0003get\u0000\u0000\u0000\u0006status\u0000"
-          + "\u0000\u0000\u0006200 OK\u0000\u0000\u0000\u0007version\u0000\u0000\u0000\bHTTP/1.1"
-          + "\u0000\u0000\u0000\u0003url\u0000\u0000\u0000\u0006public\u0000\u0000\u0000\nset-coo"
-          + "kie\u0000\u0000\u0000\nkeep-alive\u0000\u0000\u0000\u0006origin100101201202205206300"
-          + "302303304305306307402405406407408409410411412413414415416417502504505203 Non-Authori"
-          + "tative Information204 No Content301 Moved Permanently400 Bad Request401 Unauthorized"
-          + "403 Forbidden404 Not Found500 Internal Server Error501 Not Implemented503 Service Un"
-          + "availableJan Feb Mar Apr May Jun Jul Aug Sept Oct Nov Dec 00:00:00 Mon, Tue, Wed, Th"
-          + "u, Fri, Sat, Sun, GMTchunked,text/html,image/png,image/jpg,image/gif,application/xml"
-          + ",application/xhtml+xml,text/plain,text/javascript,publicprivatemax-age=gzip,deflate,"
-          + "sdchcharset=utf-8charset=iso-8859-1,utf-,*,enq=0.").getBytes(Util.UTF_8.name());
-    } catch (UnsupportedEncodingException e) {
-      throw new AssertionError();
-    }
-  }
-
-  @Override public FrameReader newReader(BufferedSource source, boolean client) {
-    return new Reader(source, client);
-  }
-
-  @Override public FrameWriter newWriter(BufferedSink sink, boolean client) {
-    return new Writer(sink, client);
-  }
-
-  /** Read spdy/3 frames. */
-  static final class Reader implements FrameReader {
-    private final BufferedSource source;
-    private final boolean client;
-    private final NameValueBlockReader headerBlockReader;
-
-    Reader(BufferedSource source, boolean client) {
-      this.source = source;
-      this.headerBlockReader = new NameValueBlockReader(this.source);
-      this.client = client;
-    }
-
-    @Override public void readConnectionPreface() {
-    }
-
-    /**
-     * Send the next frame to {@code handler}. Returns true unless there are no more frames on the
-     * stream.
-     */
-    @Override public boolean nextFrame(Handler handler) throws IOException {
-      int w1;
-      int w2;
-      try {
-        w1 = source.readInt();
-        w2 = source.readInt();
-      } catch (IOException e) {
-        return false; // This might be a normal socket close.
-      }
-
-      boolean control = (w1 & 0x80000000) != 0;
-      int flags = (w2 & 0xff000000) >>> 24;
-      int length = (w2 & 0xffffff);
-
-      if (control) {
-        int version = (w1 & 0x7fff0000) >>> 16;
-        int type = (w1 & 0xffff);
-
-        if (version != 3) {
-          throw new ProtocolException("version != 3: " + version);
-        }
-
-        switch (type) {
-          case TYPE_SYN_STREAM:
-            readSynStream(handler, flags, length);
-            return true;
-
-          case TYPE_SYN_REPLY:
-            readSynReply(handler, flags, length);
-            return true;
-
-          case TYPE_RST_STREAM:
-            readRstStream(handler, flags, length);
-            return true;
-
-          case TYPE_SETTINGS:
-            readSettings(handler, flags, length);
-            return true;
-
-          case TYPE_PING:
-            readPing(handler, flags, length);
-            return true;
-
-          case TYPE_GOAWAY:
-            readGoAway(handler, flags, length);
-            return true;
-
-          case TYPE_HEADERS:
-            readHeaders(handler, flags, length);
-            return true;
-
-          case TYPE_WINDOW_UPDATE:
-            readWindowUpdate(handler, flags, length);
-            return true;
-
-          default:
-            source.skip(length);
-            return true;
-        }
-      } else {
-        int streamId = w1 & 0x7fffffff;
-        boolean inFinished = (flags & FLAG_FIN) != 0;
-        handler.data(inFinished, streamId, source, length);
-        return true;
-      }
-    }
-
-    private void readSynStream(Handler handler, int flags, int length) throws IOException {
-      int w1 = source.readInt();
-      int w2 = source.readInt();
-      int streamId = w1 & 0x7fffffff;
-      int associatedStreamId = w2 & 0x7fffffff;
-      source.readShort(); // int priority = (s3 & 0xe000) >>> 13; int slot = s3 & 0xff;
-      List<Header> headerBlock = headerBlockReader.readNameValueBlock(length - 10);
-
-      boolean inFinished = (flags & FLAG_FIN) != 0;
-      boolean outFinished = (flags & FLAG_UNIDIRECTIONAL) != 0;
-      handler.headers(outFinished, inFinished, streamId, associatedStreamId, headerBlock,
-          HeadersMode.SPDY_SYN_STREAM);
-    }
-
-    private void readSynReply(Handler handler, int flags, int length) throws IOException {
-      int w1 = source.readInt();
-      int streamId = w1 & 0x7fffffff;
-      List<Header> headerBlock = headerBlockReader.readNameValueBlock(length - 4);
-      boolean inFinished = (flags & FLAG_FIN) != 0;
-      handler.headers(false, inFinished, streamId, -1, headerBlock, HeadersMode.SPDY_REPLY);
-    }
-
-    private void readRstStream(Handler handler, int flags, int length) throws IOException {
-      if (length != 8) throw ioException("TYPE_RST_STREAM length: %d != 8", length);
-      int streamId = source.readInt() & 0x7fffffff;
-      int errorCodeInt = source.readInt();
-      ErrorCode errorCode = ErrorCode.fromSpdy3Rst(errorCodeInt);
-      if (errorCode == null) {
-        throw ioException("TYPE_RST_STREAM unexpected error code: %d", errorCodeInt);
-      }
-      handler.rstStream(streamId, errorCode);
-    }
-
-    private void readHeaders(Handler handler, int flags, int length) throws IOException {
-      int w1 = source.readInt();
-      int streamId = w1 & 0x7fffffff;
-      List<Header> headerBlock = headerBlockReader.readNameValueBlock(length - 4);
-      handler.headers(false, false, streamId, -1, headerBlock, HeadersMode.SPDY_HEADERS);
-    }
-
-    private void readWindowUpdate(Handler handler, int flags, int length) throws IOException {
-      if (length != 8) throw ioException("TYPE_WINDOW_UPDATE length: %d != 8", length);
-      int w1 = source.readInt();
-      int w2 = source.readInt();
-      int streamId = w1 & 0x7fffffff;
-      long increment = w2 & 0x7fffffff;
-      if (increment == 0) throw ioException("windowSizeIncrement was 0", increment);
-      handler.windowUpdate(streamId, increment);
-    }
-
-    private void readPing(Handler handler, int flags, int length) throws IOException {
-      if (length != 4) throw ioException("TYPE_PING length: %d != 4", length);
-      int id = source.readInt();
-      boolean ack = client == ((id & 1) == 1);
-      handler.ping(ack, id, 0);
-    }
-
-    private void readGoAway(Handler handler, int flags, int length) throws IOException {
-      if (length != 8) throw ioException("TYPE_GOAWAY length: %d != 8", length);
-      int lastGoodStreamId = source.readInt() & 0x7fffffff;
-      int errorCodeInt = source.readInt();
-      ErrorCode errorCode = ErrorCode.fromSpdyGoAway(errorCodeInt);
-      if (errorCode == null) {
-        throw ioException("TYPE_GOAWAY unexpected error code: %d", errorCodeInt);
-      }
-      handler.goAway(lastGoodStreamId, errorCode, ByteString.EMPTY);
-    }
-
-    private void readSettings(Handler handler, int flags, int length) throws IOException {
-      int numberOfEntries = source.readInt();
-      if (length != 4 + 8 * numberOfEntries) {
-        throw ioException("TYPE_SETTINGS length: %d != 4 + 8 * %d", length, numberOfEntries);
-      }
-      Settings settings = new Settings();
-      for (int i = 0; i < numberOfEntries; i++) {
-        int w1 = source.readInt();
-        int value = source.readInt();
-        int idFlags = (w1 & 0xff000000) >>> 24;
-        int id = w1 & 0xffffff;
-        settings.set(id, idFlags, value);
-      }
-      boolean clearPrevious = (flags & Settings.FLAG_CLEAR_PREVIOUSLY_PERSISTED_SETTINGS) != 0;
-      handler.settings(clearPrevious, settings);
-    }
-
-    private static IOException ioException(String message, Object... args) throws IOException {
-      throw new IOException(Util.format(message, args));
-    }
-
-    @Override public void close() throws IOException {
-      headerBlockReader.close();
-    }
-  }
-
-  /** Write spdy/3 frames. */
-  static final class Writer implements FrameWriter {
-    private final BufferedSink sink;
-    private final Buffer headerBlockBuffer;
-    private final BufferedSink headerBlockOut;
-    private final boolean client;
-    private boolean closed;
-
-    Writer(BufferedSink sink, boolean client) {
-      this.sink = sink;
-      this.client = client;
-
-      Deflater deflater = new Deflater();
-      deflater.setDictionary(DICTIONARY);
-      headerBlockBuffer = new Buffer();
-      headerBlockOut = Okio.buffer(new DeflaterSink(headerBlockBuffer, deflater));
-    }
-
-    @Override public void ackSettings(Settings peerSettings) {
-      // Do nothing: no ACK for SPDY/3 settings.
-    }
-
-    @Override
-    public void pushPromise(int streamId, int promisedStreamId, List<Header> requestHeaders)
-        throws IOException {
-      // Do nothing: no push promise for SPDY/3.
-    }
-
-    @Override public synchronized void connectionPreface() {
-      // Do nothing: no connection preface for SPDY/3.
-    }
-
-    @Override public synchronized void flush() throws IOException {
-      if (closed) throw new IOException("closed");
-      sink.flush();
-    }
-
-    @Override public synchronized void synStream(boolean outFinished, boolean inFinished,
-        int streamId, int associatedStreamId, List<Header> headerBlock)
-        throws IOException {
-      if (closed) throw new IOException("closed");
-      writeNameValueBlockToBuffer(headerBlock);
-      int length = (int) (10 + headerBlockBuffer.size());
-      int type = TYPE_SYN_STREAM;
-      int flags = (outFinished ? FLAG_FIN : 0) | (inFinished ? FLAG_UNIDIRECTIONAL : 0);
-
-      int unused = 0;
-      sink.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
-      sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
-      sink.writeInt(streamId & 0x7fffffff);
-      sink.writeInt(associatedStreamId & 0x7fffffff);
-      sink.writeShort((unused & 0x7) << 13 | (unused & 0x1f) << 8 | (unused & 0xff));
-      sink.writeAll(headerBlockBuffer);
-      sink.flush();
-    }
-
-    @Override public synchronized void synReply(boolean outFinished, int streamId,
-        List<Header> headerBlock) throws IOException {
-      if (closed) throw new IOException("closed");
-      writeNameValueBlockToBuffer(headerBlock);
-      int type = TYPE_SYN_REPLY;
-      int flags = (outFinished ? FLAG_FIN : 0);
-      int length = (int) (headerBlockBuffer.size() + 4);
-
-      sink.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
-      sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
-      sink.writeInt(streamId & 0x7fffffff);
-      sink.writeAll(headerBlockBuffer);
-      sink.flush();
-    }
-
-    @Override public synchronized void headers(int streamId, List<Header> headerBlock)
-        throws IOException {
-      if (closed) throw new IOException("closed");
-      writeNameValueBlockToBuffer(headerBlock);
-      int flags = 0;
-      int type = TYPE_HEADERS;
-      int length = (int) (headerBlockBuffer.size() + 4);
-
-      sink.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
-      sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
-      sink.writeInt(streamId & 0x7fffffff);
-      sink.writeAll(headerBlockBuffer);
-    }
-
-    @Override public synchronized void rstStream(int streamId, ErrorCode errorCode)
-        throws IOException {
-      if (closed) throw new IOException("closed");
-      if (errorCode.spdyRstCode == -1) throw new IllegalArgumentException();
-      int flags = 0;
-      int type = TYPE_RST_STREAM;
-      int length = 8;
-      sink.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
-      sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
-      sink.writeInt(streamId & 0x7fffffff);
-      sink.writeInt(errorCode.spdyRstCode);
-      sink.flush();
-    }
-
-    @Override public int maxDataLength() {
-      return 16383;
-    }
-
-    @Override public synchronized void data(boolean outFinished, int streamId, Buffer source,
-        int byteCount) throws IOException {
-      int flags = (outFinished ? FLAG_FIN : 0);
-      sendDataFrame(streamId, flags, source, byteCount);
-    }
-
-    void sendDataFrame(int streamId, int flags, Buffer buffer, int byteCount)
-        throws IOException {
-      if (closed) throw new IOException("closed");
-      if (byteCount > 0xffffffL) {
-        throw new IllegalArgumentException("FRAME_TOO_LARGE max size is 16Mib: " + byteCount);
-      }
-      sink.writeInt(streamId & 0x7fffffff);
-      sink.writeInt((flags & 0xff) << 24 | byteCount & 0xffffff);
-      if (byteCount > 0) {
-        sink.write(buffer, byteCount);
-      }
-    }
-
-    private void writeNameValueBlockToBuffer(List<Header> headerBlock) throws IOException {
-      headerBlockOut.writeInt(headerBlock.size());
-      for (int i = 0, size = headerBlock.size(); i < size; i++) {
-        ByteString name = headerBlock.get(i).name;
-        headerBlockOut.writeInt(name.size());
-        headerBlockOut.write(name);
-        ByteString value = headerBlock.get(i).value;
-        headerBlockOut.writeInt(value.size());
-        headerBlockOut.write(value);
-      }
-      headerBlockOut.flush();
-    }
-
-    @Override public synchronized void settings(Settings settings) throws IOException {
-      if (closed) throw new IOException("closed");
-      int type = TYPE_SETTINGS;
-      int flags = 0;
-      int size = settings.size();
-      int length = 4 + size * 8;
-      sink.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
-      sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
-      sink.writeInt(size);
-      for (int i = 0; i <= Settings.COUNT; i++) {
-        if (!settings.isSet(i)) continue;
-        int settingsFlags = settings.flags(i);
-        sink.writeInt((settingsFlags & 0xff) << 24 | (i & 0xffffff));
-        sink.writeInt(settings.get(i));
-      }
-      sink.flush();
-    }
-
-    @Override public synchronized void ping(boolean reply, int payload1, int payload2)
-        throws IOException {
-      if (closed) throw new IOException("closed");
-      boolean payloadIsReply = client != ((payload1 & 1) == 1);
-      if (reply != payloadIsReply) throw new IllegalArgumentException("payload != reply");
-      int type = TYPE_PING;
-      int flags = 0;
-      int length = 4;
-      sink.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
-      sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
-      sink.writeInt(payload1);
-      sink.flush();
-    }
-
-    @Override public synchronized void goAway(int lastGoodStreamId, ErrorCode errorCode,
-        byte[] ignored) throws IOException {
-      if (closed) throw new IOException("closed");
-      if (errorCode.spdyGoAwayCode == -1) {
-        throw new IllegalArgumentException("errorCode.spdyGoAwayCode == -1");
-      }
-      int type = TYPE_GOAWAY;
-      int flags = 0;
-      int length = 8;
-      sink.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
-      sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
-      sink.writeInt(lastGoodStreamId);
-      sink.writeInt(errorCode.spdyGoAwayCode);
-      sink.flush();
-    }
-
-    @Override public synchronized void windowUpdate(int streamId, long increment)
-        throws IOException {
-      if (closed) throw new IOException("closed");
-      if (increment == 0 || increment > 0x7fffffffL) {
-        throw new IllegalArgumentException(
-            "windowSizeIncrement must be between 1 and 0x7fffffff: " + increment);
-      }
-      int type = TYPE_WINDOW_UPDATE;
-      int flags = 0;
-      int length = 8;
-      sink.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
-      sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
-      sink.writeInt(streamId);
-      sink.writeInt((int) increment);
-      sink.flush();
-    }
-
-    @Override public synchronized void close() throws IOException {
-      closed = true;
-      Util.closeAll(sink, headerBlockOut);
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/Variant.java b/okhttp/src/main/java/okhttp3/internal/framed/Variant.java
deleted file mode 100644
index 4ff3794007..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/framed/Variant.java
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.framed;
-
-import okhttp3.Protocol;
-import okio.BufferedSink;
-import okio.BufferedSource;
-
-/** A version and dialect of the framed socket protocol. */
-public interface Variant {
-
-  /** The protocol as selected using ALPN. */
-  Protocol getProtocol();
-
-  /**
-   * @param client true if this is the HTTP client's reader, reading frames from a server.
-   */
-  FrameReader newReader(BufferedSource source, boolean client);
-
-  /**
-   * @param client true if this is the HTTP client's writer, writing frames to a server.
-   */
-  FrameWriter newWriter(BufferedSink sink, boolean client);
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.java
new file mode 100644
index 0000000000..c10dc34cdc
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.java
@@ -0,0 +1,128 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package okhttp3.internal.http;
+
+import java.io.IOException;
+import java.util.List;
+import okhttp3.Cookie;
+import okhttp3.CookieJar;
+import okhttp3.Headers;
+import okhttp3.Interceptor;
+import okhttp3.MediaType;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
+import okhttp3.internal.Version;
+import okio.GzipSource;
+import okio.Okio;
+
+import static okhttp3.internal.Util.hostHeader;
+
+/**
+ * Bridges from application code to network code. First it builds a network request from a user
+ * request. Then it proceeds to call the network. Finally it builds a user response from the network
+ * response.
+ */
+public final class BridgeInterceptor implements Interceptor {
+  private final CookieJar cookieJar;
+
+  public BridgeInterceptor(CookieJar cookieJar) {
+    this.cookieJar = cookieJar;
+  }
+
+  @Override public Response intercept(Chain chain) throws IOException {
+    Request userRequest = chain.request();
+    Request.Builder requestBuilder = userRequest.newBuilder();
+
+    RequestBody body = userRequest.body();
+    if (body != null) {
+      MediaType contentType = body.contentType();
+      if (contentType != null) {
+        requestBuilder.header("Content-Type", contentType.toString());
+      }
+
+      long contentLength = body.contentLength();
+      if (contentLength != -1) {
+        requestBuilder.header("Content-Length", Long.toString(contentLength));
+        requestBuilder.removeHeader("Transfer-Encoding");
+      } else {
+        requestBuilder.header("Transfer-Encoding", "chunked");
+        requestBuilder.removeHeader("Content-Length");
+      }
+    }
+
+    if (userRequest.header("Host") == null) {
+      requestBuilder.header("Host", hostHeader(userRequest.url(), false));
+    }
+
+    if (userRequest.header("Connection") == null) {
+      requestBuilder.header("Connection", "Keep-Alive");
+    }
+
+    // If we add an "Accept-Encoding: gzip" header field we're responsible for also decompressing
+    // the transfer stream.
+    boolean transparentGzip = false;
+    if (userRequest.header("Accept-Encoding") == null && userRequest.header("Range") == null) {
+      transparentGzip = true;
+      requestBuilder.header("Accept-Encoding", "gzip");
+    }
+
+    List<Cookie> cookies = cookieJar.loadForRequest(userRequest.url());
+    if (!cookies.isEmpty()) {
+      requestBuilder.header("Cookie", cookieHeader(cookies));
+    }
+
+    if (userRequest.header("User-Agent") == null) {
+      requestBuilder.header("User-Agent", Version.userAgent());
+    }
+
+    Response networkResponse = chain.proceed(requestBuilder.build());
+
+    HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());
+
+    Response.Builder responseBuilder = networkResponse.newBuilder()
+        .request(userRequest);
+
+    if (transparentGzip
+        && "gzip".equalsIgnoreCase(networkResponse.header("Content-Encoding"))
+        && HttpHeaders.hasBody(networkResponse)) {
+      GzipSource responseBody = new GzipSource(networkResponse.body().source());
+      Headers strippedHeaders = networkResponse.headers().newBuilder()
+          .removeAll("Content-Encoding")
+          .removeAll("Content-Length")
+          .build();
+      responseBuilder.headers(strippedHeaders);
+      String contentType = networkResponse.header("Content-Type");
+      responseBuilder.body(new RealResponseBody(contentType, -1L, Okio.buffer(responseBody)));
+    }
+
+    return responseBuilder.build();
+  }
+
+  /** Returns a 'Cookie' HTTP request header with all cookies, like {@code a=b; c=d}. */
+  private String cookieHeader(List<Cookie> cookies) {
+    StringBuilder cookieHeader = new StringBuilder();
+    for (int i = 0, size = cookies.size(); i < size; i++) {
+      if (i > 0) {
+        cookieHeader.append("; ");
+      }
+      Cookie cookie = cookies.get(i);
+      cookieHeader.append(cookie.name()).append('=').append(cookie.value());
+    }
+    return cookieHeader.toString();
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
new file mode 100644
index 0000000000..b7aba87d6a
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
@@ -0,0 +1,138 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http;
+
+import java.io.IOException;
+import java.net.ProtocolException;
+import okhttp3.Interceptor;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.internal.Util;
+import okhttp3.internal.connection.RealConnection;
+import okhttp3.internal.connection.StreamAllocation;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.ForwardingSink;
+import okio.Okio;
+import okio.Sink;
+
+/** This is the last interceptor in the chain. It makes a network call to the server. */
+public final class CallServerInterceptor implements Interceptor {
+  private final boolean forWebSocket;
+
+  public CallServerInterceptor(boolean forWebSocket) {
+    this.forWebSocket = forWebSocket;
+  }
+
+  @Override public Response intercept(Chain chain) throws IOException {
+    RealInterceptorChain realChain = (RealInterceptorChain) chain;
+    HttpCodec httpCodec = realChain.httpStream();
+    StreamAllocation streamAllocation = realChain.streamAllocation();
+    RealConnection connection = (RealConnection) realChain.connection();
+    Request request = realChain.request();
+
+    long sentRequestMillis = System.currentTimeMillis();
+
+    realChain.eventListener().requestHeadersStart(realChain.call());
+    httpCodec.writeRequestHeaders(request);
+    realChain.eventListener().requestHeadersEnd(realChain.call(), request);
+
+    Response.Builder responseBuilder = null;
+    if (HttpMethod.permitsRequestBody(request.method()) && request.body() != null) {
+      // If there's a "Expect: 100-continue" header on the request, wait for a "HTTP/1.1 100
+      // Continue" response before transmitting the request body. If we don't get that, return
+      // what we did get (such as a 4xx response) without ever transmitting the request body.
+      if ("100-continue".equalsIgnoreCase(request.header("Expect"))) {
+        httpCodec.flushRequest();
+        realChain.eventListener().responseHeadersStart(realChain.call());
+        responseBuilder = httpCodec.readResponseHeaders(true);
+      }
+
+      if (responseBuilder == null) {
+        // Write the request body if the "Expect: 100-continue" expectation was met.
+        realChain.eventListener().requestBodyStart(realChain.call());
+        long contentLength = request.body().contentLength();
+        CountingSink requestBodyOut =
+            new CountingSink(httpCodec.createRequestBody(request, contentLength));
+        BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);
+
+        request.body().writeTo(bufferedRequestBody);
+        bufferedRequestBody.close();
+        realChain.eventListener()
+            .requestBodyEnd(realChain.call(), requestBodyOut.successfulCount);
+      } else if (!connection.isMultiplexed()) {
+        // If the "Expect: 100-continue" expectation wasn't met, prevent the HTTP/1 connection
+        // from being reused. Otherwise we're still obligated to transmit the request body to
+        // leave the connection in a consistent state.
+        streamAllocation.noNewStreams();
+      }
+    }
+
+    httpCodec.finishRequest();
+
+    if (responseBuilder == null) {
+      realChain.eventListener().responseHeadersStart(realChain.call());
+      responseBuilder = httpCodec.readResponseHeaders(false);
+    }
+
+    Response response = responseBuilder
+        .request(request)
+        .handshake(streamAllocation.connection().handshake())
+        .sentRequestAtMillis(sentRequestMillis)
+        .receivedResponseAtMillis(System.currentTimeMillis())
+        .build();
+
+    realChain.eventListener()
+        .responseHeadersEnd(realChain.call(), response);
+
+    int code = response.code();
+    if (forWebSocket && code == 101) {
+      // Connection is upgrading, but we need to ensure interceptors see a non-null response body.
+      response = response.newBuilder()
+          .body(Util.EMPTY_RESPONSE)
+          .build();
+    } else {
+      response = response.newBuilder()
+          .body(httpCodec.openResponseBody(response))
+          .build();
+    }
+
+    if ("close".equalsIgnoreCase(response.request().header("Connection"))
+        || "close".equalsIgnoreCase(response.header("Connection"))) {
+      streamAllocation.noNewStreams();
+    }
+
+    if ((code == 204 || code == 205) && response.body().contentLength() > 0) {
+      throw new ProtocolException(
+          "HTTP " + code + " had non-zero Content-Length: " + response.body().contentLength());
+    }
+
+    return response;
+  }
+
+  static final class CountingSink extends ForwardingSink {
+    long successfulCount;
+
+    CountingSink(Sink delegate) {
+      super(delegate);
+    }
+
+    @Override public void write(Buffer source, long byteCount) throws IOException {
+      super.write(source, byteCount);
+      successfulCount += byteCount;
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/HeaderParser.java b/okhttp/src/main/java/okhttp3/internal/http/HeaderParser.java
deleted file mode 100644
index 1e27c988c4..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/http/HeaderParser.java
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http;
-
-public final class HeaderParser {
-  /**
-   * Returns the next index in {@code input} at or after {@code pos} that contains a character from
-   * {@code characters}. Returns the input length if none of the requested characters can be found.
-   */
-  public static int skipUntil(String input, int pos, String characters) {
-    for (; pos < input.length(); pos++) {
-      if (characters.indexOf(input.charAt(pos)) != -1) {
-        break;
-      }
-    }
-    return pos;
-  }
-
-  /**
-   * Returns the next non-whitespace character in {@code input} that is white space. Result is
-   * undefined if input contains newline characters.
-   */
-  public static int skipWhitespace(String input, int pos) {
-    for (; pos < input.length(); pos++) {
-      char c = input.charAt(pos);
-      if (c != ' ' && c != '\t') {
-        break;
-      }
-    }
-    return pos;
-  }
-
-  /**
-   * Returns {@code value} as a positive integer, or 0 if it is negative, or {@code defaultValue} if
-   * it cannot be parsed.
-   */
-  public static int parseSeconds(String value, int defaultValue) {
-    try {
-      long seconds = Long.parseLong(value);
-      if (seconds > Integer.MAX_VALUE) {
-        return Integer.MAX_VALUE;
-      } else if (seconds < 0) {
-        return 0;
-      } else {
-        return (int) seconds;
-      }
-    } catch (NumberFormatException e) {
-      return defaultValue;
-    }
-  }
-
-  private HeaderParser() {
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/Http2xStream.java b/okhttp/src/main/java/okhttp3/internal/http/Http2xStream.java
deleted file mode 100644
index 5c8fdfe667..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/http/Http2xStream.java
+++ /dev/null
@@ -1,296 +0,0 @@
-/*
- * Copyright (C) 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http;
-
-import java.io.IOException;
-import java.net.ProtocolException;
-import java.util.ArrayList;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Locale;
-import java.util.Set;
-import java.util.concurrent.TimeUnit;
-import okhttp3.Headers;
-import okhttp3.Protocol;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.ResponseBody;
-import okhttp3.internal.Internal;
-import okhttp3.internal.Util;
-import okhttp3.internal.framed.ErrorCode;
-import okhttp3.internal.framed.FramedConnection;
-import okhttp3.internal.framed.FramedStream;
-import okhttp3.internal.framed.Header;
-import okio.ByteString;
-import okio.ForwardingSource;
-import okio.Okio;
-import okio.Sink;
-import okio.Source;
-
-import static okhttp3.internal.framed.Header.RESPONSE_STATUS;
-import static okhttp3.internal.framed.Header.TARGET_AUTHORITY;
-import static okhttp3.internal.framed.Header.TARGET_HOST;
-import static okhttp3.internal.framed.Header.TARGET_METHOD;
-import static okhttp3.internal.framed.Header.TARGET_PATH;
-import static okhttp3.internal.framed.Header.TARGET_SCHEME;
-import static okhttp3.internal.framed.Header.VERSION;
-
-/** An HTTP stream for HTTP/2 and SPDY. */
-public final class Http2xStream implements HttpStream {
-  private static final ByteString CONNECTION = ByteString.encodeUtf8("connection");
-  private static final ByteString HOST = ByteString.encodeUtf8("host");
-  private static final ByteString KEEP_ALIVE = ByteString.encodeUtf8("keep-alive");
-  private static final ByteString PROXY_CONNECTION = ByteString.encodeUtf8("proxy-connection");
-  private static final ByteString TRANSFER_ENCODING = ByteString.encodeUtf8("transfer-encoding");
-  private static final ByteString TE = ByteString.encodeUtf8("te");
-  private static final ByteString ENCODING = ByteString.encodeUtf8("encoding");
-  private static final ByteString UPGRADE = ByteString.encodeUtf8("upgrade");
-
-  /** See http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1#TOC-3.2.1-Request. */
-  private static final List<ByteString> SPDY_3_SKIPPED_REQUEST_HEADERS = Util.immutableList(
-      CONNECTION,
-      HOST,
-      KEEP_ALIVE,
-      PROXY_CONNECTION,
-      TRANSFER_ENCODING,
-      TARGET_METHOD,
-      TARGET_PATH,
-      TARGET_SCHEME,
-      TARGET_AUTHORITY,
-      TARGET_HOST,
-      VERSION);
-  private static final List<ByteString> SPDY_3_SKIPPED_RESPONSE_HEADERS = Util.immutableList(
-      CONNECTION,
-      HOST,
-      KEEP_ALIVE,
-      PROXY_CONNECTION,
-      TRANSFER_ENCODING);
-
-  /** See http://tools.ietf.org/html/draft-ietf-httpbis-http2-09#section-8.1.3. */
-  private static final List<ByteString> HTTP_2_SKIPPED_REQUEST_HEADERS = Util.immutableList(
-      CONNECTION,
-      HOST,
-      KEEP_ALIVE,
-      PROXY_CONNECTION,
-      TE,
-      TRANSFER_ENCODING,
-      ENCODING,
-      UPGRADE,
-      TARGET_METHOD,
-      TARGET_PATH,
-      TARGET_SCHEME,
-      TARGET_AUTHORITY,
-      TARGET_HOST,
-      VERSION);
-  private static final List<ByteString> HTTP_2_SKIPPED_RESPONSE_HEADERS = Util.immutableList(
-      CONNECTION,
-      HOST,
-      KEEP_ALIVE,
-      PROXY_CONNECTION,
-      TE,
-      TRANSFER_ENCODING,
-      ENCODING,
-      UPGRADE);
-
-  private final StreamAllocation streamAllocation;
-  private final FramedConnection framedConnection;
-  private HttpEngine httpEngine;
-  private FramedStream stream;
-
-  public Http2xStream(StreamAllocation streamAllocation, FramedConnection framedConnection) {
-    this.streamAllocation = streamAllocation;
-    this.framedConnection = framedConnection;
-  }
-
-  @Override public void setHttpEngine(HttpEngine httpEngine) {
-    this.httpEngine = httpEngine;
-  }
-
-  @Override public Sink createRequestBody(Request request, long contentLength) throws IOException {
-    return stream.getSink();
-  }
-
-  @Override public void writeRequestHeaders(Request request) throws IOException {
-    if (stream != null) return;
-
-    httpEngine.writingRequestHeaders();
-    boolean permitsRequestBody = httpEngine.permitsRequestBody(request);
-    List<Header> requestHeaders = framedConnection.getProtocol() == Protocol.HTTP_2
-        ? http2HeadersList(request)
-        : spdy3HeadersList(request);
-    boolean hasResponseBody = true;
-    stream = framedConnection.newStream(requestHeaders, permitsRequestBody, hasResponseBody);
-    stream.readTimeout().timeout(httpEngine.client.readTimeoutMillis(), TimeUnit.MILLISECONDS);
-    stream.writeTimeout().timeout(httpEngine.client.writeTimeoutMillis(), TimeUnit.MILLISECONDS);
-  }
-
-  @Override public void writeRequestBody(RetryableSink requestBody) throws IOException {
-    requestBody.writeToSocket(stream.getSink());
-  }
-
-  @Override public void finishRequest() throws IOException {
-    stream.getSink().close();
-  }
-
-  @Override public Response.Builder readResponseHeaders() throws IOException {
-    return framedConnection.getProtocol() == Protocol.HTTP_2
-        ? readHttp2HeadersList(stream.getResponseHeaders())
-        : readSpdy3HeadersList(stream.getResponseHeaders());
-  }
-
-  /**
-   * Returns a list of alternating names and values containing a SPDY request. Names are all
-   * lowercase. No names are repeated. If any name has multiple values, they are concatenated using
-   * "\0" as a delimiter.
-   */
-  public static List<Header> spdy3HeadersList(Request request) {
-    Headers headers = request.headers();
-    List<Header> result = new ArrayList<>(headers.size() + 5);
-    result.add(new Header(TARGET_METHOD, request.method()));
-    result.add(new Header(TARGET_PATH, RequestLine.requestPath(request.url())));
-    result.add(new Header(VERSION, "HTTP/1.1"));
-    result.add(new Header(TARGET_HOST, Util.hostHeader(request.url(), false)));
-    result.add(new Header(TARGET_SCHEME, request.url().scheme()));
-
-    Set<ByteString> names = new LinkedHashSet<>();
-    for (int i = 0, size = headers.size(); i < size; i++) {
-      // header names must be lowercase.
-      ByteString name = ByteString.encodeUtf8(headers.name(i).toLowerCase(Locale.US));
-
-      // Drop headers that are forbidden when layering HTTP over SPDY.
-      if (SPDY_3_SKIPPED_REQUEST_HEADERS.contains(name)) continue;
-
-      // If we haven't seen this name before, add the pair to the end of the list...
-      String value = headers.value(i);
-      if (names.add(name)) {
-        result.add(new Header(name, value));
-        continue;
-      }
-
-      // ...otherwise concatenate the existing values and this value.
-      for (int j = 0; j < result.size(); j++) {
-        if (result.get(j).name.equals(name)) {
-          String concatenated = joinOnNull(result.get(j).value.utf8(), value);
-          result.set(j, new Header(name, concatenated));
-          break;
-        }
-      }
-    }
-    return result;
-  }
-
-  private static String joinOnNull(String first, String second) {
-    return new StringBuilder(first).append('\0').append(second).toString();
-  }
-
-  public static List<Header> http2HeadersList(Request request) {
-    Headers headers = request.headers();
-    List<Header> result = new ArrayList<>(headers.size() + 4);
-    result.add(new Header(TARGET_METHOD, request.method()));
-    result.add(new Header(TARGET_PATH, RequestLine.requestPath(request.url())));
-    result.add(new Header(TARGET_AUTHORITY, Util.hostHeader(request.url(), false))); // Optional.
-    result.add(new Header(TARGET_SCHEME, request.url().scheme()));
-
-    for (int i = 0, size = headers.size(); i < size; i++) {
-      // header names must be lowercase.
-      ByteString name = ByteString.encodeUtf8(headers.name(i).toLowerCase(Locale.US));
-      if (!HTTP_2_SKIPPED_REQUEST_HEADERS.contains(name)) {
-        result.add(new Header(name, headers.value(i)));
-      }
-    }
-    return result;
-  }
-
-  /** Returns headers for a name value block containing a SPDY response. */
-  public static Response.Builder readSpdy3HeadersList(List<Header> headerBlock) throws IOException {
-    String status = null;
-    String version = "HTTP/1.1";
-    Headers.Builder headersBuilder = new Headers.Builder();
-    for (int i = 0, size = headerBlock.size(); i < size; i++) {
-      ByteString name = headerBlock.get(i).name;
-
-      String values = headerBlock.get(i).value.utf8();
-      for (int start = 0; start < values.length(); ) {
-        int end = values.indexOf('\0', start);
-        if (end == -1) {
-          end = values.length();
-        }
-        String value = values.substring(start, end);
-        if (name.equals(RESPONSE_STATUS)) {
-          status = value;
-        } else if (name.equals(VERSION)) {
-          version = value;
-        } else if (!SPDY_3_SKIPPED_RESPONSE_HEADERS.contains(name)) {
-          Internal.instance.addLenient(headersBuilder, name.utf8(), value);
-        }
-        start = end + 1;
-      }
-    }
-    if (status == null) throw new ProtocolException("Expected ':status' header not present");
-
-    StatusLine statusLine = StatusLine.parse(version + " " + status);
-    return new Response.Builder()
-        .protocol(Protocol.SPDY_3)
-        .code(statusLine.code)
-        .message(statusLine.message)
-        .headers(headersBuilder.build());
-  }
-
-  /** Returns headers for a name value block containing an HTTP/2 response. */
-  public static Response.Builder readHttp2HeadersList(List<Header> headerBlock) throws IOException {
-    String status = null;
-
-    Headers.Builder headersBuilder = new Headers.Builder();
-    for (int i = 0, size = headerBlock.size(); i < size; i++) {
-      ByteString name = headerBlock.get(i).name;
-
-      String value = headerBlock.get(i).value.utf8();
-      if (name.equals(RESPONSE_STATUS)) {
-        status = value;
-      } else if (!HTTP_2_SKIPPED_RESPONSE_HEADERS.contains(name)) {
-        Internal.instance.addLenient(headersBuilder, name.utf8(), value);
-      }
-    }
-    if (status == null) throw new ProtocolException("Expected ':status' header not present");
-
-    StatusLine statusLine = StatusLine.parse("HTTP/1.1 " + status);
-    return new Response.Builder()
-        .protocol(Protocol.HTTP_2)
-        .code(statusLine.code)
-        .message(statusLine.message)
-        .headers(headersBuilder.build());
-  }
-
-  @Override public ResponseBody openResponseBody(Response response) throws IOException {
-    Source source = new StreamFinishingSource(stream.getSource());
-    return new RealResponseBody(response.headers(), Okio.buffer(source));
-  }
-
-  @Override public void cancel() {
-    if (stream != null) stream.closeLater(ErrorCode.CANCEL);
-  }
-
-  class StreamFinishingSource extends ForwardingSource {
-    public StreamFinishingSource(Source delegate) {
-      super(delegate);
-    }
-
-    @Override public void close() throws IOException {
-      streamAllocation.streamFinished(false, Http2xStream.this);
-      super.close();
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/HttpStream.java b/okhttp/src/main/java/okhttp3/internal/http/HttpCodec.java
similarity index 73%
rename from okhttp/src/main/java/okhttp3/internal/http/HttpStream.java
rename to okhttp/src/main/java/okhttp3/internal/http/HttpCodec.java
index 34c471345c..ad9759acce 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/HttpStream.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/HttpCodec.java
@@ -21,7 +21,8 @@
 import okhttp3.ResponseBody;
 import okio.Sink;
 
-public interface HttpStream {
+/** Encodes HTTP requests and decodes HTTP responses. */
+public interface HttpCodec {
   /**
    * The timeout to use while discarding a stream of input data. Since this is used for connection
    * reuse, this timeout should be significantly less than the time it takes to establish a new
@@ -30,27 +31,28 @@
   int DISCARD_STREAM_TIMEOUT_MILLIS = 100;
 
   /** Returns an output stream where the request body can be streamed. */
-  Sink createRequestBody(Request request, long contentLength) throws IOException;
+  Sink createRequestBody(Request request, long contentLength);
 
   /** This should update the HTTP engine's sentRequestMillis field. */
   void writeRequestHeaders(Request request) throws IOException;
 
-  /**
-   * Sends the request body returned by {@link #createRequestBody} to the remote peer.
-   */
-  void writeRequestBody(RetryableSink requestBody) throws IOException;
-
   /** Flush the request to the underlying socket. */
+  void flushRequest() throws IOException;
+
+  /** Flush the request to the underlying socket and signal no more bytes will be transmitted. */
   void finishRequest() throws IOException;
 
-  /** Read and return response headers. */
-  Response.Builder readResponseHeaders() throws IOException;
+  /**
+   * Parses bytes of a response header from an HTTP transport.
+   *
+   * @param expectContinue true to return null if this is an intermediate response with a "100"
+   *     response code. Otherwise this method never returns null.
+   */
+  Response.Builder readResponseHeaders(boolean expectContinue) throws IOException;
 
   /** Returns a stream that reads the response body. */
   ResponseBody openResponseBody(Response response) throws IOException;
 
-  void setHttpEngine(HttpEngine httpEngine);
-
   /**
    * Cancel this stream. Resources held by this stream will be cleaned up, though not synchronously.
    * That may happen later by the connection pool thread.
diff --git a/okhttp/src/main/java/okhttp3/internal/http/HttpDate.java b/okhttp/src/main/java/okhttp3/internal/http/HttpDate.java
index 2991dd7b51..6df2cfd2ec 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/HttpDate.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/HttpDate.java
@@ -37,7 +37,7 @@
   private static final ThreadLocal<DateFormat> STANDARD_DATE_FORMAT =
       new ThreadLocal<DateFormat>() {
         @Override protected DateFormat initialValue() {
-          // RFC 2616 specified: RFC 822, updated by RFC 1123 format with fixed GMT.
+          // Date format specified by RFC 7231 section 7.1.1.1.
           DateFormat rfc1123 = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss 'GMT'", Locale.US);
           rfc1123.setLenient(false);
           rfc1123.setTimeZone(UTC);
@@ -90,7 +90,7 @@ public static Date parse(String value) {
         if (format == null) {
           format = new SimpleDateFormat(BROWSER_COMPATIBLE_DATE_FORMAT_STRINGS[i], Locale.US);
           // Set the timezone to use when interpreting formats that don't have a timezone. GMT is
-          // specified by RFC 2616.
+          // specified by RFC 7231.
           format.setTimeZone(UTC);
           BROWSER_COMPATIBLE_DATE_FORMATS[i] = format;
         }
diff --git a/okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java b/okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java
deleted file mode 100644
index fb56a291ff..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java
+++ /dev/null
@@ -1,1038 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package okhttp3.internal.http;
-
-import java.io.IOException;
-import java.io.InterruptedIOException;
-import java.net.ProtocolException;
-import java.net.Proxy;
-import java.net.SocketTimeoutException;
-import java.security.cert.CertificateException;
-import java.util.Date;
-import java.util.List;
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.SSLHandshakeException;
-import javax.net.ssl.SSLPeerUnverifiedException;
-import javax.net.ssl.SSLSocketFactory;
-import okhttp3.Address;
-import okhttp3.CertificatePinner;
-import okhttp3.Connection;
-import okhttp3.Cookie;
-import okhttp3.CookieJar;
-import okhttp3.Headers;
-import okhttp3.HttpUrl;
-import okhttp3.Interceptor;
-import okhttp3.MediaType;
-import okhttp3.OkHttpClient;
-import okhttp3.Protocol;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.ResponseBody;
-import okhttp3.Route;
-import okhttp3.internal.Internal;
-import okhttp3.internal.InternalCache;
-import okhttp3.internal.Version;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.GzipSource;
-import okio.Okio;
-import okio.Sink;
-import okio.Source;
-import okio.Timeout;
-
-import static java.net.HttpURLConnection.HTTP_CLIENT_TIMEOUT;
-import static java.net.HttpURLConnection.HTTP_MOVED_PERM;
-import static java.net.HttpURLConnection.HTTP_MOVED_TEMP;
-import static java.net.HttpURLConnection.HTTP_MULT_CHOICE;
-import static java.net.HttpURLConnection.HTTP_NOT_MODIFIED;
-import static java.net.HttpURLConnection.HTTP_NO_CONTENT;
-import static java.net.HttpURLConnection.HTTP_PROXY_AUTH;
-import static java.net.HttpURLConnection.HTTP_SEE_OTHER;
-import static java.net.HttpURLConnection.HTTP_UNAUTHORIZED;
-import static java.util.concurrent.TimeUnit.MILLISECONDS;
-import static okhttp3.internal.Util.closeQuietly;
-import static okhttp3.internal.Util.discard;
-import static okhttp3.internal.Util.hostHeader;
-import static okhttp3.internal.http.StatusLine.HTTP_CONTINUE;
-import static okhttp3.internal.http.StatusLine.HTTP_PERM_REDIRECT;
-import static okhttp3.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
-
-/**
- * Handles a single HTTP request/response pair. Each HTTP engine follows this lifecycle: <ol> <li>It
- * is created. <li>The HTTP request message is sent with sendRequest(). Once the request is sent it
- * is an error to modify the request headers. After sendRequest() has been called the request body
- * can be written to if it exists. <li>The HTTP response message is read with readResponse(). After
- * the response has been read the response headers and body can be read. All responses have a
- * response body input stream, though in some instances this stream is empty. </ol>
- *
- * <p>The request and response may be served by the HTTP response cache, by the network, or by both
- * in the event of a conditional GET.
- */
-public final class HttpEngine {
-  /**
-   * How many redirects and auth challenges should we attempt? Chrome follows 21 redirects; Firefox,
-   * curl, and wget follow 20; Safari follows 16; and HTTP/1.0 recommends 5.
-   */
-  public static final int MAX_FOLLOW_UPS = 20;
-
-  private static final ResponseBody EMPTY_BODY = new ResponseBody() {
-    @Override public MediaType contentType() {
-      return null;
-    }
-
-    @Override public long contentLength() {
-      return 0;
-    }
-
-    @Override public BufferedSource source() {
-      return new Buffer();
-    }
-  };
-
-  final OkHttpClient client;
-
-  public final StreamAllocation streamAllocation;
-  private final Response priorResponse;
-  private HttpStream httpStream;
-
-  /** The time when the request headers were written, or -1 if they haven't been written yet. */
-  long sentRequestMillis = -1;
-
-  /**
-   * True if this client added an "Accept-Encoding: gzip" header field and is therefore responsible
-   * for also decompressing the transfer stream.
-   */
-  private boolean transparentGzip;
-
-  /**
-   * True if the request body must be completely buffered before transmission; false if it can be
-   * streamed. Buffering has two advantages: we don't need the content-length in advance and we can
-   * retransmit if necessary. The upside of streaming is that we can save memory.
-   */
-  public final boolean bufferRequestBody;
-
-  /**
-   * The original application-provided request. Never modified by OkHttp. When follow-up requests
-   * are necessary, they are derived from this request.
-   */
-  private final Request userRequest;
-
-  /**
-   * The request to send on the network, or null for no network request. This is derived from the
-   * user request, and customized to support OkHttp features like compression and caching.
-   */
-  private Request networkRequest;
-
-  /**
-   * The cached response, or null if the cache doesn't exist or cannot be used for this request.
-   * Conditional caching means this may be non-null even when the network request is non-null. Never
-   * modified by OkHttp.
-   */
-  private Response cacheResponse;
-
-  /**
-   * The user-visible response. This is derived from either the network response, cache response, or
-   * both. It is customized to support OkHttp features like compression and caching.
-   */
-  private Response userResponse;
-
-  private Sink requestBodyOut;
-  private BufferedSink bufferedRequestBody;
-  private final boolean callerWritesRequestBody;
-  private final boolean forWebSocket;
-
-  /** The cache request currently being populated from a network response. */
-  private CacheRequest storeRequest;
-  private CacheStrategy cacheStrategy;
-
-  /**
-   * @param request the HTTP request without a body. The body must be written via the engine's
-   * request body stream.
-   * @param callerWritesRequestBody true for the {@code HttpURLConnection}-style interaction model
-   * where control flow is returned to the calling application to write the request body before the
-   * response body is readable.
-   */
-  public HttpEngine(OkHttpClient client, Request request, boolean bufferRequestBody,
-      boolean callerWritesRequestBody, boolean forWebSocket, StreamAllocation streamAllocation,
-      RetryableSink requestBodyOut, Response priorResponse) {
-    this.client = client;
-    this.userRequest = request;
-    this.bufferRequestBody = bufferRequestBody;
-    this.callerWritesRequestBody = callerWritesRequestBody;
-    this.forWebSocket = forWebSocket;
-    this.streamAllocation = streamAllocation != null
-        ? streamAllocation
-        : new StreamAllocation(client.connectionPool(), createAddress(client, request));
-    this.requestBodyOut = requestBodyOut;
-    this.priorResponse = priorResponse;
-  }
-
-  /**
-   * Figures out what the response source will be, and opens a socket to that source if necessary.
-   * Prepares the request headers and gets ready to start writing the request body if it exists.
-   *
-   * @throws RequestException if there was a problem with request setup. Unrecoverable.
-   * @throws RouteException if the was a problem during connection via a specific route. Sometimes
-   * recoverable. See {@link #recover}.
-   * @throws IOException if there was a problem while making a request. Sometimes recoverable. See
-   * {@link #recover(IOException, boolean)}.
-   */
-  public void sendRequest() throws RequestException, RouteException, IOException {
-    if (cacheStrategy != null) return; // Already sent.
-    if (httpStream != null) throw new IllegalStateException();
-
-    Request request = networkRequest(userRequest);
-
-    InternalCache responseCache = Internal.instance.internalCache(client);
-    Response cacheCandidate = responseCache != null
-        ? responseCache.get(request)
-        : null;
-
-    long now = System.currentTimeMillis();
-    cacheStrategy = new CacheStrategy.Factory(now, request, cacheCandidate).get();
-    networkRequest = cacheStrategy.networkRequest;
-    cacheResponse = cacheStrategy.cacheResponse;
-
-    if (responseCache != null) {
-      responseCache.trackResponse(cacheStrategy);
-    }
-
-    if (cacheCandidate != null && cacheResponse == null) {
-      closeQuietly(cacheCandidate.body()); // The cache candidate wasn't applicable. Close it.
-    }
-
-    // If we're forbidden from using the network and the cache is insufficient, fail.
-    if (networkRequest == null && cacheResponse == null) {
-      userResponse = new Response.Builder()
-          .request(userRequest)
-          .priorResponse(stripBody(priorResponse))
-          .protocol(Protocol.HTTP_1_1)
-          .code(504)
-          .message("Unsatisfiable Request (only-if-cached)")
-          .body(EMPTY_BODY)
-          .sentRequestAtMillis(sentRequestMillis)
-          .receivedResponseAtMillis(System.currentTimeMillis())
-          .build();
-      return;
-    }
-
-    // If we don't need the network, we're done.
-    if (networkRequest == null) {
-      userResponse = cacheResponse.newBuilder()
-          .request(userRequest)
-          .priorResponse(stripBody(priorResponse))
-          .cacheResponse(stripBody(cacheResponse))
-          .build();
-      userResponse = unzip(userResponse);
-      return;
-    }
-
-    // We need the network to satisfy this request. Possibly for validating a conditional GET.
-    boolean success = false;
-    try {
-      httpStream = connect();
-      httpStream.setHttpEngine(this);
-
-      if (writeRequestHeadersEagerly()) {
-        long contentLength = OkHeaders.contentLength(request);
-        if (bufferRequestBody) {
-          if (contentLength > Integer.MAX_VALUE) {
-            throw new IllegalStateException("Use setFixedLengthStreamingMode() or "
-                + "setChunkedStreamingMode() for requests larger than 2 GiB.");
-          }
-
-          if (contentLength != -1) {
-            // Buffer a request body of a known length.
-            httpStream.writeRequestHeaders(networkRequest);
-            requestBodyOut = new RetryableSink((int) contentLength);
-          } else {
-            // Buffer a request body of an unknown length. Don't write request headers until the
-            // entire body is ready; otherwise we can't set the Content-Length header correctly.
-            requestBodyOut = new RetryableSink();
-          }
-        } else {
-          httpStream.writeRequestHeaders(networkRequest);
-          requestBodyOut = httpStream.createRequestBody(networkRequest, contentLength);
-        }
-      }
-      success = true;
-    } finally {
-      // If we're crashing on I/O or otherwise, don't leak the cache body.
-      if (!success && cacheCandidate != null) {
-        closeQuietly(cacheCandidate.body());
-      }
-    }
-  }
-
-  /**
-   * If the caller's control flow writes the request body, we need to create that stream
-   * immediately. And that means we need to immediately write the request headers, so we can
-   * start streaming the request body. (We may already have a request body if we're retrying a
-   * failed POST.)
-   */
-  private boolean writeRequestHeadersEagerly() {
-    return callerWritesRequestBody
-        && permitsRequestBody(networkRequest)
-        && requestBodyOut == null;
-  }
-
-  private HttpStream connect() throws RouteException, RequestException, IOException {
-    boolean doExtensiveHealthChecks = !networkRequest.method().equals("GET");
-    return streamAllocation.newStream(client.connectTimeoutMillis(),
-        client.readTimeoutMillis(), client.writeTimeoutMillis(),
-        client.retryOnConnectionFailure(), doExtensiveHealthChecks);
-  }
-
-  private static Response stripBody(Response response) {
-    return response != null && response.body() != null
-        ? response.newBuilder().body(null).build()
-        : response;
-  }
-
-  /**
-   * Called immediately before the transport transmits HTTP request headers. This is used to observe
-   * the sent time should the request be cached.
-   */
-  public void writingRequestHeaders() {
-    if (sentRequestMillis != -1) throw new IllegalStateException();
-    sentRequestMillis = System.currentTimeMillis();
-  }
-
-  boolean permitsRequestBody(Request request) {
-    return HttpMethod.permitsRequestBody(request.method());
-  }
-
-  /** Returns the request body or null if this request doesn't have a body. */
-  public Sink getRequestBody() {
-    if (cacheStrategy == null) throw new IllegalStateException();
-    return requestBodyOut;
-  }
-
-  public BufferedSink getBufferedRequestBody() {
-    BufferedSink result = bufferedRequestBody;
-    if (result != null) return result;
-    Sink requestBody = getRequestBody();
-    return requestBody != null
-        ? (bufferedRequestBody = Okio.buffer(requestBody))
-        : null;
-  }
-
-  public boolean hasResponse() {
-    return userResponse != null;
-  }
-
-  public Request getRequest() {
-    return userRequest;
-  }
-
-  /** Returns the engine's response. */
-  // TODO: the returned body will always be null.
-  public Response getResponse() {
-    if (userResponse == null) throw new IllegalStateException();
-    return userResponse;
-  }
-
-  public Connection getConnection() {
-    return streamAllocation.connection();
-  }
-
-  /**
-   * Report and attempt to recover from a failure to communicate with a server. Returns a new HTTP
-   * engine that should be used for the retry if {@code e} is recoverable, or null if the failure is
-   * permanent. Requests with a body can only be recovered if the body is buffered.
-   */
-  public HttpEngine recover(IOException e, boolean routeException, Sink requestBodyOut) {
-    streamAllocation.streamFailed(e);
-
-    if (!client.retryOnConnectionFailure()) {
-      return null; // The application layer has forbidden retries.
-    }
-
-    if (requestBodyOut != null && !(requestBodyOut instanceof RetryableSink)) {
-      return null; // The body on this request cannot be retried.
-    }
-
-    if (!isRecoverable(e, routeException)) {
-      return null; // This exception is fatal.
-    }
-
-    if (!streamAllocation.hasMoreRoutes()) {
-      return null; // No more routes to attempt.
-    }
-
-    StreamAllocation streamAllocation = close();
-
-    // For failure recovery, use the same route selector with a new connection.
-    return new HttpEngine(client, userRequest, bufferRequestBody, callerWritesRequestBody,
-        forWebSocket, streamAllocation, (RetryableSink) requestBodyOut, priorResponse);
-  }
-
-  public HttpEngine recover(IOException e, boolean routeException) {
-    return recover(e, routeException, requestBodyOut);
-  }
-
-  private boolean isRecoverable(IOException e, boolean routeException) {
-    // If there was a protocol problem, don't recover.
-    if (e instanceof ProtocolException) {
-      return false;
-    }
-
-    // If there was an interruption don't recover, but if there was a timeout connecting to a route
-    // we should try the next route (if there is one).
-    if (e instanceof InterruptedIOException) {
-      return e instanceof SocketTimeoutException && routeException;
-    }
-
-    // Look for known client-side or negotiation errors that are unlikely to be fixed by trying
-    // again with a different route.
-    if (e instanceof SSLHandshakeException) {
-      // If the problem was a CertificateException from the X509TrustManager,
-      // do not retry.
-      if (e.getCause() instanceof CertificateException) {
-        return false;
-      }
-    }
-    if (e instanceof SSLPeerUnverifiedException) {
-      // e.g. a certificate pinning error.
-      return false;
-    }
-
-    // An example of one we might want to retry with a different route is a problem connecting to a
-    // proxy and would manifest as a standard IOException. Unless it is one we know we should not
-    // retry, we return true and try a new route.
-    return true;
-  }
-
-  private void maybeCache() throws IOException {
-    InternalCache responseCache = Internal.instance.internalCache(client);
-    if (responseCache == null) return;
-
-    // Should we cache this response for this request?
-    if (!CacheStrategy.isCacheable(userResponse, networkRequest)) {
-      if (HttpMethod.invalidatesCache(networkRequest.method())) {
-        try {
-          responseCache.remove(networkRequest);
-        } catch (IOException ignored) {
-          // The cache cannot be written.
-        }
-      }
-      return;
-    }
-
-    // Offer this request to the cache.
-    storeRequest = responseCache.put(userResponse);
-  }
-
-  /**
-   * Configure the socket connection to be either pooled or closed when it is either exhausted or
-   * closed. If it is unneeded when this is called, it will be released immediately.
-   */
-  public void releaseStreamAllocation() throws IOException {
-    streamAllocation.release();
-  }
-
-  /**
-   * Immediately closes the socket connection if it's currently held by this engine. Use this to
-   * interrupt an in-flight request from any thread. It's the caller's responsibility to close the
-   * request body and response body streams; otherwise resources may be leaked.
-   *
-   * <p>This method is safe to be called concurrently, but provides limited guarantees. If a
-   * transport layer connection has been established (such as a HTTP/2 stream) that is terminated.
-   * Otherwise if a socket connection is being established, that is terminated.
-   */
-  public void cancel() {
-    streamAllocation.cancel();
-  }
-
-  /**
-   * Release any resources held by this engine. Returns the stream allocation held by this engine,
-   * which itself must be used or released.
-   */
-  public StreamAllocation close() {
-    if (bufferedRequestBody != null) {
-      // This also closes the wrapped requestBodyOut.
-      closeQuietly(bufferedRequestBody);
-    } else if (requestBodyOut != null) {
-      closeQuietly(requestBodyOut);
-    }
-
-    if (userResponse != null) {
-      closeQuietly(userResponse.body());
-    } else {
-      // If this engine never achieved a response body, its stream allocation is dead.
-      streamAllocation.streamFailed(null);
-    }
-
-    return streamAllocation;
-  }
-
-  /**
-   * Returns a new response that does gzip decompression on {@code response}, if transparent gzip
-   * was both offered by OkHttp and used by the origin server.
-   *
-   * <p>In addition to decompression, this will also strip the corresponding headers. We strip the
-   * Content-Encoding header to prevent the application from attempting to double decompress. We
-   * strip the Content-Length header because it is the length of the compressed content, but the
-   * application is only interested in the length of the uncompressed content.
-   *
-   * <p>This method should only be used for non-empty response bodies. Response codes like "304 Not
-   * Modified" can include "Content-Encoding: gzip" without a response body and we will crash if we
-   * attempt to decompress the zero-byte source.
-   */
-  private Response unzip(final Response response) throws IOException {
-    if (!transparentGzip || !"gzip".equalsIgnoreCase(userResponse.header("Content-Encoding"))) {
-      return response;
-    }
-
-    if (response.body() == null) {
-      return response;
-    }
-
-    GzipSource responseBody = new GzipSource(response.body().source());
-    Headers strippedHeaders = response.headers().newBuilder()
-        .removeAll("Content-Encoding")
-        .removeAll("Content-Length")
-        .build();
-    return response.newBuilder()
-        .headers(strippedHeaders)
-        .body(new RealResponseBody(strippedHeaders, Okio.buffer(responseBody)))
-        .build();
-  }
-
-  /**
-   * Returns true if the response must have a (possibly 0-length) body. See RFC 2616 section 4.3.
-   */
-  public static boolean hasBody(Response response) {
-    // HEAD requests never yield a body regardless of the response headers.
-    if (response.request().method().equals("HEAD")) {
-      return false;
-    }
-
-    int responseCode = response.code();
-    if ((responseCode < HTTP_CONTINUE || responseCode >= 200)
-        && responseCode != HTTP_NO_CONTENT
-        && responseCode != HTTP_NOT_MODIFIED) {
-      return true;
-    }
-
-    // If the Content-Length or Transfer-Encoding headers disagree with the
-    // response code, the response is malformed. For best compatibility, we
-    // honor the headers.
-    if (OkHeaders.contentLength(response) != -1
-        || "chunked".equalsIgnoreCase(response.header("Transfer-Encoding"))) {
-      return true;
-    }
-
-    return false;
-  }
-
-  /**
-   * Populates request with defaults and cookies.
-   *
-   * <p>This client doesn't specify a default {@code Accept} header because it doesn't know what
-   * content types the application is interested in.
-   */
-  private Request networkRequest(Request request) throws IOException {
-    Request.Builder result = request.newBuilder();
-
-    if (request.header("Host") == null) {
-      result.header("Host", hostHeader(request.url(), false));
-    }
-
-    if (request.header("Connection") == null) {
-      result.header("Connection", "Keep-Alive");
-    }
-
-    if (request.header("Accept-Encoding") == null) {
-      transparentGzip = true;
-      result.header("Accept-Encoding", "gzip");
-    }
-
-    List<Cookie> cookies = client.cookieJar().loadForRequest(request.url());
-    if (!cookies.isEmpty()) {
-      result.header("Cookie", cookieHeader(cookies));
-    }
-
-    if (request.header("User-Agent") == null) {
-      result.header("User-Agent", Version.userAgent());
-    }
-
-    return result.build();
-  }
-
-  /** Returns a 'Cookie' HTTP request header with all cookies, like {@code a=b; c=d}. */
-  private String cookieHeader(List<Cookie> cookies) {
-    StringBuilder cookieHeader = new StringBuilder();
-    for (int i = 0, size = cookies.size(); i < size; i++) {
-      if (i > 0) {
-        cookieHeader.append("; ");
-      }
-      Cookie cookie = cookies.get(i);
-      cookieHeader.append(cookie.name()).append('=').append(cookie.value());
-    }
-    return cookieHeader.toString();
-  }
-
-  /**
-   * Flushes the remaining request header and body, parses the HTTP response headers and starts
-   * reading the HTTP response body if it exists.
-   */
-  public void readResponse() throws IOException {
-    if (userResponse != null) {
-      return; // Already ready.
-    }
-    if (networkRequest == null && cacheResponse == null) {
-      throw new IllegalStateException("call sendRequest() first!");
-    }
-    if (networkRequest == null) {
-      return; // No network response to read.
-    }
-
-    Response networkResponse;
-
-    if (forWebSocket) {
-      httpStream.writeRequestHeaders(networkRequest);
-      networkResponse = readNetworkResponse();
-    } else if (!callerWritesRequestBody) {
-      networkResponse = new NetworkInterceptorChain(0, networkRequest,
-          streamAllocation.connection()).proceed(networkRequest);
-    } else {
-      // Emit the request body's buffer so that everything is in requestBodyOut.
-      if (bufferedRequestBody != null && bufferedRequestBody.buffer().size() > 0) {
-        bufferedRequestBody.emit();
-      }
-
-      // Emit the request headers if we haven't yet. We might have just learned the Content-Length.
-      if (sentRequestMillis == -1) {
-        if (OkHeaders.contentLength(networkRequest) == -1
-            && requestBodyOut instanceof RetryableSink) {
-          long contentLength = ((RetryableSink) requestBodyOut).contentLength();
-          networkRequest = networkRequest.newBuilder()
-              .header("Content-Length", Long.toString(contentLength))
-              .build();
-        }
-        httpStream.writeRequestHeaders(networkRequest);
-      }
-
-      // Write the request body to the socket.
-      if (requestBodyOut != null) {
-        if (bufferedRequestBody != null) {
-          // This also closes the wrapped requestBodyOut.
-          bufferedRequestBody.close();
-        } else {
-          requestBodyOut.close();
-        }
-        if (requestBodyOut instanceof RetryableSink) {
-          httpStream.writeRequestBody((RetryableSink) requestBodyOut);
-        }
-      }
-
-      networkResponse = readNetworkResponse();
-    }
-
-    receiveHeaders(networkResponse.headers());
-
-    // If we have a cache response too, then we're doing a conditional get.
-    if (cacheResponse != null) {
-      if (validate(cacheResponse, networkResponse)) {
-        userResponse = cacheResponse.newBuilder()
-            .request(userRequest)
-            .priorResponse(stripBody(priorResponse))
-            .headers(combine(cacheResponse.headers(), networkResponse.headers()))
-            .cacheResponse(stripBody(cacheResponse))
-            .networkResponse(stripBody(networkResponse))
-            .build();
-        networkResponse.body().close();
-        releaseStreamAllocation();
-
-        // Update the cache after combining headers but before stripping the
-        // Content-Encoding header (as performed by initContentStream()).
-        InternalCache responseCache = Internal.instance.internalCache(client);
-        responseCache.trackConditionalCacheHit();
-        responseCache.update(cacheResponse, userResponse);
-        userResponse = unzip(userResponse);
-        return;
-      } else {
-        closeQuietly(cacheResponse.body());
-      }
-    }
-
-    userResponse = networkResponse.newBuilder()
-        .request(userRequest)
-        .priorResponse(stripBody(priorResponse))
-        .cacheResponse(stripBody(cacheResponse))
-        .networkResponse(stripBody(networkResponse))
-        .build();
-
-    if (hasBody(userResponse)) {
-      maybeCache();
-      userResponse = unzip(cacheWritingResponse(storeRequest, userResponse));
-    }
-  }
-
-  class NetworkInterceptorChain implements Interceptor.Chain {
-    private final int index;
-    private final Request request;
-    private final Connection connection;
-    private int calls;
-
-    NetworkInterceptorChain(int index, Request request, Connection connection) {
-      this.index = index;
-      this.request = request;
-      this.connection = connection;
-    }
-
-    @Override public Connection connection() {
-      return connection;
-    }
-
-    @Override public Request request() {
-      return request;
-    }
-
-    @Override public Response proceed(Request request) throws IOException {
-      calls++;
-
-      if (index > 0) {
-        Interceptor caller = client.networkInterceptors().get(index - 1);
-        Address address = connection().route().address();
-
-        // Confirm that the interceptor uses the connection we've already prepared.
-        if (!request.url().host().equals(address.url().host())
-            || request.url().port() != address.url().port()) {
-          throw new IllegalStateException("network interceptor " + caller
-              + " must retain the same host and port");
-        }
-
-        // Confirm that this is the interceptor's first call to chain.proceed().
-        if (calls > 1) {
-          throw new IllegalStateException("network interceptor " + caller
-              + " must call proceed() exactly once");
-        }
-      }
-
-      if (index < client.networkInterceptors().size()) {
-        // There's another interceptor in the chain. Call that.
-        NetworkInterceptorChain chain = new NetworkInterceptorChain(index + 1, request, connection);
-        Interceptor interceptor = client.networkInterceptors().get(index);
-        Response interceptedResponse = interceptor.intercept(chain);
-
-        // Confirm that the interceptor made the required call to chain.proceed().
-        if (chain.calls != 1) {
-          throw new IllegalStateException("network interceptor " + interceptor
-              + " must call proceed() exactly once");
-        }
-        if (interceptedResponse == null) {
-          throw new NullPointerException("network interceptor " + interceptor
-              + " returned null");
-        }
-
-        return interceptedResponse;
-      }
-
-      httpStream.writeRequestHeaders(request);
-
-      //Update the networkRequest with the possibly updated interceptor request.
-      networkRequest = request;
-
-      if (permitsRequestBody(request) && request.body() != null) {
-        Sink requestBodyOut = httpStream.createRequestBody(request, request.body().contentLength());
-        BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);
-        request.body().writeTo(bufferedRequestBody);
-        bufferedRequestBody.close();
-      }
-
-      Response response = readNetworkResponse();
-
-      int code = response.code();
-      if ((code == 204 || code == 205) && response.body().contentLength() > 0) {
-        throw new ProtocolException(
-            "HTTP " + code + " had non-zero Content-Length: " + response.body().contentLength());
-      }
-
-      return response;
-    }
-  }
-
-  private Response readNetworkResponse() throws IOException {
-    httpStream.finishRequest();
-
-    Response networkResponse = httpStream.readResponseHeaders()
-        .request(networkRequest)
-        .handshake(streamAllocation.connection().handshake())
-        .sentRequestAtMillis(sentRequestMillis)
-        .receivedResponseAtMillis(System.currentTimeMillis())
-        .build();
-
-    if (!forWebSocket || networkResponse.code() != 101) {
-      networkResponse = networkResponse.newBuilder()
-          .body(httpStream.openResponseBody(networkResponse))
-          .build();
-    }
-
-    if ("close".equalsIgnoreCase(networkResponse.request().header("Connection"))
-        || "close".equalsIgnoreCase(networkResponse.header("Connection"))) {
-      streamAllocation.noNewStreams();
-    }
-
-    return networkResponse;
-  }
-
-  /**
-   * Returns a new source that writes bytes to {@code cacheRequest} as they are read by the source
-   * consumer. This is careful to discard bytes left over when the stream is closed; otherwise we
-   * may never exhaust the source stream and therefore not complete the cached response.
-   */
-  private Response cacheWritingResponse(final CacheRequest cacheRequest, Response response)
-      throws IOException {
-    // Some apps return a null body; for compatibility we treat that like a null cache request.
-    if (cacheRequest == null) return response;
-    Sink cacheBodyUnbuffered = cacheRequest.body();
-    if (cacheBodyUnbuffered == null) return response;
-
-    final BufferedSource source = response.body().source();
-    final BufferedSink cacheBody = Okio.buffer(cacheBodyUnbuffered);
-
-    Source cacheWritingSource = new Source() {
-      boolean cacheRequestClosed;
-
-      @Override public long read(Buffer sink, long byteCount) throws IOException {
-        long bytesRead;
-        try {
-          bytesRead = source.read(sink, byteCount);
-        } catch (IOException e) {
-          if (!cacheRequestClosed) {
-            cacheRequestClosed = true;
-            cacheRequest.abort(); // Failed to write a complete cache response.
-          }
-          throw e;
-        }
-
-        if (bytesRead == -1) {
-          if (!cacheRequestClosed) {
-            cacheRequestClosed = true;
-            cacheBody.close(); // The cache response is complete!
-          }
-          return -1;
-        }
-
-        sink.copyTo(cacheBody.buffer(), sink.size() - bytesRead, bytesRead);
-        cacheBody.emitCompleteSegments();
-        return bytesRead;
-      }
-
-      @Override public Timeout timeout() {
-        return source.timeout();
-      }
-
-      @Override public void close() throws IOException {
-        if (!cacheRequestClosed
-            && !discard(this, HttpStream.DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
-          cacheRequestClosed = true;
-          cacheRequest.abort();
-        }
-        source.close();
-      }
-    };
-
-    return response.newBuilder()
-        .body(new RealResponseBody(response.headers(), Okio.buffer(cacheWritingSource)))
-        .build();
-  }
-
-  /**
-   * Returns true if {@code cached} should be used; false if {@code network} response should be
-   * used.
-   */
-  private static boolean validate(Response cached, Response network) {
-    if (network.code() == HTTP_NOT_MODIFIED) {
-      return true;
-    }
-
-    // The HTTP spec says that if the network's response is older than our
-    // cached response, we may return the cache's response. Like Chrome (but
-    // unlike Firefox), this client prefers to return the newer response.
-    Date lastModified = cached.headers().getDate("Last-Modified");
-    if (lastModified != null) {
-      Date networkLastModified = network.headers().getDate("Last-Modified");
-      if (networkLastModified != null
-          && networkLastModified.getTime() < lastModified.getTime()) {
-        return true;
-      }
-    }
-
-    return false;
-  }
-
-  /**
-   * Combines cached headers with a network headers as defined by RFC 2616, 13.5.3.
-   */
-  private static Headers combine(Headers cachedHeaders, Headers networkHeaders) throws IOException {
-    Headers.Builder result = new Headers.Builder();
-
-    for (int i = 0, size = cachedHeaders.size(); i < size; i++) {
-      String fieldName = cachedHeaders.name(i);
-      String value = cachedHeaders.value(i);
-      if ("Warning".equalsIgnoreCase(fieldName) && value.startsWith("1")) {
-        continue; // Drop 100-level freshness warnings.
-      }
-      if (!OkHeaders.isEndToEnd(fieldName) || networkHeaders.get(fieldName) == null) {
-        Internal.instance.addLenient(result, fieldName, value);
-      }
-    }
-
-    for (int i = 0, size = networkHeaders.size(); i < size; i++) {
-      String fieldName = networkHeaders.name(i);
-      if ("Content-Length".equalsIgnoreCase(fieldName)) {
-        continue; // Ignore content-length headers of validating responses.
-      }
-      if (OkHeaders.isEndToEnd(fieldName)) {
-        Internal.instance.addLenient(result, fieldName, networkHeaders.value(i));
-      }
-    }
-
-    return result.build();
-  }
-
-  public void receiveHeaders(Headers headers) throws IOException {
-    if (client.cookieJar() == CookieJar.NO_COOKIES) return;
-
-    List<Cookie> cookies = Cookie.parseAll(userRequest.url(), headers);
-    if (cookies.isEmpty()) return;
-
-    client.cookieJar().saveFromResponse(userRequest.url(), cookies);
-  }
-
-  /**
-   * Figures out the HTTP request to make in response to receiving this engine's response. This will
-   * either add authentication headers, follow redirects or handle a client request timeout. If a
-   * follow-up is either unnecessary or not applicable, this returns null.
-   */
-  public Request followUpRequest() throws IOException {
-    if (userResponse == null) throw new IllegalStateException();
-    Connection connection = streamAllocation.connection();
-    Route route = connection != null
-        ? connection.route()
-        : null;
-    int responseCode = userResponse.code();
-
-    final String method = userRequest.method();
-    switch (responseCode) {
-      case HTTP_PROXY_AUTH:
-        Proxy selectedProxy = route != null
-            ? route.proxy()
-            : client.proxy();
-        if (selectedProxy.type() != Proxy.Type.HTTP) {
-          throw new ProtocolException("Received HTTP_PROXY_AUTH (407) code while not using proxy");
-        }
-        return client.proxyAuthenticator().authenticate(route, userResponse);
-
-      case HTTP_UNAUTHORIZED:
-        return client.authenticator().authenticate(route, userResponse);
-
-      case HTTP_PERM_REDIRECT:
-      case HTTP_TEMP_REDIRECT:
-        // "If the 307 or 308 status code is received in response to a request other than GET
-        // or HEAD, the user agent MUST NOT automatically redirect the request"
-        if (!method.equals("GET") && !method.equals("HEAD")) {
-          return null;
-        }
-        // fall-through
-      case HTTP_MULT_CHOICE:
-      case HTTP_MOVED_PERM:
-      case HTTP_MOVED_TEMP:
-      case HTTP_SEE_OTHER:
-        // Does the client allow redirects?
-        if (!client.followRedirects()) return null;
-
-        String location = userResponse.header("Location");
-        if (location == null) return null;
-        HttpUrl url = userRequest.url().resolve(location);
-
-        // Don't follow redirects to unsupported protocols.
-        if (url == null) return null;
-
-        // If configured, don't follow redirects between SSL and non-SSL.
-        boolean sameScheme = url.scheme().equals(userRequest.url().scheme());
-        if (!sameScheme && !client.followSslRedirects()) return null;
-
-        // Redirects don't include a request body.
-        Request.Builder requestBuilder = userRequest.newBuilder();
-        if (HttpMethod.permitsRequestBody(method)) {
-          if (HttpMethod.redirectsToGet(method)) {
-            requestBuilder.method("GET", null);
-          } else {
-            requestBuilder.method(method, null);
-          }
-          requestBuilder.removeHeader("Transfer-Encoding");
-          requestBuilder.removeHeader("Content-Length");
-          requestBuilder.removeHeader("Content-Type");
-        }
-
-        // When redirecting across hosts, drop all authentication headers. This
-        // is potentially annoying to the application layer since they have no
-        // way to retain them.
-        if (!sameConnection(url)) {
-          requestBuilder.removeHeader("Authorization");
-        }
-
-        return requestBuilder.url(url).build();
-
-      case HTTP_CLIENT_TIMEOUT:
-        // 408's are rare in practice, but some servers like HAProxy use this response code. The
-        // spec says that we may repeat the request without modifications. Modern browsers also
-        // repeat the request (even non-idempotent ones.)
-        boolean retryableBody = requestBodyOut == null || requestBodyOut instanceof RetryableSink;
-        if (callerWritesRequestBody && !retryableBody) {
-          return null;
-        }
-
-        return userRequest;
-
-      default:
-        return null;
-    }
-  }
-
-  /**
-   * Returns true if an HTTP request for {@code followUp} can reuse the connection used by this
-   * engine.
-   */
-  public boolean sameConnection(HttpUrl followUp) {
-    HttpUrl url = userRequest.url();
-    return url.host().equals(followUp.host())
-        && url.port() == followUp.port()
-        && url.scheme().equals(followUp.scheme());
-  }
-
-  private static Address createAddress(OkHttpClient client, Request request) {
-    SSLSocketFactory sslSocketFactory = null;
-    HostnameVerifier hostnameVerifier = null;
-    CertificatePinner certificatePinner = null;
-    if (request.isHttps()) {
-      sslSocketFactory = client.sslSocketFactory();
-      hostnameVerifier = client.hostnameVerifier();
-      certificatePinner = client.certificatePinner();
-    }
-
-    return new Address(request.url().host(), request.url().port(), client.dns(),
-        client.socketFactory(), sslSocketFactory, hostnameVerifier, certificatePinner,
-        client.proxyAuthenticator(), client.proxy(), client.protocols(),
-        client.connectionSpecs(), client.proxySelector());
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/OkHeaders.java b/okhttp/src/main/java/okhttp3/internal/http/HttpHeaders.java
similarity index 51%
rename from okhttp/src/main/java/okhttp3/internal/http/OkHeaders.java
rename to okhttp/src/main/java/okhttp3/internal/http/HttpHeaders.java
index db8011c542..a1d6712906 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/OkHeaders.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/HttpHeaders.java
@@ -20,44 +20,30 @@
 import java.util.List;
 import java.util.Set;
 import java.util.TreeSet;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
 import okhttp3.Challenge;
+import okhttp3.Cookie;
+import okhttp3.CookieJar;
 import okhttp3.Headers;
-import okhttp3.Protocol;
+import okhttp3.HttpUrl;
 import okhttp3.Request;
 import okhttp3.Response;
-import okhttp3.internal.Platform;
+import okhttp3.internal.Util;
 
+import static java.net.HttpURLConnection.HTTP_NOT_MODIFIED;
+import static java.net.HttpURLConnection.HTTP_NO_CONTENT;
 import static okhttp3.internal.Util.equal;
+import static okhttp3.internal.http.StatusLine.HTTP_CONTINUE;
 
 /** Headers and utilities for internal use by OkHttp. */
-public final class OkHeaders {
+public final class HttpHeaders {
+  private static final String TOKEN = "([^ \"=]*)";
+  private static final String QUOTED_STRING = "\"([^\"]*)\"";
+  private static final Pattern PARAMETER
+      = Pattern.compile(" +" + TOKEN + "=(:?" + QUOTED_STRING + "|" + TOKEN + ") *(:?,|$)");
 
-  static final String PREFIX = Platform.get().getPrefix();
-
-  /**
-   * Synthetic response header: the local time when the request was sent.
-   */
-  public static final String SENT_MILLIS = PREFIX + "-Sent-Millis";
-
-  /**
-   * Synthetic response header: the local time when the response was received.
-   */
-  public static final String RECEIVED_MILLIS = PREFIX + "-Received-Millis";
-
-  /**
-   * Synthetic response header: the selected {@link Protocol protocol} ("spdy/3.1", "http/1.1",
-   * etc).
-   */
-  public static final String SELECTED_PROTOCOL = PREFIX + "-Selected-Protocol";
-
-  /** Synthetic response header: the location from which the response was loaded. */
-  public static final String RESPONSE_SOURCE = PREFIX + "-Response-Source";
-
-  private OkHeaders() {
-  }
-
-  public static long contentLength(Request request) {
-    return contentLength(request.headers());
+  private HttpHeaders() {
   }
 
   public static long contentLength(Response response) {
@@ -158,22 +144,8 @@ public static Headers varyHeaders(Headers requestHeaders, Headers responseHeader
   }
 
   /**
-   * Returns true if {@code fieldName} is an end-to-end HTTP header, as defined by RFC 2616,
-   * 13.5.1.
-   */
-  static boolean isEndToEnd(String fieldName) {
-    return !"Connection".equalsIgnoreCase(fieldName)
-        && !"Keep-Alive".equalsIgnoreCase(fieldName)
-        && !"Proxy-Authenticate".equalsIgnoreCase(fieldName)
-        && !"Proxy-Authorization".equalsIgnoreCase(fieldName)
-        && !"TE".equalsIgnoreCase(fieldName)
-        && !"Trailers".equalsIgnoreCase(fieldName)
-        && !"Transfer-Encoding".equalsIgnoreCase(fieldName)
-        && !"Upgrade".equalsIgnoreCase(fieldName);
-  }
-
-  /**
-   * Parse RFC 2617 challenges. This API is only interested in the scheme name and realm.
+   * Parse RFC 7617 challenges, also wrong ordered ones.
+   * This API is only interested in the scheme name and realm.
    */
   public static List<Challenge> parseChallenges(Headers responseHeaders, String challengeHeader) {
     // auth-scheme = token
@@ -181,39 +153,124 @@ static boolean isEndToEnd(String fieldName) {
     // challenge   = auth-scheme 1*SP 1#auth-param
     // realm       = "realm" "=" realm-value
     // realm-value = quoted-string
-    List<Challenge> result = new ArrayList<>();
-    for (int i = 0, size = responseHeaders.size(); i < size; i++) {
-      if (!challengeHeader.equalsIgnoreCase(responseHeaders.name(i))) {
-        continue;
+    List<Challenge> challenges = new ArrayList<>();
+    List<String> authenticationHeaders = responseHeaders.values(challengeHeader);
+    for (String header : authenticationHeaders) {
+      int index = header.indexOf(' ');
+      if (index == -1) continue;
+
+      String scheme = header.substring(0, index);
+      String realm = null;
+      String charset = null;
+
+      Matcher matcher = PARAMETER.matcher(header);
+      for (int i = index; matcher.find(i); i = matcher.end()) {
+        if (header.regionMatches(true, matcher.start(1), "realm", 0, 5)) {
+          realm = matcher.group(3);
+        } else if (header.regionMatches(true, matcher.start(1), "charset", 0, 7)) {
+          charset = matcher.group(3);
+        }
+
+        if (realm != null && charset != null) {
+          break;
+        }
       }
-      String value = responseHeaders.value(i);
-      int pos = 0;
-      while (pos < value.length()) {
-        int tokenStart = pos;
-        pos = HeaderParser.skipUntil(value, pos, " ");
 
-        String scheme = value.substring(tokenStart, pos).trim();
-        pos = HeaderParser.skipWhitespace(value, pos);
+      // "realm" is required.
+      if (realm == null) continue;
 
-        // TODO: This currently only handles schemes with a 'realm' parameter;
-        //       It needs to be fixed to handle any scheme and any parameters
-        //       http://code.google.com/p/android/issues/detail?id=11140
+      Challenge challenge = new Challenge(scheme, realm);
 
-        if (!value.regionMatches(true, pos, "realm=\"", 0, "realm=\"".length())) {
-          break; // Unexpected challenge parameter; give up!
+      // If a charset is provided, RFC 7617 says it must be "UTF-8".
+      if (charset != null) {
+        if (charset.equalsIgnoreCase("UTF-8")) {
+          challenge = challenge.withCharset(Util.UTF_8);
+        } else {
+          continue;
         }
+      }
+
+      challenges.add(challenge);
+    }
+    return challenges;
+  }
+
+  public static void receiveHeaders(CookieJar cookieJar, HttpUrl url, Headers headers) {
+    if (cookieJar == CookieJar.NO_COOKIES) return;
 
-        pos += "realm=\"".length();
-        int realmStart = pos;
-        pos = HeaderParser.skipUntil(value, pos, "\"");
-        String realm = value.substring(realmStart, pos);
-        pos++; // Consume '"' close quote.
-        pos = HeaderParser.skipUntil(value, pos, ",");
-        pos++; // Consume ',' comma.
-        pos = HeaderParser.skipWhitespace(value, pos);
-        result.add(new Challenge(scheme, realm));
+    List<Cookie> cookies = Cookie.parseAll(url, headers);
+    if (cookies.isEmpty()) return;
+
+    cookieJar.saveFromResponse(url, cookies);
+  }
+
+  /** Returns true if the response must have a (possibly 0-length) body. See RFC 7231. */
+  public static boolean hasBody(Response response) {
+    // HEAD requests never yield a body regardless of the response headers.
+    if (response.request().method().equals("HEAD")) {
+      return false;
+    }
+
+    int responseCode = response.code();
+    if ((responseCode < HTTP_CONTINUE || responseCode >= 200)
+        && responseCode != HTTP_NO_CONTENT
+        && responseCode != HTTP_NOT_MODIFIED) {
+      return true;
+    }
+
+    // If the Content-Length or Transfer-Encoding headers disagree with the response code, the
+    // response is malformed. For best compatibility, we honor the headers.
+    if (contentLength(response) != -1
+        || "chunked".equalsIgnoreCase(response.header("Transfer-Encoding"))) {
+      return true;
+    }
+
+    return false;
+  }
+
+  /**
+   * Returns the next index in {@code input} at or after {@code pos} that contains a character from
+   * {@code characters}. Returns the input length if none of the requested characters can be found.
+   */
+  public static int skipUntil(String input, int pos, String characters) {
+    for (; pos < input.length(); pos++) {
+      if (characters.indexOf(input.charAt(pos)) != -1) {
+        break;
       }
     }
-    return result;
+    return pos;
+  }
+
+  /**
+   * Returns the next non-whitespace character in {@code input} that is white space. Result is
+   * undefined if input contains newline characters.
+   */
+  public static int skipWhitespace(String input, int pos) {
+    for (; pos < input.length(); pos++) {
+      char c = input.charAt(pos);
+      if (c != ' ' && c != '\t') {
+        break;
+      }
+    }
+    return pos;
+  }
+
+  /**
+   * Returns {@code value} as a positive integer, or 0 if it is negative, or {@code defaultValue} if
+   * it cannot be parsed.
+   */
+  public static int parseSeconds(String value, int defaultValue) {
+    try {
+      long seconds = Long.parseLong(value);
+      if (seconds > Integer.MAX_VALUE) {
+        return Integer.MAX_VALUE;
+      } else if (seconds < 0) {
+        return 0;
+      } else {
+        return (int) seconds;
+      }
+    } catch (NumberFormatException e) {
+      return defaultValue;
+    }
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/http/HttpMethod.java b/okhttp/src/main/java/okhttp3/internal/http/HttpMethod.java
index 3629810c0e..da45901512 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/HttpMethod.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/HttpMethod.java
@@ -33,12 +33,11 @@ public static boolean requiresRequestBody(String method) {
   }
 
   public static boolean permitsRequestBody(String method) {
-    return requiresRequestBody(method)
-        || method.equals("OPTIONS")
-        || method.equals("DELETE")    // Permitted as spec is ambiguous.
-        || method.equals("PROPFIND")  // (WebDAV) without body: request <allprop/>
-        || method.equals("MKCOL")     // (WebDAV) may contain a body, but behaviour is unspecified
-        || method.equals("LOCK");     // (WebDAV) body: create lock, without body: refresh lock
+    return !(method.equals("GET") || method.equals("HEAD"));
+  }
+
+  public static boolean redirectsWithBody(String method) {
+    return method.equals("PROPFIND"); // (WebDAV) redirects should also maintain the request body
   }
 
   public static boolean redirectsToGet(String method) {
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java b/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java
new file mode 100644
index 0000000000..52f9880892
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java
@@ -0,0 +1,167 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http;
+
+import java.io.IOException;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+import okhttp3.Call;
+import okhttp3.Connection;
+import okhttp3.EventListener;
+import okhttp3.Interceptor;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.internal.connection.RealConnection;
+import okhttp3.internal.connection.StreamAllocation;
+
+import static okhttp3.internal.Util.checkDuration;
+
+/**
+ * A concrete interceptor chain that carries the entire interceptor chain: all application
+ * interceptors, the OkHttp core, all network interceptors, and finally the network caller.
+ */
+public final class RealInterceptorChain implements Interceptor.Chain {
+  private final List<Interceptor> interceptors;
+  private final StreamAllocation streamAllocation;
+  private final HttpCodec httpCodec;
+  private final RealConnection connection;
+  private final int index;
+  private final Request request;
+  private final Call call;
+  private final EventListener eventListener;
+  private final int connectTimeout;
+  private final int readTimeout;
+  private final int writeTimeout;
+  private int calls;
+
+  public RealInterceptorChain(List<Interceptor> interceptors, StreamAllocation streamAllocation,
+      HttpCodec httpCodec, RealConnection connection, int index, Request request, Call call,
+      EventListener eventListener, int connectTimeout, int readTimeout, int writeTimeout) {
+    this.interceptors = interceptors;
+    this.connection = connection;
+    this.streamAllocation = streamAllocation;
+    this.httpCodec = httpCodec;
+    this.index = index;
+    this.request = request;
+    this.call = call;
+    this.eventListener = eventListener;
+    this.connectTimeout = connectTimeout;
+    this.readTimeout = readTimeout;
+    this.writeTimeout = writeTimeout;
+  }
+
+  @Override public Connection connection() {
+    return connection;
+  }
+
+  @Override public int connectTimeoutMillis() {
+    return connectTimeout;
+  }
+
+  @Override public Interceptor.Chain withConnectTimeout(int timeout, TimeUnit unit) {
+    int millis = checkDuration("timeout", timeout, unit);
+    return new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index,
+        request, call, eventListener, millis, readTimeout, writeTimeout);
+  }
+
+  @Override public int readTimeoutMillis() {
+    return readTimeout;
+  }
+
+  @Override public Interceptor.Chain withReadTimeout(int timeout, TimeUnit unit) {
+    int millis = checkDuration("timeout", timeout, unit);
+    return new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index,
+        request, call, eventListener, connectTimeout, millis, writeTimeout);
+  }
+
+  @Override public int writeTimeoutMillis() {
+    return writeTimeout;
+  }
+
+  @Override public Interceptor.Chain withWriteTimeout(int timeout, TimeUnit unit) {
+    int millis = checkDuration("timeout", timeout, unit);
+    return new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index,
+        request, call, eventListener, connectTimeout, readTimeout, millis);
+  }
+
+  public StreamAllocation streamAllocation() {
+    return streamAllocation;
+  }
+
+  public HttpCodec httpStream() {
+    return httpCodec;
+  }
+
+  @Override public Call call() {
+    return call;
+  }
+
+  public EventListener eventListener() {
+    return eventListener;
+  }
+
+  @Override public Request request() {
+    return request;
+  }
+
+  @Override public Response proceed(Request request) throws IOException {
+    return proceed(request, streamAllocation, httpCodec, connection);
+  }
+
+  public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,
+      RealConnection connection) throws IOException {
+    if (index >= interceptors.size()) throw new AssertionError();
+
+    calls++;
+
+    // If we already have a stream, confirm that the incoming request will use it.
+    if (this.httpCodec != null && !this.connection.supportsUrl(request.url())) {
+      throw new IllegalStateException("network interceptor " + interceptors.get(index - 1)
+          + " must retain the same host and port");
+    }
+
+    // If we already have a stream, confirm that this is the only call to chain.proceed().
+    if (this.httpCodec != null && calls > 1) {
+      throw new IllegalStateException("network interceptor " + interceptors.get(index - 1)
+          + " must call proceed() exactly once");
+    }
+
+    // Call the next interceptor in the chain.
+    RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,
+        connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,
+        writeTimeout);
+    Interceptor interceptor = interceptors.get(index);
+    Response response = interceptor.intercept(next);
+
+    // Confirm that the next interceptor made its required call to chain.proceed().
+    if (httpCodec != null && index + 1 < interceptors.size() && next.calls != 1) {
+      throw new IllegalStateException("network interceptor " + interceptor
+          + " must call proceed() exactly once");
+    }
+
+    // Confirm that the intercepted response isn't null.
+    if (response == null) {
+      throw new NullPointerException("interceptor " + interceptor + " returned null");
+    }
+
+    if (response.body() == null) {
+      throw new IllegalStateException(
+          "interceptor " + interceptor + " returned a response with no body");
+    }
+
+    return response;
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RealResponseBody.java b/okhttp/src/main/java/okhttp3/internal/http/RealResponseBody.java
index d66fed988c..970d7ca949 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/RealResponseBody.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/RealResponseBody.java
@@ -15,27 +15,33 @@
  */
 package okhttp3.internal.http;
 
-import okhttp3.Headers;
+import javax.annotation.Nullable;
 import okhttp3.MediaType;
 import okhttp3.ResponseBody;
 import okio.BufferedSource;
 
 public final class RealResponseBody extends ResponseBody {
-  private final Headers headers;
+  /**
+   * Use a string to avoid parsing the content type until needed. This also defers problems caused
+   * by malformed content types.
+   */
+  private final @Nullable String contentTypeString;
+  private final long contentLength;
   private final BufferedSource source;
 
-  public RealResponseBody(Headers headers, BufferedSource source) {
-    this.headers = headers;
+  public RealResponseBody(
+      @Nullable String contentTypeString, long contentLength, BufferedSource source) {
+    this.contentTypeString = contentTypeString;
+    this.contentLength = contentLength;
     this.source = source;
   }
 
   @Override public MediaType contentType() {
-    String contentType = headers.get("Content-Type");
-    return contentType != null ? MediaType.parse(contentType) : null;
+    return contentTypeString != null ? MediaType.parse(contentTypeString) : null;
   }
 
   @Override public long contentLength() {
-    return OkHeaders.contentLength(headers);
+    return contentLength;
   }
 
   @Override public BufferedSource source() {
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RequestException.java b/okhttp/src/main/java/okhttp3/internal/http/RequestException.java
deleted file mode 100644
index 56884c811f..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/http/RequestException.java
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http;
-
-import java.io.IOException;
-
-/**
- * Indicates a problem with interpreting a request. It may indicate there was a problem with the
- * request itself, or the environment being used to interpret the request (network failure, etc.).
- */
-public final class RequestException extends Exception {
-
-  public RequestException(IOException cause) {
-    super(cause);
-  }
-
-  @Override
-  public IOException getCause() {
-    return (IOException) super.getCause();
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RequestLine.java b/okhttp/src/main/java/okhttp3/internal/http/RequestLine.java
index c70a86934e..3e09098097 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/RequestLine.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/RequestLine.java
@@ -27,9 +27,9 @@ private RequestLine() {
   /**
    * Returns the request status line, like "GET / HTTP/1.1". This is exposed to the application by
    * {@link HttpURLConnection#getHeaderFields}, so it needs to be set even if the transport is
-   * SPDY.
+   * HTTP/2.
    */
-  static String get(Request request, Proxy.Type proxyType) {
+  public static String get(Request request, Proxy.Type proxyType) {
     StringBuilder result = new StringBuilder();
     result.append(request.method());
     result.append(' ');
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
new file mode 100644
index 0000000000..ed8c9e0a75
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
@@ -0,0 +1,414 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http;
+
+import java.io.IOException;
+import java.io.InterruptedIOException;
+import java.net.HttpRetryException;
+import java.net.ProtocolException;
+import java.net.Proxy;
+import java.net.SocketTimeoutException;
+import java.security.cert.CertificateException;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.SSLHandshakeException;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import javax.net.ssl.SSLSocketFactory;
+import okhttp3.Address;
+import okhttp3.Call;
+import okhttp3.CertificatePinner;
+import okhttp3.Connection;
+import okhttp3.EventListener;
+import okhttp3.HttpUrl;
+import okhttp3.Interceptor;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
+import okhttp3.Route;
+import okhttp3.internal.connection.RouteException;
+import okhttp3.internal.connection.StreamAllocation;
+import okhttp3.internal.http2.ConnectionShutdownException;
+
+import static java.net.HttpURLConnection.HTTP_CLIENT_TIMEOUT;
+import static java.net.HttpURLConnection.HTTP_MOVED_PERM;
+import static java.net.HttpURLConnection.HTTP_MOVED_TEMP;
+import static java.net.HttpURLConnection.HTTP_MULT_CHOICE;
+import static java.net.HttpURLConnection.HTTP_PROXY_AUTH;
+import static java.net.HttpURLConnection.HTTP_SEE_OTHER;
+import static java.net.HttpURLConnection.HTTP_UNAUTHORIZED;
+import static java.net.HttpURLConnection.HTTP_UNAVAILABLE;
+import static okhttp3.internal.Util.closeQuietly;
+import static okhttp3.internal.http.StatusLine.HTTP_PERM_REDIRECT;
+import static okhttp3.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
+
+/**
+ * This interceptor recovers from failures and follows redirects as necessary. It may throw an
+ * {@link IOException} if the call was canceled.
+ */
+public final class RetryAndFollowUpInterceptor implements Interceptor {
+  /**
+   * How many redirects and auth challenges should we attempt? Chrome follows 21 redirects; Firefox,
+   * curl, and wget follow 20; Safari follows 16; and HTTP/1.0 recommends 5.
+   */
+  private static final int MAX_FOLLOW_UPS = 20;
+
+  private final OkHttpClient client;
+  private final boolean forWebSocket;
+  private StreamAllocation streamAllocation;
+  private Object callStackTrace;
+  private volatile boolean canceled;
+
+  public RetryAndFollowUpInterceptor(OkHttpClient client, boolean forWebSocket) {
+    this.client = client;
+    this.forWebSocket = forWebSocket;
+  }
+
+  /**
+   * Immediately closes the socket connection if it's currently held. Use this to interrupt an
+   * in-flight request from any thread. It's the caller's responsibility to close the request body
+   * and response body streams; otherwise resources may be leaked.
+   *
+   * <p>This method is safe to be called concurrently, but provides limited guarantees. If a
+   * transport layer connection has been established (such as a HTTP/2 stream) that is terminated.
+   * Otherwise if a socket connection is being established, that is terminated.
+   */
+  public void cancel() {
+    canceled = true;
+    StreamAllocation streamAllocation = this.streamAllocation;
+    if (streamAllocation != null) streamAllocation.cancel();
+  }
+
+  public boolean isCanceled() {
+    return canceled;
+  }
+
+  public void setCallStackTrace(Object callStackTrace) {
+    this.callStackTrace = callStackTrace;
+  }
+
+  public StreamAllocation streamAllocation() {
+    return streamAllocation;
+  }
+
+  @Override public Response intercept(Chain chain) throws IOException {
+    Request request = chain.request();
+    RealInterceptorChain realChain = (RealInterceptorChain) chain;
+    Call call = realChain.call();
+    EventListener eventListener = realChain.eventListener();
+
+    streamAllocation = new StreamAllocation(client.connectionPool(), createAddress(request.url()),
+        call, eventListener, callStackTrace);
+
+    int followUpCount = 0;
+    Response priorResponse = null;
+    while (true) {
+      if (canceled) {
+        streamAllocation.release();
+        throw new IOException("Canceled");
+      }
+
+      Response response;
+      boolean releaseConnection = true;
+      try {
+        response = realChain.proceed(request, streamAllocation, null, null);
+        releaseConnection = false;
+      } catch (RouteException e) {
+        // The attempt to connect via a route failed. The request will not have been sent.
+        if (!recover(e.getLastConnectException(), false, request)) {
+          throw e.getLastConnectException();
+        }
+        releaseConnection = false;
+        continue;
+      } catch (IOException e) {
+        // An attempt to communicate with a server failed. The request may have been sent.
+        boolean requestSendStarted = !(e instanceof ConnectionShutdownException);
+        if (!recover(e, requestSendStarted, request)) throw e;
+        releaseConnection = false;
+        continue;
+      } finally {
+        // We're throwing an unchecked exception. Release any resources.
+        if (releaseConnection) {
+          streamAllocation.streamFailed(null);
+          streamAllocation.release();
+        }
+      }
+
+      // Attach the prior response if it exists. Such responses never have a body.
+      if (priorResponse != null) {
+        response = response.newBuilder()
+            .priorResponse(priorResponse.newBuilder()
+                    .body(null)
+                    .build())
+            .build();
+      }
+
+      Request followUp = followUpRequest(response);
+
+      if (followUp == null) {
+        if (!forWebSocket) {
+          streamAllocation.release();
+        }
+        return response;
+      }
+
+      closeQuietly(response.body());
+
+      if (++followUpCount > MAX_FOLLOW_UPS) {
+        streamAllocation.release();
+        throw new ProtocolException("Too many follow-up requests: " + followUpCount);
+      }
+
+      if (followUp.body() instanceof UnrepeatableRequestBody) {
+        streamAllocation.release();
+        throw new HttpRetryException("Cannot retry streamed HTTP body", response.code());
+      }
+
+      if (!sameConnection(response, followUp.url())) {
+        streamAllocation.release();
+        streamAllocation = new StreamAllocation(client.connectionPool(),
+            createAddress(followUp.url()), call, eventListener, callStackTrace);
+      } else if (streamAllocation.codec() != null) {
+        throw new IllegalStateException("Closing the body of " + response
+            + " didn't close its backing stream. Bad interceptor?");
+      }
+
+      request = followUp;
+      priorResponse = response;
+    }
+  }
+
+  private Address createAddress(HttpUrl url) {
+    SSLSocketFactory sslSocketFactory = null;
+    HostnameVerifier hostnameVerifier = null;
+    CertificatePinner certificatePinner = null;
+    if (url.isHttps()) {
+      sslSocketFactory = client.sslSocketFactory();
+      hostnameVerifier = client.hostnameVerifier();
+      certificatePinner = client.certificatePinner();
+    }
+
+    return new Address(url.host(), url.port(), client.dns(), client.socketFactory(),
+        sslSocketFactory, hostnameVerifier, certificatePinner, client.proxyAuthenticator(),
+        client.proxy(), client.protocols(), client.connectionSpecs(), client.proxySelector());
+  }
+
+  /**
+   * Report and attempt to recover from a failure to communicate with a server. Returns true if
+   * {@code e} is recoverable, or false if the failure is permanent. Requests with a body can only
+   * be recovered if the body is buffered or if the failure occurred before the request has been
+   * sent.
+   */
+  private boolean recover(IOException e, boolean requestSendStarted, Request userRequest) {
+    streamAllocation.streamFailed(e);
+
+    // The application layer has forbidden retries.
+    if (!client.retryOnConnectionFailure()) return false;
+
+    // We can't send the request body again.
+    if (requestSendStarted && userRequest.body() instanceof UnrepeatableRequestBody) return false;
+
+    // This exception is fatal.
+    if (!isRecoverable(e, requestSendStarted)) return false;
+
+    // No more routes to attempt.
+    if (!streamAllocation.hasMoreRoutes()) return false;
+
+    // For failure recovery, use the same route selector with a new connection.
+    return true;
+  }
+
+  private boolean isRecoverable(IOException e, boolean requestSendStarted) {
+    // If there was a protocol problem, don't recover.
+    if (e instanceof ProtocolException) {
+      return false;
+    }
+
+    // If there was an interruption don't recover, but if there was a timeout connecting to a route
+    // we should try the next route (if there is one).
+    if (e instanceof InterruptedIOException) {
+      return e instanceof SocketTimeoutException && !requestSendStarted;
+    }
+
+    // Look for known client-side or negotiation errors that are unlikely to be fixed by trying
+    // again with a different route.
+    if (e instanceof SSLHandshakeException) {
+      // If the problem was a CertificateException from the X509TrustManager,
+      // do not retry.
+      if (e.getCause() instanceof CertificateException) {
+        return false;
+      }
+    }
+    if (e instanceof SSLPeerUnverifiedException) {
+      // e.g. a certificate pinning error.
+      return false;
+    }
+
+    // An example of one we might want to retry with a different route is a problem connecting to a
+    // proxy and would manifest as a standard IOException. Unless it is one we know we should not
+    // retry, we return true and try a new route.
+    return true;
+  }
+
+  /**
+   * Figures out the HTTP request to make in response to receiving {@code userResponse}. This will
+   * either add authentication headers, follow redirects or handle a client request timeout. If a
+   * follow-up is either unnecessary or not applicable, this returns null.
+   */
+  private Request followUpRequest(Response userResponse) throws IOException {
+    if (userResponse == null) throw new IllegalStateException();
+    Connection connection = streamAllocation.connection();
+    Route route = connection != null
+        ? connection.route()
+        : null;
+    int responseCode = userResponse.code();
+
+    final String method = userResponse.request().method();
+    switch (responseCode) {
+      case HTTP_PROXY_AUTH:
+        Proxy selectedProxy = route != null
+            ? route.proxy()
+            : client.proxy();
+        if (selectedProxy.type() != Proxy.Type.HTTP) {
+          throw new ProtocolException("Received HTTP_PROXY_AUTH (407) code while not using proxy");
+        }
+        return client.proxyAuthenticator().authenticate(route, userResponse);
+
+      case HTTP_UNAUTHORIZED:
+        return client.authenticator().authenticate(route, userResponse);
+
+      case HTTP_PERM_REDIRECT:
+      case HTTP_TEMP_REDIRECT:
+        // "If the 307 or 308 status code is received in response to a request other than GET
+        // or HEAD, the user agent MUST NOT automatically redirect the request"
+        if (!method.equals("GET") && !method.equals("HEAD")) {
+          return null;
+        }
+        // fall-through
+      case HTTP_MULT_CHOICE:
+      case HTTP_MOVED_PERM:
+      case HTTP_MOVED_TEMP:
+      case HTTP_SEE_OTHER:
+        // Does the client allow redirects?
+        if (!client.followRedirects()) return null;
+
+        String location = userResponse.header("Location");
+        if (location == null) return null;
+        HttpUrl url = userResponse.request().url().resolve(location);
+
+        // Don't follow redirects to unsupported protocols.
+        if (url == null) return null;
+
+        // If configured, don't follow redirects between SSL and non-SSL.
+        boolean sameScheme = url.scheme().equals(userResponse.request().url().scheme());
+        if (!sameScheme && !client.followSslRedirects()) return null;
+
+        // Most redirects don't include a request body.
+        Request.Builder requestBuilder = userResponse.request().newBuilder();
+        if (HttpMethod.permitsRequestBody(method)) {
+          final boolean maintainBody = HttpMethod.redirectsWithBody(method);
+          if (HttpMethod.redirectsToGet(method)) {
+            requestBuilder.method("GET", null);
+          } else {
+            RequestBody requestBody = maintainBody ? userResponse.request().body() : null;
+            requestBuilder.method(method, requestBody);
+          }
+          if (!maintainBody) {
+            requestBuilder.removeHeader("Transfer-Encoding");
+            requestBuilder.removeHeader("Content-Length");
+            requestBuilder.removeHeader("Content-Type");
+          }
+        }
+
+        // When redirecting across hosts, drop all authentication headers. This
+        // is potentially annoying to the application layer since they have no
+        // way to retain them.
+        if (!sameConnection(userResponse, url)) {
+          requestBuilder.removeHeader("Authorization");
+        }
+
+        return requestBuilder.url(url).build();
+
+      case HTTP_CLIENT_TIMEOUT:
+        // 408's are rare in practice, but some servers like HAProxy use this response code. The
+        // spec says that we may repeat the request without modifications. Modern browsers also
+        // repeat the request (even non-idempotent ones.)
+        if (!client.retryOnConnectionFailure()) {
+          // The application layer has directed us not to retry the request.
+          return null;
+        }
+
+        if (userResponse.request().body() instanceof UnrepeatableRequestBody) {
+          return null;
+        }
+
+        if (userResponse.priorResponse() != null
+            && userResponse.priorResponse().code() == HTTP_CLIENT_TIMEOUT) {
+          // We attempted to retry and got another timeout. Give up.
+          return null;
+        }
+
+        if (retryAfter(userResponse, 0) > 0) {
+          return null;
+        }
+
+        return userResponse.request();
+
+      case HTTP_UNAVAILABLE:
+        if (userResponse.priorResponse() != null
+            && userResponse.priorResponse().code() == HTTP_UNAVAILABLE) {
+          // We attempted to retry and got another timeout. Give up.
+          return null;
+        }
+
+        if (retryAfter(userResponse, Integer.MAX_VALUE) == 0) {
+          // specifically received an instruction to retry without delay
+          return userResponse.request();
+        }
+
+        return null;
+
+      default:
+        return null;
+    }
+  }
+
+  private int retryAfter(Response userResponse, int defaultDelay) {
+    String header = userResponse.header("Retry-After");
+
+    if (header == null) {
+      return defaultDelay;
+    }
+
+    // https://tools.ietf.org/html/rfc7231#section-7.1.3
+    // currently ignores a HTTP-date, and assumes any non int 0 is a delay
+    if (header.matches("\\d+")) {
+      return Integer.valueOf(header);
+    }
+
+    return Integer.MAX_VALUE;
+  }
+
+  /**
+   * Returns true if an HTTP request for {@code followUp} can reuse the connection used by this
+   * engine.
+   */
+  private boolean sameConnection(Response response, HttpUrl followUp) {
+    HttpUrl url = response.request().url();
+    return url.host().equals(followUp.host())
+        && url.port() == followUp.port()
+        && url.scheme().equals(followUp.scheme());
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RetryableSink.java b/okhttp/src/main/java/okhttp3/internal/http/RetryableSink.java
deleted file mode 100644
index c0010d1898..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/http/RetryableSink.java
+++ /dev/null
@@ -1,78 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http;
-
-import java.io.IOException;
-import java.net.ProtocolException;
-import okio.Buffer;
-import okio.Sink;
-import okio.Timeout;
-
-import static okhttp3.internal.Util.checkOffsetAndCount;
-
-/**
- * An HTTP request body that's completely buffered in memory. This allows the post body to be
- * transparently re-sent if the HTTP request must be sent multiple times.
- */
-public final class RetryableSink implements Sink {
-  private boolean closed;
-  private final int limit;
-  private final Buffer content = new Buffer();
-
-  public RetryableSink(int limit) {
-    this.limit = limit;
-  }
-
-  public RetryableSink() {
-    this(-1);
-  }
-
-  @Override public void close() throws IOException {
-    if (closed) return;
-    closed = true;
-    if (content.size() < limit) {
-      throw new ProtocolException(
-          "content-length promised " + limit + " bytes, but received " + content.size());
-    }
-  }
-
-  @Override public void write(Buffer source, long byteCount) throws IOException {
-    if (closed) throw new IllegalStateException("closed");
-    checkOffsetAndCount(source.size(), 0, byteCount);
-    if (limit != -1 && content.size() > limit - byteCount) {
-      throw new ProtocolException("exceeded content-length limit of " + limit + " bytes");
-    }
-    content.write(source, byteCount);
-  }
-
-  @Override public void flush() throws IOException {
-  }
-
-  @Override public Timeout timeout() {
-    return Timeout.NONE;
-  }
-
-  public long contentLength() throws IOException {
-    return content.size();
-  }
-
-  public void writeToSocket(Sink socketOut) throws IOException {
-    // Copy the content; otherwise we won't have data to retry.
-    Buffer buffer = new Buffer();
-    content.copyTo(buffer, 0, content.size());
-    socketOut.write(buffer, buffer.size());
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/StreamAllocation.java b/okhttp/src/main/java/okhttp3/internal/http/StreamAllocation.java
deleted file mode 100644
index aee74cf0bb..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/http/StreamAllocation.java
+++ /dev/null
@@ -1,336 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http;
-
-import java.io.IOException;
-import java.lang.ref.Reference;
-import java.lang.ref.WeakReference;
-import okhttp3.Address;
-import okhttp3.ConnectionPool;
-import okhttp3.Route;
-import okhttp3.internal.Internal;
-import okhttp3.internal.RouteDatabase;
-import okhttp3.internal.Util;
-import okhttp3.internal.framed.ErrorCode;
-import okhttp3.internal.framed.StreamResetException;
-import okhttp3.internal.io.RealConnection;
-
-import static java.util.concurrent.TimeUnit.MILLISECONDS;
-
-/**
- * This class coordinates the relationship between three entities:
- *
- * <ul>
- *     <li><strong>Connections:</strong> physical socket connections to remote servers. These are
- *         potentially slow to establish so it is necessary to be able to cancel a connection
- *         currently being connected.
- *     <li><strong>Streams:</strong> logical HTTP request/response pairs that are layered on
- *         connections. Each connection has its own allocation limit, which defines how many
- *         concurrent streams that connection can carry. HTTP/1.x connections can carry 1 stream
- *         at a time, SPDY and HTTP/2 typically carry multiple.
- *     <li><strong>Calls:</strong> a logical sequence of streams, typically an initial request and
- *         its follow up requests. We prefer to keep all streams of a single call on the same
- *         connection for better behavior and locality.
- * </ul>
- *
- * <p>Instances of this class act on behalf of the call, using one or more streams over one or more
- * connections. This class has APIs to release each of the above resources:
- *
- * <ul>
- *     <li>{@link #noNewStreams()} prevents the connection from being used for new streams in the
- *         future. Use this after a {@code Connection: close} header, or when the connection may be
- *         inconsistent.
- *     <li>{@link #streamFinished streamFinished()} releases the active stream from this allocation.
- *         Note that only one stream may be active at a given time, so it is necessary to call
- *         {@link #streamFinished streamFinished()} before creating a subsequent stream with {@link
- *         #newStream newStream()}.
- *     <li>{@link #release()} removes the call's hold on the connection. Note that this won't
- *         immediately free the connection if there is a stream still lingering. That happens when a
- *         call is complete but its response body has yet to be fully consumed.
- * </ul>
- *
- * <p>This class supports {@linkplain #cancel asynchronous canceling}. This is intended to have the
- * smallest blast radius possible. If an HTTP/2 stream is active, canceling will cancel that stream
- * but not the other streams sharing its connection. But if the TLS handshake is still in progress
- * then canceling may break the entire connection.
- */
-public final class StreamAllocation {
-  public final Address address;
-  private Route route;
-  private final ConnectionPool connectionPool;
-
-  // State guarded by connectionPool.
-  private final RouteSelector routeSelector;
-  private int refusedStreamCount;
-  private RealConnection connection;
-  private boolean released;
-  private boolean canceled;
-  private HttpStream stream;
-
-  public StreamAllocation(ConnectionPool connectionPool, Address address) {
-    this.connectionPool = connectionPool;
-    this.address = address;
-    this.routeSelector = new RouteSelector(address, routeDatabase());
-  }
-
-  public HttpStream newStream(int connectTimeout, int readTimeout, int writeTimeout,
-      boolean connectionRetryEnabled, boolean doExtensiveHealthChecks)
-      throws RouteException, IOException {
-    try {
-      RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,
-          writeTimeout, connectionRetryEnabled, doExtensiveHealthChecks);
-
-      HttpStream resultStream;
-      if (resultConnection.framedConnection != null) {
-        resultStream = new Http2xStream(this, resultConnection.framedConnection);
-      } else {
-        resultConnection.socket().setSoTimeout(readTimeout);
-        resultConnection.source.timeout().timeout(readTimeout, MILLISECONDS);
-        resultConnection.sink.timeout().timeout(writeTimeout, MILLISECONDS);
-        resultStream = new Http1xStream(this, resultConnection.source, resultConnection.sink);
-      }
-
-      synchronized (connectionPool) {
-        stream = resultStream;
-        return resultStream;
-      }
-    } catch (IOException e) {
-      throw new RouteException(e);
-    }
-  }
-
-  /**
-   * Finds a connection and returns it if it is healthy. If it is unhealthy the process is repeated
-   * until a healthy connection is found.
-   */
-  private RealConnection findHealthyConnection(int connectTimeout, int readTimeout,
-      int writeTimeout, boolean connectionRetryEnabled, boolean doExtensiveHealthChecks)
-      throws IOException, RouteException {
-    while (true) {
-      RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,
-          connectionRetryEnabled);
-
-      // If this is a brand new connection, we can skip the extensive health checks.
-      synchronized (connectionPool) {
-        if (candidate.successCount == 0) {
-          return candidate;
-        }
-      }
-
-      // Do a (potentially slow) check to confirm that the pooled connection is still good. If it
-      // isn't, take it out of the pool and start again.
-      if (!candidate.isHealthy(doExtensiveHealthChecks)) {
-        noNewStreams();
-        continue;
-      }
-
-      return candidate;
-    }
-  }
-
-  /**
-   * Returns a connection to host a new stream. This prefers the existing connection if it exists,
-   * then the pool, finally building a new connection.
-   */
-  private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout,
-      boolean connectionRetryEnabled) throws IOException, RouteException {
-    Route selectedRoute;
-    synchronized (connectionPool) {
-      if (released) throw new IllegalStateException("released");
-      if (stream != null) throw new IllegalStateException("stream != null");
-      if (canceled) throw new IOException("Canceled");
-
-      RealConnection allocatedConnection = this.connection;
-      if (allocatedConnection != null && !allocatedConnection.noNewStreams) {
-        return allocatedConnection;
-      }
-
-      // Attempt to get a connection from the pool.
-      RealConnection pooledConnection = Internal.instance.get(connectionPool, address, this);
-      if (pooledConnection != null) {
-        this.connection = pooledConnection;
-        return pooledConnection;
-      }
-
-      selectedRoute = route;
-    }
-
-    if (selectedRoute == null) {
-      selectedRoute = routeSelector.next();
-      synchronized (connectionPool) {
-        route = selectedRoute;
-        refusedStreamCount = 0;
-      }
-    }
-    RealConnection newConnection = new RealConnection(selectedRoute);
-    acquire(newConnection);
-
-    synchronized (connectionPool) {
-      Internal.instance.put(connectionPool, newConnection);
-      this.connection = newConnection;
-      if (canceled) throw new IOException("Canceled");
-    }
-
-    newConnection.connect(connectTimeout, readTimeout, writeTimeout, address.connectionSpecs(),
-        connectionRetryEnabled);
-    routeDatabase().connected(newConnection.route());
-
-    return newConnection;
-  }
-
-  public void streamFinished(boolean noNewStreams, HttpStream stream) {
-    synchronized (connectionPool) {
-      if (stream == null || stream != this.stream) {
-        throw new IllegalStateException("expected " + this.stream + " but was " + stream);
-      }
-      if (!noNewStreams) {
-        connection.successCount++;
-      }
-    }
-    deallocate(noNewStreams, false, true);
-  }
-
-  public HttpStream stream() {
-    synchronized (connectionPool) {
-      return stream;
-    }
-  }
-
-  private RouteDatabase routeDatabase() {
-    return Internal.instance.routeDatabase(connectionPool);
-  }
-
-  public synchronized RealConnection connection() {
-    return connection;
-  }
-
-  public void release() {
-    deallocate(false, true, false);
-  }
-
-  /** Forbid new streams from being created on the connection that hosts this allocation. */
-  public void noNewStreams() {
-    deallocate(true, false, false);
-  }
-
-  /**
-   * Releases resources held by this allocation. If sufficient resources are allocated, the
-   * connection will be detached or closed.
-   */
-  private void deallocate(boolean noNewStreams, boolean released, boolean streamFinished) {
-    RealConnection connectionToClose = null;
-    synchronized (connectionPool) {
-      if (streamFinished) {
-        this.stream = null;
-      }
-      if (released) {
-        this.released = true;
-      }
-      if (connection != null) {
-        if (noNewStreams) {
-          connection.noNewStreams = true;
-        }
-        if (this.stream == null && (this.released || connection.noNewStreams)) {
-          release(connection);
-          if (connection.allocations.isEmpty()) {
-            connection.idleAtNanos = System.nanoTime();
-            if (Internal.instance.connectionBecameIdle(connectionPool, connection)) {
-              connectionToClose = connection;
-            }
-          }
-          connection = null;
-        }
-      }
-    }
-    if (connectionToClose != null) {
-      Util.closeQuietly(connectionToClose.socket());
-    }
-  }
-
-  public void cancel() {
-    HttpStream streamToCancel;
-    RealConnection connectionToCancel;
-    synchronized (connectionPool) {
-      canceled = true;
-      streamToCancel = stream;
-      connectionToCancel = connection;
-    }
-    if (streamToCancel != null) {
-      streamToCancel.cancel();
-    } else if (connectionToCancel != null) {
-      connectionToCancel.cancel();
-    }
-  }
-
-  public void streamFailed(IOException e) {
-    boolean noNewStreams = false;
-
-    synchronized (connectionPool) {
-      if (e instanceof StreamResetException) {
-        StreamResetException streamResetException = (StreamResetException) e;
-        if (streamResetException.errorCode == ErrorCode.REFUSED_STREAM) {
-          refusedStreamCount++;
-        }
-        // On HTTP/2 stream errors, retry REFUSED_STREAM errors once on the same connection. All
-        // other errors must be retried on a new connection.
-        if (streamResetException.errorCode != ErrorCode.REFUSED_STREAM || refusedStreamCount > 1) {
-          noNewStreams = true;
-          route = null;
-        }
-      } else if (connection != null && !connection.isMultiplexed()) {
-        noNewStreams = true;
-
-        // If this route hasn't completed a call, avoid it for new connections.
-        if (connection.successCount == 0) {
-          if (route != null && e != null) {
-            routeSelector.connectFailed(route, e);
-          }
-          route = null;
-        }
-      }
-    }
-
-    deallocate(noNewStreams, false, true);
-  }
-
-  /**
-   * Use this allocation to hold {@code connection}. Each call to this must be paired with a call to
-   * {@link #release} on the same connection.
-   */
-  public void acquire(RealConnection connection) {
-    connection.allocations.add(new WeakReference<>(this));
-  }
-
-  /** Remove this allocation from the connection's list of allocations. */
-  private void release(RealConnection connection) {
-    for (int i = 0, size = connection.allocations.size(); i < size; i++) {
-      Reference<StreamAllocation> reference = connection.allocations.get(i);
-      if (reference.get() == this) {
-        connection.allocations.remove(i);
-        return;
-      }
-    }
-    throw new IllegalStateException();
-  }
-
-  public boolean hasMoreRoutes() {
-    return route != null || routeSelector.hasNext();
-  }
-
-  @Override public String toString() {
-    return address.toString();
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/framed/HttpOverSpdy3Test.java b/okhttp/src/main/java/okhttp3/internal/http/UnrepeatableRequestBody.java
similarity index 72%
rename from okhttp-tests/src/test/java/okhttp3/internal/framed/HttpOverSpdy3Test.java
rename to okhttp/src/main/java/okhttp3/internal/http/UnrepeatableRequestBody.java
index 6f7e793165..60b893fbf3 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/framed/HttpOverSpdy3Test.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/UnrepeatableRequestBody.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013 Square, Inc.
+ * Copyright (C) 2016 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,13 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.framed;
+package okhttp3.internal.http;
 
-import okhttp3.Protocol;
-
-public class HttpOverSpdy3Test extends HttpOverSpdyTest {
-
-  public HttpOverSpdy3Test() {
-    super(Protocol.SPDY_3);
-  }
+public interface UnrepeatableRequestBody {
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/http/Http1xStream.java b/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java
similarity index 75%
rename from okhttp/src/main/java/okhttp3/internal/http/Http1xStream.java
rename to okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java
index 320788755b..83780ff863 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/Http1xStream.java
+++ b/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java
@@ -13,18 +13,26 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.http;
+package okhttp3.internal.http1;
 
 import java.io.EOFException;
 import java.io.IOException;
 import java.net.ProtocolException;
 import okhttp3.Headers;
+import okhttp3.HttpUrl;
+import okhttp3.OkHttpClient;
 import okhttp3.Request;
 import okhttp3.Response;
 import okhttp3.ResponseBody;
 import okhttp3.internal.Internal;
 import okhttp3.internal.Util;
-import okhttp3.internal.io.RealConnection;
+import okhttp3.internal.connection.RealConnection;
+import okhttp3.internal.connection.StreamAllocation;
+import okhttp3.internal.http.HttpCodec;
+import okhttp3.internal.http.HttpHeaders;
+import okhttp3.internal.http.RealResponseBody;
+import okhttp3.internal.http.RequestLine;
+import okhttp3.internal.http.StatusLine;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -47,7 +55,7 @@
  *     <li>Open a sink to write the request body. Either {@linkplain #newFixedLengthSink
  *         fixed-length} or {@link #newChunkedSink chunked}.
  *     <li>Write to and then close that sink.
- *     <li>{@linkplain #readResponse Read response headers}.
+ *     <li>{@linkplain #readResponseHeaders Read response headers}.
  *     <li>Open a source to read the response body. Either {@linkplain #newFixedLengthSource
  *         fixed-length}, {@linkplain #newChunkedSource chunked} or {@linkplain
  *         #newUnknownLengthSource unknown length}.
@@ -58,7 +66,7 @@
  * Exchanges that do not have a response body can call {@link #newFixedLengthSource(long)
  * newFixedLengthSource(0)} and may skip reading and closing that source.
  */
-public final class Http1xStream implements HttpStream {
+public final class Http1Codec implements HttpCodec {
   private static final int STATE_IDLE = 0; // Idle connections are ready to write request headers.
   private static final int STATE_OPEN_REQUEST_BODY = 1;
   private static final int STATE_WRITING_REQUEST_BODY = 2;
@@ -66,25 +74,27 @@
   private static final int STATE_OPEN_RESPONSE_BODY = 4;
   private static final int STATE_READING_RESPONSE_BODY = 5;
   private static final int STATE_CLOSED = 6;
+  private static final int HEADER_LIMIT = 256 * 1024;
 
+  /** The client that configures this stream. May be null for HTTPS proxy tunnels. */
+  final OkHttpClient client;
   /** The stream allocation that owns this stream. May be null for HTTPS proxy tunnels. */
-  private final StreamAllocation streamAllocation;
-  private final BufferedSource source;
-  private final BufferedSink sink;
-  private HttpEngine httpEngine;
-  private int state = STATE_IDLE;
+  final StreamAllocation streamAllocation;
 
-  public Http1xStream(StreamAllocation streamAllocation, BufferedSource source, BufferedSink sink) {
+  final BufferedSource source;
+  final BufferedSink sink;
+  int state = STATE_IDLE;
+  private long headerLimit = HEADER_LIMIT;
+
+  public Http1Codec(OkHttpClient client, StreamAllocation streamAllocation, BufferedSource source,
+      BufferedSink sink) {
+    this.client = client;
     this.streamAllocation = streamAllocation;
     this.source = source;
     this.sink = sink;
   }
 
-  @Override public void setHttpEngine(HttpEngine httpEngine) {
-    this.httpEngine = httpEngine;
-  }
-
-  @Override public Sink createRequestBody(Request request, long contentLength) throws IOException {
+  @Override public Sink createRequestBody(Request request, long contentLength) {
     if ("chunked".equalsIgnoreCase(request.header("Transfer-Encoding"))) {
       // Stream a request body of unknown length.
       return newChunkedSink();
@@ -115,39 +125,32 @@ public Http1xStream(StreamAllocation streamAllocation, BufferedSource source, Bu
    * header field receives the proper value.
    */
   @Override public void writeRequestHeaders(Request request) throws IOException {
-    httpEngine.writingRequestHeaders();
     String requestLine = RequestLine.get(
-        request, httpEngine.getConnection().route().proxy().type());
+        request, streamAllocation.connection().route().proxy().type());
     writeRequest(request.headers(), requestLine);
   }
 
-  @Override public Response.Builder readResponseHeaders() throws IOException {
-    return readResponse();
-  }
-
   @Override public ResponseBody openResponseBody(Response response) throws IOException {
-    Source source = getTransferStream(response);
-    return new RealResponseBody(response.headers(), Okio.buffer(source));
-  }
+    streamAllocation.eventListener.responseBodyStart(streamAllocation.call);
+    String contentType = response.header("Content-Type");
 
-  private Source getTransferStream(Response response) throws IOException {
-    if (!HttpEngine.hasBody(response)) {
-      return newFixedLengthSource(0);
+    if (!HttpHeaders.hasBody(response)) {
+      Source source = newFixedLengthSource(0);
+      return new RealResponseBody(contentType, 0, Okio.buffer(source));
     }
 
     if ("chunked".equalsIgnoreCase(response.header("Transfer-Encoding"))) {
-      return newChunkedSource(httpEngine);
+      Source source = newChunkedSource(response.request().url());
+      return new RealResponseBody(contentType, -1L, Okio.buffer(source));
     }
 
-    long contentLength = OkHeaders.contentLength(response);
+    long contentLength = HttpHeaders.contentLength(response);
     if (contentLength != -1) {
-      return newFixedLengthSource(contentLength);
+      Source source = newFixedLengthSource(contentLength);
+      return new RealResponseBody(contentType, contentLength, Okio.buffer(source));
     }
 
-    // Wrap the input stream from the connection (rather than just returning
-    // "socketIn" directly here), so that we can control its use after the
-    // reference escapes.
-    return newUnknownLengthSource();
+    return new RealResponseBody(contentType, -1L, Okio.buffer(newUnknownLengthSource()));
   }
 
   /** Returns true if this connection is closed. */
@@ -155,6 +158,10 @@ public boolean isClosed() {
     return state == STATE_CLOSED;
   }
 
+  @Override public void flushRequest() throws IOException {
+    sink.flush();
+  }
+
   @Override public void finishRequest() throws IOException {
     sink.flush();
   }
@@ -173,27 +180,26 @@ public void writeRequest(Headers headers, String requestLine) throws IOException
     state = STATE_OPEN_REQUEST_BODY;
   }
 
-  /** Parses bytes of a response header from an HTTP transport. */
-  public Response.Builder readResponse() throws IOException {
+  @Override public Response.Builder readResponseHeaders(boolean expectContinue) throws IOException {
     if (state != STATE_OPEN_REQUEST_BODY && state != STATE_READ_RESPONSE_HEADERS) {
       throw new IllegalStateException("state: " + state);
     }
 
     try {
-      while (true) {
-        StatusLine statusLine = StatusLine.parse(source.readUtf8LineStrict());
-
-        Response.Builder responseBuilder = new Response.Builder()
-            .protocol(statusLine.protocol)
-            .code(statusLine.code)
-            .message(statusLine.message)
-            .headers(readHeaders());
-
-        if (statusLine.code != HTTP_CONTINUE) {
-          state = STATE_OPEN_RESPONSE_BODY;
-          return responseBuilder;
-        }
+      StatusLine statusLine = StatusLine.parse(readHeaderLine());
+
+      Response.Builder responseBuilder = new Response.Builder()
+          .protocol(statusLine.protocol)
+          .code(statusLine.code)
+          .message(statusLine.message)
+          .headers(readHeaders());
+
+      if (expectContinue && statusLine.code == HTTP_CONTINUE) {
+        return null;
       }
+
+      state = STATE_OPEN_RESPONSE_BODY;
+      return responseBuilder;
     } catch (EOFException e) {
       // Provide more context if the server ends the stream before sending a response.
       IOException exception = new IOException("unexpected end of stream on " + streamAllocation);
@@ -202,11 +208,17 @@ public void writeRequest(Headers headers, String requestLine) throws IOException
     }
   }
 
+  private String readHeaderLine() throws IOException {
+    String line = source.readUtf8LineStrict(headerLimit);
+    headerLimit -= line.length();
+    return line;
+  }
+
   /** Reads headers or trailers. */
   public Headers readHeaders() throws IOException {
     Headers.Builder headers = new Headers.Builder();
     // parse the result headers until the first blank line
-    for (String line; (line = source.readUtf8LineStrict()).length() != 0; ) {
+    for (String line; (line = readHeaderLine()).length() != 0; ) {
       Internal.instance.addLenient(headers, line);
     }
     return headers.build();
@@ -224,22 +236,16 @@ public Sink newFixedLengthSink(long contentLength) {
     return new FixedLengthSink(contentLength);
   }
 
-  @Override public void writeRequestBody(RetryableSink requestBody) throws IOException {
-    if (state != STATE_OPEN_REQUEST_BODY) throw new IllegalStateException("state: " + state);
-    state = STATE_READ_RESPONSE_HEADERS;
-    requestBody.writeToSocket(sink);
-  }
-
   public Source newFixedLengthSource(long length) throws IOException {
     if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
     state = STATE_READING_RESPONSE_BODY;
     return new FixedLengthSource(length);
   }
 
-  public Source newChunkedSource(HttpEngine httpEngine) throws IOException {
+  public Source newChunkedSource(HttpUrl url) throws IOException {
     if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
     state = STATE_READING_RESPONSE_BODY;
-    return new ChunkedSource(httpEngine);
+    return new ChunkedSource(url);
   }
 
   public Source newUnknownLengthSource() throws IOException {
@@ -255,7 +261,7 @@ public Source newUnknownLengthSource() throws IOException {
    * to the default configuration. Use this to avoid unexpected sharing of timeouts between pooled
    * connections.
    */
-  private void detachTimeout(ForwardingTimeout timeout) {
+  void detachTimeout(ForwardingTimeout timeout) {
     Timeout oldDelegate = timeout.delegate();
     timeout.setDelegate(Timeout.NONE);
     oldDelegate.clearDeadline();
@@ -268,7 +274,7 @@ private void detachTimeout(ForwardingTimeout timeout) {
     private boolean closed;
     private long bytesRemaining;
 
-    private FixedLengthSink(long bytesRemaining) {
+    FixedLengthSink(long bytesRemaining) {
       this.bytesRemaining = bytesRemaining;
     }
 
@@ -309,6 +315,9 @@ private FixedLengthSink(long bytesRemaining) {
     private final ForwardingTimeout timeout = new ForwardingTimeout(sink.timeout());
     private boolean closed;
 
+    ChunkedSink() {
+    }
+
     @Override public Timeout timeout() {
       return timeout;
     }
@@ -340,16 +349,30 @@ private FixedLengthSink(long bytesRemaining) {
   private abstract class AbstractSource implements Source {
     protected final ForwardingTimeout timeout = new ForwardingTimeout(source.timeout());
     protected boolean closed;
+    protected long bytesRead = 0;
 
     @Override public Timeout timeout() {
       return timeout;
     }
 
+    @Override public long read(Buffer sink, long byteCount) throws IOException {
+      try {
+        long read = source.read(sink, byteCount);
+        if (read > 0) {
+          bytesRead += read;
+        }
+        return read;
+      } catch (IOException e) {
+        endOfInput(false, e);
+        throw e;
+      }
+    }
+
     /**
      * Closes the cache entry and makes the socket available for reuse. This should be invoked when
      * the end of the body has been reached.
      */
-    protected final void endOfInput(boolean reuseConnection) throws IOException {
+    protected final void endOfInput(boolean reuseConnection, IOException e) throws IOException {
       if (state == STATE_CLOSED) return;
       if (state != STATE_READING_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
 
@@ -357,7 +380,7 @@ protected final void endOfInput(boolean reuseConnection) throws IOException {
 
       state = STATE_CLOSED;
       if (streamAllocation != null) {
-        streamAllocation.streamFinished(!reuseConnection, Http1xStream.this);
+        streamAllocation.streamFinished(!reuseConnection, Http1Codec.this, bytesRead, e);
       }
     }
   }
@@ -366,10 +389,10 @@ protected final void endOfInput(boolean reuseConnection) throws IOException {
   private class FixedLengthSource extends AbstractSource {
     private long bytesRemaining;
 
-    public FixedLengthSource(long length) throws IOException {
+    FixedLengthSource(long length) throws IOException {
       bytesRemaining = length;
       if (bytesRemaining == 0) {
-        endOfInput(true);
+        endOfInput(true, null);
       }
     }
 
@@ -378,15 +401,16 @@ public FixedLengthSource(long length) throws IOException {
       if (closed) throw new IllegalStateException("closed");
       if (bytesRemaining == 0) return -1;
 
-      long read = source.read(sink, Math.min(bytesRemaining, byteCount));
+      long read = super.read(sink, Math.min(bytesRemaining, byteCount));
       if (read == -1) {
-        endOfInput(false); // The server didn't supply the promised content length.
-        throw new ProtocolException("unexpected end of stream");
+        ProtocolException e = new ProtocolException("unexpected end of stream");
+        endOfInput(false, e); // The server didn't supply the promised content length.
+        throw e;
       }
 
       bytesRemaining -= read;
       if (bytesRemaining == 0) {
-        endOfInput(true);
+        endOfInput(true, null);
       }
       return read;
     }
@@ -395,7 +419,7 @@ public FixedLengthSource(long length) throws IOException {
       if (closed) return;
 
       if (bytesRemaining != 0 && !Util.discard(this, DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
-        endOfInput(false);
+        endOfInput(false, null);
       }
 
       closed = true;
@@ -405,12 +429,12 @@ public FixedLengthSource(long length) throws IOException {
   /** An HTTP body with alternating chunk sizes and chunk bodies. */
   private class ChunkedSource extends AbstractSource {
     private static final long NO_CHUNK_YET = -1L;
+    private final HttpUrl url;
     private long bytesRemainingInChunk = NO_CHUNK_YET;
     private boolean hasMoreChunks = true;
-    private final HttpEngine httpEngine;
 
-    ChunkedSource(HttpEngine httpEngine) throws IOException {
-      this.httpEngine = httpEngine;
+    ChunkedSource(HttpUrl url) {
+      this.url = url;
     }
 
     @Override public long read(Buffer sink, long byteCount) throws IOException {
@@ -423,10 +447,11 @@ public FixedLengthSource(long length) throws IOException {
         if (!hasMoreChunks) return -1;
       }
 
-      long read = source.read(sink, Math.min(byteCount, bytesRemainingInChunk));
+      long read = super.read(sink, Math.min(byteCount, bytesRemainingInChunk));
       if (read == -1) {
-        endOfInput(false); // The server didn't supply the promised chunk length.
-        throw new ProtocolException("unexpected end of stream");
+        ProtocolException e = new ProtocolException("unexpected end of stream");
+        endOfInput(false, e); // The server didn't supply the promised chunk length.
+        throw e;
       }
       bytesRemainingInChunk -= read;
       return read;
@@ -449,15 +474,15 @@ private void readChunkSize() throws IOException {
       }
       if (bytesRemainingInChunk == 0L) {
         hasMoreChunks = false;
-        httpEngine.receiveHeaders(readHeaders());
-        endOfInput(true);
+        HttpHeaders.receiveHeaders(client.cookieJar(), url, readHeaders());
+        endOfInput(true, null);
       }
     }
 
     @Override public void close() throws IOException {
       if (closed) return;
       if (hasMoreChunks && !Util.discard(this, DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
-        endOfInput(false);
+        endOfInput(false, null);
       }
       closed = true;
     }
@@ -467,16 +492,19 @@ private void readChunkSize() throws IOException {
   private class UnknownLengthSource extends AbstractSource {
     private boolean inputExhausted;
 
+    UnknownLengthSource() {
+    }
+
     @Override public long read(Buffer sink, long byteCount)
         throws IOException {
       if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
       if (closed) throw new IllegalStateException("closed");
       if (inputExhausted) return -1;
 
-      long read = source.read(sink, byteCount);
+      long read = super.read(sink, byteCount);
       if (read == -1) {
         inputExhausted = true;
-        endOfInput(true);
+        endOfInput(true, null);
         return -1;
       }
       return read;
@@ -485,7 +513,7 @@ private void readChunkSize() throws IOException {
     @Override public void close() throws IOException {
       if (closed) return;
       if (!inputExhausted) {
-        endOfInput(false);
+        endOfInput(false, null);
       }
       closed = true;
     }
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/ConnectionShutdownException.java b/okhttp/src/main/java/okhttp3/internal/http2/ConnectionShutdownException.java
new file mode 100644
index 0000000000..00c4f2441c
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http2/ConnectionShutdownException.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http2;
+
+import java.io.IOException;
+
+/**
+ * Thrown when an HTTP/2 connection is shutdown (either explicitly or if the peer has sent a GOAWAY
+ * frame) and an attempt is made to use the connection.
+ */
+public final class ConnectionShutdownException extends IOException {
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/ErrorCode.java b/okhttp/src/main/java/okhttp3/internal/http2/ErrorCode.java
new file mode 100644
index 0000000000..6a704684fc
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http2/ErrorCode.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http2;
+
+// http://tools.ietf.org/html/draft-ietf-httpbis-http2-17#section-7
+public enum ErrorCode {
+  /** Not an error! */
+  NO_ERROR(0),
+
+  PROTOCOL_ERROR(1),
+
+  INTERNAL_ERROR(2),
+
+  FLOW_CONTROL_ERROR(3),
+
+  REFUSED_STREAM(7),
+
+  CANCEL(8),
+
+  COMPRESSION_ERROR(9),
+
+  CONNECT_ERROR(0xa),
+
+  ENHANCE_YOUR_CALM(0xb),
+
+  INADEQUATE_SECURITY(0xc),
+
+  HTTP_1_1_REQUIRED(0xd);
+
+  public final int httpCode;
+
+  ErrorCode(int httpCode) {
+    this.httpCode = httpCode;
+  }
+
+  public static ErrorCode fromHttp2(int code) {
+    for (ErrorCode errorCode : ErrorCode.values()) {
+      if (errorCode.httpCode == code) return errorCode;
+    }
+    return null;
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/Header.java b/okhttp/src/main/java/okhttp3/internal/http2/Header.java
similarity index 88%
rename from okhttp/src/main/java/okhttp3/internal/framed/Header.java
rename to okhttp/src/main/java/okhttp3/internal/http2/Header.java
index 866edc2591..3cfd7be8d7 100644
--- a/okhttp/src/main/java/okhttp3/internal/framed/Header.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Header.java
@@ -13,21 +13,20 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.framed;
+package okhttp3.internal.http2;
 
 import okhttp3.internal.Util;
 import okio.ByteString;
 
 /** HTTP header: the name is an ASCII string, but the value can be UTF-8. */
 public final class Header {
-  // Special header names defined in the SPDY and HTTP/2 specs.
+  // Special header names defined in HTTP/2 spec.
+  public static final ByteString PSEUDO_PREFIX = ByteString.encodeUtf8(":");
   public static final ByteString RESPONSE_STATUS = ByteString.encodeUtf8(":status");
   public static final ByteString TARGET_METHOD = ByteString.encodeUtf8(":method");
   public static final ByteString TARGET_PATH = ByteString.encodeUtf8(":path");
   public static final ByteString TARGET_SCHEME = ByteString.encodeUtf8(":scheme");
-  public static final ByteString TARGET_AUTHORITY = ByteString.encodeUtf8(":authority"); // HTTP/2
-  public static final ByteString TARGET_HOST = ByteString.encodeUtf8(":host"); // spdy/3
-  public static final ByteString VERSION = ByteString.encodeUtf8(":version"); // spdy/3
+  public static final ByteString TARGET_AUTHORITY = ByteString.encodeUtf8(":authority");
 
   /** Name in case-insensitive ASCII encoding. */
   public final ByteString name;
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/Hpack.java b/okhttp/src/main/java/okhttp3/internal/http2/Hpack.java
similarity index 64%
rename from okhttp/src/main/java/okhttp3/internal/framed/Hpack.java
rename to okhttp/src/main/java/okhttp3/internal/http2/Hpack.java
index 2b49784e9b..a28698bf01 100644
--- a/okhttp/src/main/java/okhttp3/internal/framed/Hpack.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Hpack.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.framed;
+package okhttp3.internal.http2;
 
 import java.io.IOException;
 import java.util.ArrayList;
@@ -22,6 +22,7 @@
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
+import okhttp3.internal.Util;
 import okio.Buffer;
 import okio.BufferedSource;
 import okio.ByteString;
@@ -43,7 +44,7 @@
   private static final int PREFIX_6_BITS = 0x3f;
   private static final int PREFIX_7_BITS = 0x7f;
 
-  private static final Header[] STATIC_HEADER_TABLE = new Header[] {
+  static final Header[] STATIC_HEADER_TABLE = new Header[] {
       new Header(Header.TARGET_AUTHORITY, ""),
       new Header(Header.TARGET_METHOD, "GET"),
       new Header(Header.TARGET_METHOD, "POST"),
@@ -116,8 +117,9 @@ private Hpack() {
     private final List<Header> headerList = new ArrayList<>();
     private final BufferedSource source;
 
-    private int headerTableSizeSetting;
+    private final int headerTableSizeSetting;
     private int maxDynamicTableByteCount;
+
     // Visible for testing.
     Header[] dynamicTable = new Header[8];
     // Array is populated back to front, so new entries always have lowest index.
@@ -126,8 +128,12 @@ private Hpack() {
     int dynamicTableByteCount = 0;
 
     Reader(int headerTableSizeSetting, Source source) {
+      this(headerTableSizeSetting, headerTableSizeSetting, source);
+    }
+
+    Reader(int headerTableSizeSetting, int maxDynamicTableByteCount, Source source) {
       this.headerTableSizeSetting = headerTableSizeSetting;
-      this.maxDynamicTableByteCount = headerTableSizeSetting;
+      this.maxDynamicTableByteCount = maxDynamicTableByteCount;
       this.source = Okio.buffer(source);
     }
 
@@ -135,19 +141,6 @@ int maxDynamicTableByteCount() {
       return maxDynamicTableByteCount;
     }
 
-    /**
-     * Called by the reader when the peer sent {@link Settings#HEADER_TABLE_SIZE}. While this
-     * establishes the maximum dynamic table size, the {@link #maxDynamicTableByteCount} set during
-     * processing may limit the table size to a smaller amount.
-     *
-     * <p>Evicts entries or clears the table as needed.
-     */
-    void headerTableSizeSetting(int headerTableSizeSetting) {
-      this.headerTableSizeSetting = headerTableSizeSetting;
-      this.maxDynamicTableByteCount = headerTableSizeSetting;
-      adjustDynamicTableByteCount();
-    }
-
     private void adjustDynamicTableByteCount() {
       if (maxDynamicTableByteCount < dynamicTableByteCount) {
         if (maxDynamicTableByteCount == 0) {
@@ -159,7 +152,6 @@ private void adjustDynamicTableByteCount() {
     }
 
     private void clearDynamicTable() {
-      headerList.clear();
       Arrays.fill(dynamicTable, null);
       nextHeaderIndex = dynamicTable.length - 1;
       headerCount = 0;
@@ -354,7 +346,7 @@ ByteString readByteString() throws IOException {
     }
   }
 
-  private static final Map<ByteString, Integer> NAME_TO_FIRST_INDEX = nameToFirstIndex();
+  static final Map<ByteString, Integer> NAME_TO_FIRST_INDEX = nameToFirstIndex();
 
   private static Map<ByteString, Integer> nameToFirstIndex() {
     Map<ByteString, Integer> result = new LinkedHashMap<>(STATIC_HEADER_TABLE.length);
@@ -367,33 +359,171 @@ ByteString readByteString() throws IOException {
   }
 
   static final class Writer {
+    private static final int SETTINGS_HEADER_TABLE_SIZE = 4096;
+
+    /**
+     * The decoder has ultimate control of the maximum size of the dynamic table but we can choose
+     * to use less. We'll put a cap at 16K. This is arbitrary but should be enough for most
+     * purposes.
+     */
+    private static final int SETTINGS_HEADER_TABLE_SIZE_LIMIT = 16384;
+
     private final Buffer out;
+    private final boolean useCompression;
+
+    /**
+     * In the scenario where the dynamic table size changes multiple times between transmission of
+     * header blocks, we need to keep track of the smallest value in that interval.
+     */
+    private int smallestHeaderTableSizeSetting = Integer.MAX_VALUE;
+    private boolean emitDynamicTableSizeUpdate;
+
+    int headerTableSizeSetting;
+    int maxDynamicTableByteCount;
+
+    // Visible for testing.
+    Header[] dynamicTable = new Header[8];
+    // Array is populated back to front, so new entries always have lowest index.
+    int nextHeaderIndex = dynamicTable.length - 1;
+    int headerCount = 0;
+    int dynamicTableByteCount = 0;
 
     Writer(Buffer out) {
+      this(SETTINGS_HEADER_TABLE_SIZE, true, out);
+    }
+
+    Writer(int headerTableSizeSetting, boolean useCompression, Buffer out) {
+      this.headerTableSizeSetting = headerTableSizeSetting;
+      this.maxDynamicTableByteCount = headerTableSizeSetting;
+      this.useCompression = useCompression;
       this.out = out;
     }
 
+    private void clearDynamicTable() {
+      Arrays.fill(dynamicTable, null);
+      nextHeaderIndex = dynamicTable.length - 1;
+      headerCount = 0;
+      dynamicTableByteCount = 0;
+    }
+
+    /** Returns the count of entries evicted. */
+    private int evictToRecoverBytes(int bytesToRecover) {
+      int entriesToEvict = 0;
+      if (bytesToRecover > 0) {
+        // determine how many headers need to be evicted.
+        for (int j = dynamicTable.length - 1; j >= nextHeaderIndex && bytesToRecover > 0; j--) {
+          bytesToRecover -= dynamicTable[j].hpackSize;
+          dynamicTableByteCount -= dynamicTable[j].hpackSize;
+          headerCount--;
+          entriesToEvict++;
+        }
+        System.arraycopy(dynamicTable, nextHeaderIndex + 1, dynamicTable,
+            nextHeaderIndex + 1 + entriesToEvict, headerCount);
+        Arrays.fill(dynamicTable, nextHeaderIndex + 1, nextHeaderIndex + 1 + entriesToEvict, null);
+        nextHeaderIndex += entriesToEvict;
+      }
+      return entriesToEvict;
+    }
+
+    private void insertIntoDynamicTable(Header entry) {
+      int delta = entry.hpackSize;
+
+      // if the new or replacement header is too big, drop all entries.
+      if (delta > maxDynamicTableByteCount) {
+        clearDynamicTable();
+        return;
+      }
+
+      // Evict headers to the required length.
+      int bytesToRecover = (dynamicTableByteCount + delta) - maxDynamicTableByteCount;
+      evictToRecoverBytes(bytesToRecover);
+
+      if (headerCount + 1 > dynamicTable.length) { // Need to grow the dynamic table.
+        Header[] doubled = new Header[dynamicTable.length * 2];
+        System.arraycopy(dynamicTable, 0, doubled, dynamicTable.length, dynamicTable.length);
+        nextHeaderIndex = dynamicTable.length - 1;
+        dynamicTable = doubled;
+      }
+      int index = nextHeaderIndex--;
+      dynamicTable[index] = entry;
+      headerCount++;
+      dynamicTableByteCount += delta;
+    }
+
     /** This does not use "never indexed" semantics for sensitive headers. */
     // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#section-6.2.3
     void writeHeaders(List<Header> headerBlock) throws IOException {
-      // TODO: implement index tracking
+      if (emitDynamicTableSizeUpdate) {
+        if (smallestHeaderTableSizeSetting < maxDynamicTableByteCount) {
+          // Multiple dynamic table size updates!
+          writeInt(smallestHeaderTableSizeSetting, PREFIX_5_BITS, 0x20);
+        }
+        emitDynamicTableSizeUpdate = false;
+        smallestHeaderTableSizeSetting = Integer.MAX_VALUE;
+        writeInt(maxDynamicTableByteCount, PREFIX_5_BITS, 0x20);
+      }
+
       for (int i = 0, size = headerBlock.size(); i < size; i++) {
-        ByteString name = headerBlock.get(i).name.toAsciiLowercase();
+        Header header = headerBlock.get(i);
+        ByteString name = header.name.toAsciiLowercase();
+        ByteString value = header.value;
+        int headerIndex = -1;
+        int headerNameIndex = -1;
+
         Integer staticIndex = NAME_TO_FIRST_INDEX.get(name);
         if (staticIndex != null) {
-          // Literal Header Field without Indexing - Indexed Name.
-          writeInt(staticIndex + 1, PREFIX_4_BITS, 0);
-          writeByteString(headerBlock.get(i).value);
-        } else {
-          out.writeByte(0x00); // Literal Header without Indexing - New Name.
+          headerNameIndex = staticIndex + 1;
+          if (headerNameIndex > 1 && headerNameIndex < 8) {
+            // Only search a subset of the static header table. Most entries have an empty value, so
+            // it's unnecessary to waste cycles looking at them. This check is built on the
+            // observation that the header entries we care about are in adjacent pairs, and we
+            // always know the first index of the pair.
+            if (Util.equal(STATIC_HEADER_TABLE[headerNameIndex - 1].value, value)) {
+              headerIndex = headerNameIndex;
+            } else if (Util.equal(STATIC_HEADER_TABLE[headerNameIndex].value, value)) {
+              headerIndex = headerNameIndex + 1;
+            }
+          }
+        }
+
+        if (headerIndex == -1) {
+          for (int j = nextHeaderIndex + 1, length = dynamicTable.length; j < length; j++) {
+            if (Util.equal(dynamicTable[j].name, name)) {
+              if (Util.equal(dynamicTable[j].value, value)) {
+                headerIndex = j - nextHeaderIndex + STATIC_HEADER_TABLE.length;
+                break;
+              } else if (headerNameIndex == -1) {
+                headerNameIndex = j - nextHeaderIndex + STATIC_HEADER_TABLE.length;
+              }
+            }
+          }
+        }
+
+        if (headerIndex != -1) {
+          // Indexed Header Field.
+          writeInt(headerIndex, PREFIX_7_BITS, 0x80);
+        } else if (headerNameIndex == -1) {
+          // Literal Header Field with Incremental Indexing - New Name.
+          out.writeByte(0x40);
           writeByteString(name);
-          writeByteString(headerBlock.get(i).value);
+          writeByteString(value);
+          insertIntoDynamicTable(header);
+        } else if (name.startsWith(Header.PSEUDO_PREFIX) && !Header.TARGET_AUTHORITY.equals(name)) {
+          // Follow Chromes lead - only include the :authority pseudo header, but exclude all other
+          // pseudo headers. Literal Header Field without Indexing - Indexed Name.
+          writeInt(headerNameIndex, PREFIX_4_BITS, 0);
+          writeByteString(value);
+        } else {
+          // Literal Header Field with Incremental Indexing - Indexed Name.
+          writeInt(headerNameIndex, PREFIX_6_BITS, 0x40);
+          writeByteString(value);
+          insertIntoDynamicTable(header);
         }
       }
     }
 
     // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#section-4.1.1
-    void writeInt(int value, int prefixMask, int bits) throws IOException {
+    void writeInt(int value, int prefixMask, int bits) {
       // Write the raw value for a single byte value.
       if (value < prefixMask) {
         out.writeByte(bits | value);
@@ -414,8 +544,42 @@ void writeInt(int value, int prefixMask, int bits) throws IOException {
     }
 
     void writeByteString(ByteString data) throws IOException {
-      writeInt(data.size(), PREFIX_7_BITS, 0);
-      out.write(data);
+      if (useCompression && Huffman.get().encodedLength(data) < data.size()) {
+        Buffer huffmanBuffer = new Buffer();
+        Huffman.get().encode(data, huffmanBuffer);
+        ByteString huffmanBytes = huffmanBuffer.readByteString();
+        writeInt(huffmanBytes.size(), PREFIX_7_BITS, 0x80);
+        out.write(huffmanBytes);
+      } else {
+        writeInt(data.size(), PREFIX_7_BITS, 0);
+        out.write(data);
+      }
+    }
+
+    void setHeaderTableSizeSetting(int headerTableSizeSetting) {
+      this.headerTableSizeSetting = headerTableSizeSetting;
+      int effectiveHeaderTableSize = Math.min(headerTableSizeSetting,
+          SETTINGS_HEADER_TABLE_SIZE_LIMIT);
+
+      if (maxDynamicTableByteCount == effectiveHeaderTableSize) return; // No change.
+
+      if (effectiveHeaderTableSize < maxDynamicTableByteCount) {
+        smallestHeaderTableSizeSetting = Math.min(smallestHeaderTableSizeSetting,
+            effectiveHeaderTableSize);
+      }
+      emitDynamicTableSizeUpdate = true;
+      maxDynamicTableByteCount = effectiveHeaderTableSize;
+      adjustDynamicTableByteCount();
+    }
+
+    private void adjustDynamicTableByteCount() {
+      if (maxDynamicTableByteCount < dynamicTableByteCount) {
+        if (maxDynamicTableByteCount == 0) {
+          clearDynamicTable();
+        } else {
+          evictToRecoverBytes(dynamicTableByteCount - maxDynamicTableByteCount);
+        }
+      }
     }
   }
 
@@ -423,7 +587,7 @@ void writeByteString(ByteString data) throws IOException {
    * An HTTP/2 response cannot contain uppercase header characters and must be treated as
    * malformed.
    */
-  private static ByteString checkLowercase(ByteString name) throws IOException {
+  static ByteString checkLowercase(ByteString name) throws IOException {
     for (int i = 0, length = name.size(); i < length; i++) {
       byte c = name.getByte(i);
       if (c >= 'A' && c <= 'Z') {
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2.java
new file mode 100644
index 0000000000..cecee406ce
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2.java
@@ -0,0 +1,167 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http2;
+
+import java.io.IOException;
+import okio.ByteString;
+
+import static okhttp3.internal.Util.format;
+
+public final class Http2 {
+  static final ByteString CONNECTION_PREFACE
+      = ByteString.encodeUtf8("PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n");
+
+  /** The initial max frame size, applied independently writing to, or reading from the peer. */
+  static final int INITIAL_MAX_FRAME_SIZE = 0x4000; // 16384
+
+  static final byte TYPE_DATA = 0x0;
+  static final byte TYPE_HEADERS = 0x1;
+  static final byte TYPE_PRIORITY = 0x2;
+  static final byte TYPE_RST_STREAM = 0x3;
+  static final byte TYPE_SETTINGS = 0x4;
+  static final byte TYPE_PUSH_PROMISE = 0x5;
+  static final byte TYPE_PING = 0x6;
+  static final byte TYPE_GOAWAY = 0x7;
+  static final byte TYPE_WINDOW_UPDATE = 0x8;
+  static final byte TYPE_CONTINUATION = 0x9;
+
+  static final byte FLAG_NONE = 0x0;
+  static final byte FLAG_ACK = 0x1; // Used for settings and ping.
+  static final byte FLAG_END_STREAM = 0x1; // Used for headers and data.
+  static final byte FLAG_END_HEADERS = 0x4; // Used for headers and continuation.
+  static final byte FLAG_END_PUSH_PROMISE = 0x4;
+  static final byte FLAG_PADDED = 0x8; // Used for headers and data.
+  static final byte FLAG_PRIORITY = 0x20; // Used for headers.
+  static final byte FLAG_COMPRESSED = 0x20; // Used for data.
+
+  /** Lookup table for valid frame types. */
+  private static final String[] FRAME_NAMES = new String[] {
+      "DATA",
+      "HEADERS",
+      "PRIORITY",
+      "RST_STREAM",
+      "SETTINGS",
+      "PUSH_PROMISE",
+      "PING",
+      "GOAWAY",
+      "WINDOW_UPDATE",
+      "CONTINUATION"
+  };
+
+  /**
+   * Lookup table for valid flags for DATA, HEADERS, CONTINUATION. Invalid combinations are
+   * represented in binary.
+   */
+  static final String[] FLAGS = new String[0x40]; // Highest bit flag is 0x20.
+  static final String[] BINARY = new String[256];
+  static {
+    for (int i = 0; i < BINARY.length; i++) {
+      BINARY[i] = format("%8s", Integer.toBinaryString(i)).replace(' ', '0');
+    }
+
+    FLAGS[FLAG_NONE] = "";
+    FLAGS[FLAG_END_STREAM] = "END_STREAM";
+
+    int[] prefixFlags = new int[] {FLAG_END_STREAM};
+
+    FLAGS[FLAG_PADDED] = "PADDED";
+    for (int prefixFlag : prefixFlags) {
+      FLAGS[prefixFlag | FLAG_PADDED] = FLAGS[prefixFlag] + "|PADDED";
+    }
+
+    FLAGS[FLAG_END_HEADERS] = "END_HEADERS"; // Same as END_PUSH_PROMISE.
+    FLAGS[FLAG_PRIORITY] = "PRIORITY"; // Same as FLAG_COMPRESSED.
+    FLAGS[FLAG_END_HEADERS | FLAG_PRIORITY] = "END_HEADERS|PRIORITY"; // Only valid on HEADERS.
+    int[] frameFlags = new int[] {
+        FLAG_END_HEADERS, FLAG_PRIORITY, FLAG_END_HEADERS | FLAG_PRIORITY
+    };
+
+    for (int frameFlag : frameFlags) {
+      for (int prefixFlag : prefixFlags) {
+        FLAGS[prefixFlag | frameFlag] = FLAGS[prefixFlag] + '|' + FLAGS[frameFlag];
+        FLAGS[prefixFlag | frameFlag | FLAG_PADDED]
+            = FLAGS[prefixFlag] + '|' + FLAGS[frameFlag] + "|PADDED";
+      }
+    }
+
+    for (int i = 0; i < FLAGS.length; i++) { // Fill in holes with binary representation.
+      if (FLAGS[i] == null) FLAGS[i] = BINARY[i];
+    }
+  }
+
+  private Http2() {
+  }
+
+  static IllegalArgumentException illegalArgument(String message, Object... args) {
+    throw new IllegalArgumentException(format(message, args));
+  }
+
+  static IOException ioException(String message, Object... args) throws IOException {
+    throw new IOException(format(message, args));
+  }
+
+  /**
+   * Returns human-readable representation of HTTP/2 frame headers.
+   *
+   * <p>The format is:
+   *
+   * <pre>
+   *   direction streamID length type flags
+   * </pre>
+   *
+   * Where direction is {@code <<} for inbound and {@code >>} for outbound.
+   *
+   * <p>For example, the following would indicate a HEAD request sent from the client.
+   * <pre>
+   * {@code
+   *   << 0x0000000f    12 HEADERS       END_HEADERS|END_STREAM
+   * }
+   * </pre>
+   */
+  static String frameLog(boolean inbound, int streamId, int length, byte type, byte flags) {
+    String formattedType = type < FRAME_NAMES.length ? FRAME_NAMES[type] : format("0x%02x", type);
+    String formattedFlags = formatFlags(type, flags);
+    return format("%s 0x%08x %5d %-13s %s", inbound ? "<<" : ">>", streamId, length,
+        formattedType, formattedFlags);
+  }
+
+  /**
+   * Looks up valid string representing flags from the table. Invalid combinations are represented
+   * in binary.
+   */
+  // Visible for testing.
+  static String formatFlags(byte type, byte flags) {
+    if (flags == 0) return "";
+    switch (type) { // Special case types that have 0 or 1 flag.
+      case TYPE_SETTINGS:
+      case TYPE_PING:
+        return flags == FLAG_ACK ? "ACK" : BINARY[flags];
+      case TYPE_PRIORITY:
+      case TYPE_RST_STREAM:
+      case TYPE_GOAWAY:
+      case TYPE_WINDOW_UPDATE:
+        return BINARY[flags];
+    }
+    String result = flags < FLAGS.length ? FLAGS[flags] : BINARY[flags];
+    // Special case types that have overlap flag values.
+    if (type == TYPE_PUSH_PROMISE && (flags & FLAG_END_PUSH_PROMISE) != 0) {
+      return result.replace("HEADERS", "PUSH_PROMISE"); // TODO: Avoid allocation.
+    } else if (type == TYPE_DATA && (flags & FLAG_COMPRESSED) != 0) {
+      return result.replace("PRIORITY", "COMPRESSED"); // TODO: Avoid allocation.
+    }
+    return result;
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java
new file mode 100644
index 0000000000..5268aa2c91
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java
@@ -0,0 +1,232 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http2;
+
+import java.io.IOException;
+import java.net.ProtocolException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Locale;
+import java.util.concurrent.TimeUnit;
+import okhttp3.Headers;
+import okhttp3.Interceptor;
+import okhttp3.OkHttpClient;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+import okhttp3.internal.Internal;
+import okhttp3.internal.Util;
+import okhttp3.internal.connection.StreamAllocation;
+import okhttp3.internal.http.HttpCodec;
+import okhttp3.internal.http.HttpHeaders;
+import okhttp3.internal.http.RealResponseBody;
+import okhttp3.internal.http.RequestLine;
+import okhttp3.internal.http.StatusLine;
+import okio.Buffer;
+import okio.ByteString;
+import okio.ForwardingSource;
+import okio.Okio;
+import okio.Sink;
+import okio.Source;
+
+import static okhttp3.internal.http.StatusLine.HTTP_CONTINUE;
+import static okhttp3.internal.http2.Header.RESPONSE_STATUS;
+import static okhttp3.internal.http2.Header.TARGET_AUTHORITY;
+import static okhttp3.internal.http2.Header.TARGET_METHOD;
+import static okhttp3.internal.http2.Header.TARGET_PATH;
+import static okhttp3.internal.http2.Header.TARGET_SCHEME;
+
+/** Encode requests and responses using HTTP/2 frames. */
+public final class Http2Codec implements HttpCodec {
+  private static final ByteString CONNECTION = ByteString.encodeUtf8("connection");
+  private static final ByteString HOST = ByteString.encodeUtf8("host");
+  private static final ByteString KEEP_ALIVE = ByteString.encodeUtf8("keep-alive");
+  private static final ByteString PROXY_CONNECTION = ByteString.encodeUtf8("proxy-connection");
+  private static final ByteString TRANSFER_ENCODING = ByteString.encodeUtf8("transfer-encoding");
+  private static final ByteString TE = ByteString.encodeUtf8("te");
+  private static final ByteString ENCODING = ByteString.encodeUtf8("encoding");
+  private static final ByteString UPGRADE = ByteString.encodeUtf8("upgrade");
+
+  /** See http://tools.ietf.org/html/draft-ietf-httpbis-http2-09#section-8.1.3. */
+  private static final List<ByteString> HTTP_2_SKIPPED_REQUEST_HEADERS = Util.immutableList(
+      CONNECTION,
+      HOST,
+      KEEP_ALIVE,
+      PROXY_CONNECTION,
+      TE,
+      TRANSFER_ENCODING,
+      ENCODING,
+      UPGRADE,
+      TARGET_METHOD,
+      TARGET_PATH,
+      TARGET_SCHEME,
+      TARGET_AUTHORITY);
+  private static final List<ByteString> HTTP_2_SKIPPED_RESPONSE_HEADERS = Util.immutableList(
+      CONNECTION,
+      HOST,
+      KEEP_ALIVE,
+      PROXY_CONNECTION,
+      TE,
+      TRANSFER_ENCODING,
+      ENCODING,
+      UPGRADE);
+
+  private final OkHttpClient client;
+  private final Interceptor.Chain chain;
+  final StreamAllocation streamAllocation;
+  private final Http2Connection connection;
+  private Http2Stream stream;
+
+  public Http2Codec(OkHttpClient client, Interceptor.Chain chain, StreamAllocation streamAllocation,
+      Http2Connection connection) {
+    this.client = client;
+    this.chain = chain;
+    this.streamAllocation = streamAllocation;
+    this.connection = connection;
+  }
+
+  @Override public Sink createRequestBody(Request request, long contentLength) {
+    return stream.getSink();
+  }
+
+  @Override public void writeRequestHeaders(Request request) throws IOException {
+    if (stream != null) return;
+
+    boolean hasRequestBody = request.body() != null;
+    List<Header> requestHeaders = http2HeadersList(request);
+    stream = connection.newStream(requestHeaders, hasRequestBody);
+    stream.readTimeout().timeout(chain.readTimeoutMillis(), TimeUnit.MILLISECONDS);
+    stream.writeTimeout().timeout(chain.writeTimeoutMillis(), TimeUnit.MILLISECONDS);
+  }
+
+  @Override public void flushRequest() throws IOException {
+    connection.flush();
+  }
+
+  @Override public void finishRequest() throws IOException {
+    stream.getSink().close();
+  }
+
+  @Override public Response.Builder readResponseHeaders(boolean expectContinue) throws IOException {
+    List<Header> headers = stream.takeResponseHeaders();
+    Response.Builder responseBuilder = readHttp2HeadersList(headers);
+    if (expectContinue && Internal.instance.code(responseBuilder) == HTTP_CONTINUE) {
+      return null;
+    }
+    return responseBuilder;
+  }
+
+  public static List<Header> http2HeadersList(Request request) {
+    Headers headers = request.headers();
+    List<Header> result = new ArrayList<>(headers.size() + 4);
+    result.add(new Header(TARGET_METHOD, request.method()));
+    result.add(new Header(TARGET_PATH, RequestLine.requestPath(request.url())));
+    String host = request.header("Host");
+    if (host != null) {
+      result.add(new Header(TARGET_AUTHORITY, host)); // Optional.
+    }
+    result.add(new Header(TARGET_SCHEME, request.url().scheme()));
+
+    for (int i = 0, size = headers.size(); i < size; i++) {
+      // header names must be lowercase.
+      ByteString name = ByteString.encodeUtf8(headers.name(i).toLowerCase(Locale.US));
+      if (!HTTP_2_SKIPPED_REQUEST_HEADERS.contains(name)) {
+        result.add(new Header(name, headers.value(i)));
+      }
+    }
+    return result;
+  }
+
+  /** Returns headers for a name value block containing an HTTP/2 response. */
+  public static Response.Builder readHttp2HeadersList(List<Header> headerBlock) throws IOException {
+    StatusLine statusLine = null;
+    Headers.Builder headersBuilder = new Headers.Builder();
+    for (int i = 0, size = headerBlock.size(); i < size; i++) {
+      Header header = headerBlock.get(i);
+
+      // If there were multiple header blocks they will be delimited by nulls. Discard existing
+      // header blocks if the existing header block is a '100 Continue' intermediate response.
+      if (header == null) {
+        if (statusLine != null && statusLine.code == HTTP_CONTINUE) {
+          statusLine = null;
+          headersBuilder = new Headers.Builder();
+        }
+        continue;
+      }
+
+      ByteString name = header.name;
+      String value = header.value.utf8();
+      if (name.equals(RESPONSE_STATUS)) {
+        statusLine = StatusLine.parse("HTTP/1.1 " + value);
+      } else if (!HTTP_2_SKIPPED_RESPONSE_HEADERS.contains(name)) {
+        Internal.instance.addLenient(headersBuilder, name.utf8(), value);
+      }
+    }
+    if (statusLine == null) throw new ProtocolException("Expected ':status' header not present");
+
+    return new Response.Builder()
+        .protocol(Protocol.HTTP_2)
+        .code(statusLine.code)
+        .message(statusLine.message)
+        .headers(headersBuilder.build());
+  }
+
+  @Override public ResponseBody openResponseBody(Response response) throws IOException {
+    streamAllocation.eventListener.responseBodyStart(streamAllocation.call);
+    String contentType = response.header("Content-Type");
+    long contentLength = HttpHeaders.contentLength(response);
+    Source source = new StreamFinishingSource(stream.getSource());
+    return new RealResponseBody(contentType, contentLength, Okio.buffer(source));
+  }
+
+  @Override public void cancel() {
+    if (stream != null) stream.closeLater(ErrorCode.CANCEL);
+  }
+
+  class StreamFinishingSource extends ForwardingSource {
+    boolean completed = false;
+    long bytesRead = 0;
+
+    StreamFinishingSource(Source delegate) {
+      super(delegate);
+    }
+
+    @Override public long read(Buffer sink, long byteCount) throws IOException {
+      try {
+        long read = delegate().read(sink, byteCount);
+        if (read > 0) {
+          bytesRead += read;
+        }
+        return read;
+      } catch (IOException e) {
+        endOfInput(e);
+        throw e;
+      }
+    }
+
+    @Override public void close() throws IOException {
+      super.close();
+      endOfInput(null);
+    }
+
+    private void endOfInput(IOException e) {
+      if (completed) return;
+      completed = true;
+      streamAllocation.streamFinished(false, Http2Codec.this, bytesRead, e);
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/FramedConnection.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java
similarity index 68%
rename from okhttp/src/main/java/okhttp3/internal/framed/FramedConnection.java
rename to okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java
index 336f466cdf..a79b3b7608 100644
--- a/okhttp/src/main/java/okhttp3/internal/framed/FramedConnection.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java
@@ -13,14 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.framed;
+package okhttp3.internal.http2;
 
 import java.io.Closeable;
 import java.io.IOException;
 import java.io.InterruptedIOException;
 import java.net.InetSocketAddress;
 import java.net.Socket;
-import java.util.HashMap;
+import java.util.LinkedHashMap;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
@@ -32,27 +32,27 @@
 import java.util.concurrent.TimeUnit;
 import okhttp3.Protocol;
 import okhttp3.internal.NamedRunnable;
-import okhttp3.internal.Platform;
 import okhttp3.internal.Util;
+import okhttp3.internal.platform.Platform;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
 import okio.ByteString;
 import okio.Okio;
 
-import static okhttp3.internal.Platform.INFO;
-import static okhttp3.internal.framed.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
+import static okhttp3.internal.http2.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
+import static okhttp3.internal.platform.Platform.INFO;
 
 /**
  * A socket connection to a remote peer. A connection hosts streams which can send and receive
  * data.
  *
  * <p>Many methods in this API are <strong>synchronous:</strong> the call is completed before the
- * method returns. This is typical for Java but atypical for SPDY. This is motivated by exception
+ * method returns. This is typical for Java but atypical for HTTP/2. This is motivated by exception
  * transparency: an IOException that was triggered by a certain caller can be caught and handled by
  * that caller.
  */
-public final class FramedConnection implements Closeable {
+public final class Http2Connection implements Closeable {
 
   // Internal state of this connection is guarded by 'this'. No blocking
   // operations may be performed while holding this lock!
@@ -66,12 +66,9 @@
   // operations must synchronize on 'this' last. This ensures that we never
   // wait for a blocking operation while holding 'this'.
 
-  private static final ExecutorService executor = new ThreadPoolExecutor(0,
+  static final ExecutorService executor = new ThreadPoolExecutor(0,
       Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(),
-      Util.threadFactory("OkHttp FramedConnection", true));
-
-  /** The protocol variant, like {@link Spdy3}. */
-  final Protocol protocol;
+      Util.threadFactory("OkHttp Http2Connection", true));
 
   /** True if this peer initiated the connection. */
   final boolean client;
@@ -80,12 +77,12 @@
    * User code to run in response to incoming streams or settings. Calls to this are always invoked
    * on {@link #executor}.
    */
-  private final Listener listener;
-  private final Map<Integer, FramedStream> streams = new HashMap<>();
-  private final String hostname;
-  private int lastGoodStreamId;
-  private int nextStreamId;
-  private boolean shutdown;
+  final Listener listener;
+  final Map<Integer, Http2Stream> streams = new LinkedHashMap<>();
+  final String hostname;
+  int lastGoodStreamId;
+  int nextStreamId;
+  boolean shutdown;
 
   /** Ensures push promise callbacks events are sent in order per stream. */
   private final ExecutorService pushExecutor;
@@ -93,7 +90,7 @@
   /** Lazily-created map of in-flight pings awaiting a response. Guarded by this. */
   private Map<Integer, Ping> pings;
   /** User code to run in response to push promise events. */
-  private final PushObserver pushObserver;
+  final PushObserver pushObserver;
   private int nextPingId;
 
   /**
@@ -118,22 +115,20 @@
   // TODO: MWS will need to guard on this setting before attempting to push.
   final Settings peerSettings = new Settings();
 
-  private boolean receivedInitialPeerSettings = false;
-  final Variant variant;
+  boolean receivedInitialPeerSettings = false;
   final Socket socket;
-  final FrameWriter frameWriter;
+  final Http2Writer writer;
 
   // Visible for testing
-  final Reader readerRunnable;
+  final ReaderRunnable readerRunnable;
 
-  private FramedConnection(Builder builder) throws IOException {
-    protocol = builder.protocol;
+  Http2Connection(Builder builder) {
     pushObserver = builder.pushObserver;
     client = builder.client;
     listener = builder.listener;
     // http://tools.ietf.org/html/draft-ietf-httpbis-http2-17#section-5.1.1
     nextStreamId = builder.client ? 1 : 2;
-    if (builder.client && protocol == Protocol.HTTP_2) {
+    if (builder.client) {
       nextStreamId += 2; // In HTTP/2, 1 on client is reserved for Upgrade.
     }
 
@@ -144,51 +139,42 @@ private FramedConnection(Builder builder) throws IOException {
     // thrashing window updates every 64KiB, yet small enough to avoid blowing
     // up the heap.
     if (builder.client) {
-      okHttpSettings.set(Settings.INITIAL_WINDOW_SIZE, 0, OKHTTP_CLIENT_WINDOW_SIZE);
+      okHttpSettings.set(Settings.INITIAL_WINDOW_SIZE, OKHTTP_CLIENT_WINDOW_SIZE);
     }
 
     hostname = builder.hostname;
 
-    if (protocol == Protocol.HTTP_2) {
-      variant = new Http2();
-      // Like newSingleThreadExecutor, except lazy creates the thread.
-      pushExecutor = new ThreadPoolExecutor(0, 1, 60, TimeUnit.SECONDS,
-          new LinkedBlockingQueue<Runnable>(),
-          Util.threadFactory(Util.format("OkHttp %s Push Observer", hostname), true));
-      // 1 less than SPDY http://tools.ietf.org/html/draft-ietf-httpbis-http2-17#section-6.9.2
-      peerSettings.set(Settings.INITIAL_WINDOW_SIZE, 0, 65535);
-      peerSettings.set(Settings.MAX_FRAME_SIZE, 0, Http2.INITIAL_MAX_FRAME_SIZE);
-    } else if (protocol == Protocol.SPDY_3) {
-      variant = new Spdy3();
-      pushExecutor = null;
-    } else {
-      throw new AssertionError(protocol);
-    }
-    bytesLeftInWriteWindow = peerSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE);
+    // Like newSingleThreadExecutor, except lazy creates the thread.
+    pushExecutor = new ThreadPoolExecutor(0, 1, 60, TimeUnit.SECONDS,
+        new LinkedBlockingQueue<Runnable>(),
+        Util.threadFactory(Util.format("OkHttp %s Push Observer", hostname), true));
+    peerSettings.set(Settings.INITIAL_WINDOW_SIZE, DEFAULT_INITIAL_WINDOW_SIZE);
+    peerSettings.set(Settings.MAX_FRAME_SIZE, Http2.INITIAL_MAX_FRAME_SIZE);
+    bytesLeftInWriteWindow = peerSettings.getInitialWindowSize();
     socket = builder.socket;
-    frameWriter = variant.newWriter(builder.sink, client);
+    writer = new Http2Writer(builder.sink, client);
 
-    readerRunnable = new Reader(variant.newReader(builder.source, client));
+    readerRunnable = new ReaderRunnable(new Http2Reader(builder.source, client));
   }
 
   /** The protocol as selected using ALPN. */
   public Protocol getProtocol() {
-    return protocol;
+    return Protocol.HTTP_2;
   }
 
   /**
-   * Returns the number of {@link FramedStream#isOpen() open streams} on this connection.
+   * Returns the number of {@link Http2Stream#isOpen() open streams} on this connection.
    */
   public synchronized int openStreamCount() {
     return streams.size();
   }
 
-  synchronized FramedStream getStream(int id) {
+  synchronized Http2Stream getStream(int id) {
     return streams.get(id);
   }
 
-  synchronized FramedStream removeStream(int streamId) {
-    FramedStream stream = streams.remove(streamId);
+  synchronized Http2Stream removeStream(int streamId) {
+    Http2Stream stream = streams.remove(streamId);
     notifyAll(); // The removed stream may be blocked on a connection-wide window update.
     return stream;
   }
@@ -204,59 +190,53 @@ public synchronized int maxConcurrentStreams() {
    * @param out true to create an output stream that we can use to send data to the remote peer.
    * Corresponds to {@code FLAG_FIN}.
    */
-  public FramedStream pushStream(int associatedStreamId, List<Header> requestHeaders, boolean out)
+  public Http2Stream pushStream(int associatedStreamId, List<Header> requestHeaders, boolean out)
       throws IOException {
     if (client) throw new IllegalStateException("Client cannot push requests.");
-    if (protocol != Protocol.HTTP_2) throw new IllegalStateException("protocol != HTTP_2");
-    return newStream(associatedStreamId, requestHeaders, out, false);
+    return newStream(associatedStreamId, requestHeaders, out);
   }
 
   /**
    * Returns a new locally-initiated stream.
-   *
    * @param out true to create an output stream that we can use to send data to the remote peer.
    * Corresponds to {@code FLAG_FIN}.
-   * @param in true to create an input stream that the remote peer can use to send data to us.
-   * Corresponds to {@code FLAG_UNIDIRECTIONAL}.
    */
-  public FramedStream newStream(List<Header> requestHeaders, boolean out, boolean in)
-      throws IOException {
-    return newStream(0, requestHeaders, out, in);
+  public Http2Stream newStream(List<Header> requestHeaders, boolean out) throws IOException {
+    return newStream(0, requestHeaders, out);
   }
 
-  private FramedStream newStream(int associatedStreamId, List<Header> requestHeaders, boolean out,
-      boolean in) throws IOException {
+  private Http2Stream newStream(
+      int associatedStreamId, List<Header> requestHeaders, boolean out) throws IOException {
     boolean outFinished = !out;
-    boolean inFinished = !in;
+    boolean inFinished = false;
     boolean flushHeaders;
-    FramedStream stream;
+    Http2Stream stream;
     int streamId;
 
-    synchronized (frameWriter) {
+    synchronized (writer) {
       synchronized (this) {
         if (shutdown) {
-          throw new IOException("shutdown");
+          throw new ConnectionShutdownException();
         }
         streamId = nextStreamId;
         nextStreamId += 2;
-        stream = new FramedStream(streamId, this, outFinished, inFinished, requestHeaders);
+        stream = new Http2Stream(streamId, this, outFinished, inFinished, requestHeaders);
         flushHeaders = !out || bytesLeftInWriteWindow == 0L || stream.bytesLeftInWriteWindow == 0L;
         if (stream.isOpen()) {
           streams.put(streamId, stream);
         }
       }
       if (associatedStreamId == 0) {
-        frameWriter.synStream(outFinished, inFinished, streamId, associatedStreamId,
-            requestHeaders);
+        writer.synStream(outFinished, streamId, associatedStreamId, requestHeaders);
       } else if (client) {
         throw new IllegalArgumentException("client streams shouldn't have associated stream IDs");
       } else { // HTTP/2 has a PUSH_PROMISE frame.
-        frameWriter.pushPromise(associatedStreamId, streamId, requestHeaders);
+        writer.pushPromise(associatedStreamId, streamId, requestHeaders);
       }
     }
 
     if (flushHeaders) {
-      frameWriter.flush();
+      writer.flush();
     }
 
     return stream;
@@ -264,7 +244,7 @@ private FramedStream newStream(int associatedStreamId, List<Header> requestHeade
 
   void writeSynReply(int streamId, boolean outFinished, List<Header> alternating)
       throws IOException {
-    frameWriter.synReply(outFinished, streamId, alternating);
+    writer.synReply(outFinished, streamId, alternating);
   }
 
   /**
@@ -282,13 +262,13 @@ void writeSynReply(int streamId, boolean outFinished, List<Header> alternating)
   public void writeData(int streamId, boolean outFinished, Buffer buffer, long byteCount)
       throws IOException {
     if (byteCount == 0) { // Empty data frames are not flow-controlled.
-      frameWriter.data(outFinished, streamId, buffer, 0);
+      writer.data(outFinished, streamId, buffer, 0);
       return;
     }
 
     while (byteCount > 0) {
       int toWrite;
-      synchronized (FramedConnection.this) {
+      synchronized (Http2Connection.this) {
         try {
           while (bytesLeftInWriteWindow <= 0) {
             // Before blocking, confirm that the stream we're writing is still open. It's possible
@@ -296,19 +276,19 @@ public void writeData(int streamId, boolean outFinished, Buffer buffer, long byt
             if (!streams.containsKey(streamId)) {
               throw new IOException("stream closed");
             }
-            FramedConnection.this.wait(); // Wait until we receive a WINDOW_UPDATE.
+            Http2Connection.this.wait(); // Wait until we receive a WINDOW_UPDATE.
           }
         } catch (InterruptedException e) {
           throw new InterruptedIOException();
         }
 
         toWrite = (int) Math.min(byteCount, bytesLeftInWriteWindow);
-        toWrite = Math.min(toWrite, frameWriter.maxDataLength());
+        toWrite = Math.min(toWrite, writer.maxDataLength());
         bytesLeftInWriteWindow -= toWrite;
       }
 
       byteCount -= toWrite;
-      frameWriter.data(outFinished && byteCount == 0, streamId, buffer, toWrite);
+      writer.data(outFinished && byteCount == 0, streamId, buffer, toWrite);
     }
   }
 
@@ -317,11 +297,11 @@ public void writeData(int streamId, boolean outFinished, Buffer buffer, long byt
    */
   void addBytesToWriteWindow(long delta) {
     bytesLeftInWriteWindow += delta;
-    if (delta > 0) FramedConnection.this.notifyAll();
+    if (delta > 0) Http2Connection.this.notifyAll();
   }
 
   void writeSynResetLater(final int streamId, final ErrorCode errorCode) {
-    executor.submit(new NamedRunnable("OkHttp %s stream %d", hostname, streamId) {
+    executor.execute(new NamedRunnable("OkHttp %s stream %d", hostname, streamId) {
       @Override public void execute() {
         try {
           writeSynReset(streamId, errorCode);
@@ -332,14 +312,14 @@ void writeSynResetLater(final int streamId, final ErrorCode errorCode) {
   }
 
   void writeSynReset(int streamId, ErrorCode statusCode) throws IOException {
-    frameWriter.rstStream(streamId, statusCode);
+    writer.rstStream(streamId, statusCode);
   }
 
   void writeWindowUpdateLater(final int streamId, final long unacknowledgedBytesRead) {
     executor.execute(new NamedRunnable("OkHttp Window Update %s stream %d", hostname, streamId) {
       @Override public void execute() {
         try {
-          frameWriter.windowUpdate(streamId, unacknowledgedBytesRead);
+          writer.windowUpdate(streamId, unacknowledgedBytesRead);
         } catch (IOException ignored) {
         }
       }
@@ -355,18 +335,18 @@ public Ping ping() throws IOException {
     int pingId;
     synchronized (this) {
       if (shutdown) {
-        throw new IOException("shutdown");
+        throw new ConnectionShutdownException();
       }
       pingId = nextPingId;
       nextPingId += 2;
-      if (pings == null) pings = new HashMap<>();
+      if (pings == null) pings = new LinkedHashMap<>();
       pings.put(pingId, ping);
     }
     writePing(false, pingId, 0x4f4b6f6b /* ASCII "OKok" */, ping);
     return ping;
   }
 
-  private void writePingLater(
+  void writePingLater(
       final boolean reply, final int payload1, final int payload2, final Ping ping) {
     executor.execute(new NamedRunnable("OkHttp %s ping %08x%08x",
         hostname, payload1, payload2) {
@@ -379,20 +359,20 @@ private void writePingLater(
     });
   }
 
-  private void writePing(boolean reply, int payload1, int payload2, Ping ping) throws IOException {
-    synchronized (frameWriter) {
+  void writePing(boolean reply, int payload1, int payload2, Ping ping) throws IOException {
+    synchronized (writer) {
       // Observe the sent time immediately before performing I/O.
       if (ping != null) ping.send();
-      frameWriter.ping(reply, payload1, payload2);
+      writer.ping(reply, payload1, payload2);
     }
   }
 
-  private synchronized Ping removePing(int id) {
+  synchronized Ping removePing(int id) {
     return pings != null ? pings.remove(id) : null;
   }
 
   public void flush() throws IOException {
-    frameWriter.flush();
+    writer.flush();
   }
 
   /**
@@ -401,7 +381,7 @@ public void flush() throws IOException {
    * to gracefully stop accepting new requests without harming previously established streams.
    */
   public void shutdown(ErrorCode statusCode) throws IOException {
-    synchronized (frameWriter) {
+    synchronized (writer) {
       int lastGoodStreamId;
       synchronized (this) {
         if (shutdown) {
@@ -410,8 +390,9 @@ public void shutdown(ErrorCode statusCode) throws IOException {
         shutdown = true;
         lastGoodStreamId = this.lastGoodStreamId;
       }
-      // TODO: propagate exception message into debugData
-      frameWriter.goAway(lastGoodStreamId, statusCode, Util.EMPTY_BYTE_ARRAY);
+      // TODO: propagate exception message into debugData.
+      // TODO: configure a timeout on the reader so that it doesn’t block forever.
+      writer.goAway(lastGoodStreamId, statusCode, Util.EMPTY_BYTE_ARRAY);
     }
   }
 
@@ -423,7 +404,7 @@ public void shutdown(ErrorCode statusCode) throws IOException {
     close(ErrorCode.NO_ERROR, ErrorCode.CANCEL);
   }
 
-  private void close(ErrorCode connectionCode, ErrorCode streamCode) throws IOException {
+  void close(ErrorCode connectionCode, ErrorCode streamCode) throws IOException {
     assert (!Thread.holdsLock(this));
     IOException thrown = null;
     try {
@@ -432,11 +413,11 @@ private void close(ErrorCode connectionCode, ErrorCode streamCode) throws IOExce
       thrown = e;
     }
 
-    FramedStream[] streamsToClose = null;
+    Http2Stream[] streamsToClose = null;
     Ping[] pingsToCancel = null;
     synchronized (this) {
       if (!streams.isEmpty()) {
-        streamsToClose = streams.values().toArray(new FramedStream[streams.size()]);
+        streamsToClose = streams.values().toArray(new Http2Stream[streams.size()]);
         streams.clear();
       }
       if (pings != null) {
@@ -446,7 +427,7 @@ private void close(ErrorCode connectionCode, ErrorCode streamCode) throws IOExce
     }
 
     if (streamsToClose != null) {
-      for (FramedStream stream : streamsToClose) {
+      for (Http2Stream stream : streamsToClose) {
         try {
           stream.close(streamCode);
         } catch (IOException e) {
@@ -463,7 +444,7 @@ private void close(ErrorCode connectionCode, ErrorCode streamCode) throws IOExce
 
     // Close the writer to release its resources (such as deflaters).
     try {
-      frameWriter.close();
+      writer.close();
     } catch (IOException e) {
       if (thrown == null) thrown = e;
     }
@@ -492,11 +473,11 @@ public void start() throws IOException {
    */
   void start(boolean sendConnectionPreface) throws IOException {
     if (sendConnectionPreface) {
-      frameWriter.connectionPreface();
-      frameWriter.settings(okHttpSettings);
-      int windowSize = okHttpSettings.getInitialWindowSize(Settings.DEFAULT_INITIAL_WINDOW_SIZE);
+      writer.connectionPreface();
+      writer.settings(okHttpSettings);
+      int windowSize = okHttpSettings.getInitialWindowSize();
       if (windowSize != Settings.DEFAULT_INITIAL_WINDOW_SIZE) {
-        frameWriter.windowUpdate(0, windowSize - Settings.DEFAULT_INITIAL_WINDOW_SIZE);
+        writer.windowUpdate(0, windowSize - Settings.DEFAULT_INITIAL_WINDOW_SIZE);
       }
     }
     new Thread(readerRunnable).start(); // Not a daemon thread.
@@ -504,32 +485,35 @@ void start(boolean sendConnectionPreface) throws IOException {
 
   /** Merges {@code settings} into this peer's settings and sends them to the remote peer. */
   public void setSettings(Settings settings) throws IOException {
-    synchronized (frameWriter) {
+    synchronized (writer) {
       synchronized (this) {
         if (shutdown) {
-          throw new IOException("shutdown");
+          throw new ConnectionShutdownException();
         }
         okHttpSettings.merge(settings);
-        frameWriter.settings(settings);
+        writer.settings(settings);
       }
     }
   }
 
+  public synchronized boolean isShutdown() {
+    return shutdown;
+  }
+
   public static class Builder {
-    private Socket socket;
-    private String hostname;
-    private BufferedSource source;
-    private BufferedSink sink;
-    private Listener listener = Listener.REFUSE_INCOMING_STREAMS;
-    private Protocol protocol = Protocol.SPDY_3;
-    private PushObserver pushObserver = PushObserver.CANCEL;
-    private boolean client;
+    Socket socket;
+    String hostname;
+    BufferedSource source;
+    BufferedSink sink;
+    Listener listener = Listener.REFUSE_INCOMING_STREAMS;
+    PushObserver pushObserver = PushObserver.CANCEL;
+    boolean client;
 
     /**
      * @param client true if this peer initiated the connection; false if this peer accepted the
      * connection.
      */
-    public Builder(boolean client) throws IOException {
+    public Builder(boolean client) {
       this.client = client;
     }
 
@@ -552,18 +536,13 @@ public Builder listener(Listener listener) {
       return this;
     }
 
-    public Builder protocol(Protocol protocol) {
-      this.protocol = protocol;
-      return this;
-    }
-
     public Builder pushObserver(PushObserver pushObserver) {
       this.pushObserver = pushObserver;
       return this;
     }
 
-    public FramedConnection build() throws IOException {
-      return new FramedConnection(this);
+    public Http2Connection build() {
+      return new Http2Connection(this);
     }
   }
 
@@ -571,22 +550,20 @@ public FramedConnection build() throws IOException {
    * Methods in this class must not lock FrameWriter.  If a method needs to write a frame, create an
    * async task to do so.
    */
-  class Reader extends NamedRunnable implements FrameReader.Handler {
-    final FrameReader frameReader;
+  class ReaderRunnable extends NamedRunnable implements Http2Reader.Handler {
+    final Http2Reader reader;
 
-    private Reader(FrameReader frameReader) {
+    ReaderRunnable(Http2Reader reader) {
       super("OkHttp %s", hostname);
-      this.frameReader = frameReader;
+      this.reader = reader;
     }
 
     @Override protected void execute() {
       ErrorCode connectionErrorCode = ErrorCode.INTERNAL_ERROR;
       ErrorCode streamErrorCode = ErrorCode.INTERNAL_ERROR;
       try {
-        if (!client) {
-          frameReader.readConnectionPreface();
-        }
-        while (frameReader.nextFrame(this)) {
+        reader.readConnectionPreface(this);
+        while (reader.nextFrame(false, this)) {
         }
         connectionErrorCode = ErrorCode.NO_ERROR;
         streamErrorCode = ErrorCode.CANCEL;
@@ -598,7 +575,7 @@ private Reader(FrameReader frameReader) {
           close(connectionErrorCode, streamErrorCode);
         } catch (IOException ignored) {
         }
-        Util.closeQuietly(frameReader);
+        Util.closeQuietly(reader);
       }
     }
 
@@ -608,9 +585,9 @@ private Reader(FrameReader frameReader) {
         pushDataLater(streamId, source, length, inFinished);
         return;
       }
-      FramedStream dataStream = getStream(streamId);
+      Http2Stream dataStream = getStream(streamId);
       if (dataStream == null) {
-        writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);
+        writeSynResetLater(streamId, ErrorCode.PROTOCOL_ERROR);
         source.skip(length);
         return;
       }
@@ -620,25 +597,19 @@ private Reader(FrameReader frameReader) {
       }
     }
 
-    @Override public void headers(boolean outFinished, boolean inFinished, int streamId,
-        int associatedStreamId, List<Header> headerBlock, HeadersMode headersMode) {
+    @Override public void headers(boolean inFinished, int streamId, int associatedStreamId,
+        List<Header> headerBlock) {
       if (pushedStream(streamId)) {
         pushHeadersLater(streamId, headerBlock, inFinished);
         return;
       }
-      FramedStream stream;
-      synchronized (FramedConnection.this) {
-        // If we're shutdown, don't bother with this stream.
-        if (shutdown) return;
-
+      Http2Stream stream;
+      synchronized (Http2Connection.this) {
         stream = getStream(streamId);
 
         if (stream == null) {
-          // The headers claim to be for an existing stream, but we don't have one.
-          if (headersMode.failIfStreamAbsent()) {
-            writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);
-            return;
-          }
+          // If we're shutdown, don't bother with this stream.
+          if (shutdown) return;
 
           // If the stream ID is less than the last created ID, assume it's already closed.
           if (streamId <= lastGoodStreamId) return;
@@ -647,9 +618,8 @@ private Reader(FrameReader frameReader) {
           if (streamId % 2 == nextStreamId % 2) return;
 
           // Create a stream.
-          final FramedStream
-              newStream = new FramedStream(streamId, FramedConnection.this, outFinished,
-              inFinished, headerBlock);
+          final Http2Stream newStream = new Http2Stream(streamId, Http2Connection.this,
+              false, inFinished, headerBlock);
           lastGoodStreamId = streamId;
           streams.put(streamId, newStream);
           executor.execute(new NamedRunnable("OkHttp %s stream %d", hostname, streamId) {
@@ -657,7 +627,7 @@ private Reader(FrameReader frameReader) {
               try {
                 listener.onStream(newStream);
               } catch (IOException e) {
-                Platform.get().log(INFO, "FramedConnection.Listener failure for " + hostname, e);
+                Platform.get().log(INFO, "Http2Connection.Listener failure for " + hostname, e);
                 try {
                   newStream.close(ErrorCode.PROTOCOL_ERROR);
                 } catch (IOException ignored) {
@@ -669,15 +639,8 @@ private Reader(FrameReader frameReader) {
         }
       }
 
-      // The headers claim to be for a new stream, but we already have one.
-      if (headersMode.failIfStreamPresent()) {
-        stream.closeLater(ErrorCode.PROTOCOL_ERROR);
-        removeStream(streamId);
-        return;
-      }
-
       // Update an existing stream.
-      stream.receiveHeaders(headerBlock, headersMode);
+      stream.receiveHeaders(headerBlock);
       if (inFinished) stream.receiveFin();
     }
 
@@ -686,7 +649,7 @@ private Reader(FrameReader frameReader) {
         pushResetLater(streamId, errorCode);
         return;
       }
-      FramedStream rstStream = removeStream(streamId);
+      Http2Stream rstStream = removeStream(streamId);
       if (rstStream != null) {
         rstStream.receiveRstStream(errorCode);
       }
@@ -694,15 +657,13 @@ private Reader(FrameReader frameReader) {
 
     @Override public void settings(boolean clearPrevious, Settings newSettings) {
       long delta = 0;
-      FramedStream[] streamsToNotify = null;
-      synchronized (FramedConnection.this) {
-        int priorWriteWindowSize = peerSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE);
+      Http2Stream[] streamsToNotify = null;
+      synchronized (Http2Connection.this) {
+        int priorWriteWindowSize = peerSettings.getInitialWindowSize();
         if (clearPrevious) peerSettings.clear();
         peerSettings.merge(newSettings);
-        if (getProtocol() == Protocol.HTTP_2) {
-          ackSettingsLater(newSettings);
-        }
-        int peerInitialWindowSize = peerSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE);
+        applyAndAckSettings(newSettings);
+        int peerInitialWindowSize = peerSettings.getInitialWindowSize();
         if (peerInitialWindowSize != -1 && peerInitialWindowSize != priorWriteWindowSize) {
           delta = peerInitialWindowSize - priorWriteWindowSize;
           if (!receivedInitialPeerSettings) {
@@ -710,17 +671,17 @@ private Reader(FrameReader frameReader) {
             receivedInitialPeerSettings = true;
           }
           if (!streams.isEmpty()) {
-            streamsToNotify = streams.values().toArray(new FramedStream[streams.size()]);
+            streamsToNotify = streams.values().toArray(new Http2Stream[streams.size()]);
           }
         }
         executor.execute(new NamedRunnable("OkHttp %s settings", hostname) {
           @Override public void execute() {
-            listener.onSettings(FramedConnection.this);
+            listener.onSettings(Http2Connection.this);
           }
         });
       }
       if (streamsToNotify != null && delta != 0) {
-        for (FramedStream stream : streamsToNotify) {
+        for (Http2Stream stream : streamsToNotify) {
           synchronized (stream) {
             stream.addBytesToWriteWindow(delta);
           }
@@ -728,11 +689,11 @@ private Reader(FrameReader frameReader) {
       }
     }
 
-    private void ackSettingsLater(final Settings peerSettings) {
+    private void applyAndAckSettings(final Settings peerSettings) {
       executor.execute(new NamedRunnable("OkHttp %s ACK Settings", hostname) {
         @Override public void execute() {
           try {
-            frameWriter.ackSettings(peerSettings);
+            writer.applyAndAckSettings(peerSettings);
           } catch (IOException ignored) {
           }
         }
@@ -760,29 +721,29 @@ private void ackSettingsLater(final Settings peerSettings) {
       }
 
       // Copy the streams first. We don't want to hold a lock when we call receiveRstStream().
-      FramedStream[] streamsCopy;
-      synchronized (FramedConnection.this) {
-        streamsCopy = streams.values().toArray(new FramedStream[streams.size()]);
+      Http2Stream[] streamsCopy;
+      synchronized (Http2Connection.this) {
+        streamsCopy = streams.values().toArray(new Http2Stream[streams.size()]);
         shutdown = true;
       }
 
       // Fail all streams created after the last good stream ID.
-      for (FramedStream framedStream : streamsCopy) {
-        if (framedStream.getId() > lastGoodStreamId && framedStream.isLocallyInitiated()) {
-          framedStream.receiveRstStream(ErrorCode.REFUSED_STREAM);
-          removeStream(framedStream.getId());
+      for (Http2Stream http2Stream : streamsCopy) {
+        if (http2Stream.getId() > lastGoodStreamId && http2Stream.isLocallyInitiated()) {
+          http2Stream.receiveRstStream(ErrorCode.REFUSED_STREAM);
+          removeStream(http2Stream.getId());
         }
       }
     }
 
     @Override public void windowUpdate(int streamId, long windowSizeIncrement) {
       if (streamId == 0) {
-        synchronized (FramedConnection.this) {
+        synchronized (Http2Connection.this) {
           bytesLeftInWriteWindow += windowSizeIncrement;
-          FramedConnection.this.notifyAll();
+          Http2Connection.this.notifyAll();
         }
       } else {
-        FramedStream stream = getStream(streamId);
+        Http2Stream stream = getStream(streamId);
         if (stream != null) {
           synchronized (stream) {
             stream.addBytesToWriteWindow(windowSizeIncrement);
@@ -808,14 +769,14 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> request
   }
 
   /** Even, positive numbered streams are pushed streams in HTTP/2. */
-  private boolean pushedStream(int streamId) {
-    return protocol == Protocol.HTTP_2 && streamId != 0 && (streamId & 1) == 0;
+  boolean pushedStream(int streamId) {
+    return streamId != 0 && (streamId & 1) == 0;
   }
 
   // Guarded by this.
-  private final Set<Integer> currentPushRequests = new LinkedHashSet<>();
+  final Set<Integer> currentPushRequests = new LinkedHashSet<>();
 
-  private void pushRequestLater(final int streamId, final List<Header> requestHeaders) {
+  void pushRequestLater(final int streamId, final List<Header> requestHeaders) {
     synchronized (this) {
       if (currentPushRequests.contains(streamId)) {
         writeSynResetLater(streamId, ErrorCode.PROTOCOL_ERROR);
@@ -828,8 +789,8 @@ private void pushRequestLater(final int streamId, final List<Header> requestHead
         boolean cancel = pushObserver.onRequest(streamId, requestHeaders);
         try {
           if (cancel) {
-            frameWriter.rstStream(streamId, ErrorCode.CANCEL);
-            synchronized (FramedConnection.this) {
+            writer.rstStream(streamId, ErrorCode.CANCEL);
+            synchronized (Http2Connection.this) {
               currentPushRequests.remove(streamId);
             }
           }
@@ -839,15 +800,15 @@ private void pushRequestLater(final int streamId, final List<Header> requestHead
     });
   }
 
-  private void pushHeadersLater(final int streamId, final List<Header> requestHeaders,
+  void pushHeadersLater(final int streamId, final List<Header> requestHeaders,
       final boolean inFinished) {
     pushExecutor.execute(new NamedRunnable("OkHttp %s Push Headers[%s]", hostname, streamId) {
       @Override public void execute() {
         boolean cancel = pushObserver.onHeaders(streamId, requestHeaders, inFinished);
         try {
-          if (cancel) frameWriter.rstStream(streamId, ErrorCode.CANCEL);
+          if (cancel) writer.rstStream(streamId, ErrorCode.CANCEL);
           if (cancel || inFinished) {
-            synchronized (FramedConnection.this) {
+            synchronized (Http2Connection.this) {
               currentPushRequests.remove(streamId);
             }
           }
@@ -861,7 +822,7 @@ private void pushHeadersLater(final int streamId, final List<Header> requestHead
    * Eagerly reads {@code byteCount} bytes from the source before launching a background task to
    * process the data.  This avoids corrupting the stream.
    */
-  private void pushDataLater(final int streamId, final BufferedSource source, final int byteCount,
+  void pushDataLater(final int streamId, final BufferedSource source, final int byteCount,
       final boolean inFinished) throws IOException {
     final Buffer buffer = new Buffer();
     source.require(byteCount); // Eagerly read the frame before firing client thread.
@@ -871,9 +832,9 @@ private void pushDataLater(final int streamId, final BufferedSource source, fina
       @Override public void execute() {
         try {
           boolean cancel = pushObserver.onData(streamId, buffer, byteCount, inFinished);
-          if (cancel) frameWriter.rstStream(streamId, ErrorCode.CANCEL);
+          if (cancel) writer.rstStream(streamId, ErrorCode.CANCEL);
           if (cancel || inFinished) {
-            synchronized (FramedConnection.this) {
+            synchronized (Http2Connection.this) {
               currentPushRequests.remove(streamId);
             }
           }
@@ -883,11 +844,11 @@ private void pushDataLater(final int streamId, final BufferedSource source, fina
     });
   }
 
-  private void pushResetLater(final int streamId, final ErrorCode errorCode) {
+  void pushResetLater(final int streamId, final ErrorCode errorCode) {
     pushExecutor.execute(new NamedRunnable("OkHttp %s Push Reset[%s]", hostname, streamId) {
       @Override public void execute() {
         pushObserver.onReset(streamId, errorCode);
-        synchronized (FramedConnection.this) {
+        synchronized (Http2Connection.this) {
           currentPushRequests.remove(streamId);
         }
       }
@@ -897,17 +858,17 @@ private void pushResetLater(final int streamId, final ErrorCode errorCode) {
   /** Listener of streams and settings initiated by the peer. */
   public abstract static class Listener {
     public static final Listener REFUSE_INCOMING_STREAMS = new Listener() {
-      @Override public void onStream(FramedStream stream) throws IOException {
+      @Override public void onStream(Http2Stream stream) throws IOException {
         stream.close(ErrorCode.REFUSED_STREAM);
       }
     };
 
     /**
      * Handle a new stream from this connection's peer. Implementations should respond by either
-     * {@linkplain FramedStream#reply replying to the stream} or {@linkplain FramedStream#close
-     * closing it}. This response does not need to be synchronous.
+     * {@linkplain Http2Stream#sendResponseHeaders replying to the stream} or {@linkplain
+     * Http2Stream#close closing it}. This response does not need to be synchronous.
      */
-    public abstract void onStream(FramedStream stream) throws IOException;
+    public abstract void onStream(Http2Stream stream) throws IOException;
 
     /**
      * Notification that the connection's peer's settings may have changed. Implementations should
@@ -917,7 +878,7 @@ private void pushResetLater(final int streamId, final ErrorCode errorCode) {
      * remote peer that sends multiple settings frames will trigger multiple calls to this method,
      * and those calls are not necessarily serialized.
      */
-    public void onSettings(FramedConnection connection) {
+    public void onSettings(Http2Connection connection) {
     }
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Reader.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Reader.java
new file mode 100644
index 0000000000..1484a269eb
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Reader.java
@@ -0,0 +1,505 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http2;
+
+import java.io.Closeable;
+import java.io.IOException;
+import java.util.List;
+import java.util.logging.Logger;
+import okio.Buffer;
+import okio.BufferedSource;
+import okio.ByteString;
+import okio.Source;
+import okio.Timeout;
+
+import static java.util.logging.Level.FINE;
+import static okhttp3.internal.Util.format;
+import static okhttp3.internal.http2.Http2.CONNECTION_PREFACE;
+import static okhttp3.internal.http2.Http2.FLAG_ACK;
+import static okhttp3.internal.http2.Http2.FLAG_COMPRESSED;
+import static okhttp3.internal.http2.Http2.FLAG_END_HEADERS;
+import static okhttp3.internal.http2.Http2.FLAG_END_STREAM;
+import static okhttp3.internal.http2.Http2.FLAG_PADDED;
+import static okhttp3.internal.http2.Http2.FLAG_PRIORITY;
+import static okhttp3.internal.http2.Http2.INITIAL_MAX_FRAME_SIZE;
+import static okhttp3.internal.http2.Http2.TYPE_CONTINUATION;
+import static okhttp3.internal.http2.Http2.TYPE_DATA;
+import static okhttp3.internal.http2.Http2.TYPE_GOAWAY;
+import static okhttp3.internal.http2.Http2.TYPE_HEADERS;
+import static okhttp3.internal.http2.Http2.TYPE_PING;
+import static okhttp3.internal.http2.Http2.TYPE_PRIORITY;
+import static okhttp3.internal.http2.Http2.TYPE_PUSH_PROMISE;
+import static okhttp3.internal.http2.Http2.TYPE_RST_STREAM;
+import static okhttp3.internal.http2.Http2.TYPE_SETTINGS;
+import static okhttp3.internal.http2.Http2.TYPE_WINDOW_UPDATE;
+import static okhttp3.internal.http2.Http2.frameLog;
+import static okhttp3.internal.http2.Http2.ioException;
+import static okio.ByteString.EMPTY;
+
+/**
+ * Reads HTTP/2 transport frames.
+ *
+ * <p>This implementation assumes we do not send an increased {@link Settings#getMaxFrameSize frame
+ * size setting} to the peer. Hence, we expect all frames to have a max length of {@link
+ * Http2#INITIAL_MAX_FRAME_SIZE}.
+ */
+final class Http2Reader implements Closeable {
+  static final Logger logger = Logger.getLogger(Http2.class.getName());
+
+  private final BufferedSource source;
+  private final ContinuationSource continuation;
+  private final boolean client;
+
+  // Visible for testing.
+  final Hpack.Reader hpackReader;
+
+  /** Creates a frame reader with max header table size of 4096. */
+  Http2Reader(BufferedSource source, boolean client) {
+    this.source = source;
+    this.client = client;
+    this.continuation = new ContinuationSource(this.source);
+    this.hpackReader = new Hpack.Reader(4096, continuation);
+  }
+
+  public void readConnectionPreface(Handler handler) throws IOException {
+    if (client) {
+      // The client reads the initial SETTINGS frame.
+      if (!nextFrame(true, handler)) {
+        throw ioException("Required SETTINGS preface not received");
+      }
+    } else {
+      // The server reads the CONNECTION_PREFACE byte string.
+      ByteString connectionPreface = source.readByteString(CONNECTION_PREFACE.size());
+      if (logger.isLoggable(FINE)) logger.fine(format("<< CONNECTION %s", connectionPreface.hex()));
+      if (!CONNECTION_PREFACE.equals(connectionPreface)) {
+        throw ioException("Expected a connection header but was %s", connectionPreface.utf8());
+      }
+    }
+  }
+
+  public boolean nextFrame(boolean requireSettings, Handler handler) throws IOException {
+    try {
+      source.require(9); // Frame header size
+    } catch (IOException e) {
+      return false; // This might be a normal socket close.
+    }
+
+    //  0                   1                   2                   3
+    //  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+    // +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    // |                 Length (24)                   |
+    // +---------------+---------------+---------------+
+    // |   Type (8)    |   Flags (8)   |
+    // +-+-+-----------+---------------+-------------------------------+
+    // |R|                 Stream Identifier (31)                      |
+    // +=+=============================================================+
+    // |                   Frame Payload (0...)                      ...
+    // +---------------------------------------------------------------+
+    int length = readMedium(source);
+    if (length < 0 || length > INITIAL_MAX_FRAME_SIZE) {
+      throw ioException("FRAME_SIZE_ERROR: %s", length);
+    }
+    byte type = (byte) (source.readByte() & 0xff);
+    if (requireSettings && type != TYPE_SETTINGS) {
+      throw ioException("Expected a SETTINGS frame but was %s", type);
+    }
+    byte flags = (byte) (source.readByte() & 0xff);
+    int streamId = (source.readInt() & 0x7fffffff); // Ignore reserved bit.
+    if (logger.isLoggable(FINE)) logger.fine(frameLog(true, streamId, length, type, flags));
+
+    switch (type) {
+      case TYPE_DATA:
+        readData(handler, length, flags, streamId);
+        break;
+
+      case TYPE_HEADERS:
+        readHeaders(handler, length, flags, streamId);
+        break;
+
+      case TYPE_PRIORITY:
+        readPriority(handler, length, flags, streamId);
+        break;
+
+      case TYPE_RST_STREAM:
+        readRstStream(handler, length, flags, streamId);
+        break;
+
+      case TYPE_SETTINGS:
+        readSettings(handler, length, flags, streamId);
+        break;
+
+      case TYPE_PUSH_PROMISE:
+        readPushPromise(handler, length, flags, streamId);
+        break;
+
+      case TYPE_PING:
+        readPing(handler, length, flags, streamId);
+        break;
+
+      case TYPE_GOAWAY:
+        readGoAway(handler, length, flags, streamId);
+        break;
+
+      case TYPE_WINDOW_UPDATE:
+        readWindowUpdate(handler, length, flags, streamId);
+        break;
+
+      default:
+        // Implementations MUST discard frames that have unknown or unsupported types.
+        source.skip(length);
+    }
+    return true;
+  }
+
+  private void readHeaders(Handler handler, int length, byte flags, int streamId)
+      throws IOException {
+    if (streamId == 0) throw ioException("PROTOCOL_ERROR: TYPE_HEADERS streamId == 0");
+
+    boolean endStream = (flags & FLAG_END_STREAM) != 0;
+
+    short padding = (flags & FLAG_PADDED) != 0 ? (short) (source.readByte() & 0xff) : 0;
+
+    if ((flags & FLAG_PRIORITY) != 0) {
+      readPriority(handler, streamId);
+      length -= 5; // account for above read.
+    }
+
+    length = lengthWithoutPadding(length, flags, padding);
+
+    List<Header> headerBlock = readHeaderBlock(length, padding, flags, streamId);
+
+    handler.headers(endStream, streamId, -1, headerBlock);
+  }
+
+  private List<Header> readHeaderBlock(int length, short padding, byte flags, int streamId)
+      throws IOException {
+    continuation.length = continuation.left = length;
+    continuation.padding = padding;
+    continuation.flags = flags;
+    continuation.streamId = streamId;
+
+    // TODO: Concat multi-value headers with 0x0, except COOKIE, which uses 0x3B, 0x20.
+    // http://tools.ietf.org/html/draft-ietf-httpbis-http2-17#section-8.1.2.5
+    hpackReader.readHeaders();
+    return hpackReader.getAndResetHeaderList();
+  }
+
+  private void readData(Handler handler, int length, byte flags, int streamId)
+      throws IOException {
+    if (streamId == 0) throw ioException("PROTOCOL_ERROR: TYPE_DATA streamId == 0");
+
+    // TODO: checkState open or half-closed (local) or raise STREAM_CLOSED
+    boolean inFinished = (flags & FLAG_END_STREAM) != 0;
+    boolean gzipped = (flags & FLAG_COMPRESSED) != 0;
+    if (gzipped) {
+      throw ioException("PROTOCOL_ERROR: FLAG_COMPRESSED without SETTINGS_COMPRESS_DATA");
+    }
+
+    short padding = (flags & FLAG_PADDED) != 0 ? (short) (source.readByte() & 0xff) : 0;
+    length = lengthWithoutPadding(length, flags, padding);
+
+    handler.data(inFinished, streamId, source, length);
+    source.skip(padding);
+  }
+
+  private void readPriority(Handler handler, int length, byte flags, int streamId)
+      throws IOException {
+    if (length != 5) throw ioException("TYPE_PRIORITY length: %d != 5", length);
+    if (streamId == 0) throw ioException("TYPE_PRIORITY streamId == 0");
+    readPriority(handler, streamId);
+  }
+
+  private void readPriority(Handler handler, int streamId) throws IOException {
+    int w1 = source.readInt();
+    boolean exclusive = (w1 & 0x80000000) != 0;
+    int streamDependency = (w1 & 0x7fffffff);
+    int weight = (source.readByte() & 0xff) + 1;
+    handler.priority(streamId, streamDependency, weight, exclusive);
+  }
+
+  private void readRstStream(Handler handler, int length, byte flags, int streamId)
+      throws IOException {
+    if (length != 4) throw ioException("TYPE_RST_STREAM length: %d != 4", length);
+    if (streamId == 0) throw ioException("TYPE_RST_STREAM streamId == 0");
+    int errorCodeInt = source.readInt();
+    ErrorCode errorCode = ErrorCode.fromHttp2(errorCodeInt);
+    if (errorCode == null) {
+      throw ioException("TYPE_RST_STREAM unexpected error code: %d", errorCodeInt);
+    }
+    handler.rstStream(streamId, errorCode);
+  }
+
+  private void readSettings(Handler handler, int length, byte flags, int streamId)
+      throws IOException {
+    if (streamId != 0) throw ioException("TYPE_SETTINGS streamId != 0");
+    if ((flags & FLAG_ACK) != 0) {
+      if (length != 0) throw ioException("FRAME_SIZE_ERROR ack frame should be empty!");
+      handler.ackSettings();
+      return;
+    }
+
+    if (length % 6 != 0) throw ioException("TYPE_SETTINGS length %% 6 != 0: %s", length);
+    Settings settings = new Settings();
+    for (int i = 0; i < length; i += 6) {
+      int id = source.readShort() & 0xFFFF;
+      int value = source.readInt();
+
+      switch (id) {
+        case 1: // SETTINGS_HEADER_TABLE_SIZE
+          break;
+        case 2: // SETTINGS_ENABLE_PUSH
+          if (value != 0 && value != 1) {
+            throw ioException("PROTOCOL_ERROR SETTINGS_ENABLE_PUSH != 0 or 1");
+          }
+          break;
+        case 3: // SETTINGS_MAX_CONCURRENT_STREAMS
+          id = 4; // Renumbered in draft 10.
+          break;
+        case 4: // SETTINGS_INITIAL_WINDOW_SIZE
+          id = 7; // Renumbered in draft 10.
+          if (value < 0) {
+            throw ioException("PROTOCOL_ERROR SETTINGS_INITIAL_WINDOW_SIZE > 2^31 - 1");
+          }
+          break;
+        case 5: // SETTINGS_MAX_FRAME_SIZE
+          if (value < INITIAL_MAX_FRAME_SIZE || value > 16777215) {
+            throw ioException("PROTOCOL_ERROR SETTINGS_MAX_FRAME_SIZE: %s", value);
+          }
+          break;
+        case 6: // SETTINGS_MAX_HEADER_LIST_SIZE
+          break; // Advisory only, so ignored.
+        default:
+          break; // Must ignore setting with unknown id.
+      }
+      settings.set(id, value);
+    }
+    handler.settings(false, settings);
+  }
+
+  private void readPushPromise(Handler handler, int length, byte flags, int streamId)
+      throws IOException {
+    if (streamId == 0) {
+      throw ioException("PROTOCOL_ERROR: TYPE_PUSH_PROMISE streamId == 0");
+    }
+    short padding = (flags & FLAG_PADDED) != 0 ? (short) (source.readByte() & 0xff) : 0;
+    int promisedStreamId = source.readInt() & 0x7fffffff;
+    length -= 4; // account for above read.
+    length = lengthWithoutPadding(length, flags, padding);
+    List<Header> headerBlock = readHeaderBlock(length, padding, flags, streamId);
+    handler.pushPromise(streamId, promisedStreamId, headerBlock);
+  }
+
+  private void readPing(Handler handler, int length, byte flags, int streamId)
+      throws IOException {
+    if (length != 8) throw ioException("TYPE_PING length != 8: %s", length);
+    if (streamId != 0) throw ioException("TYPE_PING streamId != 0");
+    int payload1 = source.readInt();
+    int payload2 = source.readInt();
+    boolean ack = (flags & FLAG_ACK) != 0;
+    handler.ping(ack, payload1, payload2);
+  }
+
+  private void readGoAway(Handler handler, int length, byte flags, int streamId)
+      throws IOException {
+    if (length < 8) throw ioException("TYPE_GOAWAY length < 8: %s", length);
+    if (streamId != 0) throw ioException("TYPE_GOAWAY streamId != 0");
+    int lastStreamId = source.readInt();
+    int errorCodeInt = source.readInt();
+    int opaqueDataLength = length - 8;
+    ErrorCode errorCode = ErrorCode.fromHttp2(errorCodeInt);
+    if (errorCode == null) {
+      throw ioException("TYPE_GOAWAY unexpected error code: %d", errorCodeInt);
+    }
+    ByteString debugData = EMPTY;
+    if (opaqueDataLength > 0) { // Must read debug data in order to not corrupt the connection.
+      debugData = source.readByteString(opaqueDataLength);
+    }
+    handler.goAway(lastStreamId, errorCode, debugData);
+  }
+
+  private void readWindowUpdate(Handler handler, int length, byte flags, int streamId)
+      throws IOException {
+    if (length != 4) throw ioException("TYPE_WINDOW_UPDATE length !=4: %s", length);
+    long increment = (source.readInt() & 0x7fffffffL);
+    if (increment == 0) throw ioException("windowSizeIncrement was 0", increment);
+    handler.windowUpdate(streamId, increment);
+  }
+
+  @Override public void close() throws IOException {
+    source.close();
+  }
+
+  /**
+   * Decompression of the header block occurs above the framing layer. This class lazily reads
+   * continuation frames as they are needed by {@link Hpack.Reader#readHeaders()}.
+   */
+  static final class ContinuationSource implements Source {
+    private final BufferedSource source;
+
+    int length;
+    byte flags;
+    int streamId;
+
+    int left;
+    short padding;
+
+    ContinuationSource(BufferedSource source) {
+      this.source = source;
+    }
+
+    @Override public long read(Buffer sink, long byteCount) throws IOException {
+      while (left == 0) {
+        source.skip(padding);
+        padding = 0;
+        if ((flags & FLAG_END_HEADERS) != 0) return -1;
+        readContinuationHeader();
+        // TODO: test case for empty continuation header?
+      }
+
+      long read = source.read(sink, Math.min(byteCount, left));
+      if (read == -1) return -1;
+      left -= read;
+      return read;
+    }
+
+    @Override public Timeout timeout() {
+      return source.timeout();
+    }
+
+    @Override public void close() throws IOException {
+    }
+
+    private void readContinuationHeader() throws IOException {
+      int previousStreamId = streamId;
+
+      length = left = readMedium(source);
+      byte type = (byte) (source.readByte() & 0xff);
+      flags = (byte) (source.readByte() & 0xff);
+      if (logger.isLoggable(FINE)) logger.fine(frameLog(true, streamId, length, type, flags));
+      streamId = (source.readInt() & 0x7fffffff);
+      if (type != TYPE_CONTINUATION) throw ioException("%s != TYPE_CONTINUATION", type);
+      if (streamId != previousStreamId) throw ioException("TYPE_CONTINUATION streamId changed");
+    }
+  }
+
+  static int readMedium(BufferedSource source) throws IOException {
+    return (source.readByte() & 0xff) << 16
+        | (source.readByte() & 0xff) << 8
+        | (source.readByte() & 0xff);
+  }
+
+  static int lengthWithoutPadding(int length, byte flags, short padding)
+      throws IOException {
+    if ((flags & FLAG_PADDED) != 0) length--; // Account for reading the padding length.
+    if (padding > length) {
+      throw ioException("PROTOCOL_ERROR padding %s > remaining length %s", padding, length);
+    }
+    return (short) (length - padding);
+  }
+
+  interface Handler {
+    void data(boolean inFinished, int streamId, BufferedSource source, int length)
+        throws IOException;
+
+    /**
+     * Create or update incoming headers, creating the corresponding streams if necessary. Frames
+     * that trigger this are HEADERS and PUSH_PROMISE.
+     *
+     * @param inFinished true if the sender will not send further frames.
+     * @param streamId the stream owning these headers.
+     * @param associatedStreamId the stream that triggered the sender to create this stream.
+     */
+    void headers(boolean inFinished, int streamId, int associatedStreamId,
+        List<Header> headerBlock);
+
+    void rstStream(int streamId, ErrorCode errorCode);
+
+    void settings(boolean clearPrevious, Settings settings);
+
+    /** HTTP/2 only. */
+    void ackSettings();
+
+    /**
+     * Read a connection-level ping from the peer. {@code ack} indicates this is a reply. The data
+     * in {@code payload1} and {@code payload2} opaque binary, and there are no rules on the
+     * content.
+     */
+    void ping(boolean ack, int payload1, int payload2);
+
+    /**
+     * The peer tells us to stop creating streams.  It is safe to replay streams with {@code ID >
+     * lastGoodStreamId} on a new connection.  In- flight streams with {@code ID <=
+     * lastGoodStreamId} can only be replayed on a new connection if they are idempotent.
+     *
+     * @param lastGoodStreamId the last stream ID the peer processed before sending this message. If
+     * {@code lastGoodStreamId} is zero, the peer processed no frames.
+     * @param errorCode reason for closing the connection.
+     * @param debugData only valid for HTTP/2; opaque debug data to send.
+     */
+    void goAway(int lastGoodStreamId, ErrorCode errorCode, ByteString debugData);
+
+    /**
+     * Notifies that an additional {@code windowSizeIncrement} bytes can be sent on {@code
+     * streamId}, or the connection if {@code streamId} is zero.
+     */
+    void windowUpdate(int streamId, long windowSizeIncrement);
+
+    /**
+     * Called when reading a headers or priority frame. This may be used to change the stream's
+     * weight from the default (16) to a new value.
+     *
+     * @param streamId stream which has a priority change.
+     * @param streamDependency the stream ID this stream is dependent on.
+     * @param weight relative proportion of priority in [1..256].
+     * @param exclusive inserts this stream ID as the sole child of {@code streamDependency}.
+     */
+    void priority(int streamId, int streamDependency, int weight, boolean exclusive);
+
+    /**
+     * HTTP/2 only. Receive a push promise header block. <p> A push promise contains all the headers
+     * that pertain to a server-initiated request, and a {@code promisedStreamId} to which response
+     * frames will be delivered. Push promise frames are sent as a part of the response to {@code
+     * streamId}.
+     *
+     * @param streamId client-initiated stream ID.  Must be an odd number.
+     * @param promisedStreamId server-initiated stream ID.  Must be an even number.
+     * @param requestHeaders minimally includes {@code :method}, {@code :scheme}, {@code
+     * :authority}, and (@code :path}.
+     */
+    void pushPromise(int streamId, int promisedStreamId, List<Header> requestHeaders)
+        throws IOException;
+
+    /**
+     * HTTP/2 only. Expresses that resources for the connection or a client- initiated stream are
+     * available from a different network location or protocol configuration.
+     *
+     * <p>See <a href="http://tools.ietf.org/html/draft-ietf-httpbis-alt-svc-01">alt-svc</a>
+     *
+     * @param streamId when a client-initiated stream ID (odd number), the origin of this alternate
+     * service is the origin of the stream. When zero, the origin is specified in the {@code origin}
+     * parameter.
+     * @param origin when present, the <a href="http://tools.ietf.org/html/rfc6454">origin</a> is
+     * typically represented as a combination of scheme, host and port. When empty, the origin is
+     * that of the {@code streamId}.
+     * @param protocol an ALPN protocol, such as {@code h2}.
+     * @param host an IP address or hostname.
+     * @param port the IP port associated with the service.
+     * @param maxAge time in seconds that this alternative is considered fresh.
+     */
+    void alternateService(int streamId, String origin, ByteString protocol, String host, int port,
+        long maxAge);
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/FramedStream.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.java
similarity index 76%
rename from okhttp/src/main/java/okhttp3/internal/framed/FramedStream.java
rename to okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.java
index d6ce15eeb6..19ac954d7e 100644
--- a/okhttp/src/main/java/okhttp3/internal/framed/FramedStream.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.framed;
+package okhttp3.internal.http2;
 
 import java.io.EOFException;
 import java.io.IOException;
@@ -28,15 +28,13 @@
 import okio.Source;
 import okio.Timeout;
 
-import static okhttp3.internal.framed.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
-
 /** A logical bidirectional stream. */
-public final class FramedStream {
+public final class Http2Stream {
   // Internal state is guarded by this. No long-running or potentially
   // blocking operations are performed while the lock is held.
 
   /**
-   * The total number of bytes consumed by the application (with {@link FramedDataSource#read}), but
+   * The total number of bytes consumed by the application (with {@link FramingSource#read}), but
    * not yet acknowledged by sending a {@code WINDOW_UPDATE} frame on this stream.
    */
   // Visible for testing
@@ -50,38 +48,40 @@
   // guarded by this
   long bytesLeftInWriteWindow;
 
-  private final int id;
-  private final FramedConnection connection;
+  final int id;
+  final Http2Connection connection;
 
-  /** Headers sent by the stream initiator. Immutable and non null. */
+  /** Request headers. Immutable and non null. */
   private final List<Header> requestHeaders;
 
-  /** Headers sent in the stream reply. Null if reply is either not sent or not sent yet. */
+  /** Response headers yet to be {@linkplain #takeResponseHeaders taken}. */
   private List<Header> responseHeaders;
 
-  private final FramedDataSource source;
-  final FramedDataSink sink;
-  private final StreamTimeout readTimeout = new StreamTimeout();
-  private final StreamTimeout writeTimeout = new StreamTimeout();
+  /** True if response headers have been sent or received. */
+  private boolean hasResponseHeaders;
+
+  private final FramingSource source;
+  final FramingSink sink;
+  final StreamTimeout readTimeout = new StreamTimeout();
+  final StreamTimeout writeTimeout = new StreamTimeout();
 
   /**
    * The reason why this stream was abnormally closed. If there are multiple reasons to abnormally
    * close this stream (such as both peers closing it near-simultaneously) then this is the first
    * reason known to this peer.
    */
-  private ErrorCode errorCode = null;
+  ErrorCode errorCode = null;
 
-  FramedStream(int id, FramedConnection connection, boolean outFinished, boolean inFinished,
+  Http2Stream(int id, Http2Connection connection, boolean outFinished, boolean inFinished,
       List<Header> requestHeaders) {
     if (connection == null) throw new NullPointerException("connection == null");
     if (requestHeaders == null) throw new NullPointerException("requestHeaders == null");
     this.id = id;
     this.connection = connection;
     this.bytesLeftInWriteWindow =
-        connection.peerSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE);
-    this.source = new FramedDataSource(
-        connection.okHttpSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE));
-    this.sink = new FramedDataSink();
+        connection.peerSettings.getInitialWindowSize();
+    this.source = new FramingSource(connection.okHttpSettings.getInitialWindowSize());
+    this.sink = new FramingSink();
     this.source.finished = inFinished;
     this.sink.finished = outFinished;
     this.requestHeaders = requestHeaders;
@@ -108,7 +108,7 @@ public synchronized boolean isOpen() {
     }
     if ((source.finished || source.closed)
         && (sink.finished || sink.closed)
-        && responseHeaders != null) {
+        && hasResponseHeaders) {
       return false;
     }
     return true;
@@ -120,7 +120,7 @@ public boolean isLocallyInitiated() {
     return connection.client == streamIsClient;
   }
 
-  public FramedConnection getConnection() {
+  public Http2Connection getConnection() {
     return connection;
   }
 
@@ -129,10 +129,14 @@ public FramedConnection getConnection() {
   }
 
   /**
-   * Returns the stream's response headers, blocking if necessary if they have not been received
-   * yet.
+   * Removes and returns the stream's received response headers, blocking if necessary until headers
+   * have been received. If the returned list contains multiple blocks of headers the blocks will be
+   * delimited by 'null'.
    */
-  public synchronized List<Header> getResponseHeaders() throws IOException {
+  public synchronized List<Header> takeResponseHeaders() throws IOException {
+    if (!isLocallyInitiated()) {
+      throw new IllegalStateException("servers cannot read response headers");
+    }
     readTimeout.enter();
     try {
       while (responseHeaders == null && errorCode == null) {
@@ -141,7 +145,11 @@ public FramedConnection getConnection() {
     } finally {
       readTimeout.exitAndThrowIfTimedOut();
     }
-    if (responseHeaders != null) return responseHeaders;
+    List<Header> result = responseHeaders;
+    if (result != null) {
+      responseHeaders = null;
+      return result;
+    }
     throw new StreamResetException(errorCode);
   }
 
@@ -159,17 +167,14 @@ public synchronized ErrorCode getErrorCode() {
    * @param out true to create an output stream that we can use to send data to the remote peer.
    * Corresponds to {@code FLAG_FIN}.
    */
-  public void reply(List<Header> responseHeaders, boolean out) throws IOException {
-    assert (!Thread.holdsLock(FramedStream.this));
+  public void sendResponseHeaders(List<Header> responseHeaders, boolean out) throws IOException {
+    assert (!Thread.holdsLock(Http2Stream.this));
+    if (responseHeaders == null) {
+      throw new NullPointerException("responseHeaders == null");
+    }
     boolean outFinished = false;
     synchronized (this) {
-      if (responseHeaders == null) {
-        throw new NullPointerException("responseHeaders == null");
-      }
-      if (this.responseHeaders != null) {
-        throw new IllegalStateException("reply already sent");
-      }
-      this.responseHeaders = responseHeaders;
+      this.hasResponseHeaders = true;
       if (!out) {
         this.sink.finished = true;
         outFinished = true;
@@ -198,12 +203,12 @@ public Source getSource() {
   /**
    * Returns a sink that can be used to write data to the peer.
    *
-   * @throws IllegalStateException if this stream was initiated by the peer and a {@link #reply} has
-   * not yet been sent.
+   * @throws IllegalStateException if this stream was initiated by the peer and a {@link
+   * #sendResponseHeaders} has not yet been sent.
    */
   public Sink getSink() {
     synchronized (this) {
-      if (responseHeaders == null && !isLocallyInitiated()) {
+      if (!hasResponseHeaders && !isLocallyInitiated()) {
         throw new IllegalStateException("reply before requesting the sink");
       }
     }
@@ -249,44 +254,35 @@ private boolean closeInternal(ErrorCode errorCode) {
     return true;
   }
 
-  void receiveHeaders(List<Header> headers, HeadersMode headersMode) {
-    assert (!Thread.holdsLock(FramedStream.this));
-    ErrorCode errorCode = null;
+  void receiveHeaders(List<Header> headers) {
+    assert (!Thread.holdsLock(Http2Stream.this));
     boolean open = true;
     synchronized (this) {
+      hasResponseHeaders = true;
       if (responseHeaders == null) {
-        if (headersMode.failIfHeadersAbsent()) {
-          errorCode = ErrorCode.PROTOCOL_ERROR;
-        } else {
-          responseHeaders = headers;
-          open = isOpen();
-          notifyAll();
-        }
+        responseHeaders = headers;
+        open = isOpen();
+        notifyAll();
       } else {
-        if (headersMode.failIfHeadersPresent()) {
-          errorCode = ErrorCode.STREAM_IN_USE;
-        } else {
-          List<Header> newHeaders = new ArrayList<>();
-          newHeaders.addAll(responseHeaders);
-          newHeaders.addAll(headers);
-          this.responseHeaders = newHeaders;
-        }
+        List<Header> newHeaders = new ArrayList<>();
+        newHeaders.addAll(responseHeaders);
+        newHeaders.add(null); // Delimit separate blocks of headers with null.
+        newHeaders.addAll(headers);
+        this.responseHeaders = newHeaders;
       }
     }
-    if (errorCode != null) {
-      closeLater(errorCode);
-    } else if (!open) {
+    if (!open) {
       connection.removeStream(id);
     }
   }
 
   void receiveData(BufferedSource in, int length) throws IOException {
-    assert (!Thread.holdsLock(FramedStream.this));
+    assert (!Thread.holdsLock(Http2Stream.this));
     this.source.receive(in, length);
   }
 
   void receiveFin() {
-    assert (!Thread.holdsLock(FramedStream.this));
+    assert (!Thread.holdsLock(Http2Stream.this));
     boolean open;
     synchronized (this) {
       this.source.finished = true;
@@ -310,35 +306,34 @@ synchronized void receiveRstStream(ErrorCode errorCode) {
    * synchronization to safely receive incoming data frames, it is not intended for use by multiple
    * readers.
    */
-  private final class FramedDataSource implements Source {
+  private final class FramingSource implements Source {
     /** Buffer to receive data from the network into. Only accessed by the reader thread. */
     private final Buffer receiveBuffer = new Buffer();
 
-    /** Buffer with readable data. Guarded by FramedStream.this. */
+    /** Buffer with readable data. Guarded by Http2Stream.this. */
     private final Buffer readBuffer = new Buffer();
 
     /** Maximum number of bytes to buffer before reporting a flow control error. */
     private final long maxByteCount;
 
     /** True if the caller has closed this stream. */
-    private boolean closed;
+    boolean closed;
 
     /**
      * True if either side has cleanly shut down this stream. We will receive no more bytes beyond
      * those already in the buffer.
      */
-    private boolean finished;
+    boolean finished;
 
-    private FramedDataSource(long maxByteCount) {
+    FramingSource(long maxByteCount) {
       this.maxByteCount = maxByteCount;
     }
 
-    @Override public long read(Buffer sink, long byteCount)
-        throws IOException {
+    @Override public long read(Buffer sink, long byteCount) throws IOException {
       if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
 
       long read;
-      synchronized (FramedStream.this) {
+      synchronized (Http2Stream.this) {
         waitUntilReadable();
         checkNotClosed();
         if (readBuffer.size() == 0) return -1; // This source is exhausted.
@@ -349,7 +344,7 @@ private FramedDataSource(long maxByteCount) {
         // Flow control: notify the peer that we're ready for more data!
         unacknowledgedBytesRead += read;
         if (unacknowledgedBytesRead
-            >= connection.okHttpSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE) / 2) {
+            >= connection.okHttpSettings.getInitialWindowSize() / 2) {
           connection.writeWindowUpdateLater(id, unacknowledgedBytesRead);
           unacknowledgedBytesRead = 0;
         }
@@ -359,7 +354,7 @@ private FramedDataSource(long maxByteCount) {
       synchronized (connection) { // Multiple application threads may hit this section.
         connection.unacknowledgedBytesRead += read;
         if (connection.unacknowledgedBytesRead
-            >= connection.okHttpSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE) / 2) {
+            >= connection.okHttpSettings.getInitialWindowSize() / 2) {
           connection.writeWindowUpdateLater(0, connection.unacknowledgedBytesRead);
           connection.unacknowledgedBytesRead = 0;
         }
@@ -381,12 +376,12 @@ private void waitUntilReadable() throws IOException {
     }
 
     void receive(BufferedSource in, long byteCount) throws IOException {
-      assert (!Thread.holdsLock(FramedStream.this));
+      assert (!Thread.holdsLock(Http2Stream.this));
 
       while (byteCount > 0) {
         boolean finished;
         boolean flowControlError;
-        synchronized (FramedStream.this) {
+        synchronized (Http2Stream.this) {
           finished = this.finished;
           flowControlError = byteCount + readBuffer.size() > maxByteCount;
         }
@@ -410,11 +405,11 @@ void receive(BufferedSource in, long byteCount) throws IOException {
         byteCount -= read;
 
         // Move the received data to the read buffer to the reader can read it.
-        synchronized (FramedStream.this) {
+        synchronized (Http2Stream.this) {
           boolean wasEmpty = readBuffer.size() == 0;
           readBuffer.writeAll(receiveBuffer);
           if (wasEmpty) {
-            FramedStream.this.notifyAll();
+            Http2Stream.this.notifyAll();
           }
         }
       }
@@ -425,10 +420,10 @@ void receive(BufferedSource in, long byteCount) throws IOException {
     }
 
     @Override public void close() throws IOException {
-      synchronized (FramedStream.this) {
+      synchronized (Http2Stream.this) {
         closed = true;
         readBuffer.clear();
-        FramedStream.this.notifyAll();
+        Http2Stream.this.notifyAll();
       }
       cancelStreamIfNecessary();
     }
@@ -443,8 +438,8 @@ private void checkNotClosed() throws IOException {
     }
   }
 
-  private void cancelStreamIfNecessary() throws IOException {
-    assert (!Thread.holdsLock(FramedStream.this));
+  void cancelStreamIfNecessary() throws IOException {
+    assert (!Thread.holdsLock(Http2Stream.this));
     boolean open;
     boolean cancel;
     synchronized (this) {
@@ -456,16 +451,14 @@ private void cancelStreamIfNecessary() throws IOException {
       // is safe because the input stream is closed (we won't use any
       // further bytes) and the output stream is either finished or closed
       // (so RSTing both streams doesn't cause harm).
-      FramedStream.this.close(ErrorCode.CANCEL);
+      Http2Stream.this.close(ErrorCode.CANCEL);
     } else if (!open) {
       connection.removeStream(id);
     }
   }
 
-  /**
-   * A sink that writes outgoing data frames of a stream. This class is not thread safe.
-   */
-  final class FramedDataSink implements Sink {
+  /** A sink that writes outgoing data frames of a stream. This class is not thread safe. */
+  final class FramingSink implements Sink {
     private static final long EMIT_BUFFER_SIZE = 16384;
 
     /**
@@ -474,18 +467,18 @@ private void cancelStreamIfNecessary() throws IOException {
      */
     private final Buffer sendBuffer = new Buffer();
 
-    private boolean closed;
+    boolean closed;
 
     /**
      * True if either side has cleanly shut down this stream. We shall send no more bytes.
      */
-    private boolean finished;
+    boolean finished;
 
     @Override public void write(Buffer source, long byteCount) throws IOException {
-      assert (!Thread.holdsLock(FramedStream.this));
+      assert (!Thread.holdsLock(Http2Stream.this));
       sendBuffer.write(source, byteCount);
       while (sendBuffer.size() >= EMIT_BUFFER_SIZE) {
-        emitDataFrame(false);
+        emitFrame(false);
       }
     }
 
@@ -493,9 +486,9 @@ private void cancelStreamIfNecessary() throws IOException {
      * Emit a single data frame to the connection. The frame's size be limited by this stream's
      * write window. This method will block until the write window is nonempty.
      */
-    private void emitDataFrame(boolean outFinished) throws IOException {
+    private void emitFrame(boolean outFinished) throws IOException {
       long toWrite;
-      synchronized (FramedStream.this) {
+      synchronized (Http2Stream.this) {
         writeTimeout.enter();
         try {
           while (bytesLeftInWriteWindow <= 0 && !finished && !closed && errorCode == null) {
@@ -519,12 +512,12 @@ private void emitDataFrame(boolean outFinished) throws IOException {
     }
 
     @Override public void flush() throws IOException {
-      assert (!Thread.holdsLock(FramedStream.this));
-      synchronized (FramedStream.this) {
+      assert (!Thread.holdsLock(Http2Stream.this));
+      synchronized (Http2Stream.this) {
         checkOutNotClosed();
       }
       while (sendBuffer.size() > 0) {
-        emitDataFrame(false);
+        emitFrame(false);
         connection.flush();
       }
     }
@@ -534,22 +527,22 @@ private void emitDataFrame(boolean outFinished) throws IOException {
     }
 
     @Override public void close() throws IOException {
-      assert (!Thread.holdsLock(FramedStream.this));
-      synchronized (FramedStream.this) {
+      assert (!Thread.holdsLock(Http2Stream.this));
+      synchronized (Http2Stream.this) {
         if (closed) return;
       }
       if (!sink.finished) {
         // Emit the remaining data, setting the END_STREAM flag on the last frame.
         if (sendBuffer.size() > 0) {
           while (sendBuffer.size() > 0) {
-            emitDataFrame(true);
+            emitFrame(true);
           }
         } else {
           // Send an empty frame just so we can set the END_STREAM flag.
           connection.writeData(id, true, null, 0);
         }
       }
-      synchronized (FramedStream.this) {
+      synchronized (Http2Stream.this) {
         closed = true;
       }
       connection.flush();
@@ -562,10 +555,10 @@ private void emitDataFrame(boolean outFinished) throws IOException {
    */
   void addBytesToWriteWindow(long delta) {
     bytesLeftInWriteWindow += delta;
-    if (delta > 0) FramedStream.this.notifyAll();
+    if (delta > 0) Http2Stream.this.notifyAll();
   }
 
-  private void checkOutNotClosed() throws IOException {
+  void checkOutNotClosed() throws IOException {
     if (sink.closed) {
       throw new IOException("stream closed");
     } else if (sink.finished) {
@@ -579,7 +572,7 @@ private void checkOutNotClosed() throws IOException {
    * Like {@link #wait}, but throws an {@code InterruptedIOException} when interrupted instead of
    * the more awkward {@link InterruptedException}.
    */
-  private void waitForIo() throws InterruptedIOException {
+  void waitForIo() throws InterruptedIOException {
     try {
       wait();
     } catch (InterruptedException e) {
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Writer.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Writer.java
new file mode 100644
index 0000000000..5ef6bb9c4a
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Writer.java
@@ -0,0 +1,311 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http2;
+
+import java.io.Closeable;
+import java.io.IOException;
+import java.util.List;
+import java.util.logging.Logger;
+import okio.Buffer;
+import okio.BufferedSink;
+
+import static java.util.logging.Level.FINE;
+import static okhttp3.internal.Util.format;
+import static okhttp3.internal.http2.Http2.CONNECTION_PREFACE;
+import static okhttp3.internal.http2.Http2.FLAG_ACK;
+import static okhttp3.internal.http2.Http2.FLAG_END_HEADERS;
+import static okhttp3.internal.http2.Http2.FLAG_END_STREAM;
+import static okhttp3.internal.http2.Http2.FLAG_NONE;
+import static okhttp3.internal.http2.Http2.INITIAL_MAX_FRAME_SIZE;
+import static okhttp3.internal.http2.Http2.TYPE_CONTINUATION;
+import static okhttp3.internal.http2.Http2.TYPE_DATA;
+import static okhttp3.internal.http2.Http2.TYPE_GOAWAY;
+import static okhttp3.internal.http2.Http2.TYPE_HEADERS;
+import static okhttp3.internal.http2.Http2.TYPE_PING;
+import static okhttp3.internal.http2.Http2.TYPE_PUSH_PROMISE;
+import static okhttp3.internal.http2.Http2.TYPE_RST_STREAM;
+import static okhttp3.internal.http2.Http2.TYPE_SETTINGS;
+import static okhttp3.internal.http2.Http2.TYPE_WINDOW_UPDATE;
+import static okhttp3.internal.http2.Http2.frameLog;
+import static okhttp3.internal.http2.Http2.illegalArgument;
+
+/** Writes HTTP/2 transport frames. */
+final class Http2Writer implements Closeable {
+  private static final Logger logger = Logger.getLogger(Http2.class.getName());
+
+  private final BufferedSink sink;
+  private final boolean client;
+  private final Buffer hpackBuffer;
+  private int maxFrameSize;
+  private boolean closed;
+
+  final Hpack.Writer hpackWriter;
+
+  Http2Writer(BufferedSink sink, boolean client) {
+    this.sink = sink;
+    this.client = client;
+    this.hpackBuffer = new Buffer();
+    this.hpackWriter = new Hpack.Writer(hpackBuffer);
+    this.maxFrameSize = INITIAL_MAX_FRAME_SIZE;
+  }
+
+  public synchronized void connectionPreface() throws IOException {
+    if (closed) throw new IOException("closed");
+    if (!client) return; // Nothing to write; servers don't send connection headers!
+    if (logger.isLoggable(FINE)) {
+      logger.fine(format(">> CONNECTION %s", CONNECTION_PREFACE.hex()));
+    }
+    sink.write(CONNECTION_PREFACE.toByteArray());
+    sink.flush();
+  }
+
+  /** Applies {@code peerSettings} and then sends a settings ACK. */
+  public synchronized void applyAndAckSettings(Settings peerSettings) throws IOException {
+    if (closed) throw new IOException("closed");
+    this.maxFrameSize = peerSettings.getMaxFrameSize(maxFrameSize);
+    if (peerSettings.getHeaderTableSize() != -1) {
+      hpackWriter.setHeaderTableSizeSetting(peerSettings.getHeaderTableSize());
+    }
+    int length = 0;
+    byte type = TYPE_SETTINGS;
+    byte flags = FLAG_ACK;
+    int streamId = 0;
+    frameHeader(streamId, length, type, flags);
+    sink.flush();
+  }
+
+  /**
+   * HTTP/2 only. Send a push promise header block.
+   *
+   * <p>A push promise contains all the headers that pertain to a server-initiated request, and a
+   * {@code promisedStreamId} to which response frames will be delivered. Push promise frames are
+   * sent as a part of the response to {@code streamId}. The {@code promisedStreamId} has a priority
+   * of one greater than {@code streamId}.
+   *
+   * @param streamId client-initiated stream ID.  Must be an odd number.
+   * @param promisedStreamId server-initiated stream ID.  Must be an even number.
+   * @param requestHeaders minimally includes {@code :method}, {@code :scheme}, {@code :authority},
+   * and {@code :path}.
+   */
+  public synchronized void pushPromise(int streamId, int promisedStreamId,
+      List<Header> requestHeaders) throws IOException {
+    if (closed) throw new IOException("closed");
+    hpackWriter.writeHeaders(requestHeaders);
+
+    long byteCount = hpackBuffer.size();
+    int length = (int) Math.min(maxFrameSize - 4, byteCount);
+    byte type = TYPE_PUSH_PROMISE;
+    byte flags = byteCount == length ? FLAG_END_HEADERS : 0;
+    frameHeader(streamId, length + 4, type, flags);
+    sink.writeInt(promisedStreamId & 0x7fffffff);
+    sink.write(hpackBuffer, length);
+
+    if (byteCount > length) writeContinuationFrames(streamId, byteCount - length);
+  }
+
+  public synchronized void flush() throws IOException {
+    if (closed) throw new IOException("closed");
+    sink.flush();
+  }
+
+  public synchronized void synStream(boolean outFinished, int streamId,
+      int associatedStreamId, List<Header> headerBlock) throws IOException {
+    if (closed) throw new IOException("closed");
+    headers(outFinished, streamId, headerBlock);
+  }
+
+  public synchronized void synReply(boolean outFinished, int streamId,
+      List<Header> headerBlock) throws IOException {
+    if (closed) throw new IOException("closed");
+    headers(outFinished, streamId, headerBlock);
+  }
+
+  public synchronized void headers(int streamId, List<Header> headerBlock)
+      throws IOException {
+    if (closed) throw new IOException("closed");
+    headers(false, streamId, headerBlock);
+  }
+
+  public synchronized void rstStream(int streamId, ErrorCode errorCode)
+      throws IOException {
+    if (closed) throw new IOException("closed");
+    if (errorCode.httpCode == -1) throw new IllegalArgumentException();
+
+    int length = 4;
+    byte type = TYPE_RST_STREAM;
+    byte flags = FLAG_NONE;
+    frameHeader(streamId, length, type, flags);
+    sink.writeInt(errorCode.httpCode);
+    sink.flush();
+  }
+
+  /** The maximum size of bytes that may be sent in a single call to {@link #data}. */
+  public int maxDataLength() {
+    return maxFrameSize;
+  }
+
+  /**
+   * {@code source.length} may be longer than the max length of the variant's data frame.
+   * Implementations must send multiple frames as necessary.
+   *
+   * @param source the buffer to draw bytes from. May be null if byteCount is 0.
+   * @param byteCount must be between 0 and the minimum of {@code source.length} and {@link
+   * #maxDataLength}.
+   */
+  public synchronized void data(boolean outFinished, int streamId, Buffer source, int byteCount)
+      throws IOException {
+    if (closed) throw new IOException("closed");
+    byte flags = FLAG_NONE;
+    if (outFinished) flags |= FLAG_END_STREAM;
+    dataFrame(streamId, flags, source, byteCount);
+  }
+
+  void dataFrame(int streamId, byte flags, Buffer buffer, int byteCount) throws IOException {
+    byte type = TYPE_DATA;
+    frameHeader(streamId, byteCount, type, flags);
+    if (byteCount > 0) {
+      sink.write(buffer, byteCount);
+    }
+  }
+
+  /** Write okhttp's settings to the peer. */
+  public synchronized void settings(Settings settings) throws IOException {
+    if (closed) throw new IOException("closed");
+    int length = settings.size() * 6;
+    byte type = TYPE_SETTINGS;
+    byte flags = FLAG_NONE;
+    int streamId = 0;
+    frameHeader(streamId, length, type, flags);
+    for (int i = 0; i < Settings.COUNT; i++) {
+      if (!settings.isSet(i)) continue;
+      int id = i;
+      if (id == 4) {
+        id = 3; // SETTINGS_MAX_CONCURRENT_STREAMS renumbered.
+      } else if (id == 7) {
+        id = 4; // SETTINGS_INITIAL_WINDOW_SIZE renumbered.
+      }
+      sink.writeShort(id);
+      sink.writeInt(settings.get(i));
+    }
+    sink.flush();
+  }
+
+  /**
+   * Send a connection-level ping to the peer. {@code ack} indicates this is a reply. The data in
+   * {@code payload1} and {@code payload2} opaque binary, and there are no rules on the content.
+   */
+  public synchronized void ping(boolean ack, int payload1, int payload2) throws IOException {
+    if (closed) throw new IOException("closed");
+    int length = 8;
+    byte type = TYPE_PING;
+    byte flags = ack ? FLAG_ACK : FLAG_NONE;
+    int streamId = 0;
+    frameHeader(streamId, length, type, flags);
+    sink.writeInt(payload1);
+    sink.writeInt(payload2);
+    sink.flush();
+  }
+
+  /**
+   * Tell the peer to stop creating streams and that we last processed {@code lastGoodStreamId}, or
+   * zero if no streams were processed.
+   *
+   * @param lastGoodStreamId the last stream ID processed, or zero if no streams were processed.
+   * @param errorCode reason for closing the connection.
+   * @param debugData only valid for HTTP/2; opaque debug data to send.
+   */
+  public synchronized void goAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData)
+      throws IOException {
+    if (closed) throw new IOException("closed");
+    if (errorCode.httpCode == -1) throw illegalArgument("errorCode.httpCode == -1");
+    int length = 8 + debugData.length;
+    byte type = TYPE_GOAWAY;
+    byte flags = FLAG_NONE;
+    int streamId = 0;
+    frameHeader(streamId, length, type, flags);
+    sink.writeInt(lastGoodStreamId);
+    sink.writeInt(errorCode.httpCode);
+    if (debugData.length > 0) {
+      sink.write(debugData);
+    }
+    sink.flush();
+  }
+
+  /**
+   * Inform peer that an additional {@code windowSizeIncrement} bytes can be sent on {@code
+   * streamId}, or the connection if {@code streamId} is zero.
+   */
+  public synchronized void windowUpdate(int streamId, long windowSizeIncrement) throws IOException {
+    if (closed) throw new IOException("closed");
+    if (windowSizeIncrement == 0 || windowSizeIncrement > 0x7fffffffL) {
+      throw illegalArgument("windowSizeIncrement == 0 || windowSizeIncrement > 0x7fffffffL: %s",
+          windowSizeIncrement);
+    }
+    int length = 4;
+    byte type = TYPE_WINDOW_UPDATE;
+    byte flags = FLAG_NONE;
+    frameHeader(streamId, length, type, flags);
+    sink.writeInt((int) windowSizeIncrement);
+    sink.flush();
+  }
+
+  public void frameHeader(int streamId, int length, byte type, byte flags) throws IOException {
+    if (logger.isLoggable(FINE)) logger.fine(frameLog(false, streamId, length, type, flags));
+    if (length > maxFrameSize) {
+      throw illegalArgument("FRAME_SIZE_ERROR length > %d: %d", maxFrameSize, length);
+    }
+    if ((streamId & 0x80000000) != 0) throw illegalArgument("reserved bit set: %s", streamId);
+    writeMedium(sink, length);
+    sink.writeByte(type & 0xff);
+    sink.writeByte(flags & 0xff);
+    sink.writeInt(streamId & 0x7fffffff);
+  }
+
+  @Override public synchronized void close() throws IOException {
+    closed = true;
+    sink.close();
+  }
+
+  private static void writeMedium(BufferedSink sink, int i) throws IOException {
+    sink.writeByte((i >>> 16) & 0xff);
+    sink.writeByte((i >>> 8) & 0xff);
+    sink.writeByte(i & 0xff);
+  }
+
+  private void writeContinuationFrames(int streamId, long byteCount) throws IOException {
+    while (byteCount > 0) {
+      int length = (int) Math.min(maxFrameSize, byteCount);
+      byteCount -= length;
+      frameHeader(streamId, length, TYPE_CONTINUATION, byteCount == 0 ? FLAG_END_HEADERS : 0);
+      sink.write(hpackBuffer, length);
+    }
+  }
+
+  void headers(boolean outFinished, int streamId, List<Header> headerBlock) throws IOException {
+    if (closed) throw new IOException("closed");
+    hpackWriter.writeHeaders(headerBlock);
+
+    long byteCount = hpackBuffer.size();
+    int length = (int) Math.min(maxFrameSize, byteCount);
+    byte type = TYPE_HEADERS;
+    byte flags = byteCount == length ? FLAG_END_HEADERS : 0;
+    if (outFinished) flags |= FLAG_END_STREAM;
+    frameHeader(streamId, length, type, flags);
+    sink.write(hpackBuffer, length);
+
+    if (byteCount > length) writeContinuationFrames(streamId, byteCount - length);
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/Huffman.java b/okhttp/src/main/java/okhttp3/internal/http2/Huffman.java
similarity index 93%
rename from okhttp/src/main/java/okhttp3/internal/framed/Huffman.java
rename to okhttp/src/main/java/okhttp3/internal/http2/Huffman.java
index 0c7f3012a7..7aa8024b72 100644
--- a/okhttp/src/main/java/okhttp3/internal/framed/Huffman.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Huffman.java
@@ -13,11 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.framed;
+package okhttp3.internal.http2;
 
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
-import java.io.OutputStream;
+import okio.BufferedSink;
+import okio.ByteString;
 
 /**
  * This class was originally composed from the following classes in <a
@@ -87,12 +88,12 @@ private Huffman() {
     buildTree();
   }
 
-  void encode(byte[] data, OutputStream out) throws IOException {
+  void encode(ByteString data, BufferedSink sink) throws IOException {
     long current = 0;
     int n = 0;
 
-    for (int i = 0; i < data.length; i++) {
-      int b = data[i] & 0xFF;
+    for (int i = 0; i < data.size(); i++) {
+      int b = data.getByte(i) & 0xFF;
       int code = CODES[b];
       int nbits = CODE_LENGTHS[b];
 
@@ -102,29 +103,29 @@ void encode(byte[] data, OutputStream out) throws IOException {
 
       while (n >= 8) {
         n -= 8;
-        out.write(((int) (current >> n)));
+        sink.writeByte(((int) (current >> n)));
       }
     }
 
     if (n > 0) {
       current <<= (8 - n);
       current |= (0xFF >>> n);
-      out.write((int) current);
+      sink.writeByte((int) current);
     }
   }
 
-  int encodedLength(byte[] bytes) {
+  int encodedLength(ByteString bytes) {
     long len = 0;
 
-    for (int i = 0; i < bytes.length; i++) {
-      int b = bytes[i] & 0xFF;
+    for (int i = 0; i < bytes.size(); i++) {
+      int b = bytes.getByte(i) & 0xFF;
       len += CODE_LENGTHS[b];
     }
 
     return (int) ((len + 7) >> 3);
   }
 
-  byte[] decode(byte[] buf) throws IOException {
+  byte[] decode(byte[] buf) {
     ByteArrayOutputStream baos = new ByteArrayOutputStream();
     Node node = root;
     int current = 0;
@@ -195,13 +196,13 @@ private void addCode(int sym, int code, byte len) {
   private static final class Node {
 
     // Null if terminal.
-    private final Node[] children;
+    final Node[] children;
 
     // Terminal nodes have a symbol.
-    private final int symbol;
+    final int symbol;
 
     // Number of bits represented in the terminal node.
-    private final int terminalBits;
+    final int terminalBits;
 
     /** Construct an internal node. */
     Node() {
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/Ping.java b/okhttp/src/main/java/okhttp3/internal/http2/Ping.java
similarity index 97%
rename from okhttp/src/main/java/okhttp3/internal/framed/Ping.java
rename to okhttp/src/main/java/okhttp3/internal/http2/Ping.java
index d3e0b428d6..7847db7aab 100644
--- a/okhttp/src/main/java/okhttp3/internal/framed/Ping.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Ping.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.framed;
+package okhttp3.internal.http2;
 
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
@@ -21,7 +21,7 @@
 /**
  * A locally-originated ping.
  */
-public final class Ping {
+final class Ping {
   private final CountDownLatch latch = new CountDownLatch(1);
   private long sent = -1;
   private long received = -1;
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/PushObserver.java b/okhttp/src/main/java/okhttp3/internal/http2/PushObserver.java
similarity index 98%
rename from okhttp/src/main/java/okhttp3/internal/framed/PushObserver.java
rename to okhttp/src/main/java/okhttp3/internal/http2/PushObserver.java
index 95dd41a5b9..8c08ddb56a 100644
--- a/okhttp/src/main/java/okhttp3/internal/framed/PushObserver.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/PushObserver.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.framed;
+package okhttp3.internal.http2;
 
 import java.io.IOException;
 import java.util.List;
@@ -44,7 +44,7 @@
    *
    * @param streamId server-initiated stream ID: an even number.
    * @param requestHeaders minimally includes {@code :method}, {@code :scheme}, {@code :authority},
-   * and (@code :path}.
+   * and {@code :path}.
    */
   boolean onRequest(int streamId, List<Header> requestHeaders);
 
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Settings.java b/okhttp/src/main/java/okhttp3/internal/http2/Settings.java
new file mode 100644
index 0000000000..5b548de484
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Settings.java
@@ -0,0 +1,127 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http2;
+
+import java.util.Arrays;
+
+/**
+ * Settings describe characteristics of the sending peer, which are used by the receiving peer.
+ * Settings are {@link Http2Connection connection} scoped.
+ */
+public final class Settings {
+  /**
+   * From the HTTP/2 specs, the default initial window size for all streams is 64 KiB. (Chrome 25
+   * uses 10 MiB).
+   */
+  static final int DEFAULT_INITIAL_WINDOW_SIZE = 65535;
+
+  /** HTTP/2: Size in bytes of the table used to decode the sender's header blocks. */
+  static final int HEADER_TABLE_SIZE = 1;
+  /** HTTP/2: The peer must not send a PUSH_PROMISE frame when this is 0. */
+  static final int ENABLE_PUSH = 2;
+  /** Sender's maximum number of concurrent streams. */
+  static final int MAX_CONCURRENT_STREAMS = 4;
+  /** HTTP/2: Size in bytes of the largest frame payload the sender will accept. */
+  static final int MAX_FRAME_SIZE = 5;
+  /** HTTP/2: Advisory only. Size in bytes of the largest header list the sender will accept. */
+  static final int MAX_HEADER_LIST_SIZE = 6;
+  /** Window size in bytes. */
+  static final int INITIAL_WINDOW_SIZE = 7;
+
+  /** Total number of settings. */
+  static final int COUNT = 10;
+
+  /** Bitfield of which flags that values. */
+  private int set;
+
+  /** Flag values. */
+  private final int[] values = new int[COUNT];
+
+  void clear() {
+    set = 0;
+    Arrays.fill(values, 0);
+  }
+
+  Settings set(int id, int value) {
+    if (id < 0 || id >= values.length) {
+      return this; // Discard unknown settings.
+    }
+
+    int bit = 1 << id;
+    set |= bit;
+    values[id] = value;
+    return this;
+  }
+
+  /** Returns true if a value has been assigned for the setting {@code id}. */
+  boolean isSet(int id) {
+    int bit = 1 << id;
+    return (set & bit) != 0;
+  }
+
+  /** Returns the value for the setting {@code id}, or 0 if unset. */
+  int get(int id) {
+    return values[id];
+  }
+
+  /** Returns the number of settings that have values assigned. */
+  int size() {
+    return Integer.bitCount(set);
+  }
+
+  /** Returns -1 if unset. */
+  int getHeaderTableSize() {
+    int bit = 1 << HEADER_TABLE_SIZE;
+    return (bit & set) != 0 ? values[HEADER_TABLE_SIZE] : -1;
+  }
+
+  // TODO: honor this setting.
+  boolean getEnablePush(boolean defaultValue) {
+    int bit = 1 << ENABLE_PUSH;
+    return ((bit & set) != 0 ? values[ENABLE_PUSH] : defaultValue ? 1 : 0) == 1;
+  }
+
+  int getMaxConcurrentStreams(int defaultValue) {
+    int bit = 1 << MAX_CONCURRENT_STREAMS;
+    return (bit & set) != 0 ? values[MAX_CONCURRENT_STREAMS] : defaultValue;
+  }
+
+  int getMaxFrameSize(int defaultValue) {
+    int bit = 1 << MAX_FRAME_SIZE;
+    return (bit & set) != 0 ? values[MAX_FRAME_SIZE] : defaultValue;
+  }
+
+  int getMaxHeaderListSize(int defaultValue) {
+    int bit = 1 << MAX_HEADER_LIST_SIZE;
+    return (bit & set) != 0 ? values[MAX_HEADER_LIST_SIZE] : defaultValue;
+  }
+
+  int getInitialWindowSize() {
+    int bit = 1 << INITIAL_WINDOW_SIZE;
+    return (bit & set) != 0 ? values[INITIAL_WINDOW_SIZE] : DEFAULT_INITIAL_WINDOW_SIZE;
+  }
+
+  /**
+   * Writes {@code other} into this. If any setting is populated by this and {@code other}, the
+   * value and flags from {@code other} will be kept.
+   */
+  void merge(Settings other) {
+    for (int i = 0; i < COUNT; i++) {
+      if (!other.isSet(i)) continue;
+      set(i, other.get(i));
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/StreamResetException.java b/okhttp/src/main/java/okhttp3/internal/http2/StreamResetException.java
similarity index 96%
rename from okhttp/src/main/java/okhttp3/internal/framed/StreamResetException.java
rename to okhttp/src/main/java/okhttp3/internal/http2/StreamResetException.java
index a7af0e4b41..299f81e1b9 100644
--- a/okhttp/src/main/java/okhttp3/internal/framed/StreamResetException.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/StreamResetException.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.framed;
+package okhttp3.internal.http2;
 
 import java.io.IOException;
 
diff --git a/okhttp/src/main/java/okhttp3/internal/AndroidPlatform.java b/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.java
similarity index 51%
rename from okhttp/src/main/java/okhttp3/internal/AndroidPlatform.java
rename to okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.java
index c0096c6cd1..342e91f150 100644
--- a/okhttp/src/main/java/okhttp3/internal/AndroidPlatform.java
+++ b/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.java
@@ -13,8 +13,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal;
+package okhttp3.internal.platform;
 
+import android.os.Build;
 import android.util.Log;
 import java.io.IOException;
 import java.lang.reflect.Constructor;
@@ -22,7 +23,9 @@
 import java.lang.reflect.Method;
 import java.net.InetSocketAddress;
 import java.net.Socket;
+import java.security.Security;
 import java.security.cert.Certificate;
+import java.security.cert.TrustAnchor;
 import java.security.cert.X509Certificate;
 import java.util.List;
 import javax.net.ssl.SSLPeerUnverifiedException;
@@ -30,7 +33,12 @@
 import javax.net.ssl.SSLSocketFactory;
 import javax.net.ssl.X509TrustManager;
 import okhttp3.Protocol;
+import okhttp3.internal.Util;
+import okhttp3.internal.tls.BasicTrustRootIndex;
 import okhttp3.internal.tls.CertificateChainCleaner;
+import okhttp3.internal.tls.TrustRootIndex;
+
+import static okhttp3.internal.Util.assertionError;
 
 /** Android 2.3 or better. */
 class AndroidPlatform extends Platform {
@@ -44,7 +52,9 @@
   private final OptionalMethod<Socket> getAlpnSelectedProtocol;
   private final OptionalMethod<Socket> setAlpnProtocols;
 
-  public AndroidPlatform(Class<?> sslParametersClass, OptionalMethod<Socket> setUseSessionTickets,
+  private final CloseGuard closeGuard = CloseGuard.get();
+
+  AndroidPlatform(Class<?> sslParametersClass, OptionalMethod<Socket> setUseSessionTickets,
       OptionalMethod<Socket> setHostname, OptionalMethod<Socket> getAlpnSelectedProtocol,
       OptionalMethod<Socket> setAlpnProtocols) {
     this.sslParametersClass = sslParametersClass;
@@ -67,10 +77,20 @@ public AndroidPlatform(Class<?> sslParametersClass, OptionalMethod<Socket> setUs
       IOException ioException = new IOException("Exception in connect");
       ioException.initCause(e);
       throw ioException;
+    } catch (ClassCastException e) {
+      // On android 8.0, socket.connect throws a ClassCastException due to a bug
+      // see https://issuetracker.google.com/issues/63649622
+      if (Build.VERSION.SDK_INT == 26) {
+        IOException ioException = new IOException("Exception in connect");
+        ioException.initCause(e);
+        throw ioException;
+      } else {
+        throw e;
+      }
     }
   }
 
-  @Override public X509TrustManager trustManager(SSLSocketFactory sslSocketFactory) {
+  @Override protected X509TrustManager trustManager(SSLSocketFactory sslSocketFactory) {
     Object context = readFieldOrNull(sslSocketFactory, sslParametersClass, "sslParameters");
     if (context == null) {
       // If that didn't work, try the Google Play Services SSL provider before giving up. This
@@ -131,24 +151,70 @@ public AndroidPlatform(Class<?> sslParametersClass, OptionalMethod<Socket> setUs
     }
   }
 
-  @Override public boolean isCleartextTrafficPermitted() {
+  @Override public Object getStackTraceForCloseable(String closer) {
+    return closeGuard.createAndOpen(closer);
+  }
+
+  @Override public void logCloseableLeak(String message, Object stackTrace) {
+    boolean reported = closeGuard.warnIfOpen(stackTrace);
+    if (!reported) {
+      // Unable to report via CloseGuard. As a last-ditch effort, send it to the logger.
+      log(WARN, message, null);
+    }
+  }
+
+  @Override public boolean isCleartextTrafficPermitted(String hostname) {
     try {
       Class<?> networkPolicyClass = Class.forName("android.security.NetworkSecurityPolicy");
       Method getInstanceMethod = networkPolicyClass.getMethod("getInstance");
       Object networkSecurityPolicy = getInstanceMethod.invoke(null);
+      return api24IsCleartextTrafficPermitted(hostname, networkPolicyClass, networkSecurityPolicy);
+    } catch (ClassNotFoundException | NoSuchMethodException e) {
+      return super.isCleartextTrafficPermitted(hostname);
+    } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
+      throw assertionError("unable to determine cleartext support", e);
+    }
+  }
+
+  private boolean api24IsCleartextTrafficPermitted(String hostname, Class<?> networkPolicyClass,
+      Object networkSecurityPolicy) throws InvocationTargetException, IllegalAccessException {
+    try {
+      Method isCleartextTrafficPermittedMethod = networkPolicyClass
+          .getMethod("isCleartextTrafficPermitted", String.class);
+      return (boolean) isCleartextTrafficPermittedMethod.invoke(networkSecurityPolicy, hostname);
+    } catch (NoSuchMethodException e) {
+      return api23IsCleartextTrafficPermitted(hostname, networkPolicyClass, networkSecurityPolicy);
+    }
+  }
+
+  private boolean api23IsCleartextTrafficPermitted(String hostname, Class<?> networkPolicyClass,
+      Object networkSecurityPolicy) throws InvocationTargetException, IllegalAccessException {
+    try {
       Method isCleartextTrafficPermittedMethod = networkPolicyClass
           .getMethod("isCleartextTrafficPermitted");
-      boolean cleartextPermitted = (boolean) isCleartextTrafficPermittedMethod
-          .invoke(networkSecurityPolicy);
-      return cleartextPermitted;
-    } catch (ClassNotFoundException e) {
-      return super.isCleartextTrafficPermitted();
-    } catch (NoSuchMethodException | IllegalAccessException | IllegalArgumentException
-        | InvocationTargetException e) {
-      throw new AssertionError();
+      return (boolean) isCleartextTrafficPermittedMethod.invoke(networkSecurityPolicy);
+    } catch (NoSuchMethodException e) {
+      return super.isCleartextTrafficPermitted(hostname);
     }
   }
 
+  /**
+   * Checks to see if Google Play Services Dynamic Security Provider is present which provides ALPN
+   * support. If it isn't checks to see if device is Android 5.0+ since 4.x device have broken
+   * ALPN support.
+   */
+  private static boolean supportsAlpn() {
+    if (Security.getProvider("GMSCore_OpenSSL") != null) {
+      return true;
+    } else {
+      try {
+        Class.forName("android.net.Network"); // Arbitrary class added in Android 5.0.
+        return true;
+      } catch (ClassNotFoundException ignored) { }
+    }
+    return false;
+  }
+
   public CertificateChainCleaner buildCertificateChainCleaner(X509TrustManager trustManager) {
     try {
       Class<?> extensionsClass = Class.forName("android.net.http.X509TrustManagerExtensions");
@@ -181,12 +247,11 @@ public static Platform buildIfSupported() {
       OptionalMethod<Socket> getAlpnSelectedProtocol = null;
       OptionalMethod<Socket> setAlpnProtocols = null;
 
-      // Attempt to find Android 5.0+ APIs.
-      try {
-        Class.forName("android.net.Network"); // Arbitrary class added in Android 5.0.
-        getAlpnSelectedProtocol = new OptionalMethod<>(byte[].class, "getAlpnSelectedProtocol");
-        setAlpnProtocols = new OptionalMethod<>(null, "setAlpnProtocols", byte[].class);
-      } catch (ClassNotFoundException ignored) {
+      if (supportsAlpn()) {
+        getAlpnSelectedProtocol
+            = new OptionalMethod<>(byte[].class, "getAlpnSelectedProtocol");
+        setAlpnProtocols
+            = new OptionalMethod<>(null, "setAlpnProtocols", byte[].class);
       }
 
       return new AndroidPlatform(sslParametersClass, setUseSessionTickets, setHostname,
@@ -198,6 +263,21 @@ public static Platform buildIfSupported() {
     return null;
   }
 
+  @Override
+  public TrustRootIndex buildTrustRootIndex(X509TrustManager trustManager) {
+
+    try {
+      // From org.conscrypt.TrustManagerImpl, we want the method with this signature:
+      // private TrustAnchor findTrustAnchorByIssuerAndSignature(X509Certificate lastCert);
+      Method method = trustManager.getClass().getDeclaredMethod(
+              "findTrustAnchorByIssuerAndSignature", X509Certificate.class);
+      method.setAccessible(true);
+      return new AndroidTrustRootIndex(trustManager, method);
+    } catch (NoSuchMethodException e) {
+      return super.buildTrustRootIndex(trustManager);
+    }
+  }
+
   /**
    * X509TrustManagerExtensions was added to Android in API 17 (Android 4.2, released in late 2012).
    * This is the best way to get a clean chain on Android because it uses the same code as the TLS
@@ -227,5 +307,123 @@ public static Platform buildIfSupported() {
         throw new AssertionError(e);
       }
     }
+
+    @Override public boolean equals(Object other) {
+      return other instanceof AndroidCertificateChainCleaner; // All instances are equivalent.
+    }
+
+    @Override public int hashCode() {
+      return 0;
+    }
+  }
+
+  /**
+   * Provides access to the internal dalvik.system.CloseGuard class. Android uses this in
+   * combination with android.os.StrictMode to report on leaked java.io.Closeable's. Available since
+   * Android API 11.
+   */
+  static final class CloseGuard {
+    private final Method getMethod;
+    private final Method openMethod;
+    private final Method warnIfOpenMethod;
+
+    CloseGuard(Method getMethod, Method openMethod, Method warnIfOpenMethod) {
+      this.getMethod = getMethod;
+      this.openMethod = openMethod;
+      this.warnIfOpenMethod = warnIfOpenMethod;
+    }
+
+    Object createAndOpen(String closer) {
+      if (getMethod != null) {
+        try {
+          Object closeGuardInstance = getMethod.invoke(null);
+          openMethod.invoke(closeGuardInstance, closer);
+          return closeGuardInstance;
+        } catch (Exception ignored) {
+        }
+      }
+      return null;
+    }
+
+    boolean warnIfOpen(Object closeGuardInstance) {
+      boolean reported = false;
+      if (closeGuardInstance != null) {
+        try {
+          warnIfOpenMethod.invoke(closeGuardInstance);
+          reported = true;
+        } catch (Exception ignored) {
+        }
+      }
+      return reported;
+    }
+
+    static CloseGuard get() {
+      Method getMethod;
+      Method openMethod;
+      Method warnIfOpenMethod;
+
+      try {
+        Class<?> closeGuardClass = Class.forName("dalvik.system.CloseGuard");
+        getMethod = closeGuardClass.getMethod("get");
+        openMethod = closeGuardClass.getMethod("open", String.class);
+        warnIfOpenMethod = closeGuardClass.getMethod("warnIfOpen");
+      } catch (Exception ignored) {
+        getMethod = null;
+        openMethod = null;
+        warnIfOpenMethod = null;
+      }
+      return new CloseGuard(getMethod, openMethod, warnIfOpenMethod);
+    }
+  }
+
+  /**
+   * An index of trusted root certificates that exploits knowledge of Android implementation
+   * details. This class is potentially much faster to initialize than {@link BasicTrustRootIndex}
+   * because it doesn't need to load and index trusted CA certificates.
+   *
+   * <p>This class uses APIs added to Android in API 14 (Android 4.0, released October 2011). This
+   * class shouldn't be used in Android API 17 or better because those releases are better served by
+   * {@link AndroidPlatform.AndroidCertificateChainCleaner}.
+   */
+  static final class AndroidTrustRootIndex implements TrustRootIndex {
+    private final X509TrustManager trustManager;
+    private final Method findByIssuerAndSignatureMethod;
+
+    AndroidTrustRootIndex(X509TrustManager trustManager, Method findByIssuerAndSignatureMethod) {
+      this.findByIssuerAndSignatureMethod = findByIssuerAndSignatureMethod;
+      this.trustManager = trustManager;
+    }
+
+    @Override public X509Certificate findByIssuerAndSignature(X509Certificate cert) {
+      try {
+        TrustAnchor trustAnchor = (TrustAnchor) findByIssuerAndSignatureMethod.invoke(
+                trustManager, cert);
+        return trustAnchor != null
+                ? trustAnchor.getTrustedCert()
+                : null;
+      } catch (IllegalAccessException e) {
+        throw assertionError("unable to get issues and signature", e);
+      } catch (InvocationTargetException e) {
+        return null;
+      }
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+      if (obj == this) {
+        return true;
+      }
+      if (!(obj instanceof AndroidTrustRootIndex)) {
+        return false;
+      }
+      AndroidTrustRootIndex that = (AndroidTrustRootIndex) obj;
+      return trustManager.equals(that.trustManager)
+              && findByIssuerAndSignatureMethod.equals(that.findByIssuerAndSignatureMethod);
+    }
+
+    @Override
+    public int hashCode() {
+      return trustManager.hashCode() + 31 * findByIssuerAndSignatureMethod.hashCode();
+    }
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/Jdk9Platform.java b/okhttp/src/main/java/okhttp3/internal/platform/Jdk9Platform.java
similarity index 91%
rename from okhttp/src/main/java/okhttp3/internal/Jdk9Platform.java
rename to okhttp/src/main/java/okhttp3/internal/platform/Jdk9Platform.java
index 1cd04f965a..24b75217b0 100644
--- a/okhttp/src/main/java/okhttp3/internal/Jdk9Platform.java
+++ b/okhttp/src/main/java/okhttp3/internal/platform/Jdk9Platform.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal;
+package okhttp3.internal.platform;
 
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
@@ -24,6 +24,8 @@
 import javax.net.ssl.X509TrustManager;
 import okhttp3.Protocol;
 
+import static okhttp3.internal.Util.assertionError;
+
 /**
  * OpenJDK 9+.
  */
@@ -31,7 +33,7 @@
   final Method setProtocolMethod;
   final Method getProtocolMethod;
 
-  public Jdk9Platform(Method setProtocolMethod, Method getProtocolMethod) {
+  Jdk9Platform(Method setProtocolMethod, Method getProtocolMethod) {
     this.setProtocolMethod = setProtocolMethod;
     this.getProtocolMethod = getProtocolMethod;
   }
@@ -49,7 +51,7 @@ public void configureTlsExtensions(SSLSocket sslSocket, String hostname,
 
       sslSocket.setSSLParameters(sslParameters);
     } catch (IllegalAccessException | InvocationTargetException e) {
-      throw new AssertionError();
+      throw assertionError("unable to set ssl parameters", e);
     }
   }
 
@@ -66,7 +68,7 @@ public String getSelectedProtocol(SSLSocket socket) {
 
       return protocol;
     } catch (IllegalAccessException | InvocationTargetException e) {
-      throw new AssertionError();
+      throw assertionError("unable to get selected protocols", e);
     }
   }
 
diff --git a/okhttp/src/main/java/okhttp3/internal/JdkWithJettyBootPlatform.java b/okhttp/src/main/java/okhttp3/internal/platform/JdkWithJettyBootPlatform.java
similarity index 90%
rename from okhttp/src/main/java/okhttp3/internal/JdkWithJettyBootPlatform.java
rename to okhttp/src/main/java/okhttp3/internal/platform/JdkWithJettyBootPlatform.java
index 5e5e5a43f6..bfb4ed8c89 100644
--- a/okhttp/src/main/java/okhttp3/internal/JdkWithJettyBootPlatform.java
+++ b/okhttp/src/main/java/okhttp3/internal/platform/JdkWithJettyBootPlatform.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal;
+package okhttp3.internal.platform;
 
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.InvocationTargetException;
@@ -22,6 +22,9 @@
 import java.util.List;
 import javax.net.ssl.SSLSocket;
 import okhttp3.Protocol;
+import okhttp3.internal.Util;
+
+import static okhttp3.internal.Util.assertionError;
 
 /**
  * OpenJDK 7 or OpenJDK 8 with {@code org.mortbay.jetty.alpn/alpn-boot} in the boot class path.
@@ -33,7 +36,7 @@
   private final Class<?> clientProviderClass;
   private final Class<?> serverProviderClass;
 
-  public JdkWithJettyBootPlatform(Method putMethod, Method getMethod, Method removeMethod,
+  JdkWithJettyBootPlatform(Method putMethod, Method getMethod, Method removeMethod,
       Class<?> clientProviderClass, Class<?> serverProviderClass) {
     this.putMethod = putMethod;
     this.getMethod = getMethod;
@@ -51,15 +54,15 @@ public JdkWithJettyBootPlatform(Method putMethod, Method getMethod, Method remov
           new Class[] {clientProviderClass, serverProviderClass}, new JettyNegoProvider(names));
       putMethod.invoke(null, sslSocket, provider);
     } catch (InvocationTargetException | IllegalAccessException e) {
-      throw new AssertionError(e);
+      throw assertionError("unable to set alpn", e);
     }
   }
 
   @Override public void afterHandshake(SSLSocket sslSocket) {
     try {
       removeMethod.invoke(null, sslSocket);
-    } catch (IllegalAccessException | InvocationTargetException ignored) {
-      throw new AssertionError();
+    } catch (IllegalAccessException | InvocationTargetException e) {
+      throw assertionError("unable to remove alpn", e);
     }
   }
 
@@ -68,13 +71,13 @@ public JdkWithJettyBootPlatform(Method putMethod, Method getMethod, Method remov
       JettyNegoProvider provider =
           (JettyNegoProvider) Proxy.getInvocationHandler(getMethod.invoke(null, socket));
       if (!provider.unsupported && provider.selected == null) {
-        Platform.get().log(INFO, "ALPN callback dropped: SPDY and HTTP/2 are disabled. "
+        Platform.get().log(INFO, "ALPN callback dropped: HTTP/2 is disabled. "
             + "Is alpn-boot on the boot class path?", null);
         return null;
       }
       return provider.unsupported ? null : provider.selected;
     } catch (InvocationTargetException | IllegalAccessException e) {
-      throw new AssertionError();
+      throw assertionError("unable to get selected protocol", e);
     }
   }
 
@@ -105,11 +108,11 @@ public static Platform buildIfSupported() {
     /** This peer's supported protocols. */
     private final List<String> protocols;
     /** Set when remote peer notifies ALPN is unsupported. */
-    private boolean unsupported;
+    boolean unsupported;
     /** The protocol the server selected. */
-    private String selected;
+    String selected;
 
-    public JettyNegoProvider(List<String> protocols) {
+    JettyNegoProvider(List<String> protocols) {
       this.protocols = protocols;
     }
 
diff --git a/okhttp/src/main/java/okhttp3/internal/OptionalMethod.java b/okhttp/src/main/java/okhttp3/internal/platform/OptionalMethod.java
similarity index 98%
rename from okhttp/src/main/java/okhttp3/internal/OptionalMethod.java
rename to okhttp/src/main/java/okhttp3/internal/platform/OptionalMethod.java
index 108ec292d1..c26132fedb 100644
--- a/okhttp/src/main/java/okhttp3/internal/OptionalMethod.java
+++ b/okhttp/src/main/java/okhttp3/internal/platform/OptionalMethod.java
@@ -15,7 +15,7 @@
  *  limitations under the License.
  */
 
-package okhttp3.internal;
+package okhttp3.internal.platform;
 
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
@@ -42,7 +42,7 @@
    * @param methodName the name of the method
    * @param methodParams the method parameter types
    */
-  public OptionalMethod(Class<?> returnType, String methodName, Class... methodParams) {
+  OptionalMethod(Class<?> returnType, String methodName, Class... methodParams) {
     this.returnType = returnType;
     this.methodName = methodName;
     this.methodParams = methodParams;
diff --git a/okhttp/src/main/java/okhttp3/internal/Platform.java b/okhttp/src/main/java/okhttp3/internal/platform/Platform.java
similarity index 79%
rename from okhttp/src/main/java/okhttp3/internal/Platform.java
rename to okhttp/src/main/java/okhttp3/internal/platform/Platform.java
index 1245b6328c..c4e12b4b38 100644
--- a/okhttp/src/main/java/okhttp3/internal/Platform.java
+++ b/okhttp/src/main/java/okhttp3/internal/platform/Platform.java
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal;
+package okhttp3.internal.platform;
 
 import java.io.IOException;
 import java.lang.reflect.Field;
@@ -30,6 +30,7 @@
 import okhttp3.OkHttpClient;
 import okhttp3.Protocol;
 import okhttp3.internal.tls.BasicCertificateChainCleaner;
+import okhttp3.internal.tls.BasicTrustRootIndex;
 import okhttp3.internal.tls.CertificateChainCleaner;
 import okhttp3.internal.tls.TrustRootIndex;
 import okio.Buffer;
@@ -84,7 +85,7 @@ public String getPrefix() {
     return "OkHttp";
   }
 
-  public X509TrustManager trustManager(SSLSocketFactory sslSocketFactory) {
+  protected X509TrustManager trustManager(SSLSocketFactory sslSocketFactory) {
     // Attempt to get the trust manager from an OpenJDK socket factory. We attempt this on all
     // platforms in order to support Robolectric, which mixes classes from both Android and the
     // Oracle JDK. Note that we don't support HTTP/2 or other nice features on Robolectric.
@@ -129,10 +130,30 @@ public void log(int level, String message, Throwable t) {
     logger.log(logLevel, message, t);
   }
 
-  public boolean isCleartextTrafficPermitted() {
+  public boolean isCleartextTrafficPermitted(String hostname) {
     return true;
   }
 
+  /**
+   * Returns an object that holds a stack trace created at the moment this method is executed. This
+   * should be used specifically for {@link java.io.Closeable} objects and in conjunction with
+   * {@link #logCloseableLeak(String, Object)}.
+   */
+  public Object getStackTraceForCloseable(String closer) {
+    if (logger.isLoggable(Level.FINE)) {
+      return new Throwable(closer); // These are expensive to allocate.
+    }
+    return null;
+  }
+
+  public void logCloseableLeak(String message, Object stackTrace) {
+    if (stackTrace == null) {
+      message += " To see where this was allocated, set the OkHttpClient logger level to FINE: "
+          + "Logger.getLogger(OkHttpClient.class.getName()).setLevel(Level.FINE);";
+    }
+    log(WARN, message, (Throwable) stackTrace);
+  }
+
   public static List<String> alpnProtocolNames(List<Protocol> protocols) {
     List<String> names = new ArrayList<>(protocols.size());
     for (int i = 0, size = protocols.size(); i < size; i++) {
@@ -144,7 +165,18 @@ public boolean isCleartextTrafficPermitted() {
   }
 
   public CertificateChainCleaner buildCertificateChainCleaner(X509TrustManager trustManager) {
-    return new BasicCertificateChainCleaner(TrustRootIndex.get(trustManager));
+    return new BasicCertificateChainCleaner(buildTrustRootIndex(trustManager));
+  }
+
+  public CertificateChainCleaner buildCertificateChainCleaner(SSLSocketFactory sslSocketFactory) {
+    X509TrustManager trustManager = trustManager(sslSocketFactory);
+
+    if (trustManager == null) {
+      throw new IllegalStateException("Unable to extract the trust manager on " + Platform.get()
+          + ", sslSocketFactory is " + sslSocketFactory.getClass());
+    }
+
+    return buildCertificateChainCleaner(trustManager);
   }
 
   /** Attempt to match the host runtime to a capable Platform implementation. */
@@ -208,4 +240,8 @@ private static Platform findPlatform() {
 
     return null;
   }
+
+    public TrustRootIndex buildTrustRootIndex(X509TrustManager trustManager) {
+      return new BasicTrustRootIndex(trustManager.getAcceptedIssuers());
+    }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/publicsuffix/PublicSuffixDatabase.java b/okhttp/src/main/java/okhttp3/internal/publicsuffix/PublicSuffixDatabase.java
new file mode 100644
index 0000000000..75dafdd0a3
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/publicsuffix/PublicSuffixDatabase.java
@@ -0,0 +1,340 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.publicsuffix;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InterruptedIOException;
+import java.net.IDN;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicBoolean;
+import okhttp3.internal.Util;
+import okhttp3.internal.platform.Platform;
+import okio.BufferedSource;
+import okio.GzipSource;
+import okio.Okio;
+
+import static okhttp3.internal.Util.closeQuietly;
+
+/**
+ * A database of public suffixes provided by
+ * <a href="https://publicsuffix.org/">publicsuffix.org</a>.
+ */
+public final class PublicSuffixDatabase {
+  public static final String PUBLIC_SUFFIX_RESOURCE = "publicsuffixes.gz";
+
+  private static final byte[] WILDCARD_LABEL = new byte[]{'*'};
+  private static final String[] EMPTY_RULE = new String[0];
+  private static final String[] PREVAILING_RULE = new String[]{"*"};
+
+  private static final byte EXCEPTION_MARKER = '!';
+
+  private static final PublicSuffixDatabase instance = new PublicSuffixDatabase();
+
+  /** True after we've attempted to read the list for the first time. */
+  private final AtomicBoolean listRead = new AtomicBoolean(false);
+
+  /** Used for concurrent threads reading the list for the first time. */
+  private final CountDownLatch readCompleteLatch = new CountDownLatch(1);
+
+  // The lists are held as a large array of UTF-8 bytes. This is to avoid allocating lots of strings
+  // that will likely never be used. Each rule is separated by '\n'. Please see the
+  // PublicSuffixListGenerator class for how these lists are generated.
+  // Guarded by this.
+  private byte[] publicSuffixListBytes;
+  private byte[] publicSuffixExceptionListBytes;
+
+  public static PublicSuffixDatabase get() {
+    return instance;
+  }
+
+  /**
+   * Returns the effective top-level domain plus one (eTLD+1) by referencing the public suffix list.
+   * Returns null if the domain is a public suffix.
+   *
+   * <p>Here are some examples: <pre>{@code
+   * assertEquals("google.com", getEffectiveTldPlusOne("google.com"));
+   * assertEquals("google.com", getEffectiveTldPlusOne("www.google.com"));
+   * assertNull(getEffectiveTldPlusOne("com"));
+   * }</pre>
+   *
+   * @param domain A canonicalized domain. An International Domain Name (IDN) should be punycode
+   *    encoded.
+   */
+  public String getEffectiveTldPlusOne(String domain) {
+    if (domain == null) throw new NullPointerException("domain == null");
+
+    // We use UTF-8 in the list so we need to convert to Unicode.
+    String unicodeDomain = IDN.toUnicode(domain);
+    String[] domainLabels = unicodeDomain.split("\\.");
+    String[] rule = findMatchingRule(domainLabels);
+    if (domainLabels.length == rule.length && rule[0].charAt(0) != EXCEPTION_MARKER) {
+      // The domain is a public suffix.
+      return null;
+    }
+
+    int firstLabelOffset;
+    if (rule[0].charAt(0) == EXCEPTION_MARKER) {
+      // Exception rules hold the effective TLD plus one.
+      firstLabelOffset = domainLabels.length - rule.length;
+    } else {
+      // Otherwise the rule is for a public suffix, so we must take one more label.
+      firstLabelOffset = domainLabels.length - (rule.length + 1);
+    }
+
+    StringBuilder effectiveTldPlusOne = new StringBuilder();
+    String[] punycodeLabels = domain.split("\\.");
+    for (int i = firstLabelOffset; i < punycodeLabels.length; i++) {
+      effectiveTldPlusOne.append(punycodeLabels[i]).append('.');
+    }
+    effectiveTldPlusOne.deleteCharAt(effectiveTldPlusOne.length() - 1);
+
+    return effectiveTldPlusOne.toString();
+  }
+
+  private String[] findMatchingRule(String[] domainLabels) {
+    if (!listRead.get() && listRead.compareAndSet(false, true)) {
+      readTheListUninterruptibly();
+    } else {
+      try {
+        readCompleteLatch.await();
+      } catch (InterruptedException ignored) {
+      }
+    }
+
+    synchronized (this) {
+      if (publicSuffixListBytes == null) {
+        throw new IllegalStateException("Unable to load " + PUBLIC_SUFFIX_RESOURCE + " resource "
+            + "from the classpath.");
+      }
+    }
+
+    // Break apart the domain into UTF-8 labels, i.e. foo.bar.com turns into [foo, bar, com].
+    byte[][] domainLabelsUtf8Bytes = new byte[domainLabels.length][];
+    for (int i = 0; i < domainLabels.length; i++) {
+      domainLabelsUtf8Bytes[i] = domainLabels[i].getBytes(Util.UTF_8);
+    }
+
+    // Start by looking for exact matches. We start at the leftmost label. For example, foo.bar.com
+    // will look like: [foo, bar, com], [bar, com], [com]. The longest matching rule wins.
+    String exactMatch = null;
+    for (int i = 0; i < domainLabelsUtf8Bytes.length; i++) {
+      String rule = binarySearchBytes(publicSuffixListBytes, domainLabelsUtf8Bytes, i);
+      if (rule != null) {
+        exactMatch = rule;
+        break;
+      }
+    }
+
+    // In theory, wildcard rules are not restricted to having the wildcard in the leftmost position.
+    // In practice, wildcards are always in the leftmost position. For now, this implementation
+    // cheats and does not attempt every possible permutation. Instead, it only considers wildcards
+    // in the leftmost position. We assert this fact when we generate the public suffix file. If
+    // this assertion ever fails we'll need to refactor this implementation.
+    String wildcardMatch = null;
+    if (domainLabelsUtf8Bytes.length > 1) {
+      byte[][] labelsWithWildcard = domainLabelsUtf8Bytes.clone();
+      for (int labelIndex = 0; labelIndex < labelsWithWildcard.length - 1; labelIndex++) {
+        labelsWithWildcard[labelIndex] = WILDCARD_LABEL;
+        String rule = binarySearchBytes(publicSuffixListBytes, labelsWithWildcard, labelIndex);
+        if (rule != null) {
+          wildcardMatch = rule;
+          break;
+        }
+      }
+    }
+
+    // Exception rules only apply to wildcard rules, so only try it if we matched a wildcard.
+    String exception = null;
+    if (wildcardMatch != null) {
+      for (int labelIndex = 0; labelIndex < domainLabelsUtf8Bytes.length - 1; labelIndex++) {
+        String rule = binarySearchBytes(
+            publicSuffixExceptionListBytes, domainLabelsUtf8Bytes, labelIndex);
+        if (rule != null) {
+          exception = rule;
+          break;
+        }
+      }
+    }
+
+    if (exception != null) {
+      // Signal we've identified an exception rule.
+      exception = "!" + exception;
+      return exception.split("\\.");
+    } else if (exactMatch == null && wildcardMatch == null) {
+      return PREVAILING_RULE;
+    }
+
+    String[] exactRuleLabels = exactMatch != null
+        ? exactMatch.split("\\.")
+        : EMPTY_RULE;
+
+    String[] wildcardRuleLabels = wildcardMatch != null
+        ? wildcardMatch.split("\\.")
+        : EMPTY_RULE;
+
+    return exactRuleLabels.length > wildcardRuleLabels.length
+        ? exactRuleLabels
+        : wildcardRuleLabels;
+  }
+
+  private static String binarySearchBytes(byte[] bytesToSearch, byte[][] labels, int labelIndex) {
+    int low = 0;
+    int high = bytesToSearch.length;
+    String match = null;
+    while (low < high) {
+      int mid = (low + high) / 2;
+      // Search for a '\n' that marks the start of a value. Don't go back past the start of the
+      // array.
+      while (mid > -1 && bytesToSearch[mid] != '\n') {
+        mid--;
+      }
+      mid++;
+
+      // Now look for the ending '\n'.
+      int end = 1;
+      while (bytesToSearch[mid + end] != '\n') {
+        end++;
+      }
+      int publicSuffixLength = (mid + end) - mid;
+
+      // Compare the bytes. Note that the file stores UTF-8 encoded bytes, so we must compare the
+      // unsigned bytes.
+      int compareResult;
+      int currentLabelIndex = labelIndex;
+      int currentLabelByteIndex = 0;
+      int publicSuffixByteIndex = 0;
+
+      boolean expectDot = false;
+      while (true) {
+        int byte0;
+        if (expectDot) {
+          byte0 = '.';
+          expectDot = false;
+        } else {
+          byte0 = labels[currentLabelIndex][currentLabelByteIndex] & 0xff;
+        }
+
+        int byte1 = bytesToSearch[mid + publicSuffixByteIndex] & 0xff;
+
+        compareResult = byte0 - byte1;
+        if (compareResult != 0) break;
+
+        publicSuffixByteIndex++;
+        currentLabelByteIndex++;
+        if (publicSuffixByteIndex == publicSuffixLength) break;
+
+        if (labels[currentLabelIndex].length == currentLabelByteIndex) {
+          // We've exhausted our current label. Either there are more labels to compare, in which
+          // case we expect a dot as the next character. Otherwise, we've checked all our labels.
+          if (currentLabelIndex == labels.length - 1) {
+            break;
+          } else {
+            currentLabelIndex++;
+            currentLabelByteIndex = -1;
+            expectDot = true;
+          }
+        }
+      }
+
+      if (compareResult < 0) {
+        high = mid - 1;
+      } else if (compareResult > 0) {
+        low = mid + end + 1;
+      } else {
+        // We found a match, but are the lengths equal?
+        int publicSuffixBytesLeft = publicSuffixLength - publicSuffixByteIndex;
+        int labelBytesLeft = labels[currentLabelIndex].length - currentLabelByteIndex;
+        for (int i = currentLabelIndex + 1; i < labels.length; i++) {
+          labelBytesLeft += labels[i].length;
+        }
+
+        if (labelBytesLeft < publicSuffixBytesLeft) {
+          high = mid - 1;
+        } else if (labelBytesLeft > publicSuffixBytesLeft) {
+          low = mid + end + 1;
+        } else {
+          // Found a match.
+          match = new String(bytesToSearch, mid, publicSuffixLength, Util.UTF_8);
+          break;
+        }
+      }
+    }
+    return match;
+  }
+
+  /**
+   * Reads the public suffix list treating the operation as uninterruptible. We always want to read
+   * the list otherwise we'll be left in a bad state. If the thread was interrupted prior to this
+   * operation, it will be re-interrupted after the list is read.
+   */
+  private void readTheListUninterruptibly() {
+    boolean interrupted = false;
+    try {
+      while (true) {
+        try {
+          readTheList();
+          return;
+        } catch (InterruptedIOException e) {
+          interrupted = true;
+        } catch (IOException e) {
+          Platform.get().log(Platform.WARN, "Failed to read public suffix list", e);
+          return;
+        }
+      }
+    } finally {
+      if (interrupted) {
+        Thread.currentThread().interrupt();
+      }
+    }
+  }
+
+  private void readTheList() throws IOException {
+    byte[] publicSuffixListBytes;
+    byte[] publicSuffixExceptionListBytes;
+
+    InputStream resource = PublicSuffixDatabase.class.getResourceAsStream(PUBLIC_SUFFIX_RESOURCE);
+    if (resource == null) return;
+
+    BufferedSource bufferedSource = Okio.buffer(new GzipSource(Okio.source(resource)));
+    try {
+      int totalBytes = bufferedSource.readInt();
+      publicSuffixListBytes = new byte[totalBytes];
+      bufferedSource.readFully(publicSuffixListBytes);
+
+      int totalExceptionBytes = bufferedSource.readInt();
+      publicSuffixExceptionListBytes = new byte[totalExceptionBytes];
+      bufferedSource.readFully(publicSuffixExceptionListBytes);
+    } finally {
+      closeQuietly(bufferedSource);
+    }
+
+    synchronized (this) {
+      this.publicSuffixListBytes = publicSuffixListBytes;
+      this.publicSuffixExceptionListBytes = publicSuffixExceptionListBytes;
+    }
+
+    readCompleteLatch.countDown();
+  }
+
+  /** Visible for testing. */
+  void setListBytes(byte[] publicSuffixListBytes, byte[] publicSuffixExceptionListBytes) {
+    this.publicSuffixListBytes = publicSuffixListBytes;
+    this.publicSuffixExceptionListBytes = publicSuffixExceptionListBytes;
+    listRead.set(true);
+    readCompleteLatch.countDown();
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/tls/BasicCertificateChainCleaner.java b/okhttp/src/main/java/okhttp3/internal/tls/BasicCertificateChainCleaner.java
index be8cab093d..8a8c1d11d2 100644
--- a/okhttp/src/main/java/okhttp3/internal/tls/BasicCertificateChainCleaner.java
+++ b/okhttp/src/main/java/okhttp3/internal/tls/BasicCertificateChainCleaner.java
@@ -29,7 +29,7 @@
  * A certificate chain cleaner that uses a set of trusted root certificates to build the trusted
  * chain. This class duplicates the clean chain building performed during the TLS handshake. We
  * prefer other mechanisms where they exist, such as with
- * {@link okhttp3.internal.AndroidPlatform.AndroidCertificateChainCleaner}.
+ * {@code okhttp3.internal.platform.AndroidPlatform.AndroidCertificateChainCleaner}.
  *
  * <p>This class includes code from <a href="https://conscrypt.org/">Conscrypt's</a> {@code
  * TrustManagerImpl} and {@code TrustedCertificateIndex}.
@@ -111,4 +111,14 @@ private boolean verifySignature(X509Certificate toVerify, X509Certificate signin
       return false;
     }
   }
+
+  @Override public int hashCode() {
+    return trustRootIndex.hashCode();
+  }
+
+  @Override public boolean equals(Object other) {
+    if (other == this) return true;
+    return other instanceof BasicCertificateChainCleaner
+        && ((BasicCertificateChainCleaner) other).trustRootIndex.equals(trustRootIndex);
+  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/tls/BasicTrustRootIndex.java b/okhttp/src/main/java/okhttp3/internal/tls/BasicTrustRootIndex.java
new file mode 100644
index 0000000000..cfd8923668
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/tls/BasicTrustRootIndex.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.tls;
+
+import java.security.PublicKey;
+import java.security.cert.X509Certificate;
+import java.util.LinkedHashMap;
+import java.util.LinkedHashSet;
+import java.util.Map;
+import java.util.Set;
+import javax.security.auth.x500.X500Principal;
+
+/** A simple index that of trusted root certificates that have been loaded into memory. */
+public final class BasicTrustRootIndex implements TrustRootIndex {
+  private final Map<X500Principal, Set<X509Certificate>> subjectToCaCerts;
+
+  public BasicTrustRootIndex(X509Certificate... caCerts) {
+    subjectToCaCerts = new LinkedHashMap<>();
+    for (X509Certificate caCert : caCerts) {
+      X500Principal subject = caCert.getSubjectX500Principal();
+      Set<X509Certificate> subjectCaCerts = subjectToCaCerts.get(subject);
+      if (subjectCaCerts == null) {
+        subjectCaCerts = new LinkedHashSet<>(1);
+        subjectToCaCerts.put(subject, subjectCaCerts);
+      }
+      subjectCaCerts.add(caCert);
+    }
+  }
+
+  @Override public X509Certificate findByIssuerAndSignature(X509Certificate cert) {
+    X500Principal issuer = cert.getIssuerX500Principal();
+    Set<X509Certificate> subjectCaCerts = subjectToCaCerts.get(issuer);
+    if (subjectCaCerts == null) return null;
+
+    for (X509Certificate caCert : subjectCaCerts) {
+      PublicKey publicKey = caCert.getPublicKey();
+      try {
+        cert.verify(publicKey);
+        return caCert;
+      } catch (Exception ignored) {
+      }
+    }
+
+    return null;
+  }
+
+  @Override public boolean equals(Object other) {
+    if (other == this) return true;
+    return other instanceof okhttp3.internal.tls.BasicTrustRootIndex
+        && ((okhttp3.internal.tls.BasicTrustRootIndex) other).subjectToCaCerts.equals(
+        subjectToCaCerts);
+  }
+
+  @Override public int hashCode() {
+    return subjectToCaCerts.hashCode();
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/tls/CertificateChainCleaner.java b/okhttp/src/main/java/okhttp3/internal/tls/CertificateChainCleaner.java
index 9b7c2e2a36..98060db27a 100644
--- a/okhttp/src/main/java/okhttp3/internal/tls/CertificateChainCleaner.java
+++ b/okhttp/src/main/java/okhttp3/internal/tls/CertificateChainCleaner.java
@@ -21,7 +21,7 @@
 import java.util.List;
 import javax.net.ssl.SSLPeerUnverifiedException;
 import javax.net.ssl.X509TrustManager;
-import okhttp3.internal.Platform;
+import okhttp3.internal.platform.Platform;
 
 /**
  * Computes the effective certificate chain from the raw array returned by Java's built in TLS APIs.
@@ -42,6 +42,6 @@ public static CertificateChainCleaner get(X509TrustManager trustManager) {
   }
 
   public static CertificateChainCleaner get(X509Certificate... caCerts) {
-    return new BasicCertificateChainCleaner(TrustRootIndex.get(caCerts));
+    return new BasicCertificateChainCleaner(new BasicTrustRootIndex(caCerts));
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/tls/DistinguishedNameParser.java b/okhttp/src/main/java/okhttp3/internal/tls/DistinguishedNameParser.java
index 616bca534a..cae8dfae76 100644
--- a/okhttp/src/main/java/okhttp3/internal/tls/DistinguishedNameParser.java
+++ b/okhttp/src/main/java/okhttp3/internal/tls/DistinguishedNameParser.java
@@ -35,7 +35,7 @@
   /** Distinguished name characters. */
   private char[] chars;
 
-  public DistinguishedNameParser(X500Principal principal) {
+  DistinguishedNameParser(X500Principal principal) {
     // RFC2253 is used to ensure we get attributes in the reverse
     // order of the underlying ASN.1 encoding, so that the most
     // significant values of repeated attributes occur first.
diff --git a/okhttp/src/main/java/okhttp3/internal/tls/OkHostnameVerifier.java b/okhttp/src/main/java/okhttp3/internal/tls/OkHostnameVerifier.java
index a85df784d7..36ac5b3813 100644
--- a/okhttp/src/main/java/okhttp3/internal/tls/OkHostnameVerifier.java
+++ b/okhttp/src/main/java/okhttp3/internal/tls/OkHostnameVerifier.java
@@ -27,7 +27,6 @@
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLException;
 import javax.net.ssl.SSLSession;
-import javax.security.auth.x500.X500Principal;
 
 import static okhttp3.internal.Util.verifyAsIpAddress;
 
@@ -73,24 +72,12 @@ private boolean verifyIpAddress(String ipAddress, X509Certificate certificate) {
   /** Returns true if {@code certificate} matches {@code hostname}. */
   private boolean verifyHostname(String hostname, X509Certificate certificate) {
     hostname = hostname.toLowerCase(Locale.US);
-    boolean hasDns = false;
     List<String> altNames = getSubjectAltNames(certificate, ALT_DNS_NAME);
-    for (int i = 0, size = altNames.size(); i < size; i++) {
-      hasDns = true;
-      if (verifyHostname(hostname, altNames.get(i))) {
+    for (String altName : altNames) {
+      if (verifyHostname(hostname, altName)) {
         return true;
       }
     }
-
-    if (!hasDns) {
-      X500Principal principal = certificate.getSubjectX500Principal();
-      // RFC 2818 advises using the most specific name for matching.
-      String cn = new DistinguishedNameParser(principal).findMostSpecific("cn");
-      if (cn != null) {
-        return verifyHostname(hostname, cn);
-      }
-    }
-
     return false;
   }
 
@@ -139,7 +126,7 @@ private boolean verifyHostname(String hostname, X509Certificate certificate) {
    * @param pattern domain name pattern from certificate. May be a wildcard pattern such as {@code
    * *.android.com}.
    */
-  private boolean verifyHostname(String hostname, String pattern) {
+  public boolean verifyHostname(String hostname, String pattern) {
     // Basic sanity checks
     // Check length == 0 instead of .isEmpty() to support Java 5.
     if ((hostname == null) || (hostname.length() == 0) || (hostname.startsWith("."))
diff --git a/okhttp/src/main/java/okhttp3/internal/tls/TrustRootIndex.java b/okhttp/src/main/java/okhttp3/internal/tls/TrustRootIndex.java
index 8b5439b182..499f120e33 100644
--- a/okhttp/src/main/java/okhttp3/internal/tls/TrustRootIndex.java
+++ b/okhttp/src/main/java/okhttp3/internal/tls/TrustRootIndex.java
@@ -15,104 +15,9 @@
  */
 package okhttp3.internal.tls;
 
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.security.PublicKey;
-import java.security.cert.TrustAnchor;
 import java.security.cert.X509Certificate;
-import java.util.ArrayList;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-import javax.net.ssl.X509TrustManager;
-import javax.security.auth.x500.X500Principal;
 
-public abstract class TrustRootIndex {
+public interface TrustRootIndex {
   /** Returns the trusted CA certificate that signed {@code cert}. */
-  public abstract X509Certificate findByIssuerAndSignature(X509Certificate cert);
-
-  public static TrustRootIndex get(X509TrustManager trustManager) {
-    try {
-      // From org.conscrypt.TrustManagerImpl, we want the method with this signature:
-      // private TrustAnchor findTrustAnchorByIssuerAndSignature(X509Certificate lastCert);
-      Method method = trustManager.getClass().getDeclaredMethod(
-          "findTrustAnchorByIssuerAndSignature", X509Certificate.class);
-      method.setAccessible(true);
-      return new AndroidTrustRootIndex(trustManager, method);
-    } catch (NoSuchMethodException e) {
-      return get(trustManager.getAcceptedIssuers());
-    }
-  }
-
-  public static TrustRootIndex get(X509Certificate... caCerts) {
-    return new BasicTrustRootIndex(caCerts);
-  }
-
-  /**
-   * An index of trusted root certificates that exploits knowledge of Android implementation
-   * details. This class is potentially much faster to initialize than {@link BasicTrustRootIndex}
-   * because it doesn't need to load and index trusted CA certificates.
-   *
-   * <p>This class uses APIs added to Android in API 14 (Android 4.0, released October 2011). This
-   * class shouldn't be used in Android API 17 or better because those releases are better served by
-   * {@link okhttp3.internal.AndroidPlatform.AndroidCertificateChainCleaner}.
-   */
-  static final class AndroidTrustRootIndex extends TrustRootIndex {
-    private final X509TrustManager trustManager;
-    private final Method findByIssuerAndSignatureMethod;
-
-    AndroidTrustRootIndex(X509TrustManager trustManager, Method findByIssuerAndSignatureMethod) {
-      this.findByIssuerAndSignatureMethod = findByIssuerAndSignatureMethod;
-      this.trustManager = trustManager;
-    }
-
-    @Override public X509Certificate findByIssuerAndSignature(X509Certificate cert) {
-      try {
-        TrustAnchor trustAnchor = (TrustAnchor) findByIssuerAndSignatureMethod.invoke(
-            trustManager, cert);
-        return trustAnchor != null
-            ? trustAnchor.getTrustedCert()
-            : null;
-      } catch (IllegalAccessException e) {
-        throw new AssertionError();
-      } catch (InvocationTargetException e) {
-        return null;
-      }
-    }
-  }
-
-  /** A simple index that of trusted root certificates that have been loaded into memory. */
-  static final class BasicTrustRootIndex extends TrustRootIndex {
-    private final Map<X500Principal, List<X509Certificate>> subjectToCaCerts;
-
-    public BasicTrustRootIndex(X509Certificate... caCerts) {
-      subjectToCaCerts = new LinkedHashMap<>();
-      for (X509Certificate caCert : caCerts) {
-        X500Principal subject = caCert.getSubjectX500Principal();
-        List<X509Certificate> subjectCaCerts = subjectToCaCerts.get(subject);
-        if (subjectCaCerts == null) {
-          subjectCaCerts = new ArrayList<>(1);
-          subjectToCaCerts.put(subject, subjectCaCerts);
-        }
-        subjectCaCerts.add(caCert);
-      }
-    }
-
-    @Override public X509Certificate findByIssuerAndSignature(X509Certificate cert) {
-      X500Principal issuer = cert.getIssuerX500Principal();
-      List<X509Certificate> subjectCaCerts = subjectToCaCerts.get(issuer);
-      if (subjectCaCerts == null) return null;
-
-      for (X509Certificate caCert : subjectCaCerts) {
-        PublicKey publicKey = caCert.getPublicKey();
-        try {
-          cert.verify(publicKey);
-          return caCert;
-        } catch (Exception ignored) {
-        }
-      }
-
-      return null;
-    }
-  }
+  X509Certificate findByIssuerAndSignature(X509Certificate cert);
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java b/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java
new file mode 100644
index 0000000000..0d39abc8d5
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java
@@ -0,0 +1,591 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.ws;
+
+import java.io.Closeable;
+import java.io.IOException;
+import java.net.ProtocolException;
+import java.util.ArrayDeque;
+import java.util.Collections;
+import java.util.List;
+import java.util.Random;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.ScheduledFuture;
+import java.util.concurrent.ScheduledThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+import javax.annotation.Nullable;
+import okhttp3.Call;
+import okhttp3.Callback;
+import okhttp3.EventListener;
+import okhttp3.OkHttpClient;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.WebSocket;
+import okhttp3.WebSocketListener;
+import okhttp3.internal.Internal;
+import okhttp3.internal.Util;
+import okhttp3.internal.connection.StreamAllocation;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.ByteString;
+import okio.Okio;
+
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static okhttp3.internal.Util.closeQuietly;
+import static okhttp3.internal.ws.WebSocketProtocol.CLOSE_CLIENT_GOING_AWAY;
+import static okhttp3.internal.ws.WebSocketProtocol.CLOSE_MESSAGE_MAX;
+import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_BINARY;
+import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_TEXT;
+import static okhttp3.internal.ws.WebSocketProtocol.validateCloseCode;
+
+public final class RealWebSocket implements WebSocket, WebSocketReader.FrameCallback {
+  private static final List<Protocol> ONLY_HTTP1 = Collections.singletonList(Protocol.HTTP_1_1);
+
+  /**
+   * The maximum number of bytes to enqueue. Rather than enqueueing beyond this limit we tear down
+   * the web socket! It's possible that we're writing faster than the peer can read.
+   */
+  private static final long MAX_QUEUE_SIZE = 16 * 1024 * 1024; // 16 MiB.
+
+  /**
+   * The maximum amount of time after the client calls {@link #close} to wait for a graceful
+   * shutdown. If the server doesn't respond the websocket will be canceled.
+   */
+  private static final long CANCEL_AFTER_CLOSE_MILLIS = 60 * 1000;
+
+  /** The application's original request unadulterated by web socket headers. */
+  private final Request originalRequest;
+
+  final WebSocketListener listener;
+  private final Random random;
+  private final String key;
+
+  /** Non-null for client web sockets. These can be canceled. */
+  private Call call;
+
+  /** This runnable processes the outgoing queues. Call {@link #runWriter()} to after enqueueing. */
+  private final Runnable writerRunnable;
+
+  /** Null until this web socket is connected. Only accessed by the reader thread. */
+  private WebSocketReader reader;
+
+  // All mutable web socket state is guarded by this.
+
+  /** Null until this web socket is connected. Note that messages may be enqueued before that. */
+  private WebSocketWriter writer;
+
+  /** Null until this web socket is connected. Used for writes, pings, and close timeouts. */
+  private ScheduledExecutorService executor;
+
+  /**
+   * The streams held by this web socket. This is non-null until all incoming messages have been
+   * read and all outgoing messages have been written. It is closed when both reader and writer are
+   * exhausted, or if there is any failure.
+   */
+  private Streams streams;
+
+  /** Outgoing pongs in the order they should be written. */
+  private final ArrayDeque<ByteString> pongQueue = new ArrayDeque<>();
+
+  /** Outgoing messages and close frames in the order they should be written. */
+  private final ArrayDeque<Object> messageAndCloseQueue = new ArrayDeque<>();
+
+  /** The total size in bytes of enqueued but not yet transmitted messages. */
+  private long queueSize;
+
+  /** True if we've enqueued a close frame. No further message frames will be enqueued. */
+  private boolean enqueuedClose;
+
+  /**
+   * When executed this will cancel this websocket. This future itself should be canceled if that is
+   * unnecessary because the web socket is already closed or canceled.
+   */
+  private ScheduledFuture<?> cancelFuture;
+
+  /** The close code from the peer, or -1 if this web socket has not yet read a close frame. */
+  private int receivedCloseCode = -1;
+
+  /** The close reason from the peer, or null if this web socket has not yet read a close frame. */
+  private String receivedCloseReason;
+
+  /** True if this web socket failed and the listener has been notified. */
+  private boolean failed;
+
+  /** For testing. */
+  int pingCount;
+
+  /** For testing. */
+  int pongCount;
+
+  public RealWebSocket(Request request, WebSocketListener listener, Random random) {
+    if (!"GET".equals(request.method())) {
+      throw new IllegalArgumentException("Request must be GET: " + request.method());
+    }
+    this.originalRequest = request;
+    this.listener = listener;
+    this.random = random;
+
+    byte[] nonce = new byte[16];
+    random.nextBytes(nonce);
+    this.key = ByteString.of(nonce).base64();
+
+    this.writerRunnable = new Runnable() {
+      @Override public void run() {
+        try {
+          while (writeOneFrame()) {
+          }
+        } catch (IOException e) {
+          failWebSocket(e, null);
+        }
+      }
+    };
+  }
+
+  @Override public Request request() {
+    return originalRequest;
+  }
+
+  @Override public synchronized long queueSize() {
+    return queueSize;
+  }
+
+  @Override public void cancel() {
+    call.cancel();
+  }
+
+  public void connect(OkHttpClient client) {
+    client = client.newBuilder()
+        .eventListener(EventListener.NONE)
+        .protocols(ONLY_HTTP1)
+        .build();
+    final int pingIntervalMillis = client.pingIntervalMillis();
+    final Request request = originalRequest.newBuilder()
+        .header("Upgrade", "websocket")
+        .header("Connection", "Upgrade")
+        .header("Sec-WebSocket-Key", key)
+        .header("Sec-WebSocket-Version", "13")
+        .build();
+    call = Internal.instance.newWebSocketCall(client, request);
+    call.enqueue(new Callback() {
+      @Override public void onResponse(Call call, Response response) {
+        try {
+          checkResponse(response);
+        } catch (ProtocolException e) {
+          failWebSocket(e, response);
+          closeQuietly(response);
+          return;
+        }
+
+        // Promote the HTTP streams into web socket streams.
+        StreamAllocation streamAllocation = Internal.instance.streamAllocation(call);
+        streamAllocation.noNewStreams(); // Prevent connection pooling!
+        Streams streams = streamAllocation.connection().newWebSocketStreams(streamAllocation);
+
+        // Process all web socket messages.
+        try {
+          listener.onOpen(RealWebSocket.this, response);
+          String name = "OkHttp WebSocket " + request.url().redact();
+          initReaderAndWriter(name, pingIntervalMillis, streams);
+          streamAllocation.connection().socket().setSoTimeout(0);
+          loopReader();
+        } catch (Exception e) {
+          failWebSocket(e, null);
+        }
+      }
+
+      @Override public void onFailure(Call call, IOException e) {
+        failWebSocket(e, null);
+      }
+    });
+  }
+
+  void checkResponse(Response response) throws ProtocolException {
+    if (response.code() != 101) {
+      throw new ProtocolException("Expected HTTP 101 response but was '"
+          + response.code() + " " + response.message() + "'");
+    }
+
+    String headerConnection = response.header("Connection");
+    if (!"Upgrade".equalsIgnoreCase(headerConnection)) {
+      throw new ProtocolException("Expected 'Connection' header value 'Upgrade' but was '"
+          + headerConnection + "'");
+    }
+
+    String headerUpgrade = response.header("Upgrade");
+    if (!"websocket".equalsIgnoreCase(headerUpgrade)) {
+      throw new ProtocolException(
+          "Expected 'Upgrade' header value 'websocket' but was '" + headerUpgrade + "'");
+    }
+
+    String headerAccept = response.header("Sec-WebSocket-Accept");
+    String acceptExpected = ByteString.encodeUtf8(key + WebSocketProtocol.ACCEPT_MAGIC)
+        .sha1().base64();
+    if (!acceptExpected.equals(headerAccept)) {
+      throw new ProtocolException("Expected 'Sec-WebSocket-Accept' header value '"
+          + acceptExpected + "' but was '" + headerAccept + "'");
+    }
+  }
+
+  public void initReaderAndWriter(
+      String name, long pingIntervalMillis, Streams streams) throws IOException {
+    synchronized (this) {
+      this.streams = streams;
+      this.writer = new WebSocketWriter(streams.client, streams.sink, random);
+      this.executor = new ScheduledThreadPoolExecutor(1, Util.threadFactory(name, false));
+      if (pingIntervalMillis != 0) {
+        executor.scheduleAtFixedRate(
+            new PingRunnable(), pingIntervalMillis, pingIntervalMillis, MILLISECONDS);
+      }
+      if (!messageAndCloseQueue.isEmpty()) {
+        runWriter(); // Send messages that were enqueued before we were connected.
+      }
+    }
+
+    reader = new WebSocketReader(streams.client, streams.source, this);
+  }
+
+  /** Receive frames until there are no more. Invoked only by the reader thread. */
+  public void loopReader() throws IOException {
+    while (receivedCloseCode == -1) {
+      // This method call results in one or more onRead* methods being called on this thread.
+      reader.processNextFrame();
+    }
+  }
+
+  /**
+   * For testing: receive a single frame and return true if there are more frames to read. Invoked
+   * only by the reader thread.
+   */
+  boolean processNextFrame() throws IOException {
+    try {
+      reader.processNextFrame();
+      return receivedCloseCode == -1;
+    } catch (Exception e) {
+      failWebSocket(e, null);
+      return false;
+    }
+  }
+
+  /**
+   * For testing: wait until the web socket's executor has terminated.
+   */
+  void awaitTermination(int timeout, TimeUnit timeUnit) throws InterruptedException {
+    executor.awaitTermination(timeout, timeUnit);
+  }
+
+  /**
+   * For testing: force this web socket to release its threads.
+   */
+  void tearDown() throws InterruptedException {
+    if (cancelFuture != null) {
+      cancelFuture.cancel(false);
+    }
+    executor.shutdown();
+    executor.awaitTermination(10, TimeUnit.SECONDS);
+  }
+
+  synchronized int pingCount() {
+    return pingCount;
+  }
+
+  synchronized int pongCount() {
+    return pongCount;
+  }
+
+  @Override public void onReadMessage(String text) throws IOException {
+    listener.onMessage(this, text);
+  }
+
+  @Override public void onReadMessage(ByteString bytes) throws IOException {
+    listener.onMessage(this, bytes);
+  }
+
+  @Override public synchronized void onReadPing(ByteString payload) {
+    // Don't respond to pings after we've failed or sent the close frame.
+    if (failed || (enqueuedClose && messageAndCloseQueue.isEmpty())) return;
+
+    pongQueue.add(payload);
+    runWriter();
+    pingCount++;
+  }
+
+  @Override public synchronized void onReadPong(ByteString buffer) {
+    // This API doesn't expose pings.
+    pongCount++;
+  }
+
+  @Override public void onReadClose(int code, String reason) {
+    if (code == -1) throw new IllegalArgumentException();
+
+    Streams toClose = null;
+    synchronized (this) {
+      if (receivedCloseCode != -1) throw new IllegalStateException("already closed");
+      receivedCloseCode = code;
+      receivedCloseReason = reason;
+      if (enqueuedClose && messageAndCloseQueue.isEmpty()) {
+        toClose = this.streams;
+        this.streams = null;
+        if (cancelFuture != null) cancelFuture.cancel(false);
+        this.executor.shutdown();
+      }
+    }
+
+    try {
+      listener.onClosing(this, code, reason);
+
+      if (toClose != null) {
+        listener.onClosed(this, code, reason);
+      }
+    } finally {
+      closeQuietly(toClose);
+    }
+  }
+
+  // Writer methods to enqueue frames. They'll be sent asynchronously by the writer thread.
+
+  @Override public boolean send(String text) {
+    if (text == null) throw new NullPointerException("text == null");
+    return send(ByteString.encodeUtf8(text), OPCODE_TEXT);
+  }
+
+  @Override public boolean send(ByteString bytes) {
+    if (bytes == null) throw new NullPointerException("bytes == null");
+    return send(bytes, OPCODE_BINARY);
+  }
+
+  private synchronized boolean send(ByteString data, int formatOpcode) {
+    // Don't send new frames after we've failed or enqueued a close frame.
+    if (failed || enqueuedClose) return false;
+
+    // If this frame overflows the buffer, reject it and close the web socket.
+    if (queueSize + data.size() > MAX_QUEUE_SIZE) {
+      close(CLOSE_CLIENT_GOING_AWAY, null);
+      return false;
+    }
+
+    // Enqueue the message frame.
+    queueSize += data.size();
+    messageAndCloseQueue.add(new Message(formatOpcode, data));
+    runWriter();
+    return true;
+  }
+
+  synchronized boolean pong(ByteString payload) {
+    // Don't send pongs after we've failed or sent the close frame.
+    if (failed || (enqueuedClose && messageAndCloseQueue.isEmpty())) return false;
+
+    pongQueue.add(payload);
+    runWriter();
+    return true;
+  }
+
+  @Override public boolean close(int code, String reason) {
+    return close(code, reason, CANCEL_AFTER_CLOSE_MILLIS);
+  }
+
+  synchronized boolean close(int code, String reason, long cancelAfterCloseMillis) {
+    validateCloseCode(code);
+
+    ByteString reasonBytes = null;
+    if (reason != null) {
+      reasonBytes = ByteString.encodeUtf8(reason);
+      if (reasonBytes.size() > CLOSE_MESSAGE_MAX) {
+        throw new IllegalArgumentException("reason.size() > " + CLOSE_MESSAGE_MAX + ": " + reason);
+      }
+    }
+
+    if (failed || enqueuedClose) return false;
+
+    // Immediately prevent further frames from being enqueued.
+    enqueuedClose = true;
+
+    // Enqueue the close frame.
+    messageAndCloseQueue.add(new Close(code, reasonBytes, cancelAfterCloseMillis));
+    runWriter();
+    return true;
+  }
+
+  private void runWriter() {
+    assert (Thread.holdsLock(this));
+
+    if (executor != null) {
+      executor.execute(writerRunnable);
+    }
+  }
+
+  /**
+   * Attempts to remove a single frame from a queue and send it. This prefers to write urgent pongs
+   * before less urgent messages and close frames. For example it's possible that a caller will
+   * enqueue messages followed by pongs, but this sends pongs followed by messages. Pongs are always
+   * written in the order they were enqueued.
+   *
+   * <p>If a frame cannot be sent - because there are none enqueued or because the web socket is not
+   * connected - this does nothing and returns false. Otherwise this returns true and the caller
+   * should immediately invoke this method again until it returns false.
+   *
+   * <p>This method may only be invoked by the writer thread. There may be only thread invoking this
+   * method at a time.
+   */
+  boolean writeOneFrame() throws IOException {
+    WebSocketWriter writer;
+    ByteString pong;
+    Object messageOrClose = null;
+    int receivedCloseCode = -1;
+    String receivedCloseReason = null;
+    Streams streamsToClose = null;
+
+    synchronized (RealWebSocket.this) {
+      if (failed) {
+        return false; // Failed web socket.
+      }
+
+      writer = this.writer;
+      pong = pongQueue.poll();
+      if (pong == null) {
+        messageOrClose = messageAndCloseQueue.poll();
+        if (messageOrClose instanceof Close) {
+          receivedCloseCode = this.receivedCloseCode;
+          receivedCloseReason = this.receivedCloseReason;
+          if (receivedCloseCode != -1) {
+            streamsToClose = this.streams;
+            this.streams = null;
+            this.executor.shutdown();
+          } else {
+            // When we request a graceful close also schedule a cancel of the websocket.
+            cancelFuture = executor.schedule(new CancelRunnable(),
+                ((Close) messageOrClose).cancelAfterCloseMillis, MILLISECONDS);
+          }
+        } else if (messageOrClose == null) {
+          return false; // The queue is exhausted.
+        }
+      }
+    }
+
+    try {
+      if (pong != null) {
+        writer.writePong(pong);
+
+      } else if (messageOrClose instanceof Message) {
+        ByteString data = ((Message) messageOrClose).data;
+        BufferedSink sink = Okio.buffer(writer.newMessageSink(
+            ((Message) messageOrClose).formatOpcode, data.size()));
+        sink.write(data);
+        sink.close();
+        synchronized (this) {
+          queueSize -= data.size();
+        }
+
+      } else if (messageOrClose instanceof Close) {
+        Close close = (Close) messageOrClose;
+        writer.writeClose(close.code, close.reason);
+
+        // We closed the writer: now both reader and writer are closed.
+        if (streamsToClose != null) {
+          listener.onClosed(this, receivedCloseCode, receivedCloseReason);
+        }
+
+      } else {
+        throw new AssertionError();
+      }
+
+      return true;
+    } finally {
+      closeQuietly(streamsToClose);
+    }
+  }
+
+  private final class PingRunnable implements Runnable {
+    PingRunnable() {
+    }
+
+    @Override public void run() {
+      writePingFrame();
+    }
+  }
+
+  void writePingFrame() {
+    WebSocketWriter writer;
+    synchronized (this) {
+      if (failed) return;
+      writer = this.writer;
+    }
+
+    try {
+      writer.writePing(ByteString.EMPTY);
+    } catch (IOException e) {
+      failWebSocket(e, null);
+    }
+  }
+
+  public void failWebSocket(Exception e, @Nullable Response response) {
+    Streams streamsToClose;
+    synchronized (this) {
+      if (failed) return; // Already failed.
+      failed = true;
+      streamsToClose = this.streams;
+      this.streams = null;
+      if (cancelFuture != null) cancelFuture.cancel(false);
+      if (executor != null) executor.shutdown();
+    }
+
+    try {
+      listener.onFailure(this, e, response);
+    } finally {
+      closeQuietly(streamsToClose);
+    }
+  }
+
+  static final class Message {
+    final int formatOpcode;
+    final ByteString data;
+
+    Message(int formatOpcode, ByteString data) {
+      this.formatOpcode = formatOpcode;
+      this.data = data;
+    }
+  }
+
+  static final class Close {
+    final int code;
+    final ByteString reason;
+    final long cancelAfterCloseMillis;
+
+    Close(int code, ByteString reason, long cancelAfterCloseMillis) {
+      this.code = code;
+      this.reason = reason;
+      this.cancelAfterCloseMillis = cancelAfterCloseMillis;
+    }
+  }
+
+  public abstract static class Streams implements Closeable {
+    public final boolean client;
+    public final BufferedSource source;
+    public final BufferedSink sink;
+
+    public Streams(boolean client, BufferedSource source, BufferedSink sink) {
+      this.client = client;
+      this.source = source;
+      this.sink = sink;
+    }
+  }
+
+  final class CancelRunnable implements Runnable {
+    @Override public void run() {
+      cancel();
+    }
+  }
+}
diff --git a/okhttp-ws/src/main/java/okhttp3/internal/ws/WebSocketProtocol.java b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketProtocol.java
similarity index 74%
rename from okhttp-ws/src/main/java/okhttp3/internal/ws/WebSocketProtocol.java
rename to okhttp/src/main/java/okhttp3/internal/ws/WebSocketProtocol.java
index 0a1126a147..5be61eea5f 100644
--- a/okhttp-ws/src/main/java/okhttp3/internal/ws/WebSocketProtocol.java
+++ b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketProtocol.java
@@ -15,11 +15,13 @@
  */
 package okhttp3.internal.ws;
 
+import java.io.IOException;
 import java.net.ProtocolException;
+import okio.ByteString;
 
 public final class WebSocketProtocol {
   /** Magic value which must be appended to the key in a response header. */
-  public static final String ACCEPT_MAGIC = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
+  static final String ACCEPT_MAGIC = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
 
   /*
   Each frame starts with two bytes of data.
@@ -72,6 +74,8 @@
    * special values {@link #PAYLOAD_SHORT} or {@link #PAYLOAD_LONG}.
    */
   static final long PAYLOAD_BYTE_MAX = 125L;
+  /** Maximum length of close message in bytes. */
+  static final long CLOSE_MESSAGE_MAX = PAYLOAD_BYTE_MAX - 2;
   /**
    * Value for {@link #B1_MASK_LENGTH} which indicates the next two bytes are the unsigned length.
    */
@@ -84,6 +88,15 @@
    */
   static final int PAYLOAD_LONG = 127;
 
+  /** Used when an unchecked exception was thrown in a listener. */
+  static final int CLOSE_CLIENT_GOING_AWAY = 1001;
+  /** Used when a {@link ProtocolException} was thrown by the reader or writer. */
+  static final int CLOSE_PROTOCOL_EXCEPTION = 1002;
+  /** Used when an empty close frame was received (i.e., without a status code). */
+  static final int CLOSE_NO_STATUS_CODE = 1005;
+  /** Used when a non-{@link ProtocolException} {@link IOException} was thrown by the reader. */
+  static final int CLOSE_ABNORMAL_TERMINATION = 1006;
+
   static void toggleMask(byte[] buffer, long byteCount, byte[] key, long frameBytesRead) {
     int keyLength = key.length;
     for (int i = 0; i < byteCount; i++, frameBytesRead++) {
@@ -92,21 +105,25 @@ static void toggleMask(byte[] buffer, long byteCount, byte[] key, long frameByte
     }
   }
 
-  static void validateCloseCode(int code, boolean argument) throws ProtocolException {
-    String message = null;
+  static String closeCodeExceptionMessage(int code) {
     if (code < 1000 || code >= 5000) {
-      message = "Code must be in range [1000,5000): " + code;
+      return "Code must be in range [1000,5000): " + code;
     } else if ((code >= 1004 && code <= 1006) || (code >= 1012 && code <= 2999)) {
-      message = "Code " + code + " is reserved and may not be used.";
-    }
-    if (message != null) {
-      if (argument) {
-        throw new IllegalArgumentException(message);
-      }
-      throw new ProtocolException(message);
+      return "Code " + code + " is reserved and may not be used.";
+    } else {
+      return null;
     }
   }
 
+  static void validateCloseCode(int code) {
+    String message = closeCodeExceptionMessage(code);
+    if (message != null) throw new IllegalArgumentException(message);
+  }
+
+  public static String acceptHeader(String key) {
+    return ByteString.encodeUtf8(key + WebSocketProtocol.ACCEPT_MAGIC).sha1().base64();
+  }
+
   private WebSocketProtocol() {
     throw new AssertionError("No instances.");
   }
diff --git a/okhttp-ws/src/main/java/okhttp3/internal/ws/WebSocketReader.java b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketReader.java
similarity index 64%
rename from okhttp-ws/src/main/java/okhttp3/internal/ws/WebSocketReader.java
rename to okhttp/src/main/java/okhttp3/internal/ws/WebSocketReader.java
index 8be28a2c5a..f2844737cc 100644
--- a/okhttp-ws/src/main/java/okhttp3/internal/ws/WebSocketReader.java
+++ b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketReader.java
@@ -18,14 +18,10 @@
 import java.io.EOFException;
 import java.io.IOException;
 import java.net.ProtocolException;
-import okhttp3.MediaType;
-import okhttp3.ResponseBody;
-import okhttp3.ws.WebSocket;
+import java.util.concurrent.TimeUnit;
 import okio.Buffer;
 import okio.BufferedSource;
-import okio.Okio;
-import okio.Source;
-import okio.Timeout;
+import okio.ByteString;
 
 import static java.lang.Integer.toHexString;
 import static okhttp3.internal.ws.WebSocketProtocol.B0_FLAG_FIN;
@@ -35,6 +31,7 @@
 import static okhttp3.internal.ws.WebSocketProtocol.B0_MASK_OPCODE;
 import static okhttp3.internal.ws.WebSocketProtocol.B1_FLAG_MASK;
 import static okhttp3.internal.ws.WebSocketProtocol.B1_MASK_LENGTH;
+import static okhttp3.internal.ws.WebSocketProtocol.CLOSE_NO_STATUS_CODE;
 import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_BINARY;
 import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_CONTINUATION;
 import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_CONTROL_CLOSE;
@@ -46,43 +43,39 @@
 import static okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_LONG;
 import static okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_SHORT;
 import static okhttp3.internal.ws.WebSocketProtocol.toggleMask;
-import static okhttp3.internal.ws.WebSocketProtocol.validateCloseCode;
 
 /**
  * An <a href="http://tools.ietf.org/html/rfc6455">RFC 6455</a>-compatible WebSocket frame reader.
+ *
+ * <p>This class is not thread safe.
  */
-public final class WebSocketReader {
+final class WebSocketReader {
   public interface FrameCallback {
-    void onMessage(ResponseBody body) throws IOException;
-
-    void onPing(Buffer buffer);
-
-    void onPong(Buffer buffer);
-
-    void onClose(int code, String reason);
+    void onReadMessage(String text) throws IOException;
+    void onReadMessage(ByteString bytes) throws IOException;
+    void onReadPing(ByteString buffer);
+    void onReadPong(ByteString buffer);
+    void onReadClose(int code, String reason);
   }
 
-  private final boolean isClient;
-  private final BufferedSource source;
-  private final FrameCallback frameCallback;
+  final boolean isClient;
+  final BufferedSource source;
+  final FrameCallback frameCallback;
 
-  private final Source framedMessageSource = new FramedMessageSource();
-
-  private boolean closed;
-  private boolean messageClosed;
+  boolean closed;
 
   // Stateful data about the current frame.
-  private int opcode;
-  private long frameLength;
-  private long frameBytesRead;
-  private boolean isFinalFrame;
-  private boolean isControlFrame;
-  private boolean isMasked;
+  int opcode;
+  long frameLength;
+  long frameBytesRead;
+  boolean isFinalFrame;
+  boolean isControlFrame;
+  boolean isMasked;
 
-  private final byte[] maskKey = new byte[4];
-  private final byte[] maskBuffer = new byte[8192];
+  final byte[] maskKey = new byte[4];
+  final byte[] maskBuffer = new byte[8192];
 
-  public WebSocketReader(boolean isClient, BufferedSource source, FrameCallback frameCallback) {
+  WebSocketReader(boolean isClient, BufferedSource source, FrameCallback frameCallback) {
     if (source == null) throw new NullPointerException("source == null");
     if (frameCallback == null) throw new NullPointerException("frameCallback == null");
     this.isClient = isClient;
@@ -96,11 +89,11 @@ public WebSocketReader(boolean isClient, BufferedSource source, FrameCallback fr
    * <ul>
    *     <li>If it is a control frame this will result in a single call to {@link FrameCallback}.
    *     <li>If it is a message frame this will result in a single call to {@link
-   *         FrameCallback#onMessage}. If the message spans multiple frames, each interleaved
+   *         FrameCallback#onReadMessage}. If the message spans multiple frames, each interleaved
    *         control frame will result in a corresponding call to {@link FrameCallback}.
    * </ul>
    */
-  public void processNextFrame() throws IOException {
+  void processNextFrame() throws IOException {
     readHeader();
     if (isControlFrame) {
       readControlFrame();
@@ -112,7 +105,15 @@ public void processNextFrame() throws IOException {
   private void readHeader() throws IOException {
     if (closed) throw new IOException("closed");
 
-    int b0 = source.readByte() & 0xff;
+    // Disable the timeout to read the first byte of a new frame.
+    int b0;
+    long timeoutBefore = source.timeout().timeoutNanos();
+    source.timeout().clearTimeout();
+    try {
+      b0 = source.readByte() & 0xff;
+    } finally {
+      source.timeout().timeout(timeoutBefore, TimeUnit.NANOSECONDS);
+    }
 
     opcode = b0 & B0_MASK_OPCODE;
     isFinalFrame = (b0 & B0_FLAG_FIN) != 0;
@@ -136,7 +137,9 @@ private void readHeader() throws IOException {
     isMasked = (b1 & B1_FLAG_MASK) != 0;
     if (isMasked == isClient) {
       // Masked payloads must be read on the server. Unmasked payloads must be read on the client.
-      throw new ProtocolException("Client-sent frames must be masked. Server sent must not.");
+      throw new ProtocolException(isClient
+          ? "Server-sent frames must not be masked."
+          : "Client-sent frames must be masked.");
     }
 
     // Get frame length, optionally reading from follow-up bytes if indicated by special values.
@@ -163,10 +166,8 @@ private void readHeader() throws IOException {
   }
 
   private void readControlFrame() throws IOException {
-    Buffer buffer = null;
+    Buffer buffer = new Buffer();
     if (frameBytesRead < frameLength) {
-      buffer = new Buffer();
-
       if (isClient) {
         source.readFully(buffer, frameLength);
       } else {
@@ -183,26 +184,24 @@ private void readControlFrame() throws IOException {
 
     switch (opcode) {
       case OPCODE_CONTROL_PING:
-        frameCallback.onPing(buffer);
+        frameCallback.onReadPing(buffer.readByteString());
         break;
       case OPCODE_CONTROL_PONG:
-        frameCallback.onPong(buffer);
+        frameCallback.onReadPong(buffer.readByteString());
         break;
       case OPCODE_CONTROL_CLOSE:
-        int code = 1000;
+        int code = CLOSE_NO_STATUS_CODE;
         String reason = "";
-        if (buffer != null) {
-          long bufferSize = buffer.size();
-          if (bufferSize == 1) {
-            throw new ProtocolException("Malformed close payload length of 1.");
-          } else if (bufferSize != 0) {
-            code = buffer.readShort();
-            validateCloseCode(code, false);
-
-            reason = buffer.readUtf8();
-          }
+        long bufferSize = buffer.size();
+        if (bufferSize == 1) {
+          throw new ProtocolException("Malformed close payload length of 1.");
+        } else if (bufferSize != 0) {
+          code = buffer.readShort();
+          reason = buffer.readUtf8();
+          String codeExceptionMessage = WebSocketProtocol.closeCodeExceptionMessage(code);
+          if (codeExceptionMessage != null) throw new ProtocolException(codeExceptionMessage);
         }
-        frameCallback.onClose(code, reason);
+        frameCallback.onReadClose(code, reason);
         closed = true;
         break;
       default:
@@ -211,42 +210,23 @@ private void readControlFrame() throws IOException {
   }
 
   private void readMessageFrame() throws IOException {
-    final MediaType type;
-    switch (opcode) {
-      case OPCODE_TEXT:
-        type = WebSocket.TEXT;
-        break;
-      case OPCODE_BINARY:
-        type = WebSocket.BINARY;
-        break;
-      default:
-        throw new ProtocolException("Unknown opcode: " + toHexString(opcode));
+    int opcode = this.opcode;
+    if (opcode != OPCODE_TEXT && opcode != OPCODE_BINARY) {
+      throw new ProtocolException("Unknown opcode: " + toHexString(opcode));
     }
 
-    final BufferedSource source = Okio.buffer(framedMessageSource);
-    ResponseBody body = new ResponseBody() {
-      @Override public MediaType contentType() {
-        return type;
-      }
+    Buffer message = new Buffer();
+    readMessage(message);
 
-      @Override public long contentLength() {
-        return -1;
-      }
-
-      @Override public BufferedSource source() {
-        return source;
-      }
-    };
-
-    messageClosed = false;
-    frameCallback.onMessage(body);
-    if (!messageClosed) {
-      throw new IllegalStateException("Listener failed to call close on message payload.");
+    if (opcode == OPCODE_TEXT) {
+      frameCallback.onReadMessage(message.readUtf8());
+    } else {
+      frameCallback.onReadMessage(message.readByteString());
     }
   }
 
   /** Read headers and process any control frames until we reach a non-control frame. */
-  private void readUntilNonControlFrame() throws IOException {
+  void readUntilNonControlFrame() throws IOException {
     while (!closed) {
       readHeader();
       if (!isControlFrame) {
@@ -257,28 +237,27 @@ private void readUntilNonControlFrame() throws IOException {
   }
 
   /**
-   * A special source which knows how to read a message body across one or more frames. Control
-   * frames that occur between fragments will be processed. If the message payload is masked this
-   * will unmask as it's being processed.
+   * Reads a message body into across one or more frames. Control frames that occur between
+   * fragments will be processed. If the message payload is masked this will unmask as it's being
+   * processed.
    */
-  private final class FramedMessageSource implements Source {
-    @Override public long read(Buffer sink, long byteCount) throws IOException {
+  private void readMessage(Buffer sink) throws IOException {
+    while (true) {
       if (closed) throw new IOException("closed");
-      if (messageClosed) throw new IllegalStateException("closed");
 
       if (frameBytesRead == frameLength) {
-        if (isFinalFrame) return -1; // We are exhausted and have no continuations.
+        if (isFinalFrame) return; // We are exhausted and have no continuations.
 
         readUntilNonControlFrame();
         if (opcode != OPCODE_CONTINUATION) {
           throw new ProtocolException("Expected continuation opcode. Got: " + toHexString(opcode));
         }
         if (isFinalFrame && frameLength == 0) {
-          return -1; // Fast-path for empty final frame.
+          return; // Fast-path for empty final frame.
         }
       }
 
-      long toRead = Math.min(byteCount, frameLength - frameBytesRead);
+      long toRead = frameLength - frameBytesRead;
 
       long read;
       if (isMasked) {
@@ -293,24 +272,6 @@ private void readUntilNonControlFrame() throws IOException {
       }
 
       frameBytesRead += read;
-      return read;
-    }
-
-    @Override public Timeout timeout() {
-      return source.timeout();
-    }
-
-    @Override public void close() throws IOException {
-      if (messageClosed) return;
-      messageClosed = true;
-      if (closed) return;
-
-      // Exhaust the remainder of the message, if any.
-      source.skip(frameLength - frameBytesRead);
-      while (!isFinalFrame) {
-        readUntilNonControlFrame();
-        source.skip(frameLength);
-      }
     }
   }
 }
diff --git a/okhttp-ws/src/main/java/okhttp3/internal/ws/WebSocketWriter.java b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketWriter.java
similarity index 59%
rename from okhttp-ws/src/main/java/okhttp3/internal/ws/WebSocketWriter.java
rename to okhttp/src/main/java/okhttp3/internal/ws/WebSocketWriter.java
index 6ce0cfdd0a..321b5ae475 100644
--- a/okhttp-ws/src/main/java/okhttp3/internal/ws/WebSocketWriter.java
+++ b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketWriter.java
@@ -19,7 +19,7 @@
 import java.util.Random;
 import okio.Buffer;
 import okio.BufferedSink;
-import okio.BufferedSource;
+import okio.ByteString;
 import okio.Sink;
 import okio.Timeout;
 
@@ -39,29 +39,26 @@
 /**
  * An <a href="http://tools.ietf.org/html/rfc6455">RFC 6455</a>-compatible WebSocket frame writer.
  *
- * <p>This class is partially thread safe. Only a single "main" thread should be sending messages
- * via calls to {@link #newMessageSink}, {@link #writePing}, or {@link #writeClose}. Other threads
- * may call {@link #writePing}, {@link #writePong}, or {@link #writeClose} which will interleave on
- * the wire with frames from the "main" sending thread.
+ * <p>This class is not thread safe.
  */
-public final class WebSocketWriter {
-  private final boolean isClient;
-  private final Random random;
+final class WebSocketWriter {
+  final boolean isClient;
+  final Random random;
 
   /** Writes must be guarded by synchronizing on 'this'. */
-  private final BufferedSink sink;
+  final BufferedSink sink;
   /** Access must be guarded by synchronizing on 'this'. */
-  private boolean writerClosed;
+  boolean writerClosed;
 
-  private final Buffer buffer = new Buffer();
-  private final FrameSink frameSink = new FrameSink();
+  final Buffer buffer = new Buffer();
+  final FrameSink frameSink = new FrameSink();
 
-  private boolean activeWriter;
+  boolean activeWriter;
 
-  private final byte[] maskKey;
-  private final byte[] maskBuffer;
+  final byte[] maskKey;
+  final byte[] maskBuffer;
 
-  public WebSocketWriter(boolean isClient, BufferedSink sink, Random random) {
+  WebSocketWriter(boolean isClient, BufferedSink sink, Random random) {
     if (sink == null) throw new NullPointerException("sink == null");
     if (random == null) throw new NullPointerException("random == null");
     this.isClient = isClient;
@@ -73,18 +70,14 @@ public WebSocketWriter(boolean isClient, BufferedSink sink, Random random) {
     maskBuffer = isClient ? new byte[8192] : null;
   }
 
-  /** Send a ping with the supplied {@code payload}. Payload may be {@code null} */
-  public void writePing(Buffer payload) throws IOException {
-    synchronized (this) {
-      writeControlFrameSynchronized(OPCODE_CONTROL_PING, payload);
-    }
+  /** Send a ping with the supplied {@code payload}. */
+  void writePing(ByteString payload) throws IOException {
+    writeControlFrame(OPCODE_CONTROL_PING, payload);
   }
 
-  /** Send a pong with the supplied {@code payload}. Payload may be {@code null} */
-  public void writePong(Buffer payload) throws IOException {
-    synchronized (this) {
-      writeControlFrameSynchronized(OPCODE_CONTROL_PONG, payload);
-    }
+  /** Send a pong with the supplied {@code payload}. */
+  void writePong(ByteString payload) throws IOException {
+    writeControlFrame(OPCODE_CONTROL_PONG, payload);
   }
 
   /**
@@ -94,37 +87,34 @@ public void writePong(Buffer payload) throws IOException {
    * href="http://tools.ietf.org/html/rfc6455#section-7.4">Section 7.4 of RFC 6455</a> or {@code 0}.
    * @param reason Reason for shutting down or {@code null}.
    */
-  public void writeClose(int code, String reason) throws IOException {
-    Buffer payload = null;
+  void writeClose(int code, ByteString reason) throws IOException {
+    ByteString payload = ByteString.EMPTY;
     if (code != 0 || reason != null) {
       if (code != 0) {
-        validateCloseCode(code, true);
+        validateCloseCode(code);
       }
-      payload = new Buffer();
-      payload.writeShort(code);
+      Buffer buffer = new Buffer();
+      buffer.writeShort(code);
       if (reason != null) {
-        payload.writeUtf8(reason);
+        buffer.write(reason);
       }
+      payload = buffer.readByteString();
     }
 
-    synchronized (this) {
-      writeControlFrameSynchronized(OPCODE_CONTROL_CLOSE, payload);
+    try {
+      writeControlFrame(OPCODE_CONTROL_CLOSE, payload);
+    } finally {
       writerClosed = true;
     }
   }
 
-  private void writeControlFrameSynchronized(int opcode, Buffer payload) throws IOException {
-    assert Thread.holdsLock(this);
-
+  private void writeControlFrame(int opcode, ByteString payload) throws IOException {
     if (writerClosed) throw new IOException("closed");
 
-    int length = 0;
-    if (payload != null) {
-      length = (int) payload.size();
-      if (length > PAYLOAD_BYTE_MAX) {
-        throw new IllegalArgumentException(
-            "Payload size must be less than or equal to " + PAYLOAD_BYTE_MAX);
-      }
+    int length = payload.size();
+    if (length > PAYLOAD_BYTE_MAX) {
+      throw new IllegalArgumentException(
+          "Payload size must be less than or equal to " + PAYLOAD_BYTE_MAX);
     }
 
     int b0 = B0_FLAG_FIN | opcode;
@@ -138,25 +128,22 @@ private void writeControlFrameSynchronized(int opcode, Buffer payload) throws IO
       random.nextBytes(maskKey);
       sink.write(maskKey);
 
-      if (payload != null) {
-        writeMaskedSynchronized(payload, length);
-      }
+      byte[] bytes = payload.toByteArray();
+      toggleMask(bytes, bytes.length, maskKey, 0);
+      sink.write(bytes);
     } else {
       sink.writeByte(b1);
-
-      if (payload != null) {
-        sink.writeAll(payload);
-      }
+      sink.write(payload);
     }
 
-    sink.emit();
+    sink.flush();
   }
 
   /**
    * Stream a message payload as a series of frames. This allows control frames to be interleaved
    * between parts of the message.
    */
-  public Sink newMessageSink(int formatOpcode, long contentLength) {
+  Sink newMessageSink(int formatOpcode, long contentLength) {
     if (activeWriter) {
       throw new IllegalStateException("Another message writer is active. Did you call close()?");
     }
@@ -171,10 +158,8 @@ public Sink newMessageSink(int formatOpcode, long contentLength) {
     return frameSink;
   }
 
-  private void writeMessageFrameSynchronized(int formatOpcode, long byteCount, boolean isFirstFrame,
+  void writeMessageFrame(int formatOpcode, long byteCount, boolean isFirstFrame,
       boolean isFinal) throws IOException {
-    assert Thread.holdsLock(this);
-
     if (writerClosed) throw new IOException("closed");
 
     int b0 = isFirstFrame ? formatOpcode : OPCODE_CONTINUATION;
@@ -186,7 +171,6 @@ private void writeMessageFrameSynchronized(int formatOpcode, long byteCount, boo
     int b1 = 0;
     if (isClient) {
       b1 |= B1_FLAG_MASK;
-      random.nextBytes(maskKey);
     }
     if (byteCount <= PAYLOAD_BYTE_MAX) {
       b1 |= (int) byteCount;
@@ -202,8 +186,17 @@ private void writeMessageFrameSynchronized(int formatOpcode, long byteCount, boo
     }
 
     if (isClient) {
+      random.nextBytes(maskKey);
       sink.write(maskKey);
-      writeMaskedSynchronized(buffer, byteCount);
+
+      for (long written = 0; written < byteCount; ) {
+        int toRead = (int) Math.min(byteCount, maskBuffer.length);
+        int read = buffer.read(maskBuffer, 0, toRead);
+        if (read == -1) throw new AssertionError();
+        toggleMask(maskBuffer, read, maskKey, written);
+        sink.write(maskBuffer, 0, read);
+        written += read;
+      }
     } else {
       sink.write(buffer, byteCount);
     }
@@ -211,25 +204,11 @@ private void writeMessageFrameSynchronized(int formatOpcode, long byteCount, boo
     sink.emit();
   }
 
-  private void writeMaskedSynchronized(BufferedSource source, long byteCount) throws IOException {
-    assert Thread.holdsLock(this);
-
-    long written = 0;
-    while (written < byteCount) {
-      int toRead = (int) Math.min(byteCount, maskBuffer.length);
-      int read = source.read(maskBuffer, 0, toRead);
-      if (read == -1) throw new AssertionError();
-      toggleMask(maskBuffer, read, maskKey, written);
-      sink.write(maskBuffer, 0, read);
-      written += read;
-    }
-  }
-
-  private final class FrameSink implements Sink {
-    private int formatOpcode;
-    private long contentLength;
-    private boolean isFirstFrame;
-    private boolean closed;
+  final class FrameSink implements Sink {
+    int formatOpcode;
+    long contentLength;
+    boolean isFirstFrame;
+    boolean closed;
 
     @Override public void write(Buffer source, long byteCount) throws IOException {
       if (closed) throw new IOException("closed");
@@ -243,9 +222,7 @@ private void writeMaskedSynchronized(BufferedSource source, long byteCount) thro
 
       long emitCount = buffer.completeSegmentByteCount();
       if (emitCount > 0 && !deferWrite) {
-        synchronized (WebSocketWriter.this) {
-          writeMessageFrameSynchronized(formatOpcode, emitCount, isFirstFrame, false /* final */);
-        }
+        writeMessageFrame(formatOpcode, emitCount, isFirstFrame, false /* final */);
         isFirstFrame = false;
       }
     }
@@ -253,9 +230,7 @@ private void writeMaskedSynchronized(BufferedSource source, long byteCount) thro
     @Override public void flush() throws IOException {
       if (closed) throw new IOException("closed");
 
-      synchronized (WebSocketWriter.this) {
-        writeMessageFrameSynchronized(formatOpcode, buffer.size(), isFirstFrame, false /* final */);
-      }
+      writeMessageFrame(formatOpcode, buffer.size(), isFirstFrame, false /* final */);
       isFirstFrame = false;
     }
 
@@ -267,9 +242,7 @@ private void writeMaskedSynchronized(BufferedSource source, long byteCount) thro
     @Override public void close() throws IOException {
       if (closed) throw new IOException("closed");
 
-      synchronized (WebSocketWriter.this) {
-        writeMessageFrameSynchronized(formatOpcode, buffer.size(), isFirstFrame, true /* final */);
-      }
+      writeMessageFrame(formatOpcode, buffer.size(), isFirstFrame, true /* final */);
       closed = true;
       activeWriter = false;
     }
diff --git a/okhttp/src/main/java/okhttp3/package-info.java b/okhttp/src/main/java/okhttp3/package-info.java
new file mode 100644
index 0000000000..a34c5bbf86
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/package-info.java
@@ -0,0 +1,3 @@
+/** An HTTP+HTTP/2 client for Android and Java applications. */
+@javax.annotation.ParametersAreNonnullByDefault
+package okhttp3;
diff --git a/okhttp/src/main/resources/okhttp3/internal/publicsuffix/publicsuffixes.gz b/okhttp/src/main/resources/okhttp3/internal/publicsuffix/publicsuffixes.gz
new file mode 100644
index 0000000000..3d9b2c9ccf
Binary files /dev/null and b/okhttp/src/main/resources/okhttp3/internal/publicsuffix/publicsuffixes.gz differ
diff --git a/okhttp/src/test/java/okhttp3/internal/publicsuffix/PublicSuffixListGenerator.java b/okhttp/src/test/java/okhttp3/internal/publicsuffix/PublicSuffixListGenerator.java
new file mode 100644
index 0000000000..50b1f8703a
--- /dev/null
+++ b/okhttp/src/test/java/okhttp3/internal/publicsuffix/PublicSuffixListGenerator.java
@@ -0,0 +1,124 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.publicsuffix;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.SortedSet;
+import java.util.TreeSet;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.ByteString;
+import okio.GzipSink;
+import okio.Okio;
+import okio.Sink;
+
+/**
+ * Downloads the public suffix list from https://publicsuffix.org/list/public_suffix_list.dat and
+ * transforms the file into an efficient format used by OkHttp.
+ *
+ * <p>The intent is to use this class to update the list periodically by manually running the main
+ * method. This should be run from the top-level okhttp directory.
+ *
+ * <p>The resulting file is used by {@link PublicSuffixDatabase}.
+ */
+public final class PublicSuffixListGenerator {
+  private static final String OKHTTP_RESOURCE_DIR = "okhttp" + File.separator + "src"
+      + File.separator + "main" + File.separator + "resources" + File.separator
+      + "okhttp3" + File.separator + "internal" + File.separator + "publicsuffix";
+
+  private static final ByteString EXCEPTION_RULE_MARKER = ByteString.encodeUtf8("!");
+  private static final String WILDCARD_CHAR = "*";
+
+  public static void main(String... args) throws IOException {
+    OkHttpClient client = new OkHttpClient.Builder().build();
+    Request request = new Request.Builder()
+        .url("https://publicsuffix.org/list/public_suffix_list.dat")
+        .build();
+    SortedSet<ByteString> sortedRules = new TreeSet<>();
+    SortedSet<ByteString> sortedExceptionRules = new TreeSet<>();
+    try (Response response = client.newCall(request).execute()) {
+      BufferedSource source = response.body().source();
+      int totalRuleBytes = 0;
+      int totalExceptionRuleBytes = 0;
+      while (!source.exhausted()) {
+        String line = source.readUtf8LineStrict();
+        if (line.trim().isEmpty() || line.startsWith("//")) continue;
+
+        if (line.contains(WILDCARD_CHAR)) {
+          assertWildcardRule(line);
+        }
+
+        ByteString rule = ByteString.encodeUtf8(line);
+        if (rule.startsWith(EXCEPTION_RULE_MARKER)) {
+          rule = rule.substring(1);
+          // We use '\n' for end of value.
+          totalExceptionRuleBytes += rule.size() + 1;
+          sortedExceptionRules.add(rule);
+        } else {
+          totalRuleBytes += rule.size() + 1; // We use '\n' for end of value.
+          sortedRules.add(rule);
+        }
+      }
+
+      File resources = new File(OKHTTP_RESOURCE_DIR);
+      if (!resources.mkdirs() && !resources.exists()) {
+        throw new RuntimeException("Unable to create resource directory!");
+      }
+
+      Sink fileSink = Okio.sink(new File(resources, PublicSuffixDatabase.PUBLIC_SUFFIX_RESOURCE));
+      try (BufferedSink sink = Okio.buffer(new GzipSink(fileSink))) {
+        sink.writeInt(totalRuleBytes);
+        for (ByteString domain : sortedRules) {
+          sink.write(domain).writeByte('\n');
+        }
+
+        sink.writeInt(totalExceptionRuleBytes);
+        for (ByteString domain : sortedExceptionRules) {
+          sink.write(domain).writeByte('\n');
+        }
+      }
+    }
+  }
+
+  /**
+   * These assertions ensure the {@link PublicSuffixDatabase} remains correct. The specification is
+   * very flexible regarding wildcard rules, but this flexibility is not something currently used
+   * in practice. To simplify the implementation, we've avoided implementing the flexible rules in
+   * favor of supporting what's actually used in practice. That means if these assertions ever fail,
+   * the implementation will need to be revisited to support a more flexible rule.
+   */
+  private static void assertWildcardRule(String rule) {
+    if (rule.indexOf(WILDCARD_CHAR) != 0) {
+      throw new RuntimeException("Wildcard Assertion Failure: " + rule + "\nA wildcard rule was "
+          + "added with a wildcard that is not in leftmost position! We'll need to change the "
+          + PublicSuffixDatabase.class.getName() + " to handle this.");
+    }
+    if (rule.indexOf(WILDCARD_CHAR, 1) != -1) {
+      throw new RuntimeException("Wildcard Assertion Failure: " + rule + "\nA wildcard rule was "
+          + "added with multiple wildcards! We'll need to change "
+          + PublicSuffixDatabase.class.getName() + " to handle this.");
+    }
+    if (rule.length() == 1) {
+      throw new RuntimeException("Wildcard Assertion Failure: " + rule + "\nA wildcard rule was "
+          + "added that wildcards the first level! We'll need to change the "
+          + PublicSuffixDatabase.class.getName() + " to handle this.");
+    }
+  }
+}
diff --git a/pom.xml b/pom.xml
index 9d60a40ff0..ab0b43d83f 100644
--- a/pom.xml
+++ b/pom.xml
@@ -11,11 +11,11 @@
 
   <groupId>com.squareup.okhttp3</groupId>
   <artifactId>parent</artifactId>
-  <version>3.4.0-SNAPSHOT</version>
+  <version>3.10.0-SNAPSHOT</version>
   <packaging>pom</packaging>
 
   <name>OkHttp (Parent)</name>
-  <description>An HTTP+SPDY client for Android and Java applications</description>
+  <description>An HTTP+HTTP/2 client for Android and Java applications</description>
   <url>https://github.com/square/okhttp</url>
 
   <modules>
@@ -28,9 +28,6 @@
     <module>okhttp-testing-support</module>
     <module>okhttp-urlconnection</module>
 
-    <module>okhttp-ws</module>
-    <module>okhttp-ws-tests</module>
-
     <module>okhttp-logging-interceptor</module>
 
     <module>okcurl</module>
@@ -47,12 +44,13 @@
     <!-- ALPN library targeted to Java 7 -->
     <alpn.jdk7.version>7.1.2.v20141202</alpn.jdk7.version>
     <android.version>4.1.1.4</android.version>
+    <animal.sniffer.version>1.15</animal.sniffer.version>
     <apache.http.version>4.2.2</apache.http.version>
     <bouncycastle.version>1.50</bouncycastle.version>
     <guava.version>16.0</guava.version>
     <java.version>1.7</java.version>
     <moshi.version>1.1.0</moshi.version>
-    <okio.version>1.8.0</okio.version>
+    <okio.version>1.13.0</okio.version>
 
     <!-- Test Dependencies -->
     <junit.version>4.12</junit.version>
@@ -87,6 +85,12 @@
         <artifactId>okio</artifactId>
         <version>${okio.version}</version>
       </dependency>
+      <dependency>
+        <groupId>com.google.code.findbugs</groupId>
+        <artifactId>jsr305</artifactId>
+        <version>3.0.2</version>
+        <scope>provided</scope>
+      </dependency>
       <dependency>
         <groupId>junit</groupId>
         <artifactId>junit</artifactId>
@@ -131,11 +135,25 @@
         <plugin>
           <groupId>org.apache.maven.plugins</groupId>
           <artifactId>maven-compiler-plugin</artifactId>
-          <version>3.0</version>
+          <version>3.6.1</version>
           <configuration>
+            <compilerId>javac-with-errorprone</compilerId>
+            <forceJavacCompilerUse>true</forceJavacCompilerUse>
             <source>${java.version}</source>
             <target>${java.version}</target>
           </configuration>
+          <dependencies>
+            <dependency>
+              <groupId>org.codehaus.plexus</groupId>
+              <artifactId>plexus-compiler-javac-errorprone</artifactId>
+              <version>2.8.1</version>
+            </dependency>
+            <dependency>
+              <groupId>com.google.errorprone</groupId>
+              <artifactId>error_prone_core</artifactId>
+              <version>2.0.16</version>
+            </dependency>
+          </dependencies>
         </plugin>
 
         <plugin>
@@ -195,7 +213,14 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-checkstyle-plugin</artifactId>
-        <version>2.10</version>
+        <version>2.17</version>
+        <dependencies>
+          <dependency>
+            <groupId>com.puppycrawl.tools</groupId>
+            <artifactId>checkstyle</artifactId>
+            <version>7.7</version>
+          </dependency>
+        </dependencies>
         <configuration>
           <failsOnError>true</failsOnError>
           <configLocation>checkstyle.xml</configLocation>
@@ -214,7 +239,7 @@
       <plugin>
         <groupId>org.codehaus.mojo</groupId>
         <artifactId>animal-sniffer-maven-plugin</artifactId>
-        <version>1.11</version>
+        <version>${animal.sniffer.version}</version>
         <executions>
           <execution>
             <phase>test</phase>
@@ -253,7 +278,7 @@
               <groupId>org.apache.maven.plugins</groupId>
               <artifactId>maven-surefire-plugin</artifactId>
               <configuration>
-                <argLine>-Xbootclasspath/p:${bootclasspathPrefix}</argLine>
+                <argLine>-Xbootclasspath/p:${bootclasspathPrefix} -Xms512m -Xmx512m</argLine>
               </configuration>
               <dependencies>
                 <dependency>
@@ -285,7 +310,7 @@
               <groupId>org.apache.maven.plugins</groupId>
               <artifactId>maven-surefire-plugin</artifactId>
               <configuration>
-                <argLine>-Xbootclasspath/p:${bootclasspathPrefix}</argLine>
+                <argLine>-Xbootclasspath/p:${bootclasspathPrefix} -Xms512m -Xmx512m</argLine>
               </configuration>
               <dependencies>
                 <dependency>
@@ -311,7 +336,7 @@
     <!-- ALPN Versions targeted for each Java 8 minor release -->
     <!-- Check versions with this page: -->
     <!-- http://www.eclipse.org/jetty/documentation/current/alpn-chapter.html#alpn-chapterchapterversions -->
-        <profile>
+    <profile>
       <id>alpn-when-jdk8_05</id>
       <activation>
         <jdk>1.8.0_05</jdk>
@@ -473,6 +498,95 @@
         <alpn.jdk8.version>8.1.8.v20160420</alpn.jdk8.version>
       </properties>
     </profile>
+    <profile>
+      <id>alpn-when-jdk8_101</id>
+      <activation>
+        <jdk>1.8.0_101</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.8.v20160420</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_102</id>
+      <activation>
+        <jdk>1.8.0_102</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.9.v20160720</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_111</id>
+      <activation>
+        <jdk>1.8.0_111</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.9.v20160720</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_112</id>
+      <activation>
+        <jdk>1.8.0_112</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.9.v20160720</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_121</id>
+      <activation>
+        <jdk>1.8.0_121</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.11.v20170118</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_131</id>
+      <activation>
+        <jdk>1.8.0_131</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.11.v20170118</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_141</id>
+      <activation>
+        <jdk>1.8.0_141</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.11.v20170118</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_144</id>
+      <activation>
+        <jdk>1.8.0_144</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.11.v20170118</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_151</id>
+      <activation>
+        <jdk>1.8.0_151</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.11.v20170118</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_152</id>
+      <activation>
+        <jdk>1.8.0_152</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.11.v20170118</alpn.jdk8.version>
+      </properties>
+    </profile>
   </profiles>
 </project>
-
diff --git a/samples/crawler/pom.xml b/samples/crawler/pom.xml
index a40fe5b58f..77eea94b1b 100644
--- a/samples/crawler/pom.xml
+++ b/samples/crawler/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>3.4.0-SNAPSHOT</version>
+    <version>3.10.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>crawler</artifactId>
diff --git a/samples/crawler/src/main/java/okhttp3/sample/Crawler.java b/samples/crawler/src/main/java/okhttp3/sample/Crawler.java
index 7fad2ee5e1..72f59d32c2 100644
--- a/samples/crawler/src/main/java/okhttp3/sample/Crawler.java
+++ b/samples/crawler/src/main/java/okhttp3/sample/Crawler.java
@@ -27,6 +27,7 @@
 import java.util.concurrent.atomic.AtomicInteger;
 import okhttp3.Cache;
 import okhttp3.HttpUrl;
+import okhttp3.MediaType;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
 import okhttp3.Response;
@@ -71,10 +72,15 @@ private void drainQueue() throws Exception {
         continue;
       }
 
+      Thread currentThread = Thread.currentThread();
+      String originalName = currentThread.getName();
+      currentThread.setName("Crawler " + url.toString());
       try {
         fetch(url);
       } catch (IOException e) {
         System.out.printf("XXX: %s %s%n", url, e);
+      } finally {
+        currentThread.setName(originalName);
       }
     }
   }
@@ -89,25 +95,33 @@ public void fetch(HttpUrl url) throws IOException {
     Request request = new Request.Builder()
         .url(url)
         .build();
-    Response response = client.newCall(request).execute();
-    String responseSource = response.networkResponse() != null
-        ? ("(network: " + response.networkResponse().code() + " over " + response.protocol() + ")")
-        : "(cache)";
-    int responseCode = response.code();
+    try (Response response = client.newCall(request).execute()) {
+      String responseSource = response.networkResponse() != null ? ("(network: "
+          + response.networkResponse().code()
+          + " over "
+          + response.protocol()
+          + ")") : "(cache)";
+      int responseCode = response.code();
 
-    System.out.printf("%03d: %s %s%n", responseCode, url, responseSource);
+      System.out.printf("%03d: %s %s%n", responseCode, url, responseSource);
 
-    String contentType = response.header("Content-Type");
-    if (responseCode != 200 || contentType == null) {
-      response.body().close();
-      return;
-    }
+      String contentType = response.header("Content-Type");
+      if (responseCode != 200 || contentType == null) {
+        return;
+      }
 
-    Document document = Jsoup.parse(response.body().string(), url.toString());
-    for (Element element : document.select("a[href]")) {
-      String href = element.attr("href");
-      HttpUrl link = response.request().url().resolve(href);
-      if (link != null) queue.add(link);
+      MediaType mediaType = MediaType.parse(contentType);
+      if (mediaType == null || !mediaType.subtype().equalsIgnoreCase("html")) {
+        return;
+      }
+
+      Document document = Jsoup.parse(response.body().string(), url.toString());
+      for (Element element : document.select("a[href]")) {
+        String href = element.attr("href");
+        HttpUrl link = response.request().url().resolve(href);
+        if (link == null) continue; // URL is either invalid or its scheme isn't http/https.
+        queue.add(link.newBuilder().fragment(null).build());
+      }
     }
   }
 
diff --git a/samples/guide/pom.xml b/samples/guide/pom.xml
index 569099322c..c654656624 100644
--- a/samples/guide/pom.xml
+++ b/samples/guide/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>3.4.0-SNAPSHOT</version>
+    <version>3.10.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>guide</artifactId>
@@ -18,11 +18,6 @@
       <artifactId>okhttp</artifactId>
       <version>${project.version}</version>
     </dependency>
-    <dependency>
-      <groupId>com.squareup.okhttp3</groupId>
-      <artifactId>okhttp-ws</artifactId>
-      <version>${project.version}</version>
-    </dependency>
     <dependency>
       <groupId>com.squareup.moshi</groupId>
       <artifactId>moshi</artifactId>
diff --git a/samples/guide/src/main/java/okhttp3/recipes/Authenticate.java b/samples/guide/src/main/java/okhttp3/recipes/Authenticate.java
index 61eb27f2b1..4eb09d8f11 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/Authenticate.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/Authenticate.java
@@ -30,6 +30,10 @@ public Authenticate() {
     client = new OkHttpClient.Builder()
         .authenticator(new Authenticator() {
           @Override public Request authenticate(Route route, Response response) throws IOException {
+            if (response.request().header("Authorization") != null) {
+              return null; // Give up, we've already attempted to authenticate.
+            }
+
             System.out.println("Authenticating for response: " + response);
             System.out.println("Challenges: " + response.challenges());
             String credential = Credentials.basic("jesse", "password1");
diff --git a/samples/guide/src/main/java/okhttp3/recipes/CheckHandshake.java b/samples/guide/src/main/java/okhttp3/recipes/CheckHandshake.java
index 164e879079..befd80983c 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/CheckHandshake.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/CheckHandshake.java
@@ -28,7 +28,8 @@
 public final class CheckHandshake {
   /** Rejects otherwise-trusted certificates. */
   private static final Interceptor CHECK_HANDSHAKE_INTERCEPTOR = new Interceptor() {
-    Set<String> blacklist = Collections.singleton("sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw=");
+    Set<String> blacklist = Collections.singleton(
+        "sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=");
 
     @Override public Response intercept(Chain chain) throws IOException {
       for (Certificate certificate : chain.connection().handshake().peerCertificates()) {
diff --git a/samples/guide/src/main/java/okhttp3/recipes/CustomCipherSuites.java b/samples/guide/src/main/java/okhttp3/recipes/CustomCipherSuites.java
new file mode 100644
index 0000000000..b568bdf01c
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/CustomCipherSuites.java
@@ -0,0 +1,169 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.Socket;
+import java.security.GeneralSecurityException;
+import java.security.KeyManagementException;
+import java.security.KeyStore;
+import java.security.NoSuchAlgorithmException;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSocket;
+import javax.net.ssl.SSLSocketFactory;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.TrustManagerFactory;
+import javax.net.ssl.X509TrustManager;
+import okhttp3.CipherSuite;
+import okhttp3.ConnectionSpec;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+
+public final class CustomCipherSuites {
+  private final OkHttpClient client;
+
+  public CustomCipherSuites() throws GeneralSecurityException {
+    // Configure cipher suites to demonstrate how to customize which cipher suites will be used for
+    // an OkHttp request. In order to be selected a cipher suite must be included in both OkHttp's
+    // connection spec and in the SSLSocket's enabled cipher suites array. Most applications should
+    // not customize the cipher suites list.
+    List<CipherSuite> customCipherSuites = Arrays.asList(
+        CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
+        CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
+        CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
+        CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384);
+    final ConnectionSpec spec = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
+        .cipherSuites(customCipherSuites.toArray(new CipherSuite[0]))
+        .build();
+
+    X509TrustManager trustManager = defaultTrustManager();
+    SSLSocketFactory sslSocketFactory = defaultSslSocketFactory(trustManager);
+    SSLSocketFactory customSslSocketFactory = new DelegatingSSLSocketFactory(sslSocketFactory) {
+      @Override protected SSLSocket configureSocket(SSLSocket socket) throws IOException {
+        socket.setEnabledCipherSuites(javaNames(spec.cipherSuites()));
+        return socket;
+      }
+    };
+
+    client = new OkHttpClient.Builder()
+        .connectionSpecs(Collections.singletonList(spec))
+        .sslSocketFactory(customSslSocketFactory, trustManager)
+        .build();
+  }
+
+  /**
+   * Returns the VM's default SSL socket factory, using {@code trustManager} for trusted root
+   * certificates.
+   */
+  private SSLSocketFactory defaultSslSocketFactory(X509TrustManager trustManager)
+      throws NoSuchAlgorithmException, KeyManagementException {
+    SSLContext sslContext = SSLContext.getInstance("TLS");
+    sslContext.init(null, new TrustManager[] { trustManager }, null);
+
+    return sslContext.getSocketFactory();
+  }
+
+  /** Returns a trust manager that trusts the VM's default certificate authorities. */
+  private X509TrustManager defaultTrustManager() throws GeneralSecurityException {
+    TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
+        TrustManagerFactory.getDefaultAlgorithm());
+    trustManagerFactory.init((KeyStore) null);
+    TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
+    if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {
+      throw new IllegalStateException("Unexpected default trust managers:"
+          + Arrays.toString(trustManagers));
+    }
+    return (X509TrustManager) trustManagers[0];
+  }
+
+  private String[] javaNames(List<CipherSuite> cipherSuites) {
+    String[] result = new String[cipherSuites.size()];
+    for (int i = 0; i < result.length; i++) {
+      result[i] = cipherSuites.get(i).javaName();
+    }
+    return result;
+  }
+
+  /**
+   * An SSL socket factory that forwards all calls to a delegate. Override {@link #configureSocket}
+   * to customize a created socket before it is returned.
+   */
+  static class DelegatingSSLSocketFactory extends SSLSocketFactory {
+    protected final SSLSocketFactory delegate;
+
+    DelegatingSSLSocketFactory(SSLSocketFactory delegate) {
+      this.delegate = delegate;
+    }
+
+    @Override public String[] getDefaultCipherSuites() {
+      return delegate.getDefaultCipherSuites();
+    }
+
+    @Override public String[] getSupportedCipherSuites() {
+      return delegate.getSupportedCipherSuites();
+    }
+
+    @Override public Socket createSocket(
+        Socket socket, String host, int port, boolean autoClose) throws IOException {
+      return configureSocket((SSLSocket) delegate.createSocket(socket, host, port, autoClose));
+    }
+
+    @Override public Socket createSocket(String host, int port) throws IOException {
+      return configureSocket((SSLSocket) delegate.createSocket(host, port));
+    }
+
+    @Override public Socket createSocket(
+        String host, int port, InetAddress localHost, int localPort) throws IOException {
+      return configureSocket((SSLSocket) delegate.createSocket(host, port, localHost, localPort));
+    }
+
+    @Override public Socket createSocket(InetAddress host, int port) throws IOException {
+      return configureSocket((SSLSocket) delegate.createSocket(host, port));
+    }
+
+    @Override public Socket createSocket(
+        InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {
+      return configureSocket((SSLSocket) delegate.createSocket(
+          address, port, localAddress, localPort));
+    }
+
+    protected SSLSocket configureSocket(SSLSocket socket) throws IOException {
+      return socket;
+    }
+  }
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("https://publicobject.com/helloworld.txt")
+        .build();
+
+    try (Response response = client.newCall(request).execute()) {
+      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+      System.out.println(response.handshake().cipherSuite());
+      System.out.println(response.body().string());
+    }
+  }
+
+  public static void main(String... args) throws Exception {
+    new CustomCipherSuites().run();
+  }
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PostStreamingWithPipe.java b/samples/guide/src/main/java/okhttp3/recipes/PostStreamingWithPipe.java
new file mode 100644
index 0000000000..b313ce0d1a
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/PostStreamingWithPipe.java
@@ -0,0 +1,105 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes;
+
+import java.io.IOException;
+import okhttp3.MediaType;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
+import okio.BufferedSink;
+import okio.Okio;
+import okio.Pipe;
+
+public final class PostStreamingWithPipe {
+  public static final MediaType MEDIA_TYPE_MARKDOWN
+      = MediaType.parse("text/x-markdown; charset=utf-8");
+
+  private final OkHttpClient client = new OkHttpClient();
+
+  public void run() throws Exception {
+    final PipeBody pipeBody = new PipeBody();
+
+    Request request = new Request.Builder()
+        .url("https://api.github.com/markdown/raw")
+        .post(pipeBody)
+        .build();
+
+    streamPrimesToSinkAsynchronously(pipeBody.sink());
+
+    try (Response response = client.newCall(request).execute()) {
+      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+      System.out.println(response.body().string());
+    }
+  }
+
+  private void streamPrimesToSinkAsynchronously(final BufferedSink sink) {
+    Thread thread = new Thread("writer") {
+      @Override public void run() {
+        try {
+          sink.writeUtf8("Numbers\n");
+          sink.writeUtf8("-------\n");
+          for (int i = 2; i <= 997; i++) {
+            System.out.println(i);
+            Thread.sleep(10);
+            sink.writeUtf8(String.format(" * %s = %s\n", i, factor(i)));
+          }
+          sink.close();
+        } catch (IOException | InterruptedException e) {
+          e.printStackTrace();
+        }
+      }
+
+      private String factor(int n) {
+        for (int i = 2; i < n; i++) {
+          int x = n / i;
+          if (x * i == n) return factor(x) + " × " + i;
+        }
+        return Integer.toString(n);
+      }
+    };
+
+    thread.start();
+  }
+
+  /**
+   * This request body makes it possible for another thread to stream data to the uploading request.
+   * This is potentially useful for posting live event streams like video capture. Callers should
+   * write to {@code sink()} and close it to complete the post.
+   */
+  static final class PipeBody extends RequestBody {
+    private final Pipe pipe = new Pipe(8192);
+    private final BufferedSink sink = Okio.buffer(pipe.sink());
+
+    public BufferedSink sink() {
+      return sink;
+    }
+
+    @Override public MediaType contentType() {
+      return MEDIA_TYPE_MARKDOWN;
+    }
+
+    @Override public void writeTo(BufferedSink sink) throws IOException {
+      sink.writeAll(pipe.source());
+    }
+  }
+
+  public static void main(String... args) throws Exception {
+    new PostStreamingWithPipe().run();
+  }
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PrintEvents.java b/samples/guide/src/main/java/okhttp3/recipes/PrintEvents.java
new file mode 100644
index 0000000000..1366a82f15
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/PrintEvents.java
@@ -0,0 +1,183 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.Proxy;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicLong;
+import okhttp3.Call;
+import okhttp3.Callback;
+import okhttp3.Connection;
+import okhttp3.EventListener;
+import okhttp3.Handshake;
+import okhttp3.OkHttpClient;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+
+public final class PrintEvents {
+  private final OkHttpClient client = new OkHttpClient.Builder()
+      .eventListenerFactory(PrintingEventListener.FACTORY)
+      .build();
+
+  public void run() throws Exception {
+    Request washingtonPostRequest = new Request.Builder()
+        .url("https://www.washingtonpost.com/")
+        .build();
+    client.newCall(washingtonPostRequest).enqueue(new Callback() {
+      @Override public void onFailure(Call call, IOException e) {
+      }
+
+      @Override public void onResponse(Call call, Response response) throws IOException {
+        try (ResponseBody body = response.body()) {
+          // Consume and discard the response body.
+          body.source().readByteString();
+        }
+      }
+    });
+
+    Request newYorkTimesRequest = new Request.Builder()
+        .url("https://www.nytimes.com/")
+        .build();
+    client.newCall(newYorkTimesRequest).enqueue(new Callback() {
+      @Override public void onFailure(Call call, IOException e) {
+      }
+
+      @Override public void onResponse(Call call, Response response) throws IOException {
+        try (ResponseBody body = response.body()) {
+          // Consume and discard the response body.
+          body.source().readByteString();
+        }
+      }
+    });
+  }
+
+  public static void main(String... args) throws Exception {
+    new PrintEvents().run();
+  }
+
+  private static final class PrintingEventListener extends EventListener {
+    private static final Factory FACTORY = new Factory() {
+      final AtomicLong nextCallId = new AtomicLong(1L);
+
+      @Override public EventListener create(Call call) {
+        long callId = nextCallId.getAndIncrement();
+        System.out.printf("%04d %s%n", callId, call.request().url());
+        return new PrintingEventListener(callId, System.nanoTime());
+      }
+    };
+
+    final long callId;
+    final long callStartNanos;
+
+    PrintingEventListener(long callId, long callStartNanos) {
+      this.callId = callId;
+      this.callStartNanos = callStartNanos;
+    }
+
+    private void printEvent(String name) {
+      long elapsedNanos = System.nanoTime() - callStartNanos;
+      System.out.printf("%04d %.3f %s%n", callId, elapsedNanos / 1000000000d, name);
+    }
+
+    @Override public void callStart(Call call) {
+      printEvent("callStart");
+    }
+
+    @Override public void dnsStart(Call call, String domainName) {
+      printEvent("dnsStart");
+    }
+
+    @Override public void dnsEnd(Call call, String domainName, List<InetAddress> inetAddressList) {
+      printEvent("dnsEnd");
+    }
+
+    @Override public void connectStart(
+        Call call, InetSocketAddress inetSocketAddress, Proxy proxy) {
+      printEvent("connectStart");
+    }
+
+    @Override public void secureConnectStart(Call call) {
+      printEvent("secureConnectStart");
+    }
+
+    @Override public void secureConnectEnd(Call call, Handshake handshake) {
+      printEvent("secureConnectEnd");
+    }
+
+    @Override public void connectEnd(
+        Call call, InetSocketAddress inetSocketAddress, Proxy proxy, Protocol protocol) {
+      printEvent("connectEnd");
+    }
+
+    @Override public void connectFailed(Call call, InetSocketAddress inetSocketAddress, Proxy proxy,
+        Protocol protocol, IOException ioe) {
+      printEvent("connectFailed");
+    }
+
+    @Override public void connectionAcquired(Call call, Connection connection) {
+      printEvent("connectionAcquired");
+    }
+
+    @Override public void connectionReleased(Call call, Connection connection) {
+      printEvent("connectionReleased");
+    }
+
+    @Override public void requestHeadersStart(Call call) {
+      printEvent("requestHeadersStart");
+    }
+
+    @Override public void requestHeadersEnd(Call call, Request request) {
+      printEvent("requestHeadersEnd");
+    }
+
+    @Override public void requestBodyStart(Call call) {
+      printEvent("requestBodyStart");
+    }
+
+    @Override public void requestBodyEnd(Call call, long byteCount) {
+      printEvent("requestBodyEnd");
+    }
+
+    @Override public void responseHeadersStart(Call call) {
+      printEvent("responseHeadersStart");
+    }
+
+    @Override public void responseHeadersEnd(Call call, Response response) {
+      printEvent("responseHeadersEnd");
+    }
+
+    @Override public void responseBodyStart(Call call) {
+      printEvent("responseBodyStart");
+    }
+
+    @Override public void responseBodyEnd(Call call, long byteCount) {
+      printEvent("responseBodyEnd");
+    }
+
+    @Override public void callEnd(Call call) {
+      printEvent("callEnd");
+    }
+
+    @Override public void callFailed(Call call, IOException ioe) {
+      printEvent("callFailed");
+    }
+  }
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PrintEventsNonConcurrent.java b/samples/guide/src/main/java/okhttp3/recipes/PrintEventsNonConcurrent.java
new file mode 100644
index 0000000000..6acedb19e7
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/PrintEventsNonConcurrent.java
@@ -0,0 +1,158 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.Proxy;
+import java.util.List;
+import okhttp3.Call;
+import okhttp3.Connection;
+import okhttp3.EventListener;
+import okhttp3.Handshake;
+import okhttp3.OkHttpClient;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.Response;
+
+/**
+ * This prints events for a single in-flight call. It won't work for multiple concurrent calls
+ * because we don't know what callStartNanos refers to.
+ */
+public final class PrintEventsNonConcurrent {
+  private final OkHttpClient client = new OkHttpClient.Builder()
+      .eventListener(new PrintingEventListener())
+      .build();
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("https://publicobject.com/helloworld.txt")
+        .build();
+
+    System.out.println("REQUEST 1 (new connection)");
+    try (Response response = client.newCall(request).execute()) {
+      // Consume and discard the response body.
+      response.body().source().readByteString();
+    }
+
+    System.out.println("REQUEST 2 (pooled connection)");
+    try (Response response = client.newCall(request).execute()) {
+      // Consume and discard the response body.
+      response.body().source().readByteString();
+    }
+  }
+
+  public static void main(String... args) throws Exception {
+    new PrintEventsNonConcurrent().run();
+  }
+
+  private static final class PrintingEventListener extends EventListener {
+    long callStartNanos;
+
+    private void printEvent(String name) {
+      long nowNanos = System.nanoTime();
+      if (name.equals("callStart")) {
+        callStartNanos = nowNanos;
+      }
+      long elapsedNanos = nowNanos - callStartNanos;
+      System.out.printf("%.3f %s%n", elapsedNanos / 1000000000d, name);
+    }
+
+    @Override public void callStart(Call call) {
+      printEvent("callStart");
+    }
+
+    @Override public void dnsStart(Call call, String domainName) {
+      printEvent("dnsStart");
+    }
+
+    @Override public void dnsEnd(Call call, String domainName, List<InetAddress> inetAddressList) {
+      printEvent("dnsEnd");
+    }
+
+    @Override public void connectStart(
+        Call call, InetSocketAddress inetSocketAddress, Proxy proxy) {
+      printEvent("connectStart");
+    }
+
+    @Override public void secureConnectStart(Call call) {
+      printEvent("secureConnectStart");
+    }
+
+    @Override public void secureConnectEnd(Call call, Handshake handshake) {
+      printEvent("secureConnectEnd");
+    }
+
+    @Override public void connectEnd(
+        Call call, InetSocketAddress inetSocketAddress, Proxy proxy, Protocol protocol) {
+      printEvent("connectEnd");
+    }
+
+    @Override public void connectFailed(Call call, InetSocketAddress inetSocketAddress, Proxy proxy,
+        Protocol protocol, IOException ioe) {
+      printEvent("connectFailed");
+    }
+
+    @Override public void connectionAcquired(Call call, Connection connection) {
+      printEvent("connectionAcquired");
+    }
+
+    @Override public void connectionReleased(Call call, Connection connection) {
+      printEvent("connectionReleased");
+    }
+
+    @Override public void requestHeadersStart(Call call) {
+      printEvent("requestHeadersStart");
+    }
+
+    @Override public void requestHeadersEnd(Call call, Request request) {
+      printEvent("requestHeadersEnd");
+    }
+
+    @Override public void requestBodyStart(Call call) {
+      printEvent("requestBodyStart");
+    }
+
+    @Override public void requestBodyEnd(Call call, long byteCount) {
+      printEvent("requestBodyEnd");
+    }
+
+    @Override public void responseHeadersStart(Call call) {
+      printEvent("responseHeadersStart");
+    }
+
+    @Override public void responseHeadersEnd(Call call, Response response) {
+      printEvent("responseHeadersEnd");
+    }
+
+    @Override public void responseBodyStart(Call call) {
+      printEvent("responseBodyStart");
+    }
+
+    @Override public void responseBodyEnd(Call call, long byteCount) {
+      printEvent("responseBodyEnd");
+    }
+
+    @Override public void callEnd(Call call) {
+      printEvent("callEnd");
+    }
+
+    @Override public void callFailed(Call call, IOException ioe) {
+      printEvent("callFailed");
+    }
+  }
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/Progress.java b/samples/guide/src/main/java/okhttp3/recipes/Progress.java
index f04de79340..e75a3cc949 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/Progress.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/Progress.java
@@ -36,11 +36,27 @@ public void run() throws Exception {
         .build();
 
     final ProgressListener progressListener = new ProgressListener() {
+      boolean firstUpdate = true;
+
       @Override public void update(long bytesRead, long contentLength, boolean done) {
-        System.out.println(bytesRead);
-        System.out.println(contentLength);
-        System.out.println(done);
-        System.out.format("%d%% done\n", (100 * bytesRead) / contentLength);
+        if (done) {
+          System.out.println("completed");
+        } else {
+          if (firstUpdate) {
+            firstUpdate = false;
+            if (contentLength == -1) {
+              System.out.println("content-length: unknown");
+            } else {
+              System.out.format("content-length: %d\n", contentLength);
+            }
+          }
+
+          System.out.println(bytesRead);
+
+          if (contentLength != -1) {
+            System.out.format("%d%% done\n", (100 * bytesRead) / contentLength);
+          }
+        }
       }
     };
 
@@ -72,7 +88,7 @@ public static void main(String... args) throws Exception {
     private final ProgressListener progressListener;
     private BufferedSource bufferedSource;
 
-    public ProgressResponseBody(ResponseBody responseBody, ProgressListener progressListener) {
+    ProgressResponseBody(ResponseBody responseBody, ProgressListener progressListener) {
       this.responseBody = responseBody;
       this.progressListener = progressListener;
     }
diff --git a/samples/guide/src/main/java/okhttp3/recipes/WebSocketEcho.java b/samples/guide/src/main/java/okhttp3/recipes/WebSocketEcho.java
index c7ee9438b0..288fadb7ce 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/WebSocketEcho.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/WebSocketEcho.java
@@ -1,74 +1,53 @@
 package okhttp3.recipes;
 
-import java.io.IOException;
-import java.util.concurrent.Executor;
-import java.util.concurrent.Executors;
+import java.util.concurrent.TimeUnit;
+import okhttp3.WebSocket;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
-import okhttp3.RequestBody;
 import okhttp3.Response;
-import okhttp3.ResponseBody;
-import okhttp3.ws.WebSocket;
-import okhttp3.ws.WebSocketCall;
-import okhttp3.ws.WebSocketListener;
-import okio.Buffer;
+import okhttp3.WebSocketListener;
 import okio.ByteString;
 
-import static okhttp3.ws.WebSocket.BINARY;
-import static okhttp3.ws.WebSocket.TEXT;
-
-public final class WebSocketEcho implements WebSocketListener {
-  private final Executor writeExecutor = Executors.newSingleThreadExecutor();
-
-  private void run() throws IOException {
-    OkHttpClient client = new OkHttpClient();
+public final class WebSocketEcho extends WebSocketListener {
+  private void run() {
+    OkHttpClient client = new OkHttpClient.Builder()
+        .readTimeout(0,  TimeUnit.MILLISECONDS)
+        .build();
 
     Request request = new Request.Builder()
         .url("ws://echo.websocket.org")
         .build();
-    WebSocketCall.create(client, request).enqueue(this);
+    client.newWebSocket(request, this);
 
     // Trigger shutdown of the dispatcher's executor so this process can exit cleanly.
     client.dispatcher().executorService().shutdown();
   }
 
-  @Override public void onOpen(final WebSocket webSocket, Response response) {
-    writeExecutor.execute(new Runnable() {
-      @Override public void run() {
-        try {
-          webSocket.sendMessage(RequestBody.create(TEXT, "Hello..."));
-          webSocket.sendMessage(RequestBody.create(TEXT, "...World!"));
-          webSocket.sendMessage(RequestBody.create(BINARY, ByteString.decodeHex("deadbeef")));
-          webSocket.close(1000, "Goodbye, World!");
-        } catch (IOException e) {
-          System.err.println("Unable to send messages: " + e.getMessage());
-        }
-      }
-    });
+  @Override public void onOpen(WebSocket webSocket, Response response) {
+    webSocket.send("Hello...");
+    webSocket.send("...World!");
+    webSocket.send(ByteString.decodeHex("deadbeef"));
+    webSocket.close(1000, "Goodbye, World!");
   }
 
-  @Override public void onMessage(ResponseBody message) throws IOException {
-    if (message.contentType() == TEXT) {
-      System.out.println("MESSAGE: " + message.string());
-    } else {
-      System.out.println("MESSAGE: " + message.source().readByteString().hex());
-    }
-    message.close();
+  @Override public void onMessage(WebSocket webSocket, String text) {
+    System.out.println("MESSAGE: " + text);
   }
 
-  @Override public void onPong(Buffer payload) {
-    System.out.println("PONG: " + payload.readUtf8());
+  @Override public void onMessage(WebSocket webSocket, ByteString bytes) {
+    System.out.println("MESSAGE: " + bytes.hex());
   }
 
-  @Override public void onClose(int code, String reason) {
+  @Override public void onClosing(WebSocket webSocket, int code, String reason) {
+    webSocket.close(1000, null);
     System.out.println("CLOSE: " + code + " " + reason);
   }
 
-  @Override public void onFailure(IOException e, Response response) {
-    e.printStackTrace();
+  @Override public void onFailure(WebSocket webSocket, Throwable t, Response response) {
+    t.printStackTrace();
   }
 
-  public static void main(String... args) throws IOException {
+  public static void main(String... args) {
     new WebSocketEcho().run();
   }
 }
diff --git a/samples/pom.xml b/samples/pom.xml
index de77532ea5..4bb53c9d5b 100644
--- a/samples/pom.xml
+++ b/samples/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.4.0-SNAPSHOT</version>
+    <version>3.10.0-SNAPSHOT</version>
   </parent>
 
   <groupId>com.squareup.okhttp3.sample</groupId>
@@ -18,6 +18,7 @@
     <module>guide</module>
     <module>crawler</module>
     <module>simple-client</module>
+    <module>slack</module>
     <module>static-server</module>
   </modules>
 
diff --git a/samples/simple-client/pom.xml b/samples/simple-client/pom.xml
index 5bb5efe414..347edefa27 100644
--- a/samples/simple-client/pom.xml
+++ b/samples/simple-client/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>3.4.0-SNAPSHOT</version>
+    <version>3.10.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>simple-client</artifactId>
diff --git a/samples/simple-client/src/main/java/okhttp3/sample/OkHttpContributors.java b/samples/simple-client/src/main/java/okhttp3/sample/OkHttpContributors.java
index ec9019110b..f2ac973db2 100644
--- a/samples/simple-client/src/main/java/okhttp3/sample/OkHttpContributors.java
+++ b/samples/simple-client/src/main/java/okhttp3/sample/OkHttpContributors.java
@@ -31,23 +31,22 @@ public static void main(String... args) throws Exception {
         .build();
 
     // Execute the request and retrieve the response.
-    Response response = client.newCall(request).execute();
-
-    // Deserialize HTTP response to concrete type.
-    ResponseBody body = response.body();
-    List<Contributor> contributors = CONTRIBUTORS_JSON_ADAPTER.fromJson(body.source());
-    body.close();
-
-    // Sort list by the most contributions.
-    Collections.sort(contributors, new Comparator<Contributor>() {
-      @Override public int compare(Contributor c1, Contributor c2) {
-        return c2.contributions - c1.contributions;
+    try (Response response = client.newCall(request).execute()) {
+      // Deserialize HTTP response to concrete type.
+      ResponseBody body = response.body();
+      List<Contributor> contributors = CONTRIBUTORS_JSON_ADAPTER.fromJson(body.source());
+
+      // Sort list by the most contributions.
+      Collections.sort(contributors, new Comparator<Contributor>() {
+        @Override public int compare(Contributor c1, Contributor c2) {
+          return c2.contributions - c1.contributions;
+        }
+      });
+
+      // Output list of contributors.
+      for (Contributor contributor : contributors) {
+        System.out.println(contributor.login + ": " + contributor.contributions);
       }
-    });
-
-    // Output list of contributors.
-    for (Contributor contributor : contributors) {
-      System.out.println(contributor.login + ": " + contributor.contributions);
     }
   }
 
diff --git a/samples/slack/pom.xml b/samples/slack/pom.xml
new file mode 100644
index 0000000000..c76577e6c7
--- /dev/null
+++ b/samples/slack/pom.xml
@@ -0,0 +1,26 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.okhttp3.sample</groupId>
+    <artifactId>sample-parent</artifactId>
+    <version>3.10.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>slack</artifactId>
+  <name>Sample: Slack</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup.okhttp3</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.moshi</groupId>
+      <artifactId>moshi</artifactId>
+    </dependency>
+  </dependencies>
+</project>
diff --git a/samples/slack/src/main/java/okhttp3/slack/OAuthSession.java b/samples/slack/src/main/java/okhttp3/slack/OAuthSession.java
new file mode 100644
index 0000000000..9a6869d2fb
--- /dev/null
+++ b/samples/slack/src/main/java/okhttp3/slack/OAuthSession.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.slack;
+
+/** Authorization for an application to make Slack API calls on behalf of a user. */
+@SuppressWarnings("checkstyle:membername")
+public final class OAuthSession {
+  public final boolean ok;
+  public final String access_token;
+  public final String scope;
+  public final String user_id;
+  public final String team_name;
+  public final String team_id;
+
+  public OAuthSession(
+      boolean ok, String accessToken, String scope, String userId, String teamName, String teamId) {
+    this.ok = ok;
+    this.access_token = accessToken;
+    this.scope = scope;
+    this.user_id = userId;
+    this.team_name = teamName;
+    this.team_id = teamId;
+  }
+
+  @Override public String toString() {
+    return String.format("(ok=%s, access_token=%s, scope=%s, user_id=%s, team_name=%s, team_id=%s)",
+        ok, access_token, scope, user_id, team_name, team_id);
+  }
+}
diff --git a/samples/slack/src/main/java/okhttp3/slack/OAuthSessionFactory.java b/samples/slack/src/main/java/okhttp3/slack/OAuthSessionFactory.java
new file mode 100644
index 0000000000..04ba201c96
--- /dev/null
+++ b/samples/slack/src/main/java/okhttp3/slack/OAuthSessionFactory.java
@@ -0,0 +1,126 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.slack;
+
+import java.io.Closeable;
+import java.io.IOException;
+import java.security.SecureRandom;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import okhttp3.HttpUrl;
+import okhttp3.mockwebserver.Dispatcher;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
+import okio.ByteString;
+
+/**
+ * Runs a MockWebServer on localhost and uses it as the backend to receive an OAuth session.
+ *
+ * <p>Clients should call {@link #start}, {@link #newAuthorizeUrl} and {@link #close} in that order.
+ * Clients may request multiple sessions.
+ */
+public final class OAuthSessionFactory extends Dispatcher implements Closeable {
+  private final SecureRandom secureRandom = new SecureRandom();
+
+  private final SlackApi slackApi;
+  private MockWebServer mockWebServer;
+
+  /** Guarded by this. */
+  private Map<ByteString, Listener> listeners = new LinkedHashMap<>();
+
+  public OAuthSessionFactory(SlackApi slackApi) {
+    this.slackApi = slackApi;
+  }
+
+  public void start() throws Exception {
+    if (mockWebServer != null) throw new IllegalStateException();
+
+    mockWebServer = new MockWebServer();
+    mockWebServer.setDispatcher(this);
+    mockWebServer.start(slackApi.port);
+  }
+
+  public HttpUrl newAuthorizeUrl(String scopes, String team, Listener listener) {
+    if (mockWebServer == null) throw new IllegalStateException();
+
+    ByteString state = randomToken();
+    synchronized (this) {
+      listeners.put(state, listener);
+    }
+
+    return slackApi.authorizeUrl(scopes, redirectUrl(), state, team);
+  }
+
+  private ByteString randomToken() {
+    byte[] bytes = new byte[16];
+    secureRandom.nextBytes(bytes);
+    return ByteString.of(bytes);
+  }
+
+  private HttpUrl redirectUrl() {
+    return mockWebServer.url("/oauth/");
+  }
+
+  /** When the browser hits the redirect URL, use the provided code to ask Slack for a session. */
+  @Override public MockResponse dispatch(RecordedRequest request) throws InterruptedException {
+    HttpUrl requestUrl = mockWebServer.url(request.getPath());
+    String code = requestUrl.queryParameter("code");
+    String stateString = requestUrl.queryParameter("state");
+    ByteString state = stateString != null ? ByteString.decodeBase64(stateString) : null;
+
+    Listener listener;
+    synchronized (this) {
+      listener = listeners.get(state);
+    }
+
+    if (code == null || listener == null) {
+      return new MockResponse()
+          .setResponseCode(404)
+          .setBody("unexpected request");
+    }
+
+    try {
+      OAuthSession session = slackApi.exchangeCode(code, redirectUrl());
+      listener.sessionGranted(session);
+    } catch (IOException e) {
+      return new MockResponse()
+          .setResponseCode(400)
+          .setBody("code exchange failed: " + e.getMessage());
+    }
+
+    synchronized (this) {
+      listeners.remove(state);
+    }
+
+    // Success!
+    return new MockResponse()
+        .setResponseCode(302)
+        .addHeader("Location", "https://twitter.com/CuteEmergency/status/789457462864863232");
+  }
+
+  public interface Listener {
+    void sessionGranted(OAuthSession session);
+  }
+
+  @Override public void close() {
+    if (mockWebServer == null) throw new IllegalStateException();
+    try {
+      mockWebServer.close();
+    } catch (IOException ignored) {
+    }
+  }
+}
diff --git a/samples/slack/src/main/java/okhttp3/slack/RtmSession.java b/samples/slack/src/main/java/okhttp3/slack/RtmSession.java
new file mode 100644
index 0000000000..b5802ef4ad
--- /dev/null
+++ b/samples/slack/src/main/java/okhttp3/slack/RtmSession.java
@@ -0,0 +1,75 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.slack;
+
+import java.io.Closeable;
+import java.io.IOException;
+import okhttp3.WebSocket;
+import okhttp3.Response;
+import okhttp3.WebSocketListener;
+
+/** A realtime messaging session. */
+public final class RtmSession extends WebSocketListener implements Closeable {
+  private final SlackApi slackApi;
+
+  /** Guarded by this. */
+  private WebSocket webSocket;
+
+  public RtmSession(SlackApi slackApi) {
+    this.slackApi = slackApi;
+  }
+
+  public void open(String accessToken) throws IOException {
+    if (webSocket != null) throw new IllegalStateException();
+
+    RtmStartResponse rtmStartResponse = slackApi.rtmStart(accessToken);
+    webSocket = slackApi.rtm(rtmStartResponse.url, this);
+  }
+
+  // TODO(jwilson): can I read the response body? Do I have to?
+  //                the body from slack is a 0-byte-buffer
+  @Override public synchronized void onOpen(WebSocket webSocket, Response response) {
+    System.out.println("onOpen: " + response);
+  }
+
+  // TOOD(jwilson): decode incoming messages and dispatch them somewhere.
+  @Override public void onMessage(WebSocket webSocket, String text) {
+    System.out.println("onMessage: " + text);
+  }
+
+  @Override public void onClosing(WebSocket webSocket, int code, String reason) {
+    webSocket.close(1000, null);
+    System.out.println("onClose (" + code + "): " + reason);
+  }
+
+  @Override public void onFailure(WebSocket webSocket, Throwable t, Response response) {
+    // TODO(jwilson): can I read the response body? Do I have to?
+    System.out.println("onFailure " + response);
+  }
+
+  @Override public void close() throws IOException {
+    if (webSocket == null) return;
+
+    WebSocket webSocket;
+    synchronized (this) {
+      webSocket = this.webSocket;
+    }
+
+    if (webSocket != null) {
+      webSocket.close(1000, "bye");
+    }
+  }
+}
diff --git a/samples/slack/src/main/java/okhttp3/slack/RtmStartResponse.java b/samples/slack/src/main/java/okhttp3/slack/RtmStartResponse.java
new file mode 100644
index 0000000000..b19fff6256
--- /dev/null
+++ b/samples/slack/src/main/java/okhttp3/slack/RtmStartResponse.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.slack;
+
+import java.util.List;
+import okhttp3.HttpUrl;
+
+/** See https://api.slack.com/methods/rtm.start. */
+public final class RtmStartResponse {
+  HttpUrl url;
+  Object self;
+  Object team;
+  List<Object> users;
+  List<Object> channels;
+  List<Object> groups;
+  List<Object> mpims;
+  List<Object> ims;
+  List<Object> bots;
+}
diff --git a/samples/slack/src/main/java/okhttp3/slack/SlackApi.java b/samples/slack/src/main/java/okhttp3/slack/SlackApi.java
new file mode 100644
index 0000000000..0ec0ef7a45
--- /dev/null
+++ b/samples/slack/src/main/java/okhttp3/slack/SlackApi.java
@@ -0,0 +1,126 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.slack;
+
+import com.squareup.moshi.FromJson;
+import com.squareup.moshi.JsonAdapter;
+import com.squareup.moshi.Moshi;
+import com.squareup.moshi.ToJson;
+import java.io.IOException;
+import okhttp3.Call;
+import okhttp3.HttpUrl;
+import okhttp3.WebSocket;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.WebSocketListener;
+import okio.ByteString;
+
+/**
+ * API access to the <a href="https://api.slack.com/apps">Slack API</a> as an application. One
+ * instance of this class may operate without a user, or on behalf of many users. Use the Slack API
+ * dashboard to create a client ID and secret for this application.
+ *
+ * <p>You must configure your Slack API OAuth and Permissions page with a localhost URL like {@code
+ * http://localhost:53203/oauth/}, passing the same port to this class’ constructor.
+ */
+public final class SlackApi {
+  private final HttpUrl baseUrl = HttpUrl.parse("https://slack.com/api/");
+  private final OkHttpClient httpClient;
+  private final Moshi moshi;
+
+  public final String clientId;
+  public final String clientSecret;
+  public final int port;
+
+  public SlackApi(String clientId, String clientSecret, int port) {
+    this.httpClient = new OkHttpClient.Builder()
+        .build();
+    this.moshi = new Moshi.Builder()
+        .add(new SlackJsonAdapters())
+        .build();
+    this.clientId = clientId;
+    this.clientSecret = clientSecret;
+    this.port = port;
+  }
+
+  /** See https://api.slack.com/docs/oauth. */
+  public HttpUrl authorizeUrl(String scopes, HttpUrl redirectUrl, ByteString state, String team) {
+    HttpUrl.Builder builder = baseUrl.newBuilder("/oauth/authorize")
+        .addQueryParameter("client_id", clientId)
+        .addQueryParameter("scope", scopes)
+        .addQueryParameter("redirect_uri", redirectUrl.toString())
+        .addQueryParameter("state", state.base64());
+
+    if (team != null) {
+      builder.addQueryParameter("team", team);
+    }
+
+    return builder.build();
+  }
+
+  /** See https://api.slack.com/methods/oauth.access. */
+  public OAuthSession exchangeCode(String code, HttpUrl redirectUrl) throws IOException {
+    HttpUrl url = baseUrl.newBuilder("oauth.access")
+        .addQueryParameter("client_id", clientId)
+        .addQueryParameter("client_secret", clientSecret)
+        .addQueryParameter("code", code)
+        .addQueryParameter("redirect_uri", redirectUrl.toString())
+        .build();
+    Request request = new Request.Builder()
+        .url(url)
+        .build();
+    Call call = httpClient.newCall(request);
+    try (Response response = call.execute()) {
+      JsonAdapter<OAuthSession> jsonAdapter = moshi.adapter(OAuthSession.class);
+      return jsonAdapter.fromJson(response.body().source());
+    }
+  }
+
+  /** See https://api.slack.com/methods/rtm.start. */
+  public RtmStartResponse rtmStart(String accessToken) throws IOException {
+    HttpUrl url = baseUrl.newBuilder("rtm.start")
+        .addQueryParameter("token", accessToken)
+        .build();
+    Request request = new Request.Builder()
+        .url(url)
+        .build();
+    Call call = httpClient.newCall(request);
+    try (Response response = call.execute()) {
+      JsonAdapter<RtmStartResponse> jsonAdapter = moshi.adapter(RtmStartResponse.class);
+      return jsonAdapter.fromJson(response.body().source());
+    }
+  }
+
+  /** See https://api.slack.com/rtm. */
+  public WebSocket rtm(HttpUrl url, WebSocketListener listener) {
+    return httpClient.newWebSocket(new Request.Builder()
+        .url(url)
+        .build(), listener);
+  }
+
+  static final class SlackJsonAdapters {
+    @ToJson String urlToJson(HttpUrl httpUrl) {
+      return httpUrl.toString();
+    }
+
+    @FromJson HttpUrl urlFromJson(String urlString) {
+      if (urlString.startsWith("wss:")) urlString = "https:" + urlString.substring(4);
+      if (urlString.startsWith("ws:")) urlString = "http:" + urlString.substring(3);
+      return HttpUrl.parse(urlString);
+    }
+  }
+}
diff --git a/samples/slack/src/main/java/okhttp3/slack/SlackClient.java b/samples/slack/src/main/java/okhttp3/slack/SlackClient.java
new file mode 100644
index 0000000000..2aa2608986
--- /dev/null
+++ b/samples/slack/src/main/java/okhttp3/slack/SlackClient.java
@@ -0,0 +1,102 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.slack;
+
+import java.io.IOException;
+import java.io.InterruptedIOException;
+import okhttp3.HttpUrl;
+import okio.Timeout;
+
+/** A connection to Slack as a single user. */
+public final class SlackClient {
+  private final SlackApi slackApi;
+  private OAuthSessionFactory sessionFactory;
+
+  /** Guarded by this. */
+  private OAuthSession session;
+
+  public SlackClient(SlackApi slackApi) {
+    this.slackApi = slackApi;
+  }
+
+  /** Shows a browser URL to authorize this app to act as this user. */
+  public void requestOauthSession(String scopes, String team) throws Exception {
+    if (sessionFactory == null) {
+      sessionFactory = new OAuthSessionFactory(slackApi);
+      sessionFactory.start();
+    }
+
+    HttpUrl authorizeUrl = sessionFactory.newAuthorizeUrl(scopes, team,
+        new OAuthSessionFactory.Listener() {
+          @Override public void sessionGranted(OAuthSession session) {
+            initOauthSession(session);
+            System.out.printf("session granted: %s\n", session);
+          }
+        });
+
+    System.out.printf("open this URL in a browser: %s\n", authorizeUrl);
+  }
+
+  /** Set the OAuth session for this client. */
+  public synchronized void initOauthSession(OAuthSession session) {
+    this.session = session;
+    this.notifyAll();
+  }
+
+  /** Waits for an OAuth session for this client to be set. */
+  public synchronized void awaitAccessToken(Timeout timeout) throws InterruptedIOException {
+    while (session == null) {
+      timeout.waitUntilNotified(this);
+    }
+  }
+
+  /** Starts a real time messaging session. */
+  public void startRtm() throws IOException {
+    String accessToken;
+    synchronized (this) {
+      accessToken = session.access_token;
+    }
+
+    RtmSession rtmSession = new RtmSession(slackApi);
+    rtmSession.open(accessToken);
+  }
+
+  public static void main(String... args) throws Exception {
+    String clientId = "0000000000.00000000000";
+    String clientSecret = "00000000000000000000000000000000";
+    int port = 53203;
+    SlackApi slackApi = new SlackApi(clientId, clientSecret, port);
+
+    SlackClient client = new SlackClient(slackApi);
+    String scopes = "channels:history channels:read channels:write chat:write:bot chat:write:user "
+        + "dnd:read dnd:write emoji:read files:read files:write:user groups:history groups:read "
+        + "groups:write im:history im:read im:write mpim:history mpim:read mpim:write pins:read "
+        + "pins:write reactions:read reactions:write search:read stars:read stars:write team:read "
+        + "usergroups:read usergroups:write users:read users:write identify";
+
+    if (true) {
+      client.requestOauthSession(scopes, null);
+    } else {
+      OAuthSession session = new OAuthSession(true,
+          "xoxp-XXXXXXXXXX-XXXXXXXXXX-XXXXXXXXXXX-XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",
+          scopes, "UXXXXXXXX", "My Slack Group", "TXXXXXXXX");
+      client.initOauthSession(session);
+    }
+
+    client.awaitAccessToken(Timeout.NONE);
+    client.startRtm();
+  }
+}
diff --git a/samples/static-server/pom.xml b/samples/static-server/pom.xml
index dc446c5a2b..30b3cb8689 100644
--- a/samples/static-server/pom.xml
+++ b/samples/static-server/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>3.4.0-SNAPSHOT</version>
+    <version>3.10.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>static-server</artifactId>
diff --git a/website/index.html b/website/index.html
index ff9ec474b3..110901dab7 100644
--- a/website/index.html
+++ b/website/index.html
@@ -69,7 +69,7 @@ <h3 id="overview">Overview</h3>
 
             <h3 id="examples">Examples</h3>
             <h4>Get a URL</h4>
-            <p>This program downloads a URL and print its contents as a string. <a href="https://raw.github.com/square/okhttp/master/samples/guide/src/main/java/okhttp3/guide/GetExample.java">Full source</a>.
+            <p>This program downloads a URL and prints its contents as a string. <a href="https://raw.github.com/square/okhttp/master/samples/guide/src/main/java/okhttp3/guide/GetExample.java">Full source</a>.
 <pre class="prettyprint">
 OkHttpClient client = new OkHttpClient();
 
@@ -78,8 +78,9 @@ <h4>Get a URL</h4>
       .url(url)
       .build();
 
-  Response response = client.newCall(request).execute();
-  return response.body().string();
+  try (Response response = client.newCall(request).execute()) {
+    return response.body().string();
+  }
 }
 </pre>
             <h4>Post to a Server</h4>
@@ -97,8 +98,9 @@ <h4>Post to a Server</h4>
       .url(url)
       .post(body)
       .build();
-  Response response = client.newCall(request).execute();
-  return response.body().string();
+  try (Response response = client.newCall(request).execute()) {
+    return response.body().string();
+  }
 }
 </pre>
 
