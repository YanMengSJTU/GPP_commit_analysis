diff --git a/okhttp/src/main/java/okhttp3/ConnectionPool.java b/okhttp/src/main/java/okhttp3/ConnectionPool.java
index db97676d50..701a98813b 100644
--- a/okhttp/src/main/java/okhttp3/ConnectionPool.java
+++ b/okhttp/src/main/java/okhttp3/ConnectionPool.java
@@ -117,9 +117,7 @@ public synchronized int connectionCount() {
   RealConnection get(Address address, StreamAllocation streamAllocation) {
     assert (Thread.holdsLock(this));
     for (RealConnection connection : connections) {
-      // TODO(jwilson): this is awkward. We're already holding a lock on 'this', and
-      //     connection.allocationLimit() may also lock the FramedConnection.
-      if (connection.allocations.size() < connection.allocationLimit()
+      if (connection.allocations.size() < connection.allocationLimit
           && address.equals(connection.route().address)
           && !connection.noNewStreams) {
         streamAllocation.acquire(connection);
diff --git a/okhttp/src/main/java/okhttp3/internal/io/RealConnection.java b/okhttp/src/main/java/okhttp3/internal/io/RealConnection.java
index 3077a77178..85494a7cf5 100644
--- a/okhttp/src/main/java/okhttp3/internal/io/RealConnection.java
+++ b/okhttp/src/main/java/okhttp3/internal/io/RealConnection.java
@@ -44,7 +44,9 @@
 import okhttp3.internal.Platform;
 import okhttp3.internal.Util;
 import okhttp3.internal.Version;
+import okhttp3.internal.framed.ErrorCode;
 import okhttp3.internal.framed.FramedConnection;
+import okhttp3.internal.framed.FramedStream;
 import okhttp3.internal.http.Http1xStream;
 import okhttp3.internal.http.OkHeaders;
 import okhttp3.internal.http.RouteException;
@@ -60,7 +62,7 @@
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static okhttp3.internal.Util.closeQuietly;
 
-public final class RealConnection implements Connection {
+public final class RealConnection extends FramedConnection.Listener implements Connection {
   private final Route route;
 
   /** The low-level TCP socket. */
@@ -77,6 +79,7 @@
   public int successCount;
   public BufferedSource source;
   public BufferedSink sink;
+  public int allocationLimit;
   public final List<Reference<StreamAllocation>> allocations = new ArrayList<>();
   public boolean noNewStreams;
   public long idleAtNanos = Long.MAX_VALUE;
@@ -154,11 +157,15 @@ private void connectSocket(int connectTimeout, int readTimeout, int writeTimeout
       FramedConnection framedConnection = new FramedConnection.Builder(true)
           .socket(socket, route.address().url().host(), source, sink)
           .protocol(protocol)
+          .listener(this)
           .build();
       framedConnection.sendConnectionPreface();
 
       // Only assign the framed connection once the preface has been sent successfully.
+      this.allocationLimit = framedConnection.maxConcurrentStreams();
       this.framedConnection = framedConnection;
+    } else {
+      this.allocationLimit = 1;
     }
   }
 
@@ -308,13 +315,6 @@ public void cancel() {
     return socket;
   }
 
-  public int allocationLimit() {
-    FramedConnection framedConnection = this.framedConnection;
-    return framedConnection != null
-        ? framedConnection.maxConcurrentStreams()
-        : 1;
-  }
-
   /** Returns true if this connection is ready to host new streams. */
   public boolean isHealthy(boolean doExtensiveChecks) {
     if (socket.isClosed() || socket.isInputShutdown() || socket.isOutputShutdown()) {
@@ -347,6 +347,16 @@ public boolean isHealthy(boolean doExtensiveChecks) {
     return true;
   }
 
+  /** Refuse incoming streams. */
+  @Override public void onStream(FramedStream stream) throws IOException {
+    stream.close(ErrorCode.REFUSED_STREAM);
+  }
+
+  /** When settings are received, adjust the allocation limit. */
+  @Override public void onSettings(FramedConnection connection) {
+    allocationLimit = connection.maxConcurrentStreams();
+  }
+
   @Override public Handshake handshake() {
     return handshake;
   }
