diff --git a/okhttp-tests/src/test/java/okhttp3/ConnectionCoalescingTest.java b/okhttp-tests/src/test/java/okhttp3/ConnectionCoalescingTest.java
index aedb5f2300..5e3b25afdf 100644
--- a/okhttp-tests/src/test/java/okhttp3/ConnectionCoalescingTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/ConnectionCoalescingTest.java
@@ -20,6 +20,7 @@
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
+import java.util.concurrent.atomic.AtomicReference;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLSession;
 import okhttp3.internal.tls.HeldCertificate;
@@ -117,6 +118,33 @@
     assertEquals(1, client.connectionPool().connectionCount());
   }
 
+  /** Test a previously coalesced connection that's no longer healthy. */
+  @Test public void staleCoalescedConnection() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(200));
+    server.enqueue(new MockResponse().setResponseCode(200));
+
+    final AtomicReference<Connection> connection = new AtomicReference<>();
+    client = client.newBuilder()
+        .addNetworkInterceptor(new Interceptor() {
+          @Override public Response intercept(Chain chain) throws IOException {
+            connection.set(chain.connection());
+            return chain.proceed(chain.request());
+          }
+        })
+        .build();
+    dns.set("san.com", Dns.SYSTEM.lookup(server.getHostName()).subList(0, 1));
+
+    assert200Http2Response(execute(url), server.getHostName());
+
+    // Simulate a stale connection in the pool.
+    connection.get().socket().close();
+
+    HttpUrl sanUrl = url.newBuilder().host("san.com").build();
+    assert200Http2Response(execute(sanUrl), "san.com");
+
+    assertEquals(1, client.connectionPool().connectionCount());
+  }
+
   /** If the existing connection matches a SAN but not a match for DNS then skip. */
   @Test public void skipsWhenDnsDontMatch() throws Exception {
     server.enqueue(new MockResponse().setResponseCode(200));
@@ -287,5 +315,6 @@ private void assert200Http2Response(Response response, String expectedHost) {
     assertEquals(200, response.code());
     assertEquals(expectedHost, response.request().url().host());
     assertEquals(Protocol.HTTP_2, response.protocol());
+    response.body().close();
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java b/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
index 211181961f..3148cea7cb 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
@@ -178,7 +178,10 @@ private RealConnection findConnection(int connectTimeout, int readTimeout, int w
       // Now that we have an IP address, make another attempt at getting a connection from the pool.
       // This could match due to connection coalescing.
       Internal.instance.get(connectionPool, address, this, selectedRoute);
-      if (connection != null) return connection;
+      if (connection != null) {
+        route = selectedRoute;
+        return connection;
+      }
 
       // Create a connection and assign it to this allocation immediately. This makes it possible
       // for an asynchronous cancel() to interrupt the handshake we're about to do.
