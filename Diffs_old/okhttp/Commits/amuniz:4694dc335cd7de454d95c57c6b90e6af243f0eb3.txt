diff --git a/okhttp-tests/src/test/java/okhttp3/WebSocketCallTest.java b/okhttp-tests/src/test/java/okhttp3/WebSocketCallTest.java
index 43aad79515..8f18cb3897 100644
--- a/okhttp-tests/src/test/java/okhttp3/WebSocketCallTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/WebSocketCallTest.java
@@ -18,9 +18,12 @@
 import java.io.IOException;
 import java.net.ProtocolException;
 import java.util.Random;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicInteger;
 import java.util.logging.Logger;
 import okhttp3.internal.tls.SslClient;
 import okhttp3.internal.ws.EmptyWebSocketListener;
+import okhttp3.internal.ws.RealWebSocket;
 import okhttp3.internal.ws.WebSocketRecorder;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
@@ -30,10 +33,12 @@
 import org.junit.Rule;
 import org.junit.Test;
 
+import static java.util.concurrent.TimeUnit.SECONDS;
 import static okhttp3.WebSocket.BINARY;
 import static okhttp3.WebSocket.TEXT;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 public final class WebSocketCallTest {
@@ -155,6 +160,76 @@
     clientListener.assertTextMessage("Hello, WebSockets!");
   }
 
+  @Test public void writingOnReaderThreadThrows() throws IOException, InterruptedException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+
+    Request request = new Request.Builder().get().url(webServer.url("/")).build();
+    RealWebSocketCall call = new RealWebSocketCall(client, request, random);
+
+    final AtomicInteger count = new AtomicInteger();
+    final CountDownLatch latch = new CountDownLatch(1);
+    call.enqueue(new WebSocketListener() {
+      private WebSocket webSocket;
+
+      @Override public void onOpen(WebSocket webSocket, Response response) {
+        this.webSocket = webSocket;
+
+        try {
+          webSocket.close(1000, "");
+          fail();
+        } catch (IllegalStateException e) {
+          assertEquals("attempting to write from reader thread", e.getMessage());
+        } catch (IOException e) {
+          throw new AssertionError(e);
+        }
+
+        count.getAndIncrement();
+      }
+
+      @Override public void onMessage(ResponseBody message) throws IOException {
+        try {
+          webSocket.message(RequestBody.create(TEXT, "hey"));
+          fail();
+        } catch (IllegalStateException e) {
+          assertEquals("attempting to write from reader thread", e.getMessage());
+        }
+
+        message.close();
+        count.getAndIncrement();
+      }
+
+      @Override public void onPong(ByteString payload) {
+        try {
+          webSocket.ping(ByteString.EMPTY);
+          fail();
+        } catch (IllegalStateException e) {
+          assertEquals("attempting to write from reader thread", e.getMessage());
+        } catch (IOException e) {
+          throw new AssertionError(e);
+        }
+
+        count.getAndIncrement();
+      }
+
+      @Override public void onClose(int code, String reason) {
+        latch.countDown();
+      }
+
+      @Override public void onFailure(Throwable t, Response response) {
+        t.printStackTrace();
+      }
+    });
+
+    WebSocket server = serverListener.assertOpen();
+    server.message(RequestBody.create(TEXT, "hi"));
+    ((RealWebSocket) server).pong(ByteString.EMPTY);
+    server.close(1000, "");
+
+    assertTrue(latch.await(10, SECONDS));
+    // Verify we hit all three callbacks and attempted to write in them.
+    assertEquals(3, count.get());
+  }
+
   @Test public void throwingOnOpenClosesAndFails() {
     webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
 
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
index a8ac1c3c26..94c20d434b 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
@@ -146,14 +146,14 @@
   }
 
   @Test public void unsolicitedPong() throws IOException {
-    client.sendPong(ByteString.encodeUtf8("Hello!"));
+    client.pong(ByteString.encodeUtf8("Hello!"));
     server.processNextFrame();
     serverListener.assertPong(ByteString.encodeUtf8("Hello!"));
   }
 
   @Test public void nullPongPayloadThrows() throws IOException {
     try {
-      client.sendPong(null);
+      client.pong(null);
       fail();
     } catch (NullPointerException e) {
       assertEquals("payload == null", e.getMessage());
diff --git a/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java b/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java
index 157465b623..8c360d8025 100644
--- a/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java
+++ b/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java
@@ -82,6 +82,8 @@
   private final Response response;
   private final String name;
 
+  /** The thread looping the reader. Will become null when looping stops for any reason. */
+  private volatile Thread looperThread;
   /** Guarded by {@link #replier}. True after calling {@link #shutdown()}. */
   private boolean isShutdown;
 
@@ -100,16 +102,22 @@ protected RealWebSocket(boolean isClient, BufferedSource source, BufferedSink si
 
   /** Read and process all socket messages delivering callbacks to the supplied listener. */
   public final void loopReader() {
+    looperThread = Thread.currentThread();
+
     try {
-      readerListener.onOpen(this, response);
-    } catch (Throwable t) {
-      Util.throwIfFatal(t);
-      replyToReaderError(t);
-      readerListener.onFailure(t, null);
-      return;
-    }
+      try {
+        readerListener.onOpen(this, response);
+      } catch (Throwable t) {
+        Util.throwIfFatal(t);
+        replyToReaderError(t);
+        readerListener.onFailure(t, null);
+        return;
+      }
 
-    while (processNextFrame()) {
+      while (processNextFrame()) {
+      }
+    } finally {
+      looperThread = null;
     }
   }
 
@@ -229,6 +237,9 @@ private void replyToReaderError(final Throwable t) {
     if (message == null) throw new NullPointerException("message == null");
     if (senderSentClose) throw new IllegalStateException("closed");
     if (senderWantsClose) throw new IllegalStateException("must call close()");
+    if (Thread.currentThread() == looperThread) {
+      throw new IllegalStateException("attempting to write from reader thread");
+    }
 
     MediaType contentType = message.contentType();
     if (contentType == null) {
@@ -262,6 +273,9 @@ private void replyToReaderError(final Throwable t) {
     if (payload == null) throw new NullPointerException("payload == null");
     if (senderSentClose) throw new IllegalStateException("closed");
     if (senderWantsClose) throw new IllegalStateException("must call close()");
+    if (Thread.currentThread() == looperThread) {
+      throw new IllegalStateException("attempting to write from reader thread");
+    }
 
     try {
       writer.writePing(payload);
@@ -272,10 +286,13 @@ private void replyToReaderError(final Throwable t) {
   }
 
   /** Send an unsolicited pong with the specified payload. */
-  final void sendPong(ByteString payload) throws IOException {
+  public final void pong(ByteString payload) throws IOException {
     if (payload == null) throw new NullPointerException("payload == null");
     if (senderSentClose) throw new IllegalStateException("closed");
     if (senderWantsClose) throw new IllegalStateException("must call close()");
+    if (Thread.currentThread() == looperThread) {
+      throw new IllegalStateException("attempting to write from reader thread");
+    }
 
     try {
       writer.writePong(payload);
@@ -287,6 +304,10 @@ final void sendPong(ByteString payload) throws IOException {
 
   @Override public final void close(int code, String reason) throws IOException {
     if (senderSentClose) throw new IllegalStateException("closed");
+    if (Thread.currentThread() == looperThread) {
+      throw new IllegalStateException("attempting to write from reader thread");
+    }
+
     senderSentClose = true;
 
     // Not doing a CAS because we want writer to throw if already closed via peer close.
