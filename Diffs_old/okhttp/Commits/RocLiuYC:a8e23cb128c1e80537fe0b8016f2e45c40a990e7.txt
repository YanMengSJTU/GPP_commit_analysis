diff --git a/okhttp/src/main/java/okhttp3/Cache.java b/okhttp/src/main/java/okhttp3/Cache.java
index 343df45113..6e89f8a68b 100644
--- a/okhttp/src/main/java/okhttp3/Cache.java
+++ b/okhttp/src/main/java/okhttp3/Cache.java
@@ -15,6 +15,8 @@
  */
 package okhttp3;
 
+import android.text.TextUtils;
+
 import java.io.Closeable;
 import java.io.File;
 import java.io.Flushable;
@@ -186,12 +188,14 @@ public Cache(File directory, long maxSize) {
     this.cache = DiskLruCache.create(fileSystem, directory, VERSION, ENTRY_COUNT, maxSize);
   }
 
-  public static String key(HttpUrl url) {
-    return ByteString.encodeUtf8(url.toString()).md5().hex();
+  public static String key(Request request) {
+    String result = TextUtils.isEmpty(request.cacheKey) ? request.url.uri().toString()
+            : request.cacheKey;
+    return ByteString.encodeUtf8(result).md5().hex();
   }
 
   @Nullable Response get(Request request) {
-    String key = key(request.url());
+    String key = key(request);
     DiskLruCache.Snapshot snapshot;
     Entry entry;
     try {
@@ -246,7 +250,7 @@ public static String key(HttpUrl url) {
     Entry entry = new Entry(response);
     DiskLruCache.Editor editor = null;
     try {
-      editor = cache.edit(key(response.request().url()));
+      editor = cache.edit(key(response.request()));
       if (editor == null) {
         return null;
       }
@@ -259,7 +263,7 @@ public static String key(HttpUrl url) {
   }
 
   void remove(Request request) throws IOException {
-    cache.remove(key(request.url()));
+    cache.remove(key(request));
   }
 
   void update(Response cached, Response network) {
@@ -483,6 +487,7 @@ public synchronized int requestCount() {
     private static final String RECEIVED_MILLIS = Platform.get().getPrefix() + "-Received-Millis";
 
     private final String url;
+    private final String cacheKey;
     private final Headers varyHeaders;
     private final String requestMethod;
     private final Protocol protocol;
@@ -545,6 +550,7 @@ public synchronized int requestCount() {
       try {
         BufferedSource source = Okio.buffer(in);
         url = source.readUtf8LineStrict();
+        cacheKey = source.readUtf8LineStrict();
         requestMethod = source.readUtf8LineStrict();
         Headers.Builder varyHeadersBuilder = new Headers.Builder();
         int varyRequestHeaderLineCount = readInt(source);
@@ -597,6 +603,7 @@ public synchronized int requestCount() {
 
     Entry(Response response) {
       this.url = response.request().url().toString();
+      this.cacheKey = response.request().cacheKey();
       this.varyHeaders = HttpHeaders.varyHeaders(response);
       this.requestMethod = response.request().method();
       this.protocol = response.protocol();
@@ -613,6 +620,10 @@ public void writeTo(DiskLruCache.Editor editor) throws IOException {
 
       sink.writeUtf8(url)
           .writeByte('\n');
+      if (!TextUtils.isEmpty(cacheKey)) {
+        sink.writeUtf8(cacheKey)
+                .writeByte('\n');
+      }
       sink.writeUtf8(requestMethod)
           .writeByte('\n');
       sink.writeDecimalLong(varyHeaders.size())
@@ -694,7 +705,15 @@ private void writeCertList(BufferedSink sink, List<Certificate> certificates)
     }
 
     public boolean matches(Request request, Response response) {
-      return url.equals(request.url().toString())
+      boolean isUseCacheKey = !TextUtils.isEmpty(cacheKey);
+      boolean isCacheKeyEquals;
+      if (isUseCacheKey) {
+        isCacheKeyEquals = cacheKey.equals(request.cacheKey());
+      } else {
+        isCacheKeyEquals = url.equals(request.url().toString());
+      }
+      
+      return isCacheKeyEquals
           && requestMethod.equals(request.method())
           && HttpHeaders.varyMatches(response, varyHeaders, request);
     }
@@ -704,6 +723,7 @@ public Response response(DiskLruCache.Snapshot snapshot) {
       String contentLength = responseHeaders.get("Content-Length");
       Request cacheRequest = new Request.Builder()
           .url(url)
+          .cacheKey(cacheKey)
           .method(requestMethod, null)
           .headers(varyHeaders)
           .build();
diff --git a/okhttp/src/main/java/okhttp3/Call.java b/okhttp/src/main/java/okhttp3/Call.java
index 67d0f88d3d..89e1ec0e4d 100644
--- a/okhttp/src/main/java/okhttp3/Call.java
+++ b/okhttp/src/main/java/okhttp3/Call.java
@@ -57,6 +57,8 @@
    */
   Response execute() throws IOException;
 
+  Response execute(DiskCacheListener diskCacheListener) throws IOException;
+
   /**
    * Schedules the request to be executed at some point in the future.
    *
diff --git a/okhttp/src/main/java/okhttp3/DiskCacheListener.java b/okhttp/src/main/java/okhttp3/DiskCacheListener.java
new file mode 100644
index 0000000000..4d96f1693f
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/DiskCacheListener.java
@@ -0,0 +1,7 @@
+package okhttp3;
+
+public interface DiskCacheListener {
+    void onStart(String url, long totalCount);
+    void onProgress(String url, long totalCount, long writeCount);
+    void onComplete(String url);
+}
\ No newline at end of file
diff --git a/okhttp/src/main/java/okhttp3/Headers.java b/okhttp/src/main/java/okhttp3/Headers.java
index 8b662c96ac..07cd3c7272 100644
--- a/okhttp/src/main/java/okhttp3/Headers.java
+++ b/okhttp/src/main/java/okhttp3/Headers.java
@@ -27,7 +27,9 @@
 import java.util.Set;
 import java.util.TreeMap;
 import java.util.TreeSet;
+
 import javax.annotation.Nullable;
+
 import okhttp3.internal.Util;
 import okhttp3.internal.http.HttpDate;
 
diff --git a/okhttp/src/main/java/okhttp3/RealCall.java b/okhttp/src/main/java/okhttp3/RealCall.java
index a9ba5be366..8465a16905 100644
--- a/okhttp/src/main/java/okhttp3/RealCall.java
+++ b/okhttp/src/main/java/okhttp3/RealCall.java
@@ -80,6 +80,10 @@ static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolea
   }
 
   @Override public Response execute() throws IOException {
+    return execute(null);
+  }
+
+  @Override public Response execute(DiskCacheListener diskCacheListener) throws IOException {
     synchronized (this) {
       if (executed) throw new IllegalStateException("Already Executed");
       executed = true;
@@ -89,7 +93,7 @@ static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolea
     eventListener.callStart(this);
     try {
       client.dispatcher().executed(this);
-      Response result = getResponseWithInterceptorChain();
+      Response result = getResponseWithInterceptorChain(diskCacheListener);
       if (result == null) throw new IOException("Canceled");
       return result;
     } catch (IOException e) {
@@ -197,7 +201,7 @@ void executeOn(ExecutorService executorService) {
       boolean signalledCallback = false;
       timeout.enter();
       try {
-        Response response = getResponseWithInterceptorChain();
+        Response response = getResponseWithInterceptorChain(null);
         if (retryAndFollowUpInterceptor.isCanceled()) {
           signalledCallback = true;
           responseCallback.onFailure(RealCall.this, new IOException("Canceled"));
@@ -234,13 +238,13 @@ String redactedUrl() {
     return originalRequest.url().redact();
   }
 
-  Response getResponseWithInterceptorChain() throws IOException {
+  Response getResponseWithInterceptorChain(DiskCacheListener diskCacheListener) throws IOException {
     // Build a full stack of interceptors.
     List<Interceptor> interceptors = new ArrayList<>();
     interceptors.addAll(client.interceptors());
     interceptors.add(retryAndFollowUpInterceptor);
     interceptors.add(new BridgeInterceptor(client.cookieJar()));
-    interceptors.add(new CacheInterceptor(client.internalCache()));
+    interceptors.add(new CacheInterceptor(client.internalCache(), diskCacheListener));
     interceptors.add(new ConnectInterceptor(client));
     if (!forWebSocket) {
       interceptors.addAll(client.networkInterceptors());
diff --git a/okhttp/src/main/java/okhttp3/Request.java b/okhttp/src/main/java/okhttp3/Request.java
index e06a29c075..e61074fbf4 100644
--- a/okhttp/src/main/java/okhttp3/Request.java
+++ b/okhttp/src/main/java/okhttp3/Request.java
@@ -20,7 +20,9 @@
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
+
 import javax.annotation.Nullable;
+
 import okhttp3.internal.Util;
 import okhttp3.internal.http.HttpMethod;
 
@@ -35,6 +37,7 @@
   final @Nullable RequestBody body;
   final boolean duplex;
   final Map<Class<?>, Object> tags;
+  final String cacheKey;
 
   private volatile @Nullable CacheControl cacheControl; // Lazily initialized.
 
@@ -45,6 +48,7 @@
     this.body = builder.body;
     this.duplex = builder.duplex;
     this.tags = Util.immutableMap(builder.tags);
+    this.cacheKey = builder.cacheKey;
   }
 
   public HttpUrl url() {
@@ -95,6 +99,10 @@ boolean isDuplex() {
     return type.cast(tags.get(type));
   }
 
+  public String cacheKey() {
+    return cacheKey;
+  }
+
   public Builder newBuilder() {
     return new Builder(this);
   }
@@ -131,10 +139,12 @@ public boolean isHttps() {
 
     /** A mutable map of tags, or an immutable empty map if we don't have any. */
     Map<Class<?>, Object> tags = Collections.emptyMap();
+    String cacheKey;
 
     public Builder() {
       this.method = "GET";
       this.headers = new Headers.Builder();
+      this.cacheKey = null;
     }
 
     Builder(Request request) {
@@ -146,6 +156,7 @@ public Builder() {
           ? Collections.<Class<?>, Object>emptyMap()
           : new LinkedHashMap<>(request.tags);
       this.headers = request.headers.newBuilder();
+      this.cacheKey = request.cacheKey;
     }
 
     public Builder url(HttpUrl url) {
@@ -217,6 +228,11 @@ public Builder headers(Headers headers) {
       return this;
     }
 
+    public Builder cacheKey(String cacheKey) {
+      this.cacheKey = cacheKey;
+      return this;
+    }
+
     /**
      * Sets this request's {@code Cache-Control} header, replacing any cache control headers already
      * present. If {@code cacheControl} doesn't define any directives, this clears this request's
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java b/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java
index d46494d95b..b828cf9026 100644
--- a/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java
@@ -16,6 +16,7 @@
  */
 package okhttp3.internal.cache;
 
+import okhttp3.DiskCacheListener;
 import java.io.IOException;
 import okhttp3.Headers;
 import okhttp3.Interceptor;
@@ -44,9 +45,11 @@
 /** Serves requests from the cache and writes responses to the cache. */
 public final class CacheInterceptor implements Interceptor {
   final InternalCache cache;
+  final DiskCacheListener diskCacheListener;
 
-  public CacheInterceptor(InternalCache cache) {
+  public CacheInterceptor(InternalCache cache, DiskCacheListener diskCacheListener) {
     this.cache = cache;
+    this.diskCacheListener = diskCacheListener;
   }
 
   @Override public Response intercept(Chain chain) throws IOException {
@@ -155,7 +158,7 @@ private static Response stripBody(Response response) {
    * consumer. This is careful to discard bytes left over when the stream is closed; otherwise we
    * may never exhaust the source stream and therefore not complete the cached response.
    */
-  private Response cacheWritingResponse(final CacheRequest cacheRequest, Response response)
+  private Response cacheWritingResponse(final CacheRequest cacheRequest, final Response response)
       throws IOException {
     // Some apps return a null body; for compatibility we treat that like a null cache request.
     if (cacheRequest == null) return response;
@@ -165,11 +168,25 @@ private Response cacheWritingResponse(final CacheRequest cacheRequest, Response
     final BufferedSource source = response.body().source();
     final BufferedSink cacheBody = Okio.buffer(cacheBodyUnbuffered);
 
+    final String cacheUrl;
+    if (response.request() != null && response.request().url() != null) {
+      cacheUrl = response.request().url().toString();
+    } else {
+      cacheUrl = null;
+    }
+    final long responseBodyLength = response.body().contentLength();
+
     Source cacheWritingSource = new Source() {
       boolean cacheRequestClosed;
+      long cachedByteCount = 0;
 
       @Override public long read(Buffer sink, long byteCount) throws IOException {
         long bytesRead;
+
+        if (cachedByteCount == 0 && diskCacheListener != null) {
+          diskCacheListener.onStart(cacheUrl, responseBodyLength);
+        }
+
         try {
           bytesRead = source.read(sink, byteCount);
         } catch (IOException e) {
@@ -177,6 +194,9 @@ private Response cacheWritingResponse(final CacheRequest cacheRequest, Response
             cacheRequestClosed = true;
             cacheRequest.abort(); // Failed to write a complete cache response.
           }
+
+          if (diskCacheListener != null)
+            diskCacheListener.onComplete(cacheUrl);
           throw e;
         }
 
@@ -185,11 +205,23 @@ private Response cacheWritingResponse(final CacheRequest cacheRequest, Response
             cacheRequestClosed = true;
             cacheBody.close(); // The cache response is complete!
           }
+
+          if (diskCacheListener != null)
+            diskCacheListener.onComplete(cacheUrl);
           return -1;
         }
 
         sink.copyTo(cacheBody.buffer(), sink.size() - bytesRead, bytesRead);
         cacheBody.emitCompleteSegments();
+
+        cachedByteCount += bytesRead;
+
+        if (diskCacheListener != null) {
+          diskCacheListener.onProgress(cacheUrl, responseBodyLength, cachedByteCount);
+          if (cachedByteCount >= responseBodyLength) {
+            diskCacheListener.onComplete(cacheUrl);
+          }
+        }
         return bytesRead;
       }
 
