diff --git a/CONTRIBUTING.md b/.github/CONTRIBUTING.md
similarity index 100%
rename from CONTRIBUTING.md
rename to .github/CONTRIBUTING.md
diff --git a/.github/ISSUE_TEMPLATE.md b/.github/ISSUE_TEMPLATE.md
new file mode 100644
index 0000000000..e65d371715
--- /dev/null
+++ b/.github/ISSUE_TEMPLATE.md
@@ -0,0 +1,12 @@
+What kind of issue is this?
+
+ - [ ] Question. This issue tracker is not the place for questions. If you want to ask how to do
+       something, or to understand why something isn't working the way you expect it to, use Stack
+       Overflow. https://stackoverflow.com/questions/tagged/okhttp
+
+ - [ ] Bug report. If you’ve found a bug, spend the time to write a failing test. Bugs with tests
+       get fixed. Here’s an example: https://gist.github.com/swankjesse/981fcae102f513eb13ed
+
+ - [ ] Feature Request. Start by telling us what problem you’re trying to solve. Often a solution
+       already exists! Don’t send pull requests to implement new features without first getting our
+       support. Sometimes we leave features out on purpose to keep the project small.
diff --git a/.travis.yml b/.travis.yml
index ed135a7902..1835d337fb 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -24,3 +24,8 @@ sudo: false
 cache:
   directories:
     - $HOME/.m2
+
+addons:
+  apt:
+    packages:
+      - oracle-java8-installer
diff --git a/BUG-BOUNTY.md b/BUG-BOUNTY.md
new file mode 100644
index 0000000000..b2c35b2da0
--- /dev/null
+++ b/BUG-BOUNTY.md
@@ -0,0 +1,10 @@
+Serious about security
+======================
+
+Square recognizes the important contributions the security research community
+can make. We therefore encourage reporting security issues with the code
+contained in this repository.
+
+If you believe you have discovered a security vulnerability, please follow the
+guidelines at https://hackerone.com/square-open-source
+
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 820c4fc534..44e754fe9f 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,6 +1,523 @@
 Change Log
 ==========
 
+## Version 3.3.1
+
+_2016-05-28_
+
+ *  Fix: The plaintext check in HttpLoggingInterceptor incorrectly classified
+    newline characters as control characters. This is fixed.
+ *  Fix: Don't crash reading non-ASCII characters in HTTP/2 headers or in cached
+    HTTP headers.
+ *  Fix: Retain the response body when an attempt to open a web socket returns a
+    non-101 response code.
+
+
+## Version 3.3.0
+
+_2016-05-24_
+
+ *  New: `Response.sentRequestAtMillis()` and `receivedResponseAtMillis()`
+    methods track the system's local time when network calls are made. These
+    replace the `OkHttp-Sent-Millis` and `OkHttp-Received-Millis` headers that were
+    present in earlier versions of OkHttp.
+ *  New: Accept user-provided trust managers in `OkHttpClient.Builder`. This
+    allows OkHttp to satisfy its TLS requirements directly. Otherwise OkHttp
+    will use reflection to extract the `TrustManager` from the
+    `SSLSocketFactory`.
+ *  New: Support prerelease Java 9. This gets ALPN from the platform rather than
+    relying on the alpn-boot bootclasspath override.
+ *  New: `HttpLoggingInterceptor` now logs connection failures.
+ *  New: Upgrade to Okio 1.8.0.
+
+     ```xml
+     <dependency>
+       <groupId>com.squareup.okio</groupId>
+       <artifactId>okio</artifactId>
+       <version>1.8.0</version>
+     </dependency>
+     ```
+
+ *  Fix: Gracefully recover from a failure to rebuild the cache journal.
+ *  Fix: Don't corrupt cache entries when a cache entry is evicted while it is
+    being updated.
+ *  Fix: Make logging more consistent throughout OkHttp.
+ *  Fix: Log plaintext bodies only. This uses simple heuristics to differentiate
+    text from other data.
+ *  Fix: Recover from `REFUSED_STREAM` errors in HTTP/2. This should improve
+    interoperability with Nginx 1.10.0, which [refuses][nginx_959] streams
+    created before HTTP/2 settings have been acknowledged.
+ *  Fix: Improve recovery from failed routes.
+ *  Fix: Accommodate tunneling proxies that close the connection after an auth
+    challenge.
+ *  Fix: Use the proxy authenticator when authenticating HTTP proxies. This
+    regression was introduced in OkHttp 3.0.
+ *  Fix: Fail fast if network interceptors transform the response body such that
+    closing it doesn't also close the underlying stream. We had a bug where
+    OkHttp would attempt to reuse a connection but couldn't because it was still
+    held by a prior request.
+ *  Fix: Ensure network interceptors always have access to the underlying
+    connection.
+ *  Fix: Use `X509TrustManagerExtensions` on Android 17+.
+ *  Fix: Unblock waiting dispatchers on MockWebServer shutdown.
+
+
+## Version 3.2.0
+
+_2016-02-25_
+
+ *  Fix: Change the certificate pinner to always build full chains. This
+    prevents a potential crash when using certificate pinning with the Google
+    Play Services security provider.
+ *  Fix: Make IPv6 request lines consistent with Firefox and Chrome.
+ *  Fix: Recover gracefully when trimming the response cache fails.
+ *  New: Add multiple path segments using a single string in `HttpUrl.Builder`.
+ *  New: Support SHA-256 pins in certificate pinner.
+
+
+## Version 3.1.2
+
+_2016-02-10_
+
+ *  Fix: Don’t crash when finding the trust manager on Robolectric. We attempted
+    to detect the host platform and got confused because Robolectric looks like
+    Android but isn’t!
+ *  Fix: Change `CertificatePinner` to skip sanitizing the certificate chain
+    when no certificates were pinned. This avoids an SSL failure in insecure
+    “trust everyone” configurations, such as when talking to a development
+    HTTPS server that has a self-signed certificate.
+
+
+## Version 3.1.1
+
+_2016-02-07_
+
+ *  Fix: Don't crash when finding the trust manager if the Play Services (GMS)
+    security provider is installed.
+ *  Fix: The previous release introduced a performance regression on Android,
+    caused by looking up CA certificates. This is now fixed.
+
+
+## Version 3.1.0
+
+_2016-02-06_
+
+ *  New: WebSockets now defer some writes. This should improve performance for
+    some applications.
+ *  New: Override `equals()` and `hashCode()` in our new cookie class. This
+    class now defines equality by value rather than by reference.
+ *  New: Handle 408 responses by retrying the request. This allows servers to
+    direct clients to retry rather than failing permanently.
+ *  New: Expose the framed protocol in `Connection`. Previously this would
+    return the application-layer protocol (HTTP/1.1 or HTTP/1.0); now it always
+    returns the wire-layer protocol (HTTP/2, SPDY/3.1, or HTTP/1.1).
+ *  Fix: Permit the trusted CA root to be pinned by `CertificatePinner`.
+ *  Fix: Silently ignore unknown HTTP/2 settings. Previously this would cause
+    the entire connection to fail.
+ *  Fix: Don’t crash on unexpected charsets in the logging interceptor.
+ *  Fix: `OkHttpClient` is now non-final for the benefit of mocking frameworks.
+    Mocking sophisticated classes like `OkHttpClient` is fragile and you
+    shouldn’t do it. But if that’s how you want to live your life we won’t stand
+    in your way!
+
+
+## Version 3.0.1
+
+_2016-01-14_
+
+ *  Rollback OSGi support. This was causing library jars to include more classes
+    than expected, which interfered with Gradle builds.
+
+
+## Version 3.0.0
+
+_2016-01-13_
+
+This release commits to a stable 3.0 API. Read the 3.0.0-RC1 changes for advice
+on upgrading from 2.x to 3.x.
+
+ *  **The `Callback` interface now takes a `Call`**. This makes it easier to
+    check if the call was canceled from within the callback. When migrating
+    async calls to this new API, `Call` is now the first parameter for both
+    `onResponse()` and `onFailure()`.
+ *  Fix: handle multiple cookies in `JavaNetCookieJar` on Android.
+ *  Fix: improve the default HTTP message in MockWebServer responses.
+ *  Fix: don't leak file handles when a conditional GET throws.
+ *  Fix: Use charset specified by the request body content type in OkHttp's
+    logging interceptor.
+ *  Fix: Don't eagerly release pools on cache hits.
+ *  New: Make OkHttp OSGi ready.
+ *  New: Add already-implemented interfaces Closeable and Flushable to the cache.
+
+## Version 3.0.0-RC1
+
+_2016-01-02_
+
+OkHttp 3 is a major release focused on API simplicity and consistency. The API
+changes are numerous but most are cosmetic. Applications should be able to
+upgrade from the 2.x API to the 3.x API mechanically and without risk.
+
+Because the release includes breaking API changes, we're changing the project's
+package name from `com.squareup.okhttp` to `okhttp3`. This should make it
+possible for large applications to migrate incrementally. The Maven group ID
+is now `com.squareup.okhttp3`. For an explanation of this strategy, see Jake
+Wharton's post, [Java Interoperability Policy for Major Version
+Updates][major_versions].
+
+This release obsoletes OkHttp 2.x, and all code that uses OkHttp's
+`com.squareup.okhttp` package should upgrade to the `okhttp3` package. Libraries
+that depend on OkHttp should upgrade quickly to prevent applications from being
+stuck on the old version.
+
+ *  **There is no longer a global singleton connection pool.** In OkHttp 2.x,
+    all `OkHttpClient` instances shared a common connection pool by default.
+    In OkHttp 3.x, each new `OkHttpClient` gets its own private connection pool.
+    Applications should avoid creating many connection pools as doing so
+    prevents connection reuse. Each connection pool holds its own set of
+    connections alive so applications that have many pools also risk exhausting
+    memory!
+
+    The best practice in OkHttp 3 is to create a single OkHttpClient instance
+    and share it throughout the application. Requests that needs a customized
+    client should call `OkHttpClient.newBuilder()` on that shared instance.
+    This allows customization without the drawbacks of separate connection
+    pools.
+
+ *  **OkHttpClient is now stateless.** In the 2.x API `OkHttpClient` had getters
+    and setters. Internally each request was forced to make its own complete
+    snapshot of the `OkHttpClient` instance to defend against racy configuration
+    changes. In 3.x, `OkHttpClient` is now stateless and has a builder. Note
+    that this class is not strictly immutable as it has stateful members like
+    the connection pool and cache.
+
+ *  **Get and Set prefixes are now avoided.** With ubiquitous builders
+    throughout OkHttp these accessor prefixes aren't necessary. Previously
+    OkHttp used _get_ and _set_ prefixes sporadically which make the API
+    inconsistent and awkward to explore.
+
+ *  **OkHttpClient now implements the new `Call.Factory` interface.** This
+    interface will make your code easier to test. When you test code that makes
+    HTTP requests, you can use this interface to replace the real `OkHttpClient`
+    with your own mocks or fakes.
+
+    The interface will also let you use OkHttp's API with another HTTP client's
+    implementation. This is useful in sandboxed environments like Google App
+    Engine.
+
+ *  **OkHttp now does cookies.** We've replaced `java.net.CookieHandler` with
+    a new interface, `CookieJar` and added our own `Cookie` model class. This
+    new cookie follows the latest RFC and supports the same cookie attributes
+    as modern web browsers.
+
+ *  **Form and Multipart bodies are now modeled.** We've replaced the opaque
+    `FormEncodingBuilder` with the more powerful `FormBody` and
+    `FormBody.Builder` combo. Similarly we've upgraded `MultipartBuilder` into
+    `MultipartBody`, `MultipartBody.Part`, and `MultipartBody.Builder`.
+
+ *  **The Apache HTTP client and HttpURLConnection APIs are deprecated.** They
+    continue to work as they always have, but we're moving everything to the new
+    OkHttp 3 API. The `okhttp-apache` and `okhttp-urlconnection` modules should
+    be only be used to accelerate a transition to OkHttp's request/response API.
+    These deprecated modules will be dropped in an upcoming OkHttp 3.x release.
+
+ *  **Canceling batches of calls is now the application's responsibility.**
+    The API to cancel calls by tag has been removed and replaced with a more
+    general mechanism. The dispatcher now exposes all in-flight calls via its
+    `runningCalls()` and `queuedCalls()` methods. You can write code that
+    selects calls by tag, host, or whatever, and invokes `Call.cancel()` on the
+    ones that are no longer necessary.
+
+ *  **OkHttp no longer uses the global `java.net.Authenticator` by default.**
+    We've changed our `Authenticator` interface to authenticate web and proxy
+    authentication failures through a single method. An adapter for the old
+    authenticator is available in the `okhttp-urlconnection` module.
+
+ *  Fix: Don't throw `IOException` on `ResponseBody.contentLength()` or `close()`.
+ *  Fix: Never throw converting an `HttpUrl` to a `java.net.URI`. This changes
+    the `uri()` method to handle malformed percent-escapes and characters
+    forbidden by `URI`.
+ *  Fix: When a connect times out, attempt an alternate route. Previously route
+    selection was less efficient when differentiating failures.
+ *  New: `Response.peekBody()` lets you access the response body without
+    consuming it. This may be handy for interceptors!
+ *  New: `HttpUrl.newBuilder()` resolves a link to a builder.
+ *  New: Add the TLS version to the `Handshake`.
+ *  New: Drop `Request.uri()` and `Request#urlString()`. Just use
+    `Request.url().uri()` and `Request.url().toString()`.
+ *  New: Add URL to HTTP response logging.
+ *  New: Make `HttpUrl` the blessed URL method of `Request`.
+
+
+## Version 2.7.5
+
+_2016-02-25_
+
+ *  Fix: Change the certificate pinner to always build full chains. This
+    prevents a potential crash when using certificate pinning with the Google
+    Play Services security provider.
+
+
+## Version 2.7.4
+
+_2016-02-07_
+
+ *  Fix: Don't crash when finding the trust manager if the Play Services (GMS)
+    security provider is installed.
+ *  Fix: The previous release introduced a performance regression on Android,
+    caused by looking up CA certificates. This is now fixed.
+
+
+## Version 2.7.3
+
+_2016-02-06_
+
+ *  Fix: Permit the trusted CA root to be pinned by `CertificatePinner`.
+
+
+## Version 2.7.2
+
+_2016-01-07_
+
+ *  Fix: Don't eagerly release stream allocations on cache hits. We might still
+    need them to handle redirects.
+
+
+## Version 2.7.1
+
+_2016-01-01_
+
+ *  Fix: Don't do a health check on newly-created connections. This is
+    unnecessary work that could put the client in an inconsistent state if the
+    health check fails.
+
+
+## Version 2.7.0
+
+_2015-12-13_
+
+ *  **Rewritten connection management.** Previously OkHttp's connection pool
+    managed both idle and active connections for HTTP/2, but only idle
+    connections for HTTP/1.x. With this update the connection pool manages both
+    idle and active connections for everything. OkHttp now detects and warns on
+    connections that were allocated but never released, and will enforce HTTP/2
+    stream limits. This update also fixes `Call.cancel()` to not do I/O on the
+    calling thread.
+ *  Fix: Don't log gzipped data in the logging interceptor.
+ *  Fix: Don't resolve DNS addresses when connecting through a SOCKS proxy.
+ *  Fix: Drop the synthetic `OkHttp-Selected-Protocol` response header.
+ *  Fix: Support 204 and 205 'No Content' replies in the logging interceptor.
+ *  New: Add `Call.isExecuted()`.
+
+
+## Version 2.6.0
+
+_2015-11-22_
+
+ *  **New Logging Interceptor.** The `logging-interceptor` subproject offers
+    simple request and response logging. It may be configured to log headers and
+    bodies for debugging. It requires this Maven dependency:
+
+     ```xml
+     <dependency>
+       <groupId>com.squareup.okhttp</groupId>
+       <artifactId>logging-interceptor</artifactId>
+       <version>2.6.0</version>
+     </dependency>
+     ```
+
+    Configure basic logging like this:
+
+    ```java
+    HttpLoggingInterceptor loggingInterceptor = new HttpLoggingInterceptor();
+    loggingInterceptor.setLevel(HttpLoggingInterceptor.Level.BASIC);
+    client.networkInterceptors().add(loggingInterceptor);
+    ```
+
+    **Warning:** Avoid `Level.HEADERS` and `Level.BODY` in production because
+    they could leak passwords and other authentication credentials to insecure
+    logs.
+
+ *  **WebSocket API now uses `RequestBody` and `ResponseBody` for messages.**
+    This is a backwards-incompatible API change.
+
+ *  **The DNS service is now pluggable.** In some situations this may be useful
+    to manually prioritize specific IP addresses.
+
+ *  Fix: Don't throw when converting an `HttpUrl` to a `java.net.URI`.
+    Previously URLs with special characters like `|` and `[` would break when
+    subjected to URI’s overly-strict validation.
+ *  Fix: Don't re-encode `+` as `%20` in encoded URL query strings. OkHttp
+    prefers `%20` when doing its own encoding, but will retain `+` when that is
+    provided.
+ *  Fix: Enforce that callers call `WebSocket.close()` on IO errors. Error
+    handling in WebSockets is significantly improved.
+ *  Fix: Don't use SPDY/3 style header concatenation for HTTP/2 request headers.
+    This could have corrupted requests where multiple headers had the same name,
+    as in cookies.
+ *  Fix: Reject bad characters in the URL hostname. Previously characters like
+    `\0` would cause a late crash when building the request.
+ *  Fix: Allow interceptors to change the request method.
+ *  Fix: Don’t use the request's `User-Agent` or `Proxy-Authorization` when
+    connecting to an HTTPS server via an HTTP tunnel. The `Proxy-Authorization`
+    header was being leaked to the origin server.
+ *  Fix: Digits may be used in a URL scheme.
+ *  Fix: Improve connection timeout recovery.
+ *  Fix: Recover from `getsockname` crashes impacting Android releases prior to
+    4.2.2.
+ *  Fix: Drop partial support for HTTP/1.0. Previously OkHttp would send
+    `HTTP/1.0` on connections after seeing a response with `HTTP/1.0`. The fixed
+    behavior is consistent with Firefox and Chrome.
+ *  Fix: Allow a body in `OPTIONS` requests.
+ *  Fix: Don't percent-encode non-ASCII characters in URL fragments.
+ *  Fix: Handle null fragments.
+ *  Fix: Don’t crash on interceptors that throw `IOException` before a
+    connection is attempted.
+ *  New: Support [WebDAV][webdav] HTTP methods.
+ *  New: Buffer WebSocket frames for better performance.
+ *  New: Drop support for `TLS_DHE_DSS_WITH_AES_128_CBC_SHA`, our only remaining
+    DSS cipher suite. This is consistent with Firefox and Chrome which have also
+    dropped these cipher suite.
+
+## Version 2.5.0
+
+_2015-08-25_
+
+ *  **Timeouts now default to 10 seconds.** Previously we defaulted to never
+    timing out, and that was a lousy policy. If establishing a connection,
+    reading the next byte from a connection, or writing the next byte to a
+    connection takes more than 10 seconds to complete, you’ll need to adjust
+    the timeouts manually.
+
+ *  **OkHttp now rejects request headers that contain invalid characters.** This
+    includes potential security problems (newline characters) as well as simple
+    non-ASCII characters (including international characters and emoji).
+
+ *  **Call canceling is more reliable.**  We had a bug where a socket being
+     connected wasn't being closed when the application used `Call.cancel()`.
+
+ *  **Changing a HttpUrl’s scheme now tracks the default port.** We had a bug
+    where changing a URL from `http` to `https` would leave it on port 80.
+
+ *  **Okio has been updated to 1.6.0.**
+     ```xml
+     <dependency>
+       <groupId>com.squareup.okio</groupId>
+       <artifactId>okio</artifactId>
+       <version>1.6.0</version>
+     </dependency>
+     ```
+
+ *  New: `Cache.initialize()`. Call this on a background thread to eagerly
+    initialize the response cache.
+ *  New: Fold `MockWebServerRule` into `MockWebServer`. This makes it easier to
+    write JUnit tests with `MockWebServer`. The `MockWebServer` library now
+    depends on JUnit, though it continues to work with all testing frameworks.
+ *  Fix: `FormEncodingBuilder` is now consistent with browsers in which
+    characters it escapes. Previously we weren’t percent-encoding commas,
+    parens, and other characters.
+ *  Fix: Relax `FormEncodingBuilder` to support building empty forms.
+ *  Fix: Timeouts throw `SocketTimeoutException`, not `InterruptedIOException`.
+ *  Fix: Change `MockWebServer` to use the same logic as OkHttp when determining
+    whether an HTTP request permits a body.
+ *  Fix: `HttpUrl` now uses the canonical form for IPv6 addresses.
+ *  Fix: Use `HttpUrl` internally.
+ *  Fix: Recover from Android 4.2.2 EBADF crashes.
+ *  Fix: Don't crash with an `IllegalStateException` if an HTTP/2 or SPDY
+    write fails, leaving the connection in an inconsistent state.
+ *  Fix: Make sure the default user agent is ASCII.
+
+
+## Version 2.4.0
+
+_2015-05-22_
+
+ *  **Forbid response bodies on HTTP 204 and 205 responses.** Webservers that
+    return such malformed responses will now trigger a `ProtocolException` in
+    the client.
+
+ *  **WebSocketListener has incompatible changes.** The `onOpen()` method is now
+    called on the reader thread, so implementations must return before further
+    websocket messages will be delivered. The `onFailure()` method now includes
+    an HTTP response if one was returned.
+
+## Version 2.4.0-RC1
+
+_2015-05-16_
+
+ *  **New HttpUrl API.** It's like `java.net.URL` but good. Note that
+    `Request.Builder.url()` now throws `IllegalArgumentException` on malformed
+    URLs. (Previous releases would throw a `MalformedURLException` when calling
+    a malformed URL.)
+
+ *  **We've improved connect failure recovery.** We now differentiate between
+    setup, connecting, and connected and implement appropriate recovery rules
+    for each. This changes `Address` to no longer use `ConnectionSpec`. (This is
+    an incompatible API change).
+
+ *  **`FormEncodingBuilder` now uses `%20` instead of `+` for encoded spaces.**
+    Both are permitted-by-spec, but `%20` requires fewer special cases.
+
+ *  **Okio has been updated to 1.4.0.**
+     ```xml
+     <dependency>
+       <groupId>com.squareup.okio</groupId>
+       <artifactId>okio</artifactId>
+       <version>1.4.0</version>
+     </dependency>
+     ```
+
+ *  **`Request.Builder` no longer accepts null if a request body is required.**
+    Passing null will now fail for request methods that require a body. Instead
+    use an empty body such as this one:
+
+    ```java
+        RequestBody.create(null, new byte[0]);
+    ```
+
+ * **`CertificatePinner` now supports wildcard hostnames.** As always with
+   certificate pinning, you must be very careful to avoid [bricking][brick]
+   your app. You'll need to pin both the top-level domain and the `*.` domain
+   for full coverage.
+
+    ```java
+     client.setCertificatePinner(new CertificatePinner.Builder()
+         .add("publicobject.com",   "sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw=")
+         .add("*.publicobject.com", "sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw=")
+         .add("publicobject.com",   "sha1/SXxoaOSEzPC6BgGmxAt/EAcsajw=")
+         .add("*.publicobject.com", "sha1/SXxoaOSEzPC6BgGmxAt/EAcsajw=")
+         .add("publicobject.com",   "sha1/blhOM3W9V/bVQhsWAcLYwPU6n24=")
+         .add("*.publicobject.com", "sha1/blhOM3W9V/bVQhsWAcLYwPU6n24=")
+         .add("publicobject.com",   "sha1/T5x9IXmcrQ7YuQxXnxoCmeeQ84c=")
+         .add("*.publicobject.com", "sha1/T5x9IXmcrQ7YuQxXnxoCmeeQ84c=")
+         .build());
+    ```
+
+ *  **Interceptors lists are now deep-copied by `OkHttpClient.clone()`.**
+    Previously clones shared interceptors, which made it difficult to customize
+    the interceptors on a request-by-request basis.
+
+ *  New: `Headers.toMultimap()`.
+ *  New: `RequestBody.create(MediaType, ByteString)`.
+ *  New: `ConnectionSpec.isCompatible(SSLSocket)`.
+ *  New: `Dispatcher.getQueuedCallCount()` and
+    `Dispatcher.getRunningCallCount()`. These can be useful in diagnostics.
+ *  Fix: OkHttp no longer shares timeouts between pooled connections. This was
+    causing some applications to crash when connections were reused.
+ *  Fix: `OkApacheClient` now allows an empty `PUT` and `POST`.
+ *  Fix: Websockets no longer rebuffer socket streams.
+ *  Fix: Websockets are now better at handling close frames.
+ *  Fix: Content type matching is now case insensitive.
+ *  Fix: `Vary` headers are not lost with `android.net.http.HttpResponseCache`.
+ *  Fix: HTTP/2 wasn't enforcing stream timeouts when writing the underlying
+    connection. Now it is.
+ *  Fix: Never return null on `call.proceed()`. This was a bug in call
+    cancelation.
+ *  Fix: When a network interceptor mutates a request, that change is now
+    reflected in `Response.networkResponse()`.
+ *  Fix: Badly-behaving caches now throw a checked exception instead of a
+    `NullPointerException`.
+ *  Fix: Better handling of uncaught exceptions in MockWebServer with HTTP/2.
+
 ## Version 2.3.0
 
 _2015-03-16_
@@ -19,7 +536,7 @@ _2015-03-16_
 
  *  **Okio updated to 1.3.0.**
 
-    ```
+    ```xml
     <dependency>
       <groupId>com.squareup.okio</groupId>
       <artifactId>okio</artifactId>
@@ -66,7 +583,7 @@ _2014-12-30_
     This is a source-incompatible change. If you have code that calls
     `RequestBody.contentLength()`, your compile will break with this
     update. The change is binary-compatible, however: code compiled
-    for OkHttp 2.0 and 2.1 will continue work with this update.
+    for OkHttp 2.0 and 2.1 will continue to work with this update.
 
  *  **`COMPATIBLE_TLS` no longer supports SSLv3.** In response to the
     [POODLE](http://googleonlinesecurity.blogspot.ca/2014/10/this-poodle-bites-exploiting-ssl-30.html)
@@ -124,14 +641,14 @@ _2014-11-04_
 
     To disable TLS fallback:
 
-    ```
+    ```java
     client.setConnectionSpecs(Arrays.asList(
         ConnectionSpec.MODERN_TLS, ConnectionSpec.CLEARTEXT));
     ```
 
     To disable cleartext connections, permitting `https` URLs only:
 
-    ```
+    ```java
     client.setConnectionSpecs(Arrays.asList(
         ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS));
     ```
@@ -165,7 +682,7 @@ _2014-11-04_
 
  *  **Okio updated to 1.0.1.**
 
-    ```
+    ```xml
     <dependency>
       <groupId>com.squareup.okio</groupId>
       <artifactId>okio</artifactId>
@@ -245,7 +762,7 @@ advice on upgrading from 1.x to 2.x.
     agent.
  *  New: Guava-like API to create headers:
 
-    ```
+    ```java
     Headers headers = Headers.of(name1, value1, name2, value2, ...).
     ```
 
@@ -288,7 +805,7 @@ in addition to synchronous blocking calls.
     add the `okhttp-urlconnection` module to your project and use the
     `OkUrlFactory` to create new instances of `HttpURLConnection`:
 
-    ```
+    ```java
     // OkHttp 1.x:
     HttpURLConnection connection = client.open(url);
 
@@ -326,7 +843,7 @@ in addition to synchronous blocking calls.
  *  **TunnelRequest is gone.** It specified how to connect to an HTTP proxy.
     OkHttp 2 uses the new `Request` class for this.
 
- *  **Dispatcher** is a new class to manages the queue of asynchronous calls. It
+ *  **Dispatcher** is a new class that manages the queue of asynchronous calls. It
     implements limits on total in-flight calls and in-flight calls per host.
 
 #### Implementation changes
@@ -543,3 +1060,7 @@ _2013-05-06_
 
 Initial release.
 
+ [brick]: https://noncombatant.org/2015/05/01/about-http-public-key-pinning/
+ [webdav]: https://tools.ietf.org/html/rfc4918
+ [major_versions]: http://jakewharton.com/java-interoperability-policy-for-major-version-updates/
+ [nginx_959]: https://trac.nginx.org/nginx/ticket/959
diff --git a/README.md b/README.md
index 0e239589a1..2e40ffd9e9 100644
--- a/README.md
+++ b/README.md
@@ -1,7 +1,7 @@
 OkHttp
 ======
 
-An HTTP & SPDY client for Android and Java applications. For more information see [the website][1] and [the wiki][2].
+An HTTP & HTTP/2 client for Android and Java applications. For more information see [the website][1] and [the wiki][2].
 
 Download
 --------
@@ -9,14 +9,14 @@ Download
 Download [the latest JAR][3] or grab via Maven:
 ```xml
 <dependency>
-  <groupId>com.squareup.okhttp</groupId>
+  <groupId>com.squareup.okhttp3</groupId>
   <artifactId>okhttp</artifactId>
-  <version>2.2.0</version>
+  <version>3.3.1</version>
 </dependency>
 ```
 or Gradle:
 ```groovy
-compile 'com.squareup.okhttp:okhttp:2.2.0'
+compile 'com.squareup.okhttp3:okhttp:3.3.1'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
@@ -27,22 +27,22 @@ MockWebServer
 
 A library for testing HTTP, HTTPS, HTTP/2.0, and SPDY clients.
 
-MockWebServer coupling with OkHttp is essential for proper testing of SPDY and HTTP/2.0 so that code can be shared.
+MockWebServer coupling with OkHttp is essential for proper testing of HTTP/2.0 so that code can be shared.
 
 ### Download
 
 Download [the latest JAR][4] or grab via Maven:
 ```xml
 <dependency>
-  <groupId>com.squareup.okhttp</groupId>
+  <groupId>com.squareup.okhttp3</groupId>
   <artifactId>mockwebserver</artifactId>
-  <version>2.2.0</version>
+  <version>3.3.1</version>
   <scope>test</scope>
 </dependency>
 ```
 or Gradle:
 ```groovy
-testCompile 'com.squareup.okhttp:mockwebserver:2.2.0'
+testCompile 'com.squareup.okhttp3:mockwebserver:3.3.1'
 ```
 
 
@@ -65,6 +65,6 @@ License
 
  [1]: http://square.github.io/okhttp
  [2]: https://github.com/square/okhttp/wiki
- [3]: https://search.maven.org/remote_content?g=com.squareup.okhttp&a=okhttp&v=LATEST
- [4]: https://search.maven.org/remote_content?g=com.squareup.okhttp&a=mockwebserver&v=LATEST
+ [3]: https://search.maven.org/remote_content?g=com.squareup.okhttp3&a=okhttp&v=LATEST
+ [4]: https://search.maven.org/remote_content?g=com.squareup.okhttp3&a=mockwebserver&v=LATEST
  [snap]: https://oss.sonatype.org/content/repositories/snapshots/
diff --git a/benchmarks/README.md b/benchmarks/README.md
index 59f571fc55..ee9be3ff47 100644
--- a/benchmarks/README.md
+++ b/benchmarks/README.md
@@ -4,5 +4,5 @@ OkHttp Benchmarks
 This module allows you to test the performance of HTTP clients.
 
 ### Running
-  1. If you made modifications to `com.squareup.okhttp.benchmarks.Benchmark` run `mvn compile`.
+  1. If you made modifications to `Benchmark` run `mvn compile`.
   2. Run `mvn exec:exec` to launch a new JVM, which will execute the benchmark.
diff --git a/benchmarks/pom.xml b/benchmarks/pom.xml
index 3a5fccd851..f97dc33ef7 100644
--- a/benchmarks/pom.xml
+++ b/benchmarks/pom.xml
@@ -4,9 +4,9 @@
   <modelVersion>4.0.0</modelVersion>
 
   <parent>
-    <groupId>com.squareup.okhttp</groupId>
+    <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>2.4.0-SNAPSHOT</version>
+    <version>3.4.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>benchmarks</artifactId>
@@ -25,17 +25,17 @@
       <version>14.0.1</version>
     </dependency>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>${project.groupId}</groupId>
       <artifactId>okhttp</artifactId>
       <version>${project.version}</version>
     </dependency>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>${project.groupId}</groupId>
       <artifactId>okhttp-urlconnection</artifactId>
       <version>${project.version}</version>
     </dependency>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>${project.groupId}</groupId>
       <artifactId>mockwebserver</artifactId>
       <version>${project.version}</version>
     </dependency>
@@ -89,7 +89,7 @@
             <commandlineArgs>-Xbootclasspath/p:${bootclasspath}</commandlineArgs>
             <argument>-classpath</argument>
             <classpath />
-            <argument>com.squareup.okhttp.benchmarks.Benchmark</argument>
+            <argument>okhttp3.benchmarks.Benchmark</argument>
           </arguments>
         </configuration>
       </plugin>
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/ApacheHttpClient.java b/benchmarks/src/main/java/okhttp3/benchmarks/ApacheHttpClient.java
similarity index 86%
rename from benchmarks/src/main/java/com/squareup/okhttp/benchmarks/ApacheHttpClient.java
rename to benchmarks/src/main/java/okhttp3/benchmarks/ApacheHttpClient.java
index cb8e719111..a5c632fa0f 100644
--- a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/ApacheHttpClient.java
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/ApacheHttpClient.java
@@ -13,15 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.benchmarks;
+package okhttp3.benchmarks;
 
-import com.squareup.okhttp.internal.SslContextBuilder;
 import java.io.IOException;
 import java.io.InputStream;
-import java.net.URL;
 import java.util.concurrent.TimeUnit;
 import java.util.zip.GZIPInputStream;
-import javax.net.ssl.SSLContext;
+import okhttp3.HttpUrl;
+import okhttp3.internal.tls.SslClient;
 import org.apache.http.Header;
 import org.apache.http.HttpResponse;
 import org.apache.http.client.HttpClient;
@@ -42,21 +41,21 @@
     super.prepare(benchmark);
     ClientConnectionManager connectionManager = new PoolingClientConnectionManager();
     if (benchmark.tls) {
-      SSLContext sslContext = SslContextBuilder.localhost();
+      SslClient sslClient = SslClient.localhost();
       connectionManager.getSchemeRegistry().register(
-          new Scheme("https", 443, new SSLSocketFactory(sslContext)));
+          new Scheme("https", 443, new SSLSocketFactory(sslClient.sslContext)));
     }
     client = new DefaultHttpClient(connectionManager);
   }
 
-  @Override public Runnable request(URL url) {
+  @Override public Runnable request(HttpUrl url) {
     return new ApacheHttpClientRequest(url);
   }
 
   class ApacheHttpClientRequest implements Runnable {
-    private final URL url;
+    private final HttpUrl url;
 
-    public ApacheHttpClientRequest(URL url) {
+    public ApacheHttpClientRequest(HttpUrl url) {
       this.url = url;
     }
 
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Benchmark.java b/benchmarks/src/main/java/okhttp3/benchmarks/Benchmark.java
similarity index 86%
rename from benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Benchmark.java
rename to benchmarks/src/main/java/okhttp3/benchmarks/Benchmark.java
index 7f0073cc7d..8d4d04386a 100644
--- a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Benchmark.java
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/Benchmark.java
@@ -13,19 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.benchmarks;
+package okhttp3.benchmarks;
 
 import com.google.caliper.Param;
 import com.google.caliper.model.ArbitraryMeasurement;
 import com.google.caliper.runner.CaliperMain;
-import com.squareup.okhttp.Protocol;
-import com.squareup.okhttp.internal.SslContextBuilder;
-import com.squareup.okhttp.mockwebserver.Dispatcher;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-import com.squareup.okhttp.mockwebserver.RecordedRequest;
 import java.io.IOException;
-import java.net.URL;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
@@ -33,14 +26,20 @@
 import java.util.concurrent.TimeUnit;
 import java.util.logging.Level;
 import java.util.logging.Logger;
-import javax.net.ssl.SSLContext;
+import okhttp3.HttpUrl;
+import okhttp3.Protocol;
+import okhttp3.internal.tls.SslClient;
+import okhttp3.mockwebserver.Dispatcher;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
 import okio.Buffer;
 import okio.GzipSink;
 
 /**
- * This benchmark is fake, but may be useful for certain relative comparisons.
- * It uses a local connection to a MockWebServer to measure how many identical
- * requests per second can be carried over a fixed number of threads.
+ * This benchmark is fake, but may be useful for certain relative comparisons. It uses a local
+ * connection to a MockWebServer to measure how many identical requests per second can be carried
+ * over a fixed number of threads.
  */
 public class Benchmark extends com.google.caliper.Benchmark {
   private static final int NUM_REPORTS = 10;
@@ -48,16 +47,16 @@
 
   private final Random random = new Random(0);
 
-  /** Which client to run.*/
+  /** Which client to run. */
   @Param
   Client client;
 
   /** How many concurrent requests to execute. */
-  @Param({ "1", "10" })
+  @Param({"1", "10"})
   int concurrencyLevel;
 
   /** How many requests to enqueue to await threads to execute them. */
-  @Param({ "10" })
+  @Param({"10"})
   int targetBacklog;
 
   /** True to use TLS. */
@@ -74,11 +73,11 @@
   boolean chunked;
 
   /** The size of the HTTP response body, in uncompressed bytes. */
-  @Param({ "128", "1048576" })
+  @Param({"128", "1048576"})
   int bodyByteCount;
 
   /** How many additional headers were included, beyond the built-in ones. */
-  @Param({ "0", "20" })
+  @Param({"0", "20"})
   int headerCount;
 
   /** Which ALPN protocols are in use. Only useful with TLS. */
@@ -101,7 +100,7 @@ public double run() throws Exception {
     // Prepare the client & server
     httpClient.prepare(this);
     MockWebServer server = startServer();
-    URL url = server.getUrl("/");
+    HttpUrl url = server.url("/");
 
     int requestCount = 0;
     long reportStart = System.nanoTime();
@@ -161,8 +160,8 @@ private MockWebServer startServer() throws IOException {
     MockWebServer server = new MockWebServer();
 
     if (tls) {
-      SSLContext sslContext = SslContextBuilder.localhost();
-      server.useHttps(sslContext.getSocketFactory(), false);
+      SslClient sslClient = SslClient.localhost();
+      server.useHttps(sslClient.socketFactory, false);
       server.setProtocols(protocols);
     }
 
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Client.java b/benchmarks/src/main/java/okhttp3/benchmarks/Client.java
similarity index 96%
rename from benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Client.java
rename to benchmarks/src/main/java/okhttp3/benchmarks/Client.java
index bd777aa359..b7c6b3f3b9 100644
--- a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Client.java
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/Client.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.benchmarks;
+package okhttp3.benchmarks;
 
 enum Client {
   OkHttp {
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/HttpClient.java b/benchmarks/src/main/java/okhttp3/benchmarks/HttpClient.java
similarity index 87%
rename from benchmarks/src/main/java/com/squareup/okhttp/benchmarks/HttpClient.java
rename to benchmarks/src/main/java/okhttp3/benchmarks/HttpClient.java
index 136c5d86d3..0c0986ffeb 100644
--- a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/HttpClient.java
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/HttpClient.java
@@ -13,13 +13,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.benchmarks;
+package okhttp3.benchmarks;
 
-import java.net.URL;
+import okhttp3.HttpUrl;
 
 /** An HTTP client to benchmark. */
 interface HttpClient {
   void prepare(Benchmark benchmark);
-  void enqueue(URL url) throws Exception;
+
+  void enqueue(HttpUrl url) throws Exception;
+
   boolean acceptingJobs();
 }
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/NettyHttpClient.java b/benchmarks/src/main/java/okhttp3/benchmarks/NettyHttpClient.java
similarity index 90%
rename from benchmarks/src/main/java/com/squareup/okhttp/benchmarks/NettyHttpClient.java
rename to benchmarks/src/main/java/okhttp3/benchmarks/NettyHttpClient.java
index 5d8cec5291..01e6f6e257 100644
--- a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/NettyHttpClient.java
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/NettyHttpClient.java
@@ -13,10 +13,8 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.benchmarks;
+package okhttp3.benchmarks;
 
-import com.squareup.okhttp.internal.SslContextBuilder;
-import com.squareup.okhttp.internal.Util;
 import io.netty.bootstrap.Bootstrap;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.PooledByteBufAllocator;
@@ -41,12 +39,12 @@
 import io.netty.handler.codec.http.HttpVersion;
 import io.netty.handler.codec.http.LastHttpContent;
 import io.netty.handler.ssl.SslHandler;
-import java.net.URL;
 import java.util.ArrayDeque;
 import java.util.Deque;
 import java.util.concurrent.TimeUnit;
-import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLEngine;
+import okhttp3.HttpUrl;
+import okhttp3.internal.tls.SslClient;
 
 /** Netty isn't an HTTP client, but it's almost one. */
 class NettyHttpClient implements HttpClient {
@@ -54,7 +52,7 @@
 
   // Guarded by this. Real apps need more capable connection management.
   private final Deque<HttpChannel> freeChannels = new ArrayDeque<>();
-  private final Deque<URL> backlog = new ArrayDeque<>();
+  private final Deque<HttpUrl> backlog = new ArrayDeque<>();
 
   private int totalChannels = 0;
   private int concurrencyLevel;
@@ -70,8 +68,8 @@
         ChannelPipeline pipeline = channel.pipeline();
 
         if (benchmark.tls) {
-          SSLContext sslContext = SslContextBuilder.localhost();
-          SSLEngine engine = sslContext.createSSLEngine();
+          SslClient sslClient = SslClient.localhost();
+          SSLEngine engine = sslClient.sslContext.createSSLEngine();
           engine.setUseClientMode(true);
           pipeline.addLast("ssl", new SslHandler(engine));
         }
@@ -89,7 +87,7 @@
         .handler(channelInitializer);
   }
 
-  @Override public void enqueue(URL url) throws Exception {
+  @Override public void enqueue(HttpUrl url) throws Exception {
     HttpChannel httpChannel = null;
     synchronized (this) {
       if (!freeChannels.isEmpty()) {
@@ -102,7 +100,7 @@
       }
     }
     if (httpChannel == null) {
-      Channel channel = bootstrap.connect(url.getHost(), Util.getEffectivePort(url))
+      Channel channel = bootstrap.connect(url.host(), url.port())
           .sync().channel();
       httpChannel = (HttpChannel) channel.pipeline().last();
     }
@@ -119,7 +117,7 @@ private boolean hasFreeChannels() {
   }
 
   private void release(HttpChannel httpChannel) {
-    URL url;
+    HttpUrl url;
     synchronized (this) {
       url = backlog.pop();
       if (url == null) {
@@ -143,12 +141,12 @@ public HttpChannel(SocketChannel channel) {
       this.channel = channel;
     }
 
-    private void sendRequest(URL url) {
+    private void sendRequest(HttpUrl url) {
       start = System.nanoTime();
       total = 0;
       HttpRequest request = new DefaultFullHttpRequest(
-          HttpVersion.HTTP_1_1, HttpMethod.GET, url.getPath());
-      request.headers().set(HttpHeaders.Names.HOST, url.getHost());
+          HttpVersion.HTTP_1_1, HttpMethod.GET, url.encodedPath());
+      request.headers().set(HttpHeaders.Names.HOST, url.host());
       request.headers().set(HttpHeaders.Names.ACCEPT_ENCODING, HttpHeaders.Values.GZIP);
       channel.writeAndFlush(request);
     }
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttp.java b/benchmarks/src/main/java/okhttp3/benchmarks/OkHttp.java
similarity index 63%
rename from benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttp.java
rename to benchmarks/src/main/java/okhttp3/benchmarks/OkHttp.java
index 3885ed7f53..7c90e5e6b5 100644
--- a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttp.java
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/OkHttp.java
@@ -13,19 +13,19 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.benchmarks;
+package okhttp3.benchmarks;
 
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.OkUrlFactory;
-import com.squareup.okhttp.internal.SslContextBuilder;
 import java.io.IOException;
-import java.net.HttpURLConnection;
-import java.net.URL;
 import java.util.concurrent.TimeUnit;
 import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLSession;
 import javax.net.ssl.SSLSocketFactory;
+import okhttp3.Call;
+import okhttp3.HttpUrl;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.ResponseBody;
+import okhttp3.internal.tls.SslClient;
 
 class OkHttp extends SynchronousHttpClient {
   private static final boolean VERBOSE = false;
@@ -34,38 +34,42 @@
 
   @Override public void prepare(Benchmark benchmark) {
     super.prepare(benchmark);
-    client = new OkHttpClient();
-    client.setProtocols(benchmark.protocols);
+    client = new OkHttpClient.Builder()
+        .protocols(benchmark.protocols)
+        .build();
 
     if (benchmark.tls) {
-      SSLContext sslContext = SslContextBuilder.localhost();
-      SSLSocketFactory socketFactory = sslContext.getSocketFactory();
+      SslClient sslClient = SslClient.localhost();
+      SSLSocketFactory socketFactory = sslClient.socketFactory;
       HostnameVerifier hostnameVerifier = new HostnameVerifier() {
         @Override public boolean verify(String s, SSLSession session) {
           return true;
         }
       };
-      client.setSslSocketFactory(socketFactory);
-      client.setHostnameVerifier(hostnameVerifier);
+      client = new OkHttpClient.Builder()
+          .sslSocketFactory(socketFactory, sslClient.trustManager)
+          .hostnameVerifier(hostnameVerifier)
+          .build();
     }
   }
 
-  @Override public Runnable request(URL url) {
-    return new OkHttpRequest(url);
+  @Override public Runnable request(HttpUrl url) {
+    Call call = client.newCall(new Request.Builder().url(url).build());
+    return new OkHttpRequest(call);
   }
 
   class OkHttpRequest implements Runnable {
-    private final URL url;
+    private final Call call;
 
-    public OkHttpRequest(URL url) {
-      this.url = url;
+    public OkHttpRequest(Call call) {
+      this.call = call;
     }
 
     public void run() {
       long start = System.nanoTime();
       try {
-        HttpURLConnection urlConnection = new OkUrlFactory(client).open(url);
-        long total = readAllAndClose(urlConnection.getInputStream());
+        ResponseBody body = call.execute().body();
+        long total = readAllAndClose(body.byteStream());
         long finish = System.nanoTime();
 
         if (VERBOSE) {
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttpAsync.java b/benchmarks/src/main/java/okhttp3/benchmarks/OkHttpAsync.java
similarity index 68%
rename from benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttpAsync.java
rename to benchmarks/src/main/java/okhttp3/benchmarks/OkHttpAsync.java
index ab7849017c..57cb75cacc 100644
--- a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttpAsync.java
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/OkHttpAsync.java
@@ -13,25 +13,25 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.benchmarks;
+package okhttp3.benchmarks;
 
-import com.squareup.okhttp.Callback;
-import com.squareup.okhttp.Dispatcher;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
-import com.squareup.okhttp.ResponseBody;
-import com.squareup.okhttp.internal.SslContextBuilder;
 import java.io.IOException;
-import java.net.URL;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLSession;
 import javax.net.ssl.SSLSocketFactory;
+import okhttp3.Call;
+import okhttp3.Callback;
+import okhttp3.Dispatcher;
+import okhttp3.HttpUrl;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+import okhttp3.internal.tls.SslClient;
 
 class OkHttpAsync implements HttpClient {
   private static final boolean VERBOSE = false;
@@ -47,29 +47,32 @@
     concurrencyLevel = benchmark.concurrencyLevel;
     targetBacklog = benchmark.targetBacklog;
 
-    client = new OkHttpClient();
-    client.setProtocols(benchmark.protocols);
-    client.setDispatcher(new Dispatcher(new ThreadPoolExecutor(benchmark.concurrencyLevel,
-        benchmark.concurrencyLevel, 60, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>())));
+    client = new OkHttpClient.Builder()
+        .protocols(benchmark.protocols)
+        .dispatcher(new Dispatcher(new ThreadPoolExecutor(benchmark.concurrencyLevel,
+            benchmark.concurrencyLevel, 60, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>())))
+        .build();
 
     if (benchmark.tls) {
-      SSLContext sslContext = SslContextBuilder.localhost();
-      SSLSocketFactory socketFactory = sslContext.getSocketFactory();
+      SslClient sslClient = SslClient.localhost();
+      SSLSocketFactory socketFactory = sslClient.socketFactory;
       HostnameVerifier hostnameVerifier = new HostnameVerifier() {
         @Override public boolean verify(String s, SSLSession session) {
           return true;
         }
       };
-      client.setSslSocketFactory(socketFactory);
-      client.setHostnameVerifier(hostnameVerifier);
+      client = client.newBuilder()
+          .sslSocketFactory(socketFactory, sslClient.trustManager)
+          .hostnameVerifier(hostnameVerifier)
+          .build();
     }
 
     callback = new Callback() {
-      @Override public void onFailure(Request request, IOException e) {
+      @Override public void onFailure(Call call, IOException e) {
         System.out.println("Failed: " + e);
       }
 
-      @Override public void onResponse(Response response) throws IOException {
+      @Override public void onResponse(Call call, Response response) throws IOException {
         ResponseBody body = response.body();
         long total = SynchronousHttpClient.readAllAndClose(body.byteStream());
         long finish = System.nanoTime();
@@ -83,7 +86,7 @@
     };
   }
 
-  @Override public void enqueue(URL url) throws Exception {
+  @Override public void enqueue(HttpUrl url) throws Exception {
     requestsInFlight.incrementAndGet();
     client.newCall(new Request.Builder().tag(System.nanoTime()).url(url).build()).enqueue(callback);
   }
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/SynchronousHttpClient.java b/benchmarks/src/main/java/okhttp3/benchmarks/SynchronousHttpClient.java
similarity index 91%
rename from benchmarks/src/main/java/com/squareup/okhttp/benchmarks/SynchronousHttpClient.java
rename to benchmarks/src/main/java/okhttp3/benchmarks/SynchronousHttpClient.java
index b15eedcd88..4a17b8693d 100644
--- a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/SynchronousHttpClient.java
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/SynchronousHttpClient.java
@@ -13,14 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.benchmarks;
+package okhttp3.benchmarks;
 
 import java.io.IOException;
 import java.io.InputStream;
-import java.net.URL;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
+import okhttp3.HttpUrl;
 
 /** Any HTTP client with a blocking API. */
 abstract class SynchronousHttpClient implements HttpClient {
@@ -33,7 +33,7 @@
         1, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>());
   }
 
-  @Override public void enqueue(URL url) {
+  @Override public void enqueue(HttpUrl url) {
     executor.execute(request(url));
   }
 
@@ -51,5 +51,5 @@ static long readAllAndClose(InputStream in) throws IOException {
     return total;
   }
 
-  abstract Runnable request(URL url);
+  abstract Runnable request(HttpUrl url);
 }
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/UrlConnection.java b/benchmarks/src/main/java/okhttp3/benchmarks/UrlConnection.java
similarity index 84%
rename from benchmarks/src/main/java/com/squareup/okhttp/benchmarks/UrlConnection.java
rename to benchmarks/src/main/java/okhttp3/benchmarks/UrlConnection.java
index 630ec91c54..f75d160835 100644
--- a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/UrlConnection.java
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/UrlConnection.java
@@ -13,20 +13,19 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.benchmarks;
+package okhttp3.benchmarks;
 
-import com.squareup.okhttp.internal.SslContextBuilder;
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.HttpURLConnection;
-import java.net.URL;
 import java.util.concurrent.TimeUnit;
 import java.util.zip.GZIPInputStream;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.HttpsURLConnection;
-import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLSession;
 import javax.net.ssl.SSLSocketFactory;
+import okhttp3.HttpUrl;
+import okhttp3.internal.tls.SslClient;
 
 class UrlConnection extends SynchronousHttpClient {
   private static final boolean VERBOSE = false;
@@ -34,8 +33,8 @@
   @Override public void prepare(Benchmark benchmark) {
     super.prepare(benchmark);
     if (benchmark.tls) {
-      SSLContext sslContext = SslContextBuilder.localhost();
-      SSLSocketFactory socketFactory = sslContext.getSocketFactory();
+      SslClient sslClient = SslClient.localhost();
+      SSLSocketFactory socketFactory = sslClient.socketFactory;
       HostnameVerifier hostnameVerifier = new HostnameVerifier() {
         @Override public boolean verify(String s, SSLSession session) {
           return true;
@@ -46,21 +45,21 @@
     }
   }
 
-  @Override public Runnable request(URL url) {
+  @Override public Runnable request(HttpUrl url) {
     return new UrlConnectionRequest(url);
   }
 
   static class UrlConnectionRequest implements Runnable {
-    private final URL url;
+    private final HttpUrl url;
 
-    public UrlConnectionRequest(URL url) {
+    public UrlConnectionRequest(HttpUrl url) {
       this.url = url;
     }
 
     public void run() {
       long start = System.nanoTime();
       try {
-        HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();
+        HttpURLConnection urlConnection = (HttpURLConnection) url.url().openConnection();
         InputStream in = urlConnection.getInputStream();
         if ("gzip".equals(urlConnection.getHeaderField("Content-Encoding"))) {
           in = new GZIPInputStream(in);
diff --git a/checkstyle.xml b/checkstyle.xml
index f725be3381..d8540c6168 100644
--- a/checkstyle.xml
+++ b/checkstyle.xml
@@ -44,7 +44,7 @@
     <module name="LocalVariableName"/>
     <module name="MemberName"/>
     <module name="MethodName"/>
-    <module name="PackageName"/>
+    <!--<module name="PackageName"/>-->
     <module name="ParameterName"/>
     <module name="StaticVariableName"/>
     <module name="TypeName"/>
@@ -66,7 +66,9 @@
     <module name="LineLength">
       <property name="max" value="100"/>
     </module>
-    <module name="MethodLength"/>
+    <module name="MethodLength">
+      <property name="max" value="200"/>
+    </module>
 
 
     <!-- Checks for whitespace                               -->
@@ -80,7 +82,15 @@
     <module name="ParenPad"/>
     <module name="TypecastParenPad"/>
     <module name="WhitespaceAfter"/>
-    <module name="WhitespaceAround"/>
+    <module name="WhitespaceAround">
+      <property name="tokens"
+          value="ASSIGN, BAND, BAND_ASSIGN, BOR, BOR_ASSIGN, BSR, BSR_ASSIGN, BXOR, BXOR_ASSIGN,
+          COLON, DIV, DIV_ASSIGN, DO_WHILE, EQUAL, GE, GT, LAND, LCURLY, LE, LITERAL_CATCH,
+          LITERAL_DO, LITERAL_ELSE, LITERAL_FINALLY, LITERAL_FOR, LITERAL_IF, LITERAL_RETURN,
+          LITERAL_SWITCH, LITERAL_SYNCHRONIZED, LITERAL_TRY, LITERAL_WHILE, LOR, LT, MINUS,
+          MINUS_ASSIGN, MOD, MOD_ASSIGN, NOT_EQUAL, PLUS, PLUS_ASSIGN, QUESTION, SL, SLIST,
+          SL_ASSIGN, SR, SR_ASSIGN, STAR, STAR_ASSIGN, LITERAL_ASSERT, TYPE_EXTENSION_AND"/>
+    </module>
 
 
     <!-- Modifier Checks                                    -->
diff --git a/deploy_website.sh b/deploy_website.sh
index bbeedc2c36..c9b7f156b0 100755
--- a/deploy_website.sh
+++ b/deploy_website.sh
@@ -3,9 +3,6 @@
 set -ex
 
 REPO="git@github.com:square/okhttp.git"
-GROUP_ID="com.squareup.okhttp"
-ARTIFACT_ID="okhttp"
-
 DIR=temp-clone
 
 # Delete any existing temporary website clone
@@ -20,28 +17,12 @@ cd $DIR
 # Checkout and track the gh-pages branch
 git checkout -t origin/gh-pages
 
-# Delete everything
-rm -rf *
+# Delete everything that isn't versioned (1.x, 2.x)
+ls | grep -E -v '^\d+\.x$' | xargs rm -rf
 
 # Copy website files from real repo
 cp -R ../website/* .
 
-# Download the latest javadoc to directories like 'javadoc' or 'javadoc-urlconnection'.
-for DOCUMENTED_ARTIFACT in okhttp okhttp-urlconnection okhttp-apache
-do
-  curl -L "https://search.maven.org/remote_content?g=$GROUP_ID&a=$DOCUMENTED_ARTIFACT&v=LATEST&c=javadoc" > javadoc.zip
-  JAVADOC_DIR="javadoc${DOCUMENTED_ARTIFACT//okhttp/}"
-  mkdir $JAVADOC_DIR
-  unzip javadoc.zip -d $JAVADOC_DIR
-  rm javadoc.zip
-done
-
-# Download the 1.6.0 javadoc to '1.x/javadoc'.
-curl -L "https://search.maven.org/remote_content?g=$GROUP_ID&a=$ARTIFACT_ID&v=1.6.0&c=javadoc" > javadoc.zip
-mkdir -p 1.x/javadoc
-unzip javadoc.zip -d 1.x/javadoc
-rm javadoc.zip
-
 # Stage all files in git and create a commit
 git add .
 git add -u
diff --git a/mockwebserver/README.md b/mockwebserver/README.md
index c72966826c..06cf0723f5 100644
--- a/mockwebserver/README.md
+++ b/mockwebserver/README.md
@@ -19,7 +19,7 @@ awkward-to-reproduce situations like 500 errors or slow-loading responses.
 ### Example
 
 Use MockWebServer the same way that you use mocking frameworks like
-[Mockito](https://code.google.com/p/mockito/):
+[Mockito](https://github.com/mockito/mockito):
 
 1. Script the mocks.
 2. Run application code.
@@ -42,7 +42,7 @@ public void test() throws Exception {
   server.start();
 
   // Ask the server for its URL. You'll need this to make HTTP requests.
-  URL baseUrl = server.getUrl("/v1/chat/");
+  HttpUrl baseUrl = server.url("/v1/chat/");
 
   // Exercise your application code, which should make those HTTP requests.
   // Responses are returned in the same order that they are enqueued.
@@ -108,7 +108,7 @@ Verify requests by their method, path, HTTP version, body, and headers.
 RecordedRequest request = server.takeRequest();
 assertEquals("POST /v1/chat/send HTTP/1.1", request.getRequestLine());
 assertEquals("application/json; charset=utf-8", request.getHeader("Content-Type"));
-assertEquals("{}", request.getUtf8Body());
+assertEquals("{}", request.getBody().readUtf8());
 ```
 
 #### Dispatcher
@@ -116,21 +116,45 @@ assertEquals("{}", request.getUtf8Body());
 By default MockWebServer uses a queue to specify a series of responses. Use a
 Dispatcher to handle requests using another policy. One natural policy is to
 dispatch on the request path.
+You can, for example, filter the request instead of using `server.enqueue()`.
 
+```java
+final Dispatcher dispatcher = new Dispatcher() {
+
+    @Override
+    public MockResponse dispatch(RecordedRequest request) throws InterruptedException {
+
+        if (request.getPath().equals("/v1/login/auth/")){
+            return new MockResponse().setResponseCode(200);
+        } else if (request.getPath().equals("v1/check/version/")){
+            return new MockResponse().setResponseCode(200).setBody("version=9");
+        } else if (request.getPath().equals("/v1/profile/info")) {
+            return new MockResponse().setResponseCode(200).setBody("{\\\"info\\\":{\\\"name\":\"Lucas Albuquerque\",\"age\":\"21\",\"gender\":\"male\"}}");
+        }
+        return new MockResponse().setResponseCode(404);
+    }
+};
+server.setDispatcher(dispatcher);
+```
 
-### Download
 
-The best way to get MockWebServer is via Maven:
+### Download
 
+Get MockWebServer via Maven:
 ```xml
 <dependency>
-  <groupId>com.squareup.okhttp</groupId>
+  <groupId>com.squareup.okhttp3</groupId>
   <artifactId>mockwebserver</artifactId>
   <version>(insert latest version)</version>
   <scope>test</scope>
 </dependency>
 ```
 
+or via Gradle 
+```groovy
+testCompile 'com.squareup.okhttp3:mockwebserver:(insert latest version)'
+```
+
 ### License
 
     Licensed under the Apache License, Version 2.0 (the "License");
diff --git a/mockwebserver/pom.xml b/mockwebserver/pom.xml
index 86d250338c..555e19ddfc 100644
--- a/mockwebserver/pom.xml
+++ b/mockwebserver/pom.xml
@@ -4,9 +4,9 @@
   <modelVersion>4.0.0</modelVersion>
 
   <parent>
-    <groupId>com.squareup.okhttp</groupId>
+    <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>2.4.0-SNAPSHOT</version>
+    <version>3.4.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>mockwebserver</artifactId>
@@ -14,12 +14,18 @@
 
   <dependencies>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>${project.groupId}</groupId>
       <artifactId>okhttp</artifactId>
       <version>${project.version}</version>
     </dependency>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp-testing-support</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
       <artifactId>okhttp-ws</artifactId>
       <version>${project.version}</version>
     </dependency>
@@ -30,7 +36,6 @@
     <dependency>
       <groupId>junit</groupId>
       <artifactId>junit</artifactId>
-      <optional>true</optional>
     </dependency>
   </dependencies>
 
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/internal/SslContextBuilder.java b/mockwebserver/src/main/java/com/squareup/okhttp/internal/SslContextBuilder.java
deleted file mode 100644
index 546d66036e..0000000000
--- a/mockwebserver/src/main/java/com/squareup/okhttp/internal/SslContextBuilder.java
+++ /dev/null
@@ -1,143 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.squareup.okhttp.internal;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.math.BigInteger;
-import java.net.InetAddress;
-import java.net.UnknownHostException;
-import java.security.GeneralSecurityException;
-import java.security.KeyPair;
-import java.security.KeyPairGenerator;
-import java.security.KeyStore;
-import java.security.SecureRandom;
-import java.security.Security;
-import java.security.cert.Certificate;
-import java.security.cert.X509Certificate;
-import java.util.Date;
-import javax.net.ssl.KeyManagerFactory;
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.TrustManagerFactory;
-import javax.security.auth.x500.X500Principal;
-import org.bouncycastle.jce.provider.BouncyCastleProvider;
-import org.bouncycastle.x509.X509V3CertificateGenerator;
-
-/**
- * Constructs an SSL context for testing. This uses Bouncy Castle to generate a
- * self-signed certificate for a single hostname such as "localhost".
- *
- * <p>The crypto performed by this class is relatively slow. Clients should
- * reuse SSL context instances where possible.
- */
-public final class SslContextBuilder {
-  static {
-    Security.addProvider(new BouncyCastleProvider());
-  }
-
-  private static final long ONE_DAY_MILLIS = 1000L * 60 * 60 * 24;
-  private static SSLContext localhost; // Lazily initialized.
-
-  private final String hostName;
-  private long notBefore = System.currentTimeMillis();
-  private long notAfter = System.currentTimeMillis() + ONE_DAY_MILLIS;
-
-  /**
-   * @param hostName the subject of the host. For TLS this should be the
-   * domain name that the client uses to identify the server.
-   */
-  public SslContextBuilder(String hostName) {
-    this.hostName = hostName;
-  }
-
-  /** Returns a new SSL context for this host's current localhost address. */
-  public static synchronized SSLContext localhost() {
-    if (localhost == null) {
-      try {
-        localhost = new SslContextBuilder(InetAddress.getByName("localhost").getHostName()).build();
-      } catch (GeneralSecurityException e) {
-        throw new RuntimeException(e);
-      } catch (UnknownHostException e) {
-        throw new RuntimeException(e);
-      }
-    }
-    return localhost;
-  }
-
-  public SSLContext build() throws GeneralSecurityException {
-    char[] password = "password".toCharArray();
-
-    // Generate public and private keys and use them to make a self-signed certificate.
-    KeyPair keyPair = generateKeyPair();
-    X509Certificate certificate = selfSignedCertificate(keyPair, "1");
-
-    // Put 'em in a key store.
-    KeyStore keyStore = newEmptyKeyStore(password);
-    Certificate[] certificateChain = { certificate };
-    keyStore.setKeyEntry("private", keyPair.getPrivate(), password, certificateChain);
-    keyStore.setCertificateEntry("cert", certificate);
-
-    // Wrap it up in an SSL context.
-    KeyManagerFactory keyManagerFactory =
-        KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
-    keyManagerFactory.init(keyStore, password);
-    TrustManagerFactory trustManagerFactory =
-        TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
-    trustManagerFactory.init(keyStore);
-    SSLContext sslContext = SSLContext.getInstance("TLS");
-    sslContext.init(keyManagerFactory.getKeyManagers(), trustManagerFactory.getTrustManagers(),
-        new SecureRandom());
-    return sslContext;
-  }
-
-  public KeyPair generateKeyPair() throws GeneralSecurityException {
-    KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA", "BC");
-    keyPairGenerator.initialize(1024, new SecureRandom());
-    return keyPairGenerator.generateKeyPair();
-  }
-
-  /**
-   * Generates a certificate for {@code hostName} containing {@code keyPair}'s
-   * public key, signed by {@code keyPair}'s private key.
-   */
-  @SuppressWarnings("deprecation") // use the old Bouncy Castle APIs to reduce dependencies.
-  public X509Certificate selfSignedCertificate(KeyPair keyPair, String serialNumber)
-      throws GeneralSecurityException {
-    X509V3CertificateGenerator generator = new X509V3CertificateGenerator();
-    X500Principal issuer = new X500Principal("CN=" + hostName);
-    X500Principal subject = new X500Principal("CN=" + hostName);
-    generator.setSerialNumber(new BigInteger(serialNumber));
-    generator.setIssuerDN(issuer);
-    generator.setNotBefore(new Date(notBefore));
-    generator.setNotAfter(new Date(notAfter));
-    generator.setSubjectDN(subject);
-    generator.setPublicKey(keyPair.getPublic());
-    generator.setSignatureAlgorithm("SHA256WithRSAEncryption");
-    return generator.generateX509Certificate(keyPair.getPrivate(), "BC");
-  }
-
-  private KeyStore newEmptyKeyStore(char[] password) throws GeneralSecurityException {
-    try {
-      KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
-      InputStream in = null; // By convention, 'null' creates an empty key store.
-      keyStore.load(in, password);
-      return keyStore;
-    } catch (IOException e) {
-      throw new AssertionError(e);
-    }
-  }
-}
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/SocketPolicy.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/SocketPolicy.java
deleted file mode 100644
index e2d5f28481..0000000000
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/SocketPolicy.java
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
- * Copyright (C) 2011 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.squareup.okhttp.mockwebserver;
-
-/** What should be done with the incoming socket. */
-public enum SocketPolicy {
-
-  /**
-   * Keep the socket open after the response. This is the default HTTP/1.1
-   * behavior.
-   */
-  KEEP_OPEN,
-
-  /**
-   * Close the socket after the response. This is the default HTTP/1.0
-   * behavior.
-   */
-  DISCONNECT_AT_END,
-
-  /**
-   * Wrap the socket with SSL at the completion of this request/response pair.
-   * Used for CONNECT messages to tunnel SSL over an HTTP proxy.
-   */
-  UPGRADE_TO_SSL_AT_END,
-
-  /**
-   * Request immediate close of connection without even reading the request. Use
-   * to simulate buggy SSL servers closing connections in response to
-   * unrecognized TLS extensions.
-   */
-  DISCONNECT_AT_START,
-
-  /**
-   * Close connection after reading the request but before writing the response.
-   * Use this to simulate late connection pool failures.
-   */
-  DISCONNECT_AFTER_REQUEST,
-
-  /** Don't trust the client during the SSL handshake. */
-  FAIL_HANDSHAKE,
-
-  /**
-   * Shutdown the socket input after sending the response. For testing bad
-   * behavior.
-   */
-  SHUTDOWN_INPUT_AT_END,
-
-  /**
-   * Shutdown the socket output after sending the response. For testing bad
-   * behavior.
-   */
-  SHUTDOWN_OUTPUT_AT_END,
-
-  /**
-   * Don't response to the request but keep the socket open. For testing
-   * read response header timeout issue.
-   */
-  NO_RESPONSE
-}
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/rule/MockWebServerRule.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/rule/MockWebServerRule.java
deleted file mode 100644
index 01df8e219a..0000000000
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/rule/MockWebServerRule.java
+++ /dev/null
@@ -1,87 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.mockwebserver.rule;
-
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-import com.squareup.okhttp.mockwebserver.RecordedRequest;
-import java.io.IOException;
-import java.net.URL;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-import org.junit.rules.ExternalResource;
-
-/**
- * Allows you to use {@link MockWebServer} as a JUnit test rule.
- *
- * <p>This rule starts {@link MockWebServer} on an available port before your test runs, and shuts
- * it down after it completes.
- */
-public class MockWebServerRule extends ExternalResource {
-  private static final Logger logger = Logger.getLogger(MockWebServerRule.class.getName());
-
-  private final MockWebServer server = new MockWebServer();
-  private boolean started;
-
-  @Override protected void before() {
-    if (started) return;
-    started = true;
-    try {
-      server.start();
-    } catch (IOException e) {
-      throw new RuntimeException(e);
-    }
-  }
-
-  @Override protected void after() {
-    try {
-      server.shutdown();
-    } catch (IOException e) {
-      logger.log(Level.WARNING, "MockWebServer shutdown failed", e);
-    }
-  }
-
-  public String getHostName() {
-    if (!started) before();
-    return server.getHostName();
-  }
-
-  public int getPort() {
-    if (!started) before();
-    return server.getPort();
-  }
-
-  public int getRequestCount() {
-    return server.getRequestCount();
-  }
-
-  public void enqueue(MockResponse response) {
-    server.enqueue(response);
-  }
-
-  public RecordedRequest takeRequest() throws InterruptedException {
-    return server.takeRequest();
-  }
-
-  public URL getUrl(String path) {
-    return server.getUrl(path);
-  }
-
-  /** For any other functionality, use the {@linkplain MockWebServer} directly. */
-  public MockWebServer get() {
-    return server;
-  }
-}
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/internal/spdy/SpdyServer.java b/mockwebserver/src/main/java/okhttp3/internal/framed/FramedServer.java
similarity index 75%
rename from mockwebserver/src/main/java/com/squareup/okhttp/internal/spdy/SpdyServer.java
rename to mockwebserver/src/main/java/okhttp3/internal/framed/FramedServer.java
index 8e93b470f4..2a555be68e 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/internal/spdy/SpdyServer.java
+++ b/mockwebserver/src/main/java/okhttp3/internal/framed/FramedServer.java
@@ -14,12 +14,8 @@
  * limitations under the License.
  */
 
-package com.squareup.okhttp.internal.spdy;
+package okhttp3.internal.framed;
 
-import com.squareup.okhttp.Protocol;
-import com.squareup.okhttp.internal.Platform;
-import com.squareup.okhttp.internal.SslContextBuilder;
-import com.squareup.okhttp.internal.Util;
 import java.io.File;
 import java.io.IOException;
 import java.net.ProtocolException;
@@ -31,20 +27,27 @@
 import java.util.logging.Logger;
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
+import okhttp3.Protocol;
+import okhttp3.internal.Platform;
+import okhttp3.internal.Util;
+import okhttp3.internal.tls.SslClient;
 import okio.BufferedSink;
 import okio.Okio;
 import okio.Source;
 
+import static okhttp3.internal.Platform.INFO;
+
 /** A basic SPDY/HTTP_2 server that serves the contents of a local directory. */
-public final class SpdyServer implements IncomingStreamHandler {
-  static final Logger logger = Logger.getLogger(SpdyServer.class.getName());
+public final class FramedServer extends FramedConnection.Listener {
+  static final Logger logger = Logger.getLogger(FramedServer.class.getName());
 
-  private final List<Protocol> spdyProtocols = Util.immutableList(Protocol.HTTP_2, Protocol.SPDY_3);
+  private final List<Protocol> framedProtocols =
+      Util.immutableList(Protocol.HTTP_2, Protocol.SPDY_3);
 
   private final File baseDirectory;
   private final SSLSocketFactory sslSocketFactory;
 
-  public SpdyServer(File baseDirectory, SSLSocketFactory sslSocketFactory) {
+  public FramedServer(File baseDirectory, SSLSocketFactory sslSocketFactory) {
     this.baseDirectory = baseDirectory;
     this.sslSocketFactory = sslSocketFactory;
   }
@@ -61,19 +64,20 @@ private void run() throws Exception {
         SSLSocket sslSocket = doSsl(socket);
         String protocolString = Platform.get().getSelectedProtocol(sslSocket);
         Protocol protocol = protocolString != null ? Protocol.get(protocolString) : null;
-        if (protocol == null || !spdyProtocols.contains(protocol)) {
+        if (protocol == null || !framedProtocols.contains(protocol)) {
           throw new ProtocolException("Protocol " + protocol + " unsupported");
         }
-        SpdyConnection spdyConnection = new SpdyConnection.Builder(false, sslSocket)
+        FramedConnection framedConnection = new FramedConnection.Builder(false)
+            .socket(sslSocket)
             .protocol(protocol)
-            .handler(this)
+            .listener(this)
             .build();
-        spdyConnection.sendConnectionPreface();
+        framedConnection.start();
       } catch (IOException e) {
-        logger.log(Level.INFO, "SpdyServer connection failure: " + e);
+        logger.log(Level.INFO, "FramedServer connection failure: " + e);
         Util.closeQuietly(socket);
       } catch (Exception e) {
-        logger.log(Level.WARNING, "SpdyServer unexpected failure", e);
+        logger.log(Level.WARNING, "FramedServer unexpected failure", e);
         Util.closeQuietly(socket);
       }
     }
@@ -83,12 +87,12 @@ private SSLSocket doSsl(Socket socket) throws IOException {
     SSLSocket sslSocket = (SSLSocket) sslSocketFactory.createSocket(
         socket, socket.getInetAddress().getHostAddress(), socket.getPort(), true);
     sslSocket.setUseClientMode(false);
-    Platform.get().configureTlsExtensions(sslSocket, null, spdyProtocols);
+    Platform.get().configureTlsExtensions(sslSocket, null, framedProtocols);
     sslSocket.startHandshake();
     return sslSocket;
   }
 
-  @Override public void receive(final SpdyStream stream) throws IOException {
+  @Override public void onStream(final FramedStream stream) throws IOException {
     try {
       List<Header> requestHeaders = stream.getRequestHeaders();
       String path = null;
@@ -114,11 +118,11 @@ private SSLSocket doSsl(Socket socket) throws IOException {
         send404(stream, path);
       }
     } catch (IOException e) {
-      System.out.println(e.getMessage());
+      Platform.get().log(INFO, "Failure serving FramedStream: " + e.getMessage(), null);
     }
   }
 
-  private void send404(SpdyStream stream, String path) throws IOException {
+  private void send404(FramedStream stream, String path) throws IOException {
     List<Header> responseHeaders = Arrays.asList(
         new Header(":status", "404"),
         new Header(":version", "HTTP/1.1"),
@@ -130,7 +134,7 @@ private void send404(SpdyStream stream, String path) throws IOException {
     out.close();
   }
 
-  private void serveDirectory(SpdyStream stream, File[] files) throws IOException {
+  private void serveDirectory(FramedStream stream, File[] files) throws IOException {
     List<Header> responseHeaders = Arrays.asList(
         new Header(":status", "200"),
         new Header(":version", "HTTP/1.1"),
@@ -145,7 +149,7 @@ private void serveDirectory(SpdyStream stream, File[] files) throws IOException
     out.close();
   }
 
-  private void serveFile(SpdyStream stream, File file) throws IOException {
+  private void serveFile(FramedStream stream, File file) throws IOException {
     List<Header> responseHeaders = Arrays.asList(
         new Header(":status", "200"),
         new Header(":version", "HTTP/1.1"),
@@ -175,12 +179,12 @@ private String contentType(File file) {
 
   public static void main(String... args) throws Exception {
     if (args.length != 1 || args[0].startsWith("-")) {
-      System.out.println("Usage: SpdyServer <base directory>");
+      System.out.println("Usage: FramedServer <base directory>");
       return;
     }
 
-    SpdyServer server = new SpdyServer(new File(args[0]),
-        SslContextBuilder.localhost().getSocketFactory());
+    FramedServer server = new FramedServer(new File(args[0]),
+        SslClient.localhost().sslContext.getSocketFactory());
     server.run();
   }
 }
diff --git a/mockwebserver/src/main/java/okhttp3/internal/tls/HeldCertificate.java b/mockwebserver/src/main/java/okhttp3/internal/tls/HeldCertificate.java
new file mode 100644
index 0000000000..a7fe81f0ef
--- /dev/null
+++ b/mockwebserver/src/main/java/okhttp3/internal/tls/HeldCertificate.java
@@ -0,0 +1,143 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.tls;
+
+import java.math.BigInteger;
+import java.security.GeneralSecurityException;
+import java.security.KeyPair;
+import java.security.KeyPairGenerator;
+import java.security.SecureRandom;
+import java.security.Security;
+import java.security.cert.X509Certificate;
+import java.util.Date;
+import java.util.UUID;
+import javax.security.auth.x500.X500Principal;
+import org.bouncycastle.asn1.x509.BasicConstraints;
+import org.bouncycastle.asn1.x509.X509Extensions;
+import org.bouncycastle.jce.provider.BouncyCastleProvider;
+import org.bouncycastle.x509.X509V3CertificateGenerator;
+
+/**
+ * A certificate and its private key. This can be used on the server side by HTTPS servers, or on
+ * the client side to verify those HTTPS servers. A held certificate can also be used to sign other
+ * held certificates, as done in practice by certificate authorities.
+ */
+public final class HeldCertificate {
+  public final X509Certificate certificate;
+  public final KeyPair keyPair;
+
+  public HeldCertificate(X509Certificate certificate, KeyPair keyPair) {
+    this.certificate = certificate;
+    this.keyPair = keyPair;
+  }
+
+  public static final class Builder {
+    static {
+      Security.addProvider(new BouncyCastleProvider());
+    }
+
+    private final long duration = 1000L * 60 * 60 * 24; // One day.
+    private String hostname;
+    private String serialNumber = "1";
+    private KeyPair keyPair;
+    private HeldCertificate issuedBy;
+    private int maxIntermediateCas;
+
+    public Builder serialNumber(String serialNumber) {
+      this.serialNumber = serialNumber;
+      return this;
+    }
+
+    /**
+     * Set this certificate's name. Typically this is the URL hostname for TLS certificates. This is
+     * the CN (common name) in the certificate. Will be a random string if no value is provided.
+     */
+    public Builder commonName(String hostname) {
+      this.hostname = hostname;
+      return this;
+    }
+
+    public Builder keyPair(KeyPair keyPair) {
+      this.keyPair = keyPair;
+      return this;
+    }
+
+    /**
+     * Set the certificate that signs this certificate. If unset, a self-signed certificate will be
+     * generated.
+     */
+    public Builder issuedBy(HeldCertificate signedBy) {
+      this.issuedBy = signedBy;
+      return this;
+    }
+
+    /**
+     * Set this certificate to be a certificate authority, with up to {@code maxIntermediateCas}
+     * intermediate certificate authorities beneath it.
+     */
+    public Builder ca(int maxIntermediateCas) {
+      this.maxIntermediateCas = maxIntermediateCas;
+      return this;
+    }
+
+    public HeldCertificate build() throws GeneralSecurityException {
+      // Subject, public & private keys for this certificate.
+      KeyPair heldKeyPair = keyPair != null
+          ? keyPair
+          : generateKeyPair();
+      X500Principal subject = hostname != null
+          ? new X500Principal("CN=" + hostname)
+          : new X500Principal("CN=" + UUID.randomUUID());
+
+      // Subject, public & private keys for this certificate's signer. It may be self signed!
+      KeyPair signedByKeyPair;
+      X500Principal signedByPrincipal;
+      if (issuedBy != null) {
+        signedByKeyPair = issuedBy.keyPair;
+        signedByPrincipal = issuedBy.certificate.getSubjectX500Principal();
+      } else {
+        signedByKeyPair = heldKeyPair;
+        signedByPrincipal = subject;
+      }
+
+      // Generate & sign the certificate.
+      long now = System.currentTimeMillis();
+      X509V3CertificateGenerator generator = new X509V3CertificateGenerator();
+      generator.setSerialNumber(new BigInteger(serialNumber));
+      generator.setIssuerDN(signedByPrincipal);
+      generator.setNotBefore(new Date(now));
+      generator.setNotAfter(new Date(now + duration));
+      generator.setSubjectDN(subject);
+      generator.setPublicKey(heldKeyPair.getPublic());
+      generator.setSignatureAlgorithm("SHA256WithRSAEncryption");
+
+      if (maxIntermediateCas > 0) {
+        generator.addExtension(X509Extensions.BasicConstraints, true,
+            new BasicConstraints(maxIntermediateCas));
+      }
+
+      X509Certificate certificate = generator.generateX509Certificate(
+          signedByKeyPair.getPrivate(), "BC");
+      return new HeldCertificate(certificate, heldKeyPair);
+    }
+
+    public KeyPair generateKeyPair() throws GeneralSecurityException {
+      KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA", "BC");
+      keyPairGenerator.initialize(1024, new SecureRandom());
+      return keyPairGenerator.generateKeyPair();
+    }
+  }
+}
diff --git a/mockwebserver/src/main/java/okhttp3/internal/tls/SslClient.java b/mockwebserver/src/main/java/okhttp3/internal/tls/SslClient.java
new file mode 100644
index 0000000000..7cc061b668
--- /dev/null
+++ b/mockwebserver/src/main/java/okhttp3/internal/tls/SslClient.java
@@ -0,0 +1,163 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.tls;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.security.GeneralSecurityException;
+import java.security.KeyPair;
+import java.security.KeyStore;
+import java.security.SecureRandom;
+import java.security.cert.Certificate;
+import java.security.cert.X509Certificate;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import javax.net.ssl.KeyManagerFactory;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSocketFactory;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.TrustManagerFactory;
+import javax.net.ssl.X509TrustManager;
+
+/**
+ * Combines an SSL socket factory and trust manager, a pairing enough for OkHttp or MockWebServer to
+ * create a secure connection.
+ */
+public final class SslClient {
+  private static SslClient localhost; // Lazily initialized.
+
+  public final SSLContext sslContext;
+  public final SSLSocketFactory socketFactory;
+  public final X509TrustManager trustManager;
+
+  private SslClient(SSLContext sslContext, X509TrustManager trustManager) {
+    this.sslContext = sslContext;
+    this.socketFactory = sslContext.getSocketFactory();
+    this.trustManager = trustManager;
+  }
+
+  /** Returns an SSL client for this host's localhost address. */
+  public static synchronized SslClient localhost() {
+    if (localhost != null) return localhost;
+
+    try {
+      // Generate a self-signed cert for the server to serve and the client to trust.
+      HeldCertificate heldCertificate = new HeldCertificate.Builder()
+          .serialNumber("1")
+          .commonName(InetAddress.getByName("localhost").getHostName())
+          .build();
+
+      localhost = new Builder()
+          .certificateChain(heldCertificate.keyPair, heldCertificate.certificate)
+          .addTrustedCertificate(heldCertificate.certificate)
+          .build();
+
+      return localhost;
+    } catch (GeneralSecurityException | UnknownHostException e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  public static class Builder {
+    private final List<X509Certificate> chainCertificates = new ArrayList<>();
+    private final List<X509Certificate> certificates = new ArrayList<>();
+    private KeyPair keyPair;
+
+    /**
+     * Configure the certificate chain to use when serving HTTPS responses. The first certificate is
+     * the server's certificate, further certificates are included in the handshake so the client
+     * can build a trusted path to a CA certificate.
+     */
+    public Builder certificateChain(HeldCertificate serverCert, HeldCertificate... chain) {
+      X509Certificate[] certificates = new X509Certificate[chain.length];
+      for (int i = 0; i < chain.length; i++) {
+        certificates[i] = chain[i].certificate;
+      }
+      return certificateChain(serverCert.keyPair, serverCert.certificate, certificates);
+    }
+
+    public SslClient.Builder certificateChain(KeyPair keyPair, X509Certificate keyCert,
+        X509Certificate... certificates) {
+      this.keyPair = keyPair;
+      this.chainCertificates.add(keyCert);
+      this.chainCertificates.addAll(Arrays.asList(certificates));
+      this.certificates.addAll(Arrays.asList(certificates));
+      return this;
+    }
+
+    /**
+     * Add a certificate authority that this client trusts. Servers that provide certificate chains
+     * signed by these roots (or their intermediates) will be accepted.
+     */
+    public Builder addTrustedCertificate(X509Certificate certificate) {
+      this.certificates.add(certificate);
+      return this;
+    }
+
+    public SslClient build() {
+      try {
+        // Put the certificate in a key store.
+        char[] password = "password".toCharArray();
+        KeyStore keyStore = newEmptyKeyStore(password);
+
+        if (keyPair != null) {
+          Certificate[] certificates = chainCertificates.toArray(
+              new Certificate[chainCertificates.size()]);
+          keyStore.setKeyEntry("private", keyPair.getPrivate(), password, certificates);
+        }
+
+        for (int i = 0; i < certificates.size(); i++) {
+          keyStore.setCertificateEntry("cert_" + i, certificates.get(i));
+        }
+
+        // Wrap it up in an SSL context.
+        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(
+            KeyManagerFactory.getDefaultAlgorithm());
+        keyManagerFactory.init(keyStore, password);
+        TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
+            TrustManagerFactory.getDefaultAlgorithm());
+        trustManagerFactory.init(keyStore);
+        TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
+
+        if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {
+          throw new IllegalStateException("Unexpected default trust managers:"
+              + Arrays.toString(trustManagers));
+        }
+
+        SSLContext sslContext = SSLContext.getInstance("TLS");
+        sslContext.init(keyManagerFactory.getKeyManagers(), trustManagers, new SecureRandom());
+
+        return new SslClient(sslContext, (X509TrustManager) trustManagers[0]);
+      } catch (GeneralSecurityException gse) {
+        throw new AssertionError(gse);
+      }
+    }
+
+    private KeyStore newEmptyKeyStore(char[] password) throws GeneralSecurityException {
+      try {
+        KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
+        InputStream in = null; // By convention, 'null' creates an empty key store.
+        keyStore.load(in, password);
+        return keyStore;
+      } catch (IOException e) {
+        throw new AssertionError(e);
+      }
+    }
+  }
+}
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/Dispatcher.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/Dispatcher.java
similarity index 61%
rename from mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/Dispatcher.java
rename to mockwebserver/src/main/java/okhttp3/mockwebserver/Dispatcher.java
index 4e1e0e70f6..9f4fc9fb66 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/Dispatcher.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/Dispatcher.java
@@ -13,24 +13,31 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.mockwebserver;
+package okhttp3.mockwebserver;
 
 /** Handler for mock server requests. */
 public abstract class Dispatcher {
   /**
-   * Returns a response to satisfy {@code request}. This method may block (for
-   * instance, to wait on a CountdownLatch).
+   * Returns a response to satisfy {@code request}. This method may block (for instance, to wait on
+   * a CountdownLatch).
    */
   public abstract MockResponse dispatch(RecordedRequest request) throws InterruptedException;
 
   /**
-   * Returns an early guess of the next response, used for policy on how an
-   * incoming request should be received. The default implementation returns an
-   * empty response. Mischievous implementations can return other values to test
-   * HTTP edge cases, such as unhappy socket policies or throttled request
-   * bodies.
+   * Returns an early guess of the next response, used for policy on how an incoming request should
+   * be received. The default implementation returns an empty response. Mischievous implementations
+   * can return other values to test HTTP edge cases, such as unhappy socket policies or throttled
+   * request bodies.
    */
   public MockResponse peek() {
     return new MockResponse().setSocketPolicy(SocketPolicy.KEEP_OPEN);
   }
+
+  /**
+   * Release any resources held by this dispatcher. Any requests that are currently being dispatched
+   * should return immediately. Responses returned after shutdown will not be transmitted: their
+   * socket connections have already been closed.
+   */
+  public void shutdown() {
+  }
 }
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockResponse.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.java
similarity index 71%
rename from mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockResponse.java
rename to mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.java
index 09dda5634b..1826aa4fff 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockResponse.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.java
@@ -13,20 +13,22 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.mockwebserver;
+package okhttp3.mockwebserver;
 
-import com.squareup.okhttp.Headers;
-import com.squareup.okhttp.ws.WebSocketListener;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.TimeUnit;
+import okhttp3.Headers;
+import okhttp3.internal.Internal;
+import okhttp3.internal.framed.Settings;
+import okhttp3.ws.WebSocketListener;
 import okio.Buffer;
 
 /** A scripted response to be replayed by the mock web server. */
 public final class MockResponse implements Cloneable {
   private static final String CHUNKED_BODY_HEADER = "Transfer-encoding: chunked";
 
-  private String status = "HTTP/1.1 200 OK";
+  private String status;
   private Headers.Builder headers = new Headers.Builder();
 
   private Buffer body;
@@ -36,15 +38,18 @@
   private TimeUnit throttlePeriodUnit = TimeUnit.SECONDS;
 
   private SocketPolicy socketPolicy = SocketPolicy.KEEP_OPEN;
+  private int http2ErrorCode = -1;
 
   private long bodyDelayAmount = 0;
   private TimeUnit bodyDelayUnit = TimeUnit.MILLISECONDS;
 
   private List<PushPromise> promises = new ArrayList<>();
+  private Settings settings;
   private WebSocketListener webSocketListener;
 
   /** Creates a new mock response with an empty body. */
   public MockResponse() {
+    setResponseCode(200);
     setHeader("Content-Length", 0);
   }
 
@@ -65,7 +70,19 @@ public String getStatus() {
   }
 
   public MockResponse setResponseCode(int code) {
-    return setStatus("HTTP/1.1 " + code + " OK");
+    String reason = "Mock Response";
+    if (code >= 100 && code < 200) {
+      reason = "Informational";
+    } else if (code >= 200 && code < 300) {
+      reason = "OK";
+    } else if (code >= 300 && code < 400) {
+      reason = "Redirection";
+    } else if (code >= 400 && code < 500) {
+      reason = "Client Error";
+    } else if (code >= 500 && code < 600) {
+      reason = "Server Error";
+    }
+    return setStatus("HTTP/1.1 " + code + " " + reason);
   }
 
   public MockResponse setStatus(String status) {
@@ -79,8 +96,8 @@ public Headers getHeaders() {
   }
 
   /**
-   * Removes all HTTP headers including any "Content-Length" and
-   * "Transfer-encoding" headers that were added by default.
+   * Removes all HTTP headers including any "Content-Length" and "Transfer-encoding" headers that
+   * were added by default.
    */
   public MockResponse clearHeaders() {
     headers = new Headers.Builder();
@@ -88,8 +105,8 @@ public MockResponse clearHeaders() {
   }
 
   /**
-   * Adds {@code header} as an HTTP header. For well-formed HTTP {@code header}
-   * should contain a name followed by a colon and a value.
+   * Adds {@code header} as an HTTP header. For well-formed HTTP {@code header} should contain a
+   * name followed by a colon and a value.
    */
   public MockResponse addHeader(String header) {
     headers.add(header);
@@ -97,8 +114,8 @@ public MockResponse addHeader(String header) {
   }
 
   /**
-   * Adds a new header with the name and value. This may be used to add multiple
-   * headers with the same name.
+   * Adds a new header with the name and value. This may be used to add multiple headers with the
+   * same name.
    */
   public MockResponse addHeader(String name, Object value) {
     headers.add(name, String.valueOf(value));
@@ -106,8 +123,17 @@ public MockResponse addHeader(String name, Object value) {
   }
 
   /**
-   * Removes all headers named {@code name}, then adds a new header with the
-   * name and value.
+   * Adds a new header with the name and value. This may be used to add multiple headers with the
+   * same name. Unlike {@link #addHeader(String, Object)} this does not validate the name and
+   * value.
+   */
+  public MockResponse addHeaderLenient(String name, Object value) {
+    Internal.instance.addLenient(headers, name, String.valueOf(value));
+    return this;
+  }
+
+  /**
+   * Removes all headers named {@code name}, then adds a new header with the name and value.
    */
   public MockResponse setHeader(String name, Object value) {
     removeHeader(name);
@@ -143,8 +169,7 @@ public MockResponse setBody(String body) {
   }
 
   /**
-   * Sets the response body to {@code body}, chunked every {@code maxChunkSize}
-   * bytes.
+   * Sets the response body to {@code body}, chunked every {@code maxChunkSize} bytes.
    */
   public MockResponse setChunkedBody(Buffer body, int maxChunkSize) {
     removeHeader("Content-Length");
@@ -165,8 +190,8 @@ public MockResponse setChunkedBody(Buffer body, int maxChunkSize) {
   }
 
   /**
-   * Sets the response body to the UTF-8 encoded bytes of {@code body}, chunked
-   * every {@code maxChunkSize} bytes.
+   * Sets the response body to the UTF-8 encoded bytes of {@code body}, chunked every {@code
+   * maxChunkSize} bytes.
    */
   public MockResponse setChunkedBody(String body, int maxChunkSize) {
     return setChunkedBody(new Buffer().writeUtf8(body), maxChunkSize);
@@ -181,10 +206,23 @@ public MockResponse setSocketPolicy(SocketPolicy socketPolicy) {
     return this;
   }
 
+  public int getHttp2ErrorCode() {
+    return http2ErrorCode;
+  }
+
+  /**
+   * Sets the <a href="https://tools.ietf.org/html/rfc7540#section-7">HTTP/2 error code</a> to be
+   * returned when resetting the stream. This is only valid with {@link
+   * SocketPolicy#RESET_STREAM_AT_START}.
+   */
+  public MockResponse setHttp2ErrorCode(int http2ErrorCode) {
+    this.http2ErrorCode = http2ErrorCode;
+    return this;
+  }
+
   /**
-   * Throttles the response body writer to sleep for the given period after each
-   * series of {@code bytesPerPeriod} bytes are written. Use this to simulate
-   * network behavior.
+   * Throttles the request reader and response writer to sleep for the given period after each
+   * series of {@code bytesPerPeriod} bytes are transferred. Use this to simulate network behavior.
    */
   public MockResponse throttleBody(long bytesPerPeriod, long period, TimeUnit unit) {
     this.throttleBytesPerPeriod = bytesPerPeriod;
@@ -202,8 +240,8 @@ public long getThrottlePeriod(TimeUnit unit) {
   }
 
   /**
-   * Set the delayed time of the response body to {@code delay}. This applies to the
-   * response body only; response headers are not affected.
+   * Set the delayed time of the response body to {@code delay}. This applies to the response body
+   * only; response headers are not affected.
    */
   public MockResponse setBodyDelay(long delay, TimeUnit unit) {
     bodyDelayAmount = delay;
@@ -216,9 +254,8 @@ public long getBodyDelay(TimeUnit unit) {
   }
 
   /**
-   * When {@link MockWebServer#setProtocols(java.util.List) protocols}
-   * include {@linkplain com.squareup.okhttp.Protocol#HTTP_2}, this attaches a
-   * pushed stream to this response.
+   * When {@link MockWebServer#setProtocols(java.util.List) protocols} include {@linkplain
+   * okhttp3.Protocol#HTTP_2}, this attaches a pushed stream to this response.
    */
   public MockResponse withPush(PushPromise promise) {
     this.promises.add(promise);
@@ -230,6 +267,19 @@ public MockResponse withPush(PushPromise promise) {
     return promises;
   }
 
+  /**
+   * When {@linkplain MockWebServer#setProtocols(java.util.List) protocols} include {@linkplain
+   * okhttp3.Protocol#HTTP_2 HTTP/2}, this pushes {@code settings} before writing the response.
+   */
+  public MockResponse withSettings(Settings settings) {
+    this.settings = settings;
+    return this;
+  }
+
+  public Settings getSettings() {
+    return settings;
+  }
+
   /**
    * Attempts to perform a web socket upgrade on the connection. This will overwrite any previously
    * set status or body.
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
similarity index 71%
rename from mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
rename to mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
index 259cf3e36a..89df442534 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
@@ -15,33 +15,17 @@
  * limitations under the License.
  */
 
-package com.squareup.okhttp.mockwebserver;
-
-import com.squareup.okhttp.Headers;
-import com.squareup.okhttp.Protocol;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
-import com.squareup.okhttp.internal.NamedRunnable;
-import com.squareup.okhttp.internal.Platform;
-import com.squareup.okhttp.internal.Util;
-import com.squareup.okhttp.internal.spdy.ErrorCode;
-import com.squareup.okhttp.internal.spdy.Header;
-import com.squareup.okhttp.internal.spdy.IncomingStreamHandler;
-import com.squareup.okhttp.internal.spdy.SpdyConnection;
-import com.squareup.okhttp.internal.spdy.SpdyStream;
-import com.squareup.okhttp.internal.ws.RealWebSocket;
-import com.squareup.okhttp.internal.ws.WebSocketProtocol;
-import com.squareup.okhttp.ws.WebSocketListener;
+package okhttp3.mockwebserver;
+
 import java.io.IOException;
+import java.io.InterruptedIOException;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
-import java.net.MalformedURLException;
 import java.net.ProtocolException;
 import java.net.Proxy;
 import java.net.ServerSocket;
 import java.net.Socket;
 import java.net.SocketException;
-import java.net.URL;
 import java.security.SecureRandom;
 import java.security.cert.CertificateException;
 import java.security.cert.X509Certificate;
@@ -69,6 +53,23 @@
 import javax.net.ssl.SSLSocketFactory;
 import javax.net.ssl.TrustManager;
 import javax.net.ssl.X509TrustManager;
+import okhttp3.Headers;
+import okhttp3.HttpUrl;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.internal.NamedRunnable;
+import okhttp3.internal.Platform;
+import okhttp3.internal.Util;
+import okhttp3.internal.framed.ErrorCode;
+import okhttp3.internal.framed.FramedConnection;
+import okhttp3.internal.framed.FramedStream;
+import okhttp3.internal.framed.Header;
+import okhttp3.internal.framed.Settings;
+import okhttp3.internal.http.HttpMethod;
+import okhttp3.internal.ws.RealWebSocket;
+import okhttp3.internal.ws.WebSocketProtocol;
+import okhttp3.ws.WebSocketListener;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -76,16 +77,28 @@
 import okio.Okio;
 import okio.Sink;
 import okio.Timeout;
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
 
-import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
-import static com.squareup.okhttp.mockwebserver.SocketPolicy.FAIL_HANDSHAKE;
 import static java.util.concurrent.TimeUnit.SECONDS;
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_DURING_REQUEST_BODY;
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_DURING_RESPONSE_BODY;
+import static okhttp3.mockwebserver.SocketPolicy.FAIL_HANDSHAKE;
+import static okhttp3.mockwebserver.SocketPolicy.NO_RESPONSE;
+import static okhttp3.mockwebserver.SocketPolicy.RESET_STREAM_AT_START;
+import static okhttp3.mockwebserver.SocketPolicy.SHUTDOWN_INPUT_AT_END;
+import static okhttp3.mockwebserver.SocketPolicy.SHUTDOWN_OUTPUT_AT_END;
+import static okhttp3.mockwebserver.SocketPolicy.UPGRADE_TO_SSL_AT_END;
 
 /**
- * A scriptable web server. Callers supply canned responses and the server
- * replays them upon request in sequence.
+ * A scriptable web server. Callers supply canned responses and the server replays them upon request
+ * in sequence.
  */
-public final class MockWebServer {
+public final class MockWebServer implements TestRule {
   private static final X509TrustManager UNTRUSTED_TRUST_MANAGER = new X509TrustManager() {
     @Override public void checkClientTrusted(X509Certificate[] chain, String authType)
         throws CertificateException {
@@ -107,8 +120,8 @@
 
   private final Set<Socket> openClientSockets =
       Collections.newSetFromMap(new ConcurrentHashMap<Socket, Boolean>());
-  private final Set<SpdyConnection> openSpdyConnections =
-      Collections.newSetFromMap(new ConcurrentHashMap<SpdyConnection, Boolean>());
+  private final Set<FramedConnection> openFramedConnections =
+      Collections.newSetFromMap(new ConcurrentHashMap<FramedConnection, Boolean>());
   private final AtomicInteger requestCount = new AtomicInteger();
   private long bodyLimit = Long.MAX_VALUE;
   private ServerSocketFactory serverSocketFactory = ServerSocketFactory.getDefault();
@@ -124,79 +137,93 @@
   private List<Protocol> protocols
       = Util.immutableList(Protocol.HTTP_2, Protocol.SPDY_3, Protocol.HTTP_1_1);
 
-  public void setServerSocketFactory(ServerSocketFactory serverSocketFactory) {
-    if (serverSocketFactory == null) throw new IllegalArgumentException("null serverSocketFactory");
-    this.serverSocketFactory = serverSocketFactory;
+  private boolean started;
+
+  private synchronized void maybeStart() {
+    if (started) return;
+    try {
+      start();
+    } catch (IOException e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  @Override public Statement apply(final Statement base, Description description) {
+    return new Statement() {
+      @Override public void evaluate() throws Throwable {
+        maybeStart();
+        try {
+          base.evaluate();
+        } finally {
+          try {
+            shutdown();
+          } catch (IOException e) {
+            logger.log(Level.WARNING, "MockWebServer shutdown failed", e);
+          }
+        }
+      }
+    };
   }
 
   public int getPort() {
-    if (port == -1) throw new IllegalStateException("Call start() before getPort()");
+    maybeStart();
     return port;
   }
 
   public String getHostName() {
-    if (inetSocketAddress == null) {
-      throw new IllegalStateException("Call start() before getHostName()");
-    }
+    maybeStart();
     return inetSocketAddress.getHostName();
   }
 
   public Proxy toProxyAddress() {
-    if (inetSocketAddress == null) {
-      throw new IllegalStateException("Call start() before toProxyAddress()");
-    }
+    maybeStart();
     InetSocketAddress address = new InetSocketAddress(inetSocketAddress.getAddress(), getPort());
     return new Proxy(Proxy.Type.HTTP, address);
   }
 
-  /**
-   * Returns a URL for connecting to this server.
-   * @param path the request path, such as "/".
-   */
-  public URL getUrl(String path) {
-    try {
-      return sslSocketFactory != null
-          ? new URL("https://" + getHostName() + ":" + getPort() + path)
-          : new URL("http://" + getHostName() + ":" + getPort() + path);
-    } catch (MalformedURLException e) {
-      throw new AssertionError(e);
+  public void setServerSocketFactory(ServerSocketFactory serverSocketFactory) {
+    if (executor != null) {
+      throw new IllegalStateException(
+          "setServerSocketFactory() must be called before start()");
     }
+    this.serverSocketFactory = serverSocketFactory;
   }
 
   /**
-   * Returns a cookie domain for this server. This returns the server's
-   * non-loopback host name if it is known. Otherwise this returns ".local" for
-   * this server's loopback name.
+   * Returns a URL for connecting to this server.
+   *
+   * @param path the request path, such as "/".
    */
-  public String getCookieDomain() {
-    String hostName = getHostName();
-    return hostName.contains(".") ? hostName : ".local";
+  public HttpUrl url(String path) {
+    return new HttpUrl.Builder()
+        .scheme(sslSocketFactory != null ? "https" : "http")
+        .host(getHostName())
+        .port(getPort())
+        .build()
+        .resolve(path);
   }
 
   /**
-   * Sets the number of bytes of the POST body to keep in memory to the given
-   * limit.
+   * Sets the number of bytes of the POST body to keep in memory to the given limit.
    */
   public void setBodyLimit(long maxBodyLength) {
     this.bodyLimit = maxBodyLength;
   }
 
   /**
-   * Sets whether ALPN is used on incoming HTTPS connections to
-   * negotiate a protocol like HTTP/1.1 or HTTP/2. Call this method to disable
-   * negotiation and restrict connections to HTTP/1.1.
+   * Sets whether ALPN is used on incoming HTTPS connections to negotiate a protocol like HTTP/1.1
+   * or HTTP/2. Call this method to disable negotiation and restrict connections to HTTP/1.1.
    */
   public void setProtocolNegotiationEnabled(boolean protocolNegotiationEnabled) {
     this.protocolNegotiationEnabled = protocolNegotiationEnabled;
   }
 
   /**
-   * Indicates the protocols supported by ALPN on incoming HTTPS
-   * connections. This list is ignored when
-   * {@link #setProtocolNegotiationEnabled negotiation is disabled}.
+   * Indicates the protocols supported by ALPN on incoming HTTPS connections. This list is ignored
+   * when {@link #setProtocolNegotiationEnabled negotiation is disabled}.
    *
-   * @param protocols the protocols to use, in order of preference. The list
-   *     must contain {@linkplain Protocol#HTTP_1_1}. It must not contain null.
+   * @param protocols the protocols to use, in order of preference. The list must contain
+   * {@linkplain Protocol#HTTP_1_1}. It must not contain null.
    */
   public void setProtocols(List<Protocol> protocols) {
     protocols = Util.immutableList(protocols);
@@ -211,8 +238,8 @@ public void setProtocols(List<Protocol> protocols) {
 
   /**
    * Serve requests with HTTPS rather than otherwise.
-   * @param tunnelProxy true to expect the HTTP CONNECT method before
-   *     negotiating TLS.
+   *
+   * @param tunnelProxy true to expect the HTTP CONNECT method before negotiating TLS.
    */
   public void useHttps(SSLSocketFactory sslSocketFactory, boolean tunnelProxy) {
     this.sslSocketFactory = sslSocketFactory;
@@ -220,9 +247,9 @@ public void useHttps(SSLSocketFactory sslSocketFactory, boolean tunnelProxy) {
   }
 
   /**
-   * Awaits the next HTTP request, removes it, and returns it. Callers should
-   * use this to verify the request was sent as intended. This method will block until the
-   * request is available, possibly forever.
+   * Awaits the next HTTP request, removes it, and returns it. Callers should use this to verify the
+   * request was sent as intended. This method will block until the request is available, possibly
+   * forever.
    *
    * @return the head of the request queue
    */
@@ -231,14 +258,12 @@ public RecordedRequest takeRequest() throws InterruptedException {
   }
 
   /**
-   * Awaits the next HTTP request (waiting up to the
-   * specified wait time if necessary), removes it, and returns it. Callers should
-   * use this to verify the request was sent as intended within the given time.
+   * Awaits the next HTTP request (waiting up to the specified wait time if necessary), removes it,
+   * and returns it. Callers should use this to verify the request was sent as intended within the
+   * given time.
    *
-   * @param timeout how long to wait before giving up, in units of
-  *        {@code unit}
-   * @param unit a {@code TimeUnit} determining how to interpret the
-   *        {@code timeout} parameter
+   * @param timeout how long to wait before giving up, in units of {@code unit}
+   * @param unit a {@code TimeUnit} determining how to interpret the {@code timeout} parameter
    * @return the head of the request queue
    */
   public RecordedRequest takeRequest(long timeout, TimeUnit unit) throws InterruptedException {
@@ -246,36 +271,25 @@ public RecordedRequest takeRequest(long timeout, TimeUnit unit) throws Interrupt
   }
 
   /**
-   * Returns the number of HTTP requests received thus far by this server. This
-   * may exceed the number of HTTP connections when connection reuse is in
-   * practice.
+   * Returns the number of HTTP requests received thus far by this server. This may exceed the
+   * number of HTTP connections when connection reuse is in practice.
    */
   public int getRequestCount() {
     return requestCount.get();
   }
 
   /**
-   * Scripts {@code response} to be returned to a request made in sequence. The
-   * first request is served by the first enqueued response; the second request
-   * by the second enqueued response; and so on.
+   * Scripts {@code response} to be returned to a request made in sequence. The first request is
+   * served by the first enqueued response; the second request by the second enqueued response; and
+   * so on.
    *
-   * @throws ClassCastException if the default dispatcher has been replaced
-   *     with {@link #setDispatcher(Dispatcher)}.
+   * @throws ClassCastException if the default dispatcher has been replaced with {@link
+   * #setDispatcher(Dispatcher)}.
    */
   public void enqueue(MockResponse response) {
     ((QueueDispatcher) dispatcher).enqueueResponse(response.clone());
   }
 
-  /** @deprecated Use {@link #start()}. */
-  public void play() throws IOException {
-    start();
-  }
-
-  /** @deprecated Use {@link #start(int)}. */
-  public void play(int port) throws IOException {
-    start(port);
-  }
-
   /** Equivalent to {@code start(0)}. */
   public void start() throws IOException {
     start(0);
@@ -284,9 +298,8 @@ public void start() throws IOException {
   /**
    * Starts the server on the loopback interface for the given port.
    *
-   * @param port the port to listen to, or 0 for any available port. Automated
-   *     tests should always use port 0 to avoid flakiness when a specific port
-   *     is unavailable.
+   * @param port the port to listen to, or 0 for any available port. Automated tests should always
+   * use port 0 to avoid flakiness when a specific port is unavailable.
    */
   public void start(int port) throws IOException {
     start(InetAddress.getByName("localhost"), port);
@@ -296,10 +309,8 @@ public void start(int port) throws IOException {
    * Starts the server on the given address and port.
    *
    * @param inetAddress the address to create the server socket on
-   *
-   * @param port the port to listen to, or 0 for any available port. Automated
-   *     tests should always use port 0 to avoid flakiness when a specific port
-   *     is unavailable.
+   * @param port the port to listen to, or 0 for any available port. Automated tests should always
+   * use port 0 to avoid flakiness when a specific port is unavailable.
    */
   public void start(InetAddress inetAddress, int port) throws IOException {
     start(new InetSocketAddress(inetAddress, port));
@@ -310,8 +321,10 @@ public void start(InetAddress inetAddress, int port) throws IOException {
    *
    * @param inetSocketAddress the socket address to bind the server on
    */
-  private void start(InetSocketAddress inetSocketAddress) throws IOException {
-    if (executor != null) throw new IllegalStateException("start() already called");
+  private synchronized void start(InetSocketAddress inetSocketAddress) throws IOException {
+    if (started) throw new IllegalStateException("start() already called");
+    started = true;
+
     executor = Executors.newCachedThreadPool(Util.threadFactory("MockWebServer", false));
     this.inetSocketAddress = inetSocketAddress;
     serverSocket = serverSocketFactory.createServerSocket();
@@ -335,10 +348,11 @@ private void start(InetSocketAddress inetSocketAddress) throws IOException {
           Util.closeQuietly(s.next());
           s.remove();
         }
-        for (Iterator<SpdyConnection> s = openSpdyConnections.iterator(); s.hasNext(); ) {
+        for (Iterator<FramedConnection> s = openFramedConnections.iterator(); s.hasNext(); ) {
           Util.closeQuietly(s.next());
           s.remove();
         }
+        dispatcher.shutdown();
         executor.shutdown();
       }
 
@@ -364,7 +378,8 @@ private void acceptConnections() throws Exception {
     });
   }
 
-  public void shutdown() throws IOException {
+  public synchronized void shutdown() throws IOException {
+    if (!started) return;
     if (serverSocket == null) throw new IllegalStateException("shutdown() before start()");
 
     // Cause acceptConnections() to break out.
@@ -431,12 +446,14 @@ public void processConnection() throws Exception {
         }
 
         if (protocol != Protocol.HTTP_1_1) {
-          SpdySocketHandler spdySocketHandler = new SpdySocketHandler(socket, protocol);
-          SpdyConnection spdyConnection =
-              new SpdyConnection.Builder(false, socket).protocol(protocol)
-                  .handler(spdySocketHandler)
-                  .build();
-          openSpdyConnections.add(spdyConnection);
+          FramedSocketHandler framedSocketListener = new FramedSocketHandler(socket, protocol);
+          FramedConnection framedConnection = new FramedConnection.Builder(false)
+              .socket(socket)
+              .protocol(protocol)
+              .listener(framedSocketListener)
+              .build();
+          framedConnection.start();
+          openFramedConnections.add(framedConnection);
           openClientSockets.remove(socket);
           return;
         }
@@ -472,7 +489,7 @@ private void createTunnel() throws IOException, InterruptedException {
           if (!processOneRequest(raw, source, sink)) {
             throw new IllegalStateException("Tunnel without any CONNECT!");
           }
-          if (socketPolicy == SocketPolicy.UPGRADE_TO_SSL_AT_END) return;
+          if (socketPolicy == UPGRADE_TO_SSL_AT_END) return;
         }
       }
 
@@ -489,21 +506,23 @@ private boolean processOneRequest(Socket socket, BufferedSource source, Buffered
         requestQueue.add(request);
 
         MockResponse response = dispatcher.dispatch(request);
-        if (response.getSocketPolicy() == SocketPolicy.DISCONNECT_AFTER_REQUEST) {
+        if (response.getSocketPolicy() == DISCONNECT_AFTER_REQUEST) {
           socket.close();
           return false;
         }
-        if (response.getSocketPolicy() == SocketPolicy.NO_RESPONSE) {
+        if (response.getSocketPolicy() == NO_RESPONSE) {
           // This read should block until the socket is closed. (Because nobody is writing.)
           if (source.exhausted()) return false;
           throw new ProtocolException("unexpected data");
         }
 
+        boolean reuseSocket = true;
         boolean requestWantsWebSockets = "Upgrade".equalsIgnoreCase(request.getHeader("Connection"))
             && "websocket".equalsIgnoreCase(request.getHeader("Upgrade"));
         boolean responseWantsWebSockets = response.getWebSocketListener() != null;
         if (requestWantsWebSockets && responseWantsWebSockets) {
           handleWebSocketUpgrade(socket, source, sink, request, response);
+          reuseSocket = false;
         } else {
           writeHttpResponse(socket, sink, response);
         }
@@ -513,24 +532,25 @@ private boolean processOneRequest(Socket socket, BufferedSource source, Buffered
               + " and responded: " + response);
         }
 
-        if (response.getSocketPolicy() == SocketPolicy.DISCONNECT_AT_END) {
+        // See warnings associated with these socket policies in SocketPolicy.
+        if (response.getSocketPolicy() == DISCONNECT_AT_END) {
           socket.close();
           return false;
-        } else if (response.getSocketPolicy() == SocketPolicy.SHUTDOWN_INPUT_AT_END) {
+        } else if (response.getSocketPolicy() == SHUTDOWN_INPUT_AT_END) {
           socket.shutdownInput();
-        } else if (response.getSocketPolicy() == SocketPolicy.SHUTDOWN_OUTPUT_AT_END) {
+        } else if (response.getSocketPolicy() == SHUTDOWN_OUTPUT_AT_END) {
           socket.shutdownOutput();
         }
 
         sequenceNumber++;
-        return true;
+        return reuseSocket;
       }
     });
   }
 
   private void processHandshakeFailure(Socket raw) throws Exception {
     SSLContext context = SSLContext.getInstance("TLS");
-    context.init(null, new TrustManager[] { UNTRUSTED_TRUST_MANAGER }, new SecureRandom());
+    context.init(null, new TrustManager[] {UNTRUSTED_TRUST_MANAGER}, new SecureRandom());
     SSLSocketFactory sslSocketFactory = context.getSocketFactory();
     SSLSocket socket = (SSLSocket) sslSocketFactory.createSocket(
         raw, raw.getInetAddress().getHostAddress(), raw.getPort(), true);
@@ -544,8 +564,11 @@ private void processHandshakeFailure(Socket raw) throws Exception {
 
   private void dispatchBookkeepingRequest(int sequenceNumber, Socket socket)
       throws InterruptedException {
+    RecordedRequest request = new RecordedRequest(
+        null, null, null, -1, null, sequenceNumber, socket);
     requestCount.incrementAndGet();
-    dispatcher.dispatch(new RecordedRequest(null, null, null, -1, null, sequenceNumber, socket));
+    requestQueue.add(request);
+    dispatcher.dispatch(request);
   }
 
   /** @param sequenceNumber the index of this request on this connection. */
@@ -592,10 +615,10 @@ private RecordedRequest readRequest(Socket socket, BufferedSource source, Buffer
     boolean hasBody = false;
     TruncatingBuffer requestBody = new TruncatingBuffer(bodyLimit);
     List<Integer> chunkSizes = new ArrayList<>();
-    MockResponse throttlePolicy = dispatcher.peek();
+    MockResponse policy = dispatcher.peek();
     if (contentLength != -1) {
       hasBody = contentLength > 0;
-      throttledTransfer(throttlePolicy, socket, source, Okio.buffer(requestBody), contentLength);
+      throttledTransfer(policy, socket, source, Okio.buffer(requestBody), contentLength, true);
     } else if (chunked) {
       hasBody = true;
       while (true) {
@@ -605,24 +628,14 @@ private RecordedRequest readRequest(Socket socket, BufferedSource source, Buffer
           break;
         }
         chunkSizes.add(chunkSize);
-        throttledTransfer(throttlePolicy, socket, source, Okio.buffer(requestBody), chunkSize);
+        throttledTransfer(policy, socket, source, Okio.buffer(requestBody), chunkSize, true);
         readEmptyLine(source);
       }
     }
 
-    if (request.startsWith("OPTIONS ")
-        || request.startsWith("GET ")
-        || request.startsWith("HEAD ")
-        || request.startsWith("TRACE ")
-        || request.startsWith("CONNECT ")) {
-      if (hasBody) {
-        throw new IllegalArgumentException("Request must not have a body: " + request);
-      }
-    } else if (!request.startsWith("POST ")
-        && !request.startsWith("PUT ")
-        && !request.startsWith("PATCH ")
-        && !request.startsWith("DELETE ")) { // Permitted as spec is ambiguous.
-      throw new UnsupportedOperationException("Unexpected method: " + request);
+    String method = request.substring(0, request.indexOf(' '));
+    if (hasBody && !HttpMethod.permitsRequestBody(method)) {
+      throw new IllegalArgumentException("Request must not have a body: " + request);
     }
 
     return new RecordedRequest(request, headers.build(), chunkSizes, requestBody.receivedByteCount,
@@ -642,20 +655,22 @@ private void handleWebSocketUpgrade(Socket socket, BufferedSource source, Buffer
 
     ThreadPoolExecutor replyExecutor =
         new ThreadPoolExecutor(1, 1, 1, SECONDS, new LinkedBlockingDeque<Runnable>(),
-            Util.threadFactory(String.format("MockWebServer %s WebSocket", request.getPath()),
+            Util.threadFactory(Util.format("MockWebServer %s WebSocket", request.getPath()),
                 true));
     replyExecutor.allowCoreThreadTimeOut(true);
     final RealWebSocket webSocket =
         new RealWebSocket(false /* is server */, source, sink, new SecureRandom(), replyExecutor,
             listener, request.getPath()) {
-          @Override protected void closeConnection() throws IOException {
+          @Override protected void close() throws IOException {
             connectionClose.countDown();
           }
         };
 
     // Adapt the request and response into our Request and Response domain model.
+    String scheme = request.getTlsVersion() != null ? "https" : "http";
+    String authority = request.getHeader("Host"); // Has host and port.
     final Request fancyRequest = new Request.Builder()
-        .get().url(request.getPath())
+        .url(scheme + "://" + authority + "/")
         .headers(request.getHeaders())
         .build();
     final Response fancyResponse = new Response.Builder()
@@ -666,19 +681,8 @@ private void handleWebSocketUpgrade(Socket socket, BufferedSource source, Buffer
         .protocol(Protocol.HTTP_1_1)
         .build();
 
-    // The callback might act synchronously. Give it its own thread.
-    new Thread(new Runnable() {
-      @Override public void run() {
-        try {
-          listener.onOpen(webSocket, fancyRequest, fancyResponse);
-        } catch (IOException e) {
-          // TODO try to write close frame?
-          connectionClose.countDown();
-        }
-      }
-    }, "MockWebServer WebSocket Writer " + request.getPath()).start();
+    listener.onOpen(webSocket, fancyResponse);
 
-    // Use this thread to continuously read messages.
     while (webSocket.readMessage()) {
     }
 
@@ -689,6 +693,7 @@ private void handleWebSocketUpgrade(Socket socket, BufferedSource source, Buffer
       throw new RuntimeException(e);
     }
 
+    replyExecutor.shutdown();
     Util.closeQuietly(sink);
     Util.closeQuietly(source);
   }
@@ -711,7 +716,7 @@ private void writeHttpResponse(Socket socket, BufferedSink sink, MockResponse re
     Buffer body = response.getBody();
     if (body == null) return;
     sleepIfDelayed(response);
-    throttledTransfer(response, socket, body, sink, Long.MAX_VALUE);
+    throttledTransfer(response, socket, body, sink, body.size(), false);
   }
 
   private void sleepIfDelayed(MockResponse response) {
@@ -726,21 +731,32 @@ private void sleepIfDelayed(MockResponse response) {
   }
 
   /**
-   * Transfer bytes from {@code source} to {@code sink} until either {@code byteCount}
-   * bytes have been transferred or {@code source} is exhausted. The transfer is
-   * throttled according to {@code throttlePolicy}.
+   * Transfer bytes from {@code source} to {@code sink} until either {@code byteCount} bytes have
+   * been transferred or {@code source} is exhausted. The transfer is throttled according to {@code
+   * policy}.
    */
-  private void throttledTransfer(MockResponse throttlePolicy, Socket socket, BufferedSource source,
-      BufferedSink sink, long byteCount) throws IOException {
+  private void throttledTransfer(MockResponse policy, Socket socket, BufferedSource source,
+      BufferedSink sink, long byteCount, boolean isRequest) throws IOException {
     if (byteCount == 0) return;
 
     Buffer buffer = new Buffer();
-    long bytesPerPeriod = throttlePolicy.getThrottleBytesPerPeriod();
-    long periodDelayMs = throttlePolicy.getThrottlePeriod(TimeUnit.MILLISECONDS);
+    long bytesPerPeriod = policy.getThrottleBytesPerPeriod();
+    long periodDelayMs = policy.getThrottlePeriod(TimeUnit.MILLISECONDS);
+
+    long halfByteCount = byteCount / 2;
+    boolean disconnectHalfway = isRequest
+        ? policy.getSocketPolicy() == DISCONNECT_DURING_REQUEST_BODY
+        : policy.getSocketPolicy() == DISCONNECT_DURING_RESPONSE_BODY;
 
     while (!socket.isClosed()) {
       for (int b = 0; b < bytesPerPeriod; ) {
-        long toRead = Math.min(Math.min(2048, byteCount), bytesPerPeriod - b);
+        // Ensure we do not read past the allotted bytes in this period.
+        long toRead = Math.min(byteCount, bytesPerPeriod - b);
+        // Ensure we do not read past halfway if the policy will kill the connection.
+        if (disconnectHalfway) {
+          toRead = Math.min(toRead, byteCount - halfByteCount);
+        }
+
         long read = source.read(buffer, toRead);
         if (read == -1) return;
 
@@ -749,6 +765,11 @@ private void throttledTransfer(MockResponse throttlePolicy, Socket socket, Buffe
         b += read;
         byteCount -= read;
 
+        if (disconnectHalfway && byteCount == halfByteCount) {
+          socket.close();
+          return;
+        }
+
         if (byteCount == 0) return;
       }
 
@@ -768,10 +789,9 @@ private void readEmptyLine(BufferedSource source) throws IOException {
   }
 
   /**
-   * Sets the dispatcher used to match incoming requests to mock responses.
-   * The default dispatcher simply serves a fixed sequence of responses from
-   * a {@link #enqueue(MockResponse) queue}; custom dispatchers can vary the
-   * response based on timing or the content of the request.
+   * Sets the dispatcher used to match incoming requests to mock responses. The default dispatcher
+   * simply serves a fixed sequence of responses from a {@link #enqueue(MockResponse) queue}; custom
+   * dispatchers can vary the response based on timing or the content of the request.
    */
   public void setDispatcher(Dispatcher dispatcher) {
     if (dispatcher == null) throw new NullPointerException();
@@ -816,19 +836,31 @@ public void setDispatcher(Dispatcher dispatcher) {
     }
   }
 
-  /** Processes HTTP requests layered over SPDY/3. */
-  private class SpdySocketHandler implements IncomingStreamHandler {
+  /** Processes HTTP requests layered over framed protocols. */
+  private class FramedSocketHandler extends FramedConnection.Listener {
     private final Socket socket;
     private final Protocol protocol;
     private final AtomicInteger sequenceNumber = new AtomicInteger();
 
-    private SpdySocketHandler(Socket socket, Protocol protocol) {
+    private FramedSocketHandler(Socket socket, Protocol protocol) {
       this.socket = socket;
       this.protocol = protocol;
     }
 
-    @Override public void receive(SpdyStream stream) throws IOException {
+    @Override public void onStream(FramedStream stream) throws IOException {
+      MockResponse peekedResponse = dispatcher.peek();
+      if (peekedResponse.getSocketPolicy() == RESET_STREAM_AT_START) {
+        try {
+          dispatchBookkeepingRequest(sequenceNumber.getAndIncrement(), socket);
+          stream.close(ErrorCode.fromHttp2(peekedResponse.getHttp2ErrorCode()));
+          return;
+        } catch (InterruptedException e) {
+          throw new InterruptedIOException();
+        }
+      }
+
       RecordedRequest request = readRequest(stream);
+      requestCount.incrementAndGet();
       requestQueue.add(request);
       MockResponse response;
       try {
@@ -843,23 +875,29 @@ private SpdySocketHandler(Socket socket, Protocol protocol) {
       }
     }
 
-    private RecordedRequest readRequest(SpdyStream stream) throws IOException {
-      List<Header> spdyHeaders = stream.getRequestHeaders();
+    private RecordedRequest readRequest(FramedStream stream) throws IOException {
+      List<Header> streamHeaders = stream.getRequestHeaders();
       Headers.Builder httpHeaders = new Headers.Builder();
       String method = "<:method omitted>";
       String path = "<:path omitted>";
       String version = protocol == Protocol.SPDY_3 ? "<:version omitted>" : "HTTP/1.1";
-      for (int i = 0, size = spdyHeaders.size(); i < size; i++) {
-        ByteString name = spdyHeaders.get(i).name;
-        String value = spdyHeaders.get(i).value.utf8();
+      for (int i = 0, size = streamHeaders.size(); i < size; i++) {
+        ByteString name = streamHeaders.get(i).name;
+        String value = streamHeaders.get(i).value.utf8();
         if (name.equals(Header.TARGET_METHOD)) {
           method = value;
         } else if (name.equals(Header.TARGET_PATH)) {
           path = value;
         } else if (name.equals(Header.VERSION)) {
           version = value;
-        } else {
+        } else if (protocol == Protocol.SPDY_3) {
+          for (String s : value.split("\u0000", -1)) {
+            httpHeaders.add(name.utf8(), s);
+          }
+        } else if (protocol == Protocol.HTTP_2) {
           httpHeaders.add(name.utf8(), value);
+        } else {
+          throw new IllegalStateException();
         }
       }
 
@@ -873,8 +911,13 @@ private RecordedRequest readRequest(SpdyStream stream) throws IOException {
           sequenceNumber.getAndIncrement(), socket);
     }
 
-    private void writeResponse(SpdyStream stream, MockResponse response) throws IOException {
-      if (response.getSocketPolicy() == SocketPolicy.NO_RESPONSE) {
+    private void writeResponse(FramedStream stream, MockResponse response) throws IOException {
+      Settings settings = response.getSettings();
+      if (settings != null) {
+        stream.getConnection().setSettings(settings);
+      }
+
+      if (response.getSocketPolicy() == NO_RESPONSE) {
         return;
       }
       List<Header> spdyHeaders = new ArrayList<>();
@@ -899,33 +942,33 @@ private void writeResponse(SpdyStream stream, MockResponse response) throws IOEx
       if (body != null) {
         BufferedSink sink = Okio.buffer(stream.getSink());
         sleepIfDelayed(response);
-        throttledTransfer(response, socket, body, sink, bodyLimit);
+        throttledTransfer(response, socket, body, sink, bodyLimit, false);
         sink.close();
       } else if (closeStreamAfterHeaders) {
         stream.close(ErrorCode.NO_ERROR);
       }
     }
 
-    private void pushPromises(SpdyStream stream, List<PushPromise> promises) throws IOException {
+    private void pushPromises(FramedStream stream, List<PushPromise> promises) throws IOException {
       for (PushPromise pushPromise : promises) {
         List<Header> pushedHeaders = new ArrayList<>();
         pushedHeaders.add(new Header(stream.getConnection().getProtocol() == Protocol.SPDY_3
             ? Header.TARGET_HOST
-            : Header.TARGET_AUTHORITY, getUrl(pushPromise.getPath()).getHost()));
-        pushedHeaders.add(new Header(Header.TARGET_METHOD, pushPromise.getMethod()));
-        pushedHeaders.add(new Header(Header.TARGET_PATH, pushPromise.getPath()));
-        Headers pushPromiseHeaders = pushPromise.getHeaders();
+            : Header.TARGET_AUTHORITY, url(pushPromise.path()).host()));
+        pushedHeaders.add(new Header(Header.TARGET_METHOD, pushPromise.method()));
+        pushedHeaders.add(new Header(Header.TARGET_PATH, pushPromise.path()));
+        Headers pushPromiseHeaders = pushPromise.headers();
         for (int i = 0, size = pushPromiseHeaders.size(); i < size; i++) {
           pushedHeaders.add(new Header(pushPromiseHeaders.name(i), pushPromiseHeaders.value(i)));
         }
-        String requestLine = pushPromise.getMethod() + ' ' + pushPromise.getPath() + " HTTP/1.1";
+        String requestLine = pushPromise.method() + ' ' + pushPromise.path() + " HTTP/1.1";
         List<Integer> chunkSizes = Collections.emptyList(); // No chunked encoding for SPDY.
-        requestQueue.add(new RecordedRequest(requestLine, pushPromise.getHeaders(), chunkSizes, 0,
+        requestQueue.add(new RecordedRequest(requestLine, pushPromise.headers(), chunkSizes, 0,
             new Buffer(), sequenceNumber.getAndIncrement(), socket));
-        boolean hasBody = pushPromise.getResponse().getBody() != null;
-        SpdyStream pushedStream =
+        boolean hasBody = pushPromise.response().getBody() != null;
+        FramedStream pushedStream =
             stream.getConnection().pushStream(stream.getId(), pushedHeaders, hasBody);
-        writeResponse(pushedStream, pushPromise.getResponse());
+        writeResponse(pushedStream, pushPromise.response());
       }
     }
   }
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/PushPromise.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/PushPromise.java
similarity index 84%
rename from mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/PushPromise.java
rename to mockwebserver/src/main/java/okhttp3/mockwebserver/PushPromise.java
index 649b4ee73a..744127cadd 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/PushPromise.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/PushPromise.java
@@ -13,9 +13,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.mockwebserver;
+package okhttp3.mockwebserver;
 
-import com.squareup.okhttp.Headers;
+import okhttp3.Headers;
 
 /** An HTTP request initiated by the server. */
 public final class PushPromise {
@@ -31,19 +31,19 @@ public PushPromise(String method, String path, Headers headers, MockResponse res
     this.response = response;
   }
 
-  public String getMethod() {
+  public String method() {
     return method;
   }
 
-  public String getPath() {
+  public String path() {
     return path;
   }
 
-  public Headers getHeaders() {
+  public Headers headers() {
     return headers;
   }
 
-  public MockResponse getResponse() {
+  public MockResponse response() {
     return response;
   }
 }
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/QueueDispatcher.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/QueueDispatcher.java
similarity index 69%
rename from mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/QueueDispatcher.java
rename to mockwebserver/src/main/java/okhttp3/mockwebserver/QueueDispatcher.java
index c9c206c17c..4071d4718b 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/QueueDispatcher.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/QueueDispatcher.java
@@ -13,17 +13,26 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.mockwebserver;
+package okhttp3.mockwebserver;
 
 import java.net.HttpURLConnection;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.LinkedBlockingQueue;
+import java.util.logging.Logger;
 
 /**
- * Default dispatcher that processes a script of responses. Populate the script
- * by calling {@link #enqueueResponse(MockResponse)}.
+ * Default dispatcher that processes a script of responses. Populate the script by calling {@link
+ * #enqueueResponse(MockResponse)}.
  */
 public class QueueDispatcher extends Dispatcher {
+  /**
+   * Enqueued on shutdown to release threads waiting on {@link #dispatch}. Note that this response
+   * isn't transmitted because the connection is closed before this response is returned.
+   */
+  private static final MockResponse DEAD_LETTER = new MockResponse()
+      .setStatus("HTTP/1.1 " + 503 + " shutting down");
+
+  private static final Logger logger = Logger.getLogger(QueueDispatcher.class.getName());
   protected final BlockingQueue<MockResponse> responseQueue = new LinkedBlockingQueue<>();
   private MockResponse failFastResponse;
 
@@ -31,7 +40,7 @@
     // To permit interactive/browser testing, ignore requests for favicons.
     final String requestLine = request.getRequestLine();
     if (requestLine != null && requestLine.equals("GET /favicon.ico HTTP/1.1")) {
-      System.out.println("served " + requestLine);
+      logger.info("served " + requestLine);
       return new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_FOUND);
     }
 
@@ -40,7 +49,13 @@
       return failFastResponse;
     }
 
-    return responseQueue.take();
+    MockResponse result = responseQueue.take();
+
+    // If take() returned because we're shutting down, then enqueue another dead letter so that any
+    // other threads waiting on take() will also return.
+    if (result == DEAD_LETTER) responseQueue.add(DEAD_LETTER);
+
+    return result;
   }
 
   @Override public MockResponse peek() {
@@ -54,6 +69,10 @@ public void enqueueResponse(MockResponse response) {
     responseQueue.add(response);
   }
 
+  @Override public void shutdown() {
+    responseQueue.add(DEAD_LETTER);
+  }
+
   public void setFailFast(boolean failFast) {
     MockResponse failFastResponse = failFast
         ? new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_FOUND)
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/RecordedRequest.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/RecordedRequest.java
similarity index 91%
rename from mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/RecordedRequest.java
rename to mockwebserver/src/main/java/okhttp3/mockwebserver/RecordedRequest.java
index 99d4d273b2..aa847001a2 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/RecordedRequest.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/RecordedRequest.java
@@ -14,13 +14,13 @@
  * limitations under the License.
  */
 
-package com.squareup.okhttp.mockwebserver;
+package okhttp3.mockwebserver;
 
-import com.squareup.okhttp.Headers;
-import com.squareup.okhttp.TlsVersion;
 import java.net.Socket;
 import java.util.List;
 import javax.net.ssl.SSLSocket;
+import okhttp3.Headers;
+import okhttp3.TlsVersion;
 import okio.Buffer;
 
 /** An HTTP request that came into the mock web server. */
@@ -82,16 +82,15 @@ public String getHeader(String name) {
   }
 
   /**
-   * Returns the sizes of the chunks of this request's body, or an empty list
-   * if the request's body was empty or unchunked.
+   * Returns the sizes of the chunks of this request's body, or an empty list if the request's body
+   * was empty or unchunked.
    */
   public List<Integer> getChunkSizes() {
     return chunkSizes;
   }
 
   /**
-   * Returns the total size of the body of this POST request (before
-   * truncation).
+   * Returns the total size of the body of this POST request (before truncation).
    */
   public long getBodySize() {
     return bodySize;
@@ -108,9 +107,8 @@ public String getUtf8Body() {
   }
 
   /**
-   * Returns the index of this request on its HTTP connection. Since a single
-   * HTTP connection may serve multiple requests, each request is assigned its
-   * own sequence number.
+   * Returns the index of this request on its HTTP connection. Since a single HTTP connection may
+   * serve multiple requests, each request is assigned its own sequence number.
    */
   public int getSequenceNumber() {
     return sequenceNumber;
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/SocketPolicy.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/SocketPolicy.java
new file mode 100644
index 0000000000..eddb7557a4
--- /dev/null
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/SocketPolicy.java
@@ -0,0 +1,98 @@
+/*
+ * Copyright (C) 2011 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package okhttp3.mockwebserver;
+
+/**
+ * What should be done with the incoming socket.
+ *
+ * <p>Be careful when using values like {@link #DISCONNECT_AT_END}, {@link #SHUTDOWN_INPUT_AT_END}
+ * and {@link #SHUTDOWN_OUTPUT_AT_END} that close a socket after a response, and where there are
+ * follow-up requests. The client is unblocked and free to continue as soon as it has received the
+ * entire response body. If and when the client makes a subsequent request using a pooled socket the
+ * server may not have had time to close the socket. The socket will be closed at an indeterminate
+ * point before or during the second request. It may be closed after client has started sending the
+ * request body. If a request body is not retryable then the client may fail the request, making
+ * client behavior non-deterministic. Add delays in the client to improve the chances that the
+ * server has closed the socket before follow up requests are made.
+ */
+public enum SocketPolicy {
+
+  /**
+   * Keep the socket open after the response. This is the default HTTP/1.1 behavior.
+   */
+  KEEP_OPEN,
+
+  /**
+   * Close the socket after the response. This is the default HTTP/1.0 behavior.
+   *
+   * <p>See {@link SocketPolicy} for reasons why this can cause test flakiness and how to avoid it.
+   */
+  DISCONNECT_AT_END,
+
+  /**
+   * Wrap the socket with SSL at the completion of this request/response pair. Used for CONNECT
+   * messages to tunnel SSL over an HTTP proxy.
+   */
+  UPGRADE_TO_SSL_AT_END,
+
+  /**
+   * Request immediate close of connection without even reading the request. Use to simulate buggy
+   * SSL servers closing connections in response to unrecognized TLS extensions.
+   */
+  DISCONNECT_AT_START,
+
+  /**
+   * Close connection after reading the request but before writing the response. Use this to
+   * simulate late connection pool failures.
+   */
+  DISCONNECT_AFTER_REQUEST,
+
+  /** Close connection after reading half of the request body (if present). */
+  DISCONNECT_DURING_REQUEST_BODY,
+
+  /** Close connection after writing half of the response body (if present). */
+  DISCONNECT_DURING_RESPONSE_BODY,
+
+  /** Don't trust the client during the SSL handshake. */
+  FAIL_HANDSHAKE,
+
+  /**
+   * Shutdown the socket input after sending the response. For testing bad behavior.
+   *
+   * <p>See {@link SocketPolicy} for reasons why this can cause test flakiness and how to avoid it.
+   */
+  SHUTDOWN_INPUT_AT_END,
+
+  /**
+   * Shutdown the socket output after sending the response. For testing bad behavior.
+   *
+   * <p>See {@link SocketPolicy} for reasons why this can cause test flakiness and how to avoid it.
+   */
+  SHUTDOWN_OUTPUT_AT_END,
+
+  /**
+   * Don't respond to the request but keep the socket open. For testing read response header timeout
+   * issue.
+   */
+  NO_RESPONSE,
+
+  /**
+   * Fail HTTP/2 requests without processing them by sending an {@linkplain
+   * MockResponse#getHttp2ErrorCode() HTTP/2 error code}.
+   */
+  RESET_STREAM_AT_START
+}
diff --git a/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/rule/MockWebServerRuleTest.java b/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/rule/MockWebServerRuleTest.java
deleted file mode 100644
index 43ceebc6bb..0000000000
--- a/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/rule/MockWebServerRuleTest.java
+++ /dev/null
@@ -1,84 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.mockwebserver.rule;
-
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.net.ConnectException;
-import java.net.HttpURLConnection;
-import java.net.URL;
-import org.junit.After;
-import org.junit.Test;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotEquals;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-public class MockWebServerRuleTest {
-
-  private MockWebServerRule server = new MockWebServerRule();
-
-  @After public void tearDown() {
-    server.after();
-  }
-
-  @Test public void whenRuleCreatedPortIsAvailable() throws IOException {
-    assertTrue(server.getPort() > 0);
-  }
-
-  @Test public void differentRulesGetDifferentPorts() throws IOException {
-    assertNotEquals(server.getPort(), new MockWebServerRule().getPort());
-  }
-
-  @Test public void beforePlaysServer() throws Exception {
-    server.before();
-    assertEquals(server.getPort(), server.get().getPort());
-    server.getUrl("/").openConnection().connect();
-  }
-
-  @Test public void afterStopsServer() throws Exception {
-    server.before();
-    server.after();
-
-    try {
-      server.getUrl("/").openConnection().connect();
-      fail();
-    } catch (ConnectException e) {
-    }
-  }
-
-  @Test public void typicalUsage() throws Exception {
-    server.before(); // Implicitly called when @Rule.
-
-    server.enqueue(new MockResponse().setBody("hello world"));
-
-    URL url = server.getUrl("/aaa");
-    HttpURLConnection connection = (HttpURLConnection) url.openConnection();
-    InputStream in = connection.getInputStream();
-    BufferedReader reader = new BufferedReader(new InputStreamReader(in));
-    assertEquals("hello world", reader.readLine());
-
-    assertEquals(1, server.getRequestCount());
-    assertEquals("GET /aaa HTTP/1.1", server.takeRequest().getRequestLine());
-
-    server.after(); // Implicitly called when @Rule.
-  }
-}
-
diff --git a/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/CustomDispatcherTest.java b/mockwebserver/src/test/java/okhttp3/mockwebserver/CustomDispatcherTest.java
similarity index 96%
rename from mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/CustomDispatcherTest.java
rename to mockwebserver/src/test/java/okhttp3/mockwebserver/CustomDispatcherTest.java
index 1c8c8206c9..5f189dc608 100644
--- a/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/CustomDispatcherTest.java
+++ b/mockwebserver/src/test/java/okhttp3/mockwebserver/CustomDispatcherTest.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.mockwebserver;
+package okhttp3.mockwebserver;
 
 import java.io.IOException;
 import java.net.HttpURLConnection;
@@ -46,7 +46,7 @@ public MockResponse dispatch(RecordedRequest request) throws InterruptedExceptio
     };
     assertEquals(0, requestsMade.size());
     mockWebServer.setDispatcher(dispatcher);
-    final URL url = mockWebServer.getUrl("/");
+    final URL url = mockWebServer.url("/").url();
     final HttpURLConnection conn = (HttpURLConnection) url.openConnection();
     conn.getResponseCode(); // Force the connection to hit the "server".
     // Make sure our dispatcher got the request.
@@ -86,7 +86,7 @@ public MockResponse dispatch(RecordedRequest request) throws InterruptedExceptio
   private Thread buildRequestThread(final String path, final AtomicInteger responseCode) {
     return new Thread(new Runnable() {
       @Override public void run() {
-        final URL url = mockWebServer.getUrl(path);
+        final URL url = mockWebServer.url(path).url();
         final HttpURLConnection conn;
         try {
           conn = (HttpURLConnection) url.openConnection();
diff --git a/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/MockWebServerTest.java b/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java
similarity index 57%
rename from mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/MockWebServerTest.java
rename to mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java
index a3816d2db4..dbeafc26de 100644
--- a/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/MockWebServerTest.java
+++ b/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java
@@ -13,15 +13,16 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.mockwebserver;
+package okhttp3.mockwebserver;
 
-import com.squareup.okhttp.Headers;
-import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
 import java.io.BufferedReader;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
+import java.io.OutputStream;
+import java.net.ConnectException;
 import java.net.HttpURLConnection;
+import java.net.ProtocolException;
 import java.net.SocketTimeoutException;
 import java.net.URL;
 import java.net.URLConnection;
@@ -29,17 +30,25 @@
 import java.util.Arrays;
 import java.util.List;
 import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import okhttp3.Headers;
+import okhttp3.internal.Util;
+import org.junit.After;
 import org.junit.Rule;
 import org.junit.Test;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
 
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
 import static java.util.concurrent.TimeUnit.SECONDS;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotEquals;
+import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 public final class MockWebServerTest {
-  @Rule public final MockWebServerRule server = new MockWebServerRule();
+  @Rule public final MockWebServer server = new MockWebServer();
 
   @Test public void defaultMockResponse() {
     MockResponse response = new MockResponse();
@@ -47,11 +56,34 @@
     assertEquals("HTTP/1.1 200 OK", response.getStatus());
   }
 
+  @Test public void setResponseMockReason() {
+    String[] reasons = {
+        "Mock Response",
+        "Informational",
+        "OK",
+        "Redirection",
+        "Client Error",
+        "Server Error",
+        "Mock Response"
+    };
+    for (int i = 0; i < 600; i++) {
+      MockResponse response = new MockResponse().setResponseCode(i);
+      String expectedReason = reasons[i / 100];
+      assertEquals("HTTP/1.1 " + i + " " + expectedReason, response.getStatus());
+      assertEquals(Arrays.asList("Content-Length: 0"), headersToList(response));
+    }
+  }
+
+  @Test public void setStatusControlsWholeStatusLine() {
+    MockResponse response = new MockResponse().setStatus("HTTP/1.1 202 That'll do pig");
+    assertEquals(Arrays.asList("Content-Length: 0"), headersToList(response));
+    assertEquals("HTTP/1.1 202 That'll do pig", response.getStatus());
+  }
+
   @Test public void setBodyAdjustsHeaders() throws IOException {
     MockResponse response = new MockResponse().setBody("ABC");
     assertEquals(Arrays.asList("Content-Length: 3"), headersToList(response));
     assertEquals("ABC", response.getBody().readUtf8());
-    assertEquals("HTTP/1.1 200 OK", response.getStatus());
   }
 
   @Test public void mockResponseAddHeader() {
@@ -75,7 +107,7 @@
   @Test public void regularResponse() throws Exception {
     server.enqueue(new MockResponse().setBody("hello world"));
 
-    URL url = server.getUrl("/");
+    URL url = server.url("/").url();
     HttpURLConnection connection = (HttpURLConnection) url.openConnection();
     connection.setRequestProperty("Accept-Language", "en-US");
     InputStream in = connection.getInputStream();
@@ -91,11 +123,11 @@
   @Test public void redirect() throws Exception {
     server.enqueue(new MockResponse()
         .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: " + server.getUrl("/new-path"))
+        .addHeader("Location: " + server.url("/new-path"))
         .setBody("This page has moved!"));
     server.enqueue(new MockResponse().setBody("This is the new location!"));
 
-    URLConnection connection = server.getUrl("/").openConnection();
+    URLConnection connection = server.url("/").url().openConnection();
     InputStream in = connection.getInputStream();
     BufferedReader reader = new BufferedReader(new InputStreamReader(in));
     assertEquals("This is the new location!", reader.readLine());
@@ -107,8 +139,8 @@
   }
 
   /**
-   * Test that MockWebServer blocks for a call to enqueue() if a request
-   * is made before a mock response is ready.
+   * Test that MockWebServer blocks for a call to enqueue() if a request is made before a mock
+   * response is ready.
    */
   @Test public void dispatchBlocksWaitingForEnqueue() throws Exception {
     new Thread() {
@@ -121,7 +153,7 @@
       }
     }.start();
 
-    URLConnection connection = server.getUrl("/").openConnection();
+    URLConnection connection = server.url("/").url().openConnection();
     InputStream in = connection.getInputStream();
     BufferedReader reader = new BufferedReader(new InputStreamReader(in));
     assertEquals("enqueued in the background", reader.readLine());
@@ -133,7 +165,7 @@
         .clearHeaders()
         .addHeader("Transfer-encoding: chunked"));
 
-    URLConnection connection = server.getUrl("/").openConnection();
+    URLConnection connection = server.url("/").url().openConnection();
     InputStream in = connection.getInputStream();
     try {
       in.read();
@@ -149,7 +181,7 @@
         .addHeader("Content-Length: 4"));
     server.enqueue(new MockResponse().setBody("DEF"));
 
-    URLConnection urlConnection = server.getUrl("/").openConnection();
+    URLConnection urlConnection = server.url("/").url().openConnection();
     urlConnection.setReadTimeout(1000);
     InputStream in = urlConnection.getInputStream();
     assertEquals('A', in.read());
@@ -161,7 +193,7 @@
     } catch (SocketTimeoutException expected) {
     }
 
-    URLConnection urlConnection2 = server.getUrl("/").openConnection();
+    URLConnection urlConnection2 = server.url("/").url().openConnection();
     InputStream in2 = urlConnection2.getInputStream();
     assertEquals('D', in2.read());
     assertEquals('E', in2.read());
@@ -177,22 +209,22 @@
     server.enqueue(new MockResponse()); // The jdk's HttpUrlConnection is a bastard.
     server.enqueue(new MockResponse());
     try {
-      server.getUrl("/a").openConnection().getInputStream();
+      server.url("/a").url().openConnection().getInputStream();
     } catch (IOException expected) {
     }
-    server.getUrl("/b").openConnection().getInputStream(); // Should succeed.
+    server.url("/b").url().openConnection().getInputStream(); // Should succeed.
   }
 
   /**
-   * Throttle the request body by sleeping 500ms after every 3 bytes. With a
-   * 6-byte request, this should yield one sleep for a total delay of 500ms.
+   * Throttle the request body by sleeping 500ms after every 3 bytes. With a 6-byte request, this
+   * should yield one sleep for a total delay of 500ms.
    */
   @Test public void throttleRequest() throws Exception {
     server.enqueue(new MockResponse()
         .throttleBody(3, 500, TimeUnit.MILLISECONDS));
 
     long startNanos = System.nanoTime();
-    URLConnection connection = server.getUrl("/").openConnection();
+    URLConnection connection = server.url("/").url().openConnection();
     connection.setDoOutput(true);
     connection.getOutputStream().write("ABCDEF".getBytes("UTF-8"));
     InputStream in = connection.getInputStream();
@@ -200,13 +232,13 @@
     long elapsedNanos = System.nanoTime() - startNanos;
     long elapsedMillis = NANOSECONDS.toMillis(elapsedNanos);
 
-    assertTrue(String.format("Request + Response: %sms", elapsedMillis), elapsedMillis >= 500);
-    assertTrue(String.format("Request + Response: %sms", elapsedMillis), elapsedMillis < 1000);
+    assertTrue(Util.format("Request + Response: %sms", elapsedMillis), elapsedMillis >= 500);
+    assertTrue(Util.format("Request + Response: %sms", elapsedMillis), elapsedMillis < 1000);
   }
 
   /**
-   * Throttle the response body by sleeping 500ms after every 3 bytes. With a
-   * 6-byte response, this should yield one sleep for a total delay of 500ms.
+   * Throttle the response body by sleeping 500ms after every 3 bytes. With a 6-byte response, this
+   * should yield one sleep for a total delay of 500ms.
    */
   @Test public void throttleResponse() throws Exception {
     server.enqueue(new MockResponse()
@@ -214,7 +246,7 @@
         .throttleBody(3, 500, TimeUnit.MILLISECONDS));
 
     long startNanos = System.nanoTime();
-    URLConnection connection = server.getUrl("/").openConnection();
+    URLConnection connection = server.url("/").url().openConnection();
     InputStream in = connection.getInputStream();
     assertEquals('A', in.read());
     assertEquals('B', in.read());
@@ -226,33 +258,70 @@
     long elapsedNanos = System.nanoTime() - startNanos;
     long elapsedMillis = NANOSECONDS.toMillis(elapsedNanos);
 
-    assertTrue(String.format("Request + Response: %sms", elapsedMillis), elapsedMillis >= 500);
-    assertTrue(String.format("Request + Response: %sms", elapsedMillis), elapsedMillis < 1000);
+    assertTrue(Util.format("Request + Response: %sms", elapsedMillis), elapsedMillis >= 500);
+    assertTrue(Util.format("Request + Response: %sms", elapsedMillis), elapsedMillis < 1000);
   }
 
-  /**
-   * Delay the response body by sleeping 1s.
-   */
+  /** Delay the response body by sleeping 1s. */
   @Test public void delayResponse() throws IOException {
     server.enqueue(new MockResponse()
         .setBody("ABCDEF")
         .setBodyDelay(1, SECONDS));
 
     long startNanos = System.nanoTime();
-    URLConnection connection = server.getUrl("/").openConnection();
+    URLConnection connection = server.url("/").url().openConnection();
     InputStream in = connection.getInputStream();
     assertEquals('A', in.read());
-    assertEquals('B', in.read());
-    assertEquals('C', in.read());
-    assertEquals('D', in.read());
-    assertEquals('E', in.read());
-    assertEquals('F', in.read());
-    assertEquals(-1, in.read());
     long elapsedNanos = System.nanoTime() - startNanos;
     long elapsedMillis = NANOSECONDS.toMillis(elapsedNanos);
+    assertTrue(Util.format("Request + Response: %sms", elapsedMillis), elapsedMillis >= 1000);
 
-    assertTrue(String.format("Request + Response: %sms", elapsedMillis), elapsedMillis >= 1000);
-    assertTrue(String.format("Request + Response: %sms", elapsedMillis), elapsedMillis <= 1100);
+    in.close();
+  }
+
+  @Test public void disconnectRequestHalfway() throws IOException {
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_DURING_REQUEST_BODY));
+    // Limit the size of the request body that the server holds in memory to an arbitrary
+    // 3.5 MBytes so this test can pass on devices with little memory.
+    server.setBodyLimit(7 * 512 * 1024);
+
+    HttpURLConnection connection = (HttpURLConnection) server.url("/").url().openConnection();
+    connection.setRequestMethod("POST");
+    connection.setDoOutput(true);
+    connection.setFixedLengthStreamingMode(1024 * 1024 * 1024); // 1 GB
+    connection.connect();
+    OutputStream out = connection.getOutputStream();
+
+    byte[] data = new byte[1024 * 1024];
+    int i;
+    for (i = 0; i < 1024; i++) {
+      try {
+        out.write(data);
+        out.flush();
+      } catch (IOException e) {
+        break;
+      }
+    }
+    assertEquals(512f, i, 10f); // Halfway +/- 1%
+  }
+
+  @Test public void disconnectResponseHalfway() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("ab")
+        .setSocketPolicy(SocketPolicy.DISCONNECT_DURING_RESPONSE_BODY));
+
+    URLConnection connection = server.url("/").url().openConnection();
+    assertEquals(2, connection.getContentLength());
+    InputStream in = connection.getInputStream();
+    assertEquals('a', in.read());
+    try {
+      int byteRead = in.read();
+      // OpenJDK behavior: end of stream.
+      assertEquals(-1, byteRead);
+    } catch (ProtocolException e) {
+      // On Android, HttpURLConnection is implemented by OkHttp v2. OkHttp
+      // treats an incomplete response body as a ProtocolException.
+    }
   }
 
   private List<String> headersToList(MockResponse response) {
@@ -267,11 +336,7 @@
 
   @Test public void shutdownWithoutStart() throws IOException {
     MockWebServer server = new MockWebServer();
-    try {
-      server.shutdown();
-      fail();
-    } catch (IllegalStateException expected) {
-    }
+    server.shutdown();
   }
 
   @Test public void shutdownWithoutEnqueue() throws IOException {
@@ -279,4 +344,59 @@
     server.start();
     server.shutdown();
   }
+
+  @After public void tearDown() throws IOException {
+    server.shutdown();
+  }
+
+  @Test public void portImplicitlyStarts() throws IOException {
+    assertTrue(server.getPort() > 0);
+  }
+
+  @Test public void hostnameImplicitlyStarts() throws IOException {
+    assertNotNull(server.getHostName());
+  }
+
+  @Test public void toProxyAddressImplicitlyStarts() throws IOException {
+    assertNotNull(server.toProxyAddress());
+  }
+
+  @Test public void differentInstancesGetDifferentPorts() throws IOException {
+    MockWebServer other = new MockWebServer();
+    assertNotEquals(server.getPort(), other.getPort());
+    other.shutdown();
+  }
+
+  @Test public void statementStartsAndStops() throws Throwable {
+    final AtomicBoolean called = new AtomicBoolean();
+    Statement statement = server.apply(new Statement() {
+      @Override public void evaluate() throws Throwable {
+        called.set(true);
+        server.url("/").url().openConnection().connect();
+      }
+    }, Description.EMPTY);
+
+    statement.evaluate();
+
+    assertTrue(called.get());
+    try {
+      server.url("/").url().openConnection().connect();
+      fail();
+    } catch (ConnectException expected) {
+    }
+  }
+
+  @Test public void shutdownWhileBlockedDispatching() throws Exception {
+    // Enqueue a request that'll cause MockWebServer to hang on QueueDispatcher.dispatch().
+    HttpURLConnection connection = (HttpURLConnection) server.url("/").url().openConnection();
+    connection.setReadTimeout(500);
+    try {
+      connection.getResponseCode();
+      fail();
+    } catch (SocketTimeoutException expected) {
+    }
+
+    // Shutting down the server should unblock the dispatcher.
+    server.shutdown();
+  }
 }
diff --git a/okcurl/pom.xml b/okcurl/pom.xml
index 467c170489..a12f1f43ac 100644
--- a/okcurl/pom.xml
+++ b/okcurl/pom.xml
@@ -4,9 +4,9 @@
   <modelVersion>4.0.0</modelVersion>
 
   <parent>
-    <groupId>com.squareup.okhttp</groupId>
+    <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>2.4.0-SNAPSHOT</version>
+    <version>3.4.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okcurl</artifactId>
@@ -14,10 +14,16 @@
 
   <dependencies>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>${project.groupId}</groupId>
       <artifactId>okhttp</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp-testing-support</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
     <dependency>
       <groupId>org.bouncycastle</groupId>
       <artifactId>bcprov-jdk15on</artifactId>
@@ -56,7 +62,7 @@
           </descriptorRefs>
           <archive>
             <manifest>
-              <mainClass>com.squareup.okhttp.curl.Main</mainClass>
+              <mainClass>okhttp3.curl.Main</mainClass>
             </manifest>
           </archive>
         </configuration>
diff --git a/okcurl/src/main/java/com/squareup/okhttp/curl/Main.java b/okcurl/src/main/java/okhttp3/curl/Main.java
similarity index 69%
rename from okcurl/src/main/java/com/squareup/okhttp/curl/Main.java
rename to okcurl/src/main/java/okhttp3/curl/Main.java
index c6a85e1732..aa8f4872c1 100644
--- a/okcurl/src/main/java/com/squareup/okhttp/curl/Main.java
+++ b/okcurl/src/main/java/okhttp3/curl/Main.java
@@ -13,28 +13,16 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.curl;
+package okhttp3.curl;
 
 import com.google.common.base.Joiner;
-import com.squareup.okhttp.ConnectionPool;
-import com.squareup.okhttp.Headers;
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Protocol;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.Response;
-import com.squareup.okhttp.internal.http.StatusLine;
-import com.squareup.okhttp.internal.spdy.Http2;
-
-import io.airlift.command.Arguments;
-import io.airlift.command.Command;
-import io.airlift.command.HelpOption;
-import io.airlift.command.Option;
-import io.airlift.command.SingleCommand;
+import io.airlift.airline.Arguments;
+import io.airlift.airline.Command;
+import io.airlift.airline.HelpOption;
+import io.airlift.airline.Option;
+import io.airlift.airline.SingleCommand;
 import java.io.IOException;
 import java.io.InputStream;
-import java.security.cert.CertificateException;
 import java.security.cert.X509Certificate;
 import java.util.List;
 import java.util.Properties;
@@ -49,6 +37,16 @@
 import javax.net.ssl.SSLSocketFactory;
 import javax.net.ssl.TrustManager;
 import javax.net.ssl.X509TrustManager;
+import okhttp3.Headers;
+import okhttp3.MediaType;
+import okhttp3.OkHttpClient;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
+import okhttp3.internal.Util;
+import okhttp3.internal.framed.Http2;
+import okhttp3.internal.http.StatusLine;
 import okio.BufferedSource;
 import okio.Okio;
 import okio.Sink;
@@ -59,6 +57,7 @@
 public class Main extends HelpOption implements Runnable {
   static final String NAME = "okcurl";
   static final int DEFAULT_TIMEOUT = -1;
+  private static Logger frameLogger;
 
   static Main fromArgs(String... args) {
     return SingleCommand.singleCommand(Main.class).parse(args);
@@ -84,16 +83,16 @@ private static String protocols() {
     return Joiner.on(", ").join(Protocol.values());
   }
 
-  @Option(name = { "-X", "--request" }, description = "Specify request command to use")
+  @Option(name = {"-X", "--request"}, description = "Specify request command to use")
   public String method;
 
-  @Option(name = { "-d", "--data" }, description = "HTTP POST data")
+  @Option(name = {"-d", "--data"}, description = "HTTP POST data")
   public String data;
 
-  @Option(name = { "-H", "--header" }, description = "Custom header to pass to server")
+  @Option(name = {"-H", "--header"}, description = "Custom header to pass to server")
   public List<String> headers;
 
-  @Option(name = { "-A", "--user-agent" }, description = "User-Agent to send to server")
+  @Option(name = {"-A", "--user-agent"}, description = "User-Agent to send to server")
   public String userAgent = NAME + "/" + versionString();
 
   @Option(name = "--connect-timeout", description = "Maximum time allowed for connection (seconds)")
@@ -102,23 +101,23 @@ private static String protocols() {
   @Option(name = "--read-timeout", description = "Maximum time allowed for reading data (seconds)")
   public int readTimeout = DEFAULT_TIMEOUT;
 
-  @Option(name = { "-L", "--location" }, description = "Follow redirects")
+  @Option(name = {"-L", "--location"}, description = "Follow redirects")
   public boolean followRedirects;
 
-  @Option(name = { "-k", "--insecure" },
+  @Option(name = {"-k", "--insecure"},
       description = "Allow connections to SSL sites without certs")
   public boolean allowInsecure;
 
-  @Option(name = { "-i", "--include" }, description = "Include protocol headers in the output")
+  @Option(name = {"-i", "--include"}, description = "Include protocol headers in the output")
   public boolean showHeaders;
 
   @Option(name = "--frames", description = "Log HTTP/2 frames to STDERR")
   public boolean showHttp2Frames;
 
-  @Option(name = { "-e", "--referer" }, description = "Referer URL")
+  @Option(name = {"-e", "--referer"}, description = "Referer URL")
   public String referer;
 
-  @Option(name = { "-V", "--version" }, description = "Show version number and quit")
+  @Option(name = {"-V", "--version"}, description = "Show version number and quit")
   public boolean version;
 
   @Arguments(title = "url", description = "Remote resource URL")
@@ -170,21 +169,21 @@ private static String protocols() {
   }
 
   private OkHttpClient createClient() {
-    OkHttpClient client = new OkHttpClient();
-    client.setFollowSslRedirects(followRedirects);
+    OkHttpClient.Builder builder = new OkHttpClient.Builder();
+    builder.followSslRedirects(followRedirects);
     if (connectTimeout != DEFAULT_TIMEOUT) {
-      client.setConnectTimeout(connectTimeout, SECONDS);
+      builder.connectTimeout(connectTimeout, SECONDS);
     }
     if (readTimeout != DEFAULT_TIMEOUT) {
-      client.setReadTimeout(readTimeout, SECONDS);
+      builder.readTimeout(readTimeout, SECONDS);
     }
     if (allowInsecure) {
-      client.setSslSocketFactory(createInsecureSslSocketFactory());
-      client.setHostnameVerifier(createInsecureHostnameVerifier());
+      X509TrustManager trustManager = createInsecureTrustManager();
+      SSLSocketFactory sslSocketFactory = createInsecureSslSocketFactory(trustManager);
+      builder.sslSocketFactory(sslSocketFactory, trustManager);
+      builder.hostnameVerifier(createInsecureHostnameVerifier());
     }
-    // If we don't set this reference, there's no way to clean shutdown persistent connections.
-    client.setConnectionPool(ConnectionPool.getDefault());
-    return client;
+    return builder.build();
   }
 
   private String getRequestMethod() {
@@ -203,7 +202,7 @@ private RequestBody getRequestBody() {
     }
     String bodyData = data;
 
-    String mimeType = "application/x-form-urlencoded";
+    String mimeType = "application/x-www-form-urlencoded";
     if (headers != null) {
       for (String header : headers) {
         String[] parts = header.split(":", -1);
@@ -239,26 +238,27 @@ Request createRequest() {
   }
 
   private void close() {
-    client.getConnectionPool().evictAll(); // Close any persistent connections.
+    client.connectionPool().evictAll(); // Close any persistent connections.
   }
 
-  private static SSLSocketFactory createInsecureSslSocketFactory() {
-    try {
-      SSLContext context = SSLContext.getInstance("TLS");
-      TrustManager permissive = new X509TrustManager() {
-        @Override public void checkClientTrusted(X509Certificate[] chain, String authType)
-            throws CertificateException {
-        }
+  private static X509TrustManager createInsecureTrustManager() {
+    return new X509TrustManager() {
+      @Override public void checkClientTrusted(X509Certificate[] chain, String authType) {
+      }
 
-        @Override public void checkServerTrusted(X509Certificate[] chain, String authType)
-            throws CertificateException {
-        }
+      @Override public void checkServerTrusted(X509Certificate[] chain, String authType) {
+      }
 
-        @Override public X509Certificate[] getAcceptedIssuers() {
-          return null;
-        }
-      };
-      context.init(null, new TrustManager[] { permissive }, null);
+      @Override public X509Certificate[] getAcceptedIssuers() {
+        return new X509Certificate[0];
+      }
+    };
+  }
+
+  private static SSLSocketFactory createInsecureSslSocketFactory(TrustManager trustManager) {
+    try {
+      SSLContext context = SSLContext.getInstance("TLS");
+      context.init(null, new TrustManager[] {trustManager}, null);
       return context.getSocketFactory();
     } catch (Exception e) {
       throw new AssertionError(e);
@@ -274,15 +274,15 @@ private static HostnameVerifier createInsecureHostnameVerifier() {
   }
 
   private static void enableHttp2FrameLogging() {
-    Logger logger = Logger.getLogger(Http2.class.getName() + "$FrameLogger");
-    logger.setLevel(Level.FINE);
+    frameLogger = Logger.getLogger(Http2.class.getName() + "$FrameLogger");
+    frameLogger.setLevel(Level.FINE);
     ConsoleHandler handler = new ConsoleHandler();
     handler.setLevel(Level.FINE);
     handler.setFormatter(new SimpleFormatter() {
       @Override public String format(LogRecord record) {
-        return String.format("%s%n", record.getMessage());
+        return Util.format("%s%n", record.getMessage());
       }
     });
-    logger.addHandler(handler);
+    frameLogger.addHandler(handler);
   }
 }
diff --git a/okcurl/src/test/java/com/squareup/okhttp/curl/MainTest.java b/okcurl/src/test/java/okhttp3/curl/MainTest.java
similarity index 76%
rename from okcurl/src/test/java/com/squareup/okhttp/curl/MainTest.java
rename to okcurl/src/test/java/okhttp3/curl/MainTest.java
index 0cc065c6c0..12fe6d5ec4 100644
--- a/okcurl/src/test/java/com/squareup/okhttp/curl/MainTest.java
+++ b/okcurl/src/test/java/okhttp3/curl/MainTest.java
@@ -13,15 +13,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.curl;
+package okhttp3.curl;
 
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.RequestBody;
 import java.io.IOException;
+import okhttp3.Request;
+import okhttp3.RequestBody;
 import okio.Buffer;
 import org.junit.Test;
 
-import static com.squareup.okhttp.curl.Main.fromArgs;
+import static okhttp3.curl.Main.fromArgs;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
 
@@ -29,23 +29,23 @@
   @Test public void simple() {
     Request request = fromArgs("http://example.com").createRequest();
     assertEquals("GET", request.method());
-    assertEquals("http://example.com", request.urlString());
+    assertEquals("http://example.com/", request.url().toString());
     assertNull(request.body());
   }
 
   @Test public void put() throws IOException {
-    Request request = fromArgs("-X", "PUT", "http://example.com").createRequest();
+    Request request = fromArgs("-X", "PUT", "-d", "foo", "http://example.com").createRequest();
     assertEquals("PUT", request.method());
-    assertEquals("http://example.com", request.urlString());
-    assertEquals(0, request.body().contentLength());
+    assertEquals("http://example.com/", request.url().toString());
+    assertEquals(3, request.body().contentLength());
   }
 
   @Test public void dataPost() {
     Request request = fromArgs("-d", "foo", "http://example.com").createRequest();
     RequestBody body = request.body();
     assertEquals("POST", request.method());
-    assertEquals("http://example.com", request.urlString());
-    assertEquals("application/x-form-urlencoded; charset=utf-8", body.contentType().toString());
+    assertEquals("http://example.com/", request.url().toString());
+    assertEquals("application/x-www-form-urlencoded; charset=utf-8", body.contentType().toString());
     assertEquals("foo", bodyAsString(body));
   }
 
@@ -53,8 +53,8 @@
     Request request = fromArgs("-d", "foo", "-X", "PUT", "http://example.com").createRequest();
     RequestBody body = request.body();
     assertEquals("PUT", request.method());
-    assertEquals("http://example.com", request.urlString());
-    assertEquals("application/x-form-urlencoded; charset=utf-8", body.contentType().toString());
+    assertEquals("http://example.com/", request.url().toString());
+    assertEquals("application/x-www-form-urlencoded; charset=utf-8", body.contentType().toString());
     assertEquals("foo", bodyAsString(body));
   }
 
@@ -63,7 +63,7 @@
         "http://example.com").createRequest();
     RequestBody body = request.body();
     assertEquals("POST", request.method());
-    assertEquals("http://example.com", request.urlString());
+    assertEquals("http://example.com/", request.url().toString());
     assertEquals("application/json; charset=utf-8", body.contentType().toString());
     assertEquals("foo", bodyAsString(body));
   }
@@ -71,7 +71,7 @@
   @Test public void referer() {
     Request request = fromArgs("-e", "foo", "http://example.com").createRequest();
     assertEquals("GET", request.method());
-    assertEquals("http://example.com", request.urlString());
+    assertEquals("http://example.com/", request.url().toString());
     assertEquals("foo", request.header("Referer"));
     assertNull(request.body());
   }
@@ -79,7 +79,7 @@
   @Test public void userAgent() {
     Request request = fromArgs("-A", "foo", "http://example.com").createRequest();
     assertEquals("GET", request.method());
-    assertEquals("http://example.com", request.urlString());
+    assertEquals("http://example.com/", request.url().toString());
     assertEquals("foo", request.header("User-Agent"));
     assertNull(request.body());
   }
diff --git a/okhttp-android-support/pom.xml b/okhttp-android-support/pom.xml
index 74f15fcf05..6d26b36731 100644
--- a/okhttp-android-support/pom.xml
+++ b/okhttp-android-support/pom.xml
@@ -4,29 +4,37 @@
   <modelVersion>4.0.0</modelVersion>
 
   <parent>
-    <groupId>com.squareup.okhttp</groupId>
+    <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>2.4.0-SNAPSHOT</version>
+    <version>3.4.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-android-support</artifactId>
   <name>OkHttp Android Platform Support</name>
-  <description>Classes to support the Android platform's use of OkHttp (not required for most developers).</description>
+  <description>Classes to support the Android platform's use of OkHttp (not required for most
+    developers).
+  </description>
 
   <dependencies>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp-testing-support</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
       <artifactId>okhttp-urlconnection</artifactId>
       <version>${project.version}</version>
     </dependency>
- 
+
     <dependency>
       <groupId>junit</groupId>
       <artifactId>junit</artifactId>
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>${project.groupId}</groupId>
       <artifactId>mockwebserver</artifactId>
       <version>${project.version}</version>
       <scope>test</scope>
@@ -39,7 +47,7 @@
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-javadoc-plugin</artifactId>
         <configuration>
-          <excludePackageNames>com.squareup.okhttp.internal.*</excludePackageNames>
+          <excludePackageNames>okhttp3.internal.*</excludePackageNames>
           <links>
             <link>http://square.github.io/okhttp/javadoc/</link>
           </links>
diff --git a/okhttp-android-support/src/main/java/com/squareup/okhttp/AndroidInternal.java b/okhttp-android-support/src/main/java/okhttp3/AndroidInternal.java
similarity index 83%
rename from okhttp-android-support/src/main/java/com/squareup/okhttp/AndroidInternal.java
rename to okhttp-android-support/src/main/java/okhttp3/AndroidInternal.java
index eeaf55473f..de5788539a 100644
--- a/okhttp-android-support/src/main/java/com/squareup/okhttp/AndroidInternal.java
+++ b/okhttp-android-support/src/main/java/okhttp3/AndroidInternal.java
@@ -13,11 +13,10 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
-
-import com.squareup.okhttp.internal.huc.CacheAdapter;
+package okhttp3;
 
 import java.net.ResponseCache;
+import okhttp3.internal.huc.CacheAdapter;
 
 /**
  * Back doors to enable the use of OkHttp within the Android platform libraries. OkHttp is used to
@@ -31,15 +30,16 @@ private AndroidInternal() {
 
   /** Sets the response cache to be used to read and write cached responses. */
   public static void setResponseCache(OkUrlFactory okUrlFactory, ResponseCache responseCache) {
-    OkHttpClient client = okUrlFactory.client();
+    OkHttpClient.Builder builder = okUrlFactory.client().newBuilder();
     if (responseCache instanceof OkCacheContainer) {
       // Avoid adding layers of wrappers. Rather than wrap the ResponseCache in yet another layer to
       // make the ResponseCache look like an InternalCache, we can unwrap the Cache instead.
       // This means that Cache stats will be correctly updated.
       OkCacheContainer okCacheContainer = (OkCacheContainer) responseCache;
-      client.setCache(okCacheContainer.getCache());
+      builder.cache(okCacheContainer.getCache());
     } else {
-      client.setInternalCache(responseCache != null ? new CacheAdapter(responseCache) : null);
+      builder.setInternalCache(responseCache != null ? new CacheAdapter(responseCache) : null);
     }
+    okUrlFactory.setClient(builder.build());
   }
 }
diff --git a/okhttp-android-support/src/main/java/com/squareup/okhttp/AndroidShimResponseCache.java b/okhttp-android-support/src/main/java/okhttp3/AndroidShimResponseCache.java
similarity index 72%
rename from okhttp-android-support/src/main/java/com/squareup/okhttp/AndroidShimResponseCache.java
rename to okhttp-android-support/src/main/java/okhttp3/AndroidShimResponseCache.java
index 488d3d6cd2..b0bb9fcf73 100644
--- a/okhttp-android-support/src/main/java/com/squareup/okhttp/AndroidShimResponseCache.java
+++ b/okhttp-android-support/src/main/java/okhttp3/AndroidShimResponseCache.java
@@ -13,9 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
-
-import com.squareup.okhttp.internal.huc.JavaApiConverter;
+package okhttp3;
 
 import java.io.File;
 import java.io.IOException;
@@ -26,6 +24,7 @@
 import java.net.URLConnection;
 import java.util.List;
 import java.util.Map;
+import okhttp3.internal.huc.JavaApiConverter;
 
 /**
  * A class provided for use by Android so that it can continue supporting a {@link ResponseCache}
@@ -46,8 +45,8 @@ public static AndroidShimResponseCache create(File directory, long maxSize) thro
 
   public boolean isEquivalent(File directory, long maxSize) {
     Cache installedCache = getCache();
-    return (installedCache.getDirectory().equals(directory)
-        && installedCache.getMaxSize() == maxSize
+    return (installedCache.directory().equals(directory)
+        && installedCache.maxSize() == maxSize
         && !installedCache.isClosed());
   }
 
@@ -66,8 +65,12 @@ public Cache getCache() {
   }
 
   @Override public CacheRequest put(URI uri, URLConnection urlConnection) throws IOException {
-    Response okResponse = JavaApiConverter.createOkResponse(uri, urlConnection);
-    com.squareup.okhttp.internal.http.CacheRequest okCacheRequest =
+    Response okResponse = JavaApiConverter.createOkResponseForCachePut(uri, urlConnection);
+    if (okResponse == null) {
+      // The URLConnection is not cacheable or could not be converted. Stop.
+      return null;
+    }
+    okhttp3.internal.http.CacheRequest okCacheRequest =
         delegate.internalCache.put(okResponse);
     if (okCacheRequest == null) {
       return null;
@@ -76,60 +79,55 @@ public Cache getCache() {
   }
 
   /**
-   * Returns the number of bytes currently being used to store the values in
-   * this cache. This may be greater than the {@link #maxSize} if a background
-   * deletion is pending.
+   * Returns the number of bytes currently being used to store the values in this cache. This may be
+   * greater than the {@link #maxSize} if a background deletion is pending.
    */
   public long size() throws IOException {
-    return delegate.getSize();
+    return delegate.size();
   }
 
   /**
-   * Returns the maximum number of bytes that this cache should use to store
-   * its data.
+   * Returns the maximum number of bytes that this cache should use to store its data.
    */
   public long maxSize() {
-    return delegate.getMaxSize();
+    return delegate.maxSize();
   }
 
   /**
-   * Force buffered operations to the filesystem. This ensures that responses
-   * written to the cache will be available the next time the cache is opened,
-   * even if this process is killed.
+   * Force buffered operations to the filesystem. This ensures that responses written to the cache
+   * will be available the next time the cache is opened, even if this process is killed.
    */
   public void flush() throws IOException {
     delegate.flush();
   }
 
   /**
-   * Returns the number of HTTP requests that required the network to either
-   * supply a response or validate a locally cached response.
+   * Returns the number of HTTP requests that required the network to either supply a response or
+   * validate a locally cached response.
    */
   public int getNetworkCount() {
-    return delegate.getNetworkCount();
+    return delegate.networkCount();
   }
 
   /**
-   * Returns the number of HTTP requests whose response was provided by the
-   * cache. This may include conditional {@code GET} requests that were
-   * validated over the network.
+   * Returns the number of HTTP requests whose response was provided by the cache. This may include
+   * conditional {@code GET} requests that were validated over the network.
    */
   public int getHitCount() {
-    return delegate.getHitCount();
+    return delegate.hitCount();
   }
 
   /**
-   * Returns the total number of HTTP requests that were made. This includes
-   * both client requests and requests that were made on the client's behalf
-   * to handle a redirects and retries.
+   * Returns the total number of HTTP requests that were made. This includes both client requests
+   * and requests that were made on the client's behalf to handle a redirects and retries.
    */
   public int getRequestCount() {
-    return delegate.getRequestCount();
+    return delegate.requestCount();
   }
 
   /**
-   * Uninstalls the cache and releases any active resources. Stored contents
-   * will remain on the filesystem.
+   * Uninstalls the cache and releases any active resources. Stored contents will remain on the
+   * filesystem.
    */
   public void close() throws IOException {
     delegate.close();
@@ -141,5 +139,4 @@ public void close() throws IOException {
   public void delete() throws IOException {
     delegate.delete();
   }
-
 }
diff --git a/okhttp-android-support/src/main/java/com/squareup/okhttp/OkCacheContainer.java b/okhttp-android-support/src/main/java/okhttp3/OkCacheContainer.java
similarity index 90%
rename from okhttp-android-support/src/main/java/com/squareup/okhttp/OkCacheContainer.java
rename to okhttp-android-support/src/main/java/okhttp3/OkCacheContainer.java
index d7b62e3ae1..d52cb0133d 100644
--- a/okhttp-android-support/src/main/java/com/squareup/okhttp/OkCacheContainer.java
+++ b/okhttp-android-support/src/main/java/okhttp3/OkCacheContainer.java
@@ -13,11 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
 /**
- * An interface that allows OkHttp to detect that a {@link java.net.ResponseCache} contains a
- * {@link Cache}.
+ * An interface that allows OkHttp to detect that a {@link java.net.ResponseCache} contains a {@link
+ * Cache}.
  */
 public interface OkCacheContainer {
   Cache getCache();
diff --git a/okhttp-android-support/src/main/java/com/squareup/okhttp/internal/huc/CacheAdapter.java b/okhttp-android-support/src/main/java/okhttp3/internal/huc/CacheAdapter.java
similarity index 85%
rename from okhttp-android-support/src/main/java/com/squareup/okhttp/internal/huc/CacheAdapter.java
rename to okhttp-android-support/src/main/java/okhttp3/internal/huc/CacheAdapter.java
index 13a34c032b..8e02239dea 100644
--- a/okhttp-android-support/src/main/java/com/squareup/okhttp/internal/huc/CacheAdapter.java
+++ b/okhttp-android-support/src/main/java/okhttp3/internal/huc/CacheAdapter.java
@@ -13,13 +13,8 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.huc;
+package okhttp3.internal.huc;
 
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
-import com.squareup.okhttp.internal.InternalCache;
-import com.squareup.okhttp.internal.http.CacheRequest;
-import com.squareup.okhttp.internal.http.CacheStrategy;
 import java.io.IOException;
 import java.io.OutputStream;
 import java.net.CacheResponse;
@@ -28,6 +23,11 @@
 import java.net.URI;
 import java.util.List;
 import java.util.Map;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.internal.InternalCache;
+import okhttp3.internal.http.CacheRequest;
+import okhttp3.internal.http.CacheStrategy;
 import okio.Okio;
 import okio.Sink;
 
@@ -48,12 +48,12 @@ public ResponseCache getDelegate() {
     if (javaResponse == null) {
       return null;
     }
-    return JavaApiConverter.createOkResponse(request, javaResponse);
+    return JavaApiConverter.createOkResponseForCacheGet(request, javaResponse);
   }
 
   @Override public CacheRequest put(Response response) throws IOException {
-    URI uri = response.request().uri();
-    HttpURLConnection connection = JavaApiConverter.createJavaUrlConnection(response);
+    URI uri = response.request().url().uri();
+    HttpURLConnection connection = JavaApiConverter.createJavaUrlConnectionForCachePut(response);
     final java.net.CacheRequest request = delegate.put(uri, connection);
     if (request == null) {
       return null;
@@ -95,11 +95,11 @@ public ResponseCache getDelegate() {
   }
 
   /**
-   * Returns the {@link CacheResponse} from the delegate by converting the
-   * OkHttp {@link Request} into the arguments required by the {@link ResponseCache}.
+   * Returns the {@link CacheResponse} from the delegate by converting the OkHttp {@link Request}
+   * into the arguments required by the {@link ResponseCache}.
    */
   private CacheResponse getJavaCachedResponse(Request request) throws IOException {
     Map<String, List<String>> headers = JavaApiConverter.extractJavaHeaders(request);
-    return delegate.get(request.uri(), request.method(), headers);
+    return delegate.get(request.url().uri(), request.method(), headers);
   }
 }
diff --git a/okhttp-android-support/src/main/java/com/squareup/okhttp/internal/huc/JavaApiConverter.java b/okhttp-android-support/src/main/java/okhttp3/internal/huc/JavaApiConverter.java
similarity index 65%
rename from okhttp-android-support/src/main/java/com/squareup/okhttp/internal/huc/JavaApiConverter.java
rename to okhttp-android-support/src/main/java/okhttp3/internal/huc/JavaApiConverter.java
index 603a559980..2465372a55 100644
--- a/okhttp-android-support/src/main/java/com/squareup/okhttp/internal/huc/JavaApiConverter.java
+++ b/okhttp-android-support/src/main/java/okhttp3/internal/huc/JavaApiConverter.java
@@ -13,18 +13,8 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.huc;
-
-import com.squareup.okhttp.Handshake;
-import com.squareup.okhttp.Headers;
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
-import com.squareup.okhttp.ResponseBody;
-import com.squareup.okhttp.internal.Util;
-import com.squareup.okhttp.internal.http.CacheRequest;
-import com.squareup.okhttp.internal.http.OkHeaders;
-import com.squareup.okhttp.internal.http.StatusLine;
+package okhttp3.internal.huc;
+
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
@@ -39,10 +29,26 @@
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.HttpsURLConnection;
 import javax.net.ssl.SSLPeerUnverifiedException;
 import javax.net.ssl.SSLSocketFactory;
+import okhttp3.CipherSuite;
+import okhttp3.Handshake;
+import okhttp3.Headers;
+import okhttp3.MediaType;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+import okhttp3.internal.Internal;
+import okhttp3.internal.JavaNetHeaders;
+import okhttp3.internal.Util;
+import okhttp3.internal.http.CacheRequest;
+import okhttp3.internal.http.HttpMethod;
+import okhttp3.internal.http.OkHeaders;
+import okhttp3.internal.http.StatusLine;
 import okio.BufferedSource;
 import okio.Okio;
 import okio.Sink;
@@ -51,23 +57,42 @@
  * Helper methods that convert between Java and OkHttp representations.
  */
 public final class JavaApiConverter {
+  private static final RequestBody EMPTY_REQUEST_BODY = RequestBody.create(null, new byte[0]);
 
   private JavaApiConverter() {
   }
 
   /**
-   * Creates an OkHttp {@link Response} using the supplied {@link URI} and {@link URLConnection}
-   * to supply the data. The URLConnection is assumed to already be connected.
+   * Creates an OkHttp {@link Response} using the supplied {@link URI} and {@link URLConnection} to
+   * supply the data. The URLConnection is assumed to already be connected. If this method returns
+   * {@code null} the response is uncacheable.
    */
-  public static Response createOkResponse(URI uri, URLConnection urlConnection) throws IOException {
+  public static Response createOkResponseForCachePut(URI uri, URLConnection urlConnection)
+      throws IOException {
+
     HttpURLConnection httpUrlConnection = (HttpURLConnection) urlConnection;
 
     Response.Builder okResponseBuilder = new Response.Builder();
 
     // Request: Create one from the URL connection.
-    // A connected HttpURLConnection does not permit access to request headers.
-    Map<String, List<String>> requestHeaders = null;
-    Request okRequest = createOkRequest(uri, httpUrlConnection.getRequestMethod(), requestHeaders);
+    Headers responseHeaders = createHeaders(urlConnection.getHeaderFields());
+    // Some request headers are needed for Vary caching.
+    Headers varyHeaders = varyHeaders(urlConnection, responseHeaders);
+    if (varyHeaders == null) {
+      return null;
+    }
+
+    // OkHttp's Call API requires a placeholder body; the real body will be streamed separately.
+    String requestMethod = httpUrlConnection.getRequestMethod();
+    RequestBody placeholderBody = HttpMethod.requiresRequestBody(requestMethod)
+        ? EMPTY_REQUEST_BODY
+        : null;
+
+    Request okRequest = new Request.Builder()
+        .url(uri.toString())
+        .method(requestMethod, placeholderBody)
+        .headers(varyHeaders)
+        .build();
     okResponseBuilder.request(okRequest);
 
     // Status line
@@ -76,8 +101,12 @@ public static Response createOkResponse(URI uri, URLConnection urlConnection) th
     okResponseBuilder.code(statusLine.code);
     okResponseBuilder.message(statusLine.message);
 
+    // A network response is required for the Cache to find any Vary headers it needs.
+    Response networkResponse = okResponseBuilder.build();
+    okResponseBuilder.networkResponse(networkResponse);
+
     // Response headers
-    Headers okHeaders = extractOkResponseHeaders(httpUrlConnection);
+    Headers okHeaders = extractOkResponseHeaders(httpUrlConnection, okResponseBuilder);
     okResponseBuilder.headers(okHeaders);
 
     // Response body
@@ -97,25 +126,102 @@ public static Response createOkResponse(URI uri, URLConnection urlConnection) th
 
       Certificate[] localCertificates = httpsUrlConnection.getLocalCertificates();
 
-      Handshake handshake = Handshake.get(
-          httpsUrlConnection.getCipherSuite(), nullSafeImmutableList(peerCertificates),
-          nullSafeImmutableList(localCertificates));
+      String cipherSuiteString = httpsUrlConnection.getCipherSuite();
+      CipherSuite cipherSuite = CipherSuite.forJavaName(cipherSuiteString);
+      Handshake handshake = Handshake.get(null, cipherSuite,
+          nullSafeImmutableList(peerCertificates), nullSafeImmutableList(localCertificates));
       okResponseBuilder.handshake(handshake);
     }
 
     return okResponseBuilder.build();
   }
 
+  /**
+   * Returns headers for the header names and values in the {@link Map}.
+   */
+  private static Headers createHeaders(Map<String, List<String>> headers) {
+    Headers.Builder builder = new Headers.Builder();
+    for (Map.Entry<String, List<String>> header : headers.entrySet()) {
+      if (header.getKey() == null || header.getValue() == null) {
+        continue;
+      }
+      String name = header.getKey().trim();
+      for (String value : header.getValue()) {
+        String trimmedValue = value.trim();
+        Internal.instance.addLenient(builder, name, trimmedValue);
+      }
+    }
+    return builder.build();
+  }
+
+  private static Headers varyHeaders(URLConnection urlConnection, Headers responseHeaders) {
+    if (OkHeaders.hasVaryAll(responseHeaders)) {
+      // "*" means that this will be treated as uncacheable anyway.
+      return null;
+    }
+    Set<String> varyFields = OkHeaders.varyFields(responseHeaders);
+    if (varyFields.isEmpty()) {
+      return new Headers.Builder().build();
+    }
+
+    // This probably indicates another HTTP stack is trying to use the shared ResponseCache.
+    // We cannot guarantee this case will work properly because we cannot reliably extract *all*
+    // the request header values, and we can't get multiple Vary request header values.
+    // We also can't be sure about the Accept-Encoding behavior of other stacks.
+    if (!(urlConnection instanceof CacheHttpURLConnection
+        || urlConnection instanceof CacheHttpsURLConnection)) {
+      return null;
+    }
+
+    // This is the case we expect: The URLConnection is from a call to
+    // JavaApiConverter.createJavaUrlConnection() and we have access to the user's request headers.
+    Map<String, List<String>> requestProperties = urlConnection.getRequestProperties();
+    Headers.Builder result = new Headers.Builder();
+    for (String fieldName : varyFields) {
+      List<String> fieldValues = requestProperties.get(fieldName);
+      if (fieldValues == null) {
+        if (fieldName.equals("Accept-Encoding")) {
+          // Accept-Encoding is special. If OkHttp sees Accept-Encoding is unset it will add
+          // "gzip". We don't have access to the request that was actually made so we must do the
+          // same.
+          result.add("Accept-Encoding", "gzip");
+        }
+      } else {
+        for (String fieldValue : fieldValues) {
+          Internal.instance.addLenient(result, fieldName, fieldValue);
+        }
+      }
+    }
+    return result.build();
+  }
+
   /**
    * Creates an OkHttp {@link Response} using the supplied {@link Request} and {@link CacheResponse}
    * to supply the data.
    */
-  static Response createOkResponse(Request request, CacheResponse javaResponse)
+  static Response createOkResponseForCacheGet(Request request, CacheResponse javaResponse)
       throws IOException {
+
+    // Build a cache request for the response to use.
+    Headers responseHeaders = createHeaders(javaResponse.getHeaders());
+    Headers varyHeaders;
+    if (OkHeaders.hasVaryAll(responseHeaders)) {
+      // "*" means that this will be treated as uncacheable anyway.
+      varyHeaders = new Headers.Builder().build();
+    } else {
+      varyHeaders = OkHeaders.varyHeaders(request.headers(), responseHeaders);
+    }
+
+    Request cacheRequest = new Request.Builder()
+        .url(request.url())
+        .method(request.method(), null)
+        .headers(varyHeaders)
+        .build();
+
     Response.Builder okResponseBuilder = new Response.Builder();
 
-    // Request: Use the one provided.
-    okResponseBuilder.request(request);
+    // Request: Use the cacheRequest we built.
+    okResponseBuilder.request(cacheRequest);
 
     // Status line: Java has this as one of the headers.
     StatusLine statusLine = StatusLine.parse(extractStatusLine(javaResponse));
@@ -124,7 +230,7 @@ static Response createOkResponse(Request request, CacheResponse javaResponse)
     okResponseBuilder.message(statusLine.message);
 
     // Response headers
-    Headers okHeaders = extractOkHeaders(javaResponse);
+    Headers okHeaders = extractOkHeaders(javaResponse, okResponseBuilder);
     okResponseBuilder.headers(okHeaders);
 
     // Response body
@@ -146,8 +252,10 @@ static Response createOkResponse(Request request, CacheResponse javaResponse)
       if (localCertificates == null) {
         localCertificates = Collections.emptyList();
       }
-      Handshake handshake = Handshake.get(
-          javaSecureCacheResponse.getCipherSuite(), peerCertificates, localCertificates);
+
+      String cipherSuiteString = javaSecureCacheResponse.getCipherSuite();
+      CipherSuite cipherSuite = CipherSuite.forJavaName(cipherSuiteString);
+      Handshake handshake = Handshake.get(null, cipherSuite, peerCertificates, localCertificates);
       okResponseBuilder.handshake(handshake);
     }
 
@@ -157,37 +265,41 @@ static Response createOkResponse(Request request, CacheResponse javaResponse)
   /**
    * Creates an OkHttp {@link Request} from the supplied information.
    *
-   * <p>This method allows a {@code null} value for {@code requestHeaders} for situations
-   * where a connection is already connected and access to the headers has been lost.
-   * See {@link java.net.HttpURLConnection#getRequestProperties()} for details.
+   * <p>This method allows a {@code null} value for {@code requestHeaders} for situations where a
+   * connection is already connected and access to the headers has been lost. See {@link
+   * java.net.HttpURLConnection#getRequestProperties()} for details.
    */
   public static Request createOkRequest(
       URI uri, String requestMethod, Map<String, List<String>> requestHeaders) {
+    // OkHttp's Call API requires a placeholder body; the real body will be streamed separately.
+    RequestBody placeholderBody = HttpMethod.requiresRequestBody(requestMethod)
+        ? EMPTY_REQUEST_BODY
+        : null;
 
     Request.Builder builder = new Request.Builder()
         .url(uri.toString())
-        .method(requestMethod, null);
+        .method(requestMethod, placeholderBody);
 
     if (requestHeaders != null) {
-      Headers headers = extractOkHeaders(requestHeaders);
+      Headers headers = extractOkHeaders(requestHeaders, null);
       builder.headers(headers);
     }
     return builder.build();
   }
 
   /**
-   * Creates a {@link java.net.CacheResponse} of the correct (sub)type using information
-   * gathered from the supplied {@link Response}.
+   * Creates a {@link java.net.CacheResponse} of the correct (sub)type using information gathered
+   * from the supplied {@link Response}.
    */
   public static CacheResponse createJavaCacheResponse(final Response response) {
-    final Headers headers = response.headers();
+    final Headers headers = withSyntheticHeaders(response);
     final ResponseBody body = response.body();
     if (response.request().isHttps()) {
       final Handshake handshake = response.handshake();
       return new SecureCacheResponse() {
         @Override
         public String getCipherSuite() {
-          return handshake != null ? handshake.cipherSuite() : null;
+          return handshake != null ? handshake.cipherSuite().javaName() : null;
         }
 
         @Override
@@ -221,7 +333,7 @@ public Principal getLocalPrincipal() {
         @Override
         public Map<String, List<String>> getHeaders() throws IOException {
           // Java requires that the entry with a null key be the status line.
-          return OkHeaders.toMultimap(headers, StatusLine.get(response).toString());
+          return JavaNetHeaders.toMultimap(headers, StatusLine.get(response).toString());
         }
 
         @Override
@@ -235,7 +347,7 @@ public InputStream getBody() throws IOException {
         @Override
         public Map<String, List<String>> getHeaders() throws IOException {
           // Java requires that the entry with a null key be the status line.
-          return OkHeaders.toMultimap(headers, StatusLine.get(response).toString());
+          return JavaNetHeaders.toMultimap(headers, StatusLine.get(response).toString());
         }
 
         @Override
@@ -253,6 +365,7 @@ public InputStream getBody() throws IOException {
       public void abort() {
         okCacheRequest.abort();
       }
+
       @Override
       public OutputStream getBody() throws IOException {
         Sink body = okCacheRequest.body();
@@ -268,7 +381,11 @@ public OutputStream getBody() throws IOException {
    * Creates an {@link java.net.HttpURLConnection} of the correct subclass from the supplied OkHttp
    * {@link Response}.
    */
-  static HttpURLConnection createJavaUrlConnection(Response okResponse) {
+  static HttpURLConnection createJavaUrlConnectionForCachePut(Response okResponse) {
+    okResponse = okResponse.newBuilder()
+        .body(null)
+        .headers(withSyntheticHeaders(okResponse))
+        .build();
     Request request = okResponse.request();
     // Create an object of the correct class in case the ResponseCache uses instanceof.
     if (request.isHttps()) {
@@ -278,37 +395,48 @@ static HttpURLConnection createJavaUrlConnection(Response okResponse) {
     }
   }
 
+  private static Headers withSyntheticHeaders(Response okResponse) {
+    return okResponse.headers().newBuilder()
+        .add(OkHeaders.SENT_MILLIS, Long.toString(okResponse.sentRequestAtMillis()))
+        .add(OkHeaders.RECEIVED_MILLIS, Long.toString(okResponse.receivedResponseAtMillis()))
+        .build();
+  }
+
   /**
-   * Extracts an immutable request header map from the supplied {@link com.squareup.okhttp.Headers}.
+   * Extracts an immutable request header map from the supplied {@link Headers}.
    */
   static Map<String, List<String>> extractJavaHeaders(Request request) {
-    return OkHeaders.toMultimap(request.headers(), null);
+    return JavaNetHeaders.toMultimap(request.headers(), null);
   }
 
   /**
    * Extracts OkHttp headers from the supplied {@link java.net.CacheResponse}. Only real headers are
    * extracted. See {@link #extractStatusLine(java.net.CacheResponse)}.
    */
-  private static Headers extractOkHeaders(CacheResponse javaResponse) throws IOException {
+  private static Headers extractOkHeaders(
+      CacheResponse javaResponse, Response.Builder okResponseBuilder) throws IOException {
     Map<String, List<String>> javaResponseHeaders = javaResponse.getHeaders();
-    return extractOkHeaders(javaResponseHeaders);
+    return extractOkHeaders(javaResponseHeaders, okResponseBuilder);
   }
 
   /**
    * Extracts OkHttp headers from the supplied {@link java.net.HttpURLConnection}. Only real headers
    * are extracted. See {@link #extractStatusLine(java.net.HttpURLConnection)}.
    */
-  private static Headers extractOkResponseHeaders(HttpURLConnection httpUrlConnection) {
+  private static Headers extractOkResponseHeaders(
+      HttpURLConnection httpUrlConnection, Response.Builder okResponseBuilder) {
     Map<String, List<String>> javaResponseHeaders = httpUrlConnection.getHeaderFields();
-    return extractOkHeaders(javaResponseHeaders);
+    return extractOkHeaders(javaResponseHeaders, okResponseBuilder);
   }
 
   /**
-   * Extracts OkHttp headers from the supplied {@link Map}. Only real headers are
-   * extracted. Any entry (one with a {@code null} key) is discarded.
+   * Extracts OkHttp headers from the supplied {@link Map}. Only real headers are extracted. Any
+   * entry (one with a {@code null} key) is discarded. Special internal headers used to track cache
+   * metadata are omitted from the result and added to {@code okResponseBuilder} instead.
    */
   // @VisibleForTesting
-  static Headers extractOkHeaders(Map<String, List<String>> javaHeaders) {
+  static Headers extractOkHeaders(
+      Map<String, List<String>> javaHeaders, Response.Builder okResponseBuilder) {
     Headers.Builder okHeadersBuilder = new Headers.Builder();
     for (Map.Entry<String, List<String>> javaHeader : javaHeaders.entrySet()) {
       String name = javaHeader.getKey();
@@ -319,17 +447,27 @@ static Headers extractOkHeaders(Map<String, List<String>> javaHeaders) {
         // explicitly ignored because Headers.Builder does not support null keys.
         continue;
       }
+      if (okResponseBuilder != null && javaHeader.getValue().size() == 1) {
+        if (name.equals(OkHeaders.SENT_MILLIS)) {
+          okResponseBuilder.sentRequestAtMillis(Long.valueOf(javaHeader.getValue().get(0)));
+          continue;
+        }
+        if (name.equals(OkHeaders.RECEIVED_MILLIS)) {
+          okResponseBuilder.receivedResponseAtMillis(Long.valueOf(javaHeader.getValue().get(0)));
+          continue;
+        }
+      }
       for (String value : javaHeader.getValue()) {
-        okHeadersBuilder.add(name, value);
+        Internal.instance.addLenient(okHeadersBuilder, name, value);
       }
     }
     return okHeadersBuilder.build();
   }
 
   /**
-   * Extracts the status line from the supplied Java API {@link java.net.HttpURLConnection}.
-   * As per the spec, the status line is held as the header with the null key. Returns {@code null}
-   * if there is no status line.
+   * Extracts the status line from the supplied Java API {@link java.net.HttpURLConnection}. As per
+   * the spec, the status line is held as the header with the null key. Returns {@code null} if
+   * there is no status line.
    */
   private static String extractStatusLine(HttpURLConnection httpUrlConnection) {
     // Java specifies that this will be be response header with a null key.
@@ -337,9 +475,9 @@ private static String extractStatusLine(HttpURLConnection httpUrlConnection) {
   }
 
   /**
-   * Extracts the status line from the supplied Java API {@link java.net.CacheResponse}.
-   * As per the spec, the status line is held as the header with the null key. Returns {@code null}
-   * if there is no status line.
+   * Extracts the status line from the supplied Java API {@link java.net.CacheResponse}. As per the
+   * spec, the status line is held as the header with the null key. Throws a {@link
+   * ProtocolException} if there is no status line.
    */
   private static String extractStatusLine(CacheResponse javaResponse) throws IOException {
     Map<String, List<String>> javaResponseHeaders = javaResponse.getHeaders();
@@ -347,10 +485,14 @@ private static String extractStatusLine(CacheResponse javaResponse) throws IOExc
   }
 
   // VisibleForTesting
-  static String extractStatusLine(Map<String, List<String>> javaResponseHeaders) {
+  static String extractStatusLine(Map<String, List<String>> javaResponseHeaders)
+      throws ProtocolException {
     List<String> values = javaResponseHeaders.get(null);
     if (values == null || values.size() == 0) {
-      return null;
+      // The status line is missing. This suggests a badly behaving cache.
+      throw new ProtocolException(
+          "CacheResponse is missing a \'null\' header containing the status line. Headers="
+              + javaResponseHeaders);
     }
     return values.get(0);
   }
@@ -359,10 +501,9 @@ static String extractStatusLine(Map<String, List<String>> javaResponseHeaders) {
    * Creates an OkHttp Response.Body containing the supplied information.
    */
   private static ResponseBody createOkBody(final Headers okHeaders,
-      final CacheResponse cacheResponse) {
+      final CacheResponse cacheResponse) throws IOException {
+    final BufferedSource body = Okio.buffer(Okio.source(cacheResponse.getBody()));
     return new ResponseBody() {
-      private BufferedSource body;
-
       @Override
       public MediaType contentType() {
         String contentTypeHeader = okHeaders.get("Content-Type");
@@ -373,11 +514,8 @@ public MediaType contentType() {
       public long contentLength() {
         return OkHeaders.contentLength(okHeaders);
       }
-      @Override public BufferedSource source() throws IOException {
-        if (body == null) {
-          InputStream is = cacheResponse.getBody();
-          body = Okio.buffer(Okio.source(is));
-        }
+
+      @Override public BufferedSource source() {
         return body;
       }
     };
@@ -386,36 +524,34 @@ public long contentLength() {
   /**
    * Creates an OkHttp Response.Body containing the supplied information.
    */
-  private static ResponseBody createOkBody(final URLConnection urlConnection) {
+  private static ResponseBody createOkBody(final URLConnection urlConnection) throws IOException {
     if (!urlConnection.getDoInput()) {
       return null;
     }
-    return new ResponseBody() {
-      private BufferedSource body;
 
+    final BufferedSource body = Okio.buffer(Okio.source(urlConnection.getInputStream()));
+    return new ResponseBody() {
       @Override public MediaType contentType() {
         String contentTypeHeader = urlConnection.getContentType();
         return contentTypeHeader == null ? null : MediaType.parse(contentTypeHeader);
       }
+
       @Override public long contentLength() {
         String s = urlConnection.getHeaderField("Content-Length");
         return stringToLong(s);
       }
-      @Override public BufferedSource source() throws IOException {
-        if (body == null) {
-          InputStream is = urlConnection.getInputStream();
-          body = Okio.buffer(Okio.source(is));
-        }
+
+      @Override public BufferedSource source() {
         return body;
       }
     };
   }
 
   /**
-   * An {@link java.net.HttpURLConnection} that represents an HTTP request at the point where
-   * the request has been made, and the response headers have been received, but the body content,
-   * if present, has not been read yet. This intended to provide enough information for
-   * {@link java.net.ResponseCache} subclasses and no more.
+   * An {@link java.net.HttpURLConnection} that represents an HTTP request at the point where the
+   * request has been made, and the response headers have been received, but the body content, if
+   * present, has not been read yet. This intended to provide enough information for {@link
+   * java.net.ResponseCache} subclasses and no more.
    *
    * <p>Much of the method implementations are overrides to delegate to the OkHttp request and
    * response, or to deny access to information as a real HttpURLConnection would after connection.
@@ -426,7 +562,7 @@ private static ResponseBody createOkBody(final URLConnection urlConnection) {
     private final Response response;
 
     public CacheHttpURLConnection(Response response) {
-      super(response.request().url());
+      super(response.request().url().url());
       this.request = response.request();
       this.response = response;
 
@@ -471,9 +607,11 @@ public String getRequestProperty(String key) {
 
     @Override
     public Map<String, List<String>> getRequestProperties() {
-      // This is to preserve RI and compatibility with OkHttp's HttpURLConnectionImpl. There seems
-      // no good reason why this should fail while getRequestProperty() is ok.
-      throw throwRequestHeaderAccessException();
+      // The RI and OkHttp's HttpURLConnectionImpl fail this call after connect() as required by the
+      // spec. There seems no good reason why this should fail while getRequestProperty() is ok.
+      // We don't fail here, because we need all request header values for caching Vary responses
+      // correctly.
+      return JavaNetHeaders.toMultimap(request.headers(), null);
     }
 
     @Override
@@ -520,7 +658,7 @@ public String getHeaderFieldKey(int position) {
       if (position < 0) {
         throw new IllegalArgumentException("Invalid header index: " + position);
       }
-      if (position == 0) {
+      if (position == 0 || position > response.headers().size()) {
         return null;
       }
       return response.headers().name(position - 1);
@@ -535,6 +673,9 @@ public String getHeaderField(int position) {
       if (position == 0) {
         return StatusLine.get(response).toString();
       }
+      if (position > response.headers().size()) {
+        return null;
+      }
       return response.headers().value(position - 1);
     }
 
@@ -547,7 +688,7 @@ public String getHeaderField(String fieldName) {
 
     @Override
     public Map<String, List<String>> getHeaderFields() {
-      return OkHeaders.toMultimap(response.headers(), StatusLine.get(response).toString());
+      return JavaNetHeaders.toMultimap(response.headers(), StatusLine.get(response).toString());
     }
 
     @Override
@@ -610,7 +751,11 @@ public Object getContent(Class[] classes) throws IOException {
 
     @Override
     public InputStream getInputStream() throws IOException {
-      throw throwResponseBodyAccessException();
+      return new InputStream() {
+        @Override public int read() throws IOException {
+          throw throwResponseBodyAccessException();
+        }
+      };
     }
 
     @Override
diff --git a/okhttp-android-support/src/test/java/com/squareup/okhttp/internal/huc/ResponseCacheTest.java b/okhttp-android-support/src/test/java/com/squareup/okhttp/internal/huc/ResponseCacheTest.java
deleted file mode 100644
index 3c91fb5851..0000000000
--- a/okhttp-android-support/src/test/java/com/squareup/okhttp/internal/huc/ResponseCacheTest.java
+++ /dev/null
@@ -1,1703 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.squareup.okhttp.internal.huc;
-
-import com.squareup.okhttp.AbstractResponseCache;
-import com.squareup.okhttp.Headers;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.OkUrlFactory;
-import com.squareup.okhttp.internal.Internal;
-import com.squareup.okhttp.internal.SslContextBuilder;
-import com.squareup.okhttp.internal.http.HttpDate;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-import com.squareup.okhttp.mockwebserver.RecordedRequest;
-import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
-import java.io.BufferedReader;
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.io.OutputStream;
-import java.net.CacheRequest;
-import java.net.CacheResponse;
-import java.net.CookieManager;
-import java.net.HttpCookie;
-import java.net.HttpURLConnection;
-import java.net.ResponseCache;
-import java.net.SecureCacheResponse;
-import java.net.URI;
-import java.net.URISyntaxException;
-import java.net.URL;
-import java.net.URLConnection;
-import java.security.Principal;
-import java.security.cert.Certificate;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Date;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.atomic.AtomicReference;
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.HttpsURLConnection;
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLPeerUnverifiedException;
-import javax.net.ssl.SSLSession;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.GzipSink;
-import okio.Okio;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-
-import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-/** Tests the interaction between OkHttp and {@link ResponseCache}. */
-public final class ResponseCacheTest {
-  private static final HostnameVerifier NULL_HOSTNAME_VERIFIER = new HostnameVerifier() {
-    @Override public boolean verify(String s, SSLSession sslSession) {
-      return true;
-    }
-  };
-
-  private static final SSLContext sslContext = SslContextBuilder.localhost();
-
-  @Rule public MockWebServerRule serverRule = new MockWebServerRule();
-  @Rule public MockWebServerRule server2Rule = new MockWebServerRule();
-
-  private OkHttpClient client;
-  private MockWebServer server;
-  private MockWebServer server2;
-  private ResponseCache cache;
-
-  @Before public void setUp() throws Exception {
-    server = serverRule.get();
-    server.setProtocolNegotiationEnabled(false);
-    server2 = server2Rule.get();
-
-    client = new OkHttpClient();
-    cache = new InMemoryResponseCache();
-    Internal.instance.setCache(client, new CacheAdapter(cache));
-  }
-
-  @After public void tearDown() throws Exception {
-    CookieManager.setDefault(null);
-  }
-
-  private HttpURLConnection openConnection(URL url) {
-    return new OkUrlFactory(client).open(url);
-  }
-
-  @Test public void responseCachingAndInputStreamSkipWithFixedLength() throws IOException {
-    testResponseCaching(TransferKind.FIXED_LENGTH);
-  }
-
-  @Test public void responseCachingAndInputStreamSkipWithChunkedEncoding() throws IOException {
-    testResponseCaching(TransferKind.CHUNKED);
-  }
-
-  @Test public void responseCachingAndInputStreamSkipWithNoLengthHeaders() throws IOException {
-    testResponseCaching(TransferKind.END_OF_STREAM);
-  }
-
-  /**
-   * HttpURLConnection.getInputStream().skip(long) causes ResponseCache corruption
-   * http://code.google.com/p/android/issues/detail?id=8175
-   */
-  private void testResponseCaching(TransferKind transferKind) throws IOException {
-    MockResponse response =
-        new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-            .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-            .setStatus("HTTP/1.1 200 Fantastic");
-    transferKind.setBody(response, "I love puppies but hate spiders", 1);
-    server.enqueue(response);
-
-    // Make sure that calling skip() doesn't omit bytes from the cache.
-    HttpURLConnection urlConnection = openConnection(server.getUrl("/"));
-    InputStream in = urlConnection.getInputStream();
-    assertEquals("I love ", readAscii(urlConnection, "I love ".length()));
-    reliableSkip(in, "puppies but hate ".length());
-    assertEquals("spiders", readAscii(urlConnection, "spiders".length()));
-    assertEquals(-1, in.read());
-    in.close();
-
-    urlConnection = openConnection(server.getUrl("/")); // cached!
-    in = urlConnection.getInputStream();
-    assertEquals("I love puppies but hate spiders",
-        readAscii(urlConnection, "I love puppies but hate spiders".length()));
-    assertEquals(200, urlConnection.getResponseCode());
-    assertEquals("Fantastic", urlConnection.getResponseMessage());
-
-    assertEquals(-1, in.read());
-    in.close();
-  }
-
-  @Test public void responseCachingWithoutBody() throws IOException {
-    MockResponse response =
-        new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-            .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-            .setStatus("HTTP/1.1 200 Fantastic");
-    server.enqueue(response);
-
-    // Make sure that calling skip() doesn't omit bytes from the cache.
-    HttpURLConnection urlConnection = openConnection(server.getUrl("/"));
-    assertEquals(200, urlConnection.getResponseCode());
-    assertEquals("Fantastic", urlConnection.getResponseMessage());
-    assertTrue(urlConnection.getDoInput());
-    InputStream is = urlConnection.getInputStream();
-    assertEquals(-1, is.read());
-    is.close();
-
-    urlConnection = openConnection(server.getUrl("/")); // cached!
-    assertTrue(urlConnection.getDoInput());
-    InputStream cachedIs = urlConnection.getInputStream();
-    assertEquals(-1, cachedIs.read());
-    cachedIs.close();
-    assertEquals(200, urlConnection.getResponseCode());
-    assertEquals("Fantastic", urlConnection.getResponseMessage());
-  }
-
-  @Test public void secureResponseCaching() throws IOException {
-    server.useHttps(sslContext.getSocketFactory(), false);
-    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setBody("ABC"));
-
-    HttpsURLConnection c1 = (HttpsURLConnection) openConnection(server.getUrl("/"));
-    c1.setSSLSocketFactory(sslContext.getSocketFactory());
-    c1.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
-    assertEquals("ABC", readAscii(c1));
-
-    // OpenJDK 6 fails on this line, complaining that the connection isn't open yet
-    String suite = c1.getCipherSuite();
-    List<Certificate> localCerts = toListOrNull(c1.getLocalCertificates());
-    List<Certificate> serverCerts = toListOrNull(c1.getServerCertificates());
-    Principal peerPrincipal = c1.getPeerPrincipal();
-    Principal localPrincipal = c1.getLocalPrincipal();
-
-    HttpsURLConnection c2 = (HttpsURLConnection) openConnection(server.getUrl("/")); // cached!
-    c2.setSSLSocketFactory(sslContext.getSocketFactory());
-    c2.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
-    assertEquals("ABC", readAscii(c2));
-
-    assertEquals(suite, c2.getCipherSuite());
-    assertEquals(localCerts, toListOrNull(c2.getLocalCertificates()));
-    assertEquals(serverCerts, toListOrNull(c2.getServerCertificates()));
-    assertEquals(peerPrincipal, c2.getPeerPrincipal());
-    assertEquals(localPrincipal, c2.getLocalPrincipal());
-  }
-
-  @Test public void cacheReturnsInsecureResponseForSecureRequest() throws IOException {
-    server.useHttps(sslContext.getSocketFactory(), false);
-    server.enqueue(new MockResponse().setBody("ABC"));
-    server.enqueue(new MockResponse().setBody("DEF"));
-
-    Internal.instance.setCache(client,
-        new CacheAdapter(new InsecureResponseCache(new InMemoryResponseCache())));
-
-    HttpsURLConnection connection1 = (HttpsURLConnection) openConnection(server.getUrl("/"));
-    connection1.setSSLSocketFactory(sslContext.getSocketFactory());
-    connection1.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
-    assertEquals("ABC", readAscii(connection1));
-
-    // Not cached!
-    HttpsURLConnection connection2 = (HttpsURLConnection) openConnection(server.getUrl("/"));
-    connection2.setSSLSocketFactory(sslContext.getSocketFactory());
-    connection2.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
-    assertEquals("DEF", readAscii(connection2));
-  }
-
-  @Test public void responseCachingAndRedirects() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
-        .addHeader("Location: /foo"));
-    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setBody("ABC"));
-    server.enqueue(new MockResponse().setBody("DEF"));
-
-    HttpURLConnection connection = openConnection(server.getUrl("/"));
-    assertEquals("ABC", readAscii(connection));
-
-    connection = openConnection(server.getUrl("/")); // cached!
-    assertEquals("ABC", readAscii(connection));
-  }
-
-  @Test public void redirectToCachedResult() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60").setBody("ABC"));
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
-        .addHeader("Location: /foo"));
-    server.enqueue(new MockResponse().setBody("DEF"));
-
-    assertEquals("ABC", readAscii(openConnection(server.getUrl("/foo"))));
-    RecordedRequest request1 = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", request1.getRequestLine());
-    assertEquals(0, request1.getSequenceNumber());
-
-    assertEquals("ABC", readAscii(openConnection(server.getUrl("/bar"))));
-    RecordedRequest request2 = server.takeRequest();
-    assertEquals("GET /bar HTTP/1.1", request2.getRequestLine());
-    assertEquals(1, request2.getSequenceNumber());
-
-    // an unrelated request should reuse the pooled connection
-    assertEquals("DEF", readAscii(openConnection(server.getUrl("/baz"))));
-    RecordedRequest request3 = server.takeRequest();
-    assertEquals("GET /baz HTTP/1.1", request3.getRequestLine());
-    assertEquals(2, request3.getSequenceNumber());
-  }
-
-  @Test public void secureResponseCachingAndRedirects() throws IOException {
-    server.useHttps(sslContext.getSocketFactory(), false);
-    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
-        .addHeader("Location: /foo"));
-    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setBody("ABC"));
-    server.enqueue(new MockResponse().setBody("DEF"));
-
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
-
-    HttpsURLConnection connection1 = (HttpsURLConnection) openConnection(server.getUrl("/"));
-    assertEquals("ABC", readAscii(connection1));
-    assertNotNull(connection1.getCipherSuite());
-
-    // Cached!
-    HttpsURLConnection connection2 = (HttpsURLConnection) openConnection(server.getUrl("/"));
-    assertEquals("ABC", readAscii(connection2));
-    assertNotNull(connection2.getCipherSuite());
-
-    assertEquals(connection1.getCipherSuite(), connection2.getCipherSuite());
-  }
-
-  /**
-   * We've had bugs where caching and cross-protocol redirects yield class
-   * cast exceptions internal to the cache because we incorrectly assumed that
-   * HttpsURLConnection was always HTTPS and HttpURLConnection was always HTTP;
-   * in practice redirects mean that each can do either.
-   *
-   * https://github.com/square/okhttp/issues/214
-   */
-  @Test public void secureResponseCachingAndProtocolRedirects() throws IOException {
-    server2.useHttps(sslContext.getSocketFactory(), false);
-    server2.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setBody("ABC"));
-    server2.enqueue(new MockResponse().setBody("DEF"));
-
-    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
-        .addHeader("Location: " + server2.getUrl("/")));
-
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
-
-    HttpURLConnection connection1 = openConnection(server.getUrl("/"));
-    assertEquals("ABC", readAscii(connection1));
-
-    // Cached!
-    HttpURLConnection connection2 = openConnection(server.getUrl("/"));
-    assertEquals("ABC", readAscii(connection2));
-  }
-
-  @Test public void responseCacheRequestHeaders() throws IOException, URISyntaxException {
-    server.enqueue(new MockResponse().setBody("ABC"));
-
-    final AtomicReference<Map<String, List<String>>> requestHeadersRef =
-        new AtomicReference<Map<String, List<String>>>();
-    Internal.instance.setCache(client, new CacheAdapter(new AbstractResponseCache() {
-      @Override public CacheResponse get(URI uri, String requestMethod,
-          Map<String, List<String>> requestHeaders) throws IOException {
-        requestHeadersRef.set(requestHeaders);
-        return null;
-      }
-    }));
-
-    URL url = server.getUrl("/");
-    URLConnection urlConnection = openConnection(url);
-    urlConnection.addRequestProperty("A", "android");
-    readAscii(urlConnection);
-    assertEquals(Arrays.asList("android"), requestHeadersRef.get().get("A"));
-  }
-
-  @Test public void serverDisconnectsPrematurelyWithContentLengthHeader() throws IOException {
-    testServerPrematureDisconnect(TransferKind.FIXED_LENGTH);
-  }
-
-  @Test public void serverDisconnectsPrematurelyWithChunkedEncoding() throws IOException {
-    testServerPrematureDisconnect(TransferKind.CHUNKED);
-  }
-
-  @Test public void serverDisconnectsPrematurelyWithNoLengthHeaders() throws IOException {
-    // Intentionally empty. This case doesn't make sense because there's no
-    // such thing as a premature disconnect when the disconnect itself
-    // indicates the end of the data stream.
-  }
-
-  private void testServerPrematureDisconnect(TransferKind transferKind) throws IOException {
-    MockResponse response = new MockResponse();
-    transferKind.setBody(response, "ABCDE\nFGHIJKLMNOPQRSTUVWXYZ", 16);
-    server.enqueue(truncateViolently(response, 16));
-    server.enqueue(new MockResponse().setBody("Request #2"));
-
-    BufferedReader reader = new BufferedReader(
-        new InputStreamReader(openConnection(server.getUrl("/")).getInputStream()));
-    assertEquals("ABCDE", reader.readLine());
-    try {
-      reader.readLine();
-      fail("This implementation silently ignored a truncated HTTP body.");
-    } catch (IOException expected) {
-    } finally {
-      reader.close();
-    }
-
-    URLConnection connection = openConnection(server.getUrl("/"));
-    assertEquals("Request #2", readAscii(connection));
-  }
-
-  @Test public void clientPrematureDisconnectWithContentLengthHeader() throws IOException {
-    testClientPrematureDisconnect(TransferKind.FIXED_LENGTH);
-  }
-
-  @Test public void clientPrematureDisconnectWithChunkedEncoding() throws IOException {
-    testClientPrematureDisconnect(TransferKind.CHUNKED);
-  }
-
-  @Test public void clientPrematureDisconnectWithNoLengthHeaders() throws IOException {
-    testClientPrematureDisconnect(TransferKind.END_OF_STREAM);
-  }
-
-  private void testClientPrematureDisconnect(TransferKind transferKind) throws IOException {
-    // Setting a low transfer speed ensures that stream discarding will time out.
-    MockResponse response = new MockResponse().throttleBody(6, 1, TimeUnit.SECONDS);
-    transferKind.setBody(response, "ABCDE\nFGHIJKLMNOPQRSTUVWXYZ", 1024);
-    server.enqueue(response);
-    server.enqueue(new MockResponse().setBody("Request #2"));
-
-    URLConnection connection = openConnection(server.getUrl("/"));
-    InputStream in = connection.getInputStream();
-    assertEquals("ABCDE", readAscii(connection, 5));
-    in.close();
-    try {
-      in.read();
-      fail("Expected an IOException because the stream is closed.");
-    } catch (IOException expected) {
-    }
-
-    connection = openConnection(server.getUrl("/"));
-    assertEquals("Request #2", readAscii(connection));
-  }
-
-  @Test public void defaultExpirationDateFullyCachedForLessThan24Hours() throws Exception {
-    //      last modified: 105 seconds ago
-    //             served:   5 seconds ago
-    //   default lifetime: (105 - 5) / 10 = 10 seconds
-    //            expires:  10 seconds from served date = 5 seconds from now
-    server.enqueue(
-        new MockResponse().addHeader("Last-Modified: " + formatDate(-105, TimeUnit.SECONDS))
-            .addHeader("Date: " + formatDate(-5, TimeUnit.SECONDS))
-            .setBody("A"));
-
-    URL url = server.getUrl("/");
-    assertEquals("A", readAscii(openConnection(url)));
-    URLConnection connection = openConnection(url);
-    assertEquals("A", readAscii(connection));
-    assertNull(connection.getHeaderField("Warning"));
-  }
-
-  @Test public void defaultExpirationDateConditionallyCached() throws Exception {
-    //      last modified: 115 seconds ago
-    //             served:  15 seconds ago
-    //   default lifetime: (115 - 15) / 10 = 10 seconds
-    //            expires:  10 seconds from served date = 5 seconds ago
-    String lastModifiedDate = formatDate(-115, TimeUnit.SECONDS);
-    RecordedRequest conditionalRequest = assertConditionallyCached(
-        new MockResponse().addHeader("Last-Modified: " + lastModifiedDate)
-            .addHeader("Date: " + formatDate(-15, TimeUnit.SECONDS)));
-    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
-  }
-
-  @Test public void defaultExpirationDateFullyCachedForMoreThan24Hours() throws Exception {
-    //      last modified: 105 days ago
-    //             served:   5 days ago
-    //   default lifetime: (105 - 5) / 10 = 10 days
-    //            expires:  10 days from served date = 5 days from now
-    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-105, TimeUnit.DAYS))
-        .addHeader("Date: " + formatDate(-5, TimeUnit.DAYS))
-        .setBody("A"));
-
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-    URLConnection connection = openConnection(server.getUrl("/"));
-    assertEquals("A", readAscii(connection));
-    assertEquals("113 HttpURLConnection \"Heuristic expiration\"",
-        connection.getHeaderField("Warning"));
-  }
-
-  @Test public void noDefaultExpirationForUrlsWithQueryString() throws Exception {
-    server.enqueue(
-        new MockResponse().addHeader("Last-Modified: " + formatDate(-105, TimeUnit.SECONDS))
-            .addHeader("Date: " + formatDate(-5, TimeUnit.SECONDS))
-            .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    URL url = server.getUrl("/?foo=bar");
-    assertEquals("A", readAscii(openConnection(url)));
-    assertEquals("B", readAscii(openConnection(url)));
-  }
-
-  @Test public void expirationDateInThePastWithLastModifiedHeader() throws Exception {
-    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
-    RecordedRequest conditionalRequest = assertConditionallyCached(
-        new MockResponse().addHeader("Last-Modified: " + lastModifiedDate)
-            .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
-  }
-
-  @Test public void expirationDateInThePastWithNoLastModifiedHeader() throws Exception {
-    assertNotCached(new MockResponse().addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-  }
-
-  @Test public void expirationDateInTheFuture() throws Exception {
-    assertFullyCached(new MockResponse().addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
-  }
-
-  @Test public void maxAgePreferredWithMaxAgeAndExpires() throws Exception {
-    assertFullyCached(new MockResponse().addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void maxAgeInThePastWithDateAndLastModifiedHeaders() throws Exception {
-    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
-    RecordedRequest conditionalRequest = assertConditionallyCached(
-        new MockResponse().addHeader("Date: " + formatDate(-120, TimeUnit.SECONDS))
-            .addHeader("Last-Modified: " + lastModifiedDate)
-            .addHeader("Cache-Control: max-age=60"));
-    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
-  }
-
-  @Test public void maxAgeInThePastWithDateHeaderButNoLastModifiedHeader() throws Exception {
-    // Chrome interprets max-age relative to the local clock. Both our cache
-    // and Firefox both use the earlier of the local and server's clock.
-    assertNotCached(new MockResponse().addHeader("Date: " + formatDate(-120, TimeUnit.SECONDS))
-        .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void maxAgeInTheFutureWithDateHeader() throws Exception {
-    assertFullyCached(new MockResponse().addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void maxAgeInTheFutureWithNoDateHeader() throws Exception {
-    assertFullyCached(new MockResponse().addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void maxAgeWithLastModifiedButNoServedDate() throws Exception {
-    assertFullyCached(
-        new MockResponse().addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
-            .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void maxAgeInTheFutureWithDateAndLastModifiedHeaders() throws Exception {
-    assertFullyCached(
-        new MockResponse().addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
-            .addHeader("Date: " + formatDate(0, TimeUnit.SECONDS))
-            .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void maxAgePreferredOverLowerSharedMaxAge() throws Exception {
-    assertFullyCached(new MockResponse().addHeader("Date: " + formatDate(-2, TimeUnit.MINUTES))
-        .addHeader("Cache-Control: s-maxage=60")
-        .addHeader("Cache-Control: max-age=180"));
-  }
-
-  @Test public void maxAgePreferredOverHigherMaxAge() throws Exception {
-    assertNotCached(new MockResponse().addHeader("Date: " + formatDate(-2, TimeUnit.MINUTES))
-        .addHeader("Cache-Control: s-maxage=180")
-        .addHeader("Cache-Control: max-age=60"));
-  }
-
-  /**
-   * Tests that the ResponseCache can cache something. The InMemoryResponseCache only caches GET
-   * requests.
-   */
-  @Test public void responseCacheCanCache() throws Exception {
-    testRequestMethod("GET", true);
-  }
-
-  /**
-   * Confirm the ResponseCache can elect to not cache something. The InMemoryResponseCache only
-   * caches GET requests.
-   */
-  @Test public void responseCacheCanIgnore() throws Exception {
-    testRequestMethod("HEAD", false);
-  }
-
-  private void testRequestMethod(String requestMethod, boolean expectCached) throws Exception {
-    // 1. seed the cache (potentially)
-    // 2. expect a cache hit or miss
-    server.enqueue(new MockResponse().addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .addHeader("X-Response-ID: 1"));
-    server.enqueue(new MockResponse().addHeader("X-Response-ID: 2"));
-
-    URL url = server.getUrl("/");
-
-    HttpURLConnection request1 = openConnection(url);
-    request1.setRequestMethod(requestMethod);
-    addRequestBodyIfNecessary(requestMethod, request1);
-    request1.getInputStream().close();
-    assertEquals("1", request1.getHeaderField("X-Response-ID"));
-
-    URLConnection request2 = openConnection(url);
-    request2.getInputStream().close();
-    if (expectCached) {
-      assertEquals("1", request2.getHeaderField("X-Response-ID"));
-    } else {
-      assertEquals("2", request2.getHeaderField("X-Response-ID"));
-    }
-  }
-
-  /**
-   * Equivalent to {@code CacheTest.postInvalidatesCacheWithUncacheableResponse()} but demonstrating
-   * that {@link ResponseCache} provides no mechanism for cache invalidation as the result of
-   * locally-made requests. In reality invalidation could take place from other clients at any time.
-   */
-  @Test public void postInvalidatesCacheWithUncacheableResponse() throws Exception {
-    // 1. seed the cache
-    // 2. invalidate it with uncacheable response
-    // 3. the cache to return the original value
-    server.enqueue(
-        new MockResponse().setBody("A").addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
-    server.enqueue(new MockResponse().setBody("B").setResponseCode(500));
-
-    URL url = server.getUrl("/");
-
-    assertEquals("A", readAscii(openConnection(url)));
-
-    HttpURLConnection invalidate = openConnection(url);
-    invalidate.setRequestMethod("POST");
-    addRequestBodyIfNecessary("POST", invalidate);
-    assertEquals("B", readAscii(invalidate));
-
-    assertEquals("A", readAscii(openConnection(url)));
-  }
-
-  @Test public void etag() throws Exception {
-    RecordedRequest conditionalRequest =
-        assertConditionallyCached(new MockResponse().addHeader("ETag: v1"));
-    assertEquals("v1", conditionalRequest.getHeader("If-None-Match"));
-  }
-
-  @Test public void etagAndExpirationDateInThePast() throws Exception {
-    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
-    RecordedRequest conditionalRequest = assertConditionallyCached(
-        new MockResponse().addHeader("ETag: v1")
-            .addHeader("Last-Modified: " + lastModifiedDate)
-            .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-    assertEquals("v1", conditionalRequest.getHeader("If-None-Match"));
-    assertNull(conditionalRequest.getHeader("If-Modified-Since"));
-  }
-
-  @Test public void etagAndExpirationDateInTheFuture() throws Exception {
-    assertFullyCached(new MockResponse().addHeader("ETag: v1")
-        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
-  }
-
-  @Test public void cacheControlNoCache() throws Exception {
-    assertNotCached(new MockResponse().addHeader("Cache-Control: no-cache"));
-  }
-
-  @Test public void cacheControlNoCacheAndExpirationDateInTheFuture() throws Exception {
-    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
-    RecordedRequest conditionalRequest = assertConditionallyCached(
-        new MockResponse().addHeader("Last-Modified: " + lastModifiedDate)
-            .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-            .addHeader("Cache-Control: no-cache"));
-    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
-  }
-
-  @Test public void pragmaNoCache() throws Exception {
-    assertNotCached(new MockResponse().addHeader("Pragma: no-cache"));
-  }
-
-  @Test public void pragmaNoCacheAndExpirationDateInTheFuture() throws Exception {
-    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
-    RecordedRequest conditionalRequest = assertConditionallyCached(
-        new MockResponse().addHeader("Last-Modified: " + lastModifiedDate)
-            .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-            .addHeader("Pragma: no-cache"));
-    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
-  }
-
-  @Test public void cacheControlNoStore() throws Exception {
-    assertNotCached(new MockResponse().addHeader("Cache-Control: no-store"));
-  }
-
-  @Test public void cacheControlNoStoreAndExpirationDateInTheFuture() throws Exception {
-    assertNotCached(new MockResponse().addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: no-store"));
-  }
-
-  @Test public void partialRangeResponsesDoNotCorruptCache() throws Exception {
-    // 1. request a range
-    // 2. request a full document, expecting a cache miss
-    server.enqueue(new MockResponse().setBody("AA")
-        .setResponseCode(HttpURLConnection.HTTP_PARTIAL)
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .addHeader("Content-Range: bytes 1000-1001/2000"));
-    server.enqueue(new MockResponse().setBody("BB"));
-
-    URL url = server.getUrl("/");
-
-    URLConnection range = openConnection(url);
-    range.addRequestProperty("Range", "bytes=1000-1001");
-    assertEquals("AA", readAscii(range));
-
-    assertEquals("BB", readAscii(openConnection(url)));
-  }
-
-  @Test public void serverReturnsDocumentOlderThanCache() throws Exception {
-    server.enqueue(new MockResponse().setBody("A")
-        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-    server.enqueue(new MockResponse().setBody("B")
-        .addHeader("Last-Modified: " + formatDate(-4, TimeUnit.HOURS)));
-
-    URL url = server.getUrl("/");
-
-    assertEquals("A", readAscii(openConnection(url)));
-    assertEquals("A", readAscii(openConnection(url)));
-  }
-
-  @Test public void nonIdentityEncodingAndConditionalCache() throws Exception {
-    assertNonIdentityEncodingCached(
-        new MockResponse().addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-            .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-  }
-
-  @Test public void nonIdentityEncodingAndFullCache() throws Exception {
-    assertNonIdentityEncodingCached(
-        new MockResponse().addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-            .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
-  }
-
-  private void assertNonIdentityEncodingCached(MockResponse response) throws Exception {
-    server.enqueue(
-        response.setBody(gzip("ABCABCABC")).addHeader("Content-Encoding: gzip"));
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    // At least three request/response pairs are required because after the first request is cached
-    // a different execution path might be taken. Thus modifications to the cache applied during
-    // the second request might not be visible until another request is performed.
-    assertEquals("ABCABCABC", readAscii(openConnection(server.getUrl("/"))));
-    assertEquals("ABCABCABC", readAscii(openConnection(server.getUrl("/"))));
-    assertEquals("ABCABCABC", readAscii(openConnection(server.getUrl("/"))));
-  }
-
-  @Test public void notModifiedSpecifiesEncoding() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody(gzip("ABCABCABC"))
-        .addHeader("Content-Encoding: gzip")
-        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED)
-        .addHeader("Content-Encoding: gzip"));
-    server.enqueue(new MockResponse()
-        .setBody("DEFDEFDEF"));
-
-    assertEquals("ABCABCABC", readAscii(openConnection(server.getUrl("/"))));
-    assertEquals("ABCABCABC", readAscii(openConnection(server.getUrl("/"))));
-    assertEquals("DEFDEFDEF", readAscii(openConnection(server.getUrl("/"))));
-  }
-
-  @Test public void expiresDateBeforeModifiedDate() throws Exception {
-    assertConditionallyCached(
-        new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-            .addHeader("Expires: " + formatDate(-2, TimeUnit.HOURS)));
-  }
-
-  @Test public void requestMaxAge() throws IOException {
-    server.enqueue(new MockResponse().setBody("A")
-        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-        .addHeader("Date: " + formatDate(-1, TimeUnit.MINUTES))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-
-    URLConnection connection = openConnection(server.getUrl("/"));
-    connection.addRequestProperty("Cache-Control", "max-age=30");
-    assertEquals("B", readAscii(connection));
-  }
-
-  @Test public void requestMinFresh() throws IOException {
-    server.enqueue(new MockResponse().setBody("A")
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-
-    URLConnection connection = openConnection(server.getUrl("/"));
-    connection.addRequestProperty("Cache-Control", "min-fresh=120");
-    assertEquals("B", readAscii(connection));
-  }
-
-  @Test public void requestMaxStale() throws IOException {
-    server.enqueue(new MockResponse().setBody("A")
-        .addHeader("Cache-Control: max-age=120")
-        .addHeader("Date: " + formatDate(-4, TimeUnit.MINUTES)));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-
-    URLConnection connection = openConnection(server.getUrl("/"));
-    connection.addRequestProperty("Cache-Control", "max-stale=180");
-    assertEquals("A", readAscii(connection));
-    assertEquals("110 HttpURLConnection \"Response is stale\"",
-        connection.getHeaderField("Warning"));
-  }
-
-  @Test public void requestMaxStaleNotHonoredWithMustRevalidate() throws IOException {
-    server.enqueue(new MockResponse().setBody("A")
-        .addHeader("Cache-Control: max-age=120, must-revalidate")
-        .addHeader("Date: " + formatDate(-4, TimeUnit.MINUTES)));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-
-    URLConnection connection = openConnection(server.getUrl("/"));
-    connection.addRequestProperty("Cache-Control", "max-stale=180");
-    assertEquals("B", readAscii(connection));
-  }
-
-  @Test public void requestOnlyIfCachedWithNoResponseCached() throws IOException {
-    // (no responses enqueued)
-
-    HttpURLConnection connection = openConnection(server.getUrl("/"));
-    connection.addRequestProperty("Cache-Control", "only-if-cached");
-    assertGatewayTimeout(connection);
-  }
-
-  @Test public void requestOnlyIfCachedWithFullResponseCached() throws IOException {
-    server.enqueue(new MockResponse().setBody("A")
-        .addHeader("Cache-Control: max-age=30")
-        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
-
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-    URLConnection connection = openConnection(server.getUrl("/"));
-    connection.addRequestProperty("Cache-Control", "only-if-cached");
-    assertEquals("A", readAscii(connection));
-  }
-
-  @Test public void requestOnlyIfCachedWithConditionalResponseCached() throws IOException {
-    server.enqueue(new MockResponse().setBody("A")
-        .addHeader("Cache-Control: max-age=30")
-        .addHeader("Date: " + formatDate(-1, TimeUnit.MINUTES)));
-
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-    HttpURLConnection connection = openConnection(server.getUrl("/"));
-    connection.addRequestProperty("Cache-Control", "only-if-cached");
-    assertGatewayTimeout(connection);
-  }
-
-  @Test public void requestOnlyIfCachedWithUnhelpfulResponseCached() throws IOException {
-    server.enqueue(new MockResponse().setBody("A"));
-
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-    HttpURLConnection connection = openConnection(server.getUrl("/"));
-    connection.addRequestProperty("Cache-Control", "only-if-cached");
-    assertGatewayTimeout(connection);
-  }
-
-  @Test public void requestCacheControlNoCache() throws Exception {
-    server.enqueue(
-        new MockResponse().addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
-            .addHeader("Date: " + formatDate(0, TimeUnit.SECONDS))
-            .addHeader("Cache-Control: max-age=60")
-            .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    URL url = server.getUrl("/");
-    assertEquals("A", readAscii(openConnection(url)));
-    URLConnection connection = openConnection(url);
-    connection.setRequestProperty("Cache-Control", "no-cache");
-    assertEquals("B", readAscii(connection));
-  }
-
-  @Test public void requestPragmaNoCache() throws Exception {
-    server.enqueue(
-        new MockResponse().addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
-            .addHeader("Date: " + formatDate(0, TimeUnit.SECONDS))
-            .addHeader("Cache-Control: max-age=60")
-            .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    URL url = server.getUrl("/");
-    assertEquals("A", readAscii(openConnection(url)));
-    URLConnection connection = openConnection(url);
-    connection.setRequestProperty("Pragma", "no-cache");
-    assertEquals("B", readAscii(connection));
-  }
-
-  @Test public void clientSuppliedIfModifiedSinceWithCachedResult() throws Exception {
-    MockResponse response =
-        new MockResponse().addHeader("ETag: v3").addHeader("Cache-Control: max-age=0");
-    String ifModifiedSinceDate = formatDate(-24, TimeUnit.HOURS);
-    RecordedRequest request =
-        assertClientSuppliedCondition(response, "If-Modified-Since", ifModifiedSinceDate);
-    assertEquals(ifModifiedSinceDate, request.getHeader("If-Modified-Since"));
-    assertNull(request.getHeader("If-None-Match"));
-  }
-
-  @Test public void clientSuppliedIfNoneMatchSinceWithCachedResult() throws Exception {
-    String lastModifiedDate = formatDate(-3, TimeUnit.MINUTES);
-    MockResponse response = new MockResponse().addHeader("Last-Modified: " + lastModifiedDate)
-        .addHeader("Date: " + formatDate(-2, TimeUnit.MINUTES))
-        .addHeader("Cache-Control: max-age=0");
-    RecordedRequest request = assertClientSuppliedCondition(response, "If-None-Match", "v1");
-    assertEquals("v1", request.getHeader("If-None-Match"));
-    assertNull(request.getHeader("If-Modified-Since"));
-  }
-
-  private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String conditionName,
-      String conditionValue) throws Exception {
-    server.enqueue(seed.setBody("A"));
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    URL url = server.getUrl("/");
-    assertEquals("A", readAscii(openConnection(url)));
-
-    HttpURLConnection connection = openConnection(url);
-    connection.addRequestProperty(conditionName, conditionValue);
-    assertEquals(HttpURLConnection.HTTP_NOT_MODIFIED, connection.getResponseCode());
-    assertEquals("", readAscii(connection));
-
-    server.takeRequest(); // seed
-    return server.takeRequest();
-  }
-
-  @Test public void setIfModifiedSince() throws Exception {
-    Date since = new Date();
-    server.enqueue(new MockResponse().setBody("A"));
-
-    URL url = server.getUrl("/");
-    URLConnection connection = openConnection(url);
-    connection.setIfModifiedSince(since.getTime());
-    assertEquals("A", readAscii(connection));
-    RecordedRequest request = server.takeRequest();
-    assertEquals(HttpDate.format(since), request.getHeader("If-Modified-Since"));
-  }
-
-  @Test public void clientSuppliedConditionWithoutCachedResult() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    HttpURLConnection connection = openConnection(server.getUrl("/"));
-    String clientIfModifiedSince = formatDate(-24, TimeUnit.HOURS);
-    connection.addRequestProperty("If-Modified-Since", clientIfModifiedSince);
-    assertEquals(HttpURLConnection.HTTP_NOT_MODIFIED, connection.getResponseCode());
-    assertEquals("", readAscii(connection));
-  }
-
-  @Test public void authorizationRequestFullyCached() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60").setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    URL url = server.getUrl("/");
-    URLConnection connection = openConnection(url);
-    connection.addRequestProperty("Authorization", "password");
-    assertEquals("A", readAscii(connection));
-    assertEquals("A", readAscii(openConnection(url)));
-  }
-
-  @Test public void contentLocationDoesNotPopulateCache() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
-        .addHeader("Content-Location: /bar")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    assertEquals("A", readAscii(openConnection(server.getUrl("/foo"))));
-    assertEquals("B", readAscii(openConnection(server.getUrl("/bar"))));
-  }
-
-  @Test public void useCachesFalseDoesNotWriteToCache() throws Exception {
-    server.enqueue(
-        new MockResponse().addHeader("Cache-Control: max-age=60").setBody("A").setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    URLConnection connection = openConnection(server.getUrl("/"));
-    connection.setUseCaches(false);
-    assertEquals("A", readAscii(connection));
-    assertEquals("B", readAscii(openConnection(server.getUrl("/"))));
-  }
-
-  @Test public void useCachesFalseDoesNotReadFromCache() throws Exception {
-    server.enqueue(
-        new MockResponse().addHeader("Cache-Control: max-age=60").setBody("A").setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-    URLConnection connection = openConnection(server.getUrl("/"));
-    connection.setUseCaches(false);
-    assertEquals("B", readAscii(connection));
-  }
-
-  @Test public void defaultUseCachesSetsInitialValueOnly() throws Exception {
-    URL url = new URL("http://localhost/");
-    URLConnection c1 = openConnection(url);
-    URLConnection c2 = openConnection(url);
-    assertTrue(c1.getDefaultUseCaches());
-    c1.setDefaultUseCaches(false);
-    try {
-      assertTrue(c1.getUseCaches());
-      assertTrue(c2.getUseCaches());
-      URLConnection c3 = openConnection(url);
-      assertFalse(c3.getUseCaches());
-    } finally {
-      c1.setDefaultUseCaches(true);
-    }
-  }
-
-  @Test public void connectionIsReturnedToPoolAfterConditionalSuccess() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    assertEquals("A", readAscii(openConnection(server.getUrl("/a"))));
-    assertEquals("A", readAscii(openConnection(server.getUrl("/a"))));
-    assertEquals("B", readAscii(openConnection(server.getUrl("/b"))));
-
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(1, server.takeRequest().getSequenceNumber());
-    assertEquals(2, server.takeRequest().getSequenceNumber());
-  }
-
-  /**
-   * Confirms the cache implementation may determine the criteria for caching. In real caches
-   * this would be the "Vary" headers.
-   */
-  @Test public void cacheCanUseCriteriaBesidesVariantObeyed() throws Exception {
-    server.enqueue(
-        new MockResponse().addHeader("Cache-Control: max-age=60")
-            .addHeader(InMemoryResponseCache.CACHE_VARIANT_HEADER, "A").setBody("A"));
-    server.enqueue(
-        new MockResponse().addHeader("Cache-Control: max-age=60")
-            .addHeader(InMemoryResponseCache.CACHE_VARIANT_HEADER, "B").setBody("B"));
-
-    URL url = server.getUrl("/");
-    URLConnection connection1 = openConnection(url);
-    connection1.addRequestProperty(InMemoryResponseCache.CACHE_VARIANT_HEADER, "A");
-    assertEquals("A", readAscii(connection1));
-    URLConnection connection2 = openConnection(url);
-    connection2.addRequestProperty(InMemoryResponseCache.CACHE_VARIANT_HEADER, "A");
-    assertEquals("A", readAscii(connection2));
-    assertEquals(1, server.getRequestCount());
-
-    URLConnection connection3 = openConnection(url);
-    connection3.addRequestProperty(InMemoryResponseCache.CACHE_VARIANT_HEADER, "B");
-    assertEquals("B", readAscii(connection3));
-    assertEquals(2, server.getRequestCount());
-
-    URLConnection connection4 = openConnection(url);
-    connection4.addRequestProperty(InMemoryResponseCache.CACHE_VARIANT_HEADER, "A");
-    assertEquals("A", readAscii(connection4));
-    assertEquals(2, server.getRequestCount());
-  }
-
-  @Test public void cachePlusCookies() throws Exception {
-    server.enqueue(new MockResponse().addHeader(
-        "Set-Cookie: a=FIRST; domain=" + server.getCookieDomain() + ";")
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse().addHeader(
-        "Set-Cookie: a=SECOND; domain=" + server.getCookieDomain() + ";")
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    CookieManager cookieManager = new CookieManager();
-    CookieManager.setDefault(cookieManager);
-
-    URL url = server.getUrl("/");
-    assertEquals("A", readAscii(openConnection(url)));
-    assertCookies(cookieManager, url, "a=FIRST");
-    assertEquals("A", readAscii(openConnection(url)));
-    assertCookies(cookieManager, url, "a=SECOND");
-  }
-
-  @Test public void getHeadersReturnsNetworkEndToEndHeaders() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Allow: GET, HEAD")
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse().addHeader("Allow: GET, HEAD, PUT")
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    URLConnection connection1 = openConnection(server.getUrl("/"));
-    assertEquals("A", readAscii(connection1));
-    assertEquals("GET, HEAD", connection1.getHeaderField("Allow"));
-
-    URLConnection connection2 = openConnection(server.getUrl("/"));
-    assertEquals("A", readAscii(connection2));
-    assertEquals("GET, HEAD, PUT", connection2.getHeaderField("Allow"));
-  }
-
-  @Test public void getHeadersReturnsCachedHopByHopHeaders() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Transfer-Encoding: identity")
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse().addHeader("Transfer-Encoding: none")
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    URLConnection connection1 = openConnection(server.getUrl("/"));
-    assertEquals("A", readAscii(connection1));
-    assertEquals("identity", connection1.getHeaderField("Transfer-Encoding"));
-
-    URLConnection connection2 = openConnection(server.getUrl("/"));
-    assertEquals("A", readAscii(connection2));
-    assertEquals("identity", connection2.getHeaderField("Transfer-Encoding"));
-  }
-
-  @Test public void getHeadersDeletesCached100LevelWarnings() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Warning: 199 test danger")
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    URLConnection connection1 = openConnection(server.getUrl("/"));
-    assertEquals("A", readAscii(connection1));
-    assertEquals("199 test danger", connection1.getHeaderField("Warning"));
-
-    URLConnection connection2 = openConnection(server.getUrl("/"));
-    assertEquals("A", readAscii(connection2));
-    assertEquals(null, connection2.getHeaderField("Warning"));
-  }
-
-  @Test public void getHeadersRetainsCached200LevelWarnings() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Warning: 299 test danger")
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    URLConnection connection1 = openConnection(server.getUrl("/"));
-    assertEquals("A", readAscii(connection1));
-    assertEquals("299 test danger", connection1.getHeaderField("Warning"));
-
-    URLConnection connection2 = openConnection(server.getUrl("/"));
-    assertEquals("A", readAscii(connection2));
-    assertEquals("299 test danger", connection2.getHeaderField("Warning"));
-  }
-
-  public void assertCookies(CookieManager cookieManager, URL url, String... expectedCookies)
-      throws Exception {
-    List<String> actualCookies = new ArrayList<String>();
-    for (HttpCookie cookie : cookieManager.getCookieStore().get(url.toURI())) {
-      actualCookies.add(cookie.toString());
-    }
-    assertEquals(Arrays.asList(expectedCookies), actualCookies);
-  }
-
-  @Test public void cachePlusRange() throws Exception {
-    assertNotCached(new MockResponse().setResponseCode(HttpURLConnection.HTTP_PARTIAL)
-        .addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
-        .addHeader("Content-Range: bytes 100-100/200")
-        .addHeader("Cache-Control: max-age=60"));
-  }
-
-  /**
-   * Equivalent to {@code CacheTest.conditionalHitUpdatesCache()}, except a Java standard cache has
-   * no means to update the headers for an existing entry so the behavior is different.
-   */
-  @Test public void conditionalHitDoesNotUpdateCache() throws Exception {
-    // A response that is cacheable, but with a short life.
-    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(0, TimeUnit.SECONDS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    // A response that refers to the previous response, but is cacheable with a long life.
-    // Contains a header we can recognize as having come from the server.
-    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=30")
-        .addHeader("Allow: GET, HEAD")
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    // A response that is cacheable with a long life.
-    server.enqueue(new MockResponse().setBody("B").addHeader("Cache-Control: max-age=30"));
-    // A response that should never be requested.
-    server.enqueue(new MockResponse().setBody("C"));
-
-    // cache miss; seed the cache with an entry that will require a network hit to be sure it is
-    // still valid
-    HttpURLConnection connection1 = openConnection(server.getUrl("/a"));
-    assertEquals("A", readAscii(connection1));
-    assertEquals(null, connection1.getHeaderField("Allow"));
-
-    // conditional cache hit; The cached data should be returned, but the cache is not updated.
-    HttpURLConnection connection2 = openConnection(server.getUrl("/a"));
-    assertEquals(HttpURLConnection.HTTP_OK, connection2.getResponseCode());
-    assertEquals("A", readAscii(connection2));
-    assertEquals("GET, HEAD", connection2.getHeaderField("Allow"));
-
-    // conditional cache hit; The server responds with new data. The cache is updated.
-    HttpURLConnection connection3 = openConnection(server.getUrl("/a"));
-    assertEquals("B", readAscii(connection3));
-
-    // full cache hit; The data from connection3 has now replaced that from connection 1.
-    HttpURLConnection connection4 = openConnection(server.getUrl("/a"));
-    assertEquals("B", readAscii(connection4));
-
-    assertEquals(3, server.getRequestCount());
-  }
-
-  @Test public void responseSourceHeaderCached() throws IOException {
-    server.enqueue(new MockResponse().setBody("A")
-        .addHeader("Cache-Control: max-age=30")
-        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
-
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-    URLConnection connection = openConnection(server.getUrl("/"));
-    connection.addRequestProperty("Cache-Control", "only-if-cached");
-    assertEquals("A", readAscii(connection));
-  }
-
-  @Test public void responseSourceHeaderConditionalCacheFetched() throws IOException {
-    server.enqueue(new MockResponse().setBody("A")
-        .addHeader("Cache-Control: max-age=30")
-        .addHeader("Date: " + formatDate(-31, TimeUnit.MINUTES)));
-    server.enqueue(new MockResponse().setBody("B")
-        .addHeader("Cache-Control: max-age=30")
-        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
-
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-    HttpURLConnection connection = openConnection(server.getUrl("/"));
-    assertEquals("B", readAscii(connection));
-  }
-
-  @Test public void responseSourceHeaderConditionalCacheNotFetched() throws IOException {
-    server.enqueue(new MockResponse().setBody("A")
-        .addHeader("Cache-Control: max-age=0")
-        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
-    server.enqueue(new MockResponse().setResponseCode(304));
-
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-    HttpURLConnection connection = openConnection(server.getUrl("/"));
-    assertEquals("A", readAscii(connection));
-  }
-
-  @Test public void responseSourceHeaderFetched() throws IOException {
-    server.enqueue(new MockResponse().setBody("A"));
-
-    URLConnection connection = openConnection(server.getUrl("/"));
-    assertEquals("A", readAscii(connection));
-  }
-
-  @Test public void emptyResponseHeaderNameFromCacheIsLenient() throws Exception {
-    Headers.Builder headers = new Headers.Builder()
-        .add("Cache-Control: max-age=120");
-    Internal.instance.addLenient(headers, ": A");
-    server.enqueue(new MockResponse()
-        .setHeaders(headers.build())
-        .setBody("body"));
-
-    HttpURLConnection connection = openConnection(server.getUrl("/"));
-    assertEquals("A", connection.getHeaderField(""));
-  }
-
-  /**
-   * Test that we can interrogate the response when the cache is being
-   * populated. http://code.google.com/p/android/issues/detail?id=7787
-   */
-  @Test public void responseCacheCallbackApis() throws Exception {
-    final String body = "ABCDE";
-    final AtomicInteger cacheCount = new AtomicInteger();
-
-    server.enqueue(new MockResponse()
-        .setStatus("HTTP/1.1 200 Fantastic")
-        .addHeader("Content-Type: text/plain")
-        .addHeader("fgh: ijk")
-        .setBody(body));
-
-    Internal.instance.setCache(client, new CacheAdapter(new AbstractResponseCache() {
-      @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
-        HttpURLConnection httpURLConnection = (HttpURLConnection) connection;
-        assertEquals(server.getUrl("/"), uri.toURL());
-        assertEquals(200, httpURLConnection.getResponseCode());
-        try {
-          httpURLConnection.getInputStream();
-          fail();
-        } catch (UnsupportedOperationException expected) {
-        }
-        assertEquals("5", connection.getHeaderField("Content-Length"));
-        assertEquals("text/plain", connection.getHeaderField("Content-Type"));
-        assertEquals("ijk", connection.getHeaderField("fgh"));
-        cacheCount.incrementAndGet();
-        return null;
-      }
-    }));
-
-    URL url = server.getUrl("/");
-    HttpURLConnection connection = openConnection(url);
-    assertEquals(body, readAscii(connection));
-    assertEquals(1, cacheCount.get());
-  }
-
-  /** Don't explode if the cache returns a null body. http://b/3373699 */
-  @Test public void responseCacheReturnsNullOutputStream() throws Exception {
-    final AtomicBoolean aborted = new AtomicBoolean();
-    Internal.instance.setCache(client, new CacheAdapter(new AbstractResponseCache() {
-      @Override public CacheRequest put(URI uri, URLConnection connection) {
-        return new CacheRequest() {
-          @Override public void abort() {
-            aborted.set(true);
-          }
-
-          @Override public OutputStream getBody() throws IOException {
-            return null;
-          }
-        };
-      }
-    }));
-
-    server.enqueue(new MockResponse().setBody("abcdef"));
-
-    HttpURLConnection connection = openConnection(server.getUrl("/"));
-    assertEquals("abc", readAscii(connection, 3));
-    connection.getInputStream().close();
-    assertFalse(aborted.get()); // The best behavior is ambiguous, but RI 6 doesn't abort here
-  }
-
-  /**
-   * @param delta the offset from the current date to use. Negative
-   * values yield dates in the past; positive values yield dates in the
-   * future.
-   */
-  private String formatDate(long delta, TimeUnit timeUnit) {
-    return HttpDate.format(new Date(System.currentTimeMillis() + timeUnit.toMillis(delta)));
-  }
-
-  private void addRequestBodyIfNecessary(String requestMethod, HttpURLConnection invalidate)
-      throws IOException {
-    if (requestMethod.equals("POST") || requestMethod.equals("PUT")) {
-      invalidate.setDoOutput(true);
-      OutputStream requestBody = invalidate.getOutputStream();
-      requestBody.write('x');
-      requestBody.close();
-    }
-  }
-
-  private void assertNotCached(MockResponse response) throws Exception {
-    server.enqueue(response.setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    URL url = server.getUrl("/");
-    assertEquals("A", readAscii(openConnection(url)));
-    assertEquals("B", readAscii(openConnection(url)));
-  }
-
-  /** @return the request with the conditional get headers. */
-  private RecordedRequest assertConditionallyCached(MockResponse response) throws Exception {
-    // scenario 1: condition succeeds
-    server.enqueue(response.setBody("A").setStatus("HTTP/1.1 200 A-OK"));
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    // scenario 2: condition fails
-    server.enqueue(response.setBody("B").setStatus("HTTP/1.1 200 B-OK"));
-    server.enqueue(new MockResponse().setStatus("HTTP/1.1 200 C-OK").setBody("C"));
-
-    URL valid = server.getUrl("/valid");
-    HttpURLConnection connection1 = openConnection(valid);
-    assertEquals("A", readAscii(connection1));
-    assertEquals(HttpURLConnection.HTTP_OK, connection1.getResponseCode());
-    assertEquals("A-OK", connection1.getResponseMessage());
-    HttpURLConnection connection2 = openConnection(valid);
-    assertEquals("A", readAscii(connection2));
-    assertEquals(HttpURLConnection.HTTP_OK, connection2.getResponseCode());
-    assertEquals("A-OK", connection2.getResponseMessage());
-
-    URL invalid = server.getUrl("/invalid");
-    HttpURLConnection connection3 = openConnection(invalid);
-    assertEquals("B", readAscii(connection3));
-    assertEquals(HttpURLConnection.HTTP_OK, connection3.getResponseCode());
-    assertEquals("B-OK", connection3.getResponseMessage());
-    HttpURLConnection connection4 = openConnection(invalid);
-    assertEquals("C", readAscii(connection4));
-    assertEquals(HttpURLConnection.HTTP_OK, connection4.getResponseCode());
-    assertEquals("C-OK", connection4.getResponseMessage());
-
-    server.takeRequest(); // regular get
-    return server.takeRequest(); // conditional get
-  }
-
-  private void assertFullyCached(MockResponse response) throws Exception {
-    server.enqueue(response.setBody("A"));
-    server.enqueue(response.setBody("B"));
-
-    URL url = server.getUrl("/");
-    assertEquals("A", readAscii(openConnection(url)));
-    assertEquals("A", readAscii(openConnection(url)));
-  }
-
-  /**
-   * Shortens the body of {@code response} but not the corresponding headers.
-   * Only useful to test how clients respond to the premature conclusion of
-   * the HTTP body.
-   */
-  private MockResponse truncateViolently(MockResponse response, int numBytesToKeep) {
-    response.setSocketPolicy(DISCONNECT_AT_END);
-    Headers headers = response.getHeaders();
-    Buffer truncatedBody = new Buffer();
-    truncatedBody.write(response.getBody(), numBytesToKeep);
-    response.setBody(truncatedBody);
-    response.setHeaders(headers);
-    return response;
-  }
-
-  /**
-   * Reads {@code count} characters from the stream. If the stream is
-   * exhausted before {@code count} characters can be read, the remaining
-   * characters are returned and the stream is closed.
-   */
-  private String readAscii(URLConnection connection, int count) throws IOException {
-    HttpURLConnection httpConnection = (HttpURLConnection) connection;
-    InputStream in = httpConnection.getResponseCode() < HttpURLConnection.HTTP_BAD_REQUEST
-        ? connection.getInputStream() : httpConnection.getErrorStream();
-    StringBuilder result = new StringBuilder();
-    for (int i = 0; i < count; i++) {
-      int value = in.read();
-      if (value == -1) {
-        in.close();
-        break;
-      }
-      result.append((char) value);
-    }
-    return result.toString();
-  }
-
-  private String readAscii(URLConnection connection) throws IOException {
-    return readAscii(connection, Integer.MAX_VALUE);
-  }
-
-  private void reliableSkip(InputStream in, int length) throws IOException {
-    while (length > 0) {
-      length -= in.skip(length);
-    }
-  }
-
-  private void assertGatewayTimeout(HttpURLConnection connection) throws IOException {
-    try {
-      connection.getInputStream();
-      fail();
-    } catch (FileNotFoundException expected) {
-    }
-    assertEquals(504, connection.getResponseCode());
-    assertEquals(-1, connection.getErrorStream().read());
-  }
-
-  enum TransferKind {
-    CHUNKED() {
-      @Override void setBody(MockResponse response, Buffer content, int chunkSize)
-          throws IOException {
-        response.setChunkedBody(content, chunkSize);
-      }
-    },
-    FIXED_LENGTH() {
-      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
-        response.setBody(content);
-      }
-    },
-    END_OF_STREAM() {
-      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
-        response.setBody(content);
-        response.setSocketPolicy(DISCONNECT_AT_END);
-        response.removeHeader("Content-Length");
-      }
-    };
-
-    abstract void setBody(MockResponse response, Buffer content, int chunkSize) throws IOException;
-
-    void setBody(MockResponse response, String content, int chunkSize) throws IOException {
-      setBody(response, new Buffer().writeUtf8(content), chunkSize);
-    }
-  }
-
-  private <T> List<T> toListOrNull(T[] arrayOrNull) {
-    return arrayOrNull != null ? Arrays.asList(arrayOrNull) : null;
-  }
-
-  /** Returns a gzipped copy of {@code bytes}. */
-  public Buffer gzip(String data) throws IOException {
-    Buffer result = new Buffer();
-    BufferedSink sink = Okio.buffer(new GzipSink(result));
-    sink.writeUtf8(data);
-    sink.close();
-    return result;
-  }
-
-  private static class InsecureResponseCache extends ResponseCache {
-
-    private final ResponseCache delegate;
-
-    private InsecureResponseCache(ResponseCache delegate) {
-      this.delegate = delegate;
-    }
-
-    @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
-      return delegate.put(uri, connection);
-    }
-
-    @Override public CacheResponse get(URI uri, String requestMethod,
-        Map<String, List<String>> requestHeaders) throws IOException {
-      final CacheResponse response = delegate.get(uri, requestMethod, requestHeaders);
-      if (response instanceof SecureCacheResponse) {
-        return new CacheResponse() {
-          @Override public InputStream getBody() throws IOException {
-            return response.getBody();
-          }
-          @Override public Map<String, List<String>> getHeaders() throws IOException {
-            return response.getHeaders();
-          }
-        };
-      }
-      return response;
-    }
-  }
-
-  /**
-   * A trivial and non-thread-safe implementation of ResponseCache that uses an in-memory map to
-   * cache GETs.
-   */
-  private static class InMemoryResponseCache extends ResponseCache {
-
-    /** A request / response header that acts a bit like Vary but without the complexity. */
-    public static final String CACHE_VARIANT_HEADER = "CacheVariant";
-
-    private static class Key {
-      private final URI uri;
-      private final String cacheVariant;
-
-      private Key(URI uri, String cacheVariant) {
-        this.uri = uri;
-        this.cacheVariant = cacheVariant;
-      }
-
-      @Override
-      public boolean equals(Object o) {
-        if (this == o) {
-          return true;
-        }
-        if (o == null || getClass() != o.getClass()) {
-          return false;
-        }
-
-        Key key = (Key) o;
-
-        if (cacheVariant != null ? !cacheVariant.equals(key.cacheVariant)
-            : key.cacheVariant != null) {
-          return false;
-        }
-        if (!uri.equals(key.uri)) {
-          return false;
-        }
-
-        return true;
-      }
-
-      @Override
-      public int hashCode() {
-        int result = uri.hashCode();
-        result = 31 * result + (cacheVariant != null ? cacheVariant.hashCode() : 0);
-        return result;
-      }
-    }
-
-    private class Entry {
-
-      private final URI uri;
-      private final String cacheVariant;
-      private final String method;
-      private final Map<String, List<String>> responseHeaders;
-      private final String cipherSuite;
-      private final Certificate[] serverCertificates;
-      private final Certificate[] localCertificates;
-      private byte[] body;
-
-      public Entry(URI uri, URLConnection urlConnection) {
-        this.uri = uri;
-        HttpURLConnection httpUrlConnection = (HttpURLConnection) urlConnection;
-        method = httpUrlConnection.getRequestMethod();
-        cacheVariant = urlConnection.getHeaderField(CACHE_VARIANT_HEADER);
-        responseHeaders = urlConnection.getHeaderFields();
-        if (urlConnection instanceof HttpsURLConnection) {
-          HttpsURLConnection httpsURLConnection = (HttpsURLConnection) urlConnection;
-          cipherSuite = httpsURLConnection.getCipherSuite();
-          Certificate[] serverCertificates;
-          try {
-            serverCertificates = httpsURLConnection.getServerCertificates();
-          } catch (SSLPeerUnverifiedException e) {
-            serverCertificates = null;
-          }
-          this.serverCertificates = serverCertificates;
-          localCertificates = httpsURLConnection.getLocalCertificates();
-        } else {
-          cipherSuite = null;
-          serverCertificates = null;
-          localCertificates = null;
-        }
-      }
-
-      public CacheResponse asCacheResponse() {
-        if (!method.equals(this.method)) {
-          return null;
-        }
-
-        // Handle SSL
-        if (cipherSuite != null) {
-          return new SecureCacheResponse() {
-            @Override
-            public Map<String, List<String>> getHeaders() throws IOException {
-              return responseHeaders;
-            }
-
-            @Override
-            public InputStream getBody() throws IOException {
-              return new ByteArrayInputStream(body);
-            }
-
-            @Override
-            public String getCipherSuite() {
-              return cipherSuite;
-            }
-
-            @Override
-            public List<Certificate> getLocalCertificateChain() {
-              return localCertificates == null ? null : Arrays.asList(localCertificates);
-            }
-
-            @Override
-            public List<Certificate> getServerCertificateChain() throws SSLPeerUnverifiedException {
-              if (serverCertificates == null) {
-                throw new SSLPeerUnverifiedException("Test implementation");
-              }
-              return Arrays.asList(serverCertificates);
-            }
-
-            @Override
-            public Principal getPeerPrincipal() throws SSLPeerUnverifiedException {
-              throw new UnsupportedOperationException();
-            }
-
-            @Override
-            public Principal getLocalPrincipal() {
-              throw new UnsupportedOperationException();
-            }
-          };
-        } else {
-          return new CacheResponse() {
-            @Override
-            public Map<String, List<String>> getHeaders() throws IOException {
-              return responseHeaders;
-            }
-
-            @Override
-            public InputStream getBody() throws IOException {
-              return new ByteArrayInputStream(body);
-            }
-          };
-        }
-      }
-
-      public CacheRequest asCacheRequest() {
-        return new CacheRequest() {
-          @Override
-          public OutputStream getBody() throws IOException {
-            return new ByteArrayOutputStream() {
-              @Override
-              public void close() throws IOException {
-                super.close();
-                body = toByteArray();
-                cache.put(Entry.this.key(), Entry.this);
-              }
-            };
-          }
-
-          @Override
-          public void abort() {
-            // No-op: close() puts the item in the cache, abort need not do anything.
-          }
-        };
-      }
-
-      private Key key() {
-        return new Key(uri, cacheVariant);
-      }
-    }
-
-    private Map<Key, Entry> cache = new HashMap<Key, Entry>();
-
-    @Override
-    public CacheResponse get(URI uri, String method, Map<String, List<String>> requestHeaders)
-        throws IOException {
-
-      if (!"GET".equals(method)) {
-        return null;
-      }
-
-      String cacheVariant =
-          requestHeaders.containsKey(CACHE_VARIANT_HEADER)
-              ? requestHeaders.get(CACHE_VARIANT_HEADER).get(0) : null;
-      Key key = new Key(uri, cacheVariant);
-      Entry entry = cache.get(key);
-      if (entry == null) {
-        return null;
-      }
-      return entry.asCacheResponse();
-    }
-
-    @Override
-    public CacheRequest put(URI uri, URLConnection urlConnection) throws IOException {
-      if (!"GET".equals(((HttpURLConnection) urlConnection).getRequestMethod())) {
-        return null;
-      }
-
-      Entry entry = new Entry(uri, urlConnection);
-      return entry.asCacheRequest();
-    }
-  }
-}
diff --git a/okhttp-android-support/src/test/java/com/squareup/okhttp/AbstractResponseCache.java b/okhttp-android-support/src/test/java/okhttp3/AbstractResponseCache.java
similarity index 97%
rename from okhttp-android-support/src/test/java/com/squareup/okhttp/AbstractResponseCache.java
rename to okhttp-android-support/src/test/java/okhttp3/AbstractResponseCache.java
index 2a59d22a02..d755487c92 100644
--- a/okhttp-android-support/src/test/java/com/squareup/okhttp/AbstractResponseCache.java
+++ b/okhttp-android-support/src/test/java/okhttp3/AbstractResponseCache.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
 import java.io.IOException;
 import java.net.CacheRequest;
diff --git a/okhttp-android-support/src/test/java/com/squareup/okhttp/android/HttpResponseCache.java b/okhttp-android-support/src/test/java/okhttp3/android/HttpResponseCache.java
similarity index 79%
rename from okhttp-android-support/src/test/java/com/squareup/okhttp/android/HttpResponseCache.java
rename to okhttp-android-support/src/test/java/okhttp3/android/HttpResponseCache.java
index 30d965c2b7..c569a3b365 100644
--- a/okhttp-android-support/src/test/java/com/squareup/okhttp/android/HttpResponseCache.java
+++ b/okhttp-android-support/src/test/java/okhttp3/android/HttpResponseCache.java
@@ -14,11 +14,7 @@
  * limitations under the License.
  */
 
-package com.squareup.okhttp.android;
-
-import com.squareup.okhttp.Cache;
-import com.squareup.okhttp.AndroidShimResponseCache;
-import com.squareup.okhttp.OkCacheContainer;
+package okhttp3.android;
 
 import java.io.Closeable;
 import java.io.File;
@@ -30,15 +26,18 @@
 import java.net.URLConnection;
 import java.util.List;
 import java.util.Map;
+import okhttp3.AndroidShimResponseCache;
+import okhttp3.Cache;
+import okhttp3.OkCacheContainer;
 
 /**
  * A copy of android.net.http.HttpResponseCache taken from AOSP. Android need to keep this code
- * working somehow. Dependencies on com.squareup.okhttp are com.android.okhttp on Android.
- */
-/* <p>This class exists in okhttp-android-support to help keep the API as it always has been on
- * Android. The public API cannot be changed. This class delegates to
- * {@link com.squareup.okhttp.AndroidShimResponseCache}, a class that exists in a package that
- * enables it to interact with non-public OkHttp classes.
+ * working somehow. Dependencies on okhttp3 are com.android.okhttp on Android.
+ *
+ * <p>This class exists in okhttp-android-support to help keep the API as it always has been on
+ * Android. The public API cannot be changed. This class delegates to {@link
+ * AndroidShimResponseCache}, a class that exists in a package that enables it to interact with
+ * non-public OkHttp classes.
  */
 public final class HttpResponseCache extends ResponseCache implements Closeable, OkCacheContainer {
 
@@ -49,8 +48,8 @@ private HttpResponseCache(AndroidShimResponseCache shimResponseCache) {
   }
 
   /**
-   * Returns the currently-installed {@code HttpResponseCache}, or null if
-   * there is no cache installed or it is not a {@code HttpResponseCache}.
+   * Returns the currently-installed {@code HttpResponseCache}, or null if there is no cache
+   * installed or it is not a {@code HttpResponseCache}.
    */
   public static HttpResponseCache getInstalled() {
     ResponseCache installed = ResponseCache.getDefault();
@@ -66,9 +65,8 @@ public static HttpResponseCache getInstalled() {
    * @param directory the directory to hold cache data.
    * @param maxSize the maximum size of the cache in bytes.
    * @return the newly-installed cache
-   * @throws java.io.IOException if {@code directory} cannot be used for this cache.
-   *     Most applications should respond to this exception by logging a
-   *     warning.
+   * @throws java.io.IOException if {@code directory} cannot be used for this cache. Most
+   * applications should respond to this exception by logging a warning.
    */
   public static synchronized HttpResponseCache install(File directory, long maxSize) throws
       IOException {
@@ -103,9 +101,8 @@ public static synchronized HttpResponseCache install(File directory, long maxSiz
   }
 
   /**
-   * Returns the number of bytes currently being used to store the values in
-   * this cache. This may be greater than the {@link #maxSize} if a background
-   * deletion is pending.
+   * Returns the number of bytes currently being used to store the values in this cache. This may be
+   * greater than the {@link #maxSize} if a background deletion is pending.
    */
   public long size() {
     try {
@@ -117,17 +114,15 @@ public long size() {
   }
 
   /**
-   * Returns the maximum number of bytes that this cache should use to store
-   * its data.
+   * Returns the maximum number of bytes that this cache should use to store its data.
    */
   public long maxSize() {
     return shimResponseCache.maxSize();
   }
 
   /**
-   * Force buffered operations to the filesystem. This ensures that responses
-   * written to the cache will be available the next time the cache is opened,
-   * even if this process is killed.
+   * Force buffered operations to the filesystem. This ensures that responses written to the cache
+   * will be available the next time the cache is opened, even if this process is killed.
    */
   public void flush() {
     try {
@@ -137,34 +132,32 @@ public void flush() {
   }
 
   /**
-   * Returns the number of HTTP requests that required the network to either
-   * supply a response or validate a locally cached response.
+   * Returns the number of HTTP requests that required the network to either supply a response or
+   * validate a locally cached response.
    */
   public int getNetworkCount() {
     return shimResponseCache.getNetworkCount();
   }
 
   /**
-   * Returns the number of HTTP requests whose response was provided by the
-   * cache. This may include conditional {@code GET} requests that were
-   * validated over the network.
+   * Returns the number of HTTP requests whose response was provided by the cache. This may include
+   * conditional {@code GET} requests that were validated over the network.
    */
   public int getHitCount() {
     return shimResponseCache.getHitCount();
   }
 
   /**
-   * Returns the total number of HTTP requests that were made. This includes
-   * both client requests and requests that were made on the client's behalf
-   * to handle a redirects and retries.
+   * Returns the total number of HTTP requests that were made. This includes both client requests
+   * and requests that were made on the client's behalf to handle a redirects and retries.
    */
   public int getRequestCount() {
     return shimResponseCache.getRequestCount();
   }
 
   /**
-   * Uninstalls the cache and releases any active resources. Stored contents
-   * will remain on the filesystem.
+   * Uninstalls the cache and releases any active resources. Stored contents will remain on the
+   * filesystem.
    */
   @Override public void close() throws IOException {
     if (ResponseCache.getDefault() == this) {
@@ -187,5 +180,4 @@ public void delete() throws IOException {
   public Cache getCache() {
     return shimResponseCache.getCache();
   }
-
 }
diff --git a/okhttp-android-support/src/test/java/com/squareup/okhttp/android/HttpResponseCacheTest.java b/okhttp-android-support/src/test/java/okhttp3/android/HttpResponseCacheTest.java
similarity index 83%
rename from okhttp-android-support/src/test/java/com/squareup/okhttp/android/HttpResponseCacheTest.java
rename to okhttp-android-support/src/test/java/okhttp3/android/HttpResponseCacheTest.java
index c349790453..dcb1c01815 100644
--- a/okhttp-android-support/src/test/java/com/squareup/okhttp/android/HttpResponseCacheTest.java
+++ b/okhttp-android-support/src/test/java/okhttp3/android/HttpResponseCacheTest.java
@@ -14,20 +14,7 @@
  * limitations under the License.
  */
 
-package com.squareup.okhttp.android;
-
-import com.squareup.okhttp.AndroidInternal;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.OkUrlFactory;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.TemporaryFolder;
+package okhttp3.android;
 
 import java.io.File;
 import java.io.InputStream;
@@ -35,10 +22,20 @@
 import java.net.CacheResponse;
 import java.net.ResponseCache;
 import java.net.URI;
-import java.net.URL;
 import java.net.URLConnection;
 import java.util.List;
 import java.util.Map;
+import okhttp3.AndroidInternal;
+import okhttp3.HttpUrl;
+import okhttp3.OkHttpClient;
+import okhttp3.OkUrlFactory;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
@@ -51,18 +48,15 @@
  * A port of Android's android.net.http.HttpResponseCacheTest to JUnit4.
  */
 public final class HttpResponseCacheTest {
-
   @Rule public TemporaryFolder cacheRule = new TemporaryFolder();
-  @Rule public MockWebServerRule serverRule = new MockWebServerRule();
+  @Rule public MockWebServer server = new MockWebServer();
 
   private File cacheDir;
-  private MockWebServer server;
-  private OkUrlFactory client;
+  private OkUrlFactory urlFactory;
 
   @Before public void setUp() throws Exception {
-    server = serverRule.get();
     cacheDir = cacheRule.getRoot();
-    client = new OkUrlFactory(new OkHttpClient());
+    urlFactory = new OkUrlFactory(new OkHttpClient());
   }
 
   @After public void tearDown() throws Exception {
@@ -138,8 +132,8 @@ public CacheRequest put(URI uri, URLConnection connection) {
   }
 
   /**
-   * Make sure that statistics tracking are wired all the way through the
-   * wrapper class. http://code.google.com/p/android/issues/detail?id=25418
+   * Make sure that statistics tracking are wired all the way through the wrapper class.
+   * http://code.google.com/p/android/issues/detail?id=25418
    */
   @Test public void statisticsTracking() throws Exception {
     HttpResponseCache cache = HttpResponseCache.install(cacheDir, 10 * 1024 * 1024);
@@ -148,7 +142,7 @@ public CacheRequest put(URI uri, URLConnection connection) {
         .addHeader("Cache-Control: max-age=60")
         .setBody("A"));
 
-    URLConnection c1 = openUrl(server.getUrl("/"));
+    URLConnection c1 = openUrl(server.url("/"));
 
     InputStream inputStream = c1.getInputStream();
     assertEquals('A', inputStream.read());
@@ -157,21 +151,21 @@ public CacheRequest put(URI uri, URLConnection connection) {
     assertEquals(1, cache.getNetworkCount());
     assertEquals(0, cache.getHitCount());
 
-    URLConnection c2 = openUrl(server.getUrl("/"));
+    URLConnection c2 = openUrl(server.url("/"));
     assertEquals('A', c2.getInputStream().read());
 
-    URLConnection c3 = openUrl(server.getUrl("/"));
+    URLConnection c3 = openUrl(server.url("/"));
     assertEquals('A', c3.getInputStream().read());
     assertEquals(3, cache.getRequestCount());
     assertEquals(1, cache.getNetworkCount());
     assertEquals(2, cache.getHitCount());
   }
 
-  // This mimics the Android HttpHandler, which is found in the com.squareup.okhttp package.
-  private URLConnection openUrl(URL url) {
+  // This mimics the Android HttpHandler, which is found in the okhttp3 package.
+  private URLConnection openUrl(HttpUrl url) {
     ResponseCache responseCache = ResponseCache.getDefault();
-    AndroidInternal.setResponseCache(client, responseCache);
-    return client.open(url);
+    AndroidInternal.setResponseCache(urlFactory, responseCache);
+    return urlFactory.open(url.url());
   }
 
   private void initializeCache(HttpResponseCache cache) {
diff --git a/okhttp-android-support/src/test/java/com/squareup/okhttp/internal/huc/CacheAdapterTest.java b/okhttp-android-support/src/test/java/okhttp3/internal/huc/CacheAdapterTest.java
similarity index 81%
rename from okhttp-android-support/src/test/java/com/squareup/okhttp/internal/huc/CacheAdapterTest.java
rename to okhttp-android-support/src/test/java/okhttp3/internal/huc/CacheAdapterTest.java
index 4cca79e5e3..e24c7264ad 100644
--- a/okhttp-android-support/src/test/java/com/squareup/okhttp/internal/huc/CacheAdapterTest.java
+++ b/okhttp-android-support/src/test/java/okhttp3/internal/huc/CacheAdapterTest.java
@@ -13,15 +13,8 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.huc;
-
-import com.squareup.okhttp.AbstractResponseCache;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.OkUrlFactory;
-import com.squareup.okhttp.internal.Internal;
-import com.squareup.okhttp.internal.SslContextBuilder;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
+package okhttp3.internal.huc;
+
 import java.io.IOException;
 import java.net.CacheRequest;
 import java.net.CacheResponse;
@@ -36,14 +29,20 @@
 import java.util.Map;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.HttpsURLConnection;
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLSession;
+import okhttp3.AbstractResponseCache;
+import okhttp3.OkHttpClient;
+import okhttp3.OkUrlFactory;
+import okhttp3.RecordingHostnameVerifier;
+import okhttp3.internal.Internal;
+import okhttp3.internal.InternalCache;
+import okhttp3.internal.tls.SslClient;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okio.Buffer;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 
-import okio.Buffer;
-
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
@@ -52,24 +51,17 @@
 /**
  * A white-box test for {@link CacheAdapter}. See also:
  * <ul>
- *   <li>{@link ResponseCacheTest} for black-box tests that check that {@link ResponseCache}
- *   classes are called correctly by OkHttp.</li>
- *   <li>{@link JavaApiConverterTest} for tests that check Java API classes / OkHttp conversion
- *   logic. </li>
+ *     <li>{@link ResponseCacheTest} for black-box tests that check that {@link ResponseCache}
+ *         classes are called correctly by OkHttp.
+ *     <li>{@link JavaApiConverterTest} for tests that check Java API classes / OkHttp conversion
+ *         logic.
  * </ul>
  */
 public class CacheAdapterTest {
-  private static final SSLContext sslContext = SslContextBuilder.localhost();
-  private static final HostnameVerifier NULL_HOSTNAME_VERIFIER = new HostnameVerifier() {
-    public boolean verify(String hostname, SSLSession session) {
-      return true;
-    }
-  };
-
+  private SslClient sslClient = SslClient.localhost();
+  private HostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
   private MockWebServer server;
-
   private OkHttpClient client;
-
   private HttpURLConnection connection;
 
   @Before public void setUp() throws Exception {
@@ -89,8 +81,8 @@ public boolean verify(String hostname, SSLSession session) {
     assertEquals("http", serverUrl.getProtocol());
 
     ResponseCache responseCache = new AbstractResponseCache() {
-      @Override
-      public CacheResponse get(URI uri, String method, Map<String, List<String>> headers) throws IOException {
+      @Override public CacheResponse get(
+          URI uri, String method, Map<String, List<String>> headers) throws IOException {
         assertEquals(toUri(serverUrl), uri);
         assertEquals("GET", method);
         assertTrue("Arbitrary standard header not present", headers.containsKey("User-Agent"));
@@ -98,7 +90,7 @@ public CacheResponse get(URI uri, String method, Map<String, List<String>> heade
         return null;
       }
     };
-    Internal.instance.setCache(client, new CacheAdapter(responseCache));
+    setInternalCache(new CacheAdapter(responseCache));
 
     connection = new OkUrlFactory(client).open(serverUrl);
     connection.setRequestProperty("key1", "value1");
@@ -121,9 +113,11 @@ public CacheResponse get(URI uri, String method, Map<String, List<String>> heade
         return null;
       }
     };
-    Internal.instance.setCache(client, new CacheAdapter(responseCache));
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+    setInternalCache(new CacheAdapter(responseCache));
+    client = client.newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(hostnameVerifier)
+        .build();
 
     connection = new OkUrlFactory(client).open(serverUrl);
     connection.setRequestProperty("key1", "value1");
@@ -165,7 +159,7 @@ public CacheResponse get(URI uri, String method, Map<String, List<String>> heade
         return null;
       }
     };
-    Internal.instance.setCache(client, new CacheAdapter(responseCache));
+    setInternalCache(new CacheAdapter(responseCache));
 
     connection = new OkUrlFactory(client).open(serverUrl);
     connection.setRequestProperty("key", "value");
@@ -204,7 +198,7 @@ public CacheResponse get(URI uri, String method, Map<String, List<String>> heade
         return null;
       }
     };
-    Internal.instance.setCache(client, new CacheAdapter(responseCache));
+    setInternalCache(new CacheAdapter(responseCache));
 
     connection = new OkUrlFactory(client).open(serverUrl);
 
@@ -222,7 +216,8 @@ public CacheResponse get(URI uri, String method, Map<String, List<String>> heade
         assertEquals(serverUrl, connection.getURL());
 
         HttpsURLConnection cacheHttpsUrlConnection = (HttpsURLConnection) connection;
-        HttpsURLConnection realHttpsUrlConnection = (HttpsURLConnection) CacheAdapterTest.this.connection;
+        HttpsURLConnection realHttpsUrlConnection =
+            (HttpsURLConnection) CacheAdapterTest.this.connection;
         assertEquals(realHttpsUrlConnection.getCipherSuite(),
             cacheHttpsUrlConnection.getCipherSuite());
         assertEquals(realHttpsUrlConnection.getPeerPrincipal(),
@@ -236,9 +231,11 @@ public CacheResponse get(URI uri, String method, Map<String, List<String>> heade
         return null;
       }
     };
-    Internal.instance.setCache(client, new CacheAdapter(responseCache));
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+    setInternalCache(new CacheAdapter(responseCache));
+    client = client.newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(hostnameVerifier)
+        .build();
 
     connection = new OkUrlFactory(client).open(serverUrl);
     executeGet(connection);
@@ -260,13 +257,19 @@ private void executePost(HttpURLConnection connection) throws IOException {
   private URL configureServer(MockResponse mockResponse) throws Exception {
     server.enqueue(mockResponse);
     server.start();
-    return server.getUrl("/");
+    return server.url("/").url();
   }
 
   private URL configureHttpsServer(MockResponse mockResponse) throws Exception {
-    server.useHttps(sslContext.getSocketFactory(), false /* tunnelProxy */);
+    server.useHttps(sslClient.socketFactory, false /* tunnelProxy */);
     server.enqueue(mockResponse);
     server.start();
-    return server.getUrl("/");
+    return server.url("/").url();
+  }
+
+  private void setInternalCache(InternalCache internalCache) {
+    OkHttpClient.Builder builder = client.newBuilder();
+    Internal.instance.setCache(builder, internalCache);
+    client = builder.build();
   }
 }
diff --git a/okhttp-android-support/src/test/java/com/squareup/okhttp/internal/huc/JavaApiConverterTest.java b/okhttp-android-support/src/test/java/okhttp3/internal/huc/JavaApiConverterTest.java
similarity index 74%
rename from okhttp-android-support/src/test/java/com/squareup/okhttp/internal/huc/JavaApiConverterTest.java
rename to okhttp-android-support/src/test/java/okhttp3/internal/huc/JavaApiConverterTest.java
index d5dfcd8557..f4c9b95dab 100644
--- a/okhttp-android-support/src/test/java/com/squareup/okhttp/internal/huc/JavaApiConverterTest.java
+++ b/okhttp-android-support/src/test/java/okhttp3/internal/huc/JavaApiConverterTest.java
@@ -13,22 +13,8 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.huc;
-
-import com.squareup.okhttp.Handshake;
-import com.squareup.okhttp.Headers;
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.OkUrlFactory;
-import com.squareup.okhttp.Protocol;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.Response;
-import com.squareup.okhttp.ResponseBody;
-import com.squareup.okhttp.internal.SslContextBuilder;
-import com.squareup.okhttp.internal.Util;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
+package okhttp3.internal.huc;
+
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
@@ -37,7 +23,6 @@
 import java.net.HttpURLConnection;
 import java.net.SecureCacheResponse;
 import java.net.URI;
-import java.net.URL;
 import java.nio.charset.StandardCharsets;
 import java.security.Principal;
 import java.security.cert.Certificate;
@@ -51,14 +36,22 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
-import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.HttpsURLConnection;
-import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLPeerUnverifiedException;
-import javax.net.ssl.SSLSession;
+import okhttp3.CipherSuite;
+import okhttp3.Handshake;
+import okhttp3.Headers;
+import okhttp3.MediaType;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+import okhttp3.internal.Internal;
+import okhttp3.internal.Util;
+import okhttp3.mockwebserver.MockWebServer;
 import okio.Buffer;
 import okio.BufferedSource;
-import org.junit.After;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
@@ -68,7 +61,6 @@
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
@@ -102,109 +94,13 @@
       + "fl2WRY8hb4x+zRrwsFaLEpdEvqcjOQ==\n"
       + "-----END CERTIFICATE-----");
 
-  private static final SSLContext sslContext = SslContextBuilder.localhost();
-  private static final HostnameVerifier NULL_HOSTNAME_VERIFIER = new HostnameVerifier() {
-    public boolean verify(String hostname, SSLSession session) {
-      return true;
-    }
-  };
-
-  @Rule public MockWebServerRule server = new MockWebServerRule();
-
-  private OkHttpClient client;
-
-  private HttpURLConnection connection;
+  @Rule public MockWebServer server = new MockWebServer();
 
   @Before public void setUp() throws Exception {
-    client = new OkHttpClient();
-  }
-
-  @After public void tearDown() throws Exception {
-    if (connection != null) {
-      connection.disconnect();
-    }
-  }
-
-  @Test public void createOkResponse_fromOkHttpUrlConnection() throws Exception {
-    testCreateOkResponseInternal(new OkHttpURLConnectionFactory(client), false /* isSecure */);
-  }
-
-  @Test public void createOkResponse_fromJavaHttpUrlConnection() throws Exception {
-    testCreateOkResponseInternal(new JavaHttpURLConnectionFactory(), false /* isSecure */);
-  }
-
-  @Test public void createOkResponse_fromOkHttpsUrlConnection() throws Exception {
-    testCreateOkResponseInternal(new OkHttpURLConnectionFactory(client), true /* isSecure */);
-  }
-
-  @Test public void createOkResponse_fromJavaHttpsUrlConnection() throws Exception {
-    testCreateOkResponseInternal(new JavaHttpURLConnectionFactory(), true /* isSecure */);
-  }
-
-  private void testCreateOkResponseInternal(HttpURLConnectionFactory httpUrlConnectionFactory,
-      boolean isSecure) throws Exception {
-    String statusLine = "HTTP/1.1 200 Fantastic";
-    String body = "Nothing happens";
-    final URL serverUrl;
-    MockResponse mockResponse = new MockResponse()
-        .setStatus(statusLine)
-        .addHeader("xyzzy", "baz")
-        .setBody(body);
-    if (isSecure) {
-      serverUrl = configureHttpsServer(
-          mockResponse);
-
-      assertEquals("https", serverUrl.getProtocol());
-    } else {
-      serverUrl = configureServer(
-          mockResponse);
-      assertEquals("http", serverUrl.getProtocol());
-    }
-
-    connection = httpUrlConnectionFactory.open(serverUrl);
-    if (isSecure) {
-      HttpsURLConnection httpsUrlConnection = (HttpsURLConnection) connection;
-      httpsUrlConnection.setSSLSocketFactory(sslContext.getSocketFactory());
-      httpsUrlConnection.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
-    }
-    connection.setRequestProperty("snake", "bird");
-    connection.connect();
-    Response response = JavaApiConverter.createOkResponse(serverUrl.toURI(), connection);
-
-    // Check the response.request()
-    Request request = response.request();
-    assertEquals(isSecure, request.isHttps());
-    assertEquals(serverUrl.toURI(), request.uri());
-    assertNull(request.body());
-    Headers okRequestHeaders = request.headers();
-    // In Java the request headers are unavailable for a connected HttpURLConnection.
-    assertEquals(0, okRequestHeaders.size());
-    assertEquals("GET", request.method());
-
-    // Check the response
-    assertEquals(Protocol.HTTP_1_1, response.protocol());
-    assertEquals(200, response.code());
-    assertEquals("Fantastic", response.message());
-    Headers okResponseHeaders = response.headers();
-    assertEquals("baz", okResponseHeaders.get("xyzzy"));
-    if (isSecure) {
-      Handshake handshake = response.handshake();
-      assertNotNull(handshake);
-      HttpsURLConnection httpsURLConnection = (HttpsURLConnection) connection;
-      assertNotNullAndEquals(httpsURLConnection.getCipherSuite(), handshake.cipherSuite());
-      assertEquals(httpsURLConnection.getLocalPrincipal(), handshake.localPrincipal());
-      assertNotNullAndEquals(httpsURLConnection.getPeerPrincipal(), handshake.peerPrincipal());
-      assertNotNull(httpsURLConnection.getServerCertificates());
-      assertEquals(Arrays.asList(httpsURLConnection.getServerCertificates()),
-          handshake.peerCertificates());
-      assertNull(httpsURLConnection.getLocalCertificates());
-    } else {
-      assertNull(response.handshake());
-    }
-    assertEquals(body, response.body().string());
+    Internal.initializeInstanceForTests();
   }
 
-  @Test public void createOkResponse_fromCacheResponse() throws Exception {
+  @Test public void createOkResponseForCacheGet() throws Exception {
     final String statusLine = "HTTP/1.1 200 Fantastic";
     URI uri = new URI("http://foo/bar");
     Request request = new Request.Builder().url(uri.toURL()).build();
@@ -221,8 +117,11 @@ private void testCreateOkResponseInternal(HttpURLConnectionFactory httpUrlConnec
       }
     };
 
-    Response response = JavaApiConverter.createOkResponse(request, cacheResponse);
-    assertSame(request, response.request());
+    Response response = JavaApiConverter.createOkResponseForCacheGet(request, cacheResponse);
+    Request cacheRequest = response.request();
+    assertEquals(request.url(), cacheRequest.url());
+    assertEquals(request.method(), cacheRequest.method());
+    assertEquals(0, request.headers().size());
 
     assertEquals(Protocol.HTTP_1_1, response.protocol());
     assertEquals(200, response.code());
@@ -233,7 +132,31 @@ private void testCreateOkResponseInternal(HttpURLConnectionFactory httpUrlConnec
     assertNull(response.handshake());
   }
 
-  @Test public void createOkResponse_fromSecureCacheResponse() throws Exception {
+  /** Test for https://code.google.com/p/android/issues/detail?id=160522 */
+  @Test public void createOkResponseForCacheGet_withMissingStatusLine() throws Exception {
+    URI uri = new URI("http://foo/bar");
+    Request request = new Request.Builder().url(uri.toURL()).build();
+    CacheResponse cacheResponse = new CacheResponse() {
+      @Override public Map<String, List<String>> getHeaders() throws IOException {
+        Map<String, List<String>> headers = new HashMap<>();
+        // Headers is deliberately missing an entry with a null key.
+        headers.put("xyzzy", Arrays.asList("bar", "baz"));
+        return headers;
+      }
+
+      @Override public InputStream getBody() throws IOException {
+        return null; // Should never be called
+      }
+    };
+
+    try {
+      JavaApiConverter.createOkResponseForCacheGet(request, cacheResponse);
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  @Test public void createOkResponseForCacheGet_secure() throws Exception {
     final String statusLine = "HTTP/1.1 200 Fantastic";
     final Principal localPrincipal = LOCAL_CERT.getSubjectX500Principal();
     final List<Certificate> localCertificates = Arrays.<Certificate>asList(LOCAL_CERT);
@@ -254,14 +177,15 @@ private void testCreateOkResponseInternal(HttpURLConnectionFactory httpUrlConnec
       }
 
       @Override public String getCipherSuite() {
-        return "SuperSecure";
+        return "SSL_RSA_WITH_NULL_MD5";
       }
 
       @Override public List<Certificate> getLocalCertificateChain() {
         return localCertificates;
       }
 
-      @Override public List<Certificate> getServerCertificateChain() throws SSLPeerUnverifiedException {
+      @Override public List<Certificate> getServerCertificateChain()
+          throws SSLPeerUnverifiedException {
         return serverCertificates;
       }
 
@@ -274,8 +198,11 @@ private void testCreateOkResponseInternal(HttpURLConnectionFactory httpUrlConnec
       }
     };
 
-    Response response = JavaApiConverter.createOkResponse(request, cacheResponse);
-    assertSame(request, response.request());
+    Response response = JavaApiConverter.createOkResponseForCacheGet(request, cacheResponse);
+    Request cacheRequest = response.request();
+    assertEquals(request.url(), cacheRequest.url());
+    assertEquals(request.method(), cacheRequest.method());
+    assertEquals(0, request.headers().size());
 
     assertEquals(Protocol.HTTP_1_1, response.protocol());
     assertEquals(200, response.code());
@@ -286,7 +213,7 @@ private void testCreateOkResponseInternal(HttpURLConnectionFactory httpUrlConnec
 
     Handshake handshake = response.handshake();
     assertNotNull(handshake);
-    assertNotNullAndEquals("SuperSecure", handshake.cipherSuite());
+    assertNotNullAndEquals(CipherSuite.TLS_RSA_WITH_NULL_MD5, handshake.cipherSuite());
     assertEquals(localPrincipal, handshake.localPrincipal());
     assertEquals(serverPrincipal, handshake.peerPrincipal());
     assertEquals(serverCertificates, handshake.peerCertificates());
@@ -296,10 +223,10 @@ private void testCreateOkResponseInternal(HttpURLConnectionFactory httpUrlConnec
   @Test public void createOkRequest_nullRequestHeaders() throws Exception {
     URI uri = new URI("http://foo/bar");
 
-    Map<String,List<String>> javaRequestHeaders = null;
+    Map<String, List<String>> javaRequestHeaders = null;
     Request request = JavaApiConverter.createOkRequest(uri, "POST", javaRequestHeaders);
     assertFalse(request.isHttps());
-    assertEquals(uri, request.uri());
+    assertEquals(uri, request.url().uri());
     Headers okRequestHeaders = request.headers();
     assertEquals(0, okRequestHeaders.size());
     assertEquals("POST", request.method());
@@ -308,11 +235,11 @@ private void testCreateOkResponseInternal(HttpURLConnectionFactory httpUrlConnec
   @Test public void createOkRequest_nonNullRequestHeaders() throws Exception {
     URI uri = new URI("https://foo/bar");
 
-    Map<String,List<String>> javaRequestHeaders = new HashMap<>();
+    Map<String, List<String>> javaRequestHeaders = new HashMap<>();
     javaRequestHeaders.put("Foo", Arrays.asList("Bar"));
     Request request = JavaApiConverter.createOkRequest(uri, "POST", javaRequestHeaders);
     assertTrue(request.isHttps());
-    assertEquals(uri, request.uri());
+    assertEquals(uri, request.url().uri());
     Headers okRequestHeaders = request.headers();
     assertEquals(1, okRequestHeaders.size());
     assertEquals("Bar", okRequestHeaders.get("Foo"));
@@ -326,12 +253,12 @@ private void testCreateOkResponseInternal(HttpURLConnectionFactory httpUrlConnec
   @Test public void createOkRequest_nullRequestHeaderKey() throws Exception {
     URI uri = new URI("https://foo/bar");
 
-    Map<String,List<String>> javaRequestHeaders = new HashMap<>();
+    Map<String, List<String>> javaRequestHeaders = new HashMap<>();
     javaRequestHeaders.put(null, Arrays.asList("GET / HTTP 1.1"));
     javaRequestHeaders.put("Foo", Arrays.asList("Bar"));
     Request request = JavaApiConverter.createOkRequest(uri, "POST", javaRequestHeaders);
     assertTrue(request.isHttps());
-    assertEquals(uri, request.uri());
+    assertEquals(uri, request.url().uri());
     Headers okRequestHeaders = request.headers();
     assertEquals(1, okRequestHeaders.size());
     assertEquals("Bar", okRequestHeaders.get("Foo"));
@@ -340,7 +267,8 @@ private void testCreateOkResponseInternal(HttpURLConnectionFactory httpUrlConnec
 
   @Test public void createJavaUrlConnection_requestChangesForbidden() throws Exception {
     Response okResponse = createArbitraryOkResponse();
-    HttpURLConnection httpUrlConnection = JavaApiConverter.createJavaUrlConnection(okResponse);
+    HttpURLConnection httpUrlConnection =
+        JavaApiConverter.createJavaUrlConnectionForCachePut(okResponse);
     // Check an arbitrary (not complete) set of methods that can be used to modify the
     // request.
     try {
@@ -372,7 +300,8 @@ private void testCreateOkResponseInternal(HttpURLConnectionFactory httpUrlConnec
 
   @Test public void createJavaUrlConnection_connectionChangesForbidden() throws Exception {
     Response okResponse = createArbitraryOkResponse();
-    HttpURLConnection httpUrlConnection = JavaApiConverter.createJavaUrlConnection(okResponse);
+    HttpURLConnection httpUrlConnection =
+        JavaApiConverter.createJavaUrlConnectionForCachePut(okResponse);
     try {
       httpUrlConnection.connect();
       fail();
@@ -387,11 +316,13 @@ private void testCreateOkResponseInternal(HttpURLConnectionFactory httpUrlConnec
 
   @Test public void createJavaUrlConnection_responseChangesForbidden() throws Exception {
     Response okResponse = createArbitraryOkResponse();
-    HttpURLConnection httpUrlConnection = JavaApiConverter.createJavaUrlConnection(okResponse);
+    HttpURLConnection httpUrlConnection =
+        JavaApiConverter.createJavaUrlConnectionForCachePut(okResponse);
     // Check an arbitrary (not complete) set of methods that can be used to access the response
     // body.
+    InputStream is = httpUrlConnection.getInputStream();
     try {
-      httpUrlConnection.getInputStream();
+      is.read();
       fail();
     } catch (UnsupportedOperationException expected) {
     }
@@ -431,7 +362,8 @@ private void testCreateOkResponseInternal(HttpURLConnectionFactory httpUrlConnec
         .body(responseBody)
         .build();
 
-    HttpURLConnection httpUrlConnection = JavaApiConverter.createJavaUrlConnection(okResponse);
+    HttpURLConnection httpUrlConnection =
+        JavaApiConverter.createJavaUrlConnectionForCachePut(okResponse);
     assertEquals(200, httpUrlConnection.getResponseCode());
     assertEquals("Fantastic", httpUrlConnection.getResponseMessage());
     assertEquals(responseBody.contentLength(), httpUrlConnection.getContentLength());
@@ -506,7 +438,8 @@ private void assertHeadersContainsMapping(Map<String, List<String>> headers, Str
         .get()
         .build();
     Response okResponse = createArbitraryOkResponse(okRequest);
-    HttpURLConnection httpUrlConnection = JavaApiConverter.createJavaUrlConnection(okResponse);
+    HttpURLConnection httpUrlConnection =
+        JavaApiConverter.createJavaUrlConnectionForCachePut(okResponse);
 
     assertEquals("GET", httpUrlConnection.getRequestMethod());
     assertTrue(httpUrlConnection.getDoInput());
@@ -518,7 +451,8 @@ private void assertHeadersContainsMapping(Map<String, List<String>> headers, Str
         .post(createRequestBody("PostBody"))
         .build();
     Response okResponse = createArbitraryOkResponse(okRequest);
-    HttpURLConnection httpUrlConnection = JavaApiConverter.createJavaUrlConnection(okResponse);
+    HttpURLConnection httpUrlConnection =
+        JavaApiConverter.createJavaUrlConnectionForCachePut(okResponse);
 
     assertEquals("POST", httpUrlConnection.getRequestMethod());
     assertTrue(httpUrlConnection.getDoInput());
@@ -530,18 +464,18 @@ private void assertHeadersContainsMapping(Map<String, List<String>> headers, Str
         .get()
         .url("https://secure/request")
         .build();
-    Handshake handshake = Handshake.get("SecureCipher", Arrays.<Certificate>asList(SERVER_CERT),
-        Arrays.<Certificate>asList(LOCAL_CERT));
+    Handshake handshake = Handshake.get(null, CipherSuite.TLS_RSA_WITH_NULL_MD5,
+        Arrays.<Certificate>asList(SERVER_CERT), Arrays.<Certificate>asList(LOCAL_CERT));
     Response okResponse = createArbitraryOkResponse(okRequest).newBuilder()
         .handshake(handshake)
         .build();
     HttpsURLConnection httpsUrlConnection =
-        (HttpsURLConnection) JavaApiConverter.createJavaUrlConnection(okResponse);
+        (HttpsURLConnection) JavaApiConverter.createJavaUrlConnectionForCachePut(okResponse);
 
-    assertEquals("SecureCipher", httpsUrlConnection.getCipherSuite());
+    assertEquals("SSL_RSA_WITH_NULL_MD5", httpsUrlConnection.getCipherSuite());
     assertEquals(SERVER_CERT.getSubjectX500Principal(), httpsUrlConnection.getPeerPrincipal());
-    assertArrayEquals(new Certificate[] { LOCAL_CERT }, httpsUrlConnection.getLocalCertificates());
-    assertArrayEquals(new Certificate[] { SERVER_CERT },
+    assertArrayEquals(new Certificate[] {LOCAL_CERT}, httpsUrlConnection.getLocalCertificates());
+    assertArrayEquals(new Certificate[] {SERVER_CERT},
         httpsUrlConnection.getServerCertificates());
     assertEquals(LOCAL_CERT.getSubjectX500Principal(), httpsUrlConnection.getLocalPrincipal());
   }
@@ -552,7 +486,7 @@ private void assertHeadersContainsMapping(Map<String, List<String>> headers, Str
         .build();
     Response okResponse = createArbitraryOkResponse(okRequest);
     HttpsURLConnection httpsUrlConnection =
-        (HttpsURLConnection) JavaApiConverter.createJavaUrlConnection(okResponse);
+        (HttpsURLConnection) JavaApiConverter.createJavaUrlConnectionForCachePut(okResponse);
 
     try {
       httpsUrlConnection.getHostnameVerifier();
@@ -617,11 +551,11 @@ private void assertHeadersContainsMapping(Map<String, List<String>> headers, Str
     Request okRequest =
         createArbitraryOkRequest().newBuilder()
             .url("https://secure/request")
-            .post(createRequestBody("RequestBody") )
+            .post(createRequestBody("RequestBody"))
             .build();
     ResponseBody responseBody = createResponseBody("ResponseBody");
-    Handshake handshake = Handshake.get("SecureCipher", Arrays.<Certificate>asList(SERVER_CERT),
-        Arrays.<Certificate>asList(LOCAL_CERT));
+    Handshake handshake = Handshake.get(null, CipherSuite.TLS_RSA_WITH_NULL_MD5,
+        Arrays.<Certificate>asList(SERVER_CERT), Arrays.<Certificate>asList(LOCAL_CERT));
     Response okResponse = createArbitraryOkResponse(okRequest).newBuilder()
         .protocol(Protocol.HTTP_1_1)
         .code(200)
@@ -638,7 +572,7 @@ private void assertHeadersContainsMapping(Map<String, List<String>> headers, Str
     assertEquals(Arrays.asList("value1_1", "value1_2"), javaHeaders.get("key1"));
     assertEquals(Arrays.asList("HTTP/1.1 200 Fantastic"), javaHeaders.get(null));
     assertEquals("ResponseBody", readAll(javaCacheResponse.getBody()));
-    assertEquals(handshake.cipherSuite(), javaCacheResponse.getCipherSuite());
+    assertEquals(handshake.cipherSuite().javaName(), javaCacheResponse.getCipherSuite());
     assertEquals(handshake.localCertificates(), javaCacheResponse.getLocalCertificateChain());
     assertEquals(handshake.peerCertificates(), javaCacheResponse.getServerCertificateChain());
     assertEquals(handshake.localPrincipal(), javaCacheResponse.getLocalPrincipal());
@@ -663,32 +597,24 @@ private void assertHeadersContainsMapping(Map<String, List<String>> headers, Str
     javaResponseHeaders.put("key1", Arrays.asList("value1_1", "value1_2"));
     javaResponseHeaders.put("key2", Arrays.asList("value2"));
 
-    Headers okHeaders = JavaApiConverter.extractOkHeaders(javaResponseHeaders);
+    Headers okHeaders = JavaApiConverter.extractOkHeaders(javaResponseHeaders, null);
     assertEquals(3, okHeaders.size()); // null entry should be stripped out
     assertEquals(Arrays.asList("value1_1", "value1_2"), okHeaders.values("key1"));
     assertEquals(Arrays.asList("value2"), okHeaders.values("key2"));
   }
 
-  @Test public void extractStatusLine() {
+  @Test public void extractStatusLine() throws Exception {
     Map<String, List<String>> javaResponseHeaders = new HashMap<>();
     javaResponseHeaders.put(null, Arrays.asList("StatusLine"));
     javaResponseHeaders.put("key1", Arrays.asList("value1_1", "value1_2"));
     javaResponseHeaders.put("key2", Arrays.asList("value2"));
     assertEquals("StatusLine", JavaApiConverter.extractStatusLine(javaResponseHeaders));
 
-    assertNull(
-        JavaApiConverter.extractStatusLine(Collections.<String, List<String>>emptyMap()));
-  }
-
-  private URL configureServer(MockResponse mockResponse) throws Exception {
-    server.enqueue(mockResponse);
-    return server.getUrl("/");
-  }
-
-  private URL configureHttpsServer(MockResponse mockResponse) throws Exception {
-    server.get().useHttps(sslContext.getSocketFactory(), false /* tunnelProxy */);
-    server.enqueue(mockResponse);
-    return server.getUrl("/");
+    try {
+      JavaApiConverter.extractStatusLine(Collections.<String, List<String>>emptyMap());
+      fail();
+    } catch (IOException expected) {
+    }
   }
 
   private static <T> void assertNotNullAndEquals(T expected, T actual) {
@@ -696,28 +622,6 @@ private URL configureHttpsServer(MockResponse mockResponse) throws Exception {
     assertEquals(expected, actual);
   }
 
-  private interface HttpURLConnectionFactory {
-    public HttpURLConnection open(URL serverUrl) throws IOException;
-  }
-
-  private static class OkHttpURLConnectionFactory implements HttpURLConnectionFactory {
-    protected final OkHttpClient client;
-
-    private OkHttpURLConnectionFactory(OkHttpClient client) {
-      this.client = client;
-    }
-
-    @Override public HttpURLConnection open(URL serverUrl) {
-      return new OkUrlFactory(client).open(serverUrl);
-    }
-  }
-
-  private static class JavaHttpURLConnectionFactory implements HttpURLConnectionFactory {
-    @Override public HttpURLConnection open(URL serverUrl) throws IOException {
-      return (HttpURLConnection) serverUrl.openConnection();
-    }
-  }
-
   private static X509Certificate certificate(String certificate) {
     try {
       return (X509Certificate) CertificateFactory.getInstance("X.509").generateCertificate(
@@ -728,6 +632,7 @@ private static X509Certificate certificate(String certificate) {
     }
   }
 
+  @SafeVarargs
   private static <T> Set<T> newSet(T... elements) {
     return newSet(Arrays.asList(elements));
   }
diff --git a/okhttp-android-support/src/test/java/okhttp3/internal/huc/ResponseCacheTest.java b/okhttp-android-support/src/test/java/okhttp3/internal/huc/ResponseCacheTest.java
new file mode 100644
index 0000000000..90864623b8
--- /dev/null
+++ b/okhttp-android-support/src/test/java/okhttp3/internal/huc/ResponseCacheTest.java
@@ -0,0 +1,2191 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package okhttp3.internal.huc;
+
+import java.io.BufferedReader;
+import java.io.ByteArrayInputStream;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.OutputStream;
+import java.net.CacheRequest;
+import java.net.CacheResponse;
+import java.net.CookieManager;
+import java.net.HttpCookie;
+import java.net.HttpURLConnection;
+import java.net.ProtocolException;
+import java.net.ResponseCache;
+import java.net.SecureCacheResponse;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.net.URL;
+import java.net.URLConnection;
+import java.nio.charset.StandardCharsets;
+import java.security.Principal;
+import java.security.cert.Certificate;
+import java.text.DateFormat;
+import java.text.SimpleDateFormat;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.TimeZone;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicReference;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.HttpsURLConnection;
+import okhttp3.AbstractResponseCache;
+import okhttp3.AndroidInternal;
+import okhttp3.AndroidShimResponseCache;
+import okhttp3.Headers;
+import okhttp3.OkHttpClient;
+import okhttp3.OkUrlFactory;
+import okhttp3.RecordingHostnameVerifier;
+import okhttp3.internal.Internal;
+import okhttp3.internal.InternalCache;
+import okhttp3.internal.tls.SslClient;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
+import okhttp3.mockwebserver.SocketPolicy;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.GzipSink;
+import okio.Okio;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+/**
+ * Tests the interaction between OkHttp and {@link ResponseCache}. Based on okhttp3.CacheTest with
+ * changes for ResponseCache and HttpURLConnection.
+ */
+public final class ResponseCacheTest {
+  @Rule public TemporaryFolder cacheRule = new TemporaryFolder();
+  @Rule public MockWebServer server = new MockWebServer();
+  @Rule public MockWebServer server2 = new MockWebServer();
+
+  private HostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
+  private SslClient sslClient = SslClient.localhost();
+  private ResponseCache cache;
+  private CookieManager cookieManager;
+  private OkUrlFactory urlFactory;
+
+  @Before public void setUp() throws Exception {
+    server.setProtocolNegotiationEnabled(false);
+
+    cache = AndroidShimResponseCache.create(cacheRule.getRoot(), 10 * 1024 * 1024);
+    urlFactory = new OkUrlFactory(new OkHttpClient());
+    AndroidInternal.setResponseCache(urlFactory, cache);
+
+    cookieManager = new CookieManager();
+  }
+
+  @After public void tearDown() throws Exception {
+    ResponseCache.setDefault(null);
+  }
+
+  private HttpURLConnection openConnection(URL url) {
+    return urlFactory.open(url);
+  }
+
+  /**
+   * Test that response caching is consistent with the RI and the spec.
+   * http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.4
+   */
+  @Test public void responseCachingByResponseCode() throws Exception {
+    // Test each documented HTTP/1.1 code, plus the first unused value in each range.
+    // http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html
+
+    // We can't test 100 because it's not really a response.
+    // assertCached(false, 100);
+    assertCached(false, 101);
+    assertCached(false, 102);
+    assertCached(true, 200);
+    assertCached(false, 201);
+    assertCached(false, 202);
+    assertCached(true, 203);
+    assertCached(true, 204);
+    assertCached(false, 205);
+    assertCached(false, 206); //Electing to not cache partial responses
+    assertCached(false, 207);
+    assertCached(true, 300);
+    assertCached(true, 301);
+    assertCached(true, 302);
+    assertCached(false, 303);
+    assertCached(false, 304);
+    assertCached(false, 305);
+    assertCached(false, 306);
+    assertCached(true, 307);
+    assertCached(true, 308);
+    assertCached(false, 400);
+    assertCached(false, 401);
+    assertCached(false, 402);
+    assertCached(false, 403);
+    assertCached(true, 404);
+    assertCached(true, 405);
+    assertCached(false, 406);
+    assertCached(false, 408);
+    assertCached(false, 409);
+    // the HTTP spec permits caching 410s, but the RI doesn't.
+    assertCached(true, 410);
+    assertCached(false, 411);
+    assertCached(false, 412);
+    assertCached(false, 413);
+    assertCached(true, 414);
+    assertCached(false, 415);
+    assertCached(false, 416);
+    assertCached(false, 417);
+    assertCached(false, 418);
+
+    assertCached(false, 500);
+    assertCached(true, 501);
+    assertCached(false, 502);
+    assertCached(false, 503);
+    assertCached(false, 504);
+    assertCached(false, 505);
+    assertCached(false, 506);
+  }
+
+  private void assertCached(boolean shouldPut, int responseCode) throws Exception {
+    int expectedResponseCode = responseCode;
+
+    server = new MockWebServer();
+    MockResponse mockResponse = new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setResponseCode(responseCode)
+        .setBody("ABCDE")
+        .addHeader("WWW-Authenticate: challenge");
+    if (responseCode == HttpURLConnection.HTTP_PROXY_AUTH) {
+      mockResponse.addHeader("Proxy-Authenticate: Basic realm=\"protected area\"");
+    } else if (responseCode == HttpURLConnection.HTTP_UNAUTHORIZED) {
+      mockResponse.addHeader("WWW-Authenticate: Basic realm=\"protected area\"");
+    } else if (responseCode == HttpURLConnection.HTTP_NO_CONTENT
+        || responseCode == HttpURLConnection.HTTP_RESET) {
+      mockResponse.setBody(""); // We forbid bodies for 204 and 205.
+    }
+    server.enqueue(mockResponse);
+
+    if (responseCode == HttpURLConnection.HTTP_CLIENT_TIMEOUT) {
+      // 408's are a bit of an outlier because we may repeat the request if we encounter this
+      // response code. In this scenario, there are 2 responses: the initial 408 and then the 200
+      // because of the retry. We just want to ensure the initial 408 isn't cached.
+      expectedResponseCode = 200;
+      server.enqueue(new MockResponse()
+          .setHeader("Cache-Control", "no-store")
+          .setBody("FGHIJ"));
+    }
+
+    server.start();
+
+    URL url = server.url("/").url();
+    HttpURLConnection connection = openConnection(url);
+    assertEquals(expectedResponseCode, connection.getResponseCode());
+
+    // Exhaust the content stream.
+    readAscii(connection);
+
+    CacheResponse cached = cache.get(url.toURI(), "GET", null);
+    if (shouldPut) {
+      assertNotNull(Integer.toString(responseCode), cached);
+    } else {
+      assertNull(Integer.toString(responseCode), cached);
+    }
+    server.shutdown(); // tearDown() isn't sufficient; this test starts multiple servers
+  }
+
+  @Test public void responseCachingAndInputStreamSkipWithFixedLength() throws IOException {
+    testResponseCaching(TransferKind.FIXED_LENGTH);
+  }
+
+  @Test public void responseCachingAndInputStreamSkipWithChunkedEncoding() throws IOException {
+    testResponseCaching(TransferKind.CHUNKED);
+  }
+
+  @Test public void responseCachingAndInputStreamSkipWithNoLengthHeaders() throws IOException {
+    testResponseCaching(TransferKind.END_OF_STREAM);
+  }
+
+  /**
+   * HttpURLConnection.getInputStream().skip(long) causes ResponseCache corruption
+   * http://code.google.com/p/android/issues/detail?id=8175
+   */
+  private void testResponseCaching(TransferKind transferKind) throws IOException {
+    MockResponse mockResponse = new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setStatus("HTTP/1.1 200 Fantastic");
+    transferKind.setBody(mockResponse, "I love puppies but hate spiders", 1);
+    server.enqueue(mockResponse);
+
+    // Make sure that calling skip() doesn't omit bytes from the cache.
+    HttpURLConnection urlConnection = openConnection(server.url("/").url());
+    InputStream in = urlConnection.getInputStream();
+    assertEquals("I love ", readAscii(urlConnection, "I love ".length()));
+    reliableSkip(in, "puppies but hate ".length());
+    assertEquals("spiders", readAscii(urlConnection, "spiders".length()));
+    assertEquals(-1, in.read());
+    in.close();
+
+    urlConnection = openConnection(server.url("/").url()); // cached!
+    in = urlConnection.getInputStream();
+    assertEquals("I love puppies but hate spiders",
+        readAscii(urlConnection, "I love puppies but hate spiders".length()));
+    assertEquals(200, urlConnection.getResponseCode());
+    assertEquals("Fantastic", urlConnection.getResponseMessage());
+
+    assertEquals(-1, in.read());
+    in.close();
+  }
+
+  @Test public void secureResponseCaching() throws IOException {
+    server.useHttps(sslClient.socketFactory, false);
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setBody("ABC"));
+
+    HttpsURLConnection c1 = (HttpsURLConnection) openConnection(server.url("/").url());
+    c1.setSSLSocketFactory(sslClient.socketFactory);
+    c1.setHostnameVerifier(hostnameVerifier);
+    assertEquals("ABC", readAscii(c1));
+
+    // OpenJDK 6 fails on this line, complaining that the connection isn't open yet
+    String suite = c1.getCipherSuite();
+    List<Certificate> localCerts = toListOrNull(c1.getLocalCertificates());
+    List<Certificate> serverCerts = toListOrNull(c1.getServerCertificates());
+    Principal peerPrincipal = c1.getPeerPrincipal();
+    Principal localPrincipal = c1.getLocalPrincipal();
+
+    HttpsURLConnection c2 = (HttpsURLConnection) openConnection(server.url("/").url()); // cached!
+    c2.setSSLSocketFactory(sslClient.socketFactory);
+    c2.setHostnameVerifier(hostnameVerifier);
+    assertEquals("ABC", readAscii(c2));
+
+    assertEquals(suite, c2.getCipherSuite());
+    assertEquals(localCerts, toListOrNull(c2.getLocalCertificates()));
+    assertEquals(serverCerts, toListOrNull(c2.getServerCertificates()));
+    assertEquals(peerPrincipal, c2.getPeerPrincipal());
+    assertEquals(localPrincipal, c2.getLocalPrincipal());
+  }
+
+  @Test public void responseCachingAndRedirects() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
+        .addHeader("Location: /foo"));
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setBody("ABC"));
+    server.enqueue(new MockResponse()
+        .setBody("DEF"));
+
+    HttpURLConnection connection = openConnection(server.url("/").url());
+    assertEquals("ABC", readAscii(connection));
+
+    connection = openConnection(server.url("/").url()); // cached!
+    assertEquals("ABC", readAscii(connection));
+  }
+
+  @Test public void redirectToCachedResult() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .setBody("ABC"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
+        .addHeader("Location: /foo"));
+    server.enqueue(new MockResponse()
+        .setBody("DEF"));
+
+    assertEquals("ABC", readAscii(openConnection(server.url("/foo").url())));
+    RecordedRequest request1 = server.takeRequest();
+    assertEquals("GET /foo HTTP/1.1", request1.getRequestLine());
+    assertEquals(0, request1.getSequenceNumber());
+
+    assertEquals("ABC", readAscii(openConnection(server.url("/bar").url())));
+    RecordedRequest request2 = server.takeRequest();
+    assertEquals("GET /bar HTTP/1.1", request2.getRequestLine());
+    assertEquals(1, request2.getSequenceNumber());
+
+    // an unrelated request should reuse the pooled connection
+    assertEquals("DEF", readAscii(openConnection(server.url("/baz").url())));
+    RecordedRequest request3 = server.takeRequest();
+    assertEquals("GET /baz HTTP/1.1", request3.getRequestLine());
+    assertEquals(2, request3.getSequenceNumber());
+  }
+
+  @Test public void secureResponseCachingAndRedirects() throws IOException {
+    server.useHttps(sslClient.socketFactory, false);
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
+        .addHeader("Location: /foo"));
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setBody("ABC"));
+    server.enqueue(new MockResponse()
+        .setBody("DEF"));
+
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(hostnameVerifier)
+        .build());
+
+    HttpsURLConnection connection1 = (HttpsURLConnection) openConnection(server.url("/").url());
+    assertEquals("ABC", readAscii(connection1));
+    assertNotNull(connection1.getCipherSuite());
+
+    // Cached!
+    HttpsURLConnection connection2 = (HttpsURLConnection) openConnection(server.url("/").url());
+    assertEquals("ABC", readAscii(connection2));
+    assertNotNull(connection2.getCipherSuite());
+
+    assertEquals(connection1.getCipherSuite(), connection2.getCipherSuite());
+  }
+
+  /**
+   * We've had bugs where caching and cross-protocol redirects yield class cast exceptions internal
+   * to the cache because we incorrectly assumed that HttpsURLConnection was always HTTPS and
+   * HttpURLConnection was always HTTP; in practice redirects mean that each can do either.
+   *
+   * https://github.com/square/okhttp/issues/214
+   */
+  @Test public void secureResponseCachingAndProtocolRedirects() throws IOException {
+    server2.useHttps(sslClient.socketFactory, false);
+    server2.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setBody("ABC"));
+    server2.enqueue(new MockResponse()
+        .setBody("DEF"));
+
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
+        .addHeader("Location: " + server2.url("/").url()));
+
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(hostnameVerifier)
+        .build());
+
+    HttpURLConnection connection1 = openConnection(server.url("/").url());
+    assertEquals("ABC", readAscii(connection1));
+
+    // Cached!
+    HttpURLConnection connection2 = openConnection(server.url("/").url());
+    assertEquals("ABC", readAscii(connection2));
+  }
+
+  @Test public void foundCachedWithExpiresHeader() throws Exception {
+    temporaryRedirectCachedWithCachingHeader(302, "Expires", formatDate(1, TimeUnit.HOURS));
+  }
+
+  @Test public void foundCachedWithCacheControlHeader() throws Exception {
+    temporaryRedirectCachedWithCachingHeader(302, "Cache-Control", "max-age=60");
+  }
+
+  @Test public void temporaryRedirectCachedWithExpiresHeader() throws Exception {
+    temporaryRedirectCachedWithCachingHeader(307, "Expires", formatDate(1, TimeUnit.HOURS));
+  }
+
+  @Test public void temporaryRedirectCachedWithCacheControlHeader() throws Exception {
+    temporaryRedirectCachedWithCachingHeader(307, "Cache-Control", "max-age=60");
+  }
+
+  @Test public void foundNotCachedWithoutCacheHeader() throws Exception {
+    temporaryRedirectNotCachedWithoutCachingHeader(302);
+  }
+
+  @Test public void temporaryRedirectNotCachedWithoutCacheHeader() throws Exception {
+    temporaryRedirectNotCachedWithoutCachingHeader(307);
+  }
+
+  private void temporaryRedirectCachedWithCachingHeader(
+      int responseCode, String headerName, String headerValue) throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(responseCode)
+        .addHeader(headerName, headerValue)
+        .addHeader("Location", "/a"));
+    server.enqueue(new MockResponse()
+        .addHeader(headerName, headerValue)
+        .setBody("a"));
+    server.enqueue(new MockResponse()
+        .setBody("b"));
+    server.enqueue(new MockResponse()
+        .setBody("c"));
+
+    URL url = server.url("/").url();
+    assertEquals("a", readAscii(openConnection(url)));
+    assertEquals("a", readAscii(openConnection(url)));
+  }
+
+  private void temporaryRedirectNotCachedWithoutCachingHeader(int responseCode) throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(responseCode)
+        .addHeader("Location", "/a"));
+    server.enqueue(new MockResponse()
+        .setBody("a"));
+    server.enqueue(new MockResponse()
+        .setBody("b"));
+
+    URL url = server.url("/").url();
+    assertEquals("a", readAscii(openConnection(url)));
+    assertEquals("b", readAscii(openConnection(url)));
+  }
+
+  @Test public void serverDisconnectsPrematurelyWithContentLengthHeader() throws IOException {
+    testServerPrematureDisconnect(TransferKind.FIXED_LENGTH);
+  }
+
+  @Test public void serverDisconnectsPrematurelyWithChunkedEncoding() throws IOException {
+    testServerPrematureDisconnect(TransferKind.CHUNKED);
+  }
+
+  @Test public void serverDisconnectsPrematurelyWithNoLengthHeaders() throws IOException {
+    // Intentionally empty. This case doesn't make sense because there's no
+    // such thing as a premature disconnect when the disconnect itself
+    // indicates the end of the data stream.
+  }
+
+  private void testServerPrematureDisconnect(TransferKind transferKind) throws IOException {
+    MockResponse response = new MockResponse();
+    transferKind.setBody(response, "ABCDE\nFGHIJKLMNOPQRSTUVWXYZ", 16);
+    server.enqueue(truncateViolently(response, 16));
+    server.enqueue(new MockResponse()
+        .setBody("Request #2"));
+
+    BufferedReader reader = new BufferedReader(
+        new InputStreamReader(openConnection(server.url("/").url()).getInputStream()));
+    assertEquals("ABCDE", reader.readLine());
+    try {
+      reader.readLine();
+      fail("This implementation silently ignored a truncated HTTP body.");
+    } catch (IOException expected) {
+    } finally {
+      reader.close();
+    }
+
+    URLConnection connection = openConnection(server.url("/").url());
+    assertEquals("Request #2", readAscii(connection));
+  }
+
+  @Test public void clientPrematureDisconnectWithContentLengthHeader() throws IOException {
+    testClientPrematureDisconnect(TransferKind.FIXED_LENGTH);
+  }
+
+  @Test public void clientPrematureDisconnectWithChunkedEncoding() throws IOException {
+    testClientPrematureDisconnect(TransferKind.CHUNKED);
+  }
+
+  @Test public void clientPrematureDisconnectWithNoLengthHeaders() throws IOException {
+    testClientPrematureDisconnect(TransferKind.END_OF_STREAM);
+  }
+
+  private void testClientPrematureDisconnect(TransferKind transferKind) throws IOException {
+    // Setting a low transfer speed ensures that stream discarding will time out.
+    MockResponse response = new MockResponse()
+        .throttleBody(6, 1, TimeUnit.SECONDS);
+    transferKind.setBody(response, "ABCDE\nFGHIJKLMNOPQRSTUVWXYZ", 1024);
+    server.enqueue(response);
+    server.enqueue(new MockResponse()
+        .setBody("Request #2"));
+
+    URLConnection connection = openConnection(server.url("/").url());
+    InputStream in = connection.getInputStream();
+    assertEquals("ABCDE", readAscii(connection, 5));
+    in.close();
+    try {
+      in.read();
+      fail("Expected an IOException because the stream is closed.");
+    } catch (IOException expected) {
+    }
+
+    connection = openConnection(server.url("/").url());
+    assertEquals("Request #2", readAscii(connection));
+  }
+
+  @Test public void defaultExpirationDateFullyCachedForLessThan24Hours() throws Exception {
+    //      last modified: 105 seconds ago
+    //             served:   5 seconds ago
+    //   default lifetime: (105 - 5) / 10 = 10 seconds
+    //            expires:  10 seconds from served date = 5 seconds from now
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-105, TimeUnit.SECONDS))
+        .addHeader("Date: " + formatDate(-5, TimeUnit.SECONDS))
+        .setBody("A"));
+
+    URL url = server.url("/").url();
+    assertEquals("A", readAscii(openConnection(url)));
+    URLConnection connection = openConnection(url);
+    assertEquals("A", readAscii(connection));
+    assertNull(connection.getHeaderField("Warning"));
+  }
+
+  @Test public void defaultExpirationDateConditionallyCached() throws Exception {
+    //      last modified: 115 seconds ago
+    //             served:  15 seconds ago
+    //   default lifetime: (115 - 15) / 10 = 10 seconds
+    //            expires:  10 seconds from served date = 5 seconds ago
+    String lastModifiedDate = formatDate(-115, TimeUnit.SECONDS);
+    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
+        .addHeader("Last-Modified: " + lastModifiedDate)
+        .addHeader("Date: " + formatDate(-15, TimeUnit.SECONDS)));
+    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
+  }
+
+  @Test public void defaultExpirationDateFullyCachedForMoreThan24Hours() throws Exception {
+    //      last modified: 105 days ago
+    //             served:   5 days ago
+    //   default lifetime: (105 - 5) / 10 = 10 days
+    //            expires:  10 days from served date = 5 days from now
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-105, TimeUnit.DAYS))
+        .addHeader("Date: " + formatDate(-5, TimeUnit.DAYS))
+        .setBody("A"));
+
+    assertEquals("A", readAscii(openConnection(server.url("/").url())));
+    URLConnection connection = openConnection(server.url("/").url());
+    assertEquals("A", readAscii(connection));
+    assertEquals("113 HttpURLConnection \"Heuristic expiration\"",
+        connection.getHeaderField("Warning"));
+  }
+
+  @Test public void noDefaultExpirationForUrlsWithQueryString() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-105, TimeUnit.SECONDS))
+        .addHeader("Date: " + formatDate(-5, TimeUnit.SECONDS))
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    URL url = server.url("/?foo=bar").url();
+    assertEquals("A", readAscii(openConnection(url)));
+    assertEquals("B", readAscii(openConnection(url)));
+  }
+
+  @Test public void expirationDateInThePastWithLastModifiedHeader() throws Exception {
+    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
+    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
+        .addHeader("Last-Modified: " + lastModifiedDate)
+        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
+    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
+  }
+
+  @Test public void expirationDateInThePastWithNoLastModifiedHeader() throws Exception {
+    assertNotCached(new MockResponse()
+        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
+  }
+
+  @Test public void expirationDateInTheFuture() throws Exception {
+    assertFullyCached(new MockResponse()
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
+  }
+
+  @Test public void maxAgePreferredWithMaxAgeAndExpires() throws Exception {
+    assertFullyCached(new MockResponse()
+        .addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=60"));
+  }
+
+  @Test public void maxAgeInThePastWithDateAndLastModifiedHeaders() throws Exception {
+    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
+    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
+        .addHeader("Date: " + formatDate(-120, TimeUnit.SECONDS))
+        .addHeader("Last-Modified: " + lastModifiedDate)
+        .addHeader("Cache-Control: max-age=60"));
+    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
+  }
+
+  @Test public void maxAgeInThePastWithDateHeaderButNoLastModifiedHeader() throws Exception {
+    // Chrome interprets max-age relative to the local clock. Both our cache
+    // and Firefox both use the earlier of the local and server's clock.
+    assertNotCached(new MockResponse()
+        .addHeader("Date: " + formatDate(-120, TimeUnit.SECONDS))
+        .addHeader("Cache-Control: max-age=60"));
+  }
+
+  @Test public void maxAgeInTheFutureWithDateHeader() throws Exception {
+    assertFullyCached(new MockResponse()
+        .addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=60"));
+  }
+
+  @Test public void maxAgeInTheFutureWithNoDateHeader() throws Exception {
+    assertFullyCached(new MockResponse()
+        .addHeader("Cache-Control: max-age=60"));
+  }
+
+  @Test public void maxAgeWithLastModifiedButNoServedDate() throws Exception {
+    assertFullyCached(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
+        .addHeader("Cache-Control: max-age=60"));
+  }
+
+  @Test public void maxAgeInTheFutureWithDateAndLastModifiedHeaders() throws Exception {
+    assertFullyCached(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
+        .addHeader("Date: " + formatDate(0, TimeUnit.SECONDS))
+        .addHeader("Cache-Control: max-age=60"));
+  }
+
+  @Test public void maxAgePreferredOverLowerSharedMaxAge() throws Exception {
+    assertFullyCached(new MockResponse()
+        .addHeader("Date: " + formatDate(-2, TimeUnit.MINUTES))
+        .addHeader("Cache-Control: s-maxage=60")
+        .addHeader("Cache-Control: max-age=180"));
+  }
+
+  @Test public void maxAgePreferredOverHigherMaxAge() throws Exception {
+    assertNotCached(new MockResponse()
+        .addHeader("Date: " + formatDate(-2, TimeUnit.MINUTES))
+        .addHeader("Cache-Control: s-maxage=180")
+        .addHeader("Cache-Control: max-age=60"));
+  }
+
+  @Test public void requestMethodOptionsIsNotCached() throws Exception {
+    testRequestMethod("OPTIONS", false);
+  }
+
+  @Test public void requestMethodGetIsCached() throws Exception {
+    testRequestMethod("GET", true);
+  }
+
+  @Test public void requestMethodHeadIsNotCached() throws Exception {
+    // We could support this but choose not to for implementation simplicity
+    testRequestMethod("HEAD", false);
+  }
+
+  @Test public void requestMethodPostIsNotCached() throws Exception {
+    // We could support this but choose not to for implementation simplicity
+    testRequestMethod("POST", false);
+  }
+
+  @Test public void requestMethodPutIsNotCached() throws Exception {
+    testRequestMethod("PUT", false);
+  }
+
+  @Test public void requestMethodDeleteIsNotCached() throws Exception {
+    testRequestMethod("DELETE", false);
+  }
+
+  @Test public void requestMethodTraceIsNotCached() throws Exception {
+    testRequestMethod("TRACE", false);
+  }
+
+  private void testRequestMethod(String requestMethod, boolean expectCached) throws Exception {
+    // 1. seed the cache (potentially)
+    // 2. expect a cache hit or miss
+    server.enqueue(new MockResponse()
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .addHeader("X-Response-ID: 1"));
+    server.enqueue(new MockResponse()
+        .addHeader("X-Response-ID: 2"));
+
+    URL url = server.url("/").url();
+
+    HttpURLConnection request1 = openConnection(url);
+    request1.setRequestMethod(requestMethod);
+    addRequestBodyIfNecessary(requestMethod, request1);
+    request1.getInputStream().close();
+    assertEquals("1", request1.getHeaderField("X-Response-ID"));
+
+    URLConnection request2 = openConnection(url);
+    request2.getInputStream().close();
+    if (expectCached) {
+      assertEquals("1", request2.getHeaderField("X-Response-ID"));
+    } else {
+      assertEquals("2", request2.getHeaderField("X-Response-ID"));
+    }
+  }
+
+  private void addRequestBodyIfNecessary(String requestMethod, HttpURLConnection connection)
+      throws IOException {
+    if (requestMethod.equals("POST") || requestMethod.equals("PUT")) {
+      connection.setDoOutput(true);
+      OutputStream requestBody = connection.getOutputStream();
+      requestBody.write('x');
+      requestBody.close();
+    }
+  }
+
+  @Test public void postInvalidatesCache() throws Exception {
+    testMethodInvalidates("POST");
+  }
+
+  @Test public void putInvalidatesCache() throws Exception {
+    testMethodInvalidates("PUT");
+  }
+
+  @Test public void deleteMethodInvalidatesCache() throws Exception {
+    testMethodInvalidates("DELETE");
+  }
+
+  private void testMethodInvalidates(String requestMethod) throws Exception {
+    // 1. seed the cache
+    // 2. invalidate it
+    // 3. expect a cache miss
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+    server.enqueue(new MockResponse()
+        .setBody("C"));
+
+    URL url = server.url("/").url();
+
+    assertEquals("A", readAscii(openConnection(url)));
+
+    HttpURLConnection invalidateConnection = openConnection(url);
+    invalidateConnection.setRequestMethod(requestMethod);
+    assertEquals("B", readAscii(invalidateConnection));
+
+    assertEquals("C", readAscii(openConnection(url)));
+  }
+
+  /**
+   * Equivalent to {@code CacheTest.postInvalidatesCacheWithUncacheableResponse()} but demonstrating
+   * that {@link ResponseCache} provides no mechanism for cache invalidation as the result of
+   * locally-made requests. In reality invalidation could take place from other clients at any
+   * time.
+   */
+  @Test public void postInvalidatesCacheWithUncacheableResponse() throws Exception {
+    // 1. seed the cache
+    // 2. invalidate it with uncacheable response
+    // 3. the cache to return the original value
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
+    server.enqueue(new MockResponse()
+        .setBody("B")
+        .setResponseCode(500));
+
+    URL url = server.url("/").url();
+
+    assertEquals("A", readAscii(openConnection(url)));
+
+    HttpURLConnection invalidate = openConnection(url);
+    invalidate.setRequestMethod("POST");
+    addRequestBodyIfNecessary("POST", invalidate);
+    assertEquals("B", readAscii(invalidate));
+
+    assertEquals("A", readAscii(openConnection(url)));
+  }
+
+  @Test public void etag() throws Exception {
+    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
+        .addHeader("ETag: v1"));
+    assertEquals("v1", conditionalRequest.getHeader("If-None-Match"));
+  }
+
+  /** If both If-Modified-Since and If-None-Match conditions apply, send only If-None-Match. */
+  @Test public void etagAndExpirationDateInThePast() throws Exception {
+    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
+    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
+        .addHeader("ETag: v1")
+        .addHeader("Last-Modified: " + lastModifiedDate)
+        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
+    assertEquals("v1", conditionalRequest.getHeader("If-None-Match"));
+    assertNull(conditionalRequest.getHeader("If-Modified-Since"));
+  }
+
+  @Test public void etagAndExpirationDateInTheFuture() throws Exception {
+    assertFullyCached(new MockResponse()
+        .addHeader("ETag: v1")
+        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
+  }
+
+  @Test public void cacheControlNoCache() throws Exception {
+    assertNotCached(new MockResponse()
+        .addHeader("Cache-Control: no-cache"));
+  }
+
+  @Test public void cacheControlNoCacheAndExpirationDateInTheFuture() throws Exception {
+    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
+    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
+        .addHeader("Last-Modified: " + lastModifiedDate)
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: no-cache"));
+    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
+  }
+
+  @Test public void pragmaNoCache() throws Exception {
+    assertNotCached(new MockResponse()
+        .addHeader("Pragma: no-cache"));
+  }
+
+  @Test public void pragmaNoCacheAndExpirationDateInTheFuture() throws Exception {
+    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
+    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
+        .addHeader("Last-Modified: " + lastModifiedDate)
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .addHeader("Pragma: no-cache"));
+    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
+  }
+
+  @Test public void cacheControlNoStore() throws Exception {
+    assertNotCached(new MockResponse()
+        .addHeader("Cache-Control: no-store"));
+  }
+
+  @Test public void cacheControlNoStoreAndExpirationDateInTheFuture() throws Exception {
+    assertNotCached(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: no-store"));
+  }
+
+  @Test public void partialRangeResponsesDoNotCorruptCache() throws Exception {
+    // 1. request a range
+    // 2. request a full document, expecting a cache miss
+    server.enqueue(new MockResponse()
+        .setBody("AA")
+        .setResponseCode(HttpURLConnection.HTTP_PARTIAL)
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .addHeader("Content-Range: bytes 1000-1001/2000"));
+    server.enqueue(new MockResponse()
+        .setBody("BB"));
+
+    URL url = server.url("/").url();
+
+    HttpURLConnection range = openConnection(url);
+    range.addRequestProperty("Range", "bytes=1000-1001");
+    assertEquals("AA", readAscii(range));
+
+    assertEquals("BB", readAscii(openConnection(url)));
+  }
+
+  @Test public void serverReturnsDocumentOlderThanCache() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
+    server.enqueue(new MockResponse()
+        .setBody("B")
+        .addHeader("Last-Modified: " + formatDate(-4, TimeUnit.HOURS)));
+
+    URL url = server.url("/").url();
+
+    assertEquals("A", readAscii(openConnection(url)));
+    assertEquals("A", readAscii(openConnection(url)));
+  }
+
+  @Test public void clientSideNoStore() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .setBody("B"));
+
+    HttpURLConnection connection1 = openConnection(server.url("/").url());
+    connection1.setRequestProperty("Cache-Control", "no-store");
+    assertEquals("A", readAscii(connection1));
+
+    HttpURLConnection connection2 = openConnection(server.url("/").url());
+    assertEquals("B", readAscii(connection2));
+  }
+
+  @Test public void nonIdentityEncodingAndConditionalCache() throws Exception {
+    assertNonIdentityEncodingCached(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
+  }
+
+  @Test public void nonIdentityEncodingAndFullCache() throws Exception {
+    assertNonIdentityEncodingCached(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
+  }
+
+  private void assertNonIdentityEncodingCached(MockResponse response) throws Exception {
+    server.enqueue(response
+        .setBody(gzip("ABCABCABC"))
+        .addHeader("Content-Encoding: gzip"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    // At least three request/response pairs are required because after the first request is cached
+    // a different execution path might be taken. Thus modifications to the cache applied during
+    // the second request might not be visible until another request is performed.
+    assertEquals("ABCABCABC", readAscii(openConnection(server.url("/").url())));
+    assertEquals("ABCABCABC", readAscii(openConnection(server.url("/").url())));
+    assertEquals("ABCABCABC", readAscii(openConnection(server.url("/").url())));
+  }
+
+  @Test public void notModifiedSpecifiesEncoding() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody(gzip("ABCABCABC"))
+        .addHeader("Content-Encoding: gzip")
+        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED)
+        .addHeader("Content-Encoding: gzip"));
+    server.enqueue(new MockResponse()
+        .setBody("DEFDEFDEF"));
+
+    assertEquals("ABCABCABC", readAscii(openConnection(server.url("/").url())));
+    assertEquals("ABCABCABC", readAscii(openConnection(server.url("/").url())));
+    assertEquals("DEFDEFDEF", readAscii(openConnection(server.url("/").url())));
+  }
+
+  /** https://github.com/square/okhttp/issues/947 */
+  @Test public void gzipAndVaryOnAcceptEncoding() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody(gzip("ABCABCABC"))
+        .addHeader("Content-Encoding: gzip")
+        .addHeader("Vary: Accept-Encoding")
+        .addHeader("Cache-Control: max-age=60"));
+    server.enqueue(new MockResponse()
+        .setBody("FAIL"));
+
+    assertEquals("ABCABCABC", readAscii(openConnection(server.url("/").url())));
+    assertEquals("ABCABCABC", readAscii(openConnection(server.url("/").url())));
+  }
+
+  @Test public void expiresDateBeforeModifiedDate() throws Exception {
+    assertConditionallyCached(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(-2, TimeUnit.HOURS)));
+  }
+
+  @Test public void requestMaxAge() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
+        .addHeader("Date: " + formatDate(-1, TimeUnit.MINUTES))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    assertEquals("A", readAscii(openConnection(server.url("/").url())));
+
+    URLConnection connection = openConnection(server.url("/").url());
+    connection.addRequestProperty("Cache-Control", "max-age=30");
+    assertEquals("B", readAscii(connection));
+  }
+
+  @Test public void requestMinFresh() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    assertEquals("A", readAscii(openConnection(server.url("/").url())));
+
+    URLConnection connection = openConnection(server.url("/").url());
+    connection.addRequestProperty("Cache-Control", "min-fresh=120");
+    assertEquals("B", readAscii(connection));
+  }
+
+  @Test public void requestMaxStale() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .addHeader("Cache-Control: max-age=120")
+        .addHeader("Date: " + formatDate(-4, TimeUnit.MINUTES)));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    assertEquals("A", readAscii(openConnection(server.url("/").url())));
+
+    URLConnection connection = openConnection(server.url("/").url());
+    connection.addRequestProperty("Cache-Control", "max-stale=180");
+    assertEquals("A", readAscii(connection));
+    assertEquals("110 HttpURLConnection \"Response is stale\"",
+        connection.getHeaderField("Warning"));
+  }
+
+  @Test public void requestMaxStaleDirectiveWithNoValue() throws IOException {
+    // Add a stale response to the cache.
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .addHeader("Cache-Control: max-age=120")
+        .addHeader("Date: " + formatDate(-4, TimeUnit.MINUTES)));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    assertEquals("A", readAscii(openConnection(server.url("/").url())));
+
+    // With max-stale, we'll return that stale response.
+    URLConnection maxStaleConnection = openConnection(server.url("/").url());
+    maxStaleConnection.setRequestProperty("Cache-Control", "max-stale");
+    assertEquals("A", readAscii(maxStaleConnection));
+    assertEquals("110 HttpURLConnection \"Response is stale\"",
+        maxStaleConnection.getHeaderField("Warning"));
+  }
+
+  @Test public void requestMaxStaleNotHonoredWithMustRevalidate() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .addHeader("Cache-Control: max-age=120, must-revalidate")
+        .addHeader("Date: " + formatDate(-4, TimeUnit.MINUTES)));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    assertEquals("A", readAscii(openConnection(server.url("/").url())));
+
+    URLConnection connection = openConnection(server.url("/").url());
+    connection.addRequestProperty("Cache-Control", "max-stale=180");
+    assertEquals("B", readAscii(connection));
+  }
+
+  @Test public void requestOnlyIfCachedWithNoResponseCached() throws IOException {
+    // (no responses enqueued)
+
+    HttpURLConnection connection = openConnection(server.url("/").url());
+    connection.addRequestProperty("Cache-Control", "only-if-cached");
+    assertGatewayTimeout(connection);
+  }
+
+  @Test public void requestOnlyIfCachedWithFullResponseCached() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .addHeader("Cache-Control: max-age=30")
+        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
+
+    assertEquals("A", readAscii(openConnection(server.url("/").url())));
+    URLConnection connection = openConnection(server.url("/").url());
+    connection.addRequestProperty("Cache-Control", "only-if-cached");
+    assertEquals("A", readAscii(connection));
+  }
+
+  @Test public void requestOnlyIfCachedWithConditionalResponseCached() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .addHeader("Cache-Control: max-age=30")
+        .addHeader("Date: " + formatDate(-1, TimeUnit.MINUTES)));
+
+    assertEquals("A", readAscii(openConnection(server.url("/").url())));
+    HttpURLConnection connection = openConnection(server.url("/").url());
+    connection.addRequestProperty("Cache-Control", "only-if-cached");
+    assertGatewayTimeout(connection);
+  }
+
+  @Test public void requestOnlyIfCachedWithUnhelpfulResponseCached() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("A"));
+
+    assertEquals("A", readAscii(openConnection(server.url("/").url())));
+    HttpURLConnection connection = openConnection(server.url("/").url());
+    connection.addRequestProperty("Cache-Control", "only-if-cached");
+    assertGatewayTimeout(connection);
+  }
+
+  @Test public void requestCacheControlNoCache() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
+        .addHeader("Date: " + formatDate(0, TimeUnit.SECONDS))
+        .addHeader("Cache-Control: max-age=60")
+        .setBody("A"));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    URL url = server.url("/").url();
+    assertEquals("A", readAscii(openConnection(url)));
+    URLConnection connection = openConnection(url);
+    connection.setRequestProperty("Cache-Control", "no-cache");
+    assertEquals("B", readAscii(connection));
+  }
+
+  @Test public void requestPragmaNoCache() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
+        .addHeader("Date: " + formatDate(0, TimeUnit.SECONDS))
+        .addHeader("Cache-Control: max-age=60")
+        .setBody("A"));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    URL url = server.url("/").url();
+    assertEquals("A", readAscii(openConnection(url)));
+    URLConnection connection = openConnection(url);
+    connection.setRequestProperty("Pragma", "no-cache");
+    assertEquals("B", readAscii(connection));
+  }
+
+  @Test public void clientSuppliedIfModifiedSinceWithCachedResult() throws Exception {
+    MockResponse response = new MockResponse()
+        .addHeader("ETag: v3")
+        .addHeader("Cache-Control: max-age=0");
+    String ifModifiedSinceDate = formatDate(-24, TimeUnit.HOURS);
+    RecordedRequest request =
+        assertClientSuppliedCondition(response, "If-Modified-Since", ifModifiedSinceDate);
+    assertEquals(ifModifiedSinceDate, request.getHeader("If-Modified-Since"));
+    assertNull(request.getHeader("If-None-Match"));
+  }
+
+  @Test public void clientSuppliedIfNoneMatchSinceWithCachedResult() throws Exception {
+    String lastModifiedDate = formatDate(-3, TimeUnit.MINUTES);
+    MockResponse response = new MockResponse()
+        .addHeader("Last-Modified: " + lastModifiedDate)
+        .addHeader("Date: " + formatDate(-2, TimeUnit.MINUTES))
+        .addHeader("Cache-Control: max-age=0");
+    RecordedRequest request = assertClientSuppliedCondition(response, "If-None-Match", "v1");
+    assertEquals("v1", request.getHeader("If-None-Match"));
+    assertNull(request.getHeader("If-Modified-Since"));
+  }
+
+  private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String conditionName,
+      String conditionValue) throws Exception {
+    server.enqueue(seed.setBody("A"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    URL url = server.url("/").url();
+    assertEquals("A", readAscii(openConnection(url)));
+
+    HttpURLConnection connection = openConnection(url);
+    connection.addRequestProperty(conditionName, conditionValue);
+    assertEquals(HttpURLConnection.HTTP_NOT_MODIFIED, connection.getResponseCode());
+    assertEquals("", readAscii(connection));
+
+    server.takeRequest(); // seed
+    return server.takeRequest();
+  }
+
+  /**
+   * For Last-Modified and Date headers, we should echo the date back in the exact format we were
+   * served.
+   */
+  @Test public void retainServedDateFormat() throws Exception {
+    // Serve a response with a non-standard date format that OkHttp supports.
+    Date lastModifiedDate = new Date(System.currentTimeMillis() + TimeUnit.HOURS.toMillis(-1));
+    Date servedDate = new Date(System.currentTimeMillis() + TimeUnit.HOURS.toMillis(-2));
+    DateFormat dateFormat = new SimpleDateFormat("EEE dd-MMM-yyyy HH:mm:ss z", Locale.US);
+    dateFormat.setTimeZone(TimeZone.getTimeZone("EDT"));
+    String lastModifiedString = dateFormat.format(lastModifiedDate);
+    String servedString = dateFormat.format(servedDate);
+
+    // This response should be conditionally cached.
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + lastModifiedString)
+        .addHeader("Expires: " + servedString)
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    assertEquals("A", readAscii(openConnection(server.url("/").url())));
+    assertEquals("A", readAscii(openConnection(server.url("/").url())));
+
+    // The first request has no conditions.
+    RecordedRequest request1 = server.takeRequest();
+    assertNull(request1.getHeader("If-Modified-Since"));
+
+    // The 2nd request uses the server's date format.
+    RecordedRequest request2 = server.takeRequest();
+    assertEquals(lastModifiedString, request2.getHeader("If-Modified-Since"));
+  }
+
+  @Test public void clientSuppliedConditionWithoutCachedResult() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    HttpURLConnection connection = openConnection(server.url("/").url());
+    String clientIfModifiedSince = formatDate(-24, TimeUnit.HOURS);
+    connection.addRequestProperty("If-Modified-Since", clientIfModifiedSince);
+    assertEquals(HttpURLConnection.HTTP_NOT_MODIFIED, connection.getResponseCode());
+    assertEquals("", readAscii(connection));
+  }
+
+  @Test public void authorizationRequestFullyCached() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    URL url = server.url("/").url();
+    URLConnection connection = openConnection(url);
+    connection.addRequestProperty("Authorization", "password");
+    assertEquals("A", readAscii(connection));
+    assertEquals("A", readAscii(openConnection(url)));
+  }
+
+  @Test public void contentLocationDoesNotPopulateCache() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Content-Location: /bar")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    assertEquals("A", readAscii(openConnection(server.url("/foo").url())));
+    assertEquals("B", readAscii(openConnection(server.url("/bar").url())));
+  }
+
+  @Test public void connectionIsReturnedToPoolAfterConditionalSuccess() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    assertEquals("A", readAscii(openConnection(server.url("/a").url())));
+    assertEquals("A", readAscii(openConnection(server.url("/a").url())));
+    assertEquals("B", readAscii(openConnection(server.url("/b").url())));
+
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+    assertEquals(2, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void varyMatchesChangedRequestHeaderField() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Accept-Language")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    URL url = server.url("/").url();
+    HttpURLConnection frenchConnection = openConnection(url);
+    frenchConnection.setRequestProperty("Accept-Language", "fr-CA");
+    assertEquals("A", readAscii(frenchConnection));
+
+    HttpURLConnection englishConnection = openConnection(url);
+    englishConnection.setRequestProperty("Accept-Language", "en-US");
+    assertEquals("B", readAscii(englishConnection));
+  }
+
+  @Test public void varyMatchesUnchangedRequestHeaderField() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Accept-Language")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    URL url = server.url("/").url();
+    HttpURLConnection frenchConnection1 = openConnection(url);
+    frenchConnection1.setRequestProperty("Accept-Language", "fr-CA");
+    assertEquals("A", readAscii(frenchConnection1));
+
+    HttpURLConnection frenchConnection2 = openConnection(url);
+    frenchConnection2.setRequestProperty("Accept-Language", "fr-CA");
+    assertEquals("A", readAscii(frenchConnection2));
+  }
+
+  @Test public void varyMatchesAbsentRequestHeaderField() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Foo")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    assertEquals("A", readAscii(openConnection(server.url("/").url())));
+    assertEquals("A", readAscii(openConnection(server.url("/").url())));
+  }
+
+  @Test public void varyMatchesAddedRequestHeaderField() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Foo")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    assertEquals("A", readAscii(openConnection(server.url("/").url())));
+    HttpURLConnection connection2 = openConnection(server.url("/").url());
+    connection2.setRequestProperty("Foo", "bar");
+    assertEquals("B", readAscii(connection2));
+  }
+
+  @Test public void varyMatchesRemovedRequestHeaderField() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Foo")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    HttpURLConnection connection1 = openConnection(server.url("/").url());
+    connection1.setRequestProperty("Foo", "bar");
+    assertEquals("A", readAscii(connection1));
+    assertEquals("B", readAscii(openConnection(server.url("/").url())));
+  }
+
+  @Test public void varyFieldsAreCaseInsensitive() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: ACCEPT-LANGUAGE")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    URL url = server.url("/").url();
+    HttpURLConnection frenchConnection1 = openConnection(url);
+    frenchConnection1.setRequestProperty("Accept-Language", "fr-CA");
+    assertEquals("A", readAscii(frenchConnection1));
+    HttpURLConnection frenchConnection2 = openConnection(url);
+    frenchConnection2.setRequestProperty("accept-language", "fr-CA");
+    assertEquals("A", readAscii(frenchConnection2));
+  }
+
+  @Test public void varyMultipleFieldsWithMatch() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Accept-Language, Accept-Charset")
+        .addHeader("Vary: Accept-Encoding")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    URL url = server.url("/").url();
+    HttpURLConnection frenchConnection1 = openConnection(url);
+    frenchConnection1.setRequestProperty("Accept-Language", "fr-CA");
+    frenchConnection1.setRequestProperty("Accept-Charset", "UTF-8");
+    frenchConnection1.setRequestProperty("Accept-Encoding", "identity");
+    assertEquals("A", readAscii(frenchConnection1));
+    HttpURLConnection frenchConnection2 = openConnection(url);
+    frenchConnection2.setRequestProperty("Accept-Language", "fr-CA");
+    frenchConnection2.setRequestProperty("Accept-Charset", "UTF-8");
+    frenchConnection2.setRequestProperty("Accept-Encoding", "identity");
+    assertEquals("A", readAscii(frenchConnection2));
+  }
+
+  @Test public void varyMultipleFieldsWithNoMatch() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Accept-Language, Accept-Charset")
+        .addHeader("Vary: Accept-Encoding")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    URL url = server.url("/").url();
+    HttpURLConnection frenchConnection = openConnection(url);
+    frenchConnection.setRequestProperty("Accept-Language", "fr-CA");
+    frenchConnection.setRequestProperty("Accept-Charset", "UTF-8");
+    frenchConnection.setRequestProperty("Accept-Encoding", "identity");
+    assertEquals("A", readAscii(frenchConnection));
+    HttpURLConnection englishConnection = openConnection(url);
+    englishConnection.setRequestProperty("Accept-Language", "en-CA");
+    englishConnection.setRequestProperty("Accept-Charset", "UTF-8");
+    englishConnection.setRequestProperty("Accept-Encoding", "identity");
+    assertEquals("B", readAscii(englishConnection));
+  }
+
+  @Test public void varyMultipleFieldValuesWithMatch() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Accept-Language")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    URL url = server.url("/").url();
+    HttpURLConnection multiConnection1 = openConnection(url);
+    multiConnection1.setRequestProperty("Accept-Language", "fr-CA, fr-FR");
+    multiConnection1.addRequestProperty("Accept-Language", "en-US");
+    assertEquals("A", readAscii(multiConnection1));
+
+    HttpURLConnection multiConnection2 = openConnection(url);
+    multiConnection2.setRequestProperty("Accept-Language", "fr-CA, fr-FR");
+    multiConnection2.addRequestProperty("Accept-Language", "en-US");
+    assertEquals("A", readAscii(multiConnection2));
+  }
+
+  @Test public void varyMultipleFieldValuesWithNoMatch() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Accept-Language")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    URL url = server.url("/").url();
+    HttpURLConnection multiConnection = openConnection(url);
+    multiConnection.setRequestProperty("Accept-Language", "fr-CA, fr-FR");
+    multiConnection.addRequestProperty("Accept-Language", "en-US");
+    assertEquals("A", readAscii(multiConnection));
+
+    HttpURLConnection notFrenchConnection = openConnection(url);
+    notFrenchConnection.setRequestProperty("Accept-Language", "fr-CA");
+    notFrenchConnection.addRequestProperty("Accept-Language", "en-US");
+    assertEquals("B", readAscii(notFrenchConnection));
+  }
+
+  @Test public void varyAsterisk() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: *")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    assertEquals("A", readAscii(openConnection(server.url("/").url())));
+    assertEquals("B", readAscii(openConnection(server.url("/").url())));
+  }
+
+  @Test public void varyAndHttps() throws Exception {
+    server.useHttps(sslClient.socketFactory, false);
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Accept-Language")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(hostnameVerifier)
+        .build());
+
+    URL url = server.url("/").url();
+    HttpURLConnection connection1 = openConnection(url);
+    connection1.setRequestProperty("Accept-Language", "en-US");
+    assertEquals("A", readAscii(connection1));
+
+    HttpURLConnection connection2 = openConnection(url);
+    connection2.setRequestProperty("Accept-Language", "en-US");
+    assertEquals("A", readAscii(connection2));
+  }
+
+  @Test public void getHeadersReturnsNetworkEndToEndHeaders() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Allow: GET, HEAD")
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .addHeader("Allow: GET, HEAD, PUT")
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    URLConnection connection1 = openConnection(server.url("/").url());
+    assertEquals("A", readAscii(connection1));
+    assertEquals("GET, HEAD", connection1.getHeaderField("Allow"));
+
+    URLConnection connection2 = openConnection(server.url("/").url());
+    assertEquals("A", readAscii(connection2));
+    assertEquals("GET, HEAD, PUT", connection2.getHeaderField("Allow"));
+  }
+
+  @Test public void getHeadersReturnsCachedHopByHopHeaders() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Transfer-Encoding: identity")
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .addHeader("Transfer-Encoding: none")
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    URLConnection connection1 = openConnection(server.url("/").url());
+    assertEquals("A", readAscii(connection1));
+    assertEquals("identity", connection1.getHeaderField("Transfer-Encoding"));
+
+    URLConnection connection2 = openConnection(server.url("/").url());
+    assertEquals("A", readAscii(connection2));
+    assertEquals("identity", connection2.getHeaderField("Transfer-Encoding"));
+  }
+
+  @Test public void getHeadersDeletesCached100LevelWarnings() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Warning: 199 test danger")
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    URLConnection connection1 = openConnection(server.url("/").url());
+    assertEquals("A", readAscii(connection1));
+    assertEquals("199 test danger", connection1.getHeaderField("Warning"));
+
+    URLConnection connection2 = openConnection(server.url("/").url());
+    assertEquals("A", readAscii(connection2));
+    assertEquals(null, connection2.getHeaderField("Warning"));
+  }
+
+  @Test public void getHeadersRetainsCached200LevelWarnings() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Warning: 299 test danger")
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    URLConnection connection1 = openConnection(server.url("/").url());
+    assertEquals("A", readAscii(connection1));
+    assertEquals("299 test danger", connection1.getHeaderField("Warning"));
+
+    URLConnection connection2 = openConnection(server.url("/").url());
+    assertEquals("A", readAscii(connection2));
+    assertEquals("299 test danger", connection2.getHeaderField("Warning"));
+  }
+
+  public void assertCookies(URL url, String... expectedCookies) throws Exception {
+    List<String> actualCookies = new ArrayList<>();
+    for (HttpCookie cookie : cookieManager.getCookieStore().get(url.toURI())) {
+      actualCookies.add(cookie.toString());
+    }
+    assertEquals(Arrays.asList(expectedCookies), actualCookies);
+  }
+
+  @Test public void doNotCachePartialResponse() throws Exception {
+    assertNotCached(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_PARTIAL)
+        .addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
+        .addHeader("Content-Range: bytes 100-100/200")
+        .addHeader("Cache-Control: max-age=60"));
+  }
+
+  /**
+   * Equivalent to {@code CacheTest.conditionalHitUpdatesCache()}, except a Java standard cache has
+   * no means to update the headers for an existing entry so the behavior is different.
+   */
+  @Test public void conditionalHitDoesNotUpdateCache() throws Exception {
+    // A response that is cacheable, but with a short life.
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(0, TimeUnit.SECONDS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("A"));
+    // A response that refers to the previous response, but is cacheable with a long life.
+    // Contains a header we can recognize as having come from the server.
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=30")
+        .addHeader("Allow: GET, HEAD")
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+    // A response that is cacheable with a long life.
+    server.enqueue(new MockResponse()
+        .setBody("B")
+        .addHeader("Cache-Control: max-age=30"));
+    // A response that should never be requested.
+    server.enqueue(new MockResponse()
+        .setBody("C"));
+
+    // cache miss; seed the cache with an entry that will require a network hit to be sure it is
+    // still valid
+    HttpURLConnection connection1 = openConnection(server.url("/a").url());
+    assertEquals("A", readAscii(connection1));
+    assertEquals(null, connection1.getHeaderField("Allow"));
+
+    // conditional cache hit; The cached data should be returned, but the cache is not updated.
+    HttpURLConnection connection2 = openConnection(server.url("/a").url());
+    assertEquals(HttpURLConnection.HTTP_OK, connection2.getResponseCode());
+    assertEquals("A", readAscii(connection2));
+    assertEquals("GET, HEAD", connection2.getHeaderField("Allow"));
+
+    // conditional cache hit; The server responds with new data. The cache is updated.
+    HttpURLConnection connection3 = openConnection(server.url("/a").url());
+    assertEquals("B", readAscii(connection3));
+
+    // full cache hit; The data from connection3 has now replaced that from connection 1.
+    HttpURLConnection connection4 = openConnection(server.url("/a").url());
+    assertEquals("B", readAscii(connection4));
+
+    assertEquals(3, server.getRequestCount());
+  }
+
+  @Test public void responseSourceHeaderCached() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .addHeader("Cache-Control: max-age=30")
+        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
+
+    assertEquals("A", readAscii(openConnection(server.url("/").url())));
+    URLConnection connection = openConnection(server.url("/").url());
+    connection.addRequestProperty("Cache-Control", "only-if-cached");
+    assertEquals("A", readAscii(connection));
+  }
+
+  @Test public void responseSourceHeaderConditionalCacheFetched() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .addHeader("Cache-Control: max-age=30")
+        .addHeader("Date: " + formatDate(-31, TimeUnit.MINUTES)));
+    server.enqueue(new MockResponse()
+        .setBody("B")
+        .addHeader("Cache-Control: max-age=30")
+        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
+
+    assertEquals("A", readAscii(openConnection(server.url("/").url())));
+    HttpURLConnection connection = openConnection(server.url("/").url());
+    assertEquals("B", readAscii(connection));
+  }
+
+  @Test public void responseSourceHeaderConditionalCacheNotFetched() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .addHeader("Cache-Control: max-age=0")
+        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
+    server.enqueue(new MockResponse()
+        .setResponseCode(304));
+
+    assertEquals("A", readAscii(openConnection(server.url("/").url())));
+    HttpURLConnection connection = openConnection(server.url("/").url());
+    assertEquals("A", readAscii(connection));
+  }
+
+  @Test public void responseSourceHeaderFetched() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("A"));
+
+    URLConnection connection = openConnection(server.url("/").url());
+    assertEquals("A", readAscii(connection));
+  }
+
+  @Test public void emptyResponseHeaderNameFromCacheIsLenient() throws Exception {
+    Headers.Builder headers = new Headers.Builder()
+        .add("Cache-Control: max-age=120");
+    Internal.instance.addLenient(headers, ": A");
+    server.enqueue(new MockResponse()
+        .setHeaders(headers.build())
+        .setBody("body"));
+
+    HttpURLConnection connection = openConnection(server.url("/").url());
+    assertEquals("A", connection.getHeaderField(""));
+  }
+
+  /**
+   * @param delta the offset from the current date to use. Negative values yield dates in the past;
+   * positive values yield dates in the future.
+   */
+  private String formatDate(long delta, TimeUnit timeUnit) {
+    return formatDate(new Date(System.currentTimeMillis() + timeUnit.toMillis(delta)));
+  }
+
+  private String formatDate(Date date) {
+    DateFormat rfc1123 = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss zzz", Locale.US);
+    rfc1123.setTimeZone(TimeZone.getTimeZone("GMT"));
+    return rfc1123.format(date);
+  }
+
+  private void assertNotCached(MockResponse response) throws Exception {
+    server.enqueue(response.setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    URL url = server.url("/").url();
+    assertEquals("A", readAscii(openConnection(url)));
+    assertEquals("B", readAscii(openConnection(url)));
+  }
+
+  /** @return the request with the conditional get headers. */
+  private RecordedRequest assertConditionallyCached(MockResponse response) throws Exception {
+    // scenario 1: condition succeeds
+    server.enqueue(response.setBody("A").setStatus("HTTP/1.1 200 A-OK"));
+    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    // scenario 2: condition fails
+    server.enqueue(response.setBody("B").setStatus("HTTP/1.1 200 B-OK"));
+    server.enqueue(new MockResponse().setStatus("HTTP/1.1 200 C-OK").setBody("C"));
+
+    URL valid = server.url("/valid").url();
+    HttpURLConnection connection1 = openConnection(valid);
+    assertEquals("A", readAscii(connection1));
+    assertEquals(HttpURLConnection.HTTP_OK, connection1.getResponseCode());
+    assertEquals("A-OK", connection1.getResponseMessage());
+    HttpURLConnection connection2 = openConnection(valid);
+    assertEquals("A", readAscii(connection2));
+    assertEquals(HttpURLConnection.HTTP_OK, connection2.getResponseCode());
+    assertEquals("A-OK", connection2.getResponseMessage());
+
+    URL invalid = server.url("/invalid").url();
+    HttpURLConnection connection3 = openConnection(invalid);
+    assertEquals("B", readAscii(connection3));
+    assertEquals(HttpURLConnection.HTTP_OK, connection3.getResponseCode());
+    assertEquals("B-OK", connection3.getResponseMessage());
+    HttpURLConnection connection4 = openConnection(invalid);
+    assertEquals("C", readAscii(connection4));
+    assertEquals(HttpURLConnection.HTTP_OK, connection4.getResponseCode());
+    assertEquals("C-OK", connection4.getResponseMessage());
+
+    server.takeRequest(); // regular get
+    return server.takeRequest(); // conditional get
+  }
+
+  private void assertFullyCached(MockResponse response) throws Exception {
+    server.enqueue(response.setBody("A"));
+    server.enqueue(response.setBody("B"));
+
+    URL url = server.url("/").url();
+    assertEquals("A", readAscii(openConnection(url)));
+    assertEquals("A", readAscii(openConnection(url)));
+  }
+
+  /**
+   * Shortens the body of {@code response} but not the corresponding headers. Only useful to test
+   * how clients respond to the premature conclusion of the HTTP body.
+   */
+  private MockResponse truncateViolently(MockResponse response, int numBytesToKeep) {
+    response.setSocketPolicy(SocketPolicy.DISCONNECT_AT_END);
+    Headers headers = response.getHeaders();
+    Buffer truncatedBody = new Buffer();
+    truncatedBody.write(response.getBody(), numBytesToKeep);
+    response.setBody(truncatedBody);
+    response.setHeaders(headers);
+    return response;
+  }
+
+  enum TransferKind {
+    CHUNKED() {
+      @Override void setBody(MockResponse response, Buffer content, int chunkSize)
+          throws IOException {
+        response.setChunkedBody(content, chunkSize);
+      }
+    },
+    FIXED_LENGTH() {
+      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
+        response.setBody(content);
+      }
+    },
+    END_OF_STREAM() {
+      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
+        response.setBody(content);
+        response.setSocketPolicy(SocketPolicy.DISCONNECT_AT_END);
+        response.removeHeader("Content-Length");
+      }
+    };
+
+    abstract void setBody(MockResponse response, Buffer content, int chunkSize) throws IOException;
+
+    void setBody(MockResponse response, String content, int chunkSize) throws IOException {
+      setBody(response, new Buffer().writeUtf8(content), chunkSize);
+    }
+  }
+
+  /** Returns a gzipped copy of {@code bytes}. */
+  public Buffer gzip(String data) throws IOException {
+    Buffer result = new Buffer();
+    BufferedSink sink = Okio.buffer(new GzipSink(result));
+    sink.writeUtf8(data);
+    sink.close();
+    return result;
+  }
+
+  /**
+   * Reads {@code count} characters from the stream. If the stream is exhausted before {@code count}
+   * characters can be read, the remaining characters are returned and the stream is closed.
+   */
+  private String readAscii(URLConnection connection, int count) throws IOException {
+    HttpURLConnection httpConnection = (HttpURLConnection) connection;
+    InputStream in = httpConnection.getResponseCode() < HttpURLConnection.HTTP_BAD_REQUEST
+        ? connection.getInputStream() : httpConnection.getErrorStream();
+    StringBuilder result = new StringBuilder();
+    for (int i = 0; i < count; i++) {
+      int value = in.read();
+      if (value == -1) {
+        in.close();
+        break;
+      }
+      result.append((char) value);
+    }
+    return result.toString();
+  }
+
+  private String readAscii(URLConnection connection) throws IOException {
+    return readAscii(connection, Integer.MAX_VALUE);
+  }
+
+  private void reliableSkip(InputStream in, int length) throws IOException {
+    while (length > 0) {
+      length -= in.skip(length);
+    }
+  }
+
+  private void assertGatewayTimeout(HttpURLConnection connection) throws IOException {
+    try {
+      connection.getInputStream();
+      fail();
+    } catch (FileNotFoundException expected) {
+    }
+    assertEquals(504, connection.getResponseCode());
+    assertEquals(-1, connection.getErrorStream().read());
+  }
+
+  private static <T> List<T> toListOrNull(T[] arrayOrNull) {
+    return arrayOrNull != null ? Arrays.asList(arrayOrNull) : null;
+  }
+
+  // Android-added tests.
+
+  /**
+   * Test that we can interrogate the response when the cache is being populated.
+   * http://code.google.com/p/android/issues/detail?id=7787
+   */
+  @Test public void responseCacheCallbackApis() throws Exception {
+    final String body = "ABCDE";
+    final AtomicInteger cacheCount = new AtomicInteger();
+
+    server.enqueue(new MockResponse()
+        .setStatus("HTTP/1.1 200 Fantastic")
+        .addHeader("Content-Type: text/plain")
+        .addHeader("fgh: ijk")
+        .setBody(body));
+
+    setInternalCache(new CacheAdapter(new AbstractResponseCache() {
+      @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
+        HttpURLConnection httpURLConnection = (HttpURLConnection) connection;
+        assertEquals(server.url("/").url(), uri.toURL());
+        assertEquals(200, httpURLConnection.getResponseCode());
+        InputStream is = httpURLConnection.getInputStream();
+        try {
+          is.read();
+          fail();
+        } catch (UnsupportedOperationException expected) {
+        }
+        assertEquals("5", connection.getHeaderField("Content-Length"));
+        assertEquals("text/plain", connection.getHeaderField("Content-Type"));
+        assertEquals("ijk", connection.getHeaderField("fgh"));
+        cacheCount.incrementAndGet();
+        return null;
+      }
+    }));
+
+    URL url = server.url("/").url();
+    HttpURLConnection connection = openConnection(url);
+    assertEquals(body, readAscii(connection));
+    assertEquals(1, cacheCount.get());
+  }
+
+  /** Don't explode if the cache returns a null body. http://b/3373699 */
+  @Test public void responseCacheReturnsNullOutputStream() throws Exception {
+    final AtomicBoolean aborted = new AtomicBoolean();
+    setInternalCache(new CacheAdapter(new AbstractResponseCache() {
+      @Override public CacheRequest put(URI uri, URLConnection connection) {
+        return new CacheRequest() {
+          @Override public void abort() {
+            aborted.set(true);
+          }
+
+          @Override public OutputStream getBody() throws IOException {
+            return null;
+          }
+        };
+      }
+    }));
+
+    server.enqueue(new MockResponse().setBody("abcdef"));
+
+    HttpURLConnection connection = openConnection(server.url("/").url());
+    assertEquals("abc", readAscii(connection, 3));
+    connection.getInputStream().close();
+    assertFalse(aborted.get()); // The best behavior is ambiguous, but RI 6 doesn't abort here
+  }
+
+  /**
+   * Fail if a badly-behaved cache returns a null status line header.
+   * https://code.google.com/p/android/issues/detail?id=160522
+   */
+  @Test public void responseCacheReturnsNullStatusLine() throws Exception {
+    String cachedContentString = "Hello";
+    final byte[] cachedContent = cachedContentString.getBytes(StandardCharsets.US_ASCII);
+
+    setInternalCache(new CacheAdapter(new AbstractResponseCache() {
+      @Override
+      public CacheResponse get(URI uri, String requestMethod,
+          Map<String, List<String>> requestHeaders)
+          throws IOException {
+        return new CacheResponse() {
+          @Override public Map<String, List<String>> getHeaders() throws IOException {
+            String contentType = "text/plain";
+            Map<String, List<String>> headers = new HashMap<>();
+            headers.put("Content-Length", Arrays.asList(Integer.toString(cachedContent.length)));
+            headers.put("Content-Type", Arrays.asList(contentType));
+            headers.put("Expires", Arrays.asList(formatDate(-1, TimeUnit.HOURS)));
+            headers.put("Cache-Control", Arrays.asList("max-age=60"));
+            // Crucially, the header with a null key is missing, which renders the cache response
+            // unusable because OkHttp only caches responses with cacheable response codes.
+            return headers;
+          }
+
+          @Override public InputStream getBody() throws IOException {
+            return new ByteArrayInputStream(cachedContent);
+          }
+        };
+      }
+    }));
+    HttpURLConnection connection = openConnection(server.url("/").url());
+    // If there was no status line from the cache an exception will be thrown. No network request
+    // should be made.
+    try {
+      connection.getResponseCode();
+      fail();
+    } catch (ProtocolException expected) {
+    }
+  }
+
+  private static class InsecureResponseCache extends ResponseCache {
+
+    private final ResponseCache delegate;
+
+    private InsecureResponseCache(ResponseCache delegate) {
+      this.delegate = delegate;
+    }
+
+    @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
+      return delegate.put(uri, connection);
+    }
+
+    @Override public CacheResponse get(URI uri, String requestMethod,
+        Map<String, List<String>> requestHeaders) throws IOException {
+      final CacheResponse response = delegate.get(uri, requestMethod, requestHeaders);
+      if (response instanceof SecureCacheResponse) {
+        return new CacheResponse() {
+          @Override public InputStream getBody() throws IOException {
+            return response.getBody();
+          }
+
+          @Override public Map<String, List<String>> getHeaders() throws IOException {
+            return response.getHeaders();
+          }
+        };
+      }
+      return response;
+    }
+  }
+
+  @Test public void cacheReturnsInsecureResponseForSecureRequest() throws IOException {
+    server.useHttps(sslClient.socketFactory, false);
+    server.enqueue(new MockResponse().setBody("ABC"));
+    server.enqueue(new MockResponse().setBody("DEF"));
+
+    AndroidInternal.setResponseCache(urlFactory, new InsecureResponseCache(cache));
+
+    HttpsURLConnection connection1 = (HttpsURLConnection) openConnection(server.url("/").url());
+    connection1.setSSLSocketFactory(sslClient.socketFactory);
+    connection1.setHostnameVerifier(hostnameVerifier);
+    assertEquals("ABC", readAscii(connection1));
+
+    // Not cached!
+    HttpsURLConnection connection2 = (HttpsURLConnection) openConnection(server.url("/").url());
+    connection2.setSSLSocketFactory(sslClient.socketFactory);
+    connection2.setHostnameVerifier(hostnameVerifier);
+    assertEquals("DEF", readAscii(connection2));
+  }
+
+  @Test public void responseCacheRequestHeaders() throws IOException, URISyntaxException {
+    server.enqueue(new MockResponse()
+        .setBody("ABC"));
+
+    final AtomicReference<Map<String, List<String>>> requestHeadersRef = new AtomicReference<>();
+    setInternalCache(new CacheAdapter(new AbstractResponseCache() {
+      @Override public CacheResponse get(URI uri, String requestMethod,
+          Map<String, List<String>> requestHeaders) throws IOException {
+        requestHeadersRef.set(requestHeaders);
+        return null;
+      }
+    }));
+
+    URL url = server.url("/").url();
+    URLConnection urlConnection = openConnection(url);
+    urlConnection.addRequestProperty("A", "android");
+    readAscii(urlConnection);
+    assertEquals(Arrays.asList("android"), requestHeadersRef.get().get("A"));
+  }
+
+  @Test public void responseCachingWithoutBody() throws IOException {
+    MockResponse response =
+        new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+            .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+            .setStatus("HTTP/1.1 200 Fantastic");
+    server.enqueue(response);
+
+    HttpURLConnection urlConnection = openConnection(server.url("/").url());
+    assertEquals(200, urlConnection.getResponseCode());
+    assertEquals("Fantastic", urlConnection.getResponseMessage());
+    assertTrue(urlConnection.getDoInput());
+    InputStream is = urlConnection.getInputStream();
+    assertEquals(-1, is.read());
+    is.close();
+
+    urlConnection = openConnection(server.url("/").url()); // cached!
+    assertTrue(urlConnection.getDoInput());
+    InputStream cachedIs = urlConnection.getInputStream();
+    assertEquals(-1, cachedIs.read());
+    cachedIs.close();
+    assertEquals(200, urlConnection.getResponseCode());
+    assertEquals("Fantastic", urlConnection.getResponseMessage());
+  }
+
+  @Test public void useCachesFalseDoesNotWriteToCache() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    URLConnection connection = openConnection(server.url("/").url());
+    connection.setUseCaches(false);
+    assertEquals("A", readAscii(connection));
+    assertEquals("B", readAscii(openConnection(server.url("/").url())));
+  }
+
+  @Test public void useCachesFalseDoesNotReadFromCache() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    assertEquals("A", readAscii(openConnection(server.url("/").url())));
+    URLConnection connection = openConnection(server.url("/").url());
+    connection.setUseCaches(false);
+    assertEquals("B", readAscii(connection));
+  }
+
+  @Test public void defaultUseCachesSetsInitialValueOnly() throws Exception {
+    URL url = new URL("http://localhost/");
+    URLConnection c1 = openConnection(url);
+    URLConnection c2 = openConnection(url);
+    assertTrue(c1.getDefaultUseCaches());
+    c1.setDefaultUseCaches(false);
+    try {
+      assertTrue(c1.getUseCaches());
+      assertTrue(c2.getUseCaches());
+      URLConnection c3 = openConnection(url);
+      assertFalse(c3.getUseCaches());
+    } finally {
+      c1.setDefaultUseCaches(true);
+    }
+  }
+
+  // Other stacks (e.g. older versions of OkHttp bundled inside Android apps) can interact with the
+  // default ResponseCache. We try to keep this case working as much as possible because apps break
+  // if we don't.
+  @Test public void otherStacks_cacheHitWithoutVary() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("FAIL"));
+
+    // Set the cache as the shared cache.
+    ResponseCache.setDefault(cache);
+
+    // Use the platform's HTTP stack.
+    URLConnection connection = server.url("/").url().openConnection();
+    assertFalse(connection instanceof HttpURLConnectionImpl);
+    assertEquals("A", readAscii(connection));
+
+    URLConnection connection2 = server.url("/").url().openConnection();
+    assertFalse(connection2 instanceof HttpURLConnectionImpl);
+    assertEquals("A", readAscii(connection2));
+  }
+
+  // Other stacks (e.g. older versions of OkHttp bundled inside Android apps) can interact with the
+  // default ResponseCache. We can't keep the Vary case working because we can't get to the Vary
+  // request headers after connect(). Accept-Encoding has special behavior so we test it explicitly.
+  @Test public void otherStacks_cacheMissWithVaryAcceptEncoding() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Accept-Encoding")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    // Set the cache as the shared cache.
+    ResponseCache.setDefault(cache);
+
+    // Use the platform's HTTP stack.
+    URLConnection connection = server.url("/").url().openConnection();
+    assertFalse(connection instanceof HttpURLConnectionImpl);
+    assertEquals("A", readAscii(connection));
+
+    URLConnection connection2 = server.url("/").url().openConnection();
+    assertFalse(connection2 instanceof HttpURLConnectionImpl);
+    assertEquals("B", readAscii(connection2));
+  }
+
+  // Other stacks (e.g. older versions of OkHttp bundled inside Android apps) can interact with the
+  // default ResponseCache. We can't keep the Vary case working because we can't get to the Vary
+  // request headers after connect().
+  @Test public void otherStacks_cacheMissWithVary() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Accept-Language")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    // Set the cache as the shared cache.
+    ResponseCache.setDefault(cache);
+
+    // Use the platform's HTTP stack.
+    URLConnection connection = server.url("/").url().openConnection();
+    assertFalse(connection instanceof HttpURLConnectionImpl);
+    connection.setRequestProperty("Accept-Language", "en-US");
+    assertEquals("A", readAscii(connection));
+
+    URLConnection connection2 = server.url("/").url().openConnection();
+    assertFalse(connection2 instanceof HttpURLConnectionImpl);
+    assertEquals("B", readAscii(connection2));
+  }
+
+  // Other stacks (e.g. older versions of OkHttp bundled inside Android apps) can interact with the
+  // default ResponseCache. We can't keep the Vary case working, because we can't get to the Vary
+  // request headers after connect().
+  @Test public void otherStacks_cacheMissWithVaryAsterisk() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: *")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    // Set the cache as the shared cache.
+    ResponseCache.setDefault(cache);
+
+    // Use the platform's HTTP stack.
+    URLConnection connection = server.url("/").url().openConnection();
+    assertFalse(connection instanceof HttpURLConnectionImpl);
+    assertEquals("A", readAscii(connection));
+
+    URLConnection connection2 = server.url("/").url().openConnection();
+    assertFalse(connection2 instanceof HttpURLConnectionImpl);
+    assertEquals("B", readAscii(connection2));
+  }
+
+  private void setInternalCache(InternalCache internalCache) {
+    OkHttpClient.Builder builder = urlFactory.client().newBuilder();
+    Internal.instance.setCache(builder, internalCache);
+    urlFactory.setClient(builder.build());
+  }
+}
diff --git a/okhttp-apache/pom.xml b/okhttp-apache/pom.xml
index 2eafbad443..8ae2bc8c23 100644
--- a/okhttp-apache/pom.xml
+++ b/okhttp-apache/pom.xml
@@ -4,9 +4,9 @@
   <modelVersion>4.0.0</modelVersion>
 
   <parent>
-    <groupId>com.squareup.okhttp</groupId>
+    <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>2.4.0-SNAPSHOT</version>
+    <version>3.4.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-apache</artifactId>
@@ -14,10 +14,16 @@
 
   <dependencies>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>${project.groupId}</groupId>
       <artifactId>okhttp</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp-testing-support</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
     <dependency>
       <groupId>org.apache.httpcomponents</groupId>
       <artifactId>httpclient</artifactId>
@@ -30,7 +36,7 @@
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>${project.groupId}</groupId>
       <artifactId>mockwebserver</artifactId>
       <version>${project.version}</version>
       <scope>test</scope>
diff --git a/okhttp-apache/src/main/java/com/squareup/okhttp/apache/HttpEntityBody.java b/okhttp-apache/src/main/java/okhttp3/apache/HttpEntityBody.java
similarity index 91%
rename from okhttp-apache/src/main/java/com/squareup/okhttp/apache/HttpEntityBody.java
rename to okhttp-apache/src/main/java/okhttp3/apache/HttpEntityBody.java
index fd7884cd80..45d27aafd1 100644
--- a/okhttp-apache/src/main/java/com/squareup/okhttp/apache/HttpEntityBody.java
+++ b/okhttp-apache/src/main/java/okhttp3/apache/HttpEntityBody.java
@@ -1,8 +1,8 @@
-package com.squareup.okhttp.apache;
+package okhttp3.apache;
 
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.RequestBody;
 import java.io.IOException;
+import okhttp3.MediaType;
+import okhttp3.RequestBody;
 import okio.BufferedSink;
 import org.apache.http.HttpEntity;
 
diff --git a/okhttp-apache/src/main/java/com/squareup/okhttp/apache/OkApacheClient.java b/okhttp-apache/src/main/java/okhttp3/apache/OkApacheClient.java
similarity index 89%
rename from okhttp-apache/src/main/java/com/squareup/okhttp/apache/OkApacheClient.java
rename to okhttp-apache/src/main/java/okhttp3/apache/OkApacheClient.java
index 602a2c8297..a1af89f867 100644
--- a/okhttp-apache/src/main/java/com/squareup/okhttp/apache/OkApacheClient.java
+++ b/okhttp-apache/src/main/java/okhttp3/apache/OkApacheClient.java
@@ -1,15 +1,15 @@
 // Copyright 2013 Square, Inc.
-package com.squareup.okhttp.apache;
-
-import com.squareup.okhttp.Headers;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.Response;
-import com.squareup.okhttp.ResponseBody;
+package okhttp3.apache;
+
 import java.io.IOException;
 import java.net.InetSocketAddress;
 import java.net.Proxy;
+import okhttp3.Headers;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
 import org.apache.http.Header;
 import org.apache.http.HttpEntity;
 import org.apache.http.HttpEntityEnclosingRequest;
@@ -32,11 +32,9 @@
 import static org.apache.http.HttpVersion.HTTP_1_1;
 
 /**
- * Implements Apache's {@link HttpClient} API using {@link OkHttpClient}.
- * <p>
- * <strong>Warning:</strong> Many core features of Apache HTTP client are not implemented by this
- * API. This includes the keep-alive strategy, cookie store, credentials provider, route planner
- * and others.
+ * @deprecated OkHttp will be dropping its ability to be used with {@link HttpClient} in an upcoming
+ * release. Applications that need this should either downgrade to the Apache implementation or
+ * upgrade to OkHttp's Request/Response API.
  */
 public final class OkApacheClient implements HttpClient {
   private static Request transformRequest(HttpRequest request) {
@@ -49,7 +47,7 @@ private static Request transformRequest(HttpRequest request) {
     String contentType = null;
     for (Header header : request.getAllHeaders()) {
       String name = header.getName();
-      if ("Content-Type".equals(name)) {
+      if ("Content-Type".equalsIgnoreCase(name)) {
         contentType = header.getValue();
       } else {
         builder.header(name, header.getValue());
@@ -67,6 +65,8 @@ private static Request transformRequest(HttpRequest request) {
         if (encoding != null) {
           builder.header(encoding.getName(), encoding.getValue());
         }
+      } else {
+        body = RequestBody.create(null, new byte[0]);
       }
     }
     builder.method(method, body);
@@ -101,7 +101,7 @@ private static HttpResponse transformResponse(Response response) throws IOExcept
   private final HttpParams params = new AbstractHttpParams() {
     @Override public Object getParameter(String name) {
       if (name.equals(ConnRouteParams.DEFAULT_PROXY)) {
-        Proxy proxy = client.getProxy();
+        Proxy proxy = client.proxy();
         if (proxy == null) {
           return null;
         }
@@ -118,7 +118,9 @@ private static HttpResponse transformResponse(Response response) throws IOExcept
         if (host != null) {
           proxy = new Proxy(HTTP, new InetSocketAddress(host.getHostName(), host.getPort()));
         }
-        client.setProxy(proxy);
+        client = client.newBuilder()
+            .proxy(proxy)
+            .build();
         return this;
       }
       throw new IllegalArgumentException(name);
@@ -133,7 +135,7 @@ private static HttpResponse transformResponse(Response response) throws IOExcept
     }
   };
 
-  private final OkHttpClient client;
+  private OkHttpClient client;
 
   public OkApacheClient() {
     this(new OkHttpClient());
diff --git a/okhttp-apache/src/test/java/com/squareup/okhttp/apache/OkApacheClientTest.java b/okhttp-apache/src/test/java/okhttp3/apache/OkApacheClientTest.java
similarity index 79%
rename from okhttp-apache/src/test/java/com/squareup/okhttp/apache/OkApacheClientTest.java
rename to okhttp-apache/src/test/java/okhttp3/apache/OkApacheClientTest.java
index ca47c0131a..77493a2540 100644
--- a/okhttp-apache/src/test/java/com/squareup/okhttp/apache/OkApacheClientTest.java
+++ b/okhttp-apache/src/test/java/okhttp3/apache/OkApacheClientTest.java
@@ -1,12 +1,13 @@
-package com.squareup.okhttp.apache;
+package okhttp3.apache;
 
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-import com.squareup.okhttp.mockwebserver.RecordedRequest;
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.io.InputStream;
+import java.net.URISyntaxException;
 import java.util.zip.GZIPInputStream;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
 import okio.Buffer;
 import okio.GzipSink;
 import okio.Okio;
@@ -15,6 +16,7 @@
 import org.apache.http.HttpResponse;
 import org.apache.http.client.methods.HttpGet;
 import org.apache.http.client.methods.HttpPost;
+import org.apache.http.client.methods.HttpPut;
 import org.apache.http.entity.ByteArrayEntity;
 import org.apache.http.entity.InputStreamEntity;
 import org.apache.http.entity.StringEntity;
@@ -23,7 +25,7 @@
 import org.junit.Before;
 import org.junit.Test;
 
-import static com.squareup.okhttp.internal.Util.UTF_8;
+import static okhttp3.internal.Util.UTF_8;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
@@ -45,7 +47,7 @@
   @Test public void success() throws Exception {
     server.enqueue(new MockResponse().setBody("Hello, World!"));
 
-    HttpGet request = new HttpGet(server.getUrl("/").toURI());
+    HttpGet request = new HttpGet(server.url("/").url().toURI());
     HttpResponse response = client.execute(request);
     String actual = EntityUtils.toString(response.getEntity());
     assertEquals("Hello, World!", actual);
@@ -55,7 +57,7 @@
     server.enqueue(new MockResponse().setResponseCode(302).addHeader("Location", "/foo"));
     server.enqueue(new MockResponse().setBody("Hello, Redirect!"));
 
-    HttpGet request = new HttpGet(server.getUrl("/").toURI());
+    HttpGet request = new HttpGet(server.url("/").url().toURI());
     HttpResponse response = client.execute(request);
     String actual = EntityUtils.toString(response.getEntity(), UTF_8);
     assertEquals("Hello, Redirect!", actual);
@@ -64,7 +66,7 @@
   @Test public void sessionExpired() throws Exception {
     server.enqueue(new MockResponse().setResponseCode(422));
 
-    HttpGet request = new HttpGet(server.getUrl("/").toURI());
+    HttpGet request = new HttpGet(server.url("/").url().toURI());
     HttpResponse response = client.execute(request);
     assertEquals(422, response.getStatusLine().getStatusCode());
   }
@@ -73,13 +75,13 @@
     server.enqueue(new MockResponse().addHeader("Foo", "Bar"));
     server.enqueue(new MockResponse().addHeader("Foo", "Bar").addHeader("Foo", "Baz"));
 
-    HttpGet request1 = new HttpGet(server.getUrl("/").toURI());
+    HttpGet request1 = new HttpGet(server.url("/").url().toURI());
     HttpResponse response1 = client.execute(request1);
     Header[] headers1 = response1.getHeaders("Foo");
     assertEquals(1, headers1.length);
     assertEquals("Bar", headers1[0].getValue());
 
-    HttpGet request2 = new HttpGet(server.getUrl("/").toURI());
+    HttpGet request2 = new HttpGet(server.url("/").url().toURI());
     HttpResponse response2 = client.execute(request2);
     Header[] headers2 = response2.getHeaders("Foo");
     assertEquals(2, headers2.length);
@@ -90,7 +92,7 @@
   @Test public void postByteEntity() throws Exception {
     server.enqueue(new MockResponse());
 
-    final HttpPost post = new HttpPost(server.getUrl("/").toURI());
+    final HttpPost post = new HttpPost(server.url("/").url().toURI());
     byte[] body = "Hello, world!".getBytes(UTF_8);
     post.setEntity(new ByteArrayEntity(body));
     client.execute(post);
@@ -103,7 +105,7 @@
   @Test public void postInputStreamEntity() throws Exception {
     server.enqueue(new MockResponse());
 
-    final HttpPost post = new HttpPost(server.getUrl("/").toURI());
+    final HttpPost post = new HttpPost(server.url("/").url().toURI());
     byte[] body = "Hello, world!".getBytes(UTF_8);
     post.setEntity(new InputStreamEntity(new ByteArrayInputStream(body), body.length));
     client.execute(post);
@@ -113,11 +115,31 @@
     assertEquals(request.getHeader("Content-Length"), "13");
   }
 
+  @Test public void postEmptyEntity() throws Exception {
+    server.enqueue(new MockResponse());
+    final HttpPost post = new HttpPost(server.url("/").url().toURI());
+    client.execute(post);
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals(0, request.getBodySize());
+    assertNotNull(request.getBody());
+  }
+
+  @Test public void putEmptyEntity() throws Exception {
+    server.enqueue(new MockResponse());
+    final HttpPut put = new HttpPut(server.url("/").url().toURI());
+    client.execute(put);
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals(0, request.getBodySize());
+    assertNotNull(request.getBody());
+  }
+
   @Test public void postOverrideContentType() throws Exception {
     server.enqueue(new MockResponse());
 
     HttpPost httpPost = new HttpPost();
-    httpPost.setURI(server.getUrl("/").toURI());
+    httpPost.setURI(server.url("/").url().toURI());
     httpPost.addHeader("Content-Type", "application/xml");
     httpPost.setEntity(new StringEntity("<yo/>"));
     client.execute(httpPost);
@@ -133,7 +155,7 @@
         .setHeader("Content-Type", "application/json"));
     server.enqueue(new MockResponse().setBody("Hello, World!"));
 
-    HttpGet request1 = new HttpGet(server.getUrl("/").toURI());
+    HttpGet request1 = new HttpGet(server.url("/").url().toURI());
     HttpResponse response1 = client.execute(request1);
     Header[] headers1 = response1.getHeaders("Content-Type");
     assertEquals(1, headers1.length);
@@ -141,7 +163,7 @@
     assertNotNull(response1.getEntity().getContentType());
     assertEquals("text/html", response1.getEntity().getContentType().getValue());
 
-    HttpGet request2 = new HttpGet(server.getUrl("/").toURI());
+    HttpGet request2 = new HttpGet(server.url("/").url().toURI());
     HttpResponse response2 = client.execute(request2);
     Header[] headers2 = response2.getHeaders("Content-Type");
     assertEquals(1, headers2.length);
@@ -149,19 +171,28 @@
     assertNotNull(response2.getEntity().getContentType());
     assertEquals("application/json", response2.getEntity().getContentType().getValue());
 
-    HttpGet request3 = new HttpGet(server.getUrl("/").toURI());
+    HttpGet request3 = new HttpGet(server.url("/").url().toURI());
     HttpResponse response3 = client.execute(request3);
     Header[] headers3 = response3.getHeaders("Content-Type");
     assertEquals(0, headers3.length);
     assertNull(response3.getEntity().getContentType());
   }
 
+  @Test public void contentTypeIsCaseInsensitive() throws URISyntaxException, IOException {
+    server.enqueue(new MockResponse().setBody("{\"Message\": { \"text\": \"Hello, World!\" } }")
+        .setHeader("cONTENT-tYPE", "application/json"));
+
+    HttpGet request = new HttpGet(server.url("/").url().toURI());
+    HttpResponse response = client.execute(request);
+    assertEquals("application/json", response.getEntity().getContentType().getValue());
+  }
+
   @Test public void contentEncoding() throws Exception {
     String text = "{\"Message\": { \"text\": \"Hello, World!\" } }";
     server.enqueue(new MockResponse().setBody(gzip(text))
         .setHeader("Content-Encoding", "gzip"));
 
-    HttpGet request = new HttpGet(server.getUrl("/").toURI());
+    HttpGet request = new HttpGet(server.url("/").url().toURI());
     request.setHeader("Accept-encoding", "gzip"); // Not transparent gzip.
     HttpResponse response = client.execute(request);
     HttpEntity entity = response.getEntity();
@@ -181,7 +212,7 @@
         .setHeader("Content-Encoding", "gzip")
         .setHeader("Content-Type", "application/json"));
 
-    HttpGet request1 = new HttpGet(server.getUrl("/").toURI());
+    HttpGet request1 = new HttpGet(server.url("/").url().toURI());
     request1.setHeader("Accept-encoding", "gzip"); // Not transparent gzip.
 
     HttpResponse response = client.execute(request1);
@@ -208,7 +239,7 @@
         .setHeader("Content-Encoding", "gzip")
         .setHeader("Content-Type", "application/json"));
 
-    HttpGet request = new HttpGet(server.getUrl("/").toURI());
+    HttpGet request = new HttpGet(server.url("/").url().toURI());
     HttpResponse response = client.execute(request);
     HttpEntity entity = response.getEntity();
 
diff --git a/okhttp-hpacktests/pom.xml b/okhttp-hpacktests/pom.xml
index 6ae44d5ce6..7e8fb57ad7 100644
--- a/okhttp-hpacktests/pom.xml
+++ b/okhttp-hpacktests/pom.xml
@@ -1,12 +1,14 @@
 <?xml version="1.0" encoding="UTF-8"?>
 
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+<project xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
   <modelVersion>4.0.0</modelVersion>
 
   <parent>
-    <groupId>com.squareup.okhttp</groupId>
+    <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>2.3.0-SNAPSHOT</version>
+    <version>3.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-hpacktests</artifactId>
@@ -18,27 +20,31 @@
       <artifactId>okio</artifactId>
     </dependency>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>com.squareup.moshi</groupId>
+      <artifactId>moshi</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
       <artifactId>okhttp</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp-testing-support</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
     <dependency>
       <groupId>junit</groupId>
       <artifactId>junit</artifactId>
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>${project.groupId}</groupId>
       <artifactId>mockwebserver</artifactId>
       <version>${project.version}</version>
       <scope>test</scope>
     </dependency>
-    <!--  Gson: Java to Json conversion -->
-    <dependency>
-      <groupId>com.google.code.gson</groupId>
-      <artifactId>gson</artifactId>
-      <scope>compile</scope>
-    </dependency>
   </dependencies>
 
   <build>
diff --git a/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDecodeInteropTest.java b/okhttp-hpacktests/src/test/java/okhttp3/internal/framed/HpackDecodeInteropTest.java
similarity index 82%
rename from okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDecodeInteropTest.java
rename to okhttp-hpacktests/src/test/java/okhttp3/internal/framed/HpackDecodeInteropTest.java
index 30e1a7b47f..e99c2a29cd 100644
--- a/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDecodeInteropTest.java
+++ b/okhttp-hpacktests/src/test/java/okhttp3/internal/framed/HpackDecodeInteropTest.java
@@ -13,15 +13,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.spdy;
+package okhttp3.internal.framed;
 
-import com.squareup.okhttp.internal.spdy.hpackjson.Story;
 import java.util.Collection;
+import okhttp3.internal.framed.hpackjson.Story;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
-import static com.squareup.okhttp.internal.spdy.hpackjson.HpackJsonUtil.storiesForCurrentDraft;
+import static okhttp3.internal.framed.hpackjson.HpackJsonUtil.storiesForCurrentDraft;
 
 @RunWith(Parameterized.class)
 public class HpackDecodeInteropTest extends HpackDecodeTestBase {
@@ -30,7 +30,7 @@ public HpackDecodeInteropTest(Story story) {
     super(story);
   }
 
-  @Parameterized.Parameters(name="{0}")
+  @Parameterized.Parameters(name = "{0}")
   public static Collection<Story[]> createStories() throws Exception {
     return createStories(storiesForCurrentDraft());
   }
diff --git a/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDecodeTestBase.java b/okhttp-hpacktests/src/test/java/okhttp3/internal/framed/HpackDecodeTestBase.java
similarity index 87%
rename from okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDecodeTestBase.java
rename to okhttp-hpacktests/src/test/java/okhttp3/internal/framed/HpackDecodeTestBase.java
index e26b66963a..a77c4d8a02 100644
--- a/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDecodeTestBase.java
+++ b/okhttp-hpacktests/src/test/java/okhttp3/internal/framed/HpackDecodeTestBase.java
@@ -13,15 +13,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.spdy;
+package okhttp3.internal.framed;
 
-import com.squareup.okhttp.internal.spdy.hpackjson.Case;
-import com.squareup.okhttp.internal.spdy.hpackjson.HpackJsonUtil;
-import com.squareup.okhttp.internal.spdy.hpackjson.Story;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.LinkedHashSet;
 import java.util.List;
+import okhttp3.internal.framed.hpackjson.Case;
+import okhttp3.internal.framed.hpackjson.HpackJsonUtil;
+import okhttp3.internal.framed.hpackjson.Story;
 import okio.Buffer;
 
 import static org.junit.Assert.assertEquals;
@@ -44,7 +44,7 @@
         fail("No stories for: " + interopTestName);
       }
       for (Story story : stories) {
-        result.add(new Story[] { story });
+        result.add(new Story[] {story});
       }
     }
     return result;
@@ -60,8 +60,7 @@ public HpackDecodeTestBase(Story story) {
   }
 
   /**
-   * Expects wire to be set for all cases, and compares the decoder's output to
-   * expected headers.
+   * Expects wire to be set for all cases, and compares the decoder's output to expected headers.
    */
   protected void testDecoder() throws Exception {
     testDecoder(story);
@@ -75,9 +74,10 @@ protected void testDecoder(Story story) throws Exception {
           hpackReader.getAndResetHeaderList());
     }
   }
+
   /**
-   * Checks if {@code expected} and {@code observed} are equal when viewed as a
-   * set and headers are deduped.
+   * Checks if {@code expected} and {@code observed} are equal when viewed as a set and headers are
+   * deduped.
    *
    * TODO: See if duped headers should be preserved on decode and verify.
    */
diff --git a/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackRoundTripTest.java b/okhttp-hpacktests/src/test/java/okhttp3/internal/framed/HpackRoundTripTest.java
similarity index 86%
rename from okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackRoundTripTest.java
rename to okhttp-hpacktests/src/test/java/okhttp3/internal/framed/HpackRoundTripTest.java
index 44916724e2..8405a1fd7f 100644
--- a/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackRoundTripTest.java
+++ b/okhttp-hpacktests/src/test/java/okhttp3/internal/framed/HpackRoundTripTest.java
@@ -13,17 +13,16 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.spdy;
+package okhttp3.internal.framed;
 
-import com.squareup.okhttp.internal.spdy.hpackjson.Case;
-import com.squareup.okhttp.internal.spdy.hpackjson.Story;
+import java.util.Collection;
+import okhttp3.internal.framed.hpackjson.Case;
+import okhttp3.internal.framed.hpackjson.Story;
 import okio.Buffer;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
-import java.util.Collection;
-
 /**
  * Tests for round-tripping headers through hpack..
  */
@@ -34,9 +33,9 @@
 @RunWith(Parameterized.class)
 public class HpackRoundTripTest extends HpackDecodeTestBase {
 
-  private static final String[] RAW_DATA = { "raw-data" };
+  private static final String[] RAW_DATA = {"raw-data"};
 
-  @Parameterized.Parameters(name="{0}")
+  @Parameterized.Parameters(name = "{0}")
   public static Collection<Story[]> getStories() throws Exception {
     return createStories(RAW_DATA);
   }
@@ -59,5 +58,4 @@ public void testRoundTrip() throws Exception {
 
     testDecoder(story);
   }
-
 }
diff --git a/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/hpackjson/Case.java b/okhttp-hpacktests/src/test/java/okhttp3/internal/framed/hpackjson/Case.java
similarity index 89%
rename from okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/hpackjson/Case.java
rename to okhttp-hpacktests/src/test/java/okhttp3/internal/framed/hpackjson/Case.java
index d5d272872c..4c931b7c0e 100644
--- a/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/hpackjson/Case.java
+++ b/okhttp-hpacktests/src/test/java/okhttp3/internal/framed/hpackjson/Case.java
@@ -13,20 +13,18 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.spdy.hpackjson;
-
-import com.squareup.okhttp.internal.spdy.Header;
-import okio.ByteString;
+package okhttp3.internal.framed.hpackjson;
 
 import java.util.ArrayList;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
+import okhttp3.internal.framed.Header;
+import okio.ByteString;
 
 /**
- * Representation of an individual case (set of headers and wire format).
- * There are many cases for a single story.  This class is used reflectively
- * with Gson to parse stories.
+ * Representation of an individual case (set of headers and wire format). There are many cases for a
+ * single story.  This class is used reflectively with Moshi to parse stories.
  */
 public class Case implements Cloneable {
 
diff --git a/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/hpackjson/HpackJsonUtil.java b/okhttp-hpacktests/src/test/java/okhttp3/internal/framed/hpackjson/HpackJsonUtil.java
similarity index 79%
rename from okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/hpackjson/HpackJsonUtil.java
rename to okhttp-hpacktests/src/test/java/okhttp3/internal/framed/hpackjson/HpackJsonUtil.java
index f64302410c..1d38261c53 100644
--- a/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/hpackjson/HpackJsonUtil.java
+++ b/okhttp-hpacktests/src/test/java/okhttp3/internal/framed/hpackjson/HpackJsonUtil.java
@@ -13,19 +13,18 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.spdy.hpackjson;
+package okhttp3.internal.framed.hpackjson;
 
-import com.google.gson.Gson;
-import com.google.gson.GsonBuilder;
+import com.squareup.moshi.JsonAdapter;
+import com.squareup.moshi.Moshi;
 import java.io.File;
-import java.io.FileInputStream;
 import java.io.IOException;
 import java.io.InputStream;
-import java.io.InputStreamReader;
 import java.net.URISyntaxException;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
+import okio.Okio;
 
 /**
  * Utilities for reading HPACK tests.
@@ -36,20 +35,25 @@
 
   private static final String STORY_RESOURCE_FORMAT = "/hpack-test-case/%s/story_%02d.json";
 
-  private static final Gson GSON = new GsonBuilder().create();
+  private static final Moshi MOSHI = new Moshi.Builder().build();
+  private static final JsonAdapter<Story> STORY_JSON_ADAPTER = MOSHI.adapter(Story.class);
 
   private static Story readStory(InputStream jsonResource) throws IOException {
-    return GSON.fromJson(new InputStreamReader(jsonResource, "UTF-8"), Story.class);
+    return STORY_JSON_ADAPTER.fromJson(Okio.buffer(Okio.source(jsonResource)));
+  }
+
+  private static Story readStory(File file) throws IOException {
+    return STORY_JSON_ADAPTER.fromJson(Okio.buffer(Okio.source(file)));
   }
 
   /** Iterate through the hpack-test-case resources, only picking stories for the current draft. */
   public static String[] storiesForCurrentDraft() throws URISyntaxException {
     File testCaseDirectory = new File(HpackJsonUtil.class.getResource("/hpack-test-case").toURI());
-    List<String> storyNames = new ArrayList<String>();
+    List<String> storyNames = new ArrayList<>();
     for (File path : testCaseDirectory.listFiles()) {
       if (path.isDirectory() && Arrays.asList(path.list()).contains("story_00.json")) {
         try {
-          Story firstStory = readStory(new FileInputStream(new File(path, "story_00.json")));
+          Story firstStory = readStory(new File(path, "story_00.json"));
           if (firstStory.getDraft() >= BASE_DRAFT) {
             storyNames.add(path.getName());
           }
@@ -85,5 +89,6 @@ private static Story readStory(InputStream jsonResource) throws IOException {
     return result;
   }
 
-  private HpackJsonUtil() { } // Utilities only.
-}
\ No newline at end of file
+  private HpackJsonUtil() {
+  } // Utilities only.
+}
diff --git a/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/hpackjson/Story.java b/okhttp-hpacktests/src/test/java/okhttp3/internal/framed/hpackjson/Story.java
similarity index 92%
rename from okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/hpackjson/Story.java
rename to okhttp-hpacktests/src/test/java/okhttp3/internal/framed/hpackjson/Story.java
index 5ff2b07675..3d14d5dab5 100644
--- a/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/hpackjson/Story.java
+++ b/okhttp-hpacktests/src/test/java/okhttp3/internal/framed/hpackjson/Story.java
@@ -13,14 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.spdy.hpackjson;
+package okhttp3.internal.framed.hpackjson;
 
 import java.util.ArrayList;
 import java.util.List;
 
 /**
- * Representation of one story, a set of request headers to encode or decode.
- * This class is used reflectively with Gson to parse stories from files.
+ * Representation of one story, a set of request headers to encode or decode. This class is used
+ * reflectively with Moshi to parse stories from files.
  */
 public class Story implements Cloneable {
 
diff --git a/okhttp-logging-interceptor/README.md b/okhttp-logging-interceptor/README.md
new file mode 100644
index 0000000000..1c5dcd952a
--- /dev/null
+++ b/okhttp-logging-interceptor/README.md
@@ -0,0 +1,50 @@
+Logging Interceptor
+===================
+
+An [OkHttp interceptor][1] which logs HTTP request and response data.
+
+```java
+HttpLoggingInterceptor logging = new HttpLoggingInterceptor();
+logging.setLevel(Level.BASIC);
+OkHttpClient client = new OkHttpClient.Builder()
+  .addInterceptor(logging)
+  .build();
+```
+
+You can change the log level at any time by calling `setLevel`.
+
+To log to a custom location, pass a `Logger` instance to the constructor.
+```java
+HttpLoggingInterceptor logging = new HttpLoggingInterceptor(new Logger() {
+  @Override public void log(String message) {
+    Timber.tag("OkHttp").d(message);
+  }
+});
+```
+
+**Warning**: The logs generated by this interceptor when using the `HEADERS` or `BODY` levels has
+the potential to leak sensitive information such as "Authorization" or "Cookie" headers and the
+contents of request and response bodies. This data should only be logged in a controlled way or in
+a non-production environment.
+
+
+Download
+--------
+
+Get via Maven:
+```xml
+<dependency>
+  <groupId>com.squareup.okhttp3</groupId>
+  <artifactId>logging-interceptor</artifactId>
+  <version>(insert latest version)</version>
+</dependency>
+```
+
+or via Gradle 
+```groovy
+compile 'com.squareup.okhttp3:logging-interceptor:(insert latest version)'
+```
+
+
+
+ [1]: https://github.com/square/okhttp/wiki/Interceptors
diff --git a/okhttp-logging-interceptor/pom.xml b/okhttp-logging-interceptor/pom.xml
new file mode 100644
index 0000000000..6a451bf7fa
--- /dev/null
+++ b/okhttp-logging-interceptor/pom.xml
@@ -0,0 +1,40 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.okhttp3</groupId>
+    <artifactId>parent</artifactId>
+    <version>3.4.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>logging-interceptor</artifactId>
+  <name>OkHttp Logging Interceptor</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp-testing-support</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+</project>
diff --git a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java
new file mode 100644
index 0000000000..309ebc3f30
--- /dev/null
+++ b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java
@@ -0,0 +1,301 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.logging;
+
+import java.io.EOFException;
+import java.io.IOException;
+import java.nio.charset.Charset;
+import java.nio.charset.UnsupportedCharsetException;
+import java.util.concurrent.TimeUnit;
+import okhttp3.Connection;
+import okhttp3.Headers;
+import okhttp3.Interceptor;
+import okhttp3.MediaType;
+import okhttp3.OkHttpClient;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+import okhttp3.internal.Platform;
+import okhttp3.internal.http.HttpEngine;
+import okio.Buffer;
+import okio.BufferedSource;
+
+import static okhttp3.internal.Platform.INFO;
+
+/**
+ * An OkHttp interceptor which logs request and response information. Can be applied as an
+ * {@linkplain OkHttpClient#interceptors() application interceptor} or as a {@linkplain
+ * OkHttpClient#networkInterceptors() network interceptor}. <p> The format of the logs created by
+ * this class should not be considered stable and may change slightly between releases. If you need
+ * a stable logging format, use your own interceptor.
+ */
+public final class HttpLoggingInterceptor implements Interceptor {
+  private static final Charset UTF8 = Charset.forName("UTF-8");
+
+  public enum Level {
+    /** No logs. */
+    NONE,
+    /**
+     * Logs request and response lines.
+     *
+     * <p>Example:
+     * <pre>{@code
+     * --> POST /greeting http/1.1 (3-byte body)
+     *
+     * <-- 200 OK (22ms, 6-byte body)
+     * }</pre>
+     */
+    BASIC,
+    /**
+     * Logs request and response lines and their respective headers.
+     *
+     * <p>Example:
+     * <pre>{@code
+     * --> POST /greeting http/1.1
+     * Host: example.com
+     * Content-Type: plain/text
+     * Content-Length: 3
+     * --> END POST
+     *
+     * <-- 200 OK (22ms)
+     * Content-Type: plain/text
+     * Content-Length: 6
+     * <-- END HTTP
+     * }</pre>
+     */
+    HEADERS,
+    /**
+     * Logs request and response lines and their respective headers and bodies (if present).
+     *
+     * <p>Example:
+     * <pre>{@code
+     * --> POST /greeting http/1.1
+     * Host: example.com
+     * Content-Type: plain/text
+     * Content-Length: 3
+     *
+     * Hi?
+     * --> END GET
+     *
+     * <-- 200 OK (22ms)
+     * Content-Type: plain/text
+     * Content-Length: 6
+     *
+     * Hello!
+     * <-- END HTTP
+     * }</pre>
+     */
+    BODY
+  }
+
+  public interface Logger {
+    void log(String message);
+
+    /** A {@link Logger} defaults output appropriate for the current platform. */
+    Logger DEFAULT = new Logger() {
+      @Override public void log(String message) {
+        Platform.get().log(INFO, message, null);
+      }
+    };
+  }
+
+  public HttpLoggingInterceptor() {
+    this(Logger.DEFAULT);
+  }
+
+  public HttpLoggingInterceptor(Logger logger) {
+    this.logger = logger;
+  }
+
+  private final Logger logger;
+
+  private volatile Level level = Level.NONE;
+
+  /** Change the level at which this interceptor logs. */
+  public HttpLoggingInterceptor setLevel(Level level) {
+    if (level == null) throw new NullPointerException("level == null. Use Level.NONE instead.");
+    this.level = level;
+    return this;
+  }
+
+  public Level getLevel() {
+    return level;
+  }
+
+  @Override public Response intercept(Chain chain) throws IOException {
+    Level level = this.level;
+
+    Request request = chain.request();
+    if (level == Level.NONE) {
+      return chain.proceed(request);
+    }
+
+    boolean logBody = level == Level.BODY;
+    boolean logHeaders = logBody || level == Level.HEADERS;
+
+    RequestBody requestBody = request.body();
+    boolean hasRequestBody = requestBody != null;
+
+    Connection connection = chain.connection();
+    Protocol protocol = connection != null ? connection.protocol() : Protocol.HTTP_1_1;
+    String requestStartMessage = "--> " + request.method() + ' ' + request.url() + ' ' + protocol;
+    if (!logHeaders && hasRequestBody) {
+      requestStartMessage += " (" + requestBody.contentLength() + "-byte body)";
+    }
+    logger.log(requestStartMessage);
+
+    if (logHeaders) {
+      if (hasRequestBody) {
+        // Request body headers are only present when installed as a network interceptor. Force
+        // them to be included (when available) so there values are known.
+        if (requestBody.contentType() != null) {
+          logger.log("Content-Type: " + requestBody.contentType());
+        }
+        if (requestBody.contentLength() != -1) {
+          logger.log("Content-Length: " + requestBody.contentLength());
+        }
+      }
+
+      Headers headers = request.headers();
+      for (int i = 0, count = headers.size(); i < count; i++) {
+        String name = headers.name(i);
+        // Skip headers from the request body as they are explicitly logged above.
+        if (!"Content-Type".equalsIgnoreCase(name) && !"Content-Length".equalsIgnoreCase(name)) {
+          logger.log(name + ": " + headers.value(i));
+        }
+      }
+
+      if (!logBody || !hasRequestBody) {
+        logger.log("--> END " + request.method());
+      } else if (bodyEncoded(request.headers())) {
+        logger.log("--> END " + request.method() + " (encoded body omitted)");
+      } else {
+        Buffer buffer = new Buffer();
+        requestBody.writeTo(buffer);
+
+        Charset charset = UTF8;
+        MediaType contentType = requestBody.contentType();
+        if (contentType != null) {
+          charset = contentType.charset(UTF8);
+        }
+
+        logger.log("");
+        if (isPlaintext(buffer)) {
+          logger.log(buffer.readString(charset));
+          logger.log("--> END " + request.method()
+              + " (" + requestBody.contentLength() + "-byte body)");
+        } else {
+          logger.log("--> END " + request.method() + " (binary "
+              + requestBody.contentLength() + "-byte body omitted)");
+        }
+      }
+    }
+
+    long startNs = System.nanoTime();
+    Response response;
+    try {
+      response = chain.proceed(request);
+    } catch (Exception e) {
+      logger.log("<-- HTTP FAILED: " + e);
+      throw e;
+    }
+    long tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNs);
+
+    ResponseBody responseBody = response.body();
+    long contentLength = responseBody.contentLength();
+    String bodySize = contentLength != -1 ? contentLength + "-byte" : "unknown-length";
+    logger.log("<-- " + response.code() + ' ' + response.message() + ' '
+        + response.request().url() + " (" + tookMs + "ms" + (!logHeaders ? ", "
+        + bodySize + " body" : "") + ')');
+
+    if (logHeaders) {
+      Headers headers = response.headers();
+      for (int i = 0, count = headers.size(); i < count; i++) {
+        logger.log(headers.name(i) + ": " + headers.value(i));
+      }
+
+      if (!logBody || !HttpEngine.hasBody(response)) {
+        logger.log("<-- END HTTP");
+      } else if (bodyEncoded(response.headers())) {
+        logger.log("<-- END HTTP (encoded body omitted)");
+      } else {
+        BufferedSource source = responseBody.source();
+        source.request(Long.MAX_VALUE); // Buffer the entire body.
+        Buffer buffer = source.buffer();
+
+        Charset charset = UTF8;
+        MediaType contentType = responseBody.contentType();
+        if (contentType != null) {
+          try {
+            charset = contentType.charset(UTF8);
+          } catch (UnsupportedCharsetException e) {
+            logger.log("");
+            logger.log("Couldn't decode the response body; charset is likely malformed.");
+            logger.log("<-- END HTTP");
+
+            return response;
+          }
+        }
+
+        if (!isPlaintext(buffer)) {
+          logger.log("");
+          logger.log("<-- END HTTP (binary " + buffer.size() + "-byte body omitted)");
+          return response;
+        }
+
+        if (contentLength != 0) {
+          logger.log("");
+          logger.log(buffer.clone().readString(charset));
+        }
+
+        logger.log("<-- END HTTP (" + buffer.size() + "-byte body)");
+      }
+    }
+
+    return response;
+  }
+
+  /**
+   * Returns true if the body in question probably contains human readable text. Uses a small sample
+   * of code points to detect unicode control characters commonly used in binary file signatures.
+   */
+  static boolean isPlaintext(Buffer buffer) throws EOFException {
+    try {
+      Buffer prefix = new Buffer();
+      long byteCount = buffer.size() < 64 ? buffer.size() : 64;
+      buffer.copyTo(prefix, 0, byteCount);
+      for (int i = 0; i < 16; i++) {
+        if (prefix.exhausted()) {
+          break;
+        }
+        int codePoint = prefix.readUtf8CodePoint();
+        if (Character.isISOControl(codePoint) && !Character.isWhitespace(codePoint)) {
+          return false;
+        }
+      }
+      return true;
+    } catch (EOFException e) {
+      return false; // Truncated UTF-8 sequence.
+    }
+  }
+
+  private boolean bodyEncoded(Headers headers) {
+    String contentEncoding = headers.get("Content-Encoding");
+    return contentEncoding != null && !contentEncoding.equalsIgnoreCase("identity");
+  }
+}
diff --git a/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java b/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java
new file mode 100644
index 0000000000..caa6cd72bd
--- /dev/null
+++ b/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java
@@ -0,0 +1,703 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.logging;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.regex.Pattern;
+import okhttp3.Dns;
+import okhttp3.HttpUrl;
+import okhttp3.MediaType;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
+import okhttp3.logging.HttpLoggingInterceptor.Level;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.ByteString;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class HttpLoggingInterceptorTest {
+  private static final MediaType PLAIN = MediaType.parse("text/plain; charset=utf-8");
+
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private OkHttpClient client;
+  private String host;
+  private HttpUrl url;
+
+  private final LogRecorder networkLogs = new LogRecorder();
+  private final HttpLoggingInterceptor networkInterceptor =
+      new HttpLoggingInterceptor(networkLogs);
+
+  private final LogRecorder applicationLogs = new LogRecorder();
+  private final HttpLoggingInterceptor applicationInterceptor =
+      new HttpLoggingInterceptor(applicationLogs);
+
+  private void setLevel(Level level) {
+    networkInterceptor.setLevel(level);
+    applicationInterceptor.setLevel(level);
+  }
+
+  @Before public void setUp() {
+    client = new OkHttpClient.Builder()
+        .addNetworkInterceptor(networkInterceptor)
+        .addInterceptor(applicationInterceptor)
+        .build();
+
+    host = server.getHostName() + ":" + server.getPort();
+    url = server.url("/");
+  }
+
+  @Test public void levelGetter() {
+    // The default is NONE.
+    Assert.assertEquals(Level.NONE, applicationInterceptor.getLevel());
+
+    for (Level level : Level.values()) {
+      applicationInterceptor.setLevel(level);
+      assertEquals(level, applicationInterceptor.getLevel());
+    }
+  }
+
+  @Test public void setLevelShouldPreventNullValue() {
+    try {
+      applicationInterceptor.setLevel(null);
+      fail();
+    } catch (NullPointerException expected) {
+      assertEquals("level == null. Use Level.NONE instead.", expected.getMessage());
+    }
+  }
+
+  @Test public void setLevelShouldReturnSameInstanceOfInterceptor() {
+    for (Level level : Level.values()) {
+      assertSame(applicationInterceptor, applicationInterceptor.setLevel(level));
+    }
+  }
+
+  @Test public void none() throws IOException {
+    server.enqueue(new MockResponse());
+    client.newCall(request().build()).execute();
+
+    applicationLogs.assertNoMoreLogs();
+    networkLogs.assertNoMoreLogs();
+  }
+
+  @Test public void basicGet() throws IOException {
+    setLevel(Level.BASIC);
+
+    server.enqueue(new MockResponse());
+    client.newCall(request().build()).execute();
+
+    applicationLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms, 0-byte body\\)")
+        .assertNoMoreLogs();
+
+    networkLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms, 0-byte body\\)")
+        .assertNoMoreLogs();
+  }
+
+  @Test public void basicPost() throws IOException {
+    setLevel(Level.BASIC);
+
+    server.enqueue(new MockResponse());
+    client.newCall(request().post(RequestBody.create(PLAIN, "Hi?")).build()).execute();
+
+    applicationLogs
+        .assertLogEqual("--> POST " + url + " http/1.1 (3-byte body)")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms, 0-byte body\\)")
+        .assertNoMoreLogs();
+
+    networkLogs
+        .assertLogEqual("--> POST " + url + " http/1.1 (3-byte body)")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms, 0-byte body\\)")
+        .assertNoMoreLogs();
+  }
+
+  @Test public void basicResponseBody() throws IOException {
+    setLevel(Level.BASIC);
+
+    server.enqueue(new MockResponse()
+        .setBody("Hello!")
+        .setHeader("Content-Type", PLAIN));
+    Response response = client.newCall(request().build()).execute();
+    response.body().close();
+
+    applicationLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms, 6-byte body\\)")
+        .assertNoMoreLogs();
+
+    networkLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms, 6-byte body\\)")
+        .assertNoMoreLogs();
+  }
+
+  @Test public void basicChunkedResponseBody() throws IOException {
+    setLevel(Level.BASIC);
+
+    server.enqueue(new MockResponse()
+        .setChunkedBody("Hello!", 2)
+        .setHeader("Content-Type", PLAIN));
+    Response response = client.newCall(request().build()).execute();
+    response.body().close();
+
+    applicationLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms, unknown-length body\\)")
+        .assertNoMoreLogs();
+
+    networkLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms, unknown-length body\\)")
+        .assertNoMoreLogs();
+  }
+
+  @Test public void headersGet() throws IOException {
+    setLevel(Level.HEADERS);
+
+    server.enqueue(new MockResponse());
+    Response response = client.newCall(request().build()).execute();
+    response.body().close();
+
+    applicationLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("--> END GET")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 0")
+        .assertLogEqual("<-- END HTTP")
+        .assertNoMoreLogs();
+
+    networkLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("Host: " + host)
+        .assertLogEqual("Connection: Keep-Alive")
+        .assertLogEqual("Accept-Encoding: gzip")
+        .assertLogMatch("User-Agent: okhttp/.+")
+        .assertLogEqual("--> END GET")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 0")
+        .assertLogEqual("<-- END HTTP")
+        .assertNoMoreLogs();
+  }
+
+  @Test public void headersPost() throws IOException {
+    setLevel(Level.HEADERS);
+
+    server.enqueue(new MockResponse());
+    Request request = request().post(RequestBody.create(PLAIN, "Hi?")).build();
+    Response response = client.newCall(request).execute();
+    response.body().close();
+
+    applicationLogs
+        .assertLogEqual("--> POST " + url + " http/1.1")
+        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
+        .assertLogEqual("Content-Length: 3")
+        .assertLogEqual("--> END POST")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 0")
+        .assertLogEqual("<-- END HTTP")
+        .assertNoMoreLogs();
+
+    networkLogs
+        .assertLogEqual("--> POST " + url + " http/1.1")
+        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
+        .assertLogEqual("Content-Length: 3")
+        .assertLogEqual("Host: " + host)
+        .assertLogEqual("Connection: Keep-Alive")
+        .assertLogEqual("Accept-Encoding: gzip")
+        .assertLogMatch("User-Agent: okhttp/.+")
+        .assertLogEqual("--> END POST")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 0")
+        .assertLogEqual("<-- END HTTP")
+        .assertNoMoreLogs();
+  }
+
+  @Test public void headersPostNoContentType() throws IOException {
+    setLevel(Level.HEADERS);
+
+    server.enqueue(new MockResponse());
+    Request request = request().post(RequestBody.create(null, "Hi?")).build();
+    Response response = client.newCall(request).execute();
+    response.body().close();
+
+    applicationLogs
+        .assertLogEqual("--> POST " + url + " http/1.1")
+        .assertLogEqual("Content-Length: 3")
+        .assertLogEqual("--> END POST")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 0")
+        .assertLogEqual("<-- END HTTP")
+        .assertNoMoreLogs();
+
+    networkLogs
+        .assertLogEqual("--> POST " + url + " http/1.1")
+        .assertLogEqual("Content-Length: 3")
+        .assertLogEqual("Host: " + host)
+        .assertLogEqual("Connection: Keep-Alive")
+        .assertLogEqual("Accept-Encoding: gzip")
+        .assertLogMatch("User-Agent: okhttp/.+")
+        .assertLogEqual("--> END POST")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 0")
+        .assertLogEqual("<-- END HTTP")
+        .assertNoMoreLogs();
+  }
+
+  @Test public void headersPostNoLength() throws IOException {
+    setLevel(Level.HEADERS);
+
+    server.enqueue(new MockResponse());
+    RequestBody body = new RequestBody() {
+      @Override public MediaType contentType() {
+        return PLAIN;
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        sink.writeUtf8("Hi!");
+      }
+    };
+    Response response = client.newCall(request().post(body).build()).execute();
+    response.body().close();
+
+    applicationLogs
+        .assertLogEqual("--> POST " + url + " http/1.1")
+        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
+        .assertLogEqual("--> END POST")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 0")
+        .assertLogEqual("<-- END HTTP")
+        .assertNoMoreLogs();
+
+    networkLogs
+        .assertLogEqual("--> POST " + url + " http/1.1")
+        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
+        .assertLogEqual("Transfer-Encoding: chunked")
+        .assertLogEqual("Host: " + host)
+        .assertLogEqual("Connection: Keep-Alive")
+        .assertLogEqual("Accept-Encoding: gzip")
+        .assertLogMatch("User-Agent: okhttp/.+")
+        .assertLogEqual("--> END POST")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 0")
+        .assertLogEqual("<-- END HTTP")
+        .assertNoMoreLogs();
+  }
+
+  @Test public void headersResponseBody() throws IOException {
+    setLevel(Level.HEADERS);
+
+    server.enqueue(new MockResponse()
+        .setBody("Hello!")
+        .setHeader("Content-Type", PLAIN));
+    Response response = client.newCall(request().build()).execute();
+    response.body().close();
+
+    applicationLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("--> END GET")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 6")
+        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
+        .assertLogEqual("<-- END HTTP")
+        .assertNoMoreLogs();
+
+    networkLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("Host: " + host)
+        .assertLogEqual("Connection: Keep-Alive")
+        .assertLogEqual("Accept-Encoding: gzip")
+        .assertLogMatch("User-Agent: okhttp/.+")
+        .assertLogEqual("--> END GET")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 6")
+        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
+        .assertLogEqual("<-- END HTTP")
+        .assertNoMoreLogs();
+  }
+
+  @Test public void bodyGet() throws IOException {
+    setLevel(Level.BODY);
+
+    server.enqueue(new MockResponse());
+    Response response = client.newCall(request().build()).execute();
+    response.body().close();
+
+    applicationLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("--> END GET")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 0")
+        .assertLogEqual("<-- END HTTP (0-byte body)")
+        .assertNoMoreLogs();
+
+    networkLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("Host: " + host)
+        .assertLogEqual("Connection: Keep-Alive")
+        .assertLogEqual("Accept-Encoding: gzip")
+        .assertLogMatch("User-Agent: okhttp/.+")
+        .assertLogEqual("--> END GET")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 0")
+        .assertLogEqual("<-- END HTTP (0-byte body)")
+        .assertNoMoreLogs();
+  }
+
+  @Test public void bodyGet204() throws IOException {
+    setLevel(Level.BODY);
+    bodyGetNoBody(204);
+  }
+
+  @Test public void bodyGet205() throws IOException {
+    setLevel(Level.BODY);
+    bodyGetNoBody(205);
+  }
+
+  private void bodyGetNoBody(int code) throws IOException {
+    server.enqueue(new MockResponse()
+        .setStatus("HTTP/1.1 " + code + " No Content"));
+    Response response = client.newCall(request().build()).execute();
+    response.body().close();
+
+    applicationLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("--> END GET")
+        .assertLogMatch("<-- " + code + " No Content " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 0")
+        .assertLogEqual("<-- END HTTP (0-byte body)")
+        .assertNoMoreLogs();
+
+    networkLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("Host: " + host)
+        .assertLogEqual("Connection: Keep-Alive")
+        .assertLogEqual("Accept-Encoding: gzip")
+        .assertLogMatch("User-Agent: okhttp/.+")
+        .assertLogEqual("--> END GET")
+        .assertLogMatch("<-- " + code + " No Content " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 0")
+        .assertLogEqual("<-- END HTTP (0-byte body)")
+        .assertNoMoreLogs();
+  }
+
+  @Test public void bodyPost() throws IOException {
+    setLevel(Level.BODY);
+
+    server.enqueue(new MockResponse());
+    Request request = request().post(RequestBody.create(PLAIN, "Hi?")).build();
+    Response response = client.newCall(request).execute();
+    response.body().close();
+
+    applicationLogs
+        .assertLogEqual("--> POST " + url + " http/1.1")
+        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
+        .assertLogEqual("Content-Length: 3")
+        .assertLogEqual("")
+        .assertLogEqual("Hi?")
+        .assertLogEqual("--> END POST (3-byte body)")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 0")
+        .assertLogEqual("<-- END HTTP (0-byte body)")
+        .assertNoMoreLogs();
+
+    networkLogs
+        .assertLogEqual("--> POST " + url + " http/1.1")
+        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
+        .assertLogEqual("Content-Length: 3")
+        .assertLogEqual("Host: " + host)
+        .assertLogEqual("Connection: Keep-Alive")
+        .assertLogEqual("Accept-Encoding: gzip")
+        .assertLogMatch("User-Agent: okhttp/.+")
+        .assertLogEqual("")
+        .assertLogEqual("Hi?")
+        .assertLogEqual("--> END POST (3-byte body)")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 0")
+        .assertLogEqual("<-- END HTTP (0-byte body)")
+        .assertNoMoreLogs();
+  }
+
+  @Test public void bodyResponseBody() throws IOException {
+    setLevel(Level.BODY);
+
+    server.enqueue(new MockResponse()
+        .setBody("Hello!")
+        .setHeader("Content-Type", PLAIN));
+    Response response = client.newCall(request().build()).execute();
+    response.body().close();
+
+    applicationLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("--> END GET")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 6")
+        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
+        .assertLogEqual("")
+        .assertLogEqual("Hello!")
+        .assertLogEqual("<-- END HTTP (6-byte body)")
+        .assertNoMoreLogs();
+
+    networkLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("Host: " + host)
+        .assertLogEqual("Connection: Keep-Alive")
+        .assertLogEqual("Accept-Encoding: gzip")
+        .assertLogMatch("User-Agent: okhttp/.+")
+        .assertLogEqual("--> END GET")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 6")
+        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
+        .assertLogEqual("")
+        .assertLogEqual("Hello!")
+        .assertLogEqual("<-- END HTTP (6-byte body)")
+        .assertNoMoreLogs();
+  }
+
+  @Test public void bodyResponseBodyChunked() throws IOException {
+    setLevel(Level.BODY);
+
+    server.enqueue(new MockResponse()
+        .setChunkedBody("Hello!", 2)
+        .setHeader("Content-Type", PLAIN));
+    Response response = client.newCall(request().build()).execute();
+    response.body().close();
+
+    applicationLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("--> END GET")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Transfer-encoding: chunked")
+        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
+        .assertLogEqual("")
+        .assertLogEqual("Hello!")
+        .assertLogEqual("<-- END HTTP (6-byte body)")
+        .assertNoMoreLogs();
+
+    networkLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("Host: " + host)
+        .assertLogEqual("Connection: Keep-Alive")
+        .assertLogEqual("Accept-Encoding: gzip")
+        .assertLogMatch("User-Agent: okhttp/.+")
+        .assertLogEqual("--> END GET")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Transfer-encoding: chunked")
+        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
+        .assertLogEqual("")
+        .assertLogEqual("Hello!")
+        .assertLogEqual("<-- END HTTP (6-byte body)")
+        .assertNoMoreLogs();
+  }
+
+  @Test public void bodyResponseNotIdentityEncoded() throws IOException {
+    setLevel(Level.BODY);
+
+    server.enqueue(new MockResponse()
+        .setHeader("Content-Encoding", "gzip")
+        .setHeader("Content-Type", PLAIN)
+        .setBody(new Buffer().write(ByteString.decodeBase64(
+            "H4sIAAAAAAAAAPNIzcnJ11HwQKIAdyO+9hMAAAA="))));
+    Response response = client.newCall(request().build()).execute();
+    response.body().close();
+
+    networkLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("Host: " + host)
+        .assertLogEqual("Connection: Keep-Alive")
+        .assertLogEqual("Accept-Encoding: gzip")
+        .assertLogMatch("User-Agent: okhttp/.+")
+        .assertLogEqual("--> END GET")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Encoding: gzip")
+        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
+        .assertLogMatch("Content-Length: \\d+")
+        .assertLogEqual("<-- END HTTP (encoded body omitted)")
+        .assertNoMoreLogs();
+
+    applicationLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("--> END GET")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
+        .assertLogEqual("")
+        .assertLogEqual("Hello, Hello, Hello")
+        .assertLogEqual("<-- END HTTP (19-byte body)")
+        .assertNoMoreLogs();
+  }
+
+  @Test public void bodyGetMalformedCharset() throws IOException {
+    setLevel(Level.BODY);
+
+    server.enqueue(new MockResponse()
+        .setHeader("Content-Type", "text/html; charset=0")
+        .setBody("Ignore This"));
+    Response response = client.newCall(request().build()).execute();
+    response.body().close();
+
+    networkLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("Host: " + host)
+        .assertLogEqual("Connection: Keep-Alive")
+        .assertLogEqual("Accept-Encoding: gzip")
+        .assertLogMatch("User-Agent: okhttp/.+")
+        .assertLogEqual("--> END GET")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Type: text/html; charset=0")
+        .assertLogMatch("Content-Length: \\d+")
+        .assertLogMatch("")
+        .assertLogEqual("Couldn't decode the response body; charset is likely malformed.")
+        .assertLogEqual("<-- END HTTP")
+        .assertNoMoreLogs();
+
+    applicationLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("--> END GET")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Type: text/html; charset=0")
+        .assertLogMatch("Content-Length: \\d+")
+        .assertLogEqual("")
+        .assertLogEqual("Couldn't decode the response body; charset is likely malformed.")
+        .assertLogEqual("<-- END HTTP")
+        .assertNoMoreLogs();
+  }
+
+  @Test public void isPlaintext() throws IOException {
+    assertTrue(HttpLoggingInterceptor.isPlaintext(new Buffer()));
+    assertTrue(HttpLoggingInterceptor.isPlaintext(new Buffer().writeUtf8("abc")));
+    assertTrue(HttpLoggingInterceptor.isPlaintext(new Buffer().writeUtf8("new\r\nlines")));
+    assertTrue(HttpLoggingInterceptor.isPlaintext(new Buffer().writeUtf8("white\t space")));
+    assertTrue(HttpLoggingInterceptor.isPlaintext(new Buffer().writeByte(0x80)));
+    assertFalse(HttpLoggingInterceptor.isPlaintext(new Buffer().writeByte(0x00)));
+    assertFalse(HttpLoggingInterceptor.isPlaintext(new Buffer().writeByte(0xc0)));
+  }
+
+  @Test public void responseBodyIsBinary() throws IOException {
+    setLevel(Level.BODY);
+    Buffer buffer = new Buffer();
+    buffer.writeUtf8CodePoint(0x89);
+    buffer.writeUtf8CodePoint(0x50);
+    buffer.writeUtf8CodePoint(0x4e);
+    buffer.writeUtf8CodePoint(0x47);
+    buffer.writeUtf8CodePoint(0x0d);
+    buffer.writeUtf8CodePoint(0x0a);
+    buffer.writeUtf8CodePoint(0x1a);
+    buffer.writeUtf8CodePoint(0x0a);
+    server.enqueue(new MockResponse()
+        .setBody(buffer)
+        .setHeader("Content-Type", "image/png; charset=utf-8"));
+    Response response = client.newCall(request().build()).execute();
+    response.body().close();
+
+    applicationLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("--> END GET")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 9")
+        .assertLogEqual("Content-Type: image/png; charset=utf-8")
+        .assertLogEqual("")
+        .assertLogEqual("<-- END HTTP (binary 9-byte body omitted)")
+        .assertNoMoreLogs();
+
+    networkLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("Host: " + host)
+        .assertLogEqual("Connection: Keep-Alive")
+        .assertLogEqual("Accept-Encoding: gzip")
+        .assertLogMatch("User-Agent: okhttp/.+")
+        .assertLogEqual("--> END GET")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 9")
+        .assertLogEqual("Content-Type: image/png; charset=utf-8")
+        .assertLogEqual("")
+        .assertLogEqual("<-- END HTTP (binary 9-byte body omitted)")
+        .assertNoMoreLogs();
+  }
+
+  @Test public void connectFail() throws IOException {
+    setLevel(Level.BASIC);
+    client = new OkHttpClient.Builder()
+        .dns(new Dns() {
+          @Override public List<InetAddress> lookup(String hostname) throws UnknownHostException {
+            throw new UnknownHostException("reason");
+          }
+        })
+        .addInterceptor(applicationInterceptor)
+        .build();
+
+    try {
+      client.newCall(request().build()).execute();
+      fail();
+    } catch (UnknownHostException expected) {
+    }
+
+    applicationLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("<-- HTTP FAILED: java.net.UnknownHostException: reason")
+        .assertNoMoreLogs();
+  }
+
+  private Request.Builder request() {
+    return new Request.Builder().url(url);
+  }
+
+  private static class LogRecorder implements HttpLoggingInterceptor.Logger {
+    private final List<String> logs = new ArrayList<>();
+    private int index;
+
+    LogRecorder assertLogEqual(String expected) {
+      assertTrue("No more messages found", index < logs.size());
+      String actual = logs.get(index++);
+      assertEquals(expected, actual);
+      return this;
+    }
+
+    LogRecorder assertLogMatch(String pattern) {
+      assertTrue("No more messages found", index < logs.size());
+      String actual = logs.get(index++);
+      assertTrue("<" + actual + "> did not match pattern <" + pattern + ">",
+          Pattern.matches(pattern, actual));
+      return this;
+    }
+
+    void assertNoMoreLogs() {
+      assertTrue("More messages remain: " + logs.subList(index, logs.size()), index == logs.size());
+    }
+
+    @Override public void log(String message) {
+      logs.add(message);
+    }
+  }
+}
diff --git a/okhttp-testing-support/pom.xml b/okhttp-testing-support/pom.xml
new file mode 100644
index 0000000000..943f53acb7
--- /dev/null
+++ b/okhttp-testing-support/pom.xml
@@ -0,0 +1,27 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.okhttp3</groupId>
+    <artifactId>parent</artifactId>
+    <version>3.4.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>okhttp-testing-support</artifactId>
+  <name>OkHttp test support classes</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <optional>true</optional>
+    </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+  </dependencies>
+</project>
diff --git a/okhttp-testing-support/src/main/java/okhttp3/FakeDns.java b/okhttp-testing-support/src/main/java/okhttp3/FakeDns.java
new file mode 100644
index 0000000000..f2edc75d66
--- /dev/null
+++ b/okhttp-testing-support/src/main/java/okhttp3/FakeDns.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+
+import static org.junit.Assert.assertEquals;
+
+public final class FakeDns implements Dns {
+  private List<String> requestedHosts = new ArrayList<>();
+  private List<InetAddress> addresses = Collections.emptyList();
+
+  /** Sets the addresses to be returned by this fake DNS service. */
+  public FakeDns addresses(List<InetAddress> addresses) {
+    this.addresses = new ArrayList<>(addresses);
+    return this;
+  }
+
+  /** Sets the service to throw when a hostname is requested. */
+  public FakeDns unknownHost() {
+    this.addresses = Collections.emptyList();
+    return this;
+  }
+
+  public InetAddress address(int index) {
+    return addresses.get(index);
+  }
+
+  @Override public List<InetAddress> lookup(String hostname) throws UnknownHostException {
+    requestedHosts.add(hostname);
+    if (addresses.isEmpty()) throw new UnknownHostException();
+    return addresses;
+  }
+
+  public void assertRequests(String... expectedHosts) {
+    assertEquals(Arrays.asList(expectedHosts), requestedHosts);
+    requestedHosts.clear();
+  }
+}
diff --git a/okhttp-testing-support/src/main/java/okhttp3/FakeProxySelector.java b/okhttp-testing-support/src/main/java/okhttp3/FakeProxySelector.java
new file mode 100644
index 0000000000..c7d37f57ea
--- /dev/null
+++ b/okhttp-testing-support/src/main/java/okhttp3/FakeProxySelector.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.net.Proxy;
+import java.net.ProxySelector;
+import java.net.SocketAddress;
+import java.net.URI;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+public final class FakeProxySelector extends ProxySelector {
+  public final List<Proxy> proxies = new ArrayList<>();
+
+  public FakeProxySelector addProxy(Proxy proxy) {
+    proxies.add(proxy);
+    return this;
+  }
+
+  @Override public List<Proxy> select(URI uri) {
+    // Don't handle 'socket' schemes, which the RI's Socket class may request (for SOCKS).
+    return uri.getScheme().equals("http") || uri.getScheme().equals("https") ? proxies
+        : Collections.singletonList(Proxy.NO_PROXY);
+  }
+
+  @Override public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/tls/FakeSSLSession.java b/okhttp-testing-support/src/main/java/okhttp3/FakeSSLSession.java
similarity index 97%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/tls/FakeSSLSession.java
rename to okhttp-testing-support/src/main/java/okhttp3/FakeSSLSession.java
index 215e968dfe..ab67a9f06e 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/tls/FakeSSLSession.java
+++ b/okhttp-testing-support/src/main/java/okhttp3/FakeSSLSession.java
@@ -14,7 +14,7 @@
  * License for the specific language governing permissions and limitations under
  * the License.
  */
-package com.squareup.okhttp.internal.tls;
+package okhttp3;
 
 import java.security.Principal;
 import java.security.cert.Certificate;
@@ -23,7 +23,7 @@
 import javax.net.ssl.SSLSessionContext;
 import javax.security.cert.X509Certificate;
 
-final class FakeSSLSession implements SSLSession {
+public final class FakeSSLSession implements SSLSession {
   private final Certificate[] certificates;
 
   public FakeSSLSession(Certificate... certificates) throws Exception {
diff --git a/okhttp-testing-support/src/main/java/okhttp3/RecordingCookieJar.java b/okhttp-testing-support/src/main/java/okhttp3/RecordingCookieJar.java
new file mode 100644
index 0000000000..bd4f9be142
--- /dev/null
+++ b/okhttp-testing-support/src/main/java/okhttp3/RecordingCookieJar.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.Deque;
+import java.util.List;
+
+import static org.junit.Assert.assertEquals;
+
+public final class RecordingCookieJar implements CookieJar {
+  private final Deque<List<Cookie>> requestCookies = new ArrayDeque<>();
+  private final Deque<List<Cookie>> responseCookies = new ArrayDeque<>();
+
+  public void enqueueRequestCookies(Cookie... cookies) {
+    requestCookies.add(Arrays.asList(cookies));
+  }
+
+  public List<Cookie> takeResponseCookies() {
+    return responseCookies.removeFirst();
+  }
+
+  public void assertResponseCookies(String... cookies) {
+    List<Cookie> actualCookies = takeResponseCookies();
+    List<String> actualCookieStrings = new ArrayList<>();
+    for (Cookie cookie : actualCookies) {
+      actualCookieStrings.add(cookie.toString());
+    }
+    assertEquals(Arrays.asList(cookies), actualCookieStrings);
+  }
+
+  @Override public void saveFromResponse(HttpUrl url, List<Cookie> cookies) {
+    responseCookies.add(cookies);
+  }
+
+  @Override public List<Cookie> loadForRequest(HttpUrl url) {
+    if (requestCookies.isEmpty()) return Collections.emptyList();
+    return requestCookies.removeFirst();
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/RecordingHostnameVerifier.java b/okhttp-testing-support/src/main/java/okhttp3/RecordingHostnameVerifier.java
similarity index 96%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/RecordingHostnameVerifier.java
rename to okhttp-testing-support/src/main/java/okhttp3/RecordingHostnameVerifier.java
index c9d914f5f2..568b7c518c 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/RecordingHostnameVerifier.java
+++ b/okhttp-testing-support/src/main/java/okhttp3/RecordingHostnameVerifier.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal;
+package okhttp3;
 
 import java.util.ArrayList;
 import java.util.List;
diff --git a/okhttp-testing-support/src/main/java/okhttp3/internal/io/InMemoryFileSystem.java b/okhttp-testing-support/src/main/java/okhttp3/internal/io/InMemoryFileSystem.java
new file mode 100644
index 0000000000..bb6f519092
--- /dev/null
+++ b/okhttp-testing-support/src/main/java/okhttp3/internal/io/InMemoryFileSystem.java
@@ -0,0 +1,138 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.io;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.IdentityHashMap;
+import java.util.Iterator;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import okio.Buffer;
+import okio.ForwardingSink;
+import okio.ForwardingSource;
+import okio.Sink;
+import okio.Source;
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+
+/** A simple file system where all files are held in memory. Not safe for concurrent use. */
+public final class InMemoryFileSystem implements FileSystem, TestRule {
+  private final Map<File, Buffer> files = new LinkedHashMap<>();
+  private final Map<Source, File> openSources = new IdentityHashMap<>();
+  private final Map<Sink, File> openSinks = new IdentityHashMap<>();
+
+  @Override public Statement apply(final Statement base, Description description) {
+    return new Statement() {
+      @Override public void evaluate() throws Throwable {
+        base.evaluate();
+        ensureResourcesClosed();
+      }
+    };
+  }
+
+  public void ensureResourcesClosed() {
+    List<String> openResources = new ArrayList<>();
+    for (File file : openSources.values()) {
+      openResources.add("Source for " + file);
+    }
+    for (File file : openSinks.values()) {
+      openResources.add("Sink for " + file);
+    }
+    if (!openResources.isEmpty()) {
+      StringBuilder builder = new StringBuilder("Resources acquired but not closed:");
+      for (String resource : openResources) {
+        builder.append("\n * ").append(resource);
+      }
+      throw new IllegalStateException(builder.toString());
+    }
+  }
+
+  @Override public Source source(File file) throws FileNotFoundException {
+    Buffer result = files.get(file);
+    if (result == null) throw new FileNotFoundException();
+
+    final Source source = result.clone();
+    openSources.put(source, file);
+
+    return new ForwardingSource(source) {
+      @Override public void close() throws IOException {
+        openSources.remove(source);
+        super.close();
+      }
+    };
+  }
+
+  @Override public Sink sink(File file) throws FileNotFoundException {
+    return sink(file, false);
+  }
+
+  @Override public Sink appendingSink(File file) throws FileNotFoundException {
+    return sink(file, true);
+  }
+
+  private Sink sink(File file, boolean appending) {
+    Buffer result = null;
+    if (appending) {
+      result = files.get(file);
+    }
+    if (result == null) {
+      result = new Buffer();
+    }
+    files.put(file, result);
+
+    final Sink sink = result;
+    openSinks.put(sink, file);
+
+    return new ForwardingSink(sink) {
+      @Override public void close() throws IOException {
+        openSinks.remove(sink);
+        super.close();
+      }
+    };
+  }
+
+  @Override public void delete(File file) throws IOException {
+    files.remove(file);
+  }
+
+  @Override public boolean exists(File file) {
+    return files.containsKey(file);
+  }
+
+  @Override public long size(File file) {
+    Buffer buffer = files.get(file);
+    return buffer != null ? buffer.size() : 0L;
+  }
+
+  @Override public void rename(File from, File to) throws IOException {
+    Buffer buffer = files.remove(from);
+    if (buffer == null) throw new FileNotFoundException();
+    files.put(to, buffer);
+  }
+
+  @Override public void deleteContents(File directory) throws IOException {
+    String prefix = directory.toString() + "/";
+    for (Iterator<File> i = files.keySet().iterator(); i.hasNext(); ) {
+      File file = i.next();
+      if (file.toString().startsWith(prefix)) i.remove();
+    }
+  }
+}
diff --git a/okhttp-testing-support/src/main/java/okhttp3/testing/InstallUncaughtExceptionHandlerListener.java b/okhttp-testing-support/src/main/java/okhttp3/testing/InstallUncaughtExceptionHandlerListener.java
new file mode 100644
index 0000000000..38652c07de
--- /dev/null
+++ b/okhttp-testing-support/src/main/java/okhttp3/testing/InstallUncaughtExceptionHandlerListener.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.testing;
+
+import java.io.PrintWriter;
+import java.io.StringWriter;
+import org.junit.runner.Description;
+import org.junit.runner.Result;
+import org.junit.runner.notification.RunListener;
+
+/**
+ * A {@link org.junit.runner.notification.RunListener} used to install an aggressive default {@link
+ * java.lang.Thread.UncaughtExceptionHandler} similar to the one found on Android. No exceptions
+ * should escape from OkHttp that might cause apps to be killed or tests to fail on Android.
+ */
+public class InstallUncaughtExceptionHandlerListener extends RunListener {
+
+  private Thread.UncaughtExceptionHandler oldDefaultUncaughtExceptionHandler;
+  private Description lastTestStarted;
+
+  @Override public void testRunStarted(Description description) throws Exception {
+    System.err.println("Installing aggressive uncaught exception handler");
+    oldDefaultUncaughtExceptionHandler = Thread.getDefaultUncaughtExceptionHandler();
+    Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
+      @Override public void uncaughtException(Thread thread, Throwable throwable) {
+        StringWriter errorText = new StringWriter(256);
+        errorText.append("Uncaught exception in OkHttp thread \"");
+        errorText.append(thread.getName());
+        errorText.append("\"\n");
+        throwable.printStackTrace(new PrintWriter(errorText));
+        errorText.append("\n");
+        if (lastTestStarted != null) {
+          errorText.append("Last test to start was: ");
+          errorText.append(lastTestStarted.getDisplayName());
+          errorText.append("\n");
+        }
+        System.err.print(errorText.toString());
+        System.exit(-1);
+      }
+    });
+  }
+
+  @Override public void testStarted(Description description) throws Exception {
+    lastTestStarted = description;
+  }
+
+  @Override public void testRunFinished(Result result) throws Exception {
+    Thread.setDefaultUncaughtExceptionHandler(oldDefaultUncaughtExceptionHandler);
+    System.err.println("Uninstalled aggressive uncaught exception handler");
+  }
+}
diff --git a/okhttp-tests/pom.xml b/okhttp-tests/pom.xml
index e3a99660ec..5585632fc2 100644
--- a/okhttp-tests/pom.xml
+++ b/okhttp-tests/pom.xml
@@ -4,9 +4,9 @@
   <modelVersion>4.0.0</modelVersion>
 
   <parent>
-    <groupId>com.squareup.okhttp</groupId>
+    <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>2.4.0-SNAPSHOT</version>
+    <version>3.4.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-tests</artifactId>
@@ -18,12 +18,18 @@
       <artifactId>okio</artifactId>
     </dependency>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>${project.groupId}</groupId>
       <artifactId>okhttp</artifactId>
       <version>${project.version}</version>
     </dependency>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp-testing-support</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
       <artifactId>okhttp-urlconnection</artifactId>
       <version>${project.version}</version>
     </dependency>
@@ -34,7 +40,7 @@
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>${project.groupId}</groupId>
       <artifactId>mockwebserver</artifactId>
       <version>${project.version}</version>
       <scope>test</scope>
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/CertificatePinnerTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/CertificatePinnerTest.java
deleted file mode 100644
index c5cea2803d..0000000000
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/CertificatePinnerTest.java
+++ /dev/null
@@ -1,138 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp;
-
-import com.squareup.okhttp.internal.SslContextBuilder;
-import java.security.GeneralSecurityException;
-import java.security.KeyPair;
-import java.security.cert.X509Certificate;
-import javax.net.ssl.SSLPeerUnverifiedException;
-import org.junit.Test;
-
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-public final class CertificatePinnerTest {
-  static SslContextBuilder sslContextBuilder;
-
-  static KeyPair keyPairA;
-  static X509Certificate keypairACertificate1;
-  static String keypairACertificate1Pin;
-
-  static KeyPair keyPairB;
-  static X509Certificate keypairBCertificate1;
-  static String keypairBCertificate1Pin;
-
-  static {
-    try {
-      sslContextBuilder = new SslContextBuilder("example.com");
-
-      keyPairA = sslContextBuilder.generateKeyPair();
-      keypairACertificate1 = sslContextBuilder.selfSignedCertificate(keyPairA, "1");
-      keypairACertificate1Pin = CertificatePinner.pin(keypairACertificate1);
-
-      keyPairB = sslContextBuilder.generateKeyPair();
-      keypairBCertificate1 = sslContextBuilder.selfSignedCertificate(keyPairB, "1");
-      keypairBCertificate1Pin = CertificatePinner.pin(keypairBCertificate1);
-    } catch (GeneralSecurityException e) {
-      throw new AssertionError(e);
-    }
-  }
-
-  @Test public void malformedPin() throws Exception {
-    CertificatePinner.Builder builder = new CertificatePinner.Builder();
-    try {
-      builder.add("example.com", "md5/DmxUShsZuNiqPQsX2Oi9uv2sCnw=");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void malformedBase64() throws Exception {
-    CertificatePinner.Builder builder = new CertificatePinner.Builder();
-    try {
-      builder.add("example.com", "sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw*");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  /** Multiple certificates generated from the same keypair have the same pin. */
-  @Test public void sameKeypairSamePin() throws Exception {
-    X509Certificate keypairACertificate2 = sslContextBuilder.selfSignedCertificate(keyPairA, "2");
-    String keypairACertificate2Pin = CertificatePinner.pin(keypairACertificate2);
-
-    X509Certificate keypairBCertificate2 = sslContextBuilder.selfSignedCertificate(keyPairB, "2");
-    String keypairBCertificate2Pin = CertificatePinner.pin(keypairBCertificate2);
-
-    assertTrue(keypairACertificate1Pin.equals(keypairACertificate2Pin));
-    assertTrue(keypairBCertificate1Pin.equals(keypairBCertificate2Pin));
-    assertFalse(keypairACertificate1Pin.equals(keypairBCertificate1Pin));
-  }
-
-  @Test public void successfulCheck() throws Exception {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("example.com", keypairACertificate1Pin)
-        .build();
-
-    certificatePinner.check("example.com", keypairACertificate1);
-  }
-
-  @Test public void successfulMatchAcceptsAnyMatchingCertificate() throws Exception {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("example.com", keypairBCertificate1Pin)
-        .build();
-
-    certificatePinner.check("example.com", keypairACertificate1, keypairBCertificate1);
-  }
-
-  @Test public void unsuccessfulCheck() throws Exception {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("example.com", keypairACertificate1Pin)
-        .build();
-
-    try {
-      certificatePinner.check("example.com", keypairBCertificate1);
-      fail();
-    } catch (SSLPeerUnverifiedException expected) {
-    }
-  }
-
-  @Test public void multipleCertificatesForOneHostname() throws Exception {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("example.com", keypairACertificate1Pin, keypairBCertificate1Pin)
-        .build();
-
-    certificatePinner.check("example.com", keypairACertificate1);
-    certificatePinner.check("example.com", keypairBCertificate1);
-  }
-
-  @Test public void multipleHostnamesForOneCertificate() throws Exception {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("example.com", keypairACertificate1Pin)
-        .add("www.example.com", keypairACertificate1Pin)
-        .build();
-
-    certificatePinner.check("example.com", keypairACertificate1);
-    certificatePinner.check("www.example.com", keypairACertificate1);
-  }
-
-  @Test public void absentHostnameMatches() throws Exception {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder().build();
-    certificatePinner.check("example.com", keypairACertificate1);
-  }
-}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java
deleted file mode 100644
index ebeb698ae3..0000000000
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java
+++ /dev/null
@@ -1,582 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp;
-
-import com.squareup.okhttp.internal.RecordingHostnameVerifier;
-import com.squareup.okhttp.internal.SslContextBuilder;
-import com.squareup.okhttp.internal.Util;
-import com.squareup.okhttp.internal.http.AuthenticatorAdapter;
-import com.squareup.okhttp.internal.http.RecordingProxySelector;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-import java.io.IOException;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.Proxy;
-import java.util.Arrays;
-import java.util.List;
-import java.util.concurrent.Executor;
-import javax.net.SocketFactory;
-import javax.net.ssl.SSLContext;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-public final class ConnectionPoolTest {
-  private static final int KEEP_ALIVE_DURATION_MS = 5000;
-  private static final SSLContext sslContext = SslContextBuilder.localhost();
-
-  private MockWebServer spdyServer;
-  private InetSocketAddress spdySocketAddress;
-  private Address spdyAddress;
-
-  private MockWebServer httpServer;
-  private Address httpAddress;
-  private InetSocketAddress httpSocketAddress;
-
-  private ConnectionPool pool;
-  private FakeExecutor cleanupExecutor;
-  private Connection httpA;
-  private Connection httpB;
-  private Connection httpC;
-  private Connection httpD;
-  private Connection httpE;
-  private Connection spdyA;
-
-  private Object owner;
-
-  @Before public void setUp() throws Exception {
-    setUp(2);
-  }
-
-  private void setUp(int poolSize) throws Exception {
-    SocketFactory socketFactory = SocketFactory.getDefault();
-    RecordingProxySelector proxySelector = new RecordingProxySelector();
-
-    spdyServer = new MockWebServer();
-    httpServer = new MockWebServer();
-    spdyServer.useHttps(sslContext.getSocketFactory(), false);
-
-    List<ConnectionSpec> connectionSpecs = Util.immutableList(
-        ConnectionSpec.MODERN_TLS, ConnectionSpec.CLEARTEXT);
-
-    httpServer.start();
-    httpAddress = new Address(httpServer.getHostName(), httpServer.getPort(), socketFactory, null,
-        null, null, AuthenticatorAdapter.INSTANCE, null,
-        Util.immutableList(Protocol.SPDY_3, Protocol.HTTP_1_1), connectionSpecs, proxySelector);
-    httpSocketAddress = new InetSocketAddress(InetAddress.getByName(httpServer.getHostName()),
-        httpServer.getPort());
-
-    spdyServer.start();
-    spdyAddress = new Address(spdyServer.getHostName(), spdyServer.getPort(), socketFactory,
-        sslContext.getSocketFactory(), new RecordingHostnameVerifier(), CertificatePinner.DEFAULT,
-        AuthenticatorAdapter.INSTANCE, null, Util.immutableList(Protocol.SPDY_3, Protocol.HTTP_1_1),
-        connectionSpecs, proxySelector);
-    spdySocketAddress = new InetSocketAddress(InetAddress.getByName(spdyServer.getHostName()),
-        spdyServer.getPort());
-
-    Route httpRoute = new Route(httpAddress, Proxy.NO_PROXY, httpSocketAddress,
-        ConnectionSpec.CLEARTEXT);
-    Route spdyRoute = new Route(spdyAddress, Proxy.NO_PROXY, spdySocketAddress,
-        ConnectionSpec.MODERN_TLS);
-    pool = new ConnectionPool(poolSize, KEEP_ALIVE_DURATION_MS);
-    // Disable the automatic execution of the cleanup.
-    cleanupExecutor = new FakeExecutor();
-    pool.replaceCleanupExecutorForTests(cleanupExecutor);
-    httpA = new Connection(pool, httpRoute);
-    httpA.connect(200, 200, 200, null);
-    httpB = new Connection(pool, httpRoute);
-    httpB.connect(200, 200, 200, null);
-    httpC = new Connection(pool, httpRoute);
-    httpC.connect(200, 200, 200, null);
-    httpD = new Connection(pool, httpRoute);
-    httpD.connect(200, 200, 200, null);
-    httpE = new Connection(pool, httpRoute);
-    httpE.connect(200, 200, 200, null);
-    spdyA = new Connection(pool, spdyRoute);
-    spdyA.connect(20000, 20000, 2000, null);
-
-    owner = new Object();
-    httpA.setOwner(owner);
-    httpB.setOwner(owner);
-    httpC.setOwner(owner);
-    httpD.setOwner(owner);
-    httpE.setOwner(owner);
-  }
-
-  @After public void tearDown() throws Exception {
-    httpServer.shutdown();
-    spdyServer.shutdown();
-
-    Util.closeQuietly(httpA.getSocket());
-    Util.closeQuietly(httpB.getSocket());
-    Util.closeQuietly(httpC.getSocket());
-    Util.closeQuietly(httpD.getSocket());
-    Util.closeQuietly(httpE.getSocket());
-    Util.closeQuietly(spdyA.getSocket());
-  }
-
-  private void resetWithPoolSize(int poolSize) throws Exception {
-    tearDown();
-    setUp(poolSize);
-  }
-
-  @Test public void poolSingleHttpConnection() throws Exception {
-    resetWithPoolSize(1);
-    Connection connection = pool.get(httpAddress);
-    assertNull(connection);
-
-    connection = new Connection(pool, new Route(httpAddress, Proxy.NO_PROXY, httpSocketAddress,
-        ConnectionSpec.CLEARTEXT));
-    connection.connect(200, 200, 200, null);
-    connection.setOwner(owner);
-    assertEquals(0, pool.getConnectionCount());
-
-    pool.recycle(connection);
-    assertNull(connection.getOwner());
-    assertEquals(1, pool.getConnectionCount());
-    assertEquals(1, pool.getHttpConnectionCount());
-    assertEquals(0, pool.getMultiplexedConnectionCount());
-
-    Connection recycledConnection = pool.get(httpAddress);
-    assertNull(connection.getOwner());
-    assertEquals(connection, recycledConnection);
-    assertTrue(recycledConnection.isAlive());
-
-    recycledConnection = pool.get(httpAddress);
-    assertNull(recycledConnection);
-  }
-
-  @Test public void getDoesNotScheduleCleanup() {
-    Connection connection = pool.get(httpAddress);
-    assertNull(connection);
-    cleanupExecutor.assertExecutionScheduled(false);
-  }
-
-  @Test public void recycleSchedulesCleanup() {
-    cleanupExecutor.assertExecutionScheduled(false);
-    pool.recycle(httpA);
-    cleanupExecutor.assertExecutionScheduled(true);
-  }
-
-  @Test public void shareSchedulesCleanup() {
-    cleanupExecutor.assertExecutionScheduled(false);
-    pool.share(spdyA);
-    cleanupExecutor.assertExecutionScheduled(true);
-  }
-
-  @Test public void poolPrefersMostRecentlyRecycled() throws Exception {
-    pool.recycle(httpA);
-    pool.recycle(httpB);
-    pool.recycle(httpC);
-    assertPooled(pool, httpC, httpB, httpA);
-
-    pool.performCleanup();
-    assertPooled(pool, httpC, httpB);
-  }
-
-  @Test public void getSpdyConnection() throws Exception {
-    pool.share(spdyA);
-    assertSame(spdyA, pool.get(spdyAddress));
-    assertPooled(pool, spdyA);
-  }
-
-  @Test public void getHttpConnection() throws Exception {
-    pool.recycle(httpA);
-    assertSame(httpA, pool.get(httpAddress));
-    assertPooled(pool);
-  }
-
-  @Test public void expiredConnectionNotReturned() throws Exception {
-    pool.recycle(httpA);
-
-    // Allow enough time to pass so that the connection is now expired.
-    Thread.sleep(KEEP_ALIVE_DURATION_MS * 2);
-
-    // The connection is held, but will not be returned.
-    assertNull(pool.get(httpAddress));
-    assertPooled(pool, httpA);
-
-    // The connection must be cleaned up.
-    pool.performCleanup();
-    assertPooled(pool);
-  }
-
-  @Test public void maxIdleConnectionLimitIsEnforced() throws Exception {
-    pool.recycle(httpA);
-    pool.recycle(httpB);
-    pool.recycle(httpC);
-    pool.recycle(httpD);
-    assertPooled(pool, httpD, httpC, httpB, httpA);
-
-    pool.performCleanup();
-    assertPooled(pool, httpD, httpC);
-  }
-
-  @Test public void expiredConnectionsAreEvicted() throws Exception {
-    pool.recycle(httpA);
-    pool.recycle(httpB);
-
-    // Allow enough time to pass so that the connections are now expired.
-    Thread.sleep(2 * KEEP_ALIVE_DURATION_MS);
-    assertPooled(pool, httpB, httpA);
-
-    // The connections must be cleaned up.
-    pool.performCleanup();
-    assertPooled(pool);
-  }
-
-  @Test public void nonAliveConnectionNotReturned() throws Exception {
-    pool.recycle(httpA);
-
-    // Close the connection. It is an ex-connection. It has ceased to be.
-    httpA.getSocket().close();
-    assertPooled(pool, httpA);
-    assertNull(pool.get(httpAddress));
-
-    // The connection must be cleaned up.
-    pool.performCleanup();
-    assertPooled(pool);
-  }
-
-  @Test public void differentAddressConnectionNotReturned() throws Exception {
-    pool.recycle(httpA);
-    assertNull(pool.get(spdyAddress));
-    assertPooled(pool, httpA);
-  }
-
-  @Test public void gettingSpdyConnectionPromotesItToFrontOfQueue() throws Exception {
-    pool.share(spdyA);
-    pool.recycle(httpA);
-    assertPooled(pool, httpA, spdyA);
-    assertSame(spdyA, pool.get(spdyAddress));
-    assertPooled(pool, spdyA, httpA);
-  }
-
-  @Test public void gettingConnectionReturnsOldestFirst() throws Exception {
-    pool.recycle(httpA);
-    pool.recycle(httpB);
-    assertSame(httpA, pool.get(httpAddress));
-  }
-
-  @Test public void recyclingNonAliveConnectionClosesThatConnection() throws Exception {
-    httpA.getSocket().shutdownInput();
-    pool.recycle(httpA); // Should close httpA.
-    assertTrue(httpA.getSocket().isClosed());
-
-    // The pool should remain empty, and there is no need to schedule a cleanup.
-    assertPooled(pool);
-    cleanupExecutor.assertExecutionScheduled(false);
-  }
-
-  @Test public void shareHttpConnectionFails() throws Exception {
-    try {
-      pool.share(httpA);
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-    // The pool should remain empty, and there is no need to schedule a cleanup.
-    assertPooled(pool);
-    cleanupExecutor.assertExecutionScheduled(false);
-  }
-
-  @Test public void recycleSpdyConnectionDoesNothing() throws Exception {
-    pool.recycle(spdyA);
-    // The pool should remain empty, and there is no need to schedule the cleanup.
-    assertPooled(pool);
-    cleanupExecutor.assertExecutionScheduled(false);
-  }
-
-  @Test public void validateIdleSpdyConnectionTimeout() throws Exception {
-    pool.share(spdyA);
-    assertPooled(pool, spdyA); // Connection should be in the pool.
-
-    Thread.sleep((long) (KEEP_ALIVE_DURATION_MS * 0.7));
-    pool.performCleanup();
-    assertPooled(pool, spdyA); // Connection should still be in the pool.
-
-    Thread.sleep((long) (KEEP_ALIVE_DURATION_MS * 0.4));
-    pool.performCleanup();
-    assertPooled(pool); // Connection should have been removed.
-  }
-
-  @Test public void validateIdleHttpConnectionTimeout() throws Exception {
-    pool.recycle(httpA);
-    assertPooled(pool, httpA); // Connection should be in the pool.
-    cleanupExecutor.assertExecutionScheduled(true);
-
-    Thread.sleep((long) (KEEP_ALIVE_DURATION_MS * 0.7));
-    pool.performCleanup();
-    assertPooled(pool, httpA); // Connection should still be in the pool.
-
-    Thread.sleep((long) (KEEP_ALIVE_DURATION_MS * 0.4));
-    pool.performCleanup();
-    assertPooled(pool); // Connection should have been removed.
-  }
-
-  @Test public void maxConnections() throws IOException, InterruptedException {
-    // Pool should be empty.
-    assertEquals(0, pool.getConnectionCount());
-
-    // http A should be added to the pool.
-    pool.recycle(httpA);
-    assertEquals(1, pool.getConnectionCount());
-    assertEquals(1, pool.getHttpConnectionCount());
-    assertEquals(0, pool.getMultiplexedConnectionCount());
-
-    // http B should be added to the pool.
-    pool.recycle(httpB);
-    assertEquals(2, pool.getConnectionCount());
-    assertEquals(2, pool.getHttpConnectionCount());
-    assertEquals(0, pool.getMultiplexedConnectionCount());
-
-    // http C should be added
-    pool.recycle(httpC);
-    assertEquals(3, pool.getConnectionCount());
-    assertEquals(3, pool.getHttpConnectionCount());
-    assertEquals(0, pool.getSpdyConnectionCount());
-
-    pool.performCleanup();
-
-    // http A should be removed by cleanup.
-    assertEquals(2, pool.getConnectionCount());
-    assertEquals(2, pool.getHttpConnectionCount());
-    assertEquals(0, pool.getMultiplexedConnectionCount());
-
-    // spdy A should be added
-    pool.share(spdyA);
-    assertEquals(3, pool.getConnectionCount());
-    assertEquals(2, pool.getHttpConnectionCount());
-    assertEquals(1, pool.getSpdyConnectionCount());
-
-    pool.performCleanup();
-
-    // http B should be removed by cleanup.
-    assertEquals(2, pool.getConnectionCount());
-    assertEquals(1, pool.getHttpConnectionCount());
-    assertEquals(1, pool.getMultiplexedConnectionCount());
-
-    // http C should be returned.
-    Connection recycledHttpConnection = pool.get(httpAddress);
-    recycledHttpConnection.setOwner(owner);
-    assertNotNull(recycledHttpConnection);
-    assertTrue(recycledHttpConnection.isAlive());
-    assertEquals(1, pool.getConnectionCount());
-    assertEquals(0, pool.getHttpConnectionCount());
-    assertEquals(1, pool.getMultiplexedConnectionCount());
-
-    // spdy A will be returned but also kept in the pool.
-    Connection sharedSpdyConnection = pool.get(spdyAddress);
-    assertNotNull(sharedSpdyConnection);
-    assertEquals(spdyA, sharedSpdyConnection);
-    assertEquals(1, pool.getConnectionCount());
-    assertEquals(0, pool.getHttpConnectionCount());
-    assertEquals(1, pool.getMultiplexedConnectionCount());
-
-    // http C should be added to the pool
-    pool.recycle(httpC);
-    assertEquals(2, pool.getConnectionCount());
-    assertEquals(1, pool.getHttpConnectionCount());
-    assertEquals(1, pool.getMultiplexedConnectionCount());
-
-    // An http connection should be removed from the pool.
-    recycledHttpConnection = pool.get(httpAddress);
-    assertNotNull(recycledHttpConnection);
-    assertTrue(recycledHttpConnection.isAlive());
-    assertEquals(1, pool.getConnectionCount());
-    assertEquals(0, pool.getHttpConnectionCount());
-    assertEquals(1, pool.getMultiplexedConnectionCount());
-
-    // spdy A will be returned but also kept in the pool.
-    sharedSpdyConnection = pool.get(spdyAddress);
-    assertEquals(spdyA, sharedSpdyConnection);
-    assertNotNull(sharedSpdyConnection);
-    assertEquals(1, pool.getConnectionCount());
-    assertEquals(0, pool.getHttpConnectionCount());
-    assertEquals(1, pool.getMultiplexedConnectionCount());
-
-    // http D should be added to the pool.
-    pool.recycle(httpD);
-    assertEquals(2, pool.getConnectionCount());
-    assertEquals(1, pool.getHttpConnectionCount());
-    assertEquals(1, pool.getMultiplexedConnectionCount());
-
-    // http E should be added to the pool.
-    pool.recycle(httpE);
-    assertEquals(3, pool.getConnectionCount());
-    assertEquals(2, pool.getHttpConnectionCount());
-    assertEquals(1, pool.getSpdyConnectionCount());
-
-    pool.performCleanup();
-
-    // spdy A should be removed from the pool by cleanup.
-    assertEquals(2, pool.getConnectionCount());
-    assertEquals(2, pool.getHttpConnectionCount());
-    assertEquals(0, pool.getMultiplexedConnectionCount());
-  }
-
-  @Test public void connectionCleanup() throws Exception {
-    ConnectionPool pool = new ConnectionPool(10, KEEP_ALIVE_DURATION_MS);
-
-    // Add 3 connections to the pool.
-    pool.recycle(httpA);
-    pool.recycle(httpB);
-    pool.share(spdyA);
-
-    // Give the cleanup callable time to run and settle down.
-    Thread.sleep(100);
-
-    // Kill http A.
-    Util.closeQuietly(httpA.getSocket());
-
-    assertEquals(3, pool.getConnectionCount());
-    assertEquals(2, pool.getHttpConnectionCount());
-    assertEquals(1, pool.getSpdyConnectionCount());
-
-    // Http A should be removed.
-    pool.performCleanup();
-    assertPooled(pool, spdyA, httpB);
-    assertEquals(2, pool.getConnectionCount());
-    assertEquals(1, pool.getHttpConnectionCount());
-    assertEquals(1, pool.getMultiplexedConnectionCount());
-
-    // Now let enough time pass for the connections to expire.
-    Thread.sleep(2 * KEEP_ALIVE_DURATION_MS);
-
-    // All remaining connections should be removed.
-    pool.performCleanup();
-    assertEquals(0, pool.getConnectionCount());
-  }
-
-  @Test public void maxIdleConnectionsLimitEnforced() throws Exception {
-    ConnectionPool pool = new ConnectionPool(2, KEEP_ALIVE_DURATION_MS);
-
-    // Hit the max idle connections limit of 2.
-    pool.recycle(httpA);
-    pool.recycle(httpB);
-    Thread.sleep(100); // Give the cleanup callable time to run.
-    assertPooled(pool, httpB, httpA);
-
-    // Adding httpC bumps httpA.
-    pool.recycle(httpC);
-    Thread.sleep(100); // Give the cleanup callable time to run.
-    assertPooled(pool, httpC, httpB);
-
-    // Adding httpD bumps httpB.
-    pool.recycle(httpD);
-    Thread.sleep(100); // Give the cleanup callable time to run.
-    assertPooled(pool, httpD, httpC);
-
-    // Adding httpE bumps httpC.
-    pool.recycle(httpE);
-    Thread.sleep(100); // Give the cleanup callable time to run.
-    assertPooled(pool, httpE, httpD);
-  }
-
-  @Test public void evictAllConnections() throws Exception {
-    resetWithPoolSize(10);
-    pool.recycle(httpA);
-    Util.closeQuietly(httpA.getSocket()); // Include a closed connection in the pool.
-    pool.recycle(httpB);
-    pool.share(spdyA);
-    int connectionCount = pool.getConnectionCount();
-    assertTrue(connectionCount == 2 || connectionCount == 3);
-
-    pool.evictAll();
-    assertEquals(0, pool.getConnectionCount());
-  }
-
-  @Test public void closeIfOwnedBy() throws Exception {
-    httpA.closeIfOwnedBy(owner);
-    assertFalse(httpA.isAlive());
-    assertFalse(httpA.clearOwner());
-  }
-
-  @Test public void closeIfOwnedByDoesNothingIfNotOwner() throws Exception {
-    httpA.closeIfOwnedBy(new Object());
-    assertTrue(httpA.isAlive());
-    assertTrue(httpA.clearOwner());
-  }
-
-  @Test public void closeIfOwnedByFailsForSpdyConnections() throws Exception {
-    try {
-      spdyA.closeIfOwnedBy(owner);
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void cleanupRunnableStopsEventually() throws Exception {
-    pool.recycle(httpA);
-    pool.share(spdyA);
-    assertPooled(pool, spdyA, httpA);
-
-    // The cleanup should terminate once the pool is empty again.
-    cleanupExecutor.fakeExecute();
-    assertPooled(pool);
-
-    cleanupExecutor.assertExecutionScheduled(false);
-
-    // Adding a new connection should cause the cleanup to start up again.
-    pool.recycle(httpB);
-
-    cleanupExecutor.assertExecutionScheduled(true);
-
-    // The cleanup should terminate once the pool is empty again.
-    cleanupExecutor.fakeExecute();
-    assertPooled(pool);
-  }
-
-  private void assertPooled(ConnectionPool pool, Connection... connections) throws Exception {
-    assertEquals(Arrays.asList(connections), pool.getConnections());
-  }
-
-  /**
-   * An executor that does not actually execute anything by default. See
-   * {@link #fakeExecute()}.
-   */
-  private static class FakeExecutor implements Executor {
-
-    private Runnable runnable;
-
-    @Override
-    public void execute(Runnable runnable) {
-      // This is a bonus assertion for the invariant: At no time should two runnables be scheduled.
-      assertNull(this.runnable);
-      this.runnable = runnable;
-    }
-
-    public void assertExecutionScheduled(boolean expected) {
-      assertEquals(expected, runnable != null);
-    }
-
-    /**
-     * Executes the runnable.
-     */
-    public void fakeExecute() {
-      Runnable toRun = this.runnable;
-      this.runnable = null;
-      toRun.run();
-    }
-  }
-}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/ConnectionSpecTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/ConnectionSpecTest.java
deleted file mode 100644
index 2267c2a1d6..0000000000
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/ConnectionSpecTest.java
+++ /dev/null
@@ -1,182 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp;
-
-import com.squareup.okhttp.internal.http.AuthenticatorAdapter;
-
-import org.junit.Test;
-
-import java.net.InetSocketAddress;
-import java.net.Proxy;
-import java.net.ProxySelector;
-import java.util.Arrays;
-import java.util.LinkedHashSet;
-import java.util.Set;
-import javax.net.ssl.SSLSocket;
-import javax.net.ssl.SSLSocketFactory;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
-
-public final class ConnectionSpecTest {
-
-  private static final Proxy PROXY = Proxy.NO_PROXY;
-  private static final InetSocketAddress INET_SOCKET_ADDRESS =
-      InetSocketAddress.createUnresolved("host", 443);
-  private static final Address HTTPS_ADDRESS = new Address(
-      INET_SOCKET_ADDRESS.getHostString(), INET_SOCKET_ADDRESS.getPort(), null, null, null, null,
-      AuthenticatorAdapter.INSTANCE, PROXY, Arrays.asList(Protocol.HTTP_1_1),
-      Arrays.asList(ConnectionSpec.MODERN_TLS), ProxySelector.getDefault());
-
-  @Test
-  public void cleartextBuilder() throws Exception {
-    ConnectionSpec cleartextSpec = new ConnectionSpec.Builder(false).build();
-    assertFalse(cleartextSpec.isTls());
-  }
-
-  @Test
-  public void tlsBuilder_explicitCiphers() throws Exception {
-    ConnectionSpec tlsSpec = new ConnectionSpec.Builder(true)
-        .cipherSuites(CipherSuite.TLS_RSA_WITH_RC4_128_MD5)
-        .tlsVersions(TlsVersion.TLS_1_2)
-        .supportsTlsExtensions(true)
-        .build();
-    assertEquals(Arrays.asList(CipherSuite.TLS_RSA_WITH_RC4_128_MD5), tlsSpec.cipherSuites());
-    assertEquals(Arrays.asList(TlsVersion.TLS_1_2), tlsSpec.tlsVersions());
-    assertTrue(tlsSpec.supportsTlsExtensions());
-  }
-
-  @Test
-  public void tlsBuilder_defaultCiphers() throws Exception {
-    ConnectionSpec tlsSpec = new ConnectionSpec.Builder(true)
-        .tlsVersions(TlsVersion.TLS_1_2)
-        .supportsTlsExtensions(true)
-        .build();
-    assertNull(tlsSpec.cipherSuites());
-    assertEquals(Arrays.asList(TlsVersion.TLS_1_2), tlsSpec.tlsVersions());
-    assertTrue(tlsSpec.supportsTlsExtensions());
-  }
-
-  @Test
-  public void tls_defaultCiphers_noFallbackIndicator() throws Exception {
-    ConnectionSpec tlsSpec = new ConnectionSpec.Builder(true)
-        .tlsVersions(TlsVersion.TLS_1_2)
-        .supportsTlsExtensions(false)
-        .build();
-
-    SSLSocket socket = (SSLSocket) SSLSocketFactory.getDefault().createSocket();
-    socket.setEnabledCipherSuites(new String[] {
-        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName,
-        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName,
-    });
-    socket.setEnabledProtocols(new String[] {
-        TlsVersion.TLS_1_2.javaName,
-        TlsVersion.TLS_1_1.javaName,
-    });
-
-    Route route = new Route(HTTPS_ADDRESS, PROXY, INET_SOCKET_ADDRESS, tlsSpec,
-        false /* shouldSendTlsFallbackIndicator */);
-    tlsSpec.apply(socket, route);
-
-    assertEquals(createSet(TlsVersion.TLS_1_2.javaName), createSet(socket.getEnabledProtocols()));
-
-    Set<String> expectedCipherSet =
-        createSet(
-            CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName,
-            CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName);
-    assertEquals(expectedCipherSet, expectedCipherSet);
-  }
-
-  @Test
-  public void tls_defaultCiphers_withFallbackIndicator() throws Exception {
-    ConnectionSpec tlsSpec = new ConnectionSpec.Builder(true)
-        .tlsVersions(TlsVersion.TLS_1_2)
-        .supportsTlsExtensions(false)
-        .build();
-
-    SSLSocket socket = (SSLSocket) SSLSocketFactory.getDefault().createSocket();
-    socket.setEnabledCipherSuites(new String[] {
-        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName,
-        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName,
-    });
-    socket.setEnabledProtocols(new String[] {
-        TlsVersion.TLS_1_2.javaName,
-        TlsVersion.TLS_1_1.javaName,
-    });
-
-    Route route = new Route(HTTPS_ADDRESS, PROXY, INET_SOCKET_ADDRESS, tlsSpec,
-        true /* shouldSendTlsFallbackIndicator */);
-    tlsSpec.apply(socket, route);
-
-    assertEquals(createSet(TlsVersion.TLS_1_2.javaName), createSet(socket.getEnabledProtocols()));
-
-    Set<String> expectedCipherSet =
-        createSet(
-            CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName,
-            CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName);
-    if (Arrays.asList(socket.getSupportedCipherSuites()).contains("TLS_FALLBACK_SCSV")) {
-      expectedCipherSet.add("TLS_FALLBACK_SCSV");
-    }
-    assertEquals(expectedCipherSet, expectedCipherSet);
-  }
-
-  @Test
-  public void tls_explicitCiphers() throws Exception {
-    ConnectionSpec tlsSpec = new ConnectionSpec.Builder(true)
-        .cipherSuites(CipherSuite.TLS_RSA_WITH_RC4_128_MD5)
-        .tlsVersions(TlsVersion.TLS_1_2)
-        .supportsTlsExtensions(false)
-        .build();
-
-    SSLSocket socket = (SSLSocket) SSLSocketFactory.getDefault().createSocket();
-    socket.setEnabledCipherSuites(new String[] {
-        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName,
-        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName,
-    });
-    socket.setEnabledProtocols(new String[] {
-        TlsVersion.TLS_1_2.javaName,
-        TlsVersion.TLS_1_1.javaName,
-    });
-
-    Route route = new Route(HTTPS_ADDRESS, PROXY, INET_SOCKET_ADDRESS, tlsSpec,
-        true /* shouldSendTlsFallbackIndicator */);
-    tlsSpec.apply(socket, route);
-
-    assertEquals(createSet(TlsVersion.TLS_1_2.javaName), createSet(socket.getEnabledProtocols()));
-
-    Set<String> expectedCipherSet = createSet(CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName);
-    if (Arrays.asList(socket.getSupportedCipherSuites()).contains("TLS_FALLBACK_SCSV")) {
-      expectedCipherSet.add("TLS_FALLBACK_SCSV");
-    }
-    assertEquals(expectedCipherSet, expectedCipherSet);
-  }
-
-  @Test
-  public void tls_stringCiphersAndVersions() throws Exception {
-    // Supporting arbitrary input strings allows users to enable suites and versions that are not
-    // yet known to the library, but are supported by the platform.
-    ConnectionSpec tlsSpec = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
-        .cipherSuites("MAGIC-CIPHER")
-        .tlsVersions("TLS9k")
-        .build();
-  }
-
-  private static Set<String> createSet(String... values) {
-    return new LinkedHashSet<String>(Arrays.asList(values));
-  }
-}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/FormEncodingBuilderTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/FormEncodingBuilderTest.java
deleted file mode 100644
index a9533bf783..0000000000
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/FormEncodingBuilderTest.java
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp;
-
-import okio.Buffer;
-import org.junit.Test;
-
-import static org.junit.Assert.assertEquals;
-
-public final class FormEncodingBuilderTest {
-  @Test public void urlEncoding() throws Exception {
-    RequestBody formEncoding = new FormEncodingBuilder()
-        .add("a&b", "c=d")
-        .add("space, the", "final frontier")
-        .build();
-
-    assertEquals("application/x-www-form-urlencoded", formEncoding.contentType().toString());
-
-    String expected = "a%26b=c%3Dd&space%2C+the=final+frontier";
-    assertEquals(expected.length(), formEncoding.contentLength());
-
-    Buffer out = new Buffer();
-    formEncoding.writeTo(out);
-    assertEquals(expected, out.readUtf8());
-  }
-
-  @Test public void encodedPair() throws Exception {
-    RequestBody formEncoding = new FormEncodingBuilder()
-        .add("sim", "ple")
-        .build();
-
-    String expected = "sim=ple";
-    assertEquals(expected.length(), formEncoding.contentLength());
-
-    Buffer buffer = new Buffer();
-    formEncoding.writeTo(buffer);
-    assertEquals(expected, buffer.readUtf8());
-  }
-
-  @Test public void encodeMultiplePairs() throws Exception {
-    RequestBody formEncoding = new FormEncodingBuilder()
-        .add("sim", "ple")
-        .add("hey", "there")
-        .add("help", "me")
-        .build();
-
-    String expected = "sim=ple&hey=there&help=me";
-    assertEquals(expected.length(), formEncoding.contentLength());
-
-    Buffer buffer = new Buffer();
-    formEncoding.writeTo(buffer);
-    assertEquals(expected, buffer.readUtf8());
-  }
-}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/OkHttpClientTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/OkHttpClientTest.java
deleted file mode 100644
index 1fdaf1b912..0000000000
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/OkHttpClientTest.java
+++ /dev/null
@@ -1,222 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp;
-
-import com.squareup.okhttp.internal.RecordingAuthenticator;
-import com.squareup.okhttp.internal.http.AuthenticatorAdapter;
-import com.squareup.okhttp.internal.http.RecordingProxySelector;
-import com.squareup.okhttp.internal.tls.OkHostnameVerifier;
-import java.io.IOException;
-import java.net.Authenticator;
-import java.net.CacheRequest;
-import java.net.CacheResponse;
-import java.net.CookieHandler;
-import java.net.CookieManager;
-import java.net.ProxySelector;
-import java.net.ResponseCache;
-import java.net.URI;
-import java.net.URLConnection;
-import java.util.Arrays;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.TimeUnit;
-import javax.net.SocketFactory;
-import org.junit.After;
-import org.junit.Test;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-public final class OkHttpClientTest {
-  private static final ProxySelector DEFAULT_PROXY_SELECTOR = ProxySelector.getDefault();
-  private static final CookieHandler DEFAULT_COOKIE_HANDLER = CookieManager.getDefault();
-  private static final ResponseCache DEFAULT_RESPONSE_CACHE = ResponseCache.getDefault();
-  private static final Authenticator DEFAULT_AUTHENTICATOR = null; // No Authenticator.getDefault().
-
-  @After public void tearDown() throws Exception {
-    ProxySelector.setDefault(DEFAULT_PROXY_SELECTOR);
-    CookieManager.setDefault(DEFAULT_COOKIE_HANDLER);
-    ResponseCache.setDefault(DEFAULT_RESPONSE_CACHE);
-    Authenticator.setDefault(DEFAULT_AUTHENTICATOR);
-  }
-
-  @Test public void timeoutValidRange() {
-    OkHttpClient client = new OkHttpClient();
-    try {
-      client.setConnectTimeout(1, TimeUnit.NANOSECONDS);
-    } catch (IllegalArgumentException ignored) {
-    }
-    try {
-      client.setWriteTimeout(1, TimeUnit.NANOSECONDS);
-    } catch (IllegalArgumentException ignored) {
-    }
-    try {
-      client.setReadTimeout(1, TimeUnit.NANOSECONDS);
-    } catch (IllegalArgumentException ignored) {
-    }
-    try {
-      client.setConnectTimeout(365, TimeUnit.DAYS);
-    } catch (IllegalArgumentException ignored) {
-    }
-    try {
-      client.setWriteTimeout(365, TimeUnit.DAYS);
-    } catch (IllegalArgumentException ignored) {
-    }
-    try {
-      client.setReadTimeout(365, TimeUnit.DAYS);
-    } catch (IllegalArgumentException ignored) {
-    }
-  }
-
-  /** Confirm that {@code copyWithDefaults} gets expected constant values. */
-  @Test public void copyWithDefaultsWhenDefaultIsAConstant() throws Exception {
-    OkHttpClient client = new OkHttpClient().copyWithDefaults();
-    assertNull(client.internalCache());
-    assertEquals(0, client.getConnectTimeout());
-    assertEquals(0, client.getReadTimeout());
-    assertEquals(0, client.getWriteTimeout());
-    assertTrue(client.getFollowSslRedirects());
-    assertNull(client.getProxy());
-    assertEquals(Arrays.asList(Protocol.HTTP_2, Protocol.SPDY_3, Protocol.HTTP_1_1),
-        client.getProtocols());
-  }
-
-  /**
-   * Confirm that {@code copyWithDefaults} gets some default implementations
-   * from the core library.
-   */
-  @Test public void copyWithDefaultsWhenDefaultIsGlobal() throws Exception {
-    ProxySelector proxySelector = new RecordingProxySelector();
-    CookieManager cookieManager = new CookieManager();
-    Authenticator authenticator = new RecordingAuthenticator();
-    SocketFactory socketFactory = SocketFactory.getDefault(); // Global isn't configurable.
-    OkHostnameVerifier hostnameVerifier = OkHostnameVerifier.INSTANCE; // Global isn't configurable.
-    CertificatePinner certificatePinner = CertificatePinner.DEFAULT; // Global isn't configurable.
-
-    CookieManager.setDefault(cookieManager);
-    ProxySelector.setDefault(proxySelector);
-    Authenticator.setDefault(authenticator);
-
-    OkHttpClient client = new OkHttpClient().copyWithDefaults();
-
-    assertSame(proxySelector, client.getProxySelector());
-    assertSame(cookieManager, client.getCookieHandler());
-    assertSame(AuthenticatorAdapter.INSTANCE, client.getAuthenticator());
-    assertSame(socketFactory, client.getSocketFactory());
-    assertSame(hostnameVerifier, client.getHostnameVerifier());
-    assertSame(certificatePinner, client.getCertificatePinner());
-  }
-
-  /** There is no default cache. */
-  @Test public void copyWithDefaultsCacheIsNull() throws Exception {
-    OkHttpClient client = new OkHttpClient().copyWithDefaults();
-    assertNull(client.getCache());
-  }
-
-  @Test public void copyWithDefaultsDoesNotHonorGlobalResponseCache() {
-    ResponseCache.setDefault(new ResponseCache() {
-      @Override public CacheResponse get(URI uri, String requestMethod,
-          Map<String, List<String>> requestHeaders) throws IOException {
-        throw new AssertionError();
-      }
-
-      @Override public CacheRequest put(URI uri, URLConnection connection) {
-        throw new AssertionError();
-      }
-    });
-
-    OkHttpClient client = new OkHttpClient().copyWithDefaults();
-    assertNull(client.internalCache());
-  }
-
-  /**
-   * When copying the client, stateful things like the connection pool are
-   * shared across all clients.
-   */
-  @Test public void cloneSharesStatefulInstances() throws Exception {
-    OkHttpClient client = new OkHttpClient();
-
-    // Values should be non-null.
-    OkHttpClient a = client.clone().copyWithDefaults();
-    assertNotNull(a.routeDatabase());
-    assertNotNull(a.getDispatcher());
-    assertNotNull(a.getConnectionPool());
-    assertNotNull(a.getSslSocketFactory());
-
-    // Multiple clients share the instances.
-    OkHttpClient b = client.clone().copyWithDefaults();
-    assertSame(a.routeDatabase(), b.routeDatabase());
-    assertSame(a.getDispatcher(), b.getDispatcher());
-    assertSame(a.getConnectionPool(), b.getConnectionPool());
-    assertSame(a.getSslSocketFactory(), b.getSslSocketFactory());
-  }
-
-  /** We don't want to run user code inside of HttpEngine, etc. */
-  @Test public void copyWithDefaultsDoesNotReturnSubclass() throws Exception {
-    OkHttpClient subclass = new OkHttpClient() {};
-    OkHttpClient copy = subclass.copyWithDefaults();
-    assertEquals(OkHttpClient.class, copy.getClass());
-  }
-
-  @Test public void cloneReturnsSubclass() throws Exception {
-    OkHttpClient subclass = new OkHttpClient() {};
-    OkHttpClient clone = subclass.clone();
-    assertEquals(subclass.getClass(), clone.getClass());
-  }
-
-  /** Exercise a synchronous mocking case. */
-  @Test public void mock() throws Exception {
-    final Request request = new Request.Builder()
-        .url("http://example.com/")
-        .build();
-    final Response response = new Response.Builder()
-        .protocol(Protocol.HTTP_1_1)
-        .request(request)
-        .code(200)
-        .message("Alright")
-        .build();
-
-    OkHttpClient mockClient = new OkHttpClient() {
-      @Override public Call newCall(Request request) {
-        return new Call(this, request) {
-          @Override public Response execute() throws IOException {
-            return response;
-          }
-          @Override public void enqueue(Callback responseCallback) {
-          }
-          @Override public void cancel() {
-          }
-        };
-      }
-    };
-
-    Response actualResponse = mockClient.newCall(request).execute();
-    assertSame(response, actualResponse);
-  }
-
-  @Test public void setProtocolsRejectsHttp10() throws Exception {
-    OkHttpClient client = new OkHttpClient();
-    try {
-      client.setProtocols(Arrays.asList(Protocol.HTTP_1_0, Protocol.HTTP_1_1));
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/TestUtil.java b/okhttp-tests/src/test/java/com/squareup/okhttp/TestUtil.java
deleted file mode 100644
index 10f0d4df19..0000000000
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/TestUtil.java
+++ /dev/null
@@ -1,18 +0,0 @@
-package com.squareup.okhttp;
-
-import com.squareup.okhttp.internal.spdy.Header;
-import java.util.ArrayList;
-import java.util.List;
-
-public final class TestUtil {
-  private TestUtil() {
-  }
-
-  public static List<Header> headerEntries(String... elements) {
-    List<Header> result = new ArrayList<>(elements.length / 2);
-    for (int i = 0; i < elements.length; i += 2) {
-      result.add(new Header(elements[i], elements[i + 1]));
-    }
-    return result;
-  }
-}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/CookiesTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/CookiesTest.java
deleted file mode 100644
index d0fa1b2421..0000000000
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/CookiesTest.java
+++ /dev/null
@@ -1,360 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.squareup.okhttp.internal.http;
-
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.OkUrlFactory;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-import com.squareup.okhttp.mockwebserver.RecordedRequest;
-import java.io.IOException;
-import java.net.CookieHandler;
-import java.net.CookieManager;
-import java.net.HttpCookie;
-import java.net.HttpURLConnection;
-import java.net.URI;
-import java.net.URLConnection;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-
-import static java.net.CookiePolicy.ACCEPT_ORIGINAL_SERVER;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-/** Android's CookiesTest. */
-public class CookiesTest {
-
-  private OkHttpClient client;
-
-  @Before
-  public void setUp() throws Exception {
-    client = new OkHttpClient();
-  }
-
-  @After
-  public void tearDown() throws Exception {
-    CookieHandler.setDefault(null);
-  }
-
-  @Test
-  public void testNetscapeResponse() throws Exception {
-    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
-    CookieHandler.setDefault(cookieManager);
-    MockWebServer server = new MockWebServer();
-    server.start();
-
-    server.enqueue(new MockResponse().addHeader("Set-Cookie: a=android; "
-        + "expires=Fri, 31-Dec-9999 23:59:59 GMT; "
-        + "path=/path; "
-        + "domain=" + server.getCookieDomain() + "; "
-        + "secure"));
-    get(server, "/path/foo");
-
-    List<HttpCookie> cookies = cookieManager.getCookieStore().getCookies();
-    assertEquals(1, cookies.size());
-    HttpCookie cookie = cookies.get(0);
-    assertEquals("a", cookie.getName());
-    assertEquals("android", cookie.getValue());
-    assertEquals(null, cookie.getComment());
-    assertEquals(null, cookie.getCommentURL());
-    assertEquals(false, cookie.getDiscard());
-    assertTrue(server.getCookieDomain().equalsIgnoreCase(cookie.getDomain()));
-    assertTrue(cookie.getMaxAge() > 100000000000L);
-    assertEquals("/path", cookie.getPath());
-    assertEquals(true, cookie.getSecure());
-    assertEquals(0, cookie.getVersion());
-  }
-
-  @Test public void testRfc2109Response() throws Exception {
-    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
-    CookieHandler.setDefault(cookieManager);
-    MockWebServer server = new MockWebServer();
-    server.start();
-
-    server.enqueue(new MockResponse().addHeader("Set-Cookie: a=android; "
-        + "Comment=this cookie is delicious; "
-        + "Domain=" + server.getCookieDomain() + "; "
-        + "Max-Age=60; "
-        + "Path=/path; "
-        + "Secure; "
-        + "Version=1"));
-    get(server, "/path/foo");
-
-    List<HttpCookie> cookies = cookieManager.getCookieStore().getCookies();
-    assertEquals(1, cookies.size());
-    HttpCookie cookie = cookies.get(0);
-    assertEquals("a", cookie.getName());
-    assertEquals("android", cookie.getValue());
-    assertEquals("this cookie is delicious", cookie.getComment());
-    assertEquals(null, cookie.getCommentURL());
-    assertEquals(false, cookie.getDiscard());
-    assertTrue(server.getCookieDomain().equalsIgnoreCase(cookie.getDomain()));
-    assertEquals(60, cookie.getMaxAge());
-    assertEquals("/path", cookie.getPath());
-    assertEquals(true, cookie.getSecure());
-    assertEquals(1, cookie.getVersion());
-  }
-
-  @Test public void testRfc2965Response() throws Exception {
-    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
-    CookieHandler.setDefault(cookieManager);
-    MockWebServer server = new MockWebServer();
-    server.start();
-
-    server.enqueue(new MockResponse().addHeader("Set-Cookie2: a=android; "
-        + "Comment=this cookie is delicious; "
-        + "CommentURL=http://google.com/; "
-        + "Discard; "
-        + "Domain=" + server.getCookieDomain() + "; "
-        + "Max-Age=60; "
-        + "Path=/path; "
-        + "Port=\"80,443," + server.getPort() + "\"; "
-        + "Secure; "
-        + "Version=1"));
-    get(server, "/path/foo");
-
-    List<HttpCookie> cookies = cookieManager.getCookieStore().getCookies();
-    assertEquals(1, cookies.size());
-    HttpCookie cookie = cookies.get(0);
-    assertEquals("a", cookie.getName());
-    assertEquals("android", cookie.getValue());
-    assertEquals("this cookie is delicious", cookie.getComment());
-    assertEquals("http://google.com/", cookie.getCommentURL());
-    assertEquals(true, cookie.getDiscard());
-    assertTrue(server.getCookieDomain().equalsIgnoreCase(cookie.getDomain()));
-    assertEquals(60, cookie.getMaxAge());
-    assertEquals("/path", cookie.getPath());
-    assertEquals("80,443," + server.getPort(), cookie.getPortlist());
-    assertEquals(true, cookie.getSecure());
-    assertEquals(1, cookie.getVersion());
-  }
-
-  @Test public void testQuotedAttributeValues() throws Exception {
-    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
-    CookieHandler.setDefault(cookieManager);
-    MockWebServer server = new MockWebServer();
-    server.start();
-
-    server.enqueue(new MockResponse().addHeader("Set-Cookie2: a=\"android\"; "
-        + "Comment=\"this cookie is delicious\"; "
-        + "CommentURL=\"http://google.com/\"; "
-        + "Discard; "
-        + "Domain=\"" + server.getCookieDomain() + "\"; "
-        + "Max-Age=\"60\"; "
-        + "Path=\"/path\"; "
-        + "Port=\"80,443," + server.getPort() + "\"; "
-        + "Secure; "
-        + "Version=\"1\""));
-    get(server, "/path/foo");
-
-    List<HttpCookie> cookies = cookieManager.getCookieStore().getCookies();
-    assertEquals(1, cookies.size());
-    HttpCookie cookie = cookies.get(0);
-    assertEquals("a", cookie.getName());
-    assertEquals("android", cookie.getValue());
-    assertEquals("this cookie is delicious", cookie.getComment());
-    assertEquals("http://google.com/", cookie.getCommentURL());
-    assertEquals(true, cookie.getDiscard());
-    assertTrue(server.getCookieDomain().equalsIgnoreCase(cookie.getDomain()));
-    assertEquals(60, cookie.getMaxAge());
-    assertEquals("/path", cookie.getPath());
-    assertEquals("80,443," + server.getPort(), cookie.getPortlist());
-    assertEquals(true, cookie.getSecure());
-    assertEquals(1, cookie.getVersion());
-  }
-
-  @Test public void testSendingCookiesFromStore() throws Exception {
-    MockWebServer server = new MockWebServer();
-    server.enqueue(new MockResponse());
-    server.start();
-
-    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
-    HttpCookie cookieA = new HttpCookie("a", "android");
-    cookieA.setDomain(server.getCookieDomain());
-    cookieA.setPath("/");
-    cookieManager.getCookieStore().add(server.getUrl("/").toURI(), cookieA);
-    HttpCookie cookieB = new HttpCookie("b", "banana");
-    cookieB.setDomain(server.getCookieDomain());
-    cookieB.setPath("/");
-    cookieManager.getCookieStore().add(server.getUrl("/").toURI(), cookieB);
-    CookieHandler.setDefault(cookieManager);
-
-    get(server, "/");
-    RecordedRequest request = server.takeRequest();
-
-    assertEquals("$Version=\"1\"; "
-            + "a=\"android\";$Path=\"/\";$Domain=\""
-            + server.getCookieDomain()
-            + "\"; "
-            + "b=\"banana\";$Path=\"/\";$Domain=\""
-            + server.getCookieDomain()
-            + "\"", request.getHeader("Cookie"));
-  }
-
-  @Test public void testRedirectsDoNotIncludeTooManyCookies() throws Exception {
-    MockWebServer redirectTarget = new MockWebServer();
-    redirectTarget.enqueue(new MockResponse().setBody("A"));
-    redirectTarget.start();
-
-    MockWebServer redirectSource = new MockWebServer();
-    redirectSource.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: " + redirectTarget.getUrl("/")));
-    redirectSource.start();
-
-    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
-    HttpCookie cookie = new HttpCookie("c", "cookie");
-    cookie.setDomain(redirectSource.getCookieDomain());
-    cookie.setPath("/");
-    String portList = Integer.toString(redirectSource.getPort());
-    cookie.setPortlist(portList);
-    cookieManager.getCookieStore().add(redirectSource.getUrl("/").toURI(), cookie);
-    CookieHandler.setDefault(cookieManager);
-
-    get(redirectSource, "/");
-    RecordedRequest request = redirectSource.takeRequest();
-
-    assertEquals("$Version=\"1\"; "
-            + "c=\"cookie\";$Path=\"/\";$Domain=\""
-            + redirectSource.getCookieDomain()
-            + "\";$Port=\""
-            + portList
-            + "\"", request.getHeader("Cookie"));
-
-    for (String header : redirectTarget.takeRequest().getHeaders().names()) {
-      if (header.startsWith("Cookie")) {
-        fail(header);
-      }
-    }
-  }
-
-  /**
-   * Test which headers show up where. The cookie manager should be notified
-   * of both user-specified and derived headers like {@code Host}. Headers
-   * named {@code Cookie} or {@code Cookie2} that are returned by the cookie
-   * manager should show up in the request and in {@code
-   * getRequestProperties}.
-   */
-  @Test public void testHeadersSentToCookieHandler() throws IOException, InterruptedException {
-    final Map<String, List<String>> cookieHandlerHeaders = new HashMap<>();
-    CookieHandler.setDefault(new CookieManager() {
-      @Override
-      public Map<String, List<String>> get(URI uri,
-          Map<String, List<String>> requestHeaders) throws IOException {
-        cookieHandlerHeaders.putAll(requestHeaders);
-        Map<String, List<String>> result = new HashMap<>();
-        result.put("Cookie", Collections.singletonList("Bar=bar"));
-        result.put("Cookie2", Collections.singletonList("Baz=baz"));
-        result.put("Quux", Collections.singletonList("quux"));
-        return result;
-      }
-    });
-    MockWebServer server = new MockWebServer();
-    server.enqueue(new MockResponse());
-    server.start();
-
-    HttpURLConnection connection = new OkUrlFactory(client).open(server.getUrl("/"));
-    assertEquals(Collections.<String, List<String>>emptyMap(),
-        connection.getRequestProperties());
-
-    connection.setRequestProperty("Foo", "foo");
-    connection.setDoOutput(true);
-    connection.getOutputStream().write(5);
-    connection.getOutputStream().close();
-    connection.getInputStream().close();
-
-    RecordedRequest request = server.takeRequest();
-
-    assertContainsAll(cookieHandlerHeaders.keySet(), "Foo");
-    assertContainsAll(cookieHandlerHeaders.keySet(),
-        "Content-type", "User-Agent", "Connection", "Host");
-    assertFalse(cookieHandlerHeaders.containsKey("Cookie"));
-
-    /*
-     * The API specifies that calling getRequestProperties() on a connected instance should fail
-     * with an IllegalStateException, but the RI violates the spec and returns a valid map.
-     * http://www.mail-archive.com/net-dev@openjdk.java.net/msg01768.html
-     */
-    try {
-      assertContainsAll(connection.getRequestProperties().keySet(), "Foo");
-      assertContainsAll(connection.getRequestProperties().keySet(),
-          "Content-type", "Content-Length", "User-Agent", "Connection", "Host");
-      assertContainsAll(connection.getRequestProperties().keySet(), "Cookie", "Cookie2");
-      assertFalse(connection.getRequestProperties().containsKey("Quux"));
-    } catch (IllegalStateException expected) {
-    }
-
-    assertEquals("foo", request.getHeader("Foo"));
-    assertEquals("Bar=bar", request.getHeader("Cookie"));
-    assertEquals("Baz=baz", request.getHeader("Cookie2"));
-    assertNull(request.getHeader("Quux"));
-  }
-
-  @Test public void testCookiesSentIgnoresCase() throws Exception {
-    CookieHandler.setDefault(new CookieManager() {
-      @Override public Map<String, List<String>> get(URI uri,
-          Map<String, List<String>> requestHeaders) throws IOException {
-        Map<String, List<String>> result = new HashMap<>();
-        result.put("COOKIE", Collections.singletonList("Bar=bar"));
-        result.put("cooKIE2", Collections.singletonList("Baz=baz"));
-        return result;
-      }
-    });
-    MockWebServer server = new MockWebServer();
-    server. enqueue(new MockResponse());
-    server.start();
-
-    get(server, "/");
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("Bar=bar", request.getHeader("Cookie"));
-    assertEquals("Baz=baz", request.getHeader("Cookie2"));
-    assertNull(request.getHeader("Quux"));
-  }
-
-  private void assertContains(Collection<String> collection, String element) {
-    for (String c : collection) {
-      if (c != null && c.equalsIgnoreCase(element)) {
-        return;
-      }
-    }
-    fail("No " + element + " in " + collection);
-  }
-
-  private void assertContainsAll(Collection<String> collection, String... toFind) {
-    for (String s : toFind) {
-      assertContains(collection, s);
-    }
-  }
-
-  private Map<String,List<String>> get(MockWebServer server, String path) throws Exception {
-    URLConnection connection = new OkUrlFactory(client).open(server.getUrl(path));
-    Map<String, List<String>> headers = connection.getHeaderFields();
-    connection.getInputStream().close();
-    return headers;
-  }
-
-}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ExternalHttp2Example.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ExternalHttp2Example.java
deleted file mode 100644
index 020c7f0e36..0000000000
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ExternalHttp2Example.java
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
- * Copyright (C) 2009 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.squareup.okhttp.internal.http;
-
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.OkUrlFactory;
-import com.squareup.okhttp.Protocol;
-import com.squareup.okhttp.internal.Util;
-import java.io.BufferedReader;
-import java.io.InputStreamReader;
-import java.net.URL;
-import java.util.List;
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.HttpsURLConnection;
-import javax.net.ssl.SSLSession;
-
-import static com.squareup.okhttp.internal.http.OkHeaders.SELECTED_PROTOCOL;
-
-public final class ExternalHttp2Example {
-  public static void main(String[] args) throws Exception {
-    URL url = new URL("https://twitter.com");
-    OkHttpClient client = new OkHttpClient()
-        .setProtocols(Util.immutableList(Protocol.HTTP_2, Protocol.HTTP_1_1));
-    HttpsURLConnection connection = (HttpsURLConnection) new OkUrlFactory(client)
-        .open(url);
-
-    connection.setHostnameVerifier(new HostnameVerifier() {
-      @Override public boolean verify(String s, SSLSession sslSession) {
-        System.out.println("VERIFYING " + s);
-        return true;
-      }
-    });
-
-    int responseCode = connection.getResponseCode();
-    System.out.println(responseCode);
-    List<String> protocolValues = connection.getHeaderFields().get(SELECTED_PROTOCOL);
-    // If null, probably you didn't add jetty's alpn jar to your boot classpath!
-    if (protocolValues != null && !protocolValues.isEmpty()) {
-      System.out.println("PROTOCOL " + protocolValues.get(0));
-    }
-
-    BufferedReader reader =
-        new BufferedReader(new InputStreamReader(connection.getInputStream(), "UTF-8"));
-    String line;
-    while ((line = reader.readLine()) != null) {
-      System.out.println(line);
-    }
-  }
-}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ExternalSpdyExample.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ExternalSpdyExample.java
deleted file mode 100644
index a8009626c0..0000000000
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ExternalSpdyExample.java
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
- * Copyright (C) 2009 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.squareup.okhttp.internal.http;
-
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.OkUrlFactory;
-import com.squareup.okhttp.Protocol;
-import com.squareup.okhttp.internal.Util;
-import java.io.BufferedReader;
-import java.io.InputStreamReader;
-import java.net.URL;
-import java.util.List;
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.HttpsURLConnection;
-import javax.net.ssl.SSLSession;
-
-import static com.squareup.okhttp.internal.http.OkHeaders.SELECTED_PROTOCOL;
-
-public final class ExternalSpdyExample {
-  public static void main(String[] args) throws Exception {
-    URL url = new URL("https://www.google.ca/");
-    OkHttpClient client = new OkHttpClient()
-        .setProtocols(Util.immutableList(Protocol.SPDY_3, Protocol.HTTP_1_1));
-    HttpsURLConnection connection = (HttpsURLConnection) new OkUrlFactory(client)
-        .open(url);
-
-    connection.setHostnameVerifier(new HostnameVerifier() {
-      @Override public boolean verify(String s, SSLSession sslSession) {
-        System.out.println("VERIFYING " + s);
-        return true;
-      }
-    });
-
-    int responseCode = connection.getResponseCode();
-    System.out.println(responseCode);
-    List<String> protocolValues = connection.getHeaderFields().get(SELECTED_PROTOCOL);
-    // If null, probably you didn't add jetty's alpn jar to your boot classpath!
-    if (protocolValues != null && !protocolValues.isEmpty()) {
-      System.out.println("PROTOCOL " + protocolValues.get(0));
-    }
-
-    BufferedReader reader =
-        new BufferedReader(new InputStreamReader(connection.getInputStream(), "UTF-8"));
-    String line;
-    while ((line = reader.readLine()) != null) {
-      System.out.println(line);
-    }
-  }
-}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp2Test.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp2Test.java
deleted file mode 100644
index 91ba56cef3..0000000000
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp2Test.java
+++ /dev/null
@@ -1,81 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal.http;
-
-import com.squareup.okhttp.Headers;
-import com.squareup.okhttp.Protocol;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.PushPromise;
-import com.squareup.okhttp.mockwebserver.RecordedRequest;
-import org.junit.Test;
-
-import static org.junit.Assert.assertEquals;
-
-public class HttpOverHttp2Test extends HttpOverSpdyTest {
-
-  public HttpOverHttp2Test() {
-    super(Protocol.HTTP_2);
-    this.hostHeader = ":authority";
-  }
-
-  @Test public void serverSendsPushPromise_GET() throws Exception {
-    PushPromise pushPromise = new PushPromise("GET", "/foo/bar", Headers.of("foo", "bar"),
-        new MockResponse().setBody("bar").setStatus("HTTP/1.1 200 Sweet"));
-    MockResponse response = new MockResponse()
-        .setBody("ABCDE")
-        .setStatus("HTTP/1.1 200 Sweet")
-        .withPush(pushPromise);
-    server.enqueue(response);
-
-    connection = client.open(server.getUrl("/foo"));
-    assertContent("ABCDE", connection, Integer.MAX_VALUE);
-    assertEquals(200, connection.getResponseCode());
-    assertEquals("Sweet", connection.getResponseMessage());
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
-    assertEquals("https", request.getHeader(":scheme"));
-    assertEquals(server.getHostName() + ":" + server.getPort(), request.getHeader(hostHeader));
-
-    RecordedRequest pushedRequest = server.takeRequest();
-    assertEquals("GET /foo/bar HTTP/1.1", pushedRequest.getRequestLine());
-    assertEquals("bar", pushedRequest.getHeader("foo"));
-  }
-
-  @Test public void serverSendsPushPromise_HEAD() throws Exception {
-    PushPromise pushPromise = new PushPromise("HEAD", "/foo/bar", Headers.of("foo", "bar"),
-        new MockResponse().setStatus("HTTP/1.1 204 Sweet"));
-    MockResponse response = new MockResponse()
-        .setBody("ABCDE")
-        .setStatus("HTTP/1.1 200 Sweet")
-        .withPush(pushPromise);
-    server.enqueue(response);
-
-    connection = client.open(server.getUrl("/foo"));
-    assertContent("ABCDE", connection, Integer.MAX_VALUE);
-    assertEquals(200, connection.getResponseCode());
-    assertEquals("Sweet", connection.getResponseMessage());
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
-    assertEquals("https", request.getHeader(":scheme"));
-    assertEquals(server.getHostName() + ":" + server.getPort(), request.getHeader(hostHeader));
-
-    RecordedRequest pushedRequest = server.takeRequest();
-    assertEquals("HEAD /foo/bar HTTP/1.1", pushedRequest.getRequestLine());
-    assertEquals("bar", pushedRequest.getHeader("foo"));
-  }
-}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
deleted file mode 100644
index ab8f3c97cc..0000000000
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
+++ /dev/null
@@ -1,465 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal.http;
-
-import com.squareup.okhttp.Cache;
-import com.squareup.okhttp.ConnectionPool;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.OkUrlFactory;
-import com.squareup.okhttp.Protocol;
-import com.squareup.okhttp.internal.RecordingAuthenticator;
-import com.squareup.okhttp.internal.SslContextBuilder;
-import com.squareup.okhttp.internal.Util;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.RecordedRequest;
-import com.squareup.okhttp.mockwebserver.SocketPolicy;
-import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.Authenticator;
-import java.net.CookieManager;
-import java.net.HttpURLConnection;
-import java.net.URL;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.TimeUnit;
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLSession;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.GzipSink;
-import okio.Okio;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Ignore;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.TemporaryFolder;
-
-import static java.util.concurrent.TimeUnit.SECONDS;
-import static org.junit.Assert.assertArrayEquals;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.fail;
-
-/** Test how SPDY interacts with HTTP features. */
-public abstract class HttpOverSpdyTest {
-  private static final SSLContext sslContext = SslContextBuilder.localhost();
-
-  private static final HostnameVerifier NULL_HOSTNAME_VERIFIER = new HostnameVerifier() {
-    public boolean verify(String hostname, SSLSession session) {
-      return true;
-    }
-  };
-
-  @Rule public final TemporaryFolder tempDir = new TemporaryFolder();
-  @Rule public final MockWebServerRule server = new MockWebServerRule();
-
-  /** Protocol to test, for example {@link com.squareup.okhttp.Protocol#SPDY_3} */
-  private final Protocol protocol;
-  protected String hostHeader = ":host";
-
-  protected final OkUrlFactory client = new OkUrlFactory(new OkHttpClient());
-  protected HttpURLConnection connection;
-  protected Cache cache;
-
-  protected HttpOverSpdyTest(Protocol protocol){
-    this.protocol = protocol;
-  }
-
-  @Before public void setUp() throws Exception {
-    server.get().useHttps(sslContext.getSocketFactory(), false);
-    client.client().setProtocols(Arrays.asList(protocol, Protocol.HTTP_1_1));
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
-    cache = new Cache(tempDir.getRoot(), Integer.MAX_VALUE);
-  }
-
-  @After public void tearDown() throws Exception {
-    Authenticator.setDefault(null);
-  }
-
-  @Test public void get() throws Exception {
-    MockResponse response = new MockResponse().setBody("ABCDE").setStatus("HTTP/1.1 200 Sweet");
-    server.enqueue(response);
-
-    connection = client.open(server.getUrl("/foo"));
-    assertContent("ABCDE", connection, Integer.MAX_VALUE);
-    assertEquals(200, connection.getResponseCode());
-    assertEquals("Sweet", connection.getResponseMessage());
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
-    assertEquals("https", request.getHeader(":scheme"));
-    assertEquals(server.getHostName() + ":" + server.getPort(), request.getHeader(hostHeader));
-  }
-
-  @Test public void emptyResponse() throws IOException {
-    server.enqueue(new MockResponse());
-
-    connection = client.open(server.getUrl("/foo"));
-    assertEquals(-1, connection.getInputStream().read());
-  }
-
-  byte[] postBytes = "FGHIJ".getBytes(Util.UTF_8);
-
-  @Test public void noDefaultContentLengthOnStreamingPost() throws Exception {
-    server.enqueue(new MockResponse().setBody("ABCDE"));
-
-    connection = client.open(server.getUrl("/foo"));
-    connection.setDoOutput(true);
-    connection.setChunkedStreamingMode(0);
-    connection.getOutputStream().write(postBytes);
-    assertContent("ABCDE", connection, Integer.MAX_VALUE);
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("POST /foo HTTP/1.1", request.getRequestLine());
-    assertArrayEquals(postBytes, request.getBody().readByteArray());
-    assertNull(request.getHeader("Content-Length"));
-  }
-
-  @Test public void userSuppliedContentLengthHeader() throws Exception {
-    server.enqueue(new MockResponse().setBody("ABCDE"));
-
-    connection = client.open(server.getUrl("/foo"));
-    connection.setRequestProperty("Content-Length", String.valueOf(postBytes.length));
-    connection.setDoOutput(true);
-    connection.getOutputStream().write(postBytes);
-    assertContent("ABCDE", connection, Integer.MAX_VALUE);
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("POST /foo HTTP/1.1", request.getRequestLine());
-    assertArrayEquals(postBytes, request.getBody().readByteArray());
-    assertEquals(postBytes.length, Integer.parseInt(request.getHeader("Content-Length")));
-  }
-
-  @Test public void closeAfterFlush() throws Exception {
-    server.enqueue(new MockResponse().setBody("ABCDE"));
-
-    connection = client.open(server.getUrl("/foo"));
-    connection.setRequestProperty("Content-Length", String.valueOf(postBytes.length));
-    connection.setDoOutput(true);
-    connection.getOutputStream().write(postBytes); // push bytes into SpdyDataOutputStream.buffer
-    connection.getOutputStream().flush(); // SpdyConnection.writeData subject to write window
-    connection.getOutputStream().close(); // SpdyConnection.writeData empty frame
-    assertContent("ABCDE", connection, Integer.MAX_VALUE);
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("POST /foo HTTP/1.1", request.getRequestLine());
-    assertArrayEquals(postBytes, request.getBody().readByteArray());
-    assertEquals(postBytes.length, Integer.parseInt(request.getHeader("Content-Length")));
-  }
-
-  @Test public void setFixedLengthStreamingModeSetsContentLength() throws Exception {
-    server.enqueue(new MockResponse().setBody("ABCDE"));
-
-    connection = client.open(server.getUrl("/foo"));
-    connection.setFixedLengthStreamingMode(postBytes.length);
-    connection.setDoOutput(true);
-    connection.getOutputStream().write(postBytes);
-    assertContent("ABCDE", connection, Integer.MAX_VALUE);
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("POST /foo HTTP/1.1", request.getRequestLine());
-    assertArrayEquals(postBytes, request.getBody().readByteArray());
-    assertEquals(postBytes.length, Integer.parseInt(request.getHeader("Content-Length")));
-  }
-
-  @Test public void spdyConnectionReuse() throws Exception {
-    server.enqueue(new MockResponse().setBody("ABCDEF"));
-    server.enqueue(new MockResponse().setBody("GHIJKL"));
-
-    HttpURLConnection connection1 = client.open(server.getUrl("/r1"));
-    HttpURLConnection connection2 = client.open(server.getUrl("/r2"));
-    assertEquals("ABC", readAscii(connection1.getInputStream(), 3));
-    assertEquals("GHI", readAscii(connection2.getInputStream(), 3));
-    assertEquals("DEF", readAscii(connection1.getInputStream(), 3));
-    assertEquals("JKL", readAscii(connection2.getInputStream(), 3));
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(1, server.takeRequest().getSequenceNumber());
-  }
-
-  @Test @Ignore public void synchronousSpdyRequest() throws Exception {
-    server.enqueue(new MockResponse().setBody("A"));
-    server.enqueue(new MockResponse().setBody("A"));
-
-    ExecutorService executor = Executors.newCachedThreadPool();
-    CountDownLatch countDownLatch = new CountDownLatch(2);
-    executor.execute(new SpdyRequest("/r1", countDownLatch));
-    executor.execute(new SpdyRequest("/r2", countDownLatch));
-    countDownLatch.await();
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(1, server.takeRequest().getSequenceNumber());
-  }
-
-  @Test public void gzippedResponseBody() throws Exception {
-    server.enqueue(
-        new MockResponse().addHeader("Content-Encoding: gzip").setBody(gzip("ABCABCABC")));
-    assertContent("ABCABCABC", client.open(server.getUrl("/r1")), Integer.MAX_VALUE);
-  }
-
-  @Test public void authenticate() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_UNAUTHORIZED)
-        .addHeader("www-authenticate: Basic realm=\"protected area\"")
-        .setBody("Please authenticate."));
-    server.enqueue(new MockResponse().setBody("Successful auth!"));
-
-    Authenticator.setDefault(new RecordingAuthenticator());
-    connection = client.open(server.getUrl("/"));
-    assertEquals("Successful auth!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-
-    RecordedRequest denied = server.takeRequest();
-    assertNull(denied.getHeader("Authorization"));
-    RecordedRequest accepted = server.takeRequest();
-    assertEquals("GET / HTTP/1.1", accepted.getRequestLine());
-    assertEquals("Basic " + RecordingAuthenticator.BASE_64_CREDENTIALS,
-        accepted.getHeader("Authorization"));
-  }
-
-  @Test public void redirect() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: /foo")
-        .setBody("This page has moved!"));
-    server.enqueue(new MockResponse().setBody("This is the new location!"));
-
-    connection = client.open(server.getUrl("/"));
-    assertContent("This is the new location!", connection, Integer.MAX_VALUE);
-
-    RecordedRequest request1 = server.takeRequest();
-    assertEquals("/", request1.getPath());
-    RecordedRequest request2 = server.takeRequest();
-    assertEquals("/foo", request2.getPath());
-  }
-
-  @Test public void readAfterLastByte() throws Exception {
-    server.enqueue(new MockResponse().setBody("ABC"));
-
-    connection = client.open(server.getUrl("/"));
-    InputStream in = connection.getInputStream();
-    assertEquals("ABC", readAscii(in, 3));
-    assertEquals(-1, in.read());
-    assertEquals(-1, in.read());
-  }
-
-  @Ignore // See https://github.com/square/okhttp/issues/578
-  @Test(timeout = 3000) public void readResponseHeaderTimeout() throws Exception {
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.NO_RESPONSE));
-    server.enqueue(new MockResponse().setBody("A"));
-
-    connection = client.open(server.getUrl("/"));
-    connection.setReadTimeout(1000);
-    assertContent("A", connection, Integer.MAX_VALUE);
-  }
-
-  /**
-   * Test to ensure we don't  throw a read timeout on responses that are
-   * progressing.  For this case, we take a 4KiB body and throttle it to
-   * 1KiB/second.  We set the read timeout to two seconds.  If our
-   * implementation is acting correctly, it will not throw, as it is
-   * progressing.
-   */
-  @Test public void readTimeoutMoreGranularThanBodySize() throws Exception {
-    char[] body = new char[4096]; // 4KiB to read
-    Arrays.fill(body, 'y');
-    server.enqueue(new MockResponse().setBody(new String(body)).throttleBody(1024, 1, SECONDS)); // slow connection 1KiB/second
-
-    connection = client.open(server.getUrl("/"));
-    connection.setReadTimeout(2000); // 2 seconds to read something.
-    assertContent(new String(body), connection, Integer.MAX_VALUE);
-  }
-
-  /**
-   * Test to ensure we throw a read timeout on responses that are progressing
-   * too slowly.  For this case, we take a 2KiB body and throttle it to
-   * 1KiB/second.  We set the read timeout to half a second.  If our
-   * implementation is acting correctly, it will throw, as a byte doesn't
-   * arrive in time.
-   */
-  @Test public void readTimeoutOnSlowConnection() throws Exception {
-    char[] body = new char[2048]; // 2KiB to read
-    Arrays.fill(body, 'y');
-    server.enqueue(new MockResponse()
-        .setBody(new String(body))
-        .throttleBody(1024, 1, SECONDS)); // slow connection 1KiB/second
-
-    connection = client.open(server.getUrl("/"));
-    connection.setReadTimeout(500); // half a second to read something
-    connection.connect();
-    try {
-      readAscii(connection.getInputStream(), Integer.MAX_VALUE);
-      fail("Should have timed out!");
-    } catch (IOException e){
-      assertEquals("timeout", e.getMessage());
-    }
-  }
-
-  @Test public void spdyConnectionTimeout() throws Exception {
-    MockResponse response = new MockResponse().setBody("A");
-    response.setBodyDelay(1, TimeUnit.SECONDS);
-    server.enqueue(response);
-
-    HttpURLConnection connection1 = client.open(server.getUrl("/"));
-    connection1.setReadTimeout(2000);
-    HttpURLConnection connection2 = client.open(server.getUrl("/"));
-    connection2.setReadTimeout(200);
-    connection1.connect();
-    connection2.connect();
-    assertContent("A", connection1, Integer.MAX_VALUE);
-  }
-
-  @Test public void responsesAreCached() throws IOException {
-    client.client().setCache(cache);
-
-    server.enqueue(new MockResponse().addHeader("cache-control: max-age=60").setBody("A"));
-
-    assertContent("A", client.open(server.getUrl("/")), Integer.MAX_VALUE);
-    assertEquals(1, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(0, cache.getHitCount());
-    assertContent("A", client.open(server.getUrl("/")), Integer.MAX_VALUE);
-    assertContent("A", client.open(server.getUrl("/")), Integer.MAX_VALUE);
-    assertEquals(3, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(2, cache.getHitCount());
-  }
-
-  @Test public void conditionalCache() throws IOException {
-    client.client().setCache(cache);
-
-    server.enqueue(new MockResponse().addHeader("ETag: v1").setBody("A"));
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    assertContent("A", client.open(server.getUrl("/")), Integer.MAX_VALUE);
-    assertEquals(1, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(0, cache.getHitCount());
-    assertContent("A", client.open(server.getUrl("/")), Integer.MAX_VALUE);
-    assertEquals(2, cache.getRequestCount());
-    assertEquals(2, cache.getNetworkCount());
-    assertEquals(1, cache.getHitCount());
-  }
-
-  @Test public void responseCachedWithoutConsumingFullBody() throws IOException {
-    client.client().setCache(cache);
-
-    server.enqueue(new MockResponse().addHeader("cache-control: max-age=60").setBody("ABCD"));
-    server.enqueue(new MockResponse().addHeader("cache-control: max-age=60").setBody("EFGH"));
-
-    HttpURLConnection connection1 = client.open(server.getUrl("/"));
-    InputStream in1 = connection1.getInputStream();
-    assertEquals("AB", readAscii(in1, 2));
-    in1.close();
-
-    HttpURLConnection connection2 = client.open(server.getUrl("/"));
-    InputStream in2 = connection2.getInputStream();
-    assertEquals("ABCD", readAscii(in2, Integer.MAX_VALUE));
-    in2.close();
-  }
-
-  @Test public void acceptAndTransmitCookies() throws Exception {
-    CookieManager cookieManager = new CookieManager();
-    client.client().setCookieHandler(cookieManager);
-
-    server.enqueue(new MockResponse()
-        .addHeader("set-cookie: c=oreo; domain=" + server.get().getCookieDomain())
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    URL url = server.getUrl("/");
-    assertContent("A", client.open(url), Integer.MAX_VALUE);
-    Map<String, List<String>> requestHeaders = Collections.emptyMap();
-    assertEquals(Collections.singletonMap("Cookie", Arrays.asList("c=oreo")),
-        cookieManager.get(url.toURI(), requestHeaders));
-
-    assertContent("B", client.open(url), Integer.MAX_VALUE);
-    RecordedRequest requestA = server.takeRequest();
-    assertNull(requestA.getHeader("Cookie"));
-    RecordedRequest requestB = server.takeRequest();
-    assertEquals("c=oreo", requestB.getHeader("Cookie"));
-  }
-
-  /** https://github.com/square/okhttp/issues/1191 */
-  @Test public void disconnectWithStreamNotEstablished() throws Exception {
-    ConnectionPool connectionPool = new ConnectionPool(5, 5000);
-    client.client().setConnectionPool(connectionPool);
-
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    // Disconnect before the stream is created. A connection is still established!
-    HttpURLConnection connection1 = client.open(server.getUrl("/"));
-    connection1.connect();
-    connection1.disconnect();
-
-    // That connection is pooled, and it works.
-    assertEquals(1, connectionPool.getSpdyConnectionCount());
-    HttpURLConnection connection2 = client.open(server.getUrl("/"));
-    assertContent("abc", connection2, 3);
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-  }
-
-  void assertContent(String expected, HttpURLConnection connection, int limit)
-      throws IOException {
-    connection.connect();
-    assertEquals(expected, readAscii(connection.getInputStream(), limit));
-  }
-
-  private String readAscii(InputStream in, int count) throws IOException {
-    StringBuilder result = new StringBuilder();
-    for (int i = 0; i < count; i++) {
-      int value = in.read();
-      if (value == -1) {
-        in.close();
-        break;
-      }
-      result.append((char) value);
-    }
-    return result.toString();
-  }
-
-  public Buffer gzip(String bytes) throws IOException {
-    Buffer bytesOut = new Buffer();
-    BufferedSink sink = Okio.buffer(new GzipSink(bytesOut));
-    sink.writeUtf8(bytes);
-    sink.close();
-    return bytesOut;
-  }
-
-  class SpdyRequest implements Runnable {
-    String path;
-    CountDownLatch countDownLatch;
-    public SpdyRequest(String path, CountDownLatch countDownLatch) {
-      this.path = path;
-      this.countDownLatch = countDownLatch;
-    }
-
-    @Override public void run() {
-      try {
-        HttpURLConnection conn = client.open(server.getUrl(path));
-        assertEquals("A", readAscii(conn.getInputStream(), 1));
-        countDownLatch.countDown();
-      } catch (Exception e) {
-        throw new RuntimeException(e);
-      }
-    }
-  }
-}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/RouteSelectorTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/RouteSelectorTest.java
deleted file mode 100644
index 8efd308f76..0000000000
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/RouteSelectorTest.java
+++ /dev/null
@@ -1,473 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal.http;
-
-import com.squareup.okhttp.Address;
-import com.squareup.okhttp.Authenticator;
-import com.squareup.okhttp.ConnectionPool;
-import com.squareup.okhttp.ConnectionSpec;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Protocol;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Route;
-import com.squareup.okhttp.internal.Internal;
-import com.squareup.okhttp.internal.Network;
-import com.squareup.okhttp.internal.RouteDatabase;
-import com.squareup.okhttp.internal.SslContextBuilder;
-import com.squareup.okhttp.internal.Util;
-import java.io.IOException;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.Proxy;
-import java.net.UnknownHostException;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import java.util.NoSuchElementException;
-import javax.net.SocketFactory;
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.HttpsURLConnection;
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLHandshakeException;
-import javax.net.ssl.SSLSocketFactory;
-import org.junit.Before;
-import org.junit.Test;
-
-import static java.net.Proxy.NO_PROXY;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-public final class RouteSelectorTest {
-  public final List<ConnectionSpec> connectionSpecs = Util.immutableList(
-      ConnectionSpec.MODERN_TLS,
-      ConnectionSpec.COMPATIBLE_TLS,
-      ConnectionSpec.CLEARTEXT);
-
-  private static final int proxyAPort = 1001;
-  private static final String proxyAHost = "proxyA";
-  private static final Proxy proxyA =
-      new Proxy(Proxy.Type.HTTP, new InetSocketAddress(proxyAHost, proxyAPort));
-  private static final int proxyBPort = 1002;
-  private static final String proxyBHost = "proxyB";
-  private static final Proxy proxyB =
-      new Proxy(Proxy.Type.HTTP, new InetSocketAddress(proxyBHost, proxyBPort));
-  private String uriHost = "hostA";
-  private int uriPort = 1003;
-
-  private SocketFactory socketFactory;
-  private final SSLContext sslContext = SslContextBuilder.localhost();
-  private final SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();
-  private HostnameVerifier hostnameVerifier;
-
-  private final Authenticator authenticator = AuthenticatorAdapter.INSTANCE;
-  private final List<Protocol> protocols = Arrays.asList(Protocol.HTTP_1_1);
-  private final FakeDns dns = new FakeDns();
-  private final RecordingProxySelector proxySelector = new RecordingProxySelector();
-  private OkHttpClient client;
-  private RouteDatabase routeDatabase;
-  private Request httpRequest;
-  private Request httpsRequest;
-
-  @Before public void setUp() throws Exception {
-    socketFactory = SocketFactory.getDefault();
-    hostnameVerifier = HttpsURLConnection.getDefaultHostnameVerifier();
-
-    client = new OkHttpClient()
-        .setAuthenticator(authenticator)
-        .setProxySelector(proxySelector)
-        .setSocketFactory(socketFactory)
-        .setSslSocketFactory(sslSocketFactory)
-        .setHostnameVerifier(hostnameVerifier)
-        .setProtocols(protocols)
-        .setConnectionSpecs(connectionSpecs)
-        .setConnectionPool(ConnectionPool.getDefault());
-    Internal.instance.setNetwork(client, dns);
-
-    routeDatabase = Internal.instance.routeDatabase(client);
-
-    httpRequest = new Request.Builder()
-        .url("http://" + uriHost + ":" + uriPort + "/path")
-        .build();
-    httpsRequest = new Request.Builder()
-        .url("https://" + uriHost + ":" + uriPort + "/path")
-        .build();
-  }
-
-  @Test public void singleRoute() throws Exception {
-    Address address = httpAddress();
-    RouteSelector routeSelector = RouteSelector.get(address, httpRequest, client);
-
-    assertTrue(routeSelector.hasNext());
-    dns.inetAddresses = makeFakeAddresses(255, 1);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0],
-        uriPort, ConnectionSpec.CLEARTEXT);
-    dns.assertRequests(uriHost);
-
-    assertFalse(routeSelector.hasNext());
-    try {
-      routeSelector.next();
-      fail();
-    } catch (NoSuchElementException expected) {
-    }
-  }
-
-  @Test public void singleRouteReturnsFailedRoute() throws Exception {
-    Address address = httpAddress();
-    RouteSelector routeSelector = RouteSelector.get(address, httpRequest, client);
-
-    assertTrue(routeSelector.hasNext());
-    dns.inetAddresses = makeFakeAddresses(255, 1);
-    Route route = routeSelector.next();
-    routeDatabase.failed(route);
-    routeSelector = RouteSelector.get(address, httpRequest, client);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0],
-        uriPort, ConnectionSpec.CLEARTEXT);
-    assertFalse(routeSelector.hasNext());
-    try {
-      routeSelector.next();
-      fail();
-    } catch (NoSuchElementException expected) {
-    }
-  }
-
-  @Test public void explicitProxyTriesThatProxysAddressesOnly() throws Exception {
-    Address address = new Address(uriHost, uriPort, socketFactory, null, null, null, authenticator,
-        proxyA, protocols, connectionSpecs, proxySelector);
-    client.setProxy(proxyA);
-    RouteSelector routeSelector = RouteSelector.get(address, httpRequest, client);
-
-    assertTrue(routeSelector.hasNext());
-    dns.inetAddresses = makeFakeAddresses(255, 2);
-    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[0],
-        proxyAPort, ConnectionSpec.CLEARTEXT);
-    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[1],
-        proxyAPort, ConnectionSpec.CLEARTEXT);
-
-    assertFalse(routeSelector.hasNext());
-    dns.assertRequests(proxyAHost);
-    proxySelector.assertRequests(); // No proxy selector requests!
-  }
-
-  @Test public void explicitDirectProxy() throws Exception {
-    Address address = new Address(uriHost, uriPort, socketFactory, null, null, null, authenticator,
-        NO_PROXY, protocols, connectionSpecs, proxySelector);
-    client.setProxy(NO_PROXY);
-    RouteSelector routeSelector = RouteSelector.get(address, httpRequest, client);
-
-    assertTrue(routeSelector.hasNext());
-    dns.inetAddresses = makeFakeAddresses(255, 2);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0],
-        uriPort, ConnectionSpec.CLEARTEXT);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[1],
-        uriPort, ConnectionSpec.CLEARTEXT);
-
-    assertFalse(routeSelector.hasNext());
-    dns.assertRequests(uriHost);
-    proxySelector.assertRequests(); // No proxy selector requests!
-  }
-
-  @Test public void proxySelectorReturnsNull() throws Exception {
-    Address address = httpAddress();
-
-    proxySelector.proxies = null;
-    RouteSelector routeSelector = RouteSelector.get(address, httpRequest, client);
-    proxySelector.assertRequests(httpRequest.uri());
-
-    assertTrue(routeSelector.hasNext());
-    dns.inetAddresses = makeFakeAddresses(255, 1);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0],
-        uriPort, ConnectionSpec.CLEARTEXT);
-    dns.assertRequests(uriHost);
-
-    assertFalse(routeSelector.hasNext());
-  }
-
-  @Test public void proxySelectorReturnsNoProxies() throws Exception {
-    Address address = httpAddress();
-    RouteSelector routeSelector = RouteSelector.get(address, httpRequest, client);
-
-    assertTrue(routeSelector.hasNext());
-    dns.inetAddresses = makeFakeAddresses(255, 2);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0],
-        uriPort, ConnectionSpec.CLEARTEXT);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[1],
-        uriPort, ConnectionSpec.CLEARTEXT);
-
-    assertFalse(routeSelector.hasNext());
-    dns.assertRequests(uriHost);
-    proxySelector.assertRequests(httpRequest.uri());
-  }
-
-  @Test public void proxySelectorReturnsMultipleProxies() throws Exception {
-    Address address = httpAddress();
-
-    proxySelector.proxies.add(proxyA);
-    proxySelector.proxies.add(proxyB);
-    RouteSelector routeSelector = RouteSelector.get(address, httpRequest, client);
-    proxySelector.assertRequests(httpRequest.uri());
-
-    // First try the IP addresses of the first proxy, in sequence.
-    assertTrue(routeSelector.hasNext());
-    dns.inetAddresses = makeFakeAddresses(255, 2);
-    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[0], proxyAPort,
-        ConnectionSpec.CLEARTEXT);
-    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[1], proxyAPort,
-        ConnectionSpec.CLEARTEXT);
-    dns.assertRequests(proxyAHost);
-
-    // Next try the IP address of the second proxy.
-    assertTrue(routeSelector.hasNext());
-    dns.inetAddresses = makeFakeAddresses(254, 1);
-    assertRoute(routeSelector.next(), address, proxyB, dns.inetAddresses[0],
-        proxyBPort,
-        ConnectionSpec.CLEARTEXT);
-    dns.assertRequests(proxyBHost);
-
-    // Finally try the only IP address of the origin server.
-    assertTrue(routeSelector.hasNext());
-    dns.inetAddresses = makeFakeAddresses(253, 1);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0], uriPort,
-        ConnectionSpec.CLEARTEXT);
-    dns.assertRequests(uriHost);
-
-    assertFalse(routeSelector.hasNext());
-  }
-
-  @Test public void proxySelectorDirectConnectionsAreSkipped() throws Exception {
-    Address address = httpAddress();
-
-    proxySelector.proxies.add(NO_PROXY);
-    RouteSelector routeSelector = RouteSelector.get(address, httpRequest, client);
-    proxySelector.assertRequests(httpRequest.uri());
-
-    // Only the origin server will be attempted.
-    assertTrue(routeSelector.hasNext());
-    dns.inetAddresses = makeFakeAddresses(255, 1);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0], uriPort,
-        ConnectionSpec.CLEARTEXT);
-    dns.assertRequests(uriHost);
-
-    assertFalse(routeSelector.hasNext());
-  }
-
-  @Test public void proxyDnsFailureContinuesToNextProxy() throws Exception {
-    Address address = httpAddress();
-
-    proxySelector.proxies.add(proxyA);
-    proxySelector.proxies.add(proxyB);
-    proxySelector.proxies.add(proxyA);
-    RouteSelector routeSelector = RouteSelector.get(address, httpRequest, client);
-    proxySelector.assertRequests(httpRequest.uri());
-
-    assertTrue(routeSelector.hasNext());
-    dns.inetAddresses = makeFakeAddresses(255, 1);
-    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[0],
-        proxyAPort, ConnectionSpec.CLEARTEXT);
-    dns.assertRequests(proxyAHost);
-
-    assertTrue(routeSelector.hasNext());
-    dns.inetAddresses = null;
-    try {
-      routeSelector.next();
-      fail();
-    } catch (UnknownHostException expected) {
-    }
-    dns.assertRequests(proxyBHost);
-
-    assertTrue(routeSelector.hasNext());
-    dns.inetAddresses = makeFakeAddresses(255, 1);
-    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[0],
-        proxyAPort, ConnectionSpec.CLEARTEXT);
-    dns.assertRequests(proxyAHost);
-
-    assertTrue(routeSelector.hasNext());
-    dns.inetAddresses = makeFakeAddresses(254, 1);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0],
-        uriPort, ConnectionSpec.CLEARTEXT);
-    dns.assertRequests(uriHost);
-
-    assertFalse(routeSelector.hasNext());
-  }
-
-  // https://github.com/square/okhttp/issues/442
-  @Test public void nonSslErrorAddsAllTlsModesToFailedRoute() throws Exception {
-    Address address = httpsAddress();
-    client.setProxy(Proxy.NO_PROXY);
-    RouteSelector routeSelector = RouteSelector.get(address, httpsRequest, client);
-
-    dns.inetAddresses = makeFakeAddresses(255, 1);
-    Route route = routeSelector.next();
-    routeSelector.connectFailed(route, new IOException("Non SSL exception"));
-    assertEquals(2, routeDatabase.failedRoutesCount());
-    assertFalse(routeSelector.hasNext());
-  }
-
-  @Test public void sslErrorAddsOnlyFailedConfigurationToFailedRoute() throws Exception {
-    Address address = httpsAddress();
-    client.setProxy(Proxy.NO_PROXY);
-    RouteSelector routeSelector = RouteSelector.get(address, httpsRequest, client);
-
-    dns.inetAddresses = makeFakeAddresses(255, 1);
-    Route route = routeSelector.next();
-    routeSelector.connectFailed(route, new SSLHandshakeException("SSL exception"));
-    assertTrue(routeDatabase.failedRoutesCount() == 1);
-    assertTrue(routeSelector.hasNext());
-  }
-
-  @Test public void multipleProxiesMultipleInetAddressesMultipleConfigurations() throws Exception {
-    Address address = httpsAddress();
-    proxySelector.proxies.add(proxyA);
-    proxySelector.proxies.add(proxyB);
-    RouteSelector routeSelector = RouteSelector.get(address, httpsRequest, client);
-
-    // Proxy A
-    dns.inetAddresses = makeFakeAddresses(255, 2);
-    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[0],
-        proxyAPort, ConnectionSpec.MODERN_TLS);
-    dns.assertRequests(proxyAHost);
-    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[0],
-        proxyAPort, ConnectionSpec.COMPATIBLE_TLS);
-    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[1],
-        proxyAPort, ConnectionSpec.MODERN_TLS);
-    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[1],
-        proxyAPort, ConnectionSpec.COMPATIBLE_TLS);
-
-    // Proxy B
-    dns.inetAddresses = makeFakeAddresses(254, 2);
-    assertRoute(routeSelector.next(), address, proxyB, dns.inetAddresses[0],
-        proxyBPort, ConnectionSpec.MODERN_TLS);
-    dns.assertRequests(proxyBHost);
-    assertRoute(routeSelector.next(), address, proxyB, dns.inetAddresses[0],
-        proxyBPort, ConnectionSpec.COMPATIBLE_TLS);
-    assertRoute(routeSelector.next(), address, proxyB, dns.inetAddresses[1],
-        proxyBPort, ConnectionSpec.MODERN_TLS);
-    assertRoute(routeSelector.next(), address, proxyB, dns.inetAddresses[1],
-        proxyBPort, ConnectionSpec.COMPATIBLE_TLS);
-
-    // Origin
-    dns.inetAddresses = makeFakeAddresses(253, 2);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0],
-        uriPort, ConnectionSpec.MODERN_TLS);
-    dns.assertRequests(uriHost);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0],
-        uriPort, ConnectionSpec.COMPATIBLE_TLS);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[1],
-        uriPort, ConnectionSpec.MODERN_TLS);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[1],
-        uriPort, ConnectionSpec.COMPATIBLE_TLS);
-
-    assertFalse(routeSelector.hasNext());
-  }
-
-  @Test public void failedRoutesAreLast() throws Exception {
-    Address address = httpsAddress();
-    client.setProxy(Proxy.NO_PROXY);
-    RouteSelector routeSelector = RouteSelector.get(address, httpsRequest, client);
-
-    dns.inetAddresses = makeFakeAddresses(255, 1);
-
-    // Extract the regular sequence of routes from selector.
-    List<Route> regularRoutes = new ArrayList<>();
-    while (routeSelector.hasNext()) {
-      regularRoutes.add(routeSelector.next());
-    }
-
-    // Check that we do indeed have more than one route.
-    assertTrue(regularRoutes.size() > 1);
-    // Add first regular route as failed.
-    routeDatabase.failed(regularRoutes.get(0));
-    // Reset selector
-    routeSelector = RouteSelector.get(address, httpsRequest, client);
-
-    List<Route> routesWithFailedRoute = new ArrayList<>();
-    while (routeSelector.hasNext()) {
-      routesWithFailedRoute.add(routeSelector.next());
-    }
-
-    assertEquals(regularRoutes.get(0),
-        routesWithFailedRoute.get(routesWithFailedRoute.size() - 1));
-    assertEquals(regularRoutes.size(), routesWithFailedRoute.size());
-  }
-
-  @Test public void getHostString() throws Exception {
-    // Name proxy specification.
-    InetSocketAddress socketAddress = InetSocketAddress.createUnresolved("host", 1234);
-    assertEquals("host", RouteSelector.getHostString(socketAddress));
-    socketAddress = InetSocketAddress.createUnresolved("127.0.0.1", 1234);
-    assertEquals("127.0.0.1", RouteSelector.getHostString(socketAddress));
-
-    // InetAddress proxy specification.
-    socketAddress = new InetSocketAddress(InetAddress.getByName("localhost"), 1234);
-    assertEquals("127.0.0.1", RouteSelector.getHostString(socketAddress));
-    socketAddress = new InetSocketAddress(
-        InetAddress.getByAddress(new byte[] { 127, 0, 0, 1 }), 1234);
-    assertEquals("127.0.0.1", RouteSelector.getHostString(socketAddress));
-    socketAddress = new InetSocketAddress(
-        InetAddress.getByAddress("foobar", new byte[] { 127, 0, 0, 1 }), 1234);
-    assertEquals("127.0.0.1", RouteSelector.getHostString(socketAddress));
-  }
-
-  private void assertRoute(Route route, Address address, Proxy proxy,
-      InetAddress socketAddress, int socketPort, ConnectionSpec connectionSpec) {
-    assertEquals(address, route.getAddress());
-    assertEquals(proxy, route.getProxy());
-    assertEquals(socketAddress, route.getSocketAddress().getAddress());
-    assertEquals(socketPort, route.getSocketAddress().getPort());
-    assertEquals(connectionSpec, route.getConnectionSpec());
-  }
-
-  /** Returns an address that's without an SSL socket factory or hostname verifier. */
-  private Address httpAddress() {
-    return new Address(uriHost, uriPort, socketFactory, null, null, null, authenticator, null,
-        protocols, connectionSpecs, proxySelector);
-  }
-
-  private Address httpsAddress() {
-    return new Address(uriHost, uriPort, socketFactory, sslSocketFactory,
-        hostnameVerifier, null, authenticator, null, protocols, connectionSpecs, proxySelector);
-  }
-
-  private static InetAddress[] makeFakeAddresses(int prefix, int count) {
-    try {
-      InetAddress[] result = new InetAddress[count];
-      for (int i = 0; i < count; i++) {
-        result[i] =
-            InetAddress.getByAddress(new byte[] { (byte) prefix, (byte) 0, (byte) 0, (byte) i });
-      }
-      return result;
-    } catch (UnknownHostException e) {
-      throw new AssertionError();
-    }
-  }
-
-  private static class FakeDns implements Network {
-    List<String> requestedHosts = new ArrayList<>();
-    InetAddress[] inetAddresses;
-
-    @Override public InetAddress[] resolveInetAddresses(String host) throws UnknownHostException {
-      requestedHosts.add(host);
-      if (inetAddresses == null) throw new UnknownHostException();
-      return inetAddresses;
-    }
-
-    public void assertRequests(String... expectedHosts) {
-      assertEquals(Arrays.asList(expectedHosts), requestedHosts);
-      requestedHosts.clear();
-    }
-  }
-}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/io/InMemoryFileSystem.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/io/InMemoryFileSystem.java
deleted file mode 100644
index 3a043cbd1f..0000000000
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/io/InMemoryFileSystem.java
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal.io;
-
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.util.Iterator;
-import java.util.LinkedHashMap;
-import java.util.Map;
-import okio.Buffer;
-import okio.Sink;
-import okio.Source;
-
-/** A simple file system where all files are held in memory. Not safe for concurrent use. */
-public final class InMemoryFileSystem implements FileSystem {
-  private final Map<File, Buffer> files = new LinkedHashMap<>();
-
-  @Override public Source source(File file) throws FileNotFoundException {
-    Buffer result = files.get(file);
-    if (result == null) throw new FileNotFoundException();
-    return result.clone();
-  }
-
-  @Override public Sink sink(File file) throws FileNotFoundException {
-    Buffer result = new Buffer();
-    files.put(file, result);
-    return result;
-  }
-
-  @Override public Sink appendingSink(File file) throws FileNotFoundException {
-    Buffer result = files.get(file);
-    return result != null ? result : sink(file);
-  }
-
-  @Override public void delete(File file) throws IOException {
-    files.remove(file);
-  }
-
-  @Override public boolean exists(File file) throws IOException {
-    return files.containsKey(file);
-  }
-
-  @Override public long size(File file) {
-    Buffer buffer = files.get(file);
-    return buffer != null ? buffer.size() : 0L;
-  }
-
-  @Override public void rename(File from, File to) throws IOException {
-    Buffer buffer = files.remove(from);
-    if (buffer == null) throw new FileNotFoundException();
-    files.put(to, buffer);
-  }
-
-  @Override public void deleteContents(File directory) throws IOException {
-    String prefix = directory.toString() + "/";
-    for (Iterator<File> i = files.keySet().iterator(); i.hasNext(); ) {
-      File file = i.next();
-      if (file.toString().startsWith(prefix)) i.remove();
-    }
-  }
-}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/AddressTest.java b/okhttp-tests/src/test/java/okhttp3/AddressTest.java
similarity index 74%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/AddressTest.java
rename to okhttp-tests/src/test/java/okhttp3/AddressTest.java
index 44c39a810e..30e376be5b 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/AddressTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/AddressTest.java
@@ -13,38 +13,38 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
-import com.squareup.okhttp.internal.Util;
-import com.squareup.okhttp.internal.http.AuthenticatorAdapter;
-import com.squareup.okhttp.internal.http.RecordingProxySelector;
 import java.util.List;
 import javax.net.SocketFactory;
+import okhttp3.internal.Util;
+import okhttp3.internal.http.RecordingProxySelector;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 
 public final class AddressTest {
+  private Dns dns = Dns.SYSTEM;
   private SocketFactory socketFactory = SocketFactory.getDefault();
-  private Authenticator authenticator = AuthenticatorAdapter.INSTANCE;
+  private Authenticator authenticator = Authenticator.NONE;
   private List<Protocol> protocols = Util.immutableList(Protocol.HTTP_1_1);
   private List<ConnectionSpec> connectionSpecs = Util.immutableList(ConnectionSpec.MODERN_TLS);
   private RecordingProxySelector proxySelector = new RecordingProxySelector();
 
   @Test public void equalsAndHashcode() throws Exception {
-    Address a = new Address("square.com", 80, socketFactory, null, null, null,
+    Address a = new Address("square.com", 80, dns, socketFactory, null, null, null,
         authenticator, null, protocols, connectionSpecs, proxySelector);
-    Address b = new Address("square.com", 80, socketFactory, null, null, null,
+    Address b = new Address("square.com", 80, dns, socketFactory, null, null, null,
         authenticator, null, protocols, connectionSpecs, proxySelector);
     assertEquals(a, b);
     assertEquals(a.hashCode(), b.hashCode());
   }
 
   @Test public void differentProxySelectorsAreDifferent() throws Exception {
-    Address a = new Address("square.com", 80, socketFactory, null, null, null,
+    Address a = new Address("square.com", 80, dns, socketFactory, null, null, null,
         authenticator, null, protocols, connectionSpecs, new RecordingProxySelector());
-    Address b = new Address("square.com", 80, socketFactory, null, null, null,
+    Address b = new Address("square.com", 80, dns, socketFactory, null, null, null,
         authenticator, null, protocols, connectionSpecs, new RecordingProxySelector());
     assertFalse(a.equals(b));
   }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/CacheControlTest.java b/okhttp-tests/src/test/java/okhttp3/CacheControlTest.java
similarity index 99%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/CacheControlTest.java
rename to okhttp-tests/src/test/java/okhttp3/CacheControlTest.java
index 5d1376737e..ef15052a93 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/CacheControlTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CacheControlTest.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
 import java.util.concurrent.TimeUnit;
 import org.junit.Test;
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/CacheTest.java b/okhttp-tests/src/test/java/okhttp3/CacheTest.java
similarity index 75%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/CacheTest.java
rename to okhttp-tests/src/test/java/okhttp3/CacheTest.java
index af0f506755..da64492d1a 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/CacheTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CacheTest.java
@@ -14,23 +14,14 @@
  * limitations under the License.
  */
 
-package com.squareup.okhttp;
-
-import com.squareup.okhttp.internal.Internal;
-import com.squareup.okhttp.internal.SslContextBuilder;
-import com.squareup.okhttp.internal.Util;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-import com.squareup.okhttp.mockwebserver.RecordedRequest;
-import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
+package okhttp3;
+
 import java.io.File;
 import java.io.IOException;
-import java.net.CookieHandler;
 import java.net.CookieManager;
 import java.net.HttpCookie;
 import java.net.HttpURLConnection;
 import java.net.ResponseCache;
-import java.net.URL;
 import java.security.Principal;
 import java.security.cert.Certificate;
 import java.text.DateFormat;
@@ -46,8 +37,14 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicReference;
 import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLSession;
+import okhttp3.internal.Internal;
+import okhttp3.internal.Util;
+import okhttp3.internal.io.InMemoryFileSystem;
+import okhttp3.internal.tls.SslClient;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -57,9 +54,8 @@
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
-import org.junit.rules.TemporaryFolder;
 
-import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
@@ -67,7 +63,6 @@
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
-/** Test caching with {@link OkUrlFactory}. */
 public final class CacheTest {
   private static final HostnameVerifier NULL_HOSTNAME_VERIFIER = new HostnameVerifier() {
     @Override public boolean verify(String s, SSLSession sslSession) {
@@ -75,30 +70,27 @@
     }
   };
 
-  private static final SSLContext sslContext = SslContextBuilder.localhost();
-
-  @Rule public TemporaryFolder cacheRule = new TemporaryFolder();
-  @Rule public MockWebServerRule serverRule = new MockWebServerRule();
-  @Rule public MockWebServerRule server2Rule = new MockWebServerRule();
+  @Rule public MockWebServer server = new MockWebServer();
+  @Rule public MockWebServer server2 = new MockWebServer();
+  @Rule public InMemoryFileSystem fileSystem = new InMemoryFileSystem();
 
-  private final OkHttpClient client = new OkHttpClient();
-  private MockWebServer server;
-  private MockWebServer server2;
+  private final SslClient sslClient = SslClient.localhost();
+  private OkHttpClient client;
   private Cache cache;
   private final CookieManager cookieManager = new CookieManager();
 
   @Before public void setUp() throws Exception {
-    server = serverRule.get();
     server.setProtocolNegotiationEnabled(false);
-    server2 = server2Rule.get();
-    cache = new Cache(cacheRule.getRoot(), Integer.MAX_VALUE);
-    client.setCache(cache);
-    CookieHandler.setDefault(cookieManager);
+    cache = new Cache(new File("/cache/"), Integer.MAX_VALUE, fileSystem);
+    client = new OkHttpClient.Builder()
+        .cache(cache)
+        .cookieJar(new JavaNetCookieJar(cookieManager))
+        .build();
   }
 
   @After public void tearDown() throws Exception {
     ResponseCache.setDefault(null);
-    CookieHandler.setDefault(null);
+    cache.delete();
   }
 
   /**
@@ -113,45 +105,45 @@
     // assertCached(false, 100);
     assertCached(false, 101);
     assertCached(false, 102);
-    assertCached(true,  200);
+    assertCached(true, 200);
     assertCached(false, 201);
     assertCached(false, 202);
-    assertCached(true,  203);
-    assertCached(true,  204);
+    assertCached(true, 203);
+    assertCached(true, 204);
     assertCached(false, 205);
     assertCached(false, 206); //Electing to not cache partial responses
     assertCached(false, 207);
-    assertCached(true,  300);
-    assertCached(true,  301);
-    assertCached(true,  302);
+    assertCached(true, 300);
+    assertCached(true, 301);
+    assertCached(true, 302);
     assertCached(false, 303);
     assertCached(false, 304);
     assertCached(false, 305);
     assertCached(false, 306);
-    assertCached(true,  307);
-    assertCached(true,  308);
+    assertCached(true, 307);
+    assertCached(true, 308);
     assertCached(false, 400);
     assertCached(false, 401);
     assertCached(false, 402);
     assertCached(false, 403);
-    assertCached(true,  404);
-    assertCached(true,  405);
+    assertCached(true, 404);
+    assertCached(true, 405);
     assertCached(false, 406);
     assertCached(false, 408);
     assertCached(false, 409);
     // the HTTP spec permits caching 410s, but the RI doesn't.
-    assertCached(true,  410);
+    assertCached(true, 410);
     assertCached(false, 411);
     assertCached(false, 412);
     assertCached(false, 413);
-    assertCached(true,  414);
+    assertCached(true, 414);
     assertCached(false, 415);
     assertCached(false, 416);
     assertCached(false, 417);
     assertCached(false, 418);
 
     assertCached(false, 500);
-    assertCached(true,  501);
+    assertCached(true, 501);
     assertCached(false, 502);
     assertCached(false, 503);
     assertCached(false, 504);
@@ -160,6 +152,8 @@
   }
 
   private void assertCached(boolean shouldPut, int responseCode) throws Exception {
+    int expectedResponseCode = responseCode;
+
     server = new MockWebServer();
     MockResponse mockResponse = new MockResponse()
         .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
@@ -171,15 +165,29 @@ private void assertCached(boolean shouldPut, int responseCode) throws Exception
       mockResponse.addHeader("Proxy-Authenticate: Basic realm=\"protected area\"");
     } else if (responseCode == HttpURLConnection.HTTP_UNAUTHORIZED) {
       mockResponse.addHeader("WWW-Authenticate: Basic realm=\"protected area\"");
+    } else if (responseCode == HttpURLConnection.HTTP_NO_CONTENT
+        || responseCode == HttpURLConnection.HTTP_RESET) {
+      mockResponse.setBody(""); // We forbid bodies for 204 and 205.
     }
     server.enqueue(mockResponse);
+
+    if (responseCode == HttpURLConnection.HTTP_CLIENT_TIMEOUT) {
+      // 408's are a bit of an outlier because we may repeat the request if we encounter this
+      // response code. In this scenario, there are 2 responses: the initial 408 and then the 200
+      // because of the retry. We just want to ensure the initial 408 isn't cached.
+      expectedResponseCode = 200;
+      server.enqueue(new MockResponse()
+          .setHeader("Cache-Control", "no-store")
+          .setBody("FGHIJ"));
+    }
+
     server.start();
 
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .build();
     Response response = client.newCall(request).execute();
-    assertEquals(responseCode, response.code());
+    assertEquals(expectedResponseCode, response.code());
 
     // Exhaust the content stream.
     response.body().string();
@@ -219,7 +227,7 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     server.enqueue(mockResponse);
 
     // Make sure that calling skip() doesn't omit bytes from the cache.
-    Request request = new Request.Builder().url(server.getUrl("/")).build();
+    Request request = new Request.Builder().url(server.url("/")).build();
     Response response1 = client.newCall(request).execute();
 
     BufferedSource in1 = response1.body().source();
@@ -228,8 +236,8 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     assertEquals("spiders", in1.readUtf8("spiders".length()));
     assertTrue(in1.exhausted());
     in1.close();
-    assertEquals(1, cache.getWriteSuccessCount());
-    assertEquals(0, cache.getWriteAbortCount());
+    assertEquals(1, cache.writeSuccessCount());
+    assertEquals(0, cache.writeAbortCount());
 
     Response response2 = client.newCall(request).execute();
     BufferedSource in2 = response2.body().source();
@@ -240,42 +248,44 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
 
     assertTrue(in2.exhausted());
     in2.close();
-    assertEquals(1, cache.getWriteSuccessCount());
-    assertEquals(0, cache.getWriteAbortCount());
-    assertEquals(2, cache.getRequestCount());
-    assertEquals(1, cache.getHitCount());
+    assertEquals(1, cache.writeSuccessCount());
+    assertEquals(0, cache.writeAbortCount());
+    assertEquals(2, cache.requestCount());
+    assertEquals(1, cache.hitCount());
   }
 
   @Test public void secureResponseCaching() throws IOException {
-    server.useHttps(sslContext.getSocketFactory(), false);
+    server.useHttps(sslClient.socketFactory, false);
     server.enqueue(new MockResponse()
         .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .setBody("ABC"));
 
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+    client = client.newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
+        .build();
 
-    Request request = new Request.Builder().url(server.getUrl("/")).build();
+    Request request = new Request.Builder().url(server.url("/")).build();
     Response response1 = client.newCall(request).execute();
     BufferedSource in = response1.body().source();
     assertEquals("ABC", in.readUtf8());
 
     // OpenJDK 6 fails on this line, complaining that the connection isn't open yet
-    String suite = response1.handshake().cipherSuite();
+    CipherSuite cipherSuite = response1.handshake().cipherSuite();
     List<Certificate> localCerts = response1.handshake().localCertificates();
     List<Certificate> serverCerts = response1.handshake().peerCertificates();
     Principal peerPrincipal = response1.handshake().peerPrincipal();
     Principal localPrincipal = response1.handshake().localPrincipal();
 
     Response response2 = client.newCall(request).execute(); // Cached!
-    assertEquals("ABC", response2.body().source().readUtf8());
+    assertEquals("ABC", response2.body().string());
 
-    assertEquals(2, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(1, cache.getHitCount());
+    assertEquals(2, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(1, cache.hitCount());
 
-    assertEquals(suite, response2.handshake().cipherSuite());
+    assertEquals(cipherSuite, response2.handshake().cipherSuite());
     assertEquals(localCerts, response2.handshake().localCertificates());
     assertEquals(serverCerts, response2.handshake().peerCertificates());
     assertEquals(peerPrincipal, response2.handshake().peerPrincipal());
@@ -295,16 +305,16 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     server.enqueue(new MockResponse()
         .setBody("DEF"));
 
-    Request request = new Request.Builder().url(server.getUrl("/")).build();
+    Request request = new Request.Builder().url(server.url("/")).build();
     Response response1 = client.newCall(request).execute();
     assertEquals("ABC", response1.body().string());
 
     Response response2 = client.newCall(request).execute(); // Cached!
     assertEquals("ABC", response2.body().string());
 
-    assertEquals(4, cache.getRequestCount()); // 2 requests + 2 redirects
-    assertEquals(2, cache.getNetworkCount());
-    assertEquals(2, cache.getHitCount());
+    assertEquals(4, cache.requestCount()); // 2 requests + 2 redirects
+    assertEquals(2, cache.networkCount());
+    assertEquals(2, cache.hitCount());
   }
 
   @Test public void redirectToCachedResult() throws Exception {
@@ -317,14 +327,14 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     server.enqueue(new MockResponse()
         .setBody("DEF"));
 
-    Request request1 = new Request.Builder().url(server.getUrl("/foo")).build();
+    Request request1 = new Request.Builder().url(server.url("/foo")).build();
     Response response1 = client.newCall(request1).execute();
     assertEquals("ABC", response1.body().string());
     RecordedRequest recordedRequest1 = server.takeRequest();
     assertEquals("GET /foo HTTP/1.1", recordedRequest1.getRequestLine());
     assertEquals(0, recordedRequest1.getSequenceNumber());
 
-    Request request2 = new Request.Builder().url(server.getUrl("/bar")).build();
+    Request request2 = new Request.Builder().url(server.url("/bar")).build();
     Response response2 = client.newCall(request2).execute();
     assertEquals("ABC", response2.body().string());
     RecordedRequest recordedRequest2 = server.takeRequest();
@@ -332,7 +342,7 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     assertEquals(1, recordedRequest2.getSequenceNumber());
 
     // an unrelated request should reuse the pooled connection
-    Request request3 = new Request.Builder().url(server.getUrl("/baz")).build();
+    Request request3 = new Request.Builder().url(server.url("/baz")).build();
     Response response3 = client.newCall(request3).execute();
     assertEquals("DEF", response3.body().string());
     RecordedRequest recordedRequest3 = server.takeRequest();
@@ -341,7 +351,7 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
   }
 
   @Test public void secureResponseCachingAndRedirects() throws IOException {
-    server.useHttps(sslContext.getSocketFactory(), false);
+    server.useHttps(sslClient.socketFactory, false);
     server.enqueue(new MockResponse()
         .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
@@ -354,33 +364,34 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     server.enqueue(new MockResponse()
         .setBody("DEF"));
 
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+    client = client.newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
+        .build();
 
-    Response response1 = get(server.getUrl("/"));
+    Response response1 = get(server.url("/"));
     assertEquals("ABC", response1.body().string());
     assertNotNull(response1.handshake().cipherSuite());
 
     // Cached!
-    Response response2 = get(server.getUrl("/"));
+    Response response2 = get(server.url("/"));
     assertEquals("ABC", response2.body().string());
     assertNotNull(response2.handshake().cipherSuite());
 
-    assertEquals(4, cache.getRequestCount()); // 2 direct + 2 redirect = 4
-    assertEquals(2, cache.getHitCount());
+    assertEquals(4, cache.requestCount()); // 2 direct + 2 redirect = 4
+    assertEquals(2, cache.hitCount());
     assertEquals(response1.handshake().cipherSuite(), response2.handshake().cipherSuite());
   }
 
   /**
-   * We've had bugs where caching and cross-protocol redirects yield class
-   * cast exceptions internal to the cache because we incorrectly assumed that
-   * HttpsURLConnection was always HTTPS and HttpURLConnection was always HTTP;
-   * in practice redirects mean that each can do either.
+   * We've had bugs where caching and cross-protocol redirects yield class cast exceptions internal
+   * to the cache because we incorrectly assumed that HttpsURLConnection was always HTTPS and
+   * HttpURLConnection was always HTTP; in practice redirects mean that each can do either.
    *
    * https://github.com/square/okhttp/issues/214
    */
   @Test public void secureResponseCachingAndProtocolRedirects() throws IOException {
-    server2.useHttps(sslContext.getSocketFactory(), false);
+    server2.useHttps(sslClient.socketFactory, false);
     server2.enqueue(new MockResponse()
         .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
@@ -392,20 +403,22 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
         .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
-        .addHeader("Location: " + server2.getUrl("/")));
+        .addHeader("Location: " + server2.url("/")));
 
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+    client = client.newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
+        .build();
 
-    Response response1 = get(server.getUrl("/"));
+    Response response1 = get(server.url("/"));
     assertEquals("ABC", response1.body().string());
 
     // Cached!
-    Response response2 = get(server.getUrl("/"));
+    Response response2 = get(server.url("/"));
     assertEquals("ABC", response2.body().string());
 
-    assertEquals(4, cache.getRequestCount()); // 2 direct + 2 redirect = 4
-    assertEquals(2, cache.getHitCount());
+    assertEquals(4, cache.requestCount()); // 2 direct + 2 redirect = 4
+    assertEquals(2, cache.hitCount());
   }
 
   @Test public void foundCachedWithExpiresHeader() throws Exception {
@@ -446,7 +459,7 @@ private void temporaryRedirectCachedWithCachingHeader(
     server.enqueue(new MockResponse()
         .setBody("c"));
 
-    URL url = server.getUrl("/");
+    HttpUrl url = server.url("/");
     assertEquals("a", get(url).body().string());
     assertEquals("a", get(url).body().string());
   }
@@ -460,11 +473,31 @@ private void temporaryRedirectNotCachedWithoutCachingHeader(int responseCode) th
     server.enqueue(new MockResponse()
         .setBody("b"));
 
-    URL url = server.getUrl("/");
+    HttpUrl url = server.url("/");
     assertEquals("a", get(url).body().string());
     assertEquals("b", get(url).body().string());
   }
 
+  /** https://github.com/square/okhttp/issues/2198 */
+  @Test public void cachedRedirect() throws IOException {
+    server.enqueue(new MockResponse()
+        .setResponseCode(301)
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Location: /bar"));
+    server.enqueue(new MockResponse()
+        .setBody("ABC"));
+    server.enqueue(new MockResponse()
+        .setBody("ABC"));
+
+    Request request1 = new Request.Builder().url(server.url("/")).build();
+    Response response1 = client.newCall(request1).execute();
+    assertEquals("ABC", response1.body().string());
+
+    Request request2 = new Request.Builder().url(server.url("/")).build();
+    Response response2 = client.newCall(request2).execute();
+    assertEquals("ABC", response2.body().string());
+  }
+
   @Test public void serverDisconnectsPrematurelyWithContentLengthHeader() throws IOException {
     testServerPrematureDisconnect(TransferKind.FIXED_LENGTH);
   }
@@ -486,7 +519,7 @@ private void testServerPrematureDisconnect(TransferKind transferKind) throws IOE
     server.enqueue(new MockResponse()
         .setBody("Request #2"));
 
-    BufferedSource bodySource = get(server.getUrl("/")).body().source();
+    BufferedSource bodySource = get(server.url("/")).body().source();
     assertEquals("ABCDE", bodySource.readUtf8Line());
     try {
       bodySource.readUtf8Line();
@@ -496,12 +529,12 @@ private void testServerPrematureDisconnect(TransferKind transferKind) throws IOE
       bodySource.close();
     }
 
-    assertEquals(1, cache.getWriteAbortCount());
-    assertEquals(0, cache.getWriteSuccessCount());
-    Response response = get(server.getUrl("/"));
+    assertEquals(1, cache.writeAbortCount());
+    assertEquals(0, cache.writeSuccessCount());
+    Response response = get(server.url("/"));
     assertEquals("Request #2", response.body().string());
-    assertEquals(1, cache.getWriteAbortCount());
-    assertEquals(1, cache.getWriteSuccessCount());
+    assertEquals(1, cache.writeAbortCount());
+    assertEquals(1, cache.writeSuccessCount());
   }
 
   @Test public void clientPrematureDisconnectWithContentLengthHeader() throws IOException {
@@ -525,7 +558,7 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
     server.enqueue(new MockResponse()
         .setBody("Request #2"));
 
-    Response response1 = get(server.getUrl("/"));
+    Response response1 = get(server.url("/"));
     BufferedSource in = response1.body().source();
     assertEquals("ABCDE", in.readUtf8(5));
     in.close();
@@ -535,12 +568,12 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
     } catch (IllegalStateException expected) {
     }
 
-    assertEquals(1, cache.getWriteAbortCount());
-    assertEquals(0, cache.getWriteSuccessCount());
-    Response response2 = get(server.getUrl("/"));
+    assertEquals(1, cache.writeAbortCount());
+    assertEquals(0, cache.writeSuccessCount());
+    Response response2 = get(server.url("/"));
     assertEquals("Request #2", response2.body().string());
-    assertEquals(1, cache.getWriteAbortCount());
-    assertEquals(1, cache.getWriteSuccessCount());
+    assertEquals(1, cache.writeAbortCount());
+    assertEquals(1, cache.writeSuccessCount());
   }
 
   @Test public void defaultExpirationDateFullyCachedForLessThan24Hours() throws Exception {
@@ -553,7 +586,7 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
         .addHeader("Date: " + formatDate(-5, TimeUnit.SECONDS))
         .setBody("A"));
 
-    URL url = server.getUrl("/");
+    HttpUrl url = server.url("/");
     Response response1 = get(url);
     assertEquals("A", response1.body().string());
 
@@ -584,8 +617,8 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
         .addHeader("Date: " + formatDate(-5, TimeUnit.DAYS))
         .setBody("A"));
 
-    assertEquals("A", get(server.getUrl("/")).body().string());
-    Response response = get(server.getUrl("/"));
+    assertEquals("A", get(server.url("/")).body().string());
+    Response response = get(server.url("/"));
     assertEquals("A", response.body().string());
     assertEquals("113 HttpURLConnection \"Heuristic expiration\"", response.header("Warning"));
   }
@@ -598,7 +631,7 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    URL url = server.getUrl("/?foo=bar");
+    HttpUrl url = server.url("/").newBuilder().addQueryParameter("foo", "bar").build();
     assertEquals("A", get(url).body().string());
     assertEquals("B", get(url).body().string());
   }
@@ -722,7 +755,7 @@ private void testRequestMethod(String requestMethod, boolean expectCached) throw
     server.enqueue(new MockResponse()
         .addHeader("X-Response-ID: 2"));
 
-    URL url = server.getUrl("/");
+    HttpUrl url = server.url("/");
 
     Request request = new Request.Builder()
         .url(url)
@@ -743,8 +776,8 @@ private void testRequestMethod(String requestMethod, boolean expectCached) throw
 
   private RequestBody requestBodyOrNull(String requestMethod) {
     return (requestMethod.equals("POST") || requestMethod.equals("PUT"))
-          ? RequestBody.create(MediaType.parse("text/plain"), "foo")
-          : null;
+        ? RequestBody.create(MediaType.parse("text/plain"), "foo")
+        : null;
   }
 
   @Test public void postInvalidatesCache() throws Exception {
@@ -771,7 +804,7 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
     server.enqueue(new MockResponse()
         .setBody("C"));
 
-    URL url = server.getUrl("/");
+    HttpUrl url = server.url("/");
 
     assertEquals("A", get(url).body().string());
 
@@ -798,7 +831,7 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
     server.enqueue(new MockResponse()
         .setBody("C"));
 
-    URL url = server.getUrl("/");
+    HttpUrl url = server.url("/");
 
     assertEquals("A", get(url).body().string());
 
@@ -887,7 +920,7 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
     server.enqueue(new MockResponse()
         .setBody("BB"));
 
-    URL url = server.getUrl("/");
+    HttpUrl url = server.url("/");
 
     Request request = new Request.Builder()
         .url(url)
@@ -908,7 +941,7 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
         .setBody("B")
         .addHeader("Last-Modified: " + formatDate(-4, TimeUnit.HOURS)));
 
-    URL url = server.getUrl("/");
+    HttpUrl url = server.url("/");
 
     assertEquals("A", get(url).body().string());
     assertEquals("A", get(url).body().string());
@@ -923,14 +956,14 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
         .setBody("B"));
 
     Request request1 = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .cacheControl(new CacheControl.Builder().noStore().build())
         .build();
     Response response1 = client.newCall(request1).execute();
     assertEquals("A", response1.body().string());
 
     Request request2 = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .build();
     Response response2 = client.newCall(request2).execute();
     assertEquals("B", response2.body().string());
@@ -960,9 +993,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     // At least three request/response pairs are required because after the first request is cached
     // a different execution path might be taken. Thus modifications to the cache applied during
     // the second request might not be visible until another request is performed.
-    assertEquals("ABCABCABC", get(server.getUrl("/")).body().string());
-    assertEquals("ABCABCABC", get(server.getUrl("/")).body().string());
-    assertEquals("ABCABCABC", get(server.getUrl("/")).body().string());
+    assertEquals("ABCABCABC", get(server.url("/")).body().string());
+    assertEquals("ABCABCABC", get(server.url("/")).body().string());
+    assertEquals("ABCABCABC", get(server.url("/")).body().string());
   }
 
   @Test public void notModifiedSpecifiesEncoding() throws Exception {
@@ -977,9 +1010,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     server.enqueue(new MockResponse()
         .setBody("DEFDEFDEF"));
 
-    assertEquals("ABCABCABC", get(server.getUrl("/")).body().string());
-    assertEquals("ABCABCABC", get(server.getUrl("/")).body().string());
-    assertEquals("DEFDEFDEF", get(server.getUrl("/")).body().string());
+    assertEquals("ABCABCABC", get(server.url("/")).body().string());
+    assertEquals("ABCABCABC", get(server.url("/")).body().string());
+    assertEquals("DEFDEFDEF", get(server.url("/")).body().string());
   }
 
   /** https://github.com/square/okhttp/issues/947 */
@@ -992,8 +1025,8 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     server.enqueue(new MockResponse()
         .setBody("FAIL"));
 
-    assertEquals("ABCABCABC", get(server.getUrl("/")).body().string());
-    assertEquals("ABCABCABC", get(server.getUrl("/")).body().string());
+    assertEquals("ABCABCABC", get(server.url("/")).body().string());
+    assertEquals("ABCABCABC", get(server.url("/")).body().string());
   }
 
   @Test public void conditionalCacheHitIsNotDoublePooled() throws Exception {
@@ -1004,13 +1037,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .clearHeaders()
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    ConnectionPool pool = ConnectionPool.getDefault();
-    pool.evictAll();
-    client.setConnectionPool(pool);
-
-    assertEquals("A", get(server.getUrl("/")).body().string());
-    assertEquals("A", get(server.getUrl("/")).body().string());
-    assertEquals(1, client.getConnectionPool().getConnectionCount());
+    assertEquals("A", get(server.url("/")).body().string());
+    assertEquals("A", get(server.url("/")).body().string());
+    assertEquals(1, client.connectionPool().idleConnectionCount());
   }
 
   @Test public void expiresDateBeforeModifiedDate() throws Exception {
@@ -1028,10 +1057,10 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    assertEquals("A", get(server.getUrl("/")).body().string());
+    assertEquals("A", get(server.url("/")).body().string());
 
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .header("Cache-Control", "max-age=30")
         .build();
     Response response = client.newCall(request).execute();
@@ -1046,10 +1075,10 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    assertEquals("A", get(server.getUrl("/")).body().string());
+    assertEquals("A", get(server.url("/")).body().string());
 
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .header("Cache-Control", "min-fresh=120")
         .build();
     Response response = client.newCall(request).execute();
@@ -1064,10 +1093,10 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    assertEquals("A", get(server.getUrl("/")).body().string());
+    assertEquals("A", get(server.url("/")).body().string());
 
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .header("Cache-Control", "max-stale=180")
         .build();
     Response response = client.newCall(request).execute();
@@ -1084,11 +1113,11 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    assertEquals("A", get(server.getUrl("/")).body().string());
+    assertEquals("A", get(server.url("/")).body().string());
 
     // With max-stale, we'll return that stale response.
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .header("Cache-Control", "max-stale")
         .build();
     Response response = client.newCall(request).execute();
@@ -1104,10 +1133,10 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    assertEquals("A", get(server.getUrl("/")).body().string());
+    assertEquals("A", get(server.url("/")).body().string());
 
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .header("Cache-Control", "max-stale=180")
         .build();
     Response response = client.newCall(request).execute();
@@ -1118,15 +1147,15 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     // (no responses enqueued)
 
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .header("Cache-Control", "only-if-cached")
         .build();
     Response response = client.newCall(request).execute();
     assertTrue(response.body().source().exhausted());
     assertEquals(504, response.code());
-    assertEquals(1, cache.getRequestCount());
-    assertEquals(0, cache.getNetworkCount());
-    assertEquals(0, cache.getHitCount());
+    assertEquals(1, cache.requestCount());
+    assertEquals(0, cache.networkCount());
+    assertEquals(0, cache.hitCount());
   }
 
   @Test public void requestOnlyIfCachedWithFullResponseCached() throws IOException {
@@ -1135,16 +1164,16 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .addHeader("Cache-Control: max-age=30")
         .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
 
-    assertEquals("A", get(server.getUrl("/")).body().string());
+    assertEquals("A", get(server.url("/")).body().string());
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .header("Cache-Control", "only-if-cached")
         .build();
     Response response = client.newCall(request).execute();
     assertEquals("A", response.body().string());
-    assertEquals(2, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(1, cache.getHitCount());
+    assertEquals(2, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(1, cache.hitCount());
   }
 
   @Test public void requestOnlyIfCachedWithConditionalResponseCached() throws IOException {
@@ -1153,34 +1182,34 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .addHeader("Cache-Control: max-age=30")
         .addHeader("Date: " + formatDate(-1, TimeUnit.MINUTES)));
 
-    assertEquals("A", get(server.getUrl("/")).body().string());
+    assertEquals("A", get(server.url("/")).body().string());
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .header("Cache-Control", "only-if-cached")
         .build();
     Response response = client.newCall(request).execute();
     assertTrue(response.body().source().exhausted());
     assertEquals(504, response.code());
-    assertEquals(2, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(0, cache.getHitCount());
+    assertEquals(2, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(0, cache.hitCount());
   }
 
   @Test public void requestOnlyIfCachedWithUnhelpfulResponseCached() throws IOException {
     server.enqueue(new MockResponse()
         .setBody("A"));
 
-    assertEquals("A", get(server.getUrl("/")).body().string());
+    assertEquals("A", get(server.url("/")).body().string());
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .header("Cache-Control", "only-if-cached")
         .build();
     Response response = client.newCall(request).execute();
     assertTrue(response.body().source().exhausted());
     assertEquals(504, response.code());
-    assertEquals(2, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(0, cache.getHitCount());
+    assertEquals(2, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(0, cache.hitCount());
   }
 
   @Test public void requestCacheControlNoCache() throws Exception {
@@ -1192,7 +1221,7 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    URL url = server.getUrl("/");
+    HttpUrl url = server.url("/");
     assertEquals("A", get(url).body().string());
     Request request = new Request.Builder()
         .url(url)
@@ -1211,7 +1240,7 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    URL url = server.getUrl("/");
+    HttpUrl url = server.url("/");
     assertEquals("A", get(url).body().string());
     Request request = new Request.Builder()
         .url(url)
@@ -1249,7 +1278,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    URL url = server.getUrl("/");
+    HttpUrl url = server.url("/");
     assertEquals("A", get(url).body().string());
 
     Request request = new Request.Builder()
@@ -1265,8 +1294,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
   }
 
   /**
-   * For Last-Modified and Date headers, we should echo the date back in the
-   * exact format we were served.
+   * For Last-Modified and Date headers, we should echo the date back in the exact format we were
+   * served.
    */
   @Test public void retainServedDateFormat() throws Exception {
     // Serve a response with a non-standard date format that OkHttp supports.
@@ -1285,8 +1314,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    assertEquals("A", get(server.getUrl("/")).body().string());
-    assertEquals("A", get(server.getUrl("/")).body().string());
+    assertEquals("A", get(server.url("/")).body().string());
+    assertEquals("A", get(server.url("/")).body().string());
 
     // The first request has no conditions.
     RecordedRequest request1 = server.takeRequest();
@@ -1302,7 +1331,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .header("If-Modified-Since", formatDate(-24, TimeUnit.HOURS))
         .build();
     Response response = client.newCall(request).execute();
@@ -1317,7 +1346,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    URL url = server.getUrl("/");
+    HttpUrl url = server.url("/");
     Request request = new Request.Builder()
         .url(url)
         .header("Authorization", "password")
@@ -1335,8 +1364,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    assertEquals("A", get(server.getUrl("/foo")).body().string());
-    assertEquals("B", get(server.getUrl("/bar")).body().string());
+    assertEquals("A", get(server.url("/foo")).body().string());
+    assertEquals("B", get(server.url("/bar")).body().string());
   }
 
   @Test public void connectionIsReturnedToPoolAfterConditionalSuccess() throws Exception {
@@ -1349,9 +1378,9 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    assertEquals("A", get(server.getUrl("/a")).body().string());
-    assertEquals("A", get(server.getUrl("/a")).body().string());
-    assertEquals("B", get(server.getUrl("/b")).body().string());
+    assertEquals("A", get(server.url("/a")).body().string());
+    assertEquals("A", get(server.url("/a")).body().string());
+    assertEquals("B", get(server.url("/b")).body().string());
 
     assertEquals(0, server.takeRequest().getSequenceNumber());
     assertEquals(1, server.takeRequest().getSequenceNumber());
@@ -1368,15 +1397,15 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setBody("C"));
 
-    assertEquals("A", get(server.getUrl("/")).body().string());
-    assertEquals(1, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(0, cache.getHitCount());
-    assertEquals("B", get(server.getUrl("/")).body().string());
-    assertEquals("C", get(server.getUrl("/")).body().string());
-    assertEquals(3, cache.getRequestCount());
-    assertEquals(3, cache.getNetworkCount());
-    assertEquals(0, cache.getHitCount());
+    assertEquals("A", get(server.url("/")).body().string());
+    assertEquals(1, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(0, cache.hitCount());
+    assertEquals("B", get(server.url("/")).body().string());
+    assertEquals("C", get(server.url("/")).body().string());
+    assertEquals(3, cache.requestCount());
+    assertEquals(3, cache.networkCount());
+    assertEquals(0, cache.hitCount());
   }
 
   @Test public void statisticsConditionalCacheHit() throws Exception {
@@ -1389,15 +1418,15 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    assertEquals("A", get(server.getUrl("/")).body().string());
-    assertEquals(1, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(0, cache.getHitCount());
-    assertEquals("A", get(server.getUrl("/")).body().string());
-    assertEquals("A", get(server.getUrl("/")).body().string());
-    assertEquals(3, cache.getRequestCount());
-    assertEquals(3, cache.getNetworkCount());
-    assertEquals(2, cache.getHitCount());
+    assertEquals("A", get(server.url("/")).body().string());
+    assertEquals(1, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(0, cache.hitCount());
+    assertEquals("A", get(server.url("/")).body().string());
+    assertEquals("A", get(server.url("/")).body().string());
+    assertEquals(3, cache.requestCount());
+    assertEquals(3, cache.networkCount());
+    assertEquals(2, cache.hitCount());
   }
 
   @Test public void statisticsFullCacheHit() throws Exception {
@@ -1405,15 +1434,15 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .addHeader("Cache-Control: max-age=60")
         .setBody("A"));
 
-    assertEquals("A", get(server.getUrl("/")).body().string());
-    assertEquals(1, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(0, cache.getHitCount());
-    assertEquals("A", get(server.getUrl("/")).body().string());
-    assertEquals("A", get(server.getUrl("/")).body().string());
-    assertEquals(3, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(2, cache.getHitCount());
+    assertEquals("A", get(server.url("/")).body().string());
+    assertEquals(1, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(0, cache.hitCount());
+    assertEquals("A", get(server.url("/")).body().string());
+    assertEquals("A", get(server.url("/")).body().string());
+    assertEquals(3, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(2, cache.hitCount());
   }
 
   @Test public void varyMatchesChangedRequestHeaderField() throws Exception {
@@ -1424,7 +1453,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    URL url = server.getUrl("/");
+    HttpUrl url = server.url("/");
     Request frRequest = new Request.Builder()
         .url(url)
         .header("Accept-Language", "fr-CA")
@@ -1448,7 +1477,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    URL url = server.getUrl("/");
+    HttpUrl url = server.url("/");
     Request request = new Request.Builder()
         .url(url)
         .header("Accept-Language", "fr-CA")
@@ -1471,8 +1500,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    assertEquals("A", get(server.getUrl("/")).body().string());
-    assertEquals("A", get(server.getUrl("/")).body().string());
+    assertEquals("A", get(server.url("/")).body().string());
+    assertEquals("A", get(server.url("/")).body().string());
   }
 
   @Test public void varyMatchesAddedRequestHeaderField() throws Exception {
@@ -1483,10 +1512,9 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    assertEquals("A", get(server.getUrl("/")).body().string());
+    assertEquals("A", get(server.url("/")).body().string());
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
-        .header("Foo", "bar")
+        .url(server.url("/")).header("Foo", "bar")
         .build();
     Response response = client.newCall(request).execute();
     assertEquals("B", response.body().string());
@@ -1501,12 +1529,11 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setBody("B"));
 
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
-        .header("Foo", "bar")
+        .url(server.url("/")).header("Foo", "bar")
         .build();
     Response fooresponse = client.newCall(request).execute();
     assertEquals("A", fooresponse.body().string());
-    assertEquals("B", get(server.getUrl("/")).body().string());
+    assertEquals("B", get(server.url("/")).body().string());
   }
 
   @Test public void varyFieldsAreCaseInsensitive() throws Exception {
@@ -1517,7 +1544,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    URL url = server.getUrl("/");
+    HttpUrl url = server.url("/");
     Request request = new Request.Builder()
         .url(url)
         .header("Accept-Language", "fr-CA")
@@ -1541,7 +1568,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    URL url = server.getUrl("/");
+    HttpUrl url = server.url("/");
     Request request = new Request.Builder()
         .url(url)
         .header("Accept-Language", "fr-CA")
@@ -1569,7 +1596,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    URL url = server.getUrl("/");
+    HttpUrl url = server.url("/");
     Request frRequest = new Request.Builder()
         .url(url)
         .header("Accept-Language", "fr-CA")
@@ -1596,7 +1623,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    URL url = server.getUrl("/");
+    HttpUrl url = server.url("/");
     Request request1 = new Request.Builder()
         .url(url)
         .addHeader("Accept-Language", "fr-CA, fr-FR")
@@ -1622,7 +1649,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    URL url = server.getUrl("/");
+    HttpUrl url = server.url("/");
     Request request1 = new Request.Builder()
         .url(url)
         .addHeader("Accept-Language", "fr-CA, fr-FR")
@@ -1641,19 +1668,19 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
   }
 
   @Test public void varyAsterisk() throws Exception {
-    server.enqueue( new MockResponse()
+    server.enqueue(new MockResponse()
         .addHeader("Cache-Control: max-age=60")
         .addHeader("Vary: *")
         .setBody("A"));
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    assertEquals("A", get(server.getUrl("/")).body().string());
-    assertEquals("B", get(server.getUrl("/")).body().string());
+    assertEquals("A", get(server.url("/")).body().string());
+    assertEquals("B", get(server.url("/")).body().string());
   }
 
   @Test public void varyAndHttps() throws Exception {
-    server.useHttps(sslContext.getSocketFactory(), false);
+    server.useHttps(sslClient.socketFactory, false);
     server.enqueue(new MockResponse()
         .addHeader("Cache-Control: max-age=60")
         .addHeader("Vary: Accept-Language")
@@ -1661,10 +1688,12 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+    client = client.newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
+        .build();
 
-    URL url = server.getUrl("/");
+    HttpUrl url = server.url("/");
     Request request1 = new Request.Builder()
         .url(url)
         .header("Accept-Language", "en-US")
@@ -1681,20 +1710,25 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
   }
 
   @Test public void cachePlusCookies() throws Exception {
+    RecordingCookieJar cookieJar = new RecordingCookieJar();
+    client = client.newBuilder()
+        .cookieJar(cookieJar)
+        .build();
+
     server.enqueue(new MockResponse()
-        .addHeader("Set-Cookie: a=FIRST; domain=" + server.getCookieDomain() + ";")
+        .addHeader("Set-Cookie: a=FIRST")
         .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Cache-Control: max-age=0")
         .setBody("A"));
     server.enqueue(new MockResponse()
-        .addHeader("Set-Cookie: a=SECOND; domain=" + server.getCookieDomain() + ";")
+        .addHeader("Set-Cookie: a=SECOND")
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    URL url = server.getUrl("/");
+    HttpUrl url = server.url("/");
     assertEquals("A", get(url).body().string());
-    assertCookies(url, "a=FIRST");
+    cookieJar.assertResponseCookies("a=FIRST; path=/");
     assertEquals("A", get(url).body().string());
-    assertCookies(url, "a=SECOND");
+    cookieJar.assertResponseCookies("a=SECOND; path=/");
   }
 
   @Test public void getHeadersReturnsNetworkEndToEndHeaders() throws Exception {
@@ -1707,11 +1741,11 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .addHeader("Allow: GET, HEAD, PUT")
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    Response response1 = get(server.getUrl("/"));
+    Response response1 = get(server.url("/"));
     assertEquals("A", response1.body().string());
     assertEquals("GET, HEAD", response1.header("Allow"));
 
-    Response response2 = get(server.getUrl("/"));
+    Response response2 = get(server.url("/"));
     assertEquals("A", response2.body().string());
     assertEquals("GET, HEAD, PUT", response2.header("Allow"));
   }
@@ -1726,11 +1760,11 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .addHeader("Transfer-Encoding: none")
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    Response response1 = get(server.getUrl("/"));
+    Response response1 = get(server.url("/"));
     assertEquals("A", response1.body().string());
     assertEquals("identity", response1.header("Transfer-Encoding"));
 
-    Response response2 = get(server.getUrl("/"));
+    Response response2 = get(server.url("/"));
     assertEquals("A", response2.body().string());
     assertEquals("identity", response2.header("Transfer-Encoding"));
   }
@@ -1744,11 +1778,11 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    Response response1 = get(server.getUrl("/"));
+    Response response1 = get(server.url("/"));
     assertEquals("A", response1.body().string());
     assertEquals("199 test danger", response1.header("Warning"));
 
-    Response response2 = get(server.getUrl("/"));
+    Response response2 = get(server.url("/"));
     assertEquals("A", response2.body().string());
     assertEquals(null, response2.header("Warning"));
   }
@@ -1762,29 +1796,29 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    Response response1 = get(server.getUrl("/"));
+    Response response1 = get(server.url("/"));
     assertEquals("A", response1.body().string());
     assertEquals("299 test danger", response1.header("Warning"));
 
-    Response response2 = get(server.getUrl("/"));
+    Response response2 = get(server.url("/"));
     assertEquals("A", response2.body().string());
     assertEquals("299 test danger", response2.header("Warning"));
   }
 
-  public void assertCookies(URL url, String... expectedCookies) throws Exception {
+  public void assertCookies(HttpUrl url, String... expectedCookies) throws Exception {
     List<String> actualCookies = new ArrayList<>();
-    for (HttpCookie cookie : cookieManager.getCookieStore().get(url.toURI())) {
+    for (HttpCookie cookie : cookieManager.getCookieStore().get(url.uri())) {
       actualCookies.add(cookie.toString());
     }
     assertEquals(Arrays.asList(expectedCookies), actualCookies);
   }
 
-  @Test public void doNotCachePartialResponse() throws Exception  {
+  @Test public void doNotCachePartialResponse() throws Exception {
     assertNotCached(new MockResponse()
-            .setResponseCode(HttpURLConnection.HTTP_PARTIAL)
-            .addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
-            .addHeader("Content-Range: bytes 100-100/200")
-            .addHeader("Cache-Control: max-age=60"));
+        .setResponseCode(HttpURLConnection.HTTP_PARTIAL)
+        .addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
+        .addHeader("Content-Range: bytes 100-100/200")
+        .addHeader("Cache-Control: max-age=60"));
   }
 
   @Test public void conditionalHitUpdatesCache() throws Exception {
@@ -1800,18 +1834,18 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
         .setBody("B"));
 
     // cache miss; seed the cache
-    Response response1 = get(server.getUrl("/a"));
+    Response response1 = get(server.url("/a"));
     assertEquals("A", response1.body().string());
     assertEquals(null, response1.header("Allow"));
 
     // conditional cache hit; update the cache
-    Response response2 = get(server.getUrl("/a"));
+    Response response2 = get(server.url("/a"));
     assertEquals(HttpURLConnection.HTTP_OK, response2.code());
     assertEquals("A", response2.body().string());
     assertEquals("GET, HEAD", response2.header("Allow"));
 
     // full cache hit
-    Response response3 = get(server.getUrl("/a"));
+    Response response3 = get(server.url("/a"));
     assertEquals("A", response3.body().string());
     assertEquals("GET, HEAD", response3.header("Allow"));
 
@@ -1824,10 +1858,9 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
         .addHeader("Cache-Control: max-age=30")
         .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
 
-    assertEquals("A", get(server.getUrl("/")).body().string());
+    assertEquals("A", get(server.url("/")).body().string());
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
-        .header("Cache-Control", "only-if-cached")
+        .url(server.url("/")).header("Cache-Control", "only-if-cached")
         .build();
     Response response = client.newCall(request).execute();
     assertEquals("A", response.body().string());
@@ -1843,8 +1876,8 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
         .addHeader("Cache-Control: max-age=30")
         .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
 
-    assertEquals("A", get(server.getUrl("/")).body().string());
-    Response response = get(server.getUrl("/"));
+    assertEquals("A", get(server.url("/")).body().string());
+    Response response = get(server.url("/"));
     assertEquals("B", response.body().string());
   }
 
@@ -1856,8 +1889,8 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
     server.enqueue(new MockResponse()
         .setResponseCode(304));
 
-    assertEquals("A", get(server.getUrl("/")).body().string());
-    Response response = get(server.getUrl("/"));
+    assertEquals("A", get(server.url("/")).body().string());
+    Response response = get(server.url("/"));
     assertEquals("A", response.body().string());
   }
 
@@ -1865,7 +1898,7 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
     server.enqueue(new MockResponse()
         .setBody("A"));
 
-    Response response = get(server.getUrl("/"));
+    Response response = get(server.url("/"));
     assertEquals("A", response.body().string());
   }
 
@@ -1877,15 +1910,15 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
         .setHeaders(headers.build())
         .setBody("body"));
 
-    Response response = get(server.getUrl("/"));
+    Response response = get(server.url("/"));
     assertEquals("A", response.header(""));
+    assertEquals("body", response.body().string());
   }
 
   /**
-   * Old implementations of OkHttp's response cache wrote header fields like
-   * ":status: 200 OK". This broke our cached response parser because it split
-   * on the first colon. This regression test exists to help us read these old
-   * bad cache entries.
+   * Old implementations of OkHttp's response cache wrote header fields like ":status: 200 OK". This
+   * broke our cached response parser because it split on the first colon. This regression test
+   * exists to help us read these old bad cache entries.
    *
    * https://github.com/square/okhttp/issues/227
    */
@@ -1895,7 +1928,7 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
         .clearHeaders()
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    URL url = server.getUrl("/");
+    HttpUrl url = server.url("/");
     String urlKey = Util.md5Hex(url.toString());
     String entryMetadata = ""
         + "" + url + "\n"
@@ -1929,11 +1962,13 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
         + "2\n"
         + "\n"
         + "CLEAN " + urlKey + " " + entryMetadata.length() + " " + entryBody.length() + "\n";
-    writeFile(cache.getDirectory(), urlKey + ".0", entryMetadata);
-    writeFile(cache.getDirectory(), urlKey + ".1", entryBody);
-    writeFile(cache.getDirectory(), "journal", journalBody);
-    cache = new Cache(cache.getDirectory(), Integer.MAX_VALUE);
-    client.setCache(cache);
+    writeFile(cache.directory(), urlKey + ".0", entryMetadata);
+    writeFile(cache.directory(), urlKey + ".1", entryBody);
+    writeFile(cache.directory(), "journal", journalBody);
+    cache = new Cache(cache.directory(), Integer.MAX_VALUE, fileSystem);
+    client = client.newBuilder()
+        .cache(cache)
+        .build();
 
     Response response = get(url);
     assertEquals(entryBody, response.body().string());
@@ -1941,6 +1976,139 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
     assertEquals("foo", response.header("etag"));
   }
 
+  /** Exercise the cache format in OkHttp 2.7 and all earlier releases. */
+  @Test public void testGoldenCacheHttpsResponseOkHttp27() throws Exception {
+    HttpUrl url = server.url("/");
+    String urlKey = Util.md5Hex(url.toString());
+    String entryMetadata = ""
+        + "" + url + "\n"
+        + "GET\n"
+        + "0\n"
+        + "HTTP/1.1 200 OK\n"
+        + "4\n"
+        + "Content-Length: 3\n"
+        + "OkHttp-Received-Millis: " + System.currentTimeMillis() + "\n"
+        + "OkHttp-Sent-Millis: " + System.currentTimeMillis() + "\n"
+        + "Cache-Control: max-age=60\n"
+        + "\n"
+        + "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\n"
+        + "1\n"
+        + "MIIBnDCCAQWgAwIBAgIBATANBgkqhkiG9w0BAQsFADAUMRIwEAYDVQQDEwlsb2NhbGhvc3QwHhcNMTUxMjIyMDEx"
+        + "MTQwWhcNMTUxMjIzMDExMTQwWjAUMRIwEAYDVQQDEwlsb2NhbGhvc3QwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJ"
+        + "AoGBAJTn2Dh8xYmegvpOSmsKb2Os6Cxf1L4fYbnHr/turInUD5r1P7ZAuxurY880q3GT5bUDoirS3IfucddrT1Ac"
+        + "AmUzEmk/FDjggiP8DlxFkY/XwXBlhRDVIp/mRuASPMGInckc0ZaixOkRFyrxADj+r1eaSmXCIvV5yTY6IaIokLj1"
+        + "AgMBAAEwDQYJKoZIhvcNAQELBQADgYEAFblnedqtfRqI9j2WDyPPoG0NTZf9xwjeUu+ju+Ktty8u9k7Lgrrd/DH2"
+        + "mQEtBD1Ctvp91MJfAClNg3faZzwClUyu5pd0QXRZEUwSwZQNen2QWDHRlVsItclBJ4t+AJLqTbwofWi4m4K8REOl"
+        + "593hD55E4+lY22JZiVQyjsQhe6I=\n"
+        + "0\n";
+    String entryBody = "abc";
+    String journalBody = ""
+        + "libcore.io.DiskLruCache\n"
+        + "1\n"
+        + "201105\n"
+        + "2\n"
+        + "\n"
+        + "DIRTY " + urlKey + "\n"
+        + "CLEAN " + urlKey + " " + entryMetadata.length() + " " + entryBody.length() + "\n";
+    writeFile(cache.directory(), urlKey + ".0", entryMetadata);
+    writeFile(cache.directory(), urlKey + ".1", entryBody);
+    writeFile(cache.directory(), "journal", journalBody);
+    cache.close();
+    cache = new Cache(cache.directory(), Integer.MAX_VALUE, fileSystem);
+    client = client.newBuilder()
+        .cache(cache)
+        .build();
+
+    Response response = get(url);
+    assertEquals(entryBody, response.body().string());
+    assertEquals("3", response.header("Content-Length"));
+  }
+
+  /** The TLS version is present in OkHttp 3.0 and beyond. */
+  @Test public void testGoldenCacheHttpsResponseOkHttp30() throws Exception {
+    HttpUrl url = server.url("/");
+    String urlKey = Util.md5Hex(url.toString());
+    String entryMetadata = ""
+        + "" + url + "\n"
+        + "GET\n"
+        + "0\n"
+        + "HTTP/1.1 200 OK\n"
+        + "4\n"
+        + "Content-Length: 3\n"
+        + "OkHttp-Received-Millis: " + System.currentTimeMillis() + "\n"
+        + "OkHttp-Sent-Millis: " + System.currentTimeMillis() + "\n"
+        + "Cache-Control: max-age=60\n"
+        + "\n"
+        + "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\n"
+        + "1\n"
+        + "MIIBnDCCAQWgAwIBAgIBATANBgkqhkiG9w0BAQsFADAUMRIwEAYDVQQDEwlsb2NhbGhvc3QwHhcNMTUxMjIyMDEx"
+        + "MTQwWhcNMTUxMjIzMDExMTQwWjAUMRIwEAYDVQQDEwlsb2NhbGhvc3QwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJ"
+        + "AoGBAJTn2Dh8xYmegvpOSmsKb2Os6Cxf1L4fYbnHr/turInUD5r1P7ZAuxurY880q3GT5bUDoirS3IfucddrT1Ac"
+        + "AmUzEmk/FDjggiP8DlxFkY/XwXBlhRDVIp/mRuASPMGInckc0ZaixOkRFyrxADj+r1eaSmXCIvV5yTY6IaIokLj1"
+        + "AgMBAAEwDQYJKoZIhvcNAQELBQADgYEAFblnedqtfRqI9j2WDyPPoG0NTZf9xwjeUu+ju+Ktty8u9k7Lgrrd/DH2"
+        + "mQEtBD1Ctvp91MJfAClNg3faZzwClUyu5pd0QXRZEUwSwZQNen2QWDHRlVsItclBJ4t+AJLqTbwofWi4m4K8REOl"
+        + "593hD55E4+lY22JZiVQyjsQhe6I=\n"
+        + "0\n"
+        + "TLSv1.2\n";
+    String entryBody = "abc";
+    String journalBody = ""
+        + "libcore.io.DiskLruCache\n"
+        + "1\n"
+        + "201105\n"
+        + "2\n"
+        + "\n"
+        + "DIRTY " + urlKey + "\n"
+        + "CLEAN " + urlKey + " " + entryMetadata.length() + " " + entryBody.length() + "\n";
+    writeFile(cache.directory(), urlKey + ".0", entryMetadata);
+    writeFile(cache.directory(), urlKey + ".1", entryBody);
+    writeFile(cache.directory(), "journal", journalBody);
+    cache.close();
+    cache = new Cache(cache.directory(), Integer.MAX_VALUE, fileSystem);
+    client = client.newBuilder()
+        .cache(cache)
+        .build();
+
+    Response response = get(url);
+    assertEquals(entryBody, response.body().string());
+    assertEquals("3", response.header("Content-Length"));
+  }
+
+  @Test public void testGoldenCacheHttpResponseOkHttp30() throws Exception {
+    HttpUrl url = server.url("/");
+    String urlKey = Util.md5Hex(url.toString());
+    String entryMetadata = ""
+        + "" + url + "\n"
+        + "GET\n"
+        + "0\n"
+        + "HTTP/1.1 200 OK\n"
+        + "4\n"
+        + "Cache-Control: max-age=60\n"
+        + "Content-Length: 3\n"
+        + "OkHttp-Received-Millis: " + System.currentTimeMillis() + "\n"
+        + "OkHttp-Sent-Millis: " + System.currentTimeMillis() + "\n";
+    String entryBody = "abc";
+    String journalBody = ""
+        + "libcore.io.DiskLruCache\n"
+        + "1\n"
+        + "201105\n"
+        + "2\n"
+        + "\n"
+        + "DIRTY " + urlKey + "\n"
+        + "CLEAN " + urlKey + " " + entryMetadata.length() + " " + entryBody.length() + "\n";
+    writeFile(cache.directory(), urlKey + ".0", entryMetadata);
+    writeFile(cache.directory(), urlKey + ".1", entryBody);
+    writeFile(cache.directory(), "journal", journalBody);
+    cache.close();
+    cache = new Cache(cache.directory(), Integer.MAX_VALUE, fileSystem);
+    client = client.newBuilder()
+        .cache(cache)
+        .build();
+
+    Response response = get(url);
+    assertEquals(entryBody, response.body().string());
+    assertEquals("3", response.header("Content-Length"));
+  }
+
   @Test public void evictAll() throws Exception {
     server.enqueue(new MockResponse()
         .addHeader("Cache-Control: max-age=60")
@@ -1948,10 +2116,10 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    URL url = server.getUrl("/");
+    HttpUrl url = server.url("/");
     assertEquals("A", get(url).body().string());
-    client.getCache().evictAll();
-    assertEquals(0, client.getCache().getSize());
+    client.cache().evictAll();
+    assertEquals(0, client.cache().size());
     assertEquals("B", get(url).body().string());
   }
 
@@ -1963,16 +2131,17 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
     // Seed the cache.
-    URL url = server.getUrl("/");
+    HttpUrl url = server.url("/");
     assertEquals("A", get(url).body().string());
 
     final AtomicReference<String> ifNoneMatch = new AtomicReference<>();
-    client.networkInterceptors().add(new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        ifNoneMatch.compareAndSet(null, chain.request().header("If-None-Match"));
-        return chain.proceed(chain.request());
-      }
-    });
+    client = client.newBuilder()
+        .addNetworkInterceptor(new Interceptor() {
+          @Override public Response intercept(Chain chain) throws IOException {
+            ifNoneMatch.compareAndSet(null, chain.request().header("If-None-Match"));
+            return chain.proceed(chain.request());
+          }
+        }).build();
 
     // Confirm the value is cached and intercepted.
     assertEquals("A", get(url).body().string());
@@ -1985,15 +2154,16 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
         .setBody("A"));
 
     // Seed the cache.
-    URL url = server.getUrl("/");
+    HttpUrl url = server.url("/");
     assertEquals("A", get(url).body().string());
 
     // Confirm the interceptor isn't exercised.
-    client.networkInterceptors().add(new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        throw new AssertionError();
-      }
-    });
+    client = client.newBuilder()
+        .addNetworkInterceptor(new Interceptor() {
+          @Override public Response intercept(Chain chain) throws IOException {
+            throw new AssertionError();
+          }
+        }).build();
     assertEquals("A", get(url).body().string());
   }
 
@@ -2001,17 +2171,17 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
     // Put some responses in the cache.
     server.enqueue(new MockResponse()
         .setBody("a"));
-    URL urlA = server.getUrl("/a");
+    HttpUrl urlA = server.url("/a");
     assertEquals("a", get(urlA).body().string());
 
     server.enqueue(new MockResponse()
         .setBody("b"));
-    URL urlB = server.getUrl("/b");
+    HttpUrl urlB = server.url("/b");
     assertEquals("b", get(urlB).body().string());
 
     server.enqueue(new MockResponse()
         .setBody("c"));
-    URL urlC = server.getUrl("/c");
+    HttpUrl urlC = server.url("/c");
     assertEquals("c", get(urlC).body().string());
 
     // Confirm the iterator returns those responses...
@@ -2037,7 +2207,7 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
     server.enqueue(new MockResponse()
         .addHeader("Cache-Control: max-age=60")
         .setBody("a"));
-    URL url = server.getUrl("/a");
+    HttpUrl url = server.url("/a");
     assertEquals("a", get(url).body().string());
 
     // Remove it with iteration.
@@ -2055,7 +2225,7 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
     // Put a response in the cache.
     server.enqueue(new MockResponse()
         .setBody("a"));
-    URL url = server.getUrl("/a");
+    HttpUrl url = server.url("/a");
     assertEquals("a", get(url).body().string());
 
     Iterator<String> i = cache.urls();
@@ -2071,7 +2241,7 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
     // Put a response in the cache.
     server.enqueue(new MockResponse()
         .setBody("a"));
-    URL url = server.getUrl("/a");
+    HttpUrl url = server.url("/a");
     assertEquals("a", get(url).body().string());
 
     Iterator<String> i = cache.urls();
@@ -2090,7 +2260,7 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
     // Put a response in the cache.
     server.enqueue(new MockResponse()
         .setBody("a"));
-    URL url = server.getUrl("/a");
+    HttpUrl url = server.url("/a");
     assertEquals("a", get(url).body().string());
 
     // The URL will remain available if hasNext() returned true...
@@ -2109,7 +2279,7 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
     // Put a response in the cache.
     server.enqueue(new MockResponse()
         .setBody("a"));
-    URL url = server.getUrl("/a");
+    HttpUrl url = server.url("/a");
     assertEquals("a", get(url).body().string());
 
     Iterator<String> i = cache.urls();
@@ -2124,24 +2294,72 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
     }
   }
 
-  private Response get(URL url) throws IOException {
+  /** Test https://github.com/square/okhttp/issues/1712. */
+  @Test public void conditionalMissUpdatesCache() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("ETag: v1")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+    server.enqueue(new MockResponse()
+        .addHeader("ETag: v2")
+        .setBody("B"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    HttpUrl url = server.url("/");
+    assertEquals("A", get(url).body().string());
+    assertEquals("A", get(url).body().string());
+    assertEquals("B", get(url).body().string());
+    assertEquals("B", get(url).body().string());
+
+    assertEquals(null, server.takeRequest().getHeader("If-None-Match"));
+    assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
+    assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
+    assertEquals("v2", server.takeRequest().getHeader("If-None-Match"));
+  }
+
+  @Test public void combinedCacheHeadersCanBeNonAscii() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=0")
+        .addHeaderLenient("Alpha", "α")
+        .addHeaderLenient("β", "Beta")
+        .setBody("abcd"));
+    server.enqueue(new MockResponse()
+        .addHeader("Transfer-Encoding: none")
+        .addHeaderLenient("Gamma", "Γ")
+        .addHeaderLenient("Δ", "Delta")
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    Response response1 = get(server.url("/"));
+    assertEquals("α", response1.header("Alpha"));
+    assertEquals("Beta", response1.header("β"));
+    assertEquals("abcd", response1.body().string());
+
+    Response response2 = get(server.url("/"));
+    assertEquals("α", response2.header("Alpha"));
+    assertEquals("Beta", response2.header("β"));
+    assertEquals("Γ", response2.header("Gamma"));
+    assertEquals("Delta", response2.header("Δ"));
+    assertEquals("abcd", response2.body().string());
+  }
+  private Response get(HttpUrl url) throws IOException {
     Request request = new Request.Builder()
         .url(url)
         .build();
     return client.newCall(request).execute();
   }
 
-
   private void writeFile(File directory, String file, String content) throws IOException {
-    BufferedSink sink = Okio.buffer(Okio.sink(new File(directory, file)));
+    BufferedSink sink = Okio.buffer(fileSystem.sink(new File(directory, file)));
     sink.writeUtf8(content);
     sink.close();
   }
 
   /**
-   * @param delta the offset from the current date to use. Negative
-   * values yield dates in the past; positive values yield dates in the
-   * future.
+   * @param delta the offset from the current date to use. Negative values yield dates in the past;
+   * positive values yield dates in the future.
    */
   private String formatDate(long delta, TimeUnit timeUnit) {
     return formatDate(new Date(System.currentTimeMillis() + timeUnit.toMillis(delta)));
@@ -2158,7 +2376,7 @@ private void assertNotCached(MockResponse response) throws Exception {
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    URL url = server.getUrl("/");
+    HttpUrl url = server.url("/");
     assertEquals("A", get(url).body().string());
     assertEquals("B", get(url).body().string());
   }
@@ -2177,7 +2395,7 @@ private RecordedRequest assertConditionallyCached(MockResponse response) throws
         .setStatus("HTTP/1.1 200 C-OK")
         .setBody("C"));
 
-    URL valid = server.getUrl("/valid");
+    HttpUrl valid = server.url("/valid");
     Response response1 = get(valid);
     assertEquals("A", response1.body().string());
     assertEquals(HttpURLConnection.HTTP_OK, response1.code());
@@ -2187,7 +2405,7 @@ private RecordedRequest assertConditionallyCached(MockResponse response) throws
     assertEquals(HttpURLConnection.HTTP_OK, response2.code());
     assertEquals("A-OK", response2.message());
 
-    URL invalid = server.getUrl("/invalid");
+    HttpUrl invalid = server.url("/invalid");
     Response response3 = get(invalid);
     assertEquals("B", response3.body().string());
     assertEquals(HttpURLConnection.HTTP_OK, response3.code());
@@ -2205,15 +2423,14 @@ private void assertFullyCached(MockResponse response) throws Exception {
     server.enqueue(response.setBody("A"));
     server.enqueue(response.setBody("B"));
 
-    URL url = server.getUrl("/");
+    HttpUrl url = server.url("/");
     assertEquals("A", get(url).body().string());
     assertEquals("A", get(url).body().string());
   }
 
   /**
-   * Shortens the body of {@code response} but not the corresponding headers.
-   * Only useful to test how clients respond to the premature conclusion of
-   * the HTTP body.
+   * Shortens the body of {@code response} but not the corresponding headers. Only useful to test
+   * how clients respond to the premature conclusion of the HTTP body.
    */
   private MockResponse truncateViolently(MockResponse response, int numBytesToKeep) {
     response.setSocketPolicy(DISCONNECT_AT_END);
diff --git a/okhttp-tests/src/test/java/okhttp3/CallTest.java b/okhttp-tests/src/test/java/okhttp3/CallTest.java
new file mode 100644
index 0000000000..c2470c920b
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/CallTest.java
@@ -0,0 +1,2714 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InterruptedIOException;
+import java.net.CookieManager;
+import java.net.HttpCookie;
+import java.net.HttpURLConnection;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.ProtocolException;
+import java.net.Proxy;
+import java.net.ServerSocket;
+import java.net.SocketTimeoutException;
+import java.net.UnknownHostException;
+import java.net.UnknownServiceException;
+import java.security.cert.Certificate;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.Callable;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import java.util.concurrent.SynchronousQueue;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.logging.Logger;
+import javax.net.ServerSocketFactory;
+import javax.net.ssl.SSLHandshakeException;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import javax.net.ssl.SSLProtocolException;
+import javax.net.ssl.SSLSocket;
+import javax.net.ssl.SSLSocketFactory;
+import okhttp3.internal.DoubleInetAddressDns;
+import okhttp3.internal.RecordingOkAuthenticator;
+import okhttp3.internal.SingleInetAddressDns;
+import okhttp3.internal.Util;
+import okhttp3.internal.Version;
+import okhttp3.internal.http.RecordingProxySelector;
+import okhttp3.internal.io.InMemoryFileSystem;
+import okhttp3.internal.tls.SslClient;
+import okhttp3.mockwebserver.Dispatcher;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
+import okhttp3.mockwebserver.SocketPolicy;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.GzipSink;
+import okio.Okio;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import org.junit.rules.Timeout;
+
+import static java.net.CookiePolicy.ACCEPT_ORIGINAL_SERVER;
+import static okhttp3.TestUtil.defaultClient;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class CallTest {
+  @Rule public final TestRule timeout = new Timeout(30_000);
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final MockWebServer server2 = new MockWebServer();
+  @Rule public final InMemoryFileSystem fileSystem = new InMemoryFileSystem();
+
+  private SslClient sslClient = SslClient.localhost();
+  private OkHttpClient client = defaultClient();
+  private RecordingCallback callback = new RecordingCallback();
+  private TestLogHandler logHandler = new TestLogHandler();
+  private Cache cache = new Cache(new File("/cache/"), Integer.MAX_VALUE, fileSystem);
+  private ServerSocket nullServer;
+  private Logger logger = Logger.getLogger(OkHttpClient.class.getName());
+
+  @Before public void setUp() throws Exception {
+    logger.addHandler(logHandler);
+  }
+
+  @After public void tearDown() throws Exception {
+    cache.delete();
+    Util.closeQuietly(nullServer);
+    logger.removeHandler(logHandler);
+  }
+
+  @Test public void get() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .clearHeaders()
+        .addHeader("content-type: text/plain")
+        .addHeader("content-length", "3"));
+
+    long sentAt = System.currentTimeMillis();
+    RecordedResponse recordedResponse = executeSynchronously("/", "User-Agent", "SyncApiTest");
+    long receivedAt = System.currentTimeMillis();
+
+    recordedResponse.assertCode(200)
+        .assertSuccessful()
+        .assertHeaders(new Headers.Builder()
+            .add("content-type", "text/plain")
+            .add("content-length", "3")
+            .build())
+        .assertBody("abc")
+        .assertSentRequestAtMillis(sentAt, receivedAt)
+        .assertReceivedResponseAtMillis(sentAt, receivedAt);
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("GET", recordedRequest.getMethod());
+    assertEquals("SyncApiTest", recordedRequest.getHeader("User-Agent"));
+    assertEquals(0, recordedRequest.getBody().size());
+    assertNull(recordedRequest.getHeader("Content-Length"));
+  }
+
+  @Test public void buildRequestUsingHttpUrl() throws Exception {
+    server.enqueue(new MockResponse());
+    executeSynchronously("/").assertSuccessful();
+  }
+
+  @Test public void invalidScheme() throws Exception {
+    Request.Builder requestBuilder = new Request.Builder();
+    try {
+      requestBuilder.url("ftp://hostname/path");
+      fail();
+    } catch (IllegalArgumentException expected) {
+      assertEquals(expected.getMessage(), "unexpected url: ftp://hostname/path");
+    }
+  }
+
+  @Test public void invalidPort() throws Exception {
+    Request.Builder requestBuilder = new Request.Builder();
+    try {
+      requestBuilder.url("http://localhost:65536/");
+      fail();
+    } catch (IllegalArgumentException expected) {
+      assertEquals(expected.getMessage(), "unexpected url: http://localhost:65536/");
+    }
+  }
+
+  @Test public void getReturns500() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(500));
+    executeSynchronously("/")
+        .assertCode(500)
+        .assertNotSuccessful();
+  }
+
+  @Test public void get_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    get();
+  }
+
+  @Test public void get_HTTPS() throws Exception {
+    enableTls();
+    get();
+  }
+
+  @Test public void get_SPDY_3() throws Exception {
+    enableProtocol(Protocol.SPDY_3);
+    get();
+  }
+
+  @Test public void repeatedHeaderNames() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("B", "123")
+        .addHeader("B", "234"));
+
+    executeSynchronously("/", "A", "345", "A", "456")
+        .assertCode(200)
+        .assertHeader("B", "123", "234");
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals(Arrays.asList("345", "456"), recordedRequest.getHeaders().values("A"));
+  }
+
+  @Test public void repeatedHeaderNames_SPDY_3() throws Exception {
+    enableProtocol(Protocol.SPDY_3);
+    repeatedHeaderNames();
+  }
+
+  @Test public void repeatedHeaderNames_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    repeatedHeaderNames();
+  }
+
+  @Test public void getWithRequestBody() throws Exception {
+    server.enqueue(new MockResponse());
+
+    try {
+      new Request.Builder().method("GET", RequestBody.create(MediaType.parse("text/plain"), "abc"));
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void head() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Content-Type: text/plain"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .head()
+        .header("User-Agent", "SyncApiTest")
+        .build();
+
+    executeSynchronously(request)
+        .assertCode(200)
+        .assertHeader("Content-Type", "text/plain");
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("HEAD", recordedRequest.getMethod());
+    assertEquals("SyncApiTest", recordedRequest.getHeader("User-Agent"));
+    assertEquals(0, recordedRequest.getBody().size());
+    assertNull(recordedRequest.getHeader("Content-Length"));
+  }
+
+  @Test public void head_HTTPS() throws Exception {
+    enableTls();
+    head();
+  }
+
+  @Test public void head_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    head();
+  }
+
+  @Test public void head_SPDY_3() throws Exception {
+    enableProtocol(Protocol.SPDY_3);
+    head();
+  }
+
+  @Test public void post() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .post(RequestBody.create(MediaType.parse("text/plain"), "def"))
+        .build();
+
+    executeSynchronously(request)
+        .assertCode(200)
+        .assertBody("abc");
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("POST", recordedRequest.getMethod());
+    assertEquals("def", recordedRequest.getBody().readUtf8());
+    assertEquals("3", recordedRequest.getHeader("Content-Length"));
+    assertEquals("text/plain; charset=utf-8", recordedRequest.getHeader("Content-Type"));
+  }
+
+  @Test public void post_HTTPS() throws Exception {
+    enableTls();
+    post();
+  }
+
+  @Test public void post_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    post();
+  }
+
+  @Test public void post_SPDY_3() throws Exception {
+    enableProtocol(Protocol.SPDY_3);
+    post();
+  }
+
+  @Test public void postZeroLength() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .method("POST", RequestBody.create(null, new byte[0]))
+        .build();
+
+    executeSynchronously(request)
+        .assertCode(200)
+        .assertBody("abc");
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("POST", recordedRequest.getMethod());
+    assertEquals(0, recordedRequest.getBody().size());
+    assertEquals("0", recordedRequest.getHeader("Content-Length"));
+    assertEquals(null, recordedRequest.getHeader("Content-Type"));
+  }
+
+  @Test public void postZerolength_HTTPS() throws Exception {
+    enableTls();
+    postZeroLength();
+  }
+
+  @Test public void postZerolength_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    postZeroLength();
+  }
+
+  @Test public void postZeroLength_SPDY_3() throws Exception {
+    enableProtocol(Protocol.SPDY_3);
+    postZeroLength();
+  }
+
+  @Test public void postBodyRetransmittedAfterAuthorizationFail() throws Exception {
+    postBodyRetransmittedAfterAuthorizationFail("abc");
+  }
+
+  @Test public void postBodyRetransmittedAfterAuthorizationFail_HTTPS() throws Exception {
+    enableTls();
+    postBodyRetransmittedAfterAuthorizationFail("abc");
+  }
+
+  @Test public void postBodyRetransmittedAfterAuthorizationFail_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    postBodyRetransmittedAfterAuthorizationFail("abc");
+  }
+
+  @Test public void postBodyRetransmittedAfterAuthorizationFail_SPDY_3() throws Exception {
+    enableProtocol(Protocol.SPDY_3);
+    postBodyRetransmittedAfterAuthorizationFail("abc");
+  }
+
+  /** Don't explode when resending an empty post. https://github.com/square/okhttp/issues/1131 */
+  @Test public void postEmptyBodyRetransmittedAfterAuthorizationFail() throws Exception {
+    postBodyRetransmittedAfterAuthorizationFail("");
+  }
+
+  @Test public void postEmptyBodyRetransmittedAfterAuthorizationFail_HTTPS() throws Exception {
+    enableTls();
+    postBodyRetransmittedAfterAuthorizationFail("");
+  }
+
+  @Test public void postEmptyBodyRetransmittedAfterAuthorizationFail_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    postBodyRetransmittedAfterAuthorizationFail("");
+  }
+
+  @Test public void postEmptyBodyRetransmittedAfterAuthorizationFail_SPDY_3() throws Exception {
+    enableProtocol(Protocol.SPDY_3);
+    postBodyRetransmittedAfterAuthorizationFail("");
+  }
+
+  private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(401));
+    server.enqueue(new MockResponse());
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .method("POST", RequestBody.create(null, body))
+        .build();
+
+    String credential = Credentials.basic("jesse", "secret");
+    client = client.newBuilder()
+        .authenticator(new RecordingOkAuthenticator(credential))
+        .build();
+
+    Response response = client.newCall(request).execute();
+    assertEquals(200, response.code());
+
+    RecordedRequest recordedRequest1 = server.takeRequest();
+    assertEquals("POST", recordedRequest1.getMethod());
+    assertEquals(body, recordedRequest1.getBody().readUtf8());
+    assertNull(recordedRequest1.getHeader("Authorization"));
+
+    RecordedRequest recordedRequest2 = server.takeRequest();
+    assertEquals("POST", recordedRequest2.getMethod());
+    assertEquals(body, recordedRequest2.getBody().readUtf8());
+    assertEquals(credential, recordedRequest2.getHeader("Authorization"));
+  }
+
+  @Test public void attemptAuthorization20Times() throws Exception {
+    for (int i = 0; i < 20; i++) {
+      server.enqueue(new MockResponse().setResponseCode(401));
+    }
+    server.enqueue(new MockResponse().setBody("Success!"));
+
+    String credential = Credentials.basic("jesse", "secret");
+    client = client.newBuilder()
+        .authenticator(new RecordingOkAuthenticator(credential))
+        .build();
+
+    executeSynchronously("/")
+        .assertCode(200)
+        .assertBody("Success!");
+  }
+
+  @Test public void doesNotAttemptAuthorization21Times() throws Exception {
+    for (int i = 0; i < 21; i++) {
+      server.enqueue(new MockResponse().setResponseCode(401));
+    }
+
+    String credential = Credentials.basic("jesse", "secret");
+    client = client.newBuilder()
+        .authenticator(new RecordingOkAuthenticator(credential))
+        .build();
+
+    try {
+      client.newCall(new Request.Builder().url(server.url("/0")).build()).execute();
+      fail();
+    } catch (IOException expected) {
+      assertEquals("Too many follow-up requests: 21", expected.getMessage());
+    }
+  }
+
+  @Test public void delete() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .delete()
+        .build();
+
+    executeSynchronously(request)
+        .assertCode(200)
+        .assertBody("abc");
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("DELETE", recordedRequest.getMethod());
+    assertEquals(0, recordedRequest.getBody().size());
+    assertEquals("0", recordedRequest.getHeader("Content-Length"));
+    assertEquals(null, recordedRequest.getHeader("Content-Type"));
+  }
+
+  @Test public void delete_HTTPS() throws Exception {
+    enableTls();
+    delete();
+  }
+
+  @Test public void delete_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    delete();
+  }
+
+  @Test public void delete_SPDY_3() throws Exception {
+    enableProtocol(Protocol.SPDY_3);
+    delete();
+  }
+
+  @Test public void deleteWithRequestBody() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .method("DELETE", RequestBody.create(MediaType.parse("text/plain"), "def"))
+        .build();
+
+    executeSynchronously(request)
+        .assertCode(200)
+        .assertBody("abc");
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("DELETE", recordedRequest.getMethod());
+    assertEquals("def", recordedRequest.getBody().readUtf8());
+  }
+
+  @Test public void put() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .put(RequestBody.create(MediaType.parse("text/plain"), "def"))
+        .build();
+
+    executeSynchronously(request)
+        .assertCode(200)
+        .assertBody("abc");
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("PUT", recordedRequest.getMethod());
+    assertEquals("def", recordedRequest.getBody().readUtf8());
+    assertEquals("3", recordedRequest.getHeader("Content-Length"));
+    assertEquals("text/plain; charset=utf-8", recordedRequest.getHeader("Content-Type"));
+  }
+
+  @Test public void put_HTTPS() throws Exception {
+    enableTls();
+    put();
+  }
+
+  @Test public void put_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    put();
+  }
+
+  @Test public void put_SPDY_3() throws Exception {
+    enableProtocol(Protocol.SPDY_3);
+    put();
+  }
+
+  @Test public void patch() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .patch(RequestBody.create(MediaType.parse("text/plain"), "def"))
+        .build();
+
+    executeSynchronously(request)
+        .assertCode(200)
+        .assertBody("abc");
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("PATCH", recordedRequest.getMethod());
+    assertEquals("def", recordedRequest.getBody().readUtf8());
+    assertEquals("3", recordedRequest.getHeader("Content-Length"));
+    assertEquals("text/plain; charset=utf-8", recordedRequest.getHeader("Content-Type"));
+  }
+
+  @Test public void patch_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    patch();
+  }
+
+  @Test public void patch_HTTPS() throws Exception {
+    enableTls();
+    patch();
+  }
+
+  @Test public void patch_SPDY_3() throws Exception {
+    enableProtocol(Protocol.SPDY_3);
+    patch();
+  }
+
+  @Test public void unspecifiedRequestBodyContentTypeDoesNotGetDefault() throws Exception {
+    server.enqueue(new MockResponse());
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .method("POST", RequestBody.create(null, "abc"))
+        .build();
+
+    executeSynchronously(request).assertCode(200);
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals(null, recordedRequest.getHeader("Content-Type"));
+    assertEquals("3", recordedRequest.getHeader("Content-Length"));
+    assertEquals("abc", recordedRequest.getBody().readUtf8());
+  }
+
+  @Test public void illegalToExecuteTwice() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .addHeader("Content-Type: text/plain"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .header("User-Agent", "SyncApiTest")
+        .build();
+
+    Call call = client.newCall(request);
+    Response response = call.execute();
+    response.body().close();
+
+    try {
+      call.execute();
+      fail();
+    } catch (IllegalStateException e) {
+      assertEquals("Already Executed", e.getMessage());
+    }
+
+    try {
+      call.enqueue(callback);
+      fail();
+    } catch (IllegalStateException e) {
+      assertEquals("Already Executed", e.getMessage());
+    }
+
+    assertEquals("SyncApiTest", server.takeRequest().getHeader("User-Agent"));
+  }
+
+  @Test public void illegalToExecuteTwice_Async() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .addHeader("Content-Type: text/plain"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .header("User-Agent", "SyncApiTest")
+        .build();
+
+    Call call = client.newCall(request);
+    call.enqueue(callback);
+
+    try {
+      call.execute();
+      fail();
+    } catch (IllegalStateException e) {
+      assertEquals("Already Executed", e.getMessage());
+    }
+
+    try {
+      call.enqueue(callback);
+      fail();
+    } catch (IllegalStateException e) {
+      assertEquals("Already Executed", e.getMessage());
+    }
+
+    assertEquals("SyncApiTest", server.takeRequest().getHeader("User-Agent"));
+  }
+
+  @Test public void get_Async() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .addHeader("Content-Type: text/plain"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .header("User-Agent", "AsyncApiTest")
+        .build();
+    client.newCall(request).enqueue(callback);
+
+    callback.await(request.url())
+        .assertCode(200)
+        .assertHeader("Content-Type", "text/plain")
+        .assertBody("abc");
+
+    assertEquals("AsyncApiTest", server.takeRequest().getHeader("User-Agent"));
+  }
+
+  @Test public void exceptionThrownByOnResponseIsRedactedAndLogged() throws Exception {
+    server.enqueue(new MockResponse());
+
+    Request request = new Request.Builder()
+        .url(server.url("/secret"))
+        .build();
+
+    client.newCall(request).enqueue(new Callback() {
+      @Override public void onFailure(Call call, IOException e) {
+        fail();
+      }
+
+      @Override public void onResponse(Call call, Response response) throws IOException {
+        throw new IOException("a");
+      }
+    });
+
+    assertEquals("INFO: Callback failure for call to " + server.url("/") + "...",
+        logHandler.take());
+  }
+
+  @Test public void connectionPooling() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.enqueue(new MockResponse().setBody("def"));
+    server.enqueue(new MockResponse().setBody("ghi"));
+
+    executeSynchronously("/a").assertBody("abc");
+    executeSynchronously("/b").assertBody("def");
+    executeSynchronously("/c").assertBody("ghi");
+
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+    assertEquals(2, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void connectionPooling_Async() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.enqueue(new MockResponse().setBody("def"));
+    server.enqueue(new MockResponse().setBody("ghi"));
+
+    client.newCall(new Request.Builder().url(server.url("/a")).build()).enqueue(callback);
+    callback.await(server.url("/a")).assertBody("abc");
+
+    client.newCall(new Request.Builder().url(server.url("/b")).build()).enqueue(callback);
+    callback.await(server.url("/b")).assertBody("def");
+
+    client.newCall(new Request.Builder().url(server.url("/c")).build()).enqueue(callback);
+    callback.await(server.url("/c")).assertBody("ghi");
+
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+    assertEquals(2, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void connectionReuseWhenResponseBodyConsumed_Async() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.enqueue(new MockResponse().setBody("def"));
+
+    Request request = new Request.Builder().url(server.url("/a")).build();
+    client.newCall(request).enqueue(new Callback() {
+      @Override public void onFailure(Call call, IOException e) {
+        throw new AssertionError();
+      }
+
+      @Override public void onResponse(Call call, Response response) throws IOException {
+        InputStream bytes = response.body().byteStream();
+        assertEquals('a', bytes.read());
+        assertEquals('b', bytes.read());
+        assertEquals('c', bytes.read());
+
+        // This request will share a connection with 'A' cause it's all done.
+        client.newCall(new Request.Builder().url(server.url("/b")).build()).enqueue(callback);
+      }
+    });
+
+    callback.await(server.url("/b")).assertCode(200).assertBody("def");
+    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
+    assertEquals(1, server.takeRequest().getSequenceNumber()); // Connection reuse!
+  }
+
+  @Test public void timeoutsUpdatedOnReusedConnections() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.enqueue(new MockResponse().setBody("def").throttleBody(1, 750, TimeUnit.MILLISECONDS));
+
+    // First request: time out after 1000ms.
+    client = client.newBuilder()
+        .readTimeout(1000, TimeUnit.MILLISECONDS)
+        .build();
+    executeSynchronously("/a").assertBody("abc");
+
+    // Second request: time out after 250ms.
+    client = client.newBuilder()
+        .readTimeout(250, TimeUnit.MILLISECONDS)
+        .build();
+    Request request = new Request.Builder().url(server.url("/b")).build();
+    Response response = client.newCall(request).execute();
+    BufferedSource bodySource = response.body().source();
+    assertEquals('d', bodySource.readByte());
+
+    // The second byte of this request will be delayed by 750ms so we should time out after 250ms.
+    long startNanos = System.nanoTime();
+    try {
+      bodySource.readByte();
+      fail();
+    } catch (IOException expected) {
+      // Timed out as expected.
+      long elapsedNanos = System.nanoTime() - startNanos;
+      long elapsedMillis = TimeUnit.NANOSECONDS.toMillis(elapsedNanos);
+      assertTrue(Util.format("Timed out: %sms", elapsedMillis), elapsedMillis < 500);
+    } finally {
+      bodySource.close();
+    }
+  }
+
+  /** https://github.com/square/okhttp/issues/442 */
+  @Test public void tlsTimeoutsNotRetried() throws Exception {
+    enableTls();
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.NO_RESPONSE));
+    server.enqueue(new MockResponse()
+        .setBody("unreachable!"));
+
+    client = client.newBuilder()
+        .readTimeout(100, TimeUnit.MILLISECONDS)
+        .build();
+
+    Request request = new Request.Builder().url(server.url("/")).build();
+    try {
+      // If this succeeds, too many requests were made.
+      client.newCall(request).execute();
+      fail();
+    } catch (InterruptedIOException expected) {
+    }
+  }
+
+  /**
+   * Make a request with two routes. The first route will time out because it's connecting to a
+   * special address that never connects. The automatic retry will succeed.
+   */
+  @Test public void connectTimeoutsAttemptsAlternateRoute() throws Exception {
+    InetSocketAddress unreachableAddress = new InetSocketAddress("10.255.255.1", 8080);
+
+    RecordingProxySelector proxySelector = new RecordingProxySelector();
+    proxySelector.proxies.add(new Proxy(Proxy.Type.HTTP, unreachableAddress));
+    proxySelector.proxies.add(server.toProxyAddress());
+
+    server.enqueue(new MockResponse()
+        .setBody("success!"));
+
+    client = client.newBuilder()
+        .proxySelector(proxySelector)
+        .readTimeout(100, TimeUnit.MILLISECONDS)
+        .connectTimeout(100, TimeUnit.MILLISECONDS)
+        .build();
+
+    Request request = new Request.Builder().url("http://android.com/").build();
+    executeSynchronously(request)
+        .assertCode(200)
+        .assertBody("success!");
+  }
+
+  /**
+   * Make a request with two routes. The first route will fail because the null server connects but
+   * never responds. The manual retry will succeed.
+   */
+  @Test public void readTimeoutFails() throws Exception {
+    InetSocketAddress nullServerAddress = startNullServer();
+
+    RecordingProxySelector proxySelector = new RecordingProxySelector();
+    proxySelector.proxies.add(new Proxy(Proxy.Type.HTTP, nullServerAddress));
+    proxySelector.proxies.add(server.toProxyAddress());
+
+    server.enqueue(new MockResponse()
+        .setBody("success!"));
+
+    client = client.newBuilder()
+        .proxySelector(proxySelector)
+        .readTimeout(100, TimeUnit.MILLISECONDS)
+        .build();
+
+    Request request = new Request.Builder().url("http://android.com/").build();
+    executeSynchronously(request)
+        .assertFailure(SocketTimeoutException.class);
+    executeSynchronously(request)
+        .assertCode(200)
+        .assertBody("success!");
+  }
+
+  /** https://github.com/square/okhttp/issues/1801 */
+  @Test public void asyncCallEngineInitialized() throws Exception {
+    OkHttpClient c = new OkHttpClient.Builder()
+        .addInterceptor(new Interceptor() {
+          @Override public Response intercept(Chain chain) throws IOException {
+            throw new IOException();
+          }
+        })
+        .build();
+    Request request = new Request.Builder().url(server.url("/")).build();
+    c.newCall(request).enqueue(callback);
+    RecordedResponse response = callback.await(request.url());
+    assertEquals(request, response.request);
+  }
+
+  @Test public void reusedSinksGetIndependentTimeoutInstances() throws Exception {
+    server.enqueue(new MockResponse());
+    server.enqueue(new MockResponse());
+
+    // Call 1: set a deadline on the request body.
+    RequestBody requestBody1 = new RequestBody() {
+      @Override public MediaType contentType() {
+        return MediaType.parse("text/plain");
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        sink.writeUtf8("abc");
+        sink.timeout().deadline(5, TimeUnit.SECONDS);
+      }
+    };
+    Request request1 = new Request.Builder()
+        .url(server.url("/"))
+        .method("POST", requestBody1)
+        .build();
+    Response response1 = client.newCall(request1).execute();
+    assertEquals(200, response1.code());
+
+    // Call 2: check for the absence of a deadline on the request body.
+    RequestBody requestBody2 = new RequestBody() {
+      @Override public MediaType contentType() {
+        return MediaType.parse("text/plain");
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        assertFalse(sink.timeout().hasDeadline());
+        sink.writeUtf8("def");
+      }
+    };
+    Request request2 = new Request.Builder()
+        .url(server.url("/"))
+        .method("POST", requestBody2)
+        .build();
+    Response response2 = client.newCall(request2).execute();
+    assertEquals(200, response2.code());
+
+    // Use sequence numbers to confirm the connection was pooled.
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void reusedSourcesGetIndependentTimeoutInstances() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.enqueue(new MockResponse().setBody("def"));
+
+    // Call 1: set a deadline on the response body.
+    Request request1 = new Request.Builder().url(server.url("/")).build();
+    Response response1 = client.newCall(request1).execute();
+    BufferedSource body1 = response1.body().source();
+    assertEquals("abc", body1.readUtf8());
+    body1.timeout().deadline(5, TimeUnit.SECONDS);
+
+    // Call 2: check for the absence of a deadline on the request body.
+    Request request2 = new Request.Builder().url(server.url("/")).build();
+    Response response2 = client.newCall(request2).execute();
+    BufferedSource body2 = response2.body().source();
+    assertEquals("def", body2.readUtf8());
+    assertFalse(body2.timeout().hasDeadline());
+
+    // Use sequence numbers to confirm the connection was pooled.
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void tls() throws Exception {
+    enableTls();
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .addHeader("Content-Type: text/plain"));
+
+    executeSynchronously("/").assertHandshake();
+  }
+
+  @Test public void tls_Async() throws Exception {
+    enableTls();
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .addHeader("Content-Type: text/plain"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    client.newCall(request).enqueue(callback);
+
+    callback.await(request.url()).assertHandshake();
+  }
+
+  @Test public void recoverWhenRetryOnConnectionFailureIsTrue() throws Exception {
+    server.enqueue(new MockResponse().setBody("seed connection pool"));
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AFTER_REQUEST));
+    server.enqueue(new MockResponse().setBody("retry success"));
+
+    client = client.newBuilder()
+        .dns(new DoubleInetAddressDns())
+        .build();
+    assertTrue(client.retryOnConnectionFailure());
+
+    executeSynchronously("/").assertBody("seed connection pool");
+    executeSynchronously("/").assertBody("retry success");
+  }
+
+  @Test public void noRecoverWhenRetryOnConnectionFailureIsFalse() throws Exception {
+    server.enqueue(new MockResponse().setBody("seed connection pool"));
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AFTER_REQUEST));
+    server.enqueue(new MockResponse().setBody("unreachable!"));
+
+    client = client.newBuilder()
+        .dns(new DoubleInetAddressDns())
+        .retryOnConnectionFailure(false)
+        .build();
+
+    executeSynchronously("/").assertBody("seed connection pool");
+
+    // If this succeeds, too many requests were made.
+    executeSynchronously("/").assertFailure(IOException.class);
+  }
+
+  @Test public void recoverFromTlsHandshakeFailure() throws Exception {
+    server.useHttps(sslClient.socketFactory, false);
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    client = client.newBuilder()
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .dns(new SingleInetAddressDns())
+        .sslSocketFactory(suppressTlsFallbackClientSocketFactory(), sslClient.trustManager)
+        .build();
+
+    executeSynchronously("/").assertBody("abc");
+  }
+
+  @Test public void recoverFromTlsHandshakeFailure_tlsFallbackScsvEnabled() throws Exception {
+    final String tlsFallbackScsv = "TLS_FALLBACK_SCSV";
+    List<String> supportedCiphers =
+        Arrays.asList(sslClient.socketFactory.getSupportedCipherSuites());
+    if (!supportedCiphers.contains(tlsFallbackScsv)) {
+      // This only works if the client socket supports TLS_FALLBACK_SCSV.
+      return;
+    }
+
+    server.useHttps(sslClient.socketFactory, false);
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
+
+    RecordingSSLSocketFactory clientSocketFactory =
+        new RecordingSSLSocketFactory(sslClient.socketFactory);
+    client = client.newBuilder()
+        .sslSocketFactory(clientSocketFactory, sslClient.trustManager)
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .dns(new SingleInetAddressDns())
+        .build();
+
+    Request request = new Request.Builder().url(server.url("/")).build();
+    try {
+      client.newCall(request).execute();
+      fail();
+    } catch (SSLHandshakeException expected) {
+    }
+
+    List<SSLSocket> clientSockets = clientSocketFactory.getSocketsCreated();
+    SSLSocket firstSocket = clientSockets.get(0);
+    assertFalse(Arrays.asList(firstSocket.getEnabledCipherSuites()).contains(tlsFallbackScsv));
+    SSLSocket secondSocket = clientSockets.get(1);
+    assertTrue(Arrays.asList(secondSocket.getEnabledCipherSuites()).contains(tlsFallbackScsv));
+  }
+
+  @Test public void recoverFromTlsHandshakeFailure_Async() throws Exception {
+    server.useHttps(sslClient.socketFactory, false);
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    client = client.newBuilder()
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .sslSocketFactory(suppressTlsFallbackClientSocketFactory(), sslClient.trustManager)
+        .build();
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    client.newCall(request).enqueue(callback);
+
+    callback.await(request.url()).assertBody("abc");
+  }
+
+  @Test public void noRecoveryFromTlsHandshakeFailureWhenTlsFallbackIsDisabled() throws Exception {
+    client = client.newBuilder()
+        .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.CLEARTEXT))
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .dns(new SingleInetAddressDns())
+        .sslSocketFactory(suppressTlsFallbackClientSocketFactory(), sslClient.trustManager)
+        .build();
+
+    server.useHttps(sslClient.socketFactory, false);
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
+
+    Request request = new Request.Builder().url(server.url("/")).build();
+    try {
+      client.newCall(request).execute();
+      fail();
+    } catch (SSLProtocolException expected) {
+      // RI response to the FAIL_HANDSHAKE
+    } catch (SSLHandshakeException expected) {
+      // Android's response to the FAIL_HANDSHAKE
+    }
+  }
+
+  @Test public void cleartextCallsFailWhenCleartextIsDisabled() throws Exception {
+    // Configure the client with only TLS configurations. No cleartext!
+    client = client.newBuilder()
+        .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS))
+        .build();
+
+    server.enqueue(new MockResponse());
+
+    Request request = new Request.Builder().url(server.url("/")).build();
+    try {
+      client.newCall(request).execute();
+      fail();
+    } catch (UnknownServiceException expected) {
+      assertTrue(expected.getMessage().contains("CLEARTEXT communication not supported"));
+    }
+  }
+
+  @Test public void setFollowSslRedirectsFalse() throws Exception {
+    enableTls();
+    server.enqueue(new MockResponse()
+        .setResponseCode(301)
+        .addHeader("Location: http://square.com"));
+
+    client = client.newBuilder()
+        .followSslRedirects(false)
+        .build();
+
+    Request request = new Request.Builder().url(server.url("/")).build();
+    Response response = client.newCall(request).execute();
+    assertEquals(301, response.code());
+    response.body().close();
+  }
+
+  @Test public void matchingPinnedCertificate() throws Exception {
+    enableTls();
+    server.enqueue(new MockResponse());
+    server.enqueue(new MockResponse());
+
+    // Make a first request without certificate pinning. Use it to collect certificates to pin.
+    Request request1 = new Request.Builder().url(server.url("/")).build();
+    Response response1 = client.newCall(request1).execute();
+    CertificatePinner.Builder certificatePinnerBuilder = new CertificatePinner.Builder();
+    for (Certificate certificate : response1.handshake().peerCertificates()) {
+      certificatePinnerBuilder.add(server.getHostName(), CertificatePinner.pin(certificate));
+    }
+    response1.body().close();
+
+    // Make another request with certificate pinning. It should complete normally.
+    client = client.newBuilder()
+        .certificatePinner(certificatePinnerBuilder.build())
+        .build();
+    Request request2 = new Request.Builder().url(server.url("/")).build();
+    Response response2 = client.newCall(request2).execute();
+    assertNotSame(response2.handshake(), response1.handshake());
+    response2.body().close();
+  }
+
+  @Test public void unmatchingPinnedCertificate() throws Exception {
+    enableTls();
+    server.enqueue(new MockResponse());
+
+    // Pin publicobject.com's cert.
+    client = client.newBuilder()
+        .certificatePinner(new CertificatePinner.Builder()
+            .add(server.getHostName(), "sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw=")
+            .build())
+        .build();
+
+    // When we pin the wrong certificate, connectivity fails.
+    Request request = new Request.Builder().url(server.url("/")).build();
+    try {
+      client.newCall(request).execute();
+      fail();
+    } catch (SSLPeerUnverifiedException expected) {
+      assertTrue(expected.getMessage().startsWith("Certificate pinning failure!"));
+    }
+  }
+
+  @Test public void post_Async() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .post(RequestBody.create(MediaType.parse("text/plain"), "def"))
+        .build();
+    client.newCall(request).enqueue(callback);
+
+    callback.await(request.url())
+        .assertCode(200)
+        .assertBody("abc");
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("def", recordedRequest.getBody().readUtf8());
+    assertEquals("3", recordedRequest.getHeader("Content-Length"));
+    assertEquals("text/plain; charset=utf-8", recordedRequest.getHeader("Content-Type"));
+  }
+
+  @Test public void postBodyRetransmittedOnFailureRecovery() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AFTER_REQUEST));
+    server.enqueue(new MockResponse().setBody("def"));
+
+    // Seed the connection pool so we have something that can fail.
+    Request request1 = new Request.Builder().url(server.url("/")).build();
+    Response response1 = client.newCall(request1).execute();
+    assertEquals("abc", response1.body().string());
+
+    Request request2 = new Request.Builder()
+        .url(server.url("/"))
+        .post(RequestBody.create(MediaType.parse("text/plain"), "body!"))
+        .build();
+    Response response2 = client.newCall(request2).execute();
+    assertEquals("def", response2.body().string());
+
+    RecordedRequest get = server.takeRequest();
+    assertEquals(0, get.getSequenceNumber());
+
+    RecordedRequest post1 = server.takeRequest();
+    assertEquals("body!", post1.getBody().readUtf8());
+    assertEquals(1, post1.getSequenceNumber());
+
+    RecordedRequest post2 = server.takeRequest();
+    assertEquals("body!", post2.getBody().readUtf8());
+    assertEquals(0, post2.getSequenceNumber());
+  }
+
+  @Test public void cacheHit() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("ETag: v1")
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Accept-Charset")
+        .setBody("A"));
+
+    client = client.newBuilder()
+        .cache(cache)
+        .build();
+
+    // Store a response in the cache.
+    HttpUrl url = server.url("/");
+    long request1SentAt = System.currentTimeMillis();
+    executeSynchronously("/", "Accept-Language", "fr-CA", "Accept-Charset", "UTF-8")
+        .assertCode(200)
+        .assertBody("A");
+    long request1ReceivedAt = System.currentTimeMillis();
+    assertNull(server.takeRequest().getHeader("If-None-Match"));
+
+    // Hit that stored response. It's different, but Vary says it doesn't matter.
+    Thread.sleep(10); // Make sure the timestamps are unique.
+    RecordedResponse cacheHit = executeSynchronously(
+        "/", "Accept-Language", "en-US", "Accept-Charset", "UTF-8");
+
+    // Check the merged response. The request is the application's original request.
+    cacheHit.assertCode(200)
+        .assertBody("A")
+        .assertHeaders(new Headers.Builder()
+            .add("ETag", "v1")
+            .add("Cache-Control", "max-age=60")
+            .add("Vary", "Accept-Charset")
+            .add("Content-Length", "1")
+            .build())
+        .assertRequestUrl(url)
+        .assertRequestHeader("Accept-Language", "en-US")
+        .assertRequestHeader("Accept-Charset", "UTF-8")
+        .assertSentRequestAtMillis(request1SentAt, request1ReceivedAt)
+        .assertReceivedResponseAtMillis(request1SentAt, request1ReceivedAt);
+
+    // Check the cached response. Its request contains only the saved Vary headers.
+    cacheHit.cacheResponse()
+        .assertCode(200)
+        .assertHeaders(new Headers.Builder()
+            .add("ETag", "v1")
+            .add("Cache-Control", "max-age=60")
+            .add("Vary", "Accept-Charset")
+            .add("Content-Length", "1")
+            .build())
+        .assertRequestMethod("GET")
+        .assertRequestUrl(url)
+        .assertRequestHeader("Accept-Language")
+        .assertRequestHeader("Accept-Charset", "UTF-8")
+        .assertSentRequestAtMillis(request1SentAt, request1ReceivedAt)
+        .assertReceivedResponseAtMillis(request1SentAt, request1ReceivedAt);
+
+    cacheHit.assertNoNetworkResponse();
+  }
+
+  @Test public void conditionalCacheHit() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("ETag: v1")
+        .addHeader("Vary: Accept-Charset")
+        .addHeader("Donut: a")
+        .setBody("A"));
+    server.enqueue(new MockResponse().clearHeaders()
+        .addHeader("Donut: b")
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    client = client.newBuilder()
+        .cache(cache)
+        .build();
+
+    // Store a response in the cache.
+    long request1At = System.currentTimeMillis();
+    executeSynchronously("/", "Accept-Language", "fr-CA", "Accept-Charset", "UTF-8")
+        .assertCode(200)
+        .assertHeader("Donut", "a")
+        .assertBody("A");
+    long request1ReceivedAt = System.currentTimeMillis();
+    assertNull(server.takeRequest().getHeader("If-None-Match"));
+
+    // Hit that stored response. It's different, but Vary says it doesn't matter.
+    Thread.sleep(10); // Make sure the timestamps are unique.
+    long request2SentAt = System.currentTimeMillis();
+    RecordedResponse cacheHit = executeSynchronously(
+        "/", "Accept-Language", "en-US", "Accept-Charset", "UTF-8");
+    long request2ReceivedAt = System.currentTimeMillis();
+    assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
+
+    // Check the merged response. The request is the application's original request.
+    cacheHit.assertCode(200)
+        .assertBody("A")
+        .assertHeader("Donut", "b")
+        .assertRequestUrl(server.url("/"))
+        .assertRequestHeader("Accept-Language", "en-US")
+        .assertRequestHeader("Accept-Charset", "UTF-8")
+        .assertRequestHeader("If-None-Match") // No If-None-Match on the user's request.
+        .assertSentRequestAtMillis(request1At, request1ReceivedAt)
+        .assertReceivedResponseAtMillis(request1At, request1ReceivedAt);
+
+    // Check the cached response. Its request contains only the saved Vary headers.
+    cacheHit.cacheResponse()
+        .assertCode(200)
+        .assertHeader("Donut", "a")
+        .assertHeader("ETag", "v1")
+        .assertRequestUrl(server.url("/"))
+        .assertRequestHeader("Accept-Language") // No Vary on Accept-Language.
+        .assertRequestHeader("Accept-Charset", "UTF-8") // Because of Vary on Accept-Charset.
+        .assertRequestHeader("If-None-Match") // This wasn't present in the original request.
+        .assertSentRequestAtMillis(request1At, request1ReceivedAt)
+        .assertReceivedResponseAtMillis(request1At, request1ReceivedAt);
+
+    // Check the network response. It has the caller's request, plus some caching headers.
+    cacheHit.networkResponse()
+        .assertCode(304)
+        .assertHeader("Donut", "b")
+        .assertRequestHeader("Accept-Language", "en-US")
+        .assertRequestHeader("Accept-Charset", "UTF-8")
+        .assertRequestHeader("If-None-Match", "v1") // If-None-Match in the validation request.
+        .assertSentRequestAtMillis(request2SentAt, request2ReceivedAt)
+        .assertReceivedResponseAtMillis(request2SentAt, request2ReceivedAt);
+  }
+
+  @Test public void conditionalCacheHit_Async() throws Exception {
+    server.enqueue(new MockResponse().setBody("A").addHeader("ETag: v1"));
+    server.enqueue(new MockResponse()
+        .clearHeaders()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    client = client.newBuilder()
+        .cache(cache)
+        .build();
+
+    Request request1 = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    client.newCall(request1).enqueue(callback);
+    callback.await(request1.url()).assertCode(200).assertBody("A");
+    assertNull(server.takeRequest().getHeader("If-None-Match"));
+
+    Request request2 = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    client.newCall(request2).enqueue(callback);
+    callback.await(request2.url()).assertCode(200).assertBody("A");
+    assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
+  }
+
+  @Test public void conditionalCacheMiss() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("ETag: v1")
+        .addHeader("Vary: Accept-Charset")
+        .addHeader("Donut: a")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .addHeader("Donut: b")
+        .setBody("B"));
+
+    client = client.newBuilder()
+        .cache(cache)
+        .build();
+
+    long request1SentAt = System.currentTimeMillis();
+    executeSynchronously("/", "Accept-Language", "fr-CA", "Accept-Charset", "UTF-8")
+        .assertCode(200)
+        .assertBody("A");
+    long request1ReceivedAt = System.currentTimeMillis();
+    assertNull(server.takeRequest().getHeader("If-None-Match"));
+
+    // Different request, but Vary says it doesn't matter.
+    Thread.sleep(10); // Make sure the timestamps are unique.
+    long request2SentAt = System.currentTimeMillis();
+    RecordedResponse cacheMiss = executeSynchronously(
+        "/", "Accept-Language", "en-US", "Accept-Charset", "UTF-8");
+    long request2ReceivedAt = System.currentTimeMillis();
+    assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
+
+    // Check the user response. It has the application's original request.
+    cacheMiss.assertCode(200)
+        .assertBody("B")
+        .assertHeader("Donut", "b")
+        .assertRequestUrl(server.url("/"))
+        .assertSentRequestAtMillis(request2SentAt, request2ReceivedAt)
+        .assertReceivedResponseAtMillis(request2SentAt, request2ReceivedAt);
+
+    // Check the cache response. Even though it's a miss, we used the cache.
+    cacheMiss.cacheResponse()
+        .assertCode(200)
+        .assertHeader("Donut", "a")
+        .assertHeader("ETag", "v1")
+        .assertRequestUrl(server.url("/"))
+        .assertSentRequestAtMillis(request1SentAt, request1ReceivedAt)
+        .assertReceivedResponseAtMillis(request1SentAt, request1ReceivedAt);
+
+    // Check the network response. It has the network request, plus caching headers.
+    cacheMiss.networkResponse()
+        .assertCode(200)
+        .assertHeader("Donut", "b")
+        .assertRequestHeader("If-None-Match", "v1")  // If-None-Match in the validation request.
+        .assertRequestUrl(server.url("/"))
+        .assertSentRequestAtMillis(request2SentAt, request2ReceivedAt)
+        .assertReceivedResponseAtMillis(request2SentAt, request2ReceivedAt);
+  }
+
+  @Test public void conditionalCacheMiss_Async() throws Exception {
+    server.enqueue(new MockResponse().setBody("A").addHeader("ETag: v1"));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    client = client.newBuilder()
+        .cache(cache)
+        .build();
+
+    Request request1 = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    client.newCall(request1).enqueue(callback);
+    callback.await(request1.url()).assertCode(200).assertBody("A");
+    assertNull(server.takeRequest().getHeader("If-None-Match"));
+
+    Request request2 = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    client.newCall(request2).enqueue(callback);
+    callback.await(request2.url()).assertCode(200).assertBody("B");
+    assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
+  }
+
+  @Test public void onlyIfCachedReturns504WhenNotCached() throws Exception {
+    executeSynchronously("/", "Cache-Control", "only-if-cached")
+        .assertCode(504)
+        .assertBody("")
+        .assertNoNetworkResponse()
+        .assertNoCacheResponse();
+  }
+
+  @Test public void networkDropsOnConditionalGet() throws IOException {
+    client = client.newBuilder()
+        .cache(cache)
+        .build();
+
+    // Seed the cache.
+    server.enqueue(new MockResponse()
+        .addHeader("ETag: v1")
+        .setBody("A"));
+    executeSynchronously("/")
+        .assertCode(200)
+        .assertBody("A");
+
+    // Attempt conditional cache validation and a DNS miss.
+    client.connectionPool().evictAll();
+    client = client.newBuilder()
+        .dns(new FakeDns().unknownHost())
+        .build();
+    executeSynchronously("/").assertFailure(UnknownHostException.class);
+  }
+
+  @Test public void redirect() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(301)
+        .addHeader("Location: /b")
+        .addHeader("Test", "Redirect from /a to /b")
+        .setBody("/a has moved!"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(302)
+        .addHeader("Location: /c")
+        .addHeader("Test", "Redirect from /b to /c")
+        .setBody("/b has moved!"));
+    server.enqueue(new MockResponse().setBody("C"));
+
+    executeSynchronously("/a")
+        .assertCode(200)
+        .assertBody("C")
+        .priorResponse()
+        .assertCode(302)
+        .assertHeader("Test", "Redirect from /b to /c")
+        .priorResponse()
+        .assertCode(301)
+        .assertHeader("Test", "Redirect from /a to /b");
+
+    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
+    assertEquals(1, server.takeRequest().getSequenceNumber()); // Connection reused.
+    assertEquals(2, server.takeRequest().getSequenceNumber()); // Connection reused again!
+  }
+
+  @Test public void postRedirectsToGet() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .addHeader("Location: /page2")
+        .setBody("This page has moved!"));
+    server.enqueue(new MockResponse().setBody("Page 2"));
+
+    Response response = client.newCall(new Request.Builder()
+        .url(server.url("/page1"))
+        .post(RequestBody.create(MediaType.parse("text/plain"), "Request Body"))
+        .build()).execute();
+    assertEquals("Page 2", response.body().string());
+
+    RecordedRequest page1 = server.takeRequest();
+    assertEquals("POST /page1 HTTP/1.1", page1.getRequestLine());
+    assertEquals("Request Body", page1.getBody().readUtf8());
+
+    RecordedRequest page2 = server.takeRequest();
+    assertEquals("GET /page2 HTTP/1.1", page2.getRequestLine());
+  }
+
+  @Test public void getClientRequestTimeout() throws Exception {
+    enqueueRequestTimeoutResponses();
+
+    Response response = client.newCall(new Request.Builder()
+        .url(server.url("/")).build()).execute();
+
+    assertEquals("Body", response.body().string());
+  }
+
+  private void enqueueRequestTimeoutResponses() {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
+        .setResponseCode(HttpURLConnection.HTTP_CLIENT_TIMEOUT)
+        .setHeader("Connection", "Close")
+        .setBody("You took too long!"));
+    server.enqueue(new MockResponse().setBody("Body"));
+  }
+
+  @Test public void requestBodyRetransmittedOnClientRequestTimeout() throws Exception {
+    enqueueRequestTimeoutResponses();
+
+    Response response = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .post(RequestBody.create(MediaType.parse("text/plain"), "Hello"))
+        .build()).execute();
+
+    assertEquals("Body", response.body().string());
+
+    RecordedRequest request1 = server.takeRequest();
+    assertEquals("Hello", request1.getBody().readUtf8());
+
+    RecordedRequest request2 = server.takeRequest();
+    assertEquals("Hello", request2.getBody().readUtf8());
+  }
+
+  @Test public void propfindRedirectsToPropfind() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .addHeader("Location: /page2")
+        .setBody("This page has moved!"));
+    server.enqueue(new MockResponse().setBody("Page 2"));
+
+    Response response = client.newCall(new Request.Builder()
+        .url(server.url("/page1"))
+        .method("PROPFIND", RequestBody.create(MediaType.parse("text/plain"), "Request Body"))
+        .build()).execute();
+    assertEquals("Page 2", response.body().string());
+
+    RecordedRequest page1 = server.takeRequest();
+    assertEquals("PROPFIND /page1 HTTP/1.1", page1.getRequestLine());
+    assertEquals("Request Body", page1.getBody().readUtf8());
+
+    RecordedRequest page2 = server.takeRequest();
+    assertEquals("PROPFIND /page2 HTTP/1.1", page2.getRequestLine());
+  }
+
+  @Test public void responseCookies() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Set-Cookie", "a=b; Expires=Thu, 01 Jan 1970 00:00:00 GMT")
+        .addHeader("Set-Cookie", "c=d; Expires=Fri, 02 Jan 1970 23:59:59 GMT; path=/bar; secure"));
+
+    RecordingCookieJar cookieJar = new RecordingCookieJar();
+    client = client.newBuilder()
+        .cookieJar(cookieJar)
+        .build();
+
+    executeSynchronously("/").assertCode(200);
+
+    List<Cookie> responseCookies = cookieJar.takeResponseCookies();
+    assertEquals(2, responseCookies.size());
+    assertEquals("a=b; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/",
+        responseCookies.get(0).toString());
+    assertEquals("c=d; expires=Fri, 02 Jan 1970 23:59:59 GMT; path=/bar; secure",
+        responseCookies.get(1).toString());
+  }
+
+  @Test public void requestCookies() throws Exception {
+    server.enqueue(new MockResponse());
+
+    RecordingCookieJar cookieJar = new RecordingCookieJar();
+
+    cookieJar.enqueueRequestCookies(
+        new Cookie.Builder().name("a").value("b").domain(server.getHostName()).build(),
+        new Cookie.Builder().name("c").value("d").domain(server.getHostName()).build());
+    client = client.newBuilder()
+        .cookieJar(cookieJar)
+        .build();
+
+    executeSynchronously("/").assertCode(200);
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("a=b; c=d", recordedRequest.getHeader("Cookie"));
+  }
+
+  @Test public void redirectsDoNotIncludeTooManyCookies() throws Exception {
+    server2.enqueue(new MockResponse().setBody("Page 2"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .addHeader("Location: " + server2.url("/")));
+
+    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
+    HttpCookie cookie = new HttpCookie("c", "cookie");
+    cookie.setDomain(server.getHostName());
+    cookie.setPath("/");
+    String portList = Integer.toString(server.getPort());
+    cookie.setPortlist(portList);
+    cookieManager.getCookieStore().add(server.url("/").uri(), cookie);
+    client = client.newBuilder()
+        .cookieJar(new JavaNetCookieJar(cookieManager))
+        .build();
+
+    Response response = client.newCall(new Request.Builder()
+        .url(server.url("/page1"))
+        .build()).execute();
+    assertEquals("Page 2", response.body().string());
+
+    RecordedRequest request1 = server.takeRequest();
+    assertEquals("c=cookie", request1.getHeader("Cookie"));
+
+    RecordedRequest request2 = server2.takeRequest();
+    assertNull(request2.getHeader("Cookie"));
+  }
+
+  @Test public void redirectsDoNotIncludeTooManyAuthHeaders() throws Exception {
+    server2.enqueue(new MockResponse().setBody("Page 2"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(401));
+    server.enqueue(new MockResponse()
+        .setResponseCode(302)
+        .addHeader("Location: " + server2.url("/b")));
+
+    client = client.newBuilder()
+        .authenticator(new RecordingOkAuthenticator(Credentials.basic("jesse", "secret")))
+        .build();
+
+    Request request = new Request.Builder().url(server.url("/a")).build();
+    Response response = client.newCall(request).execute();
+    assertEquals("Page 2", response.body().string());
+
+    RecordedRequest redirectRequest = server2.takeRequest();
+    assertNull(redirectRequest.getHeader("Authorization"));
+    assertEquals("/b", redirectRequest.getPath());
+  }
+
+  @Test public void redirect_Async() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(301)
+        .addHeader("Location: /b")
+        .addHeader("Test", "Redirect from /a to /b")
+        .setBody("/a has moved!"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(302)
+        .addHeader("Location: /c")
+        .addHeader("Test", "Redirect from /b to /c")
+        .setBody("/b has moved!"));
+    server.enqueue(new MockResponse().setBody("C"));
+
+    Request request = new Request.Builder().url(server.url("/a")).build();
+    client.newCall(request).enqueue(callback);
+
+    callback.await(server.url("/a"))
+        .assertCode(200)
+        .assertBody("C")
+        .priorResponse()
+        .assertCode(302)
+        .assertHeader("Test", "Redirect from /b to /c")
+        .priorResponse()
+        .assertCode(301)
+        .assertHeader("Test", "Redirect from /a to /b");
+
+    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
+    assertEquals(1, server.takeRequest().getSequenceNumber()); // Connection reused.
+    assertEquals(2, server.takeRequest().getSequenceNumber()); // Connection reused again!
+  }
+
+  @Test public void follow20Redirects() throws Exception {
+    for (int i = 0; i < 20; i++) {
+      server.enqueue(new MockResponse()
+          .setResponseCode(301)
+          .addHeader("Location: /" + (i + 1))
+          .setBody("Redirecting to /" + (i + 1)));
+    }
+    server.enqueue(new MockResponse().setBody("Success!"));
+
+    executeSynchronously("/0")
+        .assertCode(200)
+        .assertBody("Success!");
+  }
+
+  @Test public void follow20Redirects_Async() throws Exception {
+    for (int i = 0; i < 20; i++) {
+      server.enqueue(new MockResponse()
+          .setResponseCode(301)
+          .addHeader("Location: /" + (i + 1))
+          .setBody("Redirecting to /" + (i + 1)));
+    }
+    server.enqueue(new MockResponse().setBody("Success!"));
+
+    Request request = new Request.Builder().url(server.url("/0")).build();
+    client.newCall(request).enqueue(callback);
+    callback.await(server.url("/0"))
+        .assertCode(200)
+        .assertBody("Success!");
+  }
+
+  @Test public void doesNotFollow21Redirects() throws Exception {
+    for (int i = 0; i < 21; i++) {
+      server.enqueue(new MockResponse()
+          .setResponseCode(301)
+          .addHeader("Location: /" + (i + 1))
+          .setBody("Redirecting to /" + (i + 1)));
+    }
+
+    try {
+      client.newCall(new Request.Builder().url(server.url("/0")).build()).execute();
+      fail();
+    } catch (IOException expected) {
+      assertEquals("Too many follow-up requests: 21", expected.getMessage());
+    }
+  }
+
+  @Test public void doesNotFollow21Redirects_Async() throws Exception {
+    for (int i = 0; i < 21; i++) {
+      server.enqueue(new MockResponse()
+          .setResponseCode(301)
+          .addHeader("Location: /" + (i + 1))
+          .setBody("Redirecting to /" + (i + 1)));
+    }
+
+    Request request = new Request.Builder().url(server.url("/0")).build();
+    client.newCall(request).enqueue(callback);
+    callback.await(server.url("/0")).assertFailure("Too many follow-up requests: 21");
+  }
+
+  @Test public void http204WithBodyDisallowed() throws IOException {
+    server.enqueue(new MockResponse()
+        .setResponseCode(204)
+        .setBody("I'm not even supposed to be here today."));
+
+    executeSynchronously("/")
+        .assertFailure("HTTP 204 had non-zero Content-Length: 39");
+  }
+
+  @Test public void http205WithBodyDisallowed() throws IOException {
+    server.enqueue(new MockResponse()
+        .setResponseCode(205)
+        .setBody("I'm not even supposed to be here today."));
+
+    executeSynchronously("/")
+        .assertFailure("HTTP 205 had non-zero Content-Length: 39");
+  }
+
+  @Test public void canceledBeforeExecute() throws Exception {
+    Call call = client.newCall(new Request.Builder().url(server.url("/a")).build());
+    call.cancel();
+
+    try {
+      call.execute();
+      fail();
+    } catch (IOException expected) {
+    }
+    assertEquals(0, server.getRequestCount());
+  }
+
+  @Test public void cancelDuringHttpConnect() throws Exception {
+    cancelDuringConnect("http");
+  }
+
+  @Test public void cancelDuringHttpsConnect() throws Exception {
+    cancelDuringConnect("https");
+  }
+
+  /** Cancel a call that's waiting for connect to complete. */
+  private void cancelDuringConnect(String scheme) throws Exception {
+    InetSocketAddress socketAddress = startNullServer();
+
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme(scheme)
+        .host(socketAddress.getHostName())
+        .port(socketAddress.getPort())
+        .build();
+
+    long cancelDelayMillis = 300L;
+    Call call = client.newCall(new Request.Builder().url(url).build());
+    cancelLater(call, cancelDelayMillis);
+
+    long startNanos = System.nanoTime();
+    try {
+      call.execute();
+      fail();
+    } catch (IOException expected) {
+    }
+    long elapsedNanos = System.nanoTime() - startNanos;
+    assertEquals(cancelDelayMillis, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 100f);
+  }
+
+  private InetSocketAddress startNullServer() throws IOException {
+    InetSocketAddress address = new InetSocketAddress(InetAddress.getByName("localhost"), 0);
+    nullServer = ServerSocketFactory.getDefault().createServerSocket();
+    nullServer.bind(address);
+    return new InetSocketAddress(address.getAddress(), nullServer.getLocalPort());
+  }
+
+  @Test public void cancelImmediatelyAfterEnqueue() throws Exception {
+    server.enqueue(new MockResponse());
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/a"))
+        .build());
+    call.enqueue(callback);
+    call.cancel();
+    callback.await(server.url("/a")).assertFailure("Canceled");
+  }
+
+  @Test public void cancelAll() throws Exception {
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    call.enqueue(callback);
+    client.dispatcher().cancelAll();
+    callback.await(server.url("/")).assertFailure("Canceled");
+  }
+
+  @Test public void cancelBeforeBodyIsRead() throws Exception {
+    server.enqueue(new MockResponse().setBody("def").throttleBody(1, 750, TimeUnit.MILLISECONDS));
+
+    final Call call = client.newCall(new Request.Builder().url(server.url("/a")).build());
+    ExecutorService executor = Executors.newSingleThreadExecutor();
+    Future<Response> result = executor.submit(new Callable<Response>() {
+      @Override public Response call() throws Exception {
+        return call.execute();
+      }
+    });
+
+    Thread.sleep(100); // wait for it to go in flight.
+
+    call.cancel();
+    try {
+      result.get().body().bytes();
+      fail();
+    } catch (IOException expected) {
+    }
+    assertEquals(1, server.getRequestCount());
+  }
+
+  @Test public void cancelInFlightBeforeResponseReadThrowsIOE() throws Exception {
+    Request request = new Request.Builder().url(server.url("/a")).build();
+    final Call call = client.newCall(request);
+
+    server.setDispatcher(new Dispatcher() {
+      @Override public MockResponse dispatch(RecordedRequest request) {
+        call.cancel();
+        return new MockResponse().setBody("A");
+      }
+    });
+
+    try {
+      call.execute();
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  @Test public void cancelInFlightBeforeResponseReadThrowsIOE_HTTPS() throws Exception {
+    enableTls();
+    cancelInFlightBeforeResponseReadThrowsIOE();
+  }
+
+  @Test public void cancelInFlightBeforeResponseReadThrowsIOE_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    cancelInFlightBeforeResponseReadThrowsIOE();
+  }
+
+  @Test public void cancelInFlightBeforeResponseReadThrowsIOE_SPDY_3() throws Exception {
+    enableProtocol(Protocol.SPDY_3);
+    cancelInFlightBeforeResponseReadThrowsIOE();
+  }
+
+  /**
+   * This test puts a request in front of one that is to be canceled, so that it is canceled before
+   * I/O takes place.
+   */
+  @Test public void canceledBeforeIOSignalsOnFailure() throws Exception {
+    client.dispatcher().setMaxRequests(1); // Force requests to be executed serially.
+
+    Request requestA = new Request.Builder().url(server.url("/a")).build();
+    Request requestB = new Request.Builder().url(server.url("/b")).build();
+    final Call callA = client.newCall(requestA);
+    final Call callB = client.newCall(requestB);
+
+    server.setDispatcher(new Dispatcher() {
+      char nextResponse = 'A';
+
+      @Override public MockResponse dispatch(RecordedRequest request) {
+        callB.cancel();
+        return new MockResponse().setBody(Character.toString(nextResponse++));
+      }
+    });
+
+    callA.enqueue(callback);
+    callB.enqueue(callback);
+    assertEquals("/a", server.takeRequest().getPath());
+
+    callback.await(requestA.url()).assertBody("A");
+    // At this point we know the callback is ready, and that it will receive a cancel failure.
+    callback.await(requestB.url()).assertFailure("Canceled");
+  }
+
+  @Test public void canceledBeforeIOSignalsOnFailure_HTTPS() throws Exception {
+    enableTls();
+    canceledBeforeIOSignalsOnFailure();
+  }
+
+  @Test public void canceledBeforeIOSignalsOnFailure_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    canceledBeforeIOSignalsOnFailure();
+  }
+
+  @Test public void canceledBeforeIOSignalsOnFailure_SPDY_3() throws Exception {
+    enableProtocol(Protocol.SPDY_3);
+    canceledBeforeIOSignalsOnFailure();
+  }
+
+  @Test public void canceledBeforeResponseReadSignalsOnFailure() throws Exception {
+    Request requestA = new Request.Builder().url(server.url("/a")).build();
+    final Call call = client.newCall(requestA);
+    server.setDispatcher(new Dispatcher() {
+      @Override public MockResponse dispatch(RecordedRequest request) {
+        call.cancel();
+        return new MockResponse().setBody("A");
+      }
+    });
+
+    call.enqueue(callback);
+    assertEquals("/a", server.takeRequest().getPath());
+
+    callback.await(requestA.url()).assertFailure("Canceled", "stream was reset: CANCEL",
+        "Socket closed");
+  }
+
+  @Test public void canceledBeforeResponseReadSignalsOnFailure_HTTPS() throws Exception {
+    enableTls();
+    canceledBeforeResponseReadSignalsOnFailure();
+  }
+
+  @Test public void canceledBeforeResponseReadSignalsOnFailure_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    canceledBeforeResponseReadSignalsOnFailure();
+  }
+
+  @Test public void canceledBeforeResponseReadSignalsOnFailure_SPDY_3() throws Exception {
+    enableProtocol(Protocol.SPDY_3);
+    canceledBeforeResponseReadSignalsOnFailure();
+  }
+
+  /**
+   * There's a race condition where the cancel may apply after the stream has already been
+   * processed.
+   */
+  @Test public void canceledAfterResponseIsDeliveredBreaksStreamButSignalsOnce() throws Exception {
+    server.enqueue(new MockResponse().setBody("A"));
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    final AtomicReference<String> bodyRef = new AtomicReference<>();
+    final AtomicBoolean failureRef = new AtomicBoolean();
+
+    Request request = new Request.Builder().url(server.url("/a")).build();
+    final Call call = client.newCall(request);
+    call.enqueue(new Callback() {
+      @Override public void onFailure(Call call, IOException e) {
+        failureRef.set(true);
+        latch.countDown();
+      }
+
+      @Override public void onResponse(Call call, Response response) throws IOException {
+        call.cancel();
+        try {
+          bodyRef.set(response.body().string());
+        } catch (IOException e) { // It is ok if this broke the stream.
+          bodyRef.set("A");
+          throw e; // We expect to not loop into onFailure in this case.
+        } finally {
+          latch.countDown();
+        }
+      }
+    });
+
+    latch.await();
+    assertEquals("A", bodyRef.get());
+    assertFalse(failureRef.get());
+  }
+
+  @Test public void canceledAfterResponseIsDeliveredBreaksStreamButSignalsOnce_HTTPS()
+      throws Exception {
+    enableTls();
+    canceledAfterResponseIsDeliveredBreaksStreamButSignalsOnce();
+  }
+
+  @Test public void canceledAfterResponseIsDeliveredBreaksStreamButSignalsOnce_HTTP_2()
+      throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    canceledAfterResponseIsDeliveredBreaksStreamButSignalsOnce();
+  }
+
+  @Test public void canceledAfterResponseIsDeliveredBreaksStreamButSignalsOnce_SPDY_3()
+      throws Exception {
+    enableProtocol(Protocol.SPDY_3);
+    canceledAfterResponseIsDeliveredBreaksStreamButSignalsOnce();
+  }
+
+  @Test public void cancelWithInterceptor() throws Exception {
+    client = client.newBuilder()
+        .addInterceptor(new Interceptor() {
+          @Override public Response intercept(Chain chain) throws IOException {
+            chain.proceed(chain.request());
+            throw new AssertionError(); // We expect an exception.
+          }
+        }).build();
+
+    Call call = client.newCall(new Request.Builder().url(server.url("/a")).build());
+    call.cancel();
+
+    try {
+      call.execute();
+      fail();
+    } catch (IOException expected) {
+    }
+    assertEquals(0, server.getRequestCount());
+  }
+
+  @Test public void gzip() throws Exception {
+    Buffer gzippedBody = gzip("abcabcabc");
+    String bodySize = Long.toString(gzippedBody.size());
+
+    server.enqueue(new MockResponse()
+        .setBody(gzippedBody)
+        .addHeader("Content-Encoding: gzip"));
+
+    // Confirm that the user request doesn't have Accept-Encoding, and the user
+    // response doesn't have a Content-Encoding or Content-Length.
+    RecordedResponse userResponse = executeSynchronously("/");
+    userResponse.assertCode(200)
+        .assertRequestHeader("Accept-Encoding")
+        .assertHeader("Content-Encoding")
+        .assertHeader("Content-Length")
+        .assertBody("abcabcabc");
+
+    // But the network request doesn't lie. OkHttp used gzip for this call.
+    userResponse.networkResponse()
+        .assertHeader("Content-Encoding", "gzip")
+        .assertHeader("Content-Length", bodySize)
+        .assertRequestHeader("Accept-Encoding", "gzip");
+  }
+
+  /** https://github.com/square/okhttp/issues/1927 */
+  @Test public void gzipResponseAfterAuthenticationChallenge() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(401));
+    server.enqueue(new MockResponse()
+        .setBody(gzip("abcabcabc"))
+        .addHeader("Content-Encoding: gzip"));
+    client = client.newBuilder()
+        .authenticator(new RecordingOkAuthenticator("password"))
+        .build();
+
+    executeSynchronously("/").assertBody("abcabcabc");
+  }
+
+  @Test public void asyncResponseCanBeConsumedLater() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.enqueue(new MockResponse().setBody("def"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .header("User-Agent", "SyncApiTest")
+        .build();
+
+    final BlockingQueue<Response> responseRef = new SynchronousQueue<>();
+    client.newCall(request).enqueue(new Callback() {
+      @Override public void onFailure(Call call, IOException e) {
+        throw new AssertionError();
+      }
+
+      @Override public void onResponse(Call call, Response response) throws IOException {
+        try {
+          responseRef.put(response);
+        } catch (InterruptedException e) {
+          throw new AssertionError();
+        }
+      }
+    });
+
+    Response response = responseRef.take();
+    assertEquals(200, response.code());
+    assertEquals("abc", response.body().string());
+
+    // Make another request just to confirm that that connection can be reused...
+    executeSynchronously("/").assertBody("def");
+    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
+    assertEquals(1, server.takeRequest().getSequenceNumber()); // Connection reused.
+
+    // ... even before we close the response body!
+    response.body().close();
+  }
+
+  @Test public void userAgentIsIncludedByDefault() throws Exception {
+    server.enqueue(new MockResponse());
+
+    executeSynchronously("/");
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertTrue(recordedRequest.getHeader("User-Agent")
+        .matches(Version.userAgent()));
+  }
+
+  @Test public void setFollowRedirectsFalse() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(302)
+        .addHeader("Location: /b")
+        .setBody("A"));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    client = client.newBuilder()
+        .followRedirects(false)
+        .build();
+    executeSynchronously("/a")
+        .assertBody("A")
+        .assertCode(302);
+  }
+
+  @Test public void expect100ContinueNonEmptyRequestBody() throws Exception {
+    server.enqueue(new MockResponse());
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .header("Expect", "100-continue")
+        .post(RequestBody.create(MediaType.parse("text/plain"), "abc"))
+        .build();
+
+    executeSynchronously(request)
+        .assertCode(200)
+        .assertSuccessful();
+
+    assertEquals("abc", server.takeRequest().getBody().readUtf8());
+  }
+
+  @Test public void expect100ContinueEmptyRequestBody() throws Exception {
+    server.enqueue(new MockResponse());
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .header("Expect", "100-continue")
+        .post(RequestBody.create(MediaType.parse("text/plain"), ""))
+        .build();
+
+    executeSynchronously(request)
+        .assertCode(200)
+        .assertSuccessful();
+  }
+
+  /** We forbid non-ASCII characters in outgoing request headers, but accept UTF-8. */
+  @Test public void responseHeaderParsingIsLenient() throws Exception {
+    Headers headers = new Headers.Builder()
+        .add("Content-Length", "0")
+        .addLenient("a\tb: c\u007fd")
+        .addLenient(": ef")
+        .addLenient("\ud83c\udf69: \u2615\ufe0f")
+        .build();
+    server.enqueue(new MockResponse().setHeaders(headers));
+
+    executeSynchronously("/")
+        .assertHeader("a\tb", "c\u007fd")
+        .assertHeader("\ud83c\udf69", "\u2615\ufe0f")
+        .assertHeader("", "ef");
+  }
+
+  @Test public void customDns() throws Exception {
+    // Configure a DNS that returns our MockWebServer for every hostname.
+    FakeDns dns = new FakeDns();
+    dns.addresses(Dns.SYSTEM.lookup(server.url("/").host()));
+    client = client.newBuilder()
+        .dns(dns)
+        .build();
+
+    server.enqueue(new MockResponse());
+    Request request = new Request.Builder()
+        .url(server.url("/").newBuilder().host("android.com").build())
+        .build();
+    executeSynchronously(request).assertCode(200);
+
+    dns.assertRequests("android.com");
+  }
+
+  /** We had a bug where failed HTTP/2 calls could break the entire connection. */
+  @Test public void failingCallsDoNotInterfereWithConnection() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+
+    server.enqueue(new MockResponse().setBody("Response 1"));
+    server.enqueue(new MockResponse().setBody("Response 2"));
+
+    RequestBody requestBody = new RequestBody() {
+      @Override public MediaType contentType() {
+        return null;
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        sink.writeUtf8("abc");
+        sink.flush();
+
+        makeFailingCall();
+
+        sink.writeUtf8("def");
+        sink.flush();
+      }
+    };
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .post(requestBody)
+        .build());
+    assertEquals("Response 1", call.execute().body().string());
+  }
+
+  /** Test which headers are sent unencrypted to the HTTP proxy. */
+  @Test public void proxyConnectOmitsApplicationHeaders() throws Exception {
+    server.useHttps(sslClient.socketFactory, true);
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
+        .clearHeaders());
+    server.enqueue(new MockResponse()
+        .setBody("encrypted response from the origin server"));
+
+    RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
+    client = client.newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .proxy(server.toProxyAddress())
+        .hostnameVerifier(hostnameVerifier)
+        .build();
+
+    Request request = new Request.Builder()
+        .url("https://android.com/foo")
+        .header("Private", "Secret")
+        .header("User-Agent", "App 1.0")
+        .build();
+    Response response = client.newCall(request).execute();
+    assertEquals("encrypted response from the origin server", response.body().string());
+
+    RecordedRequest connect = server.takeRequest();
+    assertNull(connect.getHeader("Private"));
+    assertEquals(Version.userAgent(), connect.getHeader("User-Agent"));
+    assertEquals("Keep-Alive", connect.getHeader("Proxy-Connection"));
+    assertEquals("android.com:443", connect.getHeader("Host"));
+
+    RecordedRequest get = server.takeRequest();
+    assertEquals("Secret", get.getHeader("Private"));
+    assertEquals("App 1.0", get.getHeader("User-Agent"));
+
+    assertEquals(Arrays.asList("verify android.com"), hostnameVerifier.calls);
+  }
+
+  /** Respond to a proxy authorization challenge. */
+  @Test public void proxyAuthenticateOnConnect() throws Exception {
+    server.useHttps(sslClient.socketFactory, true);
+    server.enqueue(new MockResponse()
+        .setResponseCode(407)
+        .addHeader("Proxy-Authenticate: Basic realm=\"localhost\""));
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
+        .clearHeaders());
+    server.enqueue(new MockResponse()
+        .setBody("response body"));
+
+    client = client.newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .proxy(server.toProxyAddress())
+        .proxyAuthenticator(new RecordingOkAuthenticator("password"))
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build();
+
+    Request request = new Request.Builder()
+        .url("https://android.com/foo")
+        .build();
+    Response response = client.newCall(request).execute();
+    assertEquals("response body", response.body().string());
+
+    RecordedRequest connect1 = server.takeRequest();
+    assertEquals("CONNECT android.com:443 HTTP/1.1", connect1.getRequestLine());
+    assertNull(connect1.getHeader("Proxy-Authorization"));
+
+    RecordedRequest connect2 = server.takeRequest();
+    assertEquals("CONNECT android.com:443 HTTP/1.1", connect2.getRequestLine());
+    assertEquals("password", connect2.getHeader("Proxy-Authorization"));
+
+    RecordedRequest get = server.takeRequest();
+    assertEquals("GET /foo HTTP/1.1", get.getRequestLine());
+    assertNull(get.getHeader("Proxy-Authorization"));
+  }
+
+  /** Confirm that the proxy authenticator works for unencrypted HTTP proxies. */
+  @Test public void httpProxyAuthenticate() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(407)
+        .addHeader("Proxy-Authenticate: Basic realm=\"localhost\""));
+    server.enqueue(new MockResponse()
+        .setBody("response body"));
+
+    client = client.newBuilder()
+        .proxy(server.toProxyAddress())
+        .proxyAuthenticator(new RecordingOkAuthenticator("password"))
+        .build();
+
+    Request request = new Request.Builder()
+        .url("http://android.com/foo")
+        .build();
+    Response response = client.newCall(request).execute();
+    assertEquals("response body", response.body().string());
+
+    RecordedRequest get1 = server.takeRequest();
+    assertEquals("GET http://android.com/foo HTTP/1.1", get1.getRequestLine());
+    assertNull(get1.getHeader("Proxy-Authorization"));
+
+    RecordedRequest get2 = server.takeRequest();
+    assertEquals("GET http://android.com/foo HTTP/1.1", get2.getRequestLine());
+    assertEquals("password", get2.getHeader("Proxy-Authorization"));
+  }
+
+  /**
+   * OkHttp has a bug where a `Connection: close` response header is not honored when establishing
+   * a TLS tunnel. https://github.com/square/okhttp/issues/2426
+   */
+  @Test public void proxyAuthenticateOnConnectWithConnectionClose() throws Exception {
+    server.useHttps(sslClient.socketFactory, true);
+    server.setProtocols(Collections.singletonList(Protocol.HTTP_1_1));
+    server.enqueue(new MockResponse()
+        .setResponseCode(407)
+        .addHeader("Proxy-Authenticate: Basic realm=\"localhost\"")
+        .addHeader("Connection: close"));
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
+        .clearHeaders());
+    server.enqueue(new MockResponse()
+        .setBody("response body"));
+
+    client = client.newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .proxy(server.toProxyAddress())
+        .proxyAuthenticator(new RecordingOkAuthenticator("password"))
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build();
+
+    Request request = new Request.Builder()
+        .url("https://android.com/foo")
+        .build();
+    Response response = client.newCall(request).execute();
+    assertEquals("response body", response.body().string());
+
+    // First CONNECT call needs a new connection.
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+
+    // Second CONNECT call needs a new connection.
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+
+    // GET reuses the connection from the second connect.
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void tooManyProxyAuthFailuresWithConnectionClose() throws IOException {
+    server.useHttps(sslClient.socketFactory, true);
+    server.setProtocols(Collections.singletonList(Protocol.HTTP_1_1));
+    for (int i = 0; i < 21; i++) {
+      server.enqueue(new MockResponse()
+          .setResponseCode(407)
+          .addHeader("Proxy-Authenticate: Basic realm=\"localhost\"")
+          .addHeader("Connection: close"));
+    }
+
+    client = client.newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .proxy(server.toProxyAddress())
+        .proxyAuthenticator(new RecordingOkAuthenticator("password"))
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build();
+
+    Request request = new Request.Builder()
+        .url("https://android.com/foo")
+        .build();
+    try {
+      client.newCall(request).execute();
+      fail();
+    } catch (ProtocolException expected) {
+    }
+  }
+
+  /**
+   * Confirm that we don't send the Proxy-Authorization header from the request to the proxy server.
+   * We used to have that behavior but it is problematic because unrelated requests end up sharing
+   * credentials. Worse, that approach leaks proxy credentials to the origin server.
+   */
+  @Test public void noProactiveProxyAuthorization() throws Exception {
+    server.useHttps(sslClient.socketFactory, true);
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
+        .clearHeaders());
+    server.enqueue(new MockResponse()
+        .setBody("response body"));
+
+    client = client.newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .proxy(server.toProxyAddress())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build();
+
+    Request request = new Request.Builder()
+        .url("https://android.com/foo")
+        .header("Proxy-Authorization", "password")
+        .build();
+    Response response = client.newCall(request).execute();
+    assertEquals("response body", response.body().string());
+
+    RecordedRequest connect = server.takeRequest();
+    assertNull(connect.getHeader("Proxy-Authorization"));
+
+    RecordedRequest get = server.takeRequest();
+    assertEquals("password", get.getHeader("Proxy-Authorization"));
+  }
+
+  @Test public void interceptorGetsFramedProtocol() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+
+    // Capture the protocol as it is observed by the interceptor.
+    final AtomicReference<Protocol> protocolRef = new AtomicReference<>();
+    Interceptor interceptor = new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        protocolRef.set(chain.connection().protocol());
+        return chain.proceed(chain.request());
+      }
+    };
+    client = client.newBuilder()
+        .addNetworkInterceptor(interceptor)
+        .build();
+
+    // Make an HTTP/2 request and confirm that the protocol matches.
+    server.enqueue(new MockResponse());
+    executeSynchronously("/");
+    assertEquals(Protocol.HTTP_2, protocolRef.get());
+  }
+
+  @Test public void serverSendsInvalidResponseHeaders() throws Exception {
+    server.enqueue(new MockResponse()
+        .setStatus("HTP/1.1 200 OK"));
+
+    executeSynchronously("/")
+        .assertFailure("Unexpected status line: HTP/1.1 200 OK");
+  }
+
+  @Test public void serverSendsInvalidCodeTooLarge() throws Exception {
+    server.enqueue(new MockResponse()
+        .setStatus("HTTP/1.1 2147483648 OK"));
+
+    executeSynchronously("/")
+        .assertFailure("Unexpected status line: HTTP/1.1 2147483648 OK");
+  }
+
+  @Test public void serverSendsInvalidCodeNotANumber() throws Exception {
+    server.enqueue(new MockResponse()
+        .setStatus("HTTP/1.1 00a OK"));
+
+    executeSynchronously("/")
+        .assertFailure("Unexpected status line: HTTP/1.1 00a OK");
+  }
+
+  @Test public void serverSendsUnnecessaryWhitespace() throws Exception {
+    server.enqueue(new MockResponse()
+        .setStatus(" HTTP/1.1 200 OK"));
+
+    executeSynchronously("/")
+        .assertFailure("Unexpected status line:  HTTP/1.1 200 OK");
+  }
+
+  @Test public void connectFails() throws Exception {
+    server.shutdown();
+
+    executeSynchronously("/")
+        .assertFailure(IOException.class);
+  }
+
+  @Test public void requestBodySurvivesRetries() throws Exception {
+    server.enqueue(new MockResponse());
+
+    // Enable a misconfigured proxy selector to guarantee that the request is retried.
+    client = client.newBuilder()
+        .proxySelector(new FakeProxySelector()
+            .addProxy(server2.toProxyAddress()))
+        .build();
+    server2.shutdown();
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .post(RequestBody.create(MediaType.parse("text/plain"), "abc"))
+        .build();
+
+    executeSynchronously(request);
+    assertEquals("abc", server.takeRequest().getBody().readUtf8());
+  }
+
+  @Ignore // This may fail in DNS lookup, which we don't have timeouts for.
+  @Test public void invalidHost() throws Exception {
+    Request request = new Request.Builder()
+        .url(HttpUrl.parse("http://1234.1.1.1/"))
+        .build();
+
+    executeSynchronously(request)
+        .assertFailure(UnknownHostException.class);
+  }
+
+  @Test public void uploadBodySmallChunkedEncoding() throws Exception {
+    upload(true, 1048576, 256);
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals(1048576, recordedRequest.getBodySize());
+    assertFalse(recordedRequest.getChunkSizes().isEmpty());
+  }
+
+  @Test public void uploadBodyLargeChunkedEncoding() throws Exception {
+    upload(true, 1048576, 65536);
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals(1048576, recordedRequest.getBodySize());
+    assertFalse(recordedRequest.getChunkSizes().isEmpty());
+  }
+
+  @Test public void uploadBodySmallFixedLength() throws Exception {
+    upload(false, 1048576, 256);
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals(1048576, recordedRequest.getBodySize());
+    assertTrue(recordedRequest.getChunkSizes().isEmpty());
+  }
+
+  @Test public void uploadBodyLargeFixedLength() throws Exception {
+    upload(false, 1048576, 65536);
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals(1048576, recordedRequest.getBodySize());
+    assertTrue(recordedRequest.getChunkSizes().isEmpty());
+  }
+
+  private void upload(
+      final boolean chunked, final int size, final int writeSize) throws Exception {
+    server.enqueue(new MockResponse());
+    executeSynchronously(new Request.Builder()
+        .url(server.url("/"))
+        .post(requestBody(chunked, size, writeSize))
+        .build());
+  }
+
+  /** https://github.com/square/okhttp/issues/2344 */
+  @Test public void ipv6HostHasSquareBraces() throws Exception {
+    // Use a proxy to fake IPv6 connectivity, even if localhost doesn't have IPv6.
+    server.useHttps(sslClient.socketFactory, true);
+    server.setProtocols(Collections.singletonList(Protocol.HTTP_1_1));
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
+        .clearHeaders());
+    server.enqueue(new MockResponse()
+        .setBody("response body"));
+
+    client = client.newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .proxy(server.toProxyAddress())
+        .build();
+
+    Request request = new Request.Builder()
+        .url("https://[::1]/")
+        .build();
+    Response response = client.newCall(request).execute();
+    assertEquals("response body", response.body().string());
+
+    RecordedRequest connect = server.takeRequest();
+    assertEquals("CONNECT [::1]:443 HTTP/1.1", connect.getRequestLine());
+    assertEquals("[::1]:443", connect.getHeader("Host"));
+
+    RecordedRequest get = server.takeRequest();
+    assertEquals("GET / HTTP/1.1", get.getRequestLine());
+    assertEquals("[::1]", get.getHeader("Host"));
+  }
+
+  private RequestBody requestBody(final boolean chunked, final long size, final int writeSize) {
+    final byte[] buffer = new byte[writeSize];
+    Arrays.fill(buffer, (byte) 'x');
+
+    return new RequestBody() {
+      @Override public MediaType contentType() {
+        return MediaType.parse("text/plain; charset=utf-8");
+      }
+
+      @Override public long contentLength() throws IOException {
+        return chunked ? -1L : size;
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        for (int count = 0; count < size; count += writeSize) {
+          sink.write(buffer, 0, (int) Math.min(size - count, writeSize));
+        }
+      }
+    };
+  }
+
+  @Test public void emptyResponseBody() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("abc", "def"));
+    executeSynchronously("/")
+        .assertCode(200)
+        .assertHeader("abc", "def")
+        .assertBody("");
+  }
+
+  private void makeFailingCall() {
+    RequestBody requestBody = new RequestBody() {
+      @Override public MediaType contentType() {
+        return null;
+      }
+
+      @Override public long contentLength() throws IOException {
+        return 1;
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        throw new IOException("write body fail!");
+      }
+    };
+    OkHttpClient nonRetryingClient = client.newBuilder()
+        .retryOnConnectionFailure(false)
+        .build();
+    Call call = nonRetryingClient.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .post(requestBody)
+        .build());
+    try {
+      call.execute();
+      fail();
+    } catch (IOException expected) {
+      assertEquals("write body fail!", expected.getMessage());
+    }
+  }
+
+  private RecordedResponse executeSynchronously(String path, String... headers) throws IOException {
+    Request.Builder builder = new Request.Builder();
+    builder.url(server.url(path));
+    for (int i = 0, size = headers.length; i < size; i += 2) {
+      builder.addHeader(headers[i], headers[i + 1]);
+    }
+    return executeSynchronously(builder.build());
+  }
+
+  private RecordedResponse executeSynchronously(Request request) throws IOException {
+    Call call = client.newCall(request);
+    try {
+      Response response = call.execute();
+      String bodyString = response.body().string();
+      return new RecordedResponse(request, response, null, bodyString, null);
+    } catch (IOException e) {
+      return new RecordedResponse(request, null, null, null, e);
+    }
+  }
+
+  /**
+   * Tests that use this will fail unless boot classpath is set. Ex. {@code
+   * -Xbootclasspath/p:/tmp/alpn-boot-8.0.0.v20140317}
+   */
+  private void enableProtocol(Protocol protocol) {
+    enableTls();
+    client = client.newBuilder()
+        .protocols(Arrays.asList(protocol, Protocol.HTTP_1_1))
+        .build();
+    server.setProtocols(client.protocols());
+  }
+
+  private void enableTls() {
+    client = client.newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build();
+    server.useHttps(sslClient.socketFactory, false);
+  }
+
+  private Buffer gzip(String data) throws IOException {
+    Buffer result = new Buffer();
+    BufferedSink sink = Okio.buffer(new GzipSink(result));
+    sink.writeUtf8(data);
+    sink.close();
+    return result;
+  }
+
+  private void cancelLater(final Call call, final long delay) {
+    new Thread("canceler") {
+      @Override public void run() {
+        try {
+          Thread.sleep(delay);
+        } catch (InterruptedException e) {
+          throw new AssertionError();
+        }
+        call.cancel();
+      }
+    }.start();
+  }
+
+  private static class RecordingSSLSocketFactory extends DelegatingSSLSocketFactory {
+
+    private List<SSLSocket> socketsCreated = new ArrayList<>();
+
+    public RecordingSSLSocketFactory(SSLSocketFactory delegate) {
+      super(delegate);
+    }
+
+    @Override
+    protected SSLSocket configureSocket(SSLSocket sslSocket) throws IOException {
+      socketsCreated.add(sslSocket);
+      return sslSocket;
+    }
+
+    public List<SSLSocket> getSocketsCreated() {
+      return socketsCreated;
+    }
+  }
+
+  /**
+   * Used during tests that involve TLS connection fallback attempts. OkHttp includes the
+   * TLS_FALLBACK_SCSV cipher on fallback connections. See {@link FallbackTestClientSocketFactory}
+   * for details.
+   */
+  private FallbackTestClientSocketFactory suppressTlsFallbackClientSocketFactory() {
+    return new FallbackTestClientSocketFactory(sslClient.socketFactory);
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/CertificateChainCleanerTest.java b/okhttp-tests/src/test/java/okhttp3/CertificateChainCleanerTest.java
new file mode 100644
index 0000000000..261c99f8b6
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/CertificateChainCleanerTest.java
@@ -0,0 +1,252 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.security.GeneralSecurityException;
+import java.security.cert.Certificate;
+import java.security.cert.X509Certificate;
+import java.util.ArrayList;
+import java.util.List;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import okhttp3.internal.tls.HeldCertificate;
+import okhttp3.internal.tls.CertificateChainCleaner;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+public final class CertificateChainCleanerTest {
+  @Test public void normalizeSingleSelfSignedCertificate() throws Exception {
+    HeldCertificate root = new HeldCertificate.Builder()
+        .serialNumber("1")
+        .build();
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate);
+    assertEquals(list(root), cleaner.clean(list(root), "hostname"));
+  }
+
+  @Test public void normalizeUnknownSelfSignedCertificate() throws Exception {
+    HeldCertificate root = new HeldCertificate.Builder()
+        .serialNumber("1")
+        .build();
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get();
+
+    try {
+      cleaner.clean(list(root), "hostname");
+      fail();
+    } catch (SSLPeerUnverifiedException expected) {
+    }
+  }
+
+  @Test public void orderedChainOfCertificatesWithRoot() throws Exception {
+    HeldCertificate root = new HeldCertificate.Builder()
+        .serialNumber("1")
+        .build();
+    HeldCertificate certA = new HeldCertificate.Builder()
+        .serialNumber("2")
+        .issuedBy(root)
+        .build();
+    HeldCertificate certB = new HeldCertificate.Builder()
+        .serialNumber("3")
+        .issuedBy(certA)
+        .build();
+
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate);
+    assertEquals(list(certB, certA, root), cleaner.clean(list(certB, certA, root), "hostname"));
+  }
+
+  @Test public void orderedChainOfCertificatesWithoutRoot() throws Exception {
+    HeldCertificate root = new HeldCertificate.Builder()
+        .serialNumber("1")
+        .build();
+    HeldCertificate certA = new HeldCertificate.Builder()
+        .serialNumber("2")
+        .issuedBy(root)
+        .build();
+    HeldCertificate certB = new HeldCertificate.Builder()
+        .serialNumber("3")
+        .issuedBy(certA)
+        .build();
+
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate);
+    assertEquals(list(certB, certA, root),
+        cleaner.clean(list(certB, certA), "hostname")); // Root is added!
+  }
+
+  @Test public void unorderedChainOfCertificatesWithRoot() throws Exception {
+    HeldCertificate root = new HeldCertificate.Builder()
+        .serialNumber("1")
+        .build();
+    HeldCertificate certA = new HeldCertificate.Builder()
+        .serialNumber("2")
+        .issuedBy(root)
+        .build();
+    HeldCertificate certB = new HeldCertificate.Builder()
+        .serialNumber("3")
+        .issuedBy(certA)
+        .build();
+    HeldCertificate certC = new HeldCertificate.Builder()
+        .serialNumber("4")
+        .issuedBy(certB)
+        .build();
+
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate);
+    assertEquals(list(certC, certB, certA, root),
+        cleaner.clean(list(certC, certA, root, certB), "hostname"));
+  }
+
+  @Test public void unorderedChainOfCertificatesWithoutRoot() throws Exception {
+    HeldCertificate root = new HeldCertificate.Builder()
+        .serialNumber("1")
+        .build();
+    HeldCertificate certA = new HeldCertificate.Builder()
+        .serialNumber("2")
+        .issuedBy(root)
+        .build();
+    HeldCertificate certB = new HeldCertificate.Builder()
+        .serialNumber("3")
+        .issuedBy(certA)
+        .build();
+    HeldCertificate certC = new HeldCertificate.Builder()
+        .serialNumber("4")
+        .issuedBy(certB)
+        .build();
+
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate);
+    assertEquals(list(certC, certB, certA, root),
+        cleaner.clean(list(certC, certA, certB), "hostname"));
+  }
+
+  @Test public void unrelatedCertificatesAreOmitted() throws Exception {
+    HeldCertificate root = new HeldCertificate.Builder()
+        .serialNumber("1")
+        .build();
+    HeldCertificate certA = new HeldCertificate.Builder()
+        .serialNumber("2")
+        .issuedBy(root)
+        .build();
+    HeldCertificate certB = new HeldCertificate.Builder()
+        .serialNumber("3")
+        .issuedBy(certA)
+        .build();
+    HeldCertificate certUnnecessary = new HeldCertificate.Builder()
+        .serialNumber("4")
+        .build();
+
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate);
+    assertEquals(list(certB, certA, root),
+        cleaner.clean(list(certB, certUnnecessary, certA, root), "hostname"));
+  }
+
+  @Test public void chainGoesAllTheWayToSelfSignedRoot() throws Exception {
+    HeldCertificate selfSigned = new HeldCertificate.Builder()
+        .serialNumber("1")
+        .build();
+    HeldCertificate trusted = new HeldCertificate.Builder()
+        .serialNumber("2")
+        .issuedBy(selfSigned)
+        .build();
+    HeldCertificate certA = new HeldCertificate.Builder()
+        .serialNumber("3")
+        .issuedBy(trusted)
+        .build();
+    HeldCertificate certB = new HeldCertificate.Builder()
+        .serialNumber("4")
+        .issuedBy(certA)
+        .build();
+
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get(
+        selfSigned.certificate, trusted.certificate);
+    assertEquals(list(certB, certA, trusted, selfSigned),
+        cleaner.clean(list(certB, certA), "hostname"));
+    assertEquals(list(certB, certA, trusted, selfSigned),
+        cleaner.clean(list(certB, certA, trusted), "hostname"));
+    assertEquals(list(certB, certA, trusted, selfSigned),
+        cleaner.clean(list(certB, certA, trusted, selfSigned), "hostname"));
+  }
+
+  @Test public void trustedRootNotSelfSigned() throws Exception {
+    HeldCertificate unknownSigner = new HeldCertificate.Builder()
+        .serialNumber("1")
+        .build();
+    HeldCertificate trusted = new HeldCertificate.Builder()
+        .issuedBy(unknownSigner)
+        .serialNumber("2")
+        .build();
+    HeldCertificate intermediateCa = new HeldCertificate.Builder()
+        .issuedBy(trusted)
+        .serialNumber("3")
+        .build();
+    HeldCertificate certificate = new HeldCertificate.Builder()
+        .issuedBy(intermediateCa)
+        .serialNumber("4")
+        .build();
+
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get(trusted.certificate);
+    assertEquals(list(certificate, intermediateCa, trusted),
+        cleaner.clean(list(certificate, intermediateCa), "hostname"));
+    assertEquals(list(certificate, intermediateCa, trusted),
+        cleaner.clean(list(certificate, intermediateCa, trusted), "hostname"));
+  }
+
+  @Test public void chainMaxLength() throws Exception {
+    List<HeldCertificate> heldCertificates = chainOfLength(10);
+    List<Certificate> certificates = new ArrayList<>();
+    for (HeldCertificate heldCertificate : heldCertificates) {
+      certificates.add(heldCertificate.certificate);
+    }
+
+    X509Certificate root = heldCertificates.get(heldCertificates.size() - 1).certificate;
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root);
+    assertEquals(certificates, cleaner.clean(certificates, "hostname"));
+    assertEquals(certificates, cleaner.clean(certificates.subList(0, 9), "hostname"));
+  }
+
+  @Test public void chainTooLong() throws Exception {
+    List<HeldCertificate> heldCertificates = chainOfLength(11);
+    List<Certificate> certificates = new ArrayList<>();
+    for (HeldCertificate heldCertificate : heldCertificates) {
+      certificates.add(heldCertificate.certificate);
+    }
+
+    X509Certificate root = heldCertificates.get(heldCertificates.size() - 1).certificate;
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root);
+    try {
+      cleaner.clean(certificates, "hostname");
+      fail();
+    } catch (SSLPeerUnverifiedException expected) {
+    }
+  }
+
+  /** Returns a chain starting at the leaf certificate and progressing to the root. */
+  private List<HeldCertificate> chainOfLength(int length) throws GeneralSecurityException {
+    List<HeldCertificate> result = new ArrayList<>();
+    for (int i = 1; i <= length; i++) {
+      result.add(0, new HeldCertificate.Builder()
+          .issuedBy(!result.isEmpty() ? result.get(0) : null)
+          .serialNumber(Integer.toString(i))
+          .build());
+    }
+    return result;
+  }
+
+  private List<Certificate> list(HeldCertificate... heldCertificates) {
+    List<Certificate> result = new ArrayList<>();
+    for (HeldCertificate heldCertificate : heldCertificates) {
+      result.add(heldCertificate.certificate);
+    }
+    return result;
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/CertificatePinnerTest.java b/okhttp-tests/src/test/java/okhttp3/CertificatePinnerTest.java
new file mode 100644
index 0000000000..26207c5980
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/CertificatePinnerTest.java
@@ -0,0 +1,278 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.security.GeneralSecurityException;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import okhttp3.CertificatePinner.Pin;
+import okhttp3.internal.tls.HeldCertificate;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class CertificatePinnerTest {
+  static HeldCertificate certA1;
+  static String certA1Sha256Pin;
+
+  static HeldCertificate certB1;
+  static String certB1Sha256Pin;
+
+  static HeldCertificate certC1;
+  static String certC1Sha256Pin;
+
+  static {
+    try {
+      certA1 = new HeldCertificate.Builder()
+          .serialNumber("100")
+          .build();
+      certA1Sha256Pin = "sha256/" + CertificatePinner.sha256(certA1.certificate).base64();
+
+      certB1 = new HeldCertificate.Builder()
+          .serialNumber("200")
+          .build();
+      certB1Sha256Pin = "sha256/" + CertificatePinner.sha256(certB1.certificate).base64();
+
+      certC1 = new HeldCertificate.Builder()
+          .serialNumber("300")
+          .build();
+      certC1Sha256Pin = "sha256/" + CertificatePinner.sha256(certC1.certificate).base64();
+    } catch (GeneralSecurityException e) {
+      throw new AssertionError(e);
+    }
+  }
+
+  @Test public void malformedPin() throws Exception {
+    CertificatePinner.Builder builder = new CertificatePinner.Builder();
+    try {
+      builder.add("example.com", "md5/DmxUShsZuNiqPQsX2Oi9uv2sCnw=");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void malformedBase64() throws Exception {
+    CertificatePinner.Builder builder = new CertificatePinner.Builder();
+    try {
+      builder.add("example.com", "sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw*");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  /** Multiple certificates generated from the same keypair have the same pin. */
+  @Test public void sameKeypairSamePin() throws Exception {
+    HeldCertificate heldCertificateA2 = new HeldCertificate.Builder()
+        .keyPair(certA1.keyPair)
+        .serialNumber("101")
+        .build();
+    String keypairACertificate2Pin = CertificatePinner.pin(heldCertificateA2.certificate);
+
+    HeldCertificate heldCertificateB2 = new HeldCertificate.Builder()
+        .keyPair(certB1.keyPair)
+        .serialNumber("201")
+        .build();
+    String keypairBCertificate2Pin = CertificatePinner.pin(heldCertificateB2.certificate);
+
+    assertTrue(certA1Sha256Pin.equals(keypairACertificate2Pin));
+    assertTrue(certB1Sha256Pin.equals(keypairBCertificate2Pin));
+    assertFalse(certA1Sha256Pin.equals(certB1Sha256Pin));
+  }
+
+  @Test public void successfulCheck() throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("example.com", certA1Sha256Pin)
+        .build();
+
+    certificatePinner.check("example.com", certA1.certificate);
+  }
+
+  @Test public void successfulCheckSha1Pin() throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("example.com", "sha1/" + CertificatePinner.sha1(certA1.certificate).base64())
+        .build();
+
+    certificatePinner.check("example.com", certA1.certificate);
+  }
+
+  @Test public void successfulMatchAcceptsAnyMatchingCertificate() throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("example.com", certB1Sha256Pin)
+        .build();
+
+    certificatePinner.check("example.com", certA1.certificate, certB1.certificate);
+  }
+
+  @Test public void unsuccessfulCheck() throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("example.com", certA1Sha256Pin)
+        .build();
+
+    try {
+      certificatePinner.check("example.com", certB1.certificate);
+      fail();
+    } catch (SSLPeerUnverifiedException expected) {
+    }
+  }
+
+  @Test public void multipleCertificatesForOneHostname() throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("example.com", certA1Sha256Pin, certB1Sha256Pin)
+        .build();
+
+    certificatePinner.check("example.com", certA1.certificate);
+    certificatePinner.check("example.com", certB1.certificate);
+  }
+
+  @Test public void multipleHostnamesForOneCertificate() throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("example.com", certA1Sha256Pin)
+        .add("www.example.com", certA1Sha256Pin)
+        .build();
+
+    certificatePinner.check("example.com", certA1.certificate);
+    certificatePinner.check("www.example.com", certA1.certificate);
+  }
+
+  @Test public void absentHostnameMatches() throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder().build();
+    certificatePinner.check("example.com", certA1.certificate);
+  }
+
+  @Test public void successfulCheckForWildcardHostname() throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("*.example.com", certA1Sha256Pin)
+        .build();
+
+    certificatePinner.check("a.example.com", certA1.certificate);
+  }
+
+  @Test public void successfulMatchAcceptsAnyMatchingCertificateForWildcardHostname()
+      throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("*.example.com", certB1Sha256Pin)
+        .build();
+
+    certificatePinner.check("a.example.com", certA1.certificate, certB1.certificate);
+  }
+
+  @Test public void unsuccessfulCheckForWildcardHostname() throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("*.example.com", certA1Sha256Pin)
+        .build();
+
+    try {
+      certificatePinner.check("a.example.com", certB1.certificate);
+      fail();
+    } catch (SSLPeerUnverifiedException expected) {
+    }
+  }
+
+  @Test public void multipleCertificatesForOneWildcardHostname() throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("*.example.com", certA1Sha256Pin, certB1Sha256Pin)
+        .build();
+
+    certificatePinner.check("a.example.com", certA1.certificate);
+    certificatePinner.check("a.example.com", certB1.certificate);
+  }
+
+  @Test public void successfulCheckForOneHostnameWithWildcardAndDirectCertificate()
+      throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("*.example.com", certA1Sha256Pin)
+        .add("a.example.com", certB1Sha256Pin)
+        .build();
+
+    certificatePinner.check("a.example.com", certA1.certificate);
+    certificatePinner.check("a.example.com", certB1.certificate);
+  }
+
+  @Test public void unsuccessfulCheckForOneHostnameWithWildcardAndDirectCertificate()
+      throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("*.example.com", certA1Sha256Pin)
+        .add("a.example.com", certB1Sha256Pin)
+        .build();
+
+    try {
+      certificatePinner.check("a.example.com", certC1.certificate);
+      fail();
+    } catch (SSLPeerUnverifiedException expected) {
+    }
+  }
+
+  @Test public void successfulFindMatchingPins() {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("first.com", certA1Sha256Pin, certB1Sha256Pin)
+        .add("second.com", certC1Sha256Pin)
+        .build();
+
+    List<Pin> expectedPins = Arrays.asList(
+        new Pin("first.com", certA1Sha256Pin),
+        new Pin("first.com", certB1Sha256Pin));
+    assertEquals(expectedPins, certificatePinner.findMatchingPins("first.com"));
+  }
+
+  @Test public void successfulFindMatchingPinsForWildcardAndDirectCertificates() {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("*.example.com", certA1Sha256Pin)
+        .add("a.example.com", certB1Sha256Pin)
+        .add("b.example.com", certC1Sha256Pin)
+        .build();
+
+    List<Pin> expectedPins = Arrays.asList(
+        new Pin("*.example.com", certA1Sha256Pin),
+        new Pin("a.example.com", certB1Sha256Pin));
+    assertEquals(expectedPins, certificatePinner.findMatchingPins("a.example.com"));
+  }
+
+  @Test public void wildcardHostnameShouldNotMatchThroughDot() throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("*.example.com", certA1Sha256Pin)
+        .build();
+
+    assertEquals(Collections.emptyList(), certificatePinner.findMatchingPins("example.com"));
+    assertEquals(Collections.emptyList(), certificatePinner.findMatchingPins("a.b.example.com"));
+  }
+
+  @Test public void successfulFindMatchingPinsIgnoresCase() {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("EXAMPLE.com", certA1Sha256Pin)
+        .add("*.MyExample.Com", certB1Sha256Pin)
+        .build();
+
+    List<Pin> expectedPin1 = Arrays.asList(new Pin("EXAMPLE.com", certA1Sha256Pin));
+    assertEquals(expectedPin1, certificatePinner.findMatchingPins("example.com"));
+
+    List<Pin> expectedPin2 = Arrays.asList(new Pin("*.MyExample.Com", certB1Sha256Pin));
+    assertEquals(expectedPin2, certificatePinner.findMatchingPins("a.myexample.com"));
+  }
+
+  @Test public void successfulFindMatchingPinPunycode() {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("σkhttp.com", certA1Sha256Pin)
+        .build();
+
+    List<Pin> expectedPin = Arrays.asList(new Pin("σkhttp.com", certA1Sha256Pin));
+    assertEquals(expectedPin, certificatePinner.findMatchingPins("xn--khttp-fde.com"));
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/ConnectionPoolTest.java b/okhttp-tests/src/test/java/okhttp3/ConnectionPoolTest.java
new file mode 100644
index 0000000000..84ebbc6824
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/ConnectionPoolTest.java
@@ -0,0 +1,211 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.net.InetSocketAddress;
+import java.net.Proxy;
+import java.net.ProxySelector;
+import java.net.Socket;
+import java.util.Collections;
+import java.util.concurrent.TimeUnit;
+import javax.net.SocketFactory;
+import okhttp3.internal.Internal;
+import okhttp3.internal.RecordingOkAuthenticator;
+import okhttp3.internal.http.StreamAllocation;
+import okhttp3.internal.io.RealConnection;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+public final class ConnectionPoolTest {
+  private final Address addressA = newAddress("a");
+  private final Route routeA1 = newRoute(addressA);
+  private final Address addressB = newAddress("b");
+  private final Route routeB1 = newRoute(addressB);
+  private final Address addressC = newAddress("c");
+  private final Route routeC1 = newRoute(addressC);
+
+  static {
+    Internal.initializeInstanceForTests();
+  }
+
+  @Test public void connectionsEvictedWhenIdleLongEnough() throws Exception {
+    ConnectionPool pool = new ConnectionPool(Integer.MAX_VALUE, 100L, TimeUnit.NANOSECONDS);
+    pool.cleanupRunning = true; // Prevent the cleanup runnable from being started.
+
+    RealConnection c1 = newConnection(pool, routeA1, 50L);
+
+    // Running at time 50, the pool returns that nothing can be evicted until time 150.
+    assertEquals(100L, pool.cleanup(50L));
+    assertEquals(1, pool.connectionCount());
+    assertFalse(c1.socket.isClosed());
+
+    // Running at time 60, the pool returns that nothing can be evicted until time 150.
+    assertEquals(90L, pool.cleanup(60L));
+    assertEquals(1, pool.connectionCount());
+    assertFalse(c1.socket.isClosed());
+
+    // Running at time 149, the pool returns that nothing can be evicted until time 150.
+    assertEquals(1L, pool.cleanup(149L));
+    assertEquals(1, pool.connectionCount());
+    assertFalse(c1.socket.isClosed());
+
+    // Running at time 150, the pool evicts.
+    assertEquals(0, pool.cleanup(150L));
+    assertEquals(0, pool.connectionCount());
+    assertTrue(c1.socket.isClosed());
+
+    // Running again, the pool reports that no further runs are necessary.
+    assertEquals(-1, pool.cleanup(150L));
+    assertEquals(0, pool.connectionCount());
+    assertTrue(c1.socket.isClosed());
+  }
+
+  @Test public void inUseConnectionsNotEvicted() throws Exception {
+    ConnectionPool pool = new ConnectionPool(Integer.MAX_VALUE, 100L, TimeUnit.NANOSECONDS);
+    pool.cleanupRunning = true; // Prevent the cleanup runnable from being started.
+
+    RealConnection c1 = newConnection(pool, routeA1, 50L);
+    StreamAllocation streamAllocation = new StreamAllocation(pool, addressA);
+    streamAllocation.acquire(c1);
+
+    // Running at time 50, the pool returns that nothing can be evicted until time 150.
+    assertEquals(100L, pool.cleanup(50L));
+    assertEquals(1, pool.connectionCount());
+    assertFalse(c1.socket.isClosed());
+
+    // Running at time 60, the pool returns that nothing can be evicted until time 160.
+    assertEquals(100L, pool.cleanup(60L));
+    assertEquals(1, pool.connectionCount());
+    assertFalse(c1.socket.isClosed());
+
+    // Running at time 160, the pool returns that nothing can be evicted until time 260.
+    assertEquals(100L, pool.cleanup(160L));
+    assertEquals(1, pool.connectionCount());
+    assertFalse(c1.socket.isClosed());
+  }
+
+  @Test public void cleanupPrioritizesEarliestEviction() throws Exception {
+    ConnectionPool pool = new ConnectionPool(Integer.MAX_VALUE, 100L, TimeUnit.NANOSECONDS);
+    pool.cleanupRunning = true; // Prevent the cleanup runnable from being started.
+
+    RealConnection c1 = newConnection(pool, routeA1, 75L);
+    RealConnection c2 = newConnection(pool, routeB1, 50L);
+
+    // Running at time 75, the pool returns that nothing can be evicted until time 150.
+    assertEquals(75L, pool.cleanup(75L));
+    assertEquals(2, pool.connectionCount());
+
+    // Running at time 149, the pool returns that nothing can be evicted until time 150.
+    assertEquals(1L, pool.cleanup(149L));
+    assertEquals(2, pool.connectionCount());
+
+    // Running at time 150, the pool evicts c2.
+    assertEquals(0L, pool.cleanup(150L));
+    assertEquals(1, pool.connectionCount());
+    assertFalse(c1.socket.isClosed());
+    assertTrue(c2.socket.isClosed());
+
+    // Running at time 150, the pool returns that nothing can be evicted until time 175.
+    assertEquals(25L, pool.cleanup(150L));
+    assertEquals(1, pool.connectionCount());
+
+    // Running at time 175, the pool evicts c1.
+    assertEquals(0L, pool.cleanup(175L));
+    assertEquals(0, pool.connectionCount());
+    assertTrue(c1.socket.isClosed());
+    assertTrue(c2.socket.isClosed());
+  }
+
+  @Test public void oldestConnectionsEvictedIfIdleLimitExceeded() throws Exception {
+    ConnectionPool pool = new ConnectionPool(2, 100L, TimeUnit.NANOSECONDS);
+    pool.cleanupRunning = true; // Prevent the cleanup runnable from being started.
+
+    RealConnection c1 = newConnection(pool, routeA1, 50L);
+    RealConnection c2 = newConnection(pool, routeB1, 75L);
+
+    // With 2 connections, there's no need to evict until the connections time out.
+    assertEquals(50L, pool.cleanup(100L));
+    assertEquals(2, pool.connectionCount());
+    assertFalse(c1.socket.isClosed());
+    assertFalse(c2.socket.isClosed());
+
+    // Add a third connection
+    RealConnection c3 = newConnection(pool, routeC1, 75L);
+
+    // The third connection bounces the first.
+    assertEquals(0L, pool.cleanup(100L));
+    assertEquals(2, pool.connectionCount());
+    assertTrue(c1.socket.isClosed());
+    assertFalse(c2.socket.isClosed());
+    assertFalse(c3.socket.isClosed());
+  }
+
+  @Test public void leakedAllocation() throws Exception {
+    ConnectionPool pool = new ConnectionPool(2, 100L, TimeUnit.NANOSECONDS);
+    pool.cleanupRunning = true; // Prevent the cleanup runnable from being started.
+
+    RealConnection c1 = newConnection(pool, routeA1, 0L);
+    allocateAndLeakAllocation(pool, c1);
+
+    awaitGarbageCollection();
+    assertEquals(0L, pool.cleanup(100L));
+    assertEquals(Collections.emptyList(), c1.allocations);
+
+    assertTrue(c1.noNewStreams); // Can't allocate once a leak has been detected.
+  }
+
+  /** Use a helper method so there's no hidden reference remaining on the stack. */
+  private void allocateAndLeakAllocation(ConnectionPool pool, RealConnection connection) {
+    StreamAllocation leak = new StreamAllocation(pool, connection.route().address());
+    leak.acquire(connection);
+  }
+
+  /**
+   * See FinalizationTester for discussion on how to best trigger GC in tests.
+   * https://android.googlesource.com/platform/libcore/+/master/support/src/test/java/libcore/
+   * java/lang/ref/FinalizationTester.java
+   */
+  private void awaitGarbageCollection() throws InterruptedException {
+    Runtime.getRuntime().gc();
+    Thread.sleep(100);
+    System.runFinalization();
+  }
+
+  private RealConnection newConnection(ConnectionPool pool, Route route, long idleAtNanos) {
+    RealConnection connection = new RealConnection(route);
+    connection.idleAtNanos = idleAtNanos;
+    connection.socket = new Socket();
+    synchronized (pool) {
+      pool.put(connection);
+    }
+    return connection;
+  }
+
+  private Address newAddress(String name) {
+    return new Address(name, 1, Dns.SYSTEM, SocketFactory.getDefault(), null, null, null,
+        new RecordingOkAuthenticator("password"), null, Collections.<Protocol>emptyList(),
+        Collections.<ConnectionSpec>emptyList(),
+        ProxySelector.getDefault());
+  }
+
+  private Route newRoute(Address address) {
+    return new Route(address, Proxy.NO_PROXY,
+        InetSocketAddress.createUnresolved(address.url().host(), address.url().port()));
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/ConnectionReuseTest.java b/okhttp-tests/src/test/java/okhttp3/ConnectionReuseTest.java
new file mode 100644
index 0000000000..5d45f0b721
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/ConnectionReuseTest.java
@@ -0,0 +1,361 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.concurrent.TimeUnit;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLException;
+import javax.net.ssl.SSLSocketFactory;
+import okhttp3.internal.tls.SslClient;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.SocketPolicy;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import org.junit.rules.Timeout;
+
+import static okhttp3.TestUtil.defaultClient;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class ConnectionReuseTest {
+  @Rule public final TestRule timeout = new Timeout(30_000);
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private SslClient sslClient = SslClient.localhost();
+  private OkHttpClient client = defaultClient();
+
+  @Test public void connectionsAreReused() throws Exception {
+    server.enqueue(new MockResponse().setBody("a"));
+    server.enqueue(new MockResponse().setBody("b"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    assertConnectionReused(request, request);
+  }
+
+  @Test public void connectionsAreReusedWithHttp2() throws Exception {
+    enableHttp2();
+    server.enqueue(new MockResponse().setBody("a"));
+    server.enqueue(new MockResponse().setBody("b"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    assertConnectionReused(request, request);
+  }
+
+  @Test public void connectionsAreNotReusedWithRequestConnectionClose() throws Exception {
+    server.enqueue(new MockResponse().setBody("a"));
+    server.enqueue(new MockResponse().setBody("b"));
+
+    Request requestA = new Request.Builder()
+        .url(server.url("/"))
+        .header("Connection", "close")
+        .build();
+    Request requestB = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    assertConnectionNotReused(requestA, requestB);
+  }
+
+  @Test public void connectionsAreNotReusedWithResponseConnectionClose() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Connection", "close")
+        .setBody("a"));
+    server.enqueue(new MockResponse().setBody("b"));
+
+    Request requestA = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    Request requestB = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    assertConnectionNotReused(requestA, requestB);
+  }
+
+  @Test public void connectionsAreNotReusedWithUnknownLengthResponseBody() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("a")
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
+        .clearHeaders());
+    server.enqueue(new MockResponse().setBody("b"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    assertConnectionNotReused(request, request);
+  }
+
+  @Test public void connectionsAreNotReusedIfPoolIsSizeZero() throws Exception {
+    client = client.newBuilder()
+        .connectionPool(new ConnectionPool(0, 5, TimeUnit.SECONDS))
+        .build();
+    server.enqueue(new MockResponse().setBody("a"));
+    server.enqueue(new MockResponse().setBody("b"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    assertConnectionNotReused(request, request);
+  }
+
+  @Test public void connectionsReusedWithRedirectEvenIfPoolIsSizeZero() throws Exception {
+    client = client.newBuilder()
+        .connectionPool(new ConnectionPool(0, 5, TimeUnit.SECONDS))
+        .build();
+    server.enqueue(new MockResponse()
+        .setResponseCode(301)
+        .addHeader("Location: /b")
+        .setBody("a"));
+    server.enqueue(new MockResponse().setBody("b"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    Response response = client.newCall(request).execute();
+    assertEquals("b", response.body().string());
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void connectionsNotReusedWithRedirectIfDiscardingResponseIsSlow() throws Exception {
+    client = client.newBuilder()
+        .connectionPool(new ConnectionPool(0, 5, TimeUnit.SECONDS))
+        .build();
+    server.enqueue(new MockResponse()
+        .setResponseCode(301)
+        .addHeader("Location: /b")
+        .setBodyDelay(1, TimeUnit.SECONDS)
+        .setBody("a"));
+    server.enqueue(new MockResponse().setBody("b"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    Response response = client.newCall(request).execute();
+    assertEquals("b", response.body().string());
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void silentRetryWhenIdempotentRequestFailsOnReusedConnection() throws Exception {
+    server.enqueue(new MockResponse().setBody("a"));
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AFTER_REQUEST));
+    server.enqueue(new MockResponse().setBody("b"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    Response responseA = client.newCall(request).execute();
+    assertEquals("a", responseA.body().string());
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+
+    Response responseB = client.newCall(request).execute();
+    assertEquals("b", responseB.body().string());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void staleConnectionNotReusedForNonIdempotentRequest() throws Exception {
+    server.enqueue(new MockResponse().setBody("a")
+        .setSocketPolicy(SocketPolicy.SHUTDOWN_OUTPUT_AT_END));
+    server.enqueue(new MockResponse().setBody("b"));
+
+    Request requestA = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    Response responseA = client.newCall(requestA).execute();
+    assertEquals("a", responseA.body().string());
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+
+    Request requestB = new Request.Builder()
+        .url(server.url("/"))
+        .post(RequestBody.create(MediaType.parse("text/plain"), "b"))
+        .build();
+    Response responseB = client.newCall(requestB).execute();
+    assertEquals("b", responseB.body().string());
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void http2ConnectionsAreSharedBeforeResponseIsConsumed() throws Exception {
+    enableHttp2();
+    server.enqueue(new MockResponse().setBody("a"));
+    server.enqueue(new MockResponse().setBody("b"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    Response response1 = client.newCall(request).execute();
+    Response response2 = client.newCall(request).execute();
+    response1.body().string(); // Discard the response body.
+    response2.body().string(); // Discard the response body.
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void connectionsAreEvicted() throws Exception {
+    server.enqueue(new MockResponse().setBody("a"));
+    server.enqueue(new MockResponse().setBody("b"));
+
+    client = client.newBuilder()
+        .connectionPool(new ConnectionPool(5, 250, TimeUnit.MILLISECONDS))
+        .build();
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    Response response1 = client.newCall(request).execute();
+    assertEquals("a", response1.body().string());
+
+    // Give the thread pool a chance to evict.
+    Thread.sleep(500);
+
+    Response response2 = client.newCall(request).execute();
+    assertEquals("b", response2.body().string());
+
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void connectionsAreNotReusedIfSslSocketFactoryChanges() throws Exception {
+    enableHttps();
+    server.enqueue(new MockResponse());
+    server.enqueue(new MockResponse());
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    Response response = client.newCall(request).execute();
+    response.body().close();
+
+    // This client shares a connection pool but has a different SSL socket factory.
+    SSLContext sslContext2 = SSLContext.getInstance("TLS");
+    sslContext2.init(null, null, null);
+    SSLSocketFactory sslSocketFactory2 = sslContext2.getSocketFactory();
+    OkHttpClient anotherClient = client.newBuilder()
+        .sslSocketFactory(sslSocketFactory2)
+        .build();
+
+    // This client fails to connect because the new SSL socket factory refuses.
+    try {
+      anotherClient.newCall(request).execute();
+      fail();
+    } catch (SSLException expected) {
+    }
+  }
+
+  @Test public void connectionsAreNotReusedIfHostnameVerifierChanges() throws Exception {
+    enableHttps();
+    server.enqueue(new MockResponse());
+    server.enqueue(new MockResponse());
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    Response response1 = client.newCall(request).execute();
+    response1.body().close();
+
+    // This client shares a connection pool but has a different SSL socket factory.
+    OkHttpClient anotherClient = client.newBuilder()
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build();
+
+    Response response2 = anotherClient.newCall(request).execute();
+    response2.body().close();
+
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+  }
+
+  /**
+   * Regression test for an edge case where closing response body in the HTTP engine doesn't release
+   * the corresponding stream allocation. This test keeps those response bodies alive and reads
+   * them after the redirect has completed. This forces a connection to not be reused where it would
+   * be otherwise.
+   *
+   * https://github.com/square/okhttp/issues/2409
+   */
+  @Test public void connectionsAreNotReusedIfNetworkInterceptorInterferes() throws Exception {
+    client = client.newBuilder().addNetworkInterceptor(new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        Response response = chain.proceed(chain.request());
+        return response.newBuilder()
+            .body(ResponseBody.create(null, "unrelated response body!"))
+            .build();
+      }
+    }).build();
+
+    server.enqueue(new MockResponse()
+        .setResponseCode(301)
+        .addHeader("Location: /b")
+        .setBody("/a has moved!"));
+    server.enqueue(new MockResponse()
+        .setBody("/b is here"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    try {
+      client.newCall(request).execute();
+      fail();
+    } catch (IllegalStateException expected) {
+      assertTrue(expected.getMessage().startsWith("Closing the body of"));
+    }
+  }
+
+  private void enableHttps() {
+    enableHttpsAndAlpn(Protocol.HTTP_1_1);
+  }
+
+  private void enableHttp2() {
+    enableHttpsAndAlpn(Protocol.HTTP_2, Protocol.HTTP_1_1);
+  }
+
+  private void enableHttpsAndAlpn(Protocol... protocols) {
+    client = client.newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .protocols(Arrays.asList(protocols))
+        .build();
+    server.useHttps(sslClient.socketFactory, false);
+    server.setProtocols(client.protocols());
+  }
+
+  private void assertConnectionReused(Request... requests) throws Exception {
+    for (int i = 0; i < requests.length; i++) {
+      Response response = client.newCall(requests[i]).execute();
+      response.body().string(); // Discard the response body.
+      assertEquals(i, server.takeRequest().getSequenceNumber());
+    }
+  }
+
+  private void assertConnectionNotReused(Request... requests) throws Exception {
+    for (Request request : requests) {
+      Response response = client.newCall(request).execute();
+      response.body().string(); // Discard the response body.
+      assertEquals(0, server.takeRequest().getSequenceNumber());
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/ConnectionSpecTest.java b/okhttp-tests/src/test/java/okhttp3/ConnectionSpecTest.java
new file mode 100644
index 0000000000..7fbd08e628
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/ConnectionSpecTest.java
@@ -0,0 +1,303 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.util.Arrays;
+import java.util.LinkedHashSet;
+import java.util.Set;
+import java.util.concurrent.CopyOnWriteArraySet;
+import javax.net.ssl.SSLSocket;
+import javax.net.ssl.SSLSocketFactory;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class ConnectionSpecTest {
+  @Test public void noTlsVersions() throws Exception {
+    try {
+      new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
+          .tlsVersions(new TlsVersion[0])
+          .build();
+      fail();
+    } catch (IllegalArgumentException expected) {
+      assertEquals("At least one TLS version is required", expected.getMessage());
+    }
+  }
+
+  @Test public void noCipherSuites() throws Exception {
+    try {
+      new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
+          .cipherSuites(new CipherSuite[0])
+          .build();
+      fail();
+    } catch (IllegalArgumentException expected) {
+      assertEquals("At least one cipher suite is required", expected.getMessage());
+    }
+  }
+
+  @Test public void cleartextBuilder() throws Exception {
+    ConnectionSpec cleartextSpec = new ConnectionSpec.Builder(false).build();
+    assertFalse(cleartextSpec.isTls());
+  }
+
+  @Test public void tlsBuilder_explicitCiphers() throws Exception {
+    ConnectionSpec tlsSpec = new ConnectionSpec.Builder(true)
+        .cipherSuites(CipherSuite.TLS_RSA_WITH_RC4_128_MD5)
+        .tlsVersions(TlsVersion.TLS_1_2)
+        .supportsTlsExtensions(true)
+        .build();
+    assertEquals(Arrays.asList(CipherSuite.TLS_RSA_WITH_RC4_128_MD5), tlsSpec.cipherSuites());
+    assertEquals(Arrays.asList(TlsVersion.TLS_1_2), tlsSpec.tlsVersions());
+    assertTrue(tlsSpec.supportsTlsExtensions());
+  }
+
+  @Test public void tlsBuilder_defaultCiphers() throws Exception {
+    ConnectionSpec tlsSpec = new ConnectionSpec.Builder(true)
+        .tlsVersions(TlsVersion.TLS_1_2)
+        .supportsTlsExtensions(true)
+        .build();
+    assertNull(tlsSpec.cipherSuites());
+    assertEquals(Arrays.asList(TlsVersion.TLS_1_2), tlsSpec.tlsVersions());
+    assertTrue(tlsSpec.supportsTlsExtensions());
+  }
+
+  @Test public void tls_defaultCiphers_noFallbackIndicator() throws Exception {
+    ConnectionSpec tlsSpec = new ConnectionSpec.Builder(true)
+        .tlsVersions(TlsVersion.TLS_1_2)
+        .supportsTlsExtensions(false)
+        .build();
+
+    SSLSocket socket = (SSLSocket) SSLSocketFactory.getDefault().createSocket();
+    socket.setEnabledCipherSuites(new String[] {
+        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName,
+        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName,
+    });
+    socket.setEnabledProtocols(new String[] {
+        TlsVersion.TLS_1_2.javaName,
+        TlsVersion.TLS_1_1.javaName,
+    });
+
+    assertTrue(tlsSpec.isCompatible(socket));
+    tlsSpec.apply(socket, false /* isFallback */);
+
+    assertEquals(set(TlsVersion.TLS_1_2.javaName), set(socket.getEnabledProtocols()));
+
+    Set<String> expectedCipherSet =
+        set(
+            CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName,
+            CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName);
+    assertEquals(expectedCipherSet, expectedCipherSet);
+  }
+
+  @Test public void tls_defaultCiphers_withFallbackIndicator() throws Exception {
+    ConnectionSpec tlsSpec = new ConnectionSpec.Builder(true)
+        .tlsVersions(TlsVersion.TLS_1_2)
+        .supportsTlsExtensions(false)
+        .build();
+
+    SSLSocket socket = (SSLSocket) SSLSocketFactory.getDefault().createSocket();
+    socket.setEnabledCipherSuites(new String[] {
+        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName,
+        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName,
+    });
+    socket.setEnabledProtocols(new String[] {
+        TlsVersion.TLS_1_2.javaName,
+        TlsVersion.TLS_1_1.javaName,
+    });
+
+    assertTrue(tlsSpec.isCompatible(socket));
+    tlsSpec.apply(socket, true /* isFallback */);
+
+    assertEquals(set(TlsVersion.TLS_1_2.javaName), set(socket.getEnabledProtocols()));
+
+    Set<String> expectedCipherSet =
+        set(
+            CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName,
+            CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName);
+    if (Arrays.asList(socket.getSupportedCipherSuites()).contains("TLS_FALLBACK_SCSV")) {
+      expectedCipherSet.add("TLS_FALLBACK_SCSV");
+    }
+    assertEquals(expectedCipherSet, expectedCipherSet);
+  }
+
+  @Test public void tls_explicitCiphers() throws Exception {
+    ConnectionSpec tlsSpec = new ConnectionSpec.Builder(true)
+        .cipherSuites(CipherSuite.TLS_RSA_WITH_RC4_128_MD5)
+        .tlsVersions(TlsVersion.TLS_1_2)
+        .supportsTlsExtensions(false)
+        .build();
+
+    SSLSocket socket = (SSLSocket) SSLSocketFactory.getDefault().createSocket();
+    socket.setEnabledCipherSuites(new String[] {
+        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName,
+        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName,
+    });
+    socket.setEnabledProtocols(new String[] {
+        TlsVersion.TLS_1_2.javaName,
+        TlsVersion.TLS_1_1.javaName,
+    });
+
+    assertTrue(tlsSpec.isCompatible(socket));
+    tlsSpec.apply(socket, true /* isFallback */);
+
+    assertEquals(set(TlsVersion.TLS_1_2.javaName), set(socket.getEnabledProtocols()));
+
+    Set<String> expectedCipherSet = set(CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName);
+    if (Arrays.asList(socket.getSupportedCipherSuites()).contains("TLS_FALLBACK_SCSV")) {
+      expectedCipherSet.add("TLS_FALLBACK_SCSV");
+    }
+    assertEquals(expectedCipherSet, expectedCipherSet);
+  }
+
+  @Test public void tls_stringCiphersAndVersions() throws Exception {
+    // Supporting arbitrary input strings allows users to enable suites and versions that are not
+    // yet known to the library, but are supported by the platform.
+    ConnectionSpec tlsSpec = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
+        .cipherSuites("MAGIC-CIPHER")
+        .tlsVersions("TLS9k")
+        .build();
+  }
+
+  @Test public void tls_missingRequiredCipher() throws Exception {
+    ConnectionSpec tlsSpec = new ConnectionSpec.Builder(true)
+        .cipherSuites(CipherSuite.TLS_RSA_WITH_RC4_128_MD5)
+        .tlsVersions(TlsVersion.TLS_1_2)
+        .supportsTlsExtensions(false)
+        .build();
+
+    SSLSocket socket = (SSLSocket) SSLSocketFactory.getDefault().createSocket();
+    socket.setEnabledProtocols(new String[] {
+        TlsVersion.TLS_1_2.javaName,
+        TlsVersion.TLS_1_1.javaName,
+    });
+
+    socket.setEnabledCipherSuites(new String[] {
+        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName,
+        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName,
+    });
+    assertTrue(tlsSpec.isCompatible(socket));
+
+    socket.setEnabledCipherSuites(new String[] {
+        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName,
+    });
+    assertFalse(tlsSpec.isCompatible(socket));
+  }
+
+  @Test public void allEnabledCipherSuites() throws Exception {
+    ConnectionSpec tlsSpec = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
+        .allEnabledCipherSuites()
+        .build();
+    assertNull(tlsSpec.cipherSuites());
+
+    SSLSocket sslSocket = (SSLSocket) SSLSocketFactory.getDefault().createSocket();
+    sslSocket.setEnabledCipherSuites(new String[] {
+        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName,
+        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName,
+    });
+
+    tlsSpec.apply(sslSocket, false);
+    assertEquals(Arrays.asList(
+        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName,
+        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName),
+        Arrays.asList(sslSocket.getEnabledCipherSuites()));
+  }
+
+  @Test public void allEnabledTlsVersions() throws Exception {
+    ConnectionSpec tlsSpec = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
+        .allEnabledTlsVersions()
+        .build();
+    assertNull(tlsSpec.tlsVersions());
+
+    SSLSocket sslSocket = (SSLSocket) SSLSocketFactory.getDefault().createSocket();
+    sslSocket.setEnabledProtocols(new String[] {
+        TlsVersion.SSL_3_0.javaName(),
+        TlsVersion.TLS_1_1.javaName()
+    });
+
+    tlsSpec.apply(sslSocket, false);
+    assertEquals(Arrays.asList(TlsVersion.SSL_3_0.javaName(), TlsVersion.TLS_1_1.javaName()),
+        Arrays.asList(sslSocket.getEnabledProtocols()));
+  }
+
+  @Test public void tls_missingTlsVersion() throws Exception {
+    ConnectionSpec tlsSpec = new ConnectionSpec.Builder(true)
+        .cipherSuites(CipherSuite.TLS_RSA_WITH_RC4_128_MD5)
+        .tlsVersions(TlsVersion.TLS_1_2)
+        .supportsTlsExtensions(false)
+        .build();
+
+    SSLSocket socket = (SSLSocket) SSLSocketFactory.getDefault().createSocket();
+    socket.setEnabledCipherSuites(new String[] {
+        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName,
+    });
+
+    socket.setEnabledProtocols(
+        new String[] {TlsVersion.TLS_1_2.javaName, TlsVersion.TLS_1_1.javaName});
+    assertTrue(tlsSpec.isCompatible(socket));
+
+    socket.setEnabledProtocols(new String[] {TlsVersion.TLS_1_1.javaName});
+    assertFalse(tlsSpec.isCompatible(socket));
+  }
+
+  @Test public void equalsAndHashCode() throws Exception {
+    ConnectionSpec allCipherSuites = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
+        .allEnabledCipherSuites()
+        .build();
+    ConnectionSpec allTlsVersions = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
+        .allEnabledTlsVersions()
+        .build();
+
+    Set<Object> set = new CopyOnWriteArraySet<>();
+    assertTrue(set.add(ConnectionSpec.MODERN_TLS));
+    assertTrue(set.add(ConnectionSpec.COMPATIBLE_TLS));
+    assertTrue(set.add(ConnectionSpec.CLEARTEXT));
+    assertTrue(set.add(allTlsVersions));
+    assertTrue(set.add(allCipherSuites));
+
+    assertTrue(set.remove(ConnectionSpec.MODERN_TLS));
+    assertTrue(set.remove(ConnectionSpec.COMPATIBLE_TLS));
+    assertTrue(set.remove(ConnectionSpec.CLEARTEXT));
+    assertTrue(set.remove(allTlsVersions));
+    assertTrue(set.remove(allCipherSuites));
+    assertTrue(set.isEmpty());
+  }
+
+  @Test public void allEnabledToString() throws Exception {
+    ConnectionSpec connectionSpec = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
+        .allEnabledTlsVersions()
+        .allEnabledCipherSuites()
+        .build();
+    assertEquals("ConnectionSpec(cipherSuites=[all enabled], tlsVersions=[all enabled], "
+        + "supportsTlsExtensions=true)", connectionSpec.toString());
+  }
+
+  @Test public void simpleToString() throws Exception {
+    ConnectionSpec connectionSpec = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
+        .tlsVersions(TlsVersion.TLS_1_2)
+        .cipherSuites(CipherSuite.TLS_RSA_WITH_RC4_128_MD5)
+        .build();
+    assertEquals("ConnectionSpec(cipherSuites=[TLS_RSA_WITH_RC4_128_MD5], tlsVersions=[TLS_1_2], "
+        + "supportsTlsExtensions=true)", connectionSpec.toString());
+  }
+
+  private static <T> Set<T> set(T... values) {
+    return new LinkedHashSet<>(Arrays.asList(values));
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/CookieTest.java b/okhttp-tests/src/test/java/okhttp3/CookieTest.java
new file mode 100644
index 0000000000..bee549dc7d
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/CookieTest.java
@@ -0,0 +1,495 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.text.ParseException;
+import java.text.SimpleDateFormat;
+import java.util.Arrays;
+import java.util.Date;
+import java.util.List;
+import java.util.Objects;
+import okhttp3.internal.Util;
+import okhttp3.internal.http.HttpDate;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class CookieTest {
+  HttpUrl url = HttpUrl.parse("https://example.com/");
+
+  @Test public void simpleCookie() throws Exception {
+    Cookie cookie = Cookie.parse(url, "SID=31d4d96e407aad42");
+    assertEquals("SID=31d4d96e407aad42; path=/", cookie.toString());
+  }
+
+  @Test public void noEqualsSign() throws Exception {
+    assertNull(Cookie.parse(url, "foo"));
+    assertNull(Cookie.parse(url, "foo; Path=/"));
+  }
+
+  @Test public void emptyName() throws Exception {
+    assertNull(Cookie.parse(url, "=b"));
+    assertNull(Cookie.parse(url, " =b"));
+    assertNull(Cookie.parse(url, "\r\t \n=b"));
+  }
+
+  @Test public void trimLeadingAndTrailingWhitespaceFromName() throws Exception {
+    assertEquals("a", Cookie.parse(url, " a=b").name());
+    assertEquals("a", Cookie.parse(url, "a =b").name());
+    assertEquals("a", Cookie.parse(url, "\r\t \na\n\t \n=b").name());
+  }
+
+  @Test public void emptyValue() throws Exception {
+    assertEquals("", Cookie.parse(url, "a=").value());
+    assertEquals("", Cookie.parse(url, "a= ").value());
+    assertEquals("", Cookie.parse(url, "a=\r\t \n").value());
+  }
+
+  @Test public void trimLeadingAndTrailingWhitespaceFromValue() throws Exception {
+    assertEquals("", Cookie.parse(url, "a= ").value());
+    assertEquals("b", Cookie.parse(url, "a= b").value());
+    assertEquals("b", Cookie.parse(url, "a=b ").value());
+    assertEquals("b", Cookie.parse(url, "a=\r\t \nb\n\t \n").value());
+  }
+
+  @Test public void maxAge() throws Exception {
+    assertEquals(51000L,
+        Cookie.parse(50000L, url, "a=b; Max-Age=1").expiresAt());
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(50000L, url, "a=b; Max-Age=9223372036854724").expiresAt());
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(50000L, url, "a=b; Max-Age=9223372036854725").expiresAt());
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(50000L, url, "a=b; Max-Age=9223372036854726").expiresAt());
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(9223372036854773807L, url, "a=b; Max-Age=1").expiresAt());
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(9223372036854773807L, url, "a=b; Max-Age=2").expiresAt());
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(9223372036854773807L, url, "a=b; Max-Age=3").expiresAt());
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(50000L, url, "a=b; Max-Age=10000000000000000000").expiresAt());
+  }
+
+  @Test public void maxAgeNonPositive() throws Exception {
+    assertEquals(Long.MIN_VALUE,
+        Cookie.parse(50000L, url, "a=b; Max-Age=-1").expiresAt());
+    assertEquals(Long.MIN_VALUE,
+        Cookie.parse(50000L, url, "a=b; Max-Age=0").expiresAt());
+    assertEquals(Long.MIN_VALUE,
+        Cookie.parse(50000L, url, "a=b; Max-Age=-9223372036854775808").expiresAt());
+    assertEquals(Long.MIN_VALUE,
+        Cookie.parse(50000L, url, "a=b; Max-Age=-9223372036854775809").expiresAt());
+    assertEquals(Long.MIN_VALUE,
+        Cookie.parse(50000L, url, "a=b; Max-Age=-10000000000000000000").expiresAt());
+  }
+
+  @Test public void domainAndPath() throws Exception {
+    Cookie cookie = Cookie.parse(url, "SID=31d4d96e407aad42; Path=/; Domain=example.com");
+    assertEquals("example.com", cookie.domain());
+    assertEquals("/", cookie.path());
+    assertFalse(cookie.hostOnly());
+    assertEquals("SID=31d4d96e407aad42; domain=example.com; path=/", cookie.toString());
+  }
+
+  @Test public void secureAndHttpOnly() throws Exception {
+    Cookie cookie = Cookie.parse(url, "SID=31d4d96e407aad42; Path=/; Secure; HttpOnly");
+    assertTrue(cookie.secure());
+    assertTrue(cookie.httpOnly());
+    assertEquals("SID=31d4d96e407aad42; path=/; secure; httponly", cookie.toString());
+  }
+
+  @Test public void expiresDate() throws Exception {
+    assertEquals(date("1970-01-01T00:00:00.000+0000"), new Date(
+        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 00:00:00 GMT").expiresAt()));
+    assertEquals(date("2021-06-09T10:18:14.000+0000"), new Date(
+        Cookie.parse(url, "a=b; Expires=Wed, 09 Jun 2021 10:18:14 GMT").expiresAt()));
+    assertEquals(date("1994-11-06T08:49:37.000+0000"), new Date(
+        Cookie.parse(url, "a=b; Expires=Sun, 06 Nov 1994 08:49:37 GMT").expiresAt()));
+  }
+
+  @Test public void awkwardDates() throws Exception {
+    assertEquals(0L,
+        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 70 00:00:00 GMT").expiresAt());
+    assertEquals(0L,
+        Cookie.parse(url, "a=b; Expires=Thu, 01 January 1970 00:00:00 GMT").expiresAt());
+    assertEquals(0L,
+        Cookie.parse(url, "a=b; Expires=Thu, 01 Janucember 1970 00:00:00 GMT").expiresAt());
+    assertEquals(0L,
+        Cookie.parse(url, "a=b; Expires=Thu, 1 Jan 1970 00:00:00 GMT").expiresAt());
+    assertEquals(0L,
+        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 0:00:00 GMT").expiresAt());
+    assertEquals(0L,
+        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 00:0:00 GMT").expiresAt());
+    assertEquals(0L,
+        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 00:00:0 GMT").expiresAt());
+    assertEquals(0L,
+        Cookie.parse(url, "a=b; Expires=00:00:00 Thu, 01 Jan 1970 GMT").expiresAt());
+    assertEquals(0L,
+        Cookie.parse(url, "a=b; Expires=00:00:00 1970 Jan 01").expiresAt());
+    assertEquals(0L,
+        Cookie.parse(url, "a=b; Expires=00:00:00 1970 Jan 1").expiresAt());
+  }
+
+  @Test public void invalidYear() throws Exception {
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1600 00:00:00 GMT").expiresAt());
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 19999 00:00:00 GMT").expiresAt());
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 00:00:00 GMT").expiresAt());
+  }
+
+  @Test public void invalidMonth() throws Exception {
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(url, "a=b; Expires=Thu, 01 Foo 1970 00:00:00 GMT").expiresAt());
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(url, "a=b; Expires=Thu, 01 Foocember 1970 00:00:00 GMT").expiresAt());
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(url, "a=b; Expires=Thu, 01 1970 00:00:00 GMT").expiresAt());
+  }
+
+  @Test public void invalidDayOfMonth() throws Exception {
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(url, "a=b; Expires=Thu, 32 Jan 1970 00:00:00 GMT").expiresAt());
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(url, "a=b; Expires=Thu, Jan 1970 00:00:00 GMT").expiresAt());
+  }
+
+  @Test public void invalidHour() throws Exception {
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 24:00:00 GMT").expiresAt());
+  }
+
+  @Test public void invalidMinute() throws Exception {
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 00:60:00 GMT").expiresAt());
+  }
+
+  @Test public void invalidSecond() throws Exception {
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 00:00:60 GMT").expiresAt());
+  }
+
+  @Test public void domainMatches() throws Exception {
+    Cookie cookie = Cookie.parse(url, "a=b; domain=example.com");
+    assertTrue(cookie.matches(HttpUrl.parse("http://example.com")));
+    assertTrue(cookie.matches(HttpUrl.parse("http://www.example.com")));
+    assertFalse(cookie.matches(HttpUrl.parse("http://square.com")));
+  }
+
+  /** If no domain is present, match only the origin domain. */
+  @Test public void domainMatchesNoDomain() throws Exception {
+    Cookie cookie = Cookie.parse(url, "a=b");
+    assertTrue(cookie.matches(HttpUrl.parse("http://example.com")));
+    assertFalse(cookie.matches(HttpUrl.parse("http://www.example.com")));
+    assertFalse(cookie.matches(HttpUrl.parse("http://square.com")));
+  }
+
+  /** Ignore an optional leading `.` in the domain. */
+  @Test public void domainMatchesIgnoresLeadingDot() throws Exception {
+    Cookie cookie = Cookie.parse(url, "a=b; domain=.example.com");
+    assertTrue(cookie.matches(HttpUrl.parse("http://example.com")));
+    assertTrue(cookie.matches(HttpUrl.parse("http://www.example.com")));
+    assertFalse(cookie.matches(HttpUrl.parse("http://square.com")));
+  }
+
+  /** Ignore the entire attribute if the domain ends with `.`. */
+  @Test public void domainIgnoredWithTrailingDot() throws Exception {
+    Cookie cookie = Cookie.parse(url, "a=b; domain=example.com.");
+    assertTrue(cookie.matches(HttpUrl.parse("http://example.com")));
+    assertFalse(cookie.matches(HttpUrl.parse("http://www.example.com")));
+    assertFalse(cookie.matches(HttpUrl.parse("http://square.com")));
+  }
+
+  @Test public void idnDomainMatches() throws Exception {
+    Cookie cookie = Cookie.parse(HttpUrl.parse("http://☃.net/"), "a=b; domain=☃.net");
+    assertTrue(cookie.matches(HttpUrl.parse("http://☃.net/")));
+    assertTrue(cookie.matches(HttpUrl.parse("http://xn--n3h.net/")));
+    assertTrue(cookie.matches(HttpUrl.parse("http://www.☃.net/")));
+    assertTrue(cookie.matches(HttpUrl.parse("http://www.xn--n3h.net/")));
+  }
+
+  @Test public void punycodeDomainMatches() throws Exception {
+    Cookie cookie = Cookie.parse(HttpUrl.parse("http://xn--n3h.net/"), "a=b; domain=xn--n3h.net");
+    assertTrue(cookie.matches(HttpUrl.parse("http://☃.net/")));
+    assertTrue(cookie.matches(HttpUrl.parse("http://xn--n3h.net/")));
+    assertTrue(cookie.matches(HttpUrl.parse("http://www.☃.net/")));
+    assertTrue(cookie.matches(HttpUrl.parse("http://www.xn--n3h.net/")));
+  }
+
+  @Test public void domainMatchesIpAddress() throws Exception {
+    HttpUrl urlWithIp = HttpUrl.parse("http://123.45.234.56/");
+    assertNull(Cookie.parse(urlWithIp, "a=b; domain=234.56"));
+    assertEquals("123.45.234.56", Cookie.parse(urlWithIp, "a=b; domain=123.45.234.56").domain());
+  }
+
+  @Test public void hostOnly() throws Exception {
+    assertTrue(Cookie.parse(url, "a=b").hostOnly());
+    assertFalse(Cookie.parse(url, "a=b; domain=example.com").hostOnly());
+  }
+
+  @Test public void defaultPath() throws Exception {
+    assertEquals("/foo", Cookie.parse(HttpUrl.parse("http://example.com/foo/bar"), "a=b").path());
+    assertEquals("/foo", Cookie.parse(HttpUrl.parse("http://example.com/foo/"), "a=b").path());
+    assertEquals("/", Cookie.parse(HttpUrl.parse("http://example.com/foo"), "a=b").path());
+    assertEquals("/", Cookie.parse(HttpUrl.parse("http://example.com/"), "a=b").path());
+  }
+
+  @Test public void defaultPathIsUsedIfPathDoesntHaveLeadingSlash() throws Exception {
+    assertEquals("/foo", Cookie.parse(HttpUrl.parse("http://example.com/foo/bar"),
+        "a=b; path=quux").path());
+    assertEquals("/foo", Cookie.parse(HttpUrl.parse("http://example.com/foo/bar"),
+        "a=b; path=").path());
+  }
+
+  @Test public void pathAttributeDoesntNeedToMatch() throws Exception {
+    assertEquals("/quux", Cookie.parse(HttpUrl.parse("http://example.com/"),
+        "a=b; path=/quux").path());
+    assertEquals("/quux", Cookie.parse(HttpUrl.parse("http://example.com/foo/bar"),
+        "a=b; path=/quux").path());
+  }
+
+  @Test public void httpOnly() throws Exception {
+    assertFalse(Cookie.parse(url, "a=b").httpOnly());
+    assertTrue(Cookie.parse(url, "a=b; HttpOnly").httpOnly());
+  }
+
+  @Test public void secure() throws Exception {
+    assertFalse(Cookie.parse(url, "a=b").secure());
+    assertTrue(Cookie.parse(url, "a=b; Secure").secure());
+  }
+
+  @Test public void maxAgeTakesPrecedenceOverExpires() throws Exception {
+    // Max-Age = 1, Expires = 2. In either order.
+    assertEquals(1000L, Cookie.parse(
+        0L, url, "a=b; Max-Age=1; Expires=Thu, 01 Jan 1970 00:00:02 GMT").expiresAt());
+    assertEquals(1000L, Cookie.parse(
+        0L, url, "a=b; Expires=Thu, 01 Jan 1970 00:00:02 GMT; Max-Age=1").expiresAt());
+    // Max-Age = 2, Expires = 1. In either order.
+    assertEquals(2000L, Cookie.parse(
+        0L, url, "a=b; Max-Age=2; Expires=Thu, 01 Jan 1970 00:00:01 GMT").expiresAt());
+    assertEquals(2000L, Cookie.parse(
+        0L, url, "a=b; Expires=Thu, 01 Jan 1970 00:00:01 GMT; Max-Age=2").expiresAt());
+  }
+
+  /** If a cookie incorrectly defines multiple 'Max-Age' attributes, the last one defined wins. */
+  @Test public void lastMaxAgeWins() throws Exception {
+    assertEquals(3000L, Cookie.parse(
+        0L, url, "a=b; Max-Age=2; Max-Age=4; Max-Age=1; Max-Age=3").expiresAt());
+  }
+
+  /** If a cookie incorrectly defines multiple 'Expires' attributes, the last one defined wins. */
+  @Test public void lastExpiresAtWins() throws Exception {
+    assertEquals(3000L, Cookie.parse(0L, url, "a=b; "
+        + "Expires=Thu, 01 Jan 1970 00:00:02 GMT; "
+        + "Expires=Thu, 01 Jan 1970 00:00:04 GMT; "
+        + "Expires=Thu, 01 Jan 1970 00:00:01 GMT; "
+        + "Expires=Thu, 01 Jan 1970 00:00:03 GMT").expiresAt());
+  }
+
+  @Test public void maxAgeOrExpiresMakesCookiePersistent() throws Exception {
+    assertFalse(Cookie.parse(0L, url, "a=b").persistent());
+    assertTrue(Cookie.parse(0L, url, "a=b; Max-Age=1").persistent());
+    assertTrue(Cookie.parse(0L, url, "a=b; Expires=Thu, 01 Jan 1970 00:00:01 GMT").persistent());
+  }
+
+  @Test public void parseAll() throws Exception {
+    Headers headers = new Headers.Builder()
+        .add("Set-Cookie: a=b")
+        .add("Set-Cookie: c=d")
+        .build();
+    List<Cookie> cookies = Cookie.parseAll(url, headers);
+    assertEquals(2, cookies.size());
+    assertEquals("a=b; path=/", cookies.get(0).toString());
+    assertEquals("c=d; path=/", cookies.get(1).toString());
+  }
+
+  @Test public void builder() throws Exception {
+    Cookie cookie = new Cookie.Builder()
+        .name("a")
+        .value("b")
+        .domain("example.com")
+        .build();
+    assertEquals("a", cookie.name());
+    assertEquals("b", cookie.value());
+    assertEquals(HttpDate.MAX_DATE, cookie.expiresAt());
+    assertEquals("example.com", cookie.domain());
+    assertEquals("/", cookie.path());
+    assertFalse(cookie.secure());
+    assertFalse(cookie.httpOnly());
+    assertFalse(cookie.persistent());
+    assertFalse(cookie.hostOnly());
+  }
+
+  @Test public void builderNameValidation() throws Exception {
+    try {
+      new Cookie.Builder().name(null);
+      fail();
+    } catch (NullPointerException expected) {
+    }
+    try {
+      new Cookie.Builder().name(" a ");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void builderValueValidation() throws Exception {
+    try {
+      new Cookie.Builder().value(null);
+      fail();
+    } catch (NullPointerException expected) {
+    }
+    try {
+      new Cookie.Builder().value(" b ");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void builderClampsMaxDate() throws Exception {
+    Cookie cookie = new Cookie.Builder()
+        .name("a")
+        .value("b")
+        .hostOnlyDomain("example.com")
+        .expiresAt(Long.MAX_VALUE)
+        .build();
+    assertEquals("a=b; expires=Fri, 31 Dec 9999 23:59:59 GMT; path=/", cookie.toString());
+  }
+
+  @Test public void builderExpiresAt() throws Exception {
+    Cookie cookie = new Cookie.Builder()
+        .name("a")
+        .value("b")
+        .hostOnlyDomain("example.com")
+        .expiresAt(date("1970-01-01T00:00:01.000+0000").getTime())
+        .build();
+    assertEquals("a=b; expires=Thu, 01 Jan 1970 00:00:01 GMT; path=/", cookie.toString());
+  }
+
+  @Test public void builderClampsMinDate() throws Exception {
+    Cookie cookie = new Cookie.Builder()
+        .name("a")
+        .value("b")
+        .hostOnlyDomain("example.com")
+        .expiresAt(date("1970-01-01T00:00:00.000+0000").getTime())
+        .build();
+    assertEquals("a=b; max-age=0; path=/", cookie.toString());
+  }
+
+  @Test public void builderDomainValidation() throws Exception {
+    try {
+      new Cookie.Builder().hostOnlyDomain(null);
+      fail();
+    } catch (NullPointerException expected) {
+    }
+    try {
+      new Cookie.Builder().hostOnlyDomain("a/b");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void builderDomain() throws Exception {
+    Cookie cookie = new Cookie.Builder()
+        .name("a")
+        .value("b")
+        .hostOnlyDomain("squareup.com")
+        .build();
+    assertEquals("squareup.com", cookie.domain());
+    assertTrue(cookie.hostOnly());
+  }
+
+  @Test public void builderPath() throws Exception {
+    Cookie cookie = new Cookie.Builder()
+        .name("a")
+        .value("b")
+        .hostOnlyDomain("example.com")
+        .path("/foo")
+        .build();
+    assertEquals("/foo", cookie.path());
+  }
+
+  @Test public void builderPathValidation() throws Exception {
+    try {
+      new Cookie.Builder().path(null);
+      fail();
+    } catch (NullPointerException expected) {
+    }
+    try {
+      new Cookie.Builder().path("foo");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void builderSecure() throws Exception {
+    Cookie cookie = new Cookie.Builder()
+        .name("a")
+        .value("b")
+        .hostOnlyDomain("example.com")
+        .secure()
+        .build();
+    assertEquals(true, cookie.secure());
+  }
+
+  @Test public void builderHttpOnly() throws Exception {
+    Cookie cookie = new Cookie.Builder()
+        .name("a")
+        .value("b")
+        .hostOnlyDomain("example.com")
+        .httpOnly()
+        .build();
+    assertEquals(true, cookie.httpOnly());
+  }
+
+  @Test public void equalsAndHashCode() throws Exception {
+    List<String> cookieStrings = Arrays.asList(
+        "a=b; Path=/c; Domain=example.com; Max-Age=5; Secure; HttpOnly",
+        "a= ; Path=/c; Domain=example.com; Max-Age=5; Secure; HttpOnly",
+        "a=b;          Domain=example.com; Max-Age=5; Secure; HttpOnly",
+        "a=b; Path=/c;                     Max-Age=5; Secure; HttpOnly",
+        "a=b; Path=/c; Domain=example.com;            Secure; HttpOnly",
+        "a=b; Path=/c; Domain=example.com; Max-Age=5;         HttpOnly",
+        "a=b; Path=/c; Domain=example.com; Max-Age=5; Secure;         "
+    );
+    for (String stringA : cookieStrings) {
+      Cookie cookieA = Cookie.parse(0, url, stringA);
+      for (String stringB : cookieStrings) {
+        Cookie cookieB = Cookie.parse(0, url, stringB);
+        if (Objects.equals(stringA, stringB)) {
+          assertEquals(cookieA.hashCode(), cookieB.hashCode());
+          assertEquals(cookieA, cookieB);
+        } else {
+          assertFalse(cookieA.hashCode() == cookieB.hashCode());
+          assertFalse(cookieA.equals(cookieB));
+        }
+      }
+      assertFalse(cookieA.equals(null));
+    }
+  }
+
+  private Date date(String s) throws ParseException {
+    SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ");
+    format.setTimeZone(Util.UTC);
+    return format.parse(s);
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/DelegatingSSLSocket.java b/okhttp-tests/src/test/java/okhttp3/DelegatingSSLSocket.java
similarity index 79%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/DelegatingSSLSocket.java
rename to okhttp-tests/src/test/java/okhttp3/DelegatingSSLSocket.java
index e13a50fcb9..fc863c2022 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/DelegatingSSLSocket.java
+++ b/okhttp-tests/src/test/java/okhttp3/DelegatingSSLSocket.java
@@ -13,15 +13,19 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
+import java.lang.reflect.InvocationTargetException;
 import java.net.InetAddress;
+import java.net.Socket;
 import java.net.SocketAddress;
 import java.net.SocketException;
+import java.net.SocketOption;
 import java.nio.channels.SocketChannel;
+import java.util.Set;
 import javax.net.ssl.HandshakeCompletedListener;
 import javax.net.ssl.SSLParameters;
 import javax.net.ssl.SSLSession;
@@ -280,4 +284,55 @@ public DelegatingSSLSocket(SSLSocket delegate) {
   @Override public void setPerformancePreferences(int connectionTime, int latency, int bandwidth) {
     delegate.setPerformancePreferences(connectionTime, latency, bandwidth);
   }
+
+  // Java 9 methods.
+
+  public SSLSession getHandshakeSession() {
+    try {
+      return (SSLSession) SSLSocket.class.getMethod("getHandshakeSession").invoke(delegate);
+    } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
+      throw new AssertionError();
+    }
+  }
+
+  public String getApplicationProtocol() {
+    try {
+      return (String) SSLSocket.class.getMethod("getApplicationProtocol").invoke(delegate);
+    } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
+      throw new AssertionError();
+    }
+  }
+
+  public String getHandshakeApplicationProtocol() {
+    try {
+      return (String) SSLSocket.class.getMethod("getHandshakeApplicationProtocol").invoke(delegate);
+    } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
+      throw new AssertionError();
+    }
+  }
+
+  public <T> Socket setOption(SocketOption<T> name, T value) throws IOException {
+    try {
+      SSLSocket.class.getMethod("setOption", SocketOption.class, Object.class).invoke(delegate, name, value);
+      return this;
+    } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
+      throw new AssertionError();
+    }
+  }
+
+  public <T> T getOption(SocketOption<T> name) throws IOException {
+    try {
+      return (T) SSLSocket.class.getMethod("getOption", SocketOption.class).invoke(delegate, name);
+    } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
+      throw new AssertionError();
+    }
+  }
+
+  public Set<SocketOption<?>> supportedOptions() {
+    try {
+      return (Set<SocketOption<?>>) SSLSocket.class.getMethod("supportedOptions").invoke(delegate);
+    } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
+      throw new AssertionError();
+    }
+  }
 }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/DelegatingSSLSocketFactory.java b/okhttp-tests/src/test/java/okhttp3/DelegatingSSLSocketFactory.java
similarity index 56%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/DelegatingSSLSocketFactory.java
rename to okhttp-tests/src/test/java/okhttp3/DelegatingSSLSocketFactory.java
index a14db22e67..5a14d0fbd6 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/DelegatingSSLSocketFactory.java
+++ b/okhttp-tests/src/test/java/okhttp3/DelegatingSSLSocketFactory.java
@@ -13,19 +13,18 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
 import java.io.IOException;
 import java.net.InetAddress;
 import java.net.Socket;
 import java.net.UnknownHostException;
-import javax.net.SocketFactory;
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
 
 /**
- * A {@link SSLSocketFactory} that delegates calls. Sockets can be configured after
- * creation by overriding {@link #configureSocket(javax.net.ssl.SSLSocket)}.
+ * A {@link SSLSocketFactory} that delegates calls. Sockets can be configured after creation by
+ * overriding {@link #configureSocket(javax.net.ssl.SSLSocket)}.
  */
 public class DelegatingSSLSocketFactory extends SSLSocketFactory {
 
@@ -35,62 +34,49 @@ public DelegatingSSLSocketFactory(SSLSocketFactory delegate) {
     this.delegate = delegate;
   }
 
-  @Override
-  public SSLSocket createSocket() throws IOException {
+  @Override public SSLSocket createSocket() throws IOException {
     SSLSocket sslSocket = (SSLSocket) delegate.createSocket();
-    configureSocket(sslSocket);
-    return sslSocket;
+    return configureSocket(sslSocket);
   }
 
-  @Override
-  public SSLSocket createSocket(String host, int port) throws IOException, UnknownHostException {
+  @Override public SSLSocket createSocket(String host, int port) throws IOException {
     SSLSocket sslSocket = (SSLSocket) delegate.createSocket(host, port);
-    configureSocket(sslSocket);
-    return sslSocket;
+    return configureSocket(sslSocket);
   }
 
-  @Override
-  public SSLSocket createSocket(String host, int port, InetAddress localAddress, int localPort)
-      throws IOException, UnknownHostException {
+  @Override public SSLSocket createSocket(
+      String host, int port, InetAddress localAddress, int localPort) throws IOException {
     SSLSocket sslSocket = (SSLSocket) delegate.createSocket(host, port, localAddress, localPort);
-    configureSocket(sslSocket);
-    return sslSocket;
+    return configureSocket(sslSocket);
   }
 
-  @Override
-  public SSLSocket createSocket(InetAddress host, int port) throws IOException {
+  @Override public SSLSocket createSocket(InetAddress host, int port) throws IOException {
     SSLSocket sslSocket = (SSLSocket) delegate.createSocket(host, port);
-    configureSocket(sslSocket);
-    return sslSocket;
+    return configureSocket(sslSocket);
   }
 
-  @Override
-  public SSLSocket createSocket(InetAddress host, int port, InetAddress localAddress, int localPort)
-      throws IOException {
+  @Override public SSLSocket createSocket(
+      InetAddress host, int port, InetAddress localAddress, int localPort) throws IOException {
     SSLSocket sslSocket = (SSLSocket) delegate.createSocket(host, port, localAddress, localPort);
-    configureSocket(sslSocket);
-    return sslSocket;
+    return configureSocket(sslSocket);
   }
 
-  @Override
-  public String[] getDefaultCipherSuites() {
+  @Override public String[] getDefaultCipherSuites() {
     return delegate.getDefaultCipherSuites();
   }
 
-  @Override
-  public String[] getSupportedCipherSuites() {
+  @Override public String[] getSupportedCipherSuites() {
     return delegate.getSupportedCipherSuites();
   }
 
-  @Override
-  public SSLSocket createSocket(Socket socket, String host, int port, boolean autoClose)
-      throws IOException {
+  @Override public SSLSocket createSocket(
+      Socket socket, String host, int port, boolean autoClose) throws IOException {
     SSLSocket sslSocket = (SSLSocket) delegate.createSocket(socket, host, port, autoClose);
-    configureSocket(sslSocket);
-    return sslSocket;
+    return configureSocket(sslSocket);
   }
 
-  protected void configureSocket(SSLSocket sslSocket) throws IOException {
+  protected SSLSocket configureSocket(SSLSocket sslSocket) throws IOException {
     // No-op by default.
+    return sslSocket;
   }
 }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/DelegatingServerSocketFactory.java b/okhttp-tests/src/test/java/okhttp3/DelegatingServerSocketFactory.java
similarity index 84%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/DelegatingServerSocketFactory.java
rename to okhttp-tests/src/test/java/okhttp3/DelegatingServerSocketFactory.java
index ef24aaaaeb..09b3a25d09 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/DelegatingServerSocketFactory.java
+++ b/okhttp-tests/src/test/java/okhttp3/DelegatingServerSocketFactory.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
 import java.io.IOException;
 import java.net.InetAddress;
@@ -35,33 +35,30 @@ public DelegatingServerSocketFactory(ServerSocketFactory delegate) {
   @Override
   public ServerSocket createServerSocket() throws IOException {
     ServerSocket serverSocket = delegate.createServerSocket();
-    configureServerSocket(serverSocket);
-    return serverSocket;
+    return configureServerSocket(serverSocket);
   }
 
   @Override
   public ServerSocket createServerSocket(int port) throws IOException {
     ServerSocket serverSocket = delegate.createServerSocket(port);
-    configureServerSocket(serverSocket);
-    return serverSocket;
+    return configureServerSocket(serverSocket);
   }
 
   @Override
   public ServerSocket createServerSocket(int port, int backlog) throws IOException {
     ServerSocket serverSocket = delegate.createServerSocket(port, backlog);
-    configureServerSocket(serverSocket);
-    return serverSocket;
+    return configureServerSocket(serverSocket);
   }
 
   @Override
   public ServerSocket createServerSocket(int port, int backlog, InetAddress ifAddress)
       throws IOException {
     ServerSocket serverSocket = delegate.createServerSocket(port, backlog, ifAddress);
-    configureServerSocket(serverSocket);
-    return serverSocket;
+    return configureServerSocket(serverSocket);
   }
 
-  protected void configureServerSocket(ServerSocket serverSocket) throws IOException {
+  protected ServerSocket configureServerSocket(ServerSocket serverSocket) throws IOException {
     // No-op by default.
+    return serverSocket;
   }
 }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/DelegatingSocketFactory.java b/okhttp-tests/src/test/java/okhttp3/DelegatingSocketFactory.java
similarity index 86%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/DelegatingSocketFactory.java
rename to okhttp-tests/src/test/java/okhttp3/DelegatingSocketFactory.java
index e8fdfe80fd..d21f37a31a 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/DelegatingSocketFactory.java
+++ b/okhttp-tests/src/test/java/okhttp3/DelegatingSocketFactory.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
 import java.io.IOException;
 import java.net.InetAddress;
@@ -36,41 +36,37 @@ public DelegatingSocketFactory(SocketFactory delegate) {
   @Override
   public Socket createSocket() throws IOException {
     Socket socket = delegate.createSocket();
-    configureSocket(socket);
-    return socket;
+    return configureSocket(socket);
   }
 
   @Override
   public Socket createSocket(String host, int port) throws IOException, UnknownHostException {
     Socket socket = delegate.createSocket(host, port);
-    configureSocket(socket);
-    return socket;
+    return configureSocket(socket);
   }
 
   @Override
   public Socket createSocket(String host, int port, InetAddress localAddress, int localPort)
       throws IOException, UnknownHostException {
     Socket socket = delegate.createSocket(host, port, localAddress, localPort);
-    configureSocket(socket);
-    return socket;
+    return configureSocket(socket);
   }
 
   @Override
   public Socket createSocket(InetAddress host, int port) throws IOException {
     Socket socket = delegate.createSocket(host, port);
-    configureSocket(socket);
-    return socket;
+    return configureSocket(socket);
   }
 
   @Override
   public Socket createSocket(InetAddress host, int port, InetAddress localAddress, int localPort)
       throws IOException {
     Socket socket = delegate.createSocket(host, port, localAddress, localPort);
-    configureSocket(socket);
-    return socket;
+    return configureSocket(socket);
   }
 
-  protected void configureSocket(Socket socket) throws IOException {
+  protected Socket configureSocket(Socket socket) throws IOException {
     // No-op by default.
+    return socket;
   }
 }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/DispatcherTest.java b/okhttp-tests/src/test/java/okhttp3/DispatcherTest.java
similarity index 53%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/DispatcherTest.java
rename to okhttp-tests/src/test/java/okhttp3/DispatcherTest.java
index 3d7701f298..6c04901464 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/DispatcherTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/DispatcherTest.java
@@ -1,23 +1,35 @@
-package com.squareup.okhttp;
+package okhttp3;
 
-import com.squareup.okhttp.Call.AsyncCall;
+import java.io.IOException;
+import java.io.InterruptedIOException;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.Iterator;
+import java.util.LinkedHashSet;
 import java.util.List;
+import java.util.Set;
 import java.util.concurrent.AbstractExecutorService;
+import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import okhttp3.RealCall.AsyncCall;
 import org.junit.Before;
 import org.junit.Test;
 
+import static java.util.concurrent.TimeUnit.SECONDS;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 public final class DispatcherTest {
   RecordingExecutor executor = new RecordingExecutor();
   RecordingCallback callback = new RecordingCallback();
   Dispatcher dispatcher = new Dispatcher(executor);
-  OkHttpClient client = new OkHttpClient().setDispatcher(dispatcher);
+  OkHttpClient client = new OkHttpClient.Builder()
+      .dispatcher(dispatcher)
+      .build();
 
   @Before public void setUp() throws Exception {
     dispatcher.setMaxRequests(20);
@@ -114,14 +126,157 @@
 
   @Test public void cancelingRunningJobTakesNoEffectUntilJobFinishes() throws Exception {
     dispatcher.setMaxRequests(1);
-    client.newCall(newRequest("http://a/1", "tag1")).enqueue(callback);
-    client.newCall(newRequest("http://a/2")).enqueue(callback);
-    dispatcher.cancel("tag1");
+    Call c1 = client.newCall(newRequest("http://a/1", "tag1"));
+    Call c2 = client.newCall(newRequest("http://a/2"));
+    c1.enqueue(callback);
+    c2.enqueue(callback);
+    c1.cancel();
     executor.assertJobs("http://a/1");
     executor.finishJob("http://a/1");
     executor.assertJobs("http://a/2");
   }
 
+  @Test public void asyncCallAccessors() throws Exception {
+    dispatcher.setMaxRequests(3);
+    Call a1 = client.newCall(newRequest("http://a/1"));
+    Call a2 = client.newCall(newRequest("http://a/2"));
+    Call a3 = client.newCall(newRequest("http://a/3"));
+    Call a4 = client.newCall(newRequest("http://a/4"));
+    Call a5 = client.newCall(newRequest("http://a/5"));
+    a1.enqueue(callback);
+    a2.enqueue(callback);
+    a3.enqueue(callback);
+    a4.enqueue(callback);
+    a5.enqueue(callback);
+    assertEquals(3, dispatcher.runningCallsCount());
+    assertEquals(2, dispatcher.queuedCallsCount());
+    assertEquals(set(a1, a2, a3), set(dispatcher.runningCalls()));
+    assertEquals(set(a4, a5), set(dispatcher.queuedCalls()));
+  }
+
+  @Test public void synchronousCallAccessors() throws Exception {
+    final CountDownLatch ready = new CountDownLatch(2);
+    final CountDownLatch waiting = new CountDownLatch(1);
+    client = client.newBuilder()
+        .addInterceptor(
+            new Interceptor() {
+              @Override public Response intercept(Chain chain) throws IOException {
+                try {
+                  ready.countDown();
+                  waiting.await();
+                } catch (InterruptedException e) {
+                  throw new AssertionError();
+                }
+                throw new IOException();
+              }
+            })
+        .build();
+
+    Call a1 = client.newCall(newRequest("http://a/1"));
+    Call a2 = client.newCall(newRequest("http://a/2"));
+    Call a3 = client.newCall(newRequest("http://a/3"));
+    Call a4 = client.newCall(newRequest("http://a/4"));
+    Thread t1 = makeSynchronousCall(a1);
+    Thread t2 = makeSynchronousCall(a2);
+
+    // We created 4 calls and started 2 of them. That's 2 running calls and 0 queued.
+    ready.await();
+    assertEquals(2, dispatcher.runningCallsCount());
+    assertEquals(0, dispatcher.queuedCallsCount());
+    assertEquals(set(a1, a2), set(dispatcher.runningCalls()));
+    assertEquals(Collections.emptyList(), dispatcher.queuedCalls());
+
+    // Cancel some calls. That doesn't impact running or queued.
+    a2.cancel();
+    a3.cancel();
+    assertEquals(set(a1, a2), set(dispatcher.runningCalls()));
+    assertEquals(Collections.emptyList(), dispatcher.queuedCalls());
+
+    // Let the calls finish.
+    waiting.countDown();
+    t1.join();
+    t2.join();
+
+    // Now we should have 0 running calls and 0 queued calls.
+    assertEquals(0, dispatcher.runningCallsCount());
+    assertEquals(0, dispatcher.queuedCallsCount());
+    assertEquals(Collections.emptyList(), dispatcher.runningCalls());
+    assertEquals(Collections.emptyList(), dispatcher.queuedCalls());
+
+    assertTrue(a1.isExecuted());
+    assertFalse(a1.isCanceled());
+
+    assertTrue(a2.isExecuted());
+    assertTrue(a2.isCanceled());
+
+    assertFalse(a3.isExecuted());
+    assertTrue(a3.isCanceled());
+
+    assertFalse(a4.isExecuted());
+    assertFalse(a4.isCanceled());
+  }
+
+  @Test public void idleCallbackInvokedWhenIdle() throws InterruptedException {
+    final AtomicBoolean idle = new AtomicBoolean();
+    dispatcher.setIdleCallback(new Runnable() {
+      @Override public void run() {
+        idle.set(true);
+      }
+    });
+
+    client.newCall(newRequest("http://a/1")).enqueue(callback);
+    client.newCall(newRequest("http://a/2")).enqueue(callback);
+    executor.finishJob("http://a/1");
+    assertFalse(idle.get());
+
+    final CountDownLatch ready = new CountDownLatch(1);
+    final CountDownLatch proceed = new CountDownLatch(1);
+    client = client.newBuilder()
+        .addInterceptor(new Interceptor() {
+          @Override public Response intercept(Chain chain) throws IOException {
+            ready.countDown();
+            try {
+              proceed.await(5, SECONDS);
+            } catch (InterruptedException e) {
+              throw new RuntimeException(e);
+            }
+            return chain.proceed(chain.request());
+          }
+        })
+        .build();
+
+    Thread t1 = makeSynchronousCall(client.newCall(newRequest("http://a/3")));
+    ready.await(5, SECONDS);
+    executor.finishJob("http://a/2");
+    assertFalse(idle.get());
+
+    proceed.countDown();
+    t1.join();
+    assertTrue(idle.get());
+  }
+
+  private <T> Set<T> set(T... values) {
+    return set(Arrays.asList(values));
+  }
+
+  private <T> Set<T> set(List<T> list) {
+    return new LinkedHashSet<>(list);
+  }
+
+  private Thread makeSynchronousCall(final Call call) {
+    Thread thread = new Thread() {
+      @Override public void run() {
+        try {
+          call.execute();
+          throw new AssertionError();
+        } catch (IOException expected) {
+        }
+      }
+    };
+    thread.start();
+    return thread;
+  }
+
   class RecordingExecutor extends AbstractExecutorService {
     private List<AsyncCall> calls = new ArrayList<>();
 
@@ -132,7 +287,7 @@
     public void assertJobs(String... expectedUrls) {
       List<String> actualUrls = new ArrayList<>();
       for (AsyncCall call : calls) {
-        actualUrls.add(call.request().urlString());
+        actualUrls.add(call.request().url().toString());
       }
       assertEquals(Arrays.asList(expectedUrls), actualUrls);
     }
@@ -140,7 +295,7 @@ public void assertJobs(String... expectedUrls) {
     public void finishJob(String url) {
       for (Iterator<AsyncCall> i = calls.iterator(); i.hasNext(); ) {
         AsyncCall call = i.next();
-        if (call.request().urlString().equals(url)) {
+        if (call.request().url().toString().equals(url)) {
           i.remove();
           dispatcher.finished(call);
           return;
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/FallbackTestClientSocketFactory.java b/okhttp-tests/src/test/java/okhttp3/FallbackTestClientSocketFactory.java
similarity index 56%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/FallbackTestClientSocketFactory.java
rename to okhttp-tests/src/test/java/okhttp3/FallbackTestClientSocketFactory.java
index 5f9e623c1c..eb9aaaa2d3 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/FallbackTestClientSocketFactory.java
+++ b/okhttp-tests/src/test/java/okhttp3/FallbackTestClientSocketFactory.java
@@ -13,11 +13,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
 import java.io.IOException;
-import java.net.InetAddress;
-import java.net.Socket;
 import java.util.ArrayList;
 import java.util.List;
 import javax.net.ssl.SSLSocket;
@@ -31,8 +29,8 @@
  */
 public class FallbackTestClientSocketFactory extends DelegatingSSLSocketFactory {
   /**
-   * The cipher suite used during TLS connection fallback to indicate a fallback.
-   * See https://tools.ietf.org/html/draft-ietf-tls-downgrade-scsv-00
+   * The cipher suite used during TLS connection fallback to indicate a fallback. See
+   * https://tools.ietf.org/html/draft-ietf-tls-downgrade-scsv-00
    */
   public static final String TLS_FALLBACK_SCSV = "TLS_FALLBACK_SCSV";
 
@@ -40,37 +38,8 @@ public FallbackTestClientSocketFactory(SSLSocketFactory delegate) {
     super(delegate);
   }
 
-  @Override public SSLSocket createSocket(Socket s, String host, int port, boolean autoClose)
-      throws IOException {
-    SSLSocket socket = super.createSocket(s, host, port, autoClose);
-    return new TlsFallbackScsvDisabledSSLSocket(socket);
-  }
-
-  @Override public SSLSocket createSocket() throws IOException {
-    SSLSocket socket = super.createSocket();
-    return new TlsFallbackScsvDisabledSSLSocket(socket);
-  }
-
-  @Override public SSLSocket createSocket(String host,int port) throws IOException {
-    SSLSocket socket = super.createSocket(host, port);
-    return new TlsFallbackScsvDisabledSSLSocket(socket);
-  }
-
-  @Override public SSLSocket createSocket(String host,int port, InetAddress localHost,
-      int localPort) throws IOException {
-    SSLSocket socket = super.createSocket(host, port, localHost, localPort);
-    return new TlsFallbackScsvDisabledSSLSocket(socket);
-  }
-
-  @Override public SSLSocket createSocket(InetAddress host,int port) throws IOException {
-    SSLSocket socket = super.createSocket(host, port);
-    return new TlsFallbackScsvDisabledSSLSocket(socket);
-  }
-
-  @Override public SSLSocket createSocket(InetAddress address,int port,
-      InetAddress localAddress, int localPort) throws IOException {
-    SSLSocket socket = super.createSocket(address, port, localAddress, localPort);
-    return new TlsFallbackScsvDisabledSSLSocket(socket);
+  @Override protected SSLSocket configureSocket(SSLSocket sslSocket) throws IOException {
+    return new TlsFallbackScsvDisabledSSLSocket(sslSocket);
   }
 
   private static class TlsFallbackScsvDisabledSSLSocket extends DelegatingSSLSocket {
diff --git a/okhttp-tests/src/test/java/okhttp3/FormBodyTest.java b/okhttp-tests/src/test/java/okhttp3/FormBodyTest.java
new file mode 100644
index 0000000000..34e40b96f7
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/FormBodyTest.java
@@ -0,0 +1,199 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import okio.Buffer;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+
+public final class FormBodyTest {
+  @Test public void urlEncoding() throws Exception {
+    FormBody body = new FormBody.Builder()
+        .add("a+=& b", "c+=& d")
+        .add("space, the", "final frontier")
+        .add("%25", "%25")
+        .build();
+
+    assertEquals(3, body.size());
+
+    assertEquals("a%2B%3D%26%20b", body.encodedName(0));
+    assertEquals("space%2C%20the", body.encodedName(1));
+    assertEquals("%2525", body.encodedName(2));
+
+    assertEquals("a+=& b", body.name(0));
+    assertEquals("space, the", body.name(1));
+    assertEquals("%25", body.name(2));
+
+    assertEquals("c%2B%3D%26%20d", body.encodedValue(0));
+    assertEquals("final%20frontier", body.encodedValue(1));
+    assertEquals("%2525", body.encodedValue(2));
+
+    assertEquals("c+=& d", body.value(0));
+    assertEquals("final frontier", body.value(1));
+    assertEquals("%25", body.value(2));
+
+    assertEquals("application/x-www-form-urlencoded", body.contentType().toString());
+
+    String expected = "a%2B%3D%26%20b=c%2B%3D%26%20d&space%2C%20the=final%20frontier&%2525=%2525";
+    assertEquals(expected.length(), body.contentLength());
+
+    Buffer out = new Buffer();
+    body.writeTo(out);
+    assertEquals(expected, out.readUtf8());
+  }
+
+  @Test public void addEncoded() throws Exception {
+    FormBody body = new FormBody.Builder()
+        .addEncoded("a+=& b", "c+=& d")
+        .addEncoded("e+=& f", "g+=& h")
+        .addEncoded("%25", "%25")
+        .build();
+
+    String expected = "a+%3D%26%20b=c+%3D%26%20d&e+%3D%26%20f=g+%3D%26%20h&%25=%25";
+    Buffer out = new Buffer();
+    body.writeTo(out);
+    assertEquals(expected, out.readUtf8());
+  }
+
+  @Test public void encodedPair() throws Exception {
+    FormBody body = new FormBody.Builder()
+        .add("sim", "ple")
+        .build();
+
+    String expected = "sim=ple";
+    assertEquals(expected.length(), body.contentLength());
+
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    assertEquals(expected, buffer.readUtf8());
+  }
+
+  @Test public void encodeMultiplePairs() throws Exception {
+    FormBody body = new FormBody.Builder()
+        .add("sim", "ple")
+        .add("hey", "there")
+        .add("help", "me")
+        .build();
+
+    String expected = "sim=ple&hey=there&help=me";
+    assertEquals(expected.length(), body.contentLength());
+
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    assertEquals(expected, buffer.readUtf8());
+  }
+
+  @Test public void buildEmptyForm() throws Exception {
+    FormBody body = new FormBody.Builder().build();
+
+    String expected = "";
+    assertEquals(expected.length(), body.contentLength());
+
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    assertEquals(expected, buffer.readUtf8());
+  }
+
+  @Test public void characterEncoding() throws Exception {
+    assertEquals("%00", formEncode(0)); // Browsers convert '\u0000' to '%EF%BF%BD'.
+    assertEquals("%01", formEncode(1));
+    assertEquals("%02", formEncode(2));
+    assertEquals("%03", formEncode(3));
+    assertEquals("%04", formEncode(4));
+    assertEquals("%05", formEncode(5));
+    assertEquals("%06", formEncode(6));
+    assertEquals("%07", formEncode(7));
+    assertEquals("%08", formEncode(8));
+    assertEquals("%09", formEncode(9));
+    assertEquals("%0A", formEncode(10)); // Browsers convert '\n' to '\r\n'
+    assertEquals("%0B", formEncode(11));
+    assertEquals("%0C", formEncode(12));
+    assertEquals("%0D", formEncode(13)); // Browsers convert '\r' to '\r\n'
+    assertEquals("%0E", formEncode(14));
+    assertEquals("%0F", formEncode(15));
+    assertEquals("%10", formEncode(16));
+    assertEquals("%11", formEncode(17));
+    assertEquals("%12", formEncode(18));
+    assertEquals("%13", formEncode(19));
+    assertEquals("%14", formEncode(20));
+    assertEquals("%15", formEncode(21));
+    assertEquals("%16", formEncode(22));
+    assertEquals("%17", formEncode(23));
+    assertEquals("%18", formEncode(24));
+    assertEquals("%19", formEncode(25));
+    assertEquals("%1A", formEncode(26));
+    assertEquals("%1B", formEncode(27));
+    assertEquals("%1C", formEncode(28));
+    assertEquals("%1D", formEncode(29));
+    assertEquals("%1E", formEncode(30));
+    assertEquals("%1F", formEncode(31));
+    assertEquals("%20", formEncode(32)); // Browsers use '+' for space.
+    assertEquals("%21", formEncode(33));
+    assertEquals("%22", formEncode(34));
+    assertEquals("%23", formEncode(35));
+    assertEquals("%24", formEncode(36));
+    assertEquals("%25", formEncode(37));
+    assertEquals("%26", formEncode(38));
+    assertEquals("%27", formEncode(39));
+    assertEquals("%28", formEncode(40));
+    assertEquals("%29", formEncode(41));
+    assertEquals("*", formEncode(42));
+    assertEquals("%2B", formEncode(43));
+    assertEquals("%2C", formEncode(44));
+    assertEquals("-", formEncode(45));
+    assertEquals(".", formEncode(46));
+    assertEquals("%2F", formEncode(47));
+    assertEquals("0", formEncode(48));
+    assertEquals("9", formEncode(57));
+    assertEquals("%3A", formEncode(58));
+    assertEquals("%3B", formEncode(59));
+    assertEquals("%3C", formEncode(60));
+    assertEquals("%3D", formEncode(61));
+    assertEquals("%3E", formEncode(62));
+    assertEquals("%3F", formEncode(63));
+    assertEquals("%40", formEncode(64));
+    assertEquals("A", formEncode(65));
+    assertEquals("Z", formEncode(90));
+    assertEquals("%5B", formEncode(91));
+    assertEquals("%5C", formEncode(92));
+    assertEquals("%5D", formEncode(93));
+    assertEquals("%5E", formEncode(94));
+    assertEquals("_", formEncode(95));
+    assertEquals("%60", formEncode(96));
+    assertEquals("a", formEncode(97));
+    assertEquals("z", formEncode(122));
+    assertEquals("%7B", formEncode(123));
+    assertEquals("%7C", formEncode(124));
+    assertEquals("%7D", formEncode(125));
+    assertEquals("%7E", formEncode(126));
+    assertEquals("%7F", formEncode(127));
+    assertEquals("%C2%80", formEncode(128));
+    assertEquals("%C3%BF", formEncode(255));
+  }
+
+  private String formEncode(int codePoint) throws IOException {
+    // Wrap the codepoint with regular printable characters to prevent trimming.
+    FormBody body = new FormBody.Builder()
+        .add("a", new String(new int[] {'b', codePoint, 'c'}, 0, 3))
+        .build();
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    buffer.skip(3); // Skip "a=b" prefix.
+    return buffer.readUtf8(buffer.size() - 1); // Skip the "c" suffix.
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java b/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java
new file mode 100644
index 0000000000..f7d655dbf0
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java
@@ -0,0 +1,1429 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.net.MalformedURLException;
+import java.net.URI;
+import java.net.URL;
+import java.net.UnknownHostException;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.LinkedHashSet;
+import okhttp3.UrlComponentEncodingTester.Component;
+import okhttp3.UrlComponentEncodingTester.Encoding;
+import org.junit.Ignore;
+import org.junit.Test;
+
+import static java.util.Collections.singletonList;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.fail;
+
+public final class HttpUrlTest {
+  @Test public void parseTrimsAsciiWhitespace() throws Exception {
+    HttpUrl expected = HttpUrl.parse("http://host/");
+    assertEquals(expected, HttpUrl.parse("http://host/\f\n\t \r")); // Leading.
+    assertEquals(expected, HttpUrl.parse("\r\n\f \thttp://host/")); // Trailing.
+    assertEquals(expected, HttpUrl.parse(" http://host/ ")); // Both.
+    assertEquals(expected, HttpUrl.parse("    http://host/    ")); // Both.
+    assertEquals(expected, HttpUrl.parse("http://host/").resolve("   "));
+    assertEquals(expected, HttpUrl.parse("http://host/").resolve("  .  "));
+  }
+
+  @Test public void parseHostAsciiNonPrintable() throws Exception {
+    String host = "host\u0001";
+    assertNull(HttpUrl.parse("http://" + host + "/"));
+  }
+
+  @Test public void parseDoesNotTrimOtherWhitespaceCharacters() throws Exception {
+    // Whitespace characters list from Google's Guava team: http://goo.gl/IcR9RD
+    assertEquals("/%0B", HttpUrl.parse("http://h/\u000b").encodedPath()); // line tabulation
+    assertEquals("/%1C", HttpUrl.parse("http://h/\u001c").encodedPath()); // information separator 4
+    assertEquals("/%1D", HttpUrl.parse("http://h/\u001d").encodedPath()); // information separator 3
+    assertEquals("/%1E", HttpUrl.parse("http://h/\u001e").encodedPath()); // information separator 2
+    assertEquals("/%1F", HttpUrl.parse("http://h/\u001f").encodedPath()); // information separator 1
+    assertEquals("/%C2%85", HttpUrl.parse("http://h/\u0085").encodedPath()); // next line
+    assertEquals("/%C2%A0", HttpUrl.parse("http://h/\u00a0").encodedPath()); // non-breaking space
+    assertEquals("/%E1%9A%80", HttpUrl.parse("http://h/\u1680").encodedPath()); // ogham space mark
+    assertEquals("/%E1%A0%8E", HttpUrl.parse("http://h/\u180e").encodedPath()); // mongolian vowel separator
+    assertEquals("/%E2%80%80", HttpUrl.parse("http://h/\u2000").encodedPath()); // en quad
+    assertEquals("/%E2%80%81", HttpUrl.parse("http://h/\u2001").encodedPath()); // em quad
+    assertEquals("/%E2%80%82", HttpUrl.parse("http://h/\u2002").encodedPath()); // en space
+    assertEquals("/%E2%80%83", HttpUrl.parse("http://h/\u2003").encodedPath()); // em space
+    assertEquals("/%E2%80%84", HttpUrl.parse("http://h/\u2004").encodedPath()); // three-per-em space
+    assertEquals("/%E2%80%85", HttpUrl.parse("http://h/\u2005").encodedPath()); // four-per-em space
+    assertEquals("/%E2%80%86", HttpUrl.parse("http://h/\u2006").encodedPath()); // six-per-em space
+    assertEquals("/%E2%80%87", HttpUrl.parse("http://h/\u2007").encodedPath()); // figure space
+    assertEquals("/%E2%80%88", HttpUrl.parse("http://h/\u2008").encodedPath()); // punctuation space
+    assertEquals("/%E2%80%89", HttpUrl.parse("http://h/\u2009").encodedPath()); // thin space
+    assertEquals("/%E2%80%8A", HttpUrl.parse("http://h/\u200a").encodedPath()); // hair space
+    assertEquals("/%E2%80%8B", HttpUrl.parse("http://h/\u200b").encodedPath()); // zero-width space
+    assertEquals("/%E2%80%8C", HttpUrl.parse("http://h/\u200c").encodedPath()); // zero-width non-joiner
+    assertEquals("/%E2%80%8D", HttpUrl.parse("http://h/\u200d").encodedPath()); // zero-width joiner
+    assertEquals("/%E2%80%8E", HttpUrl.parse("http://h/\u200e").encodedPath()); // left-to-right mark
+    assertEquals("/%E2%80%8F", HttpUrl.parse("http://h/\u200f").encodedPath()); // right-to-left mark
+    assertEquals("/%E2%80%A8", HttpUrl.parse("http://h/\u2028").encodedPath()); // line separator
+    assertEquals("/%E2%80%A9", HttpUrl.parse("http://h/\u2029").encodedPath()); // paragraph separator
+    assertEquals("/%E2%80%AF", HttpUrl.parse("http://h/\u202f").encodedPath()); // narrow non-breaking space
+    assertEquals("/%E2%81%9F", HttpUrl.parse("http://h/\u205f").encodedPath()); // medium mathematical space
+    assertEquals("/%E3%80%80", HttpUrl.parse("http://h/\u3000").encodedPath()); // ideographic space
+  }
+
+  @Test public void scheme() throws Exception {
+    assertEquals(HttpUrl.parse("http://host/"), HttpUrl.parse("http://host/"));
+    assertEquals(HttpUrl.parse("http://host/"), HttpUrl.parse("Http://host/"));
+    assertEquals(HttpUrl.parse("http://host/"), HttpUrl.parse("http://host/"));
+    assertEquals(HttpUrl.parse("http://host/"), HttpUrl.parse("HTTP://host/"));
+    assertEquals(HttpUrl.parse("https://host/"), HttpUrl.parse("https://host/"));
+    assertEquals(HttpUrl.parse("https://host/"), HttpUrl.parse("HTTPS://host/"));
+    assertEquals(HttpUrl.Builder.ParseResult.UNSUPPORTED_SCHEME,
+        new HttpUrl.Builder().parse(null, "image640://480.png"));
+    assertEquals(null, HttpUrl.parse("httpp://host/"));
+    assertEquals(null, HttpUrl.parse("0ttp://host/"));
+    assertEquals(null, HttpUrl.parse("ht+tp://host/"));
+    assertEquals(null, HttpUrl.parse("ht.tp://host/"));
+    assertEquals(null, HttpUrl.parse("ht-tp://host/"));
+    assertEquals(null, HttpUrl.parse("ht1tp://host/"));
+    assertEquals(null, HttpUrl.parse("httpss://host/"));
+  }
+
+  @Test public void parseNoScheme() throws Exception {
+    assertEquals(null, HttpUrl.parse("//host"));
+    assertEquals(null, HttpUrl.parse("/path"));
+    assertEquals(null, HttpUrl.parse("path"));
+    assertEquals(null, HttpUrl.parse("?query"));
+    assertEquals(null, HttpUrl.parse("#fragment"));
+  }
+
+  @Test public void newBuilderResolve() throws Exception {
+    // Non-exhaustive tests because implementation is the same as resolve.
+    HttpUrl base = HttpUrl.parse("http://host/a/b");
+    assertEquals(HttpUrl.parse("https://host2/"), base.newBuilder("https://host2").build());
+    assertEquals(HttpUrl.parse("http://host2/"), base.newBuilder("//host2").build());
+    assertEquals(HttpUrl.parse("http://host/path"), base.newBuilder("/path").build());
+    assertEquals(HttpUrl.parse("http://host/a/path"), base.newBuilder("path").build());
+    assertEquals(HttpUrl.parse("http://host/a/b?query"), base.newBuilder("?query").build());
+    assertEquals(HttpUrl.parse("http://host/a/b#fragment"), base.newBuilder("#fragment").build());
+    assertEquals(HttpUrl.parse("http://host/a/b"), base.newBuilder("").build());
+    assertEquals(null, base.newBuilder("ftp://b"));
+    assertEquals(null, base.newBuilder("ht+tp://b"));
+    assertEquals(null, base.newBuilder("ht-tp://b"));
+    assertEquals(null, base.newBuilder("ht.tp://b"));
+  }
+
+  @Test public void resolveNoScheme() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b");
+    assertEquals(HttpUrl.parse("http://host2/"), base.resolve("//host2"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("/path"));
+    assertEquals(HttpUrl.parse("http://host/a/path"), base.resolve("path"));
+    assertEquals(HttpUrl.parse("http://host/a/b?query"), base.resolve("?query"));
+    assertEquals(HttpUrl.parse("http://host/a/b#fragment"), base.resolve("#fragment"));
+    assertEquals(HttpUrl.parse("http://host/a/b"), base.resolve(""));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("\\path"));
+  }
+
+  @Test public void resolveUnsupportedScheme() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://a/");
+    assertEquals(null, base.resolve("ftp://b"));
+    assertEquals(null, base.resolve("ht+tp://b"));
+    assertEquals(null, base.resolve("ht-tp://b"));
+    assertEquals(null, base.resolve("ht.tp://b"));
+  }
+
+  @Test public void resolveSchemeLikePath() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://a/");
+    assertEquals(HttpUrl.parse("http://a/http//b/"), base.resolve("http//b/"));
+    assertEquals(HttpUrl.parse("http://a/ht+tp//b/"), base.resolve("ht+tp//b/"));
+    assertEquals(HttpUrl.parse("http://a/ht-tp//b/"), base.resolve("ht-tp//b/"));
+    assertEquals(HttpUrl.parse("http://a/ht.tp//b/"), base.resolve("ht.tp//b/"));
+  }
+
+  @Test public void parseAuthoritySlashCountDoesntMatter() throws Exception {
+    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:/host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:\\host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http://host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:\\/host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:/\\host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:\\\\host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:///host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:\\//host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:/\\/host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http://\\host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:\\\\/host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:/\\\\host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:\\\\\\host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:////host/path"));
+  }
+
+  @Test public void resolveAuthoritySlashCountDoesntMatterWithDifferentScheme() throws Exception {
+    HttpUrl base = HttpUrl.parse("https://a/b/c");
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:/host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http://host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\/host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:/\\host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\\\host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:///host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\//host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:/\\/host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http://\\host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\\\/host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:/\\\\host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\\\\\host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:////host/path"));
+  }
+
+  @Test public void resolveAuthoritySlashCountMattersWithSameScheme() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://a/b/c");
+    assertEquals(HttpUrl.parse("http://a/b/host/path"), base.resolve("http:host/path"));
+    assertEquals(HttpUrl.parse("http://a/host/path"), base.resolve("http:/host/path"));
+    assertEquals(HttpUrl.parse("http://a/host/path"), base.resolve("http:\\host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http://host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\/host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:/\\host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\\\host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:///host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\//host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:/\\/host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http://\\host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\\\/host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:/\\\\host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\\\\\host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:////host/path"));
+  }
+
+  @Test public void username() throws Exception {
+    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http://@host/path"));
+    assertEquals(HttpUrl.parse("http://user@host/path"), HttpUrl.parse("http://user@host/path"));
+  }
+
+  /** Given multiple '@' characters, the last one is the delimiter. */
+  @Test public void authorityWithMultipleAtSigns() throws Exception {
+    HttpUrl httpUrl = HttpUrl.parse("http://foo@bar@baz/path");
+    assertEquals("foo@bar", httpUrl.username());
+    assertEquals("", httpUrl.password());
+    assertEquals(HttpUrl.parse("http://foo%40bar@baz/path"), httpUrl);
+  }
+
+  /** Given multiple ':' characters, the first one is the delimiter. */
+  @Test public void authorityWithMultipleColons() throws Exception {
+    HttpUrl httpUrl = HttpUrl.parse("http://foo:pass1@bar:pass2@baz/path");
+    assertEquals("foo", httpUrl.username());
+    assertEquals("pass1@bar:pass2", httpUrl.password());
+    assertEquals(HttpUrl.parse("http://foo:pass1%40bar%3Apass2@baz/path"), httpUrl);
+  }
+
+  @Test public void usernameAndPassword() throws Exception {
+    assertEquals(HttpUrl.parse("http://username:password@host/path"),
+        HttpUrl.parse("http://username:password@host/path"));
+    assertEquals(HttpUrl.parse("http://username@host/path"),
+        HttpUrl.parse("http://username:@host/path"));
+  }
+
+  @Test public void passwordWithEmptyUsername() throws Exception {
+    // Chrome doesn't mind, but Firefox rejects URLs with empty usernames and non-empty passwords.
+    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http://:@host/path"));
+    assertEquals("password%40", HttpUrl.parse("http://:password@@host/path").encodedPassword());
+  }
+
+  @Test public void unprintableCharactersArePercentEncoded() throws Exception {
+    assertEquals("/%00", HttpUrl.parse("http://host/\u0000").encodedPath());
+    assertEquals("/%08", HttpUrl.parse("http://host/\u0008").encodedPath());
+    assertEquals("/%EF%BF%BD", HttpUrl.parse("http://host/\ufffd").encodedPath());
+  }
+
+  @Test public void usernameCharacters() throws Exception {
+    new UrlComponentEncodingTester()
+        .override(Encoding.PERCENT, '[', ']', '{', '}', '|', '^', '\'', ';', '=', '@')
+        .override(Encoding.SKIP, ':', '/', '\\', '?', '#')
+        .skipForUri('%')
+        .test(Component.USER);
+  }
+
+  @Test public void passwordCharacters() throws Exception {
+    new UrlComponentEncodingTester()
+        .override(Encoding.PERCENT, '[', ']', '{', '}', '|', '^', '\'', ':', ';', '=', '@')
+        .override(Encoding.SKIP, '/', '\\', '?', '#')
+        .skipForUri('%')
+        .test(Component.PASSWORD);
+  }
+
+  @Test public void hostContainsIllegalCharacter() throws Exception {
+    assertEquals(null, HttpUrl.parse("http://\n/"));
+    assertEquals(null, HttpUrl.parse("http:// /"));
+    assertEquals(null, HttpUrl.parse("http://%20/"));
+  }
+
+  @Test public void hostnameLowercaseCharactersMappedDirectly() throws Exception {
+    assertEquals("abcd", HttpUrl.parse("http://abcd").host());
+    assertEquals("xn--4xa", HttpUrl.parse("http://σ").host());
+  }
+
+  @Test public void hostnameUppercaseCharactersConvertedToLowercase() throws Exception {
+    assertEquals("abcd", HttpUrl.parse("http://ABCD").host());
+    assertEquals("xn--4xa", HttpUrl.parse("http://Σ").host());
+  }
+
+  @Test public void hostnameIgnoredCharacters() throws Exception {
+    // The soft hyphen (­) should be ignored.
+    assertEquals("abcd", HttpUrl.parse("http://AB\u00adCD").host());
+  }
+
+  @Test public void hostnameMultipleCharacterMapping() throws Exception {
+    // Map the single character telephone symbol (℡) to the string "tel".
+    assertEquals("tel", HttpUrl.parse("http://\u2121").host());
+  }
+
+  @Test public void hostnameMappingLastMappedCodePoint() throws Exception {
+    assertEquals("xn--pu5l", HttpUrl.parse("http://\uD87E\uDE1D").host());
+  }
+
+  @Ignore("The java.net.IDN implementation doesn't ignore characters that it should.")
+  @Test public void hostnameMappingLastIgnoredCodePoint() throws Exception {
+    assertEquals("abcd", HttpUrl.parse("http://ab\uDB40\uDDEFcd").host());
+  }
+
+  @Test public void hostnameMappingLastDisallowedCodePoint() throws Exception {
+    assertEquals(null, HttpUrl.parse("http://\uDBFF\uDFFF"));
+  }
+
+  @Test public void hostIpv6() throws Exception {
+    // Square braces are absent from host()...
+    assertEquals("::1", HttpUrl.parse("http://[::1]/").host());
+
+    // ... but they're included in toString().
+    assertEquals("http://[::1]/", HttpUrl.parse("http://[::1]/").toString());
+
+    // IPv6 colons don't interfere with port numbers or passwords.
+    assertEquals(8080, HttpUrl.parse("http://[::1]:8080/").port());
+    assertEquals("password", HttpUrl.parse("http://user:password@[::1]/").password());
+    assertEquals("::1", HttpUrl.parse("http://user:password@[::1]:8080/").host());
+
+    // Permit the contents of IPv6 addresses to be percent-encoded...
+    assertEquals("::1", HttpUrl.parse("http://[%3A%3A%31]/").host());
+
+    // Including the Square braces themselves! (This is what Chrome does.)
+    assertEquals("::1", HttpUrl.parse("http://%5B%3A%3A1%5D/").host());
+  }
+
+  @Test public void hostIpv6AddressDifferentFormats() throws Exception {
+    // Multiple representations of the same address; see http://tools.ietf.org/html/rfc5952.
+    String a3 = "2001:db8::1:0:0:1";
+    assertEquals(a3, HttpUrl.parse("http://[2001:db8:0:0:1:0:0:1]").host());
+    assertEquals(a3, HttpUrl.parse("http://[2001:0db8:0:0:1:0:0:1]").host());
+    assertEquals(a3, HttpUrl.parse("http://[2001:db8::1:0:0:1]").host());
+    assertEquals(a3, HttpUrl.parse("http://[2001:db8::0:1:0:0:1]").host());
+    assertEquals(a3, HttpUrl.parse("http://[2001:0db8::1:0:0:1]").host());
+    assertEquals(a3, HttpUrl.parse("http://[2001:db8:0:0:1::1]").host());
+    assertEquals(a3, HttpUrl.parse("http://[2001:db8:0000:0:1::1]").host());
+    assertEquals(a3, HttpUrl.parse("http://[2001:DB8:0:0:1::1]").host());
+  }
+
+  @Test public void hostIpv6AddressLeadingCompression() throws Exception {
+    assertEquals("::1", HttpUrl.parse("http://[::0001]").host());
+    assertEquals("::1", HttpUrl.parse("http://[0000::0001]").host());
+    assertEquals("::1", HttpUrl.parse("http://[0000:0000:0000:0000:0000:0000:0000:0001]").host());
+    assertEquals("::1", HttpUrl.parse("http://[0000:0000:0000:0000:0000:0000::0001]").host());
+  }
+
+  @Test public void hostIpv6AddressTrailingCompression() throws Exception {
+    assertEquals("1::", HttpUrl.parse("http://[0001:0000::]").host());
+    assertEquals("1::", HttpUrl.parse("http://[0001::0000]").host());
+    assertEquals("1::", HttpUrl.parse("http://[0001::]").host());
+    assertEquals("1::", HttpUrl.parse("http://[1::]").host());
+  }
+
+  @Test public void hostIpv6AddressTooManyDigitsInGroup() throws Exception {
+    assertEquals(null, HttpUrl.parse("http://[00000:0000:0000:0000:0000:0000:0000:0001]"));
+    assertEquals(null, HttpUrl.parse("http://[::00001]"));
+  }
+
+  @Test public void hostIpv6AddressMisplacedColons() throws Exception {
+    assertEquals(null, HttpUrl.parse("http://[:0000:0000:0000:0000:0000:0000:0000:0001]"));
+    assertEquals(null, HttpUrl.parse("http://[:::0000:0000:0000:0000:0000:0000:0000:0001]"));
+    assertEquals(null, HttpUrl.parse("http://[:1]"));
+    assertEquals(null, HttpUrl.parse("http://[:::1]"));
+    assertEquals(null, HttpUrl.parse("http://[0000:0000:0000:0000:0000:0000:0001:]"));
+    assertEquals(null, HttpUrl.parse("http://[0000:0000:0000:0000:0000:0000:0000:0001:]"));
+    assertEquals(null, HttpUrl.parse("http://[0000:0000:0000:0000:0000:0000:0000:0001::]"));
+    assertEquals(null, HttpUrl.parse("http://[0000:0000:0000:0000:0000:0000:0000:0001:::]"));
+    assertEquals(null, HttpUrl.parse("http://[1:]"));
+    assertEquals(null, HttpUrl.parse("http://[1:::]"));
+    assertEquals(null, HttpUrl.parse("http://[1:::1]"));
+    assertEquals(null, HttpUrl.parse("http://[00000:0000:0000:0000::0000:0000:0000:0001]"));
+  }
+
+  @Test public void hostIpv6AddressTooManyGroups() throws Exception {
+    assertEquals(null, HttpUrl.parse("http://[00000:0000:0000:0000:0000:0000:0000:0000:0001]"));
+  }
+
+  @Test public void hostIpv6AddressTooMuchCompression() throws Exception {
+    assertEquals(null, HttpUrl.parse("http://[0000::0000:0000:0000:0000::0001]"));
+    assertEquals(null, HttpUrl.parse("http://[::0000:0000:0000:0000::0001]"));
+  }
+
+  @Test public void hostIpv6ScopedAddress() throws Exception {
+    // java.net.InetAddress parses scoped addresses. These aren't valid in URLs.
+    assertEquals(null, HttpUrl.parse("http://[::1%2544]"));
+  }
+
+  @Test public void hostIpv6WithIpv4Suffix() throws Exception {
+    assertEquals("::1:ffff:ffff", HttpUrl.parse("http://[::1:255.255.255.255]/").host());
+    assertEquals("::1:0:0", HttpUrl.parse("http://[0:0:0:0:0:1:0.0.0.0]/").host());
+  }
+
+  @Test public void hostIpv6WithIpv4SuffixWithOctalPrefix() throws Exception {
+    // Chrome interprets a leading '0' as octal; Firefox rejects them. (We reject them.)
+    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:0.0.0.000000]/"));
+    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:0.010.0.010]/"));
+    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:0.0.0.000001]/"));
+  }
+
+  @Test public void hostIpv6WithIpv4SuffixWithHexadecimalPrefix() throws Exception {
+    // Chrome interprets a leading '0x' as hexadecimal; Firefox rejects them. (We reject them.)
+    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:0.0x10.0.0x10]/"));
+  }
+
+  @Test public void hostIpv6WithMalformedIpv4Suffix() throws Exception {
+    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:0.0:0.0]/"));
+    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:0.0-0.0]/"));
+    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:.255.255.255]/"));
+    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:255..255.255]/"));
+    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:255.255..255]/"));
+    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:0:1:255.255]/"));
+    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:256.255.255.255]/"));
+    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:ff.255.255.255]/"));
+    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:0:1:255.255.255.255]/"));
+    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:1:255.255.255.255]/"));
+    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:1:0.0.0.0:1]/"));
+    assertEquals(null, HttpUrl.parse("http://[0:0.0.0.0:1:0:0:0:0:1]/"));
+    assertEquals(null, HttpUrl.parse("http://[0.0.0.0:0:0:0:0:0:1]/"));
+  }
+
+  @Test public void hostIpv6WithIncompleteIpv4Suffix() throws Exception {
+    // To Chrome & Safari these are well-formed; Firefox disagrees. (We're consistent with Firefox).
+    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:255.255.255.]/"));
+    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:255.255.255]/"));
+  }
+
+  @Test public void hostIpv6CanonicalForm() throws Exception {
+    assertEquals("abcd:ef01:2345:6789:abcd:ef01:2345:6789",
+        HttpUrl.parse("http://[abcd:ef01:2345:6789:abcd:ef01:2345:6789]/").host());
+    assertEquals("a::b:0:0:0", HttpUrl.parse("http://[a:0:0:0:b:0:0:0]/").host());
+    assertEquals("a:b:0:0:c::", HttpUrl.parse("http://[a:b:0:0:c:0:0:0]/").host());
+    assertEquals("a:b::c:0:0", HttpUrl.parse("http://[a:b:0:0:0:c:0:0]/").host());
+    assertEquals("a::b:0:0:0", HttpUrl.parse("http://[a:0:0:0:b:0:0:0]/").host());
+    assertEquals("::a:b:0:0:0", HttpUrl.parse("http://[0:0:0:a:b:0:0:0]/").host());
+    assertEquals("::a:0:0:0:b", HttpUrl.parse("http://[0:0:0:a:0:0:0:b]/").host());
+    assertEquals("::a:b:c:d:e:f:1", HttpUrl.parse("http://[0:a:b:c:d:e:f:1]/").host());
+    assertEquals("a:b:c:d:e:f:1::", HttpUrl.parse("http://[a:b:c:d:e:f:1:0]/").host());
+    assertEquals("ff01::101", HttpUrl.parse("http://[FF01:0:0:0:0:0:0:101]/").host());
+    assertEquals("1::", HttpUrl.parse("http://[1:0:0:0:0:0:0:0]/").host());
+    assertEquals("::1", HttpUrl.parse("http://[0:0:0:0:0:0:0:1]/").host());
+    assertEquals("::", HttpUrl.parse("http://[0:0:0:0:0:0:0:0]/").host());
+  }
+
+  /** The builder permits square braces but does not require them. */
+  @Test public void hostIPv6Builder() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://example.com/");
+    assertEquals("http://[::1]/", base.newBuilder().host("[::1]").build().toString());
+    assertEquals("http://[::1]/", base.newBuilder().host("[::0001]").build().toString());
+    assertEquals("http://[::1]/", base.newBuilder().host("::1").build().toString());
+    assertEquals("http://[::1]/", base.newBuilder().host("::0001").build().toString());
+  }
+
+  @Test public void hostIpv4CanonicalForm() throws Exception {
+    assertEquals("255.255.255.255", HttpUrl.parse("http://255.255.255.255/").host());
+    assertEquals("1.2.3.4", HttpUrl.parse("http://1.2.3.4/").host());
+    assertEquals("0.0.0.0", HttpUrl.parse("http://0.0.0.0/").host());
+  }
+
+  @Ignore("java.net.IDN strips trailing trailing dots on Java 7, but not on Java 8.")
+  @Test public void hostWithTrailingDot() throws Exception {
+    assertEquals("host.", HttpUrl.parse("http://host./").host());
+  }
+
+  @Test public void port() throws Exception {
+    assertEquals(HttpUrl.parse("http://host/"), HttpUrl.parse("http://host:80/"));
+    assertEquals(HttpUrl.parse("http://host:99/"), HttpUrl.parse("http://host:99/"));
+    assertEquals(HttpUrl.parse("http://host/"), HttpUrl.parse("http://host:/"));
+    assertEquals(65535, HttpUrl.parse("http://host:65535/").port());
+    assertEquals(null, HttpUrl.parse("http://host:0/"));
+    assertEquals(null, HttpUrl.parse("http://host:65536/"));
+    assertEquals(null, HttpUrl.parse("http://host:-1/"));
+    assertEquals(null, HttpUrl.parse("http://host:a/"));
+    assertEquals(null, HttpUrl.parse("http://host:%39%39/"));
+  }
+
+  @Test public void pathCharacters() throws Exception {
+    new UrlComponentEncodingTester()
+        .override(Encoding.PERCENT, '^', '{', '}', '|')
+        .override(Encoding.SKIP, '\\', '?', '#')
+        .skipForUri('%', '[', ']')
+        .test(Component.PATH);
+  }
+
+  @Test public void queryCharacters() throws Exception {
+    new UrlComponentEncodingTester()
+        .override(Encoding.IDENTITY, '?', '`')
+        .override(Encoding.PERCENT, '\'')
+        .override(Encoding.SKIP, '#', '+')
+        .skipForUri('%', '\\', '^', '`', '{', '|', '}')
+        .test(Component.QUERY);
+  }
+
+  @Test public void fragmentCharacters() throws Exception {
+    new UrlComponentEncodingTester()
+        .override(Encoding.IDENTITY, ' ', '"', '#', '<', '>', '?', '`')
+        .skipForUri('%', ' ', '"', '#', '<', '>', '\\', '^', '`', '{', '|', '}')
+        .identityForNonAscii()
+        .test(Component.FRAGMENT);
+  }
+
+  @Test public void fragmentNonAscii() throws Exception {
+    HttpUrl url = HttpUrl.parse("http://host/#Σ");
+    assertEquals("http://host/#Σ", url.toString());
+    assertEquals("Σ", url.fragment());
+    assertEquals("Σ", url.encodedFragment());
+    assertEquals("http://host/#Σ", url.uri().toString());
+  }
+
+  @Test public void fragmentNonAsciiThatOffendsJavaNetUri() throws Exception {
+    HttpUrl url = HttpUrl.parse("http://host/#\u0080");
+    assertEquals("http://host/#\u0080", url.toString());
+    assertEquals("\u0080", url.fragment());
+    assertEquals("\u0080", url.encodedFragment());
+    assertEquals(new URI("http://host/#"), url.uri()); // Control characters may be stripped!
+  }
+
+  @Test public void fragmentPercentEncodedNonAscii() throws Exception {
+    HttpUrl url = HttpUrl.parse("http://host/#%C2%80");
+    assertEquals("http://host/#%C2%80", url.toString());
+    assertEquals("\u0080", url.fragment());
+    assertEquals("%C2%80", url.encodedFragment());
+    assertEquals("http://host/#%C2%80", url.uri().toString());
+  }
+
+  @Test public void fragmentPercentEncodedPartialCodePoint() throws Exception {
+    HttpUrl url = HttpUrl.parse("http://host/#%80");
+    assertEquals("http://host/#%80", url.toString());
+    assertEquals("\ufffd", url.fragment()); // Unicode replacement character.
+    assertEquals("%80", url.encodedFragment());
+    assertEquals("http://host/#%80", url.uri().toString());
+  }
+
+  @Test public void relativePath() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    assertEquals(HttpUrl.parse("http://host/a/b/d/e/f"), base.resolve("d/e/f"));
+    assertEquals(HttpUrl.parse("http://host/d/e/f"), base.resolve("../../d/e/f"));
+    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve(".."));
+    assertEquals(HttpUrl.parse("http://host/"), base.resolve("../.."));
+    assertEquals(HttpUrl.parse("http://host/"), base.resolve("../../.."));
+    assertEquals(HttpUrl.parse("http://host/a/b/"), base.resolve("."));
+    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve("././.."));
+    assertEquals(HttpUrl.parse("http://host/a/b/c/"), base.resolve("c/d/../e/../"));
+    assertEquals(HttpUrl.parse("http://host/a/b/..e/"), base.resolve("..e/"));
+    assertEquals(HttpUrl.parse("http://host/a/b/e/f../"), base.resolve("e/f../"));
+    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve("%2E."));
+    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve(".%2E"));
+    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve("%2E%2E"));
+    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve("%2e."));
+    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve(".%2e"));
+    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve("%2e%2e"));
+    assertEquals(HttpUrl.parse("http://host/a/b/"), base.resolve("%2E"));
+    assertEquals(HttpUrl.parse("http://host/a/b/"), base.resolve("%2e"));
+  }
+
+  @Test public void relativePathWithTrailingSlash() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c/");
+    assertEquals(HttpUrl.parse("http://host/a/b/"), base.resolve(".."));
+    assertEquals(HttpUrl.parse("http://host/a/b/"), base.resolve("../"));
+    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve("../.."));
+    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve("../../"));
+    assertEquals(HttpUrl.parse("http://host/"), base.resolve("../../.."));
+    assertEquals(HttpUrl.parse("http://host/"), base.resolve("../../../"));
+    assertEquals(HttpUrl.parse("http://host/"), base.resolve("../../../.."));
+    assertEquals(HttpUrl.parse("http://host/"), base.resolve("../../../../"));
+    assertEquals(HttpUrl.parse("http://host/a"), base.resolve("../../../../a"));
+    assertEquals(HttpUrl.parse("http://host/"), base.resolve("../../../../a/.."));
+    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve("../../../../a/b/.."));
+  }
+
+  @Test public void pathWithBackslash() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    assertEquals(HttpUrl.parse("http://host/a/b/d/e/f"), base.resolve("d\\e\\f"));
+    assertEquals(HttpUrl.parse("http://host/d/e/f"), base.resolve("../..\\d\\e\\f"));
+    assertEquals(HttpUrl.parse("http://host/"), base.resolve("..\\.."));
+  }
+
+  @Test public void relativePathWithSameScheme() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    assertEquals(HttpUrl.parse("http://host/a/b/d/e/f"), base.resolve("http:d/e/f"));
+    assertEquals(HttpUrl.parse("http://host/d/e/f"), base.resolve("http:../../d/e/f"));
+  }
+
+  @Test public void decodeUsername() {
+    assertEquals("user", HttpUrl.parse("http://user@host/").username());
+    assertEquals("\uD83C\uDF69", HttpUrl.parse("http://%F0%9F%8D%A9@host/").username());
+  }
+
+  @Test public void decodePassword() {
+    assertEquals("password", HttpUrl.parse("http://user:password@host/").password());
+    assertEquals("", HttpUrl.parse("http://user:@host/").password());
+    assertEquals("\uD83C\uDF69", HttpUrl.parse("http://user:%F0%9F%8D%A9@host/").password());
+  }
+
+  @Test public void decodeSlashCharacterInDecodedPathSegment() {
+    assertEquals(Arrays.asList("a/b/c"),
+        HttpUrl.parse("http://host/a%2Fb%2Fc").pathSegments());
+  }
+
+  @Test public void decodeEmptyPathSegments() {
+    assertEquals(Arrays.asList(""),
+        HttpUrl.parse("http://host/").pathSegments());
+  }
+
+  @Test public void percentDecode() throws Exception {
+    assertEquals(Arrays.asList("\u0000"),
+        HttpUrl.parse("http://host/%00").pathSegments());
+    assertEquals(Arrays.asList("a", "\u2603", "c"),
+        HttpUrl.parse("http://host/a/%E2%98%83/c").pathSegments());
+    assertEquals(Arrays.asList("a", "\uD83C\uDF69", "c"),
+        HttpUrl.parse("http://host/a/%F0%9F%8D%A9/c").pathSegments());
+    assertEquals(Arrays.asList("a", "b", "c"),
+        HttpUrl.parse("http://host/a/%62/c").pathSegments());
+    assertEquals(Arrays.asList("a", "z", "c"),
+        HttpUrl.parse("http://host/a/%7A/c").pathSegments());
+    assertEquals(Arrays.asList("a", "z", "c"),
+        HttpUrl.parse("http://host/a/%7a/c").pathSegments());
+  }
+
+  @Test public void malformedPercentEncoding() {
+    assertEquals(Arrays.asList("a%f", "b"),
+        HttpUrl.parse("http://host/a%f/b").pathSegments());
+    assertEquals(Arrays.asList("%", "b"),
+        HttpUrl.parse("http://host/%/b").pathSegments());
+    assertEquals(Arrays.asList("%"),
+        HttpUrl.parse("http://host/%").pathSegments());
+    assertEquals(Arrays.asList("%00"),
+        HttpUrl.parse("http://github.com/%%30%30").pathSegments());
+  }
+
+  @Test public void malformedUtf8Encoding() {
+    // Replace a partial UTF-8 sequence with the Unicode replacement character.
+    assertEquals(Arrays.asList("a", "\ufffdx", "c"),
+        HttpUrl.parse("http://host/a/%E2%98x/c").pathSegments());
+  }
+
+  @Test public void incompleteUrlComposition() throws Exception {
+    try {
+      new HttpUrl.Builder().scheme("http").build();
+      fail();
+    } catch (IllegalStateException expected) {
+      assertEquals("host == null", expected.getMessage());
+    }
+    try {
+      new HttpUrl.Builder().host("host").build();
+      fail();
+    } catch (IllegalStateException expected) {
+      assertEquals("scheme == null", expected.getMessage());
+    }
+  }
+
+  @Test public void minimalUrlComposition() throws Exception {
+    HttpUrl url = new HttpUrl.Builder().scheme("http").host("host").build();
+    assertEquals("http://host/", url.toString());
+    assertEquals("http", url.scheme());
+    assertEquals("", url.username());
+    assertEquals("", url.password());
+    assertEquals("host", url.host());
+    assertEquals(80, url.port());
+    assertEquals("/", url.encodedPath());
+    assertEquals(null, url.query());
+    assertEquals(null, url.fragment());
+  }
+
+  @Test public void fullUrlComposition() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .username("username")
+        .password("password")
+        .host("host")
+        .port(8080)
+        .addPathSegment("path")
+        .query("query")
+        .fragment("fragment")
+        .build();
+    assertEquals("http://username:password@host:8080/path?query#fragment", url.toString());
+    assertEquals("http", url.scheme());
+    assertEquals("username", url.username());
+    assertEquals("password", url.password());
+    assertEquals("host", url.host());
+    assertEquals(8080, url.port());
+    assertEquals("/path", url.encodedPath());
+    assertEquals("query", url.query());
+    assertEquals("fragment", url.fragment());
+  }
+
+  @Test public void changingSchemeChangesDefaultPort() throws Exception {
+    assertEquals(443, HttpUrl.parse("http://example.com")
+        .newBuilder()
+        .scheme("https")
+        .build().port());
+
+    assertEquals(80, HttpUrl.parse("https://example.com")
+        .newBuilder()
+        .scheme("http")
+        .build().port());
+
+    assertEquals(1234, HttpUrl.parse("https://example.com:1234")
+        .newBuilder()
+        .scheme("http")
+        .build().port());
+  }
+
+  @Test public void composeEncodesWhitespace() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .username("a\r\n\f\t b")
+        .password("c\r\n\f\t d")
+        .host("host")
+        .addPathSegment("e\r\n\f\t f")
+        .query("g\r\n\f\t h")
+        .fragment("i\r\n\f\t j")
+        .build();
+    assertEquals("http://a%0D%0A%0C%09%20b:c%0D%0A%0C%09%20d@host"
+        + "/e%0D%0A%0C%09%20f?g%0D%0A%0C%09%20h#i%0D%0A%0C%09 j", url.toString());
+    assertEquals("a\r\n\f\t b", url.username());
+    assertEquals("c\r\n\f\t d", url.password());
+    assertEquals("e\r\n\f\t f", url.pathSegments().get(0));
+    assertEquals("g\r\n\f\t h", url.query());
+    assertEquals("i\r\n\f\t j", url.fragment());
+  }
+
+  @Test public void composeFromUnencodedComponents() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .username("a:\u0001@/\\?#%b")
+        .password("c:\u0001@/\\?#%d")
+        .host("ef")
+        .port(8080)
+        .addPathSegment("g:\u0001@/\\?#%h")
+        .query("i:\u0001@/\\?#%j")
+        .fragment("k:\u0001@/\\?#%l")
+        .build();
+    assertEquals("http://a%3A%01%40%2F%5C%3F%23%25b:c%3A%01%40%2F%5C%3F%23%25d@ef:8080/"
+        + "g:%01@%2F%5C%3F%23%25h?i:%01@/\\?%23%25j#k:%01@/\\?#%25l", url.toString());
+    assertEquals("http", url.scheme());
+    assertEquals("a:\u0001@/\\?#%b", url.username());
+    assertEquals("c:\u0001@/\\?#%d", url.password());
+    assertEquals(Arrays.asList("g:\u0001@/\\?#%h"), url.pathSegments());
+    assertEquals("i:\u0001@/\\?#%j", url.query());
+    assertEquals("k:\u0001@/\\?#%l", url.fragment());
+    assertEquals("a%3A%01%40%2F%5C%3F%23%25b", url.encodedUsername());
+    assertEquals("c%3A%01%40%2F%5C%3F%23%25d", url.encodedPassword());
+    assertEquals("/g:%01@%2F%5C%3F%23%25h", url.encodedPath());
+    assertEquals("i:%01@/\\?%23%25j", url.encodedQuery());
+    assertEquals("k:%01@/\\?#%25l", url.encodedFragment());
+  }
+
+  @Test public void composeFromEncodedComponents() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .encodedUsername("a:\u0001@/\\?#%25b")
+        .encodedPassword("c:\u0001@/\\?#%25d")
+        .host("ef")
+        .port(8080)
+        .addEncodedPathSegment("g:\u0001@/\\?#%25h")
+        .encodedQuery("i:\u0001@/\\?#%25j")
+        .encodedFragment("k:\u0001@/\\?#%25l")
+        .build();
+    assertEquals("http://a%3A%01%40%2F%5C%3F%23%25b:c%3A%01%40%2F%5C%3F%23%25d@ef:8080/"
+        + "g:%01@%2F%5C%3F%23%25h?i:%01@/\\?%23%25j#k:%01@/\\?#%25l", url.toString());
+    assertEquals("http", url.scheme());
+    assertEquals("a:\u0001@/\\?#%b", url.username());
+    assertEquals("c:\u0001@/\\?#%d", url.password());
+    assertEquals(Arrays.asList("g:\u0001@/\\?#%h"), url.pathSegments());
+    assertEquals("i:\u0001@/\\?#%j", url.query());
+    assertEquals("k:\u0001@/\\?#%l", url.fragment());
+    assertEquals("a%3A%01%40%2F%5C%3F%23%25b", url.encodedUsername());
+    assertEquals("c%3A%01%40%2F%5C%3F%23%25d", url.encodedPassword());
+    assertEquals("/g:%01@%2F%5C%3F%23%25h", url.encodedPath());
+    assertEquals("i:%01@/\\?%23%25j", url.encodedQuery());
+    assertEquals("k:%01@/\\?#%25l", url.encodedFragment());
+  }
+
+  @Test public void composeWithEncodedPath() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .host("host")
+        .encodedPath("/a%2Fb/c")
+        .build();
+    assertEquals("http://host/a%2Fb/c", url.toString());
+    assertEquals("/a%2Fb/c", url.encodedPath());
+    assertEquals(Arrays.asList("a/b", "c"), url.pathSegments());
+  }
+
+  @Test public void composeMixingPathSegments() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .host("host")
+        .encodedPath("/a%2fb/c")
+        .addPathSegment("d%25e")
+        .addEncodedPathSegment("f%25g")
+        .build();
+    assertEquals("http://host/a%2fb/c/d%2525e/f%25g", url.toString());
+    assertEquals("/a%2fb/c/d%2525e/f%25g", url.encodedPath());
+    assertEquals(Arrays.asList("a%2fb", "c", "d%2525e", "f%25g"), url.encodedPathSegments());
+    assertEquals(Arrays.asList("a/b", "c", "d%25e", "f%g"), url.pathSegments());
+  }
+
+  @Test public void composeWithAddSegment() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    assertEquals("/a/b/c/", base.newBuilder().addPathSegment("").build().encodedPath());
+    assertEquals("/a/b/c/d",
+        base.newBuilder().addPathSegment("").addPathSegment("d").build().encodedPath());
+    assertEquals("/a/b/", base.newBuilder().addPathSegment("..").build().encodedPath());
+    assertEquals("/a/b/", base.newBuilder().addPathSegment("").addPathSegment("..").build()
+        .encodedPath());
+    assertEquals("/a/b/c/", base.newBuilder().addPathSegment("").addPathSegment("").build()
+        .encodedPath());
+  }
+
+  @Test public void pathSize() throws Exception {
+    assertEquals(1, HttpUrl.parse("http://host/").pathSize());
+    assertEquals(3, HttpUrl.parse("http://host/a/b/c").pathSize());
+  }
+
+  @Test public void addPathSegments() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+
+    // Add a string with zero slashes: resulting URL gains one slash.
+    assertEquals("/a/b/c/", base.newBuilder().addPathSegments("").build().encodedPath());
+    assertEquals("/a/b/c/d", base.newBuilder().addPathSegments("d").build().encodedPath());
+
+    // Add a string with one slash: resulting URL gains two slashes.
+    assertEquals("/a/b/c//", base.newBuilder().addPathSegments("/").build().encodedPath());
+    assertEquals("/a/b/c/d/", base.newBuilder().addPathSegments("d/").build().encodedPath());
+    assertEquals("/a/b/c//d", base.newBuilder().addPathSegments("/d").build().encodedPath());
+
+    // Add a string with two slashes: resulting URL gains three slashes.
+    assertEquals("/a/b/c///", base.newBuilder().addPathSegments("//").build().encodedPath());
+    assertEquals("/a/b/c//d/", base.newBuilder().addPathSegments("/d/").build().encodedPath());
+    assertEquals("/a/b/c/d//", base.newBuilder().addPathSegments("d//").build().encodedPath());
+    assertEquals("/a/b/c///d", base.newBuilder().addPathSegments("//d").build().encodedPath());
+    assertEquals("/a/b/c/d/e/f", base.newBuilder().addPathSegments("d/e/f").build().encodedPath());
+  }
+
+  @Test public void addPathSegmentsOntoTrailingSlash() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c/");
+
+    // Add a string with zero slashes: resulting URL gains zero slashes.
+    assertEquals("/a/b/c/", base.newBuilder().addPathSegments("").build().encodedPath());
+    assertEquals("/a/b/c/d", base.newBuilder().addPathSegments("d").build().encodedPath());
+
+    // Add a string with one slash: resulting URL gains one slash.
+    assertEquals("/a/b/c//", base.newBuilder().addPathSegments("/").build().encodedPath());
+    assertEquals("/a/b/c/d/", base.newBuilder().addPathSegments("d/").build().encodedPath());
+    assertEquals("/a/b/c//d", base.newBuilder().addPathSegments("/d").build().encodedPath());
+
+    // Add a string with two slashes: resulting URL gains two slashes.
+    assertEquals("/a/b/c///", base.newBuilder().addPathSegments("//").build().encodedPath());
+    assertEquals("/a/b/c//d/", base.newBuilder().addPathSegments("/d/").build().encodedPath());
+    assertEquals("/a/b/c/d//", base.newBuilder().addPathSegments("d//").build().encodedPath());
+    assertEquals("/a/b/c///d", base.newBuilder().addPathSegments("//d").build().encodedPath());
+    assertEquals("/a/b/c/d/e/f", base.newBuilder().addPathSegments("d/e/f").build().encodedPath());
+  }
+
+  @Test public void addPathSegmentsWithBackslash() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/");
+    assertEquals("/d/e", base.newBuilder().addPathSegments("d\\e").build().encodedPath());
+    assertEquals("/d/e", base.newBuilder().addEncodedPathSegments("d\\e").build().encodedPath());
+  }
+
+  @Test public void addPathSegmentsWithEmptyPaths() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    assertEquals("/a/b/c//d/e///f",
+        base.newBuilder().addPathSegments("/d/e///f").build().encodedPath());
+  }
+
+  @Test public void addEncodedPathSegments() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    assertEquals("/a/b/c/d/e/%20/",
+        base.newBuilder().addEncodedPathSegments("d/e/%20/\n").build().encodedPath());
+  }
+
+  @Test public void addPathSegmentDotDoesNothing() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    assertEquals("/a/b/c", base.newBuilder().addPathSegment(".").build().encodedPath());
+  }
+
+  @Test public void addPathSegmentEncodes() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    assertEquals("/a/b/c/%252e",
+        base.newBuilder().addPathSegment("%2e").build().encodedPath());
+    assertEquals("/a/b/c/%252e%252e",
+        base.newBuilder().addPathSegment("%2e%2e").build().encodedPath());
+  }
+
+  @Test public void addPathSegmentDotDotPopsDirectory() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    assertEquals("/a/b/", base.newBuilder().addPathSegment("..").build().encodedPath());
+  }
+
+  @Test public void addPathSegmentDotAndIgnoredCharacter() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    assertEquals("/a/b/c/.%0A", base.newBuilder().addPathSegment(".\n").build().encodedPath());
+  }
+
+  @Test public void addEncodedPathSegmentDotAndIgnoredCharacter() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    assertEquals("/a/b/c", base.newBuilder().addEncodedPathSegment(".\n").build().encodedPath());
+  }
+
+  @Test public void addEncodedPathSegmentDotDotAndIgnoredCharacter() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    assertEquals("/a/b/", base.newBuilder().addEncodedPathSegment("..\n").build().encodedPath());
+  }
+
+  @Test public void setPathSegment() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    assertEquals("/d/b/c", base.newBuilder().setPathSegment(0, "d").build().encodedPath());
+    assertEquals("/a/d/c", base.newBuilder().setPathSegment(1, "d").build().encodedPath());
+    assertEquals("/a/b/d", base.newBuilder().setPathSegment(2, "d").build().encodedPath());
+  }
+
+  @Test public void setPathSegmentEncodes() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    assertEquals("/%2525/b/c", base.newBuilder().setPathSegment(0, "%25").build().encodedPath());
+    assertEquals("/.%0A/b/c", base.newBuilder().setPathSegment(0, ".\n").build().encodedPath());
+    assertEquals("/%252e/b/c", base.newBuilder().setPathSegment(0, "%2e").build().encodedPath());
+  }
+
+  @Test public void setPathSegmentAcceptsEmpty() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    assertEquals("//b/c", base.newBuilder().setPathSegment(0, "").build().encodedPath());
+    assertEquals("/a/b/", base.newBuilder().setPathSegment(2, "").build().encodedPath());
+  }
+
+  @Test public void setPathSegmentRejectsDot() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    try {
+      base.newBuilder().setPathSegment(0, ".");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void setPathSegmentRejectsDotDot() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    try {
+      base.newBuilder().setPathSegment(0, "..");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void setPathSegmentWithSlash() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl url = base.newBuilder().setPathSegment(1, "/").build();
+    assertEquals("/a/%2F/c", url.encodedPath());
+  }
+
+  @Test public void setPathSegmentOutOfBounds() throws Exception {
+    try {
+      new HttpUrl.Builder().setPathSegment(1, "a");
+      fail();
+    } catch (IndexOutOfBoundsException expected) {
+    }
+  }
+
+  @Test public void setEncodedPathSegmentEncodes() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    assertEquals("/%25/b/c",
+        base.newBuilder().setEncodedPathSegment(0, "%25").build().encodedPath());
+  }
+
+  @Test public void setEncodedPathSegmentRejectsDot() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    try {
+      base.newBuilder().setEncodedPathSegment(0, ".");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void setEncodedPathSegmentRejectsDotAndIgnoredCharacter() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    try {
+      base.newBuilder().setEncodedPathSegment(0, ".\n");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void setEncodedPathSegmentRejectsDotDot() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    try {
+      base.newBuilder().setEncodedPathSegment(0, "..");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void setEncodedPathSegmentRejectsDotDotAndIgnoredCharacter() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    try {
+      base.newBuilder().setEncodedPathSegment(0, "..\n");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void setEncodedPathSegmentWithSlash() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl url = base.newBuilder().setEncodedPathSegment(1, "/").build();
+    assertEquals("/a/%2F/c", url.encodedPath());
+  }
+
+  @Test public void setEncodedPathSegmentOutOfBounds() throws Exception {
+    try {
+      new HttpUrl.Builder().setEncodedPathSegment(1, "a");
+      fail();
+    } catch (IndexOutOfBoundsException expected) {
+    }
+  }
+
+  @Test public void removePathSegment() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl url = base.newBuilder()
+        .removePathSegment(0)
+        .build();
+    assertEquals("/b/c", url.encodedPath());
+  }
+
+  @Test public void removePathSegmentDoesntRemovePath() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl url = base.newBuilder()
+        .removePathSegment(0)
+        .removePathSegment(0)
+        .removePathSegment(0)
+        .build();
+    assertEquals(Arrays.asList(""), url.pathSegments());
+    assertEquals("/", url.encodedPath());
+  }
+
+  @Test public void removePathSegmentOutOfBounds() throws Exception {
+    try {
+      new HttpUrl.Builder().removePathSegment(1);
+      fail();
+    } catch (IndexOutOfBoundsException expected) {
+    }
+  }
+
+  @Test public void toJavaNetUrl() throws Exception {
+    HttpUrl httpUrl = HttpUrl.parse("http://username:password@host/path?query#fragment");
+    URL javaNetUrl = httpUrl.url();
+    assertEquals("http://username:password@host/path?query#fragment", javaNetUrl.toString());
+  }
+
+  @Test public void toUri() throws Exception {
+    HttpUrl httpUrl = HttpUrl.parse("http://username:password@host/path?query#fragment");
+    URI uri = httpUrl.uri();
+    assertEquals("http://username:password@host/path?query#fragment", uri.toString());
+  }
+
+  @Test public void toUriSpecialQueryCharacters() throws Exception {
+    HttpUrl httpUrl = HttpUrl.parse("http://host/?d=abc!@[]^`{}|\\");
+    URI uri = httpUrl.uri();
+    assertEquals("http://host/?d=abc!@[]%5E%60%7B%7D%7C%5C", uri.toString());
+  }
+
+  @Test public void toUriWithUsernameNoPassword() throws Exception {
+    HttpUrl httpUrl = new HttpUrl.Builder()
+        .scheme("http")
+        .username("user")
+        .host("host")
+        .build();
+    assertEquals("http://user@host/", httpUrl.toString());
+    assertEquals("http://user@host/", httpUrl.uri().toString());
+  }
+
+  @Test public void toUriUsernameSpecialCharacters() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .host("host")
+        .username("=[]:;\"~|?#@^/$%*")
+        .build();
+    assertEquals("http://%3D%5B%5D%3A%3B%22~%7C%3F%23%40%5E%2F$%25*@host/", url.toString());
+    assertEquals("http://%3D%5B%5D%3A%3B%22~%7C%3F%23%40%5E%2F$%25*@host/", url.uri().toString());
+  }
+
+  @Test public void toUriPasswordSpecialCharacters() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .host("host")
+        .username("user")
+        .password("=[]:;\"~|?#@^/$%*")
+        .build();
+    assertEquals("http://user:%3D%5B%5D%3A%3B%22~%7C%3F%23%40%5E%2F$%25*@host/", url.toString());
+    assertEquals("http://user:%3D%5B%5D%3A%3B%22~%7C%3F%23%40%5E%2F$%25*@host/",
+        url.uri().toString());
+  }
+
+  @Test public void toUriPathSpecialCharacters() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .host("host")
+        .addPathSegment("=[]:;\"~|?#@^/$%*")
+        .build();
+    assertEquals("http://host/=[]:;%22~%7C%3F%23@%5E%2F$%25*", url.toString());
+    assertEquals("http://host/=%5B%5D:;%22~%7C%3F%23@%5E%2F$%25*", url.uri().toString());
+  }
+
+  @Test public void toUriQueryParameterNameSpecialCharacters() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .host("host")
+        .addQueryParameter("=[]:;\"~|?#@^/$%*", "a")
+        .build();
+    assertEquals("http://host/?%3D[]:;%22~|?%23@^/$%25*=a", url.toString());
+    assertEquals("http://host/?%3D[]:;%22~%7C?%23@%5E/$%25*=a", url.uri().toString());
+  }
+
+  @Test public void toUriQueryParameterValueSpecialCharacters() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .host("host")
+        .addQueryParameter("a", "=[]:;\"~|?#@^/$%*")
+        .build();
+    assertEquals("http://host/?a=%3D[]:;%22~|?%23@^/$%25*", url.toString());
+    assertEquals("http://host/?a=%3D[]:;%22~%7C?%23@%5E/$%25*", url.uri().toString());
+  }
+
+  @Test public void toUriQueryValueSpecialCharacters() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .host("host")
+        .query("=[]:;\"~|?#@^/$%*")
+        .build();
+    assertEquals("http://host/?=[]:;%22~|?%23@^/$%25*", url.toString());
+    assertEquals("http://host/?=[]:;%22~%7C?%23@%5E/$%25*", url.uri().toString());
+  }
+
+  @Test public void toUriFragmentSpecialCharacters() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .host("host")
+        .fragment("=[]:;\"~|?#@^/$%*")
+        .build();
+    assertEquals("http://host/#=[]:;\"~|?#@^/$%25*", url.toString());
+    assertEquals("http://host/#=[]:;%22~%7C?%23@%5E/$%25*", url.uri().toString());
+  }
+
+  @Test public void toUriWithControlCharacters() throws Exception {
+    // Percent-encoded in the path.
+    assertEquals(new URI("http://host/a%00b"), HttpUrl.parse("http://host/a\u0000b").uri());
+    assertEquals(new URI("http://host/a%C2%80b"), HttpUrl.parse("http://host/a\u0080b").uri());
+    assertEquals(new URI("http://host/a%C2%9Fb"), HttpUrl.parse("http://host/a\u009fb").uri());
+    // Percent-encoded in the query.
+    assertEquals(new URI("http://host/?a%00b"), HttpUrl.parse("http://host/?a\u0000b").uri());
+    assertEquals(new URI("http://host/?a%C2%80b"), HttpUrl.parse("http://host/?a\u0080b").uri());
+    assertEquals(new URI("http://host/?a%C2%9Fb"), HttpUrl.parse("http://host/?a\u009fb").uri());
+    // Stripped from the fragment.
+    assertEquals(new URI("http://host/#a%00b"), HttpUrl.parse("http://host/#a\u0000b").uri());
+    assertEquals(new URI("http://host/#ab"), HttpUrl.parse("http://host/#a\u0080b").uri());
+    assertEquals(new URI("http://host/#ab"), HttpUrl.parse("http://host/#a\u009fb").uri());
+  }
+
+  @Test public void toUriWithSpaceCharacters() throws Exception {
+    // Percent-encoded in the path.
+    assertEquals(new URI("http://host/a%0Bb"), HttpUrl.parse("http://host/a\u000bb").uri());
+    assertEquals(new URI("http://host/a%20b"), HttpUrl.parse("http://host/a b").uri());
+    assertEquals(new URI("http://host/a%E2%80%89b"), HttpUrl.parse("http://host/a\u2009b").uri());
+    assertEquals(new URI("http://host/a%E3%80%80b"), HttpUrl.parse("http://host/a\u3000b").uri());
+    // Percent-encoded in the query.
+    assertEquals(new URI("http://host/?a%0Bb"), HttpUrl.parse("http://host/?a\u000bb").uri());
+    assertEquals(new URI("http://host/?a%20b"), HttpUrl.parse("http://host/?a b").uri());
+    assertEquals(new URI("http://host/?a%E2%80%89b"), HttpUrl.parse("http://host/?a\u2009b").uri());
+    assertEquals(new URI("http://host/?a%E3%80%80b"), HttpUrl.parse("http://host/?a\u3000b").uri());
+    // Stripped from the fragment.
+    assertEquals(new URI("http://host/#a%0Bb"), HttpUrl.parse("http://host/#a\u000bb").uri());
+    assertEquals(new URI("http://host/#a%20b"), HttpUrl.parse("http://host/#a b").uri());
+    assertEquals(new URI("http://host/#ab"), HttpUrl.parse("http://host/#a\u2009b").uri());
+    assertEquals(new URI("http://host/#ab"), HttpUrl.parse("http://host/#a\u3000b").uri());
+  }
+
+  @Test public void toUriWithNonHexPercentEscape() throws Exception {
+    assertEquals(new URI("http://host/%25xx"), HttpUrl.parse("http://host/%xx").uri());
+  }
+
+  @Test public void toUriWithTruncatedPercentEscape() throws Exception {
+    assertEquals(new URI("http://host/%25a"), HttpUrl.parse("http://host/%a").uri());
+    assertEquals(new URI("http://host/%25"), HttpUrl.parse("http://host/%").uri());
+  }
+
+  @Test public void fromJavaNetUrl() throws Exception {
+    URL javaNetUrl = new URL("http://username:password@host/path?query#fragment");
+    HttpUrl httpUrl = HttpUrl.get(javaNetUrl);
+    assertEquals("http://username:password@host/path?query#fragment", httpUrl.toString());
+  }
+
+  @Test public void fromJavaNetUrlUnsupportedScheme() throws Exception {
+    URL javaNetUrl = new URL("mailto:user@example.com");
+    assertEquals(null, HttpUrl.get(javaNetUrl));
+  }
+
+  @Test public void fromUri() throws Exception {
+    URI uri = new URI("http://username:password@host/path?query#fragment");
+    HttpUrl httpUrl = HttpUrl.get(uri);
+    assertEquals("http://username:password@host/path?query#fragment", httpUrl.toString());
+  }
+
+  @Test public void fromUriUnsupportedScheme() throws Exception {
+    URI uri = new URI("mailto:user@example.com");
+    assertEquals(null, HttpUrl.get(uri));
+  }
+
+  @Test public void fromUriPartial() throws Exception {
+    URI uri = new URI("/path");
+    assertEquals(null, HttpUrl.get(uri));
+  }
+
+  @Test public void fromJavaNetUrl_checked() throws Exception {
+    HttpUrl httpUrl = HttpUrl.getChecked("http://username:password@host/path?query#fragment");
+    assertEquals("http://username:password@host/path?query#fragment", httpUrl.toString());
+  }
+
+  @Test public void fromJavaNetUrlUnsupportedScheme_checked() throws Exception {
+    try {
+      HttpUrl.getChecked("mailto:user@example.com");
+      fail();
+    } catch (MalformedURLException e) {
+    }
+  }
+
+  @Test public void fromJavaNetUrlBadHost_checked() throws Exception {
+    try {
+      HttpUrl.getChecked("http://hostw ithspace/");
+      fail();
+    } catch (UnknownHostException expected) {
+    }
+  }
+
+  @Test public void composeQueryWithComponents() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/");
+    HttpUrl url = base.newBuilder().addQueryParameter("a+=& b", "c+=& d").build();
+    assertEquals("http://host/?a%2B%3D%26%20b=c%2B%3D%26%20d", url.toString());
+    assertEquals("c+=& d", url.queryParameterValue(0));
+    assertEquals("a+=& b", url.queryParameterName(0));
+    assertEquals("c+=& d", url.queryParameter("a+=& b"));
+    assertEquals(Collections.singleton("a+=& b"), url.queryParameterNames());
+    assertEquals(singletonList("c+=& d"), url.queryParameterValues("a+=& b"));
+    assertEquals(1, url.querySize());
+    assertEquals("a+=& b=c+=& d", url.query()); // Ambiguous! (Though working as designed.)
+    assertEquals("a%2B%3D%26%20b=c%2B%3D%26%20d", url.encodedQuery());
+  }
+
+  @Test public void composeQueryWithEncodedComponents() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/");
+    HttpUrl url = base.newBuilder().addEncodedQueryParameter("a+=& b", "c+=& d").build();
+    assertEquals("http://host/?a+%3D%26%20b=c+%3D%26%20d", url.toString());
+    assertEquals("c =& d", url.queryParameter("a =& b"));
+  }
+
+  @Test public void composeQueryRemoveQueryParameter() throws Exception {
+    HttpUrl url = HttpUrl.parse("http://host/").newBuilder()
+        .addQueryParameter("a+=& b", "c+=& d")
+        .removeAllQueryParameters("a+=& b")
+        .build();
+    assertEquals("http://host/", url.toString());
+    assertEquals(null, url.queryParameter("a+=& b"));
+  }
+
+  @Test public void composeQueryRemoveEncodedQueryParameter() throws Exception {
+    HttpUrl url = HttpUrl.parse("http://host/").newBuilder()
+        .addEncodedQueryParameter("a+=& b", "c+=& d")
+        .removeAllEncodedQueryParameters("a+=& b")
+        .build();
+    assertEquals("http://host/", url.toString());
+    assertEquals(null, url.queryParameter("a =& b"));
+  }
+
+  @Test public void composeQuerySetQueryParameter() throws Exception {
+    HttpUrl url = HttpUrl.parse("http://host/").newBuilder()
+        .addQueryParameter("a+=& b", "c+=& d")
+        .setQueryParameter("a+=& b", "ef")
+        .build();
+    assertEquals("http://host/?a%2B%3D%26%20b=ef", url.toString());
+    assertEquals("ef", url.queryParameter("a+=& b"));
+  }
+
+  @Test public void composeQuerySetEncodedQueryParameter() throws Exception {
+    HttpUrl url = HttpUrl.parse("http://host/").newBuilder()
+        .addEncodedQueryParameter("a+=& b", "c+=& d")
+        .setEncodedQueryParameter("a+=& b", "ef")
+        .build();
+    assertEquals("http://host/?a+%3D%26%20b=ef", url.toString());
+    assertEquals("ef", url.queryParameter("a =& b"));
+  }
+
+  @Test public void composeQueryMultipleEncodedValuesForParameter() throws Exception {
+    HttpUrl url = HttpUrl.parse("http://host/").newBuilder()
+        .addQueryParameter("a+=& b", "c+=& d")
+        .addQueryParameter("a+=& b", "e+=& f")
+        .build();
+    assertEquals("http://host/?a%2B%3D%26%20b=c%2B%3D%26%20d&a%2B%3D%26%20b=e%2B%3D%26%20f",
+        url.toString());
+    assertEquals(2, url.querySize());
+    assertEquals(Collections.singleton("a+=& b"), url.queryParameterNames());
+    assertEquals(Arrays.asList("c+=& d", "e+=& f"), url.queryParameterValues("a+=& b"));
+  }
+
+  @Test public void absentQueryIsZeroNameValuePairs() throws Exception {
+    HttpUrl url = HttpUrl.parse("http://host/").newBuilder()
+        .query(null)
+        .build();
+    assertEquals(0, url.querySize());
+  }
+
+  @Test public void emptyQueryIsSingleNameValuePairWithEmptyKey() throws Exception {
+    HttpUrl url = HttpUrl.parse("http://host/").newBuilder()
+        .query("")
+        .build();
+    assertEquals(1, url.querySize());
+    assertEquals("", url.queryParameterName(0));
+    assertEquals(null, url.queryParameterValue(0));
+  }
+
+  @Test public void ampersandQueryIsTwoNameValuePairsWithEmptyKeys() throws Exception {
+    HttpUrl url = HttpUrl.parse("http://host/").newBuilder()
+        .query("&")
+        .build();
+    assertEquals(2, url.querySize());
+    assertEquals("", url.queryParameterName(0));
+    assertEquals(null, url.queryParameterValue(0));
+    assertEquals("", url.queryParameterName(1));
+    assertEquals(null, url.queryParameterValue(1));
+  }
+
+  @Test public void removeAllDoesNotRemoveQueryIfNoParametersWereRemoved() throws Exception {
+    HttpUrl url = HttpUrl.parse("http://host/").newBuilder()
+        .query("")
+        .removeAllQueryParameters("a")
+        .build();
+    assertEquals("http://host/?", url.toString());
+  }
+
+  @Test public void queryParametersWithoutValues() throws Exception {
+    HttpUrl url = HttpUrl.parse("http://host/?foo&bar&baz");
+    assertEquals(3, url.querySize());
+    assertEquals(new LinkedHashSet<>(Arrays.asList("foo", "bar", "baz")),
+        url.queryParameterNames());
+    assertEquals(null, url.queryParameterValue(0));
+    assertEquals(null, url.queryParameterValue(1));
+    assertEquals(null, url.queryParameterValue(2));
+    assertEquals(singletonList((String) null), url.queryParameterValues("foo"));
+    assertEquals(singletonList((String) null), url.queryParameterValues("bar"));
+    assertEquals(singletonList((String) null), url.queryParameterValues("baz"));
+  }
+
+  @Test public void queryParametersWithEmptyValues() throws Exception {
+    HttpUrl url = HttpUrl.parse("http://host/?foo=&bar=&baz=");
+    assertEquals(3, url.querySize());
+    assertEquals(new LinkedHashSet<>(Arrays.asList("foo", "bar", "baz")),
+        url.queryParameterNames());
+    assertEquals("", url.queryParameterValue(0));
+    assertEquals("", url.queryParameterValue(1));
+    assertEquals("", url.queryParameterValue(2));
+    assertEquals(singletonList(""), url.queryParameterValues("foo"));
+    assertEquals(singletonList(""), url.queryParameterValues("bar"));
+    assertEquals(singletonList(""), url.queryParameterValues("baz"));
+  }
+
+  @Test public void queryParametersWithRepeatedName() throws Exception {
+    HttpUrl url = HttpUrl.parse("http://host/?foo[]=1&foo[]=2&foo[]=3");
+    assertEquals(3, url.querySize());
+    assertEquals(Collections.singleton("foo[]"), url.queryParameterNames());
+    assertEquals("1", url.queryParameterValue(0));
+    assertEquals("2", url.queryParameterValue(1));
+    assertEquals("3", url.queryParameterValue(2));
+    assertEquals(Arrays.asList("1", "2", "3"), url.queryParameterValues("foo[]"));
+  }
+
+  @Test public void queryParameterLookupWithNonCanonicalEncoding() throws Exception {
+    HttpUrl url = HttpUrl.parse("http://host/?%6d=m&+=%20");
+    assertEquals("m", url.queryParameterName(0));
+    assertEquals(" ", url.queryParameterName(1));
+    assertEquals("m", url.queryParameter("m"));
+    assertEquals(" ", url.queryParameter(" "));
+  }
+
+  @Test public void roundTripBuilder() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .username("%")
+        .password("%")
+        .host("host")
+        .addPathSegment("%")
+        .query("%")
+        .fragment("%")
+        .build();
+    assertEquals("http://%25:%25@host/%25?%25#%25", url.toString());
+    assertEquals("http://%25:%25@host/%25?%25#%25", url.newBuilder().build().toString());
+    assertEquals("http://%25:%25@host/%25?%25", url.resolve("").toString());
+  }
+
+  /**
+   * Although HttpUrl prefers percent-encodings in uppercase, it should preserve the exact structure
+   * of the original encoding.
+   */
+  @Test public void rawEncodingRetained() throws Exception {
+    String urlString = "http://%6d%6D:%6d%6D@host/%6d%6D?%6d%6D#%6d%6D";
+    HttpUrl url = HttpUrl.parse(urlString);
+    assertEquals("%6d%6D", url.encodedUsername());
+    assertEquals("%6d%6D", url.encodedPassword());
+    assertEquals("/%6d%6D", url.encodedPath());
+    assertEquals(Arrays.asList("%6d%6D"), url.encodedPathSegments());
+    assertEquals("%6d%6D", url.encodedQuery());
+    assertEquals("%6d%6D", url.encodedFragment());
+    assertEquals(urlString, url.toString());
+    assertEquals(urlString, url.newBuilder().build().toString());
+    assertEquals("http://%6d%6D:%6d%6D@host/%6d%6D?%6d%6D", url.resolve("").toString());
+  }
+
+  @Test public void clearFragment() throws Exception {
+    HttpUrl url = HttpUrl.parse("http://host/#fragment")
+        .newBuilder()
+        .fragment(null)
+        .build();
+    assertEquals("http://host/", url.toString());
+    assertEquals(null, url.fragment());
+    assertEquals(null, url.encodedFragment());
+  }
+
+  @Test public void clearEncodedFragment() throws Exception {
+    HttpUrl url = HttpUrl.parse("http://host/#fragment")
+        .newBuilder()
+        .encodedFragment(null)
+        .build();
+    assertEquals("http://host/", url.toString());
+    assertEquals(null, url.fragment());
+    assertEquals(null, url.encodedFragment());
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/InterceptorTest.java b/okhttp-tests/src/test/java/okhttp3/InterceptorTest.java
similarity index 62%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/InterceptorTest.java
rename to okhttp-tests/src/test/java/okhttp3/InterceptorTest.java
index 8cd8d97bdb..287f12a317 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/InterceptorTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/InterceptorTest.java
@@ -13,21 +13,20 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.RecordedRequest;
-import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
 import java.io.IOException;
-import java.net.URL;
 import java.util.Arrays;
-import java.util.List;
 import java.util.Locale;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
+import okhttp3.mockwebserver.SocketPolicy;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.ForwardingSink;
@@ -39,6 +38,7 @@
 import org.junit.Rule;
 import org.junit.Test;
 
+import static okhttp3.TestUtil.defaultClient;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
@@ -46,13 +46,13 @@
 import static org.junit.Assert.fail;
 
 public final class InterceptorTest {
-  @Rule public MockWebServerRule server = new MockWebServerRule();
+  @Rule public MockWebServer server = new MockWebServer();
 
-  private OkHttpClient client = new OkHttpClient();
+  private OkHttpClient client = defaultClient();
   private RecordingCallback callback = new RecordingCallback();
 
   @Test public void applicationInterceptorsCanShortCircuitResponses() throws Exception {
-    server.get().shutdown(); // Accept no connections.
+    server.shutdown(); // Accept no connections.
 
     Request request = new Request.Builder()
         .url("https://localhost:1/")
@@ -66,11 +66,12 @@
         .body(ResponseBody.create(MediaType.parse("text/plain; charset=utf-8"), "abc"))
         .build();
 
-    client.interceptors().add(new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        return interceptorResponse;
-      }
-    });
+    client = client.newBuilder()
+        .addInterceptor(new Interceptor() {
+          @Override public Response intercept(Chain chain) throws IOException {
+            return interceptorResponse;
+          }
+        }).build();
 
     Response response = client.newCall(request).execute();
     assertSame(interceptorResponse, response);
@@ -90,10 +91,12 @@
             .build();
       }
     };
-    client.networkInterceptors().add(interceptor);
+    client = client.newBuilder()
+        .addNetworkInterceptor(interceptor)
+        .build();
 
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .build();
 
     try {
@@ -115,10 +118,12 @@
         return chain.proceed(chain.request());
       }
     };
-    client.networkInterceptors().add(interceptor);
+    client = client.newBuilder()
+        .addNetworkInterceptor(interceptor)
+        .build();
 
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .build();
 
     try {
@@ -135,18 +140,20 @@
 
     Interceptor interceptor = new Interceptor() {
       @Override public Response intercept(Chain chain) throws IOException {
-        Address address = chain.connection().getRoute().getAddress();
-        String sameHost = address.getUriHost();
-        int differentPort = address.getUriPort() + 1;
+        Address address = chain.connection().route().address();
+        String sameHost = address.url().host();
+        int differentPort = address.url().port() + 1;
         return chain.proceed(chain.request().newBuilder()
-            .url(new URL("http://" + sameHost + ":" + differentPort + "/"))
+            .url(HttpUrl.parse("http://" + sameHost + ":" + differentPort + "/"))
             .build());
       }
     };
-    client.networkInterceptors().add(interceptor);
+    client = client.newBuilder()
+        .addNetworkInterceptor(interceptor)
+        .build();
 
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .build();
 
     try {
@@ -161,16 +168,19 @@
   @Test public void networkInterceptorsHaveConnectionAccess() throws Exception {
     server.enqueue(new MockResponse());
 
-    client.networkInterceptors().add(new Interceptor() {
+    Interceptor interceptor = new Interceptor() {
       @Override public Response intercept(Chain chain) throws IOException {
         Connection connection = chain.connection();
         assertNotNull(connection);
         return chain.proceed(chain.request());
       }
-    });
+    };
+    client = client.newBuilder()
+        .addNetworkInterceptor(interceptor)
+        .build();
 
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .build();
     client.newCall(request).execute();
   }
@@ -180,12 +190,12 @@
         .setBody(gzip("abcabcabc"))
         .addHeader("Content-Encoding: gzip"));
 
-    client.networkInterceptors().add(new Interceptor() {
+    Interceptor interceptor = new Interceptor() {
       @Override public Response intercept(Chain chain) throws IOException {
         // The network request has everything: User-Agent, Host, Accept-Encoding.
         Request networkRequest = chain.request();
         assertNotNull(networkRequest.header("User-Agent"));
-        assertEquals(server.get().getHostName() + ":" + server.get().getPort(),
+        assertEquals(server.getHostName() + ":" + server.getPort(),
             networkRequest.header("Host"));
         assertNotNull(networkRequest.header("Accept-Encoding"));
 
@@ -194,10 +204,13 @@
         assertEquals("gzip", networkResponse.header("Content-Encoding"));
         return networkResponse;
       }
-    });
+    };
+    client = client.newBuilder()
+        .addNetworkInterceptor(interceptor)
+        .build();
 
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .build();
 
     // No extra headers in the application's request.
@@ -211,18 +224,49 @@
     assertEquals("abcabcabc", response.body().string());
   }
 
+  @Test public void networkInterceptorsCanChangeRequestMethodFromGetToPost() throws Exception {
+    server.enqueue(new MockResponse());
+
+    Interceptor interceptor = new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        Request originalRequest = chain.request();
+        MediaType mediaType = MediaType.parse("text/plain");
+        RequestBody body = RequestBody.create(mediaType, "abc");
+        return chain.proceed(originalRequest.newBuilder()
+            .method("POST", body)
+            .header("Content-Type", mediaType.toString())
+            .header("Content-Length", Long.toString(body.contentLength()))
+            .build());
+      }
+    };
+    client = client.newBuilder()
+        .addNetworkInterceptor(interceptor)
+        .build();
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .get()
+        .build();
+
+    client.newCall(request).execute();
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("POST", recordedRequest.getMethod());
+    assertEquals("abc", recordedRequest.getBody().readUtf8());
+  }
+
   @Test public void applicationInterceptorsRewriteRequestToServer() throws Exception {
-    rewriteRequestToServer(client.interceptors());
+    rewriteRequestToServer(false);
   }
 
   @Test public void networkInterceptorsRewriteRequestToServer() throws Exception {
-    rewriteRequestToServer(client.networkInterceptors());
+    rewriteRequestToServer(true);
   }
 
-  private void rewriteRequestToServer(List<Interceptor> interceptors) throws Exception {
+  private void rewriteRequestToServer(boolean network) throws Exception {
     server.enqueue(new MockResponse());
 
-    interceptors.add(new Interceptor() {
+    addInterceptor(network, new Interceptor() {
       @Override public Response intercept(Chain chain) throws IOException {
         Request originalRequest = chain.request();
         return chain.proceed(originalRequest.newBuilder()
@@ -233,7 +277,7 @@ private void rewriteRequestToServer(List<Interceptor> interceptors) throws Excep
     });
 
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .addHeader("Original-Header", "foo")
         .method("PUT", RequestBody.create(MediaType.parse("text/plain"), "abc"))
         .build();
@@ -248,19 +292,19 @@ private void rewriteRequestToServer(List<Interceptor> interceptors) throws Excep
   }
 
   @Test public void applicationInterceptorsRewriteResponseFromServer() throws Exception {
-    rewriteResponseFromServer(client.interceptors());
+    rewriteResponseFromServer(false);
   }
 
   @Test public void networkInterceptorsRewriteResponseFromServer() throws Exception {
-    rewriteResponseFromServer(client.networkInterceptors());
+    rewriteResponseFromServer(true);
   }
 
-  private void rewriteResponseFromServer(List<Interceptor> interceptors) throws Exception {
+  private void rewriteResponseFromServer(boolean network) throws Exception {
     server.enqueue(new MockResponse()
         .addHeader("Original-Header: foo")
         .setBody("abc"));
 
-    interceptors.add(new Interceptor() {
+    addInterceptor(network, new Interceptor() {
       @Override public Response intercept(Chain chain) throws IOException {
         Response originalResponse = chain.proceed(chain.request());
         return originalResponse.newBuilder()
@@ -271,7 +315,7 @@ private void rewriteResponseFromServer(List<Interceptor> interceptors) throws Ex
     });
 
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .build();
 
     Response response = client.newCall(request).execute();
@@ -281,17 +325,17 @@ private void rewriteResponseFromServer(List<Interceptor> interceptors) throws Ex
   }
 
   @Test public void multipleApplicationInterceptors() throws Exception {
-    multipleInterceptors(client.interceptors());
+    multipleInterceptors(false);
   }
 
   @Test public void multipleNetworkInterceptors() throws Exception {
-    multipleInterceptors(client.networkInterceptors());
+    multipleInterceptors(true);
   }
 
-  private void multipleInterceptors(List<Interceptor> interceptors) throws Exception {
+  private void multipleInterceptors(boolean network) throws Exception {
     server.enqueue(new MockResponse());
 
-    interceptors.add(new Interceptor() {
+    addInterceptor(network, new Interceptor() {
       @Override public Response intercept(Chain chain) throws IOException {
         Request originalRequest = chain.request();
         Response originalResponse = chain.proceed(originalRequest.newBuilder()
@@ -302,7 +346,7 @@ private void multipleInterceptors(List<Interceptor> interceptors) throws Excepti
             .build();
       }
     });
-    interceptors.add(new Interceptor() {
+    addInterceptor(network, new Interceptor() {
       @Override public Response intercept(Chain chain) throws IOException {
         Request originalRequest = chain.request();
         Response originalResponse = chain.proceed(originalRequest.newBuilder()
@@ -315,7 +359,7 @@ private void multipleInterceptors(List<Interceptor> interceptors) throws Excepti
     });
 
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .build();
 
     Response response = client.newCall(request).execute();
@@ -328,17 +372,17 @@ private void multipleInterceptors(List<Interceptor> interceptors) throws Excepti
   }
 
   @Test public void asyncApplicationInterceptors() throws Exception {
-    asyncInterceptors(client.interceptors());
+    asyncInterceptors(false);
   }
 
   @Test public void asyncNetworkInterceptors() throws Exception {
-    asyncInterceptors(client.networkInterceptors());
+    asyncInterceptors(true);
   }
 
-  private void asyncInterceptors(List<Interceptor> interceptors) throws Exception {
+  private void asyncInterceptors(boolean network) throws Exception {
     server.enqueue(new MockResponse());
 
-    interceptors.add(new Interceptor() {
+    addInterceptor(network, new Interceptor() {
       @Override public Response intercept(Chain chain) throws IOException {
         Response originalResponse = chain.proceed(chain.request());
         return originalResponse.newBuilder()
@@ -348,7 +392,7 @@ private void asyncInterceptors(List<Interceptor> interceptors) throws Exception
     });
 
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .build();
     client.newCall(request).enqueue(callback);
 
@@ -361,15 +405,17 @@ private void asyncInterceptors(List<Interceptor> interceptors) throws Exception
     server.enqueue(new MockResponse().setBody("a"));
     server.enqueue(new MockResponse().setBody("b"));
 
-    client.interceptors().add(new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        chain.proceed(chain.request());
-        return chain.proceed(chain.request());
-      }
-    });
+    client = client.newBuilder()
+        .addInterceptor(new Interceptor() {
+          @Override public Response intercept(Chain chain) throws IOException {
+            Response response1 = chain.proceed(chain.request());
+            response1.body().close();
+            return chain.proceed(chain.request());
+          }
+        }).build();
 
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .build();
 
     Response response = client.newCall(request).execute();
@@ -381,22 +427,23 @@ private void asyncInterceptors(List<Interceptor> interceptors) throws Exception
     server.enqueue(new MockResponse().setBody("a")); // Fetched by interceptor.
     server.enqueue(new MockResponse().setBody("b")); // Fetched directly.
 
-    client.interceptors().add(new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        if (chain.request().url().getPath().equals("/b")) {
-          Request requestA = new Request.Builder()
-              .url(server.getUrl("/a"))
-              .build();
-          Response responseA = client.newCall(requestA).execute();
-          assertEquals("a", responseA.body().string());
-        }
-
-        return chain.proceed(chain.request());
-      }
-    });
+    client = client.newBuilder()
+        .addInterceptor(new Interceptor() {
+          @Override public Response intercept(Chain chain) throws IOException {
+            if (chain.request().url().encodedPath().equals("/b")) {
+              Request requestA = new Request.Builder()
+                  .url(server.url("/a"))
+                  .build();
+              Response responseA = client.newCall(requestA).execute();
+              assertEquals("a", responseA.body().string());
+            }
+
+            return chain.proceed(chain.request());
+          }
+        }).build();
 
     Request requestB = new Request.Builder()
-        .url(server.getUrl("/b"))
+        .url(server.url("/b"))
         .build();
     Response responseB = client.newCall(requestB).execute();
     assertEquals("b", responseB.body().string());
@@ -407,58 +454,56 @@ private void asyncInterceptors(List<Interceptor> interceptors) throws Exception
     server.enqueue(new MockResponse().setBody("a")); // Fetched by interceptor.
     server.enqueue(new MockResponse().setBody("b")); // Fetched directly.
 
-    client.interceptors().add(new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        if (chain.request().url().getPath().equals("/b")) {
-          Request requestA = new Request.Builder()
-              .url(server.getUrl("/a"))
-              .build();
-
-          try {
-            RecordingCallback callbackA = new RecordingCallback();
-            client.newCall(requestA).enqueue(callbackA);
-            callbackA.await(requestA.url()).assertBody("a");
-          } catch (Exception e) {
-            throw new RuntimeException(e);
+    client = client.newBuilder()
+        .addInterceptor(new Interceptor() {
+          @Override public Response intercept(Chain chain) throws IOException {
+            if (chain.request().url().encodedPath().equals("/b")) {
+              Request requestA = new Request.Builder()
+                  .url(server.url("/a"))
+                  .build();
+
+              try {
+                RecordingCallback callbackA = new RecordingCallback();
+                client.newCall(requestA).enqueue(callbackA);
+                callbackA.await(requestA.url()).assertBody("a");
+              } catch (Exception e) {
+                throw new RuntimeException(e);
+              }
+            }
+
+            return chain.proceed(chain.request());
           }
-        }
-
-        return chain.proceed(chain.request());
-      }
-    });
+        }).build();
 
     Request requestB = new Request.Builder()
-        .url(server.getUrl("/b"))
+        .url(server.url("/b"))
         .build();
     RecordingCallback callbackB = new RecordingCallback();
     client.newCall(requestB).enqueue(callbackB);
     callbackB.await(requestB.url()).assertBody("b");
   }
 
-  @Test public void applicationkInterceptorThrowsRuntimeExceptionSynchronous() throws Exception {
-    interceptorThrowsRuntimeExceptionSynchronous(client.interceptors());
+  @Test public void applicationInterceptorThrowsRuntimeExceptionSynchronous() throws Exception {
+    interceptorThrowsRuntimeExceptionSynchronous(false);
   }
 
   @Test public void networkInterceptorThrowsRuntimeExceptionSynchronous() throws Exception {
-    interceptorThrowsRuntimeExceptionSynchronous(client.networkInterceptors());
+    interceptorThrowsRuntimeExceptionSynchronous(true);
   }
 
   /**
    * When an interceptor throws an unexpected exception, synchronous callers can catch it and deal
    * with it.
-   *
-   * TODO(jwilson): test that resources are not leaked when this happens.
    */
-  private void interceptorThrowsRuntimeExceptionSynchronous(
-      List<Interceptor> interceptors) throws Exception {
-    interceptors.add(new Interceptor() {
+  private void interceptorThrowsRuntimeExceptionSynchronous(boolean network) throws Exception {
+    addInterceptor(network, new Interceptor() {
       @Override public Response intercept(Chain chain) throws IOException {
         throw new RuntimeException("boom!");
       }
     });
 
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .build();
 
     try {
@@ -469,39 +514,148 @@ private void interceptorThrowsRuntimeExceptionSynchronous(
     }
   }
 
+  @Test public void networkInterceptorModifiedRequestIsReturned() throws IOException {
+    server.enqueue(new MockResponse());
+
+    Interceptor modifyHeaderInterceptor = new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        return chain.proceed(chain.request().newBuilder()
+            .header("User-Agent", "intercepted request")
+            .build());
+      }
+    };
+
+    client = client.newBuilder()
+        .addNetworkInterceptor(modifyHeaderInterceptor)
+        .build();
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .header("User-Agent", "user request")
+        .build();
+
+    Response response = client.newCall(request).execute();
+    assertNotNull(response.request().header("User-Agent"));
+    assertEquals("user request", response.request().header("User-Agent"));
+    assertEquals("intercepted request", response.networkResponse().request().header("User-Agent"));
+  }
+
   @Test public void applicationInterceptorThrowsRuntimeExceptionAsynchronous() throws Exception {
-    interceptorThrowsRuntimeExceptionAsynchronous(client.interceptors());
+    interceptorThrowsRuntimeExceptionAsynchronous(false);
   }
 
   @Test public void networkInterceptorThrowsRuntimeExceptionAsynchronous() throws Exception {
-    interceptorThrowsRuntimeExceptionAsynchronous(client.networkInterceptors());
+    interceptorThrowsRuntimeExceptionAsynchronous(true);
   }
 
   /**
    * When an interceptor throws an unexpected exception, asynchronous callers are left hanging. The
    * exception goes to the uncaught exception handler.
-   *
-   * TODO(jwilson): test that resources are not leaked when this happens.
    */
-  private void interceptorThrowsRuntimeExceptionAsynchronous(
-        List<Interceptor> interceptors) throws Exception {
-    interceptors.add(new Interceptor() {
+  private void interceptorThrowsRuntimeExceptionAsynchronous(boolean network) throws Exception {
+    addInterceptor(network, new Interceptor() {
       @Override public Response intercept(Chain chain) throws IOException {
         throw new RuntimeException("boom!");
       }
     });
 
     ExceptionCatchingExecutor executor = new ExceptionCatchingExecutor();
-    client.setDispatcher(new Dispatcher(executor));
+    client = client.newBuilder()
+        .dispatcher(new Dispatcher(executor))
+        .build();
 
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .build();
     client.newCall(request).enqueue(callback);
 
     assertEquals("boom!", executor.takeException().getMessage());
   }
 
+  @Test public void applicationInterceptorReturnsNull() throws Exception {
+    server.enqueue(new MockResponse());
+
+    Interceptor interceptor = new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        chain.proceed(chain.request());
+        return null;
+      }
+    };
+    client = client.newBuilder()
+        .addInterceptor(interceptor)
+        .build();
+
+    ExceptionCatchingExecutor executor = new ExceptionCatchingExecutor();
+    client = client.newBuilder()
+        .dispatcher(new Dispatcher(executor))
+        .build();
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    try {
+      client.newCall(request).execute();
+      fail();
+    } catch (NullPointerException expected) {
+      assertEquals("application interceptor " + interceptor
+          + " returned null", expected.getMessage());
+    }
+  }
+
+  @Test public void networkInterceptorReturnsNull() throws Exception {
+    server.enqueue(new MockResponse());
+
+    Interceptor interceptor = new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        chain.proceed(chain.request());
+        return null;
+      }
+    };
+    client = client.newBuilder()
+        .addNetworkInterceptor(interceptor)
+        .build();
+
+    ExceptionCatchingExecutor executor = new ExceptionCatchingExecutor();
+    client = client.newBuilder()
+        .dispatcher(new Dispatcher(executor))
+        .build();
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    try {
+      client.newCall(request).execute();
+      fail();
+    } catch (NullPointerException expected) {
+      assertEquals("network interceptor " + interceptor + " returned null", expected.getMessage());
+    }
+  }
+
+  @Test public void networkInterceptorReturnsConnectionOnEmptyBody() throws Exception {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
+        .addHeader("Connection", "Close"));
+
+    Interceptor interceptor = new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        Response response = chain.proceed(chain.request());
+        assertNotNull(chain.connection());
+        return response;
+      }
+    };
+
+    client = client.newBuilder()
+        .addNetworkInterceptor(interceptor)
+        .build();
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    Response response = client.newCall(request).execute();
+    response.body().close();
+  }
+
   private RequestBody uppercase(final RequestBody original) {
     return new RequestBody() {
       @Override public MediaType contentType() {
@@ -553,6 +707,16 @@ private Buffer gzip(String data) throws IOException {
     return result;
   }
 
+  private void addInterceptor(boolean network, Interceptor interceptor) {
+    OkHttpClient.Builder builder = client.newBuilder();
+    if (network) {
+      builder.addNetworkInterceptor(interceptor);
+    } else {
+      builder.addInterceptor(interceptor);
+    }
+    client = builder.build();
+  }
+
   /** Catches exceptions that are otherwise headed for the uncaught exception handler. */
   private static class ExceptionCatchingExecutor extends ThreadPoolExecutor {
     private final BlockingQueue<Exception> exceptions = new LinkedBlockingQueue<>();
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/MediaTypeTest.java b/okhttp-tests/src/test/java/okhttp3/MediaTypeTest.java
similarity index 96%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/MediaTypeTest.java
rename to okhttp-tests/src/test/java/okhttp3/MediaTypeTest.java
index 25805957a5..b4e9c2ec2a 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/MediaTypeTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/MediaTypeTest.java
@@ -14,12 +14,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
-import com.squareup.okhttp.internal.Util;
 import java.nio.charset.Charset;
 import java.nio.charset.IllegalCharsetNameException;
 import java.nio.charset.UnsupportedCharsetException;
+import okhttp3.internal.Util;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
@@ -30,8 +30,8 @@
 /**
  * Test MediaType API and parsing.
  *
- * <p>This test includes tests from <a
- * href="https://code.google.com/p/guava-libraries/">Guava's</a> MediaTypeTest.
+ * <p>This test includes tests from <a href="https://code.google.com/p/guava-libraries/">Guava's</a>
+ * MediaTypeTest.
  */
 public class MediaTypeTest {
   @Test public void testParse() throws Exception {
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/MultipartBuilderTest.java b/okhttp-tests/src/test/java/okhttp3/MultipartBodyTest.java
similarity index 73%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/MultipartBuilderTest.java
rename to okhttp-tests/src/test/java/okhttp3/MultipartBodyTest.java
index 4159679c76..a5a8664a87 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/MultipartBuilderTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/MultipartBodyTest.java
@@ -13,21 +13,25 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
 import java.io.IOException;
 import okio.Buffer;
 import okio.BufferedSink;
 import org.junit.Test;
 
-import static com.squareup.okhttp.internal.Util.UTF_8;
+import static okhttp3.internal.Util.UTF_8;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 
-public final class MultipartBuilderTest {
-  @Test(expected = IllegalStateException.class)
-  public void onePartRequired() throws Exception {
-    new MultipartBuilder().build();
+public final class MultipartBodyTest {
+  @Test public void onePartRequired() throws Exception {
+    try {
+      new MultipartBody.Builder().build();
+      fail();
+    } catch (IllegalStateException e) {
+      assertEquals("Multipart body must have at least one part.", e.getMessage());
+    }
   }
 
   @Test public void singlePart() throws Exception {
@@ -38,16 +42,19 @@ public void onePartRequired() throws Exception {
         + "Hello, World!\r\n"
         + "--123--\r\n";
 
-    RequestBody requestBody = new MultipartBuilder("123")
+    MultipartBody body = new MultipartBody.Builder("123")
         .addPart(RequestBody.create(null, "Hello, World!"))
         .build();
 
-    assertEquals("multipart/mixed; boundary=123", requestBody.contentType().toString());
+    assertEquals("123", body.boundary());
+    assertEquals(MultipartBody.MIXED, body.type());
+    assertEquals("multipart/mixed; boundary=123", body.contentType().toString());
+    assertEquals(1, body.parts().size());
+    assertEquals(53, body.contentLength());
 
     Buffer buffer = new Buffer();
-    requestBody.writeTo(buffer);
-    assertEquals(53, requestBody.contentLength());
-    assertEquals(buffer.size(), requestBody.contentLength());
+    body.writeTo(buffer);
+    assertEquals(buffer.size(), body.contentLength());
     assertEquals(expected, buffer.readUtf8());
   }
 
@@ -67,18 +74,21 @@ public void onePartRequired() throws Exception {
         + "Fox\r\n"
         + "--123--\r\n";
 
-    RequestBody requestBody = new MultipartBuilder("123")
+    MultipartBody body = new MultipartBody.Builder("123")
         .addPart(RequestBody.create(null, "Quick"))
         .addPart(RequestBody.create(null, "Brown"))
         .addPart(RequestBody.create(null, "Fox"))
         .build();
 
-    assertEquals("multipart/mixed; boundary=123", requestBody.contentType().toString());
+    assertEquals("123", body.boundary());
+    assertEquals(MultipartBody.MIXED, body.type());
+    assertEquals("multipart/mixed; boundary=123", body.contentType().toString());
+    assertEquals(3, body.parts().size());
+    assertEquals(112, body.contentLength());
 
     Buffer buffer = new Buffer();
-    requestBody.writeTo(buffer);
-    assertEquals(112, requestBody.contentLength());
-    assertEquals(buffer.size(), requestBody.contentLength());
+    body.writeTo(buffer);
+    assertEquals(buffer.size(), body.contentLength());
     assertEquals(expected, buffer.readUtf8());
   }
 
@@ -111,11 +121,11 @@ public void onePartRequired() throws Exception {
         + "\r\n"
         + "--AaB03x--\r\n";
 
-    RequestBody requestBody = new MultipartBuilder("AaB03x")
-        .type(MultipartBuilder.FORM)
+    MultipartBody body = new MultipartBody.Builder("AaB03x")
+        .setType(MultipartBody.FORM)
         .addFormDataPart("submit-name", "Larry")
         .addFormDataPart("files", null,
-            new MultipartBuilder("BbC04y")
+            new MultipartBody.Builder("BbC04y")
                 .addPart(
                     Headers.of("Content-Disposition", "file; filename=\"file1.txt\""),
                     RequestBody.create(
@@ -130,12 +140,15 @@ public void onePartRequired() throws Exception {
                 .build())
         .build();
 
-    assertEquals("multipart/form-data; boundary=AaB03x", requestBody.contentType().toString());
+    assertEquals("AaB03x", body.boundary());
+    assertEquals(MultipartBody.FORM, body.type());
+    assertEquals("multipart/form-data; boundary=AaB03x", body.contentType().toString());
+    assertEquals(2, body.parts().size());
+    assertEquals(568, body.contentLength());
 
     Buffer buffer = new Buffer();
-    requestBody.writeTo(buffer);
-    assertEquals(568, requestBody.contentLength());
-    assertEquals(buffer.size(), requestBody.contentLength());
+    body.writeTo(buffer);
+    assertEquals(buffer.size(), body.contentLength());
     assertEquals(expected, buffer.readUtf8());
   }
 
@@ -164,8 +177,8 @@ public void onePartRequired() throws Exception {
         + "Alpha\r\n"
         + "--AaB03x--\r\n";
 
-    RequestBody requestBody = new MultipartBuilder("AaB03x")
-        .type(MultipartBuilder.FORM)
+    MultipartBody body = new MultipartBody.Builder("AaB03x")
+        .setType(MultipartBody.FORM)
         .addFormDataPart("field with spaces", "filename with spaces.txt",
             RequestBody.create(MediaType.parse("text/plain; charset=utf-8"), "okay"))
         .addFormDataPart("field with \"", "\"")
@@ -174,7 +187,7 @@ public void onePartRequired() throws Exception {
         .build();
 
     Buffer buffer = new Buffer();
-    requestBody.writeTo(buffer);
+    body.writeTo(buffer);
     assertEquals(expected, buffer.readUtf8());
   }
 
@@ -209,24 +222,27 @@ public void onePartRequired() throws Exception {
         + "Fox\r\n"
         + "--123--\r\n";
 
-    RequestBody requestBody = new MultipartBuilder("123")
+    MultipartBody body = new MultipartBody.Builder("123")
         .addPart(RequestBody.create(null, "Quick"))
         .addPart(new StreamingBody("Brown"))
         .addPart(RequestBody.create(null, "Fox"))
         .build();
 
-    assertEquals("multipart/mixed; boundary=123", requestBody.contentType().toString());
+    assertEquals("123", body.boundary());
+    assertEquals(MultipartBody.MIXED, body.type());
+    assertEquals("multipart/mixed; boundary=123", body.contentType().toString());
+    assertEquals(3, body.parts().size());
+    assertEquals(-1, body.contentLength());
 
     Buffer buffer = new Buffer();
-    requestBody.writeTo(buffer);
+    body.writeTo(buffer);
     assertEquals(expected, buffer.readUtf8());
-    assertEquals(-1, requestBody.contentLength());
   }
 
   @Test public void contentTypeHeaderIsForbidden() throws Exception {
+    MultipartBody.Builder multipart = new MultipartBody.Builder();
     try {
-      new MultipartBuilder().addPart(
-          Headers.of("Content-Type", "text/plain"),
+      multipart.addPart(Headers.of("Content-Type", "text/plain"),
           RequestBody.create(null, "Hello, World!"));
       fail();
     } catch (IllegalArgumentException expected) {
@@ -234,9 +250,9 @@ public void onePartRequired() throws Exception {
   }
 
   @Test public void contentLengthHeaderIsForbidden() throws Exception {
+    MultipartBody.Builder multipart = new MultipartBody.Builder();
     try {
-      new MultipartBuilder().addPart(
-          Headers.of("Content-Length", "13"),
+      multipart.addPart(Headers.of("Content-Length", "13"),
           RequestBody.create(null, "Hello, World!"));
       fail();
     } catch (IllegalArgumentException expected) {
diff --git a/okhttp-tests/src/test/java/okhttp3/OkHttpClientTest.java b/okhttp-tests/src/test/java/okhttp3/OkHttpClientTest.java
new file mode 100644
index 0000000000..e369a4d4b1
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/OkHttpClientTest.java
@@ -0,0 +1,123 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.net.CookieHandler;
+import java.net.CookieManager;
+import java.net.ProxySelector;
+import java.net.ResponseCache;
+import java.util.Arrays;
+import java.util.concurrent.TimeUnit;
+import org.junit.After;
+import org.junit.Test;
+
+import static okhttp3.TestUtil.defaultClient;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.fail;
+
+public final class OkHttpClientTest {
+  private static final ProxySelector DEFAULT_PROXY_SELECTOR = ProxySelector.getDefault();
+  private static final CookieHandler DEFAULT_COOKIE_HANDLER = CookieManager.getDefault();
+  private static final ResponseCache DEFAULT_RESPONSE_CACHE = ResponseCache.getDefault();
+
+  @After public void tearDown() throws Exception {
+    ProxySelector.setDefault(DEFAULT_PROXY_SELECTOR);
+    CookieManager.setDefault(DEFAULT_COOKIE_HANDLER);
+    ResponseCache.setDefault(DEFAULT_RESPONSE_CACHE);
+  }
+
+  @Test public void timeoutDefaults() {
+    OkHttpClient client = defaultClient();
+    assertEquals(10_000, client.connectTimeoutMillis());
+    assertEquals(10_000, client.readTimeoutMillis());
+    assertEquals(10_000, client.writeTimeoutMillis());
+  }
+
+  @Test public void timeoutValidRange() {
+    OkHttpClient.Builder builder = new OkHttpClient.Builder();
+    try {
+      builder.connectTimeout(1, TimeUnit.NANOSECONDS);
+    } catch (IllegalArgumentException ignored) {
+    }
+    try {
+      builder.writeTimeout(1, TimeUnit.NANOSECONDS);
+    } catch (IllegalArgumentException ignored) {
+    }
+    try {
+      builder.readTimeout(1, TimeUnit.NANOSECONDS);
+    } catch (IllegalArgumentException ignored) {
+    }
+    try {
+      builder.connectTimeout(365, TimeUnit.DAYS);
+    } catch (IllegalArgumentException ignored) {
+    }
+    try {
+      builder.writeTimeout(365, TimeUnit.DAYS);
+    } catch (IllegalArgumentException ignored) {
+    }
+    try {
+      builder.readTimeout(365, TimeUnit.DAYS);
+    } catch (IllegalArgumentException ignored) {
+    }
+  }
+
+  @Test public void clonedInterceptorsListsAreIndependent() throws Exception {
+    Interceptor interceptor = new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        return chain.proceed(chain.request());
+      }
+    };
+    OkHttpClient original = defaultClient();
+    original.newBuilder()
+        .addInterceptor(interceptor)
+        .addNetworkInterceptor(interceptor)
+        .build();
+    assertEquals(0, original.interceptors().size());
+    assertEquals(0, original.networkInterceptors().size());
+  }
+
+  /**
+   * When copying the client, stateful things like the connection pool are shared across all
+   * clients.
+   */
+  @Test public void cloneSharesStatefulInstances() throws Exception {
+    OkHttpClient client = defaultClient();
+
+    // Values should be non-null.
+    OkHttpClient a = client.newBuilder().build();
+    assertNotNull(a.dispatcher());
+    assertNotNull(a.connectionPool());
+    assertNotNull(a.sslSocketFactory());
+
+    // Multiple clients share the instances.
+    OkHttpClient b = client.newBuilder().build();
+    assertSame(a.dispatcher(), b.dispatcher());
+    assertSame(a.connectionPool(), b.connectionPool());
+    assertSame(a.sslSocketFactory(), b.sslSocketFactory());
+  }
+
+  @Test public void setProtocolsRejectsHttp10() throws Exception {
+    OkHttpClient.Builder builder = new OkHttpClient.Builder();
+    try {
+      builder.protocols(Arrays.asList(Protocol.HTTP_1_0, Protocol.HTTP_1_1));
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/RecordedResponse.java b/okhttp-tests/src/test/java/okhttp3/RecordedResponse.java
similarity index 75%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/RecordedResponse.java
rename to okhttp-tests/src/test/java/okhttp3/RecordedResponse.java
index 129fecf145..ae7afa98df 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/RecordedResponse.java
+++ b/okhttp-tests/src/test/java/okhttp3/RecordedResponse.java
@@ -13,12 +13,13 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
-import com.squareup.okhttp.ws.WebSocket;
 import java.io.IOException;
-import java.net.URL;
+import java.text.SimpleDateFormat;
 import java.util.Arrays;
+import java.util.Date;
+import okhttp3.ws.WebSocket;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
@@ -45,7 +46,7 @@ public RecordedResponse(Request request, Response response, WebSocket webSocket,
     this.failure = failure;
   }
 
-  public RecordedResponse assertRequestUrl(URL url) {
+  public RecordedResponse assertRequestUrl(HttpUrl url) {
     assertEquals(url, request.url());
     return this;
   }
@@ -80,6 +81,11 @@ public RecordedResponse assertHeader(String name, String... values) {
     return this;
   }
 
+  public RecordedResponse assertHeaders(Headers headers) {
+    assertEquals(headers, response.headers());
+    return this;
+  }
+
   public RecordedResponse assertBody(String expectedBody) {
     assertEquals(expectedBody, body);
     return this;
@@ -87,6 +93,7 @@ public RecordedResponse assertBody(String expectedBody) {
 
   public RecordedResponse assertHandshake() {
     Handshake handshake = response.handshake();
+    assertNotNull(handshake.tlsVersion());
     assertNotNull(handshake.cipherSuite());
     assertNotNull(handshake.peerPrincipal());
     assertEquals(1, handshake.peerCertificates().size());
@@ -96,8 +103,7 @@ public RecordedResponse assertHandshake() {
   }
 
   /**
-   * Asserts that the current response was redirected and returns the prior
-   * response.
+   * Asserts that the current response was redirected and returns the prior response.
    */
   public RecordedResponse priorResponse() {
     Response priorResponse = response.priorResponse();
@@ -107,8 +113,7 @@ public RecordedResponse priorResponse() {
   }
 
   /**
-   * Asserts that the current response used the network and returns the network
-   * response.
+   * Asserts that the current response used the network and returns the network response.
    */
   public RecordedResponse networkResponse() {
     Response networkResponse = response.networkResponse();
@@ -130,8 +135,7 @@ public RecordedResponse assertNoCacheResponse() {
   }
 
   /**
-   * Asserts that the current response used the cache and returns the cache
-   * response.
+   * Asserts that the current response used the cache and returns the cache response.
    */
   public RecordedResponse cacheResponse() {
     Response cacheResponse = response.cacheResponse();
@@ -140,8 +144,33 @@ public RecordedResponse cacheResponse() {
     return new RecordedResponse(cacheResponse.request(), cacheResponse, null, null, null);
   }
 
-  public void assertFailure(String... messages) {
+  public RecordedResponse assertFailure(Class<?> exceptionClass) {
+    assertTrue(exceptionClass.isInstance(failure));
+    return this;
+  }
+
+  public RecordedResponse assertFailure(String... messages) {
     assertNotNull(failure);
     assertTrue(failure.getMessage(), Arrays.asList(messages).contains(failure.getMessage()));
+    return this;
+  }
+
+  public RecordedResponse assertSentRequestAtMillis(long minimum, long maximum) {
+    assertDateInRange(minimum, response.sentRequestAtMillis(), maximum);
+    return this;
+  }
+
+  public RecordedResponse assertReceivedResponseAtMillis(long minimum, long maximum) {
+    assertDateInRange(minimum, response.receivedResponseAtMillis(), maximum);
+    return this;
+  }
+
+  private void assertDateInRange(long minimum, long actual, long maximum) {
+    assertTrue("actual " + format(actual) + " < minimum " + format(maximum), actual >= minimum);
+    assertTrue("actual " + format(actual) + " > maximum " + format(minimum), actual <= maximum);
+  }
+
+  private String format(long time) {
+    return new SimpleDateFormat("HH:mm:ss.SSS").format(new Date(time));
   }
 }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/RecordingCallback.java b/okhttp-tests/src/test/java/okhttp3/RecordingCallback.java
similarity index 65%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/RecordingCallback.java
rename to okhttp-tests/src/test/java/okhttp3/RecordingCallback.java
index 73e38f0e95..56a1d7e003 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/RecordingCallback.java
+++ b/okhttp-tests/src/test/java/okhttp3/RecordingCallback.java
@@ -13,15 +13,13 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
 import java.io.IOException;
-import java.net.URL;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
 import java.util.concurrent.TimeUnit;
-import okio.Buffer;
 
 /**
  * Records received HTTP responses so they can be later retrieved by tests.
@@ -31,25 +29,22 @@
 
   private final List<RecordedResponse> responses = new ArrayList<>();
 
-  @Override public synchronized void onFailure(Request request, IOException e) {
-    responses.add(new RecordedResponse(request, null, null, null, e));
+  @Override public synchronized void onFailure(Call call, IOException e) {
+    responses.add(new RecordedResponse(call.request(), null, null, null, e));
     notifyAll();
   }
 
-  @Override public synchronized void onResponse(Response response) throws IOException {
-    Buffer buffer = new Buffer();
-    ResponseBody body = response.body();
-    body.source().readAll(buffer);
-
-    responses.add(new RecordedResponse(response.request(), response, null, buffer.readUtf8(), null));
+  @Override public synchronized void onResponse(Call call, Response response) throws IOException {
+    String body = response.body().string();
+    responses.add(new RecordedResponse(call.request(), response, null, body, null));
     notifyAll();
   }
 
   /**
-   * Returns the recorded response triggered by {@code request}. Throws if the
-   * response isn't enqueued before the timeout.
+   * Returns the recorded response triggered by {@code request}. Throws if the response isn't
+   * enqueued before the timeout.
    */
-  public synchronized RecordedResponse await(URL url) throws Exception {
+  public synchronized RecordedResponse await(HttpUrl url) throws Exception {
     long timeoutMillis = TimeUnit.NANOSECONDS.toMillis(System.nanoTime()) + TIMEOUT_MILLIS;
     while (true) {
       for (Iterator<RecordedResponse> i = responses.iterator(); i.hasNext(); ) {
@@ -67,12 +62,4 @@ public synchronized RecordedResponse await(URL url) throws Exception {
 
     throw new AssertionError("Timed out waiting for response to " + url);
   }
-
-  public synchronized void assertNoResponse(URL url) throws Exception {
-    for (RecordedResponse recordedResponse : responses) {
-      if (recordedResponse.request.url().equals(url)) {
-        throw new AssertionError("Expected no response for " + url);
-      }
-    }
-  }
 }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/RequestTest.java b/okhttp-tests/src/test/java/okhttp3/RequestTest.java
similarity index 69%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/RequestTest.java
rename to okhttp-tests/src/test/java/okhttp3/RequestTest.java
index a1249e5903..4668f6005d 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/RequestTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/RequestTest.java
@@ -13,21 +13,21 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
-import com.squareup.okhttp.internal.Util;
 import java.io.File;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.net.URI;
-import java.net.URL;
 import java.util.Arrays;
 import java.util.Collections;
+import okhttp3.internal.Util;
 import okio.Buffer;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
+import static org.junit.Assert.fail;
 
 public final class RequestTest {
   @Test public void string() throws Exception {
@@ -119,20 +119,22 @@
 
   @Test public void uninitializedURI() throws Exception {
     Request request = new Request.Builder().url("http://localhost/api").build();
-    assertEquals(new URI("http://localhost/api"), request.uri());
-    assertEquals(new URL("http://localhost/api"), request.url());
+    assertEquals(new URI("http://localhost/api"), request.url().uri());
+    assertEquals(HttpUrl.parse("http://localhost/api"), request.url());
   }
 
   @Test public void newBuilderUrlResetsUrl() throws Exception {
     Request requestWithoutCache = new Request.Builder().url("http://localhost/api").build();
-    Request builtRequestWithoutCache = requestWithoutCache.newBuilder().url("http://localhost/api/foo").build();
-    assertEquals(new URL("http://localhost/api/foo"), builtRequestWithoutCache.url());
+    Request builtRequestWithoutCache =
+        requestWithoutCache.newBuilder().url("http://localhost/api/foo").build();
+    assertEquals(HttpUrl.parse("http://localhost/api/foo"), builtRequestWithoutCache.url());
 
     Request requestWithCache = new Request.Builder().url("http://localhost/api").build();
     // cache url object
     requestWithCache.url();
-    Request builtRequestWithCache = requestWithCache.newBuilder().url("http://localhost/api/foo").build();
-    assertEquals(new URL("http://localhost/api/foo"), builtRequestWithCache.url());
+    Request builtRequestWithCache = requestWithCache.newBuilder().url(
+        "http://localhost/api/foo").build();
+    assertEquals(HttpUrl.parse("http://localhost/api/foo"), builtRequestWithCache.url());
   }
 
   @Test public void cacheControl() throws Exception {
@@ -152,6 +154,85 @@
     assertEquals(Collections.<String>emptyList(), request.headers("Cache-Control"));
   }
 
+  @Test public void headerAcceptsPermittedCharacters() throws Exception {
+    Request.Builder builder = new Request.Builder();
+    builder.header("AZab09 ~", "AZab09 ~");
+    builder.addHeader("AZab09 ~", "AZab09 ~");
+  }
+
+  @Test public void emptyNameForbidden() throws Exception {
+    Request.Builder builder = new Request.Builder();
+    try {
+      builder.header("", "Value");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+    try {
+      builder.addHeader("", "Value");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void headerForbidsNullArguments() throws Exception {
+    Request.Builder builder = new Request.Builder();
+    try {
+      builder.header(null, "Value");
+      fail();
+    } catch (NullPointerException expected) {
+    }
+    try {
+      builder.addHeader(null, "Value");
+      fail();
+    } catch (NullPointerException expected) {
+    }
+    try {
+      builder.header("Name", null);
+      fail();
+    } catch (NullPointerException expected) {
+    }
+    try {
+      builder.addHeader("Name", null);
+      fail();
+    } catch (NullPointerException expected) {
+    }
+  }
+
+  @Test public void headerForbidsControlCharacters() throws Exception {
+    assertForbiddenHeader("\u0000");
+    assertForbiddenHeader("\r");
+    assertForbiddenHeader("\n");
+    assertForbiddenHeader("\t");
+    assertForbiddenHeader("\u001f");
+    assertForbiddenHeader("\u007f");
+    assertForbiddenHeader("\u0080");
+    assertForbiddenHeader("\ud83c\udf69");
+  }
+
+  private void assertForbiddenHeader(String s) {
+    Request.Builder builder = new Request.Builder();
+    try {
+      builder.header(s, "Value");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+    try {
+      builder.addHeader(s, "Value");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+    try {
+      builder.header("Name", s);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+    try {
+      builder.addHeader("Name", s);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
   private String bodyToHex(RequestBody body) throws IOException {
     Buffer buffer = new Buffer();
     body.writeTo(buffer);
diff --git a/okhttp-tests/src/test/java/okhttp3/ResponseTest.java b/okhttp-tests/src/test/java/okhttp3/ResponseTest.java
new file mode 100644
index 0000000000..8977fdf441
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/ResponseTest.java
@@ -0,0 +1,101 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import okio.Buffer;
+import okio.BufferedSource;
+import okio.Okio;
+import okio.Source;
+import okio.Timeout;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+public final class ResponseTest {
+  @Test public void peekShorterThanResponse() throws Exception {
+    Response response = newResponse(responseBody("abcdef"));
+    ResponseBody peekedBody = response.peekBody(3);
+    assertEquals("abc", peekedBody.string());
+    assertEquals("abcdef", response.body().string());
+  }
+
+  @Test public void peekLongerThanResponse() throws Exception {
+    Response response = newResponse(responseBody("abc"));
+    ResponseBody peekedBody = response.peekBody(6);
+    assertEquals("abc", peekedBody.string());
+    assertEquals("abc", response.body().string());
+  }
+
+  @Test public void peekAfterReadingResponse() throws Exception {
+    Response response = newResponse(responseBody("abc"));
+    assertEquals("abc", response.body().string());
+
+    try {
+      response.peekBody(3);
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+  }
+
+  @Test public void eachPeakIsIndependent() throws Exception {
+    Response response = newResponse(responseBody("abcdef"));
+    ResponseBody p1 = response.peekBody(4);
+    ResponseBody p2 = response.peekBody(2);
+    assertEquals("abcdef", response.body().string());
+    assertEquals("abcd", p1.string());
+    assertEquals("ab", p2.string());
+  }
+
+  /**
+   * Returns a new response body that refuses to be read once it has been closed. This is true of
+   * most {@link BufferedSource} instances, but not of {@link Buffer}.
+   */
+  private ResponseBody responseBody(String content) {
+    final Buffer data = new Buffer().writeUtf8(content);
+
+    Source source = new Source() {
+      boolean closed;
+
+      @Override public void close() throws IOException {
+        closed = true;
+      }
+
+      @Override public long read(Buffer sink, long byteCount) throws IOException {
+        if (closed) throw new IllegalStateException();
+        return data.read(sink, byteCount);
+      }
+
+      @Override public Timeout timeout() {
+        return Timeout.NONE;
+      }
+    };
+
+    return ResponseBody.create(null, -1, Okio.buffer(source));
+  }
+
+  private Response newResponse(ResponseBody responseBody) {
+    return new Response.Builder()
+        .request(new Request.Builder()
+            .url("https://example.com/")
+            .build())
+        .protocol(Protocol.HTTP_1_1)
+        .code(200)
+        .body(responseBody)
+        .build();
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/SocksProxy.java b/okhttp-tests/src/test/java/okhttp3/SocksProxy.java
similarity index 94%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/SocksProxy.java
rename to okhttp-tests/src/test/java/okhttp3/SocksProxy.java
index e2a553203f..9c1b5a83cb 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/SocksProxy.java
+++ b/okhttp-tests/src/test/java/okhttp3/SocksProxy.java
@@ -13,10 +13,8 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
-import com.squareup.okhttp.internal.NamedRunnable;
-import com.squareup.okhttp.internal.Util;
 import java.io.IOException;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
@@ -31,6 +29,8 @@
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.logging.Level;
 import java.util.logging.Logger;
+import okhttp3.internal.NamedRunnable;
+import okhttp3.internal.Util;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -41,6 +41,8 @@
  * See <a href="https://www.ietf.org/rfc/rfc1928.txt">RFC 1928</a>.
  */
 public final class SocksProxy {
+  public final String HOSTNAME_THAT_ONLY_THE_PROXY_KNOWS = "onlyProxyCanResolveMe.org";
+
   private static final int VERSION_5 = 5;
   private static final int METHOD_NONE = 0xff;
   private static final int METHOD_NO_AUTHENTICATION_REQUIRED = 0;
@@ -156,7 +158,10 @@ private void acceptCommand(InetAddress fromAddress, BufferedSource fromSource,
       case ADDRESS_TYPE_DOMAIN_NAME:
         int domainNameLength = fromSource.readByte() & 0xff;
         String domainName = fromSource.readUtf8(domainNameLength);
-        toAddress = InetAddress.getByName(domainName);
+        // Resolve HOSTNAME_THAT_ONLY_THE_PROXY_KNOWS to localhost.
+        toAddress = domainName.equalsIgnoreCase(HOSTNAME_THAT_ONLY_THE_PROXY_KNOWS)
+            ? InetAddress.getLoopbackAddress()
+            : InetAddress.getByName(domainName);
         break;
 
       default:
@@ -203,7 +208,7 @@ private void transfer(final InetAddress fromAddress, final InetAddress toAddress
         Buffer buffer = new Buffer();
         try {
           while (true) {
-            long byteCount = source.read(buffer, 2048L);
+            long byteCount = source.read(buffer, 8192L);
             if (byteCount == -1L) break;
             sink.write(buffer, byteCount);
             sink.emit();
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/SocksProxyTest.java b/okhttp-tests/src/test/java/okhttp3/SocksProxyTest.java
similarity index 65%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/SocksProxyTest.java
rename to okhttp-tests/src/test/java/okhttp3/SocksProxyTest.java
index 9b10213c27..f74cb6f075 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/SocksProxyTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/SocksProxyTest.java
@@ -13,10 +13,8 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
 import java.io.IOException;
 import java.net.Proxy;
 import java.net.ProxySelector;
@@ -24,6 +22,8 @@
 import java.net.URI;
 import java.util.Collections;
 import java.util.List;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -48,14 +48,15 @@
     server.enqueue(new MockResponse().setBody("abc"));
     server.enqueue(new MockResponse().setBody("def"));
 
-    OkHttpClient client = new OkHttpClient()
-        .setProxy(socksProxy.proxy());
+    OkHttpClient client = new OkHttpClient.Builder()
+        .proxy(socksProxy.proxy())
+        .build();
 
-    Request request1 = new Request.Builder().url(server.getUrl("/")).build();
+    Request request1 = new Request.Builder().url(server.url("/")).build();
     Response response1 = client.newCall(request1).execute();
     assertEquals("abc", response1.body().string());
 
-    Request request2 = new Request.Builder().url(server.getUrl("/")).build();
+    Request request2 = new Request.Builder().url(server.url("/")).build();
     Response response2 = client.newCall(request2).execute();
     assertEquals("def", response2.body().string());
 
@@ -76,13 +77,34 @@
       }
     };
 
-    OkHttpClient client = new OkHttpClient()
-        .setProxySelector(proxySelector);
+    OkHttpClient client = new OkHttpClient.Builder()
+        .proxySelector(proxySelector)
+        .build();
 
-    Request request = new Request.Builder().url(server.getUrl("/")).build();
+    Request request = new Request.Builder().url(server.url("/")).build();
     Response response = client.newCall(request).execute();
     assertEquals("abc", response.body().string());
 
     assertEquals(1, socksProxy.connectionCount());
   }
+
+  @Test public void checkRemoteDNSResolve() throws Exception {
+    // This testcase will fail if the target is resolved locally instead of through the proxy.
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    OkHttpClient client = new OkHttpClient.Builder()
+        .proxy(socksProxy.proxy())
+        .build();
+
+    HttpUrl url = server.url("/")
+        .newBuilder()
+        .host(socksProxy.HOSTNAME_THAT_ONLY_THE_PROXY_KNOWS)
+        .build();
+
+    Request request = new Request.Builder().url(url).build();
+    Response response1 = client.newCall(request).execute();
+    assertEquals("abc", response1.body().string());
+
+    assertEquals(1, socksProxy.connectionCount());
+  }
 }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/TestLogHandler.java b/okhttp-tests/src/test/java/okhttp3/TestLogHandler.java
similarity index 97%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/TestLogHandler.java
rename to okhttp-tests/src/test/java/okhttp3/TestLogHandler.java
index 24cb377cab..10f3cbb9d2 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/TestLogHandler.java
+++ b/okhttp-tests/src/test/java/okhttp3/TestLogHandler.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
 import java.util.ArrayList;
 import java.util.List;
diff --git a/okhttp-tests/src/test/java/okhttp3/TestUtil.java b/okhttp-tests/src/test/java/okhttp3/TestUtil.java
new file mode 100644
index 0000000000..a4581960eb
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/TestUtil.java
@@ -0,0 +1,55 @@
+package okhttp3;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Set;
+import okhttp3.internal.SingleInetAddressDns;
+import okhttp3.internal.framed.Header;
+
+public final class TestUtil {
+  private TestUtil() {
+  }
+
+  private static final ConnectionPool connectionPool = new ConnectionPool();
+
+  /**
+   * Returns an OkHttpClient for all tests to use as a starting point.
+   *
+   * <p>The shared instance allows all tests to share a single connection pool, which prevents idle
+   * connections from consuming unnecessary resources while connections wait to be evicted.
+   *
+   * <p>This client is also configured to be slightly more deterministic, returning a single IP
+   * address for all hosts, regardless of the actual number of IP addresses reported by DNS.
+   */
+  public static OkHttpClient defaultClient() {
+    return new OkHttpClient.Builder()
+        .connectionPool(connectionPool)
+        .dns(new SingleInetAddressDns()) // Prevent unexpected fallback addresses.
+        .build();
+  }
+
+  public static List<Header> headerEntries(String... elements) {
+    List<Header> result = new ArrayList<>(elements.length / 2);
+    for (int i = 0; i < elements.length; i += 2) {
+      result.add(new Header(elements[i], elements[i + 1]));
+    }
+    return result;
+  }
+
+  public static <T> Set<T> setOf(T... elements) {
+    return setOf(Arrays.asList(elements));
+  }
+
+  public static <T> Set<T> setOf(Collection<T> elements) {
+    return new LinkedHashSet<>(elements);
+  }
+
+  public static String repeat(char c, int count) {
+    char[] array = new char[count];
+    Arrays.fill(array, c);
+    return new String(array);
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java b/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
similarity index 70%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
rename to okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
index b9c6793328..224707fe85 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
@@ -13,36 +13,8 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+package okhttp3;
 
-package com.squareup.okhttp.internal.http;
-
-import com.squareup.okhttp.Cache;
-import com.squareup.okhttp.Challenge;
-import com.squareup.okhttp.ConnectionPool;
-import com.squareup.okhttp.ConnectionSpec;
-import com.squareup.okhttp.Credentials;
-import com.squareup.okhttp.DelegatingServerSocketFactory;
-import com.squareup.okhttp.DelegatingSocketFactory;
-import com.squareup.okhttp.FallbackTestClientSocketFactory;
-import com.squareup.okhttp.Headers;
-import com.squareup.okhttp.Interceptor;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.OkUrlFactory;
-import com.squareup.okhttp.Protocol;
-import com.squareup.okhttp.Response;
-import com.squareup.okhttp.TlsVersion;
-import com.squareup.okhttp.internal.Internal;
-import com.squareup.okhttp.internal.RecordingAuthenticator;
-import com.squareup.okhttp.internal.RecordingHostnameVerifier;
-import com.squareup.okhttp.internal.RecordingOkAuthenticator;
-import com.squareup.okhttp.internal.SingleInetAddressNetwork;
-import com.squareup.okhttp.internal.SslContextBuilder;
-import com.squareup.okhttp.internal.Util;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-import com.squareup.okhttp.mockwebserver.RecordedRequest;
-import com.squareup.okhttp.mockwebserver.SocketPolicy;
-import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
@@ -57,17 +29,19 @@
 import java.net.ServerSocket;
 import java.net.Socket;
 import java.net.SocketAddress;
+import java.net.SocketTimeoutException;
 import java.net.URI;
 import java.net.URL;
 import java.net.URLConnection;
 import java.net.UnknownHostException;
+import java.security.KeyStore;
 import java.security.cert.CertificateException;
 import java.security.cert.X509Certificate;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.EnumSet;
-import java.util.HashSet;
+import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Random;
@@ -82,7 +56,20 @@
 import javax.net.ssl.SSLHandshakeException;
 import javax.net.ssl.SSLSocketFactory;
 import javax.net.ssl.TrustManager;
+import javax.net.ssl.TrustManagerFactory;
 import javax.net.ssl.X509TrustManager;
+import okhttp3.internal.DoubleInetAddressDns;
+import okhttp3.internal.Internal;
+import okhttp3.internal.RecordingAuthenticator;
+import okhttp3.internal.RecordingOkAuthenticator;
+import okhttp3.internal.SingleInetAddressDns;
+import okhttp3.internal.Util;
+import okhttp3.internal.Version;
+import okhttp3.internal.tls.SslClient;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
+import okhttp3.mockwebserver.SocketPolicy;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.GzipSink;
@@ -94,38 +81,42 @@
 import org.junit.Test;
 import org.junit.rules.TemporaryFolder;
 
-import static com.squareup.okhttp.internal.Util.UTF_8;
-import static com.squareup.okhttp.internal.http.OkHeaders.SELECTED_PROTOCOL;
-import static com.squareup.okhttp.internal.http.StatusLine.HTTP_PERM_REDIRECT;
-import static com.squareup.okhttp.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
-import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
-import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
-import static com.squareup.okhttp.mockwebserver.SocketPolicy.SHUTDOWN_INPUT_AT_END;
-import static com.squareup.okhttp.mockwebserver.SocketPolicy.SHUTDOWN_OUTPUT_AT_END;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
+import static okhttp3.TestUtil.defaultClient;
+import static okhttp3.internal.Util.UTF_8;
+import static okhttp3.internal.http.OkHeaders.SELECTED_PROTOCOL;
+import static okhttp3.internal.http.StatusLine.HTTP_PERM_REDIRECT;
+import static okhttp3.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
+import static okhttp3.mockwebserver.SocketPolicy.FAIL_HANDSHAKE;
+import static okhttp3.mockwebserver.SocketPolicy.SHUTDOWN_INPUT_AT_END;
+import static okhttp3.mockwebserver.SocketPolicy.SHUTDOWN_OUTPUT_AT_END;
+import static okhttp3.mockwebserver.SocketPolicy.UPGRADE_TO_SSL_AT_END;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
+import static org.junit.Assume.assumeTrue;
 
 /** Android's URLConnectionTest. */
 public final class URLConnectionTest {
-  private static final SSLContext sslContext = SslContextBuilder.localhost();
-
-  @Rule public final MockWebServerRule server = new MockWebServerRule();
-  @Rule public final MockWebServerRule server2 = new MockWebServerRule();
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final MockWebServer server2 = new MockWebServer();
   @Rule public final TemporaryFolder tempDir = new TemporaryFolder();
 
-  private OkUrlFactory client;
+  private SslClient sslClient = SslClient.localhost();
+  private OkUrlFactory urlFactory;
   private HttpURLConnection connection;
   private Cache cache;
 
   @Before public void setUp() throws Exception {
-    server.get().setProtocolNegotiationEnabled(false);
-    client = new OkUrlFactory(new OkHttpClient());
+    server.setProtocolNegotiationEnabled(false);
+    urlFactory = new OkUrlFactory(defaultClient());
   }
 
   @After public void tearDown() throws Exception {
@@ -145,14 +136,14 @@
   @Test public void requestHeaders() throws IOException, InterruptedException {
     server.enqueue(new MockResponse());
 
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     connection.addRequestProperty("D", "e");
     connection.addRequestProperty("D", "f");
     assertEquals("f", connection.getRequestProperty("D"));
     assertEquals("f", connection.getRequestProperty("d"));
     Map<String, List<String>> requestHeaders = connection.getRequestProperties();
-    assertEquals(newSet("e", "f"), new HashSet<String>(requestHeaders.get("D")));
-    assertEquals(newSet("e", "f"), new HashSet<String>(requestHeaders.get("d")));
+    assertEquals(newSet("e", "f"), new LinkedHashSet<>(requestHeaders.get("D")));
+    assertEquals(newSet("e", "f"), new LinkedHashSet<>(requestHeaders.get("d")));
     try {
       requestHeaders.put("G", Arrays.asList("h"));
       fail("Modified an unmodifiable view.");
@@ -204,7 +195,7 @@
   }
 
   @Test public void getRequestPropertyReturnsLastValue() throws Exception {
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     connection.addRequestProperty("A", "value1");
     connection.addRequestProperty("A", "value2");
     assertEquals("value2", connection.getRequestProperty("A"));
@@ -217,14 +208,14 @@
         .addHeader("A: e")
         .setChunkedBody("ABCDE\nFGHIJ\nKLMNO\nPQR", 8));
 
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     assertEquals(200, connection.getResponseCode());
     assertEquals("Fantastic", connection.getResponseMessage());
     assertEquals("HTTP/1.0 200 Fantastic", connection.getHeaderField(null));
     Map<String, List<String>> responseHeaders = connection.getHeaderFields();
     assertEquals(Arrays.asList("HTTP/1.0 200 Fantastic"), responseHeaders.get(null));
-    assertEquals(newSet("c", "e"), new HashSet<String>(responseHeaders.get("A")));
-    assertEquals(newSet("c", "e"), new HashSet<String>(responseHeaders.get("a")));
+    assertEquals(newSet("c", "e"), new LinkedHashSet<>(responseHeaders.get("A")));
+    assertEquals(newSet("c", "e"), new LinkedHashSet<>(responseHeaders.get("a")));
     try {
       responseHeaders.put("N", Arrays.asList("o"));
       fail("Modified an unmodifiable view.");
@@ -241,12 +232,13 @@
     assertEquals("d", connection.getHeaderField(1));
     assertEquals("A", connection.getHeaderFieldKey(2));
     assertEquals("e", connection.getHeaderField(2));
+    connection.getInputStream().close();
   }
 
   @Test public void serverSendsInvalidResponseHeaders() throws Exception {
     server.enqueue(new MockResponse().setStatus("HTP/1.1 200 OK"));
 
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     try {
       connection.getResponseCode();
       fail();
@@ -257,7 +249,7 @@
   @Test public void serverSendsInvalidCodeTooLarge() throws Exception {
     server.enqueue(new MockResponse().setStatus("HTTP/1.1 2147483648 OK"));
 
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     try {
       connection.getResponseCode();
       fail();
@@ -268,7 +260,7 @@
   @Test public void serverSendsInvalidCodeNotANumber() throws Exception {
     server.enqueue(new MockResponse().setStatus("HTTP/1.1 00a OK"));
 
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     try {
       connection.getResponseCode();
       fail();
@@ -279,7 +271,7 @@
   @Test public void serverSendsUnnecessaryWhitespace() throws Exception {
     server.enqueue(new MockResponse().setStatus(" HTTP/1.1 2147483648 OK"));
 
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     try {
       connection.getResponseCode();
       fail();
@@ -288,10 +280,10 @@
   }
 
   @Test public void connectRetriesUntilConnectedOrFailed() throws Exception {
-    URL url = server.getUrl("/foo");
-    server.get().shutdown();
+    URL url = server.url("/foo").url();
+    server.shutdown();
 
-    connection = client.open(url);
+    connection = urlFactory.open(url);
     try {
       connection.connect();
       fail();
@@ -315,12 +307,13 @@ private void testRequestBodySurvivesRetries(TransferKind transferKind) throws Ex
     server.enqueue(new MockResponse().setBody("abc"));
 
     // Use a misconfigured proxy to guarantee that the request is retried.
-    FakeProxySelector proxySelector = new FakeProxySelector();
-    proxySelector.proxies.add(server2.get().toProxyAddress());
-    client.client().setProxySelector(proxySelector);
-    server2.get().shutdown();
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .proxySelector(new FakeProxySelector()
+            .addProxy(server2.toProxyAddress()))
+        .build());
+    server2.shutdown();
 
-    connection = client.open(server.getUrl("/def"));
+    connection = urlFactory.open(server.url("/def").url());
     connection.setDoOutput(true);
     transferKind.setForRequest(connection, 4);
     connection.getOutputStream().write("body".getBytes("UTF-8"));
@@ -331,13 +324,14 @@ private void testRequestBodySurvivesRetries(TransferKind transferKind) throws Ex
 
   @Test public void getErrorStreamOnSuccessfulRequest() throws Exception {
     server.enqueue(new MockResponse().setBody("A"));
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     assertNull(connection.getErrorStream());
+    connection.getInputStream().close();
   }
 
   @Test public void getErrorStreamOnUnsuccessfulRequest() throws Exception {
     server.enqueue(new MockResponse().setResponseCode(404).setBody("A"));
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     assertEquals("A", readAscii(connection.getErrorStream(), Integer.MAX_VALUE));
   }
 
@@ -350,8 +344,13 @@ private void testRequestBodySurvivesRetries(TransferKind transferKind) throws Ex
     server.enqueue(response);
     server.enqueue(response);
 
-    assertContent("ABCDE", client.open(server.getUrl("/")), 5);
-    assertContent("ABCDE", client.open(server.getUrl("/")), 5);
+    HttpURLConnection c1 = urlFactory.open(server.url("/").url());
+    assertContent("ABCDE", c1, 5);
+    HttpURLConnection c2 = urlFactory.open(server.url("/").url());
+    assertContent("ABCDE", c2, 5);
+
+    c1.getInputStream().close();
+    c2.getInputStream().close();
   }
 
   // Check that we recognize a few basic mime types by extension.
@@ -368,11 +367,11 @@ private void testRequestBodySurvivesRetries(TransferKind transferKind) throws Ex
     server.enqueue(response);
     server.enqueue(response);
 
-    assertContent("ABCDEFGHIJKLMNOPQR", client.open(server.getUrl("/foo")));
+    assertContent("ABCDEFGHIJKLMNOPQR", urlFactory.open(server.url("/foo").url()));
     assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertContent("ABCDEFGHIJKLMNOPQR", client.open(server.getUrl("/bar?baz=quux")));
+    assertContent("ABCDEFGHIJKLMNOPQR", urlFactory.open(server.url("/bar?baz=quux").url()));
     assertEquals(1, server.takeRequest().getSequenceNumber());
-    assertContent("ABCDEFGHIJKLMNOPQR", client.open(server.getUrl("/z")));
+    assertContent("ABCDEFGHIJKLMNOPQR", urlFactory.open(server.url("/z").url()));
     assertEquals(2, server.takeRequest().getSequenceNumber());
   }
 
@@ -383,11 +382,11 @@ private void testRequestBodySurvivesRetries(TransferKind transferKind) throws Ex
     server.enqueue(response);
     server.enqueue(response);
 
-    assertContent("ABCDEFGHIJKLMNOPQR", client.open(server.getUrl("/foo")));
+    assertContent("ABCDEFGHIJKLMNOPQR", urlFactory.open(server.url("/foo").url()));
     assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertContent("ABCDEFGHIJKLMNOPQR", client.open(server.getUrl("/bar?baz=quux")));
+    assertContent("ABCDEFGHIJKLMNOPQR", urlFactory.open(server.url("/bar?baz=quux").url()));
     assertEquals(1, server.takeRequest().getSequenceNumber());
-    assertContent("ABCDEFGHIJKLMNOPQR", client.open(server.getUrl("/z")));
+    assertContent("ABCDEFGHIJKLMNOPQR", urlFactory.open(server.url("/z").url()));
     assertEquals(2, server.takeRequest().getSequenceNumber());
   }
 
@@ -406,7 +405,10 @@ private void testRequestBodySurvivesRetries(TransferKind transferKind) throws Ex
   @Test public void invalidHost() throws Exception {
     // Note that 1234.1.1.1 is an invalid host in a URI, but URL isn't as strict.
     URL url = new URL("http://1234.1.1.1/index.html");
-    HttpURLConnection connection = client.open(url);
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .dns(new FakeDns())
+        .build());
+    HttpURLConnection connection = urlFactory.open(url);
     try {
       connection.connect();
       fail();
@@ -421,11 +423,16 @@ private void testServerClosesOutput(SocketPolicy socketPolicy) throws Exception
     server.enqueue(responseAfter);
     server.enqueue(responseAfter); // Enqueue 2x because the broken connection may be reused.
 
-    HttpURLConnection connection1 = client.open(server.getUrl("/a"));
+    HttpURLConnection connection1 = urlFactory.open(server.url("/a").url());
     connection1.setReadTimeout(100);
     assertContent("This connection won't pool properly", connection1);
     assertEquals(0, server.takeRequest().getSequenceNumber());
-    HttpURLConnection connection2 = client.open(server.getUrl("/b"));
+
+    // Give the server time to enact the socket policy if it's one that could happen after the
+    // client has received the response.
+    Thread.sleep(500);
+
+    HttpURLConnection connection2 = urlFactory.open(server.url("/b").url());
     connection2.setReadTimeout(100);
     assertContent("This comes after a busted connection", connection2);
 
@@ -466,10 +473,10 @@ private void testServerClosesOutput(SocketPolicy socketPolicy) throws Exception
 
   private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Exception {
     int n = 512 * 1024;
-    server.get().setBodyLimit(0);
+    server.setBodyLimit(0);
     server.enqueue(new MockResponse());
 
-    HttpURLConnection conn = client.open(server.getUrl("/"));
+    HttpURLConnection conn = urlFactory.open(server.url("/").url());
     conn.setDoOutput(true);
     conn.setRequestMethod("POST");
     if (uploadKind == TransferKind.CHUNKED) {
@@ -503,8 +510,8 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
   @Test public void getResponseCodeNoResponseBody() throws Exception {
     server.enqueue(new MockResponse().addHeader("abc: def"));
 
-    URL url = server.getUrl("/");
-    HttpURLConnection conn = client.open(url);
+    URL url = server.url("/").url();
+    HttpURLConnection conn = urlFactory.open(url);
     conn.setDoInput(false);
     assertEquals("def", conn.getHeaderField("abc"));
     assertEquals(200, conn.getResponseCode());
@@ -516,12 +523,14 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
   }
 
   @Test public void connectViaHttps() throws Exception {
-    server.get().useHttps(sslContext.getSocketFactory(), false);
+    server.useHttps(sslClient.socketFactory, false);
     server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
 
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
-    connection = client.open(server.getUrl("/foo"));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build());
+    connection = urlFactory.open(server.url("/foo").url());
 
     assertContent("this response comes via HTTPS", connection);
 
@@ -530,13 +539,16 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
   }
 
   @Test public void inspectHandshakeThroughoutRequestLifecycle() throws Exception {
-    server.get().useHttps(sslContext.getSocketFactory(), false);
+    server.useHttps(sslClient.socketFactory, false);
     server.enqueue(new MockResponse());
 
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build());
 
-    HttpsURLConnection httpsConnection = (HttpsURLConnection) client.open(server.getUrl("/foo"));
+    HttpsURLConnection httpsConnection
+        = (HttpsURLConnection) urlFactory.open(server.url("/foo").url());
 
     // Prior to calling connect(), getting the cipher suite is forbidden.
     try {
@@ -559,40 +571,54 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
   }
 
   @Test public void connectViaHttpsReusingConnections() throws IOException, InterruptedException {
-    server.get().useHttps(sslContext.getSocketFactory(), false);
+    server.useHttps(sslClient.socketFactory, false);
     server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
     server.enqueue(new MockResponse().setBody("another response via HTTPS"));
 
     // The pool will only reuse sockets if the SSL socket factories are the same.
-    SSLSocketFactory clientSocketFactory = sslContext.getSocketFactory();
+    SSLSocketFactory clientSocketFactory = sslClient.socketFactory;
     RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
 
-    client.client().setSslSocketFactory(clientSocketFactory);
-    client.client().setHostnameVerifier(hostnameVerifier);
-    connection = client.open(server.getUrl("/"));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .sslSocketFactory(clientSocketFactory, sslClient.trustManager)
+        .hostnameVerifier(hostnameVerifier)
+        .build());
+    connection = urlFactory.open(server.url("/").url());
     assertContent("this response comes via HTTPS", connection);
 
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     assertContent("another response via HTTPS", connection);
 
     assertEquals(0, server.takeRequest().getSequenceNumber());
     assertEquals(1, server.takeRequest().getSequenceNumber());
   }
 
-  @Test public void connectViaHttpsReusingConnectionsDifferentFactories()
-      throws IOException, InterruptedException {
-    server.get().useHttps(sslContext.getSocketFactory(), false);
+  @Test public void connectViaHttpsReusingConnectionsDifferentFactories() throws Exception {
+    server.useHttps(sslClient.socketFactory, false);
     server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
     server.enqueue(new MockResponse().setBody("another response via HTTPS"));
 
     // install a custom SSL socket factory so the server can be authorized
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
-    HttpURLConnection connection1 = client.open(server.getUrl("/"));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build());
+    HttpURLConnection connection1 = urlFactory.open(server.url("/").url());
     assertContent("this response comes via HTTPS", connection1);
 
-    client.client().setSslSocketFactory(null);
-    HttpURLConnection connection2 = client.open(server.getUrl("/"));
+    SSLContext sslContext2 = SSLContext.getInstance("TLS");
+    sslContext2.init(null, null, null);
+    SSLSocketFactory sslSocketFactory2 = sslContext2.getSocketFactory();
+
+    TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
+        TrustManagerFactory.getDefaultAlgorithm());
+    trustManagerFactory.init((KeyStore) null);
+    X509TrustManager trustManager = (X509TrustManager) trustManagerFactory.getTrustManagers()[0];
+
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .sslSocketFactory(sslSocketFactory2, trustManager)
+        .build());
+    HttpURLConnection connection2 = urlFactory.open(server.url("/").url());
     try {
       readAscii(connection2.getInputStream(), Integer.MAX_VALUE);
       fail("without an SSL socket factory, the connection should fail");
@@ -600,39 +626,73 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
     }
   }
 
-  @Test public void connectViaHttpsWithSSLFallback() throws IOException, InterruptedException {
-    server.get().useHttps(sslContext.getSocketFactory(), false);
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
+  // TODO(jwilson): tests below this marker need to be migrated to OkHttp's request/response API.
+
+  @Test public void connectViaHttpsWithSSLFallback() throws Exception {
+    server.useHttps(sslClient.socketFactory, false);
+    server.enqueue(new MockResponse().setSocketPolicy(FAIL_HANDSHAKE));
     server.enqueue(new MockResponse().setBody("this response comes via SSL"));
 
-    suppressTlsFallbackScsv(client.client());
-    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
-    connection = client.open(server.getUrl("/foo"));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .sslSocketFactory(suppressTlsFallbackClientSocketFactory(), sslClient.trustManager)
+        .build());
+    connection = urlFactory.open(server.url("/foo").url());
 
     assertContent("this response comes via SSL", connection);
 
-    RecordedRequest request = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
+    RecordedRequest failHandshakeRequest = server.takeRequest();
+    assertNull(failHandshakeRequest.getRequestLine());
+
+    RecordedRequest fallbackRequest = server.takeRequest();
+    assertEquals("GET /foo HTTP/1.1", fallbackRequest.getRequestLine());
+    assertEquals(TlsVersion.TLS_1_0, fallbackRequest.getTlsVersion());
+  }
+
+  @Test public void connectViaHttpsWithSSLFallbackFailuresRecorded() throws Exception {
+    server.useHttps(sslClient.socketFactory, false);
+    server.enqueue(new MockResponse().setSocketPolicy(FAIL_HANDSHAKE));
+    server.enqueue(new MockResponse().setSocketPolicy(FAIL_HANDSHAKE));
+
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .dns(new SingleInetAddressDns())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .sslSocketFactory(suppressTlsFallbackClientSocketFactory(), sslClient.trustManager)
+        .build());
+    connection = urlFactory.open(server.url("/foo").url());
+
+    try {
+      connection.getResponseCode();
+      fail();
+    } catch (IOException expected) {
+      assertEquals(1, expected.getSuppressed().length);
+    }
   }
 
   /**
-   * When a pooled connection fails, don't blame the route. Otherwise pooled
-   * connection failures can cause unnecessary SSL fallbacks.
+   * When a pooled connection fails, don't blame the route. Otherwise pooled connection failures can
+   * cause unnecessary SSL fallbacks.
    *
    * https://github.com/square/okhttp/issues/515
    */
   @Test public void sslFallbackNotUsedWhenRecycledConnectionFails() throws Exception {
-    server.get().useHttps(sslContext.getSocketFactory(), false);
+    server.useHttps(sslClient.socketFactory, false);
     server.enqueue(new MockResponse()
         .setBody("abc")
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END));
+        .setSocketPolicy(DISCONNECT_AT_END));
     server.enqueue(new MockResponse().setBody("def"));
 
-    suppressTlsFallbackScsv(client.client());
-    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .sslSocketFactory(suppressTlsFallbackClientSocketFactory(), sslClient.trustManager)
+        .build());
+
+    assertContent("abc", urlFactory.open(server.url("/").url()));
+
+    // Give the server time to disconnect.
+    Thread.sleep(500);
 
-    assertContent("abc", client.open(server.getUrl("/")));
-    assertContent("def", client.open(server.getUrl("/")));
+    assertContent("def", urlFactory.open(server.url("/").url()));
 
     Set<TlsVersion> tlsVersions =
         EnumSet.of(TlsVersion.TLS_1_0, TlsVersion.TLS_1_2); // v1.2 on OpenJDK 8.
@@ -650,10 +710,10 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
    * http://code.google.com/p/android/issues/detail?id=13178
    */
   @Test public void connectViaHttpsToUntrustedServer() throws IOException, InterruptedException {
-    server.get().useHttps(sslContext.getSocketFactory(), false);
+    server.useHttps(sslClient.socketFactory, false);
     server.enqueue(new MockResponse()); // unused
 
-    connection = client.open(server.getUrl("/foo"));
+    connection = urlFactory.open(server.url("/foo").url());
     try {
       connection.getInputStream();
       fail();
@@ -680,52 +740,81 @@ private void testConnectViaProxy(ProxyConfig proxyConfig) throws Exception {
     server.enqueue(mockResponse);
 
     URL url = new URL("http://android.com/foo");
-    connection = proxyConfig.connect(server.get(), client, url);
+    connection = proxyConfig.connect(server, urlFactory, url);
     assertContent("this response comes via a proxy", connection);
     assertTrue(connection.usingProxy());
 
-    RecordedRequest request = server.get().takeRequest();
+    RecordedRequest request = server.takeRequest();
     assertEquals("GET http://android.com/foo HTTP/1.1", request.getRequestLine());
     assertEquals("android.com", request.getHeader("Host"));
   }
 
-  @Test public void contentDisagreesWithContentLengthHeader() throws IOException {
+  @Test public void contentDisagreesWithContentLengthHeaderBodyTooLong() throws IOException {
     server.enqueue(new MockResponse().setBody("abc\r\nYOU SHOULD NOT SEE THIS")
         .clearHeaders()
         .addHeader("Content-Length: 3"));
-    assertContent("abc", client.open(server.getUrl("/")));
+    assertContent("abc", urlFactory.open(server.url("/").url()));
+  }
+
+  @Test public void contentDisagreesWithContentLengthHeaderBodyTooShort() throws IOException {
+    server.enqueue(new MockResponse().setBody("abc")
+        .setHeader("Content-Length", "5")
+        .setSocketPolicy(DISCONNECT_AT_END));
+    try {
+      readAscii(urlFactory.open(server.url("/").url()).getInputStream(), 5);
+      fail();
+    } catch (ProtocolException expected) {
+    }
   }
 
   public void testConnectViaSocketFactory(boolean useHttps) throws IOException {
     SocketFactory uselessSocketFactory = new SocketFactory() {
-      public Socket createSocket() { throw new IllegalArgumentException("useless"); }
-      public Socket createSocket(InetAddress host, int port) { return null; }
+      public Socket createSocket() {
+        throw new IllegalArgumentException("useless");
+      }
+
+      public Socket createSocket(InetAddress host, int port) {
+        return null;
+      }
+
       public Socket createSocket(InetAddress address, int port, InetAddress localAddress,
-          int localPort) { return null; }
-      public Socket createSocket(String host, int port) { return null; }
+          int localPort) {
+        return null;
+      }
+
+      public Socket createSocket(String host, int port) {
+        return null;
+      }
+
       public Socket createSocket(String host, int port, InetAddress localHost, int localPort) {
         return null;
       }
     };
 
     if (useHttps) {
-      server.get().useHttps(sslContext.getSocketFactory(), false);
-      client.client().setSslSocketFactory(sslContext.getSocketFactory());
-      client.client().setHostnameVerifier(new RecordingHostnameVerifier());
+      server.useHttps(sslClient.socketFactory, false);
+      urlFactory.setClient(urlFactory.client().newBuilder()
+          .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+          .hostnameVerifier(new RecordingHostnameVerifier())
+          .build());
     }
 
     server.enqueue(new MockResponse().setStatus("HTTP/1.1 200 OK"));
 
-    client.client().setSocketFactory(uselessSocketFactory);
-    connection = client.open(server.getUrl("/"));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .socketFactory(uselessSocketFactory)
+        .build());
+    connection = urlFactory.open(server.url("/").url());
     try {
       connection.getResponseCode();
       fail();
     } catch (IllegalArgumentException expected) {
     }
 
-    client.client().setSocketFactory(SocketFactory.getDefault());
-    connection = client.open(server.getUrl("/"));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .socketFactory(SocketFactory.getDefault())
+        .build());
+    connection = urlFactory.open(server.url("/").url());
     assertEquals(200, connection.getResponseCode());
   }
 
@@ -737,7 +826,7 @@ public Socket createSocket(String host, int port, InetAddress localHost, int loc
     testConnectViaSocketFactory(true);
   }
 
-  @Test public void contentDisagreesWithChunkedHeader() throws IOException {
+  @Test public void contentDisagreesWithChunkedHeaderBodyTooLong() throws IOException {
     MockResponse mockResponse = new MockResponse();
     mockResponse.setChunkedBody("abc", 3);
     Buffer buffer = mockResponse.getBody();
@@ -748,7 +837,29 @@ public Socket createSocket(String host, int port, InetAddress localHost, int loc
 
     server.enqueue(mockResponse);
 
-    assertContent("abc", client.open(server.getUrl("/")));
+    assertContent("abc", urlFactory.open(server.url("/").url()));
+  }
+
+  @Test public void contentDisagreesWithChunkedHeaderBodyTooShort() throws IOException {
+    MockResponse mockResponse = new MockResponse();
+    mockResponse.setChunkedBody("abcde", 5);
+
+    Buffer truncatedBody = new Buffer();
+    Buffer fullBody = mockResponse.getBody();
+    truncatedBody.write(fullBody, fullBody.indexOf((byte) 'e'));
+    mockResponse.setBody(truncatedBody);
+
+    mockResponse.clearHeaders();
+    mockResponse.addHeader("Transfer-encoding: chunked");
+    mockResponse.setSocketPolicy(DISCONNECT_AT_END);
+
+    server.enqueue(mockResponse);
+
+    try {
+      readAscii(urlFactory.open(server.url("/").url()).getInputStream(), 5);
+      fail();
+    } catch (ProtocolException expected) {
+    }
   }
 
   @Test public void connectViaHttpProxyToHttpsUsingProxyArgWithNoProxy() throws Exception {
@@ -761,13 +872,15 @@ public Socket createSocket(String host, int port, InetAddress localHost, int loc
   }
 
   private void testConnectViaDirectProxyToHttps(ProxyConfig proxyConfig) throws Exception {
-    server.get().useHttps(sslContext.getSocketFactory(), false);
+    server.useHttps(sslClient.socketFactory, false);
     server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
 
-    URL url = server.getUrl("/foo");
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
-    connection = proxyConfig.connect(server.get(), client, url);
+    URL url = server.url("/foo").url();
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build());
+    connection = proxyConfig.connect(server, urlFactory, url);
 
     assertContent("this response comes via HTTPS", connection);
 
@@ -780,8 +893,8 @@ private void testConnectViaDirectProxyToHttps(ProxyConfig proxyConfig) throws Ex
   }
 
   /**
-   * We weren't honoring all of the appropriate proxy system properties when
-   * connecting via HTTPS. http://b/3097518
+   * We weren't honoring all of the appropriate proxy system properties when connecting via HTTPS.
+   * http://b/3097518
    */
   @Test public void connectViaHttpProxyToHttpsUsingProxySystemProperty() throws Exception {
     testConnectViaHttpProxyToHttps(ProxyConfig.PROXY_SYSTEM_PROPERTY);
@@ -792,28 +905,30 @@ private void testConnectViaDirectProxyToHttps(ProxyConfig proxyConfig) throws Ex
   }
 
   /**
-   * We were verifying the wrong hostname when connecting to an HTTPS site
-   * through a proxy. http://b/3097277
+   * We were verifying the wrong hostname when connecting to an HTTPS site through a proxy.
+   * http://b/3097277
    */
   private void testConnectViaHttpProxyToHttps(ProxyConfig proxyConfig) throws Exception {
     RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
 
-    server.get().useHttps(sslContext.getSocketFactory(), true);
+    server.useHttps(sslClient.socketFactory, true);
     server.enqueue(
-        new MockResponse().setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END).clearHeaders());
+        new MockResponse().setSocketPolicy(UPGRADE_TO_SSL_AT_END).clearHeaders());
     server.enqueue(new MockResponse().setBody("this response comes via a secure proxy"));
 
     URL url = new URL("https://android.com/foo");
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setHostnameVerifier(hostnameVerifier);
-    connection = proxyConfig.connect(server.get(), client, url);
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(hostnameVerifier)
+        .build());
+    connection = proxyConfig.connect(server, urlFactory, url);
 
     assertContent("this response comes via a secure proxy", connection);
 
     RecordedRequest connect = server.takeRequest();
     assertEquals("Connect line failure on proxy", "CONNECT android.com:443 HTTP/1.1",
         connect.getRequestLine());
-    assertEquals("android.com", connect.getHeader("Host"));
+    assertEquals("android.com:443", connect.getHeader("Host"));
 
     RecordedRequest get = server.takeRequest();
     assertEquals("GET /foo HTTP/1.1", get.getRequestLine());
@@ -825,34 +940,38 @@ private void testConnectViaHttpProxyToHttps(ProxyConfig proxyConfig) throws Exce
   @Test public void connectViaHttpProxyToHttpsUsingBadProxyAndHttpResponseCache() throws Exception {
     initResponseCache();
 
-    server.get().useHttps(sslContext.getSocketFactory(), true);
+    server.useHttps(sslClient.socketFactory, true);
     // The inclusion of a body in the response to a CONNECT is key to reproducing b/6754912.
     MockResponse badProxyResponse = new MockResponse()
-        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
+        .setSocketPolicy(UPGRADE_TO_SSL_AT_END)
         .setBody("bogus proxy connect response content");
     server.enqueue(badProxyResponse);
     server.enqueue(new MockResponse().setBody("response"));
 
     // Configure a single IP address for the host and a single configuration, so we only need one
     // failure to fail permanently.
-    Internal.instance.setNetwork(client.client(), new SingleInetAddressNetwork());
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setConnectionSpecs(Util.immutableList(ConnectionSpec.MODERN_TLS));
-    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
-    client.client().setProxy(server.get().toProxyAddress());
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .dns(new SingleInetAddressDns())
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .connectionSpecs(Util.immutableList(ConnectionSpec.MODERN_TLS))
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .proxy(server.toProxyAddress())
+        .build());
 
     URL url = new URL("https://android.com/foo");
-    connection = client.open(url);
+    connection = urlFactory.open(url);
     assertContent("response", connection);
 
     RecordedRequest connect = server.takeRequest();
     assertEquals("CONNECT android.com:443 HTTP/1.1", connect.getRequestLine());
-    assertEquals("android.com", connect.getHeader("Host"));
+    assertEquals("android.com:443", connect.getHeader("Host"));
   }
 
   private void initResponseCache() throws IOException {
     cache = new Cache(tempDir.getRoot(), Integer.MAX_VALUE);
-    client.client().setCache(cache);
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .cache(cache)
+        .build());
   }
 
   /** Test which headers are sent unencrypted to the HTTP proxy. */
@@ -860,17 +979,19 @@ private void initResponseCache() throws IOException {
       throws IOException, InterruptedException {
     RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
 
-    server.get().useHttps(sslContext.getSocketFactory(), true);
+    server.useHttps(sslClient.socketFactory, true);
     server.enqueue(
-        new MockResponse().setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END).clearHeaders());
+        new MockResponse().setSocketPolicy(UPGRADE_TO_SSL_AT_END).clearHeaders());
     server.enqueue(new MockResponse().setBody("encrypted response from the origin server"));
 
-    client.client().setProxy(server.get().toProxyAddress());
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .proxy(server.toProxyAddress())
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(hostnameVerifier)
+        .build());
 
     URL url = new URL("https://android.com/foo");
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setHostnameVerifier(hostnameVerifier);
-    connection = client.open(url);
+    connection = urlFactory.open(url);
     connection.addRequestProperty("Private", "Secret");
     connection.addRequestProperty("Proxy-Authorization", "bar");
     connection.addRequestProperty("User-Agent", "baz");
@@ -878,9 +999,9 @@ private void initResponseCache() throws IOException {
 
     RecordedRequest connect = server.takeRequest();
     assertNull(connect.getHeader("Private"));
-    assertEquals("bar", connect.getHeader("Proxy-Authorization"));
-    assertEquals("baz", connect.getHeader("User-Agent"));
-    assertEquals("android.com", connect.getHeader("Host"));
+    assertNull(connect.getHeader("Proxy-Authorization"));
+    assertEquals(Version.userAgent(), connect.getHeader("User-Agent"));
+    assertEquals("android.com:443", connect.getHeader("Host"));
     assertEquals("Keep-Alive", connect.getHeader("Proxy-Connection"));
 
     RecordedRequest get = server.takeRequest();
@@ -890,19 +1011,22 @@ private void initResponseCache() throws IOException {
 
   @Test public void proxyAuthenticateOnConnect() throws Exception {
     Authenticator.setDefault(new RecordingAuthenticator());
-    server.get().useHttps(sslContext.getSocketFactory(), true);
+    server.useHttps(sslClient.socketFactory, true);
     server.enqueue(new MockResponse().setResponseCode(407)
         .addHeader("Proxy-Authenticate: Basic realm=\"localhost\""));
     server.enqueue(
-        new MockResponse().setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END).clearHeaders());
+        new MockResponse().setSocketPolicy(UPGRADE_TO_SSL_AT_END).clearHeaders());
     server.enqueue(new MockResponse().setBody("A"));
 
-    client.client().setProxy(server.get().toProxyAddress());
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .proxyAuthenticator(new JavaNetAuthenticator())
+        .proxy(server.toProxyAddress())
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build());
 
     URL url = new URL("https://android.com/foo");
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
-    connection = client.open(url);
+    connection = urlFactory.open(url);
     assertContent("A", connection);
 
     RecordedRequest connect1 = server.takeRequest();
@@ -922,39 +1046,42 @@ private void initResponseCache() throws IOException {
   // Don't disconnect after building a tunnel with CONNECT
   // http://code.google.com/p/android/issues/detail?id=37221
   @Test public void proxyWithConnectionClose() throws IOException {
-    server.get().useHttps(sslContext.getSocketFactory(), true);
+    server.useHttps(sslClient.socketFactory, true);
     server.enqueue(
-        new MockResponse().setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END).clearHeaders());
+        new MockResponse().setSocketPolicy(UPGRADE_TO_SSL_AT_END).clearHeaders());
     server.enqueue(new MockResponse().setBody("this response comes via a proxy"));
 
-    client.client().setProxy(server.get().toProxyAddress());
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .proxy(server.toProxyAddress())
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build());
 
     URL url = new URL("https://android.com/foo");
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
-    connection = client.open(url);
+    connection = urlFactory.open(url);
     connection.setRequestProperty("Connection", "close");
 
     assertContent("this response comes via a proxy", connection);
   }
 
   @Test public void proxyWithConnectionReuse() throws IOException {
-    SSLSocketFactory socketFactory = sslContext.getSocketFactory();
+    SSLSocketFactory socketFactory = sslClient.socketFactory;
     RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
 
-    server.get().useHttps(socketFactory, true);
+    server.useHttps(socketFactory, true);
     server.enqueue(
-        new MockResponse().setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END).clearHeaders());
+        new MockResponse().setSocketPolicy(UPGRADE_TO_SSL_AT_END).clearHeaders());
     server.enqueue(new MockResponse().setBody("response 1"));
     server.enqueue(new MockResponse().setBody("response 2"));
 
-    client.client().setProxy(server.get().toProxyAddress());
-
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .proxy(server.toProxyAddress())
+        .sslSocketFactory(socketFactory, sslClient.trustManager)
+        .hostnameVerifier(hostnameVerifier)
+        .build());
     URL url = new URL("https://android.com/foo");
-    client.client().setSslSocketFactory(socketFactory);
-    client.client().setHostnameVerifier(hostnameVerifier);
-    assertContent("response 1", client.open(url));
-    assertContent("response 2", client.open(url));
+    assertContent("response 1", urlFactory.open(url));
+    assertContent("response 2", urlFactory.open(url));
   }
 
   @Test public void disconnectedConnection() throws IOException {
@@ -962,7 +1089,7 @@ private void initResponseCache() throws IOException {
         .throttleBody(2, 100, TimeUnit.MILLISECONDS)
         .setBody("ABCD"));
 
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     InputStream in = connection.getInputStream();
     assertEquals('A', (char) in.read());
     connection.disconnect();
@@ -975,12 +1102,13 @@ private void initResponseCache() throws IOException {
       fail("Expected a connection closed exception");
     } catch (IOException expected) {
     }
+    in.close();
   }
 
   @Test public void disconnectBeforeConnect() throws IOException {
     server.enqueue(new MockResponse().setBody("A"));
 
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     connection.disconnect();
     assertContent("A", connection);
     assertEquals(200, connection.getResponseCode());
@@ -992,9 +1120,8 @@ private void initResponseCache() throws IOException {
   }
 
   /**
-   * Reads {@code count} characters from the stream. If the stream is
-   * exhausted before {@code count} characters can be read, the remaining
-   * characters are returned and the stream is closed.
+   * Reads {@code count} characters from the stream. If the stream is exhausted before {@code count}
+   * characters can be read, the remaining characters are returned and the stream is closed.
    */
   private String readAscii(InputStream in, int count) throws IOException {
     StringBuilder result = new StringBuilder();
@@ -1027,7 +1154,7 @@ private void testMarkAndReset(TransferKind transferKind) throws IOException {
     server.enqueue(response);
     server.enqueue(response);
 
-    InputStream in = client.open(server.getUrl("/")).getInputStream();
+    InputStream in = urlFactory.open(server.url("/").url()).getInputStream();
     assertFalse("This implementation claims to support mark().", in.markSupported());
     in.mark(5);
     assertEquals("ABCDE", readAscii(in, 5));
@@ -1037,13 +1164,13 @@ private void testMarkAndReset(TransferKind transferKind) throws IOException {
     } catch (IOException expected) {
     }
     assertEquals("FGHIJKLMNOPQRSTUVWXYZ", readAscii(in, Integer.MAX_VALUE));
-    assertContent("ABCDEFGHIJKLMNOPQRSTUVWXYZ", client.open(server.getUrl("/")));
+    in.close();
+    assertContent("ABCDEFGHIJKLMNOPQRSTUVWXYZ", urlFactory.open(server.url("/").url()));
   }
 
   /**
-   * We've had a bug where we forget the HTTP response when we see response
-   * code 401. This causes a new HTTP request to be issued for every call into
-   * the URLConnection.
+   * We've had a bug where we forget the HTTP response when we see response code 401. This causes a
+   * new HTTP request to be issued for every call into the URLConnection.
    */
   @Test public void unauthorizedResponseHandling() throws IOException {
     MockResponse response = new MockResponse().addHeader("WWW-Authenticate: challenge")
@@ -1053,13 +1180,14 @@ private void testMarkAndReset(TransferKind transferKind) throws IOException {
     server.enqueue(response);
     server.enqueue(response);
 
-    URL url = server.getUrl("/");
-    HttpURLConnection conn = client.open(url);
+    URL url = server.url("/").url();
+    HttpURLConnection conn = urlFactory.open(url);
 
     assertEquals(401, conn.getResponseCode());
     assertEquals(401, conn.getResponseCode());
     assertEquals(401, conn.getResponseCode());
     assertEquals(1, server.getRequestCount());
+    conn.getErrorStream().close();
   }
 
   @Test public void nonHexChunkSize() throws IOException {
@@ -1067,12 +1195,13 @@ private void testMarkAndReset(TransferKind transferKind) throws IOException {
         .clearHeaders()
         .addHeader("Transfer-encoding: chunked"));
 
-    URLConnection connection = client.open(server.getUrl("/"));
+    URLConnection connection = urlFactory.open(server.url("/").url());
     try {
       readAscii(connection.getInputStream(), Integer.MAX_VALUE);
       fail();
     } catch (IOException e) {
     }
+    connection.getInputStream().close();
   }
 
   @Test public void malformedChunkSize() throws IOException {
@@ -1080,11 +1209,13 @@ private void testMarkAndReset(TransferKind transferKind) throws IOException {
         .clearHeaders()
         .addHeader("Transfer-encoding: chunked"));
 
-    URLConnection connection = client.open(server.getUrl("/"));
+    URLConnection connection = urlFactory.open(server.url("/").url());
     try {
       readAscii(connection.getInputStream(), Integer.MAX_VALUE);
       fail();
     } catch (IOException e) {
+    } finally {
+      connection.getInputStream().close();
     }
   }
 
@@ -1093,7 +1224,7 @@ private void testMarkAndReset(TransferKind transferKind) throws IOException {
         .clearHeaders()
         .addHeader("Transfer-encoding: chunked"));
 
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    HttpURLConnection connection = urlFactory.open(server.url("/").url());
     assertContent("ABCDE", connection);
   }
 
@@ -1103,25 +1234,26 @@ private void testMarkAndReset(TransferKind transferKind) throws IOException {
         .addHeader("Transfer-encoding: chunked")
         .setSocketPolicy(DISCONNECT_AT_END));
 
-    URLConnection connection = client.open(server.getUrl("/"));
+    URLConnection connection = urlFactory.open(server.url("/").url());
     try {
       readAscii(connection.getInputStream(), Integer.MAX_VALUE);
       fail();
     } catch (IOException e) {
+    } finally {
+      connection.getInputStream().close();
     }
   }
 
   /**
-   * This test checks whether connections are gzipped by default. This
-   * behavior in not required by the API, so a failure of this test does not
-   * imply a bug in the implementation.
+   * This test checks whether connections are gzipped by default. This behavior in not required by
+   * the API, so a failure of this test does not imply a bug in the implementation.
    */
   @Test public void gzipEncodingEnabledByDefault() throws IOException, InterruptedException {
     server.enqueue(new MockResponse()
         .setBody(gzip("ABCABCABC"))
         .addHeader("Content-Encoding: gzip"));
 
-    URLConnection connection = client.open(server.getUrl("/"));
+    URLConnection connection = urlFactory.open(server.url("/").url());
     assertEquals("ABCABCABC", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
     assertNull(connection.getContentEncoding());
     assertEquals(-1, connection.getContentLength());
@@ -1136,7 +1268,7 @@ private void testMarkAndReset(TransferKind transferKind) throws IOException {
         .setBody(bodyBytes)
         .addHeader("Content-Encoding: gzip"));
 
-    URLConnection connection = client.open(server.getUrl("/"));
+    URLConnection connection = urlFactory.open(server.url("/").url());
     connection.addRequestProperty("Accept-Encoding", "gzip");
     InputStream gunzippedIn = new GZIPInputStream(connection.getInputStream());
     assertEquals("ABCDEFGHIJKLMNOPQRSTUVWXYZ", readAscii(gunzippedIn, Integer.MAX_VALUE));
@@ -1165,7 +1297,7 @@ private void testMarkAndReset(TransferKind transferKind) throws IOException {
   @Test public void clientConfiguredCustomContentEncoding() throws Exception {
     server.enqueue(new MockResponse().setBody("ABCDE").addHeader("Content-Encoding: custom"));
 
-    URLConnection connection = client.open(server.getUrl("/"));
+    URLConnection connection = urlFactory.open(server.url("/").url());
     connection.addRequestProperty("Accept-Encoding", "custom");
     assertEquals("ABCDE", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
 
@@ -1174,19 +1306,21 @@ private void testMarkAndReset(TransferKind transferKind) throws IOException {
   }
 
   /**
-   * Test a bug where gzip input streams weren't exhausting the input stream,
-   * which corrupted the request that followed or prevented connection reuse.
+   * Test a bug where gzip input streams weren't exhausting the input stream, which corrupted the
+   * request that followed or prevented connection reuse.
    * http://code.google.com/p/android/issues/detail?id=7059
    * http://code.google.com/p/android/issues/detail?id=38817
    */
   private void testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferKind transferKind,
       boolean tls) throws Exception {
     if (tls) {
-      SSLSocketFactory socketFactory = sslContext.getSocketFactory();
+      SSLSocketFactory socketFactory = sslClient.socketFactory;
       RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-      server.get().useHttps(socketFactory, false);
-      client.client().setSslSocketFactory(socketFactory);
-      client.client().setHostnameVerifier(hostnameVerifier);
+      server.useHttps(socketFactory, false);
+      urlFactory.setClient(urlFactory.client().newBuilder()
+          .sslSocketFactory(socketFactory, sslClient.trustManager)
+          .hostnameVerifier(hostnameVerifier)
+          .build());
     }
 
     MockResponse responseOne = new MockResponse();
@@ -1197,13 +1331,13 @@ private void testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferK
     transferKind.setBody(responseTwo, "two (identity)", 5);
     server.enqueue(responseTwo);
 
-    HttpURLConnection connection1 = client.open(server.getUrl("/"));
+    HttpURLConnection connection1 = urlFactory.open(server.url("/").url());
     connection1.addRequestProperty("Accept-Encoding", "gzip");
     InputStream gunzippedIn = new GZIPInputStream(connection1.getInputStream());
     assertEquals("one (gzipped)", readAscii(gunzippedIn, Integer.MAX_VALUE));
     assertEquals(0, server.takeRequest().getSequenceNumber());
 
-    HttpURLConnection connection2 = client.open(server.getUrl("/"));
+    HttpURLConnection connection2 = urlFactory.open(server.url("/").url());
     assertEquals("two (identity)", readAscii(connection2.getInputStream(), Integer.MAX_VALUE));
     assertEquals(1, server.takeRequest().getSequenceNumber());
   }
@@ -1217,28 +1351,28 @@ private void testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferK
         .setBody(gzip("b")));
 
     // Seed the pool with a bad connection.
-    assertContent("a", client.open(server.getUrl("/")));
+    assertContent("a", urlFactory.open(server.url("/").url()));
+
+    // Give the server time to disconnect.
+    Thread.sleep(500);
 
     // This connection will need to be recovered. When it is, transparent gzip should still work!
-    assertContent("b", client.open(server.getUrl("/")));
+    assertContent("b", urlFactory.open(server.url("/").url()));
 
     assertEquals(0, server.takeRequest().getSequenceNumber());
     assertEquals(0, server.takeRequest().getSequenceNumber()); // Connection is not pooled.
   }
 
   @Test public void endOfStreamResponseIsNotPooled() throws Exception {
+    urlFactory.client().connectionPool().evictAll();
     server.enqueue(new MockResponse()
         .setBody("{}")
         .clearHeaders()
         .setSocketPolicy(DISCONNECT_AT_END));
 
-    ConnectionPool pool = ConnectionPool.getDefault();
-    pool.evictAll();
-    client.client().setConnectionPool(pool);
-
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    HttpURLConnection connection = urlFactory.open(server.url("/").url());
     assertContent("{}", connection);
-    assertEquals(0, client.client().getConnectionPool().getConnectionCount());
+    assertEquals(0, urlFactory.client().connectionPool().idleConnectionCount());
   }
 
   @Test public void earlyDisconnectDoesntHarmPoolingWithChunkedEncoding() throws Exception {
@@ -1258,13 +1392,13 @@ private void testEarlyDisconnectDoesntHarmPooling(TransferKind transferKind) thr
     transferKind.setBody(response2, "LMNOPQRSTUV", 1024);
     server.enqueue(response2);
 
-    HttpURLConnection connection1 = client.open(server.getUrl("/"));
+    HttpURLConnection connection1 = urlFactory.open(server.url("/").url());
     InputStream in1 = connection1.getInputStream();
     assertEquals("ABCDE", readAscii(in1, 5));
     in1.close();
     connection1.disconnect();
 
-    HttpURLConnection connection2 = client.open(server.getUrl("/"));
+    HttpURLConnection connection2 = urlFactory.open(server.url("/").url());
     InputStream in2 = connection2.getInputStream();
     assertEquals("LMNOP", readAscii(in2, 5));
     in2.close();
@@ -1282,7 +1416,7 @@ private void testEarlyDisconnectDoesntHarmPooling(TransferKind transferKind) thr
     server.enqueue(new MockResponse().setBody("A"));
 
     long startNanos = System.nanoTime();
-    URLConnection connection1 = client.open(server.getUrl("/"));
+    URLConnection connection1 = urlFactory.open(server.url("/").url());
     InputStream in = connection1.getInputStream();
     in.close();
     long elapsedNanos = System.nanoTime() - startNanos;
@@ -1291,10 +1425,10 @@ private void testEarlyDisconnectDoesntHarmPooling(TransferKind transferKind) thr
     // If we're working correctly, this should be greater than 100ms, but less than double that.
     // Previously we had a bug where we would download the entire response body as long as no
     // individual read took longer than 100ms.
-    assertTrue(String.format("Time to close: %sms", elapsedMillis), elapsedMillis < 500);
+    assertTrue(Util.format("Time to close: %sms", elapsedMillis), elapsedMillis < 500);
 
     // Do another request to confirm that the discarded connection was not pooled.
-    assertContent("A", client.open(server.getUrl("/")));
+    assertContent("A", urlFactory.open(server.url("/").url()));
 
     assertEquals(0, server.takeRequest().getSequenceNumber());
     assertEquals(0, server.takeRequest().getSequenceNumber()); // Connection is not pooled.
@@ -1304,12 +1438,13 @@ private void testEarlyDisconnectDoesntHarmPooling(TransferKind transferKind) thr
     server.enqueue(new MockResponse());
 
     String body = "ABCDEFGHIJKLMNOPQ";
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     connection.setChunkedStreamingMode(0); // OkHttp does not honor specific chunk sizes.
     connection.setDoOutput(true);
     OutputStream outputStream = connection.getOutputStream();
     outputStream.write(body.getBytes("US-ASCII"));
     assertEquals(200, connection.getResponseCode());
+    connection.getInputStream().close();
 
     RecordedRequest request = server.takeRequest();
     assertEquals(body, request.getBody().readUtf8());
@@ -1331,9 +1466,12 @@ private void testAuthenticateWithStreamingPost(StreamingMode streamingMode) thro
     server.enqueue(pleaseAuthenticate);
 
     Authenticator.setDefault(new RecordingAuthenticator());
-    connection = client.open(server.getUrl("/"));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .authenticator(new JavaNetAuthenticator())
+        .build());
+    connection = urlFactory.open(server.url("/").url());
     connection.setDoOutput(true);
-    byte[] requestBody = { 'A', 'B', 'C', 'D' };
+    byte[] requestBody = {'A', 'B', 'C', 'D'};
     if (streamingMode == StreamingMode.FIXED_LENGTH) {
       connection.setFixedLengthStreamingMode(requestBody.length);
     } else if (streamingMode == StreamingMode.CHUNKED) {
@@ -1388,9 +1526,11 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     server.enqueue(new MockResponse());
 
     String credential = Credentials.basic("jesse", "secret");
-    client.client().setAuthenticator(new RecordingOkAuthenticator(credential));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .authenticator(new RecordingOkAuthenticator(credential))
+        .build());
 
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     connection.setDoOutput(true);
     OutputStream outputStream = connection.getOutputStream();
     outputStream.write(body.getBytes("UTF-8"));
@@ -1431,7 +1571,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
   @Test public void allAttributesSetInServerAuthenticationCallbacks() throws Exception {
     List<String> calls = authCallsForHeader("WWW-Authenticate: Basic realm=\"Bar\"");
     assertEquals(1, calls.size());
-    URL url = server.getUrl("/");
+    URL url = server.url("/").url();
     String call = calls.get(0);
     assertTrue(call, call.contains("host=" + url.getHost()));
     assertTrue(call, call.contains("port=" + url.getPort()));
@@ -1446,7 +1586,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
   @Test public void allAttributesSetInProxyAuthenticationCallbacks() throws Exception {
     List<String> calls = authCallsForHeader("Proxy-Authenticate: Basic realm=\"Bar\"");
     assertEquals(1, calls.size());
-    URL url = server.getUrl("/");
+    URL url = server.url("/").url();
     String call = calls.get(0);
     assertTrue(call, call.contains("host=" + url.getHost()));
     assertTrue(call, call.contains("port=" + url.getPort()));
@@ -1463,18 +1603,26 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     int responseCode = proxy ? 407 : 401;
     RecordingAuthenticator authenticator = new RecordingAuthenticator(null);
     Authenticator.setDefault(authenticator);
-    MockResponse pleaseAuthenticate = new MockResponse().setResponseCode(responseCode)
+    MockResponse pleaseAuthenticate = new MockResponse()
+        .setResponseCode(responseCode)
         .addHeader(authHeader)
         .setBody("Please authenticate.");
     server.enqueue(pleaseAuthenticate);
 
     if (proxy) {
-      client.client().setProxy(server.get().toProxyAddress());
-      connection = client.open(new URL("http://android.com"));
+      urlFactory.setClient(urlFactory.client().newBuilder()
+          .proxy(server.toProxyAddress())
+          .proxyAuthenticator(new JavaNetAuthenticator())
+          .build());
+      connection = urlFactory.open(new URL("http://android.com/"));
     } else {
-      connection = client.open(server.getUrl("/"));
+      urlFactory.setClient(urlFactory.client().newBuilder()
+          .authenticator(new JavaNetAuthenticator())
+          .build());
+      connection = urlFactory.open(server.url("/").url());
     }
     assertEquals(responseCode, connection.getResponseCode());
+    connection.getErrorStream().close();
     return authenticator.calls;
   }
 
@@ -1490,7 +1638,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
   }
 
   private void assertValidRequestMethod(String requestMethod) throws Exception {
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     connection.setRequestMethod(requestMethod);
     assertEquals(requestMethod, connection.getRequestMethod());
   }
@@ -1504,7 +1652,7 @@ private void assertValidRequestMethod(String requestMethod) throws Exception {
   }
 
   private void assertInvalidRequestMethod(String requestMethod) throws Exception {
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     try {
       connection.setRequestMethod(requestMethod);
       fail();
@@ -1531,14 +1679,14 @@ private void assertInvalidRequestMethod(String requestMethod) throws Exception {
         .addHeader("Expires: Mon, 26 Jul 1997 05:00:00 GMT")
         .addHeader("icy-metaint:16000")
         .setBody("mp3 data"));
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     assertEquals(200, connection.getResponseCode());
     assertEquals("OK", connection.getResponseMessage());
     assertContent("mp3 data", connection);
   }
 
   @Test public void cannotSetNegativeFixedLengthStreamingMode() throws Exception {
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     try {
       connection.setFixedLengthStreamingMode(-2);
       fail();
@@ -1547,13 +1695,13 @@ private void assertInvalidRequestMethod(String requestMethod) throws Exception {
   }
 
   @Test public void canSetNegativeChunkedStreamingMode() throws Exception {
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     connection.setChunkedStreamingMode(-2);
   }
 
   @Test public void cannotSetFixedLengthStreamingModeAfterConnect() throws Exception {
     server.enqueue(new MockResponse().setBody("A"));
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     assertEquals("A", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
     try {
       connection.setFixedLengthStreamingMode(1);
@@ -1564,7 +1712,7 @@ private void assertInvalidRequestMethod(String requestMethod) throws Exception {
 
   @Test public void cannotSetChunkedStreamingModeAfterConnect() throws Exception {
     server.enqueue(new MockResponse().setBody("A"));
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     assertEquals("A", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
     try {
       connection.setChunkedStreamingMode(1);
@@ -1574,7 +1722,7 @@ private void assertInvalidRequestMethod(String requestMethod) throws Exception {
   }
 
   @Test public void cannotSetFixedLengthStreamingModeAfterChunkedStreamingMode() throws Exception {
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     connection.setChunkedStreamingMode(1);
     try {
       connection.setFixedLengthStreamingMode(1);
@@ -1584,7 +1732,7 @@ private void assertInvalidRequestMethod(String requestMethod) throws Exception {
   }
 
   @Test public void cannotSetChunkedStreamingModeAfterFixedLengthStreamingMode() throws Exception {
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     connection.setFixedLengthStreamingMode(1);
     try {
       connection.setChunkedStreamingMode(1);
@@ -1606,14 +1754,16 @@ private void assertInvalidRequestMethod(String requestMethod) throws Exception {
    * http://code.google.com/p/android/issues/detail?id=12860
    */
   private void testSecureStreamingPost(StreamingMode streamingMode) throws Exception {
-    server.get().useHttps(sslContext.getSocketFactory(), false);
+    server.useHttps(sslClient.socketFactory, false);
     server.enqueue(new MockResponse().setBody("Success!"));
 
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
-    connection = client.open(server.getUrl("/"));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build());
+    connection = urlFactory.open(server.url("/").url());
     connection.setDoOutput(true);
-    byte[] requestBody = { 'A', 'B', 'C', 'D' };
+    byte[] requestBody = {'A', 'B', 'C', 'D'};
     if (streamingMode == StreamingMode.FIXED_LENGTH) {
       connection.setFixedLengthStreamingMode(requestBody.length);
     } else if (streamingMode == StreamingMode.CHUNKED) {
@@ -1650,9 +1800,12 @@ private void testSecureStreamingPost(StreamingMode streamingMode) throws Excepti
     server.enqueue(new MockResponse().setBody("Successful auth!"));
 
     Authenticator.setDefault(new RecordingAuthenticator());
-    connection = client.open(server.getUrl("/"));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .authenticator(new JavaNetAuthenticator())
+        .build());
+    connection = urlFactory.open(server.url("/").url());
     connection.setDoOutput(true);
-    byte[] requestBody = { 'A', 'B', 'C', 'D' };
+    byte[] requestBody = {'A', 'B', 'C', 'D'};
     OutputStream outputStream = connection.getOutputStream();
     outputStream.write(requestBody);
     outputStream.close();
@@ -1684,7 +1837,10 @@ private void testSecureStreamingPost(StreamingMode streamingMode) throws Excepti
     server.enqueue(new MockResponse().setBody("Successful auth!"));
 
     Authenticator.setDefault(new RecordingAuthenticator());
-    connection = client.open(server.getUrl("/"));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .authenticator(new JavaNetAuthenticator())
+        .build());
+    connection = urlFactory.open(server.url("/").url());
     assertEquals("Successful auth!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
 
     // no authorization header for the first request...
@@ -1716,7 +1872,10 @@ private void testSecureStreamingPost(StreamingMode streamingMode) throws Excepti
     server.enqueue(successfulResponse);
 
     Authenticator.setDefault(new RecordingAuthenticator());
-    connection = client.open(server.getUrl("/"));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .authenticator(new JavaNetAuthenticator())
+        .build());
+    connection = urlFactory.open(server.url("/").url());
     assertEquals("Successful auth!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
 
     // no authorization header for the first request...
@@ -1740,7 +1899,10 @@ private void testSecureStreamingPost(StreamingMode streamingMode) throws Excepti
     server.enqueue(new MockResponse().setBody("Successful auth!"));
 
     Authenticator.setDefault(new RecordingAuthenticator());
-    connection = client.open(server.getUrl("/"));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .authenticator(new JavaNetAuthenticator())
+        .build());
+    connection = urlFactory.open(server.url("/").url());
     assertEquals("Successful auth!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
   }
 
@@ -1763,7 +1925,7 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
     server.enqueue(response);
     server.enqueue(new MockResponse().setBody("This is the new location!"));
 
-    URLConnection connection = client.open(server.getUrl("/"));
+    URLConnection connection = urlFactory.open(server.url("/").url());
     assertEquals("This is the new location!",
         readAscii(connection.getInputStream(), Integer.MAX_VALUE));
 
@@ -1777,15 +1939,17 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
   }
 
   @Test public void redirectedOnHttps() throws IOException, InterruptedException {
-    server.get().useHttps(sslContext.getSocketFactory(), false);
+    server.useHttps(sslClient.socketFactory, false);
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
         .addHeader("Location: /foo")
         .setBody("This page has moved!"));
     server.enqueue(new MockResponse().setBody("This is the new location!"));
 
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
-    connection = client.open(server.getUrl("/"));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build());
+    connection = urlFactory.open(server.url("/").url());
     assertEquals("This is the new location!",
         readAscii(connection.getInputStream(), Integer.MAX_VALUE));
 
@@ -1797,15 +1961,17 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
   }
 
   @Test public void notRedirectedFromHttpsToHttp() throws IOException, InterruptedException {
-    server.get().useHttps(sslContext.getSocketFactory(), false);
+    server.useHttps(sslClient.socketFactory, false);
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
         .addHeader("Location: http://anyhost/foo")
         .setBody("This page has moved!"));
 
-    client.client().setFollowSslRedirects(false);
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
-    connection = client.open(server.getUrl("/"));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .followSslRedirects(false)
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build());
+    connection = urlFactory.open(server.url("/").url());
     assertEquals("This page has moved!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
   }
 
@@ -1814,23 +1980,27 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
         .addHeader("Location: https://anyhost/foo")
         .setBody("This page has moved!"));
 
-    client.client().setFollowSslRedirects(false);
-    connection = client.open(server.getUrl("/"));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .followSslRedirects(false)
+        .build());
+    connection = urlFactory.open(server.url("/").url());
     assertEquals("This page has moved!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
   }
 
   @Test public void redirectedFromHttpsToHttpFollowingProtocolRedirects() throws Exception {
     server2.enqueue(new MockResponse().setBody("This is insecure HTTP!"));
 
-    server.get().useHttps(sslContext.getSocketFactory(), false);
+    server.useHttps(sslClient.socketFactory, false);
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: " + server2.getUrl("/"))
+        .addHeader("Location: " + server2.url("/").url())
         .setBody("This page has moved!"));
 
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
-    client.client().setFollowSslRedirects(true);
-    HttpsURLConnection connection = (HttpsURLConnection) client.open(server.getUrl("/"));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .followSslRedirects(true)
+        .build());
+    HttpsURLConnection connection = (HttpsURLConnection) urlFactory.open(server.url("/").url());
     assertContent("This is insecure HTTP!", connection);
     assertNull(connection.getCipherSuite());
     assertNull(connection.getLocalCertificates());
@@ -1840,17 +2010,19 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
   }
 
   @Test public void redirectedFromHttpToHttpsFollowingProtocolRedirects() throws Exception {
-    server2.get().useHttps(sslContext.getSocketFactory(), false);
+    server2.useHttps(sslClient.socketFactory, false);
     server2.enqueue(new MockResponse().setBody("This is secure HTTPS!"));
 
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: " + server2.getUrl("/"))
+        .addHeader("Location: " + server2.url("/").url())
         .setBody("This page has moved!"));
 
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
-    client.client().setFollowSslRedirects(true);
-    connection = client.open(server.getUrl("/"));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .followSslRedirects(true)
+        .build());
+    connection = urlFactory.open(server.url("/").url());
     assertContent("This is secure HTTPS!", connection);
     assertFalse(connection instanceof HttpsURLConnection);
   }
@@ -1865,31 +2037,33 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
 
   private void redirectToAnotherOriginServer(boolean https) throws Exception {
     if (https) {
-      server.get().useHttps(sslContext.getSocketFactory(), false);
-      server2.get().useHttps(sslContext.getSocketFactory(), false);
-      server2.get().setProtocolNegotiationEnabled(false);
-      client.client().setSslSocketFactory(sslContext.getSocketFactory());
-      client.client().setHostnameVerifier(new RecordingHostnameVerifier());
+      server.useHttps(sslClient.socketFactory, false);
+      server2.useHttps(sslClient.socketFactory, false);
+      server2.setProtocolNegotiationEnabled(false);
+      urlFactory.setClient(urlFactory.client().newBuilder()
+          .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+          .hostnameVerifier(new RecordingHostnameVerifier())
+          .build());
     }
 
     server2.enqueue(new MockResponse().setBody("This is the 2nd server!"));
     server2.enqueue(new MockResponse().setBody("This is the 2nd server, again!"));
 
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: " + server2.getUrl("/").toString())
+        .addHeader("Location: " + server2.url("/").url().toString())
         .setBody("This page has moved!"));
     server.enqueue(new MockResponse().setBody("This is the first server again!"));
 
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     assertContent("This is the 2nd server!", connection);
-    assertEquals(server2.getUrl("/"), connection.getURL());
+    assertEquals(server2.url("/").url(), connection.getURL());
 
     // make sure the first server was careful to recycle the connection
-    assertContent("This is the first server again!", client.open(server.getUrl("/")));
-    assertContent("This is the 2nd server, again!", client.open(server2.getUrl("/")));
+    assertContent("This is the first server again!", urlFactory.open(server.url("/").url()));
+    assertContent("This is the 2nd server, again!", urlFactory.open(server2.url("/").url()));
 
-    String server1Host = server.get().getHostName() + ":" + server.getPort();
-    String server2Host = server2.get().getHostName() + ":" + server2.getPort();
+    String server1Host = server.getHostName() + ":" + server.getPort();
+    String server2Host = server2.getHostName() + ":" + server2.getPort();
     assertEquals(server1Host, server.takeRequest().getHeader("Host"));
     assertEquals(server2Host, server2.takeRequest().getHeader("Host"));
     assertEquals("Expected connection reuse", 1, server.takeRequest().getSequenceNumber());
@@ -1898,29 +2072,31 @@ private void redirectToAnotherOriginServer(boolean https) throws Exception {
 
   @Test public void redirectWithProxySelector() throws Exception {
     final List<URI> proxySelectionRequests = new ArrayList<URI>();
-    client.client().setProxySelector(new ProxySelector() {
-      @Override public List<Proxy> select(URI uri) {
-        proxySelectionRequests.add(uri);
-        MockWebServer proxyServer = (uri.getPort() == server.get().getPort())
-            ? server.get()
-            : server2.get();
-        return Arrays.asList(proxyServer.toProxyAddress());
-      }
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .proxySelector(new ProxySelector() {
+          @Override public List<Proxy> select(URI uri) {
+            proxySelectionRequests.add(uri);
+            MockWebServer proxyServer = (uri.getPort() == server.getPort())
+                ? server
+                : server2;
+            return Arrays.asList(proxyServer.toProxyAddress());
+          }
 
-      @Override public void connectFailed(URI uri, SocketAddress address, IOException failure) {
-        throw new AssertionError();
-      }
-    });
+          @Override public void connectFailed(URI uri, SocketAddress address, IOException failure) {
+            throw new AssertionError();
+          }
+        })
+        .build());
 
     server2.enqueue(new MockResponse().setBody("This is the 2nd server!"));
 
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: " + server2.getUrl("/b").toString())
+        .addHeader("Location: " + server2.url("/b").url().toString())
         .setBody("This page has moved!"));
 
-    assertContent("This is the 2nd server!", client.open(server.getUrl("/a")));
+    assertContent("This is the 2nd server!", urlFactory.open(server.url("/a").url()));
 
-    assertEquals(Arrays.asList(server.getUrl("/a").toURI(), server2.getUrl("/b").toURI()),
+    assertEquals(Arrays.asList(server.url("/").url().toURI(), server2.url("/").url().toURI()),
         proxySelectionRequests);
   }
 
@@ -1929,11 +2105,12 @@ private void redirectToAnotherOriginServer(boolean https) throws Exception {
 
     server.enqueue(new MockResponse().setResponseCode(401));
     server.enqueue(new MockResponse().setResponseCode(302)
-        .addHeader("Location: " + server2.getUrl("/b")));
+        .addHeader("Location: " + server2.url("/b").url()));
 
-    client.client().setAuthenticator(
-        new RecordingOkAuthenticator(Credentials.basic("jesse", "secret")));
-    assertContent("Page 2", client.open(server.getUrl("/a")));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .authenticator(new RecordingOkAuthenticator(Credentials.basic("jesse", "secret")))
+        .build());
+    assertContent("Page 2", urlFactory.open(server.url("/a").url()));
 
     RecordedRequest redirectRequest = server2.takeRequest();
     assertNull(redirectRequest.getHeader("Authorization"));
@@ -1972,10 +2149,10 @@ private void testResponseRedirectedWithPost(int redirectCode, TransferKind trans
         .setBody("This page has moved!"));
     server.enqueue(new MockResponse().setBody("Page 2"));
 
-    connection = client.open(server.getUrl("/page1"));
+    connection = urlFactory.open(server.url("/page1").url());
     connection.setDoOutput(true);
     transferKind.setForRequest(connection, 4);
-    byte[] requestBody = { 'A', 'B', 'C', 'D' };
+    byte[] requestBody = {'A', 'B', 'C', 'D'};
     OutputStream outputStream = connection.getOutputStream();
     outputStream.write(requestBody);
     outputStream.close();
@@ -1995,7 +2172,7 @@ private void testResponseRedirectedWithPost(int redirectCode, TransferKind trans
         .addHeader("Location: /page2"));
     server.enqueue(new MockResponse().setBody("Page 2"));
 
-    connection = client.open(server.getUrl("/page1"));
+    connection = urlFactory.open(server.url("/page1").url());
     connection.setDoOutput(true);
     connection.addRequestProperty("Content-Length", "4");
     connection.addRequestProperty("Content-Type", "text/plain; charset=utf-8");
@@ -2016,11 +2193,11 @@ private void testResponseRedirectedWithPost(int redirectCode, TransferKind trans
 
   @Test public void response305UseProxy() throws Exception {
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_USE_PROXY)
-        .addHeader("Location: " + server.getUrl("/"))
+        .addHeader("Location: " + server.url("/").url())
         .setBody("This page has moved!"));
     server.enqueue(new MockResponse().setBody("Proxy Response"));
 
-    connection = client.open(server.getUrl("/foo"));
+    connection = urlFactory.open(server.url("/foo").url());
     // Fails on the RI, which gets "Proxy Response"
     assertEquals("This page has moved!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
 
@@ -2071,9 +2248,9 @@ private void testRedirect(boolean temporary, String method) throws Exception {
     server.enqueue(response1);
     server.enqueue(new MockResponse().setBody("Page 2"));
 
-    connection = client.open(server.getUrl("/page1"));
+    connection = urlFactory.open(server.url("/page1").url());
     connection.setRequestMethod(method);
-    byte[] requestBody = { 'A', 'B', 'C', 'D' };
+    byte[] requestBody = {'A', 'B', 'C', 'D'};
     if (method.equals("POST")) {
       connection.setDoOutput(true);
       OutputStream outputStream = connection.getOutputStream();
@@ -2088,7 +2265,7 @@ private void testRedirect(boolean temporary, String method) throws Exception {
 
     if (method.equals("GET")) {
       assertEquals("Page 2", response);
-    } else if (method.equals("HEAD"))  {
+    } else if (method.equals("HEAD")) {
       assertEquals("", response);
     } else {
       // Methods other than GET/HEAD shouldn't follow the redirect
@@ -2116,9 +2293,9 @@ private void testRedirect(boolean temporary, String method) throws Exception {
     }
     server.enqueue(new MockResponse().setBody("Success!"));
 
-    connection = client.open(server.getUrl("/0"));
+    connection = urlFactory.open(server.url("/0").url());
     assertContent("Success!", connection);
-    assertEquals(server.getUrl("/20"), connection.getURL());
+    assertEquals(server.url("/20").url(), connection.getURL());
   }
 
   @Test public void doesNotFollow21Redirects() throws Exception {
@@ -2128,42 +2305,89 @@ private void testRedirect(boolean temporary, String method) throws Exception {
           .setBody("Redirecting to /" + (i + 1)));
     }
 
-    connection = client.open(server.getUrl("/0"));
+    connection = urlFactory.open(server.url("/0").url());
     try {
       connection.getInputStream();
       fail();
     } catch (ProtocolException expected) {
       assertEquals(HttpURLConnection.HTTP_MOVED_TEMP, connection.getResponseCode());
       assertEquals("Too many follow-up requests: 21", expected.getMessage());
-      assertContent("Redirecting to /21", connection);
-      assertEquals(server.getUrl("/20"), connection.getURL());
+      assertEquals(server.url("/20").url(), connection.getURL());
     }
   }
 
   @Test public void httpsWithCustomTrustManager() throws Exception {
     RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-    RecordingTrustManager trustManager = new RecordingTrustManager();
-    SSLContext sc = SSLContext.getInstance("TLS");
-    sc.init(null, new TrustManager[] { trustManager }, new java.security.SecureRandom());
-
-    client.client().setHostnameVerifier(hostnameVerifier);
-    client.client().setSslSocketFactory(sc.getSocketFactory());
-    server.get().useHttps(sslContext.getSocketFactory(), false);
+    RecordingTrustManager trustManager = new RecordingTrustManager(sslClient.trustManager);
+    SSLContext sslContext = SSLContext.getInstance("TLS");
+    sslContext.init(null, new TrustManager[] { trustManager }, null);
+
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .hostnameVerifier(hostnameVerifier)
+        .sslSocketFactory(sslContext.getSocketFactory(), trustManager)
+        .build());
+    server.useHttps(sslClient.socketFactory, false);
     server.enqueue(new MockResponse().setBody("ABC"));
     server.enqueue(new MockResponse().setBody("DEF"));
     server.enqueue(new MockResponse().setBody("GHI"));
 
-    URL url = server.getUrl("/");
-    assertContent("ABC", client.open(url));
-    assertContent("DEF", client.open(url));
-    assertContent("GHI", client.open(url));
+    URL url = server.url("/").url();
+    assertContent("ABC", urlFactory.open(url));
+    assertContent("DEF", urlFactory.open(url));
+    assertContent("GHI", urlFactory.open(url));
 
-    assertEquals(Arrays.asList("verify " + server.get().getHostName()),
-        hostnameVerifier.calls);
-    assertEquals(Arrays.asList("checkServerTrusted [CN=" + server.get().getHostName() + " 1]"),
+    assertEquals(Arrays.asList("verify " + server.getHostName()), hostnameVerifier.calls);
+    assertEquals(Arrays.asList("checkServerTrusted [CN=" + server.getHostName() + " 1]"),
         trustManager.calls);
   }
 
+  @Test public void getClientRequestTimeout() throws Exception {
+    enqueueClientRequestTimeoutResponses();
+
+    HttpURLConnection connection = urlFactory.open(server.url("/").url());
+
+    assertEquals(200, connection.getResponseCode());
+    assertEquals("Body", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
+  }
+
+  private void enqueueClientRequestTimeoutResponses() {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
+        .setResponseCode(HttpURLConnection.HTTP_CLIENT_TIMEOUT)
+        .setHeader("Connection", "Close")
+        .setBody("You took too long!"));
+    server.enqueue(new MockResponse().setBody("Body"));
+  }
+
+  @Test public void bufferedBodyWithClientRequestTimeout() throws Exception {
+    enqueueClientRequestTimeoutResponses();
+
+    HttpURLConnection connection = urlFactory.open(server.url("/").url());
+    connection.setRequestMethod("POST");
+    connection.getOutputStream().write("Hello".getBytes("UTF-8"));
+
+    assertEquals(200, connection.getResponseCode());
+    assertEquals("Body", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
+
+    RecordedRequest request1 = server.takeRequest();
+    assertEquals("Hello", request1.getBody().readUtf8());
+
+    RecordedRequest request2 = server.takeRequest();
+    assertEquals("Hello", request2.getBody().readUtf8());
+  }
+
+  @Test public void streamedBodyWithClientRequestTimeout() throws Exception {
+    enqueueClientRequestTimeoutResponses();
+
+    HttpURLConnection connection = urlFactory.open(server.url("/").url());
+    connection.setRequestMethod("POST");
+    connection.setChunkedStreamingMode(0);
+    connection.getOutputStream().write("Hello".getBytes("UTF-8"));
+
+    assertEquals(408, connection.getResponseCode());
+    assertEquals(1, server.getRequestCount());
+  }
+
   @Test public void readTimeouts() throws IOException {
     // This relies on the fact that MockWebServer doesn't close the
     // connection after a response has been sent. This causes the client to
@@ -2173,7 +2397,7 @@ private void testRedirect(boolean temporary, String method) throws Exception {
     server.enqueue(timeout);
     server.enqueue(new MockResponse().setBody("unused")); // to keep the server alive
 
-    URLConnection connection = client.open(server.getUrl("/"));
+    URLConnection connection = urlFactory.open(server.url("/").url());
     connection.setReadTimeout(1000);
     InputStream in = connection.getInputStream();
     assertEquals('A', in.read());
@@ -2182,50 +2406,57 @@ private void testRedirect(boolean temporary, String method) throws Exception {
     try {
       in.read(); // if Content-Length was accurate, this would return -1 immediately
       fail();
-    } catch (IOException expected) {
+    } catch (SocketTimeoutException expected) {
     }
+    in.close();
   }
 
   /** Confirm that an unacknowledged write times out. */
   @Test public void writeTimeouts() throws IOException {
+    MockWebServer server = new MockWebServer();
     // Sockets on some platforms can have large buffers that mean writes do not block when
     // required. These socket factories explicitly set the buffer sizes on sockets created.
-    final int SOCKET_BUFFER_SIZE = 256 * 1024;
-    server.get().setServerSocketFactory(
+    final int SOCKET_BUFFER_SIZE = 4 * 1024;
+    server.setServerSocketFactory(
         new DelegatingServerSocketFactory(ServerSocketFactory.getDefault()) {
           @Override
-          protected void configureServerSocket(ServerSocket serverSocket) throws IOException {
+          protected ServerSocket configureServerSocket(ServerSocket serverSocket)
+              throws IOException {
             serverSocket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
+            return serverSocket;
           }
         });
-    client.client().setSocketFactory(new DelegatingSocketFactory(SocketFactory.getDefault()) {
-      @Override
-      protected void configureSocket(Socket socket) throws IOException {
-        socket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
-        socket.setSendBufferSize(SOCKET_BUFFER_SIZE);
-      }
-    });
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .socketFactory(new DelegatingSocketFactory(SocketFactory.getDefault()) {
+          @Override protected Socket configureSocket(Socket socket) throws IOException {
+            socket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
+            socket.setSendBufferSize(SOCKET_BUFFER_SIZE);
+            return socket;
+          }
+        })
+        .writeTimeout(500, TimeUnit.MILLISECONDS)
+        .build());
 
+    server.start();
     server.enqueue(new MockResponse()
         .throttleBody(1, 1, TimeUnit.SECONDS)); // Prevent the server from reading!
 
-    client.client().setWriteTimeout(500, TimeUnit.MILLISECONDS);
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     connection.setDoOutput(true);
     connection.setChunkedStreamingMode(0);
     OutputStream out = connection.getOutputStream();
     try {
-      byte[] data = new byte[16 * 1024 * 1024]; // 16 MiB.
+      byte[] data = new byte[2 * 1024 * 1024]; // 2 MiB.
       out.write(data);
       fail();
-    } catch (IOException expected) {
+    } catch (SocketTimeoutException expected) {
     }
   }
 
   @Test public void setChunkedEncodingAsRequestProperty() throws IOException, InterruptedException {
     server.enqueue(new MockResponse());
 
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     connection.setRequestProperty("Transfer-encoding", "chunked");
     connection.setDoOutput(true);
     connection.getOutputStream().write("ABC".getBytes("UTF-8"));
@@ -2239,11 +2470,11 @@ protected void configureSocket(Socket socket) throws IOException {
     server.enqueue(new MockResponse()); // server doesn't honor the connection: close header!
     server.enqueue(new MockResponse());
 
-    HttpURLConnection a = client.open(server.getUrl("/"));
+    HttpURLConnection a = urlFactory.open(server.url("/").url());
     a.setRequestProperty("Connection", "close");
     assertEquals(200, a.getResponseCode());
 
-    HttpURLConnection b = client.open(server.getUrl("/"));
+    HttpURLConnection b = urlFactory.open(server.url("/").url());
     assertEquals(200, b.getResponseCode());
 
     assertEquals(0, server.takeRequest().getSequenceNumber());
@@ -2255,10 +2486,10 @@ protected void configureSocket(Socket socket) throws IOException {
     server.enqueue(new MockResponse().addHeader("Connection: close"));
     server.enqueue(new MockResponse());
 
-    HttpURLConnection a = client.open(server.getUrl("/"));
+    HttpURLConnection a = urlFactory.open(server.url("/").url());
     assertEquals(200, a.getResponseCode());
 
-    HttpURLConnection b = client.open(server.getUrl("/"));
+    HttpURLConnection b = urlFactory.open(server.url("/").url());
     assertEquals(200, b.getResponseCode());
 
     assertEquals(0, server.takeRequest().getSequenceNumber());
@@ -2267,13 +2498,15 @@ protected void configureSocket(Socket socket) throws IOException {
   }
 
   @Test public void connectionCloseWithRedirect() throws IOException, InterruptedException {
-    MockResponse response = new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+    MockResponse response = new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
         .addHeader("Location: /foo")
         .addHeader("Connection: close");
     server.enqueue(response);
-    server.enqueue(new MockResponse().setBody("This is the new location!"));
+    server.enqueue(new MockResponse()
+        .setBody("This is the new location!"));
 
-    URLConnection connection = client.open(server.getUrl("/"));
+    URLConnection connection = urlFactory.open(server.url("/").url());
     assertEquals("This is the new location!",
         readAscii(connection.getInputStream(), Integer.MAX_VALUE));
 
@@ -2287,30 +2520,41 @@ protected void configureSocket(Socket socket) throws IOException {
    * https://code.google.com/p/android/issues/detail?id=41576
    */
   @Test public void sameConnectionRedirectAndReuse() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+    // TODO(jwilson): this behavior shouldn't rely on having another IP address to attempt.
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .dns(new DoubleInetAddressDns())
+        .build());
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
         .setSocketPolicy(SHUTDOWN_INPUT_AT_END)
         .addHeader("Location: /foo"));
-    server.enqueue(new MockResponse().setBody("This is the new page!"));
+    server.enqueue(new MockResponse()
+        .setBody("This is the new page!"));
 
-    assertContent("This is the new page!", client.open(server.getUrl("/")));
+    assertContent("This is the new page!", urlFactory.open(server.url("/").url()));
 
     assertEquals(0, server.takeRequest().getSequenceNumber());
     assertEquals(0, server.takeRequest().getSequenceNumber());
   }
 
   @Test public void responseCodeDisagreesWithHeaders() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NO_CONTENT)
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NO_CONTENT)
         .setBody("This body is not allowed!"));
 
-    URLConnection connection = client.open(server.getUrl("/"));
-    assertEquals("This body is not allowed!",
-        readAscii(connection.getInputStream(), Integer.MAX_VALUE));
+    URLConnection connection = urlFactory.open(server.url("/").url());
+    try {
+      connection.getInputStream();
+      fail();
+    } catch (IOException expected) {
+      assertEquals("HTTP 204 had non-zero Content-Length: 25", expected.getMessage());
+    }
   }
 
   @Test public void singleByteReadIsSigned() throws IOException {
     server.enqueue(new MockResponse().setBody(new Buffer().writeByte(-2).writeByte(-1)));
 
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     InputStream in = connection.getInputStream();
     assertEquals(254, in.read());
     assertEquals(255, in.read());
@@ -2330,14 +2574,14 @@ protected void configureSocket(Socket socket) throws IOException {
   }
 
   /**
-   * We explicitly permit apps to close the upload stream even after it has
-   * been transmitted.  We also permit flush so that buffered streams can
-   * do a no-op flush when they are closed. http://b/3038470
+   * We explicitly permit apps to close the upload stream even after it has been transmitted.  We
+   * also permit flush so that buffered streams can do a no-op flush when they are closed.
+   * http://b/3038470
    */
   private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws IOException {
     server.enqueue(new MockResponse().setBody("abc"));
 
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     connection.setDoOutput(true);
     byte[] upload = "def".getBytes("UTF-8");
 
@@ -2362,7 +2606,7 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
   @Test public void getHeadersThrows() throws IOException {
     server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AT_START));
 
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     try {
       connection.getInputStream();
       fail();
@@ -2377,7 +2621,10 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
   }
 
   @Test public void dnsFailureThrowsIOException() throws IOException {
-    connection = client.open(new URL("http://host.unlikelytld"));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .dns(new FakeDns())
+        .build());
+    connection = urlFactory.open(new URL("http://host.unlikelytld"));
     try {
       connection.connect();
       fail();
@@ -2386,7 +2633,7 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
   }
 
   @Test public void malformedUrlThrowsUnknownHostException() throws IOException {
-    connection = client.open(new URL("http:///foo.html"));
+    connection = urlFactory.open(new URL("http://./foo.html"));
     try {
       connection.connect();
       fail();
@@ -2398,13 +2645,13 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
     server.enqueue(new MockResponse().setBody("ABC"));
 
     // The request should work once and then fail
-    HttpURLConnection connection1 = client.open(server.getUrl(""));
+    HttpURLConnection connection1 = urlFactory.open(server.url("/").url());
     connection1.setReadTimeout(100);
     InputStream input = connection1.getInputStream();
     assertEquals("ABC", readAscii(input, Integer.MAX_VALUE));
-    server.get().shutdown();
+    server.shutdown();
     try {
-      HttpURLConnection connection2 = client.open(server.getUrl(""));
+      HttpURLConnection connection2 = urlFactory.open(server.url("").url());
       connection2.setReadTimeout(100);
       connection2.getInputStream();
       fail();
@@ -2417,9 +2664,9 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
     server.enqueue(new MockResponse().setBody("ABC")
         .clearHeaders()
         .addHeader("Connection: close")
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END));
+        .setSocketPolicy(DISCONNECT_AT_END));
 
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     InputStream in = connection.getInputStream();
     assertEquals("ABC", readAscii(in, 3));
     assertEquals(-1, in.read());
@@ -2428,40 +2675,42 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
 
   @Test public void getContent() throws Exception {
     server.enqueue(new MockResponse().addHeader("Content-Type: text/plain").setBody("A"));
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     InputStream in = (InputStream) connection.getContent();
     assertEquals("A", readAscii(in, Integer.MAX_VALUE));
   }
 
   @Test public void getContentOfType() throws Exception {
     server.enqueue(new MockResponse().addHeader("Content-Type: text/plain").setBody("A"));
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     try {
       connection.getContent(null);
       fail();
     } catch (NullPointerException expected) {
     }
     try {
-      connection.getContent(new Class[] { null });
+      connection.getContent(new Class[] {null});
       fail();
     } catch (NullPointerException expected) {
     }
-    assertNull(connection.getContent(new Class[]{getClass()}));
+    assertNull(connection.getContent(new Class[] {getClass()}));
+    connection.getInputStream().close();
   }
 
   @Test public void getOutputStreamOnGetFails() throws Exception {
     server.enqueue(new MockResponse());
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     try {
       connection.getOutputStream();
       fail();
     } catch (ProtocolException expected) {
     }
+    connection.getInputStream().close();
   }
 
   @Test public void getOutputAfterGetInputStreamFails() throws Exception {
     server.enqueue(new MockResponse());
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     connection.setDoOutput(true);
     try {
       connection.getInputStream();
@@ -2473,7 +2722,7 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
 
   @Test public void setDoOutputOrDoInputAfterConnectFails() throws Exception {
     server.enqueue(new MockResponse());
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     connection.connect();
     try {
       connection.setDoOutput(true);
@@ -2485,50 +2734,55 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
       fail();
     } catch (IllegalStateException expected) {
     }
+    connection.getInputStream().close();
   }
 
   @Test public void clientSendsContentLength() throws Exception {
     server.enqueue(new MockResponse().setBody("A"));
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     connection.setDoOutput(true);
     OutputStream out = connection.getOutputStream();
-    out.write(new byte[] { 'A', 'B', 'C' });
+    out.write(new byte[] {'A', 'B', 'C'});
     out.close();
     assertEquals("A", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
     RecordedRequest request = server.takeRequest();
     assertEquals("3", request.getHeader("Content-Length"));
+    connection.getInputStream().close();
   }
 
   @Test public void getContentLengthConnects() throws Exception {
     server.enqueue(new MockResponse().setBody("ABC"));
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     assertEquals(3, connection.getContentLength());
+    connection.getInputStream().close();
   }
 
   @Test public void getContentTypeConnects() throws Exception {
     server.enqueue(new MockResponse().addHeader("Content-Type: text/plain").setBody("ABC"));
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     assertEquals("text/plain", connection.getContentType());
+    connection.getInputStream().close();
   }
 
   @Test public void getContentEncodingConnects() throws Exception {
     server.enqueue(new MockResponse().addHeader("Content-Encoding: identity").setBody("ABC"));
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     assertEquals("identity", connection.getContentEncoding());
+    connection.getInputStream().close();
   }
 
   // http://b/4361656
   @Test public void urlContainsQueryButNoPath() throws Exception {
     server.enqueue(new MockResponse().setBody("A"));
 
-    URL url = new URL("http", server.get().getHostName(), server.getPort(), "?query");
-    assertEquals("A", readAscii(client.open(url).getInputStream(), Integer.MAX_VALUE));
+    URL url = new URL("http", server.getHostName(), server.getPort(), "?query");
+    assertEquals("A", readAscii(urlFactory.open(url).getInputStream(), Integer.MAX_VALUE));
     RecordedRequest request = server.takeRequest();
     assertEquals("GET /?query HTTP/1.1", request.getRequestLine());
   }
 
   @Test public void doOutputForMethodThatDoesntSupportOutput() throws Exception {
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     connection.setRequestMethod("HEAD");
     connection.setDoOutput(true);
     try {
@@ -2556,7 +2810,7 @@ private void testInputStreamAvailable(TransferKind transferKind) throws IOExcept
     MockResponse response = new MockResponse();
     transferKind.setBody(response, body, 4);
     server.enqueue(response);
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     InputStream in = connection.getInputStream();
     for (int i = 0; i < body.length(); i++) {
       assertTrue(in.available() >= 0);
@@ -2596,7 +2850,10 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
     server.enqueue(new MockResponse().setBody("B"));
     server.enqueue(new MockResponse().setBody("C"));
 
-    assertContent("A", client.open(server.getUrl("/a")));
+    assertContent("A", urlFactory.open(server.url("/a").url()));
+
+    // Give the server time to disconnect.
+    Thread.sleep(500);
 
     // If the request body is larger than OkHttp's replay buffer, the failure may still occur.
     byte[] requestBody = new byte[requestSize];
@@ -2604,7 +2861,7 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
 
     for (int j = 0; j < 2; j++) {
       try {
-        connection = client.open(server.getUrl("/b"));
+        connection = urlFactory.open(server.url("/b").url());
         connection.setRequestMethod("POST");
         transferKind.setForRequest(connection, requestBody.length);
         for (int i = 0; i < requestBody.length; i += 1024) {
@@ -2630,15 +2887,15 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
 
   @Test public void postBodyRetransmittedOnFailureRecovery() throws Exception {
     server.enqueue(new MockResponse().setBody("abc"));
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AFTER_REQUEST));
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
     server.enqueue(new MockResponse().setBody("def"));
 
     // Seed the connection pool so we have something that can fail.
-    assertContent("abc", client.open(server.getUrl("/")));
+    assertContent("abc", urlFactory.open(server.url("/").url()));
 
-    HttpURLConnection post = client.open(server.getUrl("/"));
+    HttpURLConnection post = urlFactory.open(server.url("/").url());
     post.setDoOutput(true);
-    post.getOutputStream().write("body!".getBytes(Util.UTF_8));
+    post.getOutputStream().write("body!".getBytes(UTF_8));
     assertContent("def", post);
 
     RecordedRequest get = server.takeRequest();
@@ -2656,7 +2913,7 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
   @Test public void fullyBufferedPostIsTooShort() throws Exception {
     server.enqueue(new MockResponse().setBody("A"));
 
-    connection = client.open(server.getUrl("/b"));
+    connection = urlFactory.open(server.url("/b").url());
     connection.setRequestProperty("Content-Length", "4");
     connection.setRequestMethod("POST");
     OutputStream out = connection.getOutputStream();
@@ -2673,7 +2930,7 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
   @Test public void fullyBufferedPostIsTooLong() throws Exception {
     server.enqueue(new MockResponse().setBody("A"));
 
-    connection = client.open(server.getUrl("/b"));
+    connection = urlFactory.open(server.url("/b").url());
     connection.setRequestProperty("Content-Length", "3");
     connection.setRequestMethod("POST");
     OutputStream out = connection.getOutputStream();
@@ -2714,7 +2971,7 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
 
   @Test public void emptyRequestHeaderValueIsAllowed() throws Exception {
     server.enqueue(new MockResponse().setBody("body"));
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     connection.addRequestProperty("B", "");
     assertContent("body", connection);
     assertEquals("", connection.getRequestProperty("B"));
@@ -2722,14 +2979,14 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
 
   @Test public void emptyResponseHeaderValueIsAllowed() throws Exception {
     server.enqueue(new MockResponse().addHeader("A:").setBody("body"));
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     assertContent("body", connection);
     assertEquals("", connection.getHeaderField("A"));
   }
 
   @Test public void emptyRequestHeaderNameIsStrict() throws Exception {
     server.enqueue(new MockResponse().setBody("body"));
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     try {
       connection.setRequestProperty("", "A");
       fail();
@@ -2741,9 +2998,55 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
     Headers.Builder headers = new Headers.Builder();
     Internal.instance.addLenient(headers, ":A");
     server.enqueue(new MockResponse().setHeaders(headers.build()).setBody("body"));
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     connection.getResponseCode();
     assertEquals("A", connection.getHeaderField(""));
+    connection.getInputStream().close();
+  }
+
+  @Test public void requestHeaderValidationIsStrict() throws Exception {
+    connection = urlFactory.open(server.url("/").url());
+    try {
+      connection.addRequestProperty("a\tb", "Value");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+    try {
+      connection.addRequestProperty("Name", "c\u007fd");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+    try {
+      connection.addRequestProperty("", "Value");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+    try {
+      connection.addRequestProperty("\ud83c\udf69", "Value");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+    try {
+      connection.addRequestProperty("Name", "\u2615\ufe0f");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void responseHeaderParsingIsLenient() throws Exception {
+    Headers headers = new Headers.Builder()
+        .add("Content-Length", "0")
+        .addLenient("a\tb: c\u007fd")
+        .addLenient(": ef")
+        .addLenient("\ud83c\udf69: \u2615\ufe0f")
+        .build();
+    server.enqueue(new MockResponse().setHeaders(headers));
+
+    connection = urlFactory.open(server.url("/").url());
+    connection.getResponseCode();
+    assertEquals("c\u007fd", connection.getHeaderField("a\tb"));
+    assertEquals("\u2615\ufe0f", connection.getHeaderField("\ud83c\udf69"));
+    assertEquals("ef", connection.getHeaderField(""));
   }
 
   @Test @Ignore public void deflateCompression() {
@@ -2767,34 +3070,38 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
 
     String credential = Credentials.basic("jesse", "peanutbutter");
     RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator(credential);
-    client.client().setAuthenticator(authenticator);
-    assertContent("A", client.open(server.getUrl("/private")));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .authenticator(authenticator)
+        .build());
+    assertContent("A", urlFactory.open(server.url("/private").url()));
 
     assertNull(server.takeRequest().getHeader("Authorization"));
     assertEquals(credential, server.takeRequest().getHeader("Authorization"));
 
     assertEquals(Proxy.NO_PROXY, authenticator.onlyProxy());
     Response response = authenticator.onlyResponse();
-    assertEquals("/private", response.request().url().getPath());
+    assertEquals("/private", response.request().url().url().getPath());
     assertEquals(Arrays.asList(new Challenge("Basic", "protected area")), response.challenges());
   }
 
   @Test public void customTokenAuthenticator() throws Exception {
     MockResponse pleaseAuthenticate = new MockResponse().setResponseCode(401)
-            .addHeader("WWW-Authenticate: Bearer realm=\"oauthed\"")
-            .setBody("Please authenticate.");
+        .addHeader("WWW-Authenticate: Bearer realm=\"oauthed\"")
+        .setBody("Please authenticate.");
     server.enqueue(pleaseAuthenticate);
     server.enqueue(new MockResponse().setBody("A"));
 
     RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator("oauthed abc123");
-    client.client().setAuthenticator(authenticator);
-    assertContent("A", client.open(server.getUrl("/private")));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .authenticator(authenticator)
+        .build());
+    assertContent("A", urlFactory.open(server.url("/private").url()));
 
     assertNull(server.takeRequest().getHeader("Authorization"));
     assertEquals("oauthed abc123", server.takeRequest().getHeader("Authorization"));
 
     Response response = authenticator.onlyResponse();
-    assertEquals("/private", response.request().url().getPath());
+    assertEquals("/private", response.request().url().url().getPath());
     assertEquals(Arrays.asList(new Challenge("Bearer", "oauthed")), response.challenges());
   }
 
@@ -2809,14 +3116,16 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
 
     RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator(
         Credentials.basic("jesse", "peanutbutter"));
-    client.client().setAuthenticator(authenticator);
-    assertContent("c", client.open(server.getUrl("/a")));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .authenticator(authenticator)
+        .build());
+    assertContent("c", urlFactory.open(server.url("/a").url()));
 
     Response challengeResponse = authenticator.responses.get(0);
-    assertEquals("/b", challengeResponse.request().url().getPath());
+    assertEquals("/b", challengeResponse.request().url().url().getPath());
 
     Response redirectedBy = challengeResponse.priorResponse();
-    assertEquals("/a", redirectedBy.request().url().getPath());
+    assertEquals("/a", redirectedBy.request().url().url().getPath());
   }
 
   @Test public void attemptAuthorization20Times() throws Exception {
@@ -2826,9 +3135,11 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
     server.enqueue(new MockResponse().setBody("Success!"));
 
     String credential = Credentials.basic("jesse", "peanutbutter");
-    client.client().setAuthenticator(new RecordingOkAuthenticator(credential));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .authenticator(new RecordingOkAuthenticator(credential))
+        .build());
 
-    connection = client.open(server.getUrl("/0"));
+    connection = urlFactory.open(server.url("/0").url());
     assertContent("Success!", connection);
   }
 
@@ -2838,9 +3149,11 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
     }
 
     String credential = Credentials.basic("jesse", "peanutbutter");
-    client.client().setAuthenticator(new RecordingOkAuthenticator(credential));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .authenticator(new RecordingOkAuthenticator(credential))
+        .build());
 
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     try {
       connection.getInputStream();
       fail();
@@ -2861,8 +3174,10 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
   private void setsNegotiatedProtocolHeader(Protocol protocol) throws IOException {
     enableProtocol(protocol);
     server.enqueue(new MockResponse().setBody("A"));
-    client.client().setProtocols(Arrays.asList(protocol, Protocol.HTTP_1_1));
-    connection = client.open(server.getUrl("/"));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .protocols(Arrays.asList(protocol, Protocol.HTTP_1_1))
+        .build());
+    connection = urlFactory.open(server.url("/").url());
     List<String> protocolValues = connection.getHeaderFields().get(SELECTED_PROTOCOL);
     assertEquals(Arrays.asList(protocol.toString()), protocolValues);
     assertContent("A", connection);
@@ -2870,14 +3185,14 @@ private void setsNegotiatedProtocolHeader(Protocol protocol) throws IOException
 
   @Test public void http10SelectedProtocol() throws Exception {
     server.enqueue(new MockResponse().setStatus("HTTP/1.0 200 OK"));
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     List<String> protocolValues = connection.getHeaderFields().get(SELECTED_PROTOCOL);
     assertEquals(Arrays.asList("http/1.0"), protocolValues);
   }
 
   @Test public void http11SelectedProtocol() throws Exception {
     server.enqueue(new MockResponse().setStatus("HTTP/1.1 200 OK"));
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     List<String> protocolValues = connection.getHeaderFields().get(SELECTED_PROTOCOL);
     assertEquals(Arrays.asList("http/1.1"), protocolValues);
   }
@@ -2915,7 +3230,7 @@ private void setsNegotiatedProtocolHeader(Protocol protocol) throws IOException
   private void zeroLengthPayload(String method)
       throws IOException, InterruptedException {
     server.enqueue(new MockResponse());
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     connection.setRequestProperty("Content-Length", "0");
     connection.setRequestMethod(method);
     connection.setFixedLengthStreamingMode(0);
@@ -2930,7 +3245,7 @@ private void zeroLengthPayload(String method)
   @Test public void unspecifiedRequestBodyContentTypeGetsDefault() throws Exception {
     server.enqueue(new MockResponse());
 
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     connection.setDoOutput(true);
     connection.getOutputStream().write("abc".getBytes(UTF_8));
     assertEquals(200, connection.getResponseCode());
@@ -2943,13 +3258,15 @@ private void zeroLengthPayload(String method)
 
   @Test public void setProtocols() throws Exception {
     server.enqueue(new MockResponse().setBody("A"));
-    client.client().setProtocols(Arrays.asList(Protocol.HTTP_1_1));
-    assertContent("A", client.open(server.getUrl("/")));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .protocols(Arrays.asList(Protocol.HTTP_1_1))
+        .build());
+    assertContent("A", urlFactory.open(server.url("/").url()));
   }
 
   @Test public void setProtocolsWithoutHttp11() throws Exception {
     try {
-      client.client().setProtocols(Arrays.asList(Protocol.SPDY_3));
+      new OkHttpClient.Builder().protocols(Arrays.asList(Protocol.SPDY_3));
       fail();
     } catch (IllegalArgumentException expected) {
     }
@@ -2957,17 +3274,17 @@ private void zeroLengthPayload(String method)
 
   @Test public void setProtocolsWithNull() throws Exception {
     try {
-      client.client().setProtocols(Arrays.asList(Protocol.HTTP_1_1, null));
+      new OkHttpClient.Builder().protocols(Arrays.asList(Protocol.HTTP_1_1, null));
       fail();
     } catch (IllegalArgumentException expected) {
     }
   }
 
   @Test public void veryLargeFixedLengthRequest() throws Exception {
-    server.get().setBodyLimit(0);
+    server.setBodyLimit(0);
     server.enqueue(new MockResponse());
 
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     connection.setDoOutput(true);
     long contentLength = Integer.MAX_VALUE + 1L;
     connection.setFixedLengthStreamingMode(contentLength);
@@ -2985,10 +3302,9 @@ private void zeroLengthPayload(String method)
   }
 
   /**
-   * We had a bug where we attempted to gunzip responses that didn't have a
-   * body. This only came up with 304s since that response code can include
-   * headers (like "Content-Encoding") without any content to go along with it.
-   * https://github.com/square/okhttp/issues/358
+   * We had a bug where we attempted to gunzip responses that didn't have a body. This only came up
+   * with 304s since that response code can include headers (like "Content-Encoding") without any
+   * content to go along with it. https://github.com/square/okhttp/issues/358
    */
   @Test public void noTransparentGzipFor304NotModified() throws Exception {
     server.enqueue(new MockResponse()
@@ -2997,11 +3313,11 @@ private void zeroLengthPayload(String method)
         .addHeader("Content-Encoding: gzip"));
     server.enqueue(new MockResponse().setBody("b"));
 
-    HttpURLConnection connection1 = client.open(server.getUrl("/"));
+    HttpURLConnection connection1 = urlFactory.open(server.url("/").url());
     assertEquals(HttpURLConnection.HTTP_NOT_MODIFIED, connection1.getResponseCode());
     assertContent("", connection1);
 
-    HttpURLConnection connection2 = client.open(server.getUrl("/"));
+    HttpURLConnection connection2 = urlFactory.open(server.url("/").url());
     assertEquals(HttpURLConnection.HTTP_OK, connection2.getResponseCode());
     assertContent("b", connection2);
 
@@ -3024,7 +3340,7 @@ private void zeroLengthPayload(String method)
         .setBody(gzip("Moved! Moved! Moved!")));
     server.enqueue(new MockResponse().setBody("This is the new page!"));
 
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    HttpURLConnection connection = urlFactory.open(server.url("/").url());
     assertContent("This is the new page!", connection);
 
     RecordedRequest requestA = server.takeRequest();
@@ -3035,13 +3351,13 @@ private void zeroLengthPayload(String method)
   }
 
   /**
-   * The RFC is unclear in this regard as it only specifies that this should
-   * invalidate the cache entry (if any).
+   * The RFC is unclear in this regard as it only specifies that this should invalidate the cache
+   * entry (if any).
    */
   @Test public void bodyPermittedOnDelete() throws Exception {
     server.enqueue(new MockResponse());
 
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    HttpURLConnection connection = urlFactory.open(server.url("/").url());
     connection.setRequestMethod("DELETE");
     connection.setDoOutput(true);
     connection.getOutputStream().write("BODY".getBytes(UTF_8));
@@ -3056,19 +3372,30 @@ private void zeroLengthPayload(String method)
     server.enqueue(new MockResponse().setBody("abc"));
 
     System.setProperty("http.agent", "foo");
-    assertContent("abc", client.open(server.getUrl("/")));
+    assertContent("abc", urlFactory.open(server.url("/").url()));
 
     RecordedRequest request = server.takeRequest();
     assertEquals("foo", request.getHeader("User-Agent"));
   }
 
-  @Test public void userAgentDefaultsToJavaVersion() throws Exception {
+  /** https://github.com/square/okhttp/issues/891 */
+  @Test public void userAgentSystemPropertyIsNotAscii() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    System.setProperty("http.agent", "a\nb\ud83c\udf69c\ud83c\udf68d\u007fe");
+    assertContent("abc", urlFactory.open(server.url("/").url()));
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("a?b?c?d?e", request.getHeader("User-Agent"));
+  }
+
+  @Test public void userAgentDefaultsToOkHttpVersion() throws Exception {
     server.enqueue(new MockResponse().setBody("abc"));
 
-    assertContent("abc", client.open(server.getUrl("/")));
+    assertContent("abc", urlFactory.open(server.url("/").url()));
 
     RecordedRequest request = server.takeRequest();
-    assertTrue(request.getHeader("User-Agent").startsWith("Java"));
+    assertEquals(Version.userAgent(), request.getHeader("User-Agent"));
   }
 
   @Test public void interceptorsNotInvoked() throws Exception {
@@ -3077,11 +3404,89 @@ private void zeroLengthPayload(String method)
         throw new AssertionError();
       }
     };
-    client.client().interceptors().add(interceptor);
-    client.client().networkInterceptors().add(interceptor);
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .addInterceptor(interceptor)
+        .addNetworkInterceptor(interceptor)
+        .build());
 
     server.enqueue(new MockResponse().setBody("abc"));
-    assertContent("abc", client.open(server.getUrl("/")));
+    assertContent("abc", urlFactory.open(server.url("/").url()));
+  }
+
+  @Test public void urlWithSpaceInHost() throws Exception {
+    URLConnection urlConnection = urlFactory.open(new URL("http://and roid.com/"));
+    try {
+      urlConnection.getInputStream();
+      fail();
+    } catch (UnknownHostException expected) {
+    }
+  }
+
+  @Test public void urlWithSpaceInHostViaHttpProxy() throws Exception {
+    server.enqueue(new MockResponse());
+    URLConnection urlConnection =
+        urlFactory.open(new URL("http://and roid.com/"), server.toProxyAddress());
+
+    try {
+      // This test is to check that a NullPointerException is not thrown.
+      urlConnection.getInputStream();
+      fail(); // the RI makes a bogus proxy request for "GET http://and roid.com/ HTTP/1.1"
+    } catch (UnknownHostException expected) {
+    }
+  }
+
+  @Test public void urlHostWithNul() throws Exception {
+    URLConnection urlConnection = urlFactory.open(new URL("http://host\u0000/"));
+    try {
+      urlConnection.getInputStream();
+      fail();
+    } catch (UnknownHostException expected) {
+    }
+  }
+
+  @Test public void urlRedirectToHostWithNul() throws Exception {
+    String redirectUrl = "http://host\u0000/";
+    server.enqueue(new MockResponse().setResponseCode(302)
+        .addHeaderLenient("Location", redirectUrl));
+
+    HttpURLConnection urlConnection = urlFactory.open(server.url("/").url());
+    assertEquals(302, urlConnection.getResponseCode());
+    assertEquals(redirectUrl, urlConnection.getHeaderField("Location"));
+  }
+
+  @Test public void urlWithBadAsciiHost() throws Exception {
+    URLConnection urlConnection = urlFactory.open(new URL("http://host\u0001/"));
+    try {
+      urlConnection.getInputStream();
+      fail();
+    } catch (UnknownHostException expected) {
+    }
+  }
+
+  @Test public void instanceFollowsRedirects() throws Exception {
+    testInstanceFollowsRedirects("http://www.google.com/");
+    testInstanceFollowsRedirects("https://www.google.com/");
+  }
+
+  @Test public void setSslSocketFactoryFailsOnJdk9() throws Exception {
+    assumeTrue(getPlatform().equals("jdk9"));
+
+    URL url = server.url("/").url();
+    HttpsURLConnection connection = (HttpsURLConnection) urlFactory.open(url);
+    try {
+      connection.setSSLSocketFactory(sslClient.socketFactory);
+      fail();
+    } catch (UnsupportedOperationException expected) {
+    }
+  }
+
+  private void testInstanceFollowsRedirects(String spec) throws Exception {
+    URL url = new URL(spec);
+    HttpURLConnection urlConnection = urlFactory.open(url);
+    urlConnection.setInstanceFollowRedirects(true);
+    assertTrue(urlConnection.getInstanceFollowRedirects());
+    urlConnection.setInstanceFollowRedirects(false);
+    assertFalse(urlConnection.getInstanceFollowRedirects());
   }
 
   /** Returns a gzipped copy of {@code bytes}. */
@@ -3094,8 +3499,8 @@ public Buffer gzip(String data) throws IOException {
   }
 
   /**
-   * Reads at most {@code limit} characters from {@code in} and asserts that
-   * content equals {@code expected}.
+   * Reads at most {@code limit} characters from {@code in} and asserts that content equals {@code
+   * expected}.
    */
   private void assertContent(String expected, HttpURLConnection connection, int limit)
       throws IOException {
@@ -3108,7 +3513,7 @@ private void assertContent(String expected, HttpURLConnection connection) throws
   }
 
   private Set<String> newSet(String... elements) {
-    return new HashSet<String>(Arrays.asList(elements));
+    return new LinkedHashSet<>(Arrays.asList(elements));
   }
 
   enum TransferKind {
@@ -3117,6 +3522,7 @@ private void assertContent(String expected, HttpURLConnection connection) throws
           throws IOException {
         response.setChunkedBody(content, chunkSize);
       }
+
       @Override void setForRequest(HttpURLConnection connection, int contentLength) {
         connection.setChunkedStreamingMode(5);
       }
@@ -3125,6 +3531,7 @@ private void assertContent(String expected, HttpURLConnection connection) throws
       @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
         response.setBody(content);
       }
+
       @Override void setForRequest(HttpURLConnection connection, int contentLength) {
         connection.setFixedLengthStreamingMode(contentLength);
       }
@@ -3135,6 +3542,7 @@ private void assertContent(String expected, HttpURLConnection connection) throws
         response.setSocketPolicy(DISCONNECT_AT_END);
         response.removeHeader("Content-Length");
       }
+
       @Override void setForRequest(HttpURLConnection connection, int contentLength) {
       }
     };
@@ -3153,7 +3561,9 @@ void setBody(MockResponse response, String content, int chunkSize) throws IOExce
       @Override public HttpURLConnection connect(
           MockWebServer server, OkUrlFactory streamHandlerFactory, URL url)
           throws IOException {
-        streamHandlerFactory.client().setProxy(Proxy.NO_PROXY);
+        streamHandlerFactory.setClient(streamHandlerFactory.client().newBuilder()
+            .proxy(Proxy.NO_PROXY)
+            .build());
         return streamHandlerFactory.open(url);
       }
     },
@@ -3162,7 +3572,9 @@ void setBody(MockResponse response, String content, int chunkSize) throws IOExce
       @Override public HttpURLConnection connect(
           MockWebServer server, OkUrlFactory streamHandlerFactory, URL url)
           throws IOException {
-        streamHandlerFactory.client().setProxy(server.toProxyAddress());
+        streamHandlerFactory.setClient(streamHandlerFactory.client().newBuilder()
+            .proxy(server.toProxyAddress())
+            .build());
         return streamHandlerFactory.open(url);
       }
     },
@@ -3204,9 +3616,14 @@ public abstract HttpURLConnection connect(
 
   private static class RecordingTrustManager implements X509TrustManager {
     private final List<String> calls = new ArrayList<String>();
+    private final X509TrustManager delegate;
+
+    public RecordingTrustManager(X509TrustManager delegate) {
+      this.delegate = delegate;
+    }
 
     public X509Certificate[] getAcceptedIssuers() {
-      return new X509Certificate[] { };
+      return delegate.getAcceptedIssuers();
     }
 
     public void checkClientTrusted(X509Certificate[] chain, String authType)
@@ -3228,40 +3645,31 @@ private String certificatesToString(X509Certificate[] certificates) {
     }
   }
 
-  private static class FakeProxySelector extends ProxySelector {
-    List<Proxy> proxies = new ArrayList<>();
-
-    @Override public List<Proxy> select(URI uri) {
-      // Don't handle 'socket' schemes, which the RI's Socket class may request (for SOCKS).
-      return uri.getScheme().equals("http") || uri.getScheme().equals("https") ? proxies
-          : Collections.singletonList(Proxy.NO_PROXY);
-    }
-
-    @Override public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {
-    }
-  }
-
   /**
    * Tests that use this will fail unless boot classpath is set. Ex. {@code
    * -Xbootclasspath/p:/tmp/alpn-boot-8.0.0.v20140317}
    */
   private void enableProtocol(Protocol protocol) {
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
-    client.client().setProtocols(Arrays.asList(protocol, Protocol.HTTP_1_1));
-    server.get().useHttps(sslContext.getSocketFactory(), false);
-    server.get().setProtocolNegotiationEnabled(true);
-    server.get().setProtocols(client.client().getProtocols());
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .protocols(Arrays.asList(protocol, Protocol.HTTP_1_1))
+        .build());
+    server.useHttps(sslClient.socketFactory, false);
+    server.setProtocolNegotiationEnabled(true);
+    server.setProtocols(urlFactory.client().protocols());
   }
 
   /**
    * Used during tests that involve TLS connection fallback attempts. OkHttp includes the
-   * TLS_FALLBACK_SCSV cipher on fallback connections. See
-   * {@link com.squareup.okhttp.FallbackTestClientSocketFactory} for details.
+   * TLS_FALLBACK_SCSV cipher on fallback connections. See {@link FallbackTestClientSocketFactory}
+   * for details.
    */
-  private static void suppressTlsFallbackScsv(OkHttpClient client) {
-    FallbackTestClientSocketFactory clientSocketFactory =
-        new FallbackTestClientSocketFactory(sslContext.getSocketFactory());
-    client.setSslSocketFactory(clientSocketFactory);
+  private FallbackTestClientSocketFactory suppressTlsFallbackClientSocketFactory() {
+    return new FallbackTestClientSocketFactory(sslClient.socketFactory);
+  }
+
+  private String getPlatform() {
+    return System.getProperty("okhttp.platform", "platform");
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/UrlComponentEncodingTester.java b/okhttp-tests/src/test/java/okhttp3/UrlComponentEncodingTester.java
new file mode 100644
index 0000000000..56611be40a
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/UrlComponentEncodingTester.java
@@ -0,0 +1,433 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.net.URI;
+import java.net.URL;
+import java.util.Collections;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import okhttp3.internal.Util;
+import okio.Buffer;
+import okio.ByteString;
+
+import static org.junit.Assert.fail;
+
+/** Tests how each code point is encoded and decoded in the context of each URL component. */
+class UrlComponentEncodingTester {
+  private static final int UNICODE_2 = 0x07ff; // Arbitrary code point that's 2 bytes in UTF-8.
+  private static final int UNICODE_3 = 0xffff; // Arbitrary code point that's 3 bytes in UTF-8.
+  private static final int UNICODE_4 = 0x10ffff; // Arbitrary code point that's 4 bytes in UTF-8.
+
+  /**
+   * The default encode set for the ASCII range. The specific rules vary per-component: for example,
+   * '?' may be identity-encoded in a fragment, but must be percent-encoded in a path.
+   *
+   * See https://url.spec.whatwg.org/#percent-encoded-bytes
+   */
+  private static final Map<Integer, Encoding> defaultEncodings;
+
+  static {
+    Map<Integer, Encoding> map = new LinkedHashMap<>();
+    map.put(       0x0, Encoding.PERCENT); // Null character
+    map.put(       0x1, Encoding.PERCENT); // Start of Header
+    map.put(       0x2, Encoding.PERCENT); // Start of Text
+    map.put(       0x3, Encoding.PERCENT); // End of Text
+    map.put(       0x4, Encoding.PERCENT); // End of Transmission
+    map.put(       0x5, Encoding.PERCENT); // Enquiry
+    map.put(       0x6, Encoding.PERCENT); // Acknowledgment
+    map.put(       0x7, Encoding.PERCENT); // Bell
+    map.put((int) '\b', Encoding.PERCENT); // Backspace
+    map.put((int) '\t', Encoding.SKIP);    // Horizontal Tab
+    map.put((int) '\n', Encoding.SKIP);    // Line feed
+    map.put(       0xb, Encoding.PERCENT); // Vertical Tab
+    map.put((int) '\f', Encoding.SKIP);    // Form feed
+    map.put((int) '\r', Encoding.SKIP);    // Carriage return
+    map.put(       0xe, Encoding.PERCENT); // Shift Out
+    map.put(       0xf, Encoding.PERCENT); // Shift In
+    map.put(      0x10, Encoding.PERCENT); // Data Link Escape
+    map.put(      0x11, Encoding.PERCENT); // Device Control 1 (oft. XON)
+    map.put(      0x12, Encoding.PERCENT); // Device Control 2
+    map.put(      0x13, Encoding.PERCENT); // Device Control 3 (oft. XOFF)
+    map.put(      0x14, Encoding.PERCENT); // Device Control 4
+    map.put(      0x15, Encoding.PERCENT); // Negative Acknowledgment
+    map.put(      0x16, Encoding.PERCENT); // Synchronous idle
+    map.put(      0x17, Encoding.PERCENT); // End of Transmission Block
+    map.put(      0x18, Encoding.PERCENT); // Cancel
+    map.put(      0x19, Encoding.PERCENT); // End of Medium
+    map.put(      0x1a, Encoding.PERCENT); // Substitute
+    map.put(      0x1b, Encoding.PERCENT); // Escape
+    map.put(      0x1c, Encoding.PERCENT); // File Separator
+    map.put(      0x1d, Encoding.PERCENT); // Group Separator
+    map.put(      0x1e, Encoding.PERCENT); // Record Separator
+    map.put(      0x1f, Encoding.PERCENT); // Unit Separator
+    map.put((int)  ' ', Encoding.PERCENT);
+    map.put((int)  '!', Encoding.IDENTITY);
+    map.put((int)  '"', Encoding.PERCENT);
+    map.put((int)  '#', Encoding.PERCENT);
+    map.put((int)  '$', Encoding.IDENTITY);
+    map.put((int)  '%', Encoding.IDENTITY);
+    map.put((int)  '&', Encoding.IDENTITY);
+    map.put((int) '\'', Encoding.IDENTITY);
+    map.put((int)  '(', Encoding.IDENTITY);
+    map.put((int)  ')', Encoding.IDENTITY);
+    map.put((int)  '*', Encoding.IDENTITY);
+    map.put((int)  '+', Encoding.IDENTITY);
+    map.put((int)  ',', Encoding.IDENTITY);
+    map.put((int)  '-', Encoding.IDENTITY);
+    map.put((int)  '.', Encoding.IDENTITY);
+    map.put((int)  '/', Encoding.IDENTITY);
+    map.put((int)  '0', Encoding.IDENTITY);
+    map.put((int)  '1', Encoding.IDENTITY);
+    map.put((int)  '2', Encoding.IDENTITY);
+    map.put((int)  '3', Encoding.IDENTITY);
+    map.put((int)  '4', Encoding.IDENTITY);
+    map.put((int)  '5', Encoding.IDENTITY);
+    map.put((int)  '6', Encoding.IDENTITY);
+    map.put((int)  '7', Encoding.IDENTITY);
+    map.put((int)  '8', Encoding.IDENTITY);
+    map.put((int)  '9', Encoding.IDENTITY);
+    map.put((int)  ':', Encoding.IDENTITY);
+    map.put((int)  ';', Encoding.IDENTITY);
+    map.put((int)  '<', Encoding.PERCENT);
+    map.put((int)  '=', Encoding.IDENTITY);
+    map.put((int)  '>', Encoding.PERCENT);
+    map.put((int)  '?', Encoding.PERCENT);
+    map.put((int)  '@', Encoding.IDENTITY);
+    map.put((int)  'A', Encoding.IDENTITY);
+    map.put((int)  'B', Encoding.IDENTITY);
+    map.put((int)  'C', Encoding.IDENTITY);
+    map.put((int)  'D', Encoding.IDENTITY);
+    map.put((int)  'E', Encoding.IDENTITY);
+    map.put((int)  'F', Encoding.IDENTITY);
+    map.put((int)  'G', Encoding.IDENTITY);
+    map.put((int)  'H', Encoding.IDENTITY);
+    map.put((int)  'I', Encoding.IDENTITY);
+    map.put((int)  'J', Encoding.IDENTITY);
+    map.put((int)  'K', Encoding.IDENTITY);
+    map.put((int)  'L', Encoding.IDENTITY);
+    map.put((int)  'M', Encoding.IDENTITY);
+    map.put((int)  'N', Encoding.IDENTITY);
+    map.put((int)  'O', Encoding.IDENTITY);
+    map.put((int)  'P', Encoding.IDENTITY);
+    map.put((int)  'Q', Encoding.IDENTITY);
+    map.put((int)  'R', Encoding.IDENTITY);
+    map.put((int)  'S', Encoding.IDENTITY);
+    map.put((int)  'T', Encoding.IDENTITY);
+    map.put((int)  'U', Encoding.IDENTITY);
+    map.put((int)  'V', Encoding.IDENTITY);
+    map.put((int)  'W', Encoding.IDENTITY);
+    map.put((int)  'X', Encoding.IDENTITY);
+    map.put((int)  'Y', Encoding.IDENTITY);
+    map.put((int)  'Z', Encoding.IDENTITY);
+    map.put((int)  '[', Encoding.IDENTITY);
+    map.put((int) '\\', Encoding.IDENTITY);
+    map.put((int)  ']', Encoding.IDENTITY);
+    map.put((int)  '^', Encoding.IDENTITY);
+    map.put((int)  '_', Encoding.IDENTITY);
+    map.put((int)  '`', Encoding.PERCENT);
+    map.put((int)  'a', Encoding.IDENTITY);
+    map.put((int)  'b', Encoding.IDENTITY);
+    map.put((int)  'c', Encoding.IDENTITY);
+    map.put((int)  'd', Encoding.IDENTITY);
+    map.put((int)  'e', Encoding.IDENTITY);
+    map.put((int)  'f', Encoding.IDENTITY);
+    map.put((int)  'g', Encoding.IDENTITY);
+    map.put((int)  'h', Encoding.IDENTITY);
+    map.put((int)  'i', Encoding.IDENTITY);
+    map.put((int)  'j', Encoding.IDENTITY);
+    map.put((int)  'k', Encoding.IDENTITY);
+    map.put((int)  'l', Encoding.IDENTITY);
+    map.put((int)  'm', Encoding.IDENTITY);
+    map.put((int)  'n', Encoding.IDENTITY);
+    map.put((int)  'o', Encoding.IDENTITY);
+    map.put((int)  'p', Encoding.IDENTITY);
+    map.put((int)  'q', Encoding.IDENTITY);
+    map.put((int)  'r', Encoding.IDENTITY);
+    map.put((int)  's', Encoding.IDENTITY);
+    map.put((int)  't', Encoding.IDENTITY);
+    map.put((int)  'u', Encoding.IDENTITY);
+    map.put((int)  'v', Encoding.IDENTITY);
+    map.put((int)  'w', Encoding.IDENTITY);
+    map.put((int)  'x', Encoding.IDENTITY);
+    map.put((int)  'y', Encoding.IDENTITY);
+    map.put((int)  'z', Encoding.IDENTITY);
+    map.put((int)  '{', Encoding.IDENTITY);
+    map.put((int)  '|', Encoding.IDENTITY);
+    map.put((int)  '}', Encoding.IDENTITY);
+    map.put((int)  '~', Encoding.IDENTITY);
+    map.put(      0x7f, Encoding.PERCENT); // Delete
+    map.put( UNICODE_2, Encoding.PERCENT);
+    map.put( UNICODE_3, Encoding.PERCENT);
+    map.put( UNICODE_4, Encoding.PERCENT);
+    defaultEncodings = Collections.unmodifiableMap(map);
+  }
+
+  private final Map<Integer, Encoding> encodings;
+  private final StringBuilder uriEscapedCodePoints = new StringBuilder();
+
+  public UrlComponentEncodingTester() {
+    this.encodings = new LinkedHashMap<>(defaultEncodings);
+  }
+
+  public UrlComponentEncodingTester override(Encoding encoding, int... codePoints) {
+    for (int codePoint : codePoints) {
+      encodings.put(codePoint, encoding);
+    }
+    return this;
+  }
+
+  public UrlComponentEncodingTester identityForNonAscii() {
+    encodings.put(UNICODE_2, Encoding.IDENTITY);
+    encodings.put(UNICODE_3, Encoding.IDENTITY);
+    encodings.put(UNICODE_4, Encoding.IDENTITY);
+    return this;
+  }
+
+  /**
+   * Configure a character to be skipped but only for conversion to and from {@code java.net.URI}.
+   * That class is more strict than the others.
+   */
+  public UrlComponentEncodingTester skipForUri(int... codePoints) {
+    uriEscapedCodePoints.append(new String(codePoints, 0, codePoints.length));
+    return this;
+  }
+
+  public UrlComponentEncodingTester test(Component component) {
+    for (Map.Entry<Integer, Encoding> entry : encodings.entrySet()) {
+      Encoding encoding = entry.getValue();
+      int codePoint = entry.getKey();
+      testEncodeAndDecode(codePoint, component);
+      if (encoding == Encoding.SKIP) continue;
+
+      testParseOriginal(codePoint, encoding, component);
+      testParseAlreadyEncoded(codePoint, encoding, component);
+      testToUrl(codePoint, encoding, component);
+      testFromUrl(codePoint, encoding, component);
+
+      if (codePoint != '%') {
+        boolean uriEscaped = uriEscapedCodePoints.indexOf(
+            Encoding.IDENTITY.encode(codePoint)) != -1;
+        testUri(codePoint, encoding, component, uriEscaped);
+      }
+    }
+    return this;
+  }
+
+  private void testParseAlreadyEncoded(int codePoint, Encoding encoding, Component component) {
+    String encoded = encoding.encode(codePoint);
+    String urlString = component.urlString(encoded);
+    HttpUrl url = HttpUrl.parse(urlString);
+    if (!component.encodedValue(url).equals(encoded)) {
+      fail(Util.format("Encoding %s %#x using %s", component, codePoint, encoding));
+    }
+  }
+
+  private void testEncodeAndDecode(int codePoint, Component component) {
+    String expected = Encoding.IDENTITY.encode(codePoint);
+    HttpUrl.Builder builder = HttpUrl.parse("http://host/").newBuilder();
+    component.set(builder, expected);
+    HttpUrl url = builder.build();
+    String actual = component.get(url);
+    if (!expected.equals(actual)) {
+      fail(Util.format("Roundtrip %s %#x %s", component, codePoint, url));
+    }
+  }
+
+  private void testParseOriginal(int codePoint, Encoding encoding, Component component) {
+    String encoded = encoding.encode(codePoint);
+    if (encoding != Encoding.PERCENT) return;
+    String identity = Encoding.IDENTITY.encode(codePoint);
+    String urlString = component.urlString(identity);
+    HttpUrl url = HttpUrl.parse(urlString);
+
+    String s = component.encodedValue(url);
+    if (!s.equals(encoded)) {
+      fail(Util.format("Encoding %s %#02x using %s", component, codePoint, encoding));
+    }
+  }
+
+  private void testToUrl(int codePoint, Encoding encoding, Component component) {
+    String encoded = encoding.encode(codePoint);
+    HttpUrl httpUrl = HttpUrl.parse(component.urlString(encoded));
+    URL javaNetUrl = httpUrl.url();
+    if (!javaNetUrl.toString().equals(javaNetUrl.toString())) {
+      fail(Util.format("Encoding %s %#x using %s", component, codePoint, encoding));
+    }
+  }
+
+  private void testFromUrl(int codePoint, Encoding encoding, Component component) {
+    String encoded = encoding.encode(codePoint);
+    HttpUrl httpUrl = HttpUrl.parse(component.urlString(encoded));
+    HttpUrl toAndFromJavaNetUrl = HttpUrl.get(httpUrl.url());
+    if (!toAndFromJavaNetUrl.equals(httpUrl)) {
+      fail(Util.format("Encoding %s %#x using %s", component, codePoint, encoding));
+    }
+  }
+
+  private void testUri(
+      int codePoint, Encoding encoding, Component component, boolean uriEscaped) {
+    String string = new String(new int[] {codePoint}, 0, 1);
+    String encoded = encoding.encode(codePoint);
+    HttpUrl httpUrl = HttpUrl.parse(component.urlString(encoded));
+    URI uri = httpUrl.uri();
+    HttpUrl toAndFromUri = HttpUrl.get(uri);
+    if (uriEscaped) {
+      // The URI has more escaping than the HttpURL. Check that the decoded values still match.
+      if (uri.toString().equals(httpUrl.toString())) {
+        fail(Util.format("Encoding %s %#x using %s", component, codePoint, encoding));
+      }
+      if (!component.get(toAndFromUri).equals(string)) {
+        fail(Util.format("Encoding %s %#x using %s", component, codePoint, encoding));
+      }
+    } else {
+      // Check that the URI and HttpURL have the exact same escaping.
+      if (!toAndFromUri.equals(httpUrl)) {
+        fail(Util.format("Encoding %s %#x using %s", component, codePoint, encoding));
+      }
+      if (!uri.toString().equals(httpUrl.toString())) {
+        fail(Util.format("Encoding %s %#x using %s", component, codePoint, encoding));
+      }
+    }
+  }
+
+  public enum Encoding {
+    IDENTITY {
+      public String encode(int codePoint) {
+        return new String(new int[] {codePoint}, 0, 1);
+      }
+    },
+
+    PERCENT {
+      public String encode(int codePoint) {
+        ByteString utf8 = ByteString.encodeUtf8(IDENTITY.encode(codePoint));
+        Buffer percentEncoded = new Buffer();
+        for (int i = 0; i < utf8.size(); i++) {
+          percentEncoded.writeUtf8(Util.format("%%%02X", utf8.getByte(i) & 0xff));
+        }
+        return percentEncoded.readUtf8();
+      }
+    },
+
+    SKIP;
+
+    public String encode(int codePoint) {
+      throw new UnsupportedOperationException();
+    }
+  }
+
+  public enum Component {
+    USER {
+      @Override public String urlString(String value) {
+        return "http://" + value + "@example.com/";
+      }
+
+      @Override public String encodedValue(HttpUrl url) {
+        return url.encodedUsername();
+      }
+
+      @Override public void set(HttpUrl.Builder builder, String value) {
+        builder.username(value);
+      }
+
+      @Override public String get(HttpUrl url) {
+        return url.username();
+      }
+    },
+    PASSWORD {
+      @Override public String urlString(String value) {
+        return "http://:" + value + "@example.com/";
+      }
+
+      @Override public String encodedValue(HttpUrl url) {
+        return url.encodedPassword();
+      }
+
+      @Override public void set(HttpUrl.Builder builder, String value) {
+        builder.password(value);
+      }
+
+      @Override public String get(HttpUrl url) {
+        return url.password();
+      }
+    },
+    PATH {
+      @Override public String urlString(String value) {
+        return "http://example.com/a" + value + "z/";
+      }
+
+      @Override public String encodedValue(HttpUrl url) {
+        String path = url.encodedPath();
+        return path.substring(2, path.length() - 2);
+      }
+
+      @Override public void set(HttpUrl.Builder builder, String value) {
+        builder.addPathSegment("a" + value + "z");
+      }
+
+      @Override public String get(HttpUrl url) {
+        String pathSegment = url.pathSegments().get(0);
+        return pathSegment.substring(1, pathSegment.length() - 1);
+      }
+    },
+    QUERY {
+      @Override public String urlString(String value) {
+        return "http://example.com/?a" + value + "z";
+      }
+
+      @Override public String encodedValue(HttpUrl url) {
+        String query = url.encodedQuery();
+        return query.substring(1, query.length() - 1);
+      }
+
+      @Override public void set(HttpUrl.Builder builder, String value) {
+        builder.query("a" + value + "z");
+      }
+
+      @Override public String get(HttpUrl url) {
+        String query = url.query();
+        return query.substring(1, query.length() - 1);
+      }
+    },
+    FRAGMENT {
+      @Override public String urlString(String value) {
+        return "http://example.com/#a" + value + "z";
+      }
+
+      @Override public String encodedValue(HttpUrl url) {
+        String fragment = url.encodedFragment();
+        return fragment.substring(1, fragment.length() - 1);
+      }
+
+      @Override public void set(HttpUrl.Builder builder, String value) {
+        builder.fragment("a" + value + "z");
+      }
+
+      @Override public String get(HttpUrl url) {
+        String fragment = url.fragment();
+        return fragment.substring(1, fragment.length() - 1);
+      }
+    };
+
+    public abstract String urlString(String value);
+
+    public abstract String encodedValue(HttpUrl url);
+
+    public abstract void set(HttpUrl.Builder builder, String value);
+
+    public abstract String get(HttpUrl url);
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/WebPlatformUrlTest.java b/okhttp-tests/src/test/java/okhttp3/WebPlatformUrlTest.java
new file mode 100644
index 0000000000..a15c57ea35
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/WebPlatformUrlTest.java
@@ -0,0 +1,131 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import okhttp3.internal.Util;
+import okio.BufferedSource;
+import okio.Okio;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameter;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+
+/** Runs the web platform URL tests against Java URL models. */
+@RunWith(Parameterized.class)
+public final class WebPlatformUrlTest {
+  @Parameterized.Parameters(name = "{0}")
+  public static List<Object[]> parameters() {
+    try {
+      List<Object[]> result = new ArrayList<>();
+      for (WebPlatformUrlTestData urlTestData : loadTests()) {
+        result.add(new Object[] {urlTestData});
+      }
+      return result;
+    } catch (IOException e) {
+      throw new AssertionError();
+    }
+  }
+
+  @Parameter(0)
+  public WebPlatformUrlTestData testData;
+
+  private static final List<String> HTTP_URL_SCHEMES
+      = Util.immutableList("http", "https");
+  private static final List<String> KNOWN_FAILURES = Util.immutableList(
+      "Parsing: <http://example\t.\norg> against <http://example.org/foo/bar>",
+      "Parsing: <http://f:0/c> against <http://example.org/foo/bar>",
+      "Parsing: <http://f:00000000000000/c> against <http://example.org/foo/bar>",
+      "Parsing: <http://f:\n/c> against <http://example.org/foo/bar>",
+      "Parsing: <http://f:999999/c> against <http://example.org/foo/bar>",
+      "Parsing: <http://192.0x00A80001> against <about:blank>",
+      // This test fails on Java 7 but passes on Java 8. See HttpUrlTest.hostWithTrailingDot().
+      "Parsing: <http://%30%78%63%30%2e%30%32%35%30.01%2e> against <http://other.com/>",
+      "Parsing: <http://%30%78%63%30%2e%30%32%35%30.01> against <http://other.com/>",
+      "Parsing: <http://192.168.0.257> against <http://other.com/>",
+      "Parsing: <http://０Ｘｃ０．０２５０．０１> against <http://other.com/>"
+  );
+
+  /** Test how {@link HttpUrl} does against the web platform test suite. */
+  @Test public void httpUrl() throws Exception {
+    if (!testData.scheme.isEmpty() && !HTTP_URL_SCHEMES.contains(testData.scheme)) {
+      System.err.println("Ignoring unsupported scheme " + testData.scheme);
+      return;
+    }
+    if (!testData.base.startsWith("https:")
+        && !testData.base.startsWith("http:")
+        && !testData.base.equals("about:blank")) {
+      System.err.println("Ignoring unsupported base " + testData.base);
+      return;
+    }
+
+    try {
+      testHttpUrl();
+      if (KNOWN_FAILURES.contains(testData.toString())) {
+        System.err.println("Expected failure but was success: " + testData);
+      }
+    } catch (Throwable e) {
+      if (KNOWN_FAILURES.contains(testData.toString())) {
+        System.err.println("Ignoring known failure: " + testData);
+        e.printStackTrace();
+      } else {
+        throw e;
+      }
+    }
+  }
+
+  private void testHttpUrl() {
+    HttpUrl url;
+    if (testData.base.equals("about:blank")) {
+      url = HttpUrl.parse(testData.input);
+    } else {
+      HttpUrl baseUrl = HttpUrl.parse(testData.base);
+      url = baseUrl.resolve(testData.input);
+    }
+
+    if (testData.expectParseFailure()) {
+      assertNull("Expected URL to fail parsing", url);
+    } else {
+      assertNotNull("Expected URL to parse successfully, but was null", url);
+      String effectivePort = url.port() != HttpUrl.defaultPort(url.scheme())
+          ? Integer.toString(url.port())
+          : "";
+      String effectiveQuery = url.encodedQuery() != null ? "?" + url.encodedQuery() : "";
+      String effectiveFragment = url.encodedFragment() != null ? "#" + url.encodedFragment() : "";
+      String effectiveHost = url.host().contains(":")
+          ? ("[" + url.host() + "]")
+          : url.host();
+      assertEquals("scheme", testData.scheme, url.scheme());
+      assertEquals("host", testData.host, effectiveHost);
+      assertEquals("port", testData.port, effectivePort);
+      assertEquals("path", testData.path, url.encodedPath());
+      assertEquals("query", testData.query, effectiveQuery);
+      assertEquals("fragment", testData.fragment, effectiveFragment);
+    }
+  }
+
+  private static List<WebPlatformUrlTestData> loadTests() throws IOException {
+    BufferedSource source = Okio.buffer(Okio.source(
+        WebPlatformUrlTest.class.getResourceAsStream("/web-platform-test-urltestdata.txt")));
+    return WebPlatformUrlTestData.load(source);
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/WebPlatformUrlTestData.java b/okhttp-tests/src/test/java/okhttp3/WebPlatformUrlTestData.java
new file mode 100644
index 0000000000..72f92f9abf
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/WebPlatformUrlTestData.java
@@ -0,0 +1,157 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.EOFException;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import okhttp3.internal.Util;
+import okio.Buffer;
+import okio.BufferedSource;
+
+/**
+ * A test from the <a href="https://github.com/w3c/web-platform-tests/tree/master/url">Web Platform
+ * URL test suite</a>. Each test is a line of the file {@code urltestdata.txt}; the format is
+ * informally specified by its JavaScript parser {@code urltestparser.js}; with which this class
+ * attempts to be compatible.
+ *
+ * <p>Each line of the urltestdata.text file specifies a test. Lines look like this: <pre>   {@code
+ *
+ *   http://example\t.\norg http://example.org/foo/bar s:http h:example.org p:/
+ * }</pre>
+ */
+public final class WebPlatformUrlTestData {
+  String input;
+  String base;
+  String scheme = "";
+  String username = "";
+  String password = null;
+  String host = "";
+  String port = "";
+  String path = "";
+  String query = "";
+  String fragment = "";
+
+  public boolean expectParseFailure() {
+    return scheme.isEmpty();
+  }
+
+  private void set(String name, String value) {
+    switch (name) {
+      case "s":
+        scheme = value;
+        break;
+      case "u":
+        username = value;
+        break;
+      case "pass":
+        password = value;
+        break;
+      case "h":
+        host = value;
+        break;
+      case "port":
+        port = value;
+        break;
+      case "p":
+        path = value;
+        break;
+      case "q":
+        query = value;
+        break;
+      case "f":
+        fragment = value;
+        break;
+      default:
+        throw new IllegalArgumentException("unexpected attribute: " + value);
+    }
+  }
+
+  @Override public String toString() {
+    return Util.format("Parsing: <%s> against <%s>", input, base);
+  }
+
+  public static List<WebPlatformUrlTestData> load(BufferedSource source) throws IOException {
+    List<WebPlatformUrlTestData> list = new ArrayList<>();
+    for (String line; (line = source.readUtf8Line()) != null; ) {
+      if (line.isEmpty() || line.startsWith("#")) continue;
+
+      int i = 0;
+      String[] parts = line.split(" ");
+      WebPlatformUrlTestData element = new WebPlatformUrlTestData();
+      element.input = unescape(parts[i++]);
+
+      String base = i < parts.length ? parts[i++] : null;
+      element.base = (base == null || base.isEmpty())
+          ? list.get(list.size() - 1).base
+          : unescape(base);
+
+      for (; i < parts.length; i++) {
+        String piece = parts[i];
+        if (piece.startsWith("#")) continue;
+        String[] nameAndValue = piece.split(":", 2);
+        element.set(nameAndValue[0], unescape(nameAndValue[1]));
+      }
+
+      list.add(element);
+    }
+    return list;
+  }
+
+  private static String unescape(String s) throws EOFException {
+    Buffer in = new Buffer().writeUtf8(s);
+    StringBuilder result = new StringBuilder();
+    while (!in.exhausted()) {
+      int c = in.readUtf8CodePoint();
+      if (c != '\\') {
+        result.append((char) c);
+        continue;
+      }
+
+      switch (in.readUtf8CodePoint()) {
+        case '\\':
+          result.append('\\');
+          break;
+        case '#':
+          result.append('#');
+          break;
+        case 'n':
+          result.append('\n');
+          break;
+        case 'r':
+          result.append('\r');
+          break;
+        case 's':
+          result.append(' ');
+          break;
+        case 't':
+          result.append('\t');
+          break;
+        case 'f':
+          result.append('\f');
+          break;
+        case 'u':
+          result.append((char) Integer.parseInt(in.readUtf8(4), 16));
+          break;
+        default:
+          throw new IllegalArgumentException("unexpected escape character in " + s);
+      }
+    }
+
+    return result.toString();
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ConnectionSpecSelectorTest.java b/okhttp-tests/src/test/java/okhttp3/internal/ConnectionSpecSelectorTest.java
new file mode 100644
index 0000000000..96c6585a34
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/ConnectionSpecSelectorTest.java
@@ -0,0 +1,141 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal;
+
+import java.io.IOException;
+import java.security.cert.CertificateException;
+import java.util.Arrays;
+import java.util.LinkedHashSet;
+import java.util.Set;
+import javax.net.ssl.SSLHandshakeException;
+import javax.net.ssl.SSLSocket;
+import okhttp3.ConnectionSpec;
+import okhttp3.TlsVersion;
+import okhttp3.internal.tls.SslClient;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+public class ConnectionSpecSelectorTest {
+  static {
+    Internal.initializeInstanceForTests();
+  }
+
+  public static final SSLHandshakeException RETRYABLE_EXCEPTION = new SSLHandshakeException(
+      "Simulated handshake exception");
+
+  private SslClient sslClient = SslClient.localhost();
+
+  @Test
+  public void nonRetryableIOException() throws Exception {
+    ConnectionSpecSelector connectionSpecSelector =
+        createConnectionSpecSelector(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS);
+    SSLSocket socket = createSocketWithEnabledProtocols(TlsVersion.TLS_1_1, TlsVersion.TLS_1_0);
+    connectionSpecSelector.configureSecureSocket(socket);
+
+    boolean retry = connectionSpecSelector.connectionFailed(
+        new IOException("Non-handshake exception"));
+    assertFalse(retry);
+    socket.close();
+  }
+
+  @Test
+  public void nonRetryableSSLHandshakeException() throws Exception {
+    ConnectionSpecSelector connectionSpecSelector =
+        createConnectionSpecSelector(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS);
+    SSLSocket socket = createSocketWithEnabledProtocols(TlsVersion.TLS_1_1, TlsVersion.TLS_1_0);
+    connectionSpecSelector.configureSecureSocket(socket);
+
+    SSLHandshakeException trustIssueException =
+        new SSLHandshakeException("Certificate handshake exception");
+    trustIssueException.initCause(new CertificateException());
+    boolean retry = connectionSpecSelector.connectionFailed(trustIssueException);
+    assertFalse(retry);
+    socket.close();
+  }
+
+  @Test
+  public void retryableSSLHandshakeException() throws Exception {
+    ConnectionSpecSelector connectionSpecSelector =
+        createConnectionSpecSelector(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS);
+    SSLSocket socket = createSocketWithEnabledProtocols(TlsVersion.TLS_1_1, TlsVersion.TLS_1_0);
+    connectionSpecSelector.configureSecureSocket(socket);
+
+    boolean retry = connectionSpecSelector.connectionFailed(RETRYABLE_EXCEPTION);
+    assertTrue(retry);
+    socket.close();
+  }
+
+  @Test
+  public void someFallbacksSupported() throws Exception {
+    ConnectionSpec sslV3 =
+        new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
+            .tlsVersions(TlsVersion.SSL_3_0)
+            .build();
+
+    ConnectionSpecSelector connectionSpecSelector = createConnectionSpecSelector(
+        ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS, sslV3);
+
+    TlsVersion[] enabledSocketTlsVersions = {TlsVersion.TLS_1_1, TlsVersion.TLS_1_0};
+    SSLSocket socket = createSocketWithEnabledProtocols(enabledSocketTlsVersions);
+
+    // MODERN_TLS is used here.
+    connectionSpecSelector.configureSecureSocket(socket);
+    assertEnabledProtocols(socket, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0);
+
+    boolean retry = connectionSpecSelector.connectionFailed(RETRYABLE_EXCEPTION);
+    assertTrue(retry);
+    socket.close();
+
+    // COMPATIBLE_TLS is used here.
+    socket = createSocketWithEnabledProtocols(enabledSocketTlsVersions);
+    connectionSpecSelector.configureSecureSocket(socket);
+    assertEnabledProtocols(socket, TlsVersion.TLS_1_0);
+
+    retry = connectionSpecSelector.connectionFailed(RETRYABLE_EXCEPTION);
+    assertFalse(retry);
+    socket.close();
+
+    // sslV3 is not used because SSLv3 is not enabled on the socket.
+  }
+
+  private static ConnectionSpecSelector createConnectionSpecSelector(
+      ConnectionSpec... connectionSpecs) {
+    return new ConnectionSpecSelector(Arrays.asList(connectionSpecs));
+  }
+
+  private SSLSocket createSocketWithEnabledProtocols(TlsVersion... tlsVersions) throws IOException {
+    SSLSocket socket = (SSLSocket) sslClient.socketFactory.createSocket();
+    socket.setEnabledProtocols(javaNames(tlsVersions));
+    return socket;
+  }
+
+  private static void assertEnabledProtocols(SSLSocket socket, TlsVersion... required) {
+    Set<String> actual = new LinkedHashSet<>(Arrays.asList(socket.getEnabledProtocols()));
+    Set<String> expected = new LinkedHashSet<>(Arrays.asList(javaNames(required)));
+    assertEquals(expected, actual);
+  }
+
+  private static String[] javaNames(TlsVersion... tlsVersions) {
+    String[] protocols = new String[tlsVersions.length];
+    for (int i = 0; i < tlsVersions.length; i++) {
+      protocols[i] = tlsVersions[i].javaName();
+    }
+    return protocols;
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/DiskLruCacheTest.java b/okhttp-tests/src/test/java/okhttp3/internal/DiskLruCacheTest.java
similarity index 72%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/DiskLruCacheTest.java
rename to okhttp-tests/src/test/java/okhttp3/internal/DiskLruCacheTest.java
index c996d202dd..be2d0be61d 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/DiskLruCacheTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/DiskLruCacheTest.java
@@ -13,9 +13,8 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal;
+package okhttp3.internal;
 
-import com.squareup.okhttp.internal.io.FileSystem;
 import java.io.File;
 import java.io.IOException;
 import java.util.ArrayDeque;
@@ -26,6 +25,7 @@
 import java.util.List;
 import java.util.NoSuchElementException;
 import java.util.concurrent.Executor;
+import okhttp3.internal.io.FileSystem;
 import okio.BufferedSink;
 import okio.BufferedSource;
 import okio.Okio;
@@ -37,10 +37,10 @@
 import org.junit.rules.TemporaryFolder;
 import org.junit.rules.Timeout;
 
-import static com.squareup.okhttp.internal.DiskLruCache.JOURNAL_FILE;
-import static com.squareup.okhttp.internal.DiskLruCache.JOURNAL_FILE_BACKUP;
-import static com.squareup.okhttp.internal.DiskLruCache.MAGIC;
-import static com.squareup.okhttp.internal.DiskLruCache.VERSION_1;
+import static okhttp3.internal.DiskLruCache.JOURNAL_FILE;
+import static okhttp3.internal.DiskLruCache.JOURNAL_FILE_BACKUP;
+import static okhttp3.internal.DiskLruCache.MAGIC;
+import static okhttp3.internal.DiskLruCache.VERSION_1;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNull;
@@ -50,7 +50,7 @@
 
 public final class DiskLruCacheTest {
   @Rule public final TemporaryFolder tempDir = new TemporaryFolder();
-  @Rule public final Timeout timeout = new Timeout(30 * 1000);
+  @Rule public final Timeout timeout = new Timeout(60 * 1000);
 
   private final FaultyFileSystem fileSystem = new FaultyFileSystem(FileSystem.SYSTEM);
   private final int appVersion = 100;
@@ -282,8 +282,8 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
   }
 
   /**
-   * Each read sees a snapshot of the file at the time read was called.
-   * This means that two reads of the same key can see different data.
+   * Each read sees a snapshot of the file at the time read was called. This means that two reads of
+   * the same key can see different data.
    */
   @Test public void readAndWriteOverlapsMaintainConsistency() throws Exception {
     DiskLruCache.Editor v1Creator = cache.edit("k1");
@@ -697,6 +697,199 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     }
   }
 
+  @Test public void rebuildJournalFailurePreventsEditors() throws Exception {
+    while (executor.jobs.isEmpty()) {
+      set("a", "a", "a");
+      set("b", "b", "b");
+    }
+
+    // Cause the rebuild action to fail.
+    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
+    executor.jobs.removeFirst().run();
+
+    // Don't allow edits under any circumstances.
+    assertNull(cache.edit("a"));
+    assertNull(cache.edit("c"));
+    DiskLruCache.Snapshot snapshot = cache.get("a");
+    assertNull(snapshot.edit());
+    snapshot.close();
+  }
+
+  @Test public void rebuildJournalFailureIsRetried() throws Exception {
+    while (executor.jobs.isEmpty()) {
+      set("a", "a", "a");
+      set("b", "b", "b");
+    }
+
+    // Cause the rebuild action to fail.
+    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
+    executor.jobs.removeFirst().run();
+
+    // The rebuild is retried on cache hits and on cache edits.
+    DiskLruCache.Snapshot snapshot = cache.get("b");
+    snapshot.close();
+    assertNull(cache.edit("d"));
+    assertEquals(2, executor.jobs.size());
+
+    // On cache misses, no retry job is queued.
+    assertNull(cache.get("c"));
+    assertEquals(2, executor.jobs.size());
+
+    // Let the rebuild complete successfully.
+    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), false);
+    executor.jobs.removeFirst().run();
+    assertJournalEquals("CLEAN a 1 1", "CLEAN b 1 1");
+  }
+
+  @Test public void rebuildJournalFailureWithInFlightEditors() throws Exception {
+    while (executor.jobs.isEmpty()) {
+      set("a", "a", "a");
+      set("b", "b", "b");
+    }
+    DiskLruCache.Editor commitEditor = cache.edit("c");
+    DiskLruCache.Editor abortEditor = cache.edit("d");
+    cache.edit("e"); // Grab an editor, but don't do anything with it.
+
+    // Cause the rebuild action to fail.
+    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
+    executor.jobs.removeFirst().run();
+
+    // In-flight editors can commit and have their values retained.
+    setString(commitEditor, 0, "c");
+    setString(commitEditor, 1, "c");
+    commitEditor.commit();
+    assertValue("c", "c", "c");
+
+    abortEditor.abort();
+
+    // Let the rebuild complete successfully.
+    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), false);
+    executor.jobs.removeFirst().run();
+    assertJournalEquals("CLEAN a 1 1", "CLEAN b 1 1", "DIRTY e", "CLEAN c 1 1");
+  }
+
+  @Test public void rebuildJournalFailureWithEditorsInFlightThenClose() throws Exception {
+    while (executor.jobs.isEmpty()) {
+      set("a", "a", "a");
+      set("b", "b", "b");
+    }
+    DiskLruCache.Editor commitEditor = cache.edit("c");
+    DiskLruCache.Editor abortEditor = cache.edit("d");
+    cache.edit("e"); // Grab an editor, but don't do anything with it.
+
+    // Cause the rebuild action to fail.
+    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
+    executor.jobs.removeFirst().run();
+
+    setString(commitEditor, 0, "c");
+    setString(commitEditor, 1, "c");
+    commitEditor.commit();
+    assertValue("c", "c", "c");
+
+    abortEditor.abort();
+
+    cache.close();
+    createNewCache();
+
+    // Although 'c' successfully committed above, the journal wasn't available to issue a CLEAN op.
+    // Because the last state of 'c' was DIRTY before the journal failed, it should be removed
+    // entirely on a subsequent open.
+    assertEquals(4, cache.size());
+    assertAbsent("c");
+    assertAbsent("d");
+    assertAbsent("e");
+  }
+
+  @Test public void rebuildJournalFailureAllowsRemovals() throws Exception {
+    while (executor.jobs.isEmpty()) {
+      set("a", "a", "a");
+      set("b", "b", "b");
+    }
+
+    // Cause the rebuild action to fail.
+    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
+    executor.jobs.removeFirst().run();
+
+    assertTrue(cache.remove("a"));
+    assertAbsent("a");
+
+    // Let the rebuild complete successfully.
+    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), false);
+    executor.jobs.removeFirst().run();
+
+    assertJournalEquals("CLEAN b 1 1");
+  }
+
+  @Test public void rebuildJournalFailureWithRemovalThenClose() throws Exception {
+    while (executor.jobs.isEmpty()) {
+      set("a", "a", "a");
+      set("b", "b", "b");
+    }
+
+    // Cause the rebuild action to fail.
+    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
+    executor.jobs.removeFirst().run();
+
+    assertTrue(cache.remove("a"));
+    assertAbsent("a");
+
+    cache.close();
+    createNewCache();
+
+    // The journal will have no record that 'a' was removed. It will have an entry for 'a', but when
+    // it tries to read the cache files, it will find they were deleted. Once it encounters an entry
+    // with missing cache files, it should remove it from the cache entirely.
+    assertEquals(4, cache.size());
+    assertNull(cache.get("a"));
+    assertEquals(2, cache.size());
+  }
+
+  @Test public void rebuildJournalFailureAllowsEvictAll() throws Exception {
+    while (executor.jobs.isEmpty()) {
+      set("a", "a", "a");
+      set("b", "b", "b");
+    }
+
+    // Cause the rebuild action to fail.
+    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
+    executor.jobs.removeFirst().run();
+
+    cache.evictAll();
+
+    assertEquals(0, cache.size());
+    assertAbsent("a");
+    assertAbsent("b");
+
+    cache.close();
+    createNewCache();
+
+    // The journal has no record that 'a' and 'b' were removed. It will have an entry for both, but
+    // when it tries to read the cache files for either entry, it will discover the cache files are
+    // missing and remove the entries from the cache.
+    assertEquals(4, cache.size());
+    assertNull(cache.get("a"));
+    assertNull(cache.get("b"));
+    assertEquals(0, cache.size());
+  }
+
+  @Test public void rebuildJournalFailureWithCacheTrim() throws Exception {
+    while (executor.jobs.isEmpty()) {
+      set("a", "aa", "aa");
+      set("b", "bb", "bb");
+    }
+
+    // Cause the rebuild action to fail.
+    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
+    executor.jobs.removeFirst().run();
+
+    // Trigger a job to trim the cache.
+    cache.setMaxSize(4);
+    executor.jobs.removeFirst().run();
+
+    assertAbsent("a");
+    assertValue("b", "bb", "bb");
+  }
+
   @Test public void restoreBackupFile() throws Exception {
     DiskLruCache.Editor creator = cache.edit("k1");
     setString(creator, 0, "ABC");
@@ -763,6 +956,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     set("a", "a", "a");
     fileSystem.delete(getCleanFile("a", 1));
     assertNull(cache.get("a"));
+    assertEquals(0, cache.size());
   }
 
   @Test public void editSameVersion() throws Exception {
@@ -859,9 +1053,8 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
   }
 
   /**
-   * We had a long-lived bug where {@link DiskLruCache#trimToSize} could
-   * infinite loop if entries being edited required deletion for the operation
-   * to complete.
+   * We had a long-lived bug where {@link DiskLruCache#trimToSize} could infinite loop if entries
+   * being edited required deletion for the operation to complete.
    */
   @Test public void trimToSizeWithActiveEdit() throws Exception {
     set("a", "a1234", "a1234");
@@ -1074,11 +1267,11 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     set("b", "b", "b");
 
     // We can't begin the edit if writing 'DIRTY' fails.
-    fileSystem.setFaulty(journalFile, true);
+    fileSystem.setFaultyWrite(journalFile, true);
     assertNull(cache.edit("c"));
 
     // Once the journal has a failure, subsequent writes aren't permitted.
-    fileSystem.setFaulty(journalFile, false);
+    fileSystem.setFaultyWrite(journalFile, false);
     assertNull(cache.edit("d"));
 
     // Confirm that the fault didn't corrupt entries stored before the fault was introduced.
@@ -1102,11 +1295,11 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     DiskLruCache.Editor editor = cache.edit("c");
     setString(editor, 0, "c");
     setString(editor, 1, "c");
-    fileSystem.setFaulty(journalFile, true);
+    fileSystem.setFaultyWrite(journalFile, true);
     editor.commit();
 
     // Once the journal has a failure, subsequent writes aren't permitted.
-    fileSystem.setFaulty(journalFile, false);
+    fileSystem.setFaultyWrite(journalFile, false);
     assertNull(cache.edit("d"));
 
     // Confirm that the fault didn't corrupt entries stored before the fault was introduced.
@@ -1126,11 +1319,11 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     DiskLruCache.Editor editor = cache.edit("c");
     setString(editor, 0, "c");
     setString(editor, 1, "c");
-    fileSystem.setFaulty(journalFile, true);
+    fileSystem.setFaultyWrite(journalFile, true);
     editor.abort();
 
     // Once the journal has a failure, subsequent writes aren't permitted.
-    fileSystem.setFaulty(journalFile, false);
+    fileSystem.setFaultyWrite(journalFile, false);
     assertNull(cache.edit("d"));
 
     // Confirm that the fault didn't corrupt entries stored before the fault was introduced.
@@ -1147,17 +1340,276 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     set("b", "b", "b");
 
     // Remove, but the journal write will fail.
-    fileSystem.setFaulty(journalFile, true);
+    fileSystem.setFaultyWrite(journalFile, true);
     assertTrue(cache.remove("a"));
 
     // Confirm that the entry was still removed.
-    fileSystem.setFaulty(journalFile, false);
+    fileSystem.setFaultyWrite(journalFile, false);
     cache.close();
     cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, Integer.MAX_VALUE, executor);
     assertAbsent("a");
     assertValue("b", "b", "b");
   }
 
+  @Test public void cleanupTrimFailurePreventsNewEditors() throws Exception {
+    cache.setMaxSize(8);
+    executor.jobs.pop();
+    set("a", "aa", "aa");
+    set("b", "bb", "bbb");
+
+    // Cause the cache trim job to fail.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
+    executor.jobs.pop().run();
+
+    // Confirm that edits are prevented after a cache trim failure.
+    assertNull(cache.edit("a"));
+    assertNull(cache.edit("b"));
+    assertNull(cache.edit("c"));
+
+    // Allow the test to clean up.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
+  }
+
+  @Test public void cleanupTrimFailureRetriedOnEditors() throws Exception {
+    cache.setMaxSize(8);
+    executor.jobs.pop();
+    set("a", "aa", "aa");
+    set("b", "bb", "bbb");
+
+    // Cause the cache trim job to fail.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
+    executor.jobs.pop().run();
+
+    // An edit should now add a job to clean up if the most recent trim failed.
+    assertNull(cache.edit("b"));
+    executor.jobs.pop().run();
+
+    // Confirm a successful cache trim now allows edits.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
+    assertNull(cache.edit("c"));
+    executor.jobs.pop().run();
+    set("c", "cc", "cc");
+    assertValue("c", "cc", "cc");
+  }
+
+  @Test public void cleanupTrimFailureWithInFlightEditor() throws Exception {
+    cache.setMaxSize(8);
+    executor.jobs.pop();
+    set("a", "aa", "aaa");
+    set("b", "bb", "bb");
+    DiskLruCache.Editor inFlightEditor = cache.edit("c");
+
+    // Cause the cache trim job to fail.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
+    executor.jobs.pop().run();
+
+    // The in-flight editor can still write after a trim failure.
+    setString(inFlightEditor, 0, "cc");
+    setString(inFlightEditor, 1, "cc");
+    inFlightEditor.commit();
+
+    // Confirm the committed values are present after a successful cache trim.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
+    executor.jobs.pop().run();
+    assertValue("c", "cc", "cc");
+  }
+
+  @Test public void cleanupTrimFailureAllowsSnapshotReads() throws Exception {
+    cache.setMaxSize(8);
+    executor.jobs.pop();
+    set("a", "aa", "aa");
+    set("b", "bb", "bbb");
+
+    // Cause the cache trim job to fail.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
+    executor.jobs.pop().run();
+
+    // Confirm we still allow snapshot reads after a trim failure.
+    assertValue("a", "aa", "aa");
+    assertValue("b", "bb", "bbb");
+
+    // Allow the test to clean up.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
+  }
+
+  @Test public void cleanupTrimFailurePreventsSnapshotWrites() throws Exception {
+    cache.setMaxSize(8);
+    executor.jobs.pop();
+    set("a", "aa", "aa");
+    set("b", "bb", "bbb");
+
+    // Cause the cache trim job to fail.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
+    executor.jobs.pop().run();
+
+    // Confirm snapshot writes are prevented after a trim failure.
+    DiskLruCache.Snapshot snapshot1 = cache.get("a");
+    assertNull(snapshot1.edit());
+    snapshot1.close();
+    DiskLruCache.Snapshot snapshot2 = cache.get("b");
+    assertNull(snapshot2.edit());
+    snapshot2.close();
+
+    // Allow the test to clean up.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
+  }
+
+  @Test public void evictAllAfterCleanupTrimFailure() throws Exception {
+    cache.setMaxSize(8);
+    executor.jobs.pop();
+    set("a", "aa", "aa");
+    set("b", "bb", "bbb");
+
+    // Cause the cache trim job to fail.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
+    executor.jobs.pop().run();
+
+    // Confirm we prevent edits after a trim failure.
+    assertNull(cache.edit("c"));
+
+    // A successful eviction should allow new writes.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
+    cache.evictAll();
+    set("c", "cc", "cc");
+    assertValue("c", "cc", "cc");
+  }
+
+  @Test public void manualRemovalAfterCleanupTrimFailure() throws Exception {
+    cache.setMaxSize(8);
+    executor.jobs.pop();
+    set("a", "aa", "aa");
+    set("b", "bb", "bbb");
+
+    // Cause the cache trim job to fail.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
+    executor.jobs.pop().run();
+
+    // Confirm we prevent edits after a trim failure.
+    assertNull(cache.edit("c"));
+
+    // A successful removal which trims the cache should allow new writes.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
+    cache.remove("a");
+    set("c", "cc", "cc");
+    assertValue("c", "cc", "cc");
+  }
+
+  @Test public void flushingAfterCleanupTrimFailure() throws Exception {
+    cache.setMaxSize(8);
+    executor.jobs.pop();
+    set("a", "aa", "aa");
+    set("b", "bb", "bbb");
+
+    // Cause the cache trim job to fail.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
+    executor.jobs.pop().run();
+
+    // Confirm we prevent edits after a trim failure.
+    assertNull(cache.edit("c"));
+
+    // A successful flush trims the cache and should allow new writes.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
+    cache.flush();
+    set("c", "cc", "cc");
+    assertValue("c", "cc", "cc");
+  }
+
+  @Test public void cleanupTrimFailureWithPartialSnapshot() throws Exception {
+    cache.setMaxSize(8);
+    executor.jobs.pop();
+    set("a", "aa", "aa");
+    set("b", "bb", "bbb");
+
+    // Cause the cache trim to fail on the second value leaving a partial snapshot.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.1"), true);
+    executor.jobs.pop().run();
+
+    // Confirm the partial snapshot is not returned.
+    assertNull(cache.get("a"));
+
+    // Confirm we prevent edits after a trim failure.
+    assertNull(cache.edit("a"));
+
+    // Confirm the partial snapshot is not returned after a successful trim.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.1"), false);
+    executor.jobs.pop().run();
+    assertNull(cache.get("a"));
+  }
+
+  @Test public void noSizeCorruptionAfterCreatorDetached() throws Exception {
+    // Create an editor for k1. Detach it by clearing the cache.
+    DiskLruCache.Editor editor = cache.edit("k1");
+    setString(editor, 0, "a");
+    setString(editor, 1, "a");
+    cache.evictAll();
+
+    // Create a new value in its place.
+    set("k1", "bb", "bb");
+    assertEquals(4, cache.size());
+
+    // Committing the detached editor should not change the cache's size.
+    editor.commit();
+    assertEquals(4, cache.size());
+    assertValue("k1", "bb", "bb");
+  }
+
+  @Test public void noSizeCorruptionAfterEditorDetached() throws Exception {
+    set("k1", "a", "a");
+
+    // Create an editor for k1. Detach it by clearing the cache.
+    DiskLruCache.Editor editor = cache.edit("k1");
+    setString(editor, 0, "bb");
+    setString(editor, 1, "bb");
+    cache.evictAll();
+
+    // Create a new value in its place.
+    set("k1", "ccc", "ccc");
+    assertEquals(6, cache.size());
+
+    // Committing the detached editor should not change the cache's size.
+    editor.commit();
+    assertEquals(6, cache.size());
+    assertValue("k1", "ccc", "ccc");
+  }
+
+  @Test public void noNewSourceAfterEditorDetached() throws Exception {
+    set("k1", "a", "a");
+
+    DiskLruCache.Editor editor = cache.edit("k1");
+    cache.evictAll();
+
+    assertNull(editor.newSource(0));
+  }
+
+  @Test public void editsDiscardedAfterEditorDetached() throws Exception {
+    set("k1", "a", "a");
+
+    // Create an editor, then detach it.
+    DiskLruCache.Editor editor = cache.edit("k1");
+    BufferedSink sink = Okio.buffer(editor.newSink(0));
+    cache.evictAll();
+
+    // Create another value in its place.
+    set("k1", "ccc", "ccc");
+
+    // Complete the original edit. It goes into a black hole.
+    sink.writeUtf8("bb");
+    sink.close();
+
+    assertValue("k1", "ccc", "ccc");
+  }
+
+  @Test public void abortAfterDetach() throws Exception {
+    set("k1", "a", "a");
+
+    DiskLruCache.Editor editor = cache.edit("k1");
+    cache.evictAll();
+
+    editor.abort();
+    assertEquals(0, cache.size());
+    assertAbsent("k1");
+  }
+
   private void assertJournalEquals(String... expectedBodyLines) throws Exception {
     List<String> expectedLines = new ArrayList<>();
     expectedLines.add(MAGIC);
@@ -1259,7 +1711,7 @@ private void generateSomeGarbageFiles() throws Exception {
     writeFile(new File(dir2, "otherFile1"), "F");
   }
 
-  private void assertGarbageFilesAllDeleted() throws Exception {
+  private void assertGarbageFilesAllDeleted() {
     assertFalse(fileSystem.exists(getCleanFile("g1", 0)));
     assertFalse(fileSystem.exists(getCleanFile("g1", 1)));
     assertFalse(fileSystem.exists(getCleanFile("g2", 0)));
@@ -1275,7 +1727,8 @@ private void set(String key, String value0, String value1) throws Exception {
     editor.commit();
   }
 
-  public static void setString(DiskLruCache.Editor editor, int index, String value) throws IOException {
+  public static void setString(DiskLruCache.Editor editor, int index, String value)
+      throws IOException {
     BufferedSink writer = Okio.buffer(editor.newSink(index));
     writer.writeUtf8(value);
     writer.close();
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/DoubleInetAddressNetwork.java b/okhttp-tests/src/test/java/okhttp3/internal/DoubleInetAddressDns.java
similarity index 70%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/DoubleInetAddressNetwork.java
rename to okhttp-tests/src/test/java/okhttp3/internal/DoubleInetAddressDns.java
index 4934b427c9..7811ff5d75 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/DoubleInetAddressNetwork.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/DoubleInetAddressDns.java
@@ -13,18 +13,21 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal;
+package okhttp3.internal;
 
 import java.net.InetAddress;
 import java.net.UnknownHostException;
+import java.util.Arrays;
+import java.util.List;
+import okhttp3.Dns;
 
 /**
  * A network that always resolves two IP addresses per host. Use this when testing route selection
  * fallbacks to guarantee that a fallback address is available.
  */
-public class DoubleInetAddressNetwork implements Network {
-  @Override public InetAddress[] resolveInetAddresses(String host) throws UnknownHostException {
-    InetAddress[] allInetAddresses = Network.DEFAULT.resolveInetAddresses(host);
-    return new InetAddress[] { allInetAddresses[0], allInetAddresses[0] };
+public class DoubleInetAddressDns implements Dns {
+  @Override public List<InetAddress> lookup(String hostname) throws UnknownHostException {
+    List<InetAddress> addresses = Dns.SYSTEM.lookup(hostname);
+    return Arrays.asList(addresses.get(0), addresses.get(0));
   }
 }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/FaultyFileSystem.java b/okhttp-tests/src/test/java/okhttp3/internal/FaultyFileSystem.java
similarity index 75%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/FaultyFileSystem.java
rename to okhttp-tests/src/test/java/okhttp3/internal/FaultyFileSystem.java
index 537f361c38..3f237d0ad0 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/FaultyFileSystem.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/FaultyFileSystem.java
@@ -13,14 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal;
+package okhttp3.internal;
 
-import com.squareup.okhttp.internal.io.FileSystem;
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.util.LinkedHashSet;
 import java.util.Set;
+import okhttp3.internal.io.FileSystem;
 import okio.Buffer;
 import okio.ForwardingSink;
 import okio.Sink;
@@ -29,12 +29,14 @@
 public final class FaultyFileSystem implements FileSystem {
   private final FileSystem delegate;
   private final Set<File> writeFaults = new LinkedHashSet<>();
+  private final Set<File> deleteFaults = new LinkedHashSet<>();
+  private final Set<File> renameFaults = new LinkedHashSet<>();
 
   public FaultyFileSystem(FileSystem delegate) {
     this.delegate = delegate;
   }
 
-  public void setFaulty(File file, boolean faulty) {
+  public void setFaultyWrite(File file, boolean faulty) {
     if (faulty) {
       writeFaults.add(file);
     } else {
@@ -42,6 +44,22 @@ public void setFaulty(File file, boolean faulty) {
     }
   }
 
+  public void setFaultyDelete(File file, boolean faulty) {
+    if (faulty) {
+      deleteFaults.add(file);
+    } else {
+      deleteFaults.remove(file);
+    }
+  }
+
+  public void setFaultyRename(File file, boolean faulty) {
+    if (faulty) {
+      renameFaults.add(file);
+    } else {
+      renameFaults.remove(file);
+    }
+  }
+
   @Override public Source source(File file) throws FileNotFoundException {
     return delegate.source(file);
   }
@@ -55,10 +73,11 @@ public void setFaulty(File file, boolean faulty) {
   }
 
   @Override public void delete(File file) throws IOException {
+    if (deleteFaults.contains(file)) throw new IOException("boom!");
     delegate.delete(file);
   }
 
-  @Override public boolean exists(File file) throws IOException {
+  @Override public boolean exists(File file) {
     return delegate.exists(file);
   }
 
@@ -67,6 +86,7 @@ public void setFaulty(File file, boolean faulty) {
   }
 
   @Override public void rename(File from, File to) throws IOException {
+    if (renameFaults.contains(from) || renameFaults.contains(to)) throw new IOException("boom!");
     delegate.rename(from, to);
   }
 
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/Jdk9PlatformTest.java b/okhttp-tests/src/test/java/okhttp3/internal/Jdk9PlatformTest.java
new file mode 100644
index 0000000000..ed6deba9c7
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/Jdk9PlatformTest.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal;
+
+import org.junit.Test;
+
+import static okhttp3.internal.PlatformTest.getPlatform;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assume.assumeTrue;
+
+public class Jdk9PlatformTest {
+  @Test
+  public void buildsWhenJdk9() {
+    assumeTrue(getPlatform().equals("jdk9"));
+
+    assertNotNull(Jdk9Platform.buildIfSupported());
+  }
+
+  @Test
+  public void findsAlpnMethods() {
+    assumeTrue(getPlatform().equals("jdk9"));
+
+    Jdk9Platform platform = Jdk9Platform.buildIfSupported();
+
+    assertEquals("getApplicationProtocol", platform.getProtocolMethod.getName());
+    assertEquals("setApplicationProtocols", platform.setProtocolMethod.getName());
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/JdkWithJettyBootPlatformTest.java b/okhttp-tests/src/test/java/okhttp3/internal/JdkWithJettyBootPlatformTest.java
new file mode 100644
index 0000000000..04853ac106
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/JdkWithJettyBootPlatformTest.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal;
+
+import org.junit.Test;
+
+import static okhttp3.internal.PlatformTest.getPlatform;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assume.assumeTrue;
+
+public class JdkWithJettyBootPlatformTest {
+  @Test
+  public void testBuildsWithJettyBoot() {
+    assumeTrue(getPlatform().equals("jdk-with-jetty-boot"));
+
+    assertNotNull(JdkWithJettyBootPlatform.buildIfSupported());
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/OptionalMethodTest.java b/okhttp-tests/src/test/java/okhttp3/internal/OptionalMethodTest.java
similarity index 97%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/OptionalMethodTest.java
rename to okhttp-tests/src/test/java/okhttp3/internal/OptionalMethodTest.java
index 3e129a2353..08e025c5d9 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/OptionalMethodTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/OptionalMethodTest.java
@@ -15,12 +15,11 @@
  *  limitations under the License.
  */
 
-package com.squareup.okhttp.internal;
-
-import org.junit.Test;
+package okhttp3.internal;
 
 import java.io.IOException;
 import java.lang.reflect.InvocationTargetException;
+import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
@@ -38,7 +37,8 @@ public String stringMethod() {
       return "string";
     }
 
-    public void voidMethod() {}
+    public void voidMethod() {
+    }
   }
 
   @SuppressWarnings("unused")
@@ -70,7 +70,8 @@ public void throwsRuntimeException() throws Exception {
       throw new NumberFormatException();
     }
 
-    protected void nonPublic() {}
+    protected void nonPublic() {
+    }
   }
 
   private final static OptionalMethod<BaseClass> STRING_METHOD_RETURNS_ANY =
@@ -194,8 +195,10 @@ public void invokeBadArgs() throws Exception {
     assertIllegalArgumentExceptionOnInvoke(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1); // no args
     assertIllegalArgumentExceptionOnInvoke(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1, 123);
     assertIllegalArgumentExceptionOnInvoke(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1, true);
-    assertIllegalArgumentExceptionOnInvoke(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1, new Object());
-    assertIllegalArgumentExceptionOnInvoke(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1, "one", "two");
+    assertIllegalArgumentExceptionOnInvoke(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1,
+        new Object());
+    assertIllegalArgumentExceptionOnInvoke(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1, "one",
+        "two");
   }
 
   @Test
@@ -268,11 +271,15 @@ public void invokeOptional() throws Exception {
   @Test
   public void invokeOptionalBadArgs() throws Exception {
     SubClass1 subClass1 = new SubClass1();
-    assertIllegalArgumentExceptionOnInvokeOptional(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1); // no args
+    assertIllegalArgumentExceptionOnInvokeOptional(METHOD_WITH_ARGS_CORRECT_PARAMS,
+        subClass1); // no args
     assertIllegalArgumentExceptionOnInvokeOptional(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1, 123);
-    assertIllegalArgumentExceptionOnInvokeOptional(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1, true);
-    assertIllegalArgumentExceptionOnInvokeOptional(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1, new Object());
-    assertIllegalArgumentExceptionOnInvokeOptional(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1, "one", "two");
+    assertIllegalArgumentExceptionOnInvokeOptional(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1,
+        true);
+    assertIllegalArgumentExceptionOnInvokeOptional(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1,
+        new Object());
+    assertIllegalArgumentExceptionOnInvokeOptional(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1,
+        "one", "two");
   }
 
   @Test
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/PlatformTest.java b/okhttp-tests/src/test/java/okhttp3/internal/PlatformTest.java
new file mode 100644
index 0000000000..43e205d7dc
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/PlatformTest.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal;
+
+import org.junit.Test;
+
+public class PlatformTest {
+  @Test
+  public void alwaysBuilds() {
+    new Platform();
+  }
+
+  public static String getPlatform() {
+    return System.getProperty("okhttp.platform", "platform");
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/RecordingAuthenticator.java b/okhttp-tests/src/test/java/okhttp3/internal/RecordingAuthenticator.java
similarity index 97%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/RecordingAuthenticator.java
rename to okhttp-tests/src/test/java/okhttp3/internal/RecordingAuthenticator.java
index 292875bff6..aeb34f742f 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/RecordingAuthenticator.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/RecordingAuthenticator.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal;
+package okhttp3.internal;
 
 import java.net.Authenticator;
 import java.net.PasswordAuthentication;
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/RecordingOkAuthenticator.java b/okhttp-tests/src/test/java/okhttp3/internal/RecordingOkAuthenticator.java
similarity index 71%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/RecordingOkAuthenticator.java
rename to okhttp-tests/src/test/java/okhttp3/internal/RecordingOkAuthenticator.java
index f5b3617d9d..7d9d2bfe6a 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/RecordingOkAuthenticator.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/RecordingOkAuthenticator.java
@@ -13,14 +13,16 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal;
+package okhttp3.internal;
 
-import com.squareup.okhttp.Authenticator;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
+import java.io.IOException;
 import java.net.Proxy;
 import java.util.ArrayList;
 import java.util.List;
+import okhttp3.Authenticator;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.Route;
 
 public final class RecordingOkAuthenticator implements Authenticator {
   public final List<Response> responses = new ArrayList<>();
@@ -41,19 +43,12 @@ public Proxy onlyProxy() {
     return proxies.get(0);
   }
 
-  @Override public Request authenticate(Proxy proxy, Response response) {
+  @Override public Request authenticate(Route route, Response response) throws IOException {
     responses.add(response);
-    proxies.add(proxy);
+    proxies.add(route.proxy());
+    String header = response.code() == 407 ? "Proxy-Authorization" : "Authorization";
     return response.request().newBuilder()
-        .addHeader("Authorization", credential)
-        .build();
-  }
-
-  @Override public Request authenticateProxy(Proxy proxy, Response response) {
-    responses.add(response);
-    proxies.add(proxy);
-    return response.request().newBuilder()
-        .addHeader("Proxy-Authorization", credential)
+        .addHeader(header, credential)
         .build();
   }
 }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/SingleInetAddressNetwork.java b/okhttp-tests/src/test/java/okhttp3/internal/SingleInetAddressDns.java
similarity index 61%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/SingleInetAddressNetwork.java
rename to okhttp-tests/src/test/java/okhttp3/internal/SingleInetAddressDns.java
index beb48cb2e1..03e8ce08e9 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/SingleInetAddressNetwork.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/SingleInetAddressDns.java
@@ -13,19 +13,21 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal;
+package okhttp3.internal;
 
 import java.net.InetAddress;
 import java.net.UnknownHostException;
+import java.util.Collections;
+import java.util.List;
+import okhttp3.Dns;
 
 /**
- * A network that resolves only one IP address per host. Use this when testing
- * route selection fallbacks to prevent the host machine's various IP addresses
- * from interfering.
+ * A network that resolves only one IP address per host. Use this when testing route selection
+ * fallbacks to prevent the host machine's various IP addresses from interfering.
  */
-public class SingleInetAddressNetwork implements Network {
-  @Override public InetAddress[] resolveInetAddresses(String host) throws UnknownHostException {
-    InetAddress[] allInetAddresses = Network.DEFAULT.resolveInetAddresses(host);
-    return new InetAddress[] { allInetAddresses[0] };
+public class SingleInetAddressDns implements Dns {
+  @Override public List<InetAddress> lookup(String hostname) throws UnknownHostException {
+    List<InetAddress> addresses = Dns.SYSTEM.lookup(hostname);
+    return Collections.singletonList(addresses.get(0));
   }
 }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java b/okhttp-tests/src/test/java/okhttp3/internal/framed/BaseTestHandler.java
similarity index 97%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java
rename to okhttp-tests/src/test/java/okhttp3/internal/framed/BaseTestHandler.java
index d0b5e97ddb..d619feff7c 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/framed/BaseTestHandler.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.spdy;
+package okhttp3.internal.framed;
 
 import java.io.IOException;
 import java.util.List;
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HpackTest.java b/okhttp-tests/src/test/java/okhttp3/internal/framed/HpackTest.java
similarity index 98%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HpackTest.java
rename to okhttp-tests/src/test/java/okhttp3/internal/framed/HpackTest.java
index 1dcbc0192f..068ab647e7 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HpackTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/framed/HpackTest.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.spdy;
+package okhttp3.internal.framed;
 
 import java.io.IOException;
 import java.util.Arrays;
@@ -23,7 +23,7 @@
 import org.junit.Before;
 import org.junit.Test;
 
-import static com.squareup.okhttp.TestUtil.headerEntries;
+import static okhttp3.TestUtil.headerEntries;
 import static okio.ByteString.decodeHex;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
@@ -41,8 +41,8 @@
   }
 
   /**
-   * Variable-length quantity special cases strings which are longer than 127
-   * bytes.  Values such as cookies can be 4KiB, and should be possible to send.
+   * Variable-length quantity special cases strings which are longer than 127 bytes.  Values such as
+   * cookies can be 4KiB, and should be possible to send.
    *
    * <p> http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#section-5.2
    */
@@ -61,8 +61,8 @@
   }
 
   /**
-   * HPACK has a max header table size, which can be smaller than the max header message.
-   * Ensure the larger header content is not lost.
+   * HPACK has a max header table size, which can be smaller than the max header message. Ensure the
+   * larger header content is not lost.
    */
   @Test public void tooLargeToHPackIsStillEmitted() throws IOException {
     bytesIn.writeByte(0x00); // Literal indexed
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http2ConnectionTest.java b/okhttp-tests/src/test/java/okhttp3/internal/framed/Http2ConnectionTest.java
similarity index 69%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http2ConnectionTest.java
rename to okhttp-tests/src/test/java/okhttp3/internal/framed/Http2ConnectionTest.java
index a13fa53c08..67d6964d7f 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http2ConnectionTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/framed/Http2ConnectionTest.java
@@ -13,10 +13,10 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.spdy;
+package okhttp3.internal.framed;
 
-import com.squareup.okhttp.internal.Util;
 import java.io.IOException;
+import java.net.Socket;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
@@ -29,17 +29,23 @@
 import org.junit.After;
 import org.junit.Test;
 
-import static com.squareup.okhttp.TestUtil.headerEntries;
-import static com.squareup.okhttp.internal.spdy.ErrorCode.CANCEL;
-import static com.squareup.okhttp.internal.spdy.ErrorCode.PROTOCOL_ERROR;
-import static com.squareup.okhttp.internal.spdy.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
-import static com.squareup.okhttp.internal.spdy.Settings.PERSIST_VALUE;
-import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_DATA;
-import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_HEADERS;
-import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_PING;
-import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_RST_STREAM;
-import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_SETTINGS;
-import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_WINDOW_UPDATE;
+import static okhttp3.TestUtil.headerEntries;
+import static okhttp3.TestUtil.repeat;
+import static okhttp3.internal.Util.EMPTY_BYTE_ARRAY;
+import static okhttp3.internal.framed.ErrorCode.CANCEL;
+import static okhttp3.internal.framed.ErrorCode.PROTOCOL_ERROR;
+import static okhttp3.internal.framed.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
+import static okhttp3.internal.framed.Settings.ENABLE_PUSH;
+import static okhttp3.internal.framed.Settings.HEADER_TABLE_SIZE;
+import static okhttp3.internal.framed.Settings.INITIAL_WINDOW_SIZE;
+import static okhttp3.internal.framed.Settings.MAX_FRAME_SIZE;
+import static okhttp3.internal.framed.Settings.PERSIST_VALUE;
+import static okhttp3.internal.framed.Spdy3.TYPE_DATA;
+import static okhttp3.internal.framed.Spdy3.TYPE_HEADERS;
+import static okhttp3.internal.framed.Spdy3.TYPE_PING;
+import static okhttp3.internal.framed.Spdy3.TYPE_RST_STREAM;
+import static okhttp3.internal.framed.Spdy3.TYPE_SETTINGS;
+import static okhttp3.internal.framed.Spdy3.TYPE_WINDOW_UPDATE;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
@@ -82,7 +88,7 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, HTTP_2);
+    FramedConnection connection = connection(peer, HTTP_2);
     Ping ping = connection.ping();
     assertTrue(ping.roundTripTime() > 0);
     assertTrue(ping.roundTripTime() < TimeUnit.SECONDS.toNanos(1));
@@ -99,9 +105,9 @@
     peer.setVariantAndClient(HTTP_2, false);
 
     Settings initial = new Settings();
-    initial.set(Settings.INITIAL_WINDOW_SIZE, PERSIST_VALUE, 1684);
+    initial.set(INITIAL_WINDOW_SIZE, PERSIST_VALUE, 1684);
     Settings shouldntImpactConnection = new Settings();
-    shouldntImpactConnection.set(Settings.INITIAL_WINDOW_SIZE, PERSIST_VALUE, 3368);
+    shouldntImpactConnection.set(INITIAL_WINDOW_SIZE, PERSIST_VALUE, 3368);
 
     peer.sendFrame().settings(initial);
     peer.acceptFrame(); // ACK
@@ -110,7 +116,7 @@
     peer.acceptFrame(); // HEADERS
     peer.play();
 
-    SpdyConnection connection = connection(peer, HTTP_2);
+    FramedConnection connection = connection(peer, HTTP_2);
 
     // Default is 64KiB - 1.
     assertEquals(65535, connection.peerSettings.getInitialWindowSize(-1));
@@ -126,7 +132,7 @@
     assertTrue(ackFrame.ack);
 
     // This stream was created *after* the connection settings were adjusted.
-    SpdyStream stream = connection.newStream(headerEntries("a", "android"), false, true);
+    FramedStream stream = connection.newStream(headerEntries("a", "android"), false, true);
 
     assertEquals(3368, connection.peerSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE));
     assertEquals(1684, connection.bytesLeftInWriteWindow); // initial wasn't affected.
@@ -137,9 +143,9 @@
   @Test public void peerHttp2ServerZerosCompressionTable() throws Exception {
     boolean client = false; // Peer is server, so we are client.
     Settings settings = new Settings();
-    settings.set(Settings.HEADER_TABLE_SIZE, PERSIST_VALUE, 0);
+    settings.set(HEADER_TABLE_SIZE, PERSIST_VALUE, 0);
 
-    SpdyConnection connection = sendHttp2SettingsAndCheckForAck(client, settings);
+    FramedConnection connection = sendHttp2SettingsAndCheckForAck(client, settings);
 
     // verify the peer's settings were read and applied.
     assertEquals(0, connection.peerSettings.getHeaderTableSize());
@@ -151,9 +157,9 @@
   @Test public void peerHttp2ClientDisablesPush() throws Exception {
     boolean client = false; // Peer is client, so we are server.
     Settings settings = new Settings();
-    settings.set(Settings.ENABLE_PUSH, 0, 0); // The peer client disables push.
+    settings.set(ENABLE_PUSH, 0, 0); // The peer client disables push.
 
-    SpdyConnection connection = sendHttp2SettingsAndCheckForAck(client, settings);
+    FramedConnection connection = sendHttp2SettingsAndCheckForAck(client, settings);
 
     // verify the peer's settings were read and applied.
     assertFalse(connection.peerSettings.getEnablePush(true));
@@ -162,31 +168,75 @@
   @Test public void peerIncreasesMaxFrameSize() throws Exception {
     int newMaxFrameSize = 0x4001;
     Settings settings = new Settings();
-    settings.set(Settings.MAX_FRAME_SIZE, 0, newMaxFrameSize);
+    settings.set(MAX_FRAME_SIZE, 0, newMaxFrameSize);
 
-    SpdyConnection connection = sendHttp2SettingsAndCheckForAck(true, settings);
+    FramedConnection connection = sendHttp2SettingsAndCheckForAck(true, settings);
 
     // verify the peer's settings were read and applied.
     assertEquals(newMaxFrameSize, connection.peerSettings.getMaxFrameSize(-1));
     assertEquals(newMaxFrameSize, connection.frameWriter.maxDataLength());
   }
 
+  /**
+   * Webservers may set the initial window size to zero, which is a special case because it means
+   * that we have to flush headers immediately before any request body can be sent.
+   * https://github.com/square/okhttp/issues/2543
+   */
+  @Test public void peerSetsZeroFlowControl() throws Exception {
+    peer.setVariantAndClient(HTTP_2, true);
+
+    // Write the mocking script.
+    peer.sendFrame().settings(new Settings().set(INITIAL_WINDOW_SIZE, 0, 0));
+    peer.sendFrame().windowUpdate(0, 10); // Increase the connection window size.
+    peer.acceptFrame(); // PING or SETTINGS ACK
+    peer.acceptFrame(); // PING or SETTINGS ACK
+    peer.sendFrame().ping(true, 1, 0);
+    peer.acceptFrame(); // HEADERS STREAM 3
+    peer.sendFrame().windowUpdate(3, 5);
+    peer.acceptFrame(); // DATA STREAM 3 "abcde"
+    peer.sendFrame().windowUpdate(3, 5);
+    peer.acceptFrame(); // DATA STREAM 3 "fghi"
+    peer.play();
+
+    // Play it back.
+    FramedConnection connection = connection(peer, HTTP_2);
+    connection.ping().roundTripTime(); // Ensure the SETTINGS have been received.
+    FramedStream stream = connection.newStream(headerEntries("a", "android"), true, true);
+    BufferedSink sink = Okio.buffer(stream.getSink());
+    sink.writeUtf8("abcdefghi");
+    sink.flush();
+
+    // Verify the peer received what was expected.
+    peer.takeFrame(); // PING or SETTINGS ACK
+    peer.takeFrame(); // PING or SETTINGS ACK
+    MockSpdyPeer.InFrame headers = peer.takeFrame();
+    assertEquals(TYPE_HEADERS, headers.type);
+    MockSpdyPeer.InFrame data1 = peer.takeFrame();
+    assertEquals(TYPE_DATA, data1.type);
+    assertEquals(3, data1.streamId);
+    assertTrue(Arrays.equals("abcde".getBytes("UTF-8"), data1.data));
+    MockSpdyPeer.InFrame data2 = peer.takeFrame();
+    assertEquals(TYPE_DATA, data2.type);
+    assertEquals(3, data2.streamId);
+    assertTrue(Arrays.equals("fghi".getBytes("UTF-8"), data2.data));
+  }
+
   @Test public void receiveGoAwayHttp2() throws Exception {
     peer.setVariantAndClient(HTTP_2, false);
 
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM 3
     peer.acceptFrame(); // SYN_STREAM 5
-    peer.sendFrame().goAway(3, PROTOCOL_ERROR, Util.EMPTY_BYTE_ARRAY);
+    peer.sendFrame().goAway(3, PROTOCOL_ERROR, EMPTY_BYTE_ARRAY);
     peer.acceptFrame(); // PING
     peer.sendFrame().ping(true, 1, 0);
     peer.acceptFrame(); // DATA STREAM 3
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, HTTP_2);
-    SpdyStream stream1 = connection.newStream(headerEntries("a", "android"), true, true);
-    SpdyStream stream2 = connection.newStream(headerEntries("b", "banana"), true, true);
+    FramedConnection connection = connection(peer, HTTP_2);
+    FramedStream stream1 = connection.newStream(headerEntries("a", "android"), true, true);
+    FramedStream stream2 = connection.newStream(headerEntries("b", "banana"), true, true);
     connection.ping().roundTripTime(); // Ensure the GO_AWAY that resets stream2 has been received.
     BufferedSink sink1 = Okio.buffer(stream1.getSink());
     BufferedSink sink2 = Okio.buffer(stream2.getSink());
@@ -244,9 +294,9 @@
     peer.play();
 
     // Play it back.
-    SpdyConnection connection = connection(peer, HTTP_2);
-    connection.okHttpSettings.set(Settings.INITIAL_WINDOW_SIZE, 0, windowSize);
-    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), false, true);
+    FramedConnection connection = connection(peer, HTTP_2);
+    connection.okHttpSettings.set(INITIAL_WINDOW_SIZE, 0, windowSize);
+    FramedStream stream = connection.newStream(headerEntries("b", "banana"), false, true);
     assertEquals(0, stream.unacknowledgedBytesRead);
     assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
     Source in = stream.getSource();
@@ -284,8 +334,8 @@ private Buffer data(int byteCount) {
     peer.play();
 
     // Play it back.
-    SpdyConnection connection = connection(peer, HTTP_2);
-    SpdyStream client = connection.newStream(headerEntries("b", "banana"), false, true);
+    FramedConnection connection = connection(peer, HTTP_2);
+    FramedStream client = connection.newStream(headerEntries("b", "banana"), false, true);
     assertEquals(-1, client.getSource().read(new Buffer(), 1));
 
     // Verify the peer received what was expected.
@@ -304,10 +354,10 @@ private Buffer data(int byteCount) {
     peer.play();
 
     // Play it back.
-    SpdyConnection connection = connection(peer, HTTP_2);
-    SpdyStream client = connection.newStream(headerEntries("b", "banana"), true, true);
+    FramedConnection connection = connection(peer, HTTP_2);
+    FramedStream client = connection.newStream(headerEntries("b", "banana"), true, true);
     BufferedSink out = Okio.buffer(client.getSink());
-    out.write(Util.EMPTY_BYTE_ARRAY);
+    out.write(EMPTY_BYTE_ARRAY);
     out.flush();
     out.close();
 
@@ -331,8 +381,8 @@ private Buffer data(int byteCount) {
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, HTTP_2);
-    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
+    FramedConnection connection = connection(peer, HTTP_2);
+    FramedStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
     BufferedSink out = Okio.buffer(stream.getSink());
     out.write(buff);
     out.flush();
@@ -369,9 +419,11 @@ private Buffer data(int byteCount) {
     RecordingPushObserver observer = new RecordingPushObserver();
 
     // play it back
-    SpdyConnection connection = connectionBuilder(peer, HTTP_2)
-        .pushObserver(observer).build();
-    SpdyStream client = connection.newStream(headerEntries("b", "banana"), false, true);
+    FramedConnection connection = connectionBuilder(peer, HTTP_2)
+        .pushObserver(observer)
+        .build();
+    connection.start(false);
+    FramedStream client = connection.newStream(headerEntries("b", "banana"), false, true);
     assertEquals(-1, client.getSource().read(new Buffer(), 1));
 
     // verify the peer received what was expected
@@ -392,7 +444,8 @@ private Buffer data(int byteCount) {
     peer.play();
 
     // play it back
-    SpdyConnection connection = connectionBuilder(peer, HTTP_2).build();
+    FramedConnection connection = connectionBuilder(peer, HTTP_2).build();
+    connection.start(false);
     connection.newStream(headerEntries("b", "banana"), false, true);
 
     // verify the peer received what was expected
@@ -417,8 +470,10 @@ private Buffer data(int byteCount) {
     peer.play();
 
     // play it back
-    connectionBuilder(peer, HTTP_2)
-        .pushObserver(PushObserver.CANCEL).build();
+    FramedConnection connection = connectionBuilder(peer, HTTP_2)
+        .pushObserver(PushObserver.CANCEL)
+        .build();
+    connection.start(false);
 
     // verify the peer received what was expected
     MockSpdyPeer.InFrame rstStream = peer.takeFrame();
@@ -427,7 +482,40 @@ private Buffer data(int byteCount) {
     assertEquals(CANCEL, rstStream.errorCode);
   }
 
-  private SpdyConnection sendHttp2SettingsAndCheckForAck(boolean client, Settings settings)
+  /**
+   * When writing a set of headers fails due to an {@code IOException}, make sure the writer is left
+   * in a consistent state so the next writer also gets an {@code IOException} also instead of
+   * something worse (like an {@link IllegalStateException}.
+   *
+   * <p>See https://github.com/square/okhttp/issues/1651
+   */
+  @Test public void socketExceptionWhileWritingHeaders() throws Exception {
+    peer.setVariantAndClient(HTTP_2, false);
+    peer.acceptFrame(); // SYN_STREAM.
+    peer.play();
+
+    String longString = repeat('a', Http2.INITIAL_MAX_FRAME_SIZE + 1);
+    Socket socket = peer.openSocket();
+    FramedConnection connection = new FramedConnection.Builder(true)
+        .socket(socket)
+        .pushObserver(IGNORE)
+        .protocol(HTTP_2.getProtocol())
+        .build();
+    connection.start(false);
+    socket.shutdownOutput();
+    try {
+      connection.newStream(headerEntries("a", longString), false, true);
+      fail();
+    } catch (IOException expected) {
+    }
+    try {
+      connection.newStream(headerEntries("b", longString), false, true);
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  private FramedConnection sendHttp2SettingsAndCheckForAck(boolean client, Settings settings)
       throws IOException, InterruptedException {
     peer.setVariantAndClient(HTTP_2, client);
     peer.sendFrame().settings(settings);
@@ -437,7 +525,7 @@ private SpdyConnection sendHttp2SettingsAndCheckForAck(boolean client, Settings
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, HTTP_2);
+    FramedConnection connection = connection(peer, HTTP_2);
 
     // verify the peer received the ACK
     MockSpdyPeer.InFrame ackFrame = peer.takeFrame();
@@ -449,13 +537,16 @@ private SpdyConnection sendHttp2SettingsAndCheckForAck(boolean client, Settings
     return connection;
   }
 
-  private SpdyConnection connection(MockSpdyPeer peer, Variant variant) throws IOException {
-    return connectionBuilder(peer, variant).build();
+  private FramedConnection connection(MockSpdyPeer peer, Variant variant) throws IOException {
+    FramedConnection connection = connectionBuilder(peer, variant).build();
+    connection.start(false);
+    return connection;
   }
 
-  private SpdyConnection.Builder connectionBuilder(MockSpdyPeer peer, Variant variant)
+  private FramedConnection.Builder connectionBuilder(MockSpdyPeer peer, Variant variant)
       throws IOException {
-    return new SpdyConnection.Builder(true, peer.openSocket())
+    return new FramedConnection.Builder(true)
+        .socket(peer.openSocket())
         .pushObserver(IGNORE)
         .protocol(variant.getProtocol());
   }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http2FrameLoggerTest.java b/okhttp-tests/src/test/java/okhttp3/internal/framed/Http2FrameLoggerTest.java
similarity index 84%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http2FrameLoggerTest.java
rename to okhttp-tests/src/test/java/okhttp3/internal/framed/Http2FrameLoggerTest.java
index 0a0a9da8ab..864a368774 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http2FrameLoggerTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/framed/Http2FrameLoggerTest.java
@@ -13,26 +13,26 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.spdy;
+package okhttp3.internal.framed;
 
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
 import org.junit.Test;
 
-import static com.squareup.okhttp.internal.spdy.Http2.FLAG_ACK;
-import static com.squareup.okhttp.internal.spdy.Http2.FLAG_END_HEADERS;
-import static com.squareup.okhttp.internal.spdy.Http2.FLAG_END_STREAM;
-import static com.squareup.okhttp.internal.spdy.Http2.FLAG_NONE;
-import static com.squareup.okhttp.internal.spdy.Http2.FrameLogger.formatFlags;
-import static com.squareup.okhttp.internal.spdy.Http2.FrameLogger.formatHeader;
-import static com.squareup.okhttp.internal.spdy.Http2.TYPE_CONTINUATION;
-import static com.squareup.okhttp.internal.spdy.Http2.TYPE_DATA;
-import static com.squareup.okhttp.internal.spdy.Http2.TYPE_GOAWAY;
-import static com.squareup.okhttp.internal.spdy.Http2.TYPE_HEADERS;
-import static com.squareup.okhttp.internal.spdy.Http2.TYPE_PING;
-import static com.squareup.okhttp.internal.spdy.Http2.TYPE_PUSH_PROMISE;
-import static com.squareup.okhttp.internal.spdy.Http2.TYPE_SETTINGS;
+import static okhttp3.internal.framed.Http2.FLAG_ACK;
+import static okhttp3.internal.framed.Http2.FLAG_END_HEADERS;
+import static okhttp3.internal.framed.Http2.FLAG_END_STREAM;
+import static okhttp3.internal.framed.Http2.FLAG_NONE;
+import static okhttp3.internal.framed.Http2.FrameLogger.formatFlags;
+import static okhttp3.internal.framed.Http2.FrameLogger.formatHeader;
+import static okhttp3.internal.framed.Http2.TYPE_CONTINUATION;
+import static okhttp3.internal.framed.Http2.TYPE_DATA;
+import static okhttp3.internal.framed.Http2.TYPE_GOAWAY;
+import static okhttp3.internal.framed.Http2.TYPE_HEADERS;
+import static okhttp3.internal.framed.Http2.TYPE_PING;
+import static okhttp3.internal.framed.Http2.TYPE_PUSH_PROMISE;
+import static okhttp3.internal.framed.Http2.TYPE_SETTINGS;
 import static org.junit.Assert.assertEquals;
 
 public class Http2FrameLoggerTest {
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http2Test.java b/okhttp-tests/src/test/java/okhttp3/internal/framed/Http2Test.java
similarity index 96%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http2Test.java
rename to okhttp-tests/src/test/java/okhttp3/internal/framed/Http2Test.java
index 331514d623..0ae2f31c78 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http2Test.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/framed/Http2Test.java
@@ -13,12 +13,13 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.spdy;
+package okhttp3.internal.framed;
 
-import com.squareup.okhttp.internal.Util;
 import java.io.IOException;
 import java.util.Arrays;
 import java.util.List;
+import java.util.concurrent.atomic.AtomicInteger;
+import okhttp3.internal.Util;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -27,13 +28,13 @@
 import okio.Okio;
 import org.junit.Test;
 
-import static com.squareup.okhttp.TestUtil.headerEntries;
-import static com.squareup.okhttp.internal.spdy.Http2.FLAG_COMPRESSED;
-import static com.squareup.okhttp.internal.spdy.Http2.FLAG_END_HEADERS;
-import static com.squareup.okhttp.internal.spdy.Http2.FLAG_END_STREAM;
-import static com.squareup.okhttp.internal.spdy.Http2.FLAG_NONE;
-import static com.squareup.okhttp.internal.spdy.Http2.FLAG_PADDED;
-import static com.squareup.okhttp.internal.spdy.Http2.FLAG_PRIORITY;
+import static okhttp3.TestUtil.headerEntries;
+import static okhttp3.internal.framed.Http2.FLAG_COMPRESSED;
+import static okhttp3.internal.framed.Http2.FLAG_END_HEADERS;
+import static okhttp3.internal.framed.Http2.FLAG_END_STREAM;
+import static okhttp3.internal.framed.Http2.FLAG_NONE;
+import static okhttp3.internal.framed.Http2.FLAG_PADDED;
+import static okhttp3.internal.framed.Http2.FLAG_PRIORITY;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
@@ -268,7 +269,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     }
   }
 
-  @Test public void readSettingsFrameInvalidSettingId() throws IOException {
+  @Test public void readSettingsFrameUnknownSettingId() throws IOException {
     writeMedium(frame, 6); // 2 for the code and 4 for the value
     frame.writeByte(Http2.TYPE_SETTINGS);
     frame.writeByte(Http2.FLAG_NONE);
@@ -276,12 +277,13 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.writeShort(7); // old number for SETTINGS_INITIAL_WINDOW_SIZE
     frame.writeInt(1);
 
-    try {
-      fr.nextFrame(new BaseTestHandler());
-      fail();
-    } catch (IOException e) {
-      assertEquals("PROTOCOL_ERROR invalid settings id: 7", e.getMessage());
-    }
+    final AtomicInteger settingValue = new AtomicInteger();
+    fr.nextFrame(new BaseTestHandler() {
+      @Override public void settings(boolean clearPrevious, Settings settings) {
+        settingValue.set(settings.get(7));
+      }
+    });
+    assertEquals(settingValue.intValue(), 1);
   }
 
   @Test public void readSettingsFrameNegativeWindowSize() throws IOException {
@@ -729,7 +731,7 @@ private static Buffer gzip(byte[] data) throws IOException {
   private static List<Header> largeHeaders() {
     String[] nameValues = new String[32];
     char[] chars = new char[512];
-    for (int i = 0; i < nameValues.length;) {
+    for (int i = 0; i < nameValues.length; ) {
       Arrays.fill(chars, (char) i);
       nameValues[i++] = nameValues[i++] = String.valueOf(chars);
     }
@@ -738,7 +740,7 @@ private static Buffer gzip(byte[] data) throws IOException {
 
   private static void writeMedium(BufferedSink sink, int i) throws IOException {
     sink.writeByte((i >>> 16) & 0xff);
-    sink.writeByte((i >>>  8) & 0xff);
-    sink.writeByte( i         & 0xff);
+    sink.writeByte((i >>> 8) & 0xff);
+    sink.writeByte(i & 0xff);
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/framed/HttpOverHttp2Test.java b/okhttp-tests/src/test/java/okhttp3/internal/framed/HttpOverHttp2Test.java
new file mode 100644
index 0000000000..c747f0b7a4
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/framed/HttpOverHttp2Test.java
@@ -0,0 +1,137 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.framed;
+
+import okhttp3.Call;
+import okhttp3.Headers;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.PushPromise;
+import okhttp3.mockwebserver.RecordedRequest;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+
+public class HttpOverHttp2Test extends HttpOverSpdyTest {
+
+  public HttpOverHttp2Test() {
+    super(Protocol.HTTP_2);
+    this.hostHeader = ":authority";
+  }
+
+  @Test public void serverSendsPushPromise_GET() throws Exception {
+    PushPromise pushPromise = new PushPromise("GET", "/foo/bar", Headers.of("foo", "bar"),
+        new MockResponse().setBody("bar").setStatus("HTTP/1.1 200 Sweet"));
+    server.enqueue(new MockResponse()
+        .setBody("ABCDE")
+        .setStatus("HTTP/1.1 200 Sweet")
+        .withPush(pushPromise));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/foo"))
+        .build());
+    Response response = call.execute();
+
+    assertEquals("ABCDE", response.body().string());
+    assertEquals(200, response.code());
+    assertEquals("Sweet", response.message());
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
+    assertEquals("https", request.getHeader(":scheme"));
+    assertEquals(server.getHostName() + ":" + server.getPort(), request.getHeader(hostHeader));
+
+    RecordedRequest pushedRequest = server.takeRequest();
+    assertEquals("GET /foo/bar HTTP/1.1", pushedRequest.getRequestLine());
+    assertEquals("bar", pushedRequest.getHeader("foo"));
+  }
+
+  @Test public void serverSendsPushPromise_HEAD() throws Exception {
+    PushPromise pushPromise = new PushPromise("HEAD", "/foo/bar", Headers.of("foo", "bar"),
+        new MockResponse().setStatus("HTTP/1.1 204 Sweet"));
+    server.enqueue(new MockResponse()
+        .setBody("ABCDE")
+        .setStatus("HTTP/1.1 200 Sweet")
+        .withPush(pushPromise));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/foo"))
+        .build());
+    Response response = call.execute();
+    assertEquals("ABCDE", response.body().string());
+    assertEquals(200, response.code());
+    assertEquals("Sweet", response.message());
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
+    assertEquals("https", request.getHeader(":scheme"));
+    assertEquals(server.getHostName() + ":" + server.getPort(), request.getHeader(hostHeader));
+
+    RecordedRequest pushedRequest = server.takeRequest();
+    assertEquals("HEAD /foo/bar HTTP/1.1", pushedRequest.getRequestLine());
+    assertEquals("bar", pushedRequest.getHeader("foo"));
+  }
+
+  /**
+   * Push a setting that permits up to 2 concurrent streams, then make 3 concurrent requests and
+   * confirm that the third concurrent request prepared a new connection.
+   */
+  @Test public void settingsLimitsMaxConcurrentStreams() throws Exception {
+    Settings settings = new Settings();
+    settings.set(Settings.MAX_CONCURRENT_STREAMS, 0, 2);
+
+    // Read & write a full request to confirm settings are accepted.
+    server.enqueue(new MockResponse().withSettings(settings));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals("", response.body().string());
+
+    server.enqueue(new MockResponse()
+        .setBody("ABC"));
+    server.enqueue(new MockResponse()
+        .setBody("DEF"));
+    server.enqueue(new MockResponse()
+        .setBody("GHI"));
+
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response1 = call1.execute();
+
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+
+    Call call3 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response3 = call3.execute();
+
+    assertEquals("ABC", response1.body().string());
+    assertEquals("DEF", response2.body().string());
+    assertEquals("GHI", response3.body().string());
+    assertEquals(0, server.takeRequest().getSequenceNumber()); // Settings connection.
+    assertEquals(1, server.takeRequest().getSequenceNumber()); // Reuse settings connection.
+    assertEquals(2, server.takeRequest().getSequenceNumber()); // Reuse settings connection.
+    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection!
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdy3Test.java b/okhttp-tests/src/test/java/okhttp3/internal/framed/HttpOverSpdy3Test.java
similarity index 90%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdy3Test.java
rename to okhttp-tests/src/test/java/okhttp3/internal/framed/HttpOverSpdy3Test.java
index 4020bf4c25..6f7e793165 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdy3Test.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/framed/HttpOverSpdy3Test.java
@@ -13,9 +13,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.http;
+package okhttp3.internal.framed;
 
-import com.squareup.okhttp.Protocol;
+import okhttp3.Protocol;
 
 public class HttpOverSpdy3Test extends HttpOverSpdyTest {
 
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/framed/HttpOverSpdyTest.java b/okhttp-tests/src/test/java/okhttp3/internal/framed/HttpOverSpdyTest.java
new file mode 100644
index 0000000000..da09b4c91d
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/framed/HttpOverSpdyTest.java
@@ -0,0 +1,724 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.framed;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.Authenticator;
+import java.net.HttpURLConnection;
+import java.net.SocketTimeoutException;
+import java.util.Arrays;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import javax.net.ssl.HostnameVerifier;
+import okhttp3.Cache;
+import okhttp3.Call;
+import okhttp3.Cookie;
+import okhttp3.Credentials;
+import okhttp3.MediaType;
+import okhttp3.OkHttpClient;
+import okhttp3.Protocol;
+import okhttp3.RecordingCookieJar;
+import okhttp3.RecordingHostnameVerifier;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
+import okhttp3.internal.DoubleInetAddressDns;
+import okhttp3.internal.RecordingOkAuthenticator;
+import okhttp3.internal.SingleInetAddressDns;
+import okhttp3.internal.Util;
+import okhttp3.internal.tls.SslClient;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
+import okhttp3.mockwebserver.SocketPolicy;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.GzipSink;
+import okio.Okio;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
+
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static java.util.concurrent.TimeUnit.SECONDS;
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.fail;
+
+/** Test how SPDY interacts with HTTP features. */
+public abstract class HttpOverSpdyTest {
+  @Rule public final TemporaryFolder tempDir = new TemporaryFolder();
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  /** Protocol to test, for example {@link Protocol#SPDY_3} */
+  private final Protocol protocol;
+  protected String hostHeader = ":host";
+
+  protected SslClient sslClient = SslClient.localhost();
+  protected HostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
+  protected OkHttpClient client;
+  protected Cache cache;
+
+  protected HttpOverSpdyTest(Protocol protocol) {
+    this.protocol = protocol;
+  }
+
+  @Before public void setUp() throws Exception {
+    server.useHttps(sslClient.socketFactory, false);
+    cache = new Cache(tempDir.getRoot(), Integer.MAX_VALUE);
+    client = new OkHttpClient.Builder()
+        .protocols(Arrays.asList(protocol, Protocol.HTTP_1_1))
+        .dns(new SingleInetAddressDns())
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(hostnameVerifier)
+        .build();
+  }
+
+  @After public void tearDown() throws Exception {
+    Authenticator.setDefault(null);
+  }
+
+  @Test public void get() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("ABCDE")
+        .setStatus("HTTP/1.1 200 Sweet"));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/foo"))
+        .build());
+    Response response = call.execute();
+
+    assertEquals("ABCDE", response.body().string());
+    assertEquals(200, response.code());
+    assertEquals("Sweet", response.message());
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
+    assertEquals("https", request.getHeader(":scheme"));
+    assertEquals(server.getHostName() + ":" + server.getPort(), request.getHeader(hostHeader));
+  }
+
+  @Test public void emptyResponse() throws IOException {
+    server.enqueue(new MockResponse());
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/foo"))
+        .build());
+    Response response = call.execute();
+
+    assertEquals(-1, response.body().byteStream().read());
+    response.body().close();
+  }
+
+  byte[] postBytes = "FGHIJ".getBytes(Util.UTF_8);
+
+  @Test public void noDefaultContentLengthOnStreamingPost() throws Exception {
+    server.enqueue(new MockResponse().setBody("ABCDE"));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/foo"))
+        .post(new RequestBody() {
+          @Override public MediaType contentType() {
+            return MediaType.parse("text/plain; charset=utf-8");
+          }
+
+          @Override public void writeTo(BufferedSink sink) throws IOException {
+            sink.write(postBytes);
+          }
+        })
+        .build());
+
+    Response response = call.execute();
+    assertEquals("ABCDE", response.body().string());
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("POST /foo HTTP/1.1", request.getRequestLine());
+    assertArrayEquals(postBytes, request.getBody().readByteArray());
+    assertNull(request.getHeader("Content-Length"));
+  }
+
+  @Test public void userSuppliedContentLengthHeader() throws Exception {
+    server.enqueue(new MockResponse().setBody("ABCDE"));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/foo"))
+        .post(new RequestBody() {
+          @Override public MediaType contentType() {
+            return MediaType.parse("text/plain; charset=utf-8");
+          }
+
+          @Override public long contentLength() throws IOException {
+            return postBytes.length;
+          }
+
+          @Override public void writeTo(BufferedSink sink) throws IOException {
+            sink.write(postBytes);
+          }
+        })
+        .build());
+
+    Response response = call.execute();
+    assertEquals("ABCDE", response.body().string());
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("POST /foo HTTP/1.1", request.getRequestLine());
+    assertArrayEquals(postBytes, request.getBody().readByteArray());
+    assertEquals(postBytes.length, Integer.parseInt(request.getHeader("Content-Length")));
+  }
+
+  @Test public void closeAfterFlush() throws Exception {
+    server.enqueue(new MockResponse().setBody("ABCDE"));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/foo"))
+        .post(new RequestBody() {
+          @Override public MediaType contentType() {
+            return MediaType.parse("text/plain; charset=utf-8");
+          }
+
+          @Override public long contentLength() throws IOException {
+            return postBytes.length;
+          }
+
+          @Override public void writeTo(BufferedSink sink) throws IOException {
+            sink.write(postBytes);  // push bytes into SpdyDataOutputStream.buffer
+            sink.flush(); // FramedConnection.writeData subject to write window
+            sink.close(); // FramedConnection.writeData empty frame
+          }
+        })
+        .build());
+
+    Response response = call.execute();
+    assertEquals("ABCDE", response.body().string());
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("POST /foo HTTP/1.1", request.getRequestLine());
+    assertArrayEquals(postBytes, request.getBody().readByteArray());
+    assertEquals(postBytes.length, Integer.parseInt(request.getHeader("Content-Length")));
+  }
+
+  @Test public void spdyConnectionReuse() throws Exception {
+    server.enqueue(new MockResponse().setBody("ABCDEF"));
+    server.enqueue(new MockResponse().setBody("GHIJKL"));
+
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/r1"))
+        .build());
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/r1"))
+        .build());
+    Response response1 = call1.execute();
+    Response response2 = call2.execute();
+
+    assertEquals("ABC", response1.body().source().readUtf8(3));
+    assertEquals("GHI", response2.body().source().readUtf8(3));
+    assertEquals("DEF", response1.body().source().readUtf8(3));
+    assertEquals("JKL", response2.body().source().readUtf8(3));
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test @Ignore public void synchronousSpdyRequest() throws Exception {
+    server.enqueue(new MockResponse().setBody("A"));
+    server.enqueue(new MockResponse().setBody("A"));
+
+    ExecutorService executor = Executors.newCachedThreadPool();
+    CountDownLatch countDownLatch = new CountDownLatch(2);
+    executor.execute(new SpdyRequest("/r1", countDownLatch));
+    executor.execute(new SpdyRequest("/r2", countDownLatch));
+    countDownLatch.await();
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void gzippedResponseBody() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Content-Encoding: gzip")
+        .setBody(gzip("ABCABCABC")));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/r1"))
+        .build());
+
+    Response response = call.execute();
+    assertEquals("ABCABCABC", response.body().string());
+  }
+
+  @Test public void authenticate() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_UNAUTHORIZED)
+        .addHeader("www-authenticate: Basic realm=\"protected area\"")
+        .setBody("Please authenticate."));
+    server.enqueue(new MockResponse()
+        .setBody("Successful auth!"));
+
+    String credential = Credentials.basic("username", "password");
+    client = client.newBuilder()
+        .authenticator(new RecordingOkAuthenticator(credential))
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals("Successful auth!", response.body().string());
+
+    RecordedRequest denied = server.takeRequest();
+    assertNull(denied.getHeader("Authorization"));
+    RecordedRequest accepted = server.takeRequest();
+    assertEquals("GET / HTTP/1.1", accepted.getRequestLine());
+    assertEquals(credential, accepted.getHeader("Authorization"));
+  }
+
+  @Test public void redirect() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .addHeader("Location: /foo")
+        .setBody("This page has moved!"));
+    server.enqueue(new MockResponse().setBody("This is the new location!"));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+
+    Response response = call.execute();
+    assertEquals("This is the new location!", response.body().string());
+
+    RecordedRequest request1 = server.takeRequest();
+    assertEquals("/", request1.getPath());
+    RecordedRequest request2 = server.takeRequest();
+    assertEquals("/foo", request2.getPath());
+  }
+
+  @Test public void readAfterLastByte() throws Exception {
+    server.enqueue(new MockResponse().setBody("ABC"));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+
+    InputStream in = response.body().byteStream();
+    assertEquals('A', in.read());
+    assertEquals('B', in.read());
+    assertEquals('C', in.read());
+    assertEquals(-1, in.read());
+    assertEquals(-1, in.read());
+  }
+
+  @Ignore // See https://github.com/square/okhttp/issues/578
+  @Test(timeout = 3000) public void readResponseHeaderTimeout() throws Exception {
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.NO_RESPONSE));
+    server.enqueue(new MockResponse().setBody("A"));
+
+    client = client.newBuilder()
+        .readTimeout(1000, MILLISECONDS)
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals("A", response.body().string());
+  }
+
+  /**
+   * Test to ensure we don't  throw a read timeout on responses that are progressing.  For this
+   * case, we take a 4KiB body and throttle it to 1KiB/second.  We set the read timeout to two
+   * seconds.  If our implementation is acting correctly, it will not throw, as it is progressing.
+   */
+  @Test public void readTimeoutMoreGranularThanBodySize() throws Exception {
+    char[] body = new char[4096]; // 4KiB to read.
+    Arrays.fill(body, 'y');
+    server.enqueue(new MockResponse().setBody(new String(body))
+        .throttleBody(1024, 1, SECONDS)); // Slow connection 1KiB/second.
+
+    client = client.newBuilder()
+        .readTimeout(2, SECONDS)
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+
+    Response response = call.execute();
+    assertEquals(new String(body), response.body().string());
+  }
+
+  /**
+   * Test to ensure we throw a read timeout on responses that are progressing too slowly.  For this
+   * case, we take a 2KiB body and throttle it to 1KiB/second.  We set the read timeout to half a
+   * second.  If our implementation is acting correctly, it will throw, as a byte doesn't arrive in
+   * time.
+   */
+  @Test public void readTimeoutOnSlowConnection() throws Exception {
+    char[] body = new char[2048]; // 2KiB to read.
+    Arrays.fill(body, 'y');
+    server.enqueue(new MockResponse()
+        .setBody(new String(body))
+        .throttleBody(1024, 1, SECONDS)); // Slow connection 1KiB/second.
+
+    client = client.newBuilder()
+        .readTimeout(500, MILLISECONDS) // Half a second to read something.
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+
+    try {
+      response.body().string();
+      fail("Should have timed out!");
+    } catch (SocketTimeoutException expected) {
+      assertEquals("timeout", expected.getMessage());
+    }
+  }
+
+  @Test public void spdyConnectionTimeout() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .setBodyDelay(1, SECONDS));
+
+    OkHttpClient client1 = client.newBuilder()
+        .readTimeout(2000, MILLISECONDS)
+        .build();
+    Call call1 = client1
+        .newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+
+    OkHttpClient client2 = client.newBuilder()
+        .readTimeout(200, MILLISECONDS)
+        .build();
+    Call call2 = client2
+        .newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+
+    Response response1 = call1.execute();
+    assertEquals("A", response1.body().string());
+
+    try {
+      call2.execute();
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  @Test public void responsesAreCached() throws IOException {
+    client = client.newBuilder()
+        .cache(cache)
+        .build();
+
+    server.enqueue(new MockResponse()
+        .addHeader("cache-control: max-age=60")
+        .setBody("A"));
+
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response1 = call1.execute();
+
+    assertEquals("A", response1.body().string());
+    assertEquals(1, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(0, cache.hitCount());
+
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+    assertEquals("A", response2.body().string());
+
+    Call call3 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response3 = call3.execute();
+    assertEquals("A", response3.body().string());
+
+    assertEquals(3, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(2, cache.hitCount());
+  }
+
+  @Test public void conditionalCache() throws IOException {
+    client = client.newBuilder()
+        .cache(cache)
+        .build();
+
+    server.enqueue(new MockResponse()
+        .addHeader("ETag: v1")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response1 = call1.execute();
+    assertEquals("A", response1.body().string());
+
+    assertEquals(1, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(0, cache.hitCount());
+
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+    assertEquals("A", response2.body().string());
+
+    assertEquals(2, cache.requestCount());
+    assertEquals(2, cache.networkCount());
+    assertEquals(1, cache.hitCount());
+  }
+
+  @Test public void responseCachedWithoutConsumingFullBody() throws IOException {
+    client = client.newBuilder()
+        .cache(cache)
+        .build();
+
+    server.enqueue(new MockResponse()
+        .addHeader("cache-control: max-age=60")
+        .setBody("ABCD"));
+    server.enqueue(new MockResponse()
+        .addHeader("cache-control: max-age=60")
+        .setBody("EFGH"));
+
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response1 = call1.execute();
+    assertEquals("AB", response1.body().source().readUtf8(2));
+    response1.body().close();
+
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+    assertEquals("ABCD", response2.body().source().readUtf8());
+    response2.body().close();
+  }
+
+  @Test public void sendRequestCookies() throws Exception {
+    RecordingCookieJar cookieJar = new RecordingCookieJar();
+    Cookie requestCookie = new Cookie.Builder()
+        .name("a")
+        .value("b")
+        .domain(server.getHostName())
+        .build();
+    cookieJar.enqueueRequestCookies(requestCookie);
+    client = client.newBuilder()
+        .cookieJar(cookieJar)
+        .build();
+
+    server.enqueue(new MockResponse());
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals("", response.body().string());
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("a=b", request.getHeader("Cookie"));
+  }
+
+  @Test public void receiveResponseCookies() throws Exception {
+    RecordingCookieJar cookieJar = new RecordingCookieJar();
+    client = client.newBuilder()
+        .cookieJar(cookieJar)
+        .build();
+
+    server.enqueue(new MockResponse()
+        .addHeader("set-cookie: a=b"));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals("", response.body().string());
+
+    cookieJar.assertResponseCookies("a=b; path=/");
+  }
+
+  /** https://github.com/square/okhttp/issues/1191 */
+  @Test public void cancelWithStreamNotCompleted() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("abc"));
+    server.enqueue(new MockResponse()
+        .setBody("def"));
+
+    // Disconnect before the stream is created. A connection is still established!
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    call1.execute();
+    call1.cancel();
+
+    // That connection is pooled, and it works.
+    assertEquals(1, client.connectionPool().connectionCount());
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+    assertEquals("def", response2.body().string());
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void recoverFromOneRefusedStreamReusesConnection() throws Exception {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.RESET_STREAM_AT_START)
+        .setHttp2ErrorCode(ErrorCode.REFUSED_STREAM.httpCode));
+    server.enqueue(new MockResponse()
+        .setBody("abc"));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals("abc", response.body().string());
+
+    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
+    assertEquals(1, server.takeRequest().getSequenceNumber()); // Reused connection.
+  }
+
+  @Test public void recoverFromOneInternalErrorRequiresNewConnection() throws Exception {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.RESET_STREAM_AT_START)
+        .setHttp2ErrorCode(ErrorCode.INTERNAL_ERROR.httpCode));
+    server.enqueue(new MockResponse()
+        .setBody("abc"));
+
+    client = client.newBuilder()
+        .dns(new DoubleInetAddressDns())
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals("abc", response.body().string());
+
+    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
+    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
+  }
+
+  @Test public void recoverFromMultipleRefusedStreamsRequiresNewConnection() throws Exception {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.RESET_STREAM_AT_START)
+        .setHttp2ErrorCode(ErrorCode.REFUSED_STREAM.httpCode));
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.RESET_STREAM_AT_START)
+        .setHttp2ErrorCode(ErrorCode.REFUSED_STREAM.httpCode));
+    server.enqueue(new MockResponse()
+        .setBody("abc"));
+
+    client = client.newBuilder()
+        .dns(new DoubleInetAddressDns())
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals("abc", response.body().string());
+
+    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
+    assertEquals(1, server.takeRequest().getSequenceNumber()); // Reused connection.
+    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
+  }
+
+  @Test public void noRecoveryFromRefusedStreamWithRetryDisabled() throws Exception {
+    noRecoveryFromErrorWithRetryDisabled(ErrorCode.REFUSED_STREAM);
+  }
+
+  @Test public void noRecoveryFromInternalErrorWithRetryDisabled() throws Exception {
+    noRecoveryFromErrorWithRetryDisabled(ErrorCode.INTERNAL_ERROR);
+  }
+
+  private void noRecoveryFromErrorWithRetryDisabled(ErrorCode errorCode) throws Exception {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.RESET_STREAM_AT_START)
+        .setHttp2ErrorCode(errorCode.httpCode));
+    server.enqueue(new MockResponse()
+        .setBody("abc"));
+
+    client = client.newBuilder()
+        .retryOnConnectionFailure(false)
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    try {
+      call.execute();
+      fail();
+    } catch (StreamResetException expected) {
+      assertEquals(errorCode, expected.errorCode);
+    }
+  }
+
+  @Test public void nonAsciiResponseHeader() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeaderLenient("Alpha", "α")
+        .addHeaderLenient("β", "Beta"));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+
+    assertEquals("α", response.header("Alpha"));
+    assertEquals("Beta", response.header("β"));
+  }
+
+  public Buffer gzip(String bytes) throws IOException {
+    Buffer bytesOut = new Buffer();
+    BufferedSink sink = Okio.buffer(new GzipSink(bytesOut));
+    sink.writeUtf8(bytes);
+    sink.close();
+    return bytesOut;
+  }
+
+  class SpdyRequest implements Runnable {
+    String path;
+    CountDownLatch countDownLatch;
+
+    public SpdyRequest(String path, CountDownLatch countDownLatch) {
+      this.path = path;
+      this.countDownLatch = countDownLatch;
+    }
+
+    @Override public void run() {
+      try {
+        Call call = client.newCall(new Request.Builder()
+            .url(server.url(path))
+            .build());
+        Response response = call.execute();
+        assertEquals("A", response.body().string());
+        countDownLatch.countDown();
+      } catch (Exception e) {
+        throw new RuntimeException(e);
+      }
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HuffmanTest.java b/okhttp-tests/src/test/java/okhttp3/internal/framed/HuffmanTest.java
similarity index 97%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HuffmanTest.java
rename to okhttp-tests/src/test/java/okhttp3/internal/framed/HuffmanTest.java
index 222d23e150..b85a1b35b7 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HuffmanTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/framed/HuffmanTest.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.spdy;
+package okhttp3.internal.framed;
 
 import java.io.ByteArrayOutputStream;
 import java.io.DataOutputStream;
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java b/okhttp-tests/src/test/java/okhttp3/internal/framed/MockSpdyPeer.java
similarity index 90%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
rename to okhttp-tests/src/test/java/okhttp3/internal/framed/MockSpdyPeer.java
index bc5499cd47..edc8f41c30 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/framed/MockSpdyPeer.java
@@ -14,13 +14,13 @@
  * limitations under the License.
  */
 
-package com.squareup.okhttp.internal.spdy;
+package okhttp3.internal.framed;
 
-import com.squareup.okhttp.internal.Util;
 import java.io.Closeable;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
+import java.net.InetSocketAddress;
 import java.net.ServerSocket;
 import java.net.Socket;
 import java.util.ArrayList;
@@ -30,6 +30,8 @@
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.LinkedBlockingQueue;
+import java.util.logging.Logger;
+import okhttp3.internal.Util;
 import okio.Buffer;
 import okio.BufferedSource;
 import okio.ByteString;
@@ -37,6 +39,8 @@
 
 /** Replays prerecorded outgoing frames and records incoming frames. */
 public final class MockSpdyPeer implements Closeable {
+  private static final Logger logger = Logger.getLogger(MockSpdyPeer.class.getName());
+
   private int frameCount = 0;
   private boolean client = false;
   private Variant variant = new Spdy3();
@@ -79,8 +83,8 @@ public FrameWriter sendFrame() {
   }
 
   /**
-   * Sends a manually-constructed frame. This is useful to test frames that
-   * won't be generated naturally.
+   * Sends a manually-constructed frame. This is useful to test frames that won't be generated
+   * naturally.
    */
   public void sendFrame(byte[] frame) throws IOException {
     outFrames.add(new OutFrame(frameCount++, bytesOut.size(), false));
@@ -88,9 +92,9 @@ public void sendFrame(byte[] frame) throws IOException {
   }
 
   /**
-   * Shortens the last frame from its original length to {@code length}. This
-   * will cause the peer to close the socket as soon as this frame has been
-   * written; otherwise the peer stays open until explicitly closed.
+   * Shortens the last frame from its original length to {@code length}. This will cause the peer to
+   * close the socket as soon as this frame has been written; otherwise the peer stays open until
+   * explicitly closed.
    */
   public FrameWriter truncateLastFrame(int length) {
     OutFrame lastFrame = outFrames.remove(outFrames.size() - 1);
@@ -113,8 +117,9 @@ public InFrame takeFrame() throws InterruptedException {
 
   public void play() throws IOException {
     if (serverSocket != null) throw new IllegalStateException();
-    serverSocket = new ServerSocket(0);
-    serverSocket.setReuseAddress(true);
+    serverSocket = new ServerSocket();
+    serverSocket.setReuseAddress(false);
+    serverSocket.bind(new InetSocketAddress("localhost", 0), 1);
     port = serverSocket.getLocalPort();
     executor.execute(new Runnable() {
       @Override public void run() {
@@ -122,7 +127,7 @@ public void play() throws IOException {
           readAndWriteFrames();
         } catch (IOException e) {
           Util.closeQuietly(MockSpdyPeer.this);
-          e.printStackTrace();
+          logger.info(MockSpdyPeer.this + " done: " + e.getMessage());
         }
       }
     });
@@ -131,6 +136,15 @@ public void play() throws IOException {
   private void readAndWriteFrames() throws IOException {
     if (socket != null) throw new IllegalStateException();
     socket = serverSocket.accept();
+
+    // Bail out now if this instance was closed while waiting for the socket to accept.
+    synchronized (this) {
+      if (executor.isShutdown()) {
+        socket.close();
+        return;
+      }
+    }
+
     OutputStream out = socket.getOutputStream();
     InputStream in = socket.getInputStream();
     FrameReader reader = variant.newReader(Okio.buffer(Okio.source(in)), client);
@@ -180,16 +194,12 @@ public Socket openSocket() throws IOException {
 
   @Override public synchronized void close() throws IOException {
     executor.shutdown();
-    Socket socket = this.socket;
-    if (socket != null) {
-      Util.closeQuietly(socket);
-      this.socket = null;
-    }
-    ServerSocket serverSocket = this.serverSocket;
-    if (serverSocket != null) {
-      Util.closeQuietly(serverSocket);
-      this.serverSocket = null;
-    }
+    Util.closeQuietly(socket);
+    Util.closeQuietly(serverSocket);
+  }
+
+  @Override public String toString() {
+    return "MockSpdyPeer[" + port + "]";
   }
 
   private static class OutFrame {
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/SettingsTest.java b/okhttp-tests/src/test/java/okhttp3/internal/framed/SettingsTest.java
similarity index 91%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/SettingsTest.java
rename to okhttp-tests/src/test/java/okhttp3/internal/framed/SettingsTest.java
index f9f9efa32d..9eae7f89db 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/SettingsTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/framed/SettingsTest.java
@@ -13,17 +13,17 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.spdy;
+package okhttp3.internal.framed;
 
 import org.junit.Test;
 
-import static com.squareup.okhttp.internal.spdy.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
-import static com.squareup.okhttp.internal.spdy.Settings.DOWNLOAD_BANDWIDTH;
-import static com.squareup.okhttp.internal.spdy.Settings.DOWNLOAD_RETRANS_RATE;
-import static com.squareup.okhttp.internal.spdy.Settings.MAX_CONCURRENT_STREAMS;
-import static com.squareup.okhttp.internal.spdy.Settings.PERSISTED;
-import static com.squareup.okhttp.internal.spdy.Settings.PERSIST_VALUE;
-import static com.squareup.okhttp.internal.spdy.Settings.UPLOAD_BANDWIDTH;
+import static okhttp3.internal.framed.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
+import static okhttp3.internal.framed.Settings.DOWNLOAD_BANDWIDTH;
+import static okhttp3.internal.framed.Settings.DOWNLOAD_RETRANS_RATE;
+import static okhttp3.internal.framed.Settings.MAX_CONCURRENT_STREAMS;
+import static okhttp3.internal.framed.Settings.PERSISTED;
+import static okhttp3.internal.framed.Settings.PERSIST_VALUE;
+import static okhttp3.internal.framed.Settings.UPLOAD_BANDWIDTH;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3ConnectionTest.java b/okhttp-tests/src/test/java/okhttp3/internal/framed/Spdy3ConnectionTest.java
similarity index 80%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3ConnectionTest.java
rename to okhttp-tests/src/test/java/okhttp3/internal/framed/Spdy3ConnectionTest.java
index eb53e35ee6..96a6fb4288 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3ConnectionTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/framed/Spdy3ConnectionTest.java
@@ -13,17 +13,19 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.spdy;
+package okhttp3.internal.framed;
 
-import com.squareup.okhttp.internal.Util;
 import java.io.IOException;
 import java.io.InterruptedIOException;
+import java.net.Socket;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
+import java.util.Random;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
+import okhttp3.internal.Util;
 import okio.AsyncTimeout;
 import okio.Buffer;
 import okio.BufferedSink;
@@ -34,21 +36,26 @@
 import org.junit.After;
 import org.junit.Test;
 
-import static com.squareup.okhttp.TestUtil.headerEntries;
-import static com.squareup.okhttp.internal.spdy.ErrorCode.CANCEL;
-import static com.squareup.okhttp.internal.spdy.ErrorCode.INTERNAL_ERROR;
-import static com.squareup.okhttp.internal.spdy.ErrorCode.INVALID_STREAM;
-import static com.squareup.okhttp.internal.spdy.ErrorCode.PROTOCOL_ERROR;
-import static com.squareup.okhttp.internal.spdy.ErrorCode.REFUSED_STREAM;
-import static com.squareup.okhttp.internal.spdy.ErrorCode.STREAM_IN_USE;
-import static com.squareup.okhttp.internal.spdy.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
-import static com.squareup.okhttp.internal.spdy.Settings.PERSIST_VALUE;
-import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_DATA;
-import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_GOAWAY;
-import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_HEADERS;
-import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_PING;
-import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_RST_STREAM;
-import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_WINDOW_UPDATE;
+import static okhttp3.TestUtil.headerEntries;
+import static okhttp3.internal.framed.ErrorCode.CANCEL;
+import static okhttp3.internal.framed.ErrorCode.INTERNAL_ERROR;
+import static okhttp3.internal.framed.ErrorCode.INVALID_STREAM;
+import static okhttp3.internal.framed.ErrorCode.PROTOCOL_ERROR;
+import static okhttp3.internal.framed.ErrorCode.REFUSED_STREAM;
+import static okhttp3.internal.framed.ErrorCode.STREAM_IN_USE;
+import static okhttp3.internal.framed.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
+import static okhttp3.internal.framed.Settings.DOWNLOAD_BANDWIDTH;
+import static okhttp3.internal.framed.Settings.DOWNLOAD_RETRANS_RATE;
+import static okhttp3.internal.framed.Settings.INITIAL_WINDOW_SIZE;
+import static okhttp3.internal.framed.Settings.MAX_CONCURRENT_STREAMS;
+import static okhttp3.internal.framed.Settings.PERSIST_VALUE;
+import static okhttp3.internal.framed.Settings.UPLOAD_BANDWIDTH;
+import static okhttp3.internal.framed.Spdy3.TYPE_DATA;
+import static okhttp3.internal.framed.Spdy3.TYPE_GOAWAY;
+import static okhttp3.internal.framed.Spdy3.TYPE_HEADERS;
+import static okhttp3.internal.framed.Spdy3.TYPE_PING;
+import static okhttp3.internal.framed.Spdy3.TYPE_RST_STREAM;
+import static okhttp3.internal.framed.Spdy3.TYPE_WINDOW_UPDATE;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
@@ -72,8 +79,8 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, SPDY3);
-    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
+    FramedConnection connection = connection(peer, SPDY3);
+    FramedStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
     assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
     assertStreamData("robot", stream.getSource());
     BufferedSink out = Okio.buffer(stream.getSink());
@@ -101,9 +108,8 @@
     peer.sendFrame().ping(true, 1, 0);
     peer.play();
 
-    SpdyConnection connection = connection(peer, SPDY3);
-    SpdyStream stream = connection.newStream(headerEntries("a", "android"), false, false);
-    assertEquals(1, connection.openStreamCount());
+    FramedConnection connection = connection(peer, SPDY3);
+    FramedStream stream = connection.newStream(headerEntries("a", "android"), false, false);
     assertEquals(headerEntries("b", "banana"), stream.getResponseHeaders());
     connection.ping().roundTripTime(); // Ensure that inFinished has been received.
     assertEquals(0, connection.openStreamCount());
@@ -118,7 +124,7 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, SPDY3);
+    FramedConnection connection = connection(peer, SPDY3);
     connection.newStream(headerEntries("b", "banana"), false, true);
     assertEquals(1, connection.openStreamCount());
     connection.ping().roundTripTime(); // Ensure that the SYN_REPLY has been received.
@@ -148,15 +154,19 @@
 
     // play it back
     final AtomicInteger receiveCount = new AtomicInteger();
-    IncomingStreamHandler handler = new IncomingStreamHandler() {
-      @Override public void receive(SpdyStream stream) throws IOException {
+    FramedConnection.Listener handler = new FramedConnection.Listener() {
+      @Override public void onStream(FramedStream stream) throws IOException {
         receiveCount.incrementAndGet();
         assertEquals(pushHeaders, stream.getRequestHeaders());
         assertEquals(null, stream.getErrorCode());
         stream.reply(headerEntries("b", "banana"), true);
       }
     };
-    new SpdyConnection.Builder(true, peer.openSocket()).handler(handler).build();
+    FramedConnection connection = new FramedConnection.Builder(true)
+        .socket(peer.openSocket())
+        .listener(handler)
+        .build();
+    connection.start(false);
 
     // verify the peer received what was expected
     MockSpdyPeer.InFrame reply = peer.takeFrame();
@@ -176,14 +186,17 @@
 
     // play it back
     final AtomicInteger receiveCount = new AtomicInteger();
-    IncomingStreamHandler handler = new IncomingStreamHandler() {
-      @Override public void receive(SpdyStream stream) throws IOException {
+    FramedConnection.Listener listener = new FramedConnection.Listener() {
+      @Override public void onStream(FramedStream stream) throws IOException {
         stream.reply(headerEntries("b", "banana"), false);
         receiveCount.incrementAndGet();
       }
     };
 
-    connectionBuilder(peer, SPDY3).handler(handler).build();
+    FramedConnection connection = connectionBuilder(peer, SPDY3)
+        .listener(listener)
+        .build();
+    connection.start(false);
 
     // verify the peer received what was expected
     MockSpdyPeer.InFrame reply = peer.takeFrame();
@@ -218,7 +231,7 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, SPDY3);
+    FramedConnection connection = connection(peer, SPDY3);
     Ping ping = connection.ping();
     assertTrue(ping.roundTripTime() > 0);
     assertTrue(ping.roundTripTime() < TimeUnit.SECONDS.toNanos(1));
@@ -252,73 +265,87 @@
 
   @Test public void serverSendsSettingsToClient() throws Exception {
     // write the mocking script
-    Settings settings = new Settings();
-    settings.set(Settings.MAX_CONCURRENT_STREAMS, PERSIST_VALUE, 10);
+    final Settings settings = new Settings();
+    settings.set(MAX_CONCURRENT_STREAMS, PERSIST_VALUE, 10);
     peer.sendFrame().settings(settings);
     peer.sendFrame().ping(false, 2, 0);
     peer.acceptFrame(); // PING
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, SPDY3);
+    final AtomicInteger maxConcurrentStreams = new AtomicInteger();
+    FramedConnection.Listener listener = new FramedConnection.Listener() {
+      @Override public void onStream(FramedStream stream) throws IOException {
+        throw new AssertionError();
+      }
+
+      @Override public void onSettings(FramedConnection connection) {
+        maxConcurrentStreams.set(connection.maxConcurrentStreams());
+      }
+    };
+    FramedConnection connection = connectionBuilder(peer, SPDY3)
+        .listener(listener)
+        .build();
+    connection.start(false);
 
     peer.takeFrame(); // Guarantees that the peer Settings frame has been processed.
     synchronized (connection) {
       assertEquals(10, connection.peerSettings.getMaxConcurrentStreams(-1));
     }
+    assertEquals(10, maxConcurrentStreams.get());
   }
 
   @Test public void multipleSettingsFramesAreMerged() throws Exception {
     // write the mocking script
     Settings settings1 = new Settings();
-    settings1.set(Settings.UPLOAD_BANDWIDTH, PERSIST_VALUE, 100);
-    settings1.set(Settings.DOWNLOAD_BANDWIDTH, PERSIST_VALUE, 200);
-    settings1.set(Settings.DOWNLOAD_RETRANS_RATE, 0, 300);
+    settings1.set(UPLOAD_BANDWIDTH, PERSIST_VALUE, 100);
+    settings1.set(DOWNLOAD_BANDWIDTH, PERSIST_VALUE, 200);
+    settings1.set(DOWNLOAD_RETRANS_RATE, 0, 300);
     peer.sendFrame().settings(settings1);
     Settings settings2 = new Settings();
-    settings2.set(Settings.DOWNLOAD_BANDWIDTH, 0, 400);
-    settings2.set(Settings.DOWNLOAD_RETRANS_RATE, PERSIST_VALUE, 500);
-    settings2.set(Settings.MAX_CONCURRENT_STREAMS, PERSIST_VALUE, 600);
+    settings2.set(DOWNLOAD_BANDWIDTH, 0, 400);
+    settings2.set(DOWNLOAD_RETRANS_RATE, PERSIST_VALUE, 500);
+    settings2.set(MAX_CONCURRENT_STREAMS, PERSIST_VALUE, 600);
     peer.sendFrame().settings(settings2);
     peer.sendFrame().ping(false, 2, 0);
     peer.acceptFrame();
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, SPDY3);
+    FramedConnection connection = connection(peer, SPDY3);
 
     peer.takeFrame(); // Guarantees that the Settings frame has been processed.
     synchronized (connection) {
       assertEquals(100, connection.peerSettings.getUploadBandwidth(-1));
-      assertEquals(PERSIST_VALUE, connection.peerSettings.flags(Settings.UPLOAD_BANDWIDTH));
+      assertEquals(PERSIST_VALUE, connection.peerSettings.flags(UPLOAD_BANDWIDTH));
       assertEquals(400, connection.peerSettings.getDownloadBandwidth(-1));
-      assertEquals(0, connection.peerSettings.flags(Settings.DOWNLOAD_BANDWIDTH));
+      assertEquals(0, connection.peerSettings.flags(DOWNLOAD_BANDWIDTH));
       assertEquals(500, connection.peerSettings.getDownloadRetransRate(-1));
-      assertEquals(PERSIST_VALUE, connection.peerSettings.flags(Settings.DOWNLOAD_RETRANS_RATE));
+      assertEquals(PERSIST_VALUE, connection.peerSettings.flags(DOWNLOAD_RETRANS_RATE));
       assertEquals(600, connection.peerSettings.getMaxConcurrentStreams(-1));
-      assertEquals(PERSIST_VALUE, connection.peerSettings.flags(Settings.MAX_CONCURRENT_STREAMS));
+      assertEquals(PERSIST_VALUE, connection.peerSettings.flags(MAX_CONCURRENT_STREAMS));
     }
   }
 
   @Test public void clearSettingsBeforeMerge() throws Exception {
     // write the mocking script
     Settings settings1 = new Settings();
-    settings1.set(Settings.UPLOAD_BANDWIDTH, PERSIST_VALUE, 100);
-    settings1.set(Settings.DOWNLOAD_BANDWIDTH, PERSIST_VALUE, 200);
-    settings1.set(Settings.DOWNLOAD_RETRANS_RATE, 0, 300);
+    settings1.set(UPLOAD_BANDWIDTH, PERSIST_VALUE, 100);
+    settings1.set(DOWNLOAD_BANDWIDTH, PERSIST_VALUE, 200);
+    settings1.set(DOWNLOAD_RETRANS_RATE, 0, 300);
     peer.sendFrame().settings(settings1);
     peer.sendFrame().ping(false, 2, 0);
     peer.acceptFrame();
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, SPDY3);
+    FramedConnection connection = connection(peer, SPDY3);
 
     peer.takeFrame(); // Guarantees that the Settings frame has been processed.
 
     // fake a settings frame with clear flag set.
     Settings settings2 = new Settings();
-    settings2.set(Settings.MAX_CONCURRENT_STREAMS, PERSIST_VALUE, 600);
+    settings2.set(MAX_CONCURRENT_STREAMS, PERSIST_VALUE, 600);
     connection.readerRunnable.settings(true, settings2);
 
     synchronized (connection) {
@@ -380,8 +407,8 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, SPDY3);
-    SpdyStream stream = connection.newStream(headerEntries("a", "android"), true, false);
+    FramedConnection connection = connection(peer, SPDY3);
+    FramedStream stream = connection.newStream(headerEntries("a", "android"), true, false);
     BufferedSink out = Okio.buffer(stream.getSink());
     out.writeUtf8("square");
     out.flush();
@@ -423,8 +450,8 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, SPDY3);
-    SpdyStream stream = connection.newStream(headerEntries("a", "android"), true, true);
+    FramedConnection connection = connection(peer, SPDY3);
+    FramedStream stream = connection.newStream(headerEntries("a", "android"), true, true);
     BufferedSink out = Okio.buffer(stream.getSink());
     connection.ping().roundTripTime(); // Ensure that the RST_CANCEL has been received.
     try {
@@ -454,8 +481,7 @@
   }
 
   /**
-   * Test that the client sends a RST_STREAM if doing so won't disrupt the
-   * output stream.
+   * Test that the client sends a RST_STREAM if doing so won't disrupt the output stream.
    */
   @Test public void clientClosesClientInputStream() throws Exception {
     // write the mocking script
@@ -464,8 +490,8 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, SPDY3);
-    SpdyStream stream = connection.newStream(headerEntries("a", "android"), false, true);
+    FramedConnection connection = connection(peer, SPDY3);
+    FramedStream stream = connection.newStream(headerEntries("a", "android"), false, true);
     Source in = stream.getSource();
     BufferedSink out = Okio.buffer(stream.getSink());
     in.close();
@@ -496,8 +522,7 @@
   }
 
   /**
-   * Test that the client doesn't send a RST_STREAM if doing so will disrupt
-   * the output stream.
+   * Test that the client doesn't send a RST_STREAM if doing so will disrupt the output stream.
    */
   @Test public void clientClosesClientInputStreamIfOutputStreamIsClosed() throws Exception {
     // write the mocking script
@@ -508,8 +533,8 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, SPDY3);
-    SpdyStream stream = connection.newStream(headerEntries("a", "android"), true, true);
+    FramedConnection connection = connection(peer, SPDY3);
+    FramedStream stream = connection.newStream(headerEntries("a", "android"), true, true);
     Source source = stream.getSource();
     BufferedSink out = Okio.buffer(stream.getSink());
     source.close();
@@ -552,8 +577,8 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, SPDY3);
-    SpdyStream stream = connection.newStream(headerEntries("a", "android"), false, true);
+    FramedConnection connection = connection(peer, SPDY3);
+    FramedStream stream = connection.newStream(headerEntries("a", "android"), false, true);
     Source source = stream.getSource();
     assertStreamData("square", source);
     connection.ping().roundTripTime(); // Ensure that inFinished has been received.
@@ -578,8 +603,8 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, SPDY3);
-    SpdyStream stream = connection.newStream(headerEntries("c", "cola"), true, true);
+    FramedConnection connection = connection(peer, SPDY3);
+    FramedStream stream = connection.newStream(headerEntries("c", "cola"), true, true);
     assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
     connection.ping().roundTripTime(); // Ensure that the 2nd SYN REPLY has been received.
     try {
@@ -611,15 +636,19 @@
 
     // play it back
     final AtomicInteger receiveCount = new AtomicInteger();
-    IncomingStreamHandler handler = new IncomingStreamHandler() {
-      @Override public void receive(SpdyStream stream) throws IOException {
+    FramedConnection.Listener listener = new FramedConnection.Listener() {
+      @Override public void onStream(FramedStream stream) throws IOException {
         receiveCount.incrementAndGet();
         assertEquals(headerEntries("a", "android"), stream.getRequestHeaders());
         assertEquals(null, stream.getErrorCode());
         stream.reply(headerEntries("c", "cola"), true);
       }
     };
-    new SpdyConnection.Builder(true, peer.openSocket()).handler(handler).build();
+    FramedConnection connection = new FramedConnection.Builder(true)
+        .socket(peer.openSocket())
+        .listener(listener)
+        .build();
+    connection.start(false);
 
     // verify the peer received what was expected
     MockSpdyPeer.InFrame reply = peer.takeFrame();
@@ -643,8 +672,8 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, SPDY3);
-    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
+    FramedConnection connection = connection(peer, SPDY3);
+    FramedStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
     assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
     assertStreamData("robot", stream.getSource());
 
@@ -668,8 +697,8 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, SPDY3);
-    SpdyStream stream = connection.newStream(headerEntries("a", "android"), true, true);
+    FramedConnection connection = connection(peer, SPDY3);
+    FramedStream stream = connection.newStream(headerEntries("a", "android"), true, true);
     assertEquals(headerEntries("b", "banana"), stream.getResponseHeaders());
 
     // verify the peer received what was expected
@@ -690,8 +719,8 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, SPDY3);
-    SpdyStream stream = connection.newStream(headerEntries("a", "android"), true, true);
+    FramedConnection connection = connection(peer, SPDY3);
+    FramedStream stream = connection.newStream(headerEntries("a", "android"), true, true);
     try {
       stream.getResponseHeaders();
       fail();
@@ -709,23 +738,22 @@
     assertEquals(2, ping.payload1);
   }
 
-
   @Test public void receiveGoAway() throws Exception {
     peer.setVariantAndClient(SPDY3, false);
 
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM 1
     peer.acceptFrame(); // SYN_STREAM 3
+    peer.acceptFrame(); // PING.
     peer.sendFrame().goAway(1, PROTOCOL_ERROR, Util.EMPTY_BYTE_ARRAY);
-    peer.acceptFrame(); // PING
     peer.sendFrame().ping(true, 1, 0);
     peer.acceptFrame(); // DATA STREAM 1
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, SPDY3);
-    SpdyStream stream1 = connection.newStream(headerEntries("a", "android"), true, true);
-    SpdyStream stream2 = connection.newStream(headerEntries("b", "banana"), true, true);
+    FramedConnection connection = connection(peer, SPDY3);
+    FramedStream stream1 = connection.newStream(headerEntries("a", "android"), true, true);
+    FramedStream stream2 = connection.newStream(headerEntries("b", "banana"), true, true);
     connection.ping().roundTripTime(); // Ensure the GO_AWAY that resets stream2 has been received.
     BufferedSink sink1 = Okio.buffer(stream1.getSink());
     BufferedSink sink2 = Okio.buffer(stream2.getSink());
@@ -772,7 +800,7 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, SPDY3);
+    FramedConnection connection = connection(peer, SPDY3);
     connection.newStream(headerEntries("a", "android"), true, true);
     Ping ping = connection.ping();
     connection.shutdown(PROTOCOL_ERROR);
@@ -796,7 +824,7 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, SPDY3);
+    FramedConnection connection = connection(peer, SPDY3);
     connection.shutdown(INTERNAL_ERROR);
     try {
       connection.ping();
@@ -819,8 +847,8 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, SPDY3);
-    SpdyStream stream = connection.newStream(headerEntries("a", "android"), true, true);
+    FramedConnection connection = connection(peer, SPDY3);
+    FramedStream stream = connection.newStream(headerEntries("a", "android"), true, true);
     assertEquals(1, connection.openStreamCount());
     connection.close();
     assertEquals(0, connection.openStreamCount());
@@ -863,7 +891,7 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, SPDY3);
+    FramedConnection connection = connection(peer, SPDY3);
     Ping ping = connection.ping();
     connection.close();
     assertEquals(-1, ping.roundTripTime());
@@ -876,8 +904,8 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, SPDY3);
-    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
+    FramedConnection connection = connection(peer, SPDY3);
+    FramedStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
     stream.readTimeout().timeout(500, TimeUnit.MILLISECONDS);
     long startNanos = System.nanoTime();
     try {
@@ -903,8 +931,8 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, SPDY3);
-    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
+    FramedConnection connection = connection(peer, SPDY3);
+    FramedStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
     stream.readTimeout().timeout(500, TimeUnit.MILLISECONDS);
     Source source = stream.getSource();
     long startNanos = System.nanoTime();
@@ -925,7 +953,7 @@
 
   @Test public void writeTimesOutAwaitingStreamWindow() throws Exception {
     // Set the peer's receive window to 5 bytes!
-    Settings peerSettings = new Settings().set(Settings.INITIAL_WINDOW_SIZE, PERSIST_VALUE, 5);
+    Settings peerSettings = new Settings().set(INITIAL_WINDOW_SIZE, PERSIST_VALUE, 5);
 
     // write the mocking script
     peer.sendFrame().settings(peerSettings);
@@ -938,9 +966,9 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, SPDY3);
+    FramedConnection connection = connection(peer, SPDY3);
     connection.ping().roundTripTime(); // Make sure settings have been received.
-    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
+    FramedStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
     Sink sink = stream.getSink();
     sink.write(new Buffer().writeUtf8("abcde"), 5);
     stream.writeTimeout().timeout(500, TimeUnit.MILLISECONDS);
@@ -963,6 +991,47 @@
     assertEquals(TYPE_RST_STREAM, peer.takeFrame().type);
   }
 
+  @Test public void writeTimesOutAwaitingConnectionWindow() throws Exception {
+    // Set the peer's receive window to 5 bytes. Give the stream 5 bytes back, so only the
+    // connection-level window is applicable.
+    Settings peerSettings = new Settings().set(INITIAL_WINDOW_SIZE, PERSIST_VALUE, 5);
+
+    // write the mocking script
+    peer.sendFrame().settings(peerSettings);
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
+    peer.sendFrame().windowUpdate(1, 5);
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 0);
+    peer.acceptFrame(); // DATA
+    peer.acceptFrame(); // RST_STREAM
+    peer.play();
+
+    // play it back
+    FramedConnection connection = connection(peer, SPDY3);
+    FramedStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
+    connection.ping().roundTripTime(); // Make sure the window update has been received.
+    Sink sink = stream.getSink();
+    stream.writeTimeout().timeout(500, TimeUnit.MILLISECONDS);
+    sink.write(new Buffer().writeUtf8("abcdef"), 6);
+    long startNanos = System.nanoTime();
+    try {
+      sink.flush(); // This will time out waiting on the write window.
+      fail();
+    } catch (InterruptedIOException expected) {
+    }
+    long elapsedNanos = System.nanoTime() - startNanos;
+    awaitWatchdogIdle();
+    assertEquals(500d, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 200d /* 200ms delta */);
+    assertEquals(0, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    assertEquals(TYPE_HEADERS, peer.takeFrame().type);
+    assertEquals(TYPE_PING, peer.takeFrame().type);
+    assertEquals(TYPE_DATA, peer.takeFrame().type);
+    assertEquals(TYPE_RST_STREAM, peer.takeFrame().type);
+  }
+
   @Test public void outgoingWritesAreBatched() throws Exception {
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
@@ -971,8 +1040,8 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, SPDY3);
-    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
+    FramedConnection connection = connection(peer, SPDY3);
+    FramedStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
 
     // two outgoing writes
     Sink sink = stream.getSink();
@@ -998,8 +1067,8 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, SPDY3);
-    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
+    FramedConnection connection = connection(peer, SPDY3);
+    FramedStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
     connection.ping().roundTripTime(); // Ensure that the HEADERS has been received.
     assertEquals(headerEntries("a", "android", "c", "c3po"), stream.getResponseHeaders());
 
@@ -1021,8 +1090,8 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, SPDY3);
-    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
+    FramedConnection connection = connection(peer, SPDY3);
+    FramedStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
     connection.ping().roundTripTime(); // Ensure that the HEADERS has been received.
     try {
       stream.getResponseHeaders();
@@ -1063,9 +1132,9 @@
     peer.play();
 
     // Play it back.
-    SpdyConnection connection = connection(peer, SPDY3);
-    connection.okHttpSettings.set(Settings.INITIAL_WINDOW_SIZE, 0, windowSize);
-    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), false, true);
+    FramedConnection connection = connection(peer, SPDY3);
+    connection.okHttpSettings.set(INITIAL_WINDOW_SIZE, 0, windowSize);
+    FramedStream stream = connection.newStream(headerEntries("b", "banana"), false, true);
     assertEquals(0, stream.unacknowledgedBytesRead);
     assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
     Source in = stream.getSource();
@@ -1103,8 +1172,8 @@ private Buffer data(int byteCount) {
     peer.play();
 
     // Play it back.
-    SpdyConnection connection = connection(peer, SPDY3);
-    SpdyStream client = connection.newStream(headerEntries("b", "banana"), false, true);
+    FramedConnection connection = connection(peer, SPDY3);
+    FramedStream client = connection.newStream(headerEntries("b", "banana"), false, true);
     assertEquals(-1, client.getSource().read(new Buffer(), 1));
 
     // Verify the peer received what was expected.
@@ -1123,8 +1192,8 @@ private Buffer data(int byteCount) {
     peer.play();
 
     // Play it back.
-    SpdyConnection connection = connection(peer, SPDY3);
-    SpdyStream client = connection.newStream(headerEntries("b", "banana"), true, true);
+    FramedConnection connection = connection(peer, SPDY3);
+    FramedStream client = connection.newStream(headerEntries("b", "banana"), true, true);
     BufferedSink out = Okio.buffer(client.getSink());
     out.write(Util.EMPTY_BYTE_ARRAY);
     out.flush();
@@ -1145,8 +1214,8 @@ private Buffer data(int byteCount) {
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, SPDY3);
-    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
+    FramedConnection connection = connection(peer, SPDY3);
+    FramedStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
     assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
     Source in = stream.getSource();
     try {
@@ -1170,8 +1239,8 @@ private Buffer data(int byteCount) {
     peer.play();
 
     // Play it back.
-    SpdyConnection connection = connection(peer, SPDY3);
-    SpdyStream stream1 = connection.newStream(headerEntries("a", "apple"), true, true);
+    FramedConnection connection = connection(peer, SPDY3);
+    FramedStream stream1 = connection.newStream(headerEntries("a", "apple"), true, true);
     BufferedSink out1 = Okio.buffer(stream1.getSink());
     out1.write(new byte[DEFAULT_INITIAL_WINDOW_SIZE]);
     out1.flush();
@@ -1187,7 +1256,7 @@ private Buffer data(int byteCount) {
     assertEquals(0, connection.getStream(1).bytesLeftInWriteWindow);
 
     // Another stream should be able to send data even though 1 is blocked.
-    SpdyStream stream2 = connection.newStream(headerEntries("b", "banana"), true, true);
+    FramedStream stream2 = connection.newStream(headerEntries("b", "banana"), true, true);
     BufferedSink out2 = Okio.buffer(stream2.getSink());
     out2.writeUtf8("foo");
     out2.flush();
@@ -1260,20 +1329,53 @@ private void headerBlockHasTrailingCompressedBytes(String frame, int length) thr
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, SPDY3);
-    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
+    FramedConnection connection = connection(peer, SPDY3);
+    FramedStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
     assertEquals("a", stream.getResponseHeaders().get(0).name.utf8());
     assertEquals(length, stream.getResponseHeaders().get(0).value.size());
     assertStreamData("robot", stream.getSource());
   }
 
-  private SpdyConnection connection(MockSpdyPeer peer, Variant variant) throws IOException {
-    return connectionBuilder(peer, variant).build();
+  @Test public void socketExceptionWhileWritingHeaders() throws Exception {
+    peer.acceptFrame(); // SYN_STREAM.
+    peer.play();
+
+    String longString = ByteString.of(randomBytes(2048)).base64();
+    Socket socket = peer.openSocket();
+    FramedConnection connection = new FramedConnection.Builder(true)
+        .socket(socket)
+        .protocol(SPDY3.getProtocol())
+        .build();
+    connection.start(false);
+    socket.shutdownOutput();
+    try {
+      connection.newStream(headerEntries("a", longString), false, true);
+      fail();
+    } catch (IOException expected) {
+    }
+    try {
+      connection.newStream(headerEntries("b", longString), false, true);
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  private byte[] randomBytes(int length) {
+    byte[] bytes = new byte[length];
+    new Random(0).nextBytes(bytes);
+    return bytes;
+  }
+
+  private FramedConnection connection(MockSpdyPeer peer, Variant variant) throws IOException {
+    FramedConnection connection = connectionBuilder(peer, variant).build();
+    connection.start(false);
+    return connection;
   }
 
-  private SpdyConnection.Builder connectionBuilder(MockSpdyPeer peer, Variant variant)
+  private FramedConnection.Builder connectionBuilder(MockSpdyPeer peer, Variant variant)
       throws IOException {
-    return new SpdyConnection.Builder(true, peer.openSocket())
+    return new FramedConnection.Builder(true)
+        .socket(peer.openSocket())
         .protocol(variant.getProtocol());
   }
 
@@ -1282,15 +1384,6 @@ private void assertStreamData(String expected, Source source) throws IOException
     assertEquals(expected, actual);
   }
 
-  private void assertFlushBlocks(BufferedSink out) throws IOException {
-    interruptAfterDelay(500);
-    try {
-      out.flush();
-      fail();
-    } catch (InterruptedIOException expected) {
-    }
-  }
-
   /** Interrupts the current thread after {@code delayMillis}. */
   private void interruptAfterDelay(final long delayMillis) {
     final Thread toInterrupt = Thread.currentThread();
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3Test.java b/okhttp-tests/src/test/java/okhttp3/internal/framed/Spdy3Test.java
similarity index 97%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3Test.java
rename to okhttp-tests/src/test/java/okhttp3/internal/framed/Spdy3Test.java
index c902773c9f..953009ffc1 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3Test.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/framed/Spdy3Test.java
@@ -13,10 +13,10 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.spdy;
+package okhttp3.internal.framed;
 
-import com.squareup.okhttp.internal.Util;
 import java.io.IOException;
+import okhttp3.internal.Util;
 import okio.Buffer;
 import okio.ByteString;
 import org.junit.Test;
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/CookiesTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http/CookiesTest.java
new file mode 100644
index 0000000000..bf01f36fac
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http/CookiesTest.java
@@ -0,0 +1,294 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package okhttp3.internal.http;
+
+import java.io.IOException;
+import java.net.CookieHandler;
+import java.net.CookieManager;
+import java.net.HttpCookie;
+import java.net.HttpURLConnection;
+import java.net.InetAddress;
+import java.net.URI;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import okhttp3.Call;
+import okhttp3.HttpUrl;
+import okhttp3.JavaNetCookieJar;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
+import org.junit.Test;
+
+import static java.net.CookiePolicy.ACCEPT_ORIGINAL_SERVER;
+import static okhttp3.TestUtil.defaultClient;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+/** Derived from Android's CookiesTest. */
+public class CookiesTest {
+  private OkHttpClient client = defaultClient();
+
+  @Test
+  public void testNetscapeResponse() throws Exception {
+    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
+    client = client.newBuilder()
+        .cookieJar(new JavaNetCookieJar(cookieManager))
+        .build();
+    MockWebServer server = new MockWebServer();
+    server.start();
+
+    HttpUrl urlWithIpAddress = urlWithIpAddress(server, "/path/foo");
+    server.enqueue(new MockResponse().addHeader("Set-Cookie: a=android; "
+        + "expires=Fri, 31-Dec-9999 23:59:59 GMT; "
+        + "path=/path; "
+        + "domain=" + urlWithIpAddress.host() + "; "
+        + "secure"));
+    get(urlWithIpAddress);
+
+    List<HttpCookie> cookies = cookieManager.getCookieStore().getCookies();
+    assertEquals(1, cookies.size());
+    HttpCookie cookie = cookies.get(0);
+    assertEquals("a", cookie.getName());
+    assertEquals("android", cookie.getValue());
+    assertEquals(null, cookie.getComment());
+    assertEquals(null, cookie.getCommentURL());
+    assertEquals(false, cookie.getDiscard());
+    assertTrue(cookie.getMaxAge() > 100000000000L);
+    assertEquals("/path", cookie.getPath());
+    assertEquals(true, cookie.getSecure());
+    assertEquals(0, cookie.getVersion());
+  }
+
+  @Test public void testRfc2109Response() throws Exception {
+    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
+    client = client.newBuilder()
+        .cookieJar(new JavaNetCookieJar(cookieManager))
+        .build();
+    MockWebServer server = new MockWebServer();
+    server.start();
+
+    HttpUrl urlWithIpAddress = urlWithIpAddress(server, "/path/foo");
+    server.enqueue(new MockResponse().addHeader("Set-Cookie: a=android; "
+        + "Comment=this cookie is delicious; "
+        + "Domain=" + urlWithIpAddress.host() + "; "
+        + "Max-Age=60; "
+        + "Path=/path; "
+        + "Secure; "
+        + "Version=1"));
+    get(urlWithIpAddress);
+
+    List<HttpCookie> cookies = cookieManager.getCookieStore().getCookies();
+    assertEquals(1, cookies.size());
+    HttpCookie cookie = cookies.get(0);
+    assertEquals("a", cookie.getName());
+    assertEquals("android", cookie.getValue());
+    assertEquals(null, cookie.getCommentURL());
+    assertEquals(false, cookie.getDiscard());
+    assertEquals(60.0, cookie.getMaxAge(), 1.0); // Converting to a fixed date can cause rounding!
+    assertEquals("/path", cookie.getPath());
+    assertEquals(true, cookie.getSecure());
+  }
+
+  @Test public void testQuotedAttributeValues() throws Exception {
+    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
+    client = client.newBuilder()
+        .cookieJar(new JavaNetCookieJar(cookieManager))
+        .build();
+    MockWebServer server = new MockWebServer();
+    server.start();
+
+    HttpUrl urlWithIpAddress = urlWithIpAddress(server, "/path/foo");
+    server.enqueue(new MockResponse().addHeader("Set-Cookie: a=\"android\"; "
+        + "Comment=\"this cookie is delicious\"; "
+        + "CommentURL=\"http://google.com/\"; "
+        + "Discard; "
+        + "Domain=" + urlWithIpAddress.host() + "; "
+        + "Max-Age=60; "
+        + "Path=\"/path\"; "
+        + "Port=\"80,443," + server.getPort() + "\"; "
+        + "Secure; "
+        + "Version=\"1\""));
+    get(urlWithIpAddress);
+
+    List<HttpCookie> cookies = cookieManager.getCookieStore().getCookies();
+    assertEquals(1, cookies.size());
+    HttpCookie cookie = cookies.get(0);
+    assertEquals("a", cookie.getName());
+    assertEquals("android", cookie.getValue());
+    assertEquals(60.0, cookie.getMaxAge(), 1.0); // Converting to a fixed date can cause rounding!
+    assertEquals("/path", cookie.getPath());
+    assertEquals(true, cookie.getSecure());
+  }
+
+  @Test public void testSendingCookiesFromStore() throws Exception {
+    MockWebServer server = new MockWebServer();
+    server.enqueue(new MockResponse());
+    server.start();
+    HttpUrl serverUrl = urlWithIpAddress(server, "/");
+
+    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
+    HttpCookie cookieA = new HttpCookie("a", "android");
+    cookieA.setDomain(serverUrl.host());
+    cookieA.setPath("/");
+    cookieManager.getCookieStore().add(serverUrl.uri(), cookieA);
+    HttpCookie cookieB = new HttpCookie("b", "banana");
+    cookieB.setDomain(serverUrl.host());
+    cookieB.setPath("/");
+    cookieManager.getCookieStore().add(serverUrl.uri(), cookieB);
+    client = client.newBuilder()
+        .cookieJar(new JavaNetCookieJar(cookieManager))
+        .build();
+
+    get(serverUrl);
+    RecordedRequest request = server.takeRequest();
+
+    assertEquals("a=android; b=banana", request.getHeader("Cookie"));
+  }
+
+  @Test public void cookieHandlerLikeAndroid() throws Exception {
+    final MockWebServer server = new MockWebServer();
+    server.enqueue(new MockResponse());
+    server.start();
+    final HttpUrl serverUrl = urlWithIpAddress(server, "/");
+
+    CookieHandler androidCookieHandler = new CookieHandler() {
+      @Override public Map<String, List<String>> get(URI uri, Map<String, List<String>> map)
+          throws IOException {
+        return Collections.singletonMap("Cookie", Collections.singletonList("$Version=\"1\"; "
+            + "a=\"android\";$Path=\"/\";$Domain=\"" + serverUrl.host() + "\"; "
+            + "b=\"banana\";$Path=\"/\";$Domain=\"" + serverUrl.host() + "\""));
+      }
+
+      @Override public void put(URI uri, Map<String, List<String>> map) throws IOException {
+      }
+    };
+
+    client = client.newBuilder()
+        .cookieJar(new JavaNetCookieJar(androidCookieHandler))
+        .build();
+
+    get(serverUrl);
+    RecordedRequest request = server.takeRequest();
+
+    assertEquals("a=android; b=banana", request.getHeader("Cookie"));
+  }
+
+  @Test public void receiveAndSendMultipleCookies() throws Exception {
+    MockWebServer server = new MockWebServer();
+    server.enqueue(new MockResponse()
+        .addHeader("Set-Cookie", "a=android")
+        .addHeader("Set-Cookie", "b=banana"));
+    server.enqueue(new MockResponse());
+    server.start();
+
+    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
+    client = client.newBuilder()
+        .cookieJar(new JavaNetCookieJar(cookieManager))
+        .build();
+
+    get(urlWithIpAddress(server, "/"));
+    RecordedRequest request1 = server.takeRequest();
+    assertNull(request1.getHeader("Cookie"));
+
+    get(urlWithIpAddress(server, "/"));
+    RecordedRequest request2 = server.takeRequest();
+    assertEquals("a=android; b=banana", request2.getHeader("Cookie"));
+  }
+
+  @Test public void testRedirectsDoNotIncludeTooManyCookies() throws Exception {
+    MockWebServer redirectTarget = new MockWebServer();
+    redirectTarget.enqueue(new MockResponse().setBody("A"));
+    redirectTarget.start();
+    HttpUrl redirectTargetUrl = urlWithIpAddress(redirectTarget, "/");
+
+    MockWebServer redirectSource = new MockWebServer();
+    redirectSource.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .addHeader("Location: " + redirectTargetUrl));
+    redirectSource.start();
+    HttpUrl redirectSourceUrl = urlWithIpAddress(redirectSource, "/");
+
+    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
+    HttpCookie cookie = new HttpCookie("c", "cookie");
+    cookie.setDomain(redirectSourceUrl.host());
+    cookie.setPath("/");
+    String portList = Integer.toString(redirectSource.getPort());
+    cookie.setPortlist(portList);
+    cookieManager.getCookieStore().add(redirectSourceUrl.uri(), cookie);
+    client = client.newBuilder()
+        .cookieJar(new JavaNetCookieJar(cookieManager))
+        .build();
+
+    get(redirectSourceUrl);
+    RecordedRequest request = redirectSource.takeRequest();
+
+    assertEquals("c=cookie", request.getHeader("Cookie"));
+
+    for (String header : redirectTarget.takeRequest().getHeaders().names()) {
+      if (header.startsWith("Cookie")) {
+        fail(header);
+      }
+    }
+  }
+
+  @Test public void testCookiesSentIgnoresCase() throws Exception {
+    client = client.newBuilder()
+        .cookieJar(new JavaNetCookieJar(new CookieManager() {
+          @Override public Map<String, List<String>> get(URI uri,
+              Map<String, List<String>> requestHeaders) throws IOException {
+            Map<String, List<String>> result = new HashMap<>();
+            result.put("COOKIE", Collections.singletonList("Bar=bar"));
+            result.put("cooKIE2", Collections.singletonList("Baz=baz"));
+            return result;
+          }
+        }))
+        .build();
+
+    MockWebServer server = new MockWebServer();
+    server.enqueue(new MockResponse());
+    server.start();
+
+    get(server.url("/"));
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("Bar=bar; Baz=baz", request.getHeader("Cookie"));
+    assertNull(request.getHeader("Cookie2"));
+    assertNull(request.getHeader("Quux"));
+  }
+
+  private HttpUrl urlWithIpAddress(MockWebServer server, String path) throws Exception {
+    return server.url(path)
+        .newBuilder()
+        .host(InetAddress.getByName(server.getHostName()).getHostAddress())
+        .build();
+  }
+
+  private void get(HttpUrl url) throws Exception {
+    Call call = client.newCall(new Request.Builder()
+        .url(url)
+        .build());
+    Response response = call.execute();
+    response.body().close();
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/DisconnectTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http/DisconnectTest.java
similarity index 80%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/DisconnectTest.java
rename to okhttp-tests/src/test/java/okhttp3/internal/http/DisconnectTest.java
index 7a70d03e34..eb85913192 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/DisconnectTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http/DisconnectTest.java
@@ -13,14 +13,8 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.http;
-
-import com.squareup.okhttp.DelegatingServerSocketFactory;
-import com.squareup.okhttp.DelegatingSocketFactory;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.OkUrlFactory;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
+package okhttp3.internal.http;
+
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
@@ -28,14 +22,18 @@
 import java.net.ServerSocket;
 import java.net.Socket;
 import java.util.concurrent.TimeUnit;
-
+import javax.net.ServerSocketFactory;
+import javax.net.SocketFactory;
+import okhttp3.DelegatingServerSocketFactory;
+import okhttp3.DelegatingSocketFactory;
+import okhttp3.OkHttpClient;
+import okhttp3.OkUrlFactory;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
 import okio.Buffer;
 import org.junit.Before;
 import org.junit.Test;
 
-import javax.net.ServerSocketFactory;
-import javax.net.SocketFactory;
-
 import static org.junit.Assert.fail;
 
 public final class DisconnectTest {
@@ -47,25 +45,26 @@
   private OkHttpClient client;
 
   @Before public void setUp() throws Exception {
-    server = new MockWebServer();
-    client = new OkHttpClient();
-
     // Sockets on some platforms can have large buffers that mean writes do not block when
     // required. These socket factories explicitly set the buffer sizes on sockets created.
+    server = new MockWebServer();
     server.setServerSocketFactory(
         new DelegatingServerSocketFactory(ServerSocketFactory.getDefault()) {
-          @Override
-          protected void configureServerSocket(ServerSocket serverSocket) throws IOException {
+          @Override protected ServerSocket configureServerSocket(
+              ServerSocket serverSocket) throws IOException {
             serverSocket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
+            return serverSocket;
           }
         });
-    client.setSocketFactory(new DelegatingSocketFactory(SocketFactory.getDefault()) {
-      @Override
-      protected void configureSocket(Socket socket) throws IOException {
-        socket.setSendBufferSize(SOCKET_BUFFER_SIZE);
-        socket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
-      }
-    });
+    client = new OkHttpClient.Builder()
+        .socketFactory(new DelegatingSocketFactory(SocketFactory.getDefault()) {
+          @Override protected Socket configureSocket(Socket socket) throws IOException {
+            socket.setSendBufferSize(SOCKET_BUFFER_SIZE);
+            socket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
+            return socket;
+          }
+        })
+        .build();
   }
 
   @Test public void interruptWritingRequestBody() throws Exception {
@@ -75,7 +74,7 @@ protected void configureSocket(Socket socket) throws IOException {
         .throttleBody(64 * 1024, 125, TimeUnit.MILLISECONDS)); // 500 Kbps
     server.start();
 
-    HttpURLConnection connection = new OkUrlFactory(client).open(server.getUrl("/"));
+    HttpURLConnection connection = new OkUrlFactory(client).open(server.url("/").url());
     disconnectLater(connection, 500);
 
     connection.setDoOutput(true);
@@ -102,7 +101,7 @@ protected void configureSocket(Socket socket) throws IOException {
         .throttleBody(64 * 1024, 125, TimeUnit.MILLISECONDS)); // 500 Kbps
     server.start();
 
-    HttpURLConnection connection = new OkUrlFactory(client).open(server.getUrl("/"));
+    HttpURLConnection connection = new OkUrlFactory(client).open(server.url("/").url());
     disconnectLater(connection, 500);
 
     InputStream responseBody = connection.getInputStream();
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/ExternalHttp2Example.java b/okhttp-tests/src/test/java/okhttp3/internal/http/ExternalHttp2Example.java
new file mode 100644
index 0000000000..73f9471fac
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http/ExternalHttp2Example.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package okhttp3.internal.http;
+
+import okhttp3.Call;
+import okhttp3.OkHttpClient;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.internal.Util;
+
+public final class ExternalHttp2Example {
+  public static void main(String[] args) throws Exception {
+    OkHttpClient client = new OkHttpClient.Builder()
+        .protocols(Util.immutableList(Protocol.HTTP_2, Protocol.HTTP_1_1))
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url("https://www.google.ca/")
+        .build());
+
+    Response response = call.execute();
+    try {
+      System.out.println(response.code());
+      System.out.println("PROTOCOL " + response.protocol());
+
+      String line;
+      while ((line = response.body().source().readUtf8Line()) != null) {
+        System.out.println(line);
+      }
+    } finally {
+      response.body().close();
+    }
+
+    client.connectionPool().evictAll();
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/ExternalSpdyExample.java b/okhttp-tests/src/test/java/okhttp3/internal/http/ExternalSpdyExample.java
new file mode 100644
index 0000000000..c1598480ec
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http/ExternalSpdyExample.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package okhttp3.internal.http;
+
+import okhttp3.Call;
+import okhttp3.OkHttpClient;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.internal.Util;
+
+public final class ExternalSpdyExample {
+  public static void main(String[] args) throws Exception {
+    OkHttpClient client = new OkHttpClient.Builder()
+        .protocols(Util.immutableList(Protocol.SPDY_3, Protocol.HTTP_1_1))
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url("https://www.google.ca/")
+        .build());
+
+    Response response = call.execute();
+    try {
+      System.out.println(response.code());
+      System.out.println("PROTOCOL " + response.protocol());
+
+      String line;
+      while ((line = response.body().source().readUtf8Line()) != null) {
+        System.out.println(line);
+      }
+    } finally {
+      response.body().close();
+    }
+
+    client.connectionPool().evictAll();
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http/HeadersTest.java
similarity index 63%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java
rename to okhttp-tests/src/test/java/okhttp3/internal/http/HeadersTest.java
index 1d946228ae..84f37d13a3 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http/HeadersTest.java
@@ -13,25 +13,27 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.http;
+package okhttp3.internal.http;
 
-import com.squareup.okhttp.Headers;
-import com.squareup.okhttp.Protocol;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
-import com.squareup.okhttp.internal.spdy.Header;
 import java.io.IOException;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
-
+import okhttp3.Headers;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.internal.framed.Header;
+import org.junit.Assert;
 import org.junit.Test;
 
-import static com.squareup.okhttp.TestUtil.headerEntries;
+import static okhttp3.TestUtil.headerEntries;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 public final class HeadersTest {
@@ -42,24 +44,20 @@
         ":status", "200 OK",
         ":version", "HTTP/1.1");
     Request request = new Request.Builder().url("http://square.com/").build();
-    Response response =
-        SpdyTransport.readNameValueBlock(headerBlock, Protocol.SPDY_3).request(request).build();
+    Response response = Http2xStream.readSpdy3HeadersList(headerBlock).request(request).build();
     Headers headers = response.headers();
-    assertEquals(4, headers.size());
-    assertEquals(Protocol.SPDY_3, response.protocol());
+    assertEquals(3, headers.size());
+    Assert.assertEquals(Protocol.SPDY_3, response.protocol());
     assertEquals(200, response.code());
     assertEquals("OK", response.message());
     assertEquals("no-cache, no-store", headers.get("cache-control"));
     assertEquals("Cookie2", headers.get("set-cookie"));
-    assertEquals(Protocol.SPDY_3.toString(), headers.get(OkHeaders.SELECTED_PROTOCOL));
-    assertEquals(OkHeaders.SELECTED_PROTOCOL, headers.name(0));
-    assertEquals(Protocol.SPDY_3.toString(), headers.value(0));
-    assertEquals("cache-control", headers.name(1));
-    assertEquals("no-cache, no-store", headers.value(1));
+    assertEquals("cache-control", headers.name(0));
+    assertEquals("no-cache, no-store", headers.value(0));
+    assertEquals("set-cookie", headers.name(1));
+    assertEquals("Cookie1", headers.value(1));
     assertEquals("set-cookie", headers.name(2));
-    assertEquals("Cookie1", headers.value(2));
-    assertEquals("set-cookie", headers.name(3));
-    assertEquals("Cookie2", headers.value(3));
+    assertEquals("Cookie2", headers.value(2));
     assertNull(headers.get(":status"));
     assertNull(headers.get(":version"));
   }
@@ -70,12 +68,9 @@
         ":version", "HTTP/1.1",
         "connection", "close");
     Request request = new Request.Builder().url("http://square.com/").build();
-    Response response =
-        SpdyTransport.readNameValueBlock(headerBlock, Protocol.SPDY_3).request(request).build();
+    Response response = Http2xStream.readSpdy3HeadersList(headerBlock).request(request).build();
     Headers headers = response.headers();
-    assertEquals(1, headers.size());
-    assertEquals(OkHeaders.SELECTED_PROTOCOL, headers.name(0));
-    assertEquals(Protocol.SPDY_3.toString(), headers.value(0));
+    assertEquals(0, headers.size());
   }
 
   @Test public void readNameValueBlockDropsForbiddenHeadersHttp2() throws IOException {
@@ -84,15 +79,14 @@
         ":version", "HTTP/1.1",
         "connection", "close");
     Request request = new Request.Builder().url("http://square.com/").build();
-    Response response = SpdyTransport.readNameValueBlock(headerBlock, Protocol.HTTP_2)
-        .request(request).build();
+    Response response = Http2xStream.readHttp2HeadersList(headerBlock).request(request).build();
     Headers headers = response.headers();
     assertEquals(1, headers.size());
-    assertEquals(OkHeaders.SELECTED_PROTOCOL, headers.name(0));
-    assertEquals(Protocol.HTTP_2.toString(), headers.value(0));
+    assertEquals(":version", headers.name(0));
+    assertEquals("HTTP/1.1", headers.value(0));
   }
 
-  @Test public void toNameValueBlock() {
+  @Test public void spdy3HeadersList() {
     Request request = new Request.Builder()
         .url("http://square.com/")
         .header("cache-control", "no-cache, no-store")
@@ -100,8 +94,7 @@
         .addHeader("set-cookie", "Cookie2")
         .header(":status", "200 OK")
         .build();
-    List<Header> headerBlock =
-        SpdyTransport.writeNameValueBlock(request, Protocol.SPDY_3, "HTTP/1.1");
+    List<Header> headerBlock = Http2xStream.spdy3HeadersList(request);
     List<Header> expected = headerEntries(
         ":method", "GET",
         ":path", "/",
@@ -114,7 +107,7 @@
     assertEquals(expected, headerBlock);
   }
 
-  @Test public void toNameValueBlockDropsForbiddenHeadersSpdy3() {
+  @Test public void spdy3HeadersListDropsForbiddenHeadersSpdy3() {
     Request request = new Request.Builder()
         .url("http://square.com/")
         .header("Connection", "close")
@@ -126,10 +119,10 @@
         ":version", "HTTP/1.1",
         ":host", "square.com",
         ":scheme", "http");
-    assertEquals(expected, SpdyTransport.writeNameValueBlock(request, Protocol.SPDY_3, "HTTP/1.1"));
+    assertEquals(expected, Http2xStream.spdy3HeadersList(request));
   }
 
-  @Test public void toNameValueBlockDropsForbiddenHeadersHttp2() {
+  @Test public void http2HeadersListDropsForbiddenHeadersHttp2() {
     Request request = new Request.Builder()
         .url("http://square.com/")
         .header("Connection", "upgrade")
@@ -140,8 +133,7 @@
         ":path", "/",
         ":authority", "square.com",
         ":scheme", "http");
-    assertEquals(expected,
-        SpdyTransport.writeNameValueBlock(request, Protocol.HTTP_2, "HTTP/1.1"));
+    assertEquals(expected, Http2xStream.http2HeadersList(request));
   }
 
   @Test public void ofTrims() {
@@ -302,4 +294,102 @@
     } catch (IllegalArgumentException expected) {
     }
   }
+
+  @Test public void toMultimapGroupsHeaders() {
+    Headers headers = Headers.of(
+        "cache-control", "no-cache",
+        "cache-control", "no-store",
+        "user-agent", "OkHttp");
+    Map<String, List<String>> headerMap = headers.toMultimap();
+    assertEquals(2, headerMap.get("cache-control").size());
+    assertEquals(1, headerMap.get("user-agent").size());
+  }
+
+  @Test public void toMultimapUsesCanonicalCase() {
+    Headers headers = Headers.of(
+        "cache-control", "no-store",
+        "Cache-Control", "no-cache",
+        "User-Agent", "OkHttp");
+    Map<String, List<String>> headerMap = headers.toMultimap();
+    assertEquals(2, headerMap.get("cache-control").size());
+    assertEquals(1, headerMap.get("user-agent").size());
+  }
+
+  @Test public void nameIndexesAreStrict() {
+    Headers headers = Headers.of("a", "b", "c", "d");
+    try {
+      headers.name(-1);
+      fail();
+    } catch (IndexOutOfBoundsException expected) {
+    }
+    assertEquals("a", headers.name(0));
+    assertEquals("c", headers.name(1));
+    try {
+      headers.name(2);
+      fail();
+    } catch (IndexOutOfBoundsException expected) {
+    }
+  }
+
+  @Test public void valueIndexesAreStrict() {
+    Headers headers = Headers.of("a", "b", "c", "d");
+    try {
+      headers.value(-1);
+      fail();
+    } catch (IndexOutOfBoundsException expected) {
+    }
+    assertEquals("b", headers.value(0));
+    assertEquals("d", headers.value(1));
+    try {
+      headers.value(2);
+      fail();
+    } catch (IndexOutOfBoundsException expected) {
+    }
+  }
+
+  @Test public void builderRejectsUnicodeInHeaderName() {
+    try {
+      new Headers.Builder().add("héader1", "value1");
+      fail("Should have complained about invalid name");
+    } catch (IllegalArgumentException expected) {
+      assertEquals("Unexpected char 0xe9 at 1 in header name: héader1",
+          expected.getMessage());
+    }
+  }
+
+  @Test public void builderRejectsUnicodeInHeaderValue() {
+    try {
+      new Headers.Builder().add("header1", "valué1");
+      fail("Should have complained about invalid value");
+    } catch (IllegalArgumentException expected) {
+      assertEquals("Unexpected char 0xe9 at 4 in header1 value: valué1",
+          expected.getMessage());
+    }
+  }
+
+  @Test public void headersEquals() {
+    Headers headers1 = new Headers.Builder()
+        .add("Connection", "close")
+        .add("Transfer-Encoding", "chunked")
+        .build();
+    Headers headers2 = new Headers.Builder()
+        .add("Connection", "close")
+        .add("Transfer-Encoding", "chunked")
+        .build();
+    assertTrue(headers1.equals(headers2));
+    assertEquals(headers1.hashCode(), headers2.hashCode());
+  }
+
+  @Test public void headersNotEquals() {
+    Headers headers1 = new Headers.Builder()
+        .add("Connection", "close")
+        .add("Transfer-Encoding", "chunked")
+        .build();
+    Headers headers2 = new Headers.Builder()
+        .add("Connection", "keep-alive")
+        .add("Transfer-Encoding", "chunked")
+        .build();
+    assertFalse(headers1.equals(headers2));
+    assertFalse(headers1.hashCode() == headers2.hashCode());
+  }
 }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpDateTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http/HttpDateTest.java
similarity index 98%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpDateTest.java
rename to okhttp-tests/src/test/java/okhttp3/internal/http/HttpDateTest.java
index 2181774f43..0a22eb0f8a 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpDateTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http/HttpDateTest.java
@@ -13,15 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.http;
+package okhttp3.internal.http;
 
+import java.util.Date;
+import java.util.TimeZone;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 
-import java.util.Date;
-import java.util.TimeZone;
-
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
 
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/RecordingProxySelector.java b/okhttp-tests/src/test/java/okhttp3/internal/http/RecordingProxySelector.java
similarity index 81%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/RecordingProxySelector.java
rename to okhttp-tests/src/test/java/okhttp3/internal/http/RecordingProxySelector.java
index ed9cfa4ba9..33a51500e0 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/RecordingProxySelector.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http/RecordingProxySelector.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.http;
+package okhttp3.internal.http;
 
 import java.io.IOException;
 import java.net.InetSocketAddress;
@@ -24,13 +24,14 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
+import okhttp3.internal.Util;
 
 import static org.junit.Assert.assertEquals;
 
 public final class RecordingProxySelector extends ProxySelector {
-  final List<URI> requestedUris = new ArrayList<>();
-  List<Proxy> proxies = new ArrayList<>();
-  final List<String> failures = new ArrayList<>();
+  public final List<Proxy> proxies = new ArrayList<>();
+  public final List<URI> requestedUris = new ArrayList<>();
+  public final List<String> failures = new ArrayList<>();
 
   @Override public List<Proxy> select(URI uri) {
     requestedUris.add(uri);
@@ -45,7 +46,7 @@ public void assertRequests(URI... expectedUris) {
   @Override public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {
     InetSocketAddress socketAddress = (InetSocketAddress) sa;
     failures.add(
-        String.format("%s %s:%d %s", uri, socketAddress.getHostName(), socketAddress.getPort(),
+        Util.format("%s %s:%d %s", uri, socketAddress.getHostName(), socketAddress.getPort(),
             ioe.getMessage()));
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/RouteExceptionTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http/RouteExceptionTest.java
new file mode 100644
index 0000000000..1a0c2d8f02
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http/RouteExceptionTest.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http;
+
+import java.io.IOException;
+import org.junit.Test;
+
+import static org.junit.Assert.assertSame;
+
+public class RouteExceptionTest {
+
+  @Test public void getConnectionIOException_single() {
+    IOException firstException = new IOException();
+    RouteException re = new RouteException(firstException);
+    assertSame(firstException, re.getLastConnectException());
+  }
+
+  @Test public void getConnectionIOException_multiple() {
+    IOException firstException = new IOException();
+    IOException secondException = new IOException();
+    IOException thirdException = new IOException();
+    RouteException re = new RouteException(firstException);
+    re.addConnectException(secondException);
+    re.addConnectException(thirdException);
+
+    IOException connectionIOException = re.getLastConnectException();
+    assertSame(thirdException, connectionIOException);
+    Throwable[] thirdSuppressedExceptions = thirdException.getSuppressed();
+    assertSame(secondException, thirdSuppressedExceptions[0]);
+
+    Throwable[] secondSuppressedException = secondException.getSuppressed();
+    assertSame(firstException, secondSuppressedException[0]);
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/RouteSelectorTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http/RouteSelectorTest.java
new file mode 100644
index 0000000000..b1e3fca305
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http/RouteSelectorTest.java
@@ -0,0 +1,376 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.Proxy;
+import java.net.ProxySelector;
+import java.net.SocketAddress;
+import java.net.URI;
+import java.net.UnknownHostException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.NoSuchElementException;
+import javax.net.SocketFactory;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.HttpsURLConnection;
+import javax.net.ssl.SSLSocketFactory;
+import okhttp3.Address;
+import okhttp3.Authenticator;
+import okhttp3.ConnectionSpec;
+import okhttp3.FakeDns;
+import okhttp3.Protocol;
+import okhttp3.Route;
+import okhttp3.internal.RouteDatabase;
+import okhttp3.internal.Util;
+import okhttp3.internal.tls.SslClient;
+import org.junit.Before;
+import org.junit.Test;
+
+import static java.net.Proxy.NO_PROXY;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class RouteSelectorTest {
+  public final List<ConnectionSpec> connectionSpecs = Util.immutableList(
+      ConnectionSpec.MODERN_TLS,
+      ConnectionSpec.COMPATIBLE_TLS,
+      ConnectionSpec.CLEARTEXT);
+
+  private static final int proxyAPort = 1001;
+  private static final String proxyAHost = "proxya";
+  private static final Proxy proxyA =
+      new Proxy(Proxy.Type.HTTP, InetSocketAddress.createUnresolved(proxyAHost, proxyAPort));
+  private static final int proxyBPort = 1002;
+  private static final String proxyBHost = "proxyb";
+  private static final Proxy proxyB =
+      new Proxy(Proxy.Type.HTTP, InetSocketAddress.createUnresolved(proxyBHost, proxyBPort));
+  private String uriHost = "hosta";
+  private int uriPort = 1003;
+
+  private SocketFactory socketFactory;
+  private final SslClient sslClient = SslClient.localhost();
+  private final SSLSocketFactory sslSocketFactory = sslClient.socketFactory;
+  private HostnameVerifier hostnameVerifier;
+
+  private final Authenticator authenticator = Authenticator.NONE;
+  private final List<Protocol> protocols = Arrays.asList(Protocol.HTTP_1_1);
+  private final FakeDns dns = new FakeDns();
+  private final RecordingProxySelector proxySelector = new RecordingProxySelector();
+  private RouteDatabase routeDatabase = new RouteDatabase();
+
+  @Before public void setUp() throws Exception {
+    socketFactory = SocketFactory.getDefault();
+    hostnameVerifier = HttpsURLConnection.getDefaultHostnameVerifier();
+  }
+
+  @Test public void singleRoute() throws Exception {
+    Address address = httpAddress();
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase);
+
+    assertTrue(routeSelector.hasNext());
+    dns.addresses(makeFakeAddresses(255, 1));
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.address(0), uriPort);
+    dns.assertRequests(uriHost);
+
+    assertFalse(routeSelector.hasNext());
+    try {
+      routeSelector.next();
+      fail();
+    } catch (NoSuchElementException expected) {
+    }
+  }
+
+  @Test public void singleRouteReturnsFailedRoute() throws Exception {
+    Address address = httpAddress();
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase);
+
+    assertTrue(routeSelector.hasNext());
+    dns.addresses(makeFakeAddresses(255, 1));
+    Route route = routeSelector.next();
+    routeDatabase.failed(route);
+    routeSelector = new RouteSelector(address, routeDatabase);
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.address(0), uriPort);
+    assertFalse(routeSelector.hasNext());
+    try {
+      routeSelector.next();
+      fail();
+    } catch (NoSuchElementException expected) {
+    }
+  }
+
+  @Test public void explicitProxyTriesThatProxysAddressesOnly() throws Exception {
+    Address address = new Address(uriHost, uriPort, dns, socketFactory, null, null, null,
+        authenticator, proxyA, protocols, connectionSpecs, proxySelector);
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase);
+
+    assertTrue(routeSelector.hasNext());
+    dns.addresses(makeFakeAddresses(255, 2));
+    assertRoute(routeSelector.next(), address, proxyA, dns.address(0), proxyAPort);
+    assertRoute(routeSelector.next(), address, proxyA, dns.address(1), proxyAPort);
+
+    assertFalse(routeSelector.hasNext());
+    dns.assertRequests(proxyAHost);
+    proxySelector.assertRequests(); // No proxy selector requests!
+  }
+
+  @Test public void explicitDirectProxy() throws Exception {
+    Address address = new Address(uriHost, uriPort, dns, socketFactory, null, null, null,
+        authenticator, NO_PROXY, protocols, connectionSpecs, proxySelector);
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase);
+
+    assertTrue(routeSelector.hasNext());
+    dns.addresses(makeFakeAddresses(255, 2));
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.address(0), uriPort);
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.address(1), uriPort);
+
+    assertFalse(routeSelector.hasNext());
+    dns.assertRequests(uriHost);
+    proxySelector.assertRequests(); // No proxy selector requests!
+  }
+
+  @Test public void proxySelectorReturnsNull() throws Exception {
+    ProxySelector nullProxySelector = new ProxySelector() {
+      @Override public List<Proxy> select(URI uri) {
+        assertEquals(uriHost, uri.getHost());
+        return null;
+      }
+
+      @Override public void connectFailed(
+          URI uri, SocketAddress socketAddress, IOException e) {
+        throw new AssertionError();
+      }
+    };
+
+    Address address = new Address(uriHost, uriPort, dns, socketFactory, null, null, null,
+        authenticator, null, protocols, connectionSpecs, nullProxySelector);
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase);
+    assertTrue(routeSelector.hasNext());
+    dns.addresses(makeFakeAddresses(255, 1));
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.address(0), uriPort);
+    dns.assertRequests(uriHost);
+
+    assertFalse(routeSelector.hasNext());
+  }
+
+  @Test public void proxySelectorReturnsNoProxies() throws Exception {
+    Address address = httpAddress();
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase);
+
+    assertTrue(routeSelector.hasNext());
+    dns.addresses(makeFakeAddresses(255, 2));
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.address(0), uriPort);
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.address(1), uriPort);
+
+    assertFalse(routeSelector.hasNext());
+    dns.assertRequests(uriHost);
+    proxySelector.assertRequests(address.url().uri());
+  }
+
+  @Test public void proxySelectorReturnsMultipleProxies() throws Exception {
+    Address address = httpAddress();
+
+    proxySelector.proxies.add(proxyA);
+    proxySelector.proxies.add(proxyB);
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase);
+    proxySelector.assertRequests(address.url().uri());
+
+    // First try the IP addresses of the first proxy, in sequence.
+    assertTrue(routeSelector.hasNext());
+    dns.addresses(makeFakeAddresses(255, 2));
+    assertRoute(routeSelector.next(), address, proxyA, dns.address(0), proxyAPort);
+    assertRoute(routeSelector.next(), address, proxyA, dns.address(1), proxyAPort);
+    dns.assertRequests(proxyAHost);
+
+    // Next try the IP address of the second proxy.
+    assertTrue(routeSelector.hasNext());
+    dns.addresses(makeFakeAddresses(254, 1));
+    assertRoute(routeSelector.next(), address, proxyB, dns.address(0), proxyBPort);
+    dns.assertRequests(proxyBHost);
+
+    // Finally try the only IP address of the origin server.
+    assertTrue(routeSelector.hasNext());
+    dns.addresses(makeFakeAddresses(253, 1));
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.address(0), uriPort);
+    dns.assertRequests(uriHost);
+
+    assertFalse(routeSelector.hasNext());
+  }
+
+  @Test public void proxySelectorDirectConnectionsAreSkipped() throws Exception {
+    Address address = httpAddress();
+
+    proxySelector.proxies.add(NO_PROXY);
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase);
+    proxySelector.assertRequests(address.url().uri());
+
+    // Only the origin server will be attempted.
+    assertTrue(routeSelector.hasNext());
+    dns.addresses(makeFakeAddresses(255, 1));
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.address(0), uriPort);
+    dns.assertRequests(uriHost);
+
+    assertFalse(routeSelector.hasNext());
+  }
+
+  @Test public void proxyDnsFailureContinuesToNextProxy() throws Exception {
+    Address address = httpAddress();
+
+    proxySelector.proxies.add(proxyA);
+    proxySelector.proxies.add(proxyB);
+    proxySelector.proxies.add(proxyA);
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase);
+    proxySelector.assertRequests(address.url().uri());
+
+    assertTrue(routeSelector.hasNext());
+    dns.addresses(makeFakeAddresses(255, 1));
+    assertRoute(routeSelector.next(), address, proxyA, dns.address(0), proxyAPort);
+    dns.assertRequests(proxyAHost);
+
+    assertTrue(routeSelector.hasNext());
+    dns.unknownHost();
+    try {
+      routeSelector.next();
+      fail();
+    } catch (UnknownHostException expected) {
+    }
+    dns.assertRequests(proxyBHost);
+
+    assertTrue(routeSelector.hasNext());
+    dns.addresses(makeFakeAddresses(255, 1));
+    assertRoute(routeSelector.next(), address, proxyA, dns.address(0), proxyAPort);
+    dns.assertRequests(proxyAHost);
+
+    assertTrue(routeSelector.hasNext());
+    dns.addresses(makeFakeAddresses(254, 1));
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.address(0), uriPort);
+    dns.assertRequests(uriHost);
+
+    assertFalse(routeSelector.hasNext());
+  }
+
+  @Test public void multipleProxiesMultipleInetAddressesMultipleConfigurations() throws Exception {
+    Address address = httpsAddress();
+    proxySelector.proxies.add(proxyA);
+    proxySelector.proxies.add(proxyB);
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase);
+
+    // Proxy A
+    dns.addresses(makeFakeAddresses(255, 2));
+    assertRoute(routeSelector.next(), address, proxyA, dns.address(0), proxyAPort);
+    dns.assertRequests(proxyAHost);
+    assertRoute(routeSelector.next(), address, proxyA, dns.address(1), proxyAPort);
+
+    // Proxy B
+    dns.addresses(makeFakeAddresses(254, 2));
+    assertRoute(routeSelector.next(), address, proxyB, dns.address(0), proxyBPort);
+    dns.assertRequests(proxyBHost);
+    assertRoute(routeSelector.next(), address, proxyB, dns.address(1), proxyBPort);
+
+    // Origin
+    dns.addresses(makeFakeAddresses(253, 2));
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.address(0), uriPort);
+    dns.assertRequests(uriHost);
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.address(1), uriPort);
+
+    assertFalse(routeSelector.hasNext());
+  }
+
+  @Test public void failedRoutesAreLast() throws Exception {
+    Address address = httpsAddress();
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase);
+
+    final int numberOfAddresses = 2;
+    dns.addresses(makeFakeAddresses(255, numberOfAddresses));
+
+    // Extract the regular sequence of routes from selector.
+    List<Route> regularRoutes = new ArrayList<>();
+    while (routeSelector.hasNext()) {
+      regularRoutes.add(routeSelector.next());
+    }
+
+    // Check that we do indeed have more than one route.
+    assertEquals(numberOfAddresses, regularRoutes.size());
+    // Add first regular route as failed.
+    routeDatabase.failed(regularRoutes.get(0));
+    // Reset selector
+    routeSelector = new RouteSelector(address, routeDatabase);
+
+    List<Route> routesWithFailedRoute = new ArrayList<>();
+    while (routeSelector.hasNext()) {
+      routesWithFailedRoute.add(routeSelector.next());
+    }
+
+    assertEquals(regularRoutes.get(0),
+        routesWithFailedRoute.get(routesWithFailedRoute.size() - 1));
+    assertEquals(regularRoutes.size(), routesWithFailedRoute.size());
+  }
+
+  @Test public void getHostString() throws Exception {
+    // Name proxy specification.
+    InetSocketAddress socketAddress = InetSocketAddress.createUnresolved("host", 1234);
+    assertEquals("host", RouteSelector.getHostString(socketAddress));
+    socketAddress = InetSocketAddress.createUnresolved("127.0.0.1", 1234);
+    assertEquals("127.0.0.1", RouteSelector.getHostString(socketAddress));
+
+    // InetAddress proxy specification.
+    socketAddress = new InetSocketAddress(InetAddress.getByName("localhost"), 1234);
+    assertEquals("127.0.0.1", RouteSelector.getHostString(socketAddress));
+    socketAddress = new InetSocketAddress(
+        InetAddress.getByAddress(new byte[] {127, 0, 0, 1}), 1234);
+    assertEquals("127.0.0.1", RouteSelector.getHostString(socketAddress));
+    socketAddress = new InetSocketAddress(
+        InetAddress.getByAddress("foobar", new byte[] {127, 0, 0, 1}), 1234);
+    assertEquals("127.0.0.1", RouteSelector.getHostString(socketAddress));
+  }
+
+  private void assertRoute(Route route, Address address, Proxy proxy, InetAddress socketAddress,
+      int socketPort) {
+    assertEquals(address, route.address());
+    assertEquals(proxy, route.proxy());
+    assertEquals(socketAddress, route.socketAddress().getAddress());
+    assertEquals(socketPort, route.socketAddress().getPort());
+  }
+
+  /** Returns an address that's without an SSL socket factory or hostname verifier. */
+  private Address httpAddress() {
+    return new Address(uriHost, uriPort, dns, socketFactory, null, null, null, authenticator, null,
+        protocols, connectionSpecs, proxySelector);
+  }
+
+  private Address httpsAddress() {
+    return new Address(uriHost, uriPort, dns, socketFactory, sslSocketFactory,
+        hostnameVerifier, null, authenticator, null, protocols, connectionSpecs, proxySelector);
+  }
+
+  private static List<InetAddress> makeFakeAddresses(int prefix, int count) {
+    try {
+      List<InetAddress> result = new ArrayList<>();
+      for (int i = 0; i < count; i++) {
+        result.add(InetAddress.getByAddress(
+            new byte[] {(byte) prefix, (byte) 0, (byte) 0, (byte) i}));
+      }
+      return result;
+    } catch (UnknownHostException e) {
+      throw new AssertionError();
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/StatusLineTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http/StatusLineTest.java
similarity index 94%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/StatusLineTest.java
rename to okhttp-tests/src/test/java/okhttp3/internal/http/StatusLineTest.java
index f339f9ebe6..6eb1aa8b12 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/StatusLineTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http/StatusLineTest.java
@@ -13,11 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.http;
+package okhttp3.internal.http;
 
-import com.squareup.okhttp.Protocol;
 import java.io.IOException;
 import java.net.ProtocolException;
+import okhttp3.Protocol;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
@@ -44,9 +44,8 @@
   }
 
   /**
-   * This is not defined in the protocol but some servers won't add the leading
-   * empty space when the message is empty.
-   * http://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html#sec6.1
+   * This is not defined in the protocol but some servers won't add the leading empty space when the
+   * message is empty. http://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html#sec6.1
    */
   @Test public void emptyMessageAndNoLeadingSpace() throws IOException {
     int version = 1;
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ThreadInterruptTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http/ThreadInterruptTest.java
similarity index 80%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ThreadInterruptTest.java
rename to okhttp-tests/src/test/java/okhttp3/internal/http/ThreadInterruptTest.java
index 63f55e1f18..47f4f0fc6b 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ThreadInterruptTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http/ThreadInterruptTest.java
@@ -13,14 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.http;
-
-import com.squareup.okhttp.DelegatingServerSocketFactory;
-import com.squareup.okhttp.DelegatingSocketFactory;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.OkUrlFactory;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
+package okhttp3.internal.http;
 
 import java.io.IOException;
 import java.io.InputStream;
@@ -30,14 +23,18 @@
 import java.net.ServerSocket;
 import java.net.Socket;
 import java.util.concurrent.TimeUnit;
-
+import javax.net.ServerSocketFactory;
+import javax.net.SocketFactory;
+import okhttp3.DelegatingServerSocketFactory;
+import okhttp3.DelegatingSocketFactory;
+import okhttp3.OkHttpClient;
+import okhttp3.OkUrlFactory;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
 import okio.Buffer;
 import org.junit.Before;
 import org.junit.Test;
 
-import javax.net.ServerSocketFactory;
-import javax.net.SocketFactory;
-
 import static org.junit.Assert.fail;
 
 public final class ThreadInterruptTest {
@@ -49,25 +46,28 @@
   private OkHttpClient client;
 
   @Before public void setUp() throws Exception {
-    server = new MockWebServer();
-    client = new OkHttpClient();
-
     // Sockets on some platforms can have large buffers that mean writes do not block when
     // required. These socket factories explicitly set the buffer sizes on sockets created.
+    server = new MockWebServer();
     server.setServerSocketFactory(
         new DelegatingServerSocketFactory(ServerSocketFactory.getDefault()) {
           @Override
-          protected void configureServerSocket(ServerSocket serverSocket) throws IOException {
+          protected ServerSocket configureServerSocket(ServerSocket serverSocket)
+              throws IOException {
             serverSocket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
+            return serverSocket;
           }
         });
-    client.setSocketFactory(new DelegatingSocketFactory(SocketFactory.getDefault()) {
-      @Override
-      protected void configureSocket(Socket socket) throws IOException {
-        socket.setSendBufferSize(SOCKET_BUFFER_SIZE);
-        socket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
-      }
-    });
+    client = new OkHttpClient.Builder()
+        .socketFactory(new DelegatingSocketFactory(SocketFactory.getDefault()) {
+          @Override
+          protected Socket configureSocket(Socket socket) throws IOException {
+            socket.setSendBufferSize(SOCKET_BUFFER_SIZE);
+            socket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
+            return socket;
+          }
+        })
+        .build();
   }
 
   @Test public void interruptWritingRequestBody() throws Exception {
@@ -79,7 +79,7 @@ protected void configureSocket(Socket socket) throws IOException {
 
     interruptLater(500);
 
-    HttpURLConnection connection = new OkUrlFactory(client).open(server.getUrl("/"));
+    HttpURLConnection connection = new OkUrlFactory(client).open(server.url("/").url());
     connection.setDoOutput(true);
     connection.setFixedLengthStreamingMode(requestBodySize);
     OutputStream requestBody = connection.getOutputStream();
@@ -106,7 +106,7 @@ protected void configureSocket(Socket socket) throws IOException {
 
     interruptLater(500);
 
-    HttpURLConnection connection = new OkUrlFactory(client).open(server.getUrl("/"));
+    HttpURLConnection connection = new OkUrlFactory(client).open(server.url("/").url());
     InputStream responseBody = connection.getInputStream();
     byte[] buffer = new byte[1024];
     try {
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/io/PipeTest.java b/okhttp-tests/src/test/java/okhttp3/internal/io/PipeTest.java
new file mode 100644
index 0000000000..9ff1ccd239
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/io/PipeTest.java
@@ -0,0 +1,414 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.io;
+
+import java.io.IOException;
+import java.io.InterruptedIOException;
+import java.util.Random;
+import java.util.concurrent.Callable;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.TimeUnit;
+import okio.Buffer;
+import okio.ByteString;
+import okio.HashingSink;
+import okio.Source;
+import org.junit.After;
+import org.junit.Test;
+
+import static junit.framework.TestCase.fail;
+import static org.junit.Assert.assertEquals;
+
+public final class PipeTest {
+  final ScheduledExecutorService executorService = Executors.newScheduledThreadPool(2);
+
+  @After public void tearDown() throws Exception {
+    executorService.shutdown();
+  }
+
+  @Test public void test() throws Exception {
+    Pipe pipe = new Pipe(6);
+    pipe.sink.write(new Buffer().writeUtf8("abc"), 3L);
+
+    Source source = pipe.source;
+    Buffer readBuffer = new Buffer();
+    assertEquals(3L, source.read(readBuffer, 6L));
+    assertEquals("abc", readBuffer.readUtf8());
+
+    pipe.sink.close();
+    assertEquals(-1L, source.read(readBuffer, 6L));
+
+    source.close();
+  }
+
+  /**
+   * A producer writes the first 16 MiB of bytes generated by {@code new Random(0)} to a sink, and a
+   * consumer consumes them. Both compute hashes of their data to confirm that they're as expected.
+   */
+  @Test public void largeDataset() throws Exception {
+    final Pipe pipe = new Pipe(1000L); // An awkward size to force producer/consumer exchange.
+    final long totalBytes = 16L * 1024L * 1024L;
+    ByteString expectedHash = ByteString.decodeHex("7c3b224bea749086babe079360cf29f98d88262d");
+
+    // Write data to the sink.
+    Future<ByteString> sinkHash = executorService.submit(new Callable<ByteString>() {
+      @Override public ByteString call() throws Exception {
+        HashingSink hashingSink = HashingSink.sha1(pipe.sink);
+        Random random = new Random(0);
+        byte[] data = new byte[8192];
+
+        Buffer buffer = new Buffer();
+        for (long i = 0L; i < totalBytes; i += data.length) {
+          random.nextBytes(data);
+          buffer.write(data);
+          hashingSink.write(buffer, buffer.size());
+        }
+
+        hashingSink.close();
+        return hashingSink.hash();
+      }
+    });
+
+    // Read data from the source.
+    Future<ByteString> sourceHash = executorService.submit(new Callable<ByteString>() {
+      @Override public ByteString call() throws Exception {
+        Buffer blackhole = new Buffer();
+        HashingSink hashingSink = HashingSink.sha1(blackhole);
+
+        Buffer buffer = new Buffer();
+        while (pipe.source.read(buffer, Long.MAX_VALUE) != -1) {
+          hashingSink.write(buffer, buffer.size());
+          blackhole.clear();
+        }
+
+        pipe.source.close();
+        return hashingSink.hash();
+      }
+    });
+
+    assertEquals(expectedHash, sinkHash.get());
+    assertEquals(expectedHash, sourceHash.get());
+  }
+
+  @Test public void sinkTimeout() throws Exception {
+    Pipe pipe = new Pipe(3);
+    pipe.sink.timeout().timeout(1000, TimeUnit.MILLISECONDS);
+    pipe.sink.write(new Buffer().writeUtf8("abc"), 3L);
+    double start = now();
+    try {
+      pipe.sink.write(new Buffer().writeUtf8("def"), 3L);
+      fail();
+    } catch (InterruptedIOException expected) {
+      assertEquals("timeout", expected.getMessage());
+    }
+    assertElapsed(1000.0, start);
+
+    Buffer readBuffer = new Buffer();
+    assertEquals(3L, pipe.source.read(readBuffer, 6L));
+    assertEquals("abc", readBuffer.readUtf8());
+  }
+
+  @Test public void sourceTimeout() throws Exception {
+    Pipe pipe = new Pipe(3L);
+    pipe.source.timeout().timeout(1000, TimeUnit.MILLISECONDS);
+    double start = now();
+    Buffer readBuffer = new Buffer();
+    try {
+      pipe.source.read(readBuffer, 6L);
+      fail();
+    } catch (InterruptedIOException expected) {
+      assertEquals("timeout", expected.getMessage());
+    }
+    assertElapsed(1000.0, start);
+    assertEquals(0, readBuffer.size());
+  }
+
+  /**
+   * The writer is writing 12 bytes as fast as it can to a 3 byte buffer. The reader alternates
+   * sleeping 1000 ms, then reading 3 bytes. That should make for an approximate timeline like
+   * this:
+   *
+   *    0: writer writes 'abc', blocks 0: reader sleeps until 1000
+   * 1000: reader reads 'abc', sleeps until 2000
+   * 1000: writer writes 'def', blocks
+   * 2000: reader reads 'def', sleeps until 3000
+   * 2000: writer writes 'ghi', blocks
+   * 3000: reader reads 'ghi', sleeps until 4000
+   * 3000: writer writes 'jkl', returns
+   * 24000: reader reads 'jkl', returns
+   *
+   * Because the writer is writing to a buffer, it finishes before the reader does.
+   */
+  @Test public void sinkBlocksOnSlowReader() throws Exception {
+    final Pipe pipe = new Pipe(3L);
+    executorService.execute(new Runnable() {
+      @Override public void run() {
+        try {
+          Buffer buffer = new Buffer();
+          Thread.sleep(1000L);
+          assertEquals(3, pipe.source.read(buffer, Long.MAX_VALUE));
+          assertEquals("abc", buffer.readUtf8());
+          Thread.sleep(1000L);
+          assertEquals(3, pipe.source.read(buffer, Long.MAX_VALUE));
+          assertEquals("def", buffer.readUtf8());
+          Thread.sleep(1000L);
+          assertEquals(3, pipe.source.read(buffer, Long.MAX_VALUE));
+          assertEquals("ghi", buffer.readUtf8());
+          Thread.sleep(1000L);
+          assertEquals(3, pipe.source.read(buffer, Long.MAX_VALUE));
+          assertEquals("jkl", buffer.readUtf8());
+        } catch (IOException | InterruptedException e) {
+          throw new AssertionError();
+        }
+      }
+    });
+
+    double start = now();
+    pipe.sink.write(new Buffer().writeUtf8("abcdefghijkl"), 12);
+    assertElapsed(3000.0, start);
+  }
+
+  @Test public void sinkWriteFailsByClosedReader() throws Exception {
+    final Pipe pipe = new Pipe(3L);
+    executorService.schedule(new Runnable() {
+      @Override public void run() {
+        try {
+          pipe.source.close();
+        } catch (IOException e) {
+          throw new AssertionError();
+        }
+      }
+    }, 1000, TimeUnit.MILLISECONDS);
+
+    double start = now();
+    try {
+      pipe.sink.write(new Buffer().writeUtf8("abcdef"), 6);
+      fail();
+    } catch (IOException expected) {
+      assertEquals("source is closed", expected.getMessage());
+      assertElapsed(1000.0, start);
+    }
+  }
+
+  @Test public void sinkFlushWaitsForReaderToReadEverything() throws Exception {
+    final Buffer readBuffer = new Buffer();
+    final Pipe pipe = new Pipe(100L);
+    executorService.execute(new Runnable() {
+      @Override public void run() {
+        try {
+          Thread.sleep(1000);
+          pipe.source.read(readBuffer, 3);
+          Thread.sleep(1000);
+          pipe.source.read(readBuffer, 3);
+        } catch (InterruptedException | IOException e) {
+          throw new AssertionError(e);
+        }
+      }
+    });
+
+    double start = now();
+    pipe.sink.write(new Buffer().writeUtf8("abcdef"), 6);
+    pipe.sink.flush();
+    assertElapsed(2000.0, start);
+    assertEquals("abcdef", readBuffer.readUtf8());
+  }
+
+  @Test public void sinkFlushFailsIfReaderIsClosedBeforeAllDataIsRead() throws Exception {
+    final Pipe pipe = new Pipe(100L);
+    executorService.execute(new Runnable() {
+      @Override public void run() {
+        try {
+          Thread.sleep(1000);
+          pipe.source.read(new Buffer(), 3);
+          Thread.sleep(1000);
+          pipe.source.close();
+        } catch (InterruptedException | IOException e) {
+          throw new AssertionError(e);
+        }
+      }
+    });
+
+    double start = now();
+    pipe.sink.write(new Buffer().writeUtf8("abcdef"), 6);
+    try {
+      pipe.sink.flush();
+      fail();
+    } catch (IOException expected) {
+      assertEquals("source is closed", expected.getMessage());
+      assertElapsed(2000.0, start);
+    }
+  }
+
+  @Test public void sinkCloseFailsIfReaderIsClosedBeforeAllDataIsRead() throws Exception {
+    final Pipe pipe = new Pipe(100L);
+    executorService.execute(new Runnable() {
+      @Override public void run() {
+        try {
+          Thread.sleep(1000);
+          pipe.source.read(new Buffer(), 3);
+          Thread.sleep(1000);
+          pipe.source.close();
+        } catch (InterruptedException | IOException e) {
+          throw new AssertionError(e);
+        }
+      }
+    });
+
+    double start = now();
+    pipe.sink.write(new Buffer().writeUtf8("abcdef"), 6);
+    try {
+      pipe.sink.close();
+      fail();
+    } catch (IOException expected) {
+      assertEquals("source is closed", expected.getMessage());
+      assertElapsed(2000.0, start);
+    }
+
+    try {
+      pipe.sink.flush();
+      fail();
+    } catch (IllegalStateException expected) {
+      assertEquals("closed", expected.getMessage());
+    }
+  }
+
+  @Test public void sinkClose() throws Exception {
+    Pipe pipe = new Pipe(100L);
+    pipe.sink.close();
+    try {
+      pipe.sink.write(new Buffer().writeUtf8("abc"), 3);
+      fail();
+    } catch (IllegalStateException expected) {
+      assertEquals("closed", expected.getMessage());
+    }
+    try {
+      pipe.sink.flush();
+      fail();
+    } catch (IllegalStateException expected) {
+      assertEquals("closed", expected.getMessage());
+    }
+  }
+
+  @Test public void sinkMultipleClose() throws Exception {
+    Pipe pipe = new Pipe(100L);
+    pipe.sink.close();
+    pipe.sink.close();
+  }
+
+  @Test public void sourceClose() throws Exception {
+    Pipe pipe = new Pipe(100L);
+    pipe.source.close();
+    try {
+      pipe.source.read(new Buffer(), 3);
+      fail();
+    } catch (IllegalStateException expected) {
+      assertEquals("closed", expected.getMessage());
+    }
+  }
+
+  @Test public void sourceMultipleClose() throws Exception {
+    Pipe pipe = new Pipe(100L);
+    pipe.source.close();
+    pipe.source.close();
+  }
+
+  @Test public void sourceReadUnblockedByClosedSink() throws Exception {
+    final Pipe pipe = new Pipe(3L);
+    executorService.schedule(new Runnable() {
+      @Override public void run() {
+        try {
+          pipe.sink.close();
+        } catch (IOException e) {
+          throw new AssertionError();
+        }
+      }
+    }, 1000, TimeUnit.MILLISECONDS);
+
+    double start = now();
+    Buffer readBuffer = new Buffer();
+    assertEquals(-1, pipe.source.read(readBuffer, Long.MAX_VALUE));
+    assertEquals(0, readBuffer.size());
+    assertElapsed(1000.0, start);
+  }
+
+  /**
+   * The writer has 12 bytes to write. It alternates sleeping 1000 ms, then writing 3 bytes. The
+   * reader is reading as fast as it can. That should make for an approximate timeline like this:
+   *
+   *    0: writer sleeps until 1000
+   *    0: reader blocks
+   * 1000: writer writes 'abc', sleeps until 2000
+   * 1000: reader reads 'abc'
+   * 2000: writer writes 'def', sleeps until 3000
+   * 2000: reader reads 'def'
+   * 3000: writer writes 'ghi', sleeps until 4000
+   * 3000: reader reads 'ghi'
+   * 4000: writer writes 'jkl', returns
+   * 4000: reader reads 'jkl', returns
+   */
+  @Test public void sourceBlocksOnSlowWriter() throws Exception {
+    final Pipe pipe = new Pipe(100L);
+    executorService.execute(new Runnable() {
+      @Override public void run() {
+        try {
+          Thread.sleep(1000L);
+          pipe.sink.write(new Buffer().writeUtf8("abc"), 3);
+          Thread.sleep(1000L);
+          pipe.sink.write(new Buffer().writeUtf8("def"), 3);
+          Thread.sleep(1000L);
+          pipe.sink.write(new Buffer().writeUtf8("ghi"), 3);
+          Thread.sleep(1000L);
+          pipe.sink.write(new Buffer().writeUtf8("jkl"), 3);
+        } catch (IOException | InterruptedException e) {
+          throw new AssertionError();
+        }
+      }
+    });
+
+    double start = now();
+    Buffer readBuffer = new Buffer();
+
+    assertEquals(3, pipe.source.read(readBuffer, Long.MAX_VALUE));
+    assertEquals("abc", readBuffer.readUtf8());
+    assertElapsed(1000.0, start);
+
+    assertEquals(3, pipe.source.read(readBuffer, Long.MAX_VALUE));
+    assertEquals("def", readBuffer.readUtf8());
+    assertElapsed(2000.0, start);
+
+    assertEquals(3, pipe.source.read(readBuffer, Long.MAX_VALUE));
+    assertEquals("ghi", readBuffer.readUtf8());
+    assertElapsed(3000.0, start);
+
+    assertEquals(3, pipe.source.read(readBuffer, Long.MAX_VALUE));
+    assertEquals("jkl", readBuffer.readUtf8());
+    assertElapsed(4000.0, start);
+  }
+
+  /** Returns the nanotime in milliseconds as a double for measuring timeouts. */
+  private double now() {
+    return System.nanoTime() / 1000000.0d;
+  }
+
+  /**
+   * Fails the test unless the time from start until now is duration, accepting differences in
+   * -50..+450 milliseconds.
+   */
+  private void assertElapsed(double duration, double start) {
+    assertEquals(duration, now() - start - 200d, 250.0);
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/io/WaitUntilNotifiedTest.java b/okhttp-tests/src/test/java/okhttp3/internal/io/WaitUntilNotifiedTest.java
new file mode 100644
index 0000000000..d2e8dfbffc
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/io/WaitUntilNotifiedTest.java
@@ -0,0 +1,147 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.io;
+
+import java.io.InterruptedIOException;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.TimeUnit;
+import okio.Timeout;
+import org.junit.After;
+import org.junit.Test;
+
+import static junit.framework.TestCase.fail;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+
+public final class WaitUntilNotifiedTest {
+  final ScheduledExecutorService executorService = Executors.newScheduledThreadPool(0);
+
+  @After public void tearDown() throws Exception {
+    executorService.shutdown();
+  }
+
+  @Test public synchronized void notified() throws Exception {
+    Timeout timeout = new Timeout();
+    timeout.timeout(5000, TimeUnit.MILLISECONDS);
+
+    double start = now();
+    executorService.schedule(new Runnable() {
+      @Override public void run() {
+        synchronized (WaitUntilNotifiedTest.this) {
+          WaitUntilNotifiedTest.this.notify();
+        }
+      }
+    }, 1000, TimeUnit.MILLISECONDS);
+
+    Pipe.waitUntilNotified(this, timeout);
+    assertElapsed(1000.0, start);
+  }
+
+  @Test public synchronized void timeout() throws Exception {
+    Timeout timeout = new Timeout();
+    timeout.timeout(1000, TimeUnit.MILLISECONDS);
+    double start = now();
+    try {
+      Pipe.waitUntilNotified(this, timeout);
+      fail();
+    } catch (InterruptedIOException expected) {
+      assertEquals("timeout", expected.getMessage());
+    }
+    assertElapsed(1000.0, start);
+  }
+
+  @Test public synchronized void deadline() throws Exception {
+    Timeout timeout = new Timeout();
+    timeout.deadline(1000, TimeUnit.MILLISECONDS);
+    double start = now();
+    try {
+      Pipe.waitUntilNotified(this, timeout);
+      fail();
+    } catch (InterruptedIOException expected) {
+      assertEquals("timeout", expected.getMessage());
+    }
+    assertElapsed(1000.0, start);
+  }
+
+  @Test public synchronized void deadlineBeforeTimeout() throws Exception {
+    Timeout timeout = new Timeout();
+    timeout.timeout(5000, TimeUnit.MILLISECONDS);
+    timeout.deadline(1000, TimeUnit.MILLISECONDS);
+    double start = now();
+    try {
+      Pipe.waitUntilNotified(this, timeout);
+      fail();
+    } catch (InterruptedIOException expected) {
+      assertEquals("timeout", expected.getMessage());
+    }
+    assertElapsed(1000.0, start);
+  }
+
+  @Test public synchronized void timeoutBeforeDeadline() throws Exception {
+    Timeout timeout = new Timeout();
+    timeout.timeout(1000, TimeUnit.MILLISECONDS);
+    timeout.deadline(5000, TimeUnit.MILLISECONDS);
+    double start = now();
+    try {
+      Pipe.waitUntilNotified(this, timeout);
+      fail();
+    } catch (InterruptedIOException expected) {
+      assertEquals("timeout", expected.getMessage());
+    }
+    assertElapsed(1000.0, start);
+  }
+
+  @Test public synchronized void deadlineAlreadyReached() throws Exception {
+    Timeout timeout = new Timeout();
+    timeout.deadlineNanoTime(System.nanoTime());
+    double start = now();
+    try {
+      Pipe.waitUntilNotified(this, timeout);
+      fail();
+    } catch (InterruptedIOException expected) {
+      assertEquals("timeout", expected.getMessage());
+    }
+    assertElapsed(0.0, start);
+  }
+
+  @Test public synchronized void threadInterrupted() throws Exception {
+    Timeout timeout = new Timeout();
+    double start = now();
+    Thread.currentThread().interrupt();
+    try {
+      Pipe.waitUntilNotified(this, timeout);
+      fail();
+    } catch (InterruptedIOException expected) {
+      assertEquals("interrupted", expected.getMessage());
+      assertFalse(Thread.interrupted());
+    }
+    assertElapsed(0.0, start);
+  }
+
+  /** Returns the nanotime in milliseconds as a double for measuring timeouts. */
+  private double now() {
+    return System.nanoTime() / 1000000.0d;
+  }
+
+  /**
+   * Fails the test unless the time from start until now is duration, accepting differences in
+   * -50..+450 milliseconds.
+   */
+  private void assertElapsed(double duration, double start) {
+    assertEquals(duration, now() - start - 200d, 250.0);
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/tls/CertificatePinnerChainValidationTest.java b/okhttp-tests/src/test/java/okhttp3/internal/tls/CertificatePinnerChainValidationTest.java
new file mode 100644
index 0000000000..4b59edbf6e
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/tls/CertificatePinnerChainValidationTest.java
@@ -0,0 +1,302 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.tls;
+
+import javax.net.ssl.SSLHandshakeException;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import okhttp3.Call;
+import okhttp3.CertificatePinner;
+import okhttp3.OkHttpClient;
+import okhttp3.RecordingHostnameVerifier;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.SocketPolicy;
+import org.junit.Rule;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class CertificatePinnerChainValidationTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  /** The pinner should pull the root certificate from the trust manager. */
+  @Test public void pinRootNotPresentInChain() throws Exception {
+    HeldCertificate rootCa = new HeldCertificate.Builder()
+        .serialNumber("1")
+        .ca(3)
+        .commonName("root")
+        .build();
+    HeldCertificate intermediateCa = new HeldCertificate.Builder()
+        .issuedBy(rootCa)
+        .ca(2)
+        .serialNumber("2")
+        .commonName("intermediate_ca")
+        .build();
+    HeldCertificate certificate = new HeldCertificate.Builder()
+        .issuedBy(intermediateCa)
+        .serialNumber("3")
+        .commonName(server.getHostName())
+        .build();
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add(server.getHostName(), CertificatePinner.pin(rootCa.certificate))
+        .build();
+    SslClient sslClient = new SslClient.Builder()
+        .addTrustedCertificate(rootCa.certificate)
+        .build();
+    OkHttpClient client = new OkHttpClient.Builder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .certificatePinner(certificatePinner)
+        .build();
+
+    SslClient serverSslClient = new SslClient.Builder()
+        .certificateChain(certificate, intermediateCa)
+        .build();
+    server.useHttps(serverSslClient.socketFactory, false);
+
+    // The request should complete successfully.
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END));
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response1 = call1.execute();
+    assertEquals("abc", response1.body().string());
+
+    // Confirm that a second request also succeeds. This should detect caching problems.
+    server.enqueue(new MockResponse()
+        .setBody("def")
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END));
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+    assertEquals("def", response2.body().string());
+  }
+
+  /** The pinner should accept an intermediate from the server's chain. */
+  @Test public void pinIntermediatePresentInChain() throws Exception {
+    HeldCertificate rootCa = new HeldCertificate.Builder()
+        .serialNumber("1")
+        .ca(3)
+        .commonName("root")
+        .build();
+    HeldCertificate intermediateCa = new HeldCertificate.Builder()
+        .issuedBy(rootCa)
+        .ca(2)
+        .serialNumber("2")
+        .commonName("intermediate_ca")
+        .build();
+    HeldCertificate certificate = new HeldCertificate.Builder()
+        .issuedBy(intermediateCa)
+        .serialNumber("3")
+        .commonName(server.getHostName())
+        .build();
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add(server.getHostName(), CertificatePinner.pin(intermediateCa.certificate))
+        .build();
+    SslClient contextBuilder = new SslClient.Builder()
+        .addTrustedCertificate(rootCa.certificate)
+        .build();
+    OkHttpClient client = new OkHttpClient.Builder()
+        .sslSocketFactory(contextBuilder.socketFactory, contextBuilder.trustManager)
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .certificatePinner(certificatePinner)
+        .build();
+
+    SslClient serverSslContext = new SslClient.Builder()
+        .certificateChain(certificate.keyPair, certificate.certificate, intermediateCa.certificate)
+        .build();
+    server.useHttps(serverSslContext.socketFactory, false);
+
+    // The request should complete successfully.
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END));
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response1 = call1.execute();
+    assertEquals("abc", response1.body().string());
+
+    // Confirm that a second request also succeeds. This should detect caching problems.
+    server.enqueue(new MockResponse()
+        .setBody("def")
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END));
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+    assertEquals("def", response2.body().string());
+  }
+
+  @Test public void unrelatedPinnedLeafCertificateInChain() throws Exception {
+    // Start with a trusted root CA certificate.
+    HeldCertificate rootCa = new HeldCertificate.Builder()
+        .serialNumber("1")
+        .ca(3)
+        .commonName("root")
+        .build();
+
+    // Add a good intermediate CA, and have that issue a good certificate to localhost. Prepare an
+    // SSL context for an HTTP client under attack. It includes the trusted CA and a pinned
+    // certificate.
+    HeldCertificate goodIntermediateCa = new HeldCertificate.Builder()
+        .issuedBy(rootCa)
+        .ca(2)
+        .serialNumber("2")
+        .commonName("good_intermediate_ca")
+        .build();
+    HeldCertificate goodCertificate = new HeldCertificate.Builder()
+        .issuedBy(goodIntermediateCa)
+        .serialNumber("3")
+        .commonName(server.getHostName())
+        .build();
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add(server.getHostName(), CertificatePinner.pin(goodCertificate.certificate))
+        .build();
+    SslClient clientContextBuilder = new SslClient.Builder()
+        .addTrustedCertificate(rootCa.certificate)
+        .build();
+    OkHttpClient client = new OkHttpClient.Builder()
+        .sslSocketFactory(clientContextBuilder.socketFactory, clientContextBuilder.trustManager)
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .certificatePinner(certificatePinner)
+        .build();
+
+    // Add a bad intermediate CA and have that issue a rogue certificate for localhost. Prepare
+    // an SSL context for an attacking webserver. It includes both these rogue certificates plus the
+    // trusted good certificate above. The attack is that by including the good certificate in the
+    // chain, we may trick the certificate pinner into accepting the rouge certificate.
+    HeldCertificate compromisedIntermediateCa = new HeldCertificate.Builder()
+        .issuedBy(rootCa)
+        .ca(2)
+        .serialNumber("4")
+        .commonName("bad_intermediate_ca")
+        .build();
+    HeldCertificate rogueCertificate = new HeldCertificate.Builder()
+        .serialNumber("5")
+        .issuedBy(compromisedIntermediateCa)
+        .commonName(server.getHostName())
+        .build();
+    SslClient serverSslContext = new SslClient.Builder()
+        .certificateChain(rogueCertificate.keyPair, rogueCertificate.certificate, compromisedIntermediateCa.certificate, goodCertificate.certificate, rootCa.certificate)
+        .build();
+    server.useHttps(serverSslContext.socketFactory, false);
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .addHeader("Content-Type: text/plain"));
+
+    // Make a request from client to server. It should succeed certificate checks (unfortunately the
+    // rogue CA is trusted) but it should fail certificate pinning.
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    Call call = client.newCall(request);
+    try {
+      call.execute();
+      fail();
+    } catch (SSLPeerUnverifiedException expected) {
+      // Certificate pinning fails!
+      String message = expected.getMessage();
+      assertTrue(message, message.startsWith("Certificate pinning failure!"));
+    }
+  }
+
+  @Test public void unrelatedPinnedIntermediateCertificateInChain() throws Exception {
+    // Start with two root CA certificates, one is good and the other is compromised.
+    HeldCertificate rootCa = new HeldCertificate.Builder()
+        .serialNumber("1")
+        .ca(3)
+        .commonName("root")
+        .build();
+    HeldCertificate compromisedRootCa = new HeldCertificate.Builder()
+        .serialNumber("2")
+        .ca(3)
+        .commonName("compromised_root")
+        .build();
+
+    // Add a good intermediate CA, and have that issue a good certificate to localhost. Prepare an
+    // SSL context for an HTTP client under attack. It includes the trusted CA and a pinned
+    // certificate.
+    HeldCertificate goodIntermediateCa = new HeldCertificate.Builder()
+        .issuedBy(rootCa)
+        .ca(2)
+        .serialNumber("3")
+        .commonName("intermediate_ca")
+        .build();
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add(server.getHostName(), CertificatePinner.pin(goodIntermediateCa.certificate))
+        .build();
+    SslClient clientContextBuilder = new SslClient.Builder()
+        .addTrustedCertificate(rootCa.certificate)
+        .addTrustedCertificate(compromisedRootCa.certificate)
+        .build();
+    OkHttpClient client = new OkHttpClient.Builder()
+        .sslSocketFactory(clientContextBuilder.socketFactory, clientContextBuilder.trustManager)
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .certificatePinner(certificatePinner)
+        .build();
+
+    // The attacker compromises the root CA, issues an intermediate with the same common name
+    // "intermediate_ca" as the good CA. This signs a rogue certificate for localhost. The server
+    // serves the good CAs certificate in the chain, which means the certificate pinner sees a
+    // different set of certificates than the SSL verifier.
+    HeldCertificate compromisedIntermediateCa = new HeldCertificate.Builder()
+        .issuedBy(compromisedRootCa)
+        .ca(2)
+        .serialNumber("4")
+        .commonName("intermediate_ca")
+        .build();
+    HeldCertificate rogueCertificate = new HeldCertificate.Builder()
+        .serialNumber("5")
+        .issuedBy(compromisedIntermediateCa)
+        .commonName(server.getHostName())
+        .build();
+    SslClient serverSslContext = new SslClient.Builder()
+        .certificateChain(
+            rogueCertificate.keyPair, rogueCertificate.certificate, goodIntermediateCa.certificate, compromisedIntermediateCa.certificate, compromisedRootCa.certificate)
+        .build();
+    server.useHttps(serverSslContext.socketFactory, false);
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .addHeader("Content-Type: text/plain"));
+
+    // Make a request from client to server. It should succeed certificate checks (unfortunately the
+    // rogue CA is trusted) but it should fail certificate pinning.
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    Call call = client.newCall(request);
+    try {
+      call.execute();
+      fail();
+    } catch (SSLHandshakeException expected) {
+      // On Android, the handshake fails before the certificate pinner runs.
+      String message = expected.getMessage();
+      assertTrue(message, message.contains("Could not validate certificate"));
+    } catch (SSLPeerUnverifiedException expected) {
+      // On OpenJDK, the handshake succeeds but the certificate pinner fails.
+      String message = expected.getMessage();
+      assertTrue(message, message.startsWith("Certificate pinning failure!"));
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/tls/HostnameVerifierTest.java b/okhttp-tests/src/test/java/okhttp3/internal/tls/HostnameVerifierTest.java
similarity index 93%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/tls/HostnameVerifierTest.java
rename to okhttp-tests/src/test/java/okhttp3/internal/tls/HostnameVerifierTest.java
index d7f1c78cb8..f03f197d94 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/tls/HostnameVerifierTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/tls/HostnameVerifierTest.java
@@ -15,15 +15,16 @@
  * the License.
  */
 
-package com.squareup.okhttp.internal.tls;
+package okhttp3.internal.tls;
 
-import com.squareup.okhttp.internal.Util;
 import java.io.ByteArrayInputStream;
 import java.security.cert.CertificateFactory;
 import java.security.cert.X509Certificate;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLSession;
 import javax.security.auth.x500.X500Principal;
+import okhttp3.FakeSSLSession;
+import okhttp3.internal.Util;
 import org.junit.Ignore;
 import org.junit.Test;
 
@@ -32,8 +33,8 @@
 import static org.junit.Assert.assertTrue;
 
 /**
- * Tests for our hostname verifier. Most of these tests are from AOSP, which
- * itself includes tests from the Apache HTTP Client test suite.
+ * Tests for our hostname verifier. Most of these tests are from AOSP, which itself includes tests
+ * from the Apache HTTP Client test suite.
  */
 public final class HostnameVerifierTest {
   private HostnameVerifier verifier = OkHostnameVerifier.INSTANCE;
@@ -144,9 +145,9 @@
   }
 
   /**
-   * Ignored due to incompatibilities between Android and Java on how non-ASCII
-   * subject alt names are parsed. Android fails to parse these, which means we
-   * fall back to the CN. The RI does parse them, so the CN is unused.
+   * Ignored due to incompatibilities between Android and Java on how non-ASCII subject alt names
+   * are parsed. Android fails to parse these, which means we fall back to the CN. The RI does parse
+   * them, so the CN is unused.
    */
   @Test @Ignore public void verifyNonAsciiSubjectAlt() throws Exception {
     // CN=foo.com, subjectAlt=bar.com, subjectAlt=&#x82b1;&#x5b50;.co.jp
@@ -329,9 +330,9 @@
   }
 
   /**
-   * Ignored due to incompatibilities between Android and Java on how non-ASCII
-   * subject alt names are parsed. Android fails to parse these, which means we
-   * fall back to the CN. The RI does parse them, so the CN is unused.
+   * Ignored due to incompatibilities between Android and Java on how non-ASCII subject alt names
+   * are parsed. Android fails to parse these, which means we fall back to the CN. The RI does parse
+   * them, so the CN is unused.
    */
   @Test @Ignore public void testWilcardNonAsciiSubjectAlt() throws Exception {
     // CN=*.foo.com, subjectAlt=*.bar.com, subjectAlt=*.&#x82b1;&#x5b50;.co.jp
@@ -432,10 +433,9 @@
   }
 
   /**
-   * Earlier implementations of Android's hostname verifier required that
-   * wildcard names wouldn't match "*.com" or similar. This was a nonstandard
-   * check that we've since dropped. It is the CA's responsibility to not hand
-   * out certificates that match so broadly.
+   * Earlier implementations of Android's hostname verifier required that wildcard names wouldn't
+   * match "*.com" or similar. This was a nonstandard check that we've since dropped. It is the CA's
+   * responsibility to not hand out certificates that match so broadly.
    */
   @Test public void wildcardsDoesNotNeedTwoDots() throws Exception {
     // openssl req -x509 -nodes -days 36500 -subj '/CN=*.com' -newkey rsa:512 -out cert.pem
@@ -518,28 +518,28 @@
 
   @Test public void verifyAsIpAddress() {
     // IPv4
-    assertTrue(OkHostnameVerifier.verifyAsIpAddress("127.0.0.1"));
-    assertTrue(OkHostnameVerifier.verifyAsIpAddress("1.2.3.4"));
+    assertTrue(Util.verifyAsIpAddress("127.0.0.1"));
+    assertTrue(Util.verifyAsIpAddress("1.2.3.4"));
 
     // IPv6
-    assertTrue(OkHostnameVerifier.verifyAsIpAddress("::1"));
-    assertTrue(OkHostnameVerifier.verifyAsIpAddress("2001:db8::1"));
-    assertTrue(OkHostnameVerifier.verifyAsIpAddress("::192.168.0.1"));
-    assertTrue(OkHostnameVerifier.verifyAsIpAddress("::ffff:192.168.0.1"));
-    assertTrue(OkHostnameVerifier.verifyAsIpAddress("FEDC:BA98:7654:3210:FEDC:BA98:7654:3210"));
-    assertTrue(OkHostnameVerifier.verifyAsIpAddress("1080:0:0:0:8:800:200C:417A"));
-    assertTrue(OkHostnameVerifier.verifyAsIpAddress("1080::8:800:200C:417A"));
-    assertTrue(OkHostnameVerifier.verifyAsIpAddress("FF01::101"));
-    assertTrue(OkHostnameVerifier.verifyAsIpAddress("0:0:0:0:0:0:13.1.68.3"));
-    assertTrue(OkHostnameVerifier.verifyAsIpAddress("0:0:0:0:0:FFFF:129.144.52.38"));
-    assertTrue(OkHostnameVerifier.verifyAsIpAddress("::13.1.68.3"));
-    assertTrue(OkHostnameVerifier.verifyAsIpAddress("::FFFF:129.144.52.38"));
+    assertTrue(Util.verifyAsIpAddress("::1"));
+    assertTrue(Util.verifyAsIpAddress("2001:db8::1"));
+    assertTrue(Util.verifyAsIpAddress("::192.168.0.1"));
+    assertTrue(Util.verifyAsIpAddress("::ffff:192.168.0.1"));
+    assertTrue(Util.verifyAsIpAddress("FEDC:BA98:7654:3210:FEDC:BA98:7654:3210"));
+    assertTrue(Util.verifyAsIpAddress("1080:0:0:0:8:800:200C:417A"));
+    assertTrue(Util.verifyAsIpAddress("1080::8:800:200C:417A"));
+    assertTrue(Util.verifyAsIpAddress("FF01::101"));
+    assertTrue(Util.verifyAsIpAddress("0:0:0:0:0:0:13.1.68.3"));
+    assertTrue(Util.verifyAsIpAddress("0:0:0:0:0:FFFF:129.144.52.38"));
+    assertTrue(Util.verifyAsIpAddress("::13.1.68.3"));
+    assertTrue(Util.verifyAsIpAddress("::FFFF:129.144.52.38"));
 
     // Hostnames
-    assertFalse(OkHostnameVerifier.verifyAsIpAddress("go"));
-    assertFalse(OkHostnameVerifier.verifyAsIpAddress("localhost"));
-    assertFalse(OkHostnameVerifier.verifyAsIpAddress("squareup.com"));
-    assertFalse(OkHostnameVerifier.verifyAsIpAddress("www.nintendo.co.jp"));
+    assertFalse(Util.verifyAsIpAddress("go"));
+    assertFalse(Util.verifyAsIpAddress("localhost"));
+    assertFalse(Util.verifyAsIpAddress("squareup.com"));
+    assertFalse(Util.verifyAsIpAddress("www.nintendo.co.jp"));
   }
 
   private X509Certificate certificate(String certificate) throws Exception {
diff --git a/okhttp-tests/src/test/resources/web-platform-test-urltestdata.txt b/okhttp-tests/src/test/resources/web-platform-test-urltestdata.txt
new file mode 100644
index 0000000000..87c4f67135
--- /dev/null
+++ b/okhttp-tests/src/test/resources/web-platform-test-urltestdata.txt
@@ -0,0 +1,342 @@
+# FORMAT NOT DOCUMENTED YET (parser is urltestparser.js)
+
+# Based on http://trac.webkit.org/browser/trunk/LayoutTests/fast/url/script-tests/segments.js
+http://example\t.\norg http://example.org/foo/bar s:http h:example.org p:/
+http://user:pass@foo:21/bar;par?b#c  s:http u:user pass:pass h:foo port:21 p:/bar;par q:?b f:#c
+http:foo.com  s:http h:example.org p:/foo/foo.com
+\t\s\s\s:foo.com\s\s\s\n  s:http h:example.org p:/foo/:foo.com
+\sfoo.com\s\s  s:http h:example.org p:/foo/foo.com
+a:\t\sfoo.com  s:a p:\sfoo.com
+http://f:21/\sb\s?\sd\s#\se\s  s:http h:f port:21 p:/%20b%20 q:?%20d%20 f:#\se
+http://f:/c  s:http h:f p:/c
+http://f:0/c  s:http h:f port:0 p:/c
+http://f:00000000000000/c  s:http h:f port:0 p:/c
+http://f:00000000000000000000080/c  s:http h:f p:/c
+http://f:b/c
+http://f:\s/c
+http://f:\n/c  s:http h:f p:/c
+http://f:fifty-two/c
+http://f:999999/c  s:http h:f port:999999 p:/c
+http://f:\s21\s/\sb\s?\sd\s#\se\s
+  s:http h:example.org p:/foo/bar
+\s\s\t  s:http h:example.org p:/foo/bar
+:foo.com/  s:http h:example.org p:/foo/:foo.com/
+:foo.com\\  s:http h:example.org p:/foo/:foo.com/
+:  s:http h:example.org p:/foo/:
+:a  s:http h:example.org p:/foo/:a
+:/  s:http h:example.org p:/foo/:/
+:\\  s:http h:example.org p:/foo/:/
+:#  s:http h:example.org p:/foo/: f:#
+\#  s:http h:example.org p:/foo/bar f:#
+\#/  s:http h:example.org p:/foo/bar f:#/
+\#\\  s:http h:example.org p:/foo/bar f:#\\
+\#;?  s:http h:example.org p:/foo/bar f:#;?
+?  s:http h:example.org p:/foo/bar q:?
+/  s:http h:example.org p:/
+:23  s:http h:example.org p:/foo/:23
+/:23  s:http h:example.org p:/:23
+::  s:http h:example.org p:/foo/::
+::23  s:http h:example.org p:/foo/::23
+foo://  s:foo p://
+http://a:b@c:29/d  s:http u:a pass:b h:c port:29 p:/d
+http::@c:29  s:http h:example.org p:/foo/:@c:29
+http://&a:foo(b]c@d:2/  s:http u:&a pass:foo(b]c h:d port:2 p:/
+http://::@c@d:2  s:http pass::%40c h:d port:2 p:/
+http://foo.com:b@d/  s:http u:foo.com pass:b h:d p:/
+http://foo.com/\\@  s:http h:foo.com p://@
+http:\\\\foo.com\\  s:http h:foo.com p:/
+http:\\\\a\\b:c\\d@foo.com\\  s:http h:a p:/b:c/d@foo.com/
+foo:/  s:foo p:/
+foo:/bar.com/  s:foo p:/bar.com/
+foo://///////  s:foo p://///////
+foo://///////bar.com/  s:foo p://///////bar.com/
+foo:////://///  s:foo p:////://///
+c:/foo  s:c p:/foo
+//foo/bar  s:http h:foo p:/bar
+http://foo/path;a??e#f#g  s:http h:foo p:/path;a q:??e f:#f#g
+http://foo/abcd?efgh?ijkl  s:http h:foo p:/abcd q:?efgh?ijkl
+http://foo/abcd#foo?bar  s:http h:foo p:/abcd f:#foo?bar
+[61:24:74]:98  s:http h:example.org p:/foo/[61:24:74]:98
+http:[61:27]/:foo  s:http h:example.org p:/foo/[61:27]/:foo
+http://[1::2]:3:4
+http://2001::1
+http://2001::1]
+http://2001::1]:80
+http://[2001::1]  s:http h:[2001::1] p:/
+http://[2001::1]:80  s:http h:[2001::1] p:/
+http:/example.com/  s:http h:example.org p:/example.com/
+ftp:/example.com/  s:ftp h:example.com p:/
+https:/example.com/  s:https h:example.com p:/
+madeupscheme:/example.com/  s:madeupscheme p:/example.com/
+file:/example.com/  s:file p:/example.com/
+ftps:/example.com/  s:ftps p:/example.com/
+gopher:/example.com/  s:gopher h:example.com p:/
+ws:/example.com/  s:ws h:example.com p:/
+wss:/example.com/  s:wss h:example.com p:/
+data:/example.com/  s:data p:/example.com/
+javascript:/example.com/  s:javascript p:/example.com/
+mailto:/example.com/  s:mailto p:/example.com/
+http:example.com/  s:http h:example.org p:/foo/example.com/
+ftp:example.com/  s:ftp h:example.com p:/
+https:example.com/  s:https h:example.com p:/
+madeupscheme:example.com/  s:madeupscheme p:example.com/
+ftps:example.com/  s:ftps p:example.com/
+gopher:example.com/  s:gopher h:example.com p:/
+ws:example.com/  s:ws h:example.com p:/
+wss:example.com/  s:wss h:example.com p:/
+data:example.com/  s:data p:example.com/
+javascript:example.com/  s:javascript p:example.com/
+mailto:example.com/  s:mailto p:example.com/
+/a/b/c  s:http h:example.org p:/a/b/c
+/a/\s/c  s:http h:example.org p:/a/%20/c
+/a%2fc  s:http h:example.org p:/a%2fc
+/a/%2f/c  s:http h:example.org p:/a/%2f/c
+\#\u03B2  s:http h:example.org p:/foo/bar f:#\u03B2
+data:text/html,test#test  s:data p:text/html,test f:#test
+
+# Based on http://trac.webkit.org/browser/trunk/LayoutTests/fast/url/file.html
+
+# Basic canonicalization, uppercase should be converted to lowercase
+file:c:\\foo\\bar.html file:///tmp/mock/path s:file p:/c:/foo/bar.html
+
+# Spaces should fail
+\s\sFile:c|////foo\\bar.html  s:file p:/c:////foo/bar.html
+
+# This should fail
+C|/foo/bar  s:file p:/C:/foo/bar
+
+# This should fail
+/C|\\foo\\bar  s:file p:/C:/foo/bar
+//C|/foo/bar  s:file p:/C:/foo/bar
+//server/file  s:file h:server p:/file
+\\\\server\\file  s:file h:server p:/file
+/\\server/file  s:file h:server p:/file
+file:///foo/bar.txt  s:file p:/foo/bar.txt
+file:///home/me  s:file p:/home/me
+//  s:file p:/
+///  s:file p:/
+///test  s:file p:/test
+file://test  s:file h:test p:/
+file://localhost  s:file h:localhost p:/
+file://localhost/  s:file h:localhost p:/
+file://localhost/test  s:file h:localhost p:/test
+test  s:file p:/tmp/mock/test
+file:test  s:file p:/tmp/mock/test
+
+# Based on http://trac.webkit.org/browser/trunk/LayoutTests/fast/url/script-tests/path.js
+http://example.com/././foo about:blank s:http h:example.com p:/foo
+http://example.com/./.foo  s:http h:example.com p:/.foo
+http://example.com/foo/.  s:http h:example.com p:/foo/
+http://example.com/foo/./  s:http h:example.com p:/foo/
+http://example.com/foo/bar/..  s:http h:example.com p:/foo/
+http://example.com/foo/bar/../  s:http h:example.com p:/foo/
+http://example.com/foo/..bar  s:http h:example.com p:/foo/..bar
+http://example.com/foo/bar/../ton  s:http h:example.com p:/foo/ton
+http://example.com/foo/bar/../ton/../../a  s:http h:example.com p:/a
+http://example.com/foo/../../..  s:http h:example.com p:/
+http://example.com/foo/../../../ton  s:http h:example.com p:/ton
+http://example.com/foo/%2e  s:http h:example.com p:/foo/
+http://example.com/foo/%2e%2  s:http h:example.com p:/foo/%2e%2
+http://example.com/foo/%2e./%2e%2e/.%2e/%2e.bar  s:http h:example.com p:/%2e.bar
+http://example.com////../..  s:http h:example.com p://
+http://example.com/foo/bar//../..  s:http h:example.com p:/foo/
+http://example.com/foo/bar//..  s:http h:example.com p:/foo/bar/
+http://example.com/foo  s:http h:example.com p:/foo
+http://example.com/%20foo  s:http h:example.com p:/%20foo
+http://example.com/foo%  s:http h:example.com p:/foo%
+http://example.com/foo%2  s:http h:example.com p:/foo%2
+http://example.com/foo%2zbar  s:http h:example.com p:/foo%2zbar
+http://example.com/foo%2\u00C2\u00A9zbar  s:http h:example.com p:/foo%2%C3%82%C2%A9zbar
+http://example.com/foo%41%7a  s:http h:example.com p:/foo%41%7a
+http://example.com/foo\t\u0091%91  s:http h:example.com p:/foo%C2%91%91
+http://example.com/foo%00%51  s:http h:example.com p:/foo%00%51
+http://example.com/(%28:%3A%29)  s:http h:example.com p:/(%28:%3A%29)
+http://example.com/%3A%3a%3C%3c  s:http h:example.com p:/%3A%3a%3C%3c
+http://example.com/foo\tbar  s:http h:example.com p:/foobar
+http://example.com\\\\foo\\\\bar  s:http h:example.com p://foo//bar
+http://example.com/%7Ffp3%3Eju%3Dduvgw%3Dd  s:http h:example.com p:/%7Ffp3%3Eju%3Dduvgw%3Dd
+http://example.com/@asdf%40  s:http h:example.com p:/@asdf%40
+http://example.com/\u4F60\u597D\u4F60\u597D  s:http h:example.com p:/%E4%BD%A0%E5%A5%BD%E4%BD%A0%E5%A5%BD
+http://example.com/\u2025/foo  s:http h:example.com p:/%E2%80%A5/foo
+http://example.com/\uFEFF/foo  s:http h:example.com p:/%EF%BB%BF/foo
+http://example.com/\u202E/foo/\u202D/bar  s:http h:example.com p:/%E2%80%AE/foo/%E2%80%AD/bar
+
+# Based on http://trac.webkit.org/browser/trunk/LayoutTests/fast/url/script-tests/relative.js
+http://www.google.com/foo?bar=baz# about:blank s:http h:www.google.com p:/foo q:?bar=baz f:#
+http://www.google.com/foo?bar=baz#\s\u00BB  s:http h:www.google.com p:/foo q:?bar=baz f:#\s\u00BB
+data:test#\s\u00BB  s:data p:test f:#\s\u00BB
+http://[www.google.com]/
+http://www.google.com  s:http h:www.google.com p:/
+http://192.0x00A80001  s:http h:192.168.0.1 p:/
+http://www/foo%2Ehtml  s:http h:www p:/foo%2Ehtml
+http://www/foo/%2E/html  s:http h:www p:/foo/html
+http://user:pass@/
+http://%25DOMAIN:foobar@foodomain.com/  s:http u:%25DOMAIN pass:foobar h:foodomain.com p:/
+http:\\\\www.google.com\\foo  s:http h:www.google.com p:/foo
+http://foo:80/  s:http h:foo p:/
+http://foo:81/  s:http h:foo port:81 p:/
+httpa://foo:80/  s:httpa p://foo:80/
+http://foo:-80/
+https://foo:443/  s:https h:foo p:/
+https://foo:80/  s:https h:foo port:80 p:/
+ftp://foo:21/  s:ftp h:foo p:/
+ftp://foo:80/  s:ftp h:foo port:80 p:/
+gopher://foo:70/  s:gopher h:foo p:/
+gopher://foo:443/  s:gopher h:foo port:443 p:/
+ws://foo:80/  s:ws h:foo p:/
+ws://foo:81/  s:ws h:foo port:81 p:/
+ws://foo:443/  s:ws h:foo port:443 p:/
+ws://foo:815/  s:ws h:foo port:815 p:/
+wss://foo:80/  s:wss h:foo port:80 p:/
+wss://foo:81/  s:wss h:foo port:81 p:/
+wss://foo:443/  s:wss h:foo p:/
+wss://foo:815/  s:wss h:foo port:815 p:/
+http:/example.com/  s:http h:example.com p:/
+ftp:/example.com/  s:ftp h:example.com p:/
+https:/example.com/  s:https h:example.com p:/
+madeupscheme:/example.com/  s:madeupscheme p:/example.com/
+file:/example.com/  s:file p:/example.com/
+ftps:/example.com/  s:ftps p:/example.com/
+gopher:/example.com/  s:gopher h:example.com p:/
+ws:/example.com/  s:ws h:example.com p:/
+wss:/example.com/  s:wss h:example.com p:/
+data:/example.com/  s:data p:/example.com/
+javascript:/example.com/  s:javascript p:/example.com/
+mailto:/example.com/  s:mailto p:/example.com/
+http:example.com/  s:http h:example.com p:/
+ftp:example.com/  s:ftp h:example.com p:/
+https:example.com/  s:https h:example.com p:/
+madeupscheme:example.com/  s:madeupscheme p:example.com/
+ftps:example.com/  s:ftps p:example.com/
+gopher:example.com/  s:gopher h:example.com p:/
+ws:example.com/  s:ws h:example.com p:/
+wss:example.com/  s:wss h:example.com p:/
+data:example.com/  s:data p:example.com/
+javascript:example.com/  s:javascript p:example.com/
+mailto:example.com/  s:mailto p:example.com/
+
+# Based on http://trac.webkit.org/browser/trunk/LayoutTests/fast/url/segments-userinfo-vs-host.html
+http:@www.example.com about:blank s:http h:www.example.com p:/
+http:/@www.example.com  s:http h:www.example.com p:/
+http://@www.example.com  s:http h:www.example.com p:/
+http:a:b@www.example.com  s:http u:a pass:b h:www.example.com p:/
+http:/a:b@www.example.com  s:http u:a pass:b h:www.example.com p:/
+http://a:b@www.example.com  s:http u:a pass:b h:www.example.com p:/
+http://@pple.com  s:http h:pple.com p:/
+http::b@www.example.com  s:http pass:b h:www.example.com p:/
+http:/:b@www.example.com  s:http pass:b h:www.example.com p:/
+http://:b@www.example.com  s:http pass:b h:www.example.com p:/
+http:/:@/www.example.com
+http://user@/www.example.com
+http:@/www.example.com
+http:/@/www.example.com
+http://@/www.example.com
+https:@/www.example.com
+http:a:b@/www.example.com
+http:/a:b@/www.example.com
+http://a:b@/www.example.com
+http::@/www.example.com
+http:a:@www.example.com  s:http u:a pass: h:www.example.com p:/
+http:/a:@www.example.com  s:http u:a pass: h:www.example.com p:/
+http://a:@www.example.com  s:http u:a pass: h:www.example.com p:/
+http://www.@pple.com  s:http u:www. h:pple.com p:/
+http:@:www.example.com
+http:/@:www.example.com
+http://@:www.example.com
+http://:@www.example.com  s:http pass: h:www.example.com p:/
+
+#Others
+/ http://www.example.com/test s:http h:www.example.com p:/
+/test.txt  s:http h:www.example.com p:/test.txt
+.  s:http h:www.example.com p:/
+..  s:http h:www.example.com p:/
+test.txt  s:http h:www.example.com p:/test.txt
+./test.txt  s:http h:www.example.com p:/test.txt
+../test.txt  s:http h:www.example.com p:/test.txt
+../aaa/test.txt  s:http h:www.example.com p:/aaa/test.txt
+../../test.txt  s:http h:www.example.com p:/test.txt
+\u4E2D/test.txt  s:http h:www.example.com p:/%E4%B8%AD/test.txt
+http://www.example2.com  s:http h:www.example2.com p:/
+//www.example2.com  s:http h:www.example2.com p:/
+
+# Based on http://trac.webkit.org/browser/trunk/LayoutTests/fast/url/host.html
+
+# Basic canonicalization, uppercase should be converted to lowercase
+http://ExAmPlE.CoM http://other.com/ s:http p:/ h:example.com
+
+# Spaces should fail
+http://example\sexample.com
+
+# This should fail
+http://Goo%20\sgoo%7C|.com
+
+# U+3000 is mapped to U+0020 (space) which is disallowed
+http://GOO\u00a0\u3000goo.com
+
+# Other types of space (no-break, zero-width, zero-width-no-break) are
+# name-prepped away to nothing.
+# U+200B, U+2060, and U+FEFF, are ignored
+http://GOO\u200b\u2060\ufeffgoo.com  s:http p:/ h:googoo.com
+
+# Ideographic full stop (full-width period for Chinese, etc.) should be
+# treated as a dot.
+# U+3002 is mapped to U+002E (dot)
+http://www.foo\u3002bar.com  s:http p:/ h:www.foo.bar.com
+
+# Invalid unicode characters should fail...
+# U+FDD0 is disallowed; %ef%b7%90 is U+FDD0
+http://\ufdd0zyx.com
+
+# ...This is the same as previous but escaped.
+http://%ef%b7%90zyx.com
+
+# Test name prepping, fullwidth input should be converted to ASCII and NOT
+# IDN-ized. This is "Go" in fullwidth UTF-8/UTF-16.
+http://\uff27\uff4f.com  s:http p:/ h:go.com
+
+# URL spec forbids the following.
+# https://www.w3.org/Bugs/Public/show_bug.cgi?id=24257
+http://\uff05\uff14\uff11.com
+http://%ef%bc%85%ef%bc%94%ef%bc%91.com
+
+# ...%00 in fullwidth should fail (also as escaped UTF-8 input)
+http://\uff05\uff10\uff10.com
+http://%ef%bc%85%ef%bc%90%ef%bc%90.com
+
+# Basic IDN support, UTF-8 and UTF-16 input should be converted to IDN
+http://\u4f60\u597d\u4f60\u597d  s:http p:/ h:xn--6qqa088eba
+
+# Invalid escaped characters should fail and the percents should be
+# escaped. https://www.w3.org/Bugs/Public/show_bug.cgi?id=24191
+http://%zz%66%a.com
+
+# If we get an invalid character that has been escaped.
+http://%25
+http://hello%00
+
+# Escaped numbers should be treated like IP addresses if they are.
+# No special handling for IPv4 or IPv4-like URLs
+http://%30%78%63%30%2e%30%32%35%30.01  s:http p:/ h:192.168.0.1
+http://%30%78%63%30%2e%30%32%35%30.01%2e  s:http p:/ h:0xc0.0250.01.
+http://192.168.0.257
+
+# Invalid escaping should trigger the regular host error handling.
+http://%3g%78%63%30%2e%30%32%35%30%2E.01
+
+# Something that isn't exactly an IP should get treated as a host and
+# spaces escaped.
+http://192.168.0.1\shello
+
+# Fullwidth and escaped UTF-8 fullwidth should still be treated as IP.
+# These are "0Xc0.0250.01" in fullwidth.
+http://\uff10\uff38\uff43\uff10\uff0e\uff10\uff12\uff15\uff10\uff0e\uff10\uff11  s:http p:/ h:192.168.0.1
+
+# Broken IPv6
+http://[google.com]
+
+# Misc Unicode
+http://foo:\uD83D\uDCA9@example.com/bar  s:http h:example.com p:/bar u:foo pass:%F0%9F%92%A9
+
+# resolving a relative reference against an unknown scheme results in an error
+x test:test
+
diff --git a/okhttp-urlconnection/pom.xml b/okhttp-urlconnection/pom.xml
index 932a07235b..3aaa66dbdd 100644
--- a/okhttp-urlconnection/pom.xml
+++ b/okhttp-urlconnection/pom.xml
@@ -4,9 +4,9 @@
   <modelVersion>4.0.0</modelVersion>
 
   <parent>
-    <groupId>com.squareup.okhttp</groupId>
+    <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>2.4.0-SNAPSHOT</version>
+    <version>3.4.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-urlconnection</artifactId>
@@ -14,10 +14,16 @@
 
   <dependencies>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>${project.groupId}</groupId>
       <artifactId>okhttp</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp-testing-support</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
@@ -25,7 +31,7 @@
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>${project.groupId}</groupId>
       <artifactId>mockwebserver</artifactId>
       <version>${project.version}</version>
       <scope>test</scope>
@@ -38,7 +44,7 @@
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-javadoc-plugin</artifactId>
         <configuration>
-          <excludePackageNames>com.squareup.okhttp.internal.*</excludePackageNames>
+          <excludePackageNames>okhttp3.internal:okhttp3.internal.*</excludePackageNames>
           <links>
             <link>http://square.github.io/okhttp/javadoc/</link>
           </links>
diff --git a/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java b/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java
deleted file mode 100644
index 04ac55206c..0000000000
--- a/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java
+++ /dev/null
@@ -1,572 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package com.squareup.okhttp.internal.huc;
-
-import com.squareup.okhttp.Connection;
-import com.squareup.okhttp.Handshake;
-import com.squareup.okhttp.Headers;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Protocol;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
-import com.squareup.okhttp.Route;
-import com.squareup.okhttp.internal.Internal;
-import com.squareup.okhttp.internal.Platform;
-import com.squareup.okhttp.internal.Util;
-import com.squareup.okhttp.internal.http.HttpDate;
-import com.squareup.okhttp.internal.http.HttpEngine;
-import com.squareup.okhttp.internal.http.HttpMethod;
-import com.squareup.okhttp.internal.http.OkHeaders;
-import com.squareup.okhttp.internal.http.RetryableSink;
-import com.squareup.okhttp.internal.http.StatusLine;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.net.HttpRetryException;
-import java.net.HttpURLConnection;
-import java.net.InetSocketAddress;
-import java.net.ProtocolException;
-import java.net.Proxy;
-import java.net.SocketPermission;
-import java.net.URL;
-import java.security.Permission;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.Date;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.concurrent.TimeUnit;
-import okio.BufferedSink;
-import okio.Sink;
-
-/**
- * This implementation uses HttpEngine to send requests and receive responses.
- * This class may use multiple HttpEngines to follow redirects, authentication
- * retries, etc. to retrieve the final response body.
- *
- * <h3>What does 'connected' mean?</h3>
- * This class inherits a {@code connected} field from the superclass. That field
- * is <strong>not</strong> used to indicate not whether this URLConnection is
- * currently connected. Instead, it indicates whether a connection has ever been
- * attempted. Once a connection has been attempted, certain properties (request
- * header fields, request method, etc.) are immutable.
- */
-public class HttpURLConnectionImpl extends HttpURLConnection {
-  private static final Set<String> METHODS = new LinkedHashSet<>(
-      Arrays.asList("OPTIONS", "GET", "HEAD", "POST", "PUT", "DELETE", "TRACE", "PATCH"));
-
-  final OkHttpClient client;
-
-  private Headers.Builder requestHeaders = new Headers.Builder();
-
-  /** Like the superclass field of the same name, but a long and available on all platforms. */
-  private long fixedContentLength = -1;
-  private int followUpCount;
-  protected IOException httpEngineFailure;
-  protected HttpEngine httpEngine;
-  /** Lazily created (with synthetic headers) on first call to getHeaders(). */
-  private Headers responseHeaders;
-
-  /**
-   * The most recently attempted route. This will be null if we haven't sent a
-   * request yet, or if the response comes from a cache.
-   */
-  private Route route;
-
-  /**
-   * The most recently received TLS handshake. This will be null if we haven't
-   * connected yet, or if the most recent connection was HTTP (and not HTTPS).
-   */
-  Handshake handshake;
-
-  public HttpURLConnectionImpl(URL url, OkHttpClient client) {
-    super(url);
-    this.client = client;
-  }
-
-  @Override public final void connect() throws IOException {
-    initHttpEngine();
-    boolean success;
-    do {
-      success = execute(false);
-    } while (!success);
-  }
-
-  @Override public final void disconnect() {
-    // Calling disconnect() before a connection exists should have no effect.
-    if (httpEngine == null) return;
-
-    httpEngine.disconnect();
-
-    // This doesn't close the stream because doing so would require all stream
-    // access to be synchronized. It's expected that the thread using the
-    // connection will close its streams directly. If it doesn't, the worst
-    // case is that the GzipSource's Inflater won't be released until it's
-    // finalized. (This logs a warning on Android.)
-  }
-
-  /**
-   * Returns an input stream from the server in the case of error such as the
-   * requested file (txt, htm, html) is not found on the remote server.
-   */
-  @Override public final InputStream getErrorStream() {
-    try {
-      HttpEngine response = getResponse();
-      if (HttpEngine.hasBody(response.getResponse())
-          && response.getResponse().code() >= HTTP_BAD_REQUEST) {
-        return response.getResponse().body().byteStream();
-      }
-      return null;
-    } catch (IOException e) {
-      return null;
-    }
-  }
-
-  private Headers getHeaders() throws IOException {
-    if (responseHeaders == null) {
-      Response response = getResponse().getResponse();
-      Headers headers = response.headers();
-
-      responseHeaders = headers.newBuilder()
-          .add(Platform.get().getPrefix() + "-Response-Source", responseSourceHeader(response))
-          .build();
-    }
-    return responseHeaders;
-  }
-
-  private static String responseSourceHeader(Response response) {
-    if (response.networkResponse() == null) {
-      if (response.cacheResponse() == null) {
-        return "NONE";
-      }
-      return "CACHE " + response.code();
-    }
-    if (response.cacheResponse() == null) {
-      return "NETWORK " + response.code();
-    }
-    return "CONDITIONAL_CACHE " + response.networkResponse().code();
-  }
-
-  /**
-   * Returns the value of the field at {@code position}. Returns null if there
-   * are fewer than {@code position} headers.
-   */
-  @Override public final String getHeaderField(int position) {
-    try {
-      return getHeaders().value(position);
-    } catch (IOException e) {
-      return null;
-    }
-  }
-
-  /**
-   * Returns the value of the field corresponding to the {@code fieldName}, or
-   * null if there is no such field. If the field has multiple values, the
-   * last value is returned.
-   */
-  @Override public final String getHeaderField(String fieldName) {
-    try {
-      return fieldName == null
-          ? StatusLine.get(getResponse().getResponse()).toString()
-          : getHeaders().get(fieldName);
-    } catch (IOException e) {
-      return null;
-    }
-  }
-
-  @Override public final String getHeaderFieldKey(int position) {
-    try {
-      return getHeaders().name(position);
-    } catch (IOException e) {
-      return null;
-    }
-  }
-
-  @Override public final Map<String, List<String>> getHeaderFields() {
-    try {
-      return OkHeaders.toMultimap(getHeaders(),
-          StatusLine.get(getResponse().getResponse()).toString());
-    } catch (IOException e) {
-      return Collections.emptyMap();
-    }
-  }
-
-  @Override public final Map<String, List<String>> getRequestProperties() {
-    if (connected) {
-      throw new IllegalStateException(
-          "Cannot access request header fields after connection is set");
-    }
-
-    return OkHeaders.toMultimap(requestHeaders.build(), null);
-  }
-
-  @Override public final InputStream getInputStream() throws IOException {
-    if (!doInput) {
-      throw new ProtocolException("This protocol does not support input");
-    }
-
-    HttpEngine response = getResponse();
-
-    // if the requested file does not exist, throw an exception formerly the
-    // Error page from the server was returned if the requested file was
-    // text/html this has changed to return FileNotFoundException for all
-    // file types
-    if (getResponseCode() >= HTTP_BAD_REQUEST) {
-      throw new FileNotFoundException(url.toString());
-    }
-
-    return response.getResponse().body().byteStream();
-  }
-
-  @Override public final OutputStream getOutputStream() throws IOException {
-    connect();
-
-    BufferedSink sink = httpEngine.getBufferedRequestBody();
-    if (sink == null) {
-      throw new ProtocolException("method does not support a request body: " + method);
-    } else if (httpEngine.hasResponse()) {
-      throw new ProtocolException("cannot write request body after response has been read");
-    }
-
-    return sink.outputStream();
-  }
-
-  @Override public final Permission getPermission() throws IOException {
-    String hostName = getURL().getHost();
-    int hostPort = Util.getEffectivePort(getURL());
-    if (usingProxy()) {
-      InetSocketAddress proxyAddress = (InetSocketAddress) client.getProxy().address();
-      hostName = proxyAddress.getHostName();
-      hostPort = proxyAddress.getPort();
-    }
-    return new SocketPermission(hostName + ":" + hostPort, "connect, resolve");
-  }
-
-  @Override public final String getRequestProperty(String field) {
-    if (field == null) return null;
-    return requestHeaders.get(field);
-  }
-
-  @Override public void setConnectTimeout(int timeoutMillis) {
-    client.setConnectTimeout(timeoutMillis, TimeUnit.MILLISECONDS);
-  }
-
-  @Override
-  public void setInstanceFollowRedirects(boolean followRedirects) {
-    client.setFollowRedirects(followRedirects);
-  }
-
-  @Override public int getConnectTimeout() {
-    return client.getConnectTimeout();
-  }
-
-  @Override public void setReadTimeout(int timeoutMillis) {
-    client.setReadTimeout(timeoutMillis, TimeUnit.MILLISECONDS);
-  }
-
-  @Override public int getReadTimeout() {
-    return client.getReadTimeout();
-  }
-
-  private void initHttpEngine() throws IOException {
-    if (httpEngineFailure != null) {
-      throw httpEngineFailure;
-    } else if (httpEngine != null) {
-      return;
-    }
-
-    connected = true;
-    try {
-      if (doOutput) {
-        if (method.equals("GET")) {
-          // they are requesting a stream to write to. This implies a POST method
-          method = "POST";
-        } else if (!HttpMethod.permitsRequestBody(method)) {
-          throw new ProtocolException(method + " does not support writing");
-        }
-      }
-      // If the user set content length to zero, we know there will not be a request body.
-      httpEngine = newHttpEngine(method, null, null, null);
-    } catch (IOException e) {
-      httpEngineFailure = e;
-      throw e;
-    }
-  }
-
-  private HttpEngine newHttpEngine(String method, Connection connection,
-      RetryableSink requestBody, Response priorResponse) {
-    Request.Builder builder = new Request.Builder()
-        .url(getURL())
-        .method(method, null /* No body; that's passed separately. */);
-    Headers headers = requestHeaders.build();
-    for (int i = 0, size = headers.size(); i < size; i++) {
-      builder.addHeader(headers.name(i), headers.value(i));
-    }
-
-    boolean bufferRequestBody = false;
-    if (HttpMethod.permitsRequestBody(method)) {
-      // Specify how the request body is terminated.
-      if (fixedContentLength != -1) {
-        builder.header("Content-Length", Long.toString(fixedContentLength));
-      } else if (chunkLength > 0) {
-        builder.header("Transfer-Encoding", "chunked");
-      } else {
-        bufferRequestBody = true;
-      }
-
-      // Add a content type for the request body, if one isn't already present.
-      if (headers.get("Content-Type") == null) {
-        builder.header("Content-Type", "application/x-www-form-urlencoded");
-      }
-    }
-
-    if (headers.get("User-Agent") == null) {
-      builder.header("User-Agent", defaultUserAgent());
-    }
-
-    Request request = builder.build();
-
-    // If we're currently not using caches, make sure the engine's client doesn't have one.
-    OkHttpClient engineClient = client;
-    if (Internal.instance.internalCache(engineClient) != null && !getUseCaches()) {
-      engineClient = client.clone().setCache(null);
-    }
-
-    return new HttpEngine(engineClient, request, bufferRequestBody, true, false, connection, null,
-        requestBody, priorResponse);
-  }
-
-  private String defaultUserAgent() {
-    String agent = System.getProperty("http.agent");
-    return agent != null ? agent : ("Java" + System.getProperty("java.version"));
-  }
-
-  /**
-   * Aggressively tries to get the final HTTP response, potentially making
-   * many HTTP requests in the process in order to cope with redirects and
-   * authentication.
-   */
-  private HttpEngine getResponse() throws IOException {
-    initHttpEngine();
-
-    if (httpEngine.hasResponse()) {
-      return httpEngine;
-    }
-
-    while (true) {
-      if (!execute(true)) {
-        continue;
-      }
-
-      Response response = httpEngine.getResponse();
-      Request followUp = httpEngine.followUpRequest();
-
-      if (followUp == null) {
-        httpEngine.releaseConnection();
-        return httpEngine;
-      }
-
-      if (++followUpCount > HttpEngine.MAX_FOLLOW_UPS) {
-        throw new ProtocolException("Too many follow-up requests: " + followUpCount);
-      }
-
-      // The first request was insufficient. Prepare for another...
-      url = followUp.url();
-      requestHeaders = followUp.headers().newBuilder();
-
-      // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM redirect
-      // should keep the same method, Chrome, Firefox and the RI all issue GETs
-      // when following any redirect.
-      Sink requestBody = httpEngine.getRequestBody();
-      if (!followUp.method().equals(method)) {
-        requestBody = null;
-      }
-
-      if (requestBody != null && !(requestBody instanceof RetryableSink)) {
-        throw new HttpRetryException("Cannot retry streamed HTTP body", responseCode);
-      }
-
-      if (!httpEngine.sameConnection(followUp.url())) {
-        httpEngine.releaseConnection();
-      }
-
-      Connection connection = httpEngine.close();
-      httpEngine = newHttpEngine(followUp.method(), connection, (RetryableSink) requestBody,
-          response);
-    }
-  }
-
-  /**
-   * Sends a request and optionally reads a response. Returns true if the
-   * request was successfully executed, and false if the request can be
-   * retried. Throws an exception if the request failed permanently.
-   */
-  private boolean execute(boolean readResponse) throws IOException {
-    try {
-      httpEngine.sendRequest();
-      route = httpEngine.getRoute();
-      handshake = httpEngine.getConnection() != null
-          ? httpEngine.getConnection().getHandshake()
-          : null;
-      if (readResponse) {
-        httpEngine.readResponse();
-      }
-
-      return true;
-    } catch (IOException e) {
-      HttpEngine retryEngine = httpEngine.recover(e);
-      if (retryEngine != null) {
-        httpEngine = retryEngine;
-        return false;
-      }
-
-      // Give up; recovery is not possible.
-      httpEngineFailure = e;
-      throw e;
-    }
-  }
-
-  /**
-   * Returns true if either:
-   * <ul>
-   *   <li>A specific proxy was explicitly configured for this connection.
-   *   <li>The response has already been retrieved, and a proxy was {@link
-   *       java.net.ProxySelector selected} in order to get it.
-   * </ul>
-   *
-   * <p><strong>Warning:</strong> This method may return false before attempting
-   * to connect and true afterwards.
-   */
-  @Override public final boolean usingProxy() {
-    Proxy proxy = route != null
-        ? route.getProxy()
-        : client.getProxy();
-    return proxy != null && proxy.type() != Proxy.Type.DIRECT;
-  }
-
-  @Override public String getResponseMessage() throws IOException {
-    return getResponse().getResponse().message();
-  }
-
-  @Override public final int getResponseCode() throws IOException {
-    return getResponse().getResponse().code();
-  }
-
-  @Override public final void setRequestProperty(String field, String newValue) {
-    if (connected) {
-      throw new IllegalStateException("Cannot set request property after connection is made");
-    }
-    if (field == null) {
-      throw new NullPointerException("field == null");
-    }
-    if (newValue == null) {
-      // Silently ignore null header values for backwards compatibility with older
-      // android versions as well as with other URLConnection implementations.
-      //
-      // Some implementations send a malformed HTTP header when faced with
-      // such requests, we respect the spec and ignore the header.
-      Platform.get().logW("Ignoring header " + field + " because its value was null.");
-      return;
-    }
-
-    // TODO: Deprecate use of X-Android-Transports header?
-    if ("X-Android-Transports".equals(field) || "X-Android-Protocols".equals(field)) {
-      setProtocols(newValue, false /* append */);
-    } else {
-      requestHeaders.set(field, newValue);
-    }
-  }
-
-  @Override public void setIfModifiedSince(long newValue) {
-    super.setIfModifiedSince(newValue);
-    if (ifModifiedSince != 0) {
-      requestHeaders.set("If-Modified-Since", HttpDate.format(new Date(ifModifiedSince)));
-    } else {
-      requestHeaders.removeAll("If-Modified-Since");
-    }
-  }
-
-  @Override public final void addRequestProperty(String field, String value) {
-    if (connected) {
-      throw new IllegalStateException("Cannot add request property after connection is made");
-    }
-    if (field == null) {
-      throw new NullPointerException("field == null");
-    }
-    if (value == null) {
-      // Silently ignore null header values for backwards compatibility with older
-      // android versions as well as with other URLConnection implementations.
-      //
-      // Some implementations send a malformed HTTP header when faced with
-      // such requests, we respect the spec and ignore the header.
-      Platform.get().logW("Ignoring header " + field + " because its value was null.");
-      return;
-    }
-
-    // TODO: Deprecate use of X-Android-Transports header?
-    if ("X-Android-Transports".equals(field) || "X-Android-Protocols".equals(field)) {
-      setProtocols(value, true /* append */);
-    } else {
-      requestHeaders.add(field, value);
-    }
-  }
-
-  /*
-   * Splits and validates a comma-separated string of protocols.
-   * When append == false, we require that the transport list contains "http/1.1".
-   * Throws {@link IllegalStateException} when one of the protocols isn't
-   * defined in {@link Protocol OkHttp's protocol enumeration}.
-   */
-  private void setProtocols(String protocolsString, boolean append) {
-    List<Protocol> protocolsList = new ArrayList<>();
-    if (append) {
-      protocolsList.addAll(client.getProtocols());
-    }
-    for (String protocol : protocolsString.split(",", -1)) {
-      try {
-        protocolsList.add(Protocol.get(protocol));
-      } catch (IOException e) {
-        throw new IllegalStateException(e);
-      }
-    }
-    client.setProtocols(protocolsList);
-  }
-
-  @Override public void setRequestMethod(String method) throws ProtocolException {
-    if (!METHODS.contains(method)) {
-      throw new ProtocolException("Expected one of " + METHODS + " but was " + method);
-    }
-    this.method = method;
-  }
-
-  @Override public void setFixedLengthStreamingMode(int contentLength) {
-    setFixedLengthStreamingMode((long) contentLength);
-  }
-
-  @Override public void setFixedLengthStreamingMode(long contentLength) {
-    if (super.connected) throw new IllegalStateException("Already connected");
-    if (chunkLength > 0) throw new IllegalStateException("Already in chunked mode");
-    if (contentLength < 0) throw new IllegalArgumentException("contentLength < 0");
-    this.fixedContentLength = contentLength;
-    super.fixedContentLength = (int) Math.min(contentLength, Integer.MAX_VALUE);
-  }
-}
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/JavaNetAuthenticator.java b/okhttp-urlconnection/src/main/java/okhttp3/JavaNetAuthenticator.java
new file mode 100644
index 0000000000..b5440a4d02
--- /dev/null
+++ b/okhttp-urlconnection/src/main/java/okhttp3/JavaNetAuthenticator.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.net.Authenticator.RequestorType;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.PasswordAuthentication;
+import java.net.Proxy;
+import java.util.List;
+
+/**
+ * Adapts {@link java.net.Authenticator} to {@link Authenticator}. Configure OkHttp to use {@link
+ * java.net.Authenticator} with {@link OkHttpClient.Builder#authenticator} or {@link
+ * OkHttpClient.Builder#proxyAuthenticator(Authenticator)}.
+ */
+public final class JavaNetAuthenticator implements Authenticator {
+  @Override public Request authenticate(Route route, Response response) throws IOException {
+    List<Challenge> challenges = response.challenges();
+    Request request = response.request();
+    HttpUrl url = request.url();
+    boolean proxyAuthorization = response.code() == 407;
+    Proxy proxy = route.proxy();
+
+    for (int i = 0, size = challenges.size(); i < size; i++) {
+      Challenge challenge = challenges.get(i);
+      if (!"Basic".equalsIgnoreCase(challenge.scheme())) continue;
+
+      PasswordAuthentication auth;
+      if (proxyAuthorization) {
+        InetSocketAddress proxyAddress = (InetSocketAddress) proxy.address();
+        auth = java.net.Authenticator.requestPasswordAuthentication(
+            proxyAddress.getHostName(), getConnectToInetAddress(proxy, url), proxyAddress.getPort(),
+            url.scheme(), challenge.realm(), challenge.scheme(), url.url(),
+            RequestorType.PROXY);
+      } else {
+        auth = java.net.Authenticator.requestPasswordAuthentication(
+            url.host(), getConnectToInetAddress(proxy, url), url.port(), url.scheme(),
+            challenge.realm(), challenge.scheme(), url.url(), RequestorType.SERVER);
+      }
+
+      if (auth != null) {
+        String credential = Credentials.basic(auth.getUserName(), new String(auth.getPassword()));
+        return request.newBuilder()
+            .header(proxyAuthorization ? "Proxy-Authorization" : "Authorization", credential)
+            .build();
+      }
+    }
+
+    return null; // No challenges were satisfied!
+  }
+
+  private InetAddress getConnectToInetAddress(Proxy proxy, HttpUrl url) throws IOException {
+    return (proxy != null && proxy.type() != Proxy.Type.DIRECT)
+        ? ((InetSocketAddress) proxy.address()).getAddress()
+        : InetAddress.getByName(url.host());
+  }
+}
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/JavaNetCookieJar.java b/okhttp-urlconnection/src/main/java/okhttp3/JavaNetCookieJar.java
new file mode 100644
index 0000000000..6af8a69b65
--- /dev/null
+++ b/okhttp-urlconnection/src/main/java/okhttp3/JavaNetCookieJar.java
@@ -0,0 +1,112 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.net.CookieHandler;
+import java.net.HttpCookie;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import okhttp3.internal.Platform;
+
+import static okhttp3.internal.Platform.WARN;
+import static okhttp3.internal.Util.delimiterOffset;
+import static okhttp3.internal.Util.trimSubstring;
+
+/** A cookie jar that delegates to a {@link java.net.CookieHandler}. */
+public final class JavaNetCookieJar implements CookieJar {
+  private final CookieHandler cookieHandler;
+
+  public JavaNetCookieJar(CookieHandler cookieHandler) {
+    this.cookieHandler = cookieHandler;
+  }
+
+  @Override public void saveFromResponse(HttpUrl url, List<Cookie> cookies) {
+    if (cookieHandler != null) {
+      List<String> cookieStrings = new ArrayList<>();
+      for (Cookie cookie : cookies) {
+        cookieStrings.add(cookie.toString());
+      }
+      Map<String, List<String>> multimap = Collections.singletonMap("Set-Cookie", cookieStrings);
+      try {
+        cookieHandler.put(url.uri(), multimap);
+      } catch (IOException e) {
+        Platform.get().log(WARN, "Saving cookies failed for " + url.resolve("/..."), e);
+      }
+    }
+  }
+
+  @Override public List<Cookie> loadForRequest(HttpUrl url) {
+    // The RI passes all headers. We don't have 'em, so we don't pass 'em!
+    Map<String, List<String>> headers = Collections.emptyMap();
+    Map<String, List<String>> cookieHeaders;
+    try {
+      cookieHeaders = cookieHandler.get(url.uri(), headers);
+    } catch (IOException e) {
+      Platform.get().log(WARN, "Loading cookies failed for " + url.resolve("/..."), e);
+      return Collections.emptyList();
+    }
+
+    List<Cookie> cookies = null;
+    for (Map.Entry<String, List<String>> entry : cookieHeaders.entrySet()) {
+      String key = entry.getKey();
+      if (("Cookie".equalsIgnoreCase(key) || "Cookie2".equalsIgnoreCase(key))
+          && !entry.getValue().isEmpty()) {
+        for (String header : entry.getValue()) {
+          if (cookies == null) cookies = new ArrayList<>();
+          cookies.addAll(decodeHeaderAsJavaNetCookies(url, header));
+        }
+      }
+    }
+
+    return cookies != null
+        ? Collections.unmodifiableList(cookies)
+        : Collections.<Cookie>emptyList();
+  }
+
+  /**
+   * Convert a request header to OkHttp's cookies via {@link HttpCookie}. That extra step handles
+   * multiple cookies in a single request header, which {@link Cookie#parse} doesn't support.
+   */
+  private List<Cookie> decodeHeaderAsJavaNetCookies(HttpUrl url, String header) {
+    List<Cookie> result = new ArrayList<>();
+    for (int pos = 0, limit = header.length(), pairEnd; pos < limit; pos = pairEnd + 1) {
+      pairEnd = delimiterOffset(header, pos, limit, ";,");
+      int equalsSign = delimiterOffset(header, pos, pairEnd, '=');
+      String name = trimSubstring(header, pos, equalsSign);
+      if (name.startsWith("$")) continue;
+
+      // We have either name=value or just a name.
+      String value = equalsSign < pairEnd
+          ? trimSubstring(header, equalsSign + 1, pairEnd)
+          : "";
+
+      // If the value is "quoted", drop the quotes.
+      if (value.startsWith("\"") && value.endsWith("\"")) {
+        value = value.substring(1, value.length() - 1);
+      }
+
+      result.add(new Cookie.Builder()
+          .name(name)
+          .value(value)
+          .domain(url.host())
+          .build());
+    }
+    return result;
+  }
+}
diff --git a/okhttp-urlconnection/src/main/java/com/squareup/okhttp/OkUrlFactory.java b/okhttp-urlconnection/src/main/java/okhttp3/OkUrlFactory.java
similarity index 72%
rename from okhttp-urlconnection/src/main/java/com/squareup/okhttp/OkUrlFactory.java
rename to okhttp-urlconnection/src/main/java/okhttp3/OkUrlFactory.java
index 4b34559e4c..973c70578b 100644
--- a/okhttp-urlconnection/src/main/java/com/squareup/okhttp/OkUrlFactory.java
+++ b/okhttp-urlconnection/src/main/java/okhttp3/OkUrlFactory.java
@@ -13,10 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
-
-import com.squareup.okhttp.internal.huc.HttpURLConnectionImpl;
-import com.squareup.okhttp.internal.huc.HttpsURLConnectionImpl;
+package okhttp3;
 
 import java.net.HttpURLConnection;
 import java.net.Proxy;
@@ -24,9 +21,18 @@
 import java.net.URLConnection;
 import java.net.URLStreamHandler;
 import java.net.URLStreamHandlerFactory;
+import okhttp3.internal.URLFilter;
+import okhttp3.internal.huc.HttpURLConnectionImpl;
+import okhttp3.internal.huc.HttpsURLConnectionImpl;
 
+/**
+ * @deprecated OkHttp will be dropping its ability to be used with {@link HttpURLConnection} in an
+ * upcoming release. Applications that need this should either downgrade to the system's built-in
+ * {@link HttpURLConnection} or upgrade to OkHttp's Request/Response API.
+ */
 public final class OkUrlFactory implements URLStreamHandlerFactory, Cloneable {
-  private final OkHttpClient client;
+  private OkHttpClient client;
+  private URLFilter urlFilter;
 
   public OkUrlFactory(OkHttpClient client) {
     this.client = client;
@@ -36,25 +42,35 @@ public OkHttpClient client() {
     return client;
   }
 
+  public OkUrlFactory setClient(OkHttpClient client) {
+    this.client = client;
+    return this;
+  }
+
+  void setUrlFilter(URLFilter filter) {
+    urlFilter = filter;
+  }
+
   /**
-   * Returns a copy of this stream handler factory that includes a shallow copy
-   * of the internal {@linkplain OkHttpClient HTTP client}.
+   * Returns a copy of this stream handler factory that includes a shallow copy of the internal
+   * {@linkplain OkHttpClient HTTP client}.
    */
   @Override public OkUrlFactory clone() {
-    return new OkUrlFactory(client.clone());
+    return new OkUrlFactory(client);
   }
 
   public HttpURLConnection open(URL url) {
-    return open(url, client.getProxy());
+    return open(url, client.proxy());
   }
 
   HttpURLConnection open(URL url, Proxy proxy) {
     String protocol = url.getProtocol();
-    OkHttpClient copy = client.copyWithDefaults();
-    copy.setProxy(proxy);
+    OkHttpClient copy = client.newBuilder()
+        .proxy(proxy)
+        .build();
 
-    if (protocol.equals("http")) return new HttpURLConnectionImpl(url, copy);
-    if (protocol.equals("https")) return new HttpsURLConnectionImpl(url, copy);
+    if (protocol.equals("http")) return new HttpURLConnectionImpl(url, copy, urlFilter);
+    if (protocol.equals("https")) return new HttpsURLConnectionImpl(url, copy, urlFilter);
     throw new IllegalArgumentException("Unexpected protocol: " + protocol);
   }
 
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/JavaNetHeaders.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/JavaNetHeaders.java
new file mode 100644
index 0000000000..0b7a02e1f9
--- /dev/null
+++ b/okhttp-urlconnection/src/main/java/okhttp3/internal/JavaNetHeaders.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.List;
+import java.util.Map;
+import java.util.TreeMap;
+import okhttp3.Headers;
+
+public final class JavaNetHeaders {
+  private JavaNetHeaders() {
+  }
+
+  private static final Comparator<String> FIELD_NAME_COMPARATOR = new Comparator<String>() {
+    // @FindBugsSuppressWarnings("ES_COMPARING_PARAMETER_STRING_WITH_EQ")
+    @Override public int compare(String a, String b) {
+      if (a == b) {
+        return 0;
+      } else if (a == null) {
+        return -1;
+      } else if (b == null) {
+        return 1;
+      } else {
+        return String.CASE_INSENSITIVE_ORDER.compare(a, b);
+      }
+    }
+  };
+
+  /**
+   * Returns an immutable map containing each field to its list of values.
+   *
+   * @param valueForNullKey the request line for requests, or the status line for responses. If
+   * non-null, this value is mapped to the null key.
+   */
+  public static Map<String, List<String>> toMultimap(Headers headers, String valueForNullKey) {
+    Map<String, List<String>> result = new TreeMap<>(FIELD_NAME_COMPARATOR);
+    for (int i = 0, size = headers.size(); i < size; i++) {
+      String fieldName = headers.name(i);
+      String value = headers.value(i);
+
+      List<String> allValues = new ArrayList<>();
+      List<String> otherValues = result.get(fieldName);
+      if (otherValues != null) {
+        allValues.addAll(otherValues);
+      }
+      allValues.add(value);
+      result.put(fieldName, Collections.unmodifiableList(allValues));
+    }
+    if (valueForNullKey != null) {
+      result.put(null, Collections.unmodifiableList(Collections.singletonList(valueForNullKey)));
+    }
+    return Collections.unmodifiableMap(result);
+  }
+}
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/SystemPropertiesConnectionPool.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/SystemPropertiesConnectionPool.java
new file mode 100644
index 0000000000..e0c9523fb0
--- /dev/null
+++ b/okhttp-urlconnection/src/main/java/okhttp3/internal/SystemPropertiesConnectionPool.java
@@ -0,0 +1,67 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package okhttp3.internal;
+
+import java.util.concurrent.TimeUnit;
+import okhttp3.ConnectionPool;
+
+/**
+ * A shared connection pool that uses system properties for tuning parameters:
+ *
+ * <ul>
+ *     <li>{@code http.keepAlive} true if HTTP and SPDY connections should be pooled at all. Default
+ *         is true.
+ *     <li>{@code http.maxConnections} maximum number of idle connections to each to keep in the
+ *         pool. Default is 5.
+ *     <li>{@code http.keepAliveDuration} Time in milliseconds to keep the connection alive in the
+ *         pool before closing it. Default is 5 minutes. This property isn't used by {@code
+ *         HttpURLConnection}.
+ * </ul>
+ *
+ * <p>The default instance <i>doesn't</i> adjust its configuration as system properties are changed.
+ * This assumes that the applications that set these parameters do so before making HTTP
+ * connections, and that this class is initialized lazily.
+ */
+public final class SystemPropertiesConnectionPool {
+  private static final long DEFAULT_KEEP_ALIVE_DURATION_MS = 5 * 60 * 1000; // 5 min
+
+  public static final ConnectionPool INSTANCE;
+  static {
+    String keepAlive = System.getProperty("http.keepAlive");
+    int maxIdleConnections;
+    if (keepAlive != null && !Boolean.parseBoolean(keepAlive)) {
+      maxIdleConnections = 0;
+    } else {
+      String maxIdleConnectionsString = System.getProperty("http.maxConnections");
+      if (maxIdleConnectionsString != null) {
+        maxIdleConnections = Integer.parseInt(maxIdleConnectionsString);
+      } else {
+        maxIdleConnections = 5;
+      }
+    }
+
+    String keepAliveDurationString = System.getProperty("http.keepAliveDuration");
+    long keepAliveDurationMs = keepAliveDurationString != null
+        ? Long.parseLong(keepAliveDurationString)
+        : DEFAULT_KEEP_ALIVE_DURATION_MS;
+
+    INSTANCE = new ConnectionPool(maxIdleConnections, keepAliveDurationMs, TimeUnit.MILLISECONDS);
+  }
+
+  private SystemPropertiesConnectionPool() {
+  }
+}
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/URLFilter.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/URLFilter.java
new file mode 100644
index 0000000000..3b077f8bc4
--- /dev/null
+++ b/okhttp-urlconnection/src/main/java/okhttp3/internal/URLFilter.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal;
+import java.io.IOException;
+import java.net.URL;
+
+/**
+ * Request filter based on the request's URL.
+ *
+ * @deprecated use {@link okhttp3.Interceptor} for non-HttpURLConnection filtering.
+ */
+public interface URLFilter {
+  /**
+   * Check whether request to the provided URL is permitted to be issued.
+   *
+   * @throws IOException if the request to the provided URL is not permitted.
+   */
+  void checkURLPermitted(URL url) throws IOException;
+}
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/BufferedRequestBody.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/BufferedRequestBody.java
new file mode 100644
index 0000000000..b4b2f68347
--- /dev/null
+++ b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/BufferedRequestBody.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.huc;
+
+import java.io.IOException;
+import okhttp3.Request;
+import okio.Buffer;
+import okio.BufferedSink;
+
+/**
+ * This request body involves an application thread only. First all bytes are written to the buffer.
+ * Only once that is complete are bytes then copied to the network.
+ *
+ * <p>This body has two special powers. First, it can retransmit the same request body multiple
+ * times in order to recover from failures or cope with redirects. Second, it can compute the total
+ * length of the request body by measuring it after it has been written to the output stream.
+ */
+final class BufferedRequestBody extends OutputStreamRequestBody {
+  final Buffer buffer = new Buffer();
+  long contentLength = -1L;
+
+  BufferedRequestBody(long expectedContentLength) {
+    initOutputStream(buffer, expectedContentLength);
+  }
+
+  @Override public long contentLength() throws IOException {
+    return contentLength;
+  }
+
+  /**
+   * Now that we've buffered the entire request body, update the request headers and the body
+   * itself. This happens late to enable HttpURLConnection users to complete the socket connection
+   * before sending request body bytes.
+   */
+  @Override public Request prepareToSendRequest(Request request) throws IOException {
+    if (request.header("Content-Length") != null) return request;
+
+    outputStream().close();
+    contentLength = buffer.size();
+    return request.newBuilder()
+        .removeHeader("Transfer-Encoding")
+        .header("Content-Length", Long.toString(buffer.size()))
+        .build();
+  }
+
+  @Override public void writeTo(BufferedSink sink) throws IOException {
+    buffer.copyTo(sink.buffer(), 0, buffer.size());
+  }
+}
diff --git a/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/DelegatingHttpsURLConnection.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/DelegatingHttpsURLConnection.java
similarity index 97%
rename from okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/DelegatingHttpsURLConnection.java
rename to okhttp-urlconnection/src/main/java/okhttp3/internal/huc/DelegatingHttpsURLConnection.java
index 631a2ae03d..86f4aa7807 100644
--- a/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/DelegatingHttpsURLConnection.java
+++ b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/DelegatingHttpsURLConnection.java
@@ -14,9 +14,8 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.squareup.okhttp.internal.huc;
+package okhttp3.internal.huc;
 
-import com.squareup.okhttp.Handshake;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
@@ -32,10 +31,11 @@
 import javax.net.ssl.HttpsURLConnection;
 import javax.net.ssl.SSLPeerUnverifiedException;
 import javax.net.ssl.SSLSocketFactory;
+import okhttp3.Handshake;
 
 /**
- * Implement an HTTPS connection by delegating to an HTTP connection for
- * everything but the HTTPS-specific stuff.
+ * Implement an HTTPS connection by delegating to an HTTP connection for everything but the
+ * HTTPS-specific stuff.
  */
 abstract class DelegatingHttpsURLConnection extends HttpsURLConnection {
   private final HttpURLConnection delegate;
@@ -57,7 +57,7 @@ public DelegatingHttpsURLConnection(HttpURLConnection delegate) {
 
   @Override public String getCipherSuite() {
     Handshake handshake = handshake();
-    return handshake != null ? handshake.cipherSuite() : null;
+    return handshake != null ? handshake.cipherSuite().javaName() : null;
   }
 
   @Override public Certificate[] getLocalCertificates() {
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/HttpURLConnectionImpl.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/HttpURLConnectionImpl.java
new file mode 100644
index 0000000000..eabcaba875
--- /dev/null
+++ b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/HttpURLConnectionImpl.java
@@ -0,0 +1,638 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package okhttp3.internal.huc;
+
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InterruptedIOException;
+import java.io.OutputStream;
+import java.net.HttpURLConnection;
+import java.net.InetSocketAddress;
+import java.net.ProtocolException;
+import java.net.Proxy;
+import java.net.SocketPermission;
+import java.net.URL;
+import java.security.Permission;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.Date;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.TimeUnit;
+import okhttp3.Call;
+import okhttp3.Callback;
+import okhttp3.Handshake;
+import okhttp3.Headers;
+import okhttp3.HttpUrl;
+import okhttp3.Interceptor;
+import okhttp3.OkHttpClient;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.internal.Internal;
+import okhttp3.internal.JavaNetHeaders;
+import okhttp3.internal.Platform;
+import okhttp3.internal.URLFilter;
+import okhttp3.internal.Util;
+import okhttp3.internal.Version;
+import okhttp3.internal.http.HttpDate;
+import okhttp3.internal.http.HttpEngine;
+import okhttp3.internal.http.HttpMethod;
+import okhttp3.internal.http.OkHeaders;
+import okhttp3.internal.http.StatusLine;
+
+import static okhttp3.internal.Platform.WARN;
+
+/**
+ * This implementation uses {@linkplain Call} to send requests and receive responses.
+ *
+ * <h3>What does 'connected' mean?</h3> This class inherits a {@code connected} field from the
+ * superclass. That field is <strong>not</strong> used to indicate whether this URLConnection is
+ * currently connected. Instead, it indicates whether a connection has ever been attempted. Once a
+ * connection has been attempted, certain properties (request header fields, request method, etc.)
+ * are immutable.
+ */
+public class HttpURLConnectionImpl extends HttpURLConnection implements Callback {
+  private static final Set<String> METHODS = new LinkedHashSet<>(
+      Arrays.asList("OPTIONS", "GET", "HEAD", "POST", "PUT", "DELETE", "TRACE", "PATCH"));
+
+  // These fields are confined to the application thread that uses HttpURLConnection.
+
+  OkHttpClient client;
+  private final NetworkInterceptor networkInterceptor = new NetworkInterceptor();
+  private Headers.Builder requestHeaders = new Headers.Builder();
+  private boolean executed;
+  Call call;
+  URLFilter urlFilter;
+
+  /** Lazily created (with synthetic headers) on first call to getHeaders(). */
+  private Headers responseHeaders;
+
+  /** Like the superclass field of the same name, but a long and available on all platforms. */
+  private long fixedContentLength = -1L;
+
+  // These fields are guarded by lock.
+  private final Object lock = new Object();
+  private Response response;
+  private IOException callFailure;
+  Response networkResponse;
+  boolean connectPending = true;
+  Proxy proxy;
+  Handshake handshake;
+
+  public HttpURLConnectionImpl(URL url, OkHttpClient client) {
+    super(url);
+    this.client = client;
+  }
+
+  public HttpURLConnectionImpl(URL url, OkHttpClient client, URLFilter urlFilter) {
+    this(url, client);
+    this.urlFilter = urlFilter;
+  }
+
+  @Override public final void connect() throws IOException {
+    if (executed) return;
+
+    Call call = buildCall();
+    executed = true;
+    call.enqueue(this);
+
+    synchronized (lock) {
+      try {
+        while (connectPending && response == null && callFailure == null) {
+          lock.wait(); // Wait 'til the network interceptor is reached or the call fails.
+        }
+        if (callFailure != null) {
+          throw callFailure;
+        }
+      } catch (InterruptedException e) {
+        throw new InterruptedIOException();
+      }
+    }
+  }
+
+  @Override public final void disconnect() {
+    // Calling disconnect() before a connection exists should have no effect.
+    if (call == null) return;
+
+    networkInterceptor.proceed(); // Unblock any waiting async thread.
+    call.cancel();
+  }
+
+  /**
+   * Returns an input stream from the server in the case of error such as the requested file (txt,
+   * htm, html) is not found on the remote server.
+   */
+  @Override public final InputStream getErrorStream() {
+    try {
+      Response response = getResponse();
+      if (HttpEngine.hasBody(response) && response.code() >= HTTP_BAD_REQUEST) {
+        return response.body().byteStream();
+      }
+      return null;
+    } catch (IOException e) {
+      return null;
+    }
+  }
+
+  private Headers getHeaders() throws IOException {
+    if (responseHeaders == null) {
+      Response response = getResponse();
+      Headers headers = response.headers();
+      responseHeaders = headers.newBuilder()
+          .add(OkHeaders.SELECTED_PROTOCOL, response.protocol().toString())
+          .add(OkHeaders.RESPONSE_SOURCE, responseSourceHeader(response))
+          .build();
+    }
+    return responseHeaders;
+  }
+
+  private static String responseSourceHeader(Response response) {
+    if (response.networkResponse() == null) {
+      if (response.cacheResponse() == null) {
+        return "NONE";
+      }
+      return "CACHE " + response.code();
+    }
+    if (response.cacheResponse() == null) {
+      return "NETWORK " + response.code();
+    }
+    return "CONDITIONAL_CACHE " + response.networkResponse().code();
+  }
+
+  /**
+   * Returns the value of the field at {@code position}. Returns null if there are fewer than {@code
+   * position} headers.
+   */
+  @Override public final String getHeaderField(int position) {
+    try {
+      Headers headers = getHeaders();
+      if (position < 0 || position >= headers.size()) return null;
+      return headers.value(position);
+    } catch (IOException e) {
+      return null;
+    }
+  }
+
+  /**
+   * Returns the value of the field corresponding to the {@code fieldName}, or null if there is no
+   * such field. If the field has multiple values, the last value is returned.
+   */
+  @Override public final String getHeaderField(String fieldName) {
+    try {
+      return fieldName == null
+          ? StatusLine.get(getResponse()).toString()
+          : getHeaders().get(fieldName);
+    } catch (IOException e) {
+      return null;
+    }
+  }
+
+  @Override public final String getHeaderFieldKey(int position) {
+    try {
+      Headers headers = getHeaders();
+      if (position < 0 || position >= headers.size()) return null;
+      return headers.name(position);
+    } catch (IOException e) {
+      return null;
+    }
+  }
+
+  @Override public final Map<String, List<String>> getHeaderFields() {
+    try {
+      return JavaNetHeaders.toMultimap(getHeaders(),
+          StatusLine.get(getResponse()).toString());
+    } catch (IOException e) {
+      return Collections.emptyMap();
+    }
+  }
+
+  @Override public final Map<String, List<String>> getRequestProperties() {
+    if (connected) {
+      throw new IllegalStateException(
+          "Cannot access request header fields after connection is set");
+    }
+
+    return JavaNetHeaders.toMultimap(requestHeaders.build(), null);
+  }
+
+  @Override public final InputStream getInputStream() throws IOException {
+    if (!doInput) {
+      throw new ProtocolException("This protocol does not support input");
+    }
+
+    Response response = getResponse();
+
+    if (response.code() >= HTTP_BAD_REQUEST) {
+      throw new FileNotFoundException(url.toString());
+    }
+
+    return response.body().byteStream();
+  }
+
+  @Override public final OutputStream getOutputStream() throws IOException {
+    OutputStreamRequestBody requestBody = (OutputStreamRequestBody) buildCall().request().body();
+    if (requestBody == null) {
+      throw new ProtocolException("method does not support a request body: " + method);
+    }
+
+    // If this request needs to stream bytes to the server, build a physical connection immediately
+    // and start streaming those bytes over that connection.
+    if (requestBody instanceof StreamedRequestBody) {
+      connect();
+      networkInterceptor.proceed();
+    }
+
+    if (requestBody.isClosed()) {
+      throw new ProtocolException("cannot write request body after response has been read");
+    }
+
+    return requestBody.outputStream();
+  }
+
+  @Override public final Permission getPermission() throws IOException {
+    URL url = getURL();
+    String hostname = url.getHost();
+    int hostPort = url.getPort() != -1
+        ? url.getPort()
+        : HttpUrl.defaultPort(url.getProtocol());
+    if (usingProxy()) {
+      InetSocketAddress proxyAddress = (InetSocketAddress) client.proxy().address();
+      hostname = proxyAddress.getHostName();
+      hostPort = proxyAddress.getPort();
+    }
+    return new SocketPermission(hostname + ":" + hostPort, "connect, resolve");
+  }
+
+  @Override public final String getRequestProperty(String field) {
+    if (field == null) return null;
+    return requestHeaders.get(field);
+  }
+
+  @Override public void setConnectTimeout(int timeoutMillis) {
+    client = client.newBuilder()
+        .connectTimeout(timeoutMillis, TimeUnit.MILLISECONDS)
+        .build();
+  }
+
+  @Override
+  public void setInstanceFollowRedirects(boolean followRedirects) {
+    client = client.newBuilder()
+        .followRedirects(followRedirects)
+        .build();
+  }
+
+  @Override public boolean getInstanceFollowRedirects() {
+    return client.followRedirects();
+  }
+
+  @Override public int getConnectTimeout() {
+    return client.connectTimeoutMillis();
+  }
+
+  @Override public void setReadTimeout(int timeoutMillis) {
+    client = client.newBuilder()
+        .readTimeout(timeoutMillis, TimeUnit.MILLISECONDS)
+        .build();
+  }
+
+  @Override public int getReadTimeout() {
+    return client.readTimeoutMillis();
+  }
+
+  private Call buildCall() throws IOException {
+    if (call != null) {
+      return call;
+    }
+
+    connected = true;
+    if (doOutput) {
+      if (method.equals("GET")) {
+        // they are requesting a stream to write to. This implies a POST method
+        method = "POST";
+      } else if (!HttpMethod.permitsRequestBody(method)) {
+        throw new ProtocolException(method + " does not support writing");
+      }
+    }
+
+    if (requestHeaders.get("User-Agent") == null) {
+      requestHeaders.add("User-Agent", defaultUserAgent());
+    }
+
+    OutputStreamRequestBody requestBody = null;
+    if (HttpMethod.permitsRequestBody(method)) {
+      // Add a content type for the request body, if one isn't already present.
+      String contentType = requestHeaders.get("Content-Type");
+      if (contentType == null) {
+        contentType = "application/x-www-form-urlencoded";
+        requestHeaders.add("Content-Type", contentType);
+      }
+
+      boolean stream = fixedContentLength != -1L || chunkLength > 0;
+
+      long contentLength = -1L;
+      String contentLengthString = requestHeaders.get("Content-Length");
+      if (fixedContentLength != -1L) {
+        contentLength = fixedContentLength;
+      } else if (contentLengthString != null) {
+        contentLength = Long.parseLong(contentLengthString);
+      }
+
+      requestBody = stream
+          ? new StreamedRequestBody(contentLength)
+          : new BufferedRequestBody(contentLength);
+      requestBody.timeout().timeout(client.writeTimeoutMillis(), TimeUnit.MILLISECONDS);
+    }
+
+    Request request = new Request.Builder()
+        .url(Internal.instance.getHttpUrlChecked(getURL().toString()))
+        .headers(requestHeaders.build())
+        .method(method, requestBody)
+        .build();
+
+    if (urlFilter != null) {
+      urlFilter.checkURLPermitted(request.url().url());
+    }
+
+    OkHttpClient.Builder clientBuilder = client.newBuilder();
+    clientBuilder.interceptors().clear();
+    clientBuilder.networkInterceptors().clear();
+    clientBuilder.networkInterceptors().add(networkInterceptor);
+
+    // If we're currently not using caches, make sure the engine's client doesn't have one.
+    if (!getUseCaches()) {
+      clientBuilder.cache(null);
+    }
+
+    return call = clientBuilder.build().newCall(request);
+  }
+
+  private String defaultUserAgent() {
+    String agent = System.getProperty("http.agent");
+    return agent != null ? Util.toHumanReadableAscii(agent) : Version.userAgent();
+  }
+
+  /**
+   * Aggressively tries to get the final HTTP response, potentially making many HTTP requests in the
+   * process in order to cope with redirects and authentication.
+   */
+  private Response getResponse() throws IOException {
+    if (response != null) {
+      return response;
+    } else if (networkResponse != null) {
+      return networkResponse;
+    } else if (callFailure != null) {
+      throw callFailure;
+    }
+
+    Call call = buildCall();
+    networkInterceptor.proceed();
+
+    OutputStreamRequestBody requestBody = (OutputStreamRequestBody) call.request().body();
+    if (requestBody != null) requestBody.outputStream().close();
+
+    if (executed) {
+      synchronized (lock) {
+        try {
+          while (response == null && callFailure == null) {
+            lock.wait(); // Wait until the response is returned or the call fails.
+          }
+        } catch (InterruptedException e) {
+          throw new InterruptedIOException();
+        }
+      }
+    } else {
+      executed = true;
+      try {
+        onResponse(call, call.execute());
+      } catch (IOException e) {
+        onFailure(call, e);
+      }
+    }
+
+    synchronized (lock) {
+      if (callFailure != null) throw callFailure;
+      if (response != null) return response;
+    }
+
+    throw new AssertionError();
+  }
+
+  /**
+   * Returns true if either:
+   *
+   * <ul>
+   *   <li>A specific proxy was explicitly configured for this connection.
+   *   <li>The response has already been retrieved, and a proxy was {@link
+   *       java.net.ProxySelector selected} in order to get it.
+   * </ul>
+   *
+   * <p><strong>Warning:</strong> This method may return false before attempting to connect and true
+   * afterwards.
+   */
+  @Override public final boolean usingProxy() {
+    if (proxy != null) return true;
+    Proxy clientProxy = client.proxy();
+    return clientProxy != null && clientProxy.type() != Proxy.Type.DIRECT;
+  }
+
+  @Override public String getResponseMessage() throws IOException {
+    return getResponse().message();
+  }
+
+  @Override public final int getResponseCode() throws IOException {
+    return getResponse().code();
+  }
+
+  @Override public final void setRequestProperty(String field, String newValue) {
+    if (connected) {
+      throw new IllegalStateException("Cannot set request property after connection is made");
+    }
+    if (field == null) {
+      throw new NullPointerException("field == null");
+    }
+    if (newValue == null) {
+      // Silently ignore null header values for backwards compatibility with older
+      // android versions as well as with other URLConnection implementations.
+      //
+      // Some implementations send a malformed HTTP header when faced with
+      // such requests, we respect the spec and ignore the header.
+      Platform.get().log(WARN, "Ignoring header " + field + " because its value was null.", null);
+      return;
+    }
+
+    // TODO: Deprecate use of X-Android-Transports header?
+    if ("X-Android-Transports".equals(field) || "X-Android-Protocols".equals(field)) {
+      setProtocols(newValue, false /* append */);
+    } else {
+      requestHeaders.set(field, newValue);
+    }
+  }
+
+  @Override public void setIfModifiedSince(long newValue) {
+    super.setIfModifiedSince(newValue);
+    if (ifModifiedSince != 0) {
+      requestHeaders.set("If-Modified-Since", HttpDate.format(new Date(ifModifiedSince)));
+    } else {
+      requestHeaders.removeAll("If-Modified-Since");
+    }
+  }
+
+  @Override public final void addRequestProperty(String field, String value) {
+    if (connected) {
+      throw new IllegalStateException("Cannot add request property after connection is made");
+    }
+    if (field == null) {
+      throw new NullPointerException("field == null");
+    }
+    if (value == null) {
+      // Silently ignore null header values for backwards compatibility with older
+      // android versions as well as with other URLConnection implementations.
+      //
+      // Some implementations send a malformed HTTP header when faced with
+      // such requests, we respect the spec and ignore the header.
+      Platform.get().log(WARN, "Ignoring header " + field + " because its value was null.", null);
+      return;
+    }
+
+    // TODO: Deprecate use of X-Android-Transports header?
+    if ("X-Android-Transports".equals(field) || "X-Android-Protocols".equals(field)) {
+      setProtocols(value, true /* append */);
+    } else {
+      requestHeaders.add(field, value);
+    }
+  }
+
+  /*
+   * Splits and validates a comma-separated string of protocols.
+   * When append == false, we require that the transport list contains "http/1.1".
+   * Throws {@link IllegalStateException} when one of the protocols isn't
+   * defined in {@link Protocol OkHttp's protocol enumeration}.
+   */
+  private void setProtocols(String protocolsString, boolean append) {
+    List<Protocol> protocolsList = new ArrayList<>();
+    if (append) {
+      protocolsList.addAll(client.protocols());
+    }
+    for (String protocol : protocolsString.split(",", -1)) {
+      try {
+        protocolsList.add(Protocol.get(protocol));
+      } catch (IOException e) {
+        throw new IllegalStateException(e);
+      }
+    }
+    client = client.newBuilder()
+        .protocols(protocolsList)
+        .build();
+  }
+
+  @Override public void setRequestMethod(String method) throws ProtocolException {
+    if (!METHODS.contains(method)) {
+      throw new ProtocolException("Expected one of " + METHODS + " but was " + method);
+    }
+    this.method = method;
+  }
+
+  @Override public void setFixedLengthStreamingMode(int contentLength) {
+    setFixedLengthStreamingMode((long) contentLength);
+  }
+
+  @Override public void setFixedLengthStreamingMode(long contentLength) {
+    if (super.connected) throw new IllegalStateException("Already connected");
+    if (chunkLength > 0) throw new IllegalStateException("Already in chunked mode");
+    if (contentLength < 0) throw new IllegalArgumentException("contentLength < 0");
+    this.fixedContentLength = contentLength;
+    super.fixedContentLength = (int) Math.min(contentLength, Integer.MAX_VALUE);
+  }
+
+  @Override public void onFailure(Call call, IOException e) {
+    synchronized (lock) {
+      this.callFailure = e;
+      lock.notifyAll();
+    }
+  }
+
+  @Override public void onResponse(Call call, Response response) {
+    synchronized (lock) {
+      this.response = response;
+      this.handshake = response.handshake();
+      this.url = response.request().url().url();
+      lock.notifyAll();
+    }
+  }
+
+  /**
+   * The HttpURLConnection gives the application control between establishing the connection and
+   * transmitting the request body. This interceptor stalls async calls right at this point. The
+   * call will remain stalled until {@link #proceed()} is called.
+   */
+  final class NetworkInterceptor implements Interceptor {
+    // Guarded by HttpUrlConnection.this.
+    private boolean proceed;
+
+    public void proceed() {
+      synchronized (lock) {
+        this.proceed = true;
+        lock.notifyAll();
+      }
+    }
+
+    @Override public Response intercept(Chain chain) throws IOException {
+      Request request = chain.request();
+
+      // Double-check the URL filter to prevent redirects from hitting filtered URLs.
+      if (urlFilter != null) {
+        urlFilter.checkURLPermitted(request.url().url());
+      }
+
+      synchronized (lock) {
+        connectPending = false;
+        proxy = chain.connection().route().proxy();
+        handshake = chain.connection().handshake();
+        lock.notifyAll();
+
+        try {
+          while (!proceed) {
+            lock.wait(); // Wait until proceed() is called.
+          }
+        } catch (InterruptedException e) {
+          throw new InterruptedIOException();
+        }
+      }
+
+      // Try to lock in the Content-Length before transmitting the request body.
+      if (request.body() instanceof OutputStreamRequestBody) {
+        OutputStreamRequestBody requestBody = (OutputStreamRequestBody) request.body();
+        request = requestBody.prepareToSendRequest(request);
+      }
+
+      Response response = chain.proceed(request);
+
+      synchronized (lock) {
+        networkResponse = response;
+        url = response.request().url().url();
+      }
+
+      return response;
+    }
+  }
+}
diff --git a/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpsURLConnectionImpl.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/HttpsURLConnectionImpl.java
similarity index 74%
rename from okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpsURLConnectionImpl.java
rename to okhttp-urlconnection/src/main/java/okhttp3/internal/huc/HttpsURLConnectionImpl.java
index 2aba0872a8..8c1d69c0a7 100644
--- a/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpsURLConnectionImpl.java
+++ b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/HttpsURLConnectionImpl.java
@@ -14,13 +14,14 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.squareup.okhttp.internal.huc;
+package okhttp3.internal.huc;
 
-import com.squareup.okhttp.Handshake;
-import com.squareup.okhttp.OkHttpClient;
 import java.net.URL;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLSocketFactory;
+import okhttp3.Handshake;
+import okhttp3.OkHttpClient;
+import okhttp3.internal.URLFilter;
 
 public final class HttpsURLConnectionImpl extends DelegatingHttpsURLConnection {
   private final HttpURLConnectionImpl delegate;
@@ -29,38 +30,42 @@ public HttpsURLConnectionImpl(URL url, OkHttpClient client) {
     this(new HttpURLConnectionImpl(url, client));
   }
 
+  public HttpsURLConnectionImpl(URL url, OkHttpClient client, URLFilter filter) {
+    this(new HttpURLConnectionImpl(url, client, filter));
+  }
+
   public HttpsURLConnectionImpl(HttpURLConnectionImpl delegate) {
     super(delegate);
     this.delegate = delegate;
   }
 
   @Override protected Handshake handshake() {
-    if (delegate.httpEngine == null) {
+    if (delegate.call == null) {
       throw new IllegalStateException("Connection has not yet been established");
     }
 
-    // If there's a response, get the handshake from there so that caching
-    // works. Otherwise get the handshake from the connection because we might
-    // have not connected yet.
-    return delegate.httpEngine.hasResponse()
-        ? delegate.httpEngine.getResponse().handshake()
-        : delegate.handshake;
+    return delegate.handshake;
   }
 
   @Override public void setHostnameVerifier(HostnameVerifier hostnameVerifier) {
-    delegate.client.setHostnameVerifier(hostnameVerifier);
+    delegate.client = delegate.client.newBuilder()
+        .hostnameVerifier(hostnameVerifier)
+        .build();
   }
 
   @Override public HostnameVerifier getHostnameVerifier() {
-    return delegate.client.getHostnameVerifier();
+    return delegate.client.hostnameVerifier();
   }
 
   @Override public void setSSLSocketFactory(SSLSocketFactory sslSocketFactory) {
-    delegate.client.setSslSocketFactory(sslSocketFactory);
+    // This fails in JDK 9 because OkHttp is unable to extract the trust manager.
+    delegate.client = delegate.client.newBuilder()
+        .sslSocketFactory(sslSocketFactory)
+        .build();
   }
 
   @Override public SSLSocketFactory getSSLSocketFactory() {
-    return delegate.client.getSslSocketFactory();
+    return delegate.client.sslSocketFactory();
   }
 
   @Override public long getContentLengthLong() {
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OutputStreamRequestBody.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OutputStreamRequestBody.java
new file mode 100644
index 0000000000..602ca024bc
--- /dev/null
+++ b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OutputStreamRequestBody.java
@@ -0,0 +1,105 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.huc;
+
+import java.io.IOException;
+import java.io.OutputStream;
+import java.net.ProtocolException;
+import okhttp3.MediaType;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okio.BufferedSink;
+import okio.Timeout;
+
+/**
+ * A request body that's populated by blocking writes to an output stream. The output data is either
+ * fully buffered (with {@link BufferedRequestBody}) or streamed (with {@link StreamedRequestBody}).
+ * In either case the bytes of the body aren't known until the caller writes them to the output
+ * stream.
+ */
+public abstract class OutputStreamRequestBody extends RequestBody {
+  private Timeout timeout;
+  private long expectedContentLength;
+  private OutputStream outputStream;
+  boolean closed;
+
+  protected void initOutputStream(final BufferedSink sink, final long expectedContentLength) {
+    this.timeout = sink.timeout();
+    this.expectedContentLength = expectedContentLength;
+
+    // An output stream that writes to sink. If expectedContentLength is not -1, then this expects
+    // exactly that many bytes to be written.
+    this.outputStream = new OutputStream() {
+      private long bytesReceived;
+
+      @Override public void write(int b) throws IOException {
+        write(new byte[] {(byte) b}, 0, 1);
+      }
+
+      @Override public void write(byte[] source, int offset, int byteCount) throws IOException {
+        if (closed) throw new IOException("closed"); // Not IllegalStateException!
+
+        if (expectedContentLength != -1L && bytesReceived + byteCount > expectedContentLength) {
+          throw new ProtocolException("expected " + expectedContentLength
+              + " bytes but received " + bytesReceived + byteCount);
+        }
+
+        bytesReceived += byteCount;
+        sink.write(source, offset, byteCount);
+      }
+
+      @Override public void flush() throws IOException {
+        if (closed) return; // Weird, but consistent with historical behavior.
+        sink.flush();
+      }
+
+      @Override public void close() throws IOException {
+        closed = true;
+
+        if (expectedContentLength != -1L && bytesReceived < expectedContentLength) {
+          throw new ProtocolException("expected " + expectedContentLength
+              + " bytes but received " + bytesReceived);
+        }
+
+        sink.close();
+      }
+    };
+  }
+
+  public final OutputStream outputStream() {
+    return outputStream;
+  }
+
+  public final Timeout timeout() {
+    return timeout;
+  }
+
+  public final boolean isClosed() {
+    return closed;
+  }
+
+  @Override public long contentLength() throws IOException {
+    return expectedContentLength;
+  }
+
+  @Override public final MediaType contentType() {
+    return null; // Let the caller provide this in a regular header.
+  }
+
+  public Request prepareToSendRequest(Request request) throws IOException {
+    return request;
+  }
+}
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/StreamedRequestBody.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/StreamedRequestBody.java
new file mode 100644
index 0000000000..eb5a1c73de
--- /dev/null
+++ b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/StreamedRequestBody.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.huc;
+
+import java.io.IOException;
+import okhttp3.internal.http.UnrepeatableRequestBody;
+import okhttp3.internal.io.Pipe;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.Okio;
+
+/**
+ * This request body streams bytes from an application thread to an OkHttp dispatcher thread via a
+ * pipe. Because the data is not buffered it can only be transmitted once.
+ */
+final class StreamedRequestBody extends OutputStreamRequestBody implements UnrepeatableRequestBody {
+  private final Pipe pipe = new Pipe(8192);
+
+  StreamedRequestBody(long expectedContentLength) {
+    initOutputStream(Okio.buffer(pipe.sink), expectedContentLength);
+  }
+
+  @Override public void writeTo(BufferedSink sink) throws IOException {
+    Buffer buffer = new Buffer();
+    while (pipe.source.read(buffer, 8192) != -1L) {
+      sink.write(buffer, buffer.size());
+    }
+  }
+}
diff --git a/okhttp-urlconnection/src/test/java/com/squareup/okhttp/OkUrlFactoryTest.java b/okhttp-urlconnection/src/test/java/okhttp3/OkUrlFactoryTest.java
similarity index 53%
rename from okhttp-urlconnection/src/test/java/com/squareup/okhttp/OkUrlFactoryTest.java
rename to okhttp-urlconnection/src/test/java/okhttp3/OkUrlFactoryTest.java
index a7dc44b0d0..5eb0f7e0fc 100644
--- a/okhttp-urlconnection/src/test/java/com/squareup/okhttp/OkUrlFactoryTest.java
+++ b/okhttp-urlconnection/src/test/java/okhttp3/OkUrlFactoryTest.java
@@ -1,21 +1,27 @@
-package com.squareup.okhttp;
+package okhttp3;
 
-import com.squareup.okhttp.internal.Platform;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
+import java.io.File;
 import java.io.IOException;
 import java.net.HttpURLConnection;
+import java.net.URL;
 import java.text.DateFormat;
 import java.text.SimpleDateFormat;
 import java.util.Date;
 import java.util.Locale;
 import java.util.TimeZone;
 import java.util.concurrent.TimeUnit;
+import javax.net.ssl.HttpsURLConnection;
+import okhttp3.internal.URLFilter;
+import okhttp3.internal.http.OkHeaders;
+import okhttp3.internal.io.InMemoryFileSystem;
+import okhttp3.internal.tls.SslClient;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okio.BufferedSource;
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
-import org.junit.rules.TemporaryFolder;
 
 import static java.nio.charset.StandardCharsets.US_ASCII;
 import static okio.Okio.buffer;
@@ -24,28 +30,32 @@
 import static org.junit.Assert.fail;
 
 public class OkUrlFactoryTest {
-  @Rule public MockWebServerRule serverRule = new MockWebServerRule();
-  @Rule public TemporaryFolder cacheFolder = new TemporaryFolder();
+  @Rule public MockWebServer server = new MockWebServer();
+  @Rule public InMemoryFileSystem fileSystem = new InMemoryFileSystem();
 
-  private MockWebServer server;
   private OkUrlFactory factory;
+  private Cache cache;
 
   @Before public void setUp() throws IOException {
-    server = serverRule.get();
-
-    OkHttpClient client = new OkHttpClient();
-    client.setCache(new Cache(cacheFolder.getRoot(), 10 * 1024 * 1024));
+    cache = new Cache(new File("/cache/"), 10 * 1024 * 1024, fileSystem);
+    OkHttpClient client = new OkHttpClient.Builder()
+        .cache(cache)
+        .build();
     factory = new OkUrlFactory(client);
   }
 
+  @After public void tearDown() throws IOException {
+    cache.delete();
+  }
+
   /**
-   * Response code 407 should only come from proxy servers. Android's client
-   * throws if it is sent by an origin server.
+   * Response code 407 should only come from proxy servers. Android's client throws if it is sent by
+   * an origin server.
    */
   @Test public void originServerSends407() throws Exception {
     server.enqueue(new MockResponse().setResponseCode(407));
 
-    HttpURLConnection conn = factory.open(server.getUrl("/"));
+    HttpURLConnection conn = factory.open(server.url("/").url());
     try {
       conn.getResponseCode();
       fail();
@@ -56,7 +66,7 @@
   @Test public void networkResponseSourceHeader() throws Exception {
     server.enqueue(new MockResponse().setBody("Isla Sorna"));
 
-    HttpURLConnection connection = factory.open(server.getUrl("/"));
+    HttpURLConnection connection = factory.open(server.url("/").url());
     assertResponseHeader(connection, "NETWORK 200");
     assertResponseBody(connection, "Isla Sorna");
   }
@@ -64,8 +74,9 @@
   @Test public void networkFailureResponseSourceHeader() throws Exception {
     server.enqueue(new MockResponse().setResponseCode(404));
 
-    HttpURLConnection connection = factory.open(server.getUrl("/"));
+    HttpURLConnection connection = factory.open(server.url("/").url());
     assertResponseHeader(connection, "NETWORK 404");
+    connection.getErrorStream().close();
   }
 
   @Test public void conditionalCacheHitResponseSourceHeaders() throws Exception {
@@ -75,11 +86,11 @@
         .setBody("Isla Nublar"));
     server.enqueue(new MockResponse().setResponseCode(304));
 
-    HttpURLConnection connection1 = factory.open(server.getUrl("/"));
+    HttpURLConnection connection1 = factory.open(server.url("/").url());
     assertResponseHeader(connection1, "NETWORK 200");
     assertResponseBody(connection1, "Isla Nublar");
 
-    HttpURLConnection connection2 = factory.open(server.getUrl("/"));
+    HttpURLConnection connection2 = factory.open(server.url("/").url());
     assertResponseHeader(connection2, "CONDITIONAL_CACHE 304");
     assertResponseBody(connection2, "Isla Nublar");
   }
@@ -91,11 +102,11 @@
         .setBody("Isla Nublar"));
     server.enqueue(new MockResponse().setBody("Isla Sorna"));
 
-    HttpURLConnection connection1 = factory.open(server.getUrl("/"));
+    HttpURLConnection connection1 = factory.open(server.url("/").url());
     assertResponseHeader(connection1, "NETWORK 200");
     assertResponseBody(connection1, "Isla Nublar");
 
-    HttpURLConnection connection2 = factory.open(server.getUrl("/"));
+    HttpURLConnection connection2 = factory.open(server.url("/").url());
     assertResponseHeader(connection2, "CONDITIONAL_CACHE 200");
     assertResponseBody(connection2, "Isla Sorna");
   }
@@ -105,11 +116,11 @@
         .addHeader("Expires: " + formatDate(2, TimeUnit.HOURS))
         .setBody("Isla Nublar"));
 
-    HttpURLConnection connection1 = factory.open(server.getUrl("/"));
+    HttpURLConnection connection1 = factory.open(server.url("/").url());
     assertResponseHeader(connection1, "NETWORK 200");
     assertResponseBody(connection1, "Isla Nublar");
 
-    HttpURLConnection connection2 = factory.open(server.getUrl("/"));
+    HttpURLConnection connection2 = factory.open(server.url("/").url());
     assertResponseHeader(connection2, "CACHE 200");
     assertResponseBody(connection2, "Isla Nublar");
   }
@@ -117,11 +128,11 @@
   @Test public void noneResponseSourceHeaders() throws Exception {
     server.enqueue(new MockResponse().setBody("Isla Nublar"));
 
-    HttpURLConnection connection1 = factory.open(server.getUrl("/"));
+    HttpURLConnection connection1 = factory.open(server.url("/").url());
     assertResponseHeader(connection1, "NETWORK 200");
     assertResponseBody(connection1, "Isla Nublar");
 
-    HttpURLConnection connection2 = factory.open(server.getUrl("/"));
+    HttpURLConnection connection2 = factory.open(server.url("/").url());
     connection2.setRequestProperty("Cache-Control", "only-if-cached");
     assertResponseHeader(connection2, "NONE");
   }
@@ -135,20 +146,80 @@ public void setInstanceFollowRedirectsFalse() throws Exception {
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    HttpURLConnection connection = factory.open(server.getUrl("/a"));
+    HttpURLConnection connection = factory.open(server.url("/a").url());
     connection.setInstanceFollowRedirects(false);
     assertResponseBody(connection, "A");
     assertResponseCode(connection, 302);
   }
 
+  @Test
+  public void testURLFilter() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+    final URL blockedURL = server.url("/a").url();
+    factory.setUrlFilter(new URLFilter() {
+      @Override
+      public void checkURLPermitted(URL url) throws IOException {
+        if (blockedURL.equals(url)) {
+          throw new IOException("Blocked");
+        }
+      }
+    });
+    try {
+      HttpURLConnection connection = factory.open(server.url("/a").url());
+      connection.getInputStream();
+      fail("Connection was successful");
+    } catch (IOException e) {
+      assertEquals("Blocked", e.getMessage());
+    }
+    HttpURLConnection connection = factory.open(server.url("/b").url());
+    assertResponseBody(connection, "B");
+  }
+
+  @Test
+  public void testURLFilterRedirect() throws Exception {
+    MockWebServer cleartextServer = new MockWebServer();
+    cleartextServer.enqueue(new MockResponse()
+        .setBody("Blocked!"));
+    final URL blockedURL = cleartextServer.url("/").url();
+
+    SslClient contextBuilder = SslClient.localhost();
+    server.useHttps(contextBuilder.socketFactory, false);
+    factory.setClient(factory.client().newBuilder()
+        .sslSocketFactory(contextBuilder.socketFactory, contextBuilder.trustManager)
+        .followSslRedirects(true)
+        .build());
+    factory.setUrlFilter(new URLFilter() {
+      @Override
+      public void checkURLPermitted(URL url) throws IOException {
+        if (blockedURL.equals(url)) {
+          throw new IOException("Blocked");
+        }
+      }
+    });
+
+    server.enqueue(new MockResponse()
+        .setResponseCode(302)
+        .addHeader("Location: " + blockedURL)
+        .setBody("This page has moved"));
+    URL destination = server.url("/").url();
+    try {
+      HttpsURLConnection httpsConnection = (HttpsURLConnection) factory.open(destination);
+      httpsConnection.getInputStream();
+      fail("Connection was successful");
+    } catch (IOException expected) {
+    }
+  }
+
   private void assertResponseBody(HttpURLConnection connection, String expected) throws Exception {
-    String actual = buffer(source(connection.getInputStream())).readString(US_ASCII);
+    BufferedSource source = buffer(source(connection.getInputStream()));
+    String actual = source.readString(US_ASCII);
+    source.close();
     assertEquals(expected, actual);
   }
 
   private void assertResponseHeader(HttpURLConnection connection, String expected) {
-    final String headerFieldPrefix = Platform.get().getPrefix();
-    assertEquals(expected, connection.getHeaderField(headerFieldPrefix + "-Response-Source"));
+    assertEquals(expected, connection.getHeaderField(OkHeaders.RESPONSE_SOURCE));
   }
 
   private void assertResponseCode(HttpURLConnection connection, int expected) throws IOException {
diff --git a/okhttp-urlconnection/src/test/java/com/squareup/okhttp/UrlConnectionCacheTest.java b/okhttp-urlconnection/src/test/java/okhttp3/UrlConnectionCacheTest.java
similarity index 74%
rename from okhttp-urlconnection/src/test/java/com/squareup/okhttp/UrlConnectionCacheTest.java
rename to okhttp-urlconnection/src/test/java/okhttp3/UrlConnectionCacheTest.java
index db0ed8fa6c..1665ae325f 100644
--- a/okhttp-urlconnection/src/test/java/com/squareup/okhttp/UrlConnectionCacheTest.java
+++ b/okhttp-urlconnection/src/test/java/okhttp3/UrlConnectionCacheTest.java
@@ -14,29 +14,8 @@
  * limitations under the License.
  */
 
-package com.squareup.okhttp;
-
-import com.squareup.okhttp.internal.Internal;
-import com.squareup.okhttp.internal.SslContextBuilder;
-import com.squareup.okhttp.internal.Util;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-import com.squareup.okhttp.mockwebserver.RecordedRequest;
-import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.GzipSink;
-import okio.Okio;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.TemporaryFolder;
+package okhttp3;
 
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.HttpsURLConnection;
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLSession;
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileNotFoundException;
@@ -44,9 +23,7 @@
 import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.io.OutputStream;
-import java.net.CookieHandler;
 import java.net.CookieManager;
-import java.net.HttpCookie;
 import java.net.HttpURLConnection;
 import java.net.ResponseCache;
 import java.net.URL;
@@ -55,15 +32,32 @@
 import java.security.cert.Certificate;
 import java.text.DateFormat;
 import java.text.SimpleDateFormat;
-import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Date;
 import java.util.List;
 import java.util.Locale;
 import java.util.TimeZone;
 import java.util.concurrent.TimeUnit;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.HttpsURLConnection;
+import javax.net.ssl.SSLSession;
+import okhttp3.internal.Internal;
+import okhttp3.internal.Util;
+import okhttp3.internal.io.InMemoryFileSystem;
+import okhttp3.internal.tls.SslClient;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.GzipSink;
+import okio.Okio;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
 
-import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
@@ -71,6 +65,7 @@
 import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
+import static org.junit.Assume.assumeFalse;
 
 /** Test caching with {@link OkUrlFactory}. */
 public final class UrlConnectionCacheTest {
@@ -80,34 +75,31 @@
     }
   };
 
-  private static final SSLContext sslContext = SslContextBuilder.localhost();
-
-  @Rule public TemporaryFolder cacheRule = new TemporaryFolder();
-  @Rule public MockWebServerRule serverRule = new MockWebServerRule();
-  @Rule public MockWebServerRule server2Rule = new MockWebServerRule();
+  @Rule public MockWebServer server = new MockWebServer();
+  @Rule public MockWebServer server2 = new MockWebServer();
+  @Rule public InMemoryFileSystem fileSystem = new InMemoryFileSystem();
 
-  private final OkUrlFactory client = new OkUrlFactory(new OkHttpClient());
-  private MockWebServer server;
-  private MockWebServer server2;
+  private final SslClient sslClient = SslClient.localhost();
+  private OkUrlFactory urlFactory = new OkUrlFactory(new OkHttpClient());
   private Cache cache;
   private final CookieManager cookieManager = new CookieManager();
 
   @Before public void setUp() throws Exception {
-    server = serverRule.get();
     server.setProtocolNegotiationEnabled(false);
-    server2 = server2Rule.get();
-    cache = new Cache(cacheRule.getRoot(), Integer.MAX_VALUE);
-    client.client().setCache(cache);
-    CookieHandler.setDefault(cookieManager);
+    cache = new Cache(new File("/cache/"), Integer.MAX_VALUE, fileSystem);
+    urlFactory = new OkUrlFactory(new OkHttpClient.Builder()
+        .cache(cache)
+        .cookieJar(new JavaNetCookieJar(cookieManager))
+        .build());
   }
 
   @After public void tearDown() throws Exception {
     ResponseCache.setDefault(null);
-    CookieHandler.setDefault(null);
+    cache.delete();
   }
 
   @Test public void responseCacheAccessWithOkHttpMember() throws IOException {
-    assertSame(cache, client.client().getCache());
+    assertSame(cache, urlFactory.client().cache());
   }
 
   /**
@@ -115,60 +107,62 @@
    * http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.4
    */
   @Test public void responseCachingByResponseCode() throws Exception {
-      // Test each documented HTTP/1.1 code, plus the first unused value in each range.
-      // http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html
-
-      // We can't test 100 because it's not really a response.
-      // assertCached(false, 100);
-      assertCached(false, 101);
-      assertCached(false, 102);
-      assertCached(true,  200);
-      assertCached(false, 201);
-      assertCached(false, 202);
-      assertCached(true,  203);
-      assertCached(true,  204);
-      assertCached(false, 205);
-      assertCached(false, 206); //Electing to not cache partial responses
-      assertCached(false, 207);
-      assertCached(true,  300);
-      assertCached(true,  301);
-      assertCached(true,  302);
-      assertCached(false, 303);
-      assertCached(false, 304);
-      assertCached(false, 305);
-      assertCached(false, 306);
-      assertCached(true,  307);
-      assertCached(true,  308);
-      assertCached(false, 400);
-      assertCached(false, 401);
-      assertCached(false, 402);
-      assertCached(false, 403);
-      assertCached(true,  404);
-      assertCached(true,  405);
-      assertCached(false, 406);
-      assertCached(false, 408);
-      assertCached(false, 409);
-      // the HTTP spec permits caching 410s, but the RI doesn't.
-      assertCached(true,  410);
-      assertCached(false, 411);
-      assertCached(false, 412);
-      assertCached(false, 413);
-      assertCached(true,  414);
-      assertCached(false, 415);
-      assertCached(false, 416);
-      assertCached(false, 417);
-      assertCached(false, 418);
-
-      assertCached(false, 500);
-      assertCached(true,  501);
-      assertCached(false, 502);
-      assertCached(false, 503);
-      assertCached(false, 504);
-      assertCached(false, 505);
-      assertCached(false, 506);
+    // Test each documented HTTP/1.1 code, plus the first unused value in each range.
+    // http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html
+
+    // We can't test 100 because it's not really a response.
+    // assertCached(false, 100);
+    assertCached(false, 101);
+    assertCached(false, 102);
+    assertCached(true, 200);
+    assertCached(false, 201);
+    assertCached(false, 202);
+    assertCached(true, 203);
+    assertCached(true, 204);
+    assertCached(false, 205);
+    assertCached(false, 206); //Electing to not cache partial responses
+    assertCached(false, 207);
+    assertCached(true, 300);
+    assertCached(true, 301);
+    assertCached(true, 302);
+    assertCached(false, 303);
+    assertCached(false, 304);
+    assertCached(false, 305);
+    assertCached(false, 306);
+    assertCached(true, 307);
+    assertCached(true, 308);
+    assertCached(false, 400);
+    assertCached(false, 401);
+    assertCached(false, 402);
+    assertCached(false, 403);
+    assertCached(true, 404);
+    assertCached(true, 405);
+    assertCached(false, 406);
+    assertCached(false, 408);
+    assertCached(false, 409);
+    // the HTTP spec permits caching 410s, but the RI doesn't.
+    assertCached(true, 410);
+    assertCached(false, 411);
+    assertCached(false, 412);
+    assertCached(false, 413);
+    assertCached(true, 414);
+    assertCached(false, 415);
+    assertCached(false, 416);
+    assertCached(false, 417);
+    assertCached(false, 418);
+
+    assertCached(false, 500);
+    assertCached(true, 501);
+    assertCached(false, 502);
+    assertCached(false, 503);
+    assertCached(false, 504);
+    assertCached(false, 505);
+    assertCached(false, 506);
   }
 
   private void assertCached(boolean shouldPut, int responseCode) throws Exception {
+    int expectedResponseCode = responseCode;
+
     server = new MockWebServer();
     MockResponse response = new MockResponse()
         .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
@@ -180,13 +174,27 @@ private void assertCached(boolean shouldPut, int responseCode) throws Exception
       response.addHeader("Proxy-Authenticate: Basic realm=\"protected area\"");
     } else if (responseCode == HttpURLConnection.HTTP_UNAUTHORIZED) {
       response.addHeader("WWW-Authenticate: Basic realm=\"protected area\"");
+    } else if (responseCode == HttpURLConnection.HTTP_NO_CONTENT
+        || responseCode == HttpURLConnection.HTTP_RESET) {
+      response.setBody(""); // We forbid bodies for 204 and 205.
     }
     server.enqueue(response);
+
+    if (responseCode == HttpURLConnection.HTTP_CLIENT_TIMEOUT) {
+      // 408's are a bit of an outlier because we may repeat the request if we encounter this
+      // response code. In this scenario, there are 2 responses: the initial 408 and then the 200
+      // because of the retry. We just want to ensure the initial 408 isn't cached.
+      expectedResponseCode = 200;
+      server.enqueue(new MockResponse()
+          .addHeader("Cache-Control", "no-store")
+          .setBody("FGHIJ"));
+    }
+
     server.start();
 
-    URL url = server.getUrl("/");
-    HttpURLConnection conn = client.open(url);
-    assertEquals(responseCode, conn.getResponseCode());
+    URL url = server.url("/").url();
+    HttpURLConnection conn = urlFactory.open(url);
+    assertEquals(expectedResponseCode, conn.getResponseCode());
 
     // exhaust the content stream
     readAscii(conn);
@@ -226,17 +234,17 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     server.enqueue(response);
 
     // Make sure that calling skip() doesn't omit bytes from the cache.
-    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
+    HttpURLConnection urlConnection = urlFactory.open(server.url("/").url());
     InputStream in = urlConnection.getInputStream();
     assertEquals("I love ", readAscii(urlConnection, "I love ".length()));
     reliableSkip(in, "puppies but hate ".length());
     assertEquals("spiders", readAscii(urlConnection, "spiders".length()));
     assertEquals(-1, in.read());
     in.close();
-    assertEquals(1, cache.getWriteSuccessCount());
-    assertEquals(0, cache.getWriteAbortCount());
+    assertEquals(1, cache.writeSuccessCount());
+    assertEquals(0, cache.writeAbortCount());
 
-    urlConnection = client.open(server.getUrl("/")); // cached!
+    urlConnection = urlFactory.open(server.url("/").url()); // cached!
     in = urlConnection.getInputStream();
     assertEquals("I love puppies but hate spiders",
         readAscii(urlConnection, "I love puppies but hate spiders".length()));
@@ -245,20 +253,22 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
 
     assertEquals(-1, in.read());
     in.close();
-    assertEquals(1, cache.getWriteSuccessCount());
-    assertEquals(0, cache.getWriteAbortCount());
-    assertEquals(2, cache.getRequestCount());
-    assertEquals(1, cache.getHitCount());
+    assertEquals(1, cache.writeSuccessCount());
+    assertEquals(0, cache.writeAbortCount());
+    assertEquals(2, cache.requestCount());
+    assertEquals(1, cache.hitCount());
   }
 
   @Test public void secureResponseCaching() throws IOException {
-    server.useHttps(sslContext.getSocketFactory(), false);
+    assumeFalse(getPlatform().equals("jdk9"));
+
+    server.useHttps(sslClient.socketFactory, false);
     server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .setBody("ABC"));
 
-    HttpsURLConnection c1 = (HttpsURLConnection) client.open(server.getUrl("/"));
-    c1.setSSLSocketFactory(sslContext.getSocketFactory());
+    HttpsURLConnection c1 = (HttpsURLConnection) urlFactory.open(server.url("/").url());
+    c1.setSSLSocketFactory(sslClient.socketFactory);
     c1.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
     assertEquals("ABC", readAscii(c1));
 
@@ -269,14 +279,14 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     Principal peerPrincipal = c1.getPeerPrincipal();
     Principal localPrincipal = c1.getLocalPrincipal();
 
-    HttpsURLConnection c2 = (HttpsURLConnection) client.open(server.getUrl("/")); // cached!
-    c2.setSSLSocketFactory(sslContext.getSocketFactory());
+    HttpsURLConnection c2 = (HttpsURLConnection) urlFactory.open(server.url("/").url()); // cached!
+    c2.setSSLSocketFactory(sslClient.socketFactory);
     c2.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
     assertEquals("ABC", readAscii(c2));
 
-    assertEquals(2, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(1, cache.getHitCount());
+    assertEquals(2, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(1, cache.hitCount());
 
     assertEquals(suite, c2.getCipherSuite());
     assertEquals(localCerts, toListOrNull(c2.getLocalCertificates()));
@@ -295,15 +305,15 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
         .setBody("ABC"));
     server.enqueue(new MockResponse().setBody("DEF"));
 
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    HttpURLConnection connection = urlFactory.open(server.url("/").url());
     assertEquals("ABC", readAscii(connection));
 
-    connection = client.open(server.getUrl("/")); // cached!
+    connection = urlFactory.open(server.url("/").url()); // cached!
     assertEquals("ABC", readAscii(connection));
 
-    assertEquals(4, cache.getRequestCount()); // 2 requests + 2 redirects
-    assertEquals(2, cache.getNetworkCount());
-    assertEquals(2, cache.getHitCount());
+    assertEquals(4, cache.requestCount()); // 2 requests + 2 redirects
+    assertEquals(2, cache.networkCount());
+    assertEquals(2, cache.hitCount());
   }
 
   @Test public void redirectToCachedResult() throws Exception {
@@ -312,25 +322,25 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
         .addHeader("Location: /foo"));
     server.enqueue(new MockResponse().setBody("DEF"));
 
-    assertEquals("ABC", readAscii(client.open(server.getUrl("/foo"))));
+    assertEquals("ABC", readAscii(urlFactory.open(server.url("/foo").url())));
     RecordedRequest request1 = server.takeRequest();
     assertEquals("GET /foo HTTP/1.1", request1.getRequestLine());
     assertEquals(0, request1.getSequenceNumber());
 
-    assertEquals("ABC", readAscii(client.open(server.getUrl("/bar"))));
+    assertEquals("ABC", readAscii(urlFactory.open(server.url("/bar").url())));
     RecordedRequest request2 = server.takeRequest();
     assertEquals("GET /bar HTTP/1.1", request2.getRequestLine());
     assertEquals(1, request2.getSequenceNumber());
 
     // an unrelated request should reuse the pooled connection
-    assertEquals("DEF", readAscii(client.open(server.getUrl("/baz"))));
+    assertEquals("DEF", readAscii(urlFactory.open(server.url("/baz").url())));
     RecordedRequest request3 = server.takeRequest();
     assertEquals("GET /baz HTTP/1.1", request3.getRequestLine());
     assertEquals(2, request3.getSequenceNumber());
   }
 
   @Test public void secureResponseCachingAndRedirects() throws IOException {
-    server.useHttps(sslContext.getSocketFactory(), false);
+    server.useHttps(sslClient.socketFactory, false);
     server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
@@ -340,33 +350,34 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
         .setBody("ABC"));
     server.enqueue(new MockResponse().setBody("DEF"));
 
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
+        .build());
 
-    HttpsURLConnection connection1 = (HttpsURLConnection) client.open(server.getUrl("/"));
+    HttpsURLConnection connection1 = (HttpsURLConnection) urlFactory.open(server.url("/").url());
     assertEquals("ABC", readAscii(connection1));
     assertNotNull(connection1.getCipherSuite());
 
     // Cached!
-    HttpsURLConnection connection2 = (HttpsURLConnection) client.open(server.getUrl("/"));
+    HttpsURLConnection connection2 = (HttpsURLConnection) urlFactory.open(server.url("/").url());
     assertEquals("ABC", readAscii(connection2));
     assertNotNull(connection2.getCipherSuite());
 
-    assertEquals(4, cache.getRequestCount()); // 2 direct + 2 redirect = 4
-    assertEquals(2, cache.getHitCount());
+    assertEquals(4, cache.requestCount()); // 2 direct + 2 redirect = 4
+    assertEquals(2, cache.hitCount());
     assertEquals(connection1.getCipherSuite(), connection2.getCipherSuite());
   }
 
   /**
-   * We've had bugs where caching and cross-protocol redirects yield class
-   * cast exceptions internal to the cache because we incorrectly assumed that
-   * HttpsURLConnection was always HTTPS and HttpURLConnection was always HTTP;
-   * in practice redirects mean that each can do either.
+   * We've had bugs where caching and cross-protocol redirects yield class cast exceptions internal
+   * to the cache because we incorrectly assumed that HttpsURLConnection was always HTTPS and
+   * HttpURLConnection was always HTTP; in practice redirects mean that each can do either.
    *
    * https://github.com/square/okhttp/issues/214
    */
   @Test public void secureResponseCachingAndProtocolRedirects() throws IOException {
-    server2.useHttps(sslContext.getSocketFactory(), false);
+    server2.useHttps(sslClient.socketFactory, false);
     server2.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .setBody("ABC"));
@@ -375,20 +386,22 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
-        .addHeader("Location: " + server2.getUrl("/")));
+        .addHeader("Location: " + server2.url("/").url()));
 
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
+        .build());
 
-    HttpURLConnection connection1 = client.open(server.getUrl("/"));
+    HttpURLConnection connection1 = urlFactory.open(server.url("/").url());
     assertEquals("ABC", readAscii(connection1));
 
     // Cached!
-    HttpURLConnection connection2 = client.open(server.getUrl("/"));
+    HttpURLConnection connection2 = urlFactory.open(server.url("/").url());
     assertEquals("ABC", readAscii(connection2));
 
-    assertEquals(4, cache.getRequestCount()); // 2 direct + 2 redirect = 4
-    assertEquals(2, cache.getHitCount());
+    assertEquals(4, cache.requestCount()); // 2 direct + 2 redirect = 4
+    assertEquals(2, cache.hitCount());
   }
 
   @Test public void serverDisconnectsPrematurelyWithContentLengthHeader() throws IOException {
@@ -412,7 +425,7 @@ private void testServerPrematureDisconnect(TransferKind transferKind) throws IOE
     server.enqueue(new MockResponse().setBody("Request #2"));
 
     BufferedReader reader = new BufferedReader(
-        new InputStreamReader(client.open(server.getUrl("/")).getInputStream()));
+        new InputStreamReader(urlFactory.open(server.url("/").url()).getInputStream()));
     assertEquals("ABCDE", reader.readLine());
     try {
       reader.readLine();
@@ -422,12 +435,12 @@ private void testServerPrematureDisconnect(TransferKind transferKind) throws IOE
       reader.close();
     }
 
-    assertEquals(1, cache.getWriteAbortCount());
-    assertEquals(0, cache.getWriteSuccessCount());
-    URLConnection connection = client.open(server.getUrl("/"));
+    assertEquals(1, cache.writeAbortCount());
+    assertEquals(0, cache.writeSuccessCount());
+    URLConnection connection = urlFactory.open(server.url("/").url());
     assertEquals("Request #2", readAscii(connection));
-    assertEquals(1, cache.getWriteAbortCount());
-    assertEquals(1, cache.getWriteSuccessCount());
+    assertEquals(1, cache.writeAbortCount());
+    assertEquals(1, cache.writeSuccessCount());
   }
 
   @Test public void clientPrematureDisconnectWithContentLengthHeader() throws IOException {
@@ -449,7 +462,7 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
     server.enqueue(response);
     server.enqueue(new MockResponse().setBody("Request #2"));
 
-    URLConnection connection = client.open(server.getUrl("/"));
+    URLConnection connection = urlFactory.open(server.url("/").url());
     InputStream in = connection.getInputStream();
     assertEquals("ABCDE", readAscii(connection, 5));
     in.close();
@@ -459,12 +472,12 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
     } catch (IOException expected) {
     }
 
-    assertEquals(1, cache.getWriteAbortCount());
-    assertEquals(0, cache.getWriteSuccessCount());
-    connection = client.open(server.getUrl("/"));
+    assertEquals(1, cache.writeAbortCount());
+    assertEquals(0, cache.writeSuccessCount());
+    connection = urlFactory.open(server.url("/").url());
     assertEquals("Request #2", readAscii(connection));
-    assertEquals(1, cache.getWriteAbortCount());
-    assertEquals(1, cache.getWriteSuccessCount());
+    assertEquals(1, cache.writeAbortCount());
+    assertEquals(1, cache.writeSuccessCount());
   }
 
   @Test public void defaultExpirationDateFullyCachedForLessThan24Hours() throws Exception {
@@ -477,9 +490,9 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
             .addHeader("Date: " + formatDate(-5, TimeUnit.SECONDS))
             .setBody("A"));
 
-    URL url = server.getUrl("/");
-    assertEquals("A", readAscii(client.open(url)));
-    URLConnection connection = client.open(url);
+    URL url = server.url("/").url();
+    assertEquals("A", readAscii(urlFactory.open(url)));
+    URLConnection connection = urlFactory.open(url);
     assertEquals("A", readAscii(connection));
     assertNull(connection.getHeaderField("Warning"));
   }
@@ -505,8 +518,8 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
         .addHeader("Date: " + formatDate(-5, TimeUnit.DAYS))
         .setBody("A"));
 
-    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
-    URLConnection connection = client.open(server.getUrl("/"));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    URLConnection connection = urlFactory.open(server.url("/").url());
     assertEquals("A", readAscii(connection));
     assertEquals("113 HttpURLConnection \"Heuristic expiration\"",
         connection.getHeaderField("Warning"));
@@ -519,9 +532,9 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
             .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
 
-    URL url = server.getUrl("/?foo=bar");
-    assertEquals("A", readAscii(client.open(url)));
-    assertEquals("B", readAscii(client.open(url)));
+    URL url = server.url("/?foo=bar").url();
+    assertEquals("A", readAscii(urlFactory.open(url)));
+    assertEquals("B", readAscii(urlFactory.open(url)));
   }
 
   @Test public void expirationDateInThePastWithLastModifiedHeader() throws Exception {
@@ -633,15 +646,15 @@ private void testRequestMethod(String requestMethod, boolean expectCached) throw
         .addHeader("X-Response-ID: 1"));
     server.enqueue(new MockResponse().addHeader("X-Response-ID: 2"));
 
-    URL url = server.getUrl("/");
+    URL url = server.url("/").url();
 
-    HttpURLConnection request1 = client.open(url);
+    HttpURLConnection request1 = urlFactory.open(url);
     request1.setRequestMethod(requestMethod);
     addRequestBodyIfNecessary(requestMethod, request1);
     request1.getInputStream().close();
     assertEquals("1", request1.getHeaderField("X-Response-ID"));
 
-    URLConnection request2 = client.open(url);
+    URLConnection request2 = urlFactory.open(url);
     request2.getInputStream().close();
     if (expectCached) {
       assertEquals("1", request2.getHeaderField("X-Response-ID"));
@@ -671,16 +684,16 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
     server.enqueue(new MockResponse().setBody("B"));
     server.enqueue(new MockResponse().setBody("C"));
 
-    URL url = server.getUrl("/");
+    URL url = server.url("/").url();
 
-    assertEquals("A", readAscii(client.open(url)));
+    assertEquals("A", readAscii(urlFactory.open(url)));
 
-    HttpURLConnection invalidate = client.open(url);
+    HttpURLConnection invalidate = urlFactory.open(url);
     invalidate.setRequestMethod(requestMethod);
     addRequestBodyIfNecessary(requestMethod, invalidate);
     assertEquals("B", readAscii(invalidate));
 
-    assertEquals("C", readAscii(client.open(url)));
+    assertEquals("C", readAscii(urlFactory.open(url)));
   }
 
   @Test public void postInvalidatesCacheWithUncacheableResponse() throws Exception {
@@ -692,16 +705,16 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
     server.enqueue(new MockResponse().setBody("B").setResponseCode(500));
     server.enqueue(new MockResponse().setBody("C"));
 
-    URL url = server.getUrl("/");
+    URL url = server.url("/").url();
 
-    assertEquals("A", readAscii(client.open(url)));
+    assertEquals("A", readAscii(urlFactory.open(url)));
 
-    HttpURLConnection invalidate = client.open(url);
+    HttpURLConnection invalidate = urlFactory.open(url);
     invalidate.setRequestMethod("POST");
     addRequestBodyIfNecessary("POST", invalidate);
     assertEquals("B", readAscii(invalidate));
 
-    assertEquals("C", readAscii(client.open(url)));
+    assertEquals("C", readAscii(urlFactory.open(url)));
   }
 
   @Test public void etag() throws Exception {
@@ -771,13 +784,13 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
         .addHeader("Content-Range: bytes 1000-1001/2000"));
     server.enqueue(new MockResponse().setBody("BB"));
 
-    URL url = server.getUrl("/");
+    URL url = server.url("/").url();
 
-    URLConnection range = client.open(url);
+    URLConnection range = urlFactory.open(url);
     range.addRequestProperty("Range", "bytes=1000-1001");
     assertEquals("AA", readAscii(range));
 
-    assertEquals("BB", readAscii(client.open(url)));
+    assertEquals("BB", readAscii(urlFactory.open(url)));
   }
 
   @Test public void serverReturnsDocumentOlderThanCache() throws Exception {
@@ -787,10 +800,10 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
     server.enqueue(new MockResponse().setBody("B")
         .addHeader("Last-Modified: " + formatDate(-4, TimeUnit.HOURS)));
 
-    URL url = server.getUrl("/");
+    URL url = server.url("/").url();
 
-    assertEquals("A", readAscii(client.open(url)));
-    assertEquals("A", readAscii(client.open(url)));
+    assertEquals("A", readAscii(urlFactory.open(url)));
+    assertEquals("A", readAscii(urlFactory.open(url)));
   }
 
   @Test public void nonIdentityEncodingAndConditionalCache() throws Exception {
@@ -814,9 +827,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     // At least three request/response pairs are required because after the first request is cached
     // a different execution path might be taken. Thus modifications to the cache applied during
     // the second request might not be visible until another request is performed.
-    assertEquals("ABCABCABC", readAscii(client.open(server.getUrl("/"))));
-    assertEquals("ABCABCABC", readAscii(client.open(server.getUrl("/"))));
-    assertEquals("ABCABCABC", readAscii(client.open(server.getUrl("/"))));
+    assertEquals("ABCABCABC", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals("ABCABCABC", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals("ABCABCABC", readAscii(urlFactory.open(server.url("/").url())));
   }
 
   @Test public void notModifiedSpecifiesEncoding() throws Exception {
@@ -831,9 +844,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     server.enqueue(new MockResponse()
         .setBody("DEFDEFDEF"));
 
-    assertEquals("ABCABCABC", readAscii(client.open(server.getUrl("/"))));
-    assertEquals("ABCABCABC", readAscii(client.open(server.getUrl("/"))));
-    assertEquals("DEFDEFDEF", readAscii(client.open(server.getUrl("/"))));
+    assertEquals("ABCABCABC", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals("ABCABCABC", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals("DEFDEFDEF", readAscii(urlFactory.open(server.url("/").url())));
   }
 
   /** https://github.com/square/okhttp/issues/947 */
@@ -845,8 +858,8 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .addHeader("Cache-Control: max-age=60"));
     server.enqueue(new MockResponse().setBody("FAIL"));
 
-    assertEquals("ABCABCABC", readAscii(client.open(server.getUrl("/"))));
-    assertEquals("ABCABCABC", readAscii(client.open(server.getUrl("/"))));
+    assertEquals("ABCABCABC", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals("ABCABCABC", readAscii(urlFactory.open(server.url("/").url())));
   }
 
   @Test public void conditionalCacheHitIsNotDoublePooled() throws Exception {
@@ -855,13 +868,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .clearHeaders()
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    ConnectionPool pool = ConnectionPool.getDefault();
-    pool.evictAll();
-    client.client().setConnectionPool(pool);
-
-    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
-    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
-    assertEquals(1, client.client().getConnectionPool().getConnectionCount());
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals(1, urlFactory.client().connectionPool().idleConnectionCount());
   }
 
   @Test public void expiresDateBeforeModifiedDate() throws Exception {
@@ -877,9 +886,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
     server.enqueue(new MockResponse().setBody("B"));
 
-    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
 
-    URLConnection connection = client.open(server.getUrl("/"));
+    URLConnection connection = urlFactory.open(server.url("/").url());
     connection.addRequestProperty("Cache-Control", "max-age=30");
     assertEquals("B", readAscii(connection));
   }
@@ -890,9 +899,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
     server.enqueue(new MockResponse().setBody("B"));
 
-    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
 
-    URLConnection connection = client.open(server.getUrl("/"));
+    URLConnection connection = urlFactory.open(server.url("/").url());
     connection.addRequestProperty("Cache-Control", "min-fresh=120");
     assertEquals("B", readAscii(connection));
   }
@@ -903,9 +912,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .addHeader("Date: " + formatDate(-4, TimeUnit.MINUTES)));
     server.enqueue(new MockResponse().setBody("B"));
 
-    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
 
-    URLConnection connection = client.open(server.getUrl("/"));
+    URLConnection connection = urlFactory.open(server.url("/").url());
     connection.addRequestProperty("Cache-Control", "max-stale=180");
     assertEquals("A", readAscii(connection));
     assertEquals("110 HttpURLConnection \"Response is stale\"",
@@ -918,9 +927,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .addHeader("Date: " + formatDate(-4, TimeUnit.MINUTES)));
     server.enqueue(new MockResponse().setBody("B"));
 
-    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
 
-    URLConnection connection = client.open(server.getUrl("/"));
+    URLConnection connection = urlFactory.open(server.url("/").url());
     connection.addRequestProperty("Cache-Control", "max-stale=180");
     assertEquals("B", readAscii(connection));
   }
@@ -928,12 +937,12 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
   @Test public void requestOnlyIfCachedWithNoResponseCached() throws IOException {
     // (no responses enqueued)
 
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    HttpURLConnection connection = urlFactory.open(server.url("/").url());
     connection.addRequestProperty("Cache-Control", "only-if-cached");
     assertGatewayTimeout(connection);
-    assertEquals(1, cache.getRequestCount());
-    assertEquals(0, cache.getNetworkCount());
-    assertEquals(0, cache.getHitCount());
+    assertEquals(1, cache.requestCount());
+    assertEquals(0, cache.networkCount());
+    assertEquals(0, cache.hitCount());
   }
 
   @Test public void requestOnlyIfCachedWithFullResponseCached() throws IOException {
@@ -941,13 +950,13 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .addHeader("Cache-Control: max-age=30")
         .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
 
-    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
-    URLConnection connection = client.open(server.getUrl("/"));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    URLConnection connection = urlFactory.open(server.url("/").url());
     connection.addRequestProperty("Cache-Control", "only-if-cached");
     assertEquals("A", readAscii(connection));
-    assertEquals(2, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(1, cache.getHitCount());
+    assertEquals(2, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(1, cache.hitCount());
   }
 
   @Test public void requestOnlyIfCachedWithConditionalResponseCached() throws IOException {
@@ -955,25 +964,25 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .addHeader("Cache-Control: max-age=30")
         .addHeader("Date: " + formatDate(-1, TimeUnit.MINUTES)));
 
-    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    HttpURLConnection connection = urlFactory.open(server.url("/").url());
     connection.addRequestProperty("Cache-Control", "only-if-cached");
     assertGatewayTimeout(connection);
-    assertEquals(2, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(0, cache.getHitCount());
+    assertEquals(2, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(0, cache.hitCount());
   }
 
   @Test public void requestOnlyIfCachedWithUnhelpfulResponseCached() throws IOException {
     server.enqueue(new MockResponse().setBody("A"));
 
-    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    HttpURLConnection connection = urlFactory.open(server.url("/").url());
     connection.addRequestProperty("Cache-Control", "only-if-cached");
     assertGatewayTimeout(connection);
-    assertEquals(2, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(0, cache.getHitCount());
+    assertEquals(2, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(0, cache.hitCount());
   }
 
   @Test public void requestCacheControlNoCache() throws Exception {
@@ -984,9 +993,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
             .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
 
-    URL url = server.getUrl("/");
-    assertEquals("A", readAscii(client.open(url)));
-    URLConnection connection = client.open(url);
+    URL url = server.url("/").url();
+    assertEquals("A", readAscii(urlFactory.open(url)));
+    URLConnection connection = urlFactory.open(url);
     connection.setRequestProperty("Cache-Control", "no-cache");
     assertEquals("B", readAscii(connection));
   }
@@ -999,9 +1008,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
             .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
 
-    URL url = server.getUrl("/");
-    assertEquals("A", readAscii(client.open(url)));
-    URLConnection connection = client.open(url);
+    URL url = server.url("/").url();
+    assertEquals("A", readAscii(urlFactory.open(url)));
+    URLConnection connection = urlFactory.open(url);
     connection.setRequestProperty("Pragma", "no-cache");
     assertEquals("B", readAscii(connection));
   }
@@ -1031,10 +1040,10 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(seed.setBody("A"));
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    URL url = server.getUrl("/");
-    assertEquals("A", readAscii(client.open(url)));
+    URL url = server.url("/").url();
+    assertEquals("A", readAscii(urlFactory.open(url)));
 
-    HttpURLConnection connection = client.open(url);
+    HttpURLConnection connection = urlFactory.open(url);
     connection.addRequestProperty(conditionName, conditionValue);
     assertEquals(HttpURLConnection.HTTP_NOT_MODIFIED, connection.getResponseCode());
     assertEquals("", readAscii(connection));
@@ -1044,16 +1053,16 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
   }
 
   /**
-   * Confirm that {@link URLConnection#setIfModifiedSince} causes an
-   * If-Modified-Since header with a GMT timestamp.
+   * Confirm that {@link URLConnection#setIfModifiedSince} causes an If-Modified-Since header with a
+   * GMT timestamp.
    *
    * https://code.google.com/p/android/issues/detail?id=66135
    */
   @Test public void setIfModifiedSince() throws Exception {
     server.enqueue(new MockResponse().setBody("A"));
 
-    URL url = server.getUrl("/");
-    URLConnection connection = client.open(url);
+    URL url = server.url("/").url();
+    URLConnection connection = urlFactory.open(url);
     connection.setIfModifiedSince(1393666200000L);
     assertEquals("A", readAscii(connection));
     RecordedRequest request = server.takeRequest();
@@ -1062,8 +1071,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
   }
 
   /**
-   * For Last-Modified and Date headers, we should echo the date back in the
-   * exact format we were served.
+   * For Last-Modified and Date headers, we should echo the date back in the exact format we were
+   * served.
    */
   @Test public void retainServedDateFormat() throws Exception {
     // Serve a response with a non-standard date format that OkHttp supports.
@@ -1082,8 +1091,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
-    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
 
     // The first request has no conditions.
     RecordedRequest request1 = server.takeRequest();
@@ -1097,7 +1106,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
   @Test public void clientSuppliedConditionWithoutCachedResult() throws Exception {
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    HttpURLConnection connection = urlFactory.open(server.url("/").url());
     String clientIfModifiedSince = formatDate(-24, TimeUnit.HOURS);
     connection.addRequestProperty("If-Modified-Since", clientIfModifiedSince);
     assertEquals(HttpURLConnection.HTTP_NOT_MODIFIED, connection.getResponseCode());
@@ -1108,11 +1117,11 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60").setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
 
-    URL url = server.getUrl("/");
-    URLConnection connection = client.open(url);
+    URL url = server.url("/").url();
+    URLConnection connection = urlFactory.open(url);
     connection.addRequestProperty("Authorization", "password");
     assertEquals("A", readAscii(connection));
-    assertEquals("A", readAscii(client.open(url)));
+    assertEquals("A", readAscii(urlFactory.open(url)));
   }
 
   @Test public void contentLocationDoesNotPopulateCache() throws Exception {
@@ -1121,8 +1130,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
 
-    assertEquals("A", readAscii(client.open(server.getUrl("/foo"))));
-    assertEquals("B", readAscii(client.open(server.getUrl("/bar"))));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/foo").url())));
+    assertEquals("B", readAscii(urlFactory.open(server.url("/bar").url())));
   }
 
   @Test public void useCachesFalseDoesNotWriteToCache() throws Exception {
@@ -1130,10 +1139,10 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         new MockResponse().addHeader("Cache-Control: max-age=60").setBody("A").setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
 
-    URLConnection connection = client.open(server.getUrl("/"));
+    URLConnection connection = urlFactory.open(server.url("/").url());
     connection.setUseCaches(false);
     assertEquals("A", readAscii(connection));
-    assertEquals("B", readAscii(client.open(server.getUrl("/"))));
+    assertEquals("B", readAscii(urlFactory.open(server.url("/").url())));
   }
 
   @Test public void useCachesFalseDoesNotReadFromCache() throws Exception {
@@ -1141,22 +1150,22 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         new MockResponse().addHeader("Cache-Control: max-age=60").setBody("A").setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
 
-    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
-    URLConnection connection = client.open(server.getUrl("/"));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    URLConnection connection = urlFactory.open(server.url("/").url());
     connection.setUseCaches(false);
     assertEquals("B", readAscii(connection));
   }
 
   @Test public void defaultUseCachesSetsInitialValueOnly() throws Exception {
     URL url = new URL("http://localhost/");
-    URLConnection c1 = client.open(url);
-    URLConnection c2 = client.open(url);
+    URLConnection c1 = urlFactory.open(url);
+    URLConnection c2 = urlFactory.open(url);
     assertTrue(c1.getDefaultUseCaches());
     c1.setDefaultUseCaches(false);
     try {
       assertTrue(c1.getUseCaches());
       assertTrue(c2.getUseCaches());
-      URLConnection c3 = client.open(url);
+      URLConnection c3 = urlFactory.open(url);
       assertFalse(c3.getUseCaches());
     } finally {
       c1.setDefaultUseCaches(true);
@@ -1170,9 +1179,9 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
     server.enqueue(new MockResponse().setBody("B"));
 
-    assertEquals("A", readAscii(client.open(server.getUrl("/a"))));
-    assertEquals("A", readAscii(client.open(server.getUrl("/a"))));
-    assertEquals("B", readAscii(client.open(server.getUrl("/b"))));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/a").url())));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/a").url())));
+    assertEquals("B", readAscii(urlFactory.open(server.url("/b").url())));
 
     assertEquals(0, server.takeRequest().getSequenceNumber());
     assertEquals(1, server.takeRequest().getSequenceNumber());
@@ -1186,15 +1195,15 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse().setBody("B"));
     server.enqueue(new MockResponse().setBody("C"));
 
-    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
-    assertEquals(1, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(0, cache.getHitCount());
-    assertEquals("B", readAscii(client.open(server.getUrl("/"))));
-    assertEquals("C", readAscii(client.open(server.getUrl("/"))));
-    assertEquals(3, cache.getRequestCount());
-    assertEquals(3, cache.getNetworkCount());
-    assertEquals(0, cache.getHitCount());
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals(1, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(0, cache.hitCount());
+    assertEquals("B", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals("C", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals(3, cache.requestCount());
+    assertEquals(3, cache.networkCount());
+    assertEquals(0, cache.hitCount());
   }
 
   @Test public void statisticsConditionalCacheHit() throws Exception {
@@ -1204,29 +1213,29 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
-    assertEquals(1, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(0, cache.getHitCount());
-    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
-    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
-    assertEquals(3, cache.getRequestCount());
-    assertEquals(3, cache.getNetworkCount());
-    assertEquals(2, cache.getHitCount());
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals(1, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(0, cache.hitCount());
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals(3, cache.requestCount());
+    assertEquals(3, cache.networkCount());
+    assertEquals(2, cache.hitCount());
   }
 
   @Test public void statisticsFullCacheHit() throws Exception {
     server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60").setBody("A"));
 
-    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
-    assertEquals(1, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(0, cache.getHitCount());
-    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
-    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
-    assertEquals(3, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(2, cache.getHitCount());
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals(1, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(0, cache.hitCount());
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals(3, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(2, cache.hitCount());
   }
 
   @Test public void varyMatchesChangedRequestHeaderField() throws Exception {
@@ -1235,12 +1244,12 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
 
-    URL url = server.getUrl("/");
-    HttpURLConnection frConnection = client.open(url);
+    URL url = server.url("/").url();
+    HttpURLConnection frConnection = urlFactory.open(url);
     frConnection.addRequestProperty("Accept-Language", "fr-CA");
     assertEquals("A", readAscii(frConnection));
 
-    HttpURLConnection enConnection = client.open(url);
+    HttpURLConnection enConnection = urlFactory.open(url);
     enConnection.addRequestProperty("Accept-Language", "en-US");
     assertEquals("B", readAscii(enConnection));
   }
@@ -1251,11 +1260,11 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
 
-    URL url = server.getUrl("/");
-    URLConnection connection1 = client.open(url);
+    URL url = server.url("/").url();
+    URLConnection connection1 = urlFactory.open(url);
     connection1.addRequestProperty("Accept-Language", "fr-CA");
     assertEquals("A", readAscii(connection1));
-    URLConnection connection2 = client.open(url);
+    URLConnection connection2 = urlFactory.open(url);
     connection2.addRequestProperty("Accept-Language", "fr-CA");
     assertEquals("A", readAscii(connection2));
   }
@@ -1266,8 +1275,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
 
-    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
-    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
   }
 
   @Test public void varyMatchesAddedRequestHeaderField() throws Exception {
@@ -1276,8 +1285,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
 
-    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
-    URLConnection fooConnection = client.open(server.getUrl("/"));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    URLConnection fooConnection = urlFactory.open(server.url("/").url());
     fooConnection.addRequestProperty("Foo", "bar");
     assertEquals("B", readAscii(fooConnection));
   }
@@ -1288,10 +1297,10 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
 
-    URLConnection fooConnection = client.open(server.getUrl("/"));
+    URLConnection fooConnection = urlFactory.open(server.url("/").url());
     fooConnection.addRequestProperty("Foo", "bar");
     assertEquals("A", readAscii(fooConnection));
-    assertEquals("B", readAscii(client.open(server.getUrl("/"))));
+    assertEquals("B", readAscii(urlFactory.open(server.url("/").url())));
   }
 
   @Test public void varyFieldsAreCaseInsensitive() throws Exception {
@@ -1300,11 +1309,11 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
 
-    URL url = server.getUrl("/");
-    URLConnection connection1 = client.open(url);
+    URL url = server.url("/").url();
+    URLConnection connection1 = urlFactory.open(url);
     connection1.addRequestProperty("Accept-Language", "fr-CA");
     assertEquals("A", readAscii(connection1));
-    URLConnection connection2 = client.open(url);
+    URLConnection connection2 = urlFactory.open(url);
     connection2.addRequestProperty("accept-language", "fr-CA");
     assertEquals("A", readAscii(connection2));
   }
@@ -1316,13 +1325,13 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
 
-    URL url = server.getUrl("/");
-    URLConnection connection1 = client.open(url);
+    URL url = server.url("/").url();
+    URLConnection connection1 = urlFactory.open(url);
     connection1.addRequestProperty("Accept-Language", "fr-CA");
     connection1.addRequestProperty("Accept-Charset", "UTF-8");
     connection1.addRequestProperty("Accept-Encoding", "identity");
     assertEquals("A", readAscii(connection1));
-    URLConnection connection2 = client.open(url);
+    URLConnection connection2 = urlFactory.open(url);
     connection2.addRequestProperty("Accept-Language", "fr-CA");
     connection2.addRequestProperty("Accept-Charset", "UTF-8");
     connection2.addRequestProperty("Accept-Encoding", "identity");
@@ -1336,13 +1345,13 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
 
-    URL url = server.getUrl("/");
-    URLConnection frConnection = client.open(url);
+    URL url = server.url("/").url();
+    URLConnection frConnection = urlFactory.open(url);
     frConnection.addRequestProperty("Accept-Language", "fr-CA");
     frConnection.addRequestProperty("Accept-Charset", "UTF-8");
     frConnection.addRequestProperty("Accept-Encoding", "identity");
     assertEquals("A", readAscii(frConnection));
-    URLConnection enConnection = client.open(url);
+    URLConnection enConnection = urlFactory.open(url);
     enConnection.addRequestProperty("Accept-Language", "en-CA");
     enConnection.addRequestProperty("Accept-Charset", "UTF-8");
     enConnection.addRequestProperty("Accept-Encoding", "identity");
@@ -1355,13 +1364,13 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
 
-    URL url = server.getUrl("/");
-    URLConnection connection1 = client.open(url);
+    URL url = server.url("/").url();
+    URLConnection connection1 = urlFactory.open(url);
     connection1.addRequestProperty("Accept-Language", "fr-CA, fr-FR");
     connection1.addRequestProperty("Accept-Language", "en-US");
     assertEquals("A", readAscii(connection1));
 
-    URLConnection connection2 = client.open(url);
+    URLConnection connection2 = urlFactory.open(url);
     connection2.addRequestProperty("Accept-Language", "fr-CA, fr-FR");
     connection2.addRequestProperty("Accept-Language", "en-US");
     assertEquals("A", readAscii(connection2));
@@ -1373,13 +1382,13 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
 
-    URL url = server.getUrl("/");
-    URLConnection connection1 = client.open(url);
+    URL url = server.url("/").url();
+    URLConnection connection1 = urlFactory.open(url);
     connection1.addRequestProperty("Accept-Language", "fr-CA, fr-FR");
     connection1.addRequestProperty("Accept-Language", "en-US");
     assertEquals("A", readAscii(connection1));
 
-    URLConnection connection2 = client.open(url);
+    URLConnection connection2 = urlFactory.open(url);
     connection2.addRequestProperty("Accept-Language", "fr-CA");
     connection2.addRequestProperty("Accept-Language", "en-US");
     assertEquals("B", readAscii(connection2));
@@ -1391,46 +1400,54 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
 
-    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
-    assertEquals("B", readAscii(client.open(server.getUrl("/"))));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals("B", readAscii(urlFactory.open(server.url("/").url())));
   }
 
   @Test public void varyAndHttps() throws Exception {
-    server.useHttps(sslContext.getSocketFactory(), false);
+    assumeFalse(getPlatform().equals("jdk9"));
+
+    server.useHttps(sslClient.socketFactory, false);
     server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
         .addHeader("Vary: Accept-Language")
         .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
 
-    URL url = server.getUrl("/");
-    HttpsURLConnection connection1 = (HttpsURLConnection) client.open(url);
-    connection1.setSSLSocketFactory(sslContext.getSocketFactory());
+    URL url = server.url("/").url();
+    HttpsURLConnection connection1 = (HttpsURLConnection) urlFactory.open(url);
+    connection1.setSSLSocketFactory(sslClient.socketFactory);
     connection1.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
     connection1.addRequestProperty("Accept-Language", "en-US");
     assertEquals("A", readAscii(connection1));
 
-    HttpsURLConnection connection2 = (HttpsURLConnection) client.open(url);
-    connection2.setSSLSocketFactory(sslContext.getSocketFactory());
+    HttpsURLConnection connection2 = (HttpsURLConnection) urlFactory.open(url);
+    connection2.setSSLSocketFactory(sslClient.socketFactory);
     connection2.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
     connection2.addRequestProperty("Accept-Language", "en-US");
     assertEquals("A", readAscii(connection2));
   }
 
   @Test public void cachePlusCookies() throws Exception {
-    server.enqueue(new MockResponse().addHeader(
-        "Set-Cookie: a=FIRST; domain=" + server.getCookieDomain() + ";")
+    RecordingCookieJar cookieJar = new RecordingCookieJar();
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .cookieJar(cookieJar)
+        .build());
+
+    server.enqueue(new MockResponse()
+        .addHeader("Set-Cookie: a=FIRST")
         .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Cache-Control: max-age=0")
         .setBody("A"));
-    server.enqueue(new MockResponse().addHeader(
-        "Set-Cookie: a=SECOND; domain=" + server.getCookieDomain() + ";")
+    server.enqueue(new MockResponse()
+        .addHeader("Set-Cookie: a=SECOND")
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    URL url = server.getUrl("/");
-    assertEquals("A", readAscii(client.open(url)));
-    assertCookies(url, "a=FIRST");
-    assertEquals("A", readAscii(client.open(url)));
-    assertCookies(url, "a=SECOND");
+    URL url = server.url("/").url();
+    assertEquals("A", readAscii(urlFactory.open(url)));
+    cookieJar.assertResponseCookies("a=FIRST; path=/");
+
+    assertEquals("A", readAscii(urlFactory.open(url)));
+    cookieJar.assertResponseCookies("a=SECOND; path=/");
   }
 
   @Test public void getHeadersReturnsNetworkEndToEndHeaders() throws Exception {
@@ -1441,11 +1458,11 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse().addHeader("Allow: GET, HEAD, PUT")
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    URLConnection connection1 = client.open(server.getUrl("/"));
+    URLConnection connection1 = urlFactory.open(server.url("/").url());
     assertEquals("A", readAscii(connection1));
     assertEquals("GET, HEAD", connection1.getHeaderField("Allow"));
 
-    URLConnection connection2 = client.open(server.getUrl("/"));
+    URLConnection connection2 = urlFactory.open(server.url("/").url());
     assertEquals("A", readAscii(connection2));
     assertEquals("GET, HEAD, PUT", connection2.getHeaderField("Allow"));
   }
@@ -1458,11 +1475,11 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse().addHeader("Transfer-Encoding: none")
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    URLConnection connection1 = client.open(server.getUrl("/"));
+    URLConnection connection1 = urlFactory.open(server.url("/").url());
     assertEquals("A", readAscii(connection1));
     assertEquals("identity", connection1.getHeaderField("Transfer-Encoding"));
 
-    URLConnection connection2 = client.open(server.getUrl("/"));
+    URLConnection connection2 = urlFactory.open(server.url("/").url());
     assertEquals("A", readAscii(connection2));
     assertEquals("identity", connection2.getHeaderField("Transfer-Encoding"));
   }
@@ -1474,11 +1491,11 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setBody("A"));
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    URLConnection connection1 = client.open(server.getUrl("/"));
+    URLConnection connection1 = urlFactory.open(server.url("/").url());
     assertEquals("A", readAscii(connection1));
     assertEquals("199 test danger", connection1.getHeaderField("Warning"));
 
-    URLConnection connection2 = client.open(server.getUrl("/"));
+    URLConnection connection2 = urlFactory.open(server.url("/").url());
     assertEquals("A", readAscii(connection2));
     assertEquals(null, connection2.getHeaderField("Warning"));
   }
@@ -1490,28 +1507,20 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setBody("A"));
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    URLConnection connection1 = client.open(server.getUrl("/"));
+    URLConnection connection1 = urlFactory.open(server.url("/").url());
     assertEquals("A", readAscii(connection1));
     assertEquals("299 test danger", connection1.getHeaderField("Warning"));
 
-    URLConnection connection2 = client.open(server.getUrl("/"));
+    URLConnection connection2 = urlFactory.open(server.url("/").url());
     assertEquals("A", readAscii(connection2));
     assertEquals("299 test danger", connection2.getHeaderField("Warning"));
   }
 
-  public void assertCookies(URL url, String... expectedCookies) throws Exception {
-    List<String> actualCookies = new ArrayList<>();
-    for (HttpCookie cookie : cookieManager.getCookieStore().get(url.toURI())) {
-      actualCookies.add(cookie.toString());
-    }
-    assertEquals(Arrays.asList(expectedCookies), actualCookies);
-  }
-
   @Test public void cachePlusRange() throws Exception {
     assertNotCached(new MockResponse().setResponseCode(HttpURLConnection.HTTP_PARTIAL)
-            .addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
-            .addHeader("Content-Range: bytes 100-100/200")
-            .addHeader("Cache-Control: max-age=60"));
+        .addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
+        .addHeader("Content-Range: bytes 100-100/200")
+        .addHeader("Cache-Control: max-age=60"));
   }
 
   @Test public void conditionalHitUpdatesCache() throws Exception {
@@ -1524,18 +1533,18 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
     server.enqueue(new MockResponse().setBody("B"));
 
     // cache miss; seed the cache
-    HttpURLConnection connection1 = client.open(server.getUrl("/a"));
+    HttpURLConnection connection1 = urlFactory.open(server.url("/a").url());
     assertEquals("A", readAscii(connection1));
     assertEquals(null, connection1.getHeaderField("Allow"));
 
     // conditional cache hit; update the cache
-    HttpURLConnection connection2 = client.open(server.getUrl("/a"));
+    HttpURLConnection connection2 = urlFactory.open(server.url("/a").url());
     assertEquals(HttpURLConnection.HTTP_OK, connection2.getResponseCode());
     assertEquals("A", readAscii(connection2));
     assertEquals("GET, HEAD", connection2.getHeaderField("Allow"));
 
     // full cache hit
-    HttpURLConnection connection3 = client.open(server.getUrl("/a"));
+    HttpURLConnection connection3 = urlFactory.open(server.url("/a").url());
     assertEquals("A", readAscii(connection3));
     assertEquals("GET, HEAD", connection3.getHeaderField("Allow"));
 
@@ -1547,8 +1556,8 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
         .addHeader("Cache-Control: max-age=30")
         .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
 
-    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
-    URLConnection connection = client.open(server.getUrl("/"));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    URLConnection connection = urlFactory.open(server.url("/").url());
     connection.addRequestProperty("Cache-Control", "only-if-cached");
     assertEquals("A", readAscii(connection));
   }
@@ -1561,8 +1570,8 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
         .addHeader("Cache-Control: max-age=30")
         .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
 
-    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    HttpURLConnection connection = urlFactory.open(server.url("/").url());
     assertEquals("B", readAscii(connection));
   }
 
@@ -1572,15 +1581,15 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
         .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
     server.enqueue(new MockResponse().setResponseCode(304));
 
-    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    HttpURLConnection connection = urlFactory.open(server.url("/").url());
     assertEquals("A", readAscii(connection));
   }
 
   @Test public void responseSourceHeaderFetched() throws IOException {
     server.enqueue(new MockResponse().setBody("A"));
 
-    URLConnection connection = client.open(server.getUrl("/"));
+    URLConnection connection = urlFactory.open(server.url("/").url());
     assertEquals("A", readAscii(connection));
   }
 
@@ -1590,15 +1599,15 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
     Internal.instance.addLenient(headers, ": A");
     server.enqueue(new MockResponse().setHeaders(headers.build()).setBody("body"));
 
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    HttpURLConnection connection = urlFactory.open(server.url("/").url());
     assertEquals("A", connection.getHeaderField(""));
+    assertEquals("body", readAscii(connection));
   }
 
   /**
-   * Old implementations of OkHttp's response cache wrote header fields like
-   * ":status: 200 OK". This broke our cached response parser because it split
-   * on the first colon. This regression test exists to help us read these old
-   * bad cache entries.
+   * Old implementations of OkHttp's response cache wrote header fields like ":status: 200 OK". This
+   * broke our cached response parser because it split on the first colon. This regression test
+   * exists to help us read these old bad cache entries.
    *
    * https://github.com/square/okhttp/issues/227
    */
@@ -1608,7 +1617,7 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
         .clearHeaders()
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    URL url = server.getUrl("/");
+    URL url = server.url("/").url();
     String urlKey = Util.md5Hex(url.toString());
     String entryMetadata = ""
         + "" + url + "\n"
@@ -1642,28 +1651,29 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
         + "2\n"
         + "\n"
         + "CLEAN " + urlKey + " " + entryMetadata.length() + " " + entryBody.length() + "\n";
-    writeFile(cache.getDirectory(), urlKey + ".0", entryMetadata);
-    writeFile(cache.getDirectory(), urlKey + ".1", entryBody);
-    writeFile(cache.getDirectory(), "journal", journalBody);
-    cache = new Cache(cache.getDirectory(), Integer.MAX_VALUE);
-    client.client().setCache(cache);
-
-    HttpURLConnection connection = client.open(url);
+    writeFile(cache.directory(), urlKey + ".0", entryMetadata);
+    writeFile(cache.directory(), urlKey + ".1", entryBody);
+    writeFile(cache.directory(), "journal", journalBody);
+    cache = new Cache(cache.directory(), Integer.MAX_VALUE, fileSystem);
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .cache(cache)
+        .build());
+
+    HttpURLConnection connection = urlFactory.open(url);
     assertEquals(entryBody, readAscii(connection));
     assertEquals("3", connection.getHeaderField("Content-Length"));
     assertEquals("foo", connection.getHeaderField("etag"));
   }
 
   private void writeFile(File directory, String file, String content) throws IOException {
-    BufferedSink sink = Okio.buffer(Okio.sink(new File(directory, file)));
+    BufferedSink sink = Okio.buffer(fileSystem.sink(new File(directory, file)));
     sink.writeUtf8(content);
     sink.close();
   }
 
   /**
-   * @param delta the offset from the current date to use. Negative
-   * values yield dates in the past; positive values yield dates in the
-   * future.
+   * @param delta the offset from the current date to use. Negative values yield dates in the past;
+   * positive values yield dates in the future.
    */
   private String formatDate(long delta, TimeUnit timeUnit) {
     return formatDate(new Date(System.currentTimeMillis() + timeUnit.toMillis(delta)));
@@ -1689,9 +1699,9 @@ private void assertNotCached(MockResponse response) throws Exception {
     server.enqueue(response.setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
 
-    URL url = server.getUrl("/");
-    assertEquals("A", readAscii(client.open(url)));
-    assertEquals("B", readAscii(client.open(url)));
+    URL url = server.url("/").url();
+    assertEquals("A", readAscii(urlFactory.open(url)));
+    assertEquals("B", readAscii(urlFactory.open(url)));
   }
 
   /** @return the request with the conditional get headers. */
@@ -1704,22 +1714,22 @@ private RecordedRequest assertConditionallyCached(MockResponse response) throws
     server.enqueue(response.setBody("B").setStatus("HTTP/1.1 200 B-OK"));
     server.enqueue(new MockResponse().setStatus("HTTP/1.1 200 C-OK").setBody("C"));
 
-    URL valid = server.getUrl("/valid");
-    HttpURLConnection connection1 = client.open(valid);
+    URL valid = server.url("/valid").url();
+    HttpURLConnection connection1 = urlFactory.open(valid);
     assertEquals("A", readAscii(connection1));
     assertEquals(HttpURLConnection.HTTP_OK, connection1.getResponseCode());
     assertEquals("A-OK", connection1.getResponseMessage());
-    HttpURLConnection connection2 = client.open(valid);
+    HttpURLConnection connection2 = urlFactory.open(valid);
     assertEquals("A", readAscii(connection2));
     assertEquals(HttpURLConnection.HTTP_OK, connection2.getResponseCode());
     assertEquals("A-OK", connection2.getResponseMessage());
 
-    URL invalid = server.getUrl("/invalid");
-    HttpURLConnection connection3 = client.open(invalid);
+    URL invalid = server.url("/invalid").url();
+    HttpURLConnection connection3 = urlFactory.open(invalid);
     assertEquals("B", readAscii(connection3));
     assertEquals(HttpURLConnection.HTTP_OK, connection3.getResponseCode());
     assertEquals("B-OK", connection3.getResponseMessage());
-    HttpURLConnection connection4 = client.open(invalid);
+    HttpURLConnection connection4 = urlFactory.open(invalid);
     assertEquals("C", readAscii(connection4));
     assertEquals(HttpURLConnection.HTTP_OK, connection4.getResponseCode());
     assertEquals("C-OK", connection4.getResponseMessage());
@@ -1732,15 +1742,14 @@ private void assertFullyCached(MockResponse response) throws Exception {
     server.enqueue(response.setBody("A"));
     server.enqueue(response.setBody("B"));
 
-    URL url = server.getUrl("/");
-    assertEquals("A", readAscii(client.open(url)));
-    assertEquals("A", readAscii(client.open(url)));
+    URL url = server.url("/").url();
+    assertEquals("A", readAscii(urlFactory.open(url)));
+    assertEquals("A", readAscii(urlFactory.open(url)));
   }
 
   /**
-   * Shortens the body of {@code response} but not the corresponding headers.
-   * Only useful to test how clients respond to the premature conclusion of
-   * the HTTP body.
+   * Shortens the body of {@code response} but not the corresponding headers. Only useful to test
+   * how clients respond to the premature conclusion of the HTTP body.
    */
   private MockResponse truncateViolently(MockResponse response, int numBytesToKeep) {
     response.setSocketPolicy(DISCONNECT_AT_END);
@@ -1753,9 +1762,8 @@ private MockResponse truncateViolently(MockResponse response, int numBytesToKeep
   }
 
   /**
-   * Reads {@code count} characters from the stream. If the stream is
-   * exhausted before {@code count} characters can be read, the remaining
-   * characters are returned and the stream is closed.
+   * Reads {@code count} characters from the stream. If the stream is exhausted before {@code count}
+   * characters can be read, the remaining characters are returned and the stream is closed.
    */
   private String readAscii(URLConnection connection, int count) throws IOException {
     HttpURLConnection httpConnection = (HttpURLConnection) connection;
@@ -1833,4 +1841,8 @@ public Buffer gzip(String data) throws IOException {
     sink.close();
     return result;
   }
+
+  private String getPlatform() {
+    return System.getProperty("okhttp.platform", "platform");
+  }
 }
diff --git a/okhttp-urlconnection/src/test/java/com/squareup/okhttp/internal/huc/URLEncodingTest.java b/okhttp-urlconnection/src/test/java/okhttp3/internal/huc/URLEncodingTest.java
similarity index 77%
rename from okhttp-urlconnection/src/test/java/com/squareup/okhttp/internal/huc/URLEncodingTest.java
rename to okhttp-urlconnection/src/test/java/okhttp3/internal/huc/URLEncodingTest.java
index 5a4ed10ac2..1cc63d8f34 100644
--- a/okhttp-urlconnection/src/test/java/com/squareup/okhttp/internal/huc/URLEncodingTest.java
+++ b/okhttp-urlconnection/src/test/java/okhttp3/internal/huc/URLEncodingTest.java
@@ -14,41 +14,36 @@
  * limitations under the License.
  */
 
-package com.squareup.okhttp.internal.huc;
-
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.OkUrlFactory;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
-import com.squareup.okhttp.internal.Internal;
-import com.squareup.okhttp.internal.InternalCache;
-import com.squareup.okhttp.internal.http.CacheRequest;
-import com.squareup.okhttp.internal.http.CacheStrategy;
+package okhttp3.internal.huc;
 
 import java.io.IOException;
-import java.net.CacheResponse;
 import java.net.HttpURLConnection;
 import java.net.URI;
 import java.net.URISyntaxException;
 import java.net.URL;
-import java.util.List;
-import java.util.Map;
 import java.util.concurrent.atomic.AtomicReference;
+import okhttp3.OkHttpClient;
+import okhttp3.OkUrlFactory;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.internal.Internal;
+import okhttp3.internal.InternalCache;
+import okhttp3.internal.http.CacheRequest;
+import okhttp3.internal.http.CacheStrategy;
 import org.junit.Ignore;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
 
 /**
- * Exercises HttpURLConnection to convert URL to a URI. Unlike URL#toURI,
- * HttpURLConnection recovers from URLs with unescaped but unsupported URI
- * characters like '{' and '|' by escaping these characters.
+ * Exercises HttpURLConnection to convert URL to a URI. Unlike URL#toURI, HttpURLConnection recovers
+ * from URLs with unescaped but unsupported URI characters like '{' and '|' by escaping these
+ * characters.
  */
 public final class URLEncodingTest {
   /**
-   * This test goes through the exhaustive set of interesting ASCII characters
-   * because most of those characters are interesting in some way according to
-   * RFC 2396 and RFC 2732. http://b/1158780
+   * This test goes through the exhaustive set of interesting ASCII characters because most of those
+   * characters are interesting in some way according to RFC 2396 and RFC 2732. http://b/1158780
    */
   @Test @Ignore public void lenientUrlToUri() throws Exception {
     // alphanum
@@ -128,42 +123,32 @@ private void testUrlToUriMapping(String string, String asAuthority, String asFil
   private URI backdoorUrlToUri(URL url) throws Exception {
     final AtomicReference<URI> uriReference = new AtomicReference<>();
 
-    OkHttpClient client = new OkHttpClient();
-    Internal.instance.setCache(client, new InternalCache() {
-      @Override
-      public Response get(Request request) throws IOException {
-        uriReference.set(request.uri());
+    OkHttpClient.Builder builder = new OkHttpClient.Builder();
+    Internal.instance.setCache(builder, new InternalCache() {
+      @Override public Response get(Request request) throws IOException {
+        uriReference.set(request.url().uri());
         throw new UnsupportedOperationException();
       }
 
-      @Override
-      public CacheRequest put(Response response) throws IOException {
+      @Override public CacheRequest put(Response response) throws IOException {
         return null;
       }
 
-      @Override
-      public void remove(Request request) throws IOException {
-
+      @Override public void remove(Request request) throws IOException {
       }
 
-      @Override
-      public void update(Response cached, Response network) throws IOException {
-
+      @Override public void update(Response cached, Response network) throws IOException {
       }
 
-      @Override
-      public void trackConditionalCacheHit() {
-
+      @Override public void trackConditionalCacheHit() {
       }
 
-      @Override
-      public void trackResponse(CacheStrategy cacheStrategy) {
-
+      @Override public void trackResponse(CacheStrategy cacheStrategy) {
       }
     });
 
     try {
-      HttpURLConnection connection = new OkUrlFactory(client).open(url);
+      HttpURLConnection connection = new OkUrlFactory(builder.build()).open(url);
       connection.getResponseCode();
     } catch (Exception expected) {
       if (expected.getCause() instanceof URISyntaxException) {
diff --git a/okhttp-ws-tests/fuzzingserver-config.json b/okhttp-ws-tests/fuzzingserver-config.json
new file mode 100644
index 0000000000..99e06abb51
--- /dev/null
+++ b/okhttp-ws-tests/fuzzingserver-config.json
@@ -0,0 +1,153 @@
+{
+  "url": "ws://127.0.0.1:9001",
+  "outdir": "./target/fuzzingserver-report",
+  "cases": ["*"],
+  "exclude-cases": [
+    "6.1.1",
+    "6.1.2",
+    "6.1.3",
+    "6.2.1",
+    "6.2.2",
+    "6.2.3",
+    "6.2.4",
+    "6.3.1",
+    "6.3.2",
+    "6.4.1",
+    "6.4.2",
+    "6.4.3",
+    "6.4.4",
+    "6.5.1",
+    "6.5.2",
+    "6.5.3",
+    "6.5.4",
+    "6.5.5",
+    "6.6.1",
+    "6.6.2",
+    "6.6.3",
+    "6.6.4",
+    "6.6.5",
+    "6.6.6",
+    "6.6.7",
+    "6.6.8",
+    "6.6.9",
+    "6.6.10",
+    "6.6.11",
+    "6.7.1",
+    "6.7.2",
+    "6.7.3",
+    "6.7.4",
+    "6.8.1",
+    "6.8.2",
+    "6.9.1",
+    "6.9.2",
+    "6.9.3",
+    "6.9.4",
+    "6.10.1",
+    "6.10.2",
+    "6.10.3",
+    "6.11.1",
+    "6.11.2",
+    "6.11.3",
+    "6.11.4",
+    "6.11.5",
+    "6.12.1",
+    "6.12.2",
+    "6.12.3",
+    "6.12.4",
+    "6.12.5",
+    "6.12.6",
+    "6.12.7",
+    "6.12.8",
+    "6.13.1",
+    "6.13.2",
+    "6.13.3",
+    "6.13.4",
+    "6.13.5",
+    "6.14.1",
+    "6.14.2",
+    "6.14.3",
+    "6.14.4",
+    "6.14.5",
+    "6.14.6",
+    "6.14.7",
+    "6.14.8",
+    "6.14.9",
+    "6.14.10",
+    "6.15.1",
+    "6.16.1",
+    "6.16.2",
+    "6.16.3",
+    "6.17.1",
+    "6.17.2",
+    "6.17.3",
+    "6.17.4",
+    "6.17.5",
+    "6.18.1",
+    "6.18.2",
+    "6.18.3",
+    "6.18.4",
+    "6.18.5",
+    "6.19.1",
+    "6.19.2",
+    "6.19.3",
+    "6.19.4",
+    "6.19.5",
+    "6.20.1",
+    "6.20.2",
+    "6.20.3",
+    "6.20.4",
+    "6.20.5",
+    "6.20.6",
+    "6.20.7",
+    "6.21.1",
+    "6.21.2",
+    "6.21.3",
+    "6.21.4",
+    "6.21.5",
+    "6.21.6",
+    "6.21.7",
+    "6.21.8",
+    "6.22.1",
+    "6.22.2",
+    "6.22.3",
+    "6.22.4",
+    "6.22.5",
+    "6.22.6",
+    "6.22.7",
+    "6.22.8",
+    "6.22.9",
+    "6.22.10",
+    "6.22.11",
+    "6.22.12",
+    "6.22.13",
+    "6.22.14",
+    "6.22.15",
+    "6.22.16",
+    "6.22.17",
+    "6.22.18",
+    "6.22.19",
+    "6.22.20",
+    "6.22.21",
+    "6.22.22",
+    "6.22.23",
+    "6.22.24",
+    "6.22.25",
+    "6.22.26",
+    "6.22.27",
+    "6.22.28",
+    "6.22.29",
+    "6.22.30",
+    "6.22.31",
+    "6.22.32",
+    "6.22.33",
+    "6.22.34",
+    "6.23.1",
+    "6.23.2",
+    "6.23.3",
+    "6.23.4",
+    "6.23.5",
+    "6.23.6",
+    "6.23.7"
+  ],
+  "exclude-agent-cases": {}
+}
diff --git a/okhttp-ws-tests/fuzzingserver-expected.txt b/okhttp-ws-tests/fuzzingserver-expected.txt
new file mode 100644
index 0000000000..f4a3305f79
--- /dev/null
+++ b/okhttp-ws-tests/fuzzingserver-expected.txt
@@ -0,0 +1,376 @@
+"1.1.1 OK"
+"1.1.2 OK"
+"1.1.3 OK"
+"1.1.4 OK"
+"1.1.5 OK"
+"1.1.6 OK"
+"1.1.7 OK"
+"1.1.8 OK"
+"1.2.1 OK"
+"1.2.2 OK"
+"1.2.3 OK"
+"1.2.4 OK"
+"1.2.5 OK"
+"1.2.6 OK"
+"1.2.7 OK"
+"1.2.8 OK"
+"10.1.1 OK"
+"12.1.1 UNIMPLEMENTED"
+"12.1.10 UNIMPLEMENTED"
+"12.1.11 UNIMPLEMENTED"
+"12.1.12 UNIMPLEMENTED"
+"12.1.13 UNIMPLEMENTED"
+"12.1.14 UNIMPLEMENTED"
+"12.1.15 UNIMPLEMENTED"
+"12.1.16 UNIMPLEMENTED"
+"12.1.17 UNIMPLEMENTED"
+"12.1.18 UNIMPLEMENTED"
+"12.1.2 UNIMPLEMENTED"
+"12.1.3 UNIMPLEMENTED"
+"12.1.4 UNIMPLEMENTED"
+"12.1.5 UNIMPLEMENTED"
+"12.1.6 UNIMPLEMENTED"
+"12.1.7 UNIMPLEMENTED"
+"12.1.8 UNIMPLEMENTED"
+"12.1.9 UNIMPLEMENTED"
+"12.2.1 UNIMPLEMENTED"
+"12.2.10 UNIMPLEMENTED"
+"12.2.11 UNIMPLEMENTED"
+"12.2.12 UNIMPLEMENTED"
+"12.2.13 UNIMPLEMENTED"
+"12.2.14 UNIMPLEMENTED"
+"12.2.15 UNIMPLEMENTED"
+"12.2.16 UNIMPLEMENTED"
+"12.2.17 UNIMPLEMENTED"
+"12.2.18 UNIMPLEMENTED"
+"12.2.2 UNIMPLEMENTED"
+"12.2.3 UNIMPLEMENTED"
+"12.2.4 UNIMPLEMENTED"
+"12.2.5 UNIMPLEMENTED"
+"12.2.6 UNIMPLEMENTED"
+"12.2.7 UNIMPLEMENTED"
+"12.2.8 UNIMPLEMENTED"
+"12.2.9 UNIMPLEMENTED"
+"12.3.1 UNIMPLEMENTED"
+"12.3.10 UNIMPLEMENTED"
+"12.3.11 UNIMPLEMENTED"
+"12.3.12 UNIMPLEMENTED"
+"12.3.13 UNIMPLEMENTED"
+"12.3.14 UNIMPLEMENTED"
+"12.3.15 UNIMPLEMENTED"
+"12.3.16 UNIMPLEMENTED"
+"12.3.17 UNIMPLEMENTED"
+"12.3.18 UNIMPLEMENTED"
+"12.3.2 UNIMPLEMENTED"
+"12.3.3 UNIMPLEMENTED"
+"12.3.4 UNIMPLEMENTED"
+"12.3.5 UNIMPLEMENTED"
+"12.3.6 UNIMPLEMENTED"
+"12.3.7 UNIMPLEMENTED"
+"12.3.8 UNIMPLEMENTED"
+"12.3.9 UNIMPLEMENTED"
+"12.4.1 UNIMPLEMENTED"
+"12.4.10 UNIMPLEMENTED"
+"12.4.11 UNIMPLEMENTED"
+"12.4.12 UNIMPLEMENTED"
+"12.4.13 UNIMPLEMENTED"
+"12.4.14 UNIMPLEMENTED"
+"12.4.15 UNIMPLEMENTED"
+"12.4.16 UNIMPLEMENTED"
+"12.4.17 UNIMPLEMENTED"
+"12.4.18 UNIMPLEMENTED"
+"12.4.2 UNIMPLEMENTED"
+"12.4.3 UNIMPLEMENTED"
+"12.4.4 UNIMPLEMENTED"
+"12.4.5 UNIMPLEMENTED"
+"12.4.6 UNIMPLEMENTED"
+"12.4.7 UNIMPLEMENTED"
+"12.4.8 UNIMPLEMENTED"
+"12.4.9 UNIMPLEMENTED"
+"12.5.1 UNIMPLEMENTED"
+"12.5.10 UNIMPLEMENTED"
+"12.5.11 UNIMPLEMENTED"
+"12.5.12 UNIMPLEMENTED"
+"12.5.13 UNIMPLEMENTED"
+"12.5.14 UNIMPLEMENTED"
+"12.5.15 UNIMPLEMENTED"
+"12.5.16 UNIMPLEMENTED"
+"12.5.17 UNIMPLEMENTED"
+"12.5.18 UNIMPLEMENTED"
+"12.5.2 UNIMPLEMENTED"
+"12.5.3 UNIMPLEMENTED"
+"12.5.4 UNIMPLEMENTED"
+"12.5.5 UNIMPLEMENTED"
+"12.5.6 UNIMPLEMENTED"
+"12.5.7 UNIMPLEMENTED"
+"12.5.8 UNIMPLEMENTED"
+"12.5.9 UNIMPLEMENTED"
+"13.1.1 UNIMPLEMENTED"
+"13.1.10 UNIMPLEMENTED"
+"13.1.11 UNIMPLEMENTED"
+"13.1.12 UNIMPLEMENTED"
+"13.1.13 UNIMPLEMENTED"
+"13.1.14 UNIMPLEMENTED"
+"13.1.15 UNIMPLEMENTED"
+"13.1.16 UNIMPLEMENTED"
+"13.1.17 UNIMPLEMENTED"
+"13.1.18 UNIMPLEMENTED"
+"13.1.2 UNIMPLEMENTED"
+"13.1.3 UNIMPLEMENTED"
+"13.1.4 UNIMPLEMENTED"
+"13.1.5 UNIMPLEMENTED"
+"13.1.6 UNIMPLEMENTED"
+"13.1.7 UNIMPLEMENTED"
+"13.1.8 UNIMPLEMENTED"
+"13.1.9 UNIMPLEMENTED"
+"13.2.1 UNIMPLEMENTED"
+"13.2.10 UNIMPLEMENTED"
+"13.2.11 UNIMPLEMENTED"
+"13.2.12 UNIMPLEMENTED"
+"13.2.13 UNIMPLEMENTED"
+"13.2.14 UNIMPLEMENTED"
+"13.2.15 UNIMPLEMENTED"
+"13.2.16 UNIMPLEMENTED"
+"13.2.17 UNIMPLEMENTED"
+"13.2.18 UNIMPLEMENTED"
+"13.2.2 UNIMPLEMENTED"
+"13.2.3 UNIMPLEMENTED"
+"13.2.4 UNIMPLEMENTED"
+"13.2.5 UNIMPLEMENTED"
+"13.2.6 UNIMPLEMENTED"
+"13.2.7 UNIMPLEMENTED"
+"13.2.8 UNIMPLEMENTED"
+"13.2.9 UNIMPLEMENTED"
+"13.3.1 UNIMPLEMENTED"
+"13.3.10 UNIMPLEMENTED"
+"13.3.11 UNIMPLEMENTED"
+"13.3.12 UNIMPLEMENTED"
+"13.3.13 UNIMPLEMENTED"
+"13.3.14 UNIMPLEMENTED"
+"13.3.15 UNIMPLEMENTED"
+"13.3.16 UNIMPLEMENTED"
+"13.3.17 UNIMPLEMENTED"
+"13.3.18 UNIMPLEMENTED"
+"13.3.2 UNIMPLEMENTED"
+"13.3.3 UNIMPLEMENTED"
+"13.3.4 UNIMPLEMENTED"
+"13.3.5 UNIMPLEMENTED"
+"13.3.6 UNIMPLEMENTED"
+"13.3.7 UNIMPLEMENTED"
+"13.3.8 UNIMPLEMENTED"
+"13.3.9 UNIMPLEMENTED"
+"13.4.1 UNIMPLEMENTED"
+"13.4.10 UNIMPLEMENTED"
+"13.4.11 UNIMPLEMENTED"
+"13.4.12 UNIMPLEMENTED"
+"13.4.13 UNIMPLEMENTED"
+"13.4.14 UNIMPLEMENTED"
+"13.4.15 UNIMPLEMENTED"
+"13.4.16 UNIMPLEMENTED"
+"13.4.17 UNIMPLEMENTED"
+"13.4.18 UNIMPLEMENTED"
+"13.4.2 UNIMPLEMENTED"
+"13.4.3 UNIMPLEMENTED"
+"13.4.4 UNIMPLEMENTED"
+"13.4.5 UNIMPLEMENTED"
+"13.4.6 UNIMPLEMENTED"
+"13.4.7 UNIMPLEMENTED"
+"13.4.8 UNIMPLEMENTED"
+"13.4.9 UNIMPLEMENTED"
+"13.5.1 UNIMPLEMENTED"
+"13.5.10 UNIMPLEMENTED"
+"13.5.11 UNIMPLEMENTED"
+"13.5.12 UNIMPLEMENTED"
+"13.5.13 UNIMPLEMENTED"
+"13.5.14 UNIMPLEMENTED"
+"13.5.15 UNIMPLEMENTED"
+"13.5.16 UNIMPLEMENTED"
+"13.5.17 UNIMPLEMENTED"
+"13.5.18 UNIMPLEMENTED"
+"13.5.2 UNIMPLEMENTED"
+"13.5.3 UNIMPLEMENTED"
+"13.5.4 UNIMPLEMENTED"
+"13.5.5 UNIMPLEMENTED"
+"13.5.6 UNIMPLEMENTED"
+"13.5.7 UNIMPLEMENTED"
+"13.5.8 UNIMPLEMENTED"
+"13.5.9 UNIMPLEMENTED"
+"13.6.1 UNIMPLEMENTED"
+"13.6.10 UNIMPLEMENTED"
+"13.6.11 UNIMPLEMENTED"
+"13.6.12 UNIMPLEMENTED"
+"13.6.13 UNIMPLEMENTED"
+"13.6.14 UNIMPLEMENTED"
+"13.6.15 UNIMPLEMENTED"
+"13.6.16 UNIMPLEMENTED"
+"13.6.17 UNIMPLEMENTED"
+"13.6.18 UNIMPLEMENTED"
+"13.6.2 UNIMPLEMENTED"
+"13.6.3 UNIMPLEMENTED"
+"13.6.4 UNIMPLEMENTED"
+"13.6.5 UNIMPLEMENTED"
+"13.6.6 UNIMPLEMENTED"
+"13.6.7 UNIMPLEMENTED"
+"13.6.8 UNIMPLEMENTED"
+"13.6.9 UNIMPLEMENTED"
+"13.7.1 UNIMPLEMENTED"
+"13.7.10 UNIMPLEMENTED"
+"13.7.11 UNIMPLEMENTED"
+"13.7.12 UNIMPLEMENTED"
+"13.7.13 UNIMPLEMENTED"
+"13.7.14 UNIMPLEMENTED"
+"13.7.15 UNIMPLEMENTED"
+"13.7.16 UNIMPLEMENTED"
+"13.7.17 UNIMPLEMENTED"
+"13.7.18 UNIMPLEMENTED"
+"13.7.2 UNIMPLEMENTED"
+"13.7.3 UNIMPLEMENTED"
+"13.7.4 UNIMPLEMENTED"
+"13.7.5 UNIMPLEMENTED"
+"13.7.6 UNIMPLEMENTED"
+"13.7.7 UNIMPLEMENTED"
+"13.7.8 UNIMPLEMENTED"
+"13.7.9 UNIMPLEMENTED"
+"2.1 OK"
+"2.10 OK"
+"2.11 OK"
+"2.2 OK"
+"2.3 OK"
+"2.4 OK"
+"2.5 OK"
+"2.6 OK"
+"2.7 OK"
+"2.8 OK"
+"2.9 OK"
+"3.1 OK"
+"3.2 NON-STRICT"
+"3.3 NON-STRICT"
+"3.4 NON-STRICT"
+"3.5 OK"
+"3.6 OK"
+"3.7 OK"
+"4.1.1 OK"
+"4.1.2 OK"
+"4.1.3 NON-STRICT"
+"4.1.4 NON-STRICT"
+"4.1.5 OK"
+"4.2.1 OK"
+"4.2.2 OK"
+"4.2.3 NON-STRICT"
+"4.2.4 NON-STRICT"
+"4.2.5 OK"
+"5.1 OK"
+"5.10 OK"
+"5.11 OK"
+"5.12 OK"
+"5.13 OK"
+"5.14 OK"
+"5.15 NON-STRICT"
+"5.16 OK"
+"5.17 OK"
+"5.18 OK"
+"5.19 OK"
+"5.2 OK"
+"5.20 OK"
+"5.3 OK"
+"5.4 OK"
+"5.5 OK"
+"5.6 OK"
+"5.7 OK"
+"5.8 OK"
+"5.9 OK"
+"7.1.1 OK"
+"7.1.2 OK"
+"7.1.3 OK"
+"7.1.4 OK"
+"7.1.5 FAILED"
+"7.1.6 INFORMATIONAL"
+"7.13.1 INFORMATIONAL"
+"7.13.2 INFORMATIONAL"
+"7.3.1 OK"
+"7.3.2 OK"
+"7.3.3 OK"
+"7.3.4 OK"
+"7.3.5 OK"
+"7.3.6 OK"
+"7.5.1 FAILED"
+"7.7.1 OK"
+"7.7.10 OK"
+"7.7.11 OK"
+"7.7.12 OK"
+"7.7.13 OK"
+"7.7.2 OK"
+"7.7.3 OK"
+"7.7.4 OK"
+"7.7.5 OK"
+"7.7.6 OK"
+"7.7.7 OK"
+"7.7.8 OK"
+"7.7.9 OK"
+"7.9.1 OK"
+"7.9.10 OK"
+"7.9.11 OK"
+"7.9.12 OK"
+"7.9.13 OK"
+"7.9.2 OK"
+"7.9.3 OK"
+"7.9.4 OK"
+"7.9.5 OK"
+"7.9.6 OK"
+"7.9.7 OK"
+"7.9.8 OK"
+"7.9.9 OK"
+"9.1.1 OK"
+"9.1.2 OK"
+"9.1.3 OK"
+"9.1.4 OK"
+"9.1.5 OK"
+"9.1.6 OK"
+"9.2.1 OK"
+"9.2.2 OK"
+"9.2.3 OK"
+"9.2.4 OK"
+"9.2.5 OK"
+"9.2.6 OK"
+"9.3.1 OK"
+"9.3.2 OK"
+"9.3.3 OK"
+"9.3.4 OK"
+"9.3.5 OK"
+"9.3.6 OK"
+"9.3.7 OK"
+"9.3.8 OK"
+"9.3.9 OK"
+"9.4.1 OK"
+"9.4.2 OK"
+"9.4.3 OK"
+"9.4.4 OK"
+"9.4.5 OK"
+"9.4.6 OK"
+"9.4.7 OK"
+"9.4.8 OK"
+"9.4.9 OK"
+"9.5.1 OK"
+"9.5.2 OK"
+"9.5.3 OK"
+"9.5.4 OK"
+"9.5.5 OK"
+"9.5.6 OK"
+"9.6.1 OK"
+"9.6.2 OK"
+"9.6.3 OK"
+"9.6.4 OK"
+"9.6.5 OK"
+"9.6.6 OK"
+"9.7.1 OK"
+"9.7.2 OK"
+"9.7.3 OK"
+"9.7.4 OK"
+"9.7.5 OK"
+"9.7.6 OK"
+"9.8.1 OK"
+"9.8.2 OK"
+"9.8.3 OK"
+"9.8.4 OK"
+"9.8.5 OK"
+"9.8.6 OK"
diff --git a/okhttp-ws-tests/fuzzingserver-test.sh b/okhttp-ws-tests/fuzzingserver-test.sh
new file mode 100755
index 0000000000..af89a42422
--- /dev/null
+++ b/okhttp-ws-tests/fuzzingserver-test.sh
@@ -0,0 +1,28 @@
+#!/usr/bin/env bash
+
+SCRIPT_DIR="$( cd "$( dirname "$0" )" && pwd )"
+cd "$SCRIPT_DIR"
+
+which wstest
+if [ $? != 0 ]; then
+  echo "Run 'pip install autobahntestsuite', maybe with 'sudo'."
+  exit 1
+fi
+which jq
+if [ $? != 0 ]; then
+  echo "Run 'brew install jq'"
+  exit 1
+fi
+
+trap 'kill $(jobs -pr)' SIGINT SIGTERM EXIT
+
+set -ex
+
+wstest -m fuzzingserver -s fuzzingserver-config.json &
+sleep 2 # wait for wstest to start
+
+java -jar target/okhttp-ws-tests-*-jar-with-dependencies.jar
+
+jq '.[] as $in | $in | keys[] | . + " " + $in[.].behavior' target/fuzzingserver-report/index.json > target/fuzzingserver-actual.txt
+
+diff fuzzingserver-expected.txt target/fuzzingserver-actual.txt
diff --git a/okhttp-ws-tests/fuzzingserver-update-expected.sh b/okhttp-ws-tests/fuzzingserver-update-expected.sh
new file mode 100755
index 0000000000..56592c95fe
--- /dev/null
+++ b/okhttp-ws-tests/fuzzingserver-update-expected.sh
@@ -0,0 +1,11 @@
+#!/usr/bin/env bash
+
+SCRIPT_DIR="$( cd "$( dirname "$0" )" && pwd )"
+cd "$SCRIPT_DIR"
+
+if [ ! -f target/fuzzingserver-actual.txt ]; then
+  echo "File not found. Did you run the Autobahn test script?"
+  exit 1
+fi
+
+cp target/fuzzingserver-actual.txt fuzzingserver-expected.txt
diff --git a/okhttp-ws-tests/pom.xml b/okhttp-ws-tests/pom.xml
index 424f4a56e1..cef5759623 100644
--- a/okhttp-ws-tests/pom.xml
+++ b/okhttp-ws-tests/pom.xml
@@ -4,9 +4,9 @@
   <modelVersion>4.0.0</modelVersion>
 
   <parent>
-    <groupId>com.squareup.okhttp</groupId>
+    <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>2.4.0-SNAPSHOT</version>
+    <version>3.4.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-ws-tests</artifactId>
@@ -14,18 +14,25 @@
 
   <dependencies>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>${project.groupId}</groupId>
       <artifactId>okhttp-ws</artifactId>
       <version>${project.version}</version>
     </dependency>
 
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp-testing-support</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
+
     <dependency>
       <groupId>junit</groupId>
       <artifactId>junit</artifactId>
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>${project.groupId}</groupId>
       <artifactId>mockwebserver</artifactId>
       <version>${project.version}</version>
       <scope>test</scope>
@@ -34,6 +41,28 @@
 
   <build>
     <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-assembly-plugin</artifactId>
+        <configuration>
+          <descriptorRefs>
+            <descriptorRef>jar-with-dependencies</descriptorRef>
+          </descriptorRefs>
+          <archive>
+            <manifest>
+              <mainClass>okhttp3.ws.AutobahnTester</mainClass>
+            </manifest>
+          </archive>
+        </configuration>
+        <executions>
+          <execution>
+            <phase>package</phase>
+            <goals>
+              <goal>single</goal>
+            </goals>
+          </execution>
+        </executions>
+      </plugin>
       <!-- Do not deploy this as an artifact to Maven central. -->
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
diff --git a/okhttp-ws-tests/src/main/java/okhttp3/ws/AutobahnTester.java b/okhttp-ws-tests/src/main/java/okhttp3/ws/AutobahnTester.java
new file mode 100644
index 0000000000..707f58c116
--- /dev/null
+++ b/okhttp-ws-tests/src/main/java/okhttp3/ws/AutobahnTester.java
@@ -0,0 +1,198 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.ws;
+
+import java.io.IOException;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.concurrent.atomic.AtomicReference;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+import okhttp3.internal.Version;
+import okio.Buffer;
+import okio.BufferedSource;
+
+import static okhttp3.ws.WebSocket.BINARY;
+import static okhttp3.ws.WebSocket.TEXT;
+
+/**
+ * Exercises the web socket implementation against the <a
+ * href="http://autobahn.ws/testsuite/">Autobahn Testsuite</a>.
+ */
+public final class AutobahnTester {
+  private static final String HOST = "ws://localhost:9001";
+
+  public static void main(String... args) throws IOException {
+    new AutobahnTester().run();
+  }
+
+  final OkHttpClient client = new OkHttpClient();
+
+  private WebSocketCall newWebSocket(String path) {
+    Request request = new Request.Builder().url(HOST + path).build();
+    return WebSocketCall.create(client, request);
+  }
+
+  public void run() throws IOException {
+    try {
+      long count = getTestCount();
+      System.out.println("Test count: " + count);
+
+      for (long number = 1; number <= count; number++) {
+        runTest(number, count);
+      }
+
+      updateReports();
+    } finally {
+      client.dispatcher().executorService().shutdown();
+    }
+  }
+
+  private void runTest(final long number, final long count) throws IOException {
+    final CountDownLatch latch = new CountDownLatch(1);
+    final AtomicLong startNanos = new AtomicLong();
+    newWebSocket("/runCase?case=" + number + "&agent=okhttp") //
+        .enqueue(new WebSocketListener() {
+          private final ExecutorService sendExecutor = Executors.newSingleThreadExecutor();
+          private WebSocket webSocket;
+
+          @Override public void onOpen(WebSocket webSocket, Response response) {
+            this.webSocket = webSocket;
+
+            System.out.println("Executing test case " + number + "/" + count);
+            startNanos.set(System.nanoTime());
+          }
+
+          @Override public void onMessage(final ResponseBody message) throws IOException {
+            final RequestBody response;
+            if (message.contentType() == TEXT) {
+              response = RequestBody.create(TEXT, message.string());
+            } else {
+              BufferedSource source = message.source();
+              response = RequestBody.create(BINARY, source.readByteString());
+              source.close();
+            }
+            sendExecutor.execute(new Runnable() {
+              @Override public void run() {
+                try {
+                  webSocket.sendMessage(response);
+                } catch (IOException e) {
+                  e.printStackTrace(System.out);
+                }
+              }
+            });
+          }
+
+          @Override public void onPong(Buffer payload) {
+          }
+
+          @Override public void onClose(int code, String reason) {
+            sendExecutor.shutdown();
+            latch.countDown();
+          }
+
+          @Override public void onFailure(IOException e, Response response) {
+            e.printStackTrace(System.out);
+            latch.countDown();
+          }
+        });
+    try {
+      if (!latch.await(30, TimeUnit.SECONDS)) {
+        throw new IllegalStateException("Timed out waiting for test " + number + " to finish.");
+      }
+    } catch (InterruptedException e) {
+      throw new AssertionError();
+    }
+
+    long endNanos = System.nanoTime();
+    long tookMs = TimeUnit.NANOSECONDS.toMillis(endNanos - startNanos.get());
+    System.out.println("Took " + tookMs + "ms");
+  }
+
+  private long getTestCount() throws IOException {
+    final CountDownLatch latch = new CountDownLatch(1);
+    final AtomicLong countRef = new AtomicLong();
+    final AtomicReference<IOException> failureRef = new AtomicReference<>();
+    newWebSocket("/getCaseCount").enqueue(new WebSocketListener() {
+      @Override public void onOpen(WebSocket webSocket, Response response) {
+      }
+
+      @Override public void onMessage(ResponseBody message) throws IOException {
+        countRef.set(message.source().readDecimalLong());
+        message.close();
+      }
+
+      @Override public void onPong(Buffer payload) {
+      }
+
+      @Override public void onClose(int code, String reason) {
+        latch.countDown();
+      }
+
+      @Override public void onFailure(IOException e, Response response) {
+        failureRef.set(e);
+        latch.countDown();
+      }
+    });
+    try {
+      if (!latch.await(10, TimeUnit.SECONDS)) {
+        throw new IllegalStateException("Timed out waiting for count.");
+      }
+    } catch (InterruptedException e) {
+      throw new AssertionError();
+    }
+    IOException failure = failureRef.get();
+    if (failure != null) {
+      throw failure;
+    }
+    return countRef.get();
+  }
+
+  private void updateReports() {
+    final CountDownLatch latch = new CountDownLatch(1);
+    newWebSocket("/updateReports?agent=" + Version.userAgent()).enqueue(new WebSocketListener() {
+      @Override public void onOpen(WebSocket webSocket, Response response) {
+      }
+
+      @Override public void onMessage(ResponseBody message) throws IOException {
+      }
+
+      @Override public void onPong(Buffer payload) {
+      }
+
+      @Override public void onClose(int code, String reason) {
+        latch.countDown();
+      }
+
+      @Override public void onFailure(IOException e, Response response) {
+        latch.countDown();
+      }
+    });
+    try {
+      if (!latch.await(10, TimeUnit.SECONDS)) {
+        throw new IllegalStateException("Timed out waiting for count.");
+      }
+    } catch (InterruptedException e) {
+      throw new AssertionError();
+    }
+  }
+}
diff --git a/okhttp-ws-tests/src/test/java/com/squareup/okhttp/internal/ws/RealWebSocketTest.java b/okhttp-ws-tests/src/test/java/com/squareup/okhttp/internal/ws/RealWebSocketTest.java
deleted file mode 100644
index 857f00c2fb..0000000000
--- a/okhttp-ws-tests/src/test/java/com/squareup/okhttp/internal/ws/RealWebSocketTest.java
+++ /dev/null
@@ -1,303 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal.ws;
-
-import com.squareup.okhttp.ws.WebSocketRecorder;
-import java.io.IOException;
-import java.net.ProtocolException;
-import java.util.Random;
-import java.util.concurrent.Executor;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.ByteString;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-
-import static com.squareup.okhttp.ws.WebSocket.PayloadType.BINARY;
-import static com.squareup.okhttp.ws.WebSocket.PayloadType.TEXT;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-public final class RealWebSocketTest {
-  // NOTE: Fields are named 'client' and 'server' for cognitive simplicity. This differentiation has
-  // zero effect on the behavior of the WebSocket API which is why tests are only written once
-  // from the perspective of a single peer.
-
-  private RealWebSocket client;
-  private boolean clientConnectionCloseThrows;
-  private boolean clientConnectionClosed;
-  private final Buffer client2Server = new Buffer();
-  private final WebSocketRecorder clientListener = new WebSocketRecorder();
-
-  private RealWebSocket server;
-  private final Buffer server2client = new Buffer();
-  private final WebSocketRecorder serverListener = new WebSocketRecorder();
-
-  @Before public void setUp() {
-    Random random = new Random(0);
-    String url = "http://example.com/websocket";
-
-    Executor synchronousExecutor = new Executor() {
-      @Override public void execute(Runnable command) {
-        command.run();
-      }
-    };
-
-    client = new RealWebSocket(true, server2client, client2Server, random, synchronousExecutor,
-        clientListener, url) {
-      @Override protected void closeConnection() throws IOException {
-        clientConnectionClosed = true;
-        if (clientConnectionCloseThrows) {
-          throw new IOException("Oops!");
-        }
-      }
-    };
-    server = new RealWebSocket(false, client2Server, server2client, random, synchronousExecutor,
-        serverListener, url) {
-      @Override protected void closeConnection() throws IOException {
-      }
-    };
-  }
-
-  @After public void tearDown() {
-    clientListener.assertExhausted();
-    serverListener.assertExhausted();
-  }
-
-  @Test public void textMessage() throws IOException {
-    client.sendMessage(TEXT, new Buffer().writeUtf8("Hello!"));
-    server.readMessage();
-    serverListener.assertTextMessage("Hello!");
-  }
-
-  @Test public void binaryMessage() throws IOException {
-    client.sendMessage(BINARY, new Buffer().writeUtf8("Hello!"));
-    server.readMessage();
-    serverListener.assertBinaryMessage(new byte[] { 'H', 'e', 'l', 'l', 'o', '!' });
-  }
-
-  @Test public void streamingMessage() throws IOException {
-    BufferedSink sink = client.newMessageSink(TEXT);
-    sink.writeUtf8("Hel").flush();
-    sink.writeUtf8("lo!").flush();
-    sink.close();
-    server.readMessage();
-    serverListener.assertTextMessage("Hello!");
-  }
-
-  @Test public void streamingMessageCanInterleavePing() throws IOException, InterruptedException {
-    BufferedSink sink = client.newMessageSink(TEXT);
-    sink.writeUtf8("Hel").flush();
-    client.sendPing(new Buffer().writeUtf8("Pong?"));
-    sink.writeUtf8("lo!").flush();
-    sink.close();
-    server.readMessage();
-    serverListener.assertTextMessage("Hello!");
-    client.readMessage();
-    clientListener.assertPong(new Buffer().writeUtf8("Pong?"));
-  }
-
-  @Test public void pingWritesPong() throws IOException, InterruptedException {
-    client.sendPing(new Buffer().writeUtf8("Hello!"));
-    server.readMessage(); // Read the ping, write the pong.
-    client.readMessage(); // Read the pong.
-    clientListener.assertPong(new Buffer().writeUtf8("Hello!"));
-  }
-
-  @Test public void unsolicitedPong() throws IOException {
-    client.sendPong(new Buffer().writeUtf8("Hello!"));
-    server.readMessage();
-    serverListener.assertPong(new Buffer().writeUtf8("Hello!"));
-  }
-
-  @Test public void close() throws IOException {
-    client.close(1000, "Hello!");
-    server.readMessage(); // This will trigger a close response.
-    serverListener.assertClose(1000, "Hello!");
-    client.readMessage();
-    clientListener.assertClose(1000, "Hello!");
-  }
-
-  @Test public void clientCloseThenMethodsThrow() throws IOException {
-    client.close(1000, "Hello!");
-
-    try {
-      client.sendPing(new Buffer().writeUtf8("Pong?"));
-      fail();
-    } catch (IllegalStateException e) {
-      assertEquals("closed", e.getMessage());
-    }
-    try {
-      client.close(1000, "Hello!");
-      fail();
-    } catch (IllegalStateException e) {
-      assertEquals("closed", e.getMessage());
-    }
-    try {
-      client.sendMessage(TEXT, new Buffer().writeUtf8("Hello!"));
-      fail();
-    } catch (IllegalStateException e) {
-      assertEquals("closed", e.getMessage());
-    }
-    try {
-      client.newMessageSink(TEXT);
-      fail();
-    } catch (IllegalStateException e) {
-      assertEquals("closed", e.getMessage());
-    }
-  }
-
-  @Test public void serverCloseThenWritingThrows() throws IOException {
-    server.close(1000, "Hello!");
-    client.readMessage();
-    clientListener.assertClose(1000, "Hello!");
-
-    try {
-      client.sendPing(new Buffer().writeUtf8("Pong?"));
-      fail();
-    } catch (IOException e) {
-      assertEquals("closed", e.getMessage());
-    }
-    try {
-      client.sendMessage(TEXT, new Buffer().writeUtf8("Hi!"));
-      fail();
-    } catch (IOException e) {
-      assertEquals("closed", e.getMessage());
-    }
-    try {
-      client.close(1000, "Bye!");
-      fail();
-    } catch (IOException e) {
-      assertEquals("closed", e.getMessage());
-    }
-  }
-
-  @Test public void serverCloseWhileWritingThrows() throws IOException {
-    // Start writing data.
-    BufferedSink sink = client.newMessageSink(TEXT);
-    sink.writeUtf8("Hel").flush();
-
-    server.close(1000, "Hello!");
-    client.readMessage();
-    clientListener.assertClose(1000, "Hello!");
-
-    try {
-      sink.writeUtf8("lo!").emit(); // No writing to the underlying sink.
-      fail();
-    } catch (IOException e) {
-      assertEquals("closed", e.getMessage());
-      sink.buffer().clear();
-    }
-    try {
-      sink.flush(); // No flushing.
-      fail();
-    } catch (IOException e) {
-      assertEquals("closed", e.getMessage());
-    }
-    try {
-      sink.close(); // No closing because this requires writing a frame.
-      fail();
-    } catch (IOException e) {
-      assertEquals("closed", e.getMessage());
-    }
-  }
-
-  @Test public void clientCloseClosesConnection() throws IOException {
-    client.close(1000, "Hello!");
-    assertFalse(clientConnectionClosed);
-    server.readMessage(); // Read client close, send server close.
-    serverListener.assertClose(1000, "Hello!");
-
-    client.readMessage();
-    assertTrue(clientConnectionClosed);
-    clientListener.assertClose(1000, "Hello!");
-  }
-
-  @Test public void serverCloseClosesConnection() throws IOException {
-    server.close(1000, "Hello!");
-
-    client.readMessage(); // Read server close, send client close, close connection.
-    clientListener.assertClose(1000, "Hello!");
-    assertTrue(clientConnectionClosed);
-
-    server.readMessage();
-    serverListener.assertClose(1000, "Hello!");
-  }
-
-  @Test public void clientAndServerCloseClosesConnection() throws IOException {
-    // Send close from both sides at the same time.
-    server.close(1000, "Hello!");
-    client.close(1000, "Hi!");
-    assertFalse(clientConnectionClosed);
-
-    client.readMessage(); // Read close, should NOT send close.
-    assertTrue(clientConnectionClosed);
-    clientListener.assertClose(1000, "Hello!");
-
-    server.readMessage();
-    serverListener.assertClose(1000, "Hi!");
-
-    serverListener.assertExhausted(); // Client should not have sent second close.
-    clientListener.assertExhausted(); // Server should not have sent second close.
-  }
-
-  @Test public void serverCloseBreaksReadMessageLoop() throws IOException {
-    server.sendMessage(TEXT, new Buffer().writeUtf8("Hello!"));
-    server.close(1000, "Bye!");
-    assertTrue(client.readMessage());
-    clientListener.assertTextMessage("Hello!");
-    assertFalse(client.readMessage());
-    clientListener.assertClose(1000, "Bye!");
-  }
-
-  @Test public void protocolErrorBeforeCloseSendsClose() {
-    server2client.write(ByteString.decodeHex("0a00")); // Invalid non-final ping frame.
-
-    client.readMessage(); // Detects error, send close.
-    clientListener.assertFailure(ProtocolException.class, "Control frames must be final.");
-    assertTrue(clientConnectionClosed);
-
-    server.readMessage();
-    serverListener.assertClose(1002, "");
-  }
-
-  @Test public void protocolErrorAfterCloseDoesNotSendClose() throws IOException {
-    client.close(1000, "Hello!");
-    server2client.write(ByteString.decodeHex("0a00")); // Invalid non-final ping frame.
-
-    client.readMessage();
-    clientListener.assertFailure(ProtocolException.class, "Control frames must be final.");
-    assertTrue(clientConnectionClosed);
-
-    server.readMessage();
-    serverListener.assertClose(1000, "Hello!");
-  }
-
-  @Test public void peerConnectionCloseThrowingDoesNotPropagate() throws IOException {
-    clientConnectionCloseThrows = true;
-
-    server.close(1000, "Bye!");
-    client.readMessage();
-    clientListener.assertClose(1000, "Bye!");
-    assertTrue(clientConnectionClosed);
-
-    server.readMessage();
-    serverListener.assertClose(1000, "Bye!");
-  }
-}
diff --git a/okhttp-ws-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketWriterTest.java b/okhttp-ws-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketWriterTest.java
deleted file mode 100644
index d31687bb25..0000000000
--- a/okhttp-ws-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketWriterTest.java
+++ /dev/null
@@ -1,335 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal.ws;
-
-import java.io.EOFException;
-import java.io.IOException;
-import java.util.Arrays;
-import java.util.Random;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.ByteString;
-import org.junit.After;
-import org.junit.Test;
-
-import static com.squareup.okhttp.ws.WebSocket.PayloadType.BINARY;
-import static com.squareup.okhttp.ws.WebSocket.PayloadType.TEXT;
-import static com.squareup.okhttp.internal.ws.WebSocketProtocol.toggleMask;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
-
-public final class WebSocketWriterTest {
-  private final Buffer data = new Buffer();
-  private final Random random = new Random(0);
-
-  // Mutually exclusive. Use the one corresponding to the peer whose behavior you wish to test.
-  private final WebSocketWriter serverWriter = new WebSocketWriter(false, data, random);
-  private final WebSocketWriter clientWriter = new WebSocketWriter(true, data, random);
-
-  @After public void tearDown() throws IOException {
-    assertEquals("Data not empty", "", data.readByteString().hex());
-  }
-
-  @Test public void serverSendSimpleHello() throws IOException {
-    Buffer payload = new Buffer().writeUtf8("Hello");
-    serverWriter.sendMessage(TEXT, payload);
-    assertData("810548656c6c6f");
-  }
-
-  @Test public void clientSendSimpleHello() throws IOException {
-    Buffer payload = new Buffer().writeUtf8("Hello");
-    clientWriter.sendMessage(TEXT, payload);
-    assertData("818560b420bb28d14cd70f");
-  }
-
-  @Test public void serverStreamSimpleHello() throws IOException {
-    BufferedSink sink = serverWriter.newMessageSink(TEXT);
-
-    sink.writeUtf8("Hel").flush();
-    assertData("010348656c");
-
-    sink.writeUtf8("lo").flush();
-    assertData("00026c6f");
-
-    sink.close();
-    assertData("8000");
-  }
-
-  @Test public void serverStreamCloseFlushes() throws IOException {
-    BufferedSink sink = serverWriter.newMessageSink(TEXT);
-
-    sink.writeUtf8("Hel").flush();
-    assertData("010348656c");
-
-    sink.writeUtf8("lo").close();
-    assertData("00026c6f");
-    assertData("8000");
-  }
-
-  @Test public void clientStreamSimpleHello() throws IOException {
-    BufferedSink sink = clientWriter.newMessageSink(TEXT);
-
-    sink.writeUtf8("Hel").flush();
-    assertData("018360b420bb28d14c");
-
-    sink.writeUtf8("lo").flush();
-    assertData("00823851d9d4543e");
-
-    sink.close();
-    assertData("80807acb933d");
-  }
-
-  @Test public void serverSendBinary() throws IOException {
-    byte[] payload = binaryData(100);
-    serverWriter.sendMessage(BINARY, new Buffer().write(payload));
-    assertData("8264");
-    assertData(payload);
-  }
-
-  @Test public void serverSendBinaryShort() throws IOException {
-    byte[] payload = binaryData(0xffff);
-    serverWriter.sendMessage(BINARY, new Buffer().write(payload));
-    assertData("827effff");
-    assertData(payload);
-  }
-
-  @Test public void serverSendBinaryLong() throws IOException {
-    byte[] payload = binaryData(65537);
-    serverWriter.sendMessage(BINARY, new Buffer().write(payload));
-    assertData("827f0000000000010001");
-    assertData(payload);
-  }
-
-  @Test public void clientSendBinary() throws IOException {
-    byte[] payload = binaryData(100);
-    clientWriter.sendMessage(BINARY, new Buffer().write(payload));
-    assertData("82e4");
-
-    byte[] maskKey = new byte[4];
-    random.setSeed(0); // Reset the seed so we can mask the payload.
-    random.nextBytes(maskKey);
-    toggleMask(payload, payload.length, maskKey, 0);
-
-    assertData(maskKey);
-    assertData(payload);
-  }
-
-  @Test public void serverStreamBinary() throws IOException {
-    byte[] payload = binaryData(100);
-    BufferedSink sink = serverWriter.newMessageSink(BINARY);
-
-    sink.write(payload, 0, 50).flush();
-    assertData("0232");
-    assertData(Arrays.copyOfRange(payload, 0, 50));
-
-    sink.write(payload, 50, 50).flush();
-    assertData("0032");
-    assertData(Arrays.copyOfRange(payload, 50, 100));
-
-    sink.close();
-    assertData("8000");
-  }
-
-  @Test public void clientStreamBinary() throws IOException {
-    byte[] maskKey1 = new byte[4];
-    random.nextBytes(maskKey1);
-    byte[] maskKey2 = new byte[4];
-    random.nextBytes(maskKey2);
-    byte[] maskKey3 = new byte[4];
-    random.nextBytes(maskKey3);
-
-    random.setSeed(0); // Reset the seed so real data matches.
-
-    byte[] payload = binaryData(100);
-    BufferedSink sink = clientWriter.newMessageSink(BINARY);
-
-    sink.write(payload, 0, 50).flush();
-    byte[] part1 = Arrays.copyOfRange(payload, 0, 50);
-    toggleMask(part1, 50, maskKey1, 0);
-    assertData("02b2");
-    assertData(maskKey1);
-    assertData(part1);
-
-    sink.write(payload, 50, 50).flush();
-    byte[] part2 = Arrays.copyOfRange(payload, 50, 100);
-    toggleMask(part2, 50, maskKey2, 0);
-    assertData("00b2");
-    assertData(maskKey2);
-    assertData(part2);
-
-    sink.close();
-    assertData("8080");
-    assertData(maskKey3);
-  }
-
-  @Test public void serverEmptyClose() throws IOException {
-    serverWriter.writeClose(0, null);
-    assertData("8800");
-  }
-
-  @Test public void serverCloseWithCode() throws IOException {
-    serverWriter.writeClose(1005, null);
-    assertData("880203ed");
-  }
-
-  @Test public void serverCloseWithCodeAndReason() throws IOException {
-    serverWriter.writeClose(1005, "Hello");
-    assertData("880703ed48656c6c6f");
-  }
-
-  @Test public void clientEmptyClose() throws IOException {
-    clientWriter.writeClose(0, null);
-    assertData("888060b420bb");
-  }
-
-  @Test public void clientCloseWithCode() throws IOException {
-    clientWriter.writeClose(1005, null);
-    assertData("888260b420bb6359");
-  }
-
-  @Test public void clientCloseWithCodeAndReason() throws IOException {
-    clientWriter.writeClose(1005, "Hello");
-    assertData("888760b420bb635968de0cd84f");
-  }
-
-  @Test public void closeWithOnlyReasonThrows() throws IOException {
-    try {
-      clientWriter.writeClose(0, "Hello");
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertEquals("Code required to include reason.", e.getMessage());
-    }
-  }
-
-  @Test public void closeCodeOutOfRangeThrows() throws IOException {
-    try {
-      clientWriter.writeClose(98724976, "Hello");
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertEquals("Code must be in range [1000,5000).", e.getMessage());
-    }
-  }
-
-  @Test public void serverEmptyPing() throws IOException {
-    serverWriter.writePing(null);
-    assertData("8900");
-  }
-
-  @Test public void clientEmptyPing() throws IOException {
-    clientWriter.writePing(null);
-    assertData("898060b420bb");
-  }
-
-  @Test public void serverPingWithPayload() throws IOException {
-    serverWriter.writePing(new Buffer().writeUtf8("Hello"));
-    assertData("890548656c6c6f");
-  }
-
-  @Test public void clientPingWithPayload() throws IOException {
-    clientWriter.writePing(new Buffer().writeUtf8("Hello"));
-    assertData("898560b420bb28d14cd70f");
-  }
-
-  @Test public void serverEmptyPong() throws IOException {
-    serverWriter.writePong(null);
-    assertData("8a00");
-  }
-
-  @Test public void clientEmptyPong() throws IOException {
-    clientWriter.writePong(null);
-    assertData("8a8060b420bb");
-  }
-
-  @Test public void serverPongWithPayload() throws IOException {
-    serverWriter.writePong(new Buffer().writeUtf8("Hello"));
-    assertData("8a0548656c6c6f");
-  }
-
-  @Test public void clientPongWithPayload() throws IOException {
-    clientWriter.writePong(new Buffer().writeUtf8("Hello"));
-    assertData("8a8560b420bb28d14cd70f");
-  }
-
-  @Test public void pingTooLongThrows() throws IOException {
-    try {
-      serverWriter.writePing(new Buffer().write(binaryData(1000)));
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertEquals("Payload size must be less than or equal to 125", e.getMessage());
-    }
-  }
-
-  @Test public void pongTooLongThrows() throws IOException {
-    try {
-      serverWriter.writePong(new Buffer().write(binaryData(1000)));
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertEquals("Payload size must be less than or equal to 125", e.getMessage());
-    }
-  }
-
-  @Test public void closeTooLongThrows() throws IOException {
-    try {
-      String longString = ByteString.of(binaryData(75)).hex();
-      serverWriter.writeClose(1000, longString);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertEquals("Payload size must be less than or equal to 125", e.getMessage());
-    }
-  }
-
-  @Test public void twoWritersThrows() {
-    clientWriter.newMessageSink(TEXT);
-    try {
-      clientWriter.newMessageSink(TEXT);
-      fail();
-    } catch (IllegalStateException e) {
-      assertEquals("Another message writer is active. Did you call close()?", e.getMessage());
-    }
-  }
-
-  @Test public void writeWhileWriterThrows() throws IOException {
-    clientWriter.newMessageSink(TEXT);
-    try {
-      clientWriter.sendMessage(TEXT, new Buffer());
-      fail();
-    } catch (IllegalStateException e) {
-      assertEquals("A message writer is active. Did you call close()?", e.getMessage());
-    }
-  }
-
-  private void assertData(String hex) throws EOFException {
-    ByteString expected = ByteString.decodeHex(hex);
-    ByteString actual = data.readByteString(expected.size());
-    assertEquals(expected, actual);
-  }
-
-  private void assertData(byte[] data) throws IOException {
-    int byteCount = 16;
-    for (int i = 0; i < data.length; i += byteCount) {
-      int count = Math.min(byteCount, data.length - i);
-      Buffer expectedChunk = new Buffer();
-      expectedChunk.write(data, i, count);
-      assertEquals("At " + i, expectedChunk.readByteString(), this.data.readByteString(count));
-    }
-  }
-
-  private static byte[] binaryData(int length) {
-    byte[] junk = new byte[length];
-    new Random(0).nextBytes(junk);
-    return junk;
-  }
-}
diff --git a/okhttp-ws-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java b/okhttp-ws-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
new file mode 100644
index 0000000000..90a803ec14
--- /dev/null
+++ b/okhttp-ws-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
@@ -0,0 +1,504 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.ws;
+
+import java.io.Closeable;
+import java.io.IOException;
+import java.net.ProtocolException;
+import java.util.Random;
+import java.util.concurrent.Executor;
+import okhttp3.MediaType;
+import okhttp3.RequestBody;
+import okhttp3.ws.WebSocketRecorder;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.ByteString;
+import okio.Okio;
+import okio.Sink;
+import okio.Source;
+import okio.Timeout;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import static okhttp3.ws.WebSocket.BINARY;
+import static okhttp3.ws.WebSocket.TEXT;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class RealWebSocketTest {
+  // NOTE: Fields are named 'client' and 'server' for cognitive simplicity. This differentiation has
+  // zero effect on the behavior of the WebSocket API which is why tests are only written once
+  // from the perspective of a single peer.
+
+  private final Executor clientExecutor = new SynchronousExecutor();
+  private RealWebSocket client;
+  private boolean clientConnectionCloseThrows;
+  private boolean clientConnectionClosed;
+  private final MemorySocket client2Server = new MemorySocket();
+  private final WebSocketRecorder clientListener = new WebSocketRecorder();
+
+  private final Executor serverExecutor = new SynchronousExecutor();
+  private RealWebSocket server;
+  private boolean serverConnectionClosed;
+  private final MemorySocket server2client = new MemorySocket();
+  private final WebSocketRecorder serverListener = new WebSocketRecorder();
+
+  @Before public void setUp() {
+    Random random = new Random(0);
+    String url = "http://example.com/websocket";
+
+    client = new RealWebSocket(true, server2client.source(), client2Server.sink(), random,
+        clientExecutor, clientListener, url) {
+      @Override protected void close() throws IOException {
+        if (clientConnectionClosed) {
+          throw new AssertionError("Already closed");
+        }
+        clientConnectionClosed = true;
+
+        if (clientConnectionCloseThrows) {
+          throw new IOException("Oops!");
+        }
+      }
+    };
+    server = new RealWebSocket(false, client2Server.source(), server2client.sink(), random,
+        serverExecutor, serverListener, url) {
+      @Override protected void close() throws IOException {
+        if (serverConnectionClosed) {
+          throw new AssertionError("Already closed");
+        }
+        serverConnectionClosed = true;
+      }
+    };
+  }
+
+  @After public void tearDown() {
+    clientListener.assertExhausted();
+    serverListener.assertExhausted();
+  }
+
+  @Test public void nullMessageThrows() throws IOException {
+    try {
+      client.sendMessage(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertEquals("message == null", e.getMessage());
+    }
+  }
+
+  @Test public void textMessage() throws IOException {
+    client.sendMessage(RequestBody.create(TEXT, "Hello!"));
+    server.readMessage();
+    serverListener.assertTextMessage("Hello!");
+  }
+
+  @Test public void binaryMessage() throws IOException {
+    client.sendMessage(RequestBody.create(BINARY, "Hello!"));
+    server.readMessage();
+    serverListener.assertBinaryMessage(new byte[] {'H', 'e', 'l', 'l', 'o', '!'});
+  }
+
+  @Test public void missingContentTypeThrows() throws IOException {
+    try {
+      client.sendMessage(RequestBody.create(null, "Hey!"));
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("Message content type was null. Must use WebSocket.TEXT or WebSocket.BINARY.",
+          e.getMessage());
+    }
+  }
+
+  @Test public void unknownContentTypeThrows() throws IOException {
+    try {
+      client.sendMessage(RequestBody.create(MediaType.parse("text/plain"), "Hey!"));
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals(
+          "Unknown message content type: text/plain. Must use WebSocket.TEXT or WebSocket.BINARY.",
+          e.getMessage());
+    }
+  }
+
+  @Test public void streamingMessage() throws IOException {
+    RequestBody message = new RequestBody() {
+      @Override public MediaType contentType() {
+        return TEXT;
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        sink.writeUtf8("Hel").flush();
+        sink.writeUtf8("lo!").flush();
+        sink.close();
+      }
+    };
+    client.sendMessage(message);
+    server.readMessage();
+    serverListener.assertTextMessage("Hello!");
+  }
+
+  @Test public void streamingMessageCanInterleavePing() throws IOException, InterruptedException {
+    RequestBody message = new RequestBody() {
+      @Override public MediaType contentType() {
+        return TEXT;
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        sink.writeUtf8("Hel").flush();
+        client.sendPing(new Buffer().writeUtf8("Pong?"));
+        sink.writeUtf8("lo!").flush();
+        sink.close();
+      }
+    };
+
+    client.sendMessage(message);
+    server.readMessage();
+    serverListener.assertTextMessage("Hello!");
+    client.readMessage();
+    clientListener.assertPong(new Buffer().writeUtf8("Pong?"));
+  }
+
+  @Test public void pingWritesPong() throws IOException, InterruptedException {
+    client.sendPing(new Buffer().writeUtf8("Hello!"));
+    server.readMessage(); // Read the ping, write the pong.
+    client.readMessage(); // Read the pong.
+    clientListener.assertPong(new Buffer().writeUtf8("Hello!"));
+  }
+
+  @Test public void unsolicitedPong() throws IOException {
+    client.sendPong(new Buffer().writeUtf8("Hello!"));
+    server.readMessage();
+    serverListener.assertPong(new Buffer().writeUtf8("Hello!"));
+  }
+
+  @Test public void close() throws IOException {
+    client.close(1000, "Hello!");
+    assertFalse(server.readMessage()); // This will trigger a close response.
+    serverListener.assertClose(1000, "Hello!");
+    assertFalse(client.readMessage());
+    clientListener.assertClose(1000, "Hello!");
+  }
+
+  @Test public void clientCloseThenMethodsThrow() throws IOException {
+    client.close(1000, "Hello!");
+
+    try {
+      client.sendPing(new Buffer().writeUtf8("Pong?"));
+      fail();
+    } catch (IllegalStateException e) {
+      assertEquals("closed", e.getMessage());
+    }
+    try {
+      client.close(1000, "Hello!");
+      fail();
+    } catch (IllegalStateException e) {
+      assertEquals("closed", e.getMessage());
+    }
+    try {
+      client.sendMessage(RequestBody.create(TEXT, "Hello!"));
+      fail();
+    } catch (IllegalStateException e) {
+      assertEquals("closed", e.getMessage());
+    }
+  }
+
+  @Test public void socketClosedDuringPingKillsWebSocket() throws IOException {
+    client2Server.close();
+
+    try {
+      client.sendPing(new Buffer().writeUtf8("Ping!"));
+      fail();
+    } catch (IOException ignored) {
+    }
+
+    // A failed write prevents further use of the WebSocket instance.
+    try {
+      client.sendMessage(RequestBody.create(TEXT, "Hello!"));
+      fail();
+    } catch (IllegalStateException e) {
+      assertEquals("must call close()", e.getMessage());
+    }
+    try {
+      client.sendPing(new Buffer().writeUtf8("Ping!"));
+      fail();
+    } catch (IllegalStateException e) {
+      assertEquals("must call close()", e.getMessage());
+    }
+  }
+
+  @Test public void socketClosedDuringMessageKillsWebSocket() throws IOException {
+    client2Server.close();
+
+    try {
+      client.sendMessage(RequestBody.create(TEXT, "Hello!"));
+      fail();
+    } catch (IOException ignored) {
+    }
+
+    // A failed write prevents further use of the WebSocket instance.
+    try {
+      client.sendMessage(RequestBody.create(TEXT, "Hello!"));
+      fail();
+    } catch (IllegalStateException e) {
+      assertEquals("must call close()", e.getMessage());
+    }
+    try {
+      client.sendPing(new Buffer().writeUtf8("Ping!"));
+      fail();
+    } catch (IllegalStateException e) {
+      assertEquals("must call close()", e.getMessage());
+    }
+  }
+
+  @Test public void serverCloseThenWritingPingThrows() throws IOException {
+    server.close(1000, "Hello!");
+    client.readMessage();
+    clientListener.assertClose(1000, "Hello!");
+
+    try {
+      client.sendPing(new Buffer().writeUtf8("Pong?"));
+      fail();
+    } catch (IOException e) {
+      assertEquals("closed", e.getMessage());
+    }
+  }
+
+  @Test public void serverCloseThenWritingMessageThrows() throws IOException {
+    server.close(1000, "Hello!");
+    client.readMessage();
+    clientListener.assertClose(1000, "Hello!");
+
+    try {
+      client.sendMessage(RequestBody.create(TEXT, "Hi!"));
+      fail();
+    } catch (IOException e) {
+      assertEquals("closed", e.getMessage());
+    }
+  }
+
+  @Test public void serverCloseThenWritingCloseThrows() throws IOException {
+    server.close(1000, "Hello!");
+    client.readMessage();
+    clientListener.assertClose(1000, "Hello!");
+
+    try {
+      client.close(1000, "Bye!");
+      fail();
+    } catch (IOException e) {
+      assertEquals("closed", e.getMessage());
+    }
+  }
+
+  @Test public void serverCloseWhileWritingThrows() throws IOException {
+    RequestBody message = new RequestBody() {
+      @Override public MediaType contentType() {
+        return TEXT;
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        // Start writing data.
+        sink.writeUtf8("Hel").flush();
+
+        server.close(1000, "Hello!");
+        client.readMessage();
+        clientListener.assertClose(1000, "Hello!");
+
+        try {
+          sink.flush(); // No flushing.
+          fail();
+        } catch (IOException e) {
+          assertEquals("closed", e.getMessage());
+        }
+        try {
+          sink.close(); // No closing because this requires writing a frame.
+          fail();
+        } catch (IOException e) {
+          assertEquals("closed", e.getMessage());
+        }
+      }
+    };
+    client.sendMessage(message);
+  }
+
+  @Test public void clientCloseClosesConnection() throws IOException {
+    client.close(1000, "Hello!");
+    assertFalse(clientConnectionClosed);
+    server.readMessage(); // Read client close, send server close.
+    serverListener.assertClose(1000, "Hello!");
+
+    client.readMessage(); // Read server close, close connection.
+    assertTrue(clientConnectionClosed);
+    clientListener.assertClose(1000, "Hello!");
+  }
+
+  @Test public void serverCloseClosesConnection() throws IOException {
+    server.close(1000, "Hello!");
+
+    client.readMessage(); // Read server close, send client close, close connection.
+    assertTrue(clientConnectionClosed);
+    clientListener.assertClose(1000, "Hello!");
+
+    server.readMessage();
+    serverListener.assertClose(1000, "Hello!");
+  }
+
+  @Test public void clientAndServerCloseClosesConnection() throws IOException {
+    // Send close from both sides at the same time.
+    server.close(1000, "Hello!");
+    client.close(1000, "Hi!");
+    assertFalse(clientConnectionClosed);
+
+    client.readMessage(); // Read close, close connection close.
+    assertTrue(clientConnectionClosed);
+    clientListener.assertClose(1000, "Hello!");
+
+    server.readMessage();
+    serverListener.assertClose(1000, "Hi!");
+
+    serverListener.assertExhausted(); // Client should not have sent second close.
+    clientListener.assertExhausted(); // Server should not have sent second close.
+  }
+
+  @Test public void serverCloseBreaksReadMessageLoop() throws IOException {
+    server.sendMessage(RequestBody.create(TEXT, "Hello!"));
+    server.close(1000, "Bye!");
+    assertTrue(client.readMessage());
+    clientListener.assertTextMessage("Hello!");
+    assertFalse(client.readMessage());
+    clientListener.assertClose(1000, "Bye!");
+  }
+
+  @Test public void protocolErrorBeforeCloseSendsClose() throws IOException {
+    server2client.raw().write(ByteString.decodeHex("0a00")); // Invalid non-final ping frame.
+
+    client.readMessage(); // Detects error, send close, close connection.
+    assertTrue(clientConnectionClosed);
+    clientListener.assertFailure(ProtocolException.class, "Control frames must be final.");
+
+    server.readMessage();
+    serverListener.assertClose(1002, "");
+  }
+
+  @Test public void protocolErrorAfterCloseDoesNotSendClose() throws IOException {
+    client.close(1000, "Hello!");
+    assertFalse(clientConnectionClosed); // Not closed until close reply is received.
+    server2client.raw().write(ByteString.decodeHex("0a00")); // Invalid non-final ping frame.
+
+    client.readMessage(); // Detects error, closes connection immediately since close already sent.
+    assertTrue(clientConnectionClosed);
+    clientListener.assertFailure(ProtocolException.class, "Control frames must be final.");
+
+    server.readMessage();
+    serverListener.assertClose(1000, "Hello!");
+
+    serverListener.assertExhausted(); // Client should not have sent second close.
+  }
+
+  @Test public void closeThrowingClosesConnection() {
+    client2Server.close();
+
+    try {
+      client.close(1000, null);
+      fail();
+    } catch (IOException ignored) {
+    }
+    assertTrue(clientConnectionClosed);
+  }
+
+  @Test public void closeMessageAndConnectionCloseThrowingDoesNotMaskOriginal() throws IOException {
+    client2Server.close();
+    clientConnectionCloseThrows = true;
+
+    try {
+      client.close(1000, "Bye!");
+      fail();
+    } catch (IOException e) {
+      assertNotEquals("Oops!", e.getMessage());
+    }
+    assertTrue(clientConnectionClosed);
+  }
+
+  @Test public void peerConnectionCloseThrowingDoesNotPropagate() throws IOException {
+    clientConnectionCloseThrows = true;
+
+    server.close(1000, "Bye!");
+    client.readMessage();
+    assertTrue(clientConnectionClosed);
+    clientListener.assertClose(1000, "Bye!");
+
+    server.readMessage();
+    serverListener.assertClose(1000, "Bye!");
+  }
+
+  static final class MemorySocket implements Closeable {
+    private final Buffer buffer = new Buffer();
+    private boolean closed;
+
+    @Override public void close() {
+      closed = true;
+    }
+
+    Buffer raw() {
+      return buffer;
+    }
+
+    BufferedSource source() {
+      return Okio.buffer(new Source() {
+        @Override public long read(Buffer sink, long byteCount) throws IOException {
+          if (closed) throw new IOException("closed");
+          return buffer.read(sink, byteCount);
+        }
+
+        @Override public Timeout timeout() {
+          return Timeout.NONE;
+        }
+
+        @Override public void close() throws IOException {
+          closed = true;
+        }
+      });
+    }
+
+    BufferedSink sink() {
+      return Okio.buffer(new Sink() {
+        @Override public void write(Buffer source, long byteCount) throws IOException {
+          if (closed) throw new IOException("closed");
+          buffer.write(source, byteCount);
+        }
+
+        @Override public void flush() throws IOException {
+        }
+
+        @Override public Timeout timeout() {
+          return Timeout.NONE;
+        }
+
+        @Override public void close() throws IOException {
+          closed = true;
+        }
+      });
+    }
+  }
+
+  static final class SynchronousExecutor implements Executor {
+    @Override public void execute(Runnable command) {
+      command.run();
+    }
+  }
+}
diff --git a/okhttp-ws-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketReaderTest.java b/okhttp-ws-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
similarity index 79%
rename from okhttp-ws-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketReaderTest.java
rename to okhttp-ws-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
index 1674511a43..6bb7ef86d8 100644
--- a/okhttp-ws-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketReaderTest.java
+++ b/okhttp-ws-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
@@ -13,24 +13,27 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.ws;
+package okhttp3.internal.ws;
 
-import com.squareup.okhttp.ws.WebSocketRecorder;
 import java.io.EOFException;
 import java.io.IOException;
 import java.net.ProtocolException;
 import java.util.Random;
 import java.util.concurrent.atomic.AtomicReference;
+import java.util.regex.Pattern;
+import okhttp3.ResponseBody;
+import okhttp3.internal.Util;
+import okhttp3.ws.WebSocketRecorder;
+import okhttp3.ws.WebSocketRecorder.MessageDelegate;
 import okio.Buffer;
 import okio.BufferedSource;
 import okio.ByteString;
 import org.junit.After;
 import org.junit.Test;
 
-import static com.squareup.okhttp.ws.WebSocket.PayloadType;
-import static com.squareup.okhttp.ws.WebSocketRecorder.MessageDelegate;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 public final class WebSocketReaderTest {
@@ -151,11 +154,12 @@
 
     final Buffer sink = new Buffer();
     callback.setNextMessageDelegate(new MessageDelegate() {
-      @Override public void onMessage(BufferedSource payload, PayloadType type) throws IOException {
-        payload.readFully(sink, 3); // Read "Hel"
+      @Override public void onMessage(ResponseBody message) throws IOException {
+        BufferedSource source = message.source();
+        source.readFully(sink, 3); // Read "Hel"
         data.write(ByteString.decodeHex("5158")); // lo
-        payload.readFully(sink, 2); // Read "lo"
-        payload.close();
+        source.readFully(sink, 2); // Read "lo"
+        source.close();
       }
     });
     serverReader.processNextFrame();
@@ -251,8 +255,8 @@
   @Test public void noCloseErrors() throws IOException {
     data.write(ByteString.decodeHex("810548656c6c6f")); // Hello
     callback.setNextMessageDelegate(new MessageDelegate() {
-      @Override public void onMessage(BufferedSource payload, PayloadType type) throws IOException {
-        payload.readAll(new Buffer());
+      @Override public void onMessage(ResponseBody body) throws IOException {
+        body.source().readAll(new Buffer());
       }
     });
     try {
@@ -269,9 +273,9 @@
 
     final Buffer sink = new Buffer();
     callback.setNextMessageDelegate(new MessageDelegate() {
-      @Override public void onMessage(BufferedSource payload, PayloadType type) throws IOException {
-        payload.read(sink, 3);
-        payload.close();
+      @Override public void onMessage(ResponseBody message) throws IOException {
+        message.source().read(sink, 3);
+        message.close();
       }
     });
 
@@ -291,9 +295,9 @@
 
     final Buffer sink = new Buffer();
     callback.setNextMessageDelegate(new MessageDelegate() {
-      @Override public void onMessage(BufferedSource payload, PayloadType type) throws IOException {
-        payload.read(sink, 2);
-        payload.close();
+      @Override public void onMessage(ResponseBody message) throws IOException {
+        message.source().read(sink, 2);
+        message.close();
       }
     });
 
@@ -311,10 +315,10 @@
 
     final AtomicReference<Exception> exception = new AtomicReference<>();
     callback.setNextMessageDelegate(new MessageDelegate() {
-      @Override public void onMessage(BufferedSource payload, PayloadType type) throws IOException {
-        payload.close();
+      @Override public void onMessage(ResponseBody message) throws IOException {
+        message.close();
         try {
-          payload.readAll(new Buffer());
+          message.source().readAll(new Buffer());
           fail();
         } catch (IllegalStateException e) {
           exception.set(e);
@@ -341,7 +345,17 @@
   @Test public void emptyCloseCallsCallback() throws IOException {
     data.write(ByteString.decodeHex("8800")); // Empty close
     clientReader.processNextFrame();
-    callback.assertClose(0, "");
+    callback.assertClose(1000, "");
+  }
+
+  @Test public void closeLengthOfOneThrows() throws IOException {
+    data.write(ByteString.decodeHex("880100")); // Close with invalid 1-byte payload
+    try {
+      clientReader.processNextFrame();
+      fail();
+    } catch (ProtocolException e) {
+      assertEquals("Malformed close payload length of 1.", e.getMessage());
+    }
   }
 
   @Test public void closeCallsCallback() throws IOException {
@@ -350,6 +364,44 @@
     callback.assertClose(1000, "Hello");
   }
 
+  @Test public void closeOutOfRangeThrows() throws IOException {
+    data.write(ByteString.decodeHex("88020001")); // Close with code 1
+    try {
+      clientReader.processNextFrame();
+      fail();
+    } catch (ProtocolException e) {
+      assertEquals("Code must be in range [1000,5000): 1", e.getMessage());
+    }
+    data.write(ByteString.decodeHex("88021388")); // Close with code 5000
+    try {
+      clientReader.processNextFrame();
+      fail();
+    } catch (ProtocolException e) {
+      assertEquals("Code must be in range [1000,5000): 5000", e.getMessage());
+    }
+  }
+
+  @Test public void closeReservedSetThrows() throws IOException {
+    data.write(ByteString.decodeHex("880203ec")); // Close with code 1004
+    data.write(ByteString.decodeHex("880203ed")); // Close with code 1005
+    data.write(ByteString.decodeHex("880203ee")); // Close with code 1006
+    for (int i = 1012; i <= 2999; i++) {
+      data.write(ByteString.decodeHex("8802" + Util.format("%04X", i))); // Close with code 'i'
+    }
+
+    int count = 0;
+    for (; !data.exhausted(); count++) {
+      try {
+        clientReader.processNextFrame();
+        fail();
+      } catch (ProtocolException e) {
+        String message = e.getMessage();
+        assertTrue(message, Pattern.matches("Code \\d+ is reserved and may not be used.", message));
+      }
+    }
+    assertEquals(1991, count);
+  }
+
   private byte[] binaryData(int length) {
     byte[] junk = new byte[length];
     random.nextBytes(junk);
diff --git a/okhttp-ws-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java b/okhttp-ws-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java
new file mode 100644
index 0000000000..384151cf4a
--- /dev/null
+++ b/okhttp-ws-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java
@@ -0,0 +1,407 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.ws;
+
+import java.io.EOFException;
+import java.io.IOException;
+import java.util.Random;
+import okhttp3.RequestBody;
+import okhttp3.internal.Util;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.ByteString;
+import okio.Okio;
+import okio.Sink;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+
+import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_BINARY;
+import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_TEXT;
+import static okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_BYTE_MAX;
+import static okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_SHORT_MAX;
+import static okhttp3.internal.ws.WebSocketProtocol.toggleMask;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class WebSocketWriterTest {
+  private final Buffer data = new Buffer();
+  private final Random random = new Random(0);
+
+  /**
+   * Check all data as verified inside of the test. We do this in a rule instead of @After so that
+   * exceptions thrown from the test do not cause this check to fail.
+   */
+  @Rule public final TestRule noDataLeftBehind = new TestRule() {
+    @Override public Statement apply(final Statement base, Description description) {
+      return new Statement() {
+        @Override public void evaluate() throws Throwable {
+          base.evaluate();
+          assertEquals("Data not empty", "", data.readByteString().hex());
+        }
+      };
+    }
+  };
+
+  // Mutually exclusive. Use the one corresponding to the peer whose behavior you wish to test.
+  private final WebSocketWriter serverWriter = new WebSocketWriter(false, data, random);
+  private final WebSocketWriter clientWriter = new WebSocketWriter(true, data, random);
+
+  @Test public void serverTextMessage() throws IOException {
+    BufferedSink sink = Okio.buffer(serverWriter.newMessageSink(OPCODE_TEXT, -1));
+
+    sink.writeUtf8("Hel").flush();
+    assertData("010348656c");
+
+    sink.writeUtf8("lo").flush();
+    assertData("00026c6f");
+
+    sink.close();
+    assertData("8000");
+  }
+
+  @Test public void serverSmallBufferedPayloadWrittenAsOneFrame() throws IOException {
+    int length = 5;
+    byte[] bytes = binaryData(length);
+
+    RequestBody body = RequestBody.create(null, bytes);
+    BufferedSink sink = Okio.buffer(serverWriter.newMessageSink(OPCODE_TEXT, length));
+    body.writeTo(sink);
+    sink.close();
+
+    assertData("8105");
+    assertData(bytes);
+    assertTrue(data.exhausted());
+  }
+
+  @Test public void serverLargeBufferedPayloadWrittenAsOneFrame() throws IOException {
+    int length = 12345;
+    byte[] bytes = binaryData(length);
+
+    RequestBody body = RequestBody.create(null, bytes);
+    BufferedSink sink = Okio.buffer(serverWriter.newMessageSink(OPCODE_TEXT, length));
+    body.writeTo(sink);
+    sink.close();
+
+    assertData("817e");
+    assertData(Util.format("%04x", length));
+    assertData(bytes);
+    assertTrue(data.exhausted());
+  }
+
+  @Test public void serverLargeNonBufferedPayloadWrittenAsMultipleFrames() throws IOException {
+    int length = 100_000;
+    Buffer bytes = new Buffer().write(binaryData(length));
+
+    BufferedSink sink = Okio.buffer(serverWriter.newMessageSink(OPCODE_TEXT, length));
+    Buffer body = bytes.clone();
+    sink.write(body.readByteString(20_000));
+    sink.write(body.readByteString(20_000));
+    sink.write(body.readByteString(20_000));
+    sink.write(body.readByteString(20_000));
+    sink.write(body.readByteString(20_000));
+    sink.close();
+
+    assertData("017e4000");
+    assertData(bytes.readByteArray(16_384));
+    assertData("007e4000");
+    assertData(bytes.readByteArray(16_384));
+    assertData("007e6000");
+    assertData(bytes.readByteArray(24_576));
+    assertData("007e4000");
+    assertData(bytes.readByteArray(16_384));
+    assertData("007e6000");
+    assertData(bytes.readByteArray(24_576));
+    assertData("807e06a0");
+    assertData(bytes.readByteArray(1_696));
+    assertTrue(data.exhausted());
+  }
+
+  @Test public void closeFlushes() throws IOException {
+    BufferedSink sink = Okio.buffer(serverWriter.newMessageSink(OPCODE_TEXT, -1));
+
+    sink.writeUtf8("Hel").flush();
+    assertData("010348656c");
+
+    sink.writeUtf8("lo").close();
+    assertData("80026c6f");
+  }
+
+  @Test public void noWritesAfterClose() throws IOException {
+    Sink sink = serverWriter.newMessageSink(OPCODE_TEXT, -1);
+
+    sink.close();
+    assertData("8100");
+
+    Buffer payload = new Buffer().writeUtf8("Hello");
+    try {
+      // Write to the unbuffered sink as BufferedSink keeps its own closed state.
+      sink.write(payload, payload.size());
+      fail();
+    } catch (IOException e) {
+      assertEquals("closed", e.getMessage());
+    }
+  }
+
+  @Test public void clientTextMessage() throws IOException {
+    BufferedSink sink = Okio.buffer(clientWriter.newMessageSink(OPCODE_TEXT, -1));
+
+    sink.writeUtf8("Hel").flush();
+    assertData("018360b420bb28d14c");
+
+    sink.writeUtf8("lo").flush();
+    assertData("00823851d9d4543e");
+
+    sink.close();
+    assertData("80807acb933d");
+  }
+
+  @Test public void serverBinaryMessage() throws IOException {
+    BufferedSink sink = Okio.buffer(serverWriter.newMessageSink(OPCODE_BINARY, -1));
+
+    sink.write(binaryData(50)).flush();
+    assertData("0232");
+    assertData(binaryData(50));
+
+    sink.write(binaryData(50)).flush();
+    assertData("0032");
+    assertData(binaryData(50));
+
+    sink.close();
+    assertData("8000");
+  }
+
+  @Test public void serverMessageLengthShort() throws IOException {
+    Sink sink = serverWriter.newMessageSink(OPCODE_BINARY, -1);
+
+    // Create a payload which will overflow the normal payload byte size.
+    Buffer payload = new Buffer();
+    while (payload.completeSegmentByteCount() <= PAYLOAD_BYTE_MAX) {
+      payload.writeByte('0');
+    }
+    long byteCount = payload.completeSegmentByteCount();
+
+    // Write directly to the unbuffered sink. This ensures it will become single frame.
+    sink.write(payload.clone(), byteCount);
+    assertData("027e"); // 'e' == 4-byte follow-up length.
+    assertData(Util.format("%04X", payload.completeSegmentByteCount()));
+    assertData(payload.readByteArray());
+
+    sink.close();
+    assertData("8000");
+  }
+
+  @Test public void serverMessageLengthLong() throws IOException {
+    Sink sink = serverWriter.newMessageSink(OPCODE_BINARY, -1);
+
+    // Create a payload which will overflow the normal and short payload byte size.
+    Buffer payload = new Buffer();
+    while (payload.completeSegmentByteCount() <= PAYLOAD_SHORT_MAX) {
+      payload.writeByte('0');
+    }
+    long byteCount = payload.completeSegmentByteCount();
+
+    // Write directly to the unbuffered sink. This ensures it will become single frame.
+    sink.write(payload.clone(), byteCount);
+    assertData("027f"); // 'f' == 16-byte follow-up length.
+    assertData(Util.format("%016X", byteCount));
+    assertData(payload.readByteArray(byteCount));
+
+    sink.close();
+    assertData("8000");
+  }
+
+  @Test public void clientBinary() throws IOException {
+    byte[] maskKey1 = new byte[4];
+    random.nextBytes(maskKey1);
+    byte[] maskKey2 = new byte[4];
+    random.nextBytes(maskKey2);
+
+    random.setSeed(0); // Reset the seed so real data matches.
+
+    BufferedSink sink = Okio.buffer(clientWriter.newMessageSink(OPCODE_BINARY, -1));
+
+    byte[] part1 = binaryData(50);
+    sink.write(part1).flush();
+    toggleMask(part1, 50, maskKey1, 0);
+    assertData("02b2");
+    assertData(maskKey1);
+    assertData(part1);
+
+    byte[] part2 = binaryData(50);
+    sink.write(part2).close();
+    toggleMask(part2, 50, maskKey2, 0);
+    assertData("80b2");
+    assertData(maskKey2);
+    assertData(part2);
+  }
+
+  @Test public void serverEmptyClose() throws IOException {
+    serverWriter.writeClose(0, null);
+    assertData("8800");
+  }
+
+  @Test public void serverCloseWithCode() throws IOException {
+    serverWriter.writeClose(1001, null);
+    assertData("880203e9");
+  }
+
+  @Test public void serverCloseWithCodeAndReason() throws IOException {
+    serverWriter.writeClose(1001, "Hello");
+    assertData("880703e948656c6c6f");
+  }
+
+  @Test public void clientEmptyClose() throws IOException {
+    clientWriter.writeClose(0, null);
+    assertData("888060b420bb");
+  }
+
+  @Test public void clientCloseWithCode() throws IOException {
+    clientWriter.writeClose(1001, null);
+    assertData("888260b420bb635d");
+  }
+
+  @Test public void clientCloseWithCodeAndReason() throws IOException {
+    clientWriter.writeClose(1001, "Hello");
+    assertData("888760b420bb635d68de0cd84f");
+  }
+
+  @Test public void closeWithOnlyReasonThrows() throws IOException {
+    clientWriter.writeClose(0, "Hello");
+    assertData("888760b420bb60b468de0cd84f");
+  }
+
+  @Test public void closeCodeOutOfRangeThrows() throws IOException {
+    try {
+      clientWriter.writeClose(98724976, "Hello");
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("Code must be in range [1000,5000): 98724976", e.getMessage());
+    }
+  }
+
+  @Test public void closeReservedThrows() throws IOException {
+    try {
+      clientWriter.writeClose(1005, "Hello");
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("Code 1005 is reserved and may not be used.", e.getMessage());
+    }
+  }
+
+  @Test public void serverEmptyPing() throws IOException {
+    serverWriter.writePing(null);
+    assertData("8900");
+  }
+
+  @Test public void clientEmptyPing() throws IOException {
+    clientWriter.writePing(null);
+    assertData("898060b420bb");
+  }
+
+  @Test public void serverPingWithPayload() throws IOException {
+    serverWriter.writePing(new Buffer().writeUtf8("Hello"));
+    assertData("890548656c6c6f");
+  }
+
+  @Test public void clientPingWithPayload() throws IOException {
+    clientWriter.writePing(new Buffer().writeUtf8("Hello"));
+    assertData("898560b420bb28d14cd70f");
+  }
+
+  @Test public void serverEmptyPong() throws IOException {
+    serverWriter.writePong(null);
+    assertData("8a00");
+  }
+
+  @Test public void clientEmptyPong() throws IOException {
+    clientWriter.writePong(null);
+    assertData("8a8060b420bb");
+  }
+
+  @Test public void serverPongWithPayload() throws IOException {
+    serverWriter.writePong(new Buffer().writeUtf8("Hello"));
+    assertData("8a0548656c6c6f");
+  }
+
+  @Test public void clientPongWithPayload() throws IOException {
+    clientWriter.writePong(new Buffer().writeUtf8("Hello"));
+    assertData("8a8560b420bb28d14cd70f");
+  }
+
+  @Test public void pingTooLongThrows() throws IOException {
+    try {
+      serverWriter.writePing(new Buffer().write(binaryData(1000)));
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("Payload size must be less than or equal to 125", e.getMessage());
+    }
+  }
+
+  @Test public void pongTooLongThrows() throws IOException {
+    try {
+      serverWriter.writePong(new Buffer().write(binaryData(1000)));
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("Payload size must be less than or equal to 125", e.getMessage());
+    }
+  }
+
+  @Test public void closeTooLongThrows() throws IOException {
+    try {
+      String longString = ByteString.of(binaryData(75)).hex();
+      serverWriter.writeClose(1000, longString);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("Payload size must be less than or equal to 125", e.getMessage());
+    }
+  }
+
+  @Test public void twoMessageSinksThrows() {
+    clientWriter.newMessageSink(OPCODE_TEXT, -1);
+    try {
+      clientWriter.newMessageSink(OPCODE_TEXT, -1);
+      fail();
+    } catch (IllegalStateException e) {
+      assertEquals("Another message writer is active. Did you call close()?", e.getMessage());
+    }
+  }
+
+  private void assertData(String hex) throws EOFException {
+    ByteString expected = ByteString.decodeHex(hex);
+    ByteString actual = data.readByteString(expected.size());
+    assertEquals(expected, actual);
+  }
+
+  private void assertData(byte[] data) throws IOException {
+    int byteCount = 16;
+    for (int i = 0; i < data.length; i += byteCount) {
+      int count = Math.min(byteCount, data.length - i);
+      Buffer expectedChunk = new Buffer();
+      expectedChunk.write(data, i, count);
+      assertEquals("At " + i, expectedChunk.readByteString(), this.data.readByteString(count));
+    }
+  }
+
+  private static byte[] binaryData(int length) {
+    byte[] junk = new byte[length];
+    new Random(0).nextBytes(junk);
+    return junk;
+  }
+}
diff --git a/okhttp-ws-tests/src/test/java/com/squareup/okhttp/ws/WebSocketCallTest.java b/okhttp-ws-tests/src/test/java/okhttp3/ws/WebSocketCallTest.java
similarity index 65%
rename from okhttp-ws-tests/src/test/java/com/squareup/okhttp/ws/WebSocketCallTest.java
rename to okhttp-ws-tests/src/test/java/okhttp3/ws/WebSocketCallTest.java
index 63d21cb73f..06dd4a2e28 100644
--- a/okhttp-ws-tests/src/test/java/com/squareup/okhttp/ws/WebSocketCallTest.java
+++ b/okhttp-ws-tests/src/test/java/okhttp3/ws/WebSocketCallTest.java
@@ -13,34 +13,37 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.ws;
+package okhttp3.ws;
 
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
 import java.io.IOException;
 import java.net.ProtocolException;
 import java.util.Random;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicReference;
+import okhttp3.OkHttpClient;
+import okhttp3.RecordingHostnameVerifier;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+import okhttp3.internal.tls.SslClient;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
 import okio.Buffer;
-import okio.BufferedSink;
-import okio.BufferedSource;
 import org.junit.After;
 import org.junit.Rule;
 import org.junit.Test;
 
-import static com.squareup.okhttp.ws.WebSocket.PayloadType.TEXT;
+import static okhttp3.ws.WebSocket.TEXT;
 
 public final class WebSocketCallTest {
-  @Rule public final MockWebServerRule server = new MockWebServerRule();
+  @Rule public final MockWebServer server = new MockWebServer();
 
+  private final SslClient sslClient = SslClient.localhost();
   private final WebSocketRecorder listener = new WebSocketRecorder();
-  private final OkHttpClient client = new OkHttpClient();
   private final Random random = new Random(0);
+  private OkHttpClient client = new OkHttpClient();
 
   @After public void tearDown() {
     listener.assertExhausted();
@@ -60,15 +63,22 @@
     server.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
 
     WebSocket webSocket = awaitWebSocket();
-    webSocket.sendMessage(TEXT, new Buffer().writeUtf8("Hello, WebSockets!"));
+    webSocket.sendMessage(RequestBody.create(TEXT, "Hello, WebSockets!"));
     serverListener.assertTextMessage("Hello, WebSockets!");
   }
 
   @Test public void serverMessage() throws IOException {
     WebSocketListener serverListener = new EmptyWebSocketListener() {
-      @Override public void onOpen(WebSocket webSocket, Request request, Response response)
-          throws IOException {
-        webSocket.sendMessage(TEXT, new Buffer().writeUtf8("Hello, WebSockets!"));
+      @Override public void onOpen(final WebSocket webSocket, Response response) {
+        new Thread() {
+          @Override public void run() {
+            try {
+              webSocket.sendMessage(RequestBody.create(TEXT, "Hello, WebSockets!"));
+            } catch (IOException e) {
+              throw new AssertionError(e);
+            }
+          }
+        }.start();
       }
     };
     server.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
@@ -77,46 +87,29 @@
     listener.assertTextMessage("Hello, WebSockets!");
   }
 
-  @Test public void clientStreamingMessage() throws IOException {
-    WebSocketRecorder serverListener = new WebSocketRecorder();
-    server.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-
-    WebSocket webSocket = awaitWebSocket();
-    BufferedSink sink = webSocket.newMessageSink(TEXT);
-    sink.writeUtf8("Hello, ").flush();
-    sink.writeUtf8("WebSockets!").flush();
-    sink.close();
-
-    serverListener.assertTextMessage("Hello, WebSockets!");
-  }
-
-  @Test public void serverStreamingMessage() throws IOException {
-    WebSocketListener serverListener = new EmptyWebSocketListener() {
-      @Override public void onOpen(WebSocket webSocket, Request request, Response response)
-          throws IOException {
-        BufferedSink sink = webSocket.newMessageSink(TEXT);
-        sink.writeUtf8("Hello, ").flush();
-        sink.writeUtf8("WebSockets!").flush();
-        sink.close();
-      }
-    };
-    server.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-
-    awaitWebSocket();
-    listener.assertTextMessage("Hello, WebSockets!");
-  }
-
-  @Test public void okButNotOk() {
-    server.enqueue(new MockResponse());
+  @Test public void non101RetainsBody() throws IOException {
+    server.enqueue(new MockResponse().setResponseCode(200).setBody("Body"));
     awaitWebSocket();
     listener.assertFailure(ProtocolException.class, "Expected HTTP 101 response but was '200 OK'");
+    listener.assertResponse(200, "Body");
   }
 
-  @Test public void notFound() {
+  @Test public void notFound() throws IOException {
     server.enqueue(new MockResponse().setStatus("HTTP/1.1 404 Not Found"));
     awaitWebSocket();
     listener.assertFailure(ProtocolException.class,
         "Expected HTTP 101 response but was '404 Not Found'");
+    listener.assertResponse(404, "");
+  }
+
+  @Test public void clientTimeoutClosesBody() throws IOException {
+    server.enqueue(new MockResponse().setResponseCode(408));
+    WebSocketListener serverListener = new EmptyWebSocketListener();
+    server.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+
+    WebSocket webSocket = awaitWebSocket();
+    webSocket.sendPing(new Buffer().writeUtf8("WebSockets are fun!"));
+    listener.assertPong(new Buffer().writeUtf8("WebSockets are fun!"));
   }
 
   @Test public void missingConnectionHeader() {
@@ -130,7 +123,8 @@
   }
 
   @Test public void wrongConnectionHeader() {
-    server.enqueue(new MockResponse().setResponseCode(101)
+    server.enqueue(new MockResponse()
+        .setResponseCode(101)
         .setHeader("Upgrade", "websocket")
         .setHeader("Connection", "Downgrade")
         .setHeader("Sec-WebSocket-Accept", "ujmZX4KXZqjwy6vi1aQFH5p4Ygk="));
@@ -181,8 +175,52 @@
         "Expected 'Sec-WebSocket-Accept' header value 'ujmZX4KXZqjwy6vi1aQFH5p4Ygk=' but was 'magic'");
   }
 
+  @Test public void wsScheme() throws IOException {
+    websocketScheme("ws");
+  }
+
+  @Test public void wsUppercaseScheme() throws IOException {
+    websocketScheme("WS");
+  }
+
+  @Test public void wssScheme() throws IOException {
+    server.useHttps(sslClient.socketFactory, false);
+    client = client.newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build();
+
+    websocketScheme("wss");
+  }
+
+  @Test public void httpsScheme() throws IOException {
+    server.useHttps(sslClient.socketFactory, false);
+    client = client.newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build();
+
+    websocketScheme("https");
+  }
+
+  private void websocketScheme(String scheme) throws IOException {
+    WebSocketRecorder serverListener = new WebSocketRecorder();
+    server.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+
+    Request request1 = new Request.Builder()
+        .url(scheme + "://" + server.getHostName() + ":" + server.getPort() + "/")
+        .build();
+
+    WebSocket webSocket = awaitWebSocket(request1);
+    webSocket.sendMessage(RequestBody.create(TEXT, "abc"));
+    serverListener.assertTextMessage("abc");
+  }
+
   private WebSocket awaitWebSocket() {
-    Request request = new Request.Builder().get().url(server.getUrl("/")).build();
+    return awaitWebSocket(new Request.Builder().get().url(server.url("/")).build());
+  }
+
+  private WebSocket awaitWebSocket(Request request) {
     WebSocketCall call = new WebSocketCall(client, request, random);
 
     final AtomicReference<Response> responseRef = new AtomicReference<>();
@@ -190,16 +228,14 @@ private WebSocket awaitWebSocket() {
     final AtomicReference<IOException> failureRef = new AtomicReference<>();
     final CountDownLatch latch = new CountDownLatch(1);
     call.enqueue(new WebSocketListener() {
-      @Override public void onOpen(WebSocket webSocket, Request request, Response response)
-          throws IOException {
+      @Override public void onOpen(WebSocket webSocket, Response response) {
         webSocketRef.set(webSocket);
         responseRef.set(response);
         latch.countDown();
       }
 
-      @Override public void onMessage(BufferedSource payload, WebSocket.PayloadType type)
-          throws IOException {
-        listener.onMessage(payload, type);
+      @Override public void onMessage(ResponseBody message) throws IOException {
+        listener.onMessage(message);
       }
 
       @Override public void onPong(Buffer payload) {
@@ -210,8 +246,8 @@ private WebSocket awaitWebSocket() {
         listener.onClose(code, reason);
       }
 
-      @Override public void onFailure(IOException e) {
-        listener.onFailure(e);
+      @Override public void onFailure(IOException e, Response response) {
+        listener.onFailure(e, response);
         failureRef.set(e);
         latch.countDown();
       }
@@ -229,12 +265,10 @@ private WebSocket awaitWebSocket() {
   }
 
   private static class EmptyWebSocketListener implements WebSocketListener {
-    @Override public void onOpen(WebSocket webSocket, Request request, Response response)
-        throws IOException {
+    @Override public void onOpen(WebSocket webSocket, Response response) {
     }
 
-    @Override public void onMessage(BufferedSource payload, WebSocket.PayloadType type)
-        throws IOException {
+    @Override public void onMessage(ResponseBody message) throws IOException {
     }
 
     @Override public void onPong(Buffer payload) {
@@ -243,7 +277,7 @@ private WebSocket awaitWebSocket() {
     @Override public void onClose(int code, String reason) {
     }
 
-    @Override public void onFailure(IOException e) {
+    @Override public void onFailure(IOException e, Response response) {
     }
   }
 }
diff --git a/okhttp-ws-tests/src/test/java/com/squareup/okhttp/ws/WebSocketRecorder.java b/okhttp-ws-tests/src/test/java/okhttp3/ws/WebSocketRecorder.java
similarity index 66%
rename from okhttp-ws-tests/src/test/java/com/squareup/okhttp/ws/WebSocketRecorder.java
rename to okhttp-ws-tests/src/test/java/okhttp3/ws/WebSocketRecorder.java
index 551cd91660..485a4a1e88 100644
--- a/okhttp-ws-tests/src/test/java/com/squareup/okhttp/ws/WebSocketRecorder.java
+++ b/okhttp-ws-tests/src/test/java/okhttp3/ws/WebSocketRecorder.java
@@ -13,50 +13,50 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.ws;
+package okhttp3.ws;
 
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
-import com.squareup.okhttp.internal.ws.WebSocketReader;
 import java.io.IOException;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.TimeUnit;
+import okhttp3.MediaType;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+import okhttp3.internal.ws.WebSocketReader;
 import okio.Buffer;
-import okio.BufferedSource;
 
-import static com.squareup.okhttp.ws.WebSocket.PayloadType.BINARY;
-import static com.squareup.okhttp.ws.WebSocket.PayloadType.TEXT;
+import static okhttp3.ws.WebSocket.BINARY;
+import static okhttp3.ws.WebSocket.TEXT;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 
 public final class WebSocketRecorder implements WebSocketReader.FrameCallback, WebSocketListener {
   public interface MessageDelegate {
-    void onMessage(BufferedSource payload, WebSocket.PayloadType type) throws IOException;
+    void onMessage(ResponseBody message) throws IOException;
   }
 
   private final BlockingQueue<Object> events = new LinkedBlockingQueue<>();
   private MessageDelegate delegate;
+  private Response response;
 
   /** Sets a delegate for the next call to {@link #onMessage}. Cleared after invoked. */
   public void setNextMessageDelegate(MessageDelegate delegate) {
     this.delegate = delegate;
   }
 
-  @Override public void onOpen(WebSocket webSocket, Request request, Response response) {
+  @Override public void onOpen(WebSocket webSocket, Response response) {
   }
 
-  @Override public void onMessage(BufferedSource source, WebSocket.PayloadType type)
-      throws IOException {
+  @Override public void onMessage(ResponseBody message) throws IOException {
     if (delegate != null) {
-      delegate.onMessage(source, type);
+      delegate.onMessage(message);
       delegate = null;
     } else {
-      Message message = new Message(type);
-      source.readAll(message.buffer);
-      source.close();
-      events.add(message);
+      Message event = new Message(message.contentType());
+      message.source().readAll(event.buffer);
+      message.close();
+      events.add(event);
     }
   }
 
@@ -72,8 +72,9 @@ public void setNextMessageDelegate(MessageDelegate delegate) {
     events.add(new Close(code, reason));
   }
 
-  @Override public void onFailure(IOException e) {
+  @Override public void onFailure(IOException e, Response response) {
     events.add(e);
+    this.response = response;
   }
 
   private Object nextEvent() {
@@ -88,28 +89,48 @@ private Object nextEvent() {
     }
   }
 
-  public void assertTextMessage(String payload) {
+  public void assertTextMessage(String payload) throws IOException {
     Message message = new Message(TEXT);
     message.buffer.writeUtf8(payload);
-    assertEquals(message, nextEvent());
+    Object actual = nextEvent();
+    if (actual instanceof IOException) {
+      throw (IOException) actual;
+    }
+    assertEquals(message, actual);
   }
 
-  public void assertBinaryMessage(byte[] payload) {
+  public void assertBinaryMessage(byte[] payload) throws IOException {
     Message message = new Message(BINARY);
     message.buffer.write(payload);
-    assertEquals(message, nextEvent());
+    Object actual = nextEvent();
+    if (actual instanceof IOException) {
+      throw (IOException) actual;
+    }
+    assertEquals(message, actual);
   }
 
-  public void assertPing(Buffer payload) {
-    assertEquals(new Ping(payload), nextEvent());
+  public void assertPing(Buffer payload) throws IOException {
+    Object actual = nextEvent();
+    if (actual instanceof IOException) {
+      throw (IOException) actual;
+    }
+    assertEquals(new Ping(payload), actual);
   }
 
-  public void assertPong(Buffer payload) {
-    assertEquals(new Pong(payload), nextEvent());
+  public void assertPong(Buffer payload) throws IOException {
+    Object actual = nextEvent();
+    if (actual instanceof IOException) {
+      throw (IOException) actual;
+    }
+    assertEquals(new Pong(payload), actual);
   }
 
-  public void assertClose(int code, String reason) {
-      assertEquals(new Close(code, reason), nextEvent());
+  public void assertClose(int code, String reason) throws IOException {
+    Object actual = nextEvent();
+    if (actual instanceof IOException) {
+      throw (IOException) actual;
+    }
+    assertEquals(new Close(code, reason), actual);
   }
 
   public void assertFailure(Class<? extends IOException> cls, String message) {
@@ -125,26 +146,32 @@ public void assertExhausted() {
     assertTrue("Remaining events: " + events, events.isEmpty());
   }
 
+  public void assertResponse(int code, String body) throws IOException {
+    assertNotNull(response);
+    assertEquals(code, response.code());
+    assertEquals(body, response.body().string());
+  }
+
   private static class Message {
-    public final WebSocket.PayloadType type;
+    public final MediaType mediaType;
     public final Buffer buffer = new Buffer();
 
-    private Message(WebSocket.PayloadType type) {
-      this.type = type;
+    private Message(MediaType mediaType) {
+      this.mediaType = mediaType;
     }
 
     @Override public String toString() {
-      return "Message[" + type + " " + buffer + "]";
+      return "Message[" + mediaType + " " + buffer + "]";
     }
 
     @Override public int hashCode() {
-      return type.hashCode() * 37 + buffer.hashCode();
+      return mediaType.hashCode() * 37 + buffer.hashCode();
     }
 
     @Override public boolean equals(Object obj) {
       if (obj instanceof Message) {
         Message other = (Message) obj;
-        return type == other.type && buffer.equals(other.buffer);
+        return mediaType.equals(other.mediaType) && buffer.equals(other.buffer);
       }
       return false;
     }
diff --git a/okhttp-ws/pom.xml b/okhttp-ws/pom.xml
index ae34464dd3..7cbfab9e5b 100644
--- a/okhttp-ws/pom.xml
+++ b/okhttp-ws/pom.xml
@@ -4,9 +4,9 @@
   <modelVersion>4.0.0</modelVersion>
 
   <parent>
-    <groupId>com.squareup.okhttp</groupId>
+    <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>2.4.0-SNAPSHOT</version>
+    <version>3.4.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-ws</artifactId>
@@ -14,7 +14,7 @@
 
   <dependencies>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>${project.groupId}</groupId>
       <artifactId>okhttp</artifactId>
       <version>${project.version}</version>
     </dependency>
@@ -26,7 +26,7 @@
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-javadoc-plugin</artifactId>
         <configuration>
-          <excludePackageNames>com.squareup.okhttp.internal.*</excludePackageNames>
+          <excludePackageNames>okhttp3.internal.*</excludePackageNames>
           <links>
             <link>http://square.github.io/okhttp/javadoc/</link>
           </links>
diff --git a/okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/WebSocketWriter.java b/okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/WebSocketWriter.java
deleted file mode 100644
index 74bd083269..0000000000
--- a/okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/WebSocketWriter.java
+++ /dev/null
@@ -1,294 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal.ws;
-
-import java.io.IOException;
-import java.util.Random;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.Okio;
-import okio.Sink;
-import okio.Timeout;
-
-import static com.squareup.okhttp.ws.WebSocket.PayloadType;
-import static com.squareup.okhttp.internal.ws.WebSocketProtocol.B0_FLAG_FIN;
-import static com.squareup.okhttp.internal.ws.WebSocketProtocol.B1_FLAG_MASK;
-import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_BINARY;
-import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_CONTINUATION;
-import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_CONTROL_CLOSE;
-import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_CONTROL_PING;
-import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_CONTROL_PONG;
-import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_TEXT;
-import static com.squareup.okhttp.internal.ws.WebSocketProtocol.PAYLOAD_LONG;
-import static com.squareup.okhttp.internal.ws.WebSocketProtocol.PAYLOAD_MAX;
-import static com.squareup.okhttp.internal.ws.WebSocketProtocol.PAYLOAD_SHORT;
-import static com.squareup.okhttp.internal.ws.WebSocketProtocol.toggleMask;
-
-/**
- * An <a href="http://tools.ietf.org/html/rfc6455">RFC 6455</a>-compatible WebSocket frame writer.
- * <p>
- * This class is partially thread safe. Only a single "main" thread should be sending messages via
- * calls to {@link #newMessageSink} or {@link #sendMessage} as well as any calls to
- * {@link #writePing} or {@link #writeClose}. Other threads may call {@link #writePing},
- * {@link #writePong}, or {@link #writeClose} which will interleave on the wire with frames from
- * the main thread.
- */
-public final class WebSocketWriter {
-  private final boolean isClient;
-  /** Writes must be guarded by synchronizing on this instance! */
-  private final BufferedSink sink;
-  private final Random random;
-
-  private final FrameSink frameSink = new FrameSink();
-
-  private boolean closed;
-  private boolean activeWriter;
-
-  private final byte[] maskKey;
-  private final byte[] maskBuffer;
-
-  public WebSocketWriter(boolean isClient, BufferedSink sink, Random random) {
-    if (sink == null) throw new NullPointerException("sink == null");
-    if (random == null) throw new NullPointerException("random == null");
-    this.isClient = isClient;
-    this.sink = sink;
-    this.random = random;
-
-    // Masks are only a concern for client writers.
-    maskKey = isClient ? new byte[4] : null;
-    maskBuffer = isClient ? new byte[2048] : null;
-  }
-
-  /** Send a ping with the supplied {@code payload}. Payload may be {@code null} */
-  public void writePing(Buffer payload) throws IOException {
-    synchronized (sink) {
-      writeControlFrame(OPCODE_CONTROL_PING, payload);
-    }
-  }
-
-  /** Send a pong with the supplied {@code payload}. Payload may be {@code null} */
-  public void writePong(Buffer payload) throws IOException {
-    synchronized (sink) {
-      writeControlFrame(OPCODE_CONTROL_PONG, payload);
-    }
-  }
-
-  /**
-   * Send a close frame with optional code and reason.
-   *
-   * @param code Status code as defined by
-   * <a href="http://tools.ietf.org/html/rfc6455#section-7.4">Section 7.4 of RFC 6455</a> or
-   * {@code 0}.
-   * @param reason Reason for shutting down or {@code null}. {@code code} is required if set.
-   */
-  public void writeClose(int code, String reason) throws IOException {
-    Buffer payload = null;
-    if (code != 0) {
-      if (code < 1000 || code >= 5000) {
-        throw new IllegalArgumentException("Code must be in range [1000,5000).");
-      }
-      payload = new Buffer();
-      payload.writeShort(code);
-      if (reason != null) {
-        payload.writeUtf8(reason);
-      }
-    } else if (reason != null) {
-      throw new IllegalArgumentException("Code required to include reason.");
-    }
-
-    synchronized (sink) {
-      writeControlFrame(OPCODE_CONTROL_CLOSE, payload);
-      closed = true;
-    }
-  }
-
-  private void writeControlFrame(int opcode, Buffer payload) throws IOException {
-    if (closed) throw new IOException("closed");
-
-    int length = 0;
-    if (payload != null) {
-      length = (int) payload.size();
-      if (length > PAYLOAD_MAX) {
-        throw new IllegalArgumentException(
-            "Payload size must be less than or equal to " + PAYLOAD_MAX);
-      }
-    }
-
-    int b0 = B0_FLAG_FIN | opcode;
-    sink.writeByte(b0);
-
-    int b1 = length;
-    if (isClient) {
-      b1 |= B1_FLAG_MASK;
-      sink.writeByte(b1);
-
-      random.nextBytes(maskKey);
-      sink.write(maskKey);
-
-      if (payload != null) {
-        writeAllMasked(payload, length);
-      }
-    } else {
-      sink.writeByte(b1);
-
-      if (payload != null) {
-        sink.writeAll(payload);
-      }
-    }
-
-    sink.flush();
-  }
-
-  /**
-   * Stream a message payload as a series of frames. This allows control frames to be interleaved
-   * between parts of the message.
-   */
-  public BufferedSink newMessageSink(PayloadType type) {
-    if (type == null) throw new NullPointerException("type == null");
-    if (activeWriter) {
-      throw new IllegalStateException("Another message writer is active. Did you call close()?");
-    }
-    activeWriter = true;
-
-    frameSink.payloadType = type;
-    frameSink.isFirstFrame = true;
-    return Okio.buffer(frameSink);
-  }
-
-  /**
-   * Send a message payload as a single frame. This will block any control frames that need sent
-   * until it is completed.
-   */
-  public void sendMessage(PayloadType type, Buffer payload) throws IOException {
-    if (type == null) throw new NullPointerException("type == null");
-    if (payload == null) throw new NullPointerException("payload == null");
-    if (activeWriter) {
-      throw new IllegalStateException("A message writer is active. Did you call close()?");
-    }
-    writeFrame(type, payload, payload.size(), true /* first frame */, true /* final */);
-  }
-
-  private void writeFrame(PayloadType payloadType, Buffer source, long byteCount,
-      boolean isFirstFrame, boolean isFinal) throws IOException {
-    if (closed) throw new IOException("closed");
-
-    int opcode = OPCODE_CONTINUATION;
-    if (isFirstFrame) {
-      switch (payloadType) {
-        case TEXT:
-          opcode = OPCODE_TEXT;
-          break;
-        case BINARY:
-          opcode = OPCODE_BINARY;
-          break;
-        default:
-          throw new IllegalStateException("Unknown payload type: " + payloadType);
-      }
-    }
-
-    synchronized (sink) {
-      int b0 = opcode;
-      if (isFinal) {
-        b0 |= B0_FLAG_FIN;
-      }
-      sink.writeByte(b0);
-
-      int b1 = 0;
-      if (isClient) {
-        b1 |= B1_FLAG_MASK;
-        random.nextBytes(maskKey);
-      }
-      if (byteCount <= PAYLOAD_MAX) {
-        b1 |= (int) byteCount;
-        sink.writeByte(b1);
-      } else if (byteCount <= 0xffffL) { // Unsigned short.
-        b1 |= PAYLOAD_SHORT;
-        sink.writeByte(b1);
-        sink.writeShort((int) byteCount);
-      } else {
-        b1 |= PAYLOAD_LONG;
-        sink.writeByte(b1);
-        sink.writeLong(byteCount);
-      }
-
-      if (isClient) {
-        sink.write(maskKey);
-        writeAllMasked(source, byteCount);
-      } else {
-        sink.write(source, byteCount);
-      }
-
-      sink.flush();
-    }
-  }
-
-  private void writeAllMasked(BufferedSource source, long byteCount) throws IOException {
-    long written = 0;
-    while (written < byteCount) {
-      int toRead = (int) Math.min(byteCount, maskBuffer.length);
-      int read = source.read(maskBuffer, 0, toRead);
-      if (read == -1) throw new AssertionError();
-      toggleMask(maskBuffer, read, maskKey, written);
-      sink.write(maskBuffer, 0, read);
-      written += read;
-    }
-  }
-
-  private final class FrameSink implements Sink {
-    private PayloadType payloadType;
-    private boolean isFirstFrame;
-
-    @Override public void write(Buffer source, long byteCount) throws IOException {
-      writeFrame(payloadType, source, byteCount, isFirstFrame, false /* final */);
-      isFirstFrame = false;
-    }
-
-    @Override public void flush() throws IOException {
-      if (closed) throw new IOException("closed");
-
-      synchronized (sink) {
-        sink.flush();
-      }
-    }
-
-    @Override public Timeout timeout() {
-      return sink.timeout();
-    }
-
-    @SuppressWarnings("PointlessBitwiseExpression")
-    @Override public void close() throws IOException {
-      if (closed) throw new IOException("closed");
-
-      int length = 0;
-
-      synchronized (sink) {
-        sink.writeByte(B0_FLAG_FIN | OPCODE_CONTINUATION);
-
-        if (isClient) {
-          sink.writeByte(B1_FLAG_MASK | length);
-          random.nextBytes(maskKey);
-          sink.write(maskKey);
-        } else {
-          sink.writeByte(length);
-        }
-        sink.flush();
-      }
-
-      activeWriter = false;
-    }
-  }
-}
diff --git a/okhttp-ws/src/main/java/com/squareup/okhttp/ws/WebSocket.java b/okhttp-ws/src/main/java/com/squareup/okhttp/ws/WebSocket.java
deleted file mode 100644
index 4cf2f42d6f..0000000000
--- a/okhttp-ws/src/main/java/com/squareup/okhttp/ws/WebSocket.java
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.ws;
-
-import java.io.IOException;
-import okio.Buffer;
-import okio.BufferedSink;
-
-/** Blocking interface to connect and write to a web socket. */
-public interface WebSocket {
-  /** The format of a message payload. */
-  enum PayloadType {
-    /** UTF8-encoded text data. */
-    TEXT,
-    /** Arbitrary binary data. */
-    BINARY
-  }
-
-  /**
-   * Stream a message payload to the server of the specified {code type}.
-   * <p>
-   * You must call {@link BufferedSink#close() close()} to complete the message. Calls to
-   * {@link BufferedSink#flush() flush()} write a frame fragment. The message may be empty.
-   *
-   * @throws IllegalStateException if not connected, already closed, or another writer is active.
-   */
-  BufferedSink newMessageSink(WebSocket.PayloadType type);
-
-  /**
-   * Send a message payload to the server of the specified {@code type}.
-   *
-   * @throws IllegalStateException if not connected, already closed, or another writer is active.
-   */
-  void sendMessage(WebSocket.PayloadType type, Buffer payload) throws IOException;
-
-  /**
-   * Send a ping to the server with optional payload.
-   *
-   * @throws IllegalStateException if already closed.
-   */
-  void sendPing(Buffer payload) throws IOException;
-
-  /**
-   * Send a close frame to the server.
-   * <p>
-   * The corresponding {@link WebSocketListener} will continue to get messages until its
-   * {@link WebSocketListener#onClose onClose()} method is called.
-   * <p>
-   * It is an error to call this method before calling close on an active writer. Calling this
-   * method more than once has no effect.
-   *
-   * @throws IllegalStateException if already closed.
-   */
-  void close(int code, String reason) throws IOException;
-}
diff --git a/okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/RealWebSocket.java b/okhttp-ws/src/main/java/okhttp3/internal/ws/RealWebSocket.java
similarity index 50%
rename from okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/RealWebSocket.java
rename to okhttp-ws/src/main/java/okhttp3/internal/ws/RealWebSocket.java
index a647ac7040..b9af6bdd65 100644
--- a/okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/RealWebSocket.java
+++ b/okhttp-ws/src/main/java/okhttp3/internal/ws/RealWebSocket.java
@@ -13,23 +13,29 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.ws;
+package okhttp3.internal.ws;
 
-import com.squareup.okhttp.internal.NamedRunnable;
-import com.squareup.okhttp.ws.WebSocket;
-import com.squareup.okhttp.ws.WebSocketListener;
 import java.io.IOException;
 import java.net.ProtocolException;
 import java.util.Random;
 import java.util.concurrent.Executor;
+import java.util.concurrent.atomic.AtomicBoolean;
+import okhttp3.MediaType;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import okhttp3.internal.NamedRunnable;
+import okhttp3.ws.WebSocket;
+import okhttp3.ws.WebSocketListener;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
+import okio.Okio;
 
-import static com.squareup.okhttp.internal.ws.WebSocketReader.FrameCallback;
+import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_BINARY;
+import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_TEXT;
+import static okhttp3.internal.ws.WebSocketReader.FrameCallback;
 
 public abstract class RealWebSocket implements WebSocket {
-  /** A close code which indicates that the peer encountered a protocol exception. */
   private static final int CLOSE_PROTOCOL_EXCEPTION = 1002;
 
   private final WebSocketWriter writer;
@@ -38,10 +44,13 @@
 
   /** True after calling {@link #close(int, String)}. No writes are allowed afterward. */
   private volatile boolean writerSentClose;
+  /** True after {@link IOException}. {@link #close(int, String)} becomes only valid call. */
+  private boolean writerWantsClose;
   /** True after a close frame was read by the reader. No frames will follow it. */
-  private volatile boolean readerSentClose;
-  /** Lock required to negotiate closing the connection. */
-  private final Object closeLock = new Object();
+  private boolean readerSentClose;
+
+  /** True after calling {@link #close()} to free connection resources. */
+  private final AtomicBoolean connectionClosed = new AtomicBoolean();
 
   public RealWebSocket(boolean isClient, BufferedSource source, BufferedSink sink, Random random,
       final Executor replyExecutor, final WebSocketListener listener, final String url) {
@@ -49,8 +58,8 @@ public RealWebSocket(boolean isClient, BufferedSource source, BufferedSink sink,
 
     writer = new WebSocketWriter(isClient, sink, random);
     reader = new WebSocketReader(isClient, source, new FrameCallback() {
-      @Override public void onMessage(BufferedSource source, PayloadType type) throws IOException {
-        listener.onMessage(source, type);
+      @Override public void onMessage(ResponseBody message) throws IOException {
+        listener.onMessage(message);
       }
 
       @Override public void onPing(final Buffer buffer) {
@@ -69,6 +78,7 @@ public RealWebSocket(boolean isClient, BufferedSource source, BufferedSink sink,
       }
 
       @Override public void onClose(final int code, final String reason) {
+        readerSentClose = true;
         replyExecutor.execute(new NamedRunnable("OkHttp %s WebSocket Close Reply", url) {
           @Override protected void execute() {
             peerClose(code, reason);
@@ -79,8 +89,8 @@ public RealWebSocket(boolean isClient, BufferedSource source, BufferedSink sink,
   }
 
   /**
-   * Read a single message from the web socket and deliver it to the listener. This method should
-   * be called in a loop with the return value indicating whether looping should continue.
+   * Read a single message from the web socket and deliver it to the listener. This method should be
+   * called in a loop with the return value indicating whether looping should continue.
    */
   public boolean readMessage() {
     try {
@@ -92,65 +102,96 @@ public boolean readMessage() {
     }
   }
 
-  @Override public BufferedSink newMessageSink(PayloadType type) {
+  @Override public void sendMessage(RequestBody message) throws IOException {
+    if (message == null) throw new NullPointerException("message == null");
     if (writerSentClose) throw new IllegalStateException("closed");
-    return writer.newMessageSink(type);
-  }
+    if (writerWantsClose) throw new IllegalStateException("must call close()");
 
-  @Override public void sendMessage(PayloadType type, Buffer payload) throws IOException {
-    if (writerSentClose) throw new IllegalStateException("closed");
-    writer.sendMessage(type, payload);
+    MediaType contentType = message.contentType();
+    if (contentType == null) {
+      throw new IllegalArgumentException(
+          "Message content type was null. Must use WebSocket.TEXT or WebSocket.BINARY.");
+    }
+    String contentSubtype = contentType.subtype();
+
+    int formatOpcode;
+    if (WebSocket.TEXT.subtype().equals(contentSubtype)) {
+      formatOpcode = OPCODE_TEXT;
+    } else if (WebSocket.BINARY.subtype().equals(contentSubtype)) {
+      formatOpcode = OPCODE_BINARY;
+    } else {
+      throw new IllegalArgumentException("Unknown message content type: "
+          + contentType.type() + "/" + contentType.subtype() // Omit any implicitly added charset.
+          + ". Must use WebSocket.TEXT or WebSocket.BINARY.");
+    }
+
+    BufferedSink sink = Okio.buffer(writer.newMessageSink(formatOpcode, message.contentLength()));
+    try {
+      message.writeTo(sink);
+      sink.close();
+    } catch (IOException e) {
+      writerWantsClose = true;
+      throw e;
+    }
   }
 
   @Override public void sendPing(Buffer payload) throws IOException {
     if (writerSentClose) throw new IllegalStateException("closed");
-    writer.writePing(payload);
+    if (writerWantsClose) throw new IllegalStateException("must call close()");
+
+    try {
+      writer.writePing(payload);
+    } catch (IOException e) {
+      writerWantsClose = true;
+      throw e;
+    }
   }
 
   /** Send an unsolicited pong with the specified payload. */
   public void sendPong(Buffer payload) throws IOException {
     if (writerSentClose) throw new IllegalStateException("closed");
-    writer.writePong(payload);
+    if (writerWantsClose) throw new IllegalStateException("must call close()");
+
+    try {
+      writer.writePong(payload);
+    } catch (IOException e) {
+      writerWantsClose = true;
+      throw e;
+    }
   }
 
   @Override public void close(int code, String reason) throws IOException {
     if (writerSentClose) throw new IllegalStateException("closed");
+    writerSentClose = true;
 
-    boolean closeConnection;
-    synchronized (closeLock) {
-      writerSentClose = true;
-
-      // If the reader has also indicated a desire to close we will close the connection.
-      closeConnection = readerSentClose;
-    }
-
-    writer.writeClose(code, reason);
-
-    if (closeConnection) {
-      closeConnection();
+    try {
+      writer.writeClose(code, reason);
+    } catch (IOException e) {
+      if (connectionClosed.compareAndSet(false, true)) {
+        // Try to close the connection without masking the original exception.
+        try {
+          close();
+        } catch (IOException ignored) {
+        }
+      }
+      throw e;
     }
   }
 
   /** Replies and closes this web socket when a close frame is read from the peer. */
   private void peerClose(int code, String reason) {
-    boolean writeCloseResponse;
-    synchronized (closeLock) {
-      readerSentClose = true;
-
-      // If the writer has not indicated a desire to close we will write a close response.
-      writeCloseResponse = !writerSentClose;
-    }
-
-    if (writeCloseResponse) {
+    if (!writerSentClose) {
       try {
         writer.writeClose(code, reason);
       } catch (IOException ignored) {
       }
     }
 
-    try {
-      closeConnection();
-    } catch (IOException ignored) {
+    if (connectionClosed.compareAndSet(false, true)) {
+      try {
+        close();
+      } catch (IOException ignored) {
+      }
     }
 
     listener.onClose(code, reason);
@@ -158,32 +199,24 @@ private void peerClose(int code, String reason) {
 
   /** Called on the reader thread when an error occurs. */
   private void readerErrorClose(IOException e) {
-    boolean writeCloseResponse;
-    synchronized (closeLock) {
-      readerSentClose = true;
-
-      // If the writer has not closed we will close the connection.
-      writeCloseResponse = !writerSentClose;
-    }
-
-    if (writeCloseResponse) {
-      if (e instanceof ProtocolException) {
-        // For protocol exceptions, try to inform the server of such.
-        try {
-          writer.writeClose(CLOSE_PROTOCOL_EXCEPTION, null);
-        } catch (IOException ignored) {
-        }
+    // For protocol exceptions, try to inform the server of such.
+    if (!writerSentClose && e instanceof ProtocolException) {
+      try {
+        writer.writeClose(CLOSE_PROTOCOL_EXCEPTION, null);
+      } catch (IOException ignored) {
       }
     }
 
-    try {
-      closeConnection();
-    } catch (IOException ignored) {
+    if (connectionClosed.compareAndSet(false, true)) {
+      try {
+        close();
+      } catch (IOException ignored) {
+      }
     }
 
-    listener.onFailure(e);
+    listener.onFailure(e, null);
   }
 
-  /** Perform any tear-down work on the connection (close the socket, recycle, etc.). */
-  protected abstract void closeConnection() throws IOException;
+  /** Perform any tear-down work (close the connection, shutdown executors). */
+  protected abstract void close() throws IOException;
 }
diff --git a/okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/WebSocketProtocol.java b/okhttp-ws/src/main/java/okhttp3/internal/ws/WebSocketProtocol.java
similarity index 69%
rename from okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/WebSocketProtocol.java
rename to okhttp-ws/src/main/java/okhttp3/internal/ws/WebSocketProtocol.java
index 2b93398fa5..0a1126a147 100644
--- a/okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/WebSocketProtocol.java
+++ b/okhttp-ws/src/main/java/okhttp3/internal/ws/WebSocketProtocol.java
@@ -13,7 +13,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.ws;
+package okhttp3.internal.ws;
+
+import java.net.ProtocolException;
 
 public final class WebSocketProtocol {
   /** Magic value which must be appended to the key in a response header. */
@@ -45,17 +47,15 @@
   static final int OPCODE_FLAG_CONTROL = 0b00001000;
 
   /**
-   * Byte 1 flag for whether the payload data is masked.
-   * <p>
-   * If this flag is set, the next four bytes represent the mask key. These bytes appear after
-   * any additional bytes specified by {@link #B1_MASK_LENGTH}.
+   * Byte 1 flag for whether the payload data is masked. <p> If this flag is set, the next four
+   * bytes represent the mask key. These bytes appear after any additional bytes specified by {@link
+   * #B1_MASK_LENGTH}.
    */
   static final int B1_FLAG_MASK = 0b10000000;
   /**
-   * Byte 1 mask for the payload length.
-   * <p>
-   * If this value is {@link #PAYLOAD_SHORT}, the next two bytes represent the length.
-   * If this value is {@link #PAYLOAD_LONG}, the next eight bytes represent the length.
+   * Byte 1 mask for the payload length. <p> If this value is {@link #PAYLOAD_SHORT}, the next two
+   * bytes represent the length. If this value is {@link #PAYLOAD_LONG}, the next eight bytes
+   * represent the length.
    */
   static final int B1_MASK_LENGTH = 0b01111111;
 
@@ -68,14 +68,16 @@
   static final int OPCODE_CONTROL_PONG = 0xa;
 
   /**
-   * Maximum length of frame payload. Larger payloads, if supported, can use the special values
-   * {@link #PAYLOAD_SHORT} or {@link #PAYLOAD_LONG}.
+   * Maximum length of frame payload. Larger payloads, if supported by the frame type, can use the
+   * special values {@link #PAYLOAD_SHORT} or {@link #PAYLOAD_LONG}.
    */
-  static final int PAYLOAD_MAX = 125;
+  static final long PAYLOAD_BYTE_MAX = 125L;
   /**
    * Value for {@link #B1_MASK_LENGTH} which indicates the next two bytes are the unsigned length.
    */
   static final int PAYLOAD_SHORT = 126;
+  /** Maximum length of a frame payload to be denoted as {@link #PAYLOAD_SHORT}. */
+  static final long PAYLOAD_SHORT_MAX = 0xffffL;
   /**
    * Value for {@link #B1_MASK_LENGTH} which indicates the next eight bytes are the unsigned
    * length.
@@ -90,6 +92,21 @@ static void toggleMask(byte[] buffer, long byteCount, byte[] key, long frameByte
     }
   }
 
+  static void validateCloseCode(int code, boolean argument) throws ProtocolException {
+    String message = null;
+    if (code < 1000 || code >= 5000) {
+      message = "Code must be in range [1000,5000): " + code;
+    } else if ((code >= 1004 && code <= 1006) || (code >= 1012 && code <= 2999)) {
+      message = "Code " + code + " is reserved and may not be used.";
+    }
+    if (message != null) {
+      if (argument) {
+        throw new IllegalArgumentException(message);
+      }
+      throw new ProtocolException(message);
+    }
+  }
+
   private WebSocketProtocol() {
     throw new AssertionError("No instances.");
   }
diff --git a/okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/WebSocketReader.java b/okhttp-ws/src/main/java/okhttp3/internal/ws/WebSocketReader.java
similarity index 72%
rename from okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/WebSocketReader.java
rename to okhttp-ws/src/main/java/okhttp3/internal/ws/WebSocketReader.java
index ee4e482f62..8be28a2c5a 100644
--- a/okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/WebSocketReader.java
+++ b/okhttp-ws/src/main/java/okhttp3/internal/ws/WebSocketReader.java
@@ -13,46 +13,52 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.ws;
+package okhttp3.internal.ws;
 
 import java.io.EOFException;
 import java.io.IOException;
 import java.net.ProtocolException;
+import okhttp3.MediaType;
+import okhttp3.ResponseBody;
+import okhttp3.ws.WebSocket;
 import okio.Buffer;
 import okio.BufferedSource;
 import okio.Okio;
 import okio.Source;
 import okio.Timeout;
 
-import static com.squareup.okhttp.ws.WebSocket.PayloadType;
-import static com.squareup.okhttp.internal.ws.WebSocketProtocol.B0_FLAG_FIN;
-import static com.squareup.okhttp.internal.ws.WebSocketProtocol.B0_FLAG_RSV1;
-import static com.squareup.okhttp.internal.ws.WebSocketProtocol.B0_FLAG_RSV2;
-import static com.squareup.okhttp.internal.ws.WebSocketProtocol.B0_FLAG_RSV3;
-import static com.squareup.okhttp.internal.ws.WebSocketProtocol.B0_MASK_OPCODE;
-import static com.squareup.okhttp.internal.ws.WebSocketProtocol.B1_FLAG_MASK;
-import static com.squareup.okhttp.internal.ws.WebSocketProtocol.B1_MASK_LENGTH;
-import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_BINARY;
-import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_CONTINUATION;
-import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_CONTROL_CLOSE;
-import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_CONTROL_PING;
-import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_CONTROL_PONG;
-import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_FLAG_CONTROL;
-import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_TEXT;
-import static com.squareup.okhttp.internal.ws.WebSocketProtocol.PAYLOAD_LONG;
-import static com.squareup.okhttp.internal.ws.WebSocketProtocol.PAYLOAD_MAX;
-import static com.squareup.okhttp.internal.ws.WebSocketProtocol.PAYLOAD_SHORT;
-import static com.squareup.okhttp.internal.ws.WebSocketProtocol.toggleMask;
 import static java.lang.Integer.toHexString;
+import static okhttp3.internal.ws.WebSocketProtocol.B0_FLAG_FIN;
+import static okhttp3.internal.ws.WebSocketProtocol.B0_FLAG_RSV1;
+import static okhttp3.internal.ws.WebSocketProtocol.B0_FLAG_RSV2;
+import static okhttp3.internal.ws.WebSocketProtocol.B0_FLAG_RSV3;
+import static okhttp3.internal.ws.WebSocketProtocol.B0_MASK_OPCODE;
+import static okhttp3.internal.ws.WebSocketProtocol.B1_FLAG_MASK;
+import static okhttp3.internal.ws.WebSocketProtocol.B1_MASK_LENGTH;
+import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_BINARY;
+import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_CONTINUATION;
+import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_CONTROL_CLOSE;
+import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_CONTROL_PING;
+import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_CONTROL_PONG;
+import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_FLAG_CONTROL;
+import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_TEXT;
+import static okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_BYTE_MAX;
+import static okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_LONG;
+import static okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_SHORT;
+import static okhttp3.internal.ws.WebSocketProtocol.toggleMask;
+import static okhttp3.internal.ws.WebSocketProtocol.validateCloseCode;
 
 /**
  * An <a href="http://tools.ietf.org/html/rfc6455">RFC 6455</a>-compatible WebSocket frame reader.
  */
 public final class WebSocketReader {
   public interface FrameCallback {
-    void onMessage(BufferedSource source, PayloadType type) throws IOException;
+    void onMessage(ResponseBody body) throws IOException;
+
     void onPing(Buffer buffer);
+
     void onPong(Buffer buffer);
+
     void onClose(int code, String reason);
   }
 
@@ -74,7 +80,7 @@
   private boolean isMasked;
 
   private final byte[] maskKey = new byte[4];
-  private final byte[] maskBuffer = new byte[2048];
+  private final byte[] maskBuffer = new byte[8192];
 
   public WebSocketReader(boolean isClient, BufferedSource source, FrameCallback frameCallback) {
     if (source == null) throw new NullPointerException("source == null");
@@ -86,11 +92,12 @@ public WebSocketReader(boolean isClient, BufferedSource source, FrameCallback fr
 
   /**
    * Process the next protocol frame.
+   *
    * <ul>
-   * <li>If it is a control frame this will result in a single call to {@link FrameCallback}.</li>
-   * <li>If it is a message frame this will result in a single call to {@link
-   * WebSocketListener#onMessage}. If the message spans multiple frames, each interleaved control
-   * frame will result in a corresponding call to {@link FrameCallback}.
+   *     <li>If it is a control frame this will result in a single call to {@link FrameCallback}.
+   *     <li>If it is a message frame this will result in a single call to {@link
+   *         FrameCallback#onMessage}. If the message spans multiple frames, each interleaved
+   *         control frame will result in a corresponding call to {@link FrameCallback}.
    * </ul>
    */
   public void processNextFrame() throws IOException {
@@ -145,8 +152,8 @@ private void readHeader() throws IOException {
     }
     frameBytesRead = 0;
 
-    if (isControlFrame && frameLength > PAYLOAD_MAX) {
-      throw new ProtocolException("Control frame must be less than " + PAYLOAD_MAX + "B.");
+    if (isControlFrame && frameLength > PAYLOAD_BYTE_MAX) {
+      throw new ProtocolException("Control frame must be less than " + PAYLOAD_BYTE_MAX + "B.");
     }
 
     if (isMasked) {
@@ -182,35 +189,57 @@ private void readControlFrame() throws IOException {
         frameCallback.onPong(buffer);
         break;
       case OPCODE_CONTROL_CLOSE:
-        int code = 0;
+        int code = 1000;
         String reason = "";
         if (buffer != null) {
-          code = buffer.readShort();
-          reason = buffer.readUtf8();
+          long bufferSize = buffer.size();
+          if (bufferSize == 1) {
+            throw new ProtocolException("Malformed close payload length of 1.");
+          } else if (bufferSize != 0) {
+            code = buffer.readShort();
+            validateCloseCode(code, false);
+
+            reason = buffer.readUtf8();
+          }
         }
         frameCallback.onClose(code, reason);
         closed = true;
         break;
       default:
-        throw new IllegalStateException("Unknown control opcode: " + toHexString(opcode));
+        throw new ProtocolException("Unknown control opcode: " + toHexString(opcode));
     }
   }
 
   private void readMessageFrame() throws IOException {
-    PayloadType type;
+    final MediaType type;
     switch (opcode) {
       case OPCODE_TEXT:
-        type = PayloadType.TEXT;
+        type = WebSocket.TEXT;
         break;
       case OPCODE_BINARY:
-        type = PayloadType.BINARY;
+        type = WebSocket.BINARY;
         break;
       default:
-        throw new IllegalStateException("Unknown opcode: " + toHexString(opcode));
+        throw new ProtocolException("Unknown opcode: " + toHexString(opcode));
     }
 
+    final BufferedSource source = Okio.buffer(framedMessageSource);
+    ResponseBody body = new ResponseBody() {
+      @Override public MediaType contentType() {
+        return type;
+      }
+
+      @Override public long contentLength() {
+        return -1;
+      }
+
+      @Override public BufferedSource source() {
+        return source;
+      }
+    };
+
     messageClosed = false;
-    frameCallback.onMessage(Okio.buffer(framedMessageSource), type);
+    frameCallback.onMessage(body);
     if (!messageClosed) {
       throw new IllegalStateException("Listener failed to call close on message payload.");
     }
diff --git a/okhttp-ws/src/main/java/okhttp3/internal/ws/WebSocketWriter.java b/okhttp-ws/src/main/java/okhttp3/internal/ws/WebSocketWriter.java
new file mode 100644
index 0000000000..6ce0cfdd0a
--- /dev/null
+++ b/okhttp-ws/src/main/java/okhttp3/internal/ws/WebSocketWriter.java
@@ -0,0 +1,277 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.ws;
+
+import java.io.IOException;
+import java.util.Random;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.Sink;
+import okio.Timeout;
+
+import static okhttp3.internal.ws.WebSocketProtocol.B0_FLAG_FIN;
+import static okhttp3.internal.ws.WebSocketProtocol.B1_FLAG_MASK;
+import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_CONTINUATION;
+import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_CONTROL_CLOSE;
+import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_CONTROL_PING;
+import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_CONTROL_PONG;
+import static okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_BYTE_MAX;
+import static okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_LONG;
+import static okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_SHORT;
+import static okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_SHORT_MAX;
+import static okhttp3.internal.ws.WebSocketProtocol.toggleMask;
+import static okhttp3.internal.ws.WebSocketProtocol.validateCloseCode;
+
+/**
+ * An <a href="http://tools.ietf.org/html/rfc6455">RFC 6455</a>-compatible WebSocket frame writer.
+ *
+ * <p>This class is partially thread safe. Only a single "main" thread should be sending messages
+ * via calls to {@link #newMessageSink}, {@link #writePing}, or {@link #writeClose}. Other threads
+ * may call {@link #writePing}, {@link #writePong}, or {@link #writeClose} which will interleave on
+ * the wire with frames from the "main" sending thread.
+ */
+public final class WebSocketWriter {
+  private final boolean isClient;
+  private final Random random;
+
+  /** Writes must be guarded by synchronizing on 'this'. */
+  private final BufferedSink sink;
+  /** Access must be guarded by synchronizing on 'this'. */
+  private boolean writerClosed;
+
+  private final Buffer buffer = new Buffer();
+  private final FrameSink frameSink = new FrameSink();
+
+  private boolean activeWriter;
+
+  private final byte[] maskKey;
+  private final byte[] maskBuffer;
+
+  public WebSocketWriter(boolean isClient, BufferedSink sink, Random random) {
+    if (sink == null) throw new NullPointerException("sink == null");
+    if (random == null) throw new NullPointerException("random == null");
+    this.isClient = isClient;
+    this.sink = sink;
+    this.random = random;
+
+    // Masks are only a concern for client writers.
+    maskKey = isClient ? new byte[4] : null;
+    maskBuffer = isClient ? new byte[8192] : null;
+  }
+
+  /** Send a ping with the supplied {@code payload}. Payload may be {@code null} */
+  public void writePing(Buffer payload) throws IOException {
+    synchronized (this) {
+      writeControlFrameSynchronized(OPCODE_CONTROL_PING, payload);
+    }
+  }
+
+  /** Send a pong with the supplied {@code payload}. Payload may be {@code null} */
+  public void writePong(Buffer payload) throws IOException {
+    synchronized (this) {
+      writeControlFrameSynchronized(OPCODE_CONTROL_PONG, payload);
+    }
+  }
+
+  /**
+   * Send a close frame with optional code and reason.
+   *
+   * @param code Status code as defined by <a
+   * href="http://tools.ietf.org/html/rfc6455#section-7.4">Section 7.4 of RFC 6455</a> or {@code 0}.
+   * @param reason Reason for shutting down or {@code null}.
+   */
+  public void writeClose(int code, String reason) throws IOException {
+    Buffer payload = null;
+    if (code != 0 || reason != null) {
+      if (code != 0) {
+        validateCloseCode(code, true);
+      }
+      payload = new Buffer();
+      payload.writeShort(code);
+      if (reason != null) {
+        payload.writeUtf8(reason);
+      }
+    }
+
+    synchronized (this) {
+      writeControlFrameSynchronized(OPCODE_CONTROL_CLOSE, payload);
+      writerClosed = true;
+    }
+  }
+
+  private void writeControlFrameSynchronized(int opcode, Buffer payload) throws IOException {
+    assert Thread.holdsLock(this);
+
+    if (writerClosed) throw new IOException("closed");
+
+    int length = 0;
+    if (payload != null) {
+      length = (int) payload.size();
+      if (length > PAYLOAD_BYTE_MAX) {
+        throw new IllegalArgumentException(
+            "Payload size must be less than or equal to " + PAYLOAD_BYTE_MAX);
+      }
+    }
+
+    int b0 = B0_FLAG_FIN | opcode;
+    sink.writeByte(b0);
+
+    int b1 = length;
+    if (isClient) {
+      b1 |= B1_FLAG_MASK;
+      sink.writeByte(b1);
+
+      random.nextBytes(maskKey);
+      sink.write(maskKey);
+
+      if (payload != null) {
+        writeMaskedSynchronized(payload, length);
+      }
+    } else {
+      sink.writeByte(b1);
+
+      if (payload != null) {
+        sink.writeAll(payload);
+      }
+    }
+
+    sink.emit();
+  }
+
+  /**
+   * Stream a message payload as a series of frames. This allows control frames to be interleaved
+   * between parts of the message.
+   */
+  public Sink newMessageSink(int formatOpcode, long contentLength) {
+    if (activeWriter) {
+      throw new IllegalStateException("Another message writer is active. Did you call close()?");
+    }
+    activeWriter = true;
+
+    // Reset FrameSink state for a new writer.
+    frameSink.formatOpcode = formatOpcode;
+    frameSink.contentLength = contentLength;
+    frameSink.isFirstFrame = true;
+    frameSink.closed = false;
+
+    return frameSink;
+  }
+
+  private void writeMessageFrameSynchronized(int formatOpcode, long byteCount, boolean isFirstFrame,
+      boolean isFinal) throws IOException {
+    assert Thread.holdsLock(this);
+
+    if (writerClosed) throw new IOException("closed");
+
+    int b0 = isFirstFrame ? formatOpcode : OPCODE_CONTINUATION;
+    if (isFinal) {
+      b0 |= B0_FLAG_FIN;
+    }
+    sink.writeByte(b0);
+
+    int b1 = 0;
+    if (isClient) {
+      b1 |= B1_FLAG_MASK;
+      random.nextBytes(maskKey);
+    }
+    if (byteCount <= PAYLOAD_BYTE_MAX) {
+      b1 |= (int) byteCount;
+      sink.writeByte(b1);
+    } else if (byteCount <= PAYLOAD_SHORT_MAX) {
+      b1 |= PAYLOAD_SHORT;
+      sink.writeByte(b1);
+      sink.writeShort((int) byteCount);
+    } else {
+      b1 |= PAYLOAD_LONG;
+      sink.writeByte(b1);
+      sink.writeLong(byteCount);
+    }
+
+    if (isClient) {
+      sink.write(maskKey);
+      writeMaskedSynchronized(buffer, byteCount);
+    } else {
+      sink.write(buffer, byteCount);
+    }
+
+    sink.emit();
+  }
+
+  private void writeMaskedSynchronized(BufferedSource source, long byteCount) throws IOException {
+    assert Thread.holdsLock(this);
+
+    long written = 0;
+    while (written < byteCount) {
+      int toRead = (int) Math.min(byteCount, maskBuffer.length);
+      int read = source.read(maskBuffer, 0, toRead);
+      if (read == -1) throw new AssertionError();
+      toggleMask(maskBuffer, read, maskKey, written);
+      sink.write(maskBuffer, 0, read);
+      written += read;
+    }
+  }
+
+  private final class FrameSink implements Sink {
+    private int formatOpcode;
+    private long contentLength;
+    private boolean isFirstFrame;
+    private boolean closed;
+
+    @Override public void write(Buffer source, long byteCount) throws IOException {
+      if (closed) throw new IOException("closed");
+
+      buffer.write(source, byteCount);
+
+      // Determine if this is a buffered write which we can defer until close() flushes.
+      boolean deferWrite = isFirstFrame
+          && contentLength != -1
+          && buffer.size() > contentLength - 8192 /* segment size */;
+
+      long emitCount = buffer.completeSegmentByteCount();
+      if (emitCount > 0 && !deferWrite) {
+        synchronized (WebSocketWriter.this) {
+          writeMessageFrameSynchronized(formatOpcode, emitCount, isFirstFrame, false /* final */);
+        }
+        isFirstFrame = false;
+      }
+    }
+
+    @Override public void flush() throws IOException {
+      if (closed) throw new IOException("closed");
+
+      synchronized (WebSocketWriter.this) {
+        writeMessageFrameSynchronized(formatOpcode, buffer.size(), isFirstFrame, false /* final */);
+      }
+      isFirstFrame = false;
+    }
+
+    @Override public Timeout timeout() {
+      return sink.timeout();
+    }
+
+    @SuppressWarnings("PointlessBitwiseExpression")
+    @Override public void close() throws IOException {
+      if (closed) throw new IOException("closed");
+
+      synchronized (WebSocketWriter.this) {
+        writeMessageFrameSynchronized(formatOpcode, buffer.size(), isFirstFrame, true /* final */);
+      }
+      closed = true;
+      activeWriter = false;
+    }
+  }
+}
diff --git a/okhttp-ws/src/main/java/okhttp3/ws/WebSocket.java b/okhttp-ws/src/main/java/okhttp3/ws/WebSocket.java
new file mode 100644
index 0000000000..7435c01d7f
--- /dev/null
+++ b/okhttp-ws/src/main/java/okhttp3/ws/WebSocket.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.ws;
+
+import java.io.IOException;
+import okhttp3.MediaType;
+import okhttp3.RequestBody;
+import okio.Buffer;
+
+/** Blocking interface to connect and write to a web socket. */
+public interface WebSocket {
+  /** A {@link MediaType} indicating UTF-8 text frames should be used when sending the message. */
+  MediaType TEXT = MediaType.parse("application/vnd.okhttp.websocket+text; charset=utf-8");
+  /** A {@link MediaType} indicating binary frames should be used when sending the message. */
+  MediaType BINARY = MediaType.parse("application/vnd.okhttp.websocket+binary");
+
+  /**
+   * Send a message payload to the server.
+   *
+   * <p>The {@linkplain RequestBody#contentType() content type} of {@code message} should be either
+   * {@link #TEXT} or {@link #BINARY}.
+   *
+   * @throws IOException if unable to write the message. Clients must call {@link #close} when this
+   * happens to ensure resources are cleaned up.
+   * @throws IllegalStateException if not connected, already closed, or another writer is active.
+   */
+  void sendMessage(RequestBody message) throws IOException;
+
+  /**
+   * Send a ping to the server with optional payload.
+   *
+   * @throws IOException if unable to write the ping.  Clients must call {@link #close} when this
+   * happens to ensure resources are cleaned up.
+   * @throws IllegalStateException if already closed.
+   */
+  void sendPing(Buffer payload) throws IOException;
+
+  /**
+   * Send a close frame to the server.
+   *
+   * <p>The corresponding {@link WebSocketListener} will continue to get messages until its {@link
+   * WebSocketListener#onClose onClose()} method is called.
+   *
+   * <p>It is an error to call this method before calling close on an active writer. Calling this
+   * method more than once has no effect.
+   *
+   * @throws IOException if unable to write the close message. Resources will still be freed.
+   * @throws IllegalStateException if already closed.
+   */
+  void close(int code, String reason) throws IOException;
+}
diff --git a/okhttp-ws/src/main/java/com/squareup/okhttp/ws/WebSocketCall.java b/okhttp-ws/src/main/java/okhttp3/ws/WebSocketCall.java
similarity index 50%
rename from okhttp-ws/src/main/java/com/squareup/okhttp/ws/WebSocketCall.java
rename to okhttp-ws/src/main/java/okhttp3/ws/WebSocketCall.java
index 2108ee88c5..7293392083 100644
--- a/okhttp-ws/src/main/java/com/squareup/okhttp/ws/WebSocketCall.java
+++ b/okhttp-ws/src/main/java/okhttp3/ws/WebSocketCall.java
@@ -13,36 +13,32 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.ws;
-
-import com.squareup.okhttp.Call;
-import com.squareup.okhttp.Callback;
-import com.squareup.okhttp.Connection;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
-import com.squareup.okhttp.internal.Internal;
-import com.squareup.okhttp.internal.NamedRunnable;
-import com.squareup.okhttp.internal.Util;
-import com.squareup.okhttp.internal.ws.RealWebSocket;
-import com.squareup.okhttp.internal.ws.WebSocketProtocol;
+package okhttp3.ws;
+
 import java.io.IOException;
 import java.net.ProtocolException;
-import java.net.Socket;
 import java.security.SecureRandom;
 import java.util.Collections;
 import java.util.Random;
-import java.util.concurrent.Executor;
+import java.util.concurrent.ExecutorService;
 import java.util.concurrent.LinkedBlockingDeque;
 import java.util.concurrent.ThreadPoolExecutor;
-import okio.BufferedSink;
-import okio.BufferedSource;
+import okhttp3.Call;
+import okhttp3.Callback;
+import okhttp3.OkHttpClient;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.internal.Internal;
+import okhttp3.internal.Util;
+import okhttp3.internal.http.StreamAllocation;
+import okhttp3.internal.ws.RealWebSocket;
+import okhttp3.internal.ws.WebSocketProtocol;
 import okio.ByteString;
-import okio.Okio;
 
 import static java.util.concurrent.TimeUnit.SECONDS;
 
-public class WebSocketCall {
+public final class WebSocketCall {
   /**
    * Prepares the {@code request} to create a web socket at some point in the future.
    */
@@ -50,12 +46,11 @@ public static WebSocketCall create(OkHttpClient client, Request request) {
     return new WebSocketCall(client, request);
   }
 
-  private final Request request;
   private final Call call;
   private final Random random;
   private final String key;
 
-  protected WebSocketCall(OkHttpClient client, Request request) {
+  WebSocketCall(OkHttpClient client, Request request) {
     this(client, request, new SecureRandom());
   }
 
@@ -63,39 +58,22 @@ protected WebSocketCall(OkHttpClient client, Request request) {
     if (!"GET".equals(request.method())) {
       throw new IllegalArgumentException("Request must be GET: " + request.method());
     }
-    String url = request.urlString();
-    String httpUrl;
-    if (url.startsWith("ws://")) {
-      httpUrl = "http://" + url.substring(5);
-    } else if (url.startsWith("wss://")) {
-      httpUrl = "https://" + url.substring(6);
-    } else if (url.startsWith("http://") || url.startsWith("https://")) {
-      httpUrl = url;
-    } else {
-      throw new IllegalArgumentException(
-          "Request url must use 'ws', 'wss', 'http', or 'https' scheme: " + url);
-    }
-
     this.random = random;
 
     byte[] nonce = new byte[16];
     random.nextBytes(nonce);
     key = ByteString.of(nonce).base64();
 
-    // Copy the client. Otherwise changes (socket factory, redirect policy,
-    // etc.) may incorrectly be reflected in the request when it is executed.
-    client = client.clone();
-    // Force HTTP/1.1 until the WebSocket over HTTP/2 version is finalized.
-    client.setProtocols(Collections.singletonList(com.squareup.okhttp.Protocol.HTTP_1_1));
+    client = client.newBuilder()
+        .protocols(Collections.singletonList(Protocol.HTTP_1_1))
+        .build();
 
     request = request.newBuilder()
-        .url(httpUrl)
         .header("Upgrade", "websocket")
         .header("Connection", "Upgrade")
         .header("Sec-WebSocket-Key", key)
         .header("Sec-WebSocket-Version", "13")
         .build();
-    this.request = request;
 
     call = client.newCall(request);
   }
@@ -103,8 +81,8 @@ protected WebSocketCall(OkHttpClient client, Request request) {
   /**
    * Schedules the request to be executed at some point in the future.
    *
-   * <p>The {@link OkHttpClient#getDispatcher dispatcher} defines when the request will run:
-   * usually immediately unless there are several other requests currently being executed.
+   * <p>The {@link OkHttpClient#dispatcher dispatcher} defines when the request will run: usually
+   * immediately unless there are several other requests currently being executed.
    *
    * <p>This client will later call back {@code responseCallback} with either an HTTP response or a
    * failure exception. If you {@link #cancel} a request before it completes the callback will not
@@ -114,16 +92,16 @@ protected WebSocketCall(OkHttpClient client, Request request) {
    */
   public void enqueue(final WebSocketListener listener) {
     Callback responseCallback = new Callback() {
-      @Override public void onResponse(Response response) throws IOException {
+      @Override public void onResponse(Call call, Response response) throws IOException {
         try {
           createWebSocket(response, listener);
         } catch (IOException e) {
-          listener.onFailure(e);
+          listener.onFailure(e, response);
         }
       }
 
-      @Override public void onFailure(Request request, IOException e) {
-        listener.onFailure(e);
+      @Override public void onFailure(Call call, IOException e) {
+        listener.onFailure(e, null);
       }
     };
     // TODO call.enqueue(responseCallback, true);
@@ -135,11 +113,8 @@ public void cancel() {
     call.cancel();
   }
 
-  private void createWebSocket(Response response, WebSocketListener listener)
-      throws IOException {
+  private void createWebSocket(Response response, WebSocketListener listener) throws IOException {
     if (response.code() != 101) {
-      // TODO call.engine.releaseConnection();
-      Internal.instance.callEngineReleaseConnection(call);
       throw new ProtocolException("Expected HTTP 101 response but was '"
           + response.code()
           + " "
@@ -167,59 +142,44 @@ private void createWebSocket(Response response, WebSocketListener listener)
           + "'");
     }
 
-    // TODO connection = call.engine.getConnection();
-    Connection connection = Internal.instance.callEngineGetConnection(call);
-    // TODO if (!connection.clearOwner()) {
-    if (!Internal.instance.clearOwner(connection)) {
-      throw new IllegalStateException("Unable to take ownership of connection.");
-    }
-
-    Socket socket = connection.getSocket();
-    BufferedSource source = Okio.buffer(Okio.source(socket));
-    BufferedSink sink = Okio.buffer(Okio.sink(socket));
+    StreamAllocation streamAllocation = Internal.instance.callEngineGetStreamAllocation(call);
+    RealWebSocket webSocket = StreamWebSocket.create(
+        streamAllocation, response, random, listener);
 
-    final RealWebSocket webSocket =
-        ConnectionWebSocket.create(response, connection, source, sink, random, listener);
+    listener.onOpen(webSocket, response);
 
-    // Start a dedicated thread for reading the web socket.
-    new Thread(new NamedRunnable("OkHttp WebSocket reader %s", request.urlString()) {
-      @Override protected void execute() {
-        while (webSocket.readMessage()) {
-        }
-      }
-    }).start();
-
-    // TODO connection.setOwner(webSocket);
-    Internal.instance.connectionSetOwner(connection, webSocket);
-
-    listener.onOpen(webSocket, request, response);
+    while (webSocket.readMessage()) {
+    }
   }
 
   // Keep static so that the WebSocketCall instance can be garbage collected.
-  private static class ConnectionWebSocket extends RealWebSocket {
-    static RealWebSocket create(Response response, Connection connection, BufferedSource source,
-        BufferedSink sink, Random random, WebSocketListener listener) {
-      String url = response.request().urlString();
+  private static class StreamWebSocket extends RealWebSocket {
+    static RealWebSocket create(StreamAllocation streamAllocation, Response response,
+        Random random, WebSocketListener listener) {
+      String url = response.request().url().toString();
       ThreadPoolExecutor replyExecutor =
           new ThreadPoolExecutor(1, 1, 1, SECONDS, new LinkedBlockingDeque<Runnable>(),
-              Util.threadFactory(String.format("OkHttp %s WebSocket", url), true));
+              Util.threadFactory(Util.format("OkHttp %s WebSocket", url), true));
       replyExecutor.allowCoreThreadTimeOut(true);
 
-      return new ConnectionWebSocket(connection, source, sink, random, replyExecutor, listener,
-          url);
+      return new StreamWebSocket(streamAllocation, random, replyExecutor, listener, url);
     }
 
-    private final Connection connection;
+    private final StreamAllocation streamAllocation;
+    private final ExecutorService replyExecutor;
 
-    private ConnectionWebSocket(Connection connection, BufferedSource source, BufferedSink sink,
-        Random random, Executor replyExecutor, WebSocketListener listener, String url) {
-      super(true /* is client */, source, sink, random, replyExecutor, listener, url);
-      this.connection = connection;
+    private StreamWebSocket(StreamAllocation streamAllocation,
+        Random random, ExecutorService replyExecutor, WebSocketListener listener, String url) {
+      super(true /* is client */, streamAllocation.connection().source,
+          streamAllocation.connection().sink, random, replyExecutor, listener, url);
+      this.streamAllocation = streamAllocation;
+      this.replyExecutor = replyExecutor;
     }
 
-    @Override protected void closeConnection() throws IOException {
-      // TODO connection.closeIfOwnedBy(this);
-      Internal.instance.closeIfOwnedBy(connection, this);
+    @Override protected void close() throws IOException {
+      replyExecutor.shutdown();
+      streamAllocation.noNewStreams();
+      streamAllocation.streamFinished(true, streamAllocation.stream());
     }
   }
 }
diff --git a/okhttp-ws/src/main/java/com/squareup/okhttp/ws/WebSocketListener.java b/okhttp-ws/src/main/java/okhttp3/ws/WebSocketListener.java
similarity index 51%
rename from okhttp-ws/src/main/java/com/squareup/okhttp/ws/WebSocketListener.java
rename to okhttp-ws/src/main/java/okhttp3/ws/WebSocketListener.java
index a113eed244..12d5e66aab 100644
--- a/okhttp-ws/src/main/java/com/squareup/okhttp/ws/WebSocketListener.java
+++ b/okhttp-ws/src/main/java/okhttp3/ws/WebSocketListener.java
@@ -13,29 +13,45 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.ws;
+package okhttp3.ws;
 
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
 import java.io.IOException;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
 import okio.Buffer;
-import okio.BufferedSource;
-
-import static com.squareup.okhttp.ws.WebSocket.PayloadType;
 
 /** Listener for server-initiated messages on a connected {@link WebSocket}. */
 public interface WebSocketListener {
-  void onOpen(WebSocket webSocket, Request request, Response response) throws IOException;
+  /**
+   * Called when the request has successfully been upgraded to a web socket. This method is called
+   * on the message reading thread to allow setting up any state before the {@linkplain #onMessage
+   * message}, {@linkplain #onPong pong}, and {@link #onClose close} callbacks start.
+   *
+   * <p><b>Do not</b> use this callback to write to the web socket. Start a new thread or use
+   * another thread in your application.
+   */
+  void onOpen(WebSocket webSocket, Response response);
+
+  /**
+   * Called when the transport or protocol layer of this web socket errors during communication.
+   *
+   * @param response Present when the failure is a direct result of the response (e.g., failed
+   * upgrade, non-101 response code, etc.). {@code null} otherwise.
+   */
+  void onFailure(IOException e, Response response);
 
   /**
-   * Called when a server message is received. The {@code type} indicates whether the
-   * {@code payload} should be interpreted as UTF-8 text or binary data.
+   * Called when a server message is received. The {@code type} indicates whether the {@code
+   * payload} should be interpreted as UTF-8 text or binary data.
    *
    * <p>Implementations <strong>must</strong> call {@code source.close()} before returning. This
-   * indicates completion of parsing the message payload and will consume any remaining bytes in
-   * the message.
+   * indicates completion of parsing the message payload and will consume any remaining bytes in the
+   * message.
+   *
+   * <p>The {@linkplain ResponseBody#contentType() content type} of {@code message} will be either
+   * {@link WebSocket#TEXT} or {@link WebSocket#BINARY} which indicates the format of the message.
    */
-  void onMessage(BufferedSource payload, PayloadType type) throws IOException;
+  void onMessage(ResponseBody message) throws IOException;
 
   /**
    * Called when a server pong is received. This is usually a result of calling {@link
@@ -44,16 +60,12 @@
   void onPong(Buffer payload);
 
   /**
-   * Called when the server sends a close message. This may have been initiated
-   * from a call to {@link WebSocket#close(int, String) close()} or as an unprompted
-   * message from the server.
+   * Called when the server sends a close message. This may have been initiated from a call to
+   * {@link WebSocket#close(int, String) close()} or as an unprompted message from the server.
    *
    * @param code The <a href="http://tools.ietf.org/html/rfc6455#section-7.4.1">RFC-compliant</a>
    * status code.
    * @param reason Reason for close or an empty string.
    */
   void onClose(int code, String reason);
-
-  /** Called when the transport or protocol layer of this web socket errors during communication. */
-  void onFailure(IOException e);
 }
diff --git a/okhttp/pom.xml b/okhttp/pom.xml
index 1cd007c72f..a26e988b27 100644
--- a/okhttp/pom.xml
+++ b/okhttp/pom.xml
@@ -4,9 +4,9 @@
   <modelVersion>4.0.0</modelVersion>
 
   <parent>
-    <groupId>com.squareup.okhttp</groupId>
+    <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>2.4.0-SNAPSHOT</version>
+    <version>3.4.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp</artifactId>
@@ -17,6 +17,11 @@
       <groupId>com.squareup.okio</groupId>
       <artifactId>okio</artifactId>
     </dependency>
+    <dependency>
+      <groupId>com.google.android</groupId>
+      <artifactId>android</artifactId>
+      <scope>provided</scope>
+    </dependency>
   </dependencies>
 
   <build>
@@ -37,7 +42,7 @@
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-javadoc-plugin</artifactId>
         <configuration>
-          <excludePackageNames>com.squareup.okhttp.internal:com.squareup.okhttp.internal.*</excludePackageNames>
+          <excludePackageNames>okhttp3.internal:okhttp3.internal.*</excludePackageNames>
           <links>
             <link>http://square.github.io/okio/</link>
           </links>
diff --git a/okhttp/src/main/java-templates/com/squareup/okhttp/internal/Version.java b/okhttp/src/main/java-templates/okhttp3/internal/Version.java
similarity index 95%
rename from okhttp/src/main/java-templates/com/squareup/okhttp/internal/Version.java
rename to okhttp/src/main/java-templates/okhttp3/internal/Version.java
index 59fece92bf..fce1c067c0 100644
--- a/okhttp/src/main/java-templates/com/squareup/okhttp/internal/Version.java
+++ b/okhttp/src/main/java-templates/okhttp3/internal/Version.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal;
+package okhttp3.internal;
 
 public final class Version {
   public static String userAgent() {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Authenticator.java b/okhttp/src/main/java/com/squareup/okhttp/Authenticator.java
deleted file mode 100644
index cb66dc6249..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/Authenticator.java
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp;
-
-import java.io.IOException;
-import java.net.Proxy;
-
-/**
- * Responds to authentication challenges from the remote web or proxy server.
- */
-public interface Authenticator {
-  /**
-   * Returns a request that includes a credential to satisfy an authentication
-   * challenge in {@code response}. Returns null if the challenge cannot be
-   * satisfied. This method is called in response to an HTTP 401 unauthorized
-   * status code sent by the origin server.
-   *
-   * <p>Typical implementations will look up a credential and create a request
-   * derived from the initial request by setting the "Authorization" header.
-   * <pre>   {@code
-   *
-   *    String credential = Credentials.basic(...)
-   *    return response.request().newBuilder()
-   *        .header("Authorization", credential)
-   *        .build();
-   * }</pre>
-   */
-  Request authenticate(Proxy proxy, Response response) throws IOException;
-
-  /**
-   * Returns a request that includes a credential to satisfy an authentication
-   * challenge made by {@code response}. Returns null if the challenge cannot be
-   * satisfied. This method is called in response to an HTTP 407 unauthorized
-   * status code sent by the proxy server.
-   *
-   * <p>Typical implementations will look up a credential and create a request
-   * derived from the initial request by setting the "Proxy-Authorization"
-   * header. <pre>   {@code
-   *
-   *    String credential = Credentials.basic(...)
-   *    return response.request().newBuilder()
-   *        .header("Proxy-Authorization", credential)
-   *        .build();
-   * }</pre>
-   */
-  Request authenticateProxy(Proxy proxy, Response response) throws IOException;
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Connection.java b/okhttp/src/main/java/com/squareup/okhttp/Connection.java
deleted file mode 100644
index 7dddc3a5cf..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/Connection.java
+++ /dev/null
@@ -1,448 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.squareup.okhttp;
-
-import com.squareup.okhttp.internal.Platform;
-import com.squareup.okhttp.internal.Util;
-import com.squareup.okhttp.internal.http.HttpConnection;
-import com.squareup.okhttp.internal.http.HttpEngine;
-import com.squareup.okhttp.internal.http.HttpTransport;
-import com.squareup.okhttp.internal.http.OkHeaders;
-import com.squareup.okhttp.internal.http.SpdyTransport;
-import com.squareup.okhttp.internal.http.Transport;
-import com.squareup.okhttp.internal.spdy.SpdyConnection;
-import com.squareup.okhttp.internal.tls.OkHostnameVerifier;
-import java.io.IOException;
-import java.net.Proxy;
-import java.net.Socket;
-import java.net.URL;
-import java.security.cert.X509Certificate;
-import java.util.concurrent.TimeUnit;
-import javax.net.ssl.SSLPeerUnverifiedException;
-import javax.net.ssl.SSLSocket;
-import okio.Source;
-
-import static com.squareup.okhttp.internal.Util.getDefaultPort;
-import static com.squareup.okhttp.internal.Util.getEffectivePort;
-import static java.net.HttpURLConnection.HTTP_OK;
-import static java.net.HttpURLConnection.HTTP_PROXY_AUTH;
-
-/**
- * The sockets and streams of an HTTP, HTTPS, or HTTPS+SPDY connection. May be
- * used for multiple HTTP request/response exchanges. Connections may be direct
- * to the origin server or via a proxy.
- *
- * <p>Typically instances of this class are created, connected and exercised
- * automatically by the HTTP client. Applications may use this class to monitor
- * HTTP connections as members of a {@linkplain ConnectionPool connection pool}.
- *
- * <p>Do not confuse this class with the misnamed {@code HttpURLConnection},
- * which isn't so much a connection as a single request/response exchange.
- *
- * <h3>Modern TLS</h3>
- * There are tradeoffs when selecting which options to include when negotiating
- * a secure connection to a remote host. Newer TLS options are quite useful:
- * <ul>
- *   <li>Server Name Indication (SNI) enables one IP address to negotiate secure
- *       connections for multiple domain names.
- *   <li>Application Layer Protocol Negotiation (ALPN) enables the HTTPS port
- *       (443) to be used for different HTTP and SPDY protocols.
- * </ul>
- * Unfortunately, older HTTPS servers refuse to connect when such options are
- * presented. Rather than avoiding these options entirely, this class allows a
- * connection to be attempted with modern options and then retried without them
- * should the attempt fail.
- */
-public final class Connection {
-  private final ConnectionPool pool;
-  private final Route route;
-
-  private Socket socket;
-  private boolean connected = false;
-  private HttpConnection httpConnection;
-  private SpdyConnection spdyConnection;
-  private Protocol protocol = Protocol.HTTP_1_1;
-  private long idleStartTimeNs;
-  private Handshake handshake;
-  private int recycleCount;
-
-  /**
-   * The object that owns this connection. Null if it is shared (for SPDY),
-   * belongs to a pool, or has been discarded. Guarded by {@code pool}, which
-   * clears the owner when an incoming connection is recycled.
-   */
-  private Object owner;
-
-  public Connection(ConnectionPool pool, Route route) {
-    this.pool = pool;
-    this.route = route;
-  }
-
-  Object getOwner() {
-    synchronized (pool) {
-      return owner;
-    }
-  }
-
-  void setOwner(Object owner) {
-    if (isSpdy()) return; // SPDY connections are shared.
-    synchronized (pool) {
-      if (this.owner != null) throw new IllegalStateException("Connection already has an owner!");
-      this.owner = owner;
-    }
-  }
-
-  /**
-   * Attempts to clears the owner of this connection. Returns true if the owner
-   * was cleared and the connection can be pooled or reused. This will return
-   * false if the connection cannot be pooled or reused, such as if it was
-   * closed with {@link #closeIfOwnedBy}.
-   */
-  boolean clearOwner() {
-    synchronized (pool) {
-      if (owner == null) {
-        // No owner? Don't reuse this connection.
-        return false;
-      }
-
-      owner = null;
-      return true;
-    }
-  }
-
-  /**
-   * Closes this connection if it is currently owned by {@code owner}. This also
-   * strips the ownership of the connection so it cannot be pooled or reused.
-   */
-  void closeIfOwnedBy(Object owner) throws IOException {
-    if (isSpdy()) throw new IllegalStateException();
-    synchronized (pool) {
-      if (this.owner != owner) {
-        return; // Wrong owner. Perhaps a late disconnect?
-      }
-
-      this.owner = null; // Drop the owner so the connection won't be reused.
-    }
-
-    // Don't close() inside the synchronized block.
-    socket.close();
-  }
-
-  void connect(int connectTimeout, int readTimeout, int writeTimeout, Request tunnelRequest)
-      throws IOException {
-    if (connected) throw new IllegalStateException("already connected");
-
-    if (route.proxy.type() == Proxy.Type.DIRECT || route.proxy.type() == Proxy.Type.HTTP) {
-      socket = route.address.socketFactory.createSocket();
-    } else {
-      socket = new Socket(route.proxy);
-    }
-
-    socket.setSoTimeout(readTimeout);
-    Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);
-
-    if (route.address.sslSocketFactory != null) {
-      upgradeToTls(tunnelRequest, readTimeout, writeTimeout);
-    } else {
-      httpConnection = new HttpConnection(pool, this, socket);
-    }
-    connected = true;
-  }
-
-  /**
-   * Connects this connection if it isn't already. This creates tunnels, shares
-   * the connection with the connection pool, and configures timeouts.
-   */
-  void connectAndSetOwner(OkHttpClient client, Object owner, Request request) throws IOException {
-    setOwner(owner);
-
-    if (!isConnected()) {
-      Request tunnelRequest = tunnelRequest(request);
-      connect(client.getConnectTimeout(), client.getReadTimeout(),
-          client.getWriteTimeout(), tunnelRequest);
-      if (isSpdy()) {
-        client.getConnectionPool().share(this);
-      }
-      client.routeDatabase().connected(getRoute());
-    }
-
-    setTimeouts(client.getReadTimeout(), client.getWriteTimeout());
-  }
-
-  /**
-   * Returns a request that creates a TLS tunnel via an HTTP proxy, or null if
-   * no tunnel is necessary. Everything in the tunnel request is sent
-   * unencrypted to the proxy server, so tunnels include only the minimum set of
-   * headers. This avoids sending potentially sensitive data like HTTP cookies
-   * to the proxy unencrypted.
-   */
-  private Request tunnelRequest(Request request) throws IOException {
-    if (!route.requiresTunnel()) return null;
-
-    String host = request.url().getHost();
-    int port = getEffectivePort(request.url());
-    String authority = (port == getDefaultPort("https")) ? host : (host + ":" + port);
-    Request.Builder result = new Request.Builder()
-        .url(new URL("https", host, port, "/"))
-        .header("Host", authority)
-        .header("Proxy-Connection", "Keep-Alive"); // For HTTP/1.0 proxies like Squid.
-
-    // Copy over the User-Agent header if it exists.
-    String userAgent = request.header("User-Agent");
-    if (userAgent != null) {
-      result.header("User-Agent", userAgent);
-    }
-
-    // Copy over the Proxy-Authorization header if it exists.
-    String proxyAuthorization = request.header("Proxy-Authorization");
-    if (proxyAuthorization != null) {
-      result.header("Proxy-Authorization", proxyAuthorization);
-    }
-
-    return result.build();
-  }
-
-  /**
-   * Create an {@code SSLSocket} and perform the TLS handshake and certificate
-   * validation.
-   */
-  private void upgradeToTls(Request tunnelRequest, int readTimeout, int writeTimeout)
-      throws IOException {
-    Platform platform = Platform.get();
-
-    // Make an SSL Tunnel on the first message pair of each SSL + proxy connection.
-    if (tunnelRequest != null) {
-      makeTunnel(tunnelRequest, readTimeout, writeTimeout);
-    }
-
-    // Create the wrapper over connected socket.
-    socket = route.address.sslSocketFactory
-        .createSocket(socket, route.address.uriHost, route.address.uriPort, true /* autoClose */);
-    SSLSocket sslSocket = (SSLSocket) socket;
-
-    // Configure the socket's ciphers, TLS versions, and extensions.
-    route.connectionSpec.apply(sslSocket, route);
-
-    try {
-      // Force handshake. This can throw!
-      sslSocket.startHandshake();
-
-      String maybeProtocol;
-      if (route.connectionSpec.supportsTlsExtensions()
-          && (maybeProtocol = platform.getSelectedProtocol(sslSocket)) != null) {
-        protocol = Protocol.get(maybeProtocol); // Throws IOE on unknown.
-      }
-    } finally {
-      platform.afterHandshake(sslSocket);
-    }
-
-    handshake = Handshake.get(sslSocket.getSession());
-
-    // Verify that the socket's certificates are acceptable for the target host.
-    if (!route.address.hostnameVerifier.verify(route.address.uriHost, sslSocket.getSession())) {
-      X509Certificate cert = (X509Certificate) sslSocket.getSession().getPeerCertificates()[0];
-      throw new SSLPeerUnverifiedException("Hostname " + route.address.uriHost + " not verified:"
-          + "\n    certificate: " + CertificatePinner.pin(cert)
-          + "\n    DN: " + cert.getSubjectDN().getName()
-          + "\n    subjectAltNames: " + OkHostnameVerifier.allSubjectAltNames(cert));
-    }
-
-    // Check that the certificate pinner is satisfied by the certificates presented.
-    route.address.certificatePinner.check(route.address.uriHost, handshake.peerCertificates());
-
-    if (protocol == Protocol.SPDY_3 || protocol == Protocol.HTTP_2) {
-      sslSocket.setSoTimeout(0); // SPDY timeouts are set per-stream.
-      spdyConnection = new SpdyConnection.Builder(route.address.getUriHost(), true, socket)
-          .protocol(protocol).build();
-      spdyConnection.sendConnectionPreface();
-    } else {
-      httpConnection = new HttpConnection(pool, this, socket);
-    }
-  }
-
-  /** Returns true if {@link #connect} has been attempted on this connection. */
-  boolean isConnected() {
-    return connected;
-  }
-
-  /** Returns the route used by this connection. */
-  public Route getRoute() {
-    return route;
-  }
-
-  /**
-   * Returns the socket that this connection uses, or null if the connection
-   * is not currently connected.
-   */
-  public Socket getSocket() {
-    return socket;
-  }
-
-  /** Returns true if this connection is alive. */
-  boolean isAlive() {
-    return !socket.isClosed() && !socket.isInputShutdown() && !socket.isOutputShutdown();
-  }
-
-  /**
-   * Returns true if we are confident that we can read data from this
-   * connection. This is more expensive and more accurate than {@link
-   * #isAlive()}; callers should check {@link #isAlive()} first.
-   */
-  boolean isReadable() {
-    if (httpConnection != null) return httpConnection.isReadable();
-    return true; // SPDY connections, and connections before connect() are both optimistic.
-  }
-
-  void resetIdleStartTime() {
-    if (spdyConnection != null) throw new IllegalStateException("spdyConnection != null");
-    this.idleStartTimeNs = System.nanoTime();
-  }
-
-  /** Returns true if this connection is idle. */
-  boolean isIdle() {
-    return spdyConnection == null || spdyConnection.isIdle();
-  }
-
-  /**
-   * Returns the time in ns when this connection became idle. Undefined if
-   * this connection is not idle.
-   */
-  long getIdleStartTimeNs() {
-    return spdyConnection == null ? idleStartTimeNs : spdyConnection.getIdleStartTimeNs();
-  }
-
-  public Handshake getHandshake() {
-    return handshake;
-  }
-
-  /** Returns the transport appropriate for this connection. */
-  Transport newTransport(HttpEngine httpEngine) throws IOException {
-    return (spdyConnection != null)
-        ? new SpdyTransport(httpEngine, spdyConnection)
-        : new HttpTransport(httpEngine, httpConnection);
-  }
-
-  /**
-   * Returns true if this is a SPDY connection. Such connections can be used
-   * in multiple HTTP requests simultaneously.
-   */
-  boolean isSpdy() {
-    return spdyConnection != null;
-  }
-
-  /**
-   * Returns the protocol negotiated by this connection, or {@link
-   * Protocol#HTTP_1_1} if no protocol has been negotiated.
-   */
-  public Protocol getProtocol() {
-    return protocol;
-  }
-
-  /**
-   * Sets the protocol negotiated by this connection. Typically this is used
-   * when an HTTP/1.1 request is sent and an HTTP/1.0 response is received.
-   */
-  void setProtocol(Protocol protocol) {
-    if (protocol == null) throw new IllegalArgumentException("protocol == null");
-    this.protocol = protocol;
-  }
-
-  void setTimeouts(int readTimeoutMillis, int writeTimeoutMillis) throws IOException {
-    if (!connected) throw new IllegalStateException("setTimeouts - not connected");
-
-    // Don't set timeouts on shared SPDY connections.
-    if (httpConnection != null) {
-      socket.setSoTimeout(readTimeoutMillis);
-      httpConnection.setTimeouts(readTimeoutMillis, writeTimeoutMillis);
-    }
-  }
-
-  void incrementRecycleCount() {
-    recycleCount++;
-  }
-
-  /**
-   * Returns the number of times this connection has been returned to the
-   * connection pool.
-   */
-  int recycleCount() {
-    return recycleCount;
-  }
-
-  /**
-   * To make an HTTPS connection over an HTTP proxy, send an unencrypted
-   * CONNECT request to create the proxy connection. This may need to be
-   * retried if the proxy requires authorization.
-   */
-  private void makeTunnel(Request request, int readTimeout, int writeTimeout)
-      throws IOException {
-    HttpConnection tunnelConnection = new HttpConnection(pool, this, socket);
-    tunnelConnection.setTimeouts(readTimeout, writeTimeout);
-    URL url = request.url();
-    String requestLine = "CONNECT " + url.getHost() + ":" + url.getPort() + " HTTP/1.1";
-    while (true) {
-      tunnelConnection.writeRequest(request.headers(), requestLine);
-      tunnelConnection.flush();
-      Response response = tunnelConnection.readResponse().request(request).build();
-      // The response body from a CONNECT should be empty, but if it is not then we should consume
-      // it before proceeding.
-      long contentLength = OkHeaders.contentLength(response);
-      if (contentLength == -1L) {
-        contentLength = 0L;
-      }
-      Source body = tunnelConnection.newFixedLengthSource(contentLength);
-      Util.skipAll(body, Integer.MAX_VALUE, TimeUnit.MILLISECONDS);
-      body.close();
-
-      switch (response.code()) {
-        case HTTP_OK:
-          // Assume the server won't send a TLS ServerHello until we send a TLS ClientHello. If that
-          // happens, then we will have buffered bytes that are needed by the SSLSocket!
-          // This check is imperfect: it doesn't tell us whether a handshake will succeed, just that
-          // it will almost certainly fail because the proxy has sent unexpected data.
-          if (tunnelConnection.bufferSize() > 0) {
-            throw new IOException("TLS tunnel buffered too many bytes!");
-          }
-          return;
-
-        case HTTP_PROXY_AUTH:
-          request = OkHeaders.processAuthHeader(
-              route.address.authenticator, response, route.proxy);
-          if (request != null) continue;
-          throw new IOException("Failed to authenticate with proxy");
-
-        default:
-          throw new IOException(
-              "Unexpected response code for CONNECT: " + response.code());
-      }
-    }
-  }
-
-  @Override public String toString() {
-    return "Connection{"
-        + route.address.uriHost + ":" + route.address.uriPort
-        + ", proxy="
-        + route.proxy
-        + " hostAddress="
-        + route.inetSocketAddress.getAddress().getHostAddress()
-        + " cipherSuite="
-        + (handshake != null ? handshake.cipherSuite() : "none")
-        + " protocol="
-        + protocol
-        + '}';
-  }
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/FormEncodingBuilder.java b/okhttp/src/main/java/com/squareup/okhttp/FormEncodingBuilder.java
deleted file mode 100644
index 891fbff005..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/FormEncodingBuilder.java
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp;
-
-import com.squareup.okhttp.internal.Util;
-import java.io.UnsupportedEncodingException;
-import java.net.URLEncoder;
-
-/**
- * Fluent API to build <a href="http://www.w3.org/MarkUp/html-spec/html-spec_8.html#SEC8.2.1">HTML
- * 2.0</a>-compliant form data.
- */
-public final class FormEncodingBuilder {
-  private static final MediaType CONTENT_TYPE
-      = MediaType.parse("application/x-www-form-urlencoded");
-
-  private final StringBuilder content = new StringBuilder();
-
-  /** Add new key-value pair. */
-  public FormEncodingBuilder add(String name, String value) {
-    if (content.length() > 0) {
-      content.append('&');
-    }
-    try {
-      content.append(URLEncoder.encode(name, "UTF-8"))
-          .append('=')
-          .append(URLEncoder.encode(value, "UTF-8"));
-    } catch (UnsupportedEncodingException e) {
-      throw new AssertionError(e);
-    }
-    return this;
-  }
-
-  public RequestBody build() {
-    if (content.length() == 0) {
-      throw new IllegalStateException("Form encoded body must have at least one part.");
-    }
-
-    // Convert to bytes so RequestBody.create() doesn't add a charset to the content-type.
-    byte[] contentBytes = content.toString().getBytes(Util.UTF_8);
-    return RequestBody.create(CONTENT_TYPE, contentBytes);
-  }
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/MultipartBuilder.java b/okhttp/src/main/java/com/squareup/okhttp/MultipartBuilder.java
deleted file mode 100644
index 5b160b6741..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/MultipartBuilder.java
+++ /dev/null
@@ -1,300 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp;
-
-import com.squareup.okhttp.internal.Util;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.UUID;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.ByteString;
-
-/**
- * Fluent API to build <a href="http://www.ietf.org/rfc/rfc2387.txt">RFC
- * 2387</a>-compliant request bodies.
- */
-public final class MultipartBuilder {
-  /**
-   * The "mixed" subtype of "multipart" is intended for use when the body
-   * parts are independent and need to be bundled in a particular order. Any
-   * "multipart" subtypes that an implementation does not recognize must be
-   * treated as being of subtype "mixed".
-   */
-  public static final MediaType MIXED = MediaType.parse("multipart/mixed");
-
-  /**
-   * The "multipart/alternative" type is syntactically identical to
-   * "multipart/mixed", but the semantics are different. In particular, each
-   * of the body parts is an "alternative" version of the same information.
-   */
-  public static final MediaType ALTERNATIVE = MediaType.parse("multipart/alternative");
-
-  /**
-   * This type is syntactically identical to "multipart/mixed", but the
-   * semantics are different. In particular, in a digest, the default {@code
-   * Content-Type} value for a body part is changed from "text/plain" to
-   * "message/rfc822".
-   */
-  public static final MediaType DIGEST = MediaType.parse("multipart/digest");
-
-  /**
-   * This type is syntactically identical to "multipart/mixed", but the
-   * semantics are different. In particular, in a parallel entity, the order
-   * of body parts is not significant.
-   */
-  public static final MediaType PARALLEL = MediaType.parse("multipart/parallel");
-
-  /**
-   * The media-type multipart/form-data follows the rules of all multipart
-   * MIME data streams as outlined in RFC 2046. In forms, there are a series
-   * of fields to be supplied by the user who fills out the form. Each field
-   * has a name. Within a given form, the names are unique.
-   */
-  public static final MediaType FORM = MediaType.parse("multipart/form-data");
-
-  private static final byte[] COLONSPACE = { ':', ' ' };
-  private static final byte[] CRLF = { '\r', '\n' };
-  private static final byte[] DASHDASH = { '-', '-' };
-
-  private final ByteString boundary;
-  private MediaType type = MIXED;
-
-  // Parallel lists of nullable headers and non-null bodies.
-  private final List<Headers> partHeaders = new ArrayList<>();
-  private final List<RequestBody> partBodies = new ArrayList<>();
-
-  /** Creates a new multipart builder that uses a random boundary token. */
-  public MultipartBuilder() {
-    this(UUID.randomUUID().toString());
-  }
-
-  /**
-   * Creates a new multipart builder that uses {@code boundary} to separate
-   * parts. Prefer the no-argument constructor to defend against injection
-   * attacks.
-   */
-  public MultipartBuilder(String boundary) {
-    this.boundary = ByteString.encodeUtf8(boundary);
-  }
-
-  /**
-   * Set the MIME type. Expected values for {@code type} are {@link #MIXED} (the
-   * default), {@link #ALTERNATIVE}, {@link #DIGEST}, {@link #PARALLEL} and
-   * {@link #FORM}.
-   */
-  public MultipartBuilder type(MediaType type) {
-    if (type == null) {
-      throw new NullPointerException("type == null");
-    }
-    if (!type.type().equals("multipart")) {
-      throw new IllegalArgumentException("multipart != " + type);
-    }
-    this.type = type;
-    return this;
-  }
-
-  /** Add a part to the body. */
-  public MultipartBuilder addPart(RequestBody body) {
-    return addPart(null, body);
-  }
-
-  /** Add a part to the body. */
-  public MultipartBuilder addPart(Headers headers, RequestBody body) {
-    if (body == null) {
-      throw new NullPointerException("body == null");
-    }
-    if (headers != null && headers.get("Content-Type") != null) {
-      throw new IllegalArgumentException("Unexpected header: Content-Type");
-    }
-    if (headers != null && headers.get("Content-Length") != null) {
-      throw new IllegalArgumentException("Unexpected header: Content-Length");
-    }
-
-    partHeaders.add(headers);
-    partBodies.add(body);
-    return this;
-  }
-
-  /**
-   * Appends a quoted-string to a StringBuilder.
-   *
-   * <p>RFC 2388 is rather vague about how one should escape special characters
-   * in form-data parameters, and as it turns out Firefox and Chrome actually
-   * do rather different things, and both say in their comments that they're
-   * not really sure what the right approach is. We go with Chrome's behavior
-   * (which also experimentally seems to match what IE does), but if you
-   * actually want to have a good chance of things working, please avoid
-   * double-quotes, newlines, percent signs, and the like in your field names.
-   */
-  private static StringBuilder appendQuotedString(StringBuilder target, String key) {
-    target.append('"');
-    for (int i = 0, len = key.length(); i < len; i++) {
-      char ch = key.charAt(i);
-      switch (ch) {
-        case '\n':
-          target.append("%0A");
-          break;
-        case '\r':
-          target.append("%0D");
-          break;
-        case '"':
-          target.append("%22");
-          break;
-        default:
-          target.append(ch);
-          break;
-      }
-    }
-    target.append('"');
-    return target;
-  }
-
-  /** Add a form data part to the body. */
-  public MultipartBuilder addFormDataPart(String name, String value) {
-    return addFormDataPart(name, null, RequestBody.create(null, value));
-  }
-
-  /** Add a form data part to the body. */
-  public MultipartBuilder addFormDataPart(String name, String filename, RequestBody value) {
-    if (name == null) {
-      throw new NullPointerException("name == null");
-    }
-    StringBuilder disposition = new StringBuilder("form-data; name=");
-    appendQuotedString(disposition, name);
-
-    if (filename != null) {
-      disposition.append("; filename=");
-      appendQuotedString(disposition, filename);
-    }
-
-    return addPart(Headers.of("Content-Disposition", disposition.toString()), value);
-  }
-
-  /** Assemble the specified parts into a request body. */
-  public RequestBody build() {
-    if (partHeaders.isEmpty()) {
-      throw new IllegalStateException("Multipart body must have at least one part.");
-    }
-    return new MultipartRequestBody(type, boundary, partHeaders, partBodies);
-  }
-
-  private static final class MultipartRequestBody extends RequestBody {
-    private final ByteString boundary;
-    private final MediaType contentType;
-    private final List<Headers> partHeaders;
-    private final List<RequestBody> partBodies;
-    private long contentLength = -1L;
-
-    public MultipartRequestBody(MediaType type, ByteString boundary, List<Headers> partHeaders,
-        List<RequestBody> partBodies) {
-      if (type == null) throw new NullPointerException("type == null");
-
-      this.boundary = boundary;
-      this.contentType = MediaType.parse(type + "; boundary=" + boundary.utf8());
-      this.partHeaders = Util.immutableList(partHeaders);
-      this.partBodies = Util.immutableList(partBodies);
-    }
-
-    @Override public MediaType contentType() {
-      return contentType;
-    }
-
-    @Override public long contentLength() throws IOException {
-      long result = contentLength;
-      if (result != -1L) return result;
-      return contentLength = writeOrCountBytes(null, true);
-    }
-
-    /**
-     * Either writes this request to {@code sink} or measures its content length. We have one method
-     * do double-duty to make sure the counting and content are consistent, particularly when it
-     * comes to awkward operations like measuring the encoded length of header strings, or the
-     * length-in-digits of an encoded integer.
-     */
-    private long writeOrCountBytes(BufferedSink sink, boolean countBytes) throws IOException {
-      long byteCount = 0L;
-
-      Buffer byteCountBuffer = null;
-      if (countBytes) {
-        sink = byteCountBuffer = new Buffer();
-      }
-
-      for (int p = 0, partCount = partHeaders.size(); p < partCount; p++) {
-        Headers headers = partHeaders.get(p);
-        RequestBody body = partBodies.get(p);
-
-        sink.write(DASHDASH);
-        sink.write(boundary);
-        sink.write(CRLF);
-
-        if (headers != null) {
-          for (int h = 0, headerCount = headers.size(); h < headerCount; h++) {
-            sink.writeUtf8(headers.name(h))
-                .write(COLONSPACE)
-                .writeUtf8(headers.value(h))
-                .write(CRLF);
-          }
-        }
-
-        MediaType contentType = body.contentType();
-        if (contentType != null) {
-          sink.writeUtf8("Content-Type: ")
-              .writeUtf8(contentType.toString())
-              .write(CRLF);
-        }
-
-        long contentLength = body.contentLength();
-        if (contentLength != -1) {
-          sink.writeUtf8("Content-Length: ")
-              .writeDecimalLong(contentLength)
-              .write(CRLF);
-        } else if (countBytes) {
-          // We can't measure the body's size without the sizes of its components.
-          byteCountBuffer.clear();
-          return -1L;
-        }
-
-        sink.write(CRLF);
-
-        if (countBytes) {
-          byteCount += contentLength;
-        } else {
-          partBodies.get(p).writeTo(sink);
-        }
-
-        sink.write(CRLF);
-      }
-
-      sink.write(DASHDASH);
-      sink.write(boundary);
-      sink.write(DASHDASH);
-      sink.write(CRLF);
-
-      if (countBytes) {
-        byteCount += byteCountBuffer.size();
-        byteCountBuffer.clear();
-      }
-
-      return byteCount;
-    }
-
-    @Override public void writeTo(BufferedSink sink) throws IOException {
-      writeOrCountBytes(sink, false);
-    }
-  }
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java b/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
deleted file mode 100644
index 2b2f434202..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
+++ /dev/null
@@ -1,657 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp;
-
-import com.squareup.okhttp.internal.Internal;
-import com.squareup.okhttp.internal.InternalCache;
-import com.squareup.okhttp.internal.Network;
-import com.squareup.okhttp.internal.RouteDatabase;
-import com.squareup.okhttp.internal.Util;
-import com.squareup.okhttp.internal.http.AuthenticatorAdapter;
-import com.squareup.okhttp.internal.http.HttpEngine;
-import com.squareup.okhttp.internal.http.Transport;
-import com.squareup.okhttp.internal.tls.OkHostnameVerifier;
-import java.io.IOException;
-import java.net.CookieHandler;
-import java.net.Proxy;
-import java.net.ProxySelector;
-import java.net.URLConnection;
-import java.security.GeneralSecurityException;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.concurrent.TimeUnit;
-import javax.net.SocketFactory;
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLSocketFactory;
-
-/**
- * Configures and creates HTTP connections. Most applications can use a single
- * OkHttpClient for all of their HTTP requests - benefiting from a shared
- * response cache, thread pool, connection re-use, etc.
- *
- * <p>Instances of OkHttpClient are intended to be fully configured before they're
- * shared - once shared they should be treated as immutable and can safely be used
- * to concurrently open new connections. If required, threads can call
- * {@link #clone()} to make a shallow copy of the OkHttpClient that can be
- * safely modified with further configuration changes.
- */
-public class OkHttpClient implements Cloneable {
-  private static final List<Protocol> DEFAULT_PROTOCOLS = Util.immutableList(
-      Protocol.HTTP_2, Protocol.SPDY_3, Protocol.HTTP_1_1);
-
-  private static final List<ConnectionSpec> DEFAULT_CONNECTION_SPECS = Util.immutableList(
-      ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS, ConnectionSpec.CLEARTEXT);
-
-  static {
-    Internal.instance = new Internal() {
-      @Override public Transport newTransport(
-          Connection connection, HttpEngine httpEngine) throws IOException {
-        return connection.newTransport(httpEngine);
-      }
-
-      @Override public boolean clearOwner(Connection connection) {
-        return connection.clearOwner();
-      }
-
-      @Override public void closeIfOwnedBy(Connection connection, Object owner) throws IOException {
-        connection.closeIfOwnedBy(owner);
-      }
-
-      @Override public int recycleCount(Connection connection) {
-        return connection.recycleCount();
-      }
-
-      @Override public void setProtocol(Connection connection, Protocol protocol) {
-        connection.setProtocol(protocol);
-      }
-
-      @Override public void setOwner(Connection connection, HttpEngine httpEngine) {
-        connection.setOwner(httpEngine);
-      }
-
-      @Override public boolean isReadable(Connection pooled) {
-        return pooled.isReadable();
-      }
-
-      @Override public void addLenient(Headers.Builder builder, String line) {
-        builder.addLenient(line);
-      }
-
-      @Override public void setCache(OkHttpClient client, InternalCache internalCache) {
-        client.setInternalCache(internalCache);
-      }
-
-      @Override public InternalCache internalCache(OkHttpClient client) {
-        return client.internalCache();
-      }
-
-      @Override public void recycle(ConnectionPool pool, Connection connection) {
-        pool.recycle(connection);
-      }
-
-      @Override public RouteDatabase routeDatabase(OkHttpClient client) {
-        return client.routeDatabase();
-      }
-
-      @Override public Network network(OkHttpClient client) {
-        return client.network;
-      }
-
-      @Override public void setNetwork(OkHttpClient client, Network network) {
-        client.network = network;
-      }
-
-      @Override public void connectAndSetOwner(OkHttpClient client, Connection connection,
-          HttpEngine owner, Request request) throws IOException {
-        connection.connectAndSetOwner(client, owner, request);
-      }
-
-      @Override
-      public void callEnqueue(Call call, Callback responseCallback, boolean forWebSocket) {
-        call.enqueue(responseCallback, forWebSocket);
-      }
-
-      @Override public void callEngineReleaseConnection(Call call) throws IOException {
-        call.engine.releaseConnection();
-      }
-
-      @Override public Connection callEngineGetConnection(Call call) {
-        return call.engine.getConnection();
-      }
-
-      @Override public void connectionSetOwner(Connection connection, Object owner) {
-        connection.setOwner(owner);
-      }
-    };
-  }
-
-  /** Lazily-initialized. */
-  private static SSLSocketFactory defaultSslSocketFactory;
-
-  private final RouteDatabase routeDatabase;
-  private Dispatcher dispatcher;
-  private Proxy proxy;
-  private List<Protocol> protocols;
-  private List<ConnectionSpec> connectionSpecs;
-  private final List<Interceptor> interceptors = new ArrayList<>();
-  private final List<Interceptor> networkInterceptors = new ArrayList<>();
-  private ProxySelector proxySelector;
-  private CookieHandler cookieHandler;
-
-  /** Non-null if this client is caching; possibly by {@code cache}. */
-  private InternalCache internalCache;
-  private Cache cache;
-
-  private SocketFactory socketFactory;
-  private SSLSocketFactory sslSocketFactory;
-  private HostnameVerifier hostnameVerifier;
-  private CertificatePinner certificatePinner;
-  private Authenticator authenticator;
-  private ConnectionPool connectionPool;
-  private Network network;
-  private boolean followSslRedirects = true;
-  private boolean followRedirects = true;
-  private boolean retryOnConnectionFailure = true;
-  private int connectTimeout;
-  private int readTimeout;
-  private int writeTimeout;
-
-  public OkHttpClient() {
-    routeDatabase = new RouteDatabase();
-    dispatcher = new Dispatcher();
-  }
-
-  private OkHttpClient(OkHttpClient okHttpClient) {
-    this.routeDatabase = okHttpClient.routeDatabase;
-    this.dispatcher = okHttpClient.dispatcher;
-    this.proxy = okHttpClient.proxy;
-    this.protocols = okHttpClient.protocols;
-    this.connectionSpecs = okHttpClient.connectionSpecs;
-    this.interceptors.addAll(okHttpClient.interceptors);
-    this.networkInterceptors.addAll(okHttpClient.networkInterceptors);
-    this.proxySelector = okHttpClient.proxySelector;
-    this.cookieHandler = okHttpClient.cookieHandler;
-    this.cache = okHttpClient.cache;
-    this.internalCache = cache != null ? cache.internalCache : okHttpClient.internalCache;
-    this.socketFactory = okHttpClient.socketFactory;
-    this.sslSocketFactory = okHttpClient.sslSocketFactory;
-    this.hostnameVerifier = okHttpClient.hostnameVerifier;
-    this.certificatePinner = okHttpClient.certificatePinner;
-    this.authenticator = okHttpClient.authenticator;
-    this.connectionPool = okHttpClient.connectionPool;
-    this.network = okHttpClient.network;
-    this.followSslRedirects = okHttpClient.followSslRedirects;
-    this.followRedirects = okHttpClient.followRedirects;
-    this.retryOnConnectionFailure = okHttpClient.retryOnConnectionFailure;
-    this.connectTimeout = okHttpClient.connectTimeout;
-    this.readTimeout = okHttpClient.readTimeout;
-    this.writeTimeout = okHttpClient.writeTimeout;
-  }
-
-  /**
-   * Sets the default connect timeout for new connections. A value of 0 means no timeout, otherwise
-   * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
-   *
-   * @see URLConnection#setConnectTimeout(int)
-   */
-  public final void setConnectTimeout(long timeout, TimeUnit unit) {
-    if (timeout < 0) throw new IllegalArgumentException("timeout < 0");
-    if (unit == null) throw new IllegalArgumentException("unit == null");
-    long millis = unit.toMillis(timeout);
-    if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException("Timeout too large.");
-    if (millis == 0 && timeout > 0) throw new IllegalArgumentException("Timeout too small.");
-    connectTimeout = (int) millis;
-  }
-
-  /** Default connect timeout (in milliseconds). */
-  public final int getConnectTimeout() {
-    return connectTimeout;
-  }
-
-  /**
-   * Sets the default read timeout for new connections. A value of 0 means no timeout, otherwise
-   * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
-   *
-   * @see URLConnection#setReadTimeout(int)
-   */
-  public final void setReadTimeout(long timeout, TimeUnit unit) {
-    if (timeout < 0) throw new IllegalArgumentException("timeout < 0");
-    if (unit == null) throw new IllegalArgumentException("unit == null");
-    long millis = unit.toMillis(timeout);
-    if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException("Timeout too large.");
-    if (millis == 0 && timeout > 0) throw new IllegalArgumentException("Timeout too small.");
-    readTimeout = (int) millis;
-  }
-
-  /** Default read timeout (in milliseconds). */
-  public final int getReadTimeout() {
-    return readTimeout;
-  }
-
-  /**
-   * Sets the default write timeout for new connections. A value of 0 means no timeout, otherwise
-   * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
-   */
-  public final void setWriteTimeout(long timeout, TimeUnit unit) {
-    if (timeout < 0) throw new IllegalArgumentException("timeout < 0");
-    if (unit == null) throw new IllegalArgumentException("unit == null");
-    long millis = unit.toMillis(timeout);
-    if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException("Timeout too large.");
-    if (millis == 0 && timeout > 0) throw new IllegalArgumentException("Timeout too small.");
-    writeTimeout = (int) millis;
-  }
-
-  /** Default write timeout (in milliseconds). */
-  public final int getWriteTimeout() {
-    return writeTimeout;
-  }
-
-  /**
-   * Sets the HTTP proxy that will be used by connections created by this
-   * client. This takes precedence over {@link #setProxySelector}, which is
-   * only honored when this proxy is null (which it is by default). To disable
-   * proxy use completely, call {@code setProxy(Proxy.NO_PROXY)}.
-   */
-  public final OkHttpClient setProxy(Proxy proxy) {
-    this.proxy = proxy;
-    return this;
-  }
-
-  public final Proxy getProxy() {
-    return proxy;
-  }
-
-  /**
-   * Sets the proxy selection policy to be used if no {@link #setProxy proxy}
-   * is specified explicitly. The proxy selector may return multiple proxies;
-   * in that case they will be tried in sequence until a successful connection
-   * is established.
-   *
-   * <p>If unset, the {@link ProxySelector#getDefault() system-wide default}
-   * proxy selector will be used.
-   */
-  public final OkHttpClient setProxySelector(ProxySelector proxySelector) {
-    this.proxySelector = proxySelector;
-    return this;
-  }
-
-  public final ProxySelector getProxySelector() {
-    return proxySelector;
-  }
-
-  /**
-   * Sets the cookie handler to be used to read outgoing cookies and write
-   * incoming cookies.
-   *
-   * <p>If unset, the {@link CookieHandler#getDefault() system-wide default}
-   * cookie handler will be used.
-   */
-  public final OkHttpClient setCookieHandler(CookieHandler cookieHandler) {
-    this.cookieHandler = cookieHandler;
-    return this;
-  }
-
-  public final CookieHandler getCookieHandler() {
-    return cookieHandler;
-  }
-
-  /** Sets the response cache to be used to read and write cached responses. */
-  final void setInternalCache(InternalCache internalCache) {
-    this.internalCache = internalCache;
-    this.cache = null;
-  }
-
-  final InternalCache internalCache() {
-    return internalCache;
-  }
-
-  public final OkHttpClient setCache(Cache cache) {
-    this.cache = cache;
-    this.internalCache = null;
-    return this;
-  }
-
-  public final Cache getCache() {
-    return cache;
-  }
-
-  /**
-   * Sets the socket factory used to create connections.
-   *
-   * <p>If unset, the {@link SocketFactory#getDefault() system-wide default}
-   * socket factory will be used.
-   */
-  public final OkHttpClient setSocketFactory(SocketFactory socketFactory) {
-    this.socketFactory = socketFactory;
-    return this;
-  }
-
-  public final SocketFactory getSocketFactory() {
-    return socketFactory;
-  }
-
-  /**
-   * Sets the socket factory used to secure HTTPS connections.
-   *
-   * <p>If unset, a lazily created SSL socket factory will be used.
-   */
-  public final OkHttpClient setSslSocketFactory(SSLSocketFactory sslSocketFactory) {
-    this.sslSocketFactory = sslSocketFactory;
-    return this;
-  }
-
-  public final SSLSocketFactory getSslSocketFactory() {
-    return sslSocketFactory;
-  }
-
-  /**
-   * Sets the verifier used to confirm that response certificates apply to
-   * requested hostnames for HTTPS connections.
-   *
-   * <p>If unset, a default hostname verifier will be used.
-   */
-  public final OkHttpClient setHostnameVerifier(HostnameVerifier hostnameVerifier) {
-    this.hostnameVerifier = hostnameVerifier;
-    return this;
-  }
-
-  public final HostnameVerifier getHostnameVerifier() {
-    return hostnameVerifier;
-  }
-
-  /**
-   * Sets the certificate pinner that constrains which certificates are trusted.
-   * By default HTTPS connections rely on only the {@link #setSslSocketFactory
-   * SSL socket factory} to establish trust. Pinning certificates avoids the
-   * need to trust certificate authorities.
-   */
-  public final OkHttpClient setCertificatePinner(CertificatePinner certificatePinner) {
-    this.certificatePinner = certificatePinner;
-    return this;
-  }
-
-  public final CertificatePinner getCertificatePinner() {
-    return certificatePinner;
-  }
-
-  /**
-   * Sets the authenticator used to respond to challenges from the remote web
-   * server or proxy server.
-   *
-   * <p>If unset, the {@link java.net.Authenticator#setDefault system-wide default}
-   * authenticator will be used.
-   */
-  public final OkHttpClient setAuthenticator(Authenticator authenticator) {
-    this.authenticator = authenticator;
-    return this;
-  }
-
-  public final Authenticator getAuthenticator() {
-    return authenticator;
-  }
-
-  /**
-   * Sets the connection pool used to recycle HTTP and HTTPS connections.
-   *
-   * <p>If unset, the {@link ConnectionPool#getDefault() system-wide
-   * default} connection pool will be used.
-   */
-  public final OkHttpClient setConnectionPool(ConnectionPool connectionPool) {
-    this.connectionPool = connectionPool;
-    return this;
-  }
-
-  public final ConnectionPool getConnectionPool() {
-    return connectionPool;
-  }
-
-  /**
-   * Configure this client to follow redirects from HTTPS to HTTP and from HTTP
-   * to HTTPS.
-   *
-   * <p>If unset, protocol redirects will be followed. This is different than
-   * the built-in {@code HttpURLConnection}'s default.
-   */
-  public final OkHttpClient setFollowSslRedirects(boolean followProtocolRedirects) {
-    this.followSslRedirects = followProtocolRedirects;
-    return this;
-  }
-
-  public final boolean getFollowSslRedirects() {
-    return followSslRedirects;
-  }
-
-  /** Configure this client to follow redirects. If unset, redirects be followed. */
-  public final void setFollowRedirects(boolean followRedirects) {
-    this.followRedirects = followRedirects;
-  }
-
-  public final boolean getFollowRedirects() {
-    return followRedirects;
-  }
-
-  /**
-   * Configure this client to retry or not when a connectivity problem is encountered. By default,
-   * this client silently recovers from the following problems:
-   *
-   * <ul>
-   *   <li><strong>Unreachable IP addresses.</strong> If the URL's host has multiple IP addresses,
-   *       failure to reach any individual IP address doesn't fail the overall request. This can
-   *       increase availability of multi-homed services.
-   *   <li><strong>Stale pooled connections.</strong> The {@link ConnectionPool} reuses sockets
-   *       to decrease request latency, but these connections will occasionally time out.
-   *   <li><strong>Unreachable proxy servers.</strong> A {@link ProxySelector} can be used to
-   *       attempt multiple proxy servers in sequence, eventually falling back to a direct
-   *       connection.
-   * </ul>
-   *
-   * Set this to false to avoid retrying requests when doing so is destructive. In this case the
-   * calling application should do its own recovery of connectivity failures.
-   */
-  public final void setRetryOnConnectionFailure(boolean retryOnConnectionFailure) {
-    this.retryOnConnectionFailure = retryOnConnectionFailure;
-  }
-
-  public final boolean getRetryOnConnectionFailure() {
-    return retryOnConnectionFailure;
-  }
-
-  final RouteDatabase routeDatabase() {
-    return routeDatabase;
-  }
-
-  /**
-   * Sets the dispatcher used to set policy and execute asynchronous requests.
-   * Must not be null.
-   */
-  public final OkHttpClient setDispatcher(Dispatcher dispatcher) {
-    if (dispatcher == null) throw new IllegalArgumentException("dispatcher == null");
-    this.dispatcher = dispatcher;
-    return this;
-  }
-
-  public final Dispatcher getDispatcher() {
-    return dispatcher;
-  }
-
-  /**
-   * Configure the protocols used by this client to communicate with remote
-   * servers. By default this client will prefer the most efficient transport
-   * available, falling back to more ubiquitous protocols. Applications should
-   * only call this method to avoid specific compatibility problems, such as web
-   * servers that behave incorrectly when SPDY is enabled.
-   *
-   * <p>The following protocols are currently supported:
-   * <ul>
-   *   <li><a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html">http/1.1</a>
-   *   <li><a href="http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1">spdy/3.1</a>
-   *   <li><a href="http://tools.ietf.org/html/draft-ietf-httpbis-http2-17">h2</a>
-   * </ul>
-   *
-   * <p><strong>This is an evolving set.</strong> Future releases include
-   * support for transitional protocols. The http/1.1 transport will never be
-   * dropped.
-   *
-   * <p>If multiple protocols are specified, <a
-   * href="http://tools.ietf.org/html/draft-ietf-tls-applayerprotoneg">ALPN</a>
-   * will be used to negotiate a transport.
-   *
-   * <p>{@link Protocol#HTTP_1_0} is not supported in this set. Requests are
-   * initiated with {@code HTTP/1.1} only. If the server responds with {@code
-   * HTTP/1.0}, that will be exposed by {@link Response#protocol()}.
-   *
-   * @param protocols the protocols to use, in order of preference. The list
-   *     must contain {@link Protocol#HTTP_1_1}. It must not contain null or
-   *     {@link Protocol#HTTP_1_0}.
-   */
-  public final OkHttpClient setProtocols(List<Protocol> protocols) {
-    protocols = Util.immutableList(protocols);
-    if (!protocols.contains(Protocol.HTTP_1_1)) {
-      throw new IllegalArgumentException("protocols doesn't contain http/1.1: " + protocols);
-    }
-    if (protocols.contains(Protocol.HTTP_1_0)) {
-      throw new IllegalArgumentException("protocols must not contain http/1.0: " + protocols);
-    }
-    if (protocols.contains(null)) {
-      throw new IllegalArgumentException("protocols must not contain null");
-    }
-    this.protocols = Util.immutableList(protocols);
-    return this;
-  }
-
-  public final List<Protocol> getProtocols() {
-    return protocols;
-  }
-
-  public final OkHttpClient setConnectionSpecs(List<ConnectionSpec> connectionSpecs) {
-    this.connectionSpecs = Util.immutableList(connectionSpecs);
-    return this;
-  }
-
-  public final List<ConnectionSpec> getConnectionSpecs() {
-    return connectionSpecs;
-  }
-
-  /**
-   * Returns a modifiable list of interceptors that observe the full span of each call: from before
-   * the connection is established (if any) until after the response source is selected (either the
-   * origin server, cache, or both).
-   */
-  public List<Interceptor> interceptors() {
-    return interceptors;
-  }
-
-  /**
-   * Returns a modifiable list of interceptors that observe a single network request and response.
-   * These interceptors must call {@link Interceptor.Chain#proceed} exactly once: it is an error for
-   * a network interceptor to short-circuit or repeat a network request.
-   */
-  public List<Interceptor> networkInterceptors() {
-    return networkInterceptors;
-  }
-
-  /**
-   * Prepares the {@code request} to be executed at some point in the future.
-   */
-  public Call newCall(Request request) {
-    return new Call(this, request);
-  }
-
-  /**
-   * Cancels all scheduled or in-flight calls tagged with {@code tag}. Requests
-   * that are already complete cannot be canceled.
-   */
-  public OkHttpClient cancel(Object tag) {
-    getDispatcher().cancel(tag);
-    return this;
-  }
-
-  /**
-   * Returns a shallow copy of this OkHttpClient that uses the system-wide
-   * default for each field that hasn't been explicitly configured.
-   */
-  final OkHttpClient copyWithDefaults() {
-    OkHttpClient result = new OkHttpClient(this);
-    if (result.proxySelector == null) {
-      result.proxySelector = ProxySelector.getDefault();
-    }
-    if (result.cookieHandler == null) {
-      result.cookieHandler = CookieHandler.getDefault();
-    }
-    if (result.socketFactory == null) {
-      result.socketFactory = SocketFactory.getDefault();
-    }
-    if (result.sslSocketFactory == null) {
-      result.sslSocketFactory = getDefaultSSLSocketFactory();
-    }
-    if (result.hostnameVerifier == null) {
-      result.hostnameVerifier = OkHostnameVerifier.INSTANCE;
-    }
-    if (result.certificatePinner == null) {
-      result.certificatePinner = CertificatePinner.DEFAULT;
-    }
-    if (result.authenticator == null) {
-      result.authenticator = AuthenticatorAdapter.INSTANCE;
-    }
-    if (result.connectionPool == null) {
-      result.connectionPool = ConnectionPool.getDefault();
-    }
-    if (result.protocols == null) {
-      result.protocols = DEFAULT_PROTOCOLS;
-    }
-    if (result.connectionSpecs == null) {
-      result.connectionSpecs = DEFAULT_CONNECTION_SPECS;
-    }
-    if (result.network == null) {
-      result.network = Network.DEFAULT;
-    }
-    return result;
-  }
-
-  /**
-   * Java and Android programs default to using a single global SSL context,
-   * accessible to HTTP clients as {@link SSLSocketFactory#getDefault()}. If we
-   * used the shared SSL context, when OkHttp enables ALPN for its SPDY-related
-   * stuff, it would also enable ALPN for other usages, which might crash them
-   * because ALPN is enabled when it isn't expected to be.
-   *
-   * <p>This code avoids that by defaulting to an OkHttp-created SSL context.
-   * The drawback of this approach is that apps that customize the global SSL
-   * context will lose these customizations.
-   */
-  private synchronized SSLSocketFactory getDefaultSSLSocketFactory() {
-    if (defaultSslSocketFactory == null) {
-      try {
-        SSLContext sslContext = SSLContext.getInstance("TLS");
-        sslContext.init(null, null, null);
-        defaultSslSocketFactory = sslContext.getSocketFactory();
-      } catch (GeneralSecurityException e) {
-        throw new AssertionError(); // The system has no TLS. Just give up.
-      }
-    }
-    return defaultSslSocketFactory;
-  }
-
-  /** Returns a shallow copy of this OkHttpClient. */
-  @Override public final OkHttpClient clone() {
-    try {
-      return (OkHttpClient) super.clone();
-    } catch (CloneNotSupportedException e) {
-      throw new AssertionError();
-    }
-  }
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/ResponseBody.java b/okhttp/src/main/java/com/squareup/okhttp/ResponseBody.java
deleted file mode 100644
index bdd98b4c69..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/ResponseBody.java
+++ /dev/null
@@ -1,136 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp;
-
-import com.squareup.okhttp.internal.Util;
-import java.io.Closeable;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.io.Reader;
-import java.nio.charset.Charset;
-import okio.Buffer;
-import okio.BufferedSource;
-
-import static com.squareup.okhttp.internal.Util.UTF_8;
-
-public abstract class ResponseBody implements Closeable {
-  /** Multiple calls to {@link #charStream()} must return the same instance. */
-  private Reader reader;
-
-  public abstract MediaType contentType();
-
-  /**
-   * Returns the number of bytes in that will returned by {@link #bytes}, or
-   * {@link #byteStream}, or -1 if unknown.
-   */
-  public abstract long contentLength() throws IOException;
-
-  public final InputStream byteStream() throws IOException {
-    return source().inputStream();
-  }
-
-  public abstract BufferedSource source() throws IOException;
-
-  public final byte[] bytes() throws IOException {
-    long contentLength = contentLength();
-    if (contentLength > Integer.MAX_VALUE) {
-      throw new IOException("Cannot buffer entire body for content length: " + contentLength);
-    }
-
-    BufferedSource source = source();
-    byte[] bytes;
-    try {
-      bytes = source.readByteArray();
-    } finally {
-      Util.closeQuietly(source);
-    }
-    if (contentLength != -1 && contentLength != bytes.length) {
-      throw new IOException("Content-Length and stream length disagree");
-    }
-    return bytes;
-  }
-
-  /**
-   * Returns the response as a character stream decoded with the charset
-   * of the Content-Type header. If that header is either absent or lacks a
-   * charset, this will attempt to decode the response body as UTF-8.
-   */
-  public final Reader charStream() throws IOException {
-    Reader r = reader;
-    return r != null ? r : (reader = new InputStreamReader(byteStream(), charset()));
-  }
-
-  /**
-   * Returns the response as a string decoded with the charset of the
-   * Content-Type header. If that header is either absent or lacks a charset,
-   * this will attempt to decode the response body as UTF-8.
-   */
-  public final String string() throws IOException {
-    return new String(bytes(), charset().name());
-  }
-
-  private Charset charset() {
-    MediaType contentType = contentType();
-    return contentType != null ? contentType.charset(UTF_8) : UTF_8;
-  }
-
-  @Override public void close() throws IOException {
-    source().close();
-  }
-
-  /**
-   * Returns a new response body that transmits {@code content}. If {@code
-   * contentType} is non-null and lacks a charset, this will use UTF-8.
-   */
-  public static ResponseBody create(MediaType contentType, String content) {
-    Charset charset = Util.UTF_8;
-    if (contentType != null) {
-      charset = contentType.charset();
-      if (charset == null) {
-        charset = Util.UTF_8;
-        contentType = MediaType.parse(contentType + "; charset=utf-8");
-      }
-    }
-    Buffer buffer = new Buffer().writeString(content, charset);
-    return create(contentType, buffer.size(), buffer);
-  }
-
-  /** Returns a new response body that transmits {@code content}. */
-  public static ResponseBody create(final MediaType contentType, byte[] content) {
-    Buffer buffer = new Buffer().write(content);
-    return create(contentType, content.length, buffer);
-  }
-
-  /** Returns a new response body that transmits {@code content}. */
-  public static ResponseBody create(
-      final MediaType contentType, final long contentLength, final BufferedSource content) {
-    if (content == null) throw new NullPointerException("source == null");
-    return new ResponseBody() {
-      @Override public MediaType contentType() {
-        return contentType;
-      }
-
-      @Override public long contentLength() {
-        return contentLength;
-      }
-
-      @Override public BufferedSource source() {
-        return content;
-      }
-    };
-  }
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/Internal.java b/okhttp/src/main/java/com/squareup/okhttp/internal/Internal.java
deleted file mode 100644
index d806b483c2..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/Internal.java
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal;
-
-import com.squareup.okhttp.Call;
-import com.squareup.okhttp.Callback;
-import com.squareup.okhttp.Connection;
-import com.squareup.okhttp.ConnectionPool;
-import com.squareup.okhttp.Headers;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Protocol;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.internal.http.HttpEngine;
-import com.squareup.okhttp.internal.http.Transport;
-import java.io.IOException;
-import java.util.logging.Logger;
-
-/**
- * Escalate internal APIs in {@code com.squareup.okhttp} so they can be used
- * from OkHttp's implementation packages. The only implementation of this
- * interface is in {@link com.squareup.okhttp.OkHttpClient}.
- */
-public abstract class Internal {
-  public static final Logger logger = Logger.getLogger(OkHttpClient.class.getName());
-  public static Internal instance;
-
-  public abstract Transport newTransport(Connection connection, HttpEngine httpEngine)
-      throws IOException;
-
-  public abstract boolean clearOwner(Connection connection);
-
-  public abstract void closeIfOwnedBy(Connection connection, Object owner) throws IOException;
-
-  public abstract int recycleCount(Connection connection);
-
-  public abstract void setProtocol(Connection connection, Protocol protocol);
-
-  public abstract void setOwner(Connection connection, HttpEngine httpEngine);
-
-  public abstract boolean isReadable(Connection pooled);
-
-  public abstract void addLenient(Headers.Builder builder, String line);
-
-  public abstract void setCache(OkHttpClient client, InternalCache internalCache);
-
-  public abstract InternalCache internalCache(OkHttpClient client);
-
-  public abstract void recycle(ConnectionPool pool, Connection connection);
-
-  public abstract RouteDatabase routeDatabase(OkHttpClient client);
-
-  public abstract Network network(OkHttpClient client);
-
-  public abstract void setNetwork(OkHttpClient client, Network network);
-
-  public abstract void connectAndSetOwner(OkHttpClient client, Connection connection,
-      HttpEngine owner, Request request) throws IOException;
-
-  // TODO delete the following when web sockets move into the main package.
-  public abstract void callEnqueue(Call call, Callback responseCallback, boolean forWebSocket);
-  public abstract void callEngineReleaseConnection(Call call) throws IOException;
-  public abstract Connection callEngineGetConnection(Call call);
-  public abstract void connectionSetOwner(Connection connection, Object owner);
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/Network.java b/okhttp/src/main/java/com/squareup/okhttp/internal/Network.java
deleted file mode 100644
index a0070651b2..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/Network.java
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal;
-
-import java.net.InetAddress;
-import java.net.UnknownHostException;
-
-/**
- * Services specific to the host device's network interface. Prefer this over {@link
- * InetAddress#getAllByName} to make code more testable.
- */
-public interface Network {
-  Network DEFAULT = new Network() {
-    @Override public InetAddress[] resolveInetAddresses(String host) throws UnknownHostException {
-      if (host == null) throw new UnknownHostException("host == null");
-      return InetAddress.getAllByName(host);
-    }
-  };
-
-  InetAddress[] resolveInetAddresses(String host) throws UnknownHostException;
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/Platform.java b/okhttp/src/main/java/com/squareup/okhttp/internal/Platform.java
deleted file mode 100644
index 073f75f9c4..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/Platform.java
+++ /dev/null
@@ -1,378 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- * Copyright (C) 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal;
-
-import com.squareup.okhttp.Protocol;
-import java.io.IOException;
-import java.lang.reflect.InvocationHandler;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.lang.reflect.Proxy;
-import java.net.InetSocketAddress;
-import java.net.Socket;
-import java.net.SocketException;
-import java.net.URI;
-import java.net.URISyntaxException;
-import java.net.URL;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.logging.Level;
-import javax.net.ssl.SSLSocket;
-import okio.Buffer;
-
-import static com.squareup.okhttp.internal.Internal.logger;
-
-/**
- * Access to platform-specific features.
- *
- * <h3>Server name indication (SNI)</h3>
- * Supported on Android 2.3+.
- *
- * <h3>Session Tickets</h3>
- * Supported on Android 2.3+.
- *
- * <h3>Android Traffic Stats (Socket Tagging)</h3>
- * Supported on Android 4.0+.
- *
- * <h3>ALPN (Application Layer Protocol Negotiation)</h3>
- * Supported on Android 5.0+. The APIs were present in Android 4.4, but that implementation was
- * unstable.
- *
- * Supported on OpenJDK 7 and 8 (via the JettyALPN-boot library).
- */
-public class Platform {
-  private static final Platform PLATFORM = findPlatform();
-
-  public static Platform get() {
-    return PLATFORM;
-  }
-
-  /** Prefix used on custom headers. */
-  public String getPrefix() {
-    return "OkHttp";
-  }
-
-  public void logW(String warning) {
-    System.out.println(warning);
-  }
-
-  public void tagSocket(Socket socket) throws SocketException {
-  }
-
-  public void untagSocket(Socket socket) throws SocketException {
-  }
-
-  public URI toUriLenient(URL url) throws URISyntaxException {
-    return url.toURI(); // this isn't as good as the built-in toUriLenient
-  }
-
-  /**
-   * Configure TLS extensions on {@code sslSocket} for {@code route}.
-   *
-   * @param hostname non-null for client-side handshakes; null for
-   *     server-side handshakes.
-   */
-  public void configureTlsExtensions(SSLSocket sslSocket, String hostname,
-      List<Protocol> protocols) {
-  }
-
-  /**
-   * Called after the TLS handshake to release resources allocated by {@link
-   * #configureTlsExtensions}.
-   */
-  public void afterHandshake(SSLSocket sslSocket) {
-  }
-
-  /** Returns the negotiated protocol, or null if no protocol was negotiated. */
-  public String getSelectedProtocol(SSLSocket socket) {
-    return null;
-  }
-
-  public void connectSocket(Socket socket, InetSocketAddress address,
-      int connectTimeout) throws IOException {
-    socket.connect(address, connectTimeout);
-  }
-
-  /** Attempt to match the host runtime to a capable Platform implementation. */
-  private static Platform findPlatform() {
-    // Attempt to find Android 2.3+ APIs.
-    try {
-      try {
-        Class.forName("com.android.org.conscrypt.OpenSSLSocketImpl");
-      } catch (ClassNotFoundException e) {
-        // Older platform before being unbundled.
-        Class.forName("org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl");
-      }
-
-      OptionalMethod<Socket> setUseSessionTickets
-          = new OptionalMethod<>(null, "setUseSessionTickets", boolean.class);
-      OptionalMethod<Socket> setHostname
-          = new OptionalMethod<>(null, "setHostname", String.class);
-      Method trafficStatsTagSocket = null;
-      Method trafficStatsUntagSocket = null;
-      OptionalMethod<Socket> getAlpnSelectedProtocol = null;
-      OptionalMethod<Socket> setAlpnProtocols = null;
-
-      // Attempt to find Android 4.0+ APIs.
-      try {
-        Class<?> trafficStats = Class.forName("android.net.TrafficStats");
-        trafficStatsTagSocket = trafficStats.getMethod("tagSocket", Socket.class);
-        trafficStatsUntagSocket = trafficStats.getMethod("untagSocket", Socket.class);
-
-        // Attempt to find Android 5.0+ APIs.
-        try {
-          Class.forName("android.net.Network"); // Arbitrary class added in Android 5.0.
-          getAlpnSelectedProtocol = new OptionalMethod<>(byte[].class, "getAlpnSelectedProtocol");
-          setAlpnProtocols = new OptionalMethod<>(null, "setAlpnProtocols", byte[].class);
-        } catch (ClassNotFoundException ignored) {
-        }
-      } catch (ClassNotFoundException | NoSuchMethodException ignored) {
-      }
-
-      return new Android(setUseSessionTickets, setHostname, trafficStatsTagSocket,
-          trafficStatsUntagSocket, getAlpnSelectedProtocol, setAlpnProtocols);
-    } catch (ClassNotFoundException ignored) {
-      // This isn't an Android runtime.
-    }
-
-    // Find Jetty's ALPN extension for OpenJDK.
-    try {
-      String negoClassName = "org.eclipse.jetty.alpn.ALPN";
-      Class<?> negoClass = Class.forName(negoClassName);
-      Class<?> providerClass = Class.forName(negoClassName + "$Provider");
-      Class<?> clientProviderClass = Class.forName(negoClassName + "$ClientProvider");
-      Class<?> serverProviderClass = Class.forName(negoClassName + "$ServerProvider");
-      Method putMethod = negoClass.getMethod("put", SSLSocket.class, providerClass);
-      Method getMethod = negoClass.getMethod("get", SSLSocket.class);
-      Method removeMethod = negoClass.getMethod("remove", SSLSocket.class);
-      return new JdkWithJettyBootPlatform(
-          putMethod, getMethod, removeMethod, clientProviderClass, serverProviderClass);
-    } catch (ClassNotFoundException | NoSuchMethodException ignored) {
-    }
-
-    return new Platform();
-  }
-
-  /** Android 2.3 or better. */
-  private static class Android extends Platform {
-    private final OptionalMethod<Socket> setUseSessionTickets;
-    private final OptionalMethod<Socket> setHostname;
-
-    // Non-null on Android 4.0+.
-    private final Method trafficStatsTagSocket;
-    private final Method trafficStatsUntagSocket;
-
-    // Non-null on Android 5.0+.
-    private final OptionalMethod<Socket> getAlpnSelectedProtocol;
-    private final OptionalMethod<Socket> setAlpnProtocols;
-
-    public Android(OptionalMethod<Socket> setUseSessionTickets, OptionalMethod<Socket> setHostname,
-        Method trafficStatsTagSocket, Method trafficStatsUntagSocket,
-        OptionalMethod<Socket> getAlpnSelectedProtocol, OptionalMethod<Socket> setAlpnProtocols) {
-      this.setUseSessionTickets = setUseSessionTickets;
-      this.setHostname = setHostname;
-      this.trafficStatsTagSocket = trafficStatsTagSocket;
-      this.trafficStatsUntagSocket = trafficStatsUntagSocket;
-      this.getAlpnSelectedProtocol = getAlpnSelectedProtocol;
-      this.setAlpnProtocols = setAlpnProtocols;
-    }
-
-    @Override public void connectSocket(Socket socket, InetSocketAddress address,
-        int connectTimeout) throws IOException {
-      try {
-        socket.connect(address, connectTimeout);
-      } catch (SecurityException se) {
-        // Before android 4.3, socket.connect could throw a SecurityException
-        // if opening a socket resulted in an EACCES error.
-        IOException ioException = new IOException("Exception in connect");
-        ioException.initCause(se);
-        throw ioException;
-      }
-    }
-
-    @Override public void configureTlsExtensions(
-        SSLSocket sslSocket, String hostname, List<Protocol> protocols) {
-      // Enable SNI and session tickets.
-      if (hostname != null) {
-        setUseSessionTickets.invokeOptionalWithoutCheckedException(sslSocket, true);
-        setHostname.invokeOptionalWithoutCheckedException(sslSocket, hostname);
-      }
-
-      // Enable ALPN.
-      if (setAlpnProtocols != null && setAlpnProtocols.isSupported(sslSocket)) {
-        Object[] parameters = { concatLengthPrefixed(protocols) };
-        setAlpnProtocols.invokeWithoutCheckedException(sslSocket, parameters);
-      }
-    }
-
-    @Override public String getSelectedProtocol(SSLSocket socket) {
-      if (getAlpnSelectedProtocol == null) return null;
-      if (!getAlpnSelectedProtocol.isSupported(socket)) return null;
-
-      byte[] alpnResult = (byte[]) getAlpnSelectedProtocol.invokeWithoutCheckedException(socket);
-      return alpnResult != null ? new String(alpnResult, Util.UTF_8) : null;
-    }
-
-    @Override public void tagSocket(Socket socket) throws SocketException {
-      if (trafficStatsTagSocket == null) return;
-
-      try {
-        trafficStatsTagSocket.invoke(null, socket);
-      } catch (IllegalAccessException e) {
-        throw new RuntimeException(e);
-      } catch (InvocationTargetException e) {
-        throw new RuntimeException(e.getCause());
-      }
-    }
-
-    @Override public void untagSocket(Socket socket) throws SocketException {
-      if (trafficStatsUntagSocket == null) return;
-
-      try {
-        trafficStatsUntagSocket.invoke(null, socket);
-      } catch (IllegalAccessException e) {
-        throw new RuntimeException(e);
-      } catch (InvocationTargetException e) {
-        throw new RuntimeException(e.getCause());
-      }
-    }
-  }
-
-  /**
-   * OpenJDK 7+ with {@code org.mortbay.jetty.alpn/alpn-boot} in the boot class path.
-   */
-  private static class JdkWithJettyBootPlatform extends Platform {
-    private final Method putMethod;
-    private final Method getMethod;
-    private final Method removeMethod;
-    private final Class<?> clientProviderClass;
-    private final Class<?> serverProviderClass;
-
-    public JdkWithJettyBootPlatform(Method putMethod, Method getMethod, Method removeMethod,
-        Class<?> clientProviderClass, Class<?> serverProviderClass) {
-      this.putMethod = putMethod;
-      this.getMethod = getMethod;
-      this.removeMethod = removeMethod;
-      this.clientProviderClass = clientProviderClass;
-      this.serverProviderClass = serverProviderClass;
-    }
-
-    @Override public void configureTlsExtensions(
-        SSLSocket sslSocket, String hostname, List<Protocol> protocols) {
-      List<String> names = new ArrayList<>(protocols.size());
-      for (int i = 0, size = protocols.size(); i < size; i++) {
-        Protocol protocol = protocols.get(i);
-        if (protocol == Protocol.HTTP_1_0) continue; // No HTTP/1.0 for ALPN.
-        names.add(protocol.toString());
-      }
-      try {
-        Object provider = Proxy.newProxyInstance(Platform.class.getClassLoader(),
-            new Class[] { clientProviderClass, serverProviderClass }, new JettyNegoProvider(names));
-        putMethod.invoke(null, sslSocket, provider);
-      } catch (InvocationTargetException | IllegalAccessException e) {
-        throw new AssertionError(e);
-      }
-    }
-
-    @Override public void afterHandshake(SSLSocket sslSocket) {
-      try {
-        removeMethod.invoke(null, sslSocket);
-      } catch (IllegalAccessException | InvocationTargetException ignored) {
-        throw new AssertionError();
-      }
-    }
-
-    @Override public String getSelectedProtocol(SSLSocket socket) {
-      try {
-        JettyNegoProvider provider =
-            (JettyNegoProvider) Proxy.getInvocationHandler(getMethod.invoke(null, socket));
-        if (!provider.unsupported && provider.selected == null) {
-          logger.log(Level.INFO, "ALPN callback dropped: SPDY and HTTP/2 are disabled. "
-              + "Is alpn-boot on the boot class path?");
-          return null;
-        }
-        return provider.unsupported ? null : provider.selected;
-      } catch (InvocationTargetException | IllegalAccessException e) {
-        throw new AssertionError();
-      }
-    }
-  }
-
-  /**
-   * Handle the methods of ALPN's ClientProvider and ServerProvider
-   * without a compile-time dependency on those interfaces.
-   */
-  private static class JettyNegoProvider implements InvocationHandler {
-    /** This peer's supported protocols. */
-    private final List<String> protocols;
-    /** Set when remote peer notifies ALPN is unsupported. */
-    private boolean unsupported;
-    /** The protocol the server selected. */
-    private String selected;
-
-    public JettyNegoProvider(List<String> protocols) {
-      this.protocols = protocols;
-    }
-
-    @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
-      String methodName = method.getName();
-      Class<?> returnType = method.getReturnType();
-      if (args == null) {
-        args = Util.EMPTY_STRING_ARRAY;
-      }
-      if (methodName.equals("supports") && boolean.class == returnType) {
-        return true; // ALPN is supported.
-      } else if (methodName.equals("unsupported") && void.class == returnType) {
-        this.unsupported = true; // Peer doesn't support ALPN.
-        return null;
-      } else if (methodName.equals("protocols") && args.length == 0) {
-        return protocols; // Client advertises these protocols.
-      } else if ((methodName.equals("selectProtocol") || methodName.equals("select"))
-          && String.class == returnType && args.length == 1 && args[0] instanceof List) {
-        List<String> peerProtocols = (List) args[0];
-        // Pick the first known protocol the peer advertises.
-        for (int i = 0, size = peerProtocols.size(); i < size; i++) {
-          if (protocols.contains(peerProtocols.get(i))) {
-            return selected = peerProtocols.get(i);
-          }
-        }
-        return selected = protocols.get(0); // On no intersection, try peer's first protocol.
-      } else if ((methodName.equals("protocolSelected") || methodName.equals("selected"))
-          && args.length == 1) {
-        this.selected = (String) args[0]; // Server selected this protocol.
-        return null;
-      } else {
-        return method.invoke(this, args);
-      }
-    }
-  }
-
-  /**
-   * Returns the concatenation of 8-bit, length prefixed protocol names.
-   * http://tools.ietf.org/html/draft-agl-tls-nextprotoneg-04#page-4
-   */
-  static byte[] concatLengthPrefixed(List<Protocol> protocols) {
-    Buffer result = new Buffer();
-    for (int i = 0, size = protocols.size(); i < size; i++) {
-      Protocol protocol = protocols.get(i);
-      if (protocol == Protocol.HTTP_1_0) continue; // No HTTP/1.0 for ALPN.
-      result.writeByte(protocol.toString().length());
-      result.writeUtf8(protocol.toString());
-    }
-    return result.readByteArray();
-  }
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/Util.java b/okhttp/src/main/java/com/squareup/okhttp/internal/Util.java
deleted file mode 100644
index eee686f104..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/Util.java
+++ /dev/null
@@ -1,275 +0,0 @@
-/*
- * Copyright (C) 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.squareup.okhttp.internal;
-
-import java.io.Closeable;
-import java.io.IOException;
-import java.io.InterruptedIOException;
-import java.io.UnsupportedEncodingException;
-import java.lang.reflect.Array;
-import java.net.ServerSocket;
-import java.net.Socket;
-import java.net.URI;
-import java.net.URL;
-import java.nio.charset.Charset;
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.ThreadFactory;
-import java.util.concurrent.TimeUnit;
-import okio.Buffer;
-import okio.ByteString;
-import okio.Source;
-
-/** Junk drawer of utility methods. */
-public final class Util {
-  public static final byte[] EMPTY_BYTE_ARRAY = new byte[0];
-  public static final String[] EMPTY_STRING_ARRAY = new String[0];
-
-  /** A cheap and type-safe constant for the UTF-8 Charset. */
-  public static final Charset UTF_8 = Charset.forName("UTF-8");
-
-  private Util() {
-  }
-
-  public static int getEffectivePort(URI uri) {
-    return getEffectivePort(uri.getScheme(), uri.getPort());
-  }
-
-  public static int getEffectivePort(URL url) {
-    return getEffectivePort(url.getProtocol(), url.getPort());
-  }
-
-  private static int getEffectivePort(String scheme, int specifiedPort) {
-    return specifiedPort != -1 ? specifiedPort : getDefaultPort(scheme);
-  }
-
-  public static int getDefaultPort(String protocol) {
-    if ("http".equals(protocol)) return 80;
-    if ("https".equals(protocol)) return 443;
-    return -1;
-  }
-
-  public static void checkOffsetAndCount(long arrayLength, long offset, long count) {
-    if ((offset | count) < 0 || offset > arrayLength || arrayLength - offset < count) {
-      throw new ArrayIndexOutOfBoundsException();
-    }
-  }
-
-  /** Returns true if two possibly-null objects are equal. */
-  public static boolean equal(Object a, Object b) {
-    return a == b || (a != null && a.equals(b));
-  }
-
-  /**
-   * Closes {@code closeable}, ignoring any checked exceptions. Does nothing
-   * if {@code closeable} is null.
-   */
-  public static void closeQuietly(Closeable closeable) {
-    if (closeable != null) {
-      try {
-        closeable.close();
-      } catch (RuntimeException rethrown) {
-        throw rethrown;
-      } catch (Exception ignored) {
-      }
-    }
-  }
-
-  /**
-   * Closes {@code socket}, ignoring any checked exceptions. Does nothing if
-   * {@code socket} is null.
-   */
-  public static void closeQuietly(Socket socket) {
-    if (socket != null) {
-      try {
-        socket.close();
-      } catch (RuntimeException rethrown) {
-        throw rethrown;
-      } catch (Exception ignored) {
-      }
-    }
-  }
-
-  /**
-   * Closes {@code serverSocket}, ignoring any checked exceptions. Does nothing if
-   * {@code serverSocket} is null.
-   */
-  public static void closeQuietly(ServerSocket serverSocket) {
-    if (serverSocket != null) {
-      try {
-        serverSocket.close();
-      } catch (RuntimeException rethrown) {
-        throw rethrown;
-      } catch (Exception ignored) {
-      }
-    }
-  }
-
-  /**
-   * Closes {@code a} and {@code b}. If either close fails, this completes
-   * the other close and rethrows the first encountered exception.
-   */
-  public static void closeAll(Closeable a, Closeable b) throws IOException {
-    Throwable thrown = null;
-    try {
-      a.close();
-    } catch (Throwable e) {
-      thrown = e;
-    }
-    try {
-      b.close();
-    } catch (Throwable e) {
-      if (thrown == null) thrown = e;
-    }
-    if (thrown == null) return;
-    if (thrown instanceof IOException) throw (IOException) thrown;
-    if (thrown instanceof RuntimeException) throw (RuntimeException) thrown;
-    if (thrown instanceof Error) throw (Error) thrown;
-    throw new AssertionError(thrown);
-  }
-
-  /**
-   * Attempts to exhaust {@code source}, returning true if successful. This is useful when reading
-   * a complete source is helpful, such as when doing so completes a cache body or frees a socket
-   * connection for reuse.
-   */
-  public static boolean discard(Source source, int timeout, TimeUnit timeUnit) {
-    try {
-      return skipAll(source, timeout, timeUnit);
-    } catch (IOException e) {
-      return false;
-    }
-  }
-
-  /**
-   * Reads until {@code in} is exhausted or the deadline has been reached. This is careful to not
-   * extend the deadline if one exists already.
-   */
-  public static boolean skipAll(Source source, int duration, TimeUnit timeUnit) throws IOException {
-    long now = System.nanoTime();
-    long originalDuration = source.timeout().hasDeadline()
-        ? source.timeout().deadlineNanoTime() - now
-        : Long.MAX_VALUE;
-    source.timeout().deadlineNanoTime(now + Math.min(originalDuration, timeUnit.toNanos(duration)));
-    try {
-      Buffer skipBuffer = new Buffer();
-      while (source.read(skipBuffer, 2048) != -1) {
-        skipBuffer.clear();
-      }
-      return true; // Success! The source has been exhausted.
-    } catch (InterruptedIOException e) {
-      return false; // We ran out of time before exhausting the source.
-    } finally {
-      if (originalDuration == Long.MAX_VALUE) {
-        source.timeout().clearDeadline();
-      } else {
-        source.timeout().deadlineNanoTime(now + originalDuration);
-      }
-    }
-  }
-
-  /** Returns a 32 character string containing an MD5 hash of {@code s}. */
-  public static String md5Hex(String s) {
-    try {
-      MessageDigest messageDigest = MessageDigest.getInstance("MD5");
-      byte[] md5bytes = messageDigest.digest(s.getBytes("UTF-8"));
-      return ByteString.of(md5bytes).hex();
-    } catch (NoSuchAlgorithmException | UnsupportedEncodingException e) {
-      throw new AssertionError(e);
-    }
-  }
-
-  /** Returns a Base 64-encoded string containing a SHA-1 hash of {@code s}. */
-  public static String shaBase64(String s) {
-    try {
-      MessageDigest messageDigest = MessageDigest.getInstance("SHA-1");
-      byte[] sha1Bytes = messageDigest.digest(s.getBytes("UTF-8"));
-      return ByteString.of(sha1Bytes).base64();
-    } catch (NoSuchAlgorithmException | UnsupportedEncodingException e) {
-      throw new AssertionError(e);
-    }
-  }
-
-  /** Returns a SHA-1 hash of {@code s}. */
-  public static ByteString sha1(ByteString s) {
-    try {
-      MessageDigest messageDigest = MessageDigest.getInstance("SHA-1");
-      byte[] sha1Bytes = messageDigest.digest(s.toByteArray());
-      return ByteString.of(sha1Bytes);
-    } catch (NoSuchAlgorithmException e) {
-      throw new AssertionError(e);
-    }
-  }
-
-  /** Returns an immutable copy of {@code list}. */
-  public static <T> List<T> immutableList(List<T> list) {
-    return Collections.unmodifiableList(new ArrayList<>(list));
-  }
-
-  /** Returns an immutable list containing {@code elements}. */
-  public static <T> List<T> immutableList(T... elements) {
-    return Collections.unmodifiableList(Arrays.asList(elements.clone()));
-  }
-
-  /** Returns an immutable copy of {@code map}. */
-  public static <K, V> Map<K, V> immutableMap(Map<K, V> map) {
-    return Collections.unmodifiableMap(new LinkedHashMap<>(map));
-  }
-
-  public static ThreadFactory threadFactory(final String name, final boolean daemon) {
-    return new ThreadFactory() {
-      @Override public Thread newThread(Runnable runnable) {
-        Thread result = new Thread(runnable, name);
-        result.setDaemon(daemon);
-        return result;
-      }
-    };
-  }
-
-  /**
-   * Returns an array containing containing only elements found in {@code first}  and also in
-   * {@code second}. The returned elements are in the same order as in {@code first}.
-   */
-  @SuppressWarnings("unchecked")
-  public static <T> T[] intersect(Class<T> arrayType, T[] first, T[] second) {
-    List<T> result = intersect(first, second);
-    return result.toArray((T[]) Array.newInstance(arrayType, result.size()));
-  }
-
-  /**
-   * Returns a list containing containing only elements found in {@code first}  and also in
-   * {@code second}. The returned elements are in the same order as in {@code first}.
-   */
-  private static <T> List<T> intersect(T[] first, T[] second) {
-    List<T> result = new ArrayList<>();
-    for (T a : first) {
-      for (T b : second) {
-        if (a.equals(b)) {
-          result.add(b);
-          break;
-        }
-      }
-    }
-    return result;
-  }
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/AuthenticatorAdapter.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/AuthenticatorAdapter.java
deleted file mode 100644
index a517ada7cc..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/AuthenticatorAdapter.java
+++ /dev/null
@@ -1,87 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal.http;
-
-import com.squareup.okhttp.Authenticator;
-import com.squareup.okhttp.Challenge;
-import com.squareup.okhttp.Credentials;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
-import java.io.IOException;
-import java.net.Authenticator.RequestorType;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.PasswordAuthentication;
-import java.net.Proxy;
-import java.net.URL;
-import java.util.List;
-
-/** Adapts {@link java.net.Authenticator} to {@link com.squareup.okhttp.Authenticator}. */
-public final class AuthenticatorAdapter implements Authenticator {
-  /** Uses the global authenticator to get the password. */
-  public static final Authenticator INSTANCE = new AuthenticatorAdapter();
-
-  @Override public Request authenticate(Proxy proxy, Response response) throws IOException {
-    List<Challenge> challenges = response.challenges();
-    Request request = response.request();
-    URL url = request.url();
-    for (int i = 0, size = challenges.size(); i < size; i++) {
-      Challenge challenge = challenges.get(i);
-      if (!"Basic".equalsIgnoreCase(challenge.getScheme())) continue;
-
-      PasswordAuthentication auth = java.net.Authenticator.requestPasswordAuthentication(
-          url.getHost(), getConnectToInetAddress(proxy, url), url.getPort(), url.getProtocol(),
-          challenge.getRealm(), challenge.getScheme(), url, RequestorType.SERVER);
-      if (auth == null) continue;
-
-      String credential = Credentials.basic(auth.getUserName(), new String(auth.getPassword()));
-      return request.newBuilder()
-          .header("Authorization", credential)
-          .build();
-    }
-    return null;
-
-  }
-
-  @Override public Request authenticateProxy(Proxy proxy, Response response) throws IOException {
-    List<Challenge> challenges = response.challenges();
-    Request request = response.request();
-    URL url = request.url();
-    for (int i = 0, size = challenges.size(); i < size; i++) {
-      Challenge challenge = challenges.get(i);
-      if (!"Basic".equalsIgnoreCase(challenge.getScheme())) continue;
-
-      InetSocketAddress proxyAddress = (InetSocketAddress) proxy.address();
-      PasswordAuthentication auth = java.net.Authenticator.requestPasswordAuthentication(
-          proxyAddress.getHostName(), getConnectToInetAddress(proxy, url), proxyAddress.getPort(),
-          url.getProtocol(), challenge.getRealm(), challenge.getScheme(), url,
-          RequestorType.PROXY);
-      if (auth == null) continue;
-
-      String credential = Credentials.basic(auth.getUserName(), new String(auth.getPassword()));
-      return request.newBuilder()
-          .header("Proxy-Authorization", credential)
-          .build();
-    }
-    return null;
-  }
-
-  private InetAddress getConnectToInetAddress(Proxy proxy, URL url) throws IOException {
-    return (proxy != null && proxy.type() != Proxy.Type.DIRECT)
-        ? ((InetSocketAddress) proxy.address()).getAddress()
-        : InetAddress.getByName(url.getHost());
-  }
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpTransport.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpTransport.java
deleted file mode 100644
index d02e1e56d1..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpTransport.java
+++ /dev/null
@@ -1,137 +0,0 @@
-/*
- * Copyright (C) 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.squareup.okhttp.internal.http;
-
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
-import com.squareup.okhttp.ResponseBody;
-import java.io.IOException;
-import okio.Okio;
-import okio.Sink;
-import okio.Source;
-
-public final class HttpTransport implements Transport {
-  private final HttpEngine httpEngine;
-  private final HttpConnection httpConnection;
-
-  public HttpTransport(HttpEngine httpEngine, HttpConnection httpConnection) {
-    this.httpEngine = httpEngine;
-    this.httpConnection = httpConnection;
-  }
-
-  @Override public Sink createRequestBody(Request request, long contentLength) throws IOException {
-    if ("chunked".equalsIgnoreCase(request.header("Transfer-Encoding"))) {
-      // Stream a request body of unknown length.
-      return httpConnection.newChunkedSink();
-    }
-
-    if (contentLength != -1) {
-      // Stream a request body of a known length.
-      return httpConnection.newFixedLengthSink(contentLength);
-    }
-
-    throw new IllegalStateException(
-        "Cannot stream a request body without chunked encoding or a known content length!");
-  }
-
-  @Override public void finishRequest() throws IOException {
-    httpConnection.flush();
-  }
-
-  @Override public void writeRequestBody(RetryableSink requestBody) throws IOException {
-    httpConnection.writeRequestBody(requestBody);
-  }
-
-  /**
-   * Prepares the HTTP headers and sends them to the server.
-   *
-   * <p>For streaming requests with a body, headers must be prepared
-   * <strong>before</strong> the output stream has been written to. Otherwise
-   * the body would need to be buffered!
-   *
-   * <p>For non-streaming requests with a body, headers must be prepared
-   * <strong>after</strong> the output stream has been written to and closed.
-   * This ensures that the {@code Content-Length} header field receives the
-   * proper value.
-   */
-  public void writeRequestHeaders(Request request) throws IOException {
-    httpEngine.writingRequestHeaders();
-    String requestLine = RequestLine.get(request,
-        httpEngine.getConnection().getRoute().getProxy().type(),
-        httpEngine.getConnection().getProtocol());
-    httpConnection.writeRequest(request.headers(), requestLine);
-  }
-
-  @Override public Response.Builder readResponseHeaders() throws IOException {
-    return httpConnection.readResponse();
-  }
-
-  @Override public void releaseConnectionOnIdle() throws IOException {
-    if (canReuseConnection()) {
-      httpConnection.poolOnIdle();
-    } else {
-      httpConnection.closeOnIdle();
-    }
-  }
-
-  @Override public boolean canReuseConnection() {
-    // If the request specified that the connection shouldn't be reused, don't reuse it.
-    if ("close".equalsIgnoreCase(httpEngine.getRequest().header("Connection"))) {
-      return false;
-    }
-
-    // If the response specified that the connection shouldn't be reused, don't reuse it.
-    if ("close".equalsIgnoreCase(httpEngine.getResponse().header("Connection"))) {
-      return false;
-    }
-
-    if (httpConnection.isClosed()) {
-      return false;
-    }
-
-    return true;
-  }
-
-  @Override public ResponseBody openResponseBody(Response response) throws IOException {
-    Source source = getTransferStream(response);
-    return new RealResponseBody(response.headers(), Okio.buffer(source));
-  }
-
-  private Source getTransferStream(Response response) throws IOException {
-    if (!HttpEngine.hasBody(response)) {
-      return httpConnection.newFixedLengthSource(0);
-    }
-
-    if ("chunked".equalsIgnoreCase(response.header("Transfer-Encoding"))) {
-      return httpConnection.newChunkedSource(httpEngine);
-    }
-
-    long contentLength = OkHeaders.contentLength(response);
-    if (contentLength != -1) {
-      return httpConnection.newFixedLengthSource(contentLength);
-    }
-
-    // Wrap the input stream from the connection (rather than just returning
-    // "socketIn" directly here), so that we can control its use after the
-    // reference escapes.
-    return httpConnection.newUnknownLengthSource();
-  }
-
-  @Override public void disconnect(HttpEngine engine) throws IOException {
-    httpConnection.closeIfOwnedBy(engine);
-  }
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RequestLine.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RequestLine.java
deleted file mode 100644
index f764afd326..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RequestLine.java
+++ /dev/null
@@ -1,57 +0,0 @@
-package com.squareup.okhttp.internal.http;
-
-import com.squareup.okhttp.Protocol;
-import com.squareup.okhttp.Request;
-import java.net.HttpURLConnection;
-import java.net.Proxy;
-import java.net.URL;
-
-public final class RequestLine {
-  private RequestLine() {
-  }
-
-  /**
-   * Returns the request status line, like "GET / HTTP/1.1". This is exposed
-   * to the application by {@link HttpURLConnection#getHeaderFields}, so it
-   * needs to be set even if the transport is SPDY.
-   */
-  static String get(Request request, Proxy.Type proxyType, Protocol protocol) {
-    StringBuilder result = new StringBuilder();
-    result.append(request.method());
-    result.append(' ');
-
-    if (includeAuthorityInRequestLine(request, proxyType)) {
-      result.append(request.url());
-    } else {
-      result.append(requestPath(request.url()));
-    }
-
-    result.append(' ');
-    result.append(version(protocol));
-    return result.toString();
-  }
-
-  /**
-   * Returns true if the request line should contain the full URL with host
-   * and port (like "GET http://android.com/foo HTTP/1.1") or only the path
-   * (like "GET /foo HTTP/1.1").
-   */
-  private static boolean includeAuthorityInRequestLine(Request request, Proxy.Type proxyType) {
-    return !request.isHttps() && proxyType == Proxy.Type.HTTP;
-  }
-
-  /**
-   * Returns the path to request, like the '/' in 'GET / HTTP/1.1'. Never empty,
-   * even if the request URL is. Includes the query component if it exists.
-   */
-  public static String requestPath(URL url) {
-    String pathAndQuery = url.getFile();
-    if (pathAndQuery == null) return "/";
-    if (!pathAndQuery.startsWith("/")) return "/" + pathAndQuery;
-    return pathAndQuery;
-  }
-
-  public static String version(Protocol protocol) {
-    return protocol == Protocol.HTTP_1_0 ? "HTTP/1.0" : "HTTP/1.1";
-  }
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RetryableSink.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RetryableSink.java
deleted file mode 100644
index 371769f66e..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RetryableSink.java
+++ /dev/null
@@ -1,80 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.squareup.okhttp.internal.http;
-
-import java.io.IOException;
-import java.net.ProtocolException;
-import okio.Buffer;
-import okio.Sink;
-import okio.Timeout;
-
-import static com.squareup.okhttp.internal.Util.checkOffsetAndCount;
-
-/**
- * An HTTP request body that's completely buffered in memory. This allows
- * the post body to be transparently re-sent if the HTTP request must be
- * sent multiple times.
- */
-public final class RetryableSink implements Sink {
-  private boolean closed;
-  private final int limit;
-  private final Buffer content = new Buffer();
-
-  public RetryableSink(int limit) {
-    this.limit = limit;
-  }
-
-  public RetryableSink() {
-    this(-1);
-  }
-
-  @Override public void close() throws IOException {
-    if (closed) return;
-    closed = true;
-    if (content.size() < limit) {
-      throw new ProtocolException(
-          "content-length promised " + limit + " bytes, but received " + content.size());
-    }
-  }
-
-  @Override public void write(Buffer source, long byteCount) throws IOException {
-    if (closed) throw new IllegalStateException("closed");
-    checkOffsetAndCount(source.size(), 0, byteCount);
-    if (limit != -1 && content.size() > limit - byteCount) {
-      throw new ProtocolException("exceeded content-length limit of " + limit + " bytes");
-    }
-    content.write(source, byteCount);
-  }
-
-  @Override public void flush() throws IOException {
-  }
-
-  @Override public Timeout timeout() {
-    return Timeout.NONE;
-  }
-
-  public long contentLength() throws IOException {
-    return content.size();
-  }
-
-  public void writeToSocket(Sink socketOut) throws IOException {
-    // Copy the content; otherwise we won't have data to retry.
-    Buffer buffer = new Buffer();
-    content.copyTo(buffer, 0, content.size());
-    socketOut.write(buffer, buffer.size());
-  }
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
deleted file mode 100644
index 61b6610810..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
+++ /dev/null
@@ -1,232 +0,0 @@
-/*
- * Copyright (C) 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.squareup.okhttp.internal.http;
-
-import com.squareup.okhttp.Headers;
-import com.squareup.okhttp.Protocol;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
-import com.squareup.okhttp.ResponseBody;
-import com.squareup.okhttp.internal.Util;
-import com.squareup.okhttp.internal.spdy.ErrorCode;
-import com.squareup.okhttp.internal.spdy.Header;
-import com.squareup.okhttp.internal.spdy.SpdyConnection;
-import com.squareup.okhttp.internal.spdy.SpdyStream;
-import java.io.IOException;
-import java.net.ProtocolException;
-import java.util.ArrayList;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Locale;
-import java.util.Set;
-import java.util.concurrent.TimeUnit;
-import okio.ByteString;
-import okio.Okio;
-import okio.Sink;
-
-import static com.squareup.okhttp.internal.spdy.Header.RESPONSE_STATUS;
-import static com.squareup.okhttp.internal.spdy.Header.TARGET_AUTHORITY;
-import static com.squareup.okhttp.internal.spdy.Header.TARGET_HOST;
-import static com.squareup.okhttp.internal.spdy.Header.TARGET_METHOD;
-import static com.squareup.okhttp.internal.spdy.Header.TARGET_PATH;
-import static com.squareup.okhttp.internal.spdy.Header.TARGET_SCHEME;
-import static com.squareup.okhttp.internal.spdy.Header.VERSION;
-
-public final class SpdyTransport implements Transport {
-  /** See http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1#TOC-3.2.1-Request. */
-  private static final List<ByteString> SPDY_3_PROHIBITED_HEADERS = Util.immutableList(
-      ByteString.encodeUtf8("connection"),
-      ByteString.encodeUtf8("host"),
-      ByteString.encodeUtf8("keep-alive"),
-      ByteString.encodeUtf8("proxy-connection"),
-      ByteString.encodeUtf8("transfer-encoding"));
-
-  /** See http://tools.ietf.org/html/draft-ietf-httpbis-http2-09#section-8.1.3. */
-  private static final List<ByteString> HTTP_2_PROHIBITED_HEADERS = Util.immutableList(
-      ByteString.encodeUtf8("connection"),
-      ByteString.encodeUtf8("host"),
-      ByteString.encodeUtf8("keep-alive"),
-      ByteString.encodeUtf8("proxy-connection"),
-      ByteString.encodeUtf8("te"),
-      ByteString.encodeUtf8("transfer-encoding"),
-      ByteString.encodeUtf8("encoding"),
-      ByteString.encodeUtf8("upgrade"));
-
-  private final HttpEngine httpEngine;
-  private final SpdyConnection spdyConnection;
-  private SpdyStream stream;
-
-  public SpdyTransport(HttpEngine httpEngine, SpdyConnection spdyConnection) {
-    this.httpEngine = httpEngine;
-    this.spdyConnection = spdyConnection;
-  }
-
-  @Override public Sink createRequestBody(Request request, long contentLength) throws IOException {
-    return stream.getSink();
-  }
-
-  @Override public void writeRequestHeaders(Request request) throws IOException {
-    if (stream != null) return;
-
-    httpEngine.writingRequestHeaders();
-    boolean permitsRequestBody = httpEngine.permitsRequestBody();
-    boolean hasResponseBody = true;
-    String version = RequestLine.version(httpEngine.getConnection().getProtocol());
-    stream = spdyConnection.newStream(
-        writeNameValueBlock(request, spdyConnection.getProtocol(), version), permitsRequestBody,
-        hasResponseBody);
-    stream.readTimeout().timeout(httpEngine.client.getReadTimeout(), TimeUnit.MILLISECONDS);
-  }
-
-  @Override public void writeRequestBody(RetryableSink requestBody) throws IOException {
-    requestBody.writeToSocket(stream.getSink());
-  }
-
-  @Override public void finishRequest() throws IOException {
-    stream.getSink().close();
-  }
-
-  @Override public Response.Builder readResponseHeaders() throws IOException {
-    return readNameValueBlock(stream.getResponseHeaders(), spdyConnection.getProtocol());
-  }
-
-  /**
-   * Returns a list of alternating names and values containing a SPDY request.
-   * Names are all lowercase. No names are repeated. If any name has multiple
-   * values, they are concatenated using "\0" as a delimiter.
-   */
-  public static List<Header> writeNameValueBlock(Request request, Protocol protocol,
-      String version) {
-    Headers headers = request.headers();
-    List<Header> result = new ArrayList<>(headers.size() + 10);
-    result.add(new Header(TARGET_METHOD, request.method()));
-    result.add(new Header(TARGET_PATH, RequestLine.requestPath(request.url())));
-    String host = HttpEngine.hostHeader(request.url());
-    if (Protocol.SPDY_3 == protocol) {
-      result.add(new Header(VERSION, version));
-      result.add(new Header(TARGET_HOST, host));
-    } else if (Protocol.HTTP_2 == protocol) {
-      result.add(new Header(TARGET_AUTHORITY, host)); // Optional in HTTP/2
-    } else {
-      throw new AssertionError();
-    }
-    result.add(new Header(TARGET_SCHEME, request.url().getProtocol()));
-
-    Set<ByteString> names = new LinkedHashSet<ByteString>();
-    for (int i = 0, size = headers.size(); i < size; i++) {
-      // header names must be lowercase.
-      ByteString name = ByteString.encodeUtf8(headers.name(i).toLowerCase(Locale.US));
-      String value = headers.value(i);
-
-      // Drop headers that are forbidden when layering HTTP over SPDY.
-      if (isProhibitedHeader(protocol, name)) continue;
-
-      // They shouldn't be set, but if they are, drop them. We've already written them!
-      if (name.equals(TARGET_METHOD)
-          || name.equals(TARGET_PATH)
-          || name.equals(TARGET_SCHEME)
-          || name.equals(TARGET_AUTHORITY)
-          || name.equals(TARGET_HOST)
-          || name.equals(VERSION)) {
-        continue;
-      }
-
-      // If we haven't seen this name before, add the pair to the end of the list...
-      if (names.add(name)) {
-        result.add(new Header(name, value));
-        continue;
-      }
-
-      // ...otherwise concatenate the existing values and this value.
-      for (int j = 0; j < result.size(); j++) {
-        if (result.get(j).name.equals(name)) {
-          String concatenated = joinOnNull(result.get(j).value.utf8(), value);
-          result.set(j, new Header(name, concatenated));
-          break;
-        }
-      }
-    }
-    return result;
-  }
-
-  private static String joinOnNull(String first, String second) {
-    return new StringBuilder(first).append('\0').append(second).toString();
-  }
-
-  /** Returns headers for a name value block containing a SPDY response. */
-  public static Response.Builder readNameValueBlock(List<Header> headerBlock,
-      Protocol protocol) throws IOException {
-    String status = null;
-    String version = "HTTP/1.1"; // :version present only in spdy/3.
-
-    Headers.Builder headersBuilder = new Headers.Builder();
-    headersBuilder.set(OkHeaders.SELECTED_PROTOCOL, protocol.toString());
-    for (int i = 0, size = headerBlock.size(); i < size; i++) {
-      ByteString name = headerBlock.get(i).name;
-      String values = headerBlock.get(i).value.utf8();
-      for (int start = 0; start < values.length(); ) {
-        int end = values.indexOf('\0', start);
-        if (end == -1) {
-          end = values.length();
-        }
-        String value = values.substring(start, end);
-        if (name.equals(RESPONSE_STATUS)) {
-          status = value;
-        } else if (name.equals(VERSION)) {
-          version = value;
-        } else if (!isProhibitedHeader(protocol, name)) { // Don't write forbidden headers!
-          headersBuilder.add(name.utf8(), value);
-        }
-        start = end + 1;
-      }
-    }
-    if (status == null) throw new ProtocolException("Expected ':status' header not present");
-
-    StatusLine statusLine = StatusLine.parse(version + " " + status);
-    return new Response.Builder()
-        .protocol(protocol)
-        .code(statusLine.code)
-        .message(statusLine.message)
-        .headers(headersBuilder.build());
-  }
-
-  @Override public ResponseBody openResponseBody(Response response) throws IOException {
-    return new RealResponseBody(response.headers(), Okio.buffer(stream.getSource()));
-  }
-
-  @Override public void releaseConnectionOnIdle() {
-  }
-
-  @Override public void disconnect(HttpEngine engine) throws IOException {
-    if (stream != null) stream.close(ErrorCode.CANCEL);
-  }
-
-  @Override public boolean canReuseConnection() {
-    return true; // TODO: spdyConnection.isClosed() ?
-  }
-
-  /** When true, this header should not be emitted or consumed. */
-  private static boolean isProhibitedHeader(Protocol protocol, ByteString name) {
-    if (protocol == Protocol.SPDY_3) {
-      return SPDY_3_PROHIBITED_HEADERS.contains(name);
-    } else if (protocol == Protocol.HTTP_2) {
-      return HTTP_2_PROHIBITED_HEADERS.contains(name);
-    } else {
-      throw new AssertionError(protocol);
-    }
-  }
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/IncomingStreamHandler.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/IncomingStreamHandler.java
deleted file mode 100644
index 44d4ea2bfa..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/IncomingStreamHandler.java
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.squareup.okhttp.internal.spdy;
-
-import java.io.IOException;
-
-/** Listener to be notified when a connected peer creates a new stream. */
-public interface IncomingStreamHandler {
-  IncomingStreamHandler REFUSE_INCOMING_STREAMS = new IncomingStreamHandler() {
-    @Override public void receive(SpdyStream stream) throws IOException {
-      stream.close(ErrorCode.REFUSED_STREAM);
-    }
-  };
-
-  /**
-   * Handle a new stream from this connection's peer. Implementations should
-   * respond by either {@link SpdyStream#reply replying to the stream} or
-   * {@link SpdyStream#close closing it}. This response does not need to be
-   * synchronous.
-   */
-  void receive(SpdyStream stream) throws IOException;
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Address.java b/okhttp/src/main/java/okhttp3/Address.java
similarity index 50%
rename from okhttp/src/main/java/com/squareup/okhttp/Address.java
rename to okhttp/src/main/java/okhttp3/Address.java
index 38768a4004..4fd97764a3 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Address.java
+++ b/okhttp/src/main/java/okhttp3/Address.java
@@ -13,161 +13,171 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
-import com.squareup.okhttp.internal.Util;
 import java.net.Proxy;
 import java.net.ProxySelector;
 import java.util.List;
 import javax.net.SocketFactory;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLSocketFactory;
+import okhttp3.internal.Util;
 
-import static com.squareup.okhttp.internal.Util.equal;
+import static okhttp3.internal.Util.equal;
 
 /**
- * A specification for a connection to an origin server. For simple connections,
- * this is the server's hostname and port. If an explicit proxy is requested (or
- * {@linkplain Proxy#NO_PROXY no proxy} is explicitly requested), this also includes
- * that proxy information. For secure connections the address also includes the
- * SSL socket factory and hostname verifier.
+ * A specification for a connection to an origin server. For simple connections, this is the
+ * server's hostname and port. If an explicit proxy is requested (or {@linkplain Proxy#NO_PROXY no
+ * proxy} is explicitly requested), this also includes that proxy information. For secure
+ * connections the address also includes the SSL socket factory, hostname verifier, and certificate
+ * pinner.
  *
- * <p>HTTP requests that share the same {@code Address} may also share the same
- * {@link Connection}.
+ * <p>HTTP requests that share the same {@code Address} may also share the same {@link Connection}.
  */
 public final class Address {
-  final Proxy proxy;
-  final String uriHost;
-  final int uriPort;
+  final HttpUrl url;
+  final Dns dns;
   final SocketFactory socketFactory;
-  final SSLSocketFactory sslSocketFactory;
-  final HostnameVerifier hostnameVerifier;
-  final CertificatePinner certificatePinner;
-  final Authenticator authenticator;
+  final Authenticator proxyAuthenticator;
   final List<Protocol> protocols;
   final List<ConnectionSpec> connectionSpecs;
   final ProxySelector proxySelector;
+  final Proxy proxy;
+  final SSLSocketFactory sslSocketFactory;
+  final HostnameVerifier hostnameVerifier;
+  final CertificatePinner certificatePinner;
 
-  public Address(String uriHost, int uriPort, SocketFactory socketFactory,
+  public Address(String uriHost, int uriPort, Dns dns, SocketFactory socketFactory,
       SSLSocketFactory sslSocketFactory, HostnameVerifier hostnameVerifier,
-      CertificatePinner certificatePinner, Authenticator authenticator, Proxy proxy,
+      CertificatePinner certificatePinner, Authenticator proxyAuthenticator, Proxy proxy,
       List<Protocol> protocols, List<ConnectionSpec> connectionSpecs, ProxySelector proxySelector) {
-    if (uriHost == null) throw new NullPointerException("uriHost == null");
-    if (uriPort <= 0) throw new IllegalArgumentException("uriPort <= 0: " + uriPort);
-    if (authenticator == null) throw new IllegalArgumentException("authenticator == null");
-    if (protocols == null) throw new IllegalArgumentException("protocols == null");
-    if (proxySelector == null) throw new IllegalArgumentException("proxySelector == null");
-    this.proxy = proxy;
-    this.uriHost = uriHost;
-    this.uriPort = uriPort;
+    this.url = new HttpUrl.Builder()
+        .scheme(sslSocketFactory != null ? "https" : "http")
+        .host(uriHost)
+        .port(uriPort)
+        .build();
+
+    if (dns == null) throw new NullPointerException("dns == null");
+    this.dns = dns;
+
+    if (socketFactory == null) throw new NullPointerException("socketFactory == null");
     this.socketFactory = socketFactory;
-    this.sslSocketFactory = sslSocketFactory;
-    this.hostnameVerifier = hostnameVerifier;
-    this.certificatePinner = certificatePinner;
-    this.authenticator = authenticator;
+
+    if (proxyAuthenticator == null) {
+      throw new NullPointerException("proxyAuthenticator == null");
+    }
+    this.proxyAuthenticator = proxyAuthenticator;
+
+    if (protocols == null) throw new NullPointerException("protocols == null");
     this.protocols = Util.immutableList(protocols);
+
+    if (connectionSpecs == null) throw new NullPointerException("connectionSpecs == null");
     this.connectionSpecs = Util.immutableList(connectionSpecs);
+
+    if (proxySelector == null) throw new NullPointerException("proxySelector == null");
     this.proxySelector = proxySelector;
-  }
 
-  /** Returns the hostname of the origin server. */
-  public String getUriHost() {
-    return uriHost;
+    this.proxy = proxy;
+    this.sslSocketFactory = sslSocketFactory;
+    this.hostnameVerifier = hostnameVerifier;
+    this.certificatePinner = certificatePinner;
   }
 
   /**
-   * Returns the port of the origin server; typically 80 or 443. Unlike
-   * may {@code getPort()} accessors, this method never returns -1.
+   * Returns a URL with the hostname and port of the origin server. The path, query, and fragment of
+   * this URL are always empty, since they are not significant for planning a route.
    */
-  public int getUriPort() {
-    return uriPort;
+  public HttpUrl url() {
+    return url;
+  }
+
+  /** Returns the service that will be used to resolve IP addresses for hostnames. */
+  public Dns dns() {
+    return dns;
   }
 
   /** Returns the socket factory for new connections. */
-  public SocketFactory getSocketFactory() {
+  public SocketFactory socketFactory() {
     return socketFactory;
   }
 
-  /**
-   * Returns the SSL socket factory, or null if this is not an HTTPS
-   * address.
-   */
-  public SSLSocketFactory getSslSocketFactory() {
-    return sslSocketFactory;
+  /** Returns the client's proxy authenticator. */
+  public Authenticator proxyAuthenticator() {
+    return proxyAuthenticator;
   }
 
   /**
-   * Returns the hostname verifier, or null if this is not an HTTPS
-   * address.
+   * Returns the protocols the client supports. This method always returns a non-null list that
+   * contains minimally {@link Protocol#HTTP_1_1}.
    */
-  public HostnameVerifier getHostnameVerifier() {
-    return hostnameVerifier;
+  public List<Protocol> protocols() {
+    return protocols;
+  }
+
+  public List<ConnectionSpec> connectionSpecs() {
+    return connectionSpecs;
   }
 
   /**
-   * Returns the client's authenticator. This method never returns null.
+   * Returns this address's proxy selector. Only used if the proxy is null. If none of this
+   * selector's proxies are reachable, a direct connection will be attempted.
    */
-  public Authenticator getAuthenticator() {
-    return authenticator;
+  public ProxySelector proxySelector() {
+    return proxySelector;
   }
 
   /**
-   * Returns the protocols the client supports. This method always returns a
-   * non-null list that contains minimally {@link Protocol#HTTP_1_1}.
+   * Returns this address's explicitly-specified HTTP proxy, or null to delegate to the {@linkplain
+   * #proxySelector proxy selector}.
    */
-  public List<Protocol> getProtocols() {
-    return protocols;
+  public Proxy proxy() {
+    return proxy;
   }
 
-  public List<ConnectionSpec> getConnectionSpecs() {
-    return connectionSpecs;
+  /** Returns the SSL socket factory, or null if this is not an HTTPS address. */
+  public SSLSocketFactory sslSocketFactory() {
+    return sslSocketFactory;
   }
 
-  /**
-   * Returns this address's explicitly-specified HTTP proxy, or null to
-   * delegate to the {@linkplain #getProxySelector proxy selector}.
-   */
-  public Proxy getProxy() {
-    return proxy;
+  /** Returns the hostname verifier, or null if this is not an HTTPS address. */
+  public HostnameVerifier hostnameVerifier() {
+    return hostnameVerifier;
   }
 
-  /**
-   * Returns this address's proxy selector. Only used if the proxy is null. If none of this
-   * selector's proxies are reachable, a direct connection will be attempted.
-   */
-  public ProxySelector getProxySelector() {
-    return proxySelector;
+  /** Returns this address's certificate pinner, or null if this is not an HTTPS address. */
+  public CertificatePinner certificatePinner() {
+    return certificatePinner;
   }
 
   @Override public boolean equals(Object other) {
     if (other instanceof Address) {
       Address that = (Address) other;
-      return equal(this.proxy, that.proxy)
-          && this.uriHost.equals(that.uriHost)
-          && this.uriPort == that.uriPort
+      return this.url.equals(that.url)
+          && this.dns.equals(that.dns)
+          && this.proxyAuthenticator.equals(that.proxyAuthenticator)
+          && this.protocols.equals(that.protocols)
+          && this.connectionSpecs.equals(that.connectionSpecs)
+          && this.proxySelector.equals(that.proxySelector)
+          && equal(this.proxy, that.proxy)
           && equal(this.sslSocketFactory, that.sslSocketFactory)
           && equal(this.hostnameVerifier, that.hostnameVerifier)
-          && equal(this.certificatePinner, that.certificatePinner)
-          && equal(this.authenticator, that.authenticator)
-          && equal(this.protocols, that.protocols)
-          && equal(this.connectionSpecs, that.connectionSpecs)
-          && equal(this.proxySelector, that.proxySelector);
+          && equal(this.certificatePinner, that.certificatePinner);
     }
     return false;
   }
 
   @Override public int hashCode() {
     int result = 17;
+    result = 31 * result + url.hashCode();
+    result = 31 * result + dns.hashCode();
+    result = 31 * result + proxyAuthenticator.hashCode();
+    result = 31 * result + protocols.hashCode();
+    result = 31 * result + connectionSpecs.hashCode();
+    result = 31 * result + proxySelector.hashCode();
     result = 31 * result + (proxy != null ? proxy.hashCode() : 0);
-    result = 31 * result + uriHost.hashCode();
-    result = 31 * result + uriPort;
     result = 31 * result + (sslSocketFactory != null ? sslSocketFactory.hashCode() : 0);
     result = 31 * result + (hostnameVerifier != null ? hostnameVerifier.hashCode() : 0);
     result = 31 * result + (certificatePinner != null ? certificatePinner.hashCode() : 0);
-    result = 31 * result + authenticator.hashCode();
-    result = 31 * result + protocols.hashCode();
-    result = 31 * result + connectionSpecs.hashCode();
-    result = 31 * result + proxySelector.hashCode();
     return result;
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/Authenticator.java b/okhttp/src/main/java/okhttp3/Authenticator.java
new file mode 100644
index 0000000000..3463690f7b
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/Authenticator.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+
+/**
+ * Responds to an authentication challenge from either a remote web server or a proxy server.
+ * Implementations may either attempt to satisfy the challenge by returning a request that includes
+ * an authorization header, or they may refuse the challenge by returning null. In this case the
+ * unauthenticated response will be returned to the caller that triggered it.
+ *
+ * <p>When authentication is requested by an origin server, the response code is 401 and the
+ * implementation should respond with a new request that sets the "Authorization" header.
+ * <pre>   {@code
+ *
+ *    String credential = Credentials.basic(...)
+ *    return response.request().newBuilder()
+ *        .header("Authorization", credential)
+ *        .build();
+ * }</pre>
+ *
+ * <p>When authentication is requested by a proxy server, the response code is 407 and the
+ * implementation should respond with a new request that sets the "Proxy-Authorization" header.
+ * <pre>   {@code
+ *
+ *    String credential = Credentials.basic(...)
+ *    return response.request().newBuilder()
+ *        .header("Proxy-Authorization", credential)
+ *        .build();
+ * }</pre>
+ *
+ * <p>Applications may configure OkHttp with an authenticator for origin servers, or proxy servers,
+ * or both.
+ */
+public interface Authenticator {
+  /** An authenticator that knows no credentials and makes no attempt to authenticate. */
+  Authenticator NONE = new Authenticator() {
+    @Override public Request authenticate(Route route, Response response) {
+      return null;
+    }
+  };
+
+  /**
+   * Returns a request that includes a credential to satisfy an authentication challenge in {@code
+   * response}. Returns null if the challenge cannot be satisfied.
+   */
+  Request authenticate(Route route, Response response) throws IOException;
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Cache.java b/okhttp/src/main/java/okhttp3/Cache.java
similarity index 75%
rename from okhttp/src/main/java/com/squareup/okhttp/Cache.java
rename to okhttp/src/main/java/okhttp3/Cache.java
index 03c37a55d7..7473edef75 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Cache.java
+++ b/okhttp/src/main/java/okhttp3/Cache.java
@@ -13,19 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+package okhttp3;
 
-package com.squareup.okhttp;
-
-import com.squareup.okhttp.internal.DiskLruCache;
-import com.squareup.okhttp.internal.InternalCache;
-import com.squareup.okhttp.internal.Util;
-import com.squareup.okhttp.internal.http.CacheRequest;
-import com.squareup.okhttp.internal.http.CacheStrategy;
-import com.squareup.okhttp.internal.http.HttpMethod;
-import com.squareup.okhttp.internal.http.OkHeaders;
-import com.squareup.okhttp.internal.http.StatusLine;
-import com.squareup.okhttp.internal.io.FileSystem;
+import java.io.Closeable;
 import java.io.File;
+import java.io.Flushable;
 import java.io.IOException;
 import java.security.cert.Certificate;
 import java.security.cert.CertificateEncodingException;
@@ -36,6 +28,15 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.NoSuchElementException;
+import okhttp3.internal.DiskLruCache;
+import okhttp3.internal.InternalCache;
+import okhttp3.internal.Util;
+import okhttp3.internal.http.CacheRequest;
+import okhttp3.internal.http.CacheStrategy;
+import okhttp3.internal.http.HttpMethod;
+import okhttp3.internal.http.OkHeaders;
+import okhttp3.internal.http.StatusLine;
+import okhttp3.internal.io.FileSystem;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -51,14 +52,15 @@
  * bandwidth.
  *
  * <h3>Cache Optimization</h3>
- * To measure cache effectiveness, this class tracks three statistics:
+ *
+ * <p>To measure cache effectiveness, this class tracks three statistics:
  * <ul>
- *   <li><strong>{@linkplain #getRequestCount() Request Count:}</strong> the number of HTTP
- *     requests issued since this cache was created.
- *   <li><strong>{@linkplain #getNetworkCount() Network Count:}</strong> the number of those
- *     requests that required network use.
- *   <li><strong>{@linkplain #getHitCount() Hit Count:}</strong> the number of those requests whose
- *     responses were served by the cache.
+ *     <li><strong>{@linkplain #requestCount() Request Count:}</strong> the number of HTTP
+ *         requests issued since this cache was created.
+ *     <li><strong>{@linkplain #networkCount() Network Count:}</strong> the number of those
+ *         requests that required network use.
+ *     <li><strong>{@linkplain #hitCount() Hit Count:}</strong> the number of those requests
+ *         whose responses were served by the cache.
  * </ul>
  *
  * Sometimes a request will result in a conditional cache hit. If the cache contains a stale copy of
@@ -72,8 +74,9 @@
  * partial responses.
  *
  * <h3>Force a Network Response</h3>
- * In some situations, such as after a user clicks a 'refresh' button, it may be necessary to skip
- * the cache, and fetch data directly from the server. To force a full refresh, add the {@code
+ *
+ * <p>In some situations, such as after a user clicks a 'refresh' button, it may be necessary to
+ * skip the cache, and fetch data directly from the server. To force a full refresh, add the {@code
  * no-cache} directive: <pre>   {@code
  *
  *   Request request = new Request.Builder()
@@ -94,7 +97,8 @@
  * }</pre>
  *
  * <h3>Force a Cache Response</h3>
- * Sometimes you'll want to show resources if they are available immediately, but not otherwise.
+ *
+ * <p>Sometimes you'll want to show resources if they are available immediately, but not otherwise.
  * This can be used so your application can show <i>something</i> while waiting for the latest data
  * to be downloaded. To restrict a request to locally-cached resources, add the {@code
  * only-if-cached} directive: <pre>   {@code
@@ -128,7 +132,7 @@
  * caching directives. It even offers convenient constants {@link CacheControl#FORCE_NETWORK} and
  * {@link CacheControl#FORCE_CACHE} that address the use cases above.
  */
-public final class Cache {
+public final class Cache implements Closeable, Flushable {
   private static final int VERSION = 201105;
   private static final int ENTRY_METADATA = 0;
   private static final int ENTRY_BODY = 1;
@@ -138,18 +142,23 @@
     @Override public Response get(Request request) throws IOException {
       return Cache.this.get(request);
     }
+
     @Override public CacheRequest put(Response response) throws IOException {
       return Cache.this.put(response);
     }
+
     @Override public void remove(Request request) throws IOException {
       Cache.this.remove(request);
     }
+
     @Override public void update(Response cached, Response network) throws IOException {
       Cache.this.update(cached, network);
     }
+
     @Override public void trackConditionalCacheHit() {
       Cache.this.trackConditionalCacheHit();
     }
+
     @Override public void trackResponse(CacheStrategy cacheStrategy) {
       Cache.this.trackResponse(cacheStrategy);
     }
@@ -165,11 +174,15 @@
   private int requestCount;
 
   public Cache(File directory, long maxSize) {
-    cache = DiskLruCache.create(FileSystem.SYSTEM, directory, VERSION, ENTRY_COUNT, maxSize);
+    this(directory, maxSize, FileSystem.SYSTEM);
+  }
+
+  Cache(File directory, long maxSize, FileSystem fileSystem) {
+    this.cache = DiskLruCache.create(fileSystem, directory, VERSION, ENTRY_COUNT, maxSize);
   }
 
   private static String urlToKey(Request request) {
-    return Util.md5Hex(request.urlString());
+    return Util.md5Hex(request.url().toString());
   }
 
   Response get(Request request) {
@@ -193,7 +206,7 @@ Response get(Request request) {
       return null;
     }
 
-    Response response = entry.response(request, snapshot);
+    Response response = entry.response(snapshot);
 
     if (!entry.matches(request, response)) {
       Util.closeQuietly(response.body());
@@ -270,17 +283,31 @@ private void abortQuietly(DiskLruCache.Editor editor) {
   }
 
   /**
-   * Closes the cache and deletes all of its stored values. This will delete
-   * all files in the cache directory including files that weren't created by
-   * the cache.
+   * Initialize the cache. This will include reading the journal files from the storage and building
+   * up the necessary in-memory cache information.
+   *
+   * <p>The initialization time may vary depending on the journal file size and the current actual
+   * cache size. The application needs to be aware of calling this function during the
+   * initialization phase and preferably in a background worker thread.
+   *
+   * <p>Note that if the application chooses to not call this method to initialize the cache. By
+   * default, the okhttp will perform lazy initialization upon the first usage of the cache.
+   */
+  public void initialize() throws IOException {
+    cache.initialize();
+  }
+
+  /**
+   * Closes the cache and deletes all of its stored values. This will delete all files in the cache
+   * directory including files that weren't created by the cache.
    */
   public void delete() throws IOException {
     cache.delete();
   }
 
   /**
-   * Deletes all values stored in the cache. In-flight writes to the cache will
-   * complete normally, but the corresponding responses will not be stored.
+   * Deletes all values stored in the cache. In-flight writes to the cache will complete normally,
+   * but the corresponding responses will not be stored.
    */
   public void evictAll() throws IOException {
     cache.evictAll();
@@ -338,31 +365,31 @@ public void evictAll() throws IOException {
     };
   }
 
-  public synchronized int getWriteAbortCount() {
+  public synchronized int writeAbortCount() {
     return writeAbortCount;
   }
 
-  public synchronized int getWriteSuccessCount() {
+  public synchronized int writeSuccessCount() {
     return writeSuccessCount;
   }
 
-  public long getSize() throws IOException {
+  public long size() throws IOException {
     return cache.size();
   }
 
-  public long getMaxSize() {
+  public long maxSize() {
     return cache.getMaxSize();
   }
 
-  public void flush() throws IOException {
+  @Override public void flush() throws IOException {
     cache.flush();
   }
 
-  public void close() throws IOException {
+  @Override public void close() throws IOException {
     cache.close();
   }
 
-  public File getDirectory() {
+  public File directory() {
     return cache.getDirectory();
   }
 
@@ -376,7 +403,6 @@ private synchronized void trackResponse(CacheStrategy cacheStrategy) {
     if (cacheStrategy.networkRequest != null) {
       // If this is a conditional request, we'll increment hitCount if/when it hits.
       networkCount++;
-
     } else if (cacheStrategy.cacheResponse != null) {
       // This response uses the cache and not the network. That's a cache hit.
       hitCount++;
@@ -387,15 +413,15 @@ private synchronized void trackConditionalCacheHit() {
     hitCount++;
   }
 
-  public synchronized int getNetworkCount() {
+  public synchronized int networkCount() {
     return networkCount;
   }
 
-  public synchronized int getHitCount() {
+  public synchronized int hitCount() {
     return hitCount;
   }
 
-  public synchronized int getRequestCount() {
+  public synchronized int requestCount() {
     return requestCount;
   }
 
@@ -452,6 +478,8 @@ public CacheRequestImpl(final DiskLruCache.Editor editor) throws IOException {
     private final String message;
     private final Headers responseHeaders;
     private final Handshake handshake;
+    private final long sentRequestMillis;
+    private final long receivedResponseMillis;
 
     /**
      * Reads an entry from an input stream. A typical entry looks like this:
@@ -486,21 +514,20 @@ public CacheRequestImpl(final DiskLruCache.Editor editor) throws IOException {
      *   base64-encoded peerCertificate[0]
      *   base64-encoded peerCertificate[1]
      *   -1
+     *   TLSv1.2
      * }</pre>
-     * The file is newline separated. The first two lines are the URL and
-     * the request method. Next is the number of HTTP Vary request header
-     * lines, followed by those lines.
+     * The file is newline separated. The first two lines are the URL and the request method. Next
+     * is the number of HTTP Vary request header lines, followed by those lines.
      *
-     * <p>Next is the response status line, followed by the number of HTTP
-     * response header lines, followed by those lines.
+     * <p>Next is the response status line, followed by the number of HTTP response header lines,
+     * followed by those lines.
      *
-     * <p>HTTPS responses also contain SSL session information. This begins
-     * with a blank line, and then a line containing the cipher suite. Next
-     * is the length of the peer certificate chain. These certificates are
-     * base64-encoded and appear each on their own line. The next line
-     * contains the length of the local certificate chain. These
-     * certificates are also base64-encoded and appear each on their own
-     * line. A length of -1 is used to encode a null array.
+     * <p>HTTPS responses also contain SSL session information. This begins with a blank line, and
+     * then a line containing the cipher suite. Next is the length of the peer certificate chain.
+     * These certificates are base64-encoded and appear each on their own line. The next line
+     * contains the length of the local certificate chain. These certificates are also
+     * base64-encoded and appear each on their own line. A length of -1 is used to encode a null
+     * array. The last line is optional. If present, it contains the TLS version.
      */
     public Entry(Source in) throws IOException {
       try {
@@ -523,6 +550,16 @@ public Entry(Source in) throws IOException {
         for (int i = 0; i < responseHeaderLineCount; i++) {
           responseHeadersBuilder.addLenient(source.readUtf8LineStrict());
         }
+        String sendRequestMillisString = responseHeadersBuilder.get(OkHeaders.SENT_MILLIS);
+        String receivedResponseMillisString = responseHeadersBuilder.get(OkHeaders.RECEIVED_MILLIS);
+        responseHeadersBuilder.removeAll(OkHeaders.SENT_MILLIS);
+        responseHeadersBuilder.removeAll(OkHeaders.RECEIVED_MILLIS);
+        sentRequestMillis = sendRequestMillisString != null
+            ? Long.parseLong(sendRequestMillisString)
+            : 0L;
+        receivedResponseMillis = receivedResponseMillisString != null
+            ? Long.parseLong(receivedResponseMillisString)
+            : 0L;
         responseHeaders = responseHeadersBuilder.build();
 
         if (isHttps()) {
@@ -530,10 +567,14 @@ public Entry(Source in) throws IOException {
           if (blank.length() > 0) {
             throw new IOException("expected \"\" but was \"" + blank + "\"");
           }
-          String cipherSuite = source.readUtf8LineStrict();
+          String cipherSuiteString = source.readUtf8LineStrict();
+          CipherSuite cipherSuite = CipherSuite.forJavaName(cipherSuiteString);
           List<Certificate> peerCertificates = readCertificateList(source);
           List<Certificate> localCertificates = readCertificateList(source);
-          handshake = Handshake.get(cipherSuite, peerCertificates, localCertificates);
+          TlsVersion tlsVersion = !source.exhausted()
+              ? TlsVersion.forJavaName(source.readUtf8LineStrict())
+              : null;
+          handshake = Handshake.get(tlsVersion, cipherSuite, peerCertificates, localCertificates);
         } else {
           handshake = null;
         }
@@ -543,7 +584,7 @@ public Entry(Source in) throws IOException {
     }
 
     public Entry(Response response) {
-      this.url = response.request().urlString();
+      this.url = response.request().url().toString();
       this.varyHeaders = OkHeaders.varyHeaders(response);
       this.requestMethod = response.request().method();
       this.protocol = response.protocol();
@@ -551,41 +592,56 @@ public Entry(Response response) {
       this.message = response.message();
       this.responseHeaders = response.headers();
       this.handshake = response.handshake();
+      this.sentRequestMillis = response.sentRequestAtMillis();
+      this.receivedResponseMillis = response.receivedResponseAtMillis();
     }
 
     public void writeTo(DiskLruCache.Editor editor) throws IOException {
       BufferedSink sink = Okio.buffer(editor.newSink(ENTRY_METADATA));
 
-      sink.writeUtf8(url);
-      sink.writeByte('\n');
-      sink.writeUtf8(requestMethod);
-      sink.writeByte('\n');
-      sink.writeDecimalLong(varyHeaders.size());
-      sink.writeByte('\n');
+      sink.writeUtf8(url)
+          .writeByte('\n');
+      sink.writeUtf8(requestMethod)
+          .writeByte('\n');
+      sink.writeDecimalLong(varyHeaders.size())
+          .writeByte('\n');
       for (int i = 0, size = varyHeaders.size(); i < size; i++) {
-        sink.writeUtf8(varyHeaders.name(i));
-        sink.writeUtf8(": ");
-        sink.writeUtf8(varyHeaders.value(i));
-        sink.writeByte('\n');
+        sink.writeUtf8(varyHeaders.name(i))
+            .writeUtf8(": ")
+            .writeUtf8(varyHeaders.value(i))
+            .writeByte('\n');
       }
 
-      sink.writeUtf8(new StatusLine(protocol, code, message).toString());
-      sink.writeByte('\n');
-      sink.writeDecimalLong(responseHeaders.size());
-      sink.writeByte('\n');
+      sink.writeUtf8(new StatusLine(protocol, code, message).toString())
+          .writeByte('\n');
+      sink.writeDecimalLong(responseHeaders.size() + 2)
+          .writeByte('\n');
       for (int i = 0, size = responseHeaders.size(); i < size; i++) {
-        sink.writeUtf8(responseHeaders.name(i));
-        sink.writeUtf8(": ");
-        sink.writeUtf8(responseHeaders.value(i));
-        sink.writeByte('\n');
+        sink.writeUtf8(responseHeaders.name(i))
+            .writeUtf8(": ")
+            .writeUtf8(responseHeaders.value(i))
+            .writeByte('\n');
       }
+      sink.writeUtf8(OkHeaders.SENT_MILLIS)
+          .writeUtf8(": ")
+          .writeDecimalLong(sentRequestMillis)
+          .writeByte('\n');
+      sink.writeUtf8(OkHeaders.RECEIVED_MILLIS)
+          .writeUtf8(": ")
+          .writeDecimalLong(receivedResponseMillis)
+          .writeByte('\n');
 
       if (isHttps()) {
         sink.writeByte('\n');
-        sink.writeUtf8(handshake.cipherSuite());
-        sink.writeByte('\n');
+        sink.writeUtf8(handshake.cipherSuite().javaName())
+            .writeByte('\n');
         writeCertList(sink, handshake.peerCertificates());
         writeCertList(sink, handshake.localCertificates());
+        // The handshake’s TLS version is null on HttpsURLConnection and on older cached responses.
+        if (handshake.tlsVersion() != null) {
+          sink.writeUtf8(handshake.tlsVersion().javaName())
+              .writeByte('\n');
+        }
       }
       sink.close();
     }
@@ -616,13 +672,13 @@ private boolean isHttps() {
     private void writeCertList(BufferedSink sink, List<Certificate> certificates)
         throws IOException {
       try {
-        sink.writeDecimalLong(certificates.size());
-        sink.writeByte('\n');
+        sink.writeDecimalLong(certificates.size())
+            .writeByte('\n');
         for (int i = 0, size = certificates.size(); i < size; i++) {
           byte[] bytes = certificates.get(i).getEncoded();
           String line = ByteString.of(bytes).base64();
-          sink.writeUtf8(line);
-          sink.writeByte('\n');
+          sink.writeUtf8(line)
+              .writeByte('\n');
         }
       } catch (CertificateEncodingException e) {
         throw new IOException(e.getMessage());
@@ -630,12 +686,12 @@ private void writeCertList(BufferedSink sink, List<Certificate> certificates)
     }
 
     public boolean matches(Request request, Response response) {
-      return url.equals(request.urlString())
+      return url.equals(request.url().toString())
           && requestMethod.equals(request.method())
           && OkHeaders.varyMatches(response, varyHeaders, request);
     }
 
-    public Response response(Request request, DiskLruCache.Snapshot snapshot) {
+    public Response response(DiskLruCache.Snapshot snapshot) {
       String contentType = responseHeaders.get("Content-Type");
       String contentLength = responseHeaders.get("Content-Length");
       Request cacheRequest = new Request.Builder()
@@ -651,6 +707,8 @@ public Response response(Request request, DiskLruCache.Snapshot snapshot) {
           .headers(responseHeaders)
           .body(new CacheResponseBody(snapshot, contentType, contentLength))
           .handshake(handshake)
+          .sentRequestAtMillis(sentRequestMillis)
+          .receivedResponseAtMillis(receivedResponseMillis)
           .build();
     }
   }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/CacheControl.java b/okhttp/src/main/java/okhttp3/CacheControl.java
similarity index 83%
rename from okhttp/src/main/java/com/squareup/okhttp/CacheControl.java
rename to okhttp/src/main/java/okhttp3/CacheControl.java
index 2ee8982b0c..d8eb446149 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/CacheControl.java
+++ b/okhttp/src/main/java/okhttp3/CacheControl.java
@@ -1,29 +1,26 @@
-package com.squareup.okhttp;
+package okhttp3;
 
-import com.squareup.okhttp.internal.http.HeaderParser;
 import java.util.concurrent.TimeUnit;
+import okhttp3.internal.http.HeaderParser;
 
 /**
- * A Cache-Control header with cache directives from a server or client. These
- * directives set policy on what responses can be stored, and which requests can
- * be satisfied by those stored responses.
+ * A Cache-Control header with cache directives from a server or client. These directives set policy
+ * on what responses can be stored, and which requests can be satisfied by those stored responses.
  *
- * <p>See <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9">RFC
- * 2616, 14.9</a>.
+ * <p>See <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9">RFC 2616,
+ * 14.9</a>.
  */
 public final class CacheControl {
   /**
-   * Cache control request directives that require network validation of
-   * responses. Note that such requests may be assisted by the cache via
-   * conditional GET requests.
+   * Cache control request directives that require network validation of responses. Note that such
+   * requests may be assisted by the cache via conditional GET requests.
    */
   public static final CacheControl FORCE_NETWORK = new Builder().noCache().build();
 
   /**
-   * Cache control request directives that uses the cache only, even if the
-   * cached response is stale. If the response isn't available in the cache or
-   * requires server validation, the call will fail with a {@code 504
-   * Unsatisfiable Request}.
+   * Cache control request directives that uses the cache only, even if the cached response is
+   * stale. If the response isn't available in the cache or requires server validation, the call
+   * will fail with a {@code 504 Unsatisfiable Request}.
    */
   public static final CacheControl FORCE_CACHE = new Builder()
       .onlyIfCached()
@@ -42,7 +39,7 @@
   private final boolean onlyIfCached;
   private final boolean noTransform;
 
-  String headerValue; // Lazily computed, if absent.
+  String headerValue; // Lazily computed, null if absent.
 
   private CacheControl(boolean noCache, boolean noStore, int maxAgeSeconds, int sMaxAgeSeconds,
       boolean isPrivate, boolean isPublic, boolean mustRevalidate, int maxStaleSeconds,
@@ -76,10 +73,9 @@ private CacheControl(Builder builder) {
   }
 
   /**
-   * In a response, this field's name "no-cache" is misleading. It doesn't
-   * prevent us from caching the response; it only means we have to validate the
-   * response with the origin server before returning it. We can do this with a
-   * conditional GET.
+   * In a response, this field's name "no-cache" is misleading. It doesn't prevent us from caching
+   * the response; it only means we have to validate the response with the origin server before
+   * returning it. We can do this with a conditional GET.
    *
    * <p>In a request, it means do not use a cache to satisfy the request.
    */
@@ -93,17 +89,15 @@ public boolean noStore() {
   }
 
   /**
-   * The duration past the response's served date that it can be served without
-   * validation.
+   * The duration past the response's served date that it can be served without validation.
    */
   public int maxAgeSeconds() {
     return maxAgeSeconds;
   }
 
   /**
-   * The "s-maxage" directive is the max age for shared caches. Not to be
-   * confused with "max-age" for non-shared caches, As in Firefox and Chrome,
-   * this directive is not honored by this cache.
+   * The "s-maxage" directive is the max age for shared caches. Not to be confused with "max-age"
+   * for non-shared caches, As in Firefox and Chrome, this directive is not honored by this cache.
    */
   public int sMaxAgeSeconds() {
     return sMaxAgeSeconds;
@@ -130,11 +124,10 @@ public int minFreshSeconds() {
   }
 
   /**
-   * This field's name "only-if-cached" is misleading. It actually means "do
-   * not use the network". It is set by a client who only wants to make a
-   * request if it can be fully satisfied by the cache. Cached responses that
-   * would require validation (ie. conditional gets) are not permitted if this
-   * header is set.
+   * This field's name "only-if-cached" is misleading. It actually means "do not use the network".
+   * It is set by a client who only wants to make a request if it can be fully satisfied by the
+   * cache. Cached responses that would require validation (ie. conditional gets) are not permitted
+   * if this header is set.
    */
   public boolean onlyIfCached() {
     return onlyIfCached;
@@ -145,8 +138,8 @@ public boolean noTransform() {
   }
 
   /**
-   * Returns the cache directives of {@code headers}. This honors both
-   * Cache-Control and Pragma headers if they are present.
+   * Returns the cache directives of {@code headers}. This honors both Cache-Control and Pragma
+   * headers if they are present.
    */
   public static CacheControl parse(Headers headers) {
     boolean noCache = false;
@@ -291,12 +284,11 @@ public Builder noStore() {
     }
 
     /**
-     * Sets the maximum age of a cached response. If the cache response's age
-     * exceeds {@code maxAge}, it will not be used and a network request will
-     * be made.
+     * Sets the maximum age of a cached response. If the cache response's age exceeds {@code
+     * maxAge}, it will not be used and a network request will be made.
      *
-     * @param maxAge a non-negative integer. This is stored and transmitted with
-     *     {@link TimeUnit#SECONDS} precision; finer precision will be lost.
+     * @param maxAge a non-negative integer. This is stored and transmitted with {@link
+     * TimeUnit#SECONDS} precision; finer precision will be lost.
      */
     public Builder maxAge(int maxAge, TimeUnit timeUnit) {
       if (maxAge < 0) throw new IllegalArgumentException("maxAge < 0: " + maxAge);
@@ -308,13 +300,11 @@ public Builder maxAge(int maxAge, TimeUnit timeUnit) {
     }
 
     /**
-     * Accept cached responses that have exceeded their freshness lifetime by
-     * up to {@code maxStale}. If unspecified, stale cache responses will not be
-     * used.
+     * Accept cached responses that have exceeded their freshness lifetime by up to {@code
+     * maxStale}. If unspecified, stale cache responses will not be used.
      *
-     * @param maxStale a non-negative integer. This is stored and transmitted
-     *     with {@link TimeUnit#SECONDS} precision; finer precision will be
-     *     lost.
+     * @param maxStale a non-negative integer. This is stored and transmitted with {@link
+     * TimeUnit#SECONDS} precision; finer precision will be lost.
      */
     public Builder maxStale(int maxStale, TimeUnit timeUnit) {
       if (maxStale < 0) throw new IllegalArgumentException("maxStale < 0: " + maxStale);
@@ -326,14 +316,12 @@ public Builder maxStale(int maxStale, TimeUnit timeUnit) {
     }
 
     /**
-     * Sets the minimum number of seconds that a response will continue to be
-     * fresh for. If the response will be stale when {@code minFresh} have
-     * elapsed, the cached response will not be used and a network request will
-     * be made.
+     * Sets the minimum number of seconds that a response will continue to be fresh for. If the
+     * response will be stale when {@code minFresh} have elapsed, the cached response will not be
+     * used and a network request will be made.
      *
-     * @param minFresh a non-negative integer. This is stored and transmitted
-     *     with {@link TimeUnit#SECONDS} precision; finer precision will be
-     *     lost.
+     * @param minFresh a non-negative integer. This is stored and transmitted with {@link
+     * TimeUnit#SECONDS} precision; finer precision will be lost.
      */
     public Builder minFresh(int minFresh, TimeUnit timeUnit) {
       if (minFresh < 0) throw new IllegalArgumentException("minFresh < 0: " + minFresh);
@@ -345,8 +333,8 @@ public Builder minFresh(int minFresh, TimeUnit timeUnit) {
     }
 
     /**
-     * Only accept the response if it is in the cache. If the response isn't
-     * cached, a {@code 504 Unsatisfiable Request} response will be returned.
+     * Only accept the response if it is in the cache. If the response isn't cached, a {@code 504
+     * Unsatisfiable Request} response will be returned.
      */
     public Builder onlyIfCached() {
       this.onlyIfCached = true;
diff --git a/okhttp/src/main/java/okhttp3/Call.java b/okhttp/src/main/java/okhttp3/Call.java
new file mode 100644
index 0000000000..02b8976e6a
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/Call.java
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+
+/**
+ * A call is a request that has been prepared for execution. A call can be canceled. As this object
+ * represents a single request/response pair (stream), it cannot be executed twice.
+ */
+public interface Call {
+  /** Returns the original request that initiated this call. */
+  Request request();
+
+  /**
+   * Invokes the request immediately, and blocks until the response can be processed or is in
+   * error.
+   *
+   * <p>The caller may read the response body with the response's {@link Response#body} method. To
+   * avoid leaking resources callers must {@linkplain ResponseBody close the response body}.
+   *
+   * <p>Note that transport-layer success (receiving a HTTP response code, headers and body) does
+   * not necessarily indicate application-layer success: {@code response} may still indicate an
+   * unhappy HTTP response code like 404 or 500.
+   *
+   * @throws IOException if the request could not be executed due to cancellation, a connectivity
+   * problem or timeout. Because networks can fail during an exchange, it is possible that the
+   * remote server accepted the request before the failure.
+   * @throws IllegalStateException when the call has already been executed.
+   */
+  Response execute() throws IOException;
+
+  /**
+   * Schedules the request to be executed at some point in the future.
+   *
+   * <p>The {@link OkHttpClient#dispatcher dispatcher} defines when the request will run: usually
+   * immediately unless there are several other requests currently being executed.
+   *
+   * <p>This client will later call back {@code responseCallback} with either an HTTP response or a
+   * failure exception.
+   *
+   * @throws IllegalStateException when the call has already been executed.
+   */
+  void enqueue(Callback responseCallback);
+
+  /** Cancels the request, if possible. Requests that are already complete cannot be canceled. */
+  void cancel();
+
+  /**
+   * Returns true if this call has been either {@linkplain #execute() executed} or {@linkplain
+   * #enqueue(Callback) enqueued}. It is an error to execute a call more than once.
+   */
+  boolean isExecuted();
+
+  boolean isCanceled();
+
+  interface Factory {
+    Call newCall(Request request);
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Callback.java b/okhttp/src/main/java/okhttp3/Callback.java
similarity index 52%
rename from okhttp/src/main/java/com/squareup/okhttp/Callback.java
rename to okhttp/src/main/java/okhttp3/Callback.java
index d86960fe05..3b7ed85bf4 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Callback.java
+++ b/okhttp/src/main/java/okhttp3/Callback.java
@@ -13,30 +13,27 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
 import java.io.IOException;
 
 public interface Callback {
   /**
-   * Called when the request could not be executed due to cancellation, a
-   * connectivity problem or timeout. Because networks can fail during an
-   * exchange, it is possible that the remote server accepted the request
-   * before the failure.
+   * Called when the request could not be executed due to cancellation, a connectivity problem or
+   * timeout. Because networks can fail during an exchange, it is possible that the remote server
+   * accepted the request before the failure.
    */
-  void onFailure(Request request, IOException e);
+  void onFailure(Call call, IOException e);
 
   /**
-   * Called when the HTTP response was successfully returned by the remote
-   * server. The callback may proceed to read the response body with {@link
-   * Response#body}. The response is still live until its response body is
-   * closed with {@code response.body().close()}. The recipient of the callback
-   * may even consume the response body on another thread.
+   * Called when the HTTP response was successfully returned by the remote server. The callback may
+   * proceed to read the response body with {@link Response#body}. The response is still live until
+   * its response body is {@linkplain ResponseBody closed}. The recipient of the callback may
+   * consume the response body on another thread.
    *
-   * <p>Note that transport-layer success (receiving a HTTP response code,
-   * headers and body) does not necessarily indicate application-layer
-   * success: {@code response} may still indicate an unhappy HTTP response
-   * code like 404 or 500.
+   * <p>Note that transport-layer success (receiving a HTTP response code, headers and body) does
+   * not necessarily indicate application-layer success: {@code response} may still indicate an
+   * unhappy HTTP response code like 404 or 500.
    */
-  void onResponse(Response response) throws IOException;
+  void onResponse(Call call, Response response) throws IOException;
 }
diff --git a/okhttp/src/main/java/okhttp3/CertificatePinner.java b/okhttp/src/main/java/okhttp3/CertificatePinner.java
new file mode 100644
index 0000000000..2695a55e42
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/CertificatePinner.java
@@ -0,0 +1,325 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.security.cert.Certificate;
+import java.security.cert.X509Certificate;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import okhttp3.internal.Util;
+import okhttp3.internal.tls.CertificateChainCleaner;
+import okio.ByteString;
+
+/**
+ * Constrains which certificates are trusted. Pinning certificates defends against attacks on
+ * certificate authorities. It also prevents connections through man-in-the-middle certificate
+ * authorities either known or unknown to the application's user.
+ *
+ * <p>This class currently pins a certificate's Subject Public Key Info as described on <a
+ * href="http://goo.gl/AIx3e5">Adam Langley's Weblog</a>. Pins are either base64 SHA-256 hashes as
+ * in <a href="http://tools.ietf.org/html/rfc7469">HTTP Public Key Pinning (HPKP)</a> or SHA-1
+ * base64 hashes as in Chromium's <a href="http://goo.gl/XDh6je">static certificates</a>.
+ *
+ * <h3>Setting up Certificate Pinning</h3>
+ *
+ * <p>The easiest way to pin a host is turn on pinning with a broken configuration and read the
+ * expected configuration when the connection fails. Be sure to do this on a trusted network, and
+ * without man-in-the-middle tools like <a href="http://charlesproxy.com">Charles</a> or <a
+ * href="http://fiddlertool.com">Fiddler</a>.
+ *
+ * <p>For example, to pin {@code https://publicobject.com}, start with a broken
+ * configuration: <pre>   {@code
+ *
+ *     String hostname = "publicobject.com";
+ *     CertificatePinner certificatePinner = new CertificatePinner.Builder()
+ *         .add(hostname, "sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=")
+ *         .build();
+ *     OkHttpClient client = OkHttpClient.Builder()
+ *         .certificatePinner(certificatePinner)
+ *         .build();
+ *
+ *     Request request = new Request.Builder()
+ *         .url("https://" + hostname)
+ *         .build();
+ *     client.newCall(request).execute();
+ * }</pre>
+ *
+ * As expected, this fails with a certificate pinning exception: <pre>   {@code
+ *
+ * javax.net.ssl.SSLPeerUnverifiedException: Certificate pinning failure!
+ *   Peer certificate chain:
+ *     sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=: CN=publicobject.com, OU=PositiveSSL
+ *     sha256/klO23nT2ehFDXCfx3eHTDRESMz3asj1muO+4aIdjiuY=: CN=COMODO RSA Secure Server CA
+ *     sha256/grX4Ta9HpZx6tSHkmCrvpApTQGo67CYDnvprLg5yRME=: CN=COMODO RSA Certification Authority
+ *     sha256/lCppFqbkrlJ3EcVFAkeip0+44VaoJUymbnOaEUk7tEU=: CN=AddTrust External CA Root
+ *   Pinned certificates for publicobject.com:
+ *     sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=
+ *   at okhttp3.CertificatePinner.check(CertificatePinner.java)
+ *   at okhttp3.Connection.upgradeToTls(Connection.java)
+ *   at okhttp3.Connection.connect(Connection.java)
+ *   at okhttp3.Connection.connectAndSetOwner(Connection.java)
+ * }</pre>
+ *
+ * Follow up by pasting the public key hashes from the exception into the
+ * certificate pinner's configuration: <pre>   {@code
+ *
+ *     CertificatePinner certificatePinner = new CertificatePinner.Builder()
+ *       .add("publicobject.com", "sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=")
+ *       .add("publicobject.com", "sha256/klO23nT2ehFDXCfx3eHTDRESMz3asj1muO+4aIdjiuY=")
+ *       .add("publicobject.com", "sha256/grX4Ta9HpZx6tSHkmCrvpApTQGo67CYDnvprLg5yRME=")
+ *       .add("publicobject.com", "sha256/lCppFqbkrlJ3EcVFAkeip0+44VaoJUymbnOaEUk7tEU=")
+ *       .build();
+ * }</pre>
+ *
+ * Pinning is per-hostname and/or per-wildcard pattern. To pin both {@code publicobject.com} and
+ * {@code www.publicobject.com}, you must configure both hostnames.
+ *
+ * <p>Wildcard pattern rules:
+ * <ol>
+ *     <li>Asterisk {@code *} is only permitted in the left-most domain name label and must be the
+ *         only character in that label (i.e., must match the whole left-most label). For example,
+ *         {@code *.example.com} is permitted, while {@code *a.example.com}, {@code a*.example.com},
+ *         {@code a*b.example.com}, {@code a.*.example.com} are not permitted.
+ *     <li>Asterisk {@code *} cannot match across domain name labels. For example,
+ *         {@code *.example.com} matches {@code test.example.com} but does not match
+ *         {@code sub.test.example.com}.
+ *     <li>Wildcard patterns for single-label domain names are not permitted.
+ * </ol>
+ *
+ * If hostname pinned directly and via wildcard pattern, both direct and wildcard pins will be used.
+ * For example: {@code *.example.com} pinned with {@code pin1} and {@code a.example.com} pinned with
+ * {@code pin2}, to check {@code a.example.com} both {@code pin1} and {@code pin2} will be used.
+ *
+ * <h3>Warning: Certificate Pinning is Dangerous!</h3>
+ *
+ * <p>Pinning certificates limits your server team's abilities to update their TLS certificates. By
+ * pinning certificates, you take on additional operational complexity and limit your ability to
+ * migrate between certificate authorities. Do not use certificate pinning without the blessing of
+ * your server's TLS administrator!
+ *
+ * <h4>Note about self-signed certificates</h4>
+ *
+ * <p>{@link CertificatePinner} can not be used to pin self-signed certificate if such certificate
+ * is not accepted by {@link javax.net.ssl.TrustManager}.
+ *
+ * @see <a href="https://www.owasp.org/index.php/Certificate_and_Public_Key_Pinning"> OWASP:
+ * Certificate and Public Key Pinning</a>
+ */
+public final class CertificatePinner {
+  public static final CertificatePinner DEFAULT = new Builder().build();
+
+  private final List<Pin> pins;
+  private final CertificateChainCleaner certificateChainCleaner;
+
+  private CertificatePinner(List<Pin> pins, CertificateChainCleaner certificateChainCleaner) {
+    this.pins = pins;
+    this.certificateChainCleaner = certificateChainCleaner;
+  }
+
+  /**
+   * Confirms that at least one of the certificates pinned for {@code hostname} is in {@code
+   * peerCertificates}. Does nothing if there are no certificates pinned for {@code hostname}.
+   * OkHttp calls this after a successful TLS handshake, but before the connection is used.
+   *
+   * @throws SSLPeerUnverifiedException if {@code peerCertificates} don't match the certificates
+   * pinned for {@code hostname}.
+   */
+  public void check(String hostname, List<Certificate> peerCertificates)
+      throws SSLPeerUnverifiedException {
+    List<Pin> pins = findMatchingPins(hostname);
+    if (pins.isEmpty()) return;
+
+    if (certificateChainCleaner != null) {
+      peerCertificates = certificateChainCleaner.clean(peerCertificates, hostname);
+    }
+
+    for (int c = 0, certsSize = peerCertificates.size(); c < certsSize; c++) {
+      X509Certificate x509Certificate = (X509Certificate) peerCertificates.get(c);
+
+      // Lazily compute the hashes for each certificate.
+      ByteString sha1 = null;
+      ByteString sha256 = null;
+
+      for (int p = 0, pinsSize = pins.size(); p < pinsSize; p++) {
+        Pin pin = pins.get(p);
+        if (pin.hashAlgorithm.equals("sha256/")) {
+          if (sha256 == null) sha256 = sha256(x509Certificate);
+          if (pin.hash.equals(sha256)) return; // Success!
+        } else if (pin.hashAlgorithm.equals("sha1/")) {
+          if (sha1 == null) sha1 = sha1(x509Certificate);
+          if (pin.hash.equals(sha1)) return; // Success!
+        } else {
+          throw new AssertionError();
+        }
+      }
+    }
+
+    // If we couldn't find a matching pin, format a nice exception.
+    StringBuilder message = new StringBuilder()
+        .append("Certificate pinning failure!")
+        .append("\n  Peer certificate chain:");
+    for (int c = 0, certsSize = peerCertificates.size(); c < certsSize; c++) {
+      X509Certificate x509Certificate = (X509Certificate) peerCertificates.get(c);
+      message.append("\n    ").append(pin(x509Certificate))
+          .append(": ").append(x509Certificate.getSubjectDN().getName());
+    }
+    message.append("\n  Pinned certificates for ").append(hostname).append(":");
+    for (int p = 0, pinsSize = pins.size(); p < pinsSize; p++) {
+      Pin pin = pins.get(p);
+      message.append("\n    ").append(pin);
+    }
+    throw new SSLPeerUnverifiedException(message.toString());
+  }
+
+  /** @deprecated replaced with {@link #check(String, List)}. */
+  public void check(String hostname, Certificate... peerCertificates)
+      throws SSLPeerUnverifiedException {
+    check(hostname, Arrays.asList(peerCertificates));
+  }
+
+  /**
+   * Returns list of matching certificates' pins for the hostname. Returns an empty list if the
+   * hostname does not have pinned certificates.
+   */
+  List<Pin> findMatchingPins(String hostname) {
+    List<Pin> result = Collections.emptyList();
+    for (Pin pin : pins) {
+      if (pin.matches(hostname)) {
+        if (result.isEmpty()) result = new ArrayList<>();
+        result.add(pin);
+      }
+    }
+    return result;
+  }
+
+  /** Returns a certificate pinner that uses {@code certificateChainCleaner}. */
+  CertificatePinner withCertificateChainCleaner(CertificateChainCleaner certificateChainCleaner) {
+    return this.certificateChainCleaner != certificateChainCleaner
+        ? new CertificatePinner(pins, certificateChainCleaner)
+        : this;
+  }
+
+  /**
+   * Returns the SHA-256 of {@code certificate}'s public key.
+   *
+   * <p>In OkHttp 3.1.2 and earlier, this returned a SHA-1 hash of the public key. Both types are
+   * supported, but SHA-256 is preferred.
+   */
+  public static String pin(Certificate certificate) {
+    if (!(certificate instanceof X509Certificate)) {
+      throw new IllegalArgumentException("Certificate pinning requires X509 certificates");
+    }
+    return "sha256/" + sha256((X509Certificate) certificate).base64();
+  }
+
+  static ByteString sha1(X509Certificate x509Certificate) {
+    return Util.sha1(ByteString.of(x509Certificate.getPublicKey().getEncoded()));
+  }
+
+  static ByteString sha256(X509Certificate x509Certificate) {
+    return Util.sha256(ByteString.of(x509Certificate.getPublicKey().getEncoded()));
+  }
+
+  static final class Pin {
+    private static final String WILDCARD = "*.";
+    /** A hostname like {@code example.com} or a pattern like {@code *.example.com}. */
+    final String pattern;
+    /** The canonical hostname, i.e. {@code EXAMPLE.com} becomes {@code example.com}. */
+    final String canonicalHostname;
+    /** Either {@code sha1/} or {@code sha256/}. */
+    final String hashAlgorithm;
+    /** The hash of the pinned certificate using {@link #hashAlgorithm}. */
+    final ByteString hash;
+
+    Pin(String pattern, String pin) {
+      this.pattern = pattern;
+      this.canonicalHostname = pattern.startsWith(WILDCARD)
+          ? HttpUrl.parse("http://" + pattern.substring(WILDCARD.length())).host()
+          : HttpUrl.parse("http://" + pattern).host();
+      if (pin.startsWith("sha1/")) {
+        this.hashAlgorithm = "sha1/";
+        this.hash = ByteString.decodeBase64(pin.substring("sha1/".length()));
+      } else if (pin.startsWith("sha256/")) {
+        this.hashAlgorithm = "sha256/";
+        this.hash = ByteString.decodeBase64(pin.substring("sha256/".length()));
+      } else {
+        throw new IllegalArgumentException("pins must start with 'sha256/' or 'sha1/': " + pin);
+      }
+
+      if (this.hash == null) {
+        throw new IllegalArgumentException("pins must be base64: " + pin);
+      }
+    }
+
+    boolean matches(String hostname) {
+      if (pattern.startsWith(WILDCARD)) {
+        int firstDot = hostname.indexOf('.');
+        return hostname.regionMatches(false, firstDot + 1, canonicalHostname, 0,
+            canonicalHostname.length());
+      }
+
+      return hostname.equals(canonicalHostname);
+    }
+
+    @Override public boolean equals(Object other) {
+      return other instanceof Pin
+          && pattern.equals(((Pin) other).pattern)
+          && hashAlgorithm.equals(((Pin) other).hashAlgorithm)
+          && hash.equals(((Pin) other).hash);
+    }
+
+    @Override public int hashCode() {
+      int result = 17;
+      result = 31 * result + pattern.hashCode();
+      result = 31 * result + hashAlgorithm.hashCode();
+      result = 31 * result + hash.hashCode();
+      return result;
+    }
+
+    @Override public String toString() {
+      return hashAlgorithm + hash.base64();
+    }
+  }
+
+  /** Builds a configured certificate pinner. */
+  public static final class Builder {
+    private final List<Pin> pins = new ArrayList<>();
+
+    /**
+     * Pins certificates for {@code pattern}.
+     *
+     * @param pattern lower-case host name or wildcard pattern such as {@code *.example.com}.
+     * @param pins SHA-256 or SHA-1 hashes. Each pin is a hash of a certificate's Subject Public Key
+     * Info, base64-encoded and prefixed with either {@code sha256/} or {@code sha1/}.
+     */
+    public Builder add(String pattern, String... pins) {
+      if (pattern == null) throw new NullPointerException("pattern == null");
+
+      for (String pin : pins) {
+        this.pins.add(new Pin(pattern, pin));
+      }
+
+      return this;
+    }
+
+    public CertificatePinner build() {
+      return new CertificatePinner(Util.immutableList(pins), null);
+    }
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Challenge.java b/okhttp/src/main/java/okhttp3/Challenge.java
similarity index 85%
rename from okhttp/src/main/java/com/squareup/okhttp/Challenge.java
rename to okhttp/src/main/java/okhttp3/Challenge.java
index a1ef7145a0..f4bb369c45 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Challenge.java
+++ b/okhttp/src/main/java/okhttp3/Challenge.java
@@ -13,9 +13,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
-import static com.squareup.okhttp.internal.Util.equal;
+import okhttp3.internal.Util;
 
 /** An RFC 2617 challenge. */
 public final class Challenge {
@@ -28,19 +28,19 @@ public Challenge(String scheme, String realm) {
   }
 
   /** Returns the authentication scheme, like {@code Basic}. */
-  public String getScheme() {
+  public String scheme() {
     return scheme;
   }
 
   /** Returns the protection space. */
-  public String getRealm() {
+  public String realm() {
     return realm;
   }
 
   @Override public boolean equals(Object o) {
     return o instanceof Challenge
-        && equal(scheme, ((Challenge) o).scheme)
-        && equal(realm, ((Challenge) o).realm);
+        && Util.equal(scheme, ((Challenge) o).scheme)
+        && Util.equal(realm, ((Challenge) o).realm);
   }
 
   @Override public int hashCode() {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/CipherSuite.java b/okhttp/src/main/java/okhttp3/CipherSuite.java
similarity index 98%
rename from okhttp/src/main/java/com/squareup/okhttp/CipherSuite.java
rename to okhttp/src/main/java/okhttp3/CipherSuite.java
index 13344578be..6697cad846 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/CipherSuite.java
+++ b/okhttp/src/main/java/okhttp3/CipherSuite.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
 import static java.lang.Integer.MAX_VALUE;
 
@@ -356,7 +356,7 @@
 
   /**
    * @param javaName the name used by Java APIs for this cipher suite. Different than the IANA name
-   *     for older cipher suites because the prefix is {@code SSL_} instead of {@code TLS_}.
+   * for older cipher suites because the prefix is {@code SSL_} instead of {@code TLS_}.
    * @param value the integer identifier for this cipher suite. (Documentation only.)
    * @param rfc the RFC describing this cipher suite. (Documentation only.)
    * @param sinceJavaVersion the first major Java release supporting this cipher suite.
@@ -367,6 +367,15 @@ private CipherSuite(
     this.javaName = javaName;
   }
 
+  /**
+   * Returns the Java name of this cipher suite. For some older cipher suites the Java name has the
+   * prefix {@code SSL_}, causing the Java name to be different from the {@linkplain #name() enum
+   * name} which is always prefixed {@code TLS_}.
+   */
+  public String javaName() {
+    return javaName;
+  }
+
   public static CipherSuite forJavaName(String javaName) {
     return javaName.startsWith("SSL_")
         ? valueOf("TLS_" + javaName.substring(4))
diff --git a/okhttp/src/main/java/okhttp3/Connection.java b/okhttp/src/main/java/okhttp3/Connection.java
new file mode 100644
index 0000000000..de3c22d98b
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/Connection.java
@@ -0,0 +1,93 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package okhttp3;
+
+import java.net.Socket;
+
+/**
+ * The sockets and streams of an HTTP, HTTPS, or HTTPS+SPDY connection. May be used for multiple
+ * HTTP request/response exchanges. Connections may be direct to the origin server or via a proxy.
+ *
+ * <p>Typically instances of this class are created, connected and exercised automatically by the
+ * HTTP client. Applications may use this class to monitor HTTP connections as members of a
+ * {@linkplain ConnectionPool connection pool}.
+ *
+ * <p>Do not confuse this class with the misnamed {@code HttpURLConnection}, which isn't so much a
+ * connection as a single request/response exchange.
+ *
+ * <h3>Modern TLS</h3>
+ *
+ * <p>There are tradeoffs when selecting which options to include when negotiating a secure
+ * connection to a remote host. Newer TLS options are quite useful:
+ *
+ * <ul>
+ *     <li>Server Name Indication (SNI) enables one IP address to negotiate secure connections for
+ *         multiple domain names.
+ *     <li>Application Layer Protocol Negotiation (ALPN) enables the HTTPS port (443) to be used for
+ *         different HTTP and SPDY protocols.
+ * </ul>
+ *
+ * <p>Unfortunately, older HTTPS servers refuse to connect when such options are presented. Rather
+ * than avoiding these options entirely, this class allows a connection to be attempted with modern
+ * options and then retried without them should the attempt fail.
+ *
+ * <h3>Connection Reuse</h3>
+ *
+ * <p>Each connection can carry a varying number streams, depending on the underlying protocol being
+ * used. HTTP/1.x connections can carry either zero or one streams. HTTP/2 connections can carry any
+ * number of streams, dynamically configured with {@code SETTINGS_MAX_CONCURRENT_STREAMS}. A
+ * connection currently carrying zero streams is an idle stream. We keep it alive because reusing an
+ * existing connection is typically faster than establishing a new one.
+ *
+ * <p>When a single logical call requires multiple streams due to redirects or authorization
+ * challenges, we prefer to use the same physical connection for all streams in the sequence. There
+ * are potential performance and behavior consequences to this preference. To support this feature,
+ * this class separates <i>allocations</i> from <i>streams</i>. An allocation is created by a call,
+ * used for one or more streams, and then released. An allocated connection won't be stolen by other
+ * calls while a redirect or authorization challenge is being handled.
+ *
+ * <p>When the maximum concurrent streams limit is reduced, some allocations will be rescinded.
+ * Attempting to create new streams on these allocations will fail.
+ *
+ * <p>Note that an allocation may be released before its stream is completed. This is intended to
+ * make bookkeeping easier for the caller: releasing the allocation as soon as the terminal stream
+ * has been found. But only complete the stream once its data stream has been exhausted.
+ */
+public interface Connection {
+  /** Returns the route used by this connection. */
+  Route route();
+
+  /**
+   * Returns the socket that this connection is using. Returns an {@linkplain
+   * javax.net.ssl.SSLSocket SSL socket} if this connection is HTTPS. If this is an HTTP/2 or SPDY
+   * connection the socket may be shared by multiple concurrent calls.
+   */
+  Socket socket();
+
+  /**
+   * Returns the TLS handshake used to establish this connection, or null if the connection is not
+   * HTTPS.
+   */
+  Handshake handshake();
+
+  /**
+   * Returns the protocol negotiated by this connection, or {@link Protocol#HTTP_1_1} if no protocol
+   * has been negotiated. This method returns {@link Protocol#HTTP_1_1} even if the remote peer is
+   * using {@link Protocol#HTTP_1_0}.
+   */
+  Protocol protocol();
+}
diff --git a/okhttp/src/main/java/okhttp3/ConnectionPool.java b/okhttp/src/main/java/okhttp3/ConnectionPool.java
new file mode 100644
index 0000000000..d6391c3f83
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/ConnectionPool.java
@@ -0,0 +1,263 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package okhttp3;
+
+import java.lang.ref.Reference;
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Deque;
+import java.util.Iterator;
+import java.util.List;
+import java.util.concurrent.Executor;
+import java.util.concurrent.SynchronousQueue;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+import okhttp3.internal.Platform;
+import okhttp3.internal.RouteDatabase;
+import okhttp3.internal.Util;
+import okhttp3.internal.http.StreamAllocation;
+import okhttp3.internal.io.RealConnection;
+
+import static okhttp3.internal.Platform.WARN;
+import static okhttp3.internal.Util.closeQuietly;
+
+/**
+ * Manages reuse of HTTP and SPDY connections for reduced network latency. HTTP requests that share
+ * the same {@link Address} may share a {@link Connection}. This class implements the policy of
+ * which connections to keep open for future use.
+ */
+public final class ConnectionPool {
+  /**
+   * Background threads are used to cleanup expired connections. There will be at most a single
+   * thread running per connection pool. The thread pool executor permits the pool itself to be
+   * garbage collected.
+   */
+  private static final Executor executor = new ThreadPoolExecutor(0 /* corePoolSize */,
+      Integer.MAX_VALUE /* maximumPoolSize */, 60L /* keepAliveTime */, TimeUnit.SECONDS,
+      new SynchronousQueue<Runnable>(), Util.threadFactory("OkHttp ConnectionPool", true));
+
+  /** The maximum number of idle connections for each address. */
+  private final int maxIdleConnections;
+  private final long keepAliveDurationNs;
+  private final Runnable cleanupRunnable = new Runnable() {
+    @Override public void run() {
+      while (true) {
+        long waitNanos = cleanup(System.nanoTime());
+        if (waitNanos == -1) return;
+        if (waitNanos > 0) {
+          long waitMillis = waitNanos / 1000000L;
+          waitNanos -= (waitMillis * 1000000L);
+          synchronized (ConnectionPool.this) {
+            try {
+              ConnectionPool.this.wait(waitMillis, (int) waitNanos);
+            } catch (InterruptedException ignored) {
+            }
+          }
+        }
+      }
+    }
+  };
+
+  private final Deque<RealConnection> connections = new ArrayDeque<>();
+  final RouteDatabase routeDatabase = new RouteDatabase();
+  boolean cleanupRunning;
+
+  /**
+   * Create a new connection pool with tuning parameters appropriate for a single-user application.
+   * The tuning parameters in this pool are subject to change in future OkHttp releases. Currently
+   * this pool holds up to 5 idle connections which will be evicted after 5 minutes of inactivity.
+   */
+  public ConnectionPool() {
+    this(5, 5, TimeUnit.MINUTES);
+  }
+
+  public ConnectionPool(int maxIdleConnections, long keepAliveDuration, TimeUnit timeUnit) {
+    this.maxIdleConnections = maxIdleConnections;
+    this.keepAliveDurationNs = timeUnit.toNanos(keepAliveDuration);
+
+    // Put a floor on the keep alive duration, otherwise cleanup will spin loop.
+    if (keepAliveDuration <= 0) {
+      throw new IllegalArgumentException("keepAliveDuration <= 0: " + keepAliveDuration);
+    }
+  }
+
+  /** Returns the number of idle connections in the pool. */
+  public synchronized int idleConnectionCount() {
+    int total = 0;
+    for (RealConnection connection : connections) {
+      if (connection.allocations.isEmpty()) total++;
+    }
+    return total;
+  }
+
+  /**
+   * Returns total number of connections in the pool. Note that prior to OkHttp 2.7 this included
+   * only idle connections and SPDY connections. Since OkHttp 2.7 this includes all connections,
+   * both active and inactive. Use {@link #idleConnectionCount()} to count connections not currently
+   * in use.
+   */
+  public synchronized int connectionCount() {
+    return connections.size();
+  }
+
+  /** Returns a recycled connection to {@code address}, or null if no such connection exists. */
+  RealConnection get(Address address, StreamAllocation streamAllocation) {
+    assert (Thread.holdsLock(this));
+    for (RealConnection connection : connections) {
+      if (connection.allocations.size() < connection.allocationLimit
+          && address.equals(connection.route().address)
+          && !connection.noNewStreams) {
+        streamAllocation.acquire(connection);
+        return connection;
+      }
+    }
+    return null;
+  }
+
+  void put(RealConnection connection) {
+    assert (Thread.holdsLock(this));
+    if (!cleanupRunning) {
+      cleanupRunning = true;
+      executor.execute(cleanupRunnable);
+    }
+    connections.add(connection);
+  }
+
+  /**
+   * Notify this pool that {@code connection} has become idle. Returns true if the connection has
+   * been removed from the pool and should be closed.
+   */
+  boolean connectionBecameIdle(RealConnection connection) {
+    assert (Thread.holdsLock(this));
+    if (connection.noNewStreams || maxIdleConnections == 0) {
+      connections.remove(connection);
+      return true;
+    } else {
+      notifyAll(); // Awake the cleanup thread: we may have exceeded the idle connection limit.
+      return false;
+    }
+  }
+
+  /** Close and remove all idle connections in the pool. */
+  public void evictAll() {
+    List<RealConnection> evictedConnections = new ArrayList<>();
+    synchronized (this) {
+      for (Iterator<RealConnection> i = connections.iterator(); i.hasNext(); ) {
+        RealConnection connection = i.next();
+        if (connection.allocations.isEmpty()) {
+          connection.noNewStreams = true;
+          evictedConnections.add(connection);
+          i.remove();
+        }
+      }
+    }
+
+    for (RealConnection connection : evictedConnections) {
+      closeQuietly(connection.socket());
+    }
+  }
+
+  /**
+   * Performs maintenance on this pool, evicting the connection that has been idle the longest if
+   * either it has exceeded the keep alive limit or the idle connections limit.
+   *
+   * <p>Returns the duration in nanos to sleep until the next scheduled call to this method. Returns
+   * -1 if no further cleanups are required.
+   */
+  long cleanup(long now) {
+    int inUseConnectionCount = 0;
+    int idleConnectionCount = 0;
+    RealConnection longestIdleConnection = null;
+    long longestIdleDurationNs = Long.MIN_VALUE;
+
+    // Find either a connection to evict, or the time that the next eviction is due.
+    synchronized (this) {
+      for (Iterator<RealConnection> i = connections.iterator(); i.hasNext(); ) {
+        RealConnection connection = i.next();
+
+        // If the connection is in use, keep searching.
+        if (pruneAndGetAllocationCount(connection, now) > 0) {
+          inUseConnectionCount++;
+          continue;
+        }
+
+        idleConnectionCount++;
+
+        // If the connection is ready to be evicted, we're done.
+        long idleDurationNs = now - connection.idleAtNanos;
+        if (idleDurationNs > longestIdleDurationNs) {
+          longestIdleDurationNs = idleDurationNs;
+          longestIdleConnection = connection;
+        }
+      }
+
+      if (longestIdleDurationNs >= this.keepAliveDurationNs
+          || idleConnectionCount > this.maxIdleConnections) {
+        // We've found a connection to evict. Remove it from the list, then close it below (outside
+        // of the synchronized block).
+        connections.remove(longestIdleConnection);
+      } else if (idleConnectionCount > 0) {
+        // A connection will be ready to evict soon.
+        return keepAliveDurationNs - longestIdleDurationNs;
+      } else if (inUseConnectionCount > 0) {
+        // All connections are in use. It'll be at least the keep alive duration 'til we run again.
+        return keepAliveDurationNs;
+      } else {
+        // No connections, idle or in use.
+        cleanupRunning = false;
+        return -1;
+      }
+    }
+
+    closeQuietly(longestIdleConnection.socket());
+
+    // Cleanup again immediately.
+    return 0;
+  }
+
+  /**
+   * Prunes any leaked allocations and then returns the number of remaining live allocations on
+   * {@code connection}. Allocations are leaked if the connection is tracking them but the
+   * application code has abandoned them. Leak detection is imprecise and relies on garbage
+   * collection.
+   */
+  private int pruneAndGetAllocationCount(RealConnection connection, long now) {
+    List<Reference<StreamAllocation>> references = connection.allocations;
+    for (int i = 0; i < references.size(); ) {
+      Reference<StreamAllocation> reference = references.get(i);
+
+      if (reference.get() != null) {
+        i++;
+        continue;
+      }
+
+      // We've discovered a leaked allocation. This is an application bug.
+      Platform.get().log(WARN, "A connection to " + connection.route().address().url()
+          + " was leaked. Did you forget to close a response body?", null);
+      references.remove(i);
+      connection.noNewStreams = true;
+
+      // If this was the last allocation, the connection is eligible for immediate eviction.
+      if (references.isEmpty()) {
+        connection.idleAtNanos = now - keepAliveDurationNs;
+        return 0;
+      }
+    }
+
+    return references.size();
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/ConnectionSpec.java b/okhttp/src/main/java/okhttp3/ConnectionSpec.java
new file mode 100644
index 0000000000..8c99932f9e
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/ConnectionSpec.java
@@ -0,0 +1,332 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.util.Arrays;
+import java.util.List;
+import javax.net.ssl.SSLSocket;
+
+import static okhttp3.internal.Util.concat;
+import static okhttp3.internal.Util.contains;
+import static okhttp3.internal.Util.immutableList;
+import static okhttp3.internal.Util.intersect;
+
+/**
+ * Specifies configuration for the socket connection that HTTP traffic travels through. For {@code
+ * https:} URLs, this includes the TLS version and cipher suites to use when negotiating a secure
+ * connection.
+ *
+ * <p>The TLS versions configured in a connection spec are only be used if they are also enabled in
+ * the SSL socket. For example, if an SSL socket does not have TLS 1.2 enabled, it will not be used
+ * even if it is present on the connection spec. The same policy also applies to cipher suites.
+ *
+ * <p>Use {@link Builder#allEnabledTlsVersions()} and {@link Builder#allEnabledCipherSuites} to
+ * defer all feature selection to the underlying SSL socket.
+ */
+public final class ConnectionSpec {
+
+  // This is a subset of the cipher suites supported in Chrome 46, current as of 2015-11-05.
+  // All of these suites are available on Android 5.0; earlier releases support a subset of
+  // these suites. https://github.com/square/okhttp/issues/330
+  private static final CipherSuite[] APPROVED_CIPHER_SUITES = new CipherSuite[] {
+      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
+      CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
+      CipherSuite.TLS_DHE_RSA_WITH_AES_128_GCM_SHA256,
+
+      // Note that the following cipher suites are all on HTTP/2's bad cipher suites list. We'll
+      // continue to include them until better suites are commonly available. For example, none
+      // of the better cipher suites listed above shipped with Android 4.4 or Java 7.
+      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,
+      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,
+      CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,
+      CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,
+      CipherSuite.TLS_DHE_RSA_WITH_AES_128_CBC_SHA,
+      CipherSuite.TLS_DHE_RSA_WITH_AES_256_CBC_SHA,
+      CipherSuite.TLS_RSA_WITH_AES_128_GCM_SHA256,
+      CipherSuite.TLS_RSA_WITH_AES_128_CBC_SHA,
+      CipherSuite.TLS_RSA_WITH_AES_256_CBC_SHA,
+      CipherSuite.TLS_RSA_WITH_3DES_EDE_CBC_SHA,
+  };
+
+  /** A modern TLS connection with extensions like SNI and ALPN available. */
+  public static final ConnectionSpec MODERN_TLS = new Builder(true)
+      .cipherSuites(APPROVED_CIPHER_SUITES)
+      .tlsVersions(TlsVersion.TLS_1_2, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0)
+      .supportsTlsExtensions(true)
+      .build();
+
+  /** A backwards-compatible fallback connection for interop with obsolete servers. */
+  public static final ConnectionSpec COMPATIBLE_TLS = new Builder(MODERN_TLS)
+      .tlsVersions(TlsVersion.TLS_1_0)
+      .supportsTlsExtensions(true)
+      .build();
+
+  /** Unencrypted, unauthenticated connections for {@code http:} URLs. */
+  public static final ConnectionSpec CLEARTEXT = new Builder(false).build();
+
+  private final boolean tls;
+  private final boolean supportsTlsExtensions;
+  private final String[] cipherSuites;
+  private final String[] tlsVersions;
+
+  private ConnectionSpec(Builder builder) {
+    this.tls = builder.tls;
+    this.cipherSuites = builder.cipherSuites;
+    this.tlsVersions = builder.tlsVersions;
+    this.supportsTlsExtensions = builder.supportsTlsExtensions;
+  }
+
+  public boolean isTls() {
+    return tls;
+  }
+
+  /**
+   * Returns the cipher suites to use for a connection. Returns {@code null} if all of the SSL
+   * socket's enabled cipher suites should be used.
+   */
+  public List<CipherSuite> cipherSuites() {
+    if (cipherSuites == null) return null;
+
+    CipherSuite[] result = new CipherSuite[cipherSuites.length];
+    for (int i = 0; i < cipherSuites.length; i++) {
+      result[i] = CipherSuite.forJavaName(cipherSuites[i]);
+    }
+    return immutableList(result);
+  }
+
+  /**
+   * Returns the TLS versions to use when negotiating a connection. Returns {@code null} if all of
+   * the SSL socket's enabled TLS versions should be used.
+   */
+  public List<TlsVersion> tlsVersions() {
+    if (tlsVersions == null) return null;
+
+    TlsVersion[] result = new TlsVersion[tlsVersions.length];
+    for (int i = 0; i < tlsVersions.length; i++) {
+      result[i] = TlsVersion.forJavaName(tlsVersions[i]);
+    }
+    return immutableList(result);
+  }
+
+  public boolean supportsTlsExtensions() {
+    return supportsTlsExtensions;
+  }
+
+  /** Applies this spec to {@code sslSocket}. */
+  void apply(SSLSocket sslSocket, boolean isFallback) {
+    ConnectionSpec specToApply = supportedSpec(sslSocket, isFallback);
+
+    if (specToApply.tlsVersions != null) {
+      sslSocket.setEnabledProtocols(specToApply.tlsVersions);
+    }
+    if (specToApply.cipherSuites != null) {
+      sslSocket.setEnabledCipherSuites(specToApply.cipherSuites);
+    }
+  }
+
+  /**
+   * Returns a copy of this that omits cipher suites and TLS versions not enabled by {@code
+   * sslSocket}.
+   */
+  private ConnectionSpec supportedSpec(SSLSocket sslSocket, boolean isFallback) {
+    String[] cipherSuitesIntersection = cipherSuites != null
+        ? intersect(String.class, cipherSuites, sslSocket.getEnabledCipherSuites())
+        : sslSocket.getEnabledCipherSuites();
+    String[] tlsVersionsIntersection = tlsVersions != null
+        ? intersect(String.class, tlsVersions, sslSocket.getEnabledProtocols())
+        : sslSocket.getEnabledProtocols();
+
+    // In accordance with https://tools.ietf.org/html/draft-ietf-tls-downgrade-scsv-00
+    // the SCSV cipher is added to signal that a protocol fallback has taken place.
+    if (isFallback && contains(sslSocket.getSupportedCipherSuites(), "TLS_FALLBACK_SCSV")) {
+      cipherSuitesIntersection = concat(cipherSuitesIntersection, "TLS_FALLBACK_SCSV");
+    }
+
+    return new Builder(this)
+        .cipherSuites(cipherSuitesIntersection)
+        .tlsVersions(tlsVersionsIntersection)
+        .build();
+  }
+
+  /**
+   * Returns {@code true} if the socket, as currently configured, supports this connection spec. In
+   * order for a socket to be compatible the enabled cipher suites and protocols must intersect.
+   *
+   * <p>For cipher suites, at least one of the {@link #cipherSuites() required cipher suites} must
+   * match the socket's enabled cipher suites. If there are no required cipher suites the socket
+   * must have at least one cipher suite enabled.
+   *
+   * <p>For protocols, at least one of the {@link #tlsVersions() required protocols} must match the
+   * socket's enabled protocols.
+   */
+  public boolean isCompatible(SSLSocket socket) {
+    if (!tls) {
+      return false;
+    }
+
+    if (tlsVersions != null
+        && !nonEmptyIntersection(tlsVersions, socket.getEnabledProtocols())) {
+      return false;
+    }
+
+    if (cipherSuites != null
+        && !nonEmptyIntersection(cipherSuites, socket.getEnabledCipherSuites())) {
+      return false;
+    }
+
+    return true;
+  }
+
+  /**
+   * An N*M intersection that terminates if any intersection is found. The sizes of both arguments
+   * are assumed to be so small, and the likelihood of an intersection so great, that it is not
+   * worth the CPU cost of sorting or the memory cost of hashing.
+   */
+  private static boolean nonEmptyIntersection(String[] a, String[] b) {
+    if (a == null || b == null || a.length == 0 || b.length == 0) {
+      return false;
+    }
+    for (String toFind : a) {
+      if (contains(b, toFind)) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  @Override public boolean equals(Object other) {
+    if (!(other instanceof ConnectionSpec)) return false;
+    if (other == this) return true;
+
+    ConnectionSpec that = (ConnectionSpec) other;
+    if (this.tls != that.tls) return false;
+
+    if (tls) {
+      if (!Arrays.equals(this.cipherSuites, that.cipherSuites)) return false;
+      if (!Arrays.equals(this.tlsVersions, that.tlsVersions)) return false;
+      if (this.supportsTlsExtensions != that.supportsTlsExtensions) return false;
+    }
+
+    return true;
+  }
+
+  @Override public int hashCode() {
+    int result = 17;
+    if (tls) {
+      result = 31 * result + Arrays.hashCode(cipherSuites);
+      result = 31 * result + Arrays.hashCode(tlsVersions);
+      result = 31 * result + (supportsTlsExtensions ? 0 : 1);
+    }
+    return result;
+  }
+
+  @Override public String toString() {
+    if (!tls) {
+      return "ConnectionSpec()";
+    }
+
+    String cipherSuitesString = cipherSuites != null ? cipherSuites().toString() : "[all enabled]";
+    String tlsVersionsString = tlsVersions != null ? tlsVersions().toString() : "[all enabled]";
+    return "ConnectionSpec("
+        + "cipherSuites=" + cipherSuitesString
+        + ", tlsVersions=" + tlsVersionsString
+        + ", supportsTlsExtensions=" + supportsTlsExtensions
+        + ")";
+  }
+
+  public static final class Builder {
+    private boolean tls;
+    private String[] cipherSuites;
+    private String[] tlsVersions;
+    private boolean supportsTlsExtensions;
+
+    Builder(boolean tls) {
+      this.tls = tls;
+    }
+
+    public Builder(ConnectionSpec connectionSpec) {
+      this.tls = connectionSpec.tls;
+      this.cipherSuites = connectionSpec.cipherSuites;
+      this.tlsVersions = connectionSpec.tlsVersions;
+      this.supportsTlsExtensions = connectionSpec.supportsTlsExtensions;
+    }
+
+    public Builder allEnabledCipherSuites() {
+      if (!tls) throw new IllegalStateException("no cipher suites for cleartext connections");
+      this.cipherSuites = null;
+      return this;
+    }
+
+    public Builder cipherSuites(CipherSuite... cipherSuites) {
+      if (!tls) throw new IllegalStateException("no cipher suites for cleartext connections");
+
+      String[] strings = new String[cipherSuites.length];
+      for (int i = 0; i < cipherSuites.length; i++) {
+        strings[i] = cipherSuites[i].javaName;
+      }
+      return cipherSuites(strings);
+    }
+
+    public Builder cipherSuites(String... cipherSuites) {
+      if (!tls) throw new IllegalStateException("no cipher suites for cleartext connections");
+
+      if (cipherSuites.length == 0) {
+        throw new IllegalArgumentException("At least one cipher suite is required");
+      }
+
+      this.cipherSuites = cipherSuites.clone(); // Defensive copy.
+      return this;
+    }
+
+    public Builder allEnabledTlsVersions() {
+      if (!tls) throw new IllegalStateException("no TLS versions for cleartext connections");
+      this.tlsVersions = null;
+      return this;
+    }
+
+    public Builder tlsVersions(TlsVersion... tlsVersions) {
+      if (!tls) throw new IllegalStateException("no TLS versions for cleartext connections");
+
+      String[] strings = new String[tlsVersions.length];
+      for (int i = 0; i < tlsVersions.length; i++) {
+        strings[i] = tlsVersions[i].javaName;
+      }
+
+      return tlsVersions(strings);
+    }
+
+    public Builder tlsVersions(String... tlsVersions) {
+      if (!tls) throw new IllegalStateException("no TLS versions for cleartext connections");
+
+      if (tlsVersions.length == 0) {
+        throw new IllegalArgumentException("At least one TLS version is required");
+      }
+
+      this.tlsVersions = tlsVersions.clone(); // Defensive copy.
+      return this;
+    }
+
+    public Builder supportsTlsExtensions(boolean supportsTlsExtensions) {
+      if (!tls) throw new IllegalStateException("no TLS extensions for cleartext connections");
+      this.supportsTlsExtensions = supportsTlsExtensions;
+      return this;
+    }
+
+    public ConnectionSpec build() {
+      return new ConnectionSpec(this);
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/Cookie.java b/okhttp/src/main/java/okhttp3/Cookie.java
new file mode 100644
index 0000000000..29a4bf84d1
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/Cookie.java
@@ -0,0 +1,590 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.util.ArrayList;
+import java.util.Calendar;
+import java.util.Collections;
+import java.util.Date;
+import java.util.GregorianCalendar;
+import java.util.List;
+import java.util.Locale;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import okhttp3.internal.Util;
+import okhttp3.internal.http.HttpDate;
+
+import static okhttp3.internal.Util.UTC;
+import static okhttp3.internal.Util.delimiterOffset;
+import static okhttp3.internal.Util.domainToAscii;
+import static okhttp3.internal.Util.trimSubstring;
+import static okhttp3.internal.Util.verifyAsIpAddress;
+
+/**
+ * An <a href="http://tools.ietf.org/html/rfc6265">RFC 6265</a> Cookie.
+ *
+ * <p>This class doesn't support additional attributes on cookies, like <a
+ * href="https://code.google.com/p/chromium/issues/detail?id=232693">Chromium's Priority=HIGH
+ * extension</a>.
+ */
+public final class Cookie {
+  private static final Pattern YEAR_PATTERN
+      = Pattern.compile("(\\d{2,4})[^\\d]*");
+  private static final Pattern MONTH_PATTERN
+      = Pattern.compile("(?i)(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec).*");
+  private static final Pattern DAY_OF_MONTH_PATTERN
+      = Pattern.compile("(\\d{1,2})[^\\d]*");
+  private static final Pattern TIME_PATTERN
+      = Pattern.compile("(\\d{1,2}):(\\d{1,2}):(\\d{1,2})[^\\d]*");
+
+  private final String name;
+  private final String value;
+  private final long expiresAt;
+  private final String domain;
+  private final String path;
+  private final boolean secure;
+  private final boolean httpOnly;
+
+  private final boolean persistent; // True if 'expires' or 'max-age' is present.
+  private final boolean hostOnly; // True unless 'domain' is present.
+
+  private Cookie(String name, String value, long expiresAt, String domain, String path,
+      boolean secure, boolean httpOnly, boolean hostOnly, boolean persistent) {
+    this.name = name;
+    this.value = value;
+    this.expiresAt = expiresAt;
+    this.domain = domain;
+    this.path = path;
+    this.secure = secure;
+    this.httpOnly = httpOnly;
+    this.hostOnly = hostOnly;
+    this.persistent = persistent;
+  }
+
+  private Cookie(Builder builder) {
+    if (builder.name == null) throw new NullPointerException("builder.name == null");
+    if (builder.value == null) throw new NullPointerException("builder.value == null");
+    if (builder.domain == null) throw new NullPointerException("builder.domain == null");
+
+    this.name = builder.name;
+    this.value = builder.value;
+    this.expiresAt = builder.expiresAt;
+    this.domain = builder.domain;
+    this.path = builder.path;
+    this.secure = builder.secure;
+    this.httpOnly = builder.httpOnly;
+    this.persistent = builder.persistent;
+    this.hostOnly = builder.hostOnly;
+  }
+
+  /** Returns a non-empty string with this cookie's name. */
+  public String name() {
+    return name;
+  }
+
+  /** Returns a possibly-empty string with this cookie's value. */
+  public String value() {
+    return value;
+  }
+
+  /** Returns true if this cookie expires at the end of the current session. */
+  public boolean persistent() {
+    return persistent;
+  }
+
+  /**
+   * Returns the time that this cookie expires, in the same format as {@link
+   * System#currentTimeMillis()}. This is December 31, 9999 if the cookie is {@linkplain
+   * #persistent() not persistent}, in which case it will expire at the end of the current session.
+   *
+   * <p>This may return a value less than the current time, in which case the cookie is already
+   * expired. Webservers may return expired cookies as a mechanism to delete previously set cookies
+   * that may or may not themselves be expired.
+   */
+  public long expiresAt() {
+    return expiresAt;
+  }
+
+  /**
+   * Returns true if this cookie's domain should be interpreted as a single host name, or false if
+   * it should be interpreted as a pattern. This flag will be false if its {@code Set-Cookie} header
+   * included a {@code domain} attribute.
+   *
+   * <p>For example, suppose the cookie's domain is {@code example.com}. If this flag is true it
+   * matches <strong>only</strong> {@code example.com}. If this flag is false it matches {@code
+   * example.com} and all subdomains including {@code api.example.com}, {@code www.example.com}, and
+   * {@code beta.api.example.com}.
+   */
+  public boolean hostOnly() {
+    return hostOnly;
+  }
+
+  /**
+   * Returns the cookie's domain. If {@link #hostOnly()} returns true this is the only domain that
+   * matches this cookie; otherwise it matches this domain and all subdomains.
+   */
+  public String domain() {
+    return domain;
+  }
+
+  /**
+   * Returns this cookie's path. This cookie matches URLs prefixed with path segments that match
+   * this path's segments. For example, if this path is {@code /foo} this cookie matches requests to
+   * {@code /foo} and {@code /foo/bar}, but not {@code /} or {@code /football}.
+   */
+  public String path() {
+    return path;
+  }
+
+  /**
+   * Returns true if this cookie should be limited to only HTTP APIs. In web browsers this prevents
+   * the cookie from being accessible to scripts.
+   */
+  public boolean httpOnly() {
+    return httpOnly;
+  }
+
+  /** Returns true if this cookie should be limited to only HTTPS requests. */
+  public boolean secure() {
+    return secure;
+  }
+
+  /**
+   * Returns true if this cookie should be included on a request to {@code url}. In addition to this
+   * check callers should also confirm that this cookie has not expired.
+   */
+  public boolean matches(HttpUrl url) {
+    boolean domainMatch = hostOnly
+        ? url.host().equals(domain)
+        : domainMatch(url, domain);
+    if (!domainMatch) return false;
+
+    if (!pathMatch(url, path)) return false;
+
+    if (secure && !url.isHttps()) return false;
+
+    return true;
+  }
+
+  private static boolean domainMatch(HttpUrl url, String domain) {
+    String urlHost = url.host();
+
+    if (urlHost.equals(domain)) {
+      return true; // As in 'example.com' matching 'example.com'.
+    }
+
+    if (urlHost.endsWith(domain)
+        && urlHost.charAt(urlHost.length() - domain.length() - 1) == '.'
+        && !verifyAsIpAddress(urlHost)) {
+      return true; // As in 'example.com' matching 'www.example.com'.
+    }
+
+    return false;
+  }
+
+  private static boolean pathMatch(HttpUrl url, String path) {
+    String urlPath = url.encodedPath();
+
+    if (urlPath.equals(path)) {
+      return true; // As in '/foo' matching '/foo'.
+    }
+
+    if (urlPath.startsWith(path)) {
+      if (path.endsWith("/")) return true; // As in '/' matching '/foo'.
+      if (urlPath.charAt(path.length()) == '/') return true; // As in '/foo' matching '/foo/bar'.
+    }
+
+    return false;
+  }
+
+  /**
+   * Attempt to parse a {@code Set-Cookie} HTTP header value {@code setCookie} as a cookie. Returns
+   * null if {@code setCookie} is not a well-formed cookie.
+   */
+  public static Cookie parse(HttpUrl url, String setCookie) {
+    return parse(System.currentTimeMillis(), url, setCookie);
+  }
+
+  static Cookie parse(long currentTimeMillis, HttpUrl url, String setCookie) {
+    int pos = 0;
+    int limit = setCookie.length();
+    int cookiePairEnd = delimiterOffset(setCookie, pos, limit, ';');
+
+    int pairEqualsSign = delimiterOffset(setCookie, pos, cookiePairEnd, '=');
+    if (pairEqualsSign == cookiePairEnd) return null;
+
+    String cookieName = trimSubstring(setCookie, pos, pairEqualsSign);
+    if (cookieName.isEmpty()) return null;
+
+    String cookieValue = trimSubstring(setCookie, pairEqualsSign + 1, cookiePairEnd);
+
+    long expiresAt = HttpDate.MAX_DATE;
+    long deltaSeconds = -1L;
+    String domain = null;
+    String path = null;
+    boolean secureOnly = false;
+    boolean httpOnly = false;
+    boolean hostOnly = true;
+    boolean persistent = false;
+
+    pos = cookiePairEnd + 1;
+    while (pos < limit) {
+      int attributePairEnd = delimiterOffset(setCookie, pos, limit, ';');
+
+      int attributeEqualsSign = delimiterOffset(setCookie, pos, attributePairEnd, '=');
+      String attributeName = trimSubstring(setCookie, pos, attributeEqualsSign);
+      String attributeValue = attributeEqualsSign < attributePairEnd
+          ? trimSubstring(setCookie, attributeEqualsSign + 1, attributePairEnd)
+          : "";
+
+      if (attributeName.equalsIgnoreCase("expires")) {
+        try {
+          expiresAt = parseExpires(attributeValue, 0, attributeValue.length());
+          persistent = true;
+        } catch (IllegalArgumentException e) {
+          // Ignore this attribute, it isn't recognizable as a date.
+        }
+      } else if (attributeName.equalsIgnoreCase("max-age")) {
+        try {
+          deltaSeconds = parseMaxAge(attributeValue);
+          persistent = true;
+        } catch (NumberFormatException e) {
+          // Ignore this attribute, it isn't recognizable as a max age.
+        }
+      } else if (attributeName.equalsIgnoreCase("domain")) {
+        try {
+          domain = parseDomain(attributeValue);
+          hostOnly = false;
+        } catch (IllegalArgumentException e) {
+          // Ignore this attribute, it isn't recognizable as a domain.
+        }
+      } else if (attributeName.equalsIgnoreCase("path")) {
+        path = attributeValue;
+      } else if (attributeName.equalsIgnoreCase("secure")) {
+        secureOnly = true;
+      } else if (attributeName.equalsIgnoreCase("httponly")) {
+        httpOnly = true;
+      }
+
+      pos = attributePairEnd + 1;
+    }
+
+    // If 'Max-Age' is present, it takes precedence over 'Expires', regardless of the order the two
+    // attributes are declared in the cookie string.
+    if (deltaSeconds == Long.MIN_VALUE) {
+      expiresAt = Long.MIN_VALUE;
+    } else if (deltaSeconds != -1L) {
+      long deltaMilliseconds = deltaSeconds <= (Long.MAX_VALUE / 1000)
+          ? deltaSeconds * 1000
+          : Long.MAX_VALUE;
+      expiresAt = currentTimeMillis + deltaMilliseconds;
+      if (expiresAt < currentTimeMillis || expiresAt > HttpDate.MAX_DATE) {
+        expiresAt = HttpDate.MAX_DATE; // Handle overflow & limit the date range.
+      }
+    }
+
+    // If the domain is present, it must domain match. Otherwise we have a host-only cookie.
+    if (domain == null) {
+      domain = url.host();
+    } else if (!domainMatch(url, domain)) {
+      return null; // No domain match? This is either incompetence or malice!
+    }
+
+    // If the path is absent or didn't start with '/', use the default path. It's a string like
+    // '/foo/bar' for a URL like 'http://example.com/foo/bar/baz'. It always starts with '/'.
+    if (path == null || !path.startsWith("/")) {
+      String encodedPath = url.encodedPath();
+      int lastSlash = encodedPath.lastIndexOf('/');
+      path = lastSlash != 0 ? encodedPath.substring(0, lastSlash) : "/";
+    }
+
+    return new Cookie(cookieName, cookieValue, expiresAt, domain, path, secureOnly, httpOnly,
+        hostOnly, persistent);
+  }
+
+  /** Parse a date as specified in RFC 6265, section 5.1.1. */
+  private static long parseExpires(String s, int pos, int limit) {
+    pos = dateCharacterOffset(s, pos, limit, false);
+
+    int hour = -1;
+    int minute = -1;
+    int second = -1;
+    int dayOfMonth = -1;
+    int month = -1;
+    int year = -1;
+    Matcher matcher = TIME_PATTERN.matcher(s);
+
+    while (pos < limit) {
+      int end = dateCharacterOffset(s, pos + 1, limit, true);
+      matcher.region(pos, end);
+
+      if (hour == -1 && matcher.usePattern(TIME_PATTERN).matches()) {
+        hour = Integer.parseInt(matcher.group(1));
+        minute = Integer.parseInt(matcher.group(2));
+        second = Integer.parseInt(matcher.group(3));
+      } else if (dayOfMonth == -1 && matcher.usePattern(DAY_OF_MONTH_PATTERN).matches()) {
+        dayOfMonth = Integer.parseInt(matcher.group(1));
+      } else if (month == -1 && matcher.usePattern(MONTH_PATTERN).matches()) {
+        String monthString = matcher.group(1).toLowerCase(Locale.US);
+        month = MONTH_PATTERN.pattern().indexOf(monthString) / 4; // Sneaky! jan=1, dec=12.
+      } else if (year == -1 && matcher.usePattern(YEAR_PATTERN).matches()) {
+        year = Integer.parseInt(matcher.group(1));
+      }
+
+      pos = dateCharacterOffset(s, end + 1, limit, false);
+    }
+
+    // Convert two-digit years into four-digit years. 99 becomes 1999, 15 becomes 2015.
+    if (year >= 70 && year <= 99) year += 1900;
+    if (year >= 0 && year <= 69) year += 2000;
+
+    // If any partial is omitted or out of range, return -1. The date is impossible. Note that leap
+    // seconds are not supported by this syntax.
+    if (year < 1601) throw new IllegalArgumentException();
+    if (month == -1) throw new IllegalArgumentException();
+    if (dayOfMonth < 1 || dayOfMonth > 31) throw new IllegalArgumentException();
+    if (hour < 0 || hour > 23) throw new IllegalArgumentException();
+    if (minute < 0 || minute > 59) throw new IllegalArgumentException();
+    if (second < 0 || second > 59) throw new IllegalArgumentException();
+
+    Calendar calendar = new GregorianCalendar(UTC);
+    calendar.setLenient(false);
+    calendar.set(Calendar.YEAR, year);
+    calendar.set(Calendar.MONTH, month - 1);
+    calendar.set(Calendar.DAY_OF_MONTH, dayOfMonth);
+    calendar.set(Calendar.HOUR_OF_DAY, hour);
+    calendar.set(Calendar.MINUTE, minute);
+    calendar.set(Calendar.SECOND, second);
+    calendar.set(Calendar.MILLISECOND, 0);
+    return calendar.getTimeInMillis();
+  }
+
+  /**
+   * Returns the index of the next date character in {@code input}, or if {@code invert} the index
+   * of the next non-date character in {@code input}.
+   */
+  private static int dateCharacterOffset(String input, int pos, int limit, boolean invert) {
+    for (int i = pos; i < limit; i++) {
+      int c = input.charAt(i);
+      boolean dateCharacter = (c < ' ' && c != '\t') || (c >= '\u007f')
+          || (c >= '0' && c <= '9')
+          || (c >= 'a' && c <= 'z')
+          || (c >= 'A' && c <= 'Z')
+          || (c == ':');
+      if (dateCharacter == !invert) return i;
+    }
+    return limit;
+  }
+
+  /**
+   * Returns the positive value if {@code attributeValue} is positive, or {@link Long#MIN_VALUE} if
+   * it is either 0 or negative. If the value is positive but out of range, this returns {@link
+   * Long#MAX_VALUE}.
+   *
+   * @throws NumberFormatException if {@code s} is not an integer of any precision.
+   */
+  private static long parseMaxAge(String s) {
+    try {
+      long parsed = Long.parseLong(s);
+      return parsed <= 0L ? Long.MIN_VALUE : parsed;
+    } catch (NumberFormatException e) {
+      // Check if the value is an integer (positive or negative) that's too big for a long.
+      if (s.matches("-?\\d+")) {
+        return s.startsWith("-") ? Long.MIN_VALUE : Long.MAX_VALUE;
+      }
+      throw e;
+    }
+  }
+
+  /**
+   * Returns a domain string like {@code example.com} for an input domain like {@code EXAMPLE.COM}
+   * or {@code .example.com}.
+   */
+  private static String parseDomain(String s) {
+    if (s.endsWith(".")) {
+      throw new IllegalArgumentException();
+    }
+    if (s.startsWith(".")) {
+      s = s.substring(1);
+    }
+    String canonicalDomain = domainToAscii(s);
+    if (canonicalDomain == null) {
+      throw new IllegalArgumentException();
+    }
+    return canonicalDomain;
+  }
+
+  /** Returns all of the cookies from a set of HTTP response headers. */
+  public static List<Cookie> parseAll(HttpUrl url, Headers headers) {
+    List<String> cookieStrings = headers.values("Set-Cookie");
+    List<Cookie> cookies = null;
+
+    for (int i = 0, size = cookieStrings.size(); i < size; i++) {
+      Cookie cookie = Cookie.parse(url, cookieStrings.get(i));
+      if (cookie == null) continue;
+      if (cookies == null) cookies = new ArrayList<>();
+      cookies.add(cookie);
+    }
+
+    return cookies != null
+        ? Collections.unmodifiableList(cookies)
+        : Collections.<Cookie>emptyList();
+  }
+
+  /**
+   * Builds a cookie. The {@linkplain #name() name}, {@linkplain #value() value}, and {@linkplain
+   * #domain() domain} values must all be set before calling {@link #build}.
+   */
+  public static final class Builder {
+    String name;
+    String value;
+    long expiresAt = HttpDate.MAX_DATE;
+    String domain;
+    String path = "/";
+    boolean secure;
+    boolean httpOnly;
+    boolean persistent;
+    boolean hostOnly;
+
+    public Builder name(String name) {
+      if (name == null) throw new NullPointerException("name == null");
+      if (!name.trim().equals(name)) throw new IllegalArgumentException("name is not trimmed");
+      this.name = name;
+      return this;
+    }
+
+    public Builder value(String value) {
+      if (value == null) throw new NullPointerException("value == null");
+      if (!value.trim().equals(value)) throw new IllegalArgumentException("value is not trimmed");
+      this.value = value;
+      return this;
+    }
+
+    public Builder expiresAt(long expiresAt) {
+      if (expiresAt <= 0) expiresAt = Long.MIN_VALUE;
+      if (expiresAt > HttpDate.MAX_DATE) expiresAt = HttpDate.MAX_DATE;
+      this.expiresAt = expiresAt;
+      this.persistent = true;
+      return this;
+    }
+
+    /**
+     * Set the domain pattern for this cookie. The cookie will match {@code domain} and all of its
+     * subdomains.
+     */
+    public Builder domain(String domain) {
+      return domain(domain, false);
+    }
+
+    /**
+     * Set the host-only domain for this cookie. The cookie will match {@code domain} but none of
+     * its subdomains.
+     */
+    public Builder hostOnlyDomain(String domain) {
+      return domain(domain, true);
+    }
+
+    private Builder domain(String domain, boolean hostOnly) {
+      if (domain == null) throw new NullPointerException("domain == null");
+      String canonicalDomain = Util.domainToAscii(domain);
+      if (canonicalDomain == null) {
+        throw new IllegalArgumentException("unexpected domain: " + domain);
+      }
+      this.domain = canonicalDomain;
+      this.hostOnly = hostOnly;
+      return this;
+    }
+
+    public Builder path(String path) {
+      if (!path.startsWith("/")) throw new IllegalArgumentException("path must start with '/'");
+      this.path = path;
+      return this;
+    }
+
+    public Builder secure() {
+      this.secure = true;
+      return this;
+    }
+
+    public Builder httpOnly() {
+      this.httpOnly = true;
+      return this;
+    }
+
+    public Cookie build() {
+      return new Cookie(this);
+    }
+  }
+
+  @Override public String toString() {
+    StringBuilder result = new StringBuilder();
+    result.append(name);
+    result.append('=');
+    result.append(value);
+
+    if (persistent) {
+      if (expiresAt == Long.MIN_VALUE) {
+        result.append("; max-age=0");
+      } else {
+        result.append("; expires=").append(HttpDate.format(new Date(expiresAt)));
+      }
+    }
+
+    if (!hostOnly) {
+      result.append("; domain=").append(domain);
+    }
+
+    result.append("; path=").append(path);
+
+    if (secure) {
+      result.append("; secure");
+    }
+
+    if (httpOnly) {
+      result.append("; httponly");
+    }
+
+    return result.toString();
+  }
+
+  @Override public boolean equals(Object other) {
+    if (!(other instanceof Cookie)) return false;
+    Cookie that = (Cookie) other;
+    return that.name.equals(name)
+        && that.value.equals(value)
+        && that.domain.equals(domain)
+        && that.path.equals(path)
+        && that.expiresAt == expiresAt
+        && that.secure == secure
+        && that.httpOnly == httpOnly
+        && that.persistent == persistent
+        && that.hostOnly == hostOnly;
+  }
+
+  @Override public int hashCode() {
+    int hash = 17;
+    hash = 31 * hash + name.hashCode();
+    hash = 31 * hash + value.hashCode();
+    hash = 31 * hash + domain.hashCode();
+    hash = 31 * hash + path.hashCode();
+    hash = 31 * hash + (int) (expiresAt ^ (expiresAt >>> 32));
+    hash = 31 * hash + (secure ? 0 : 1);
+    hash = 31 * hash + (httpOnly ? 0 : 1);
+    hash = 31 * hash + (persistent ? 0 : 1);
+    hash = 31 * hash + (hostOnly ? 0 : 1);
+    return hash;
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/CookieJar.java b/okhttp/src/main/java/okhttp3/CookieJar.java
new file mode 100644
index 0000000000..d2cdfce22a
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/CookieJar.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * Provides <strong>policy</strong> and <strong>persistence</strong> for HTTP cookies.
+ *
+ * <p>As policy, implementations of this interface are responsible for selecting which cookies to
+ * accept and which to reject. A reasonable policy is to reject all cookies, though that may be
+ * interfere with session-based authentication schemes that require cookies.
+ *
+ * <p>As persistence, implementations of this interface must also provide storage of cookies. Simple
+ * implementations may store cookies in memory; sophisticated ones may use the file system or
+ * database to hold accepted cookies. The <a
+ * href="https://tools.ietf.org/html/rfc6265#section-5.3">cookie storage model</a> specifies
+ * policies for updating and expiring cookies.
+ */
+public interface CookieJar {
+  /** A cookie jar that never accepts any cookies. */
+  CookieJar NO_COOKIES = new CookieJar() {
+    @Override public void saveFromResponse(HttpUrl url, List<Cookie> cookies) {
+    }
+
+    @Override public List<Cookie> loadForRequest(HttpUrl url) {
+      return Collections.emptyList();
+    }
+  };
+
+  /**
+   * Saves {@code cookies} from an HTTP response to this store according to this jar's policy.
+   *
+   * <p>Note that this method may be called a second time for a single HTTP response if the response
+   * includes a trailer. For this obscure HTTP feature, {@code cookies} contains only the trailer's
+   * cookies.
+   */
+  void saveFromResponse(HttpUrl url, List<Cookie> cookies);
+
+  /**
+   * Load cookies from the jar for an HTTP request to {@code url}. This method returns a possibly
+   * empty list of cookies for the network request.
+   *
+   * <p>Simple implementations will return the accepted cookies that have not yet expired and that
+   * {@linkplain Cookie#matches match} {@code url}.
+   */
+  List<Cookie> loadForRequest(HttpUrl url);
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Credentials.java b/okhttp/src/main/java/okhttp3/Credentials.java
similarity index 97%
rename from okhttp/src/main/java/com/squareup/okhttp/Credentials.java
rename to okhttp/src/main/java/okhttp3/Credentials.java
index 92c128f568..9be4e6a22f 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Credentials.java
+++ b/okhttp/src/main/java/okhttp3/Credentials.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
 import java.io.UnsupportedEncodingException;
 import okio.ByteString;
diff --git a/okhttp/src/main/java/okhttp3/Dispatcher.java b/okhttp/src/main/java/okhttp3/Dispatcher.java
new file mode 100644
index 0000000000..0d30547afb
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/Dispatcher.java
@@ -0,0 +1,235 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Deque;
+import java.util.Iterator;
+import java.util.List;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.SynchronousQueue;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+import okhttp3.RealCall.AsyncCall;
+import okhttp3.internal.Util;
+
+/**
+ * Policy on when async requests are executed.
+ *
+ * <p>Each dispatcher uses an {@link ExecutorService} to run calls internally. If you supply your
+ * own executor, it should be able to run {@linkplain #getMaxRequests the configured maximum} number
+ * of calls concurrently.
+ */
+public final class Dispatcher {
+  private int maxRequests = 64;
+  private int maxRequestsPerHost = 5;
+  private Runnable idleCallback;
+
+  /** Executes calls. Created lazily. */
+  private ExecutorService executorService;
+
+  /** Ready async calls in the order they'll be run. */
+  private final Deque<AsyncCall> readyAsyncCalls = new ArrayDeque<>();
+
+  /** Running asynchronous calls. Includes canceled calls that haven't finished yet. */
+  private final Deque<AsyncCall> runningAsyncCalls = new ArrayDeque<>();
+
+  /** Running synchronous calls. Includes canceled calls that haven't finished yet. */
+  private final Deque<RealCall> runningSyncCalls = new ArrayDeque<>();
+
+  public Dispatcher(ExecutorService executorService) {
+    this.executorService = executorService;
+  }
+
+  public Dispatcher() {
+  }
+
+  public synchronized ExecutorService executorService() {
+    if (executorService == null) {
+      executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,
+          new SynchronousQueue<Runnable>(), Util.threadFactory("OkHttp Dispatcher", false));
+    }
+    return executorService;
+  }
+
+  /**
+   * Set the maximum number of requests to execute concurrently. Above this requests queue in
+   * memory, waiting for the running calls to complete.
+   *
+   * <p>If more than {@code maxRequests} requests are in flight when this is invoked, those requests
+   * will remain in flight.
+   */
+  public synchronized void setMaxRequests(int maxRequests) {
+    if (maxRequests < 1) {
+      throw new IllegalArgumentException("max < 1: " + maxRequests);
+    }
+    this.maxRequests = maxRequests;
+    promoteCalls();
+  }
+
+  public synchronized int getMaxRequests() {
+    return maxRequests;
+  }
+
+  /**
+   * Set the maximum number of requests for each host to execute concurrently. This limits requests
+   * by the URL's host name. Note that concurrent requests to a single IP address may still exceed
+   * this limit: multiple hostnames may share an IP address or be routed through the same HTTP
+   * proxy.
+   *
+   * <p>If more than {@code maxRequestsPerHost} requests are in flight when this is invoked, those
+   * requests will remain in flight.
+   */
+  public synchronized void setMaxRequestsPerHost(int maxRequestsPerHost) {
+    if (maxRequestsPerHost < 1) {
+      throw new IllegalArgumentException("max < 1: " + maxRequestsPerHost);
+    }
+    this.maxRequestsPerHost = maxRequestsPerHost;
+    promoteCalls();
+  }
+
+  public synchronized int getMaxRequestsPerHost() {
+    return maxRequestsPerHost;
+  }
+
+  /**
+   * Set a callback to be invoked each time the dispatcher becomes idle (when the number of running
+   * calls returns to zero).
+   *
+   * <p>Note: The time at which a {@linkplain Call call} is considered idle is different depending
+   * on whether it was run {@linkplain Call#enqueue(Callback) asynchronously} or
+   * {@linkplain Call#execute() synchronously}. Asynchronous calls become idle after the
+   * {@link Callback#onResponse onResponse} or {@link Callback#onFailure onFailure} callback has
+   * returned. Synchronous calls become idle once {@link Call#execute() execute()} returns. This
+   * means that if you are doing synchronous calls the network layer will not truly be idle until
+   * every returned {@link Response} has been closed.
+   */
+  public synchronized void setIdleCallback(Runnable idleCallback) {
+    this.idleCallback = idleCallback;
+  }
+
+  synchronized void enqueue(AsyncCall call) {
+    if (runningAsyncCalls.size() < maxRequests && runningCallsForHost(call) < maxRequestsPerHost) {
+      runningAsyncCalls.add(call);
+      executorService().execute(call);
+    } else {
+      readyAsyncCalls.add(call);
+    }
+  }
+
+  /**
+   * Cancel all calls currently enqueued or executing. Includes calls executed both {@linkplain
+   * Call#execute() synchronously} and {@linkplain Call#enqueue asynchronously}.
+   */
+  public synchronized void cancelAll() {
+    for (AsyncCall call : readyAsyncCalls) {
+      call.cancel();
+    }
+
+    for (AsyncCall call : runningAsyncCalls) {
+      call.cancel();
+    }
+
+    for (RealCall call : runningSyncCalls) {
+      call.cancel();
+    }
+  }
+
+  private void promoteCalls() {
+    if (runningAsyncCalls.size() >= maxRequests) return; // Already running max capacity.
+    if (readyAsyncCalls.isEmpty()) return; // No ready calls to promote.
+
+    for (Iterator<AsyncCall> i = readyAsyncCalls.iterator(); i.hasNext(); ) {
+      AsyncCall call = i.next();
+
+      if (runningCallsForHost(call) < maxRequestsPerHost) {
+        i.remove();
+        runningAsyncCalls.add(call);
+        executorService().execute(call);
+      }
+
+      if (runningAsyncCalls.size() >= maxRequests) return; // Reached max capacity.
+    }
+  }
+
+  /** Returns the number of running calls that share a host with {@code call}. */
+  private int runningCallsForHost(AsyncCall call) {
+    int result = 0;
+    for (AsyncCall c : runningAsyncCalls) {
+      if (c.host().equals(call.host())) result++;
+    }
+    return result;
+  }
+
+  /** Used by {@code Call#execute} to signal it is in-flight. */
+  synchronized void executed(RealCall call) {
+    runningSyncCalls.add(call);
+  }
+
+  /** Used by {@code AsyncCall#run} to signal completion. */
+  void finished(AsyncCall call) {
+    finished(runningAsyncCalls, call, true);
+  }
+
+  /** Used by {@code Call#execute} to signal completion. */
+  void finished(RealCall call) {
+    finished(runningSyncCalls, call, false);
+  }
+
+  private <T> void finished(Deque<T> calls, T call, boolean promoteCalls) {
+    int runningCallsCount;
+    Runnable idleCallback;
+    synchronized (this) {
+      if (!calls.remove(call)) throw new AssertionError("Call wasn't in-flight!");
+      if (promoteCalls) promoteCalls();
+      runningCallsCount = runningCallsCount();
+      idleCallback = this.idleCallback;
+    }
+
+    if (runningCallsCount == 0 && idleCallback != null) {
+      idleCallback.run();
+    }
+  }
+
+  /** Returns a snapshot of the calls currently awaiting execution. */
+  public synchronized List<Call> queuedCalls() {
+    List<Call> result = new ArrayList<>();
+    for (AsyncCall asyncCall : readyAsyncCalls) {
+      result.add(asyncCall.get());
+    }
+    return Collections.unmodifiableList(result);
+  }
+
+  /** Returns a snapshot of the calls currently being executed. */
+  public synchronized List<Call> runningCalls() {
+    List<Call> result = new ArrayList<>();
+    result.addAll(runningSyncCalls);
+    for (AsyncCall asyncCall : runningAsyncCalls) {
+      result.add(asyncCall.get());
+    }
+    return Collections.unmodifiableList(result);
+  }
+
+  public synchronized int queuedCallsCount() {
+    return readyAsyncCalls.size();
+  }
+
+  public synchronized int runningCallsCount() {
+    return runningAsyncCalls.size() + runningSyncCalls.size();
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/Dns.java b/okhttp/src/main/java/okhttp3/Dns.java
new file mode 100644
index 0000000000..a2e6db591c
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/Dns.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.util.Arrays;
+import java.util.List;
+
+/**
+ * A domain name service that resolves IP addresses for host names. Most applications will use the
+ * {@linkplain #SYSTEM system DNS service}, which is the default. Some applications may provide
+ * their own implementation to use a different DNS server, to prefer IPv6 addresses, to prefer IPv4
+ * addresses, or to force a specific known IP address.
+ *
+ * <p>Implementations of this interface must be safe for concurrent use.
+ */
+public interface Dns {
+  /**
+   * A DNS that uses {@link InetAddress#getAllByName} to ask the underlying operating system to
+   * lookup IP addresses. Most custom {@link Dns} implementations should delegate to this instance.
+   */
+  Dns SYSTEM = new Dns() {
+    @Override public List<InetAddress> lookup(String hostname) throws UnknownHostException {
+      if (hostname == null) throw new UnknownHostException("hostname == null");
+      return Arrays.asList(InetAddress.getAllByName(hostname));
+    }
+  };
+
+  /**
+   * Returns the IP addresses of {@code hostname}, in the order they will be attempted by OkHttp. If
+   * a connection to an address fails, OkHttp will retry the connection with the next address until
+   * either a connection is made, the set of IP addresses is exhausted, or a limit is exceeded.
+   */
+  List<InetAddress> lookup(String hostname) throws UnknownHostException;
+}
diff --git a/okhttp/src/main/java/okhttp3/FormBody.java b/okhttp/src/main/java/okhttp3/FormBody.java
new file mode 100644
index 0000000000..95181b1f76
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/FormBody.java
@@ -0,0 +1,124 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import okhttp3.internal.Util;
+import okio.Buffer;
+import okio.BufferedSink;
+
+import static okhttp3.HttpUrl.FORM_ENCODE_SET;
+import static okhttp3.HttpUrl.percentDecode;
+
+public final class FormBody extends RequestBody {
+  private static final MediaType CONTENT_TYPE =
+      MediaType.parse("application/x-www-form-urlencoded");
+
+  private final List<String> encodedNames;
+  private final List<String> encodedValues;
+
+  private FormBody(List<String> encodedNames, List<String> encodedValues) {
+    this.encodedNames = Util.immutableList(encodedNames);
+    this.encodedValues = Util.immutableList(encodedValues);
+  }
+
+  /** The number of key-value pairs in this form-encoded body. */
+  public int size() {
+    return encodedNames.size();
+  }
+
+  public String encodedName(int index) {
+    return encodedNames.get(index);
+  }
+
+  public String name(int index) {
+    return percentDecode(encodedName(index), true);
+  }
+
+  public String encodedValue(int index) {
+    return encodedValues.get(index);
+  }
+
+  public String value(int index) {
+    return percentDecode(encodedValue(index), true);
+  }
+
+  @Override public MediaType contentType() {
+    return CONTENT_TYPE;
+  }
+
+  @Override public long contentLength() {
+    return writeOrCountBytes(null, true);
+  }
+
+  @Override public void writeTo(BufferedSink sink) throws IOException {
+    writeOrCountBytes(sink, false);
+  }
+
+  /**
+   * Either writes this request to {@code sink} or measures its content length. We have one method
+   * do double-duty to make sure the counting and content are consistent, particularly when it comes
+   * to awkward operations like measuring the encoded length of header strings, or the
+   * length-in-digits of an encoded integer.
+   */
+  private long writeOrCountBytes(BufferedSink sink, boolean countBytes) {
+    long byteCount = 0L;
+
+    Buffer buffer;
+    if (countBytes) {
+      buffer = new Buffer();
+    } else {
+      buffer = sink.buffer();
+    }
+
+    for (int i = 0, size = encodedNames.size(); i < size; i++) {
+      if (i > 0) buffer.writeByte('&');
+      buffer.writeUtf8(encodedNames.get(i));
+      buffer.writeByte('=');
+      buffer.writeUtf8(encodedValues.get(i));
+    }
+
+    if (countBytes) {
+      byteCount = buffer.size();
+      buffer.clear();
+    }
+
+    return byteCount;
+  }
+
+  public static final class Builder {
+    private final List<String> names = new ArrayList<>();
+    private final List<String> values = new ArrayList<>();
+
+    public Builder add(String name, String value) {
+      names.add(HttpUrl.canonicalize(name, FORM_ENCODE_SET, false, false, true, true));
+      values.add(HttpUrl.canonicalize(value, FORM_ENCODE_SET, false, false, true, true));
+      return this;
+    }
+
+    public Builder addEncoded(String name, String value) {
+      names.add(HttpUrl.canonicalize(name, FORM_ENCODE_SET, true, false, true, true));
+      values.add(HttpUrl.canonicalize(value, FORM_ENCODE_SET, true, false, true, true));
+      return this;
+    }
+
+    public FormBody build() {
+      return new FormBody(names, values);
+    }
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Handshake.java b/okhttp/src/main/java/okhttp3/Handshake.java
similarity index 65%
rename from okhttp/src/main/java/com/squareup/okhttp/Handshake.java
rename to okhttp/src/main/java/okhttp3/Handshake.java
index d9f5366757..d2c08be57e 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Handshake.java
+++ b/okhttp/src/main/java/okhttp3/Handshake.java
@@ -13,10 +13,8 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+package okhttp3;
 
-package com.squareup.okhttp;
-
-import com.squareup.okhttp.internal.Util;
 import java.security.Principal;
 import java.security.cert.Certificate;
 import java.security.cert.X509Certificate;
@@ -24,29 +22,37 @@
 import java.util.List;
 import javax.net.ssl.SSLPeerUnverifiedException;
 import javax.net.ssl.SSLSession;
+import okhttp3.internal.Util;
 
 /**
- * A record of a TLS handshake. For HTTPS clients, the client is <i>local</i>
- * and the remote server is its <i>peer</i>.
+ * A record of a TLS handshake. For HTTPS clients, the client is <i>local</i> and the remote server
+ * is its <i>peer</i>.
  *
- * <p>This value object describes a completed handshake. Use {@link
- * javax.net.ssl.SSLSocketFactory} to set policy for new handshakes.
+ * <p>This value object describes a completed handshake. Use {@link ConnectionSpec} to set policy
+ * for new handshakes.
  */
 public final class Handshake {
-  private final String cipherSuite;
+  private final TlsVersion tlsVersion;
+  private final CipherSuite cipherSuite;
   private final List<Certificate> peerCertificates;
   private final List<Certificate> localCertificates;
 
-  private Handshake(
-      String cipherSuite, List<Certificate> peerCertificates, List<Certificate> localCertificates) {
+  private Handshake(TlsVersion tlsVersion, CipherSuite cipherSuite,
+      List<Certificate> peerCertificates, List<Certificate> localCertificates) {
+    this.tlsVersion = tlsVersion;
     this.cipherSuite = cipherSuite;
     this.peerCertificates = peerCertificates;
     this.localCertificates = localCertificates;
   }
 
   public static Handshake get(SSLSession session) {
-    String cipherSuite = session.getCipherSuite();
-    if (cipherSuite == null) throw new IllegalStateException("cipherSuite == null");
+    String cipherSuiteString = session.getCipherSuite();
+    if (cipherSuiteString == null) throw new IllegalStateException("cipherSuite == null");
+    CipherSuite cipherSuite = CipherSuite.forJavaName(cipherSuiteString);
+
+    String tlsVersionString = session.getProtocol();
+    if (tlsVersionString == null) throw new IllegalStateException("tlsVersion == null");
+    TlsVersion tlsVersion = TlsVersion.forJavaName(tlsVersionString);
 
     Certificate[] peerCertificates;
     try {
@@ -63,18 +69,26 @@ public static Handshake get(SSLSession session) {
         ? Util.immutableList(localCertificates)
         : Collections.<Certificate>emptyList();
 
-    return new Handshake(cipherSuite, peerCertificatesList, localCertificatesList);
+    return new Handshake(tlsVersion, cipherSuite, peerCertificatesList, localCertificatesList);
   }
 
-  public static Handshake get(
-      String cipherSuite, List<Certificate> peerCertificates, List<Certificate> localCertificates) {
-    if (cipherSuite == null) throw new IllegalArgumentException("cipherSuite == null");
-    return new Handshake(cipherSuite, Util.immutableList(peerCertificates),
+  public static Handshake get(TlsVersion tlsVersion, CipherSuite cipherSuite,
+      List<Certificate> peerCertificates, List<Certificate> localCertificates) {
+    if (cipherSuite == null) throw new NullPointerException("cipherSuite == null");
+    return new Handshake(tlsVersion, cipherSuite, Util.immutableList(peerCertificates),
         Util.immutableList(localCertificates));
   }
 
-  /** Returns a cipher suite name like "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA". */
-  public String cipherSuite() {
+  /**
+   * Returns the TLS version used for this connection. May return null if the response was cached
+   * with a version of OkHttp prior to 3.0.
+   */
+  public TlsVersion tlsVersion() {
+    return tlsVersion;
+  }
+
+  /** Returns the cipher suite used for the connection. */
+  public CipherSuite cipherSuite() {
     return cipherSuite;
   }
 
@@ -105,13 +119,15 @@ public Principal localPrincipal() {
   @Override public boolean equals(Object other) {
     if (!(other instanceof Handshake)) return false;
     Handshake that = (Handshake) other;
-    return cipherSuite.equals(that.cipherSuite)
+    return Util.equal(cipherSuite, that.cipherSuite)
+        && cipherSuite.equals(that.cipherSuite)
         && peerCertificates.equals(that.peerCertificates)
         && localCertificates.equals(that.localCertificates);
   }
 
   @Override public int hashCode() {
     int result = 17;
+    result = 31 * result + (tlsVersion != null ? tlsVersion.hashCode() : 0);
     result = 31 * result + cipherSuite.hashCode();
     result = 31 * result + peerCertificates.hashCode();
     result = 31 * result + localCertificates.hashCode();
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Headers.java b/okhttp/src/main/java/okhttp3/Headers.java
similarity index 65%
rename from okhttp/src/main/java/com/squareup/okhttp/Headers.java
rename to okhttp/src/main/java/okhttp3/Headers.java
index 2be385ce2b..5080883af7 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Headers.java
+++ b/okhttp/src/main/java/okhttp3/Headers.java
@@ -15,34 +15,36 @@
  *  limitations under the License.
  */
 
-package com.squareup.okhttp;
+package okhttp3;
 
-import com.squareup.okhttp.internal.http.HttpDate;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.Date;
+import java.util.LinkedHashMap;
 import java.util.List;
+import java.util.Locale;
 import java.util.Map;
 import java.util.Set;
 import java.util.TreeSet;
+import okhttp3.internal.Util;
+import okhttp3.internal.http.HttpDate;
 
 /**
- * The header fields of a single HTTP message. Values are uninterpreted strings;
- * use {@code Request} and {@code Response} for interpreted headers. This class
- * maintains the order of the header fields within the HTTP message.
+ * The header fields of a single HTTP message. Values are uninterpreted strings; use {@code Request}
+ * and {@code Response} for interpreted headers. This class maintains the order of the header fields
+ * within the HTTP message.
  *
- * <p>This class tracks header values line-by-line. A field with multiple comma-
- * separated values on the same line will be treated as a field with a single
- * value by this class. It is the caller's responsibility to detect and split
- * on commas if their field permits multiple values. This simplifies use of
- * single-valued fields whose values routinely contain commas, such as cookies
- * or dates.
+ * <p>This class tracks header values line-by-line. A field with multiple comma- separated values on
+ * the same line will be treated as a field with a single value by this class. It is the caller's
+ * responsibility to detect and split on commas if their field permits multiple values. This
+ * simplifies use of single-valued fields whose values routinely contain commas, such as cookies or
+ * dates.
  *
- * <p>This class trims whitespace from values. It never returns values with
- * leading or trailing whitespace.
+ * <p>This class trims whitespace from values. It never returns values with leading or trailing
+ * whitespace.
  *
- * <p>Instances of this class are immutable. Use {@link Builder} to create
- * instances.
+ * <p>Instances of this class are immutable. Use {@link Builder} to create instances.
  */
 public final class Headers {
   private final String[] namesAndValues;
@@ -61,9 +63,8 @@ public String get(String name) {
   }
 
   /**
-   * Returns the last value corresponding to the specified field parsed as an
-   * HTTP date, or null if either the field is absent or cannot be parsed as a
-   * date.
+   * Returns the last value corresponding to the specified field parsed as an HTTP date, or null if
+   * either the field is absent or cannot be parsed as a date.
    */
   public Date getDate(String name) {
     String value = get(name);
@@ -75,22 +76,14 @@ public int size() {
     return namesAndValues.length / 2;
   }
 
-  /** Returns the field at {@code position} or null if that is out of range. */
+  /** Returns the field at {@code position}. */
   public String name(int index) {
-    int nameIndex = index * 2;
-    if (nameIndex < 0 || nameIndex >= namesAndValues.length) {
-      return null;
-    }
-    return namesAndValues[nameIndex];
+    return namesAndValues[index * 2];
   }
 
-  /** Returns the value at {@code index} or null if that is out of range. */
+  /** Returns the value at {@code index}. */
   public String value(int index) {
-    int valueIndex = index * 2 + 1;
-    if (valueIndex < 0 || valueIndex >= namesAndValues.length) {
-      return null;
-    }
-    return namesAndValues[valueIndex];
+    return namesAndValues[index * 2 + 1];
   }
 
   /** Returns an immutable case-insensitive set of header names. */
@@ -122,6 +115,41 @@ public Builder newBuilder() {
     return result;
   }
 
+  /**
+   * Returns true if {@code other} is a {@code Headers} object with the same headers, with the same
+   * casing, in the same order. Note that two headers instances may be <i>semantically</i> equal
+   * but not equal according to this method. In particular, none of the following sets of headers
+   * are equal according to this method: <pre>   {@code
+   *
+   *   1. Original
+   *   Content-Type: text/html
+   *   Content-Length: 50
+   *
+   *   2. Different order
+   *   Content-Length: 50
+   *   Content-Type: text/html
+   *
+   *   3. Different case
+   *   content-type: text/html
+   *   content-length: 50
+   *
+   *   4. Different values
+   *   Content-Type: text/html
+   *   Content-Length: 050
+   * }</pre>
+   *
+   * Applications that require semantically equal headers should convert them into a canonical form
+   * before comparing them for equality.
+   */
+  @Override public boolean equals(Object other) {
+    return other instanceof Headers
+        && Arrays.equals(((Headers) other).namesAndValues, namesAndValues);
+  }
+
+  @Override public int hashCode() {
+    return Arrays.hashCode(namesAndValues);
+  }
+
   @Override public String toString() {
     StringBuilder result = new StringBuilder();
     for (int i = 0, size = size(); i < size; i++) {
@@ -130,6 +158,20 @@ public Builder newBuilder() {
     return result.toString();
   }
 
+  public Map<String, List<String>> toMultimap() {
+    Map<String, List<String>> result = new LinkedHashMap<>();
+    for (int i = 0, size = size(); i < size; i++) {
+      String name = name(i).toLowerCase(Locale.US);
+      List<String> values = result.get(name);
+      if (values == null) {
+        values = new ArrayList<>(2);
+        result.put(name, values);
+      }
+      values.add(value(i));
+    }
+    return result;
+  }
+
   private static String get(String[] namesAndValues, String name) {
     for (int i = namesAndValues.length - 2; i >= 0; i -= 2) {
       if (name.equalsIgnoreCase(namesAndValues[i])) {
@@ -140,12 +182,12 @@ private static String get(String[] namesAndValues, String name) {
   }
 
   /**
-   * Returns headers for the alternating header names and values. There must be
-   * an even number of arguments, and they must alternate between header names
-   * and values.
+   * Returns headers for the alternating header names and values. There must be an even number of
+   * arguments, and they must alternate between header names and values.
    */
   public static Headers of(String... namesAndValues) {
-    if (namesAndValues == null || namesAndValues.length % 2 != 0) {
+    if (namesAndValues == null) throw new NullPointerException("namesAndValues == null");
+    if (namesAndValues.length % 2 != 0) {
       throw new IllegalArgumentException("Expected alternating header names and values");
     }
 
@@ -172,9 +214,7 @@ public static Headers of(String... namesAndValues) {
    * Returns headers for the header names and values in the {@link Map}.
    */
   public static Headers of(Map<String, String> headers) {
-    if (headers == null) {
-      throw new IllegalArgumentException("Expected map with header names and values");
-    }
+    if (headers == null) throw new NullPointerException("headers == null");
 
     // Make a defensive copy and clean it up.
     String[] namesAndValues = new String[headers.size() * 2];
@@ -227,19 +267,15 @@ public Builder add(String line) {
 
     /** Add a field with the specified value. */
     public Builder add(String name, String value) {
-      if (name == null) throw new IllegalArgumentException("name == null");
-      if (value == null) throw new IllegalArgumentException("value == null");
-      if (name.length() == 0 || name.indexOf('\0') != -1 || value.indexOf('\0') != -1) {
-        throw new IllegalArgumentException("Unexpected header: " + name + ": " + value);
-      }
+      checkNameAndValue(name, value);
       return addLenient(name, value);
     }
 
     /**
-     * Add a field with the specified value without any validation. Only
-     * appropriate for headers from the remote peer.
+     * Add a field with the specified value without any validation. Only appropriate for headers
+     * from the remote peer or cache.
      */
-    private Builder addLenient(String name, String value) {
+    Builder addLenient(String name, String value) {
       namesAndValues.add(name);
       namesAndValues.add(value.trim());
       return this;
@@ -257,15 +293,36 @@ public Builder removeAll(String name) {
     }
 
     /**
-     * Set a field with the specified value. If the field is not found, it is
-     * added. If the field is found, the existing values are replaced.
+     * Set a field with the specified value. If the field is not found, it is added. If the field is
+     * found, the existing values are replaced.
      */
     public Builder set(String name, String value) {
+      checkNameAndValue(name, value);
       removeAll(name);
-      add(name, value);
+      addLenient(name, value);
       return this;
     }
 
+    private void checkNameAndValue(String name, String value) {
+      if (name == null) throw new NullPointerException("name == null");
+      if (name.isEmpty()) throw new IllegalArgumentException("name is empty");
+      for (int i = 0, length = name.length(); i < length; i++) {
+        char c = name.charAt(i);
+        if (c <= '\u001f' || c >= '\u007f') {
+          throw new IllegalArgumentException(Util.format(
+              "Unexpected char %#04x at %d in header name: %s", (int) c, i, name));
+        }
+      }
+      if (value == null) throw new NullPointerException("value == null");
+      for (int i = 0, length = value.length(); i < length; i++) {
+        char c = value.charAt(i);
+        if (c <= '\u001f' || c >= '\u007f') {
+          throw new IllegalArgumentException(Util.format(
+              "Unexpected char %#04x at %d in %s value: %s", (int) c, i, name, value));
+        }
+      }
+    }
+
     /** Equivalent to {@code build().get(name)}, but potentially faster. */
     public String get(String name) {
       for (int i = namesAndValues.size() - 2; i >= 0; i -= 2) {
diff --git a/okhttp/src/main/java/okhttp3/HttpUrl.java b/okhttp/src/main/java/okhttp3/HttpUrl.java
new file mode 100644
index 0000000000..45effb8f6d
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/HttpUrl.java
@@ -0,0 +1,1614 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.net.InetAddress;
+import java.net.MalformedURLException;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.net.URL;
+import java.net.UnknownHostException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Set;
+import okio.Buffer;
+
+import static okhttp3.internal.Util.delimiterOffset;
+import static okhttp3.internal.Util.domainToAscii;
+import static okhttp3.internal.Util.skipLeadingAsciiWhitespace;
+import static okhttp3.internal.Util.skipTrailingAsciiWhitespace;
+
+/**
+ * A uniform resource locator (URL) with a scheme of either {@code http} or {@code https}. Use this
+ * class to compose and decompose Internet addresses. For example, this code will compose and print
+ * a URL for Google search: <pre>   {@code
+ *
+ *   HttpUrl url = new HttpUrl.Builder()
+ *       .scheme("https")
+ *       .host("www.google.com")
+ *       .addPathSegment("search")
+ *       .addQueryParameter("q", "polar bears")
+ *       .build();
+ *   System.out.println(url);
+ * }</pre>
+ *
+ * which prints: <pre>   {@code
+ *
+ *     https://www.google.com/search?q=polar%20bears
+ * }</pre>
+ *
+ * As another example, this code prints the human-readable query parameters of a Twitter search:
+ * <pre>   {@code
+ *
+ *   HttpUrl url = HttpUrl.parse("https://twitter.com/search?q=cute%20%23puppies&f=images");
+ *   for (int i = 0, size = url.querySize(); i < size; i++) {
+ *     System.out.println(url.queryParameterName(i) + ": " + url.queryParameterValue(i));
+ *   }
+ * }</pre>
+ *
+ * which prints: <pre>   {@code
+ *
+ *   q: cute #puppies
+ *   f: images
+ * }</pre>
+ *
+ * In addition to composing URLs from their component parts and decomposing URLs into their
+ * component parts, this class implements relative URL resolution: what address you'd reach by
+ * clicking a relative link on a specified page. For example: <pre>   {@code
+ *
+ *   HttpUrl base = HttpUrl.parse("https://www.youtube.com/user/WatchTheDaily/videos");
+ *   HttpUrl link = base.resolve("../../watch?v=cbP2N1BQdYc");
+ *   System.out.println(link);
+ * }</pre>
+ *
+ * which prints: <pre>   {@code
+ *
+ *   https://www.youtube.com/watch?v=cbP2N1BQdYc
+ * }</pre>
+ *
+ * <h3>What's in a URL?</h3>
+ *
+ * A URL has several components.
+ *
+ * <h4>Scheme</h4>
+ *
+ * <p>Sometimes referred to as <i>protocol</i>, A URL's scheme describes what mechanism should be
+ * used to retrieve the resource. Although URLs have many schemes ({@code mailto}, {@code file},
+ * {@code ftp}), this class only supports {@code http} and {@code https}. Use {@link URI
+ * java.net.URI} for URLs with arbitrary schemes.
+ *
+ * <h4>Username and Password</h4>
+ *
+ * <p>Username and password are either present, or the empty string {@code ""} if absent. This class
+ * offers no mechanism to differentiate empty from absent. Neither of these components are popular
+ * in practice. Typically HTTP applications use other mechanisms for user identification and
+ * authentication.
+ *
+ * <h4>Host</h4>
+ *
+ * <p>The host identifies the webserver that serves the URL's resource. It is either a hostname like
+ * {@code square.com} or {@code localhost}, an IPv4 address like {@code 192.168.0.1}, or an IPv6
+ * address like {@code ::1}.
+ *
+ * <p>Usually a webserver is reachable with multiple identifiers: its IP addresses, registered
+ * domain names, and even {@code localhost} when connecting from the server itself. Each of a
+ * webserver's names is a distinct URL and they are not interchangeable. For example, even if {@code
+ * http://square.github.io/dagger} and {@code http://google.github.io/dagger} are served by the same
+ * IP address, the two URLs identify different resources.
+ *
+ * <h4>Port</h4>
+ *
+ * <p>The port used to connect to the webserver. By default this is 80 for HTTP and 443 for HTTPS.
+ * This class never returns -1 for the port: if no port is explicitly specified in the URL then the
+ * scheme's default is used.
+ *
+ * <h4>Path</h4>
+ *
+ * <p>The path identifies a specific resource on the host. Paths have a hierarchical structure like
+ * "/square/okhttp/issues/1486". Each path segment is prefixed with "/". This class offers methods
+ * to compose and decompose paths by segment. If a path's last segment is the empty string, then the
+ * path ends with "/". This class always builds non-empty paths: if the path is omitted it defaults
+ * to "/", which is a path whose only segment is the empty string.
+ *
+ * <h4>Query</h4>
+ *
+ * <p>The query is optional: it can be null, empty, or non-empty. For many HTTP URLs the query
+ * string is subdivided into a collection of name-value parameters. This class offers methods to set
+ * the query as the single string, or as individual name-value parameters. With name-value
+ * parameters the values are optional and names may be repeated.
+ *
+ * <h4>Fragment</h4>
+ *
+ * <p>The fragment is optional: it can be null, empty, or non-empty. Unlike host, port, path, and
+ * query the fragment is not sent to the webserver: it's private to the client.
+ *
+ * <h3>Encoding</h3>
+ *
+ * <p>Each component must be encoded before it is embedded in the complete URL. As we saw above, the
+ * string {@code cute #puppies} is encoded as {@code cute%20%23puppies} when used as a query
+ * parameter value.
+ *
+ * <h4>Percent encoding</h4>
+ *
+ * <p>Percent encoding replaces a character (like {@code \ud83c\udf69}) with its UTF-8 hex bytes
+ * (like {@code %F0%9F%8D%A9}). This approach works for whitespace characters, control characters,
+ * non-ASCII characters, and characters that already have another meaning in a particular context.
+ *
+ * <p>Percent encoding is used in every URL component except for the hostname. But the set of
+ * characters that need to be encoded is different for each component. For example, the path
+ * component must escape all of its {@code ?} characters, otherwise it could be interpreted as the
+ * start of the URL's query. But within the query and fragment components, the {@code ?} character
+ * doesn't delimit anything and doesn't need to be escaped. <pre>   {@code
+ *
+ *   HttpUrl url = HttpUrl.parse("http://who-let-the-dogs.out").newBuilder()
+ *       .addPathSegment("_Who?_")
+ *       .query("_Who?_")
+ *       .fragment("_Who?_")
+ *       .build();
+ *   System.out.println(url);
+ * }</pre>
+ *
+ * This prints: <pre>   {@code
+ *
+ *   http://who-let-the-dogs.out/_Who%3F_?_Who?_#_Who?_
+ * }</pre>
+ *
+ * When parsing URLs that lack percent encoding where it is required, this class will percent encode
+ * the offending characters.
+ *
+ * <h4>IDNA Mapping and Punycode encoding</h4>
+ *
+ * <p>Hostnames have different requirements and use a different encoding scheme. It consists of IDNA
+ * mapping and Punycode encoding.
+ *
+ * <p>In order to avoid confusion and discourage phishing attacks, <a
+ * href="http://www.unicode.org/reports/tr46/#ToASCII">IDNA Mapping</a> transforms names to avoid
+ * confusing characters. This includes basic case folding: transforming shouting {@code SQUARE.COM}
+ * into cool and casual {@code square.com}. It also handles more exotic characters. For example, the
+ * Unicode trademark sign (™) could be confused for the letters "TM" in {@code http://ho™mail.com}.
+ * To mitigate this, the single character (™) maps to the string (tm). There is similar policy for
+ * all of the 1.1 million Unicode code points. Note that some code points such as "\ud83c\udf69" are
+ * not mapped and cannot be used in a hostname.
+ *
+ * <p><a href="http://ietf.org/rfc/rfc3492.txt">Punycode</a> converts a Unicode string to an ASCII
+ * string to make international domain names work everywhere. For example, "σ" encodes as "xn--4xa".
+ * The encoded string is not human readable, but can be used with classes like {@link InetAddress}
+ * to establish connections.
+ *
+ * <h3>Why another URL model?</h3>
+ *
+ * <p>Java includes both {@link URL java.net.URL} and {@link URI java.net.URI}. We offer a new URL
+ * model to address problems that the others don't.
+ *
+ * <h4>Different URLs should be different</h4>
+ *
+ * <p>Although they have different content, {@code java.net.URL} considers the following two URLs
+ * equal, and the {@link Object#equals equals()} method between them returns true:
+ *
+ * <ul>
+ *   <li>http://square.github.io/
+ *   <li>http://google.github.io/
+ * </ul>
+ *
+ * This is because those two hosts share the same IP address. This is an old, bad design decision
+ * that makes {@code java.net.URL} unusable for many things. It shouldn't be used as a {@link
+ * java.util.Map Map} key or in a {@link Set}. Doing so is both inefficient because equality may
+ * require a DNS lookup, and incorrect because unequal URLs may be equal because of how they are
+ * hosted.
+ *
+ * <h4>Equal URLs should be equal</h4>
+ *
+ * <p>These two URLs are semantically identical, but {@code java.net.URI} disagrees:
+ *
+ * <ul>
+ *   <li>http://host:80/
+ *   <li>http://host
+ * </ul>
+ *
+ * Both the unnecessary port specification ({@code :80}) and the absent trailing slash ({@code /})
+ * cause URI to bucket the two URLs separately. This harms URI's usefulness in collections. Any
+ * application that stores information-per-URL will need to either canonicalize manually, or suffer
+ * unnecessary redundancy for such URLs.
+ *
+ * <p>Because they don't attempt canonical form, these classes are surprisingly difficult to use
+ * securely. Suppose you're building a webservice that checks that incoming paths are prefixed
+ * "/static/images/" before serving the corresponding assets from the filesystem. <pre>   {@code
+ *
+ *   String attack = "http://example.com/static/images/../../../../../etc/passwd";
+ *   System.out.println(new URL(attack).getPath());
+ *   System.out.println(new URI(attack).getPath());
+ *   System.out.println(HttpUrl.parse(attack).path());
+ * }</pre>
+ *
+ * By canonicalizing the input paths, they are complicit in directory traversal attacks. Code that
+ * checks only the path prefix may suffer!
+ * <pre>   {@code
+ *
+ *    /static/images/../../../../../etc/passwd
+ *    /static/images/../../../../../etc/passwd
+ *    /etc/passwd
+ * }</pre>
+ *
+ * <h4>If it works on the web, it should work in your application</h4>
+ *
+ * <p>The {@code java.net.URI} class is strict around what URLs it accepts. It rejects URLs like
+ * "http://example.com/abc|def" because the '|' character is unsupported. This class is more
+ * forgiving: it will automatically percent-encode the '|', yielding "http://example.com/abc%7Cdef".
+ * This kind behavior is consistent with web browsers. {@code HttpUrl} prefers consistency with
+ * major web browsers over consistency with obsolete specifications.
+ *
+ * <h4>Paths and Queries should decompose</h4>
+ *
+ * <p>Neither of the built-in URL models offer direct access to path segments or query parameters.
+ * Manually using {@code StringBuilder} to assemble these components is cumbersome: do '+'
+ * characters get silently replaced with spaces? If a query parameter contains a '&amp;', does that
+ * get escaped? By offering methods to read and write individual query parameters directly,
+ * application developers are saved from the hassles of encoding and decoding.
+ *
+ * <h4>Plus a modern API</h4>
+ *
+ * <p>The URL (JDK1.0) and URI (Java 1.4) classes predate builders and instead use telescoping
+ * constructors. For example, there's no API to compose a URI with a custom port without also
+ * providing a query and fragment.
+ *
+ * <p>Instances of {@link HttpUrl} are well-formed and always have a scheme, host, and path. With
+ * {@code java.net.URL} it's possible to create an awkward URL like {@code http:/} with scheme and
+ * path but no hostname. Building APIs that consume such malformed values is difficult!
+ *
+ * <p>This class has a modern API. It avoids punitive checked exceptions: {@link #parse parse()}
+ * returns null if the input is an invalid URL. You can even be explicit about whether each
+ * component has been encoded already.
+ */
+public final class HttpUrl {
+  private static final char[] HEX_DIGITS =
+      {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
+  static final String USERNAME_ENCODE_SET = " \"':;<=>@[]^`{}|/\\?#";
+  static final String PASSWORD_ENCODE_SET = " \"':;<=>@[]^`{}|/\\?#";
+  static final String PATH_SEGMENT_ENCODE_SET = " \"<>^`{}|/\\?#";
+  static final String PATH_SEGMENT_ENCODE_SET_URI = "[]";
+  static final String QUERY_ENCODE_SET = " \"'<>#";
+  static final String QUERY_COMPONENT_ENCODE_SET = " \"'<>#&=";
+  static final String QUERY_COMPONENT_ENCODE_SET_URI = "\\^`{|}";
+  static final String FORM_ENCODE_SET = " \"':;<=>@[]^`{}|/\\?#&!$(),~";
+  static final String FRAGMENT_ENCODE_SET = "";
+  static final String FRAGMENT_ENCODE_SET_URI = " \"#<>\\^`{|}";
+
+  /** Either "http" or "https". */
+  private final String scheme;
+
+  /** Decoded username. */
+  private final String username;
+
+  /** Decoded password. */
+  private final String password;
+
+  /** Canonical hostname. */
+  private final String host;
+
+  /** Either 80, 443 or a user-specified port. In range [1..65535]. */
+  private final int port;
+
+  /**
+   * A list of canonical path segments. This list always contains at least one element, which may be
+   * the empty string. Each segment is formatted with a leading '/', so if path segments were ["a",
+   * "b", ""], then the encoded path would be "/a/b/".
+   */
+  private final List<String> pathSegments;
+
+  /**
+   * Alternating, decoded query names and values, or null for no query. Names may be empty or
+   * non-empty, but never null. Values are null if the name has no corresponding '=' separator, or
+   * empty, or non-empty.
+   */
+  private final List<String> queryNamesAndValues;
+
+  /** Decoded fragment. */
+  private final String fragment;
+
+  /** Canonical URL. */
+  private final String url;
+
+  private HttpUrl(Builder builder) {
+    this.scheme = builder.scheme;
+    this.username = percentDecode(builder.encodedUsername, false);
+    this.password = percentDecode(builder.encodedPassword, false);
+    this.host = builder.host;
+    this.port = builder.effectivePort();
+    this.pathSegments = percentDecode(builder.encodedPathSegments, false);
+    this.queryNamesAndValues = builder.encodedQueryNamesAndValues != null
+        ? percentDecode(builder.encodedQueryNamesAndValues, true)
+        : null;
+    this.fragment = builder.encodedFragment != null
+        ? percentDecode(builder.encodedFragment, false)
+        : null;
+    this.url = builder.toString();
+  }
+
+  /** Returns this URL as a {@link URL java.net.URL}. */
+  public URL url() {
+    try {
+      return new URL(url);
+    } catch (MalformedURLException e) {
+      throw new RuntimeException(e); // Unexpected!
+    }
+  }
+
+  /**
+   * Returns this URL as a {@link URI java.net.URI}. Because {@code URI} is more strict than this
+   * class, the returned URI may be semantically different from this URL:
+   *
+   * <ul>
+   *     <li>Characters forbidden by URI like {@code [} and {@code |} will be escaped.
+   *     <li>Invalid percent-encoded sequences like {@code %xx} will be encoded like {@code %25xx}.
+   *     <li>Whitespace and control characters in the fragment will be stripped.
+   * </ul>
+   *
+   * <p>These differences may have a significant consequence when the URI is interpretted by a
+   * webserver. For this reason the {@linkplain URI URI class} and this method should be avoided.
+   */
+  public URI uri() {
+    String uri = newBuilder().reencodeForUri().toString();
+    try {
+      return new URI(uri);
+    } catch (URISyntaxException e) {
+      // Unlikely edge case: the URI has a forbidden character in the fragment. Strip it & retry.
+      try {
+        String stripped = uri.replaceAll("[\\u0000-\\u001F\\u007F-\\u009F\\p{javaWhitespace}]", "");
+        return URI.create(stripped);
+      } catch (Exception e1) {
+        throw new RuntimeException(e); // Unexpected!
+      }
+    }
+  }
+
+  /** Returns either "http" or "https". */
+  public String scheme() {
+    return scheme;
+  }
+
+  public boolean isHttps() {
+    return scheme.equals("https");
+  }
+
+  /** Returns the username, or an empty string if none is set. */
+  public String encodedUsername() {
+    if (username.isEmpty()) return "";
+    int usernameStart = scheme.length() + 3; // "://".length() == 3.
+    int usernameEnd = delimiterOffset(url, usernameStart, url.length(), ":@");
+    return url.substring(usernameStart, usernameEnd);
+  }
+
+  public String username() {
+    return username;
+  }
+
+  /** Returns the password, or an empty string if none is set. */
+  public String encodedPassword() {
+    if (password.isEmpty()) return "";
+    int passwordStart = url.indexOf(':', scheme.length() + 3) + 1;
+    int passwordEnd = url.indexOf('@');
+    return url.substring(passwordStart, passwordEnd);
+  }
+
+  /** Returns the decoded password, or an empty string if none is present. */
+  public String password() {
+    return password;
+  }
+
+  /**
+   * Returns the host address suitable for use with {@link InetAddress#getAllByName(String)}. May
+   * be:
+   *
+   * <ul>
+   *   <li>A regular host name, like {@code android.com}.
+   *   <li>An IPv4 address, like {@code 127.0.0.1}.
+   *   <li>An IPv6 address, like {@code ::1}. Note that there are no square braces.
+   *   <li>An encoded IDN, like {@code xn--n3h.net}.
+   * </ul>
+   */
+  public String host() {
+    return host;
+  }
+
+  /**
+   * Returns the explicitly-specified port if one was provided, or the default port for this URL's
+   * scheme. For example, this returns 8443 for {@code https://square.com:8443/} and 443 for {@code
+   * https://square.com/}. The result is in {@code [1..65535]}.
+   */
+  public int port() {
+    return port;
+  }
+
+  /**
+   * Returns 80 if {@code scheme.equals("http")}, 443 if {@code scheme.equals("https")} and -1
+   * otherwise.
+   */
+  public static int defaultPort(String scheme) {
+    if (scheme.equals("http")) {
+      return 80;
+    } else if (scheme.equals("https")) {
+      return 443;
+    } else {
+      return -1;
+    }
+  }
+
+  public int pathSize() {
+    return pathSegments.size();
+  }
+
+  /**
+   * Returns the entire path of this URL, encoded for use in HTTP resource resolution. The returned
+   * path is always nonempty and is prefixed with {@code /}.
+   */
+  public String encodedPath() {
+    int pathStart = url.indexOf('/', scheme.length() + 3); // "://".length() == 3.
+    int pathEnd = delimiterOffset(url, pathStart, url.length(), "?#");
+    return url.substring(pathStart, pathEnd);
+  }
+
+  static void pathSegmentsToString(StringBuilder out, List<String> pathSegments) {
+    for (int i = 0, size = pathSegments.size(); i < size; i++) {
+      out.append('/');
+      out.append(pathSegments.get(i));
+    }
+  }
+
+  public List<String> encodedPathSegments() {
+    int pathStart = url.indexOf('/', scheme.length() + 3);
+    int pathEnd = delimiterOffset(url, pathStart, url.length(), "?#");
+    List<String> result = new ArrayList<>();
+    for (int i = pathStart; i < pathEnd; ) {
+      i++; // Skip the '/'.
+      int segmentEnd = delimiterOffset(url, i, pathEnd, '/');
+      result.add(url.substring(i, segmentEnd));
+      i = segmentEnd;
+    }
+    return result;
+  }
+
+  public List<String> pathSegments() {
+    return pathSegments;
+  }
+
+  /**
+   * Returns the query of this URL, encoded for use in HTTP resource resolution. The returned string
+   * may be null (for URLs with no query), empty (for URLs with an empty query) or non-empty (all
+   * other URLs).
+   */
+  public String encodedQuery() {
+    if (queryNamesAndValues == null) return null; // No query.
+    int queryStart = url.indexOf('?') + 1;
+    int queryEnd = delimiterOffset(url, queryStart + 1, url.length(), '#');
+    return url.substring(queryStart, queryEnd);
+  }
+
+  static void namesAndValuesToQueryString(StringBuilder out, List<String> namesAndValues) {
+    for (int i = 0, size = namesAndValues.size(); i < size; i += 2) {
+      String name = namesAndValues.get(i);
+      String value = namesAndValues.get(i + 1);
+      if (i > 0) out.append('&');
+      out.append(name);
+      if (value != null) {
+        out.append('=');
+        out.append(value);
+      }
+    }
+  }
+
+  /**
+   * Cuts {@code encodedQuery} up into alternating parameter names and values. This divides a query
+   * string like {@code subject=math&easy&problem=5-2=3} into the list {@code ["subject", "math",
+   * "easy", null, "problem", "5-2=3"]}. Note that values may be null and may contain '='
+   * characters.
+   */
+  static List<String> queryStringToNamesAndValues(String encodedQuery) {
+    List<String> result = new ArrayList<>();
+    for (int pos = 0; pos <= encodedQuery.length(); ) {
+      int ampersandOffset = encodedQuery.indexOf('&', pos);
+      if (ampersandOffset == -1) ampersandOffset = encodedQuery.length();
+
+      int equalsOffset = encodedQuery.indexOf('=', pos);
+      if (equalsOffset == -1 || equalsOffset > ampersandOffset) {
+        result.add(encodedQuery.substring(pos, ampersandOffset));
+        result.add(null); // No value for this name.
+      } else {
+        result.add(encodedQuery.substring(pos, equalsOffset));
+        result.add(encodedQuery.substring(equalsOffset + 1, ampersandOffset));
+      }
+      pos = ampersandOffset + 1;
+    }
+    return result;
+  }
+
+  public String query() {
+    if (queryNamesAndValues == null) return null; // No query.
+    StringBuilder result = new StringBuilder();
+    namesAndValuesToQueryString(result, queryNamesAndValues);
+    return result.toString();
+  }
+
+  public int querySize() {
+    return queryNamesAndValues != null ? queryNamesAndValues.size() / 2 : 0;
+  }
+
+  /**
+   * Returns the first query parameter named {@code name} decoded using UTF-8, or null if there is
+   * no such query parameter.
+   */
+  public String queryParameter(String name) {
+    if (queryNamesAndValues == null) return null;
+    for (int i = 0, size = queryNamesAndValues.size(); i < size; i += 2) {
+      if (name.equals(queryNamesAndValues.get(i))) {
+        return queryNamesAndValues.get(i + 1);
+      }
+    }
+    return null;
+  }
+
+  public Set<String> queryParameterNames() {
+    if (queryNamesAndValues == null) return Collections.emptySet();
+    Set<String> result = new LinkedHashSet<>();
+    for (int i = 0, size = queryNamesAndValues.size(); i < size; i += 2) {
+      result.add(queryNamesAndValues.get(i));
+    }
+    return Collections.unmodifiableSet(result);
+  }
+
+  public List<String> queryParameterValues(String name) {
+    if (queryNamesAndValues == null) return Collections.emptyList();
+    List<String> result = new ArrayList<>();
+    for (int i = 0, size = queryNamesAndValues.size(); i < size; i += 2) {
+      if (name.equals(queryNamesAndValues.get(i))) {
+        result.add(queryNamesAndValues.get(i + 1));
+      }
+    }
+    return Collections.unmodifiableList(result);
+  }
+
+  public String queryParameterName(int index) {
+    return queryNamesAndValues.get(index * 2);
+  }
+
+  public String queryParameterValue(int index) {
+    return queryNamesAndValues.get(index * 2 + 1);
+  }
+
+  public String encodedFragment() {
+    if (fragment == null) return null;
+    int fragmentStart = url.indexOf('#') + 1;
+    return url.substring(fragmentStart);
+  }
+
+  public String fragment() {
+    return fragment;
+  }
+
+  /**
+   * Returns the URL that would be retrieved by following {@code link} from this URL, or null if
+   * the resulting URL is not well-formed.
+   */
+  public HttpUrl resolve(String link) {
+    Builder builder = newBuilder(link);
+    return builder != null ? builder.build() : null;
+  }
+
+  public Builder newBuilder() {
+    Builder result = new Builder();
+    result.scheme = scheme;
+    result.encodedUsername = encodedUsername();
+    result.encodedPassword = encodedPassword();
+    result.host = host;
+    // If we're set to a default port, unset it in case of a scheme change.
+    result.port = port != defaultPort(scheme) ? port : -1;
+    result.encodedPathSegments.clear();
+    result.encodedPathSegments.addAll(encodedPathSegments());
+    result.encodedQuery(encodedQuery());
+    result.encodedFragment = encodedFragment();
+    return result;
+  }
+
+  /**
+   * Returns a builder for the URL that would be retrieved by following {@code link} from this URL,
+   * or null if the resulting URL is not well-formed.
+   */
+  public Builder newBuilder(String link) {
+    Builder builder = new Builder();
+    Builder.ParseResult result = builder.parse(this, link);
+    return result == Builder.ParseResult.SUCCESS ? builder : null;
+  }
+
+  /**
+   * Returns a new {@code HttpUrl} representing {@code url} if it is a well-formed HTTP or HTTPS
+   * URL, or null if it isn't.
+   */
+  public static HttpUrl parse(String url) {
+    Builder builder = new Builder();
+    Builder.ParseResult result = builder.parse(null, url);
+    return result == Builder.ParseResult.SUCCESS ? builder.build() : null;
+  }
+
+  /**
+   * Returns an {@link HttpUrl} for {@code url} if its protocol is {@code http} or {@code https}, or
+   * null if it has any other protocol.
+   */
+  public static HttpUrl get(URL url) {
+    return parse(url.toString());
+  }
+
+  /**
+   * Returns a new {@code HttpUrl} representing {@code url} if it is a well-formed HTTP or HTTPS
+   * URL, or throws an exception if it isn't.
+   *
+   * @throws MalformedURLException if there was a non-host related URL issue
+   * @throws UnknownHostException if the host was invalid
+   */
+  static HttpUrl getChecked(String url) throws MalformedURLException, UnknownHostException {
+    Builder builder = new Builder();
+    Builder.ParseResult result = builder.parse(null, url);
+    switch (result) {
+      case SUCCESS:
+        return builder.build();
+      case INVALID_HOST:
+        throw new UnknownHostException("Invalid host: " + url);
+      case UNSUPPORTED_SCHEME:
+      case MISSING_SCHEME:
+      case INVALID_PORT:
+      default:
+        throw new MalformedURLException("Invalid URL: " + result + " for " + url);
+    }
+  }
+
+  public static HttpUrl get(URI uri) {
+    return parse(uri.toString());
+  }
+
+  @Override public boolean equals(Object o) {
+    return o instanceof HttpUrl && ((HttpUrl) o).url.equals(url);
+  }
+
+  @Override public int hashCode() {
+    return url.hashCode();
+  }
+
+  @Override public String toString() {
+    return url;
+  }
+
+  public static final class Builder {
+    String scheme;
+    String encodedUsername = "";
+    String encodedPassword = "";
+    String host;
+    int port = -1;
+    final List<String> encodedPathSegments = new ArrayList<>();
+    List<String> encodedQueryNamesAndValues;
+    String encodedFragment;
+
+    public Builder() {
+      encodedPathSegments.add(""); // The default path is '/' which needs a trailing space.
+    }
+
+    public Builder scheme(String scheme) {
+      if (scheme == null) {
+        throw new NullPointerException("scheme == null");
+      } else if (scheme.equalsIgnoreCase("http")) {
+        this.scheme = "http";
+      } else if (scheme.equalsIgnoreCase("https")) {
+        this.scheme = "https";
+      } else {
+        throw new IllegalArgumentException("unexpected scheme: " + scheme);
+      }
+      return this;
+    }
+
+    public Builder username(String username) {
+      if (username == null) throw new NullPointerException("username == null");
+      this.encodedUsername = canonicalize(username, USERNAME_ENCODE_SET, false, false, false, true);
+      return this;
+    }
+
+    public Builder encodedUsername(String encodedUsername) {
+      if (encodedUsername == null) throw new NullPointerException("encodedUsername == null");
+      this.encodedUsername = canonicalize(
+          encodedUsername, USERNAME_ENCODE_SET, true, false, false, true);
+      return this;
+    }
+
+    public Builder password(String password) {
+      if (password == null) throw new NullPointerException("password == null");
+      this.encodedPassword = canonicalize(password, PASSWORD_ENCODE_SET, false, false, false, true);
+      return this;
+    }
+
+    public Builder encodedPassword(String encodedPassword) {
+      if (encodedPassword == null) throw new NullPointerException("encodedPassword == null");
+      this.encodedPassword = canonicalize(
+          encodedPassword, PASSWORD_ENCODE_SET, true, false, false, true);
+      return this;
+    }
+
+    /**
+     * @param host either a regular hostname, International Domain Name, IPv4 address, or IPv6
+     * address.
+     */
+    public Builder host(String host) {
+      if (host == null) throw new NullPointerException("host == null");
+      String encoded = canonicalizeHost(host, 0, host.length());
+      if (encoded == null) throw new IllegalArgumentException("unexpected host: " + host);
+      this.host = encoded;
+      return this;
+    }
+
+    public Builder port(int port) {
+      if (port <= 0 || port > 65535) throw new IllegalArgumentException("unexpected port: " + port);
+      this.port = port;
+      return this;
+    }
+
+    int effectivePort() {
+      return port != -1 ? port : defaultPort(scheme);
+    }
+
+    public Builder addPathSegment(String pathSegment) {
+      if (pathSegment == null) throw new NullPointerException("pathSegment == null");
+      push(pathSegment, 0, pathSegment.length(), false, false);
+      return this;
+    }
+
+    /**
+     * Adds a set of path segments separated by a slash (either {@code \} or {@code /}). If
+     * {@code pathSegments} starts with a slash, the resulting URL will have empty path segment.
+     */
+    public Builder addPathSegments(String pathSegments) {
+      if (pathSegments == null) throw new NullPointerException("pathSegments == null");
+      return addPathSegments(pathSegments, false);
+    }
+
+    public Builder addEncodedPathSegment(String encodedPathSegment) {
+      if (encodedPathSegment == null) {
+        throw new NullPointerException("encodedPathSegment == null");
+      }
+      push(encodedPathSegment, 0, encodedPathSegment.length(), false, true);
+      return this;
+    }
+
+    /**
+     * Adds a set of encoded path segments separated by a slash (either {@code \} or {@code /}). If
+     * {@code encodedPathSegments} starts with a slash, the resulting URL will have empty path
+     * segment.
+     */
+    public Builder addEncodedPathSegments(String encodedPathSegments) {
+      if (encodedPathSegments == null) {
+        throw new NullPointerException("encodedPathSegments == null");
+      }
+      return addPathSegments(encodedPathSegments, true);
+    }
+
+    private Builder addPathSegments(String pathSegments, boolean alreadyEncoded) {
+      int offset = 0;
+      do {
+        int segmentEnd = delimiterOffset(pathSegments, offset, pathSegments.length(), "/\\");
+        boolean addTrailingSlash = segmentEnd < pathSegments.length();
+        push(pathSegments, offset, segmentEnd, addTrailingSlash, alreadyEncoded);
+        offset = segmentEnd + 1;
+      } while (offset <= pathSegments.length());
+      return this;
+    }
+
+    public Builder setPathSegment(int index, String pathSegment) {
+      if (pathSegment == null) throw new NullPointerException("pathSegment == null");
+      String canonicalPathSegment = canonicalize(
+          pathSegment, 0, pathSegment.length(), PATH_SEGMENT_ENCODE_SET, false, false, false, true);
+      if (isDot(canonicalPathSegment) || isDotDot(canonicalPathSegment)) {
+        throw new IllegalArgumentException("unexpected path segment: " + pathSegment);
+      }
+      encodedPathSegments.set(index, canonicalPathSegment);
+      return this;
+    }
+
+    public Builder setEncodedPathSegment(int index, String encodedPathSegment) {
+      if (encodedPathSegment == null) {
+        throw new NullPointerException("encodedPathSegment == null");
+      }
+      String canonicalPathSegment = canonicalize(encodedPathSegment,
+          0, encodedPathSegment.length(), PATH_SEGMENT_ENCODE_SET, true, false, false, true);
+      encodedPathSegments.set(index, canonicalPathSegment);
+      if (isDot(canonicalPathSegment) || isDotDot(canonicalPathSegment)) {
+        throw new IllegalArgumentException("unexpected path segment: " + encodedPathSegment);
+      }
+      return this;
+    }
+
+    public Builder removePathSegment(int index) {
+      encodedPathSegments.remove(index);
+      if (encodedPathSegments.isEmpty()) {
+        encodedPathSegments.add(""); // Always leave at least one '/'.
+      }
+      return this;
+    }
+
+    public Builder encodedPath(String encodedPath) {
+      if (encodedPath == null) throw new NullPointerException("encodedPath == null");
+      if (!encodedPath.startsWith("/")) {
+        throw new IllegalArgumentException("unexpected encodedPath: " + encodedPath);
+      }
+      resolvePath(encodedPath, 0, encodedPath.length());
+      return this;
+    }
+
+    public Builder query(String query) {
+      this.encodedQueryNamesAndValues = query != null
+          ? queryStringToNamesAndValues(canonicalize(
+          query, QUERY_ENCODE_SET, false, false, true, true))
+          : null;
+      return this;
+    }
+
+    public Builder encodedQuery(String encodedQuery) {
+      this.encodedQueryNamesAndValues = encodedQuery != null
+          ? queryStringToNamesAndValues(
+          canonicalize(encodedQuery, QUERY_ENCODE_SET, true, false, true, true))
+          : null;
+      return this;
+    }
+
+    /** Encodes the query parameter using UTF-8 and adds it to this URL's query string. */
+    public Builder addQueryParameter(String name, String value) {
+      if (name == null) throw new NullPointerException("name == null");
+      if (encodedQueryNamesAndValues == null) encodedQueryNamesAndValues = new ArrayList<>();
+      encodedQueryNamesAndValues.add(
+          canonicalize(name, QUERY_COMPONENT_ENCODE_SET, false, false, true, true));
+      encodedQueryNamesAndValues.add(value != null
+          ? canonicalize(value, QUERY_COMPONENT_ENCODE_SET, false, false, true, true)
+          : null);
+      return this;
+    }
+
+    /** Adds the pre-encoded query parameter to this URL's query string. */
+    public Builder addEncodedQueryParameter(String encodedName, String encodedValue) {
+      if (encodedName == null) throw new NullPointerException("encodedName == null");
+      if (encodedQueryNamesAndValues == null) encodedQueryNamesAndValues = new ArrayList<>();
+      encodedQueryNamesAndValues.add(
+          canonicalize(encodedName, QUERY_COMPONENT_ENCODE_SET, true, false, true, true));
+      encodedQueryNamesAndValues.add(encodedValue != null
+          ? canonicalize(encodedValue, QUERY_COMPONENT_ENCODE_SET, true, false, true, true)
+          : null);
+      return this;
+    }
+
+    public Builder setQueryParameter(String name, String value) {
+      removeAllQueryParameters(name);
+      addQueryParameter(name, value);
+      return this;
+    }
+
+    public Builder setEncodedQueryParameter(String encodedName, String encodedValue) {
+      removeAllEncodedQueryParameters(encodedName);
+      addEncodedQueryParameter(encodedName, encodedValue);
+      return this;
+    }
+
+    public Builder removeAllQueryParameters(String name) {
+      if (name == null) throw new NullPointerException("name == null");
+      if (encodedQueryNamesAndValues == null) return this;
+      String nameToRemove = canonicalize(
+          name, QUERY_COMPONENT_ENCODE_SET, false, false, true, true);
+      removeAllCanonicalQueryParameters(nameToRemove);
+      return this;
+    }
+
+    public Builder removeAllEncodedQueryParameters(String encodedName) {
+      if (encodedName == null) throw new NullPointerException("encodedName == null");
+      if (encodedQueryNamesAndValues == null) return this;
+      removeAllCanonicalQueryParameters(
+          canonicalize(encodedName, QUERY_COMPONENT_ENCODE_SET, true, false, true, true));
+      return this;
+    }
+
+    private void removeAllCanonicalQueryParameters(String canonicalName) {
+      for (int i = encodedQueryNamesAndValues.size() - 2; i >= 0; i -= 2) {
+        if (canonicalName.equals(encodedQueryNamesAndValues.get(i))) {
+          encodedQueryNamesAndValues.remove(i + 1);
+          encodedQueryNamesAndValues.remove(i);
+          if (encodedQueryNamesAndValues.isEmpty()) {
+            encodedQueryNamesAndValues = null;
+            return;
+          }
+        }
+      }
+    }
+
+    public Builder fragment(String fragment) {
+      this.encodedFragment = fragment != null
+          ? canonicalize(fragment, FRAGMENT_ENCODE_SET, false, false, false, false)
+          : null;
+      return this;
+    }
+
+    public Builder encodedFragment(String encodedFragment) {
+      this.encodedFragment = encodedFragment != null
+          ? canonicalize(encodedFragment, FRAGMENT_ENCODE_SET, true, false, false, false)
+          : null;
+      return this;
+    }
+
+    /**
+     * Re-encodes the components of this URL so that it satisfies (obsolete) RFC 2396, which is
+     * particularly strict for certain components.
+     */
+    Builder reencodeForUri() {
+      for (int i = 0, size = encodedPathSegments.size(); i < size; i++) {
+        String pathSegment = encodedPathSegments.get(i);
+        encodedPathSegments.set(i,
+            canonicalize(pathSegment, PATH_SEGMENT_ENCODE_SET_URI, true, true, false, true));
+      }
+      if (encodedQueryNamesAndValues != null) {
+        for (int i = 0, size = encodedQueryNamesAndValues.size(); i < size; i++) {
+          String component = encodedQueryNamesAndValues.get(i);
+          if (component != null) {
+            encodedQueryNamesAndValues.set(i,
+                canonicalize(component, QUERY_COMPONENT_ENCODE_SET_URI, true, true, true, true));
+          }
+        }
+      }
+      if (encodedFragment != null) {
+        encodedFragment = canonicalize(
+            encodedFragment, FRAGMENT_ENCODE_SET_URI, true, true, false, false);
+      }
+      return this;
+    }
+
+    public HttpUrl build() {
+      if (scheme == null) throw new IllegalStateException("scheme == null");
+      if (host == null) throw new IllegalStateException("host == null");
+      return new HttpUrl(this);
+    }
+
+    @Override public String toString() {
+      StringBuilder result = new StringBuilder();
+      result.append(scheme);
+      result.append("://");
+
+      if (!encodedUsername.isEmpty() || !encodedPassword.isEmpty()) {
+        result.append(encodedUsername);
+        if (!encodedPassword.isEmpty()) {
+          result.append(':');
+          result.append(encodedPassword);
+        }
+        result.append('@');
+      }
+
+      if (host.indexOf(':') != -1) {
+        // Host is an IPv6 address.
+        result.append('[');
+        result.append(host);
+        result.append(']');
+      } else {
+        result.append(host);
+      }
+
+      int effectivePort = effectivePort();
+      if (effectivePort != defaultPort(scheme)) {
+        result.append(':');
+        result.append(effectivePort);
+      }
+
+      pathSegmentsToString(result, encodedPathSegments);
+
+      if (encodedQueryNamesAndValues != null) {
+        result.append('?');
+        namesAndValuesToQueryString(result, encodedQueryNamesAndValues);
+      }
+
+      if (encodedFragment != null) {
+        result.append('#');
+        result.append(encodedFragment);
+      }
+
+      return result.toString();
+    }
+
+    enum ParseResult {
+      SUCCESS,
+      MISSING_SCHEME,
+      UNSUPPORTED_SCHEME,
+      INVALID_PORT,
+      INVALID_HOST,
+    }
+
+    ParseResult parse(HttpUrl base, String input) {
+      int pos = skipLeadingAsciiWhitespace(input, 0, input.length());
+      int limit = skipTrailingAsciiWhitespace(input, pos, input.length());
+
+      // Scheme.
+      int schemeDelimiterOffset = schemeDelimiterOffset(input, pos, limit);
+      if (schemeDelimiterOffset != -1) {
+        if (input.regionMatches(true, pos, "https:", 0, 6)) {
+          this.scheme = "https";
+          pos += "https:".length();
+        } else if (input.regionMatches(true, pos, "http:", 0, 5)) {
+          this.scheme = "http";
+          pos += "http:".length();
+        } else {
+          return ParseResult.UNSUPPORTED_SCHEME; // Not an HTTP scheme.
+        }
+      } else if (base != null) {
+        this.scheme = base.scheme;
+      } else {
+        return ParseResult.MISSING_SCHEME; // No scheme.
+      }
+
+      // Authority.
+      boolean hasUsername = false;
+      boolean hasPassword = false;
+      int slashCount = slashCount(input, pos, limit);
+      if (slashCount >= 2 || base == null || !base.scheme.equals(this.scheme)) {
+        // Read an authority if either:
+        //  * The input starts with 2 or more slashes. These follow the scheme if it exists.
+        //  * The input scheme exists and is different from the base URL's scheme.
+        //
+        // The structure of an authority is:
+        //   username:password@host:port
+        //
+        // Username, password and port are optional.
+        //   [username[:password]@]host[:port]
+        pos += slashCount;
+        authority:
+        while (true) {
+          int componentDelimiterOffset = delimiterOffset(input, pos, limit, "@/\\?#");
+          int c = componentDelimiterOffset != limit
+              ? input.charAt(componentDelimiterOffset)
+              : -1;
+          switch (c) {
+            case '@':
+              // User info precedes.
+              if (!hasPassword) {
+                int passwordColonOffset = delimiterOffset(
+                    input, pos, componentDelimiterOffset, ':');
+                String canonicalUsername = canonicalize(
+                    input, pos, passwordColonOffset, USERNAME_ENCODE_SET, true, false, false, true);
+                this.encodedUsername = hasUsername
+                    ? this.encodedUsername + "%40" + canonicalUsername
+                    : canonicalUsername;
+                if (passwordColonOffset != componentDelimiterOffset) {
+                  hasPassword = true;
+                  this.encodedPassword = canonicalize(input, passwordColonOffset + 1,
+                      componentDelimiterOffset, PASSWORD_ENCODE_SET, true, false, false, true);
+                }
+                hasUsername = true;
+              } else {
+                this.encodedPassword = this.encodedPassword + "%40" + canonicalize(input, pos,
+                    componentDelimiterOffset, PASSWORD_ENCODE_SET, true, false, false, true);
+              }
+              pos = componentDelimiterOffset + 1;
+              break;
+
+            case -1:
+            case '/':
+            case '\\':
+            case '?':
+            case '#':
+              // Host info precedes.
+              int portColonOffset = portColonOffset(input, pos, componentDelimiterOffset);
+              if (portColonOffset + 1 < componentDelimiterOffset) {
+                this.host = canonicalizeHost(input, pos, portColonOffset);
+                this.port = parsePort(input, portColonOffset + 1, componentDelimiterOffset);
+                if (this.port == -1) return ParseResult.INVALID_PORT; // Invalid port.
+              } else {
+                this.host = canonicalizeHost(input, pos, portColonOffset);
+                this.port = defaultPort(this.scheme);
+              }
+              if (this.host == null) return ParseResult.INVALID_HOST; // Invalid host.
+              pos = componentDelimiterOffset;
+              break authority;
+          }
+        }
+      } else {
+        // This is a relative link. Copy over all authority components. Also maybe the path & query.
+        this.encodedUsername = base.encodedUsername();
+        this.encodedPassword = base.encodedPassword();
+        this.host = base.host;
+        this.port = base.port;
+        this.encodedPathSegments.clear();
+        this.encodedPathSegments.addAll(base.encodedPathSegments());
+        if (pos == limit || input.charAt(pos) == '#') {
+          encodedQuery(base.encodedQuery());
+        }
+      }
+
+      // Resolve the relative path.
+      int pathDelimiterOffset = delimiterOffset(input, pos, limit, "?#");
+      resolvePath(input, pos, pathDelimiterOffset);
+      pos = pathDelimiterOffset;
+
+      // Query.
+      if (pos < limit && input.charAt(pos) == '?') {
+        int queryDelimiterOffset = delimiterOffset(input, pos, limit, '#');
+        this.encodedQueryNamesAndValues = queryStringToNamesAndValues(canonicalize(
+            input, pos + 1, queryDelimiterOffset, QUERY_ENCODE_SET, true, false, true, true));
+        pos = queryDelimiterOffset;
+      }
+
+      // Fragment.
+      if (pos < limit && input.charAt(pos) == '#') {
+        this.encodedFragment = canonicalize(
+            input, pos + 1, limit, FRAGMENT_ENCODE_SET, true, false, false, false);
+      }
+
+      return ParseResult.SUCCESS;
+    }
+
+    private void resolvePath(String input, int pos, int limit) {
+      // Read a delimiter.
+      if (pos == limit) {
+        // Empty path: keep the base path as-is.
+        return;
+      }
+      char c = input.charAt(pos);
+      if (c == '/' || c == '\\') {
+        // Absolute path: reset to the default "/".
+        encodedPathSegments.clear();
+        encodedPathSegments.add("");
+        pos++;
+      } else {
+        // Relative path: clear everything after the last '/'.
+        encodedPathSegments.set(encodedPathSegments.size() - 1, "");
+      }
+
+      // Read path segments.
+      for (int i = pos; i < limit; ) {
+        int pathSegmentDelimiterOffset = delimiterOffset(input, i, limit, "/\\");
+        boolean segmentHasTrailingSlash = pathSegmentDelimiterOffset < limit;
+        push(input, i, pathSegmentDelimiterOffset, segmentHasTrailingSlash, true);
+        i = pathSegmentDelimiterOffset;
+        if (segmentHasTrailingSlash) i++;
+      }
+    }
+
+    /** Adds a path segment. If the input is ".." or equivalent, this pops a path segment. */
+    private void push(String input, int pos, int limit, boolean addTrailingSlash,
+        boolean alreadyEncoded) {
+      String segment = canonicalize(
+          input, pos, limit, PATH_SEGMENT_ENCODE_SET, alreadyEncoded, false, false, true);
+      if (isDot(segment)) {
+        return; // Skip '.' path segments.
+      }
+      if (isDotDot(segment)) {
+        pop();
+        return;
+      }
+      if (encodedPathSegments.get(encodedPathSegments.size() - 1).isEmpty()) {
+        encodedPathSegments.set(encodedPathSegments.size() - 1, segment);
+      } else {
+        encodedPathSegments.add(segment);
+      }
+      if (addTrailingSlash) {
+        encodedPathSegments.add("");
+      }
+    }
+
+    private boolean isDot(String input) {
+      return input.equals(".") || input.equalsIgnoreCase("%2e");
+    }
+
+    private boolean isDotDot(String input) {
+      return input.equals("..")
+          || input.equalsIgnoreCase("%2e.")
+          || input.equalsIgnoreCase(".%2e")
+          || input.equalsIgnoreCase("%2e%2e");
+    }
+
+    /**
+     * Removes a path segment. When this method returns the last segment is always "", which means
+     * the encoded path will have a trailing '/'.
+     *
+     * <p>Popping "/a/b/c/" yields "/a/b/". In this case the list of path segments goes from ["a",
+     * "b", "c", ""] to ["a", "b", ""].
+     *
+     * <p>Popping "/a/b/c" also yields "/a/b/". The list of path segments goes from ["a", "b", "c"]
+     * to ["a", "b", ""].
+     */
+    private void pop() {
+      String removed = encodedPathSegments.remove(encodedPathSegments.size() - 1);
+
+      // Make sure the path ends with a '/' by either adding an empty string or clearing a segment.
+      if (removed.isEmpty() && !encodedPathSegments.isEmpty()) {
+        encodedPathSegments.set(encodedPathSegments.size() - 1, "");
+      } else {
+        encodedPathSegments.add("");
+      }
+    }
+
+    /**
+     * Returns the index of the ':' in {@code input} that is after scheme characters. Returns -1 if
+     * {@code input} does not have a scheme that starts at {@code pos}.
+     */
+    private static int schemeDelimiterOffset(String input, int pos, int limit) {
+      if (limit - pos < 2) return -1;
+
+      char c0 = input.charAt(pos);
+      if ((c0 < 'a' || c0 > 'z') && (c0 < 'A' || c0 > 'Z')) return -1; // Not a scheme start char.
+
+      for (int i = pos + 1; i < limit; i++) {
+        char c = input.charAt(i);
+
+        if ((c >= 'a' && c <= 'z')
+            || (c >= 'A' && c <= 'Z')
+            || (c >= '0' && c <= '9')
+            || c == '+'
+            || c == '-'
+            || c == '.') {
+          continue; // Scheme character. Keep going.
+        } else if (c == ':') {
+          return i; // Scheme prefix!
+        } else {
+          return -1; // Non-scheme character before the first ':'.
+        }
+      }
+
+      return -1; // No ':'; doesn't start with a scheme.
+    }
+
+    /** Returns the number of '/' and '\' slashes in {@code input}, starting at {@code pos}. */
+    private static int slashCount(String input, int pos, int limit) {
+      int slashCount = 0;
+      while (pos < limit) {
+        char c = input.charAt(pos);
+        if (c == '\\' || c == '/') {
+          slashCount++;
+          pos++;
+        } else {
+          break;
+        }
+      }
+      return slashCount;
+    }
+
+    /** Finds the first ':' in {@code input}, skipping characters between square braces "[...]". */
+    private static int portColonOffset(String input, int pos, int limit) {
+      for (int i = pos; i < limit; i++) {
+        switch (input.charAt(i)) {
+          case '[':
+            while (++i < limit) {
+              if (input.charAt(i) == ']') break;
+            }
+            break;
+          case ':':
+            return i;
+        }
+      }
+      return limit; // No colon.
+    }
+
+    private static String canonicalizeHost(String input, int pos, int limit) {
+      // Start by percent decoding the host. The WHATWG spec suggests doing this only after we've
+      // checked for IPv6 square braces. But Chrome does it first, and that's more lenient.
+      String percentDecoded = percentDecode(input, pos, limit, false);
+
+      // If the input contains a :, it’s an IPv6 address.
+      if (percentDecoded.contains(":")) {
+        // If the input is encased in square braces "[...]", drop 'em.
+        InetAddress inetAddress = percentDecoded.startsWith("[") && percentDecoded.endsWith("]")
+            ? decodeIpv6(percentDecoded, 1, percentDecoded.length() - 1)
+            : decodeIpv6(percentDecoded, 0, percentDecoded.length());
+        if (inetAddress == null) return null;
+        byte[] address = inetAddress.getAddress();
+        if (address.length == 16) return inet6AddressToAscii(address);
+        throw new AssertionError();
+      }
+
+      return domainToAscii(percentDecoded);
+    }
+
+    /** Decodes an IPv6 address like 1111:2222:3333:4444:5555:6666:7777:8888 or ::1. */
+    private static InetAddress decodeIpv6(String input, int pos, int limit) {
+      byte[] address = new byte[16];
+      int b = 0;
+      int compress = -1;
+      int groupOffset = -1;
+
+      for (int i = pos; i < limit; ) {
+        if (b == address.length) return null; // Too many groups.
+
+        // Read a delimiter.
+        if (i + 2 <= limit && input.regionMatches(i, "::", 0, 2)) {
+          // Compression "::" delimiter, which is anywhere in the input, including its prefix.
+          if (compress != -1) return null; // Multiple "::" delimiters.
+          i += 2;
+          b += 2;
+          compress = b;
+          if (i == limit) break;
+        } else if (b != 0) {
+          // Group separator ":" delimiter.
+          if (input.regionMatches(i, ":", 0, 1)) {
+            i++;
+          } else if (input.regionMatches(i, ".", 0, 1)) {
+            // If we see a '.', rewind to the beginning of the previous group and parse as IPv4.
+            if (!decodeIpv4Suffix(input, groupOffset, limit, address, b - 2)) return null;
+            b += 2; // We rewound two bytes and then added four.
+            break;
+          } else {
+            return null; // Wrong delimiter.
+          }
+        }
+
+        // Read a group, one to four hex digits.
+        int value = 0;
+        groupOffset = i;
+        for (; i < limit; i++) {
+          char c = input.charAt(i);
+          int hexDigit = decodeHexDigit(c);
+          if (hexDigit == -1) break;
+          value = (value << 4) + hexDigit;
+        }
+        int groupLength = i - groupOffset;
+        if (groupLength == 0 || groupLength > 4) return null; // Group is the wrong size.
+
+        // We've successfully read a group. Assign its value to our byte array.
+        address[b++] = (byte) ((value >>> 8) & 0xff);
+        address[b++] = (byte) (value & 0xff);
+      }
+
+      // All done. If compression happened, we need to move bytes to the right place in the
+      // address. Here's a sample:
+      //
+      //      input: "1111:2222:3333::7777:8888"
+      //     before: { 11, 11, 22, 22, 33, 33, 00, 00, 77, 77, 88, 88, 00, 00, 00, 00  }
+      //   compress: 6
+      //          b: 10
+      //      after: { 11, 11, 22, 22, 33, 33, 00, 00, 00, 00, 00, 00, 77, 77, 88, 88 }
+      //
+      if (b != address.length) {
+        if (compress == -1) return null; // Address didn't have compression or enough groups.
+        System.arraycopy(address, compress, address, address.length - (b - compress), b - compress);
+        Arrays.fill(address, compress, compress + (address.length - b), (byte) 0);
+      }
+
+      try {
+        return InetAddress.getByAddress(address);
+      } catch (UnknownHostException e) {
+        throw new AssertionError();
+      }
+    }
+
+    /** Decodes an IPv4 address suffix of an IPv6 address, like 1111::5555:6666:192.168.0.1. */
+    private static boolean decodeIpv4Suffix(
+        String input, int pos, int limit, byte[] address, int addressOffset) {
+      int b = addressOffset;
+
+      for (int i = pos; i < limit; ) {
+        if (b == address.length) return false; // Too many groups.
+
+        // Read a delimiter.
+        if (b != addressOffset) {
+          if (input.charAt(i) != '.') return false; // Wrong delimiter.
+          i++;
+        }
+
+        // Read 1 or more decimal digits for a value in 0..255.
+        int value = 0;
+        int groupOffset = i;
+        for (; i < limit; i++) {
+          char c = input.charAt(i);
+          if (c < '0' || c > '9') break;
+          if (value == 0 && groupOffset != i) return false; // Reject unnecessary leading '0's.
+          value = (value * 10) + c - '0';
+          if (value > 255) return false; // Value out of range.
+        }
+        int groupLength = i - groupOffset;
+        if (groupLength == 0) return false; // No digits.
+
+        // We've successfully read a byte.
+        address[b++] = (byte) value;
+      }
+
+      if (b != addressOffset + 4) return false; // Too few groups. We wanted exactly four.
+      return true; // Success.
+    }
+
+    private static String inet6AddressToAscii(byte[] address) {
+      // Go through the address looking for the longest run of 0s. Each group is 2-bytes.
+      int longestRunOffset = -1;
+      int longestRunLength = 0;
+      for (int i = 0; i < address.length; i += 2) {
+        int currentRunOffset = i;
+        while (i < 16 && address[i] == 0 && address[i + 1] == 0) {
+          i += 2;
+        }
+        int currentRunLength = i - currentRunOffset;
+        if (currentRunLength > longestRunLength) {
+          longestRunOffset = currentRunOffset;
+          longestRunLength = currentRunLength;
+        }
+      }
+
+      // Emit each 2-byte group in hex, separated by ':'. The longest run of zeroes is "::".
+      Buffer result = new Buffer();
+      for (int i = 0; i < address.length; ) {
+        if (i == longestRunOffset) {
+          result.writeByte(':');
+          i += longestRunLength;
+          if (i == 16) result.writeByte(':');
+        } else {
+          if (i > 0) result.writeByte(':');
+          int group = (address[i] & 0xff) << 8 | address[i + 1] & 0xff;
+          result.writeHexadecimalUnsignedLong(group);
+          i += 2;
+        }
+      }
+      return result.readUtf8();
+    }
+
+    private static int parsePort(String input, int pos, int limit) {
+      try {
+        // Canonicalize the port string to skip '\n' etc.
+        String portString = canonicalize(input, pos, limit, "", false, false, false, true);
+        int i = Integer.parseInt(portString);
+        if (i > 0 && i <= 65535) return i;
+        return -1;
+      } catch (NumberFormatException e) {
+        return -1; // Invalid port.
+      }
+    }
+  }
+
+  static String percentDecode(String encoded, boolean plusIsSpace) {
+    return percentDecode(encoded, 0, encoded.length(), plusIsSpace);
+  }
+
+  private List<String> percentDecode(List<String> list, boolean plusIsSpace) {
+    List<String> result = new ArrayList<>(list.size());
+    for (String s : list) {
+      result.add(s != null ? percentDecode(s, plusIsSpace) : null);
+    }
+    return Collections.unmodifiableList(result);
+  }
+
+  static String percentDecode(String encoded, int pos, int limit, boolean plusIsSpace) {
+    for (int i = pos; i < limit; i++) {
+      char c = encoded.charAt(i);
+      if (c == '%' || (c == '+' && plusIsSpace)) {
+        // Slow path: the character at i requires decoding!
+        Buffer out = new Buffer();
+        out.writeUtf8(encoded, pos, i);
+        percentDecode(out, encoded, i, limit, plusIsSpace);
+        return out.readUtf8();
+      }
+    }
+
+    // Fast path: no characters in [pos..limit) required decoding.
+    return encoded.substring(pos, limit);
+  }
+
+  static void percentDecode(Buffer out, String encoded, int pos, int limit, boolean plusIsSpace) {
+    int codePoint;
+    for (int i = pos; i < limit; i += Character.charCount(codePoint)) {
+      codePoint = encoded.codePointAt(i);
+      if (codePoint == '%' && i + 2 < limit) {
+        int d1 = decodeHexDigit(encoded.charAt(i + 1));
+        int d2 = decodeHexDigit(encoded.charAt(i + 2));
+        if (d1 != -1 && d2 != -1) {
+          out.writeByte((d1 << 4) + d2);
+          i += 2;
+          continue;
+        }
+      } else if (codePoint == '+' && plusIsSpace) {
+        out.writeByte(' ');
+        continue;
+      }
+      out.writeUtf8CodePoint(codePoint);
+    }
+  }
+
+  static boolean percentEncoded(String encoded, int pos, int limit) {
+    return pos + 2 < limit
+        && encoded.charAt(pos) == '%'
+        && decodeHexDigit(encoded.charAt(pos + 1)) != -1
+        && decodeHexDigit(encoded.charAt(pos + 2)) != -1;
+  }
+
+  static int decodeHexDigit(char c) {
+    if (c >= '0' && c <= '9') return c - '0';
+    if (c >= 'a' && c <= 'f') return c - 'a' + 10;
+    if (c >= 'A' && c <= 'F') return c - 'A' + 10;
+    return -1;
+  }
+
+  /**
+   * Returns a substring of {@code input} on the range {@code [pos..limit)} with the following
+   * transformations:
+   * <ul>
+   *   <li>Tabs, newlines, form feeds and carriage returns are skipped.
+   *   <li>In queries, ' ' is encoded to '+' and '+' is encoded to "%2B".
+   *   <li>Characters in {@code encodeSet} are percent-encoded.
+   *   <li>Control characters and non-ASCII characters are percent-encoded.
+   *   <li>All other characters are copied without transformation.
+   * </ul>
+   *
+   * @param alreadyEncoded true to leave '%' as-is; false to convert it to '%25'.
+   * @param strict true to encode '%' if it is not the prefix of a valid percent encoding.
+   * @param plusIsSpace true to encode '+' as "%2B" if it is not already encoded.
+   * @param asciiOnly true to encode all non-ASCII codepoints.
+   */
+  static String canonicalize(String input, int pos, int limit, String encodeSet,
+      boolean alreadyEncoded, boolean strict, boolean plusIsSpace, boolean asciiOnly) {
+    int codePoint;
+    for (int i = pos; i < limit; i += Character.charCount(codePoint)) {
+      codePoint = input.codePointAt(i);
+      if (codePoint < 0x20
+          || codePoint == 0x7f
+          || codePoint >= 0x80 && asciiOnly
+          || encodeSet.indexOf(codePoint) != -1
+          || codePoint == '%' && (!alreadyEncoded || strict && !percentEncoded(input, i, limit))
+          || codePoint == '+' && plusIsSpace) {
+        // Slow path: the character at i requires encoding!
+        Buffer out = new Buffer();
+        out.writeUtf8(input, pos, i);
+        canonicalize(out, input, i, limit, encodeSet, alreadyEncoded, strict, plusIsSpace,
+            asciiOnly);
+        return out.readUtf8();
+      }
+    }
+
+    // Fast path: no characters in [pos..limit) required encoding.
+    return input.substring(pos, limit);
+  }
+
+  static void canonicalize(Buffer out, String input, int pos, int limit, String encodeSet,
+      boolean alreadyEncoded, boolean strict, boolean plusIsSpace, boolean asciiOnly) {
+    Buffer utf8Buffer = null; // Lazily allocated.
+    int codePoint;
+    for (int i = pos; i < limit; i += Character.charCount(codePoint)) {
+      codePoint = input.codePointAt(i);
+      if (alreadyEncoded
+          && (codePoint == '\t' || codePoint == '\n' || codePoint == '\f' || codePoint == '\r')) {
+        // Skip this character.
+      } else if (codePoint == '+' && plusIsSpace) {
+        // Encode '+' as '%2B' since we permit ' ' to be encoded as either '+' or '%20'.
+        out.writeUtf8(alreadyEncoded ? "+" : "%2B");
+      } else if (codePoint < 0x20
+          || codePoint == 0x7f
+          || codePoint >= 0x80 && asciiOnly
+          || encodeSet.indexOf(codePoint) != -1
+          || codePoint == '%' && (!alreadyEncoded || strict && !percentEncoded(input, i, limit))) {
+        // Percent encode this character.
+        if (utf8Buffer == null) {
+          utf8Buffer = new Buffer();
+        }
+        utf8Buffer.writeUtf8CodePoint(codePoint);
+        while (!utf8Buffer.exhausted()) {
+          int b = utf8Buffer.readByte() & 0xff;
+          out.writeByte('%');
+          out.writeByte(HEX_DIGITS[(b >> 4) & 0xf]);
+          out.writeByte(HEX_DIGITS[b & 0xf]);
+        }
+      } else {
+        // This character doesn't need encoding. Just copy it over.
+        out.writeUtf8CodePoint(codePoint);
+      }
+    }
+  }
+
+  static String canonicalize(String input, String encodeSet, boolean alreadyEncoded, boolean strict,
+      boolean plusIsSpace, boolean asciiOnly) {
+    return canonicalize(
+        input, 0, input.length(), encodeSet, alreadyEncoded, strict, plusIsSpace, asciiOnly);
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Interceptor.java b/okhttp/src/main/java/okhttp3/Interceptor.java
similarity index 81%
rename from okhttp/src/main/java/com/squareup/okhttp/Interceptor.java
rename to okhttp/src/main/java/okhttp3/Interceptor.java
index 7563e96425..f124a96b65 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Interceptor.java
+++ b/okhttp/src/main/java/okhttp3/Interceptor.java
@@ -13,22 +13,29 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
 import java.io.IOException;
 
 /**
  * Observes, modifies, and potentially short-circuits requests going out and the corresponding
+<<<<<<< HEAD:okhttp/src/main/java/com/squareup/okhttp/Interceptor.java
  * requests coming back in. Typically interceptors will be used to add, remove, or transform headers
  * on the request or response.
  * 观察，修改以及可能短路的请求输出和响应请求的回来。通常情况下连接器用来添加，移除或者转换请求或者回应的头部信息
+=======
+ * responses coming back in. Typically interceptors add, remove, or transform headers on the request
+ * or response.
+>>>>>>> upstream/master:okhttp/src/main/java/okhttp3/Interceptor.java
  */
 public interface Interceptor {
   Response intercept(Chain chain) throws IOException;
 
   interface Chain {
     Request request();
+
     Response proceed(Request request) throws IOException;
+
     Connection connection();
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/MediaType.java b/okhttp/src/main/java/okhttp3/MediaType.java
similarity index 90%
rename from okhttp/src/main/java/com/squareup/okhttp/MediaType.java
rename to okhttp/src/main/java/okhttp3/MediaType.java
index 4d2f1fcf44..bbdcedf686 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/MediaType.java
+++ b/okhttp/src/main/java/okhttp3/MediaType.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
 import java.nio.charset.Charset;
 import java.util.Locale;
@@ -21,8 +21,8 @@
 import java.util.regex.Pattern;
 
 /**
- * An <a href="http://tools.ietf.org/html/rfc2045">RFC 2045</a> Media Type,
- * appropriate to describe the content type of an HTTP request or response body.
+ * An <a href="http://tools.ietf.org/html/rfc2045">RFC 2045</a> Media Type, appropriate to describe
+ * the content type of an HTTP request or response body.
  */
 public final class MediaType {
   private static final String TOKEN = "([a-zA-Z0-9-!#$%&'*+.^_`{|}~]+)";
@@ -44,8 +44,8 @@ private MediaType(String mediaType, String type, String subtype, String charset)
   }
 
   /**
-   * Returns a media type for {@code string}, or null if {@code string} is not a
-   * well-formed media type.
+   * Returns a media type for {@code string}, or null if {@code string} is not a well-formed media
+   * type.
    */
   public static MediaType parse(String string) {
     Matcher typeSubtype = TYPE_SUBTYPE.matcher(string);
@@ -74,40 +74,38 @@ public static MediaType parse(String string) {
   }
 
   /**
-   * Returns the high-level media type, such as "text", "image", "audio",
-   * "video", or "application".
+   * Returns the high-level media type, such as "text", "image", "audio", "video", or
+   * "application".
    */
   public String type() {
     return type;
   }
 
   /**
-   * Returns a specific media subtype, such as "plain" or "png", "mpeg",
-   * "mp4" or "xml".
+   * Returns a specific media subtype, such as "plain" or "png", "mpeg", "mp4" or "xml".
    */
   public String subtype() {
     return subtype;
   }
 
   /**
-   * Returns the charset of this media type, or null if this media type doesn't
-   * specify a charset.
+   * Returns the charset of this media type, or null if this media type doesn't specify a charset.
    */
   public Charset charset() {
     return charset != null ? Charset.forName(charset) : null;
   }
 
   /**
-   * Returns the charset of this media type, or {@code defaultValue} if this
-   * media type doesn't specify a charset.
+   * Returns the charset of this media type, or {@code defaultValue} if this media type doesn't
+   * specify a charset.
    */
   public Charset charset(Charset defaultValue) {
     return charset != null ? Charset.forName(charset) : defaultValue;
   }
 
   /**
-   * Returns the encoded media type, like "text/plain; charset=utf-8",
-   * appropriate for use in a Content-Type header.
+   * Returns the encoded media type, like "text/plain; charset=utf-8", appropriate for use in a
+   * Content-Type header.
    */
   @Override public String toString() {
     return mediaType;
diff --git a/okhttp/src/main/java/okhttp3/MultipartBody.java b/okhttp/src/main/java/okhttp3/MultipartBody.java
new file mode 100644
index 0000000000..7ac584d1d9
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/MultipartBody.java
@@ -0,0 +1,332 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.UUID;
+import okhttp3.internal.Util;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.ByteString;
+
+/** An <a href="http://www.ietf.org/rfc/rfc2387.txt">RFC 2387</a>-compliant request body. */
+public final class MultipartBody extends RequestBody {
+  /**
+   * The "mixed" subtype of "multipart" is intended for use when the body parts are independent and
+   * need to be bundled in a particular order. Any "multipart" subtypes that an implementation does
+   * not recognize must be treated as being of subtype "mixed".
+   */
+  public static final MediaType MIXED = MediaType.parse("multipart/mixed");
+
+  /**
+   * The "multipart/alternative" type is syntactically identical to "multipart/mixed", but the
+   * semantics are different. In particular, each of the body parts is an "alternative" version of
+   * the same information.
+   */
+  public static final MediaType ALTERNATIVE = MediaType.parse("multipart/alternative");
+
+  /**
+   * This type is syntactically identical to "multipart/mixed", but the semantics are different. In
+   * particular, in a digest, the default {@code Content-Type} value for a body part is changed from
+   * "text/plain" to "message/rfc822".
+   */
+  public static final MediaType DIGEST = MediaType.parse("multipart/digest");
+
+  /**
+   * This type is syntactically identical to "multipart/mixed", but the semantics are different. In
+   * particular, in a parallel entity, the order of body parts is not significant.
+   */
+  public static final MediaType PARALLEL = MediaType.parse("multipart/parallel");
+
+  /**
+   * The media-type multipart/form-data follows the rules of all multipart MIME data streams as
+   * outlined in RFC 2046. In forms, there are a series of fields to be supplied by the user who
+   * fills out the form. Each field has a name. Within a given form, the names are unique.
+   */
+  public static final MediaType FORM = MediaType.parse("multipart/form-data");
+
+  private static final byte[] COLONSPACE = {':', ' '};
+  private static final byte[] CRLF = {'\r', '\n'};
+  private static final byte[] DASHDASH = {'-', '-'};
+
+  private final ByteString boundary;
+  private final MediaType originalType;
+  private final MediaType contentType;
+  private final List<Part> parts;
+  private long contentLength = -1L;
+
+  MultipartBody(ByteString boundary, MediaType type, List<Part> parts) {
+    this.boundary = boundary;
+    this.originalType = type;
+    this.contentType = MediaType.parse(type + "; boundary=" + boundary.utf8());
+    this.parts = Util.immutableList(parts);
+  }
+
+  public MediaType type() {
+    return originalType;
+  }
+
+  public String boundary() {
+    return boundary.utf8();
+  }
+
+  /** The number of parts in this multipart body. */
+  public int size() {
+    return parts.size();
+  }
+
+  public List<Part> parts() {
+    return parts;
+  }
+
+  public Part part(int index) {
+    return parts.get(index);
+  }
+
+  /** A combination of {@link #type()} and {@link #boundary()}. */
+  @Override public MediaType contentType() {
+    return contentType;
+  }
+
+  @Override public long contentLength() throws IOException {
+    long result = contentLength;
+    if (result != -1L) return result;
+    return contentLength = writeOrCountBytes(null, true);
+  }
+
+  @Override public void writeTo(BufferedSink sink) throws IOException {
+    writeOrCountBytes(sink, false);
+  }
+
+  /**
+   * Either writes this request to {@code sink} or measures its content length. We have one method
+   * do double-duty to make sure the counting and content are consistent, particularly when it comes
+   * to awkward operations like measuring the encoded length of header strings, or the
+   * length-in-digits of an encoded integer.
+   */
+  private long writeOrCountBytes(BufferedSink sink, boolean countBytes) throws IOException {
+    long byteCount = 0L;
+
+    Buffer byteCountBuffer = null;
+    if (countBytes) {
+      sink = byteCountBuffer = new Buffer();
+    }
+
+    for (int p = 0, partCount = parts.size(); p < partCount; p++) {
+      Part part = parts.get(p);
+      Headers headers = part.headers;
+      RequestBody body = part.body;
+
+      sink.write(DASHDASH);
+      sink.write(boundary);
+      sink.write(CRLF);
+
+      if (headers != null) {
+        for (int h = 0, headerCount = headers.size(); h < headerCount; h++) {
+          sink.writeUtf8(headers.name(h))
+              .write(COLONSPACE)
+              .writeUtf8(headers.value(h))
+              .write(CRLF);
+        }
+      }
+
+      MediaType contentType = body.contentType();
+      if (contentType != null) {
+        sink.writeUtf8("Content-Type: ")
+            .writeUtf8(contentType.toString())
+            .write(CRLF);
+      }
+
+      long contentLength = body.contentLength();
+      if (contentLength != -1) {
+        sink.writeUtf8("Content-Length: ")
+            .writeDecimalLong(contentLength)
+            .write(CRLF);
+      } else if (countBytes) {
+        // We can't measure the body's size without the sizes of its components.
+        byteCountBuffer.clear();
+        return -1L;
+      }
+
+      sink.write(CRLF);
+
+      if (countBytes) {
+        byteCount += contentLength;
+      } else {
+        body.writeTo(sink);
+      }
+
+      sink.write(CRLF);
+    }
+
+    sink.write(DASHDASH);
+    sink.write(boundary);
+    sink.write(DASHDASH);
+    sink.write(CRLF);
+
+    if (countBytes) {
+      byteCount += byteCountBuffer.size();
+      byteCountBuffer.clear();
+    }
+
+    return byteCount;
+  }
+
+  /**
+   * Appends a quoted-string to a StringBuilder.
+   *
+   * <p>RFC 2388 is rather vague about how one should escape special characters in form-data
+   * parameters, and as it turns out Firefox and Chrome actually do rather different things, and
+   * both say in their comments that they're not really sure what the right approach is. We go with
+   * Chrome's behavior (which also experimentally seems to match what IE does), but if you actually
+   * want to have a good chance of things working, please avoid double-quotes, newlines, percent
+   * signs, and the like in your field names.
+   */
+  static StringBuilder appendQuotedString(StringBuilder target, String key) {
+    target.append('"');
+    for (int i = 0, len = key.length(); i < len; i++) {
+      char ch = key.charAt(i);
+      switch (ch) {
+        case '\n':
+          target.append("%0A");
+          break;
+        case '\r':
+          target.append("%0D");
+          break;
+        case '"':
+          target.append("%22");
+          break;
+        default:
+          target.append(ch);
+          break;
+      }
+    }
+    target.append('"');
+    return target;
+  }
+
+  public static final class Part {
+    public static Part create(RequestBody body) {
+      return create(null, body);
+    }
+
+    public static Part create(Headers headers, RequestBody body) {
+      if (body == null) {
+        throw new NullPointerException("body == null");
+      }
+      if (headers != null && headers.get("Content-Type") != null) {
+        throw new IllegalArgumentException("Unexpected header: Content-Type");
+      }
+      if (headers != null && headers.get("Content-Length") != null) {
+        throw new IllegalArgumentException("Unexpected header: Content-Length");
+      }
+      return new Part(headers, body);
+    }
+
+    public static Part createFormData(String name, String value) {
+      return createFormData(name, null, RequestBody.create(null, value));
+    }
+
+    public static Part createFormData(String name, String filename, RequestBody body) {
+      if (name == null) {
+        throw new NullPointerException("name == null");
+      }
+      StringBuilder disposition = new StringBuilder("form-data; name=");
+      appendQuotedString(disposition, name);
+
+      if (filename != null) {
+        disposition.append("; filename=");
+        appendQuotedString(disposition, filename);
+      }
+
+      return create(Headers.of("Content-Disposition", disposition.toString()), body);
+    }
+
+    private final Headers headers;
+    private final RequestBody body;
+
+    private Part(Headers headers, RequestBody body) {
+      this.headers = headers;
+      this.body = body;
+    }
+  }
+
+  public static final class Builder {
+    private final ByteString boundary;
+    private MediaType type = MIXED;
+    private final List<Part> parts = new ArrayList<>();
+
+    public Builder() {
+      this(UUID.randomUUID().toString());
+    }
+
+    public Builder(String boundary) {
+      this.boundary = ByteString.encodeUtf8(boundary);
+    }
+
+    /**
+     * Set the MIME type. Expected values for {@code type} are {@link #MIXED} (the default), {@link
+     * #ALTERNATIVE}, {@link #DIGEST}, {@link #PARALLEL} and {@link #FORM}.
+     */
+    public Builder setType(MediaType type) {
+      if (type == null) {
+        throw new NullPointerException("type == null");
+      }
+      if (!type.type().equals("multipart")) {
+        throw new IllegalArgumentException("multipart != " + type);
+      }
+      this.type = type;
+      return this;
+    }
+
+    /** Add a part to the body. */
+    public Builder addPart(RequestBody body) {
+      return addPart(Part.create(body));
+    }
+
+    /** Add a part to the body. */
+    public Builder addPart(Headers headers, RequestBody body) {
+      return addPart(Part.create(headers, body));
+    }
+
+    /** Add a form data part to the body. */
+    public Builder addFormDataPart(String name, String value) {
+      return addPart(Part.createFormData(name, value));
+    }
+
+    /** Add a form data part to the body. */
+    public Builder addFormDataPart(String name, String filename, RequestBody body) {
+      return addPart(Part.createFormData(name, filename, body));
+    }
+
+    /** Add a part to the body. */
+    public Builder addPart(Part part) {
+      if (part == null) throw new NullPointerException("part == null");
+      parts.add(part);
+      return this;
+    }
+
+    /** Assemble the specified parts into a request body. */
+    public MultipartBody build() {
+      if (parts.isEmpty()) {
+        throw new IllegalStateException("Multipart body must have at least one part.");
+      }
+      return new MultipartBody(boundary, type, parts);
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/OkHttpClient.java b/okhttp/src/main/java/okhttp3/OkHttpClient.java
new file mode 100644
index 0000000000..b23e6a2212
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/OkHttpClient.java
@@ -0,0 +1,791 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.net.MalformedURLException;
+import java.net.Proxy;
+import java.net.ProxySelector;
+import java.net.UnknownHostException;
+import java.security.GeneralSecurityException;
+import java.security.KeyStore;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+import javax.net.SocketFactory;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSocket;
+import javax.net.ssl.SSLSocketFactory;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.TrustManagerFactory;
+import javax.net.ssl.X509TrustManager;
+import okhttp3.internal.Internal;
+import okhttp3.internal.InternalCache;
+import okhttp3.internal.Platform;
+import okhttp3.internal.RouteDatabase;
+import okhttp3.internal.Util;
+import okhttp3.internal.http.StreamAllocation;
+import okhttp3.internal.io.RealConnection;
+import okhttp3.internal.tls.CertificateChainCleaner;
+import okhttp3.internal.tls.OkHostnameVerifier;
+
+/**
+ * Factory for {@linkplain Call calls}, which can be used to send HTTP requests and read their
+ * responses. Most applications can use a single OkHttpClient for all of their HTTP requests,
+ * benefiting from a shared response cache, thread pool, connection re-use, etc.
+ *
+ * <p>To create an {@code OkHttpClient} with the default settings, use the {@linkplain
+ * #OkHttpClient() default constructor}. Or create a configured instance with {@link
+ * OkHttpClient.Builder}. To adjust an existing client before making a request, use {@link
+ * #newBuilder()}. This example shows a call with a 30 second timeout:
+ * <pre>   {@code
+ *
+ *   OkHttpClient client = ...
+ *   OkHttpClient clientWith30sTimeout = client.newBuilder()
+ *       .readTimeout(30, TimeUnit.SECONDS)
+ *       .build();
+ *   Response response = clientWith30sTimeout.newCall(request).execute();
+ * }</pre>
+ */
+public class OkHttpClient implements Cloneable, Call.Factory {
+  private static final List<Protocol> DEFAULT_PROTOCOLS = Util.immutableList(
+      Protocol.HTTP_2, Protocol.SPDY_3, Protocol.HTTP_1_1);
+
+  private static final List<ConnectionSpec> DEFAULT_CONNECTION_SPECS;
+
+  static {
+    List<ConnectionSpec> connSpecs = new ArrayList<>(Arrays.asList(ConnectionSpec.MODERN_TLS,
+        ConnectionSpec.COMPATIBLE_TLS));
+    if (Platform.get().isCleartextTrafficPermitted()) {
+      connSpecs.add(ConnectionSpec.CLEARTEXT);
+    }
+    DEFAULT_CONNECTION_SPECS = Util.immutableList(connSpecs);
+
+    Internal.instance = new Internal() {
+      @Override public void addLenient(Headers.Builder builder, String line) {
+        builder.addLenient(line);
+      }
+
+      @Override public void addLenient(Headers.Builder builder, String name, String value) {
+        builder.addLenient(name, value);
+      }
+
+      @Override public void setCache(OkHttpClient.Builder builder, InternalCache internalCache) {
+        builder.setInternalCache(internalCache);
+      }
+
+      @Override public InternalCache internalCache(OkHttpClient client) {
+        return client.internalCache();
+      }
+
+      @Override public boolean connectionBecameIdle(
+          ConnectionPool pool, RealConnection connection) {
+        return pool.connectionBecameIdle(connection);
+      }
+
+      @Override public RealConnection get(
+          ConnectionPool pool, Address address, StreamAllocation streamAllocation) {
+        return pool.get(address, streamAllocation);
+      }
+
+      @Override public void put(ConnectionPool pool, RealConnection connection) {
+        pool.put(connection);
+      }
+
+      @Override public RouteDatabase routeDatabase(ConnectionPool connectionPool) {
+        return connectionPool.routeDatabase;
+      }
+
+      @Override
+      public void callEnqueue(Call call, Callback responseCallback, boolean forWebSocket) {
+        ((RealCall) call).enqueue(responseCallback, forWebSocket);
+      }
+
+      @Override public StreamAllocation callEngineGetStreamAllocation(Call call) {
+        return ((RealCall) call).engine.streamAllocation;
+      }
+
+      @Override
+      public void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket, boolean isFallback) {
+        tlsConfiguration.apply(sslSocket, isFallback);
+      }
+
+      @Override public HttpUrl getHttpUrlChecked(String url)
+          throws MalformedURLException, UnknownHostException {
+        return HttpUrl.getChecked(url);
+      }
+    };
+  }
+
+  final Dispatcher dispatcher;
+  final Proxy proxy;
+  final List<Protocol> protocols;
+  final List<ConnectionSpec> connectionSpecs;
+  final List<Interceptor> interceptors;
+  final List<Interceptor> networkInterceptors;
+  final ProxySelector proxySelector;
+  final CookieJar cookieJar;
+  final Cache cache;
+  final InternalCache internalCache;
+  final SocketFactory socketFactory;
+  final SSLSocketFactory sslSocketFactory;
+  final CertificateChainCleaner certificateChainCleaner;
+  final HostnameVerifier hostnameVerifier;
+  final CertificatePinner certificatePinner;
+  final Authenticator proxyAuthenticator;
+  final Authenticator authenticator;
+  final ConnectionPool connectionPool;
+  final Dns dns;
+  final boolean followSslRedirects;
+  final boolean followRedirects;
+  final boolean retryOnConnectionFailure;
+  final int connectTimeout;
+  final int readTimeout;
+  final int writeTimeout;
+
+  public OkHttpClient() {
+    this(new Builder());
+  }
+
+  private OkHttpClient(Builder builder) {
+    this.dispatcher = builder.dispatcher;
+    this.proxy = builder.proxy;
+    this.protocols = builder.protocols;
+    this.connectionSpecs = builder.connectionSpecs;
+    this.interceptors = Util.immutableList(builder.interceptors);
+    this.networkInterceptors = Util.immutableList(builder.networkInterceptors);
+    this.proxySelector = builder.proxySelector;
+    this.cookieJar = builder.cookieJar;
+    this.cache = builder.cache;
+    this.internalCache = builder.internalCache;
+    this.socketFactory = builder.socketFactory;
+
+    boolean isTLS = false;
+    for (ConnectionSpec spec : connectionSpecs) {
+      isTLS = isTLS || spec.isTls();
+    }
+
+    if (builder.sslSocketFactory != null || !isTLS) {
+      this.sslSocketFactory = builder.sslSocketFactory;
+      this.certificateChainCleaner = builder.certificateChainCleaner;
+    } else {
+      X509TrustManager trustManager = systemDefaultTrustManager();
+      this.sslSocketFactory = systemDefaultSslSocketFactory(trustManager);
+      this.certificateChainCleaner = CertificateChainCleaner.get(trustManager);
+    }
+
+    this.hostnameVerifier = builder.hostnameVerifier;
+    this.certificatePinner = builder.certificatePinner.withCertificateChainCleaner(
+        certificateChainCleaner);
+    this.proxyAuthenticator = builder.proxyAuthenticator;
+    this.authenticator = builder.authenticator;
+    this.connectionPool = builder.connectionPool;
+    this.dns = builder.dns;
+    this.followSslRedirects = builder.followSslRedirects;
+    this.followRedirects = builder.followRedirects;
+    this.retryOnConnectionFailure = builder.retryOnConnectionFailure;
+    this.connectTimeout = builder.connectTimeout;
+    this.readTimeout = builder.readTimeout;
+    this.writeTimeout = builder.writeTimeout;
+  }
+
+  private X509TrustManager systemDefaultTrustManager() {
+    try {
+      TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
+          TrustManagerFactory.getDefaultAlgorithm());
+      trustManagerFactory.init((KeyStore) null);
+      TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
+      if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {
+        throw new IllegalStateException("Unexpected default trust managers:"
+            + Arrays.toString(trustManagers));
+      }
+      return (X509TrustManager) trustManagers[0];
+    } catch (GeneralSecurityException e) {
+      throw new AssertionError(); // The system has no TLS. Just give up.
+    }
+  }
+
+  private SSLSocketFactory systemDefaultSslSocketFactory(X509TrustManager trustManager) {
+    try {
+      SSLContext sslContext = SSLContext.getInstance("TLS");
+      sslContext.init(null, new TrustManager[] { trustManager }, null);
+      return sslContext.getSocketFactory();
+    } catch (GeneralSecurityException e) {
+      throw new AssertionError(); // The system has no TLS. Just give up.
+    }
+  }
+
+  /** Default connect timeout (in milliseconds). */
+  public int connectTimeoutMillis() {
+    return connectTimeout;
+  }
+
+  /** Default read timeout (in milliseconds). */
+  public int readTimeoutMillis() {
+    return readTimeout;
+  }
+
+  /** Default write timeout (in milliseconds). */
+  public int writeTimeoutMillis() {
+    return writeTimeout;
+  }
+
+  public Proxy proxy() {
+    return proxy;
+  }
+
+  public ProxySelector proxySelector() {
+    return proxySelector;
+  }
+
+  public CookieJar cookieJar() {
+    return cookieJar;
+  }
+
+  public Cache cache() {
+    return cache;
+  }
+
+  InternalCache internalCache() {
+    return cache != null ? cache.internalCache : internalCache;
+  }
+
+  public Dns dns() {
+    return dns;
+  }
+
+  public SocketFactory socketFactory() {
+    return socketFactory;
+  }
+
+  public SSLSocketFactory sslSocketFactory() {
+    return sslSocketFactory;
+  }
+
+  public HostnameVerifier hostnameVerifier() {
+    return hostnameVerifier;
+  }
+
+  public CertificatePinner certificatePinner() {
+    return certificatePinner;
+  }
+
+  public Authenticator authenticator() {
+    return authenticator;
+  }
+
+  public Authenticator proxyAuthenticator() {
+    return proxyAuthenticator;
+  }
+
+  public ConnectionPool connectionPool() {
+    return connectionPool;
+  }
+
+  public boolean followSslRedirects() {
+    return followSslRedirects;
+  }
+
+  public boolean followRedirects() {
+    return followRedirects;
+  }
+
+  public boolean retryOnConnectionFailure() {
+    return retryOnConnectionFailure;
+  }
+
+  public Dispatcher dispatcher() {
+    return dispatcher;
+  }
+
+  public List<Protocol> protocols() {
+    return protocols;
+  }
+
+  public List<ConnectionSpec> connectionSpecs() {
+    return connectionSpecs;
+  }
+
+  /**
+   * Returns an immutable list of interceptors that observe the full span of each call: from before
+   * the connection is established (if any) until after the response source is selected (either the
+   * origin server, cache, or both).
+   */
+  public List<Interceptor> interceptors() {
+    return interceptors;
+  }
+
+  /**
+   * Returns an immutable list of interceptors that observe a single network request and response.
+   * These interceptors must call {@link Interceptor.Chain#proceed} exactly once: it is an error for
+   * a network interceptor to short-circuit or repeat a network request.
+   */
+  public List<Interceptor> networkInterceptors() {
+    return networkInterceptors;
+  }
+
+  /**
+   * Prepares the {@code request} to be executed at some point in the future.
+   */
+  @Override public Call newCall(Request request) {
+    return new RealCall(this, request);
+  }
+
+  public Builder newBuilder() {
+    return new Builder(this);
+  }
+
+  public static final class Builder {
+    Dispatcher dispatcher;
+    Proxy proxy;
+    List<Protocol> protocols;
+    List<ConnectionSpec> connectionSpecs;
+    final List<Interceptor> interceptors = new ArrayList<>();
+    final List<Interceptor> networkInterceptors = new ArrayList<>();
+    ProxySelector proxySelector;
+    CookieJar cookieJar;
+    Cache cache;
+    InternalCache internalCache;
+    SocketFactory socketFactory;
+    SSLSocketFactory sslSocketFactory;
+    CertificateChainCleaner certificateChainCleaner;
+    HostnameVerifier hostnameVerifier;
+    CertificatePinner certificatePinner;
+    Authenticator proxyAuthenticator;
+    Authenticator authenticator;
+    ConnectionPool connectionPool;
+    Dns dns;
+    boolean followSslRedirects;
+    boolean followRedirects;
+    boolean retryOnConnectionFailure;
+    int connectTimeout;
+    int readTimeout;
+    int writeTimeout;
+
+    public Builder() {
+      dispatcher = new Dispatcher();
+      protocols = DEFAULT_PROTOCOLS;
+      connectionSpecs = DEFAULT_CONNECTION_SPECS;
+      proxySelector = ProxySelector.getDefault();
+      cookieJar = CookieJar.NO_COOKIES;
+      socketFactory = SocketFactory.getDefault();
+      hostnameVerifier = OkHostnameVerifier.INSTANCE;
+      certificatePinner = CertificatePinner.DEFAULT;
+      proxyAuthenticator = Authenticator.NONE;
+      authenticator = Authenticator.NONE;
+      connectionPool = new ConnectionPool();
+      dns = Dns.SYSTEM;
+      followSslRedirects = true;
+      followRedirects = true;
+      retryOnConnectionFailure = true;
+      connectTimeout = 10_000;
+      readTimeout = 10_000;
+      writeTimeout = 10_000;
+    }
+
+    Builder(OkHttpClient okHttpClient) {
+      this.dispatcher = okHttpClient.dispatcher;
+      this.proxy = okHttpClient.proxy;
+      this.protocols = okHttpClient.protocols;
+      this.connectionSpecs = okHttpClient.connectionSpecs;
+      this.interceptors.addAll(okHttpClient.interceptors);
+      this.networkInterceptors.addAll(okHttpClient.networkInterceptors);
+      this.proxySelector = okHttpClient.proxySelector;
+      this.cookieJar = okHttpClient.cookieJar;
+      this.internalCache = okHttpClient.internalCache;
+      this.cache = okHttpClient.cache;
+      this.socketFactory = okHttpClient.socketFactory;
+      this.sslSocketFactory = okHttpClient.sslSocketFactory;
+      this.certificateChainCleaner = okHttpClient.certificateChainCleaner;
+      this.hostnameVerifier = okHttpClient.hostnameVerifier;
+      this.certificatePinner = okHttpClient.certificatePinner;
+      this.proxyAuthenticator = okHttpClient.proxyAuthenticator;
+      this.authenticator = okHttpClient.authenticator;
+      this.connectionPool = okHttpClient.connectionPool;
+      this.dns = okHttpClient.dns;
+      this.followSslRedirects = okHttpClient.followSslRedirects;
+      this.followRedirects = okHttpClient.followRedirects;
+      this.retryOnConnectionFailure = okHttpClient.retryOnConnectionFailure;
+      this.connectTimeout = okHttpClient.connectTimeout;
+      this.readTimeout = okHttpClient.readTimeout;
+      this.writeTimeout = okHttpClient.writeTimeout;
+    }
+
+    /**
+     * Sets the default connect timeout for new connections. A value of 0 means no timeout,
+     * otherwise values must be between 1 and {@link Integer#MAX_VALUE} when converted to
+     * milliseconds.
+     */
+    public Builder connectTimeout(long timeout, TimeUnit unit) {
+      if (timeout < 0) throw new IllegalArgumentException("timeout < 0");
+      if (unit == null) throw new NullPointerException("unit == null");
+      long millis = unit.toMillis(timeout);
+      if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException("Timeout too large.");
+      if (millis == 0 && timeout > 0) throw new IllegalArgumentException("Timeout too small.");
+      connectTimeout = (int) millis;
+      return this;
+    }
+
+    /**
+     * Sets the default read timeout for new connections. A value of 0 means no timeout, otherwise
+     * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
+     */
+    public Builder readTimeout(long timeout, TimeUnit unit) {
+      if (timeout < 0) throw new IllegalArgumentException("timeout < 0");
+      if (unit == null) throw new NullPointerException("unit == null");
+      long millis = unit.toMillis(timeout);
+      if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException("Timeout too large.");
+      if (millis == 0 && timeout > 0) throw new IllegalArgumentException("Timeout too small.");
+      readTimeout = (int) millis;
+      return this;
+    }
+
+    /**
+     * Sets the default write timeout for new connections. A value of 0 means no timeout, otherwise
+     * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
+     */
+    public Builder writeTimeout(long timeout, TimeUnit unit) {
+      if (timeout < 0) throw new IllegalArgumentException("timeout < 0");
+      if (unit == null) throw new NullPointerException("unit == null");
+      long millis = unit.toMillis(timeout);
+      if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException("Timeout too large.");
+      if (millis == 0 && timeout > 0) throw new IllegalArgumentException("Timeout too small.");
+      writeTimeout = (int) millis;
+      return this;
+    }
+
+    /**
+     * Sets the HTTP proxy that will be used by connections created by this client. This takes
+     * precedence over {@link #proxySelector}, which is only honored when this proxy is null (which
+     * it is by default). To disable proxy use completely, call {@code setProxy(Proxy.NO_PROXY)}.
+     */
+    public Builder proxy(Proxy proxy) {
+      this.proxy = proxy;
+      return this;
+    }
+
+    /**
+     * Sets the proxy selection policy to be used if no {@link #proxy proxy} is specified
+     * explicitly. The proxy selector may return multiple proxies; in that case they will be tried
+     * in sequence until a successful connection is established.
+     *
+     * <p>If unset, the {@link ProxySelector#getDefault() system-wide default} proxy selector will
+     * be used.
+     */
+    public Builder proxySelector(ProxySelector proxySelector) {
+      this.proxySelector = proxySelector;
+      return this;
+    }
+
+    /**
+     * Sets the handler that can accept cookies from incoming HTTP responses and provides cookies to
+     * outgoing HTTP requests.
+     *
+     * <p>If unset, {@linkplain CookieJar#NO_COOKIES no cookies} will be accepted nor provided.
+     */
+    public Builder cookieJar(CookieJar cookieJar) {
+      if (cookieJar == null) throw new NullPointerException("cookieJar == null");
+      this.cookieJar = cookieJar;
+      return this;
+    }
+
+    /** Sets the response cache to be used to read and write cached responses. */
+    void setInternalCache(InternalCache internalCache) {
+      this.internalCache = internalCache;
+      this.cache = null;
+    }
+
+    public Builder cache(Cache cache) {
+      this.cache = cache;
+      this.internalCache = null;
+      return this;
+    }
+
+    /**
+     * Sets the DNS service used to lookup IP addresses for hostnames.
+     *
+     * <p>If unset, the {@link Dns#SYSTEM system-wide default} DNS will be used.
+     */
+    public Builder dns(Dns dns) {
+      if (dns == null) throw new NullPointerException("dns == null");
+      this.dns = dns;
+      return this;
+    }
+
+    /**
+     * Sets the socket factory used to create connections. OkHttp only uses the parameterless {@link
+     * SocketFactory#createSocket() createSocket()} method to create unconnected sockets. Overriding
+     * this method, e. g., allows the socket to be bound to a specific local address.
+     *
+     * <p>If unset, the {@link SocketFactory#getDefault() system-wide default} socket factory will
+     * be used.
+     */
+    public Builder socketFactory(SocketFactory socketFactory) {
+      if (socketFactory == null) throw new NullPointerException("socketFactory == null");
+      this.socketFactory = socketFactory;
+      return this;
+    }
+
+    /**
+     * Sets the socket factory used to secure HTTPS connections. If unset, the system default will
+     * be used.
+     *
+     * @deprecated {@code SSLSocketFactory} does not expose its {@link X509TrustManager}, which is
+     *     a field that OkHttp needs to build a clean certificate chain. This method instead must
+     *     use reflection to extract the trust manager. Applications should prefer to call {@link
+     *     #sslSocketFactory(SSLSocketFactory, X509TrustManager)}, which avoids such reflection.
+     */
+    public Builder sslSocketFactory(SSLSocketFactory sslSocketFactory) {
+      if (sslSocketFactory == null) throw new NullPointerException("sslSocketFactory == null");
+      X509TrustManager trustManager = Platform.get().trustManager(sslSocketFactory);
+      if (trustManager == null) {
+        throw new IllegalStateException("Unable to extract the trust manager on " + Platform.get()
+            + ", sslSocketFactory is " + sslSocketFactory.getClass());
+      }
+      this.sslSocketFactory = sslSocketFactory;
+      this.certificateChainCleaner = CertificateChainCleaner.get(trustManager);
+      return this;
+    }
+
+    /**
+     * Sets the socket factory and trust manager used to secure HTTPS connections. If unset, the
+     * system defaults will be used.
+     *
+     * <p>Most applications should not call this method, and instead use the system defaults. Those
+     * classes include special optimizations that can be lost if the implementations are decorated.
+     *
+     * <p>If necessary, you can create and configure the defaults yourself with the following code:
+     *
+     * <pre>   {@code
+     *
+     *   TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
+     *       TrustManagerFactory.getDefaultAlgorithm());
+     *   trustManagerFactory.init((KeyStore) null);
+     *   TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
+     *   if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {
+     *     throw new IllegalStateException("Unexpected default trust managers:"
+     *         + Arrays.toString(trustManagers));
+     *   }
+     *   X509TrustManager trustManager = (X509TrustManager) trustManagers[0];
+     *
+     *   SSLContext sslContext = SSLContext.getInstance("TLS");
+     *   sslContext.init(null, new TrustManager[] { trustManager }, null);
+     *   SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();
+     *
+     *   OkHttpClient client = new OkHttpClient.Builder()
+     *       .sslSocketFactory(sslSocketFactory, trustManager);
+     *       .build();
+     * }</pre>
+     */
+    public Builder sslSocketFactory(
+        SSLSocketFactory sslSocketFactory, X509TrustManager trustManager) {
+      if (sslSocketFactory == null) throw new NullPointerException("sslSocketFactory == null");
+      if (trustManager == null) throw new NullPointerException("trustManager == null");
+      this.sslSocketFactory = sslSocketFactory;
+      this.certificateChainCleaner = CertificateChainCleaner.get(trustManager);
+      return this;
+    }
+
+    /**
+     * Sets the verifier used to confirm that response certificates apply to requested hostnames for
+     * HTTPS connections.
+     *
+     * <p>If unset, a default hostname verifier will be used.
+     */
+    public Builder hostnameVerifier(HostnameVerifier hostnameVerifier) {
+      if (hostnameVerifier == null) throw new NullPointerException("hostnameVerifier == null");
+      this.hostnameVerifier = hostnameVerifier;
+      return this;
+    }
+
+    /**
+     * Sets the certificate pinner that constrains which certificates are trusted. By default HTTPS
+     * connections rely on only the {@link #sslSocketFactory SSL socket factory} to establish trust.
+     * Pinning certificates avoids the need to trust certificate authorities.
+     */
+    public Builder certificatePinner(CertificatePinner certificatePinner) {
+      if (certificatePinner == null) throw new NullPointerException("certificatePinner == null");
+      this.certificatePinner = certificatePinner;
+      return this;
+    }
+
+    /**
+     * Sets the authenticator used to respond to challenges from origin servers. Use {@link
+     * #proxyAuthenticator} to set the authenticator for proxy servers.
+     *
+     * <p>If unset, the {@linkplain Authenticator#NONE no authentication will be attempted}.
+     */
+    public Builder authenticator(Authenticator authenticator) {
+      if (authenticator == null) throw new NullPointerException("authenticator == null");
+      this.authenticator = authenticator;
+      return this;
+    }
+
+    /**
+     * Sets the authenticator used to respond to challenges from proxy servers. Use {@link
+     * #authenticator} to set the authenticator for origin servers.
+     *
+     * <p>If unset, the {@linkplain Authenticator#NONE no authentication will be attempted}.
+     */
+    public Builder proxyAuthenticator(Authenticator proxyAuthenticator) {
+      if (proxyAuthenticator == null) throw new NullPointerException("proxyAuthenticator == null");
+      this.proxyAuthenticator = proxyAuthenticator;
+      return this;
+    }
+
+    /**
+     * Sets the connection pool used to recycle HTTP and HTTPS connections.
+     *
+     * <p>If unset, a new connection pool will be used.
+     */
+    public Builder connectionPool(ConnectionPool connectionPool) {
+      if (connectionPool == null) throw new NullPointerException("connectionPool == null");
+      this.connectionPool = connectionPool;
+      return this;
+    }
+
+    /**
+     * Configure this client to follow redirects from HTTPS to HTTP and from HTTP to HTTPS.
+     *
+     * <p>If unset, protocol redirects will be followed. This is different than the built-in {@code
+     * HttpURLConnection}'s default.
+     */
+    public Builder followSslRedirects(boolean followProtocolRedirects) {
+      this.followSslRedirects = followProtocolRedirects;
+      return this;
+    }
+
+    /** Configure this client to follow redirects. If unset, redirects be followed. */
+    public Builder followRedirects(boolean followRedirects) {
+      this.followRedirects = followRedirects;
+      return this;
+    }
+
+    /**
+     * Configure this client to retry or not when a connectivity problem is encountered. By default,
+     * this client silently recovers from the following problems:
+     *
+     * <ul>
+     *   <li><strong>Unreachable IP addresses.</strong> If the URL's host has multiple IP addresses,
+     *       failure to reach any individual IP address doesn't fail the overall request. This can
+     *       increase availability of multi-homed services.
+     *   <li><strong>Stale pooled connections.</strong> The {@link ConnectionPool} reuses sockets
+     *       to decrease request latency, but these connections will occasionally time out.
+     *   <li><strong>Unreachable proxy servers.</strong> A {@link ProxySelector} can be used to
+     *       attempt multiple proxy servers in sequence, eventually falling back to a direct
+     *       connection.
+     * </ul>
+     *
+     * Set this to false to avoid retrying requests when doing so is destructive. In this case the
+     * calling application should do its own recovery of connectivity failures.
+     */
+    public Builder retryOnConnectionFailure(boolean retryOnConnectionFailure) {
+      this.retryOnConnectionFailure = retryOnConnectionFailure;
+      return this;
+    }
+
+    /**
+     * Sets the dispatcher used to set policy and execute asynchronous requests. Must not be null.
+     */
+    public Builder dispatcher(Dispatcher dispatcher) {
+      if (dispatcher == null) throw new IllegalArgumentException("dispatcher == null");
+      this.dispatcher = dispatcher;
+      return this;
+    }
+
+    /**
+     * Configure the protocols used by this client to communicate with remote servers. By default
+     * this client will prefer the most efficient transport available, falling back to more
+     * ubiquitous protocols. Applications should only call this method to avoid specific
+     * compatibility problems, such as web servers that behave incorrectly when SPDY is enabled.
+     *
+     * <p>The following protocols are currently supported:
+     *
+     * <ul>
+     *     <li><a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html">http/1.1</a>
+     *     <li><a
+     *         href="http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1">spdy/3.1</a>
+     *     <li><a href="http://tools.ietf.org/html/draft-ietf-httpbis-http2-17">h2</a>
+     * </ul>
+     *
+     * <p><strong>This is an evolving set.</strong> Future releases include support for transitional
+     * protocols. The http/1.1 transport will never be dropped.
+     *
+     * <p>If multiple protocols are specified, <a
+     * href="http://tools.ietf.org/html/draft-ietf-tls-applayerprotoneg">ALPN</a> will be used to
+     * negotiate a transport.
+     *
+     * <p>{@link Protocol#HTTP_1_0} is not supported in this set. Requests are initiated with {@code
+     * HTTP/1.1} only. If the server responds with {@code HTTP/1.0}, that will be exposed by {@link
+     * Response#protocol()}.
+     *
+     * @param protocols the protocols to use, in order of preference. The list must contain {@link
+     * Protocol#HTTP_1_1}. It must not contain null or {@link Protocol#HTTP_1_0}.
+     */
+    public Builder protocols(List<Protocol> protocols) {
+      protocols = Util.immutableList(protocols);
+      if (!protocols.contains(Protocol.HTTP_1_1)) {
+        throw new IllegalArgumentException("protocols doesn't contain http/1.1: " + protocols);
+      }
+      if (protocols.contains(Protocol.HTTP_1_0)) {
+        throw new IllegalArgumentException("protocols must not contain http/1.0: " + protocols);
+      }
+      if (protocols.contains(null)) {
+        throw new IllegalArgumentException("protocols must not contain null");
+      }
+      this.protocols = Util.immutableList(protocols);
+      return this;
+    }
+
+    public Builder connectionSpecs(List<ConnectionSpec> connectionSpecs) {
+      this.connectionSpecs = Util.immutableList(connectionSpecs);
+      return this;
+    }
+
+    /**
+     * Returns a modifiable list of interceptors that observe the full span of each call: from
+     * before the connection is established (if any) until after the response source is selected
+     * (either the origin server, cache, or both).
+     */
+    public List<Interceptor> interceptors() {
+      return interceptors;
+    }
+
+    public Builder addInterceptor(Interceptor interceptor) {
+      interceptors.add(interceptor);
+      return this;
+    }
+
+    /**
+     * Returns a modifiable list of interceptors that observe a single network request and response.
+     * These interceptors must call {@link Interceptor.Chain#proceed} exactly once: it is an error
+     * for a network interceptor to short-circuit or repeat a network request.
+     */
+    public List<Interceptor> networkInterceptors() {
+      return networkInterceptors;
+    }
+
+    public Builder addNetworkInterceptor(Interceptor interceptor) {
+      networkInterceptors.add(interceptor);
+      return this;
+    }
+
+    public OkHttpClient build() {
+      return new OkHttpClient(this);
+    }
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Protocol.java b/okhttp/src/main/java/okhttp3/Protocol.java
similarity index 65%
rename from okhttp/src/main/java/com/squareup/okhttp/Protocol.java
rename to okhttp/src/main/java/okhttp3/Protocol.java
index 6b02098133..eec1c1219c 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Protocol.java
+++ b/okhttp/src/main/java/okhttp3/Protocol.java
@@ -13,58 +13,51 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
 import java.io.IOException;
 
 /**
  * Protocols that OkHttp implements for <a
- * href="http://tools.ietf.org/html/draft-ietf-tls-applayerprotoneg">ALPN</a>
- * selection.
+ * href="http://tools.ietf.org/html/draft-ietf-tls-applayerprotoneg">ALPN</a> selection.
  *
- * <h3>Protocol vs Scheme</h3>
- * Despite its name, {@link java.net.URL#getProtocol()} returns the
- * {@linkplain java.net.URI#getScheme() scheme} (http, https, etc.) of the URL, not
- * the protocol (http/1.1, spdy/3.1, etc.). OkHttp uses the word <i>protocol</i>
- * to identify how HTTP messages are framed.
+ * <h3>Protocol vs Scheme</h3> Despite its name, {@link java.net.URL#getProtocol()} returns the
+ * {@linkplain java.net.URI#getScheme() scheme} (http, https, etc.) of the URL, not the protocol
+ * (http/1.1, spdy/3.1, etc.). OkHttp uses the word <i>protocol</i> to identify how HTTP messages
+ * are framed.
  */
 public enum Protocol {
   /**
-   * An obsolete plaintext framing that does not use persistent sockets by
-   * default.
+   * An obsolete plaintext framing that does not use persistent sockets by default.
    */
   HTTP_1_0("http/1.0"),
 
   /**
    * A plaintext framing that includes persistent connections.
    *
-   * <p>This version of OkHttp implements <a
-   * href="http://www.ietf.org/rfc/rfc2616.txt">RFC 2616</a>, and tracks
-   * revisions to that spec.
+   * <p>This version of OkHttp implements <a href="http://www.ietf.org/rfc/rfc2616.txt">RFC
+   * 2616</a>, and tracks revisions to that spec.
    */
   HTTP_1_1("http/1.1"),
 
   /**
-   * Chromium's binary-framed protocol that includes header compression,
-   * multiplexing multiple requests on the same socket, and server-push.
-   * HTTP/1.1 semantics are layered on SPDY/3.
+   * Chromium's binary-framed protocol that includes header compression, multiplexing multiple
+   * requests on the same socket, and server-push. HTTP/1.1 semantics are layered on SPDY/3.
    *
    * <p>This version of OkHttp implements SPDY 3 <a
-   * href="http://dev.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1">draft
-   * 3.1</a>. Future releases of OkHttp may use this identifier for a newer draft
-   * of the SPDY spec.
+   * href="http://dev.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1">draft 3.1</a>. Future
+   * releases of OkHttp may use this identifier for a newer draft of the SPDY spec.
    */
   SPDY_3("spdy/3.1"),
 
   /**
-   * The IETF's binary-framed protocol that includes header compression,
-   * multiplexing multiple requests on the same socket, and server-push.
-   * HTTP/1.1 semantics are layered on HTTP/2.
+   * The IETF's binary-framed protocol that includes header compression, multiplexing multiple
+   * requests on the same socket, and server-push. HTTP/1.1 semantics are layered on HTTP/2.
    *
-   * <p>HTTP/2 requires deployments of HTTP/2 that use TLS 1.2 support
-   * {@linkplain com.squareup.okhttp.CipherSuite#TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256}
-   * , present in Java 8+ and Android 5+. Servers that enforce this may send an
-   * exception message including the string {@code INADEQUATE_SECURITY}.
+   * <p>HTTP/2 requires deployments of HTTP/2 that use TLS 1.2 support {@linkplain
+   * CipherSuite#TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256} , present in Java 8+ and Android 5+. Servers
+   * that enforce this may send an exception message including the string {@code
+   * INADEQUATE_SECURITY}.
    */
   HTTP_2("h2");
 
@@ -76,6 +69,7 @@
 
   /**
    * Returns the protocol identified by {@code protocol}.
+   *
    * @throws IOException if {@code protocol} is unknown.
    */
   public static Protocol get(String protocol) throws IOException {
@@ -88,8 +82,8 @@ public static Protocol get(String protocol) throws IOException {
   }
 
   /**
-   * Returns the string used to identify this protocol for ALPN, like
-   * "http/1.1", "spdy/3.1" or "h2".
+   * Returns the string used to identify this protocol for ALPN, like "http/1.1", "spdy/3.1" or
+   * "h2".
    */
   @Override public String toString() {
     return protocol;
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Call.java b/okhttp/src/main/java/okhttp3/RealCall.java
similarity index 55%
rename from okhttp/src/main/java/com/squareup/okhttp/Call.java
rename to okhttp/src/main/java/okhttp3/RealCall.java
index c4742c2799..c78062dfcc 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Call.java
+++ b/okhttp/src/main/java/okhttp3/RealCall.java
@@ -13,25 +13,22 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
-import com.squareup.okhttp.internal.NamedRunnable;
-import com.squareup.okhttp.internal.http.HttpEngine;
 import java.io.IOException;
-import java.net.MalformedURLException;
+import java.net.HttpRetryException;
 import java.net.ProtocolException;
-import java.net.URL;
-import java.util.logging.Level;
+import okhttp3.internal.NamedRunnable;
+import okhttp3.internal.Platform;
+import okhttp3.internal.http.HttpEngine;
+import okhttp3.internal.http.RouteException;
+import okhttp3.internal.http.StreamAllocation;
+import okhttp3.internal.http.UnrepeatableRequestBody;
 
-import static com.squareup.okhttp.internal.Internal.logger;
-import static com.squareup.okhttp.internal.http.HttpEngine.MAX_FOLLOW_UPS;
+import static okhttp3.internal.Platform.INFO;
+import static okhttp3.internal.http.HttpEngine.MAX_FOLLOW_UPS;
 
-/**
- * A call is a request that has been prepared for execution. A call can be
- * canceled. As this object represents a single request/response pair (stream),
- * it cannot be executed twice.
- */
-public class Call {
+final class RealCall implements Call {
   private final OkHttpClient client;
 
   // Guarded by this.
@@ -42,66 +39,31 @@
   Request originalRequest;
   HttpEngine engine;
 
-  protected Call(OkHttpClient client, Request originalRequest) {
-    // Copy the client. Otherwise changes (socket factory, redirect policy,
-    // etc.) may incorrectly be reflected in the request when it is executed.
-    this.client = client.copyWithDefaults();
+  protected RealCall(OkHttpClient client, Request originalRequest) {
+    this.client = client;
     this.originalRequest = originalRequest;
   }
 
-  /**
-   * Invokes the request immediately, and blocks until the response can be
-   * processed or is in error.
-   *
-   * <p>The caller may read the response body with the response's
-   * {@link Response#body} method.  To facilitate connection recycling, callers
-   * should always {@link ResponseBody#close() close the response body}.
-   *
-   * <p>Note that transport-layer success (receiving a HTTP response code,
-   * headers and body) does not necessarily indicate application-layer success:
-   * {@code response} may still indicate an unhappy HTTP response code like 404
-   * or 500.
-   *
-   * @throws IOException if the request could not be executed due to
-   *     cancellation, a connectivity problem or timeout. Because networks can
-   *     fail during an exchange, it is possible that the remote server
-   *     accepted the request before the failure.
-   *
-   * @throws IllegalStateException when the call has already been executed.
-   */
-  public Response execute() throws IOException {
+  @Override public Request request() {
+    return originalRequest;
+  }
+
+  @Override public Response execute() throws IOException {
     synchronized (this) {
       if (executed) throw new IllegalStateException("Already Executed");
       executed = true;
     }
     try {
-      client.getDispatcher().executed(this);
+      client.dispatcher().executed(this);
       Response result = getResponseWithInterceptorChain(false);
       if (result == null) throw new IOException("Canceled");
       return result;
     } finally {
-      client.getDispatcher().finished(this);
+      client.dispatcher().finished(this);
     }
   }
 
-  Object tag() {
-    return originalRequest.tag();
-  }
-
-  /**
-   * Schedules the request to be executed at some point in the future.
-   *
-   * <p>The {@link OkHttpClient#getDispatcher dispatcher} defines when the
-   * request will run: usually immediately unless there are several other
-   * requests currently being executed.
-   *
-   * <p>This client will later call back {@code responseCallback} with either
-   * an HTTP response or a failure exception. If you {@link #cancel} a request
-   * before it completes the callback will not be invoked.
-   *
-   * @throws IllegalStateException when the call has already been executed.
-   */
-  public void enqueue(Callback responseCallback) {
+  @Override public void enqueue(Callback responseCallback) {
     enqueue(responseCallback, false);
   }
 
@@ -110,19 +72,19 @@ void enqueue(Callback responseCallback, boolean forWebSocket) {
       if (executed) throw new IllegalStateException("Already Executed");
       executed = true;
     }
-    client.getDispatcher().enqueue(new AsyncCall(responseCallback, forWebSocket));
+    client.dispatcher().enqueue(new AsyncCall(responseCallback, forWebSocket));
   }
 
-  /**
-   * Cancels the request, if possible. Requests that are already complete
-   * cannot be canceled.
-   */
-  public void cancel() {
+  @Override public void cancel() {
     canceled = true;
-    if (engine != null) engine.disconnect();
+    if (engine != null) engine.cancel();
+  }
+
+  @Override public synchronized boolean isExecuted() {
+    return executed;
   }
 
-  public boolean isCanceled() {
+  @Override public boolean isCanceled() {
     return canceled;
   }
 
@@ -131,29 +93,25 @@ public boolean isCanceled() {
     private final boolean forWebSocket;
 
     private AsyncCall(Callback responseCallback, boolean forWebSocket) {
-      super("OkHttp %s", originalRequest.urlString());
+      super("OkHttp %s", redactedUrl().toString());
       this.responseCallback = responseCallback;
       this.forWebSocket = forWebSocket;
     }
 
     String host() {
-      return originalRequest.url().getHost();
+      return originalRequest.url().host();
     }
 
     Request request() {
       return originalRequest;
     }
 
-    Object tag() {
-      return originalRequest.tag();
-    }
-
     void cancel() {
-      Call.this.cancel();
+      RealCall.this.cancel();
     }
 
-    Call get() {
-      return Call.this;
+    RealCall get() {
+      return RealCall.this;
     }
 
     @Override protected void execute() {
@@ -162,20 +120,20 @@ Call get() {
         Response response = getResponseWithInterceptorChain(forWebSocket);
         if (canceled) {
           signalledCallback = true;
-          responseCallback.onFailure(originalRequest, new IOException("Canceled"));
+          responseCallback.onFailure(RealCall.this, new IOException("Canceled"));
         } else {
           signalledCallback = true;
-          responseCallback.onResponse(response);
+          responseCallback.onResponse(RealCall.this, response);
         }
       } catch (IOException e) {
         if (signalledCallback) {
           // Do not signal the callback twice!
-          logger.log(Level.INFO, "Callback failure for " + toLoggableString(), e);
+          Platform.get().log(INFO, "Callback failure for " + toLoggableString(), e);
         } else {
-          responseCallback.onFailure(engine.getRequest(), e);
+          responseCallback.onFailure(RealCall.this, e);
         }
       } finally {
-        client.getDispatcher().finished(this);
+        client.dispatcher().finished(this);
       }
     }
   }
@@ -186,12 +144,11 @@ Call get() {
    */
   private String toLoggableString() {
     String string = canceled ? "canceled call" : "call";
-    try {
-      String redactedUrl = new URL(originalRequest.url(), "/...").toString();
-      return string + " to " + redactedUrl;
-    } catch (MalformedURLException e) {
-      return string;
-    }
+    return string + " to " + redactedUrl();
+  }
+
+  HttpUrl redactedUrl() {
+    return originalRequest.url().resolve("/...");
   }
 
   private Response getResponseWithInterceptorChain(boolean forWebSocket) throws IOException {
@@ -219,20 +176,27 @@ private Response getResponseWithInterceptorChain(boolean forWebSocket) throws IO
     }
 
     @Override public Response proceed(Request request) throws IOException {
+      // If there's another interceptor in the chain, call that.
       if (index < client.interceptors().size()) {
-        // There's another interceptor in the chain. Call that.
         Interceptor.Chain chain = new ApplicationInterceptorChain(index + 1, request, forWebSocket);
-        return client.interceptors().get(index).intercept(chain);
-      } else {
-        // No more interceptors. Do HTTP.
-        return getResponse(request, forWebSocket);
+        Interceptor interceptor = client.interceptors().get(index);
+        Response interceptedResponse = interceptor.intercept(chain);
+
+        if (interceptedResponse == null) {
+          throw new NullPointerException("application interceptor " + interceptor
+              + " returned null");
+        }
+
+        return interceptedResponse;
       }
+
+      // No more interceptors. Do HTTP.
+      return getResponse(request, forWebSocket);
     }
   }
 
   /**
-   * Performs the request and returns the response. May return null if this
-   * call was canceled.
+   * Performs the request and returns the response. May return null if this call was canceled.
    */
   Response getResponse(Request request, boolean forWebSocket) throws IOException {
     // Copy body metadata to the appropriate request headers.
@@ -258,27 +222,47 @@ Response getResponse(Request request, boolean forWebSocket) throws IOException {
     }
 
     // Create the initial HTTP engine. Retries and redirects need new engine for each attempt.
-    engine = new HttpEngine(client, request, false, false, forWebSocket, null, null, null, null);
+    engine = new HttpEngine(client, request, false, forWebSocket, null, null);
 
     int followUpCount = 0;
     while (true) {
       if (canceled) {
-        engine.releaseConnection();
-        return null;
+        engine.releaseStreamAllocation();
+        throw new IOException("Canceled");
       }
 
+      boolean releaseConnection = true;
       try {
         engine.sendRequest();
         engine.readResponse();
+        releaseConnection = false;
+      } catch (RouteException e) {
+        // The attempt to connect via a route failed. The request will not have been sent.
+        HttpEngine retryEngine = engine.recover(e.getLastConnectException(), true);
+        if (retryEngine != null) {
+          releaseConnection = false;
+          engine = retryEngine;
+          continue;
+        }
+        // Give up; recovery is not possible.
+        throw e.getLastConnectException();
       } catch (IOException e) {
-        HttpEngine retryEngine = engine.recover(e, null);
+        // An attempt to communicate with a server failed. The request may have been sent.
+        HttpEngine retryEngine = engine.recover(e, false);
         if (retryEngine != null) {
+          releaseConnection = false;
           engine = retryEngine;
           continue;
         }
 
         // Give up; recovery is not possible.
         throw e;
+      } finally {
+        // We're throwing an unchecked exception. Release any resources.
+        if (releaseConnection) {
+          StreamAllocation streamAllocation = engine.close();
+          streamAllocation.release();
+        }
       }
 
       Response response = engine.getResponse();
@@ -286,23 +270,32 @@ Response getResponse(Request request, boolean forWebSocket) throws IOException {
 
       if (followUp == null) {
         if (!forWebSocket) {
-          engine.releaseConnection();
+          engine.releaseStreamAllocation();
         }
         return response;
       }
 
+      StreamAllocation streamAllocation = engine.close();
+
       if (++followUpCount > MAX_FOLLOW_UPS) {
+        streamAllocation.release();
         throw new ProtocolException("Too many follow-up requests: " + followUpCount);
       }
 
+      if (followUp.body() instanceof UnrepeatableRequestBody) {
+        throw new HttpRetryException("Cannot retry streamed HTTP body", response.code());
+      }
+
       if (!engine.sameConnection(followUp.url())) {
-        engine.releaseConnection();
+        streamAllocation.release();
+        streamAllocation = null;
+      } else if (streamAllocation.stream() != null) {
+        throw new IllegalStateException("Closing the body of " + response
+            + " didn't close its backing stream. Bad interceptor?");
       }
 
-      Connection connection = engine.close();
       request = followUp;
-      engine = new HttpEngine(client, request, false, false, forWebSocket, connection, null, null,
-          response);
+      engine = new HttpEngine(client, request, false, forWebSocket, streamAllocation, response);
     }
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Request.java b/okhttp/src/main/java/okhttp3/Request.java
similarity index 64%
rename from okhttp/src/main/java/com/squareup/okhttp/Request.java
rename to okhttp/src/main/java/okhttp3/Request.java
index 098ee9b91a..89188ec587 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Request.java
+++ b/okhttp/src/main/java/okhttp3/Request.java
@@ -13,62 +13,35 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
-
-import com.squareup.okhttp.internal.Platform;
-import com.squareup.okhttp.internal.Util;
-import com.squareup.okhttp.internal.http.HttpMethod;
-import java.io.IOException;
-import java.net.MalformedURLException;
-import java.net.URI;
-import java.net.URISyntaxException;
+package okhttp3;
+
 import java.net.URL;
 import java.util.List;
+import okhttp3.internal.http.HttpMethod;
 
 /**
- * An HTTP request. Instances of this class are immutable if their {@link #body}
- * is null or itself immutable.
+ * An HTTP request. Instances of this class are immutable if their {@link #body} is null or itself
+ * immutable.
  */
 public final class Request {
-  private final String urlString;
+  private final HttpUrl url;
   private final String method;
   private final Headers headers;
   private final RequestBody body;
   private final Object tag;
 
-  private volatile URL url; // Lazily initialized.
-  private volatile URI uri; // Lazily initialized.
   private volatile CacheControl cacheControl; // Lazily initialized.
 
   private Request(Builder builder) {
-    this.urlString = builder.urlString;
+    this.url = builder.url;
     this.method = builder.method;
     this.headers = builder.headers.build();
     this.body = builder.body;
     this.tag = builder.tag != null ? builder.tag : this;
-    this.url = builder.url;
-  }
-
-  public URL url() {
-    try {
-      URL result = url;
-      return result != null ? result : (url = new URL(urlString));
-    } catch (MalformedURLException e) {
-      throw new RuntimeException("Malformed URL: " + urlString, e);
-    }
   }
 
-  public URI uri() throws IOException {
-    try {
-      URI result = uri;
-      return result != null ? result : (uri = Platform.get().toUriLenient(url()));
-    } catch (URISyntaxException e) {
-      throw new IOException(e.getMessage());
-    }
-  }
-
-  public String urlString() {
-    return urlString;
+  public HttpUrl url() {
+    return url;
   }
 
   public String method() {
@@ -100,8 +73,8 @@ public Builder newBuilder() {
   }
 
   /**
-   * Returns the cache control directives for this response. This is never null,
-   * even if this response contains no {@code Cache-Control} header.
+   * Returns the cache control directives for this response. This is never null, even if this
+   * response contains no {@code Cache-Control} header.
    */
   public CacheControl cacheControl() {
     CacheControl result = cacheControl;
@@ -109,22 +82,21 @@ public CacheControl cacheControl() {
   }
 
   public boolean isHttps() {
-    return url().getProtocol().equals("https");
+    return url.isHttps();
   }
 
   @Override public String toString() {
     return "Request{method="
         + method
         + ", url="
-        + urlString
+        + url
         + ", tag="
         + (tag != this ? tag : null)
         + '}';
   }
 
   public static class Builder {
-    private String urlString;
-    private URL url;
+    private HttpUrl url;
     private String method;
     private Headers.Builder headers;
     private RequestBody body;
@@ -136,7 +108,6 @@ public Builder() {
     }
 
     private Builder(Request request) {
-      this.urlString = request.urlString;
       this.url = request.url;
       this.method = request.method;
       this.body = request.body;
@@ -144,23 +115,49 @@ private Builder(Request request) {
       this.headers = request.headers.newBuilder();
     }
 
-    public Builder url(String url) {
-      if (url == null) throw new IllegalArgumentException("url == null");
-      this.urlString = url;
-      this.url = null;
+    public Builder url(HttpUrl url) {
+      if (url == null) throw new NullPointerException("url == null");
+      this.url = url;
       return this;
     }
 
+    /**
+     * Sets the URL target of this request.
+     *
+     * @throws IllegalArgumentException if {@code url} is not a valid HTTP or HTTPS URL. Avoid this
+     * exception by calling {@link HttpUrl#parse}; it returns null for invalid URLs.
+     */
+    public Builder url(String url) {
+      if (url == null) throw new NullPointerException("url == null");
+
+      // Silently replace websocket URLs with HTTP URLs.
+      if (url.regionMatches(true, 0, "ws:", 0, 3)) {
+        url = "http:" + url.substring(3);
+      } else if (url.regionMatches(true, 0, "wss:", 0, 4)) {
+        url = "https:" + url.substring(4);
+      }
+
+      HttpUrl parsed = HttpUrl.parse(url);
+      if (parsed == null) throw new IllegalArgumentException("unexpected url: " + url);
+      return url(parsed);
+    }
+
+    /**
+     * Sets the URL target of this request.
+     *
+     * @throws IllegalArgumentException if the scheme of {@code url} is not {@code http} or {@code
+     * https}.
+     */
     public Builder url(URL url) {
-      if (url == null) throw new IllegalArgumentException("url == null");
-      this.url = url;
-      this.urlString = url.toString();
-      return this;
+      if (url == null) throw new NullPointerException("url == null");
+      HttpUrl parsed = HttpUrl.get(url);
+      if (parsed == null) throw new IllegalArgumentException("unexpected url: " + url);
+      return url(parsed);
     }
 
     /**
-     * Sets the header named {@code name} to {@code value}. If this request
-     * already has any headers with that name, they are all replaced.
+     * Sets the header named {@code name} to {@code value}. If this request already has any headers
+     * with that name, they are all replaced.
      */
     public Builder header(String name, String value) {
       headers.set(name, value);
@@ -168,8 +165,11 @@ public Builder header(String name, String value) {
     }
 
     /**
-     * Adds a header with {@code name} and {@code value}. Prefer this method for
-     * multiply-valued headers like "Cookie".
+     * Adds a header with {@code name} and {@code value}. Prefer this method for multiply-valued
+     * headers like "Cookie".
+     *
+     * <p>Note that for some headers including {@code Content-Length} and {@code Content-Encoding},
+     * OkHttp may replace {@code value} with a header derived from the request body.
      */
     public Builder addHeader(String name, String value) {
       headers.add(name, value);
@@ -188,9 +188,9 @@ public Builder headers(Headers headers) {
     }
 
     /**
-     * Sets this request's {@code Cache-Control} header, replacing any cache
-     * control headers already present. If {@code cacheControl} doesn't define
-     * any directives, this clears this request's cache-control headers.
+     * Sets this request's {@code Cache-Control} header, replacing any cache control headers already
+     * present. If {@code cacheControl} doesn't define any directives, this clears this request's
+     * cache-control headers.
      */
     public Builder cacheControl(CacheControl cacheControl) {
       String value = cacheControl.toString();
@@ -215,7 +215,7 @@ public Builder delete(RequestBody body) {
     }
 
     public Builder delete() {
-      return method("DELETE", null);
+      return delete(RequestBody.create(null, new byte[0]));
     }
 
     public Builder put(RequestBody body) {
@@ -227,14 +227,13 @@ public Builder patch(RequestBody body) {
     }
 
     public Builder method(String method, RequestBody body) {
-      if (method == null || method.length() == 0) {
-        throw new IllegalArgumentException("method == null || method.length() == 0");
-      }
+      if (method == null) throw new NullPointerException("method == null");
+      if (method.length() == 0) throw new IllegalArgumentException("method.length() == 0");
       if (body != null && !HttpMethod.permitsRequestBody(method)) {
         throw new IllegalArgumentException("method " + method + " must not have a request body.");
       }
-      if (body == null && HttpMethod.permitsRequestBody(method)) {
-        body = RequestBody.create(null, Util.EMPTY_BYTE_ARRAY);
+      if (body == null && HttpMethod.requiresRequestBody(method)) {
+        throw new IllegalArgumentException("method " + method + " must have a request body.");
       }
       this.method = method;
       this.body = body;
@@ -242,9 +241,8 @@ public Builder method(String method, RequestBody body) {
     }
 
     /**
-     * Attaches {@code tag} to the request. It can be used later to cancel the
-     * request. If the tag is unspecified or null, the request is canceled by
-     * using the request itself as the tag.
+     * Attaches {@code tag} to the request. It can be used later to cancel the request. If the tag
+     * is unspecified or null, the request is canceled by using the request itself as the tag.
      */
     public Builder tag(Object tag) {
       this.tag = tag;
@@ -252,7 +250,7 @@ public Builder tag(Object tag) {
     }
 
     public Request build() {
-      if (urlString == null) throw new IllegalStateException("url == null");
+      if (url == null) throw new IllegalStateException("url == null");
       return new Request(this);
     }
   }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/RequestBody.java b/okhttp/src/main/java/okhttp3/RequestBody.java
similarity index 81%
rename from okhttp/src/main/java/com/squareup/okhttp/RequestBody.java
rename to okhttp/src/main/java/okhttp3/RequestBody.java
index 19ee211136..136cfdc4e3 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/RequestBody.java
+++ b/okhttp/src/main/java/okhttp3/RequestBody.java
@@ -13,13 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
-import com.squareup.okhttp.internal.Util;
 import java.io.File;
 import java.io.IOException;
 import java.nio.charset.Charset;
+import okhttp3.internal.Util;
 import okio.BufferedSink;
+import okio.ByteString;
 import okio.Okio;
 import okio.Source;
 
@@ -28,8 +29,8 @@
   public abstract MediaType contentType();
 
   /**
-   * Returns the number of bytes that will be written to {@code out} in a call
-   * to {@link #writeTo}, or -1 if that count is unknown.
+   * Returns the number of bytes that will be written to {@code out} in a call to {@link #writeTo},
+   * or -1 if that count is unknown.
    */
   public long contentLength() throws IOException {
     return -1;
@@ -39,8 +40,8 @@ public long contentLength() throws IOException {
   public abstract void writeTo(BufferedSink sink) throws IOException;
 
   /**
-   * Returns a new request body that transmits {@code content}. If {@code
-   * contentType} is non-null and lacks a charset, this will use UTF-8.
+   * Returns a new request body that transmits {@code content}. If {@code contentType} is non-null
+   * and lacks a charset, this will use UTF-8.
    */
   public static RequestBody create(MediaType contentType, String content) {
     Charset charset = Util.UTF_8;
@@ -55,6 +56,23 @@ public static RequestBody create(MediaType contentType, String content) {
     return create(contentType, bytes);
   }
 
+  /** Returns a new request body that transmits {@code content}. */
+  public static RequestBody create(final MediaType contentType, final ByteString content) {
+    return new RequestBody() {
+      @Override public MediaType contentType() {
+        return contentType;
+      }
+
+      @Override public long contentLength() throws IOException {
+        return content.size();
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        sink.write(content);
+      }
+    };
+  }
+
   /** Returns a new request body that transmits {@code content}. */
   public static RequestBody create(final MediaType contentType, final byte[] content) {
     return create(contentType, content, 0, content.length);
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Response.java b/okhttp/src/main/java/okhttp3/Response.java
similarity index 65%
rename from okhttp/src/main/java/com/squareup/okhttp/Response.java
rename to okhttp/src/main/java/okhttp3/Response.java
index bf52795341..4b1928404b 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Response.java
+++ b/okhttp/src/main/java/okhttp3/Response.java
@@ -13,27 +13,33 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
-import com.squareup.okhttp.internal.http.OkHeaders;
+import java.io.Closeable;
+import java.io.IOException;
 import java.util.Collections;
 import java.util.List;
+import okhttp3.internal.http.OkHeaders;
+import okio.Buffer;
+import okio.BufferedSource;
 
-import static com.squareup.okhttp.internal.http.StatusLine.HTTP_PERM_REDIRECT;
-import static com.squareup.okhttp.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
 import static java.net.HttpURLConnection.HTTP_MOVED_PERM;
 import static java.net.HttpURLConnection.HTTP_MOVED_TEMP;
 import static java.net.HttpURLConnection.HTTP_MULT_CHOICE;
 import static java.net.HttpURLConnection.HTTP_PROXY_AUTH;
 import static java.net.HttpURLConnection.HTTP_SEE_OTHER;
 import static java.net.HttpURLConnection.HTTP_UNAUTHORIZED;
+import static okhttp3.internal.http.StatusLine.HTTP_PERM_REDIRECT;
+import static okhttp3.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
 
 /**
- * An HTTP response. Instances of this class are not immutable: the response
- * body is a one-shot value that may be consumed only once. All other properties
- * are immutable.
+ * An HTTP response. Instances of this class are not immutable: the response body is a one-shot
+ * value that may be consumed only once and then closed. All other properties are immutable.
+ *
+ * <p>This class implements {@link Closeable}. Closing it simply closes its response body. See
+ * {@link ResponseBody} for an explanation and examples.
  */
-public final class Response {
+public final class Response implements Closeable {
   private final Request request;
   private final Protocol protocol;
   private final int code;
@@ -41,9 +47,11 @@
   private final Handshake handshake;
   private final Headers headers;
   private final ResponseBody body;
-  private Response networkResponse;
-  private Response cacheResponse;
+  private final Response networkResponse;
+  private final Response cacheResponse;
   private final Response priorResponse;
+  private final long sentRequestAtMillis;
+  private final long receivedResponseAtMillis;
 
   private volatile CacheControl cacheControl; // Lazily initialized.
 
@@ -58,11 +66,14 @@ private Response(Builder builder) {
     this.networkResponse = builder.networkResponse;
     this.cacheResponse = builder.cacheResponse;
     this.priorResponse = builder.priorResponse;
+    this.sentRequestAtMillis = builder.sentRequestAtMillis;
+    this.receivedResponseAtMillis = builder.receivedResponseAtMillis;
   }
 
   /**
    * The wire-level request that initiated this HTTP response. This is not
    * necessarily the same request issued by the application:
+   *
    * <ul>
    *     <li>It may be transformed by the HTTP client. For example, the client
    *         may copy headers like {@code Content-Length} from the request body.
@@ -76,8 +87,7 @@ public Request request() {
   }
 
   /**
-   * Returns the HTTP protocol, such as {@link Protocol#HTTP_1_1} or {@link
-   * Protocol#HTTP_1_0}.
+   * Returns the HTTP protocol, such as {@link Protocol#HTTP_1_1} or {@link Protocol#HTTP_1_0}.
    */
   public Protocol protocol() {
     return protocol;
@@ -89,8 +99,8 @@ public int code() {
   }
 
   /**
-   * Returns true if the code is in [200..300), which means the request was
-   * successfully received, understood, and accepted.
+   * Returns true if the code is in [200..300), which means the request was successfully received,
+   * understood, and accepted.
    */
   public boolean isSuccessful() {
     return code >= 200 && code < 300;
@@ -102,8 +112,8 @@ public String message() {
   }
 
   /**
-   * Returns the TLS handshake of the connection that carried this response, or
-   * null if the response was received without TLS.
+   * Returns the TLS handshake of the connection that carried this response, or null if the response
+   * was received without TLS.
    */
   public Handshake handshake() {
     return handshake;
@@ -126,6 +136,38 @@ public Headers headers() {
     return headers;
   }
 
+  /**
+   * Peeks up to {@code byteCount} bytes from the response body and returns them as a new response
+   * body. If fewer than {@code byteCount} bytes are in the response body, the full response body is
+   * returned. If more than {@code byteCount} bytes are in the response body, the returned value
+   * will be truncated to {@code byteCount} bytes.
+   *
+   * <p>It is an error to call this method after the body has been consumed.
+   *
+   * <p><strong>Warning:</strong> this method loads the requested bytes into memory. Most
+   * applications should set a modest limit on {@code byteCount}, such as 1 MiB.
+   */
+  public ResponseBody peekBody(long byteCount) throws IOException {
+    BufferedSource source = body.source();
+    source.request(byteCount);
+    Buffer copy = source.buffer().clone();
+
+    // There may be more than byteCount bytes in source.buffer(). If there is, return a prefix.
+    Buffer result;
+    if (copy.size() > byteCount) {
+      result = new Buffer();
+      result.write(copy, byteCount);
+      copy.clear();
+    } else {
+      result = copy;
+    }
+
+    return ResponseBody.create(body.contentType(), result.size(), result);
+  }
+
+  /**
+   * Never {@code null}, must be closed after consumption, can be consumed only once.
+   */
   public ResponseBody body() {
     return body;
   }
@@ -150,40 +192,38 @@ public boolean isRedirect() {
   }
 
   /**
-   * Returns the raw response received from the network. Will be null if this
-   * response didn't use the network, such as when the response is fully cached.
-   * The body of the returned response should not be read.
+   * Returns the raw response received from the network. Will be null if this response didn't use
+   * the network, such as when the response is fully cached. The body of the returned response
+   * should not be read.
    */
   public Response networkResponse() {
     return networkResponse;
   }
 
   /**
-   * Returns the raw response received from the cache. Will be null if this
-   * response didn't use the cache. For conditional get requests the cache
-   * response and network response may both be non-null. The body of the
-   * returned response should not be read.
+   * Returns the raw response received from the cache. Will be null if this response didn't use the
+   * cache. For conditional get requests the cache response and network response may both be
+   * non-null. The body of the returned response should not be read.
    */
   public Response cacheResponse() {
     return cacheResponse;
   }
 
   /**
-   * Returns the response for the HTTP redirect or authorization challenge that
-   * triggered this response, or null if this response wasn't triggered by an
-   * automatic retry. The body of the returned response should not be read
-   * because it has already been consumed by the redirecting client.
+   * Returns the response for the HTTP redirect or authorization challenge that triggered this
+   * response, or null if this response wasn't triggered by an automatic retry. The body of the
+   * returned response should not be read because it has already been consumed by the redirecting
+   * client.
    */
   public Response priorResponse() {
     return priorResponse;
   }
 
   /**
-   * Returns the authorization challenges appropriate for this response's code.
-   * If the response code is 401 unauthorized, this returns the
-   * "WWW-Authenticate" challenges. If the response code is 407 proxy
-   * unauthorized, this returns the "Proxy-Authenticate" challenges. Otherwise
-   * this returns an empty list of challenges.
+   * Returns the authorization challenges appropriate for this response's code. If the response code
+   * is 401 unauthorized, this returns the "WWW-Authenticate" challenges. If the response code is
+   * 407 proxy unauthorized, this returns the "Proxy-Authenticate" challenges. Otherwise this
+   * returns an empty list of challenges.
    */
   public List<Challenge> challenges() {
     String responseField;
@@ -198,14 +238,37 @@ public Response priorResponse() {
   }
 
   /**
-   * Returns the cache control directives for this response. This is never null,
-   * even if this response contains no {@code Cache-Control} header.
+   * Returns the cache control directives for this response. This is never null, even if this
+   * response contains no {@code Cache-Control} header.
    */
   public CacheControl cacheControl() {
     CacheControl result = cacheControl;
     return result != null ? result : (cacheControl = CacheControl.parse(headers));
   }
 
+  /**
+   * Returns a {@linkplain System#currentTimeMillis() timestamp} taken immediately before OkHttp
+   * transmitted the initiating request over the network. If this response is being served from the
+   * cache then this is the timestamp of the original request.
+   */
+  public long sentRequestAtMillis() {
+    return sentRequestAtMillis;
+  }
+
+  /**
+   * Returns a {@linkplain System#currentTimeMillis() timestamp} taken immediately after OkHttp
+   * received this response's headers from the network. If this response is being served from the
+   * cache then this is the timestamp of the original response.
+   */
+  public long receivedResponseAtMillis() {
+    return receivedResponseAtMillis;
+  }
+
+  /** Closes the response body. Equivalent to {@code body().close()}. */
+  @Override public void close() {
+    body.close();
+  }
+
   @Override public String toString() {
     return "Response{protocol="
         + protocol
@@ -214,7 +277,7 @@ public CacheControl cacheControl() {
         + ", message="
         + message
         + ", url="
-        + request.urlString()
+        + request.url()
         + '}';
   }
 
@@ -229,6 +292,8 @@ public CacheControl cacheControl() {
     private Response networkResponse;
     private Response cacheResponse;
     private Response priorResponse;
+    private long sentRequestAtMillis;
+    private long receivedResponseAtMillis;
 
     public Builder() {
       headers = new Headers.Builder();
@@ -245,6 +310,8 @@ private Builder(Response response) {
       this.networkResponse = response.networkResponse;
       this.cacheResponse = response.cacheResponse;
       this.priorResponse = response.priorResponse;
+      this.sentRequestAtMillis = response.sentRequestAtMillis;
+      this.receivedResponseAtMillis = response.receivedResponseAtMillis;
     }
 
     public Builder request(Request request) {
@@ -273,8 +340,8 @@ public Builder handshake(Handshake handshake) {
     }
 
     /**
-     * Sets the header named {@code name} to {@code value}. If this request
-     * already has any headers with that name, they are all replaced.
+     * Sets the header named {@code name} to {@code value}. If this request already has any headers
+     * with that name, they are all replaced.
      */
     public Builder header(String name, String value) {
       headers.set(name, value);
@@ -282,8 +349,8 @@ public Builder header(String name, String value) {
     }
 
     /**
-     * Adds a header with {@code name} and {@code value}. Prefer this method for
-     * multiply-valued headers like "Set-Cookie".
+     * Adds a header with {@code name} and {@code value}. Prefer this method for multiply-valued
+     * headers like "Set-Cookie".
      */
     public Builder addHeader(String name, String value) {
       headers.add(name, value);
@@ -342,6 +409,16 @@ private void checkPriorResponse(Response response) {
       }
     }
 
+    public Builder sentRequestAtMillis(long sentRequestAtMillis) {
+      this.sentRequestAtMillis = sentRequestAtMillis;
+      return this;
+    }
+
+    public Builder receivedResponseAtMillis(long receivedResponseAtMillis) {
+      this.receivedResponseAtMillis = receivedResponseAtMillis;
+      return this;
+    }
+
     public Response build() {
       if (request == null) throw new IllegalStateException("request == null");
       if (protocol == null) throw new IllegalStateException("protocol == null");
diff --git a/okhttp/src/main/java/okhttp3/ResponseBody.java b/okhttp/src/main/java/okhttp3/ResponseBody.java
new file mode 100644
index 0000000000..acc383be27
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/ResponseBody.java
@@ -0,0 +1,207 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.Closeable;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.Reader;
+import java.nio.charset.Charset;
+import okhttp3.internal.Util;
+import okio.Buffer;
+import okio.BufferedSource;
+
+import static okhttp3.internal.Util.UTF_8;
+
+/**
+ * A one-shot stream from the origin server to the client application with the raw bytes of the
+ * response body. Each response body is supported by an active connection to the webserver. This
+ * imposes both obligations and limits on the client application.
+ *
+ * <h3>The response body must be closed.</h3>
+ *
+ * Each response body is backed by a limited resource like a socket (live network responses) or
+ * an open file (for cached responses). Failing to close the response body will leak resources and
+ * may ultimately cause the application to slow down or crash.
+ *
+ * <p>Both this class and {@link Response} implement {@link Closeable}. Closing a response simply
+ * closes its response body. If you invoke {@link Call#execute()} or implement {@link
+ * Callback#onResponse} you must close this body by calling any of the following methods:
+ *
+ * <ul>
+ *   <li>Response.close()</li>
+ *   <li>Response.body().close()</li>
+ *   <li>Response.body().source().close()</li>
+ *   <li>Response.body().charStream().close()</li>
+ *   <li>Response.body().byteString().close()</li>
+ *   <li>Response.body().bytes()</li>
+ *   <li>Response.body().string()</li>
+ * </ul>
+ *
+ * <p>There is no benefit to invoking multiple {@code close()} methods for the same response body.
+ *
+ * <p>For synchronous calls, the easiest way to make sure a response body is closed is with a {@code
+ * try} block. With this structure the compiler inserts an implicit {@code finally} clause that
+ * calls {@code close()} for you.
+ *
+ * <pre>   {@code
+ *
+ *   Call call = client.newCall(request);
+ *   try (Response response = call.execute()) {
+ *     ... // Use the response.
+ *   }
+ * }</pre>
+ *
+ * You can use a similar block for asynchronous calls: <pre>   {@code
+ *
+ *   Call call = client.newCall(request);
+ *   call.enqueue(new Callback() {
+ *     public void onResponse(Call call, Response response) throws IOException {
+ *       try (ResponseBody responseBody = response.body()) {
+ *         ... // Use the response.
+ *       }
+ *     }
+ *
+ *     public void onFailure(Call call, IOException e) {
+ *       ... // Handle the failure.
+ *     }
+ *   });
+ * }</pre>
+ *
+ * These examples will not work if you're consuming the response body on another thread. In such
+ * cases the consuming thread must call {@link #close} when it has finished reading the response
+ * body.
+ *
+ * <h3>The response body can be consumed only once.</h3>
+ *
+ * <p>This class may be used to stream very large responses. For example, it is possible to use this
+ * class to read a response that is larger than the entire memory allocated to the current process.
+ * It can even stream a response larger than the total storage on the current device, which is a
+ * common requirement for video streaming applications.
+ *
+ * <p>Because this class does not buffer the full response in memory, the application may not
+ * re-read the bytes of the response. Use this one shot to read the entire response into memory with
+ * {@link #bytes()} or {@link #string()}. Or stream the response with either {@link #source()},
+ * {@link #byteStream()}, or {@link #charStream()}.
+ */
+public abstract class ResponseBody implements Closeable {
+  /** Multiple calls to {@link #charStream()} must return the same instance. */
+  private Reader reader;
+
+  public abstract MediaType contentType();
+
+  /**
+   * Returns the number of bytes in that will returned by {@link #bytes}, or {@link #byteStream}, or
+   * -1 if unknown.
+   */
+  public abstract long contentLength();
+
+  public final InputStream byteStream() {
+    return source().inputStream();
+  }
+
+  public abstract BufferedSource source();
+
+  public final byte[] bytes() throws IOException {
+    long contentLength = contentLength();
+    if (contentLength > Integer.MAX_VALUE) {
+      throw new IOException("Cannot buffer entire body for content length: " + contentLength);
+    }
+
+    BufferedSource source = source();
+    byte[] bytes;
+    try {
+      bytes = source.readByteArray();
+    } finally {
+      Util.closeQuietly(source);
+    }
+    if (contentLength != -1 && contentLength != bytes.length) {
+      throw new IOException("Content-Length and stream length disagree");
+    }
+    return bytes;
+  }
+
+  /**
+   * Returns the response as a character stream decoded with the charset of the Content-Type header.
+   * If that header is either absent or lacks a charset, this will attempt to decode the response
+   * body as UTF-8.
+   */
+  public final Reader charStream() {
+    Reader r = reader;
+    return r != null ? r : (reader = new InputStreamReader(byteStream(), charset()));
+  }
+
+  /**
+   * Returns the response as a string decoded with the charset of the Content-Type header. If that
+   * header is either absent or lacks a charset, this will attempt to decode the response body as
+   * UTF-8.
+   */
+  public final String string() throws IOException {
+    return new String(bytes(), charset().name());
+  }
+
+  private Charset charset() {
+    MediaType contentType = contentType();
+    return contentType != null ? contentType.charset(UTF_8) : UTF_8;
+  }
+
+  @Override public void close() {
+    Util.closeQuietly(source());
+  }
+
+  /**
+   * Returns a new response body that transmits {@code content}. If {@code contentType} is non-null
+   * and lacks a charset, this will use UTF-8.
+   */
+  public static ResponseBody create(MediaType contentType, String content) {
+    Charset charset = UTF_8;
+    if (contentType != null) {
+      charset = contentType.charset();
+      if (charset == null) {
+        charset = UTF_8;
+        contentType = MediaType.parse(contentType + "; charset=utf-8");
+      }
+    }
+    Buffer buffer = new Buffer().writeString(content, charset);
+    return create(contentType, buffer.size(), buffer);
+  }
+
+  /** Returns a new response body that transmits {@code content}. */
+  public static ResponseBody create(final MediaType contentType, byte[] content) {
+    Buffer buffer = new Buffer().write(content);
+    return create(contentType, content.length, buffer);
+  }
+
+  /** Returns a new response body that transmits {@code content}. */
+  public static ResponseBody create(
+      final MediaType contentType, final long contentLength, final BufferedSource content) {
+    if (content == null) throw new NullPointerException("source == null");
+    return new ResponseBody() {
+      @Override public MediaType contentType() {
+        return contentType;
+      }
+
+      @Override public long contentLength() {
+        return contentLength;
+      }
+
+      @Override public BufferedSource source() {
+        return content;
+      }
+    };
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Route.java b/okhttp/src/main/java/okhttp3/Route.java
similarity index 51%
rename from okhttp/src/main/java/com/squareup/okhttp/Route.java
rename to okhttp/src/main/java/okhttp3/Route.java
index f24431132f..8aaa0f5b85 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Route.java
+++ b/okhttp/src/main/java/okhttp3/Route.java
@@ -13,41 +13,32 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
 import java.net.InetSocketAddress;
 import java.net.Proxy;
 
 /**
- * The concrete route used by a connection to reach an abstract origin server.
- * When creating a connection the client has many options:
+ * The concrete route used by a connection to reach an abstract origin server. When creating a
+ * connection the client has many options:
+ *
  * <ul>
- *   <li><strong>HTTP proxy:</strong> a proxy server may be explicitly
- *       configured for the client. Otherwise the {@linkplain java.net.ProxySelector
- *       proxy selector} is used. It may return multiple proxies to attempt.
- *   <li><strong>IP address:</strong> whether connecting directly to an origin
- *       server or a proxy, opening a socket requires an IP address. The DNS
- *       server may return multiple IP addresses to attempt.
- *   <li><strong>TLS configuration:</strong> which cipher suites and TLS
- *       versions to attempt with the HTTPS connection.
+ *     <li><strong>HTTP proxy:</strong> a proxy server may be explicitly configured for the client.
+ *         Otherwise the {@linkplain java.net.ProxySelector proxy selector} is used. It may return
+ *         multiple proxies to attempt.
+ *     <li><strong>IP address:</strong> whether connecting directly to an origin server or a proxy,
+ *         opening a socket requires an IP address. The DNS server may return multiple IP addresses
+ *         to attempt.
  * </ul>
- * Each route is a specific selection of these options.
+ *
+ * <p>Each route is a specific selection of these options.
  */
 public final class Route {
   final Address address;
   final Proxy proxy;
   final InetSocketAddress inetSocketAddress;
-  final ConnectionSpec connectionSpec;
-  final boolean shouldSendTlsFallbackIndicator;
 
-  public Route(Address address, Proxy proxy, InetSocketAddress inetSocketAddress,
-      ConnectionSpec connectionSpec) {
-    this(address, proxy, inetSocketAddress, connectionSpec,
-        false /* shouldSendTlsFallbackIndicator */);
-  }
-
-  public Route(Address address, Proxy proxy, InetSocketAddress inetSocketAddress,
-      ConnectionSpec connectionSpec, boolean shouldSendTlsFallbackIndicator) {
+  public Route(Address address, Proxy proxy, InetSocketAddress inetSocketAddress) {
     if (address == null) {
       throw new NullPointerException("address == null");
     }
@@ -57,43 +48,29 @@ public Route(Address address, Proxy proxy, InetSocketAddress inetSocketAddress,
     if (inetSocketAddress == null) {
       throw new NullPointerException("inetSocketAddress == null");
     }
-    if (connectionSpec == null) {
-      throw new NullPointerException("connectionConfiguration == null");
-    }
     this.address = address;
     this.proxy = proxy;
     this.inetSocketAddress = inetSocketAddress;
-    this.connectionSpec = connectionSpec;
-    this.shouldSendTlsFallbackIndicator = shouldSendTlsFallbackIndicator;
   }
 
-  public Address getAddress() {
+  public Address address() {
     return address;
   }
 
   /**
    * Returns the {@link Proxy} of this route.
    *
-   * <strong>Warning:</strong> This may disagree with {@link Address#getProxy}
-   * when it is null. When the address's proxy is null, the proxy selector is
-   * used.
+   * <strong>Warning:</strong> This may disagree with {@link Address#proxy} when it is null. When
+   * the address's proxy is null, the proxy selector is used.
    */
-  public Proxy getProxy() {
+  public Proxy proxy() {
     return proxy;
   }
 
-  public InetSocketAddress getSocketAddress() {
+  public InetSocketAddress socketAddress() {
     return inetSocketAddress;
   }
 
-  public ConnectionSpec getConnectionSpec() {
-    return connectionSpec;
-  }
-
-  public boolean getShouldSendTlsFallbackIndicator() {
-    return shouldSendTlsFallbackIndicator;
-  }
-
   /**
    * Returns true if this route tunnels HTTPS through an HTTP proxy. See <a
    * href="http://www.ietf.org/rfc/rfc2817.txt">RFC 2817, Section 5.2</a>.
@@ -107,9 +84,7 @@ public boolean requiresTunnel() {
       Route other = (Route) obj;
       return address.equals(other.address)
           && proxy.equals(other.proxy)
-          && inetSocketAddress.equals(other.inetSocketAddress)
-          && connectionSpec.equals(other.connectionSpec)
-          && shouldSendTlsFallbackIndicator == other.shouldSendTlsFallbackIndicator;
+          && inetSocketAddress.equals(other.inetSocketAddress);
     }
     return false;
   }
@@ -119,8 +94,6 @@ public boolean requiresTunnel() {
     result = 31 * result + address.hashCode();
     result = 31 * result + proxy.hashCode();
     result = 31 * result + inetSocketAddress.hashCode();
-    result = 31 * result + connectionSpec.hashCode();
-    result = 31 * result + (shouldSendTlsFallbackIndicator ? 1 : 0);
     return result;
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/TlsVersion.java b/okhttp/src/main/java/okhttp3/TlsVersion.java
similarity index 75%
rename from okhttp/src/main/java/com/squareup/okhttp/TlsVersion.java
rename to okhttp/src/main/java/okhttp3/TlsVersion.java
index a8d7b9b311..668cd9732b 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/TlsVersion.java
+++ b/okhttp/src/main/java/okhttp3/TlsVersion.java
@@ -13,13 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
-
-import javax.net.ssl.SSLSocket;
+package okhttp3;
 
 /**
- * Versions of TLS that can be offered when negotiating a secure socket. See
- * {@link SSLSocket#setEnabledProtocols}.
+ * Versions of TLS that can be offered when negotiating a secure socket. See {@link
+ * javax.net.ssl.SSLSocket#setEnabledProtocols}.
  */
 public enum TlsVersion {
   TLS_1_2("TLSv1.2"), // 2008.
@@ -30,17 +28,25 @@
 
   final String javaName;
 
-  private TlsVersion(String javaName) {
+  TlsVersion(String javaName) {
     this.javaName = javaName;
   }
 
   public static TlsVersion forJavaName(String javaName) {
     switch (javaName) {
-      case "TLSv1.2": return TLS_1_2;
-      case "TLSv1.1": return TLS_1_1;
-      case "TLSv1": return TLS_1_0;
-      case "SSLv3": return SSL_3_0;
+      case "TLSv1.2":
+        return TLS_1_2;
+      case "TLSv1.1":
+        return TLS_1_1;
+      case "TLSv1":
+        return TLS_1_0;
+      case "SSLv3":
+        return SSL_3_0;
     }
     throw new IllegalArgumentException("Unexpected TLS version: " + javaName);
   }
+
+  public String javaName() {
+    return javaName;
+  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/AndroidPlatform.java b/okhttp/src/main/java/okhttp3/internal/AndroidPlatform.java
new file mode 100644
index 0000000000..c0096c6cd1
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/AndroidPlatform.java
@@ -0,0 +1,231 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal;
+
+import android.util.Log;
+import java.io.IOException;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.net.InetSocketAddress;
+import java.net.Socket;
+import java.security.cert.Certificate;
+import java.security.cert.X509Certificate;
+import java.util.List;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import javax.net.ssl.SSLSocket;
+import javax.net.ssl.SSLSocketFactory;
+import javax.net.ssl.X509TrustManager;
+import okhttp3.Protocol;
+import okhttp3.internal.tls.CertificateChainCleaner;
+
+/** Android 2.3 or better. */
+class AndroidPlatform extends Platform {
+  private static final int MAX_LOG_LENGTH = 4000;
+
+  private final Class<?> sslParametersClass;
+  private final OptionalMethod<Socket> setUseSessionTickets;
+  private final OptionalMethod<Socket> setHostname;
+
+  // Non-null on Android 5.0+.
+  private final OptionalMethod<Socket> getAlpnSelectedProtocol;
+  private final OptionalMethod<Socket> setAlpnProtocols;
+
+  public AndroidPlatform(Class<?> sslParametersClass, OptionalMethod<Socket> setUseSessionTickets,
+      OptionalMethod<Socket> setHostname, OptionalMethod<Socket> getAlpnSelectedProtocol,
+      OptionalMethod<Socket> setAlpnProtocols) {
+    this.sslParametersClass = sslParametersClass;
+    this.setUseSessionTickets = setUseSessionTickets;
+    this.setHostname = setHostname;
+    this.getAlpnSelectedProtocol = getAlpnSelectedProtocol;
+    this.setAlpnProtocols = setAlpnProtocols;
+  }
+
+  @Override public void connectSocket(Socket socket, InetSocketAddress address,
+      int connectTimeout) throws IOException {
+    try {
+      socket.connect(address, connectTimeout);
+    } catch (AssertionError e) {
+      if (Util.isAndroidGetsocknameError(e)) throw new IOException(e);
+      throw e;
+    } catch (SecurityException e) {
+      // Before android 4.3, socket.connect could throw a SecurityException
+      // if opening a socket resulted in an EACCES error.
+      IOException ioException = new IOException("Exception in connect");
+      ioException.initCause(e);
+      throw ioException;
+    }
+  }
+
+  @Override public X509TrustManager trustManager(SSLSocketFactory sslSocketFactory) {
+    Object context = readFieldOrNull(sslSocketFactory, sslParametersClass, "sslParameters");
+    if (context == null) {
+      // If that didn't work, try the Google Play Services SSL provider before giving up. This
+      // must be loaded by the SSLSocketFactory's class loader.
+      try {
+        Class<?> gmsSslParametersClass = Class.forName(
+            "com.google.android.gms.org.conscrypt.SSLParametersImpl", false,
+            sslSocketFactory.getClass().getClassLoader());
+        context = readFieldOrNull(sslSocketFactory, gmsSslParametersClass, "sslParameters");
+      } catch (ClassNotFoundException e) {
+        return super.trustManager(sslSocketFactory);
+      }
+    }
+
+    X509TrustManager x509TrustManager = readFieldOrNull(
+        context, X509TrustManager.class, "x509TrustManager");
+    if (x509TrustManager != null) return x509TrustManager;
+
+    return readFieldOrNull(context, X509TrustManager.class, "trustManager");
+  }
+
+  @Override public void configureTlsExtensions(
+      SSLSocket sslSocket, String hostname, List<Protocol> protocols) {
+    // Enable SNI and session tickets.
+    if (hostname != null) {
+      setUseSessionTickets.invokeOptionalWithoutCheckedException(sslSocket, true);
+      setHostname.invokeOptionalWithoutCheckedException(sslSocket, hostname);
+    }
+
+    // Enable ALPN.
+    if (setAlpnProtocols != null && setAlpnProtocols.isSupported(sslSocket)) {
+      Object[] parameters = {concatLengthPrefixed(protocols)};
+      setAlpnProtocols.invokeWithoutCheckedException(sslSocket, parameters);
+    }
+  }
+
+  @Override public String getSelectedProtocol(SSLSocket socket) {
+    if (getAlpnSelectedProtocol == null) return null;
+    if (!getAlpnSelectedProtocol.isSupported(socket)) return null;
+
+    byte[] alpnResult = (byte[]) getAlpnSelectedProtocol.invokeWithoutCheckedException(socket);
+    return alpnResult != null ? new String(alpnResult, Util.UTF_8) : null;
+  }
+
+  @Override public void log(int level, String message, Throwable t) {
+    int logLevel = level == WARN ? Log.WARN : Log.DEBUG;
+    if (t != null) message = message + '\n' + Log.getStackTraceString(t);
+
+    // Split by line, then ensure each line can fit into Log's maximum length.
+    for (int i = 0, length = message.length(); i < length; i++) {
+      int newline = message.indexOf('\n', i);
+      newline = newline != -1 ? newline : length;
+      do {
+        int end = Math.min(newline, i + MAX_LOG_LENGTH);
+        Log.println(logLevel, "OkHttp", message.substring(i, end));
+        i = end;
+      } while (i < newline);
+    }
+  }
+
+  @Override public boolean isCleartextTrafficPermitted() {
+    try {
+      Class<?> networkPolicyClass = Class.forName("android.security.NetworkSecurityPolicy");
+      Method getInstanceMethod = networkPolicyClass.getMethod("getInstance");
+      Object networkSecurityPolicy = getInstanceMethod.invoke(null);
+      Method isCleartextTrafficPermittedMethod = networkPolicyClass
+          .getMethod("isCleartextTrafficPermitted");
+      boolean cleartextPermitted = (boolean) isCleartextTrafficPermittedMethod
+          .invoke(networkSecurityPolicy);
+      return cleartextPermitted;
+    } catch (ClassNotFoundException e) {
+      return super.isCleartextTrafficPermitted();
+    } catch (NoSuchMethodException | IllegalAccessException | IllegalArgumentException
+        | InvocationTargetException e) {
+      throw new AssertionError();
+    }
+  }
+
+  public CertificateChainCleaner buildCertificateChainCleaner(X509TrustManager trustManager) {
+    try {
+      Class<?> extensionsClass = Class.forName("android.net.http.X509TrustManagerExtensions");
+      Constructor<?> constructor = extensionsClass.getConstructor(X509TrustManager.class);
+      Object extensions = constructor.newInstance(trustManager);
+      Method checkServerTrusted = extensionsClass.getMethod(
+          "checkServerTrusted", X509Certificate[].class, String.class, String.class);
+      return new AndroidCertificateChainCleaner(extensions, checkServerTrusted);
+    } catch (Exception e) {
+      return super.buildCertificateChainCleaner(trustManager);
+    }
+  }
+
+  public static Platform buildIfSupported() {
+    // Attempt to find Android 2.3+ APIs.
+    try {
+      Class<?> sslParametersClass;
+      try {
+        sslParametersClass = Class.forName("com.android.org.conscrypt.SSLParametersImpl");
+      } catch (ClassNotFoundException e) {
+        // Older platform before being unbundled.
+        sslParametersClass = Class.forName(
+            "org.apache.harmony.xnet.provider.jsse.SSLParametersImpl");
+      }
+
+      OptionalMethod<Socket> setUseSessionTickets = new OptionalMethod<>(
+          null, "setUseSessionTickets", boolean.class);
+      OptionalMethod<Socket> setHostname = new OptionalMethod<>(
+          null, "setHostname", String.class);
+      OptionalMethod<Socket> getAlpnSelectedProtocol = null;
+      OptionalMethod<Socket> setAlpnProtocols = null;
+
+      // Attempt to find Android 5.0+ APIs.
+      try {
+        Class.forName("android.net.Network"); // Arbitrary class added in Android 5.0.
+        getAlpnSelectedProtocol = new OptionalMethod<>(byte[].class, "getAlpnSelectedProtocol");
+        setAlpnProtocols = new OptionalMethod<>(null, "setAlpnProtocols", byte[].class);
+      } catch (ClassNotFoundException ignored) {
+      }
+
+      return new AndroidPlatform(sslParametersClass, setUseSessionTickets, setHostname,
+          getAlpnSelectedProtocol, setAlpnProtocols);
+    } catch (ClassNotFoundException ignored) {
+      // This isn't an Android runtime.
+    }
+
+    return null;
+  }
+
+  /**
+   * X509TrustManagerExtensions was added to Android in API 17 (Android 4.2, released in late 2012).
+   * This is the best way to get a clean chain on Android because it uses the same code as the TLS
+   * handshake.
+   */
+  static final class AndroidCertificateChainCleaner extends CertificateChainCleaner {
+    private final Object x509TrustManagerExtensions;
+    private final Method checkServerTrusted;
+
+    AndroidCertificateChainCleaner(Object x509TrustManagerExtensions, Method checkServerTrusted) {
+      this.x509TrustManagerExtensions = x509TrustManagerExtensions;
+      this.checkServerTrusted = checkServerTrusted;
+    }
+
+    @SuppressWarnings({"unchecked", "SuspiciousToArrayCall"}) // Reflection on List<Certificate>.
+    @Override public List<Certificate> clean(List<Certificate> chain, String hostname)
+        throws SSLPeerUnverifiedException {
+      try {
+        X509Certificate[] certificates = chain.toArray(new X509Certificate[chain.size()]);
+        return (List<Certificate>) checkServerTrusted.invoke(
+            x509TrustManagerExtensions, certificates, "RSA", hostname);
+      } catch (InvocationTargetException e) {
+        SSLPeerUnverifiedException exception = new SSLPeerUnverifiedException(e.getMessage());
+        exception.initCause(e);
+        throw exception;
+      } catch (IllegalAccessException e) {
+        throw new AssertionError(e);
+      }
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/ConnectionSpecSelector.java b/okhttp/src/main/java/okhttp3/internal/ConnectionSpecSelector.java
new file mode 100644
index 0000000000..1393910b1b
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/ConnectionSpecSelector.java
@@ -0,0 +1,141 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal;
+
+import java.io.IOException;
+import java.io.InterruptedIOException;
+import java.net.ProtocolException;
+import java.net.UnknownServiceException;
+import java.security.cert.CertificateException;
+import java.util.Arrays;
+import java.util.List;
+import javax.net.ssl.SSLHandshakeException;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import javax.net.ssl.SSLProtocolException;
+import javax.net.ssl.SSLSocket;
+import okhttp3.ConnectionSpec;
+
+/**
+ * Handles the connection spec fallback strategy: When a secure socket connection fails due to a
+ * handshake / protocol problem the connection may be retried with different protocols. Instances
+ * are stateful and should be created and used for a single connection attempt.
+ */
+public final class ConnectionSpecSelector {
+
+  private final List<ConnectionSpec> connectionSpecs;
+  private int nextModeIndex;
+  private boolean isFallbackPossible;
+  private boolean isFallback;
+
+  public ConnectionSpecSelector(List<ConnectionSpec> connectionSpecs) {
+    this.nextModeIndex = 0;
+    this.connectionSpecs = connectionSpecs;
+  }
+
+  /**
+   * Configures the supplied {@link SSLSocket} to connect to the specified host using an appropriate
+   * {@link ConnectionSpec}. Returns the chosen {@link ConnectionSpec}, never {@code null}.
+   *
+   * @throws IOException if the socket does not support any of the TLS modes available
+   */
+  public ConnectionSpec configureSecureSocket(SSLSocket sslSocket) throws IOException {
+    ConnectionSpec tlsConfiguration = null;
+    for (int i = nextModeIndex, size = connectionSpecs.size(); i < size; i++) {
+      ConnectionSpec connectionSpec = connectionSpecs.get(i);
+      if (connectionSpec.isCompatible(sslSocket)) {
+        tlsConfiguration = connectionSpec;
+        nextModeIndex = i + 1;
+        break;
+      }
+    }
+
+    if (tlsConfiguration == null) {
+      // This may be the first time a connection has been attempted and the socket does not support
+      // any the required protocols, or it may be a retry (but this socket supports fewer
+      // protocols than was suggested by a prior socket).
+      throw new UnknownServiceException(
+          "Unable to find acceptable protocols. isFallback=" + isFallback
+              + ", modes=" + connectionSpecs
+              + ", supported protocols=" + Arrays.toString(sslSocket.getEnabledProtocols()));
+    }
+
+    isFallbackPossible = isFallbackPossible(sslSocket);
+
+    Internal.instance.apply(tlsConfiguration, sslSocket, isFallback);
+
+    return tlsConfiguration;
+  }
+
+  /**
+   * Reports a failure to complete a connection. Determines the next {@link ConnectionSpec} to try,
+   * if any.
+   *
+   * @return {@code true} if the connection should be retried using {@link
+   * #configureSecureSocket(SSLSocket)} or {@code false} if not
+   */
+  public boolean connectionFailed(IOException e) {
+    // Any future attempt to connect using this strategy will be a fallback attempt.
+    isFallback = true;
+
+    if (!isFallbackPossible) {
+      return false;
+    }
+
+    // If there was a protocol problem, don't recover.
+    if (e instanceof ProtocolException) {
+      return false;
+    }
+
+    // If there was an interruption or timeout (SocketTimeoutException), don't recover.
+    // For the socket connect timeout case we do not try the same host with a different
+    // ConnectionSpec: we assume it is unreachable.
+    if (e instanceof InterruptedIOException) {
+      return false;
+    }
+
+    // Look for known client-side or negotiation errors that are unlikely to be fixed by trying
+    // again with a different connection spec.
+    if (e instanceof SSLHandshakeException) {
+      // If the problem was a CertificateException from the X509TrustManager,
+      // do not retry.
+      if (e.getCause() instanceof CertificateException) {
+        return false;
+      }
+    }
+    if (e instanceof SSLPeerUnverifiedException) {
+      // e.g. a certificate pinning error.
+      return false;
+    }
+
+    // On Android, SSLProtocolExceptions can be caused by TLS_FALLBACK_SCSV failures, which means we
+    // retry those when we probably should not.
+    return (e instanceof SSLHandshakeException || e instanceof SSLProtocolException);
+  }
+
+  /**
+   * Returns {@code true} if any later {@link ConnectionSpec} in the fallback strategy looks
+   * possible based on the supplied {@link SSLSocket}. It assumes that a future socket will have the
+   * same capabilities as the supplied socket.
+   */
+  private boolean isFallbackPossible(SSLSocket socket) {
+    for (int i = nextModeIndex; i < connectionSpecs.size(); i++) {
+      if (connectionSpecs.get(i).isCompatible(socket)) {
+        return true;
+      }
+    }
+    return false;
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java b/okhttp/src/main/java/okhttp3/internal/DiskLruCache.java
similarity index 81%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java
rename to okhttp/src/main/java/okhttp3/internal/DiskLruCache.java
index 284771fc34..097686bf28 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java
+++ b/okhttp/src/main/java/okhttp3/internal/DiskLruCache.java
@@ -13,14 +13,13 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+package okhttp3.internal;
 
-package com.squareup.okhttp.internal;
-
-import com.squareup.okhttp.internal.io.FileSystem;
 import java.io.Closeable;
 import java.io.EOFException;
 import java.io.File;
 import java.io.FileNotFoundException;
+import java.io.Flushable;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -33,6 +32,7 @@
 import java.util.concurrent.TimeUnit;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
+import okhttp3.internal.io.FileSystem;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -41,51 +41,49 @@
 import okio.Source;
 import okio.Timeout;
 
+import static okhttp3.internal.Platform.WARN;
+
 /**
- * A cache that uses a bounded amount of space on a filesystem. Each cache
- * entry has a string key and a fixed number of values. Each key must match
- * the regex <strong>[a-z0-9_-]{1,64}</strong>. Values are byte sequences,
- * accessible as streams or files. Each value must be between {@code 0} and
- * {@code Integer.MAX_VALUE} bytes in length.
+ * A cache that uses a bounded amount of space on a filesystem. Each cache entry has a string key
+ * and a fixed number of values. Each key must match the regex <strong>[a-z0-9_-]{1,64}</strong>.
+ * Values are byte sequences, accessible as streams or files. Each value must be between {@code 0}
+ * and {@code Integer.MAX_VALUE} bytes in length.
+ *
+ * <p>The cache stores its data in a directory on the filesystem. This directory must be exclusive
+ * to the cache; the cache may delete or overwrite files from its directory. It is an error for
+ * multiple processes to use the same cache directory at the same time.
  *
- * <p>The cache stores its data in a directory on the filesystem. This
- * directory must be exclusive to the cache; the cache may delete or overwrite
- * files from its directory. It is an error for multiple processes to use the
- * same cache directory at the same time.
+ * <p>This cache limits the number of bytes that it will store on the filesystem. When the number of
+ * stored bytes exceeds the limit, the cache will remove entries in the background until the limit
+ * is satisfied. The limit is not strict: the cache may temporarily exceed it while waiting for
+ * files to be deleted. The limit does not include filesystem overhead or the cache journal so
+ * space-sensitive applications should set a conservative limit.
  *
- * <p>This cache limits the number of bytes that it will store on the
- * filesystem. When the number of stored bytes exceeds the limit, the cache will
- * remove entries in the background until the limit is satisfied. The limit is
- * not strict: the cache may temporarily exceed it while waiting for files to be
- * deleted. The limit does not include filesystem overhead or the cache
- * journal so space-sensitive applications should set a conservative limit.
+ * <p>Clients call {@link #edit} to create or update the values of an entry. An entry may have only
+ * one editor at one time; if a value is not available to be edited then {@link #edit} will return
+ * null.
  *
- * <p>Clients call {@link #edit} to create or update the values of an entry. An
- * entry may have only one editor at one time; if a value is not available to be
- * edited then {@link #edit} will return null.
  * <ul>
- *     <li>When an entry is being <strong>created</strong> it is necessary to
- *         supply a full set of values; the empty value should be used as a
- *         placeholder if necessary.
- *     <li>When an entry is being <strong>edited</strong>, it is not necessary
- *         to supply data for every value; values default to their previous
- *         value.
+ *     <li>When an entry is being <strong>created</strong> it is necessary to supply a full set of
+ *         values; the empty value should be used as a placeholder if necessary.
+ *     <li>When an entry is being <strong>edited</strong>, it is not necessary to supply data for
+ *         every value; values default to their previous value.
  * </ul>
- * Every {@link #edit} call must be matched by a call to {@link Editor#commit}
- * or {@link Editor#abort}. Committing is atomic: a read observes the full set
- * of values as they were before or after the commit, but never a mix of values.
  *
- * <p>Clients call {@link #get} to read a snapshot of an entry. The read will
- * observe the value at the time that {@link #get} was called. Updates and
- * removals after the call do not impact ongoing reads.
+ * <p>Every {@link #edit} call must be matched by a call to {@link Editor#commit} or {@link
+ * Editor#abort}. Committing is atomic: a read observes the full set of values as they were before
+ * or after the commit, but never a mix of values.
  *
- * <p>This class is tolerant of some I/O errors. If files are missing from the
- * filesystem, the corresponding entries will be dropped from the cache. If
- * an error occurs while writing a cache value, the edit will fail silently.
- * Callers should handle other problems by catching {@code IOException} and
- * responding appropriately.
+ * <p>Clients call {@link #get} to read a snapshot of an entry. The read will observe the value at
+ * the time that {@link #get} was called. Updates and removals after the call do not impact ongoing
+ * reads.
+ *
+ * <p>This class is tolerant of some I/O errors. If files are missing from the filesystem, the
+ * corresponding entries will be dropped from the cache. If an error occurs while writing a cache
+ * value, the edit will fail silently. Callers should handle other problems by catching {@code
+ * IOException} and responding appropriately.
  */
-public final class DiskLruCache implements Closeable {
+public final class DiskLruCache implements Closeable, Flushable {
   static final String JOURNAL_FILE = "journal";
   static final String JOURNAL_FILE_TEMP = "journal.tmp";
   static final String JOURNAL_FILE_BACKUP = "journal.bkp";
@@ -155,11 +153,13 @@
   // Must be read and written when synchronized on 'this'.
   private boolean initialized;
   private boolean closed;
+  private boolean mostRecentTrimFailed;
+  private boolean mostRecentRebuildFailed;
 
   /**
-   * To differentiate between old and current snapshots, each entry is given
-   * a sequence number each time an edit is committed. A snapshot is stale if
-   * its sequence number is not equal to its entry's sequence number.
+   * To differentiate between old and current snapshots, each entry is given a sequence number each
+   * time an edit is committed. A snapshot is stale if its sequence number is not equal to its
+   * entry's sequence number.
    */
   private long nextSequenceNumber = 0;
 
@@ -171,14 +171,21 @@ public void run() {
         if (!initialized | closed) {
           return; // Nothing to do
         }
+
         try {
           trimToSize();
+        } catch (IOException ignored) {
+          mostRecentTrimFailed = true;
+        }
+
+        try {
           if (journalRebuildRequired()) {
             rebuildJournal();
             redundantOpCount = 0;
           }
         } catch (IOException e) {
-          throw new RuntimeException(e);
+          mostRecentRebuildFailed = true;
+          journalWriter = Okio.buffer(NULL_SINK);
         }
       }
     }
@@ -197,8 +204,7 @@ public void run() {
     this.executor = executor;
   }
 
-  // Visible for testing.
-  void initialize() throws IOException {
+  public synchronized void initialize() throws IOException {
     assert Thread.holdsLock(this);
 
     if (initialized) {
@@ -223,8 +229,8 @@ void initialize() throws IOException {
         initialized = true;
         return;
       } catch (IOException journalIsCorrupt) {
-        Platform.get().logW("DiskLruCache " + directory + " is corrupt: "
-            + journalIsCorrupt.getMessage() + ", removing");
+        Platform.get().log(WARN, "DiskLruCache " + directory + " is corrupt: "
+            + journalIsCorrupt.getMessage() + ", removing", journalIsCorrupt);
         delete();
         closed = false;
       }
@@ -349,8 +355,8 @@ private void readJournalLine(String line) throws IOException {
   }
 
   /**
-   * Computes the initial size and collects garbage as a part of opening the
-   * cache. Dirty entries are assumed to be inconsistent and will be deleted.
+   * Computes the initial size and collects garbage as a part of opening the cache. Dirty entries
+   * are assumed to be inconsistent and will be deleted.
    */
   private void processJournal() throws IOException {
     fileSystem.delete(journalFileTmp);
@@ -372,8 +378,8 @@ private void processJournal() throws IOException {
   }
 
   /**
-   * Creates a new journal that omits redundant information. This replaces the
-   * current journal if it exists.
+   * Creates a new journal that omits redundant information. This replaces the current journal if it
+   * exists.
    */
   private synchronized void rebuildJournal() throws IOException {
     if (journalWriter != null) {
@@ -412,12 +418,12 @@ private synchronized void rebuildJournal() throws IOException {
 
     journalWriter = newJournalWriter();
     hasJournalErrors = false;
+    mostRecentRebuildFailed = false;
   }
 
   /**
-   * Returns a snapshot of the entry named {@code key}, or null if it doesn't
-   * exist is not currently readable. If a value is returned, it is moved to
-   * the head of the LRU queue.
+   * Returns a snapshot of the entry named {@code key}, or null if it doesn't exist is not currently
+   * readable. If a value is returned, it is moved to the head of the LRU queue.
    */
   public synchronized Snapshot get(String key) throws IOException {
     initialize();
@@ -440,8 +446,7 @@ public synchronized Snapshot get(String key) throws IOException {
   }
 
   /**
-   * Returns an editor for the entry named {@code key}, or null if another
-   * edit is in progress.
+   * Returns an editor for the entry named {@code key}, or null if another edit is in progress.
    */
   public Editor edit(String key) throws IOException {
     return edit(key, ANY_SEQUENCE_NUMBER);
@@ -460,6 +465,15 @@ private synchronized Editor edit(String key, long expectedSequenceNumber) throws
     if (entry != null && entry.currentEditor != null) {
       return null; // Another edit is in progress.
     }
+    if (mostRecentTrimFailed || mostRecentRebuildFailed) {
+      // The OS has become our enemy! If the trim job failed, it means we are storing more data than
+      // requested by the user. Do not allow edits so we do not go over that limit any further. If
+      // the journal rebuild failed, the journal writer will not be active, meaning we will not be
+      // able to record the edit, causing file leaks. In both cases, we want to retry the clean up
+      // so we can get out of this state!
+      executor.execute(cleanupRunnable);
+      return null;
+    }
 
     // Flush the journal before creating files to prevent file leaks.
     journalWriter.writeUtf8(DIRTY).writeByte(' ').writeUtf8(key).writeByte('\n');
@@ -484,16 +498,15 @@ public File getDirectory() {
   }
 
   /**
-   * Returns the maximum number of bytes that this cache should use to store
-   * its data.
+   * Returns the maximum number of bytes that this cache should use to store its data.
    */
   public synchronized long getMaxSize() {
     return maxSize;
   }
 
   /**
-   * Changes the maximum number of bytes the cache can store and queues a job
-   * to trim the existing store, if necessary.
+   * Changes the maximum number of bytes the cache can store and queues a job to trim the existing
+   * store, if necessary.
    */
   public synchronized void setMaxSize(long maxSize) {
     this.maxSize = maxSize;
@@ -503,9 +516,8 @@ public synchronized void setMaxSize(long maxSize) {
   }
 
   /**
-   * Returns the number of bytes currently being used to store the values in
-   * this cache. This may be greater than the max size if a background
-   * deletion is pending.
+   * Returns the number of bytes currently being used to store the values in this cache. This may be
+   * greater than the max size if a background deletion is pending.
    */
   public synchronized long size() throws IOException {
     initialize();
@@ -573,8 +585,8 @@ private synchronized void completeEdit(Editor editor, boolean success) throws IO
   }
 
   /**
-   * We only rebuild the journal when it will halve the size of the journal
-   * and eliminate at least 2000 ops.
+   * We only rebuild the journal when it will halve the size of the journal and eliminate at least
+   * 2000 ops.
    */
   private boolean journalRebuildRequired() {
     final int redundantOpCompactThreshold = 2000;
@@ -583,9 +595,8 @@ private boolean journalRebuildRequired() {
   }
 
   /**
-   * Drops the entry for {@code key} if it exists and can be removed. If the
-   * entry for {@code key} is currently being edited, that edit will complete
-   * normally but its value will not be stored.
+   * Drops the entry for {@code key} if it exists and can be removed. If the entry for {@code key}
+   * is currently being edited, that edit will complete normally but its value will not be stored.
    *
    * @return true if an entry was removed.
    */
@@ -596,12 +607,14 @@ public synchronized boolean remove(String key) throws IOException {
     validateKey(key);
     Entry entry = lruEntries.get(key);
     if (entry == null) return false;
-    return removeEntry(entry);
+    boolean removed = removeEntry(entry);
+    if (removed && size <= maxSize) mostRecentTrimFailed = false;
+    return removed;
   }
 
   private boolean removeEntry(Entry entry) throws IOException {
     if (entry.currentEditor != null) {
-      entry.currentEditor.hasErrors = true; // Prevent the edit from completing normally.
+      entry.currentEditor.detach(); // Prevent the edit from completing normally.
     }
 
     for (int i = 0; i < valueCount; i++) {
@@ -633,7 +646,7 @@ private synchronized void checkNotClosed() {
   }
 
   /** Force buffered operations to the filesystem. */
-  public synchronized void flush() throws IOException {
+  @Override public synchronized void flush() throws IOException {
     if (!initialized) return;
 
     checkNotClosed();
@@ -642,7 +655,7 @@ public synchronized void flush() throws IOException {
   }
 
   /** Closes this cache. Stored values will remain on the filesystem. */
-  public synchronized void close() throws IOException {
+  @Override public synchronized void close() throws IOException {
     if (!initialized || closed) {
       closed = true;
       return;
@@ -664,12 +677,12 @@ private void trimToSize() throws IOException {
       Entry toEvict = lruEntries.values().iterator().next();
       removeEntry(toEvict);
     }
+    mostRecentTrimFailed = false;
   }
 
   /**
-   * Closes the cache and deletes all of its stored values. This will delete
-   * all files in the cache directory including files that weren't created by
-   * the cache.
+   * Closes the cache and deletes all of its stored values. This will delete all files in the cache
+   * directory including files that weren't created by the cache.
    */
   public void delete() throws IOException {
     close();
@@ -677,8 +690,8 @@ public void delete() throws IOException {
   }
 
   /**
-   * Deletes all stored values from the cache. In-flight edits will complete
-   * normally but their values will not be stored.
+   * Deletes all stored values from the cache. In-flight edits will complete normally but their
+   * values will not be stored.
    */
   public synchronized void evictAll() throws IOException {
     initialize();
@@ -686,6 +699,7 @@ public synchronized void evictAll() throws IOException {
     for (Entry entry : lruEntries.values().toArray(new Entry[lruEntries.size()])) {
       removeEntry(entry);
     }
+    mostRecentTrimFailed = false;
   }
 
   private void validateKey(String key) {
@@ -782,9 +796,8 @@ public String key() {
     }
 
     /**
-     * Returns an editor for this snapshot's entry, or null if either the
-     * entry has changed since this snapshot was created or if another edit
-     * is in progress.
+     * Returns an editor for this snapshot's entry, or null if either the entry has changed since
+     * this snapshot was created or if another edit is in progress.
      */
     public Editor edit() throws IOException {
       return DiskLruCache.this.edit(key, sequenceNumber);
@@ -827,8 +840,7 @@ public void close() {
   public final class Editor {
     private final Entry entry;
     private final boolean[] written;
-    private boolean hasErrors;
-    private boolean committed;
+    private boolean done;
 
     private Editor(Entry entry) {
       this.entry = entry;
@@ -836,15 +848,34 @@ private Editor(Entry entry) {
     }
 
     /**
-     * Returns an unbuffered input stream to read the last committed value,
-     * or null if no value has been committed.
+     * Prevents this editor from completing normally. This is necessary either when the edit causes
+     * an I/O error, or if the target entry is evicted while this editor is active. In either case
+     * we delete the editor's created files and prevent new files from being created. Note that once
+     * an editor has been detached it is possible for another editor to edit the entry.
+     */
+    void detach() {
+      if (entry.currentEditor == this) {
+        for (int i = 0; i < valueCount; i++) {
+          try {
+            fileSystem.delete(entry.dirtyFiles[i]);
+          } catch (IOException e) {
+            // This file is potentially leaked. Not much we can do about that.
+          }
+        }
+        entry.currentEditor = null;
+      }
+    }
+
+    /**
+     * Returns an unbuffered input stream to read the last committed value, or null if no value has
+     * been committed.
      */
     public Source newSource(int index) throws IOException {
       synchronized (DiskLruCache.this) {
-        if (entry.currentEditor != this) {
+        if (done) {
           throw new IllegalStateException();
         }
-        if (!entry.readable) {
+        if (!entry.readable || entry.currentEditor != this) {
           return null;
         }
         try {
@@ -856,17 +887,18 @@ public Source newSource(int index) throws IOException {
     }
 
     /**
-     * Returns a new unbuffered output stream to write the value at
-     * {@code index}. If the underlying output stream encounters errors
-     * when writing to the filesystem, this edit will be aborted when
-     * {@link #commit} is called. The returned output stream does not throw
-     * IOExceptions.
+     * Returns a new unbuffered output stream to write the value at {@code index}. If the underlying
+     * output stream encounters errors when writing to the filesystem, this edit will be aborted
+     * when {@link #commit} is called. The returned output stream does not throw IOExceptions.
      */
     public Sink newSink(int index) throws IOException {
       synchronized (DiskLruCache.this) {
-        if (entry.currentEditor != this) {
+        if (done) {
           throw new IllegalStateException();
         }
+        if (entry.currentEditor != this) {
+          return NULL_SINK;
+        }
         if (!entry.readable) {
           written[index] = true;
         }
@@ -880,7 +912,7 @@ public Sink newSink(int index) throws IOException {
         return new FaultHidingSink(sink) {
           @Override protected void onException(IOException e) {
             synchronized (DiskLruCache.this) {
-              hasErrors = true;
+              detach();
             }
           }
         };
@@ -888,34 +920,40 @@ public Sink newSink(int index) throws IOException {
     }
 
     /**
-     * Commits this edit so it is visible to readers.  This releases the
-     * edit lock so another edit may be started on the same key.
+     * Commits this edit so it is visible to readers.  This releases the edit lock so another edit
+     * may be started on the same key.
      */
     public void commit() throws IOException {
       synchronized (DiskLruCache.this) {
-        if (hasErrors) {
-          completeEdit(this, false);
-          removeEntry(entry); // The previous entry is stale.
-        } else {
+        if (done) {
+          throw new IllegalStateException();
+        }
+        if (entry.currentEditor == this) {
           completeEdit(this, true);
         }
-        committed = true;
+        done = true;
       }
     }
 
     /**
-     * Aborts this edit. This releases the edit lock so another edit may be
-     * started on the same key.
+     * Aborts this edit. This releases the edit lock so another edit may be started on the same
+     * key.
      */
     public void abort() throws IOException {
       synchronized (DiskLruCache.this) {
-        completeEdit(this, false);
+        if (done) {
+          throw new IllegalStateException();
+        }
+        if (entry.currentEditor == this) {
+          completeEdit(this, false);
+        }
+        done = true;
       }
     }
 
     public void abortUnlessCommitted() {
       synchronized (DiskLruCache.this) {
-        if (!committed) {
+        if (!done && entry.currentEditor == this) {
           try {
             completeEdit(this, false);
           } catch (IOException ignored) {
@@ -1011,6 +1049,12 @@ Snapshot snapshot() {
             break;
           }
         }
+        // Since the entry is no longer valid, remove it so the metadata is accurate (i.e. the cache
+        // size.)
+        try {
+          removeEntry(this);
+        } catch (IOException ignored) {
+        }
         return null;
       }
     }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/FaultHidingSink.java b/okhttp/src/main/java/okhttp3/internal/FaultHidingSink.java
similarity index 62%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/FaultHidingSink.java
rename to okhttp/src/main/java/okhttp3/internal/FaultHidingSink.java
index 91e990db8d..e77f6bb448 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/FaultHidingSink.java
+++ b/okhttp/src/main/java/okhttp3/internal/FaultHidingSink.java
@@ -1,4 +1,19 @@
-package com.squareup.okhttp.internal;
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal;
 
 import java.io.IOException;
 import okio.Buffer;
diff --git a/okhttp/src/main/java/okhttp3/internal/Internal.java b/okhttp/src/main/java/okhttp3/internal/Internal.java
new file mode 100644
index 0000000000..5ed594eacf
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/Internal.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal;
+
+import java.net.MalformedURLException;
+import java.net.UnknownHostException;
+import javax.net.ssl.SSLSocket;
+import okhttp3.Address;
+import okhttp3.Call;
+import okhttp3.Callback;
+import okhttp3.ConnectionPool;
+import okhttp3.ConnectionSpec;
+import okhttp3.Headers;
+import okhttp3.HttpUrl;
+import okhttp3.OkHttpClient;
+import okhttp3.internal.http.StreamAllocation;
+import okhttp3.internal.io.RealConnection;
+
+/**
+ * Escalate internal APIs in {@code okhttp3} so they can be used from OkHttp's implementation
+ * packages. The only implementation of this interface is in {@link OkHttpClient}.
+ */
+public abstract class Internal {
+
+  public static void initializeInstanceForTests() {
+    // Needed in tests to ensure that the instance is actually pointing to something.
+    new OkHttpClient();
+  }
+
+  public static Internal instance;
+
+  public abstract void addLenient(Headers.Builder builder, String line);
+
+  public abstract void addLenient(Headers.Builder builder, String name, String value);
+
+  public abstract void setCache(OkHttpClient.Builder builder, InternalCache internalCache);
+
+  public abstract InternalCache internalCache(OkHttpClient client);
+
+  public abstract RealConnection get(
+      ConnectionPool pool, Address address, StreamAllocation streamAllocation);
+
+  public abstract void put(ConnectionPool pool, RealConnection connection);
+
+  public abstract boolean connectionBecameIdle(ConnectionPool pool, RealConnection connection);
+
+  public abstract RouteDatabase routeDatabase(ConnectionPool connectionPool);
+
+  public abstract void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket,
+      boolean isFallback);
+
+  public abstract HttpUrl getHttpUrlChecked(String url)
+      throws MalformedURLException, UnknownHostException;
+
+  // TODO delete the following when web sockets move into the main package.
+  public abstract void callEnqueue(Call call, Callback responseCallback, boolean forWebSocket);
+
+  public abstract StreamAllocation callEngineGetStreamAllocation(Call call);
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/InternalCache.java b/okhttp/src/main/java/okhttp3/internal/InternalCache.java
similarity index 70%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/InternalCache.java
rename to okhttp/src/main/java/okhttp3/internal/InternalCache.java
index 4925358225..9752002bc5 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/InternalCache.java
+++ b/okhttp/src/main/java/okhttp3/internal/InternalCache.java
@@ -13,17 +13,17 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal;
+package okhttp3.internal;
 
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
-import com.squareup.okhttp.internal.http.CacheRequest;
-import com.squareup.okhttp.internal.http.CacheStrategy;
 import java.io.IOException;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.internal.http.CacheRequest;
+import okhttp3.internal.http.CacheStrategy;
 
 /**
- * OkHttp's internal cache interface. Applications shouldn't implement this:
- * instead use {@link com.squareup.okhttp.Cache}.
+ * OkHttp's internal cache interface. Applications shouldn't implement this: instead use {@link
+ * okhttp3.Cache}.
  */
 public interface InternalCache {
   Response get(Request request) throws IOException;
@@ -31,16 +31,15 @@
   CacheRequest put(Response response) throws IOException;
 
   /**
-   * Remove any cache entries for the supplied {@code request}. This is invoked
-   * when the client invalidates the cache, such as when making POST requests.
+   * Remove any cache entries for the supplied {@code request}. This is invoked when the client
+   * invalidates the cache, such as when making POST requests.
    */
   void remove(Request request) throws IOException;
 
   /**
-   * Handles a conditional request hit by updating the stored cache response
-   * with the headers from {@code network}. The cached response body is not
-   * updated. If the stored response has changed since {@code cached} was
-   * returned, this does nothing.
+   * Handles a conditional request hit by updating the stored cache response with the headers from
+   * {@code network}. The cached response body is not updated. If the stored response has changed
+   * since {@code cached} was returned, this does nothing.
    */
   void update(Response cached, Response network) throws IOException;
 
diff --git a/okhttp/src/main/java/okhttp3/internal/Jdk9Platform.java b/okhttp/src/main/java/okhttp3/internal/Jdk9Platform.java
new file mode 100644
index 0000000000..1cd04f965a
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/Jdk9Platform.java
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.util.List;
+import javax.net.ssl.SSLParameters;
+import javax.net.ssl.SSLSocket;
+import javax.net.ssl.SSLSocketFactory;
+import javax.net.ssl.X509TrustManager;
+import okhttp3.Protocol;
+
+/**
+ * OpenJDK 9+.
+ */
+final class Jdk9Platform extends Platform {
+  final Method setProtocolMethod;
+  final Method getProtocolMethod;
+
+  public Jdk9Platform(Method setProtocolMethod, Method getProtocolMethod) {
+    this.setProtocolMethod = setProtocolMethod;
+    this.getProtocolMethod = getProtocolMethod;
+  }
+
+  @Override
+  public void configureTlsExtensions(SSLSocket sslSocket, String hostname,
+      List<Protocol> protocols) {
+    try {
+      SSLParameters sslParameters = sslSocket.getSSLParameters();
+
+      List<String> names = alpnProtocolNames(protocols);
+
+      setProtocolMethod.invoke(sslParameters,
+          new Object[] {names.toArray(new String[names.size()])});
+
+      sslSocket.setSSLParameters(sslParameters);
+    } catch (IllegalAccessException | InvocationTargetException e) {
+      throw new AssertionError();
+    }
+  }
+
+  @Override
+  public String getSelectedProtocol(SSLSocket socket) {
+    try {
+      String protocol = (String) getProtocolMethod.invoke(socket);
+
+      // SSLSocket.getApplicationProtocol returns "" if application protocols values will not
+      // be used. Observed if you didn't specify SSLParameters.setApplicationProtocols
+      if (protocol == null || protocol.equals("")) {
+        return null;
+      }
+
+      return protocol;
+    } catch (IllegalAccessException | InvocationTargetException e) {
+      throw new AssertionError();
+    }
+  }
+
+  @Override public X509TrustManager trustManager(SSLSocketFactory sslSocketFactory) {
+    // Not supported due to access checks on JDK 9+:
+    // java.lang.reflect.InaccessibleObjectException: Unable to make member of class
+    // sun.security.ssl.SSLSocketFactoryImpl accessible:  module java.base does not export
+    // sun.security.ssl to unnamed module @xxx
+    throw new UnsupportedOperationException(
+        "clientBuilder.sslSocketFactory(SSLSocketFactory) not supported on JDK 9+");
+  }
+
+  public static Jdk9Platform buildIfSupported() {
+    // Find JDK 9 new methods
+    try {
+      Method setProtocolMethod =
+          SSLParameters.class.getMethod("setApplicationProtocols", String[].class);
+      Method getProtocolMethod = SSLSocket.class.getMethod("getApplicationProtocol");
+
+      return new Jdk9Platform(setProtocolMethod, getProtocolMethod);
+    } catch (NoSuchMethodException ignored) {
+      // pre JDK 9
+    }
+
+    return null;
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/JdkWithJettyBootPlatform.java b/okhttp/src/main/java/okhttp3/internal/JdkWithJettyBootPlatform.java
new file mode 100644
index 0000000000..5e5e5a43f6
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/JdkWithJettyBootPlatform.java
@@ -0,0 +1,148 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal;
+
+import java.lang.reflect.InvocationHandler;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.lang.reflect.Proxy;
+import java.util.List;
+import javax.net.ssl.SSLSocket;
+import okhttp3.Protocol;
+
+/**
+ * OpenJDK 7 or OpenJDK 8 with {@code org.mortbay.jetty.alpn/alpn-boot} in the boot class path.
+ */
+class JdkWithJettyBootPlatform extends Platform {
+  private final Method putMethod;
+  private final Method getMethod;
+  private final Method removeMethod;
+  private final Class<?> clientProviderClass;
+  private final Class<?> serverProviderClass;
+
+  public JdkWithJettyBootPlatform(Method putMethod, Method getMethod, Method removeMethod,
+      Class<?> clientProviderClass, Class<?> serverProviderClass) {
+    this.putMethod = putMethod;
+    this.getMethod = getMethod;
+    this.removeMethod = removeMethod;
+    this.clientProviderClass = clientProviderClass;
+    this.serverProviderClass = serverProviderClass;
+  }
+
+  @Override public void configureTlsExtensions(
+      SSLSocket sslSocket, String hostname, List<Protocol> protocols) {
+    List<String> names = alpnProtocolNames(protocols);
+
+    try {
+      Object provider = Proxy.newProxyInstance(Platform.class.getClassLoader(),
+          new Class[] {clientProviderClass, serverProviderClass}, new JettyNegoProvider(names));
+      putMethod.invoke(null, sslSocket, provider);
+    } catch (InvocationTargetException | IllegalAccessException e) {
+      throw new AssertionError(e);
+    }
+  }
+
+  @Override public void afterHandshake(SSLSocket sslSocket) {
+    try {
+      removeMethod.invoke(null, sslSocket);
+    } catch (IllegalAccessException | InvocationTargetException ignored) {
+      throw new AssertionError();
+    }
+  }
+
+  @Override public String getSelectedProtocol(SSLSocket socket) {
+    try {
+      JettyNegoProvider provider =
+          (JettyNegoProvider) Proxy.getInvocationHandler(getMethod.invoke(null, socket));
+      if (!provider.unsupported && provider.selected == null) {
+        Platform.get().log(INFO, "ALPN callback dropped: SPDY and HTTP/2 are disabled. "
+            + "Is alpn-boot on the boot class path?", null);
+        return null;
+      }
+      return provider.unsupported ? null : provider.selected;
+    } catch (InvocationTargetException | IllegalAccessException e) {
+      throw new AssertionError();
+    }
+  }
+
+  public static Platform buildIfSupported() {
+    // Find Jetty's ALPN extension for OpenJDK.
+    try {
+      String negoClassName = "org.eclipse.jetty.alpn.ALPN";
+      Class<?> negoClass = Class.forName(negoClassName);
+      Class<?> providerClass = Class.forName(negoClassName + "$Provider");
+      Class<?> clientProviderClass = Class.forName(negoClassName + "$ClientProvider");
+      Class<?> serverProviderClass = Class.forName(negoClassName + "$ServerProvider");
+      Method putMethod = negoClass.getMethod("put", SSLSocket.class, providerClass);
+      Method getMethod = negoClass.getMethod("get", SSLSocket.class);
+      Method removeMethod = negoClass.getMethod("remove", SSLSocket.class);
+      return new JdkWithJettyBootPlatform(
+          putMethod, getMethod, removeMethod, clientProviderClass, serverProviderClass);
+    } catch (ClassNotFoundException | NoSuchMethodException ignored) {
+    }
+
+    return null;
+  }
+
+  /**
+   * Handle the methods of ALPN's ClientProvider and ServerProvider without a compile-time
+   * dependency on those interfaces.
+   */
+  private static class JettyNegoProvider implements InvocationHandler {
+    /** This peer's supported protocols. */
+    private final List<String> protocols;
+    /** Set when remote peer notifies ALPN is unsupported. */
+    private boolean unsupported;
+    /** The protocol the server selected. */
+    private String selected;
+
+    public JettyNegoProvider(List<String> protocols) {
+      this.protocols = protocols;
+    }
+
+    @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
+      String methodName = method.getName();
+      Class<?> returnType = method.getReturnType();
+      if (args == null) {
+        args = Util.EMPTY_STRING_ARRAY;
+      }
+      if (methodName.equals("supports") && boolean.class == returnType) {
+        return true; // ALPN is supported.
+      } else if (methodName.equals("unsupported") && void.class == returnType) {
+        this.unsupported = true; // Peer doesn't support ALPN.
+        return null;
+      } else if (methodName.equals("protocols") && args.length == 0) {
+        return protocols; // Client advertises these protocols.
+      } else if ((methodName.equals("selectProtocol") || methodName.equals("select"))
+          && String.class == returnType && args.length == 1 && args[0] instanceof List) {
+        List<String> peerProtocols = (List) args[0];
+        // Pick the first known protocol the peer advertises.
+        for (int i = 0, size = peerProtocols.size(); i < size; i++) {
+          if (protocols.contains(peerProtocols.get(i))) {
+            return selected = peerProtocols.get(i);
+          }
+        }
+        return selected = protocols.get(0); // On no intersection, try peer's first protocol.
+      } else if ((methodName.equals("protocolSelected") || methodName.equals("selected"))
+          && args.length == 1) {
+        this.selected = (String) args[0]; // Server selected this protocol.
+        return null;
+      } else {
+        return method.invoke(this, args);
+      }
+    }
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/NamedRunnable.java b/okhttp/src/main/java/okhttp3/internal/NamedRunnable.java
similarity index 92%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/NamedRunnable.java
rename to okhttp/src/main/java/okhttp3/internal/NamedRunnable.java
index 7a02ecfbde..ff9729e2af 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/NamedRunnable.java
+++ b/okhttp/src/main/java/okhttp3/internal/NamedRunnable.java
@@ -13,8 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
-package com.squareup.okhttp.internal;
+package okhttp3.internal;
 
 /**
  * Runnable implementation which always sets its thread name.
@@ -23,7 +22,7 @@
   protected final String name;
 
   public NamedRunnable(String format, Object... args) {
-    this.name = String.format(format, args);
+    this.name = Util.format(format, args);
   }
 
   @Override public final void run() {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/OptionalMethod.java b/okhttp/src/main/java/okhttp3/internal/OptionalMethod.java
similarity index 88%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/OptionalMethod.java
rename to okhttp/src/main/java/okhttp3/internal/OptionalMethod.java
index 21b31cc491..108ec292d1 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/OptionalMethod.java
+++ b/okhttp/src/main/java/okhttp3/internal/OptionalMethod.java
@@ -15,7 +15,7 @@
  *  limitations under the License.
  */
 
-package com.squareup.okhttp.internal;
+package okhttp3.internal;
 
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
@@ -57,8 +57,7 @@ public boolean isSupported(T target) {
 
   /**
    * Invokes the method on {@code target} with {@code args}. If the method does not exist or is not
-   * public then {@code null} is returned. See also
-   * {@link #invokeOptionalWithoutCheckedException(Object, Object...)}.
+   * public then {@code null} is returned. See also {@link #invokeOptionalWithoutCheckedException}.
    *
    * @throws IllegalArgumentException if the arguments are invalid
    * @throws InvocationTargetException if the invocation throws an exception
@@ -76,9 +75,9 @@ public Object invokeOptional(T target, Object... args) throws InvocationTargetEx
   }
 
   /**
-   * Invokes the method on {@code target}.  If the method does not exist or is not
-   * public then {@code null} is returned. Any RuntimeException thrown by the method is thrown,
-   * checked exceptions are wrapped in an {@link AssertionError}.
+   * Invokes the method on {@code target}.  If the method does not exist or is not public then
+   * {@code null} is returned. Any RuntimeException thrown by the method is thrown, checked
+   * exceptions are wrapped in an {@link AssertionError}.
    *
    * @throws IllegalArgumentException if the arguments are invalid
    */
@@ -120,8 +119,8 @@ public Object invoke(T target, Object... args) throws InvocationTargetException
 
   /**
    * Invokes the method on {@code target}. Throws an error if the method is not supported. Any
-   * RuntimeException thrown by the method is thrown, checked exceptions are wrapped in
-   * an {@link AssertionError}.
+   * RuntimeException thrown by the method is thrown, checked exceptions are wrapped in an {@link
+   * AssertionError}.
    *
    * @throws IllegalArgumentException if the arguments are invalid
    */
@@ -140,10 +139,9 @@ public Object invokeWithoutCheckedException(T target, Object... args) {
   }
 
   /**
-   * Perform a lookup for the method. No caching.
-   * In order to return a method the method name and arguments must match those specified when
-   * the {@link OptionalMethod} was created. If the return type is specified (i.e. non-null) it
-   * must also be compatible. The method must also be public.
+   * Perform a lookup for the method. No caching. In order to return a method the method name and
+   * arguments must match those specified when the {@link OptionalMethod} was created. If the return
+   * type is specified (i.e. non-null) it must also be compatible. The method must also be public.
    */
   private Method getMethod(Class<?> clazz) {
     Method method = null;
diff --git a/okhttp/src/main/java/okhttp3/internal/Platform.java b/okhttp/src/main/java/okhttp3/internal/Platform.java
new file mode 100644
index 0000000000..1245b6328c
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/Platform.java
@@ -0,0 +1,211 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal;
+
+import java.io.IOException;
+import java.lang.reflect.Field;
+import java.net.InetSocketAddress;
+import java.net.Socket;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import javax.net.ssl.SSLSocket;
+import javax.net.ssl.SSLSocketFactory;
+import javax.net.ssl.X509TrustManager;
+import okhttp3.OkHttpClient;
+import okhttp3.Protocol;
+import okhttp3.internal.tls.BasicCertificateChainCleaner;
+import okhttp3.internal.tls.CertificateChainCleaner;
+import okhttp3.internal.tls.TrustRootIndex;
+import okio.Buffer;
+
+/**
+ * Access to platform-specific features.
+ *
+ * <h3>Server name indication (SNI)</h3>
+ *
+ * <p>Supported on Android 2.3+.
+ *
+ * Supported on OpenJDK 7+
+ *
+ * <h3>Session Tickets</h3>
+ *
+ * <p>Supported on Android 2.3+.
+ *
+ * <h3>Android Traffic Stats (Socket Tagging)</h3>
+ *
+ * <p>Supported on Android 4.0+.
+ *
+ * <h3>ALPN (Application Layer Protocol Negotiation)</h3>
+ *
+ * <p>Supported on Android 5.0+. The APIs were present in Android 4.4, but that implementation was
+ * unstable.
+ *
+ * Supported on OpenJDK 7 and 8 (via the JettyALPN-boot library).
+ *
+ * Supported on OpenJDK 9 via SSLParameters and SSLSocket features.
+ *
+ * <h3>Trust Manager Extraction</h3>
+ *
+ * <p>Supported on Android 2.3+ and OpenJDK 7+. There are no public APIs to recover the trust
+ * manager that was used to create an {@link SSLSocketFactory}.
+ *
+ * <h3>Android Cleartext Permit Detection</h3>
+ *
+ * <p>Supported on Android 6.0+ via {@code NetworkSecurityPolicy}.
+ */
+public class Platform {
+  private static final Platform PLATFORM = findPlatform();
+  public static final int INFO = 4;
+  public static final int WARN = 5;
+  private static final Logger logger = Logger.getLogger(OkHttpClient.class.getName());
+
+  public static Platform get() {
+    return PLATFORM;
+  }
+
+  /** Prefix used on custom headers. */
+  public String getPrefix() {
+    return "OkHttp";
+  }
+
+  public X509TrustManager trustManager(SSLSocketFactory sslSocketFactory) {
+    // Attempt to get the trust manager from an OpenJDK socket factory. We attempt this on all
+    // platforms in order to support Robolectric, which mixes classes from both Android and the
+    // Oracle JDK. Note that we don't support HTTP/2 or other nice features on Robolectric.
+    try {
+      Class<?> sslContextClass = Class.forName("sun.security.ssl.SSLContextImpl");
+      Object context = readFieldOrNull(sslSocketFactory, sslContextClass, "context");
+      if (context == null) return null;
+      return readFieldOrNull(context, X509TrustManager.class, "trustManager");
+    } catch (ClassNotFoundException e) {
+      return null;
+    }
+  }
+
+  /**
+   * Configure TLS extensions on {@code sslSocket} for {@code route}.
+   *
+   * @param hostname non-null for client-side handshakes; null for server-side handshakes.
+   */
+  public void configureTlsExtensions(SSLSocket sslSocket, String hostname,
+      List<Protocol> protocols) {
+  }
+
+  /**
+   * Called after the TLS handshake to release resources allocated by {@link
+   * #configureTlsExtensions}.
+   */
+  public void afterHandshake(SSLSocket sslSocket) {
+  }
+
+  /** Returns the negotiated protocol, or null if no protocol was negotiated. */
+  public String getSelectedProtocol(SSLSocket socket) {
+    return null;
+  }
+
+  public void connectSocket(Socket socket, InetSocketAddress address,
+      int connectTimeout) throws IOException {
+    socket.connect(address, connectTimeout);
+  }
+
+  public void log(int level, String message, Throwable t) {
+    Level logLevel = level == WARN ? Level.WARNING : Level.INFO;
+    logger.log(logLevel, message, t);
+  }
+
+  public boolean isCleartextTrafficPermitted() {
+    return true;
+  }
+
+  public static List<String> alpnProtocolNames(List<Protocol> protocols) {
+    List<String> names = new ArrayList<>(protocols.size());
+    for (int i = 0, size = protocols.size(); i < size; i++) {
+      Protocol protocol = protocols.get(i);
+      if (protocol == Protocol.HTTP_1_0) continue; // No HTTP/1.0 for ALPN.
+      names.add(protocol.toString());
+    }
+    return names;
+  }
+
+  public CertificateChainCleaner buildCertificateChainCleaner(X509TrustManager trustManager) {
+    return new BasicCertificateChainCleaner(TrustRootIndex.get(trustManager));
+  }
+
+  /** Attempt to match the host runtime to a capable Platform implementation. */
+  private static Platform findPlatform() {
+    Platform android = AndroidPlatform.buildIfSupported();
+
+    if (android != null) {
+      return android;
+    }
+
+    Platform jdk9 = Jdk9Platform.buildIfSupported();
+
+    if (jdk9 != null) {
+      return jdk9;
+    }
+
+    Platform jdkWithJettyBoot = JdkWithJettyBootPlatform.buildIfSupported();
+
+    if (jdkWithJettyBoot != null) {
+      return jdkWithJettyBoot;
+    }
+
+    // Probably an Oracle JDK like OpenJDK.
+    return new Platform();
+  }
+
+  /**
+   * Returns the concatenation of 8-bit, length prefixed protocol names.
+   * http://tools.ietf.org/html/draft-agl-tls-nextprotoneg-04#page-4
+   */
+  static byte[] concatLengthPrefixed(List<Protocol> protocols) {
+    Buffer result = new Buffer();
+    for (int i = 0, size = protocols.size(); i < size; i++) {
+      Protocol protocol = protocols.get(i);
+      if (protocol == Protocol.HTTP_1_0) continue; // No HTTP/1.0 for ALPN.
+      result.writeByte(protocol.toString().length());
+      result.writeUtf8(protocol.toString());
+    }
+    return result.readByteArray();
+  }
+
+  static <T> T readFieldOrNull(Object instance, Class<T> fieldType, String fieldName) {
+    for (Class<?> c = instance.getClass(); c != Object.class; c = c.getSuperclass()) {
+      try {
+        Field field = c.getDeclaredField(fieldName);
+        field.setAccessible(true);
+        Object value = field.get(instance);
+        if (value == null || !fieldType.isInstance(value)) return null;
+        return fieldType.cast(value);
+      } catch (NoSuchFieldException ignored) {
+      } catch (IllegalAccessException e) {
+        throw new AssertionError();
+      }
+    }
+
+    // Didn't find the field we wanted. As a last gasp attempt, try to find the value on a delegate.
+    if (!fieldName.equals("delegate")) {
+      Object delegate = readFieldOrNull(instance, Object.class, "delegate");
+      if (delegate != null) return readFieldOrNull(delegate, fieldType, fieldName);
+    }
+
+    return null;
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/RouteDatabase.java b/okhttp/src/main/java/okhttp3/internal/RouteDatabase.java
similarity index 78%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/RouteDatabase.java
rename to okhttp/src/main/java/okhttp3/internal/RouteDatabase.java
index 929d2e8b5b..9928ae7763 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/RouteDatabase.java
+++ b/okhttp/src/main/java/okhttp3/internal/RouteDatabase.java
@@ -13,17 +13,16 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal;
+package okhttp3.internal;
 
-import com.squareup.okhttp.Route;
 import java.util.LinkedHashSet;
 import java.util.Set;
+import okhttp3.Route;
 
 /**
- * A blacklist of failed routes to avoid when creating a new connection to a
- * target address. This is used so that OkHttp can learn from its mistakes: if
- * there was a failure attempting to connect to a specific IP address, proxy
- * server or TLS mode, that failure is remembered and alternate routes are
+ * A blacklist of failed routes to avoid when creating a new connection to a target address. This is
+ * used so that OkHttp can learn from its mistakes: if there was a failure attempting to connect to
+ * a specific IP address or proxy server, that failure is remembered and alternate routes are
  * preferred.
  *
  * 当创建一个新的连接的时候会去检查当前连接失败的黑名单
@@ -45,8 +44,4 @@ public synchronized void connected(Route route) {
   public synchronized boolean shouldPostpone(Route route) {
     return failedRoutes.contains(route);
   }
-
-  public synchronized int failedRoutesCount() {
-    return failedRoutes.size();
-  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/Util.java b/okhttp/src/main/java/okhttp3/internal/Util.java
new file mode 100644
index 0000000000..0d72116405
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/Util.java
@@ -0,0 +1,454 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal;
+
+import java.io.Closeable;
+import java.io.IOException;
+import java.io.InterruptedIOException;
+import java.io.UnsupportedEncodingException;
+import java.lang.reflect.Array;
+import java.net.IDN;
+import java.net.ServerSocket;
+import java.net.Socket;
+import java.nio.charset.Charset;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.TimeZone;
+import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.TimeUnit;
+import java.util.regex.Pattern;
+import okhttp3.HttpUrl;
+import okio.Buffer;
+import okio.ByteString;
+import okio.Source;
+
+/** Junk drawer of utility methods. */
+public final class Util {
+  public static final byte[] EMPTY_BYTE_ARRAY = new byte[0];
+  public static final String[] EMPTY_STRING_ARRAY = new String[0];
+
+  /** A cheap and type-safe constant for the UTF-8 Charset. */
+  public static final Charset UTF_8 = Charset.forName("UTF-8");
+
+  /** GMT and UTC are equivalent for our purposes. */
+  public static final TimeZone UTC = TimeZone.getTimeZone("GMT");
+
+  /**
+   * Quick and dirty pattern to differentiate IP addresses from hostnames. This is an approximation
+   * of Android's private InetAddress#isNumeric API.
+   *
+   * <p>This matches IPv6 addresses as a hex string containing at least one colon, and possibly
+   * including dots after the first colon. It matches IPv4 addresses as strings containing only
+   * decimal digits and dots. This pattern matches strings like "a:.23" and "54" that are neither IP
+   * addresses nor hostnames; they will be verified as IP addresses (which is a more strict
+   * verification).
+   */
+  private static final Pattern VERIFY_AS_IP_ADDRESS = Pattern.compile(
+      "([0-9a-fA-F]*:[0-9a-fA-F:.]*)|([\\d.]+)");
+
+  private Util() {
+  }
+
+  public static void checkOffsetAndCount(long arrayLength, long offset, long count) {
+    if ((offset | count) < 0 || offset > arrayLength || arrayLength - offset < count) {
+      throw new ArrayIndexOutOfBoundsException();
+    }
+  }
+
+  /** Returns true if two possibly-null objects are equal. */
+  public static boolean equal(Object a, Object b) {
+    return a == b || (a != null && a.equals(b));
+  }
+
+  /**
+   * Closes {@code closeable}, ignoring any checked exceptions. Does nothing if {@code closeable} is
+   * null.
+   */
+  public static void closeQuietly(Closeable closeable) {
+    if (closeable != null) {
+      try {
+        closeable.close();
+      } catch (RuntimeException rethrown) {
+        throw rethrown;
+      } catch (Exception ignored) {
+      }
+    }
+  }
+
+  /**
+   * Closes {@code socket}, ignoring any checked exceptions. Does nothing if {@code socket} is
+   * null.
+   */
+  public static void closeQuietly(Socket socket) {
+    if (socket != null) {
+      try {
+        socket.close();
+      } catch (AssertionError e) {
+        if (!isAndroidGetsocknameError(e)) throw e;
+      } catch (RuntimeException rethrown) {
+        throw rethrown;
+      } catch (Exception ignored) {
+      }
+    }
+  }
+
+  /**
+   * Closes {@code serverSocket}, ignoring any checked exceptions. Does nothing if {@code
+   * serverSocket} is null.
+   */
+  public static void closeQuietly(ServerSocket serverSocket) {
+    if (serverSocket != null) {
+      try {
+        serverSocket.close();
+      } catch (RuntimeException rethrown) {
+        throw rethrown;
+      } catch (Exception ignored) {
+      }
+    }
+  }
+
+  /**
+   * Closes {@code a} and {@code b}. If either close fails, this completes the other close and
+   * rethrows the first encountered exception.
+   */
+  public static void closeAll(Closeable a, Closeable b) throws IOException {
+    Throwable thrown = null;
+    try {
+      a.close();
+    } catch (Throwable e) {
+      thrown = e;
+    }
+    try {
+      b.close();
+    } catch (Throwable e) {
+      if (thrown == null) thrown = e;
+    }
+    if (thrown == null) return;
+    if (thrown instanceof IOException) throw (IOException) thrown;
+    if (thrown instanceof RuntimeException) throw (RuntimeException) thrown;
+    if (thrown instanceof Error) throw (Error) thrown;
+    throw new AssertionError(thrown);
+  }
+
+  /**
+   * Attempts to exhaust {@code source}, returning true if successful. This is useful when reading a
+   * complete source is helpful, such as when doing so completes a cache body or frees a socket
+   * connection for reuse.
+   */
+  public static boolean discard(Source source, int timeout, TimeUnit timeUnit) {
+    try {
+      return skipAll(source, timeout, timeUnit);
+    } catch (IOException e) {
+      return false;
+    }
+  }
+
+  /**
+   * Reads until {@code in} is exhausted or the deadline has been reached. This is careful to not
+   * extend the deadline if one exists already.
+   */
+  public static boolean skipAll(Source source, int duration, TimeUnit timeUnit) throws IOException {
+    long now = System.nanoTime();
+    long originalDuration = source.timeout().hasDeadline()
+        ? source.timeout().deadlineNanoTime() - now
+        : Long.MAX_VALUE;
+    source.timeout().deadlineNanoTime(now + Math.min(originalDuration, timeUnit.toNanos(duration)));
+    try {
+      Buffer skipBuffer = new Buffer();
+      while (source.read(skipBuffer, 8192) != -1) {
+        skipBuffer.clear();
+      }
+      return true; // Success! The source has been exhausted.
+    } catch (InterruptedIOException e) {
+      return false; // We ran out of time before exhausting the source.
+    } finally {
+      if (originalDuration == Long.MAX_VALUE) {
+        source.timeout().clearDeadline();
+      } else {
+        source.timeout().deadlineNanoTime(now + originalDuration);
+      }
+    }
+  }
+
+  /** Returns a 32 character string containing an MD5 hash of {@code s}. */
+  public static String md5Hex(String s) {
+    try {
+      MessageDigest messageDigest = MessageDigest.getInstance("MD5");
+      byte[] md5bytes = messageDigest.digest(s.getBytes("UTF-8"));
+      return ByteString.of(md5bytes).hex();
+    } catch (NoSuchAlgorithmException | UnsupportedEncodingException e) {
+      throw new AssertionError(e);
+    }
+  }
+
+  /** Returns a Base 64-encoded string containing a SHA-1 hash of {@code s}. */
+  public static String shaBase64(String s) {
+    try {
+      MessageDigest messageDigest = MessageDigest.getInstance("SHA-1");
+      byte[] sha1Bytes = messageDigest.digest(s.getBytes("UTF-8"));
+      return ByteString.of(sha1Bytes).base64();
+    } catch (NoSuchAlgorithmException | UnsupportedEncodingException e) {
+      throw new AssertionError(e);
+    }
+  }
+
+  /** Returns a SHA-1 hash of {@code s}. */
+  public static ByteString sha1(ByteString s) {
+    try {
+      MessageDigest messageDigest = MessageDigest.getInstance("SHA-1");
+      byte[] sha1Bytes = messageDigest.digest(s.toByteArray());
+      return ByteString.of(sha1Bytes);
+    } catch (NoSuchAlgorithmException e) {
+      throw new AssertionError(e);
+    }
+  }
+
+  /** Returns a SHA-256 hash of {@code s}. */
+  public static ByteString sha256(ByteString s) {
+    try {
+      MessageDigest messageDigest = MessageDigest.getInstance("SHA-256");
+      byte[] sha1Bytes = messageDigest.digest(s.toByteArray());
+      return ByteString.of(sha1Bytes);
+    } catch (NoSuchAlgorithmException e) {
+      throw new AssertionError(e);
+    }
+  }
+
+  /** Returns an immutable copy of {@code list}. */
+  public static <T> List<T> immutableList(List<T> list) {
+    return Collections.unmodifiableList(new ArrayList<>(list));
+  }
+
+  /** Returns an immutable list containing {@code elements}. */
+  public static <T> List<T> immutableList(T... elements) {
+    return Collections.unmodifiableList(Arrays.asList(elements.clone()));
+  }
+
+  /** Returns an immutable copy of {@code map}. */
+  public static <K, V> Map<K, V> immutableMap(Map<K, V> map) {
+    return Collections.unmodifiableMap(new LinkedHashMap<>(map));
+  }
+
+  public static ThreadFactory threadFactory(final String name, final boolean daemon) {
+    return new ThreadFactory() {
+      @Override public Thread newThread(Runnable runnable) {
+        Thread result = new Thread(runnable, name);
+        result.setDaemon(daemon);
+        return result;
+      }
+    };
+  }
+
+  /**
+   * Returns an array containing containing only elements found in {@code first}  and also in {@code
+   * second}. The returned elements are in the same order as in {@code first}.
+   */
+  @SuppressWarnings("unchecked")
+  public static <T> T[] intersect(Class<T> arrayType, T[] first, T[] second) {
+    List<T> result = intersect(first, second);
+    return result.toArray((T[]) Array.newInstance(arrayType, result.size()));
+  }
+
+  /**
+   * Returns a list containing containing only elements found in {@code first}  and also in {@code
+   * second}. The returned elements are in the same order as in {@code first}.
+   */
+  private static <T> List<T> intersect(T[] first, T[] second) {
+    List<T> result = new ArrayList<>();
+    for (T a : first) {
+      for (T b : second) {
+        if (a.equals(b)) {
+          result.add(b);
+          break;
+        }
+      }
+    }
+    return result;
+  }
+
+  public static String hostHeader(HttpUrl url, boolean includeDefaultPort) {
+    String host = url.host().contains(":")
+        ? "[" + url.host() + "]"
+        : url.host();
+    return includeDefaultPort || url.port() != HttpUrl.defaultPort(url.scheme())
+        ? host + ":" + url.port()
+        : host;
+  }
+
+  /** Returns {@code s} with control characters and non-ASCII characters replaced with '?'. */
+  public static String toHumanReadableAscii(String s) {
+    for (int i = 0, length = s.length(), c; i < length; i += Character.charCount(c)) {
+      c = s.codePointAt(i);
+      if (c > '\u001f' && c < '\u007f') continue;
+
+      Buffer buffer = new Buffer();
+      buffer.writeUtf8(s, 0, i);
+      for (int j = i; j < length; j += Character.charCount(c)) {
+        c = s.codePointAt(j);
+        buffer.writeUtf8CodePoint(c > '\u001f' && c < '\u007f' ? c : '?');
+      }
+      return buffer.readUtf8();
+    }
+    return s;
+  }
+
+  /**
+   * Returns true if {@code e} is due to a firmware bug fixed after Android 4.2.2.
+   * https://code.google.com/p/android/issues/detail?id=54072
+   */
+  public static boolean isAndroidGetsocknameError(AssertionError e) {
+    return e.getCause() != null && e.getMessage() != null
+        && e.getMessage().contains("getsockname failed");
+  }
+
+  public static boolean contains(String[] array, String value) {
+    return Arrays.asList(array).contains(value);
+  }
+
+  public static String[] concat(String[] array, String value) {
+    String[] result = new String[array.length + 1];
+    System.arraycopy(array, 0, result, 0, array.length);
+    result[result.length - 1] = value;
+    return result;
+  }
+
+  /**
+   * Increments {@code pos} until {@code input[pos]} is not ASCII whitespace. Stops at {@code
+   * limit}.
+   */
+  public static int skipLeadingAsciiWhitespace(String input, int pos, int limit) {
+    for (int i = pos; i < limit; i++) {
+      switch (input.charAt(i)) {
+        case '\t':
+        case '\n':
+        case '\f':
+        case '\r':
+        case ' ':
+          continue;
+        default:
+          return i;
+      }
+    }
+    return limit;
+  }
+
+  /**
+   * Decrements {@code limit} until {@code input[limit - 1]} is not ASCII whitespace. Stops at
+   * {@code pos}.
+   */
+  public static int skipTrailingAsciiWhitespace(String input, int pos, int limit) {
+    for (int i = limit - 1; i >= pos; i--) {
+      switch (input.charAt(i)) {
+        case '\t':
+        case '\n':
+        case '\f':
+        case '\r':
+        case ' ':
+          continue;
+        default:
+          return i + 1;
+      }
+    }
+    return pos;
+  }
+
+  /** Equivalent to {@code string.substring(pos, limit).trim()}. */
+  public static String trimSubstring(String string, int pos, int limit) {
+    int start = skipLeadingAsciiWhitespace(string, pos, limit);
+    int end = skipTrailingAsciiWhitespace(string, start, limit);
+    return string.substring(start, end);
+  }
+
+  /**
+   * Returns the index of the first character in {@code input} that contains a character in {@code
+   * delimiters}. Returns limit if there is no such character.
+   */
+  public static int delimiterOffset(String input, int pos, int limit, String delimiters) {
+    for (int i = pos; i < limit; i++) {
+      if (delimiters.indexOf(input.charAt(i)) != -1) return i;
+    }
+    return limit;
+  }
+
+  /**
+   * Returns the index of the first character in {@code input} that is {@code delimiter}. Returns
+   * limit if there is no such character.
+   */
+  public static int delimiterOffset(String input, int pos, int limit, char delimiter) {
+    for (int i = pos; i < limit; i++) {
+      if (input.charAt(i) == delimiter) return i;
+    }
+    return limit;
+  }
+
+  /**
+   * Performs IDN ToASCII encoding and canonicalize the result to lowercase. e.g. This converts
+   * {@code ☃.net} to {@code xn--n3h.net}, and {@code WwW.GoOgLe.cOm} to {@code www.google.com}.
+   * {@code null} will be returned if the input cannot be ToASCII encoded or if the result
+   * contains unsupported ASCII characters.
+   */
+  public static String domainToAscii(String input) {
+    try {
+      String result = IDN.toASCII(input).toLowerCase(Locale.US);
+      if (result.isEmpty()) return null;
+
+      // Confirm that the IDN ToASCII result doesn't contain any illegal characters.
+      if (containsInvalidHostnameAsciiCodes(result)) {
+        return null;
+      }
+      // TODO: implement all label limits.
+      return result;
+    } catch (IllegalArgumentException e) {
+      return null;
+    }
+  }
+
+  private static boolean containsInvalidHostnameAsciiCodes(String hostnameAscii) {
+    for (int i = 0; i < hostnameAscii.length(); i++) {
+      char c = hostnameAscii.charAt(i);
+      // The WHATWG Host parsing rules accepts some character codes which are invalid by
+      // definition for OkHttp's host header checks (and the WHATWG Host syntax definition). Here
+      // we rule out characters that would cause problems in host headers.
+      if (c <= '\u001f' || c >= '\u007f') {
+        return true;
+      }
+      // Check for the characters mentioned in the WHATWG Host parsing spec:
+      // U+0000, U+0009, U+000A, U+000D, U+0020, "#", "%", "/", ":", "?", "@", "[", "\", and "]"
+      // (excluding the characters covered above).
+      if (" #%/:?@[\\]".indexOf(c) != -1) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  /** Returns true if {@code host} is not a host name and might be an IP address. */
+  public static boolean verifyAsIpAddress(String host) {
+    return VERIFY_AS_IP_ADDRESS.matcher(host).matches();
+  }
+
+  /** Returns a {@link Locale#US} formatted {@link String}. */
+  public static String format(String format, Object... args) {
+    return String.format(Locale.US, format, args);
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/ErrorCode.java b/okhttp/src/main/java/okhttp3/internal/framed/ErrorCode.java
similarity index 98%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/spdy/ErrorCode.java
rename to okhttp/src/main/java/okhttp3/internal/framed/ErrorCode.java
index 701de92d64..1142319d7e 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/ErrorCode.java
+++ b/okhttp/src/main/java/okhttp3/internal/framed/ErrorCode.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.spdy;
+package okhttp3.internal.framed;
 
 // http://tools.ietf.org/html/draft-ietf-httpbis-http2-17#section-7
 public enum ErrorCode {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java b/okhttp/src/main/java/okhttp3/internal/framed/FrameReader.java
similarity index 61%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
rename to okhttp/src/main/java/okhttp3/internal/framed/FrameReader.java
index e3736c5fe4..741a568c0d 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
+++ b/okhttp/src/main/java/okhttp3/internal/framed/FrameReader.java
@@ -13,8 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
-package com.squareup.okhttp.internal.spdy;
+package okhttp3.internal.framed;
 
 import java.io.Closeable;
 import java.io.IOException;
@@ -25,107 +24,100 @@
 /** Reads transport frames for SPDY/3 or HTTP/2. */
 public interface FrameReader extends Closeable {
   void readConnectionPreface() throws IOException;
+
   boolean nextFrame(Handler handler) throws IOException;
 
-  public interface Handler {
+  interface Handler {
     void data(boolean inFinished, int streamId, BufferedSource source, int length)
         throws IOException;
 
     /**
-     * Create or update incoming headers, creating the corresponding streams
-     * if necessary. Frames that trigger this are SPDY SYN_STREAM, HEADERS, and
-     * SYN_REPLY, and HTTP/2 HEADERS and PUSH_PROMISE.
+     * Create or update incoming headers, creating the corresponding streams if necessary. Frames
+     * that trigger this are SPDY SYN_STREAM, HEADERS, and SYN_REPLY, and HTTP/2 HEADERS and
+     * PUSH_PROMISE.
      *
      * @param outFinished true if the receiver should not send further frames.
      * @param inFinished true if the sender will not send further frames.
      * @param streamId the stream owning these headers.
-     * @param associatedStreamId the stream that triggered the sender to create
-     *     this stream.
+     * @param associatedStreamId the stream that triggered the sender to create this stream.
      */
     void headers(boolean outFinished, boolean inFinished, int streamId, int associatedStreamId,
         List<Header> headerBlock, HeadersMode headersMode);
+
     void rstStream(int streamId, ErrorCode errorCode);
+
     void settings(boolean clearPrevious, Settings settings);
 
     /** HTTP/2 only. */
     void ackSettings();
 
     /**
-     *  Read a connection-level ping from the peer.  {@code ack} indicates this
-     *  is a reply.  Payload parameters are different between SPDY/3 and HTTP/2.
-     *  <p>
-     *  In SPDY/3, only the first {@code payload1} parameter is set.  If the
-     *  reader is a client, it is an unsigned even number.  Likewise, a server
-     *  will receive an odd number.
-     *  <p>
-     *  In HTTP/2, both {@code payload1} and {@code payload2} parameters are
-     *  set. The data is opaque binary, and there are no rules on the content.
+     * Read a connection-level ping from the peer.  {@code ack} indicates this is a reply.  Payload
+     * parameters are different between SPDY/3 and HTTP/2.
+     *
+     * <p>In SPDY/3, only the first {@code payload1} parameter is set.  If the reader is a client,
+     * it is an unsigned even number. Likewise, a server will receive an odd number.
+     *
+     * <p>In HTTP/2, both {@code payload1} and {@code payload2} parameters are set. The data is
+     * opaque binary, and there are no rules on the content.
      */
     void ping(boolean ack, int payload1, int payload2);
 
     /**
-     * The peer tells us to stop creating streams.  It is safe to replay
-     * streams with {@code ID > lastGoodStreamId} on a new connection.  In-
-     * flight streams with {@code ID <= lastGoodStreamId} can only be replayed
-     * on a new connection if they are idempotent.
+     * The peer tells us to stop creating streams.  It is safe to replay streams with {@code ID >
+     * lastGoodStreamId} on a new connection.  In- flight streams with {@code ID <=
+     * lastGoodStreamId} can only be replayed on a new connection if they are idempotent.
      *
-     * @param lastGoodStreamId the last stream ID the peer processed before
-     *     sending this message. If {@code lastGoodStreamId} is zero, the peer
-     *     processed no frames.
+     * @param lastGoodStreamId the last stream ID the peer processed before sending this message. If
+     * {@code lastGoodStreamId} is zero, the peer processed no frames.
      * @param errorCode reason for closing the connection.
      * @param debugData only valid for HTTP/2; opaque debug data to send.
      */
     void goAway(int lastGoodStreamId, ErrorCode errorCode, ByteString debugData);
 
     /**
-     * Notifies that an additional {@code windowSizeIncrement} bytes can be
-     * sent on {@code streamId}, or the connection if {@code streamId} is zero.
+     * Notifies that an additional {@code windowSizeIncrement} bytes can be sent on {@code
+     * streamId}, or the connection if {@code streamId} is zero.
      */
     void windowUpdate(int streamId, long windowSizeIncrement);
 
     /**
-     * Called when reading a headers or priority frame. This may be used to
-     * change the stream's weight from the default (16) to a new value.
+     * Called when reading a headers or priority frame. This may be used to change the stream's
+     * weight from the default (16) to a new value.
      *
      * @param streamId stream which has a priority change.
      * @param streamDependency the stream ID this stream is dependent on.
      * @param weight relative proportion of priority in [1..256].
-     * @param exclusive inserts this stream ID as the sole child of
-     *     {@code streamDependency}.
+     * @param exclusive inserts this stream ID as the sole child of {@code streamDependency}.
      */
     void priority(int streamId, int streamDependency, int weight, boolean exclusive);
 
     /**
-     * HTTP/2 only. Receive a push promise header block.
-     * <p>
-     * A push promise contains all the headers that pertain to a server-initiated
-     * request, and a {@code promisedStreamId} to which response frames will be
-     * delivered. Push promise frames are sent as a part of the response to
-     * {@code streamId}.
+     * HTTP/2 only. Receive a push promise header block. <p> A push promise contains all the headers
+     * that pertain to a server-initiated request, and a {@code promisedStreamId} to which response
+     * frames will be delivered. Push promise frames are sent as a part of the response to {@code
+     * streamId}.
      *
      * @param streamId client-initiated stream ID.  Must be an odd number.
-     * @param promisedStreamId server-initiated stream ID.  Must be an even
-     * number.
-     * @param requestHeaders minimally includes {@code :method}, {@code :scheme},
-     * {@code :authority}, and (@code :path}.
+     * @param promisedStreamId server-initiated stream ID.  Must be an even number.
+     * @param requestHeaders minimally includes {@code :method}, {@code :scheme}, {@code
+     * :authority}, and (@code :path}.
      */
     void pushPromise(int streamId, int promisedStreamId, List<Header> requestHeaders)
         throws IOException;
 
     /**
-     * HTTP/2 only. Expresses that resources for the connection or a client-
-     * initiated stream are available from a different network location or
-     * protocol configuration.
+     * HTTP/2 only. Expresses that resources for the connection or a client- initiated stream are
+     * available from a different network location or protocol configuration.
      *
      * <p>See <a href="http://tools.ietf.org/html/draft-ietf-httpbis-alt-svc-01">alt-svc</a>
      *
-     * @param streamId when a client-initiated stream ID (odd number), the
-     *     origin of this alternate service is the origin of the stream. When
-     *     zero, the origin is specified in the {@code origin} parameter.
-     * @param origin when present, the
-     *     <a href="http://tools.ietf.org/html/rfc6454">origin</a> is typically
-     *     represented as a combination of scheme, host and port. When empty,
-     *     the origin is that of the {@code streamId}.
+     * @param streamId when a client-initiated stream ID (odd number), the origin of this alternate
+     * service is the origin of the stream. When zero, the origin is specified in the {@code origin}
+     * parameter.
+     * @param origin when present, the <a href="http://tools.ietf.org/html/rfc6454">origin</a> is
+     * typically represented as a combination of scheme, host and port. When empty, the origin is
+     * that of the {@code streamId}.
      * @param protocol an ALPN protocol, such as {@code h2}.
      * @param host an IP address or hostname.
      * @param port the IP port associated with the service.
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java b/okhttp/src/main/java/okhttp3/internal/framed/FrameWriter.java
similarity index 71%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java
rename to okhttp/src/main/java/okhttp3/internal/framed/FrameWriter.java
index 0f4b799366..5e8c7ebef9 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java
+++ b/okhttp/src/main/java/okhttp3/internal/framed/FrameWriter.java
@@ -13,8 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
-package com.squareup.okhttp.internal.spdy;
+package okhttp3.internal.framed;
 
 import java.io.Closeable;
 import java.io.IOException;
@@ -25,34 +24,37 @@
 public interface FrameWriter extends Closeable {
   /** HTTP/2 only. */
   void connectionPreface() throws IOException;
+
   /** Informs the peer that we've applied its latest settings. */
   void ackSettings(Settings peerSettings) throws IOException;
 
   /**
    * HTTP/2 only. Send a push promise header block.
-   * <p>
-   * A push promise contains all the headers that pertain to a server-initiated
-   * request, and a {@code promisedStreamId} to which response frames will be
-   * delivered. Push promise frames are sent as a part of the response to
-   * {@code streamId}.  The {@code promisedStreamId} has a priority of one
-   * greater than {@code streamId}.
+   *
+   * <p>A push promise contains all the headers that pertain to a server-initiated request, and a
+   * {@code promisedStreamId} to which response frames will be delivered. Push promise frames are
+   * sent as a part of the response to {@code streamId}. The {@code promisedStreamId} has a priority
+   * of one greater than {@code streamId}.
    *
    * @param streamId client-initiated stream ID.  Must be an odd number.
-   * @param promisedStreamId server-initiated stream ID.  Must be an even
-   * number.
-   * @param requestHeaders minimally includes {@code :method}, {@code :scheme},
-   * {@code :authority}, and (@code :path}.
+   * @param promisedStreamId server-initiated stream ID.  Must be an even number.
+   * @param requestHeaders minimally includes {@code :method}, {@code :scheme}, {@code :authority},
+   * and (@code :path}.
    */
   void pushPromise(int streamId, int promisedStreamId, List<Header> requestHeaders)
       throws IOException;
 
   /** SPDY/3 only. */
   void flush() throws IOException;
+
   void synStream(boolean outFinished, boolean inFinished, int streamId, int associatedStreamId,
       List<Header> headerBlock) throws IOException;
+
   void synReply(boolean outFinished, int streamId, List<Header> headerBlock)
       throws IOException;
+
   void headers(int streamId, List<Header> headerBlock) throws IOException;
+
   void rstStream(int streamId, ErrorCode errorCode) throws IOException;
 
   /** The maximum size of bytes that may be sent in a single call to {@link #data}. */
@@ -63,8 +65,8 @@ void synReply(boolean outFinished, int streamId, List<Header> headerBlock)
    * Implementations must send multiple frames as necessary.
    *
    * @param source the buffer to draw bytes from. May be null if byteCount is 0.
-   * @param byteCount must be between 0 and the minimum of {code source.length}
-   * and {@link #maxDataLength}.
+   * @param byteCount must be between 0 and the minimum of {code source.length} and {@link
+   * #maxDataLength}.
    */
   void data(boolean outFinished, int streamId, Buffer source, int byteCount) throws IOException;
 
@@ -72,32 +74,30 @@ void synReply(boolean outFinished, int streamId, List<Header> headerBlock)
   void settings(Settings okHttpSettings) throws IOException;
 
   /**
-   *  Send a connection-level ping to the peer.  {@code ack} indicates this is
-   *  a reply.  Payload parameters are different between SPDY/3 and HTTP/2.
-   *  <p>
-   *  In SPDY/3, only the first {@code payload1} parameter is sent.  If the
-   *  sender is a client, it is an unsigned odd number.  Likewise, a server
-   *  will send an even number.
-   *  <p>
-   *  In HTTP/2, both {@code payload1} and {@code payload2} parameters are
-   *  sent.  The data is opaque binary, and there are no rules on the content.
+   * Send a connection-level ping to the peer.  {@code ack} indicates this is a reply.  Payload
+   * parameters are different between SPDY/3 and HTTP/2.
+   *
+   * <p>In SPDY/3, only the first {@code payload1} parameter is sent.  If the sender is a client, it
+   * is an unsigned odd number. Likewise, a server will send an even number.
+   *
+   * <p>In HTTP/2, both {@code payload1} and {@code payload2} parameters are sent.  The data is
+   * opaque binary, and there are no rules on the content.
    */
   void ping(boolean ack, int payload1, int payload2) throws IOException;
 
   /**
-   * Tell the peer to stop creating streams and that we last processed
-   * {@code lastGoodStreamId}, or zero if no streams were processed.
+   * Tell the peer to stop creating streams and that we last processed {@code lastGoodStreamId}, or
+   * zero if no streams were processed.
    *
-   * @param lastGoodStreamId the last stream ID processed, or zero if no
-   * streams were processed.
+   * @param lastGoodStreamId the last stream ID processed, or zero if no streams were processed.
    * @param errorCode reason for closing the connection.
    * @param debugData only valid for HTTP/2; opaque debug data to send.
    */
   void goAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData) throws IOException;
 
   /**
-   * Inform peer that an additional {@code windowSizeIncrement} bytes can be
-   * sent on {@code streamId}, or the connection if {@code streamId} is zero.
+   * Inform peer that an additional {@code windowSizeIncrement} bytes can be sent on {@code
+   * streamId}, or the connection if {@code streamId} is zero.
    */
   void windowUpdate(int streamId, long windowSizeIncrement) throws IOException;
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java b/okhttp/src/main/java/okhttp3/internal/framed/FramedConnection.java
similarity index 69%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
rename to okhttp/src/main/java/okhttp3/internal/framed/FramedConnection.java
index 04bff0badb..336f466cdf 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
+++ b/okhttp/src/main/java/okhttp3/internal/framed/FramedConnection.java
@@ -13,11 +13,8 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.spdy;
+package okhttp3.internal.framed;
 
-import com.squareup.okhttp.Protocol;
-import com.squareup.okhttp.internal.NamedRunnable;
-import com.squareup.okhttp.internal.Util;
 import java.io.Closeable;
 import java.io.IOException;
 import java.io.InterruptedIOException;
@@ -33,23 +30,29 @@
 import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
+import okhttp3.Protocol;
+import okhttp3.internal.NamedRunnable;
+import okhttp3.internal.Platform;
+import okhttp3.internal.Util;
 import okio.Buffer;
+import okio.BufferedSink;
 import okio.BufferedSource;
 import okio.ByteString;
 import okio.Okio;
 
-import static com.squareup.okhttp.internal.spdy.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
+import static okhttp3.internal.Platform.INFO;
+import static okhttp3.internal.framed.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
 
 /**
- * A socket connection to a remote peer. A connection hosts streams which can
- * send and receive data.
+ * A socket connection to a remote peer. A connection hosts streams which can send and receive
+ * data.
  *
- * <p>Many methods in this API are <strong>synchronous:</strong> the call is
- * completed before the method returns. This is typical for Java but atypical
- * for SPDY. This is motivated by exception transparency: an IOException that
- * was triggered by a certain caller can be caught and handled by that caller.
+ * <p>Many methods in this API are <strong>synchronous:</strong> the call is completed before the
+ * method returns. This is typical for Java but atypical for SPDY. This is motivated by exception
+ * transparency: an IOException that was triggered by a certain caller can be caught and handled by
+ * that caller.
  */
-public final class SpdyConnection implements Closeable {
+public final class FramedConnection implements Closeable {
 
   // Internal state of this connection is guarded by 'this'. No blocking
   // operations may be performed while holding this lock!
@@ -65,25 +68,24 @@
 
   private static final ExecutorService executor = new ThreadPoolExecutor(0,
       Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(),
-      Util.threadFactory("OkHttp SpdyConnection", true));
+      Util.threadFactory("OkHttp FramedConnection", true));
 
-  /** The protocol variant, like {@link com.squareup.okhttp.internal.spdy.Spdy3}. */
+  /** The protocol variant, like {@link Spdy3}. */
   final Protocol protocol;
 
   /** True if this peer initiated the connection. */
   final boolean client;
 
   /**
-   * User code to run in response to an incoming stream. Callbacks must not be
-   * run on the callback executor.
+   * User code to run in response to incoming streams or settings. Calls to this are always invoked
+   * on {@link #executor}.
    */
-  private final IncomingStreamHandler handler;
-  private final Map<Integer, SpdyStream> streams = new HashMap<>();
-  private final String hostName;
+  private final Listener listener;
+  private final Map<Integer, FramedStream> streams = new HashMap<>();
+  private final String hostname;
   private int lastGoodStreamId;
   private int nextStreamId;
   private boolean shutdown;
-  private long idleStartTimeNs = System.nanoTime();
 
   /** Ensures push promise callbacks events are sent in order per stream. */
   private final ExecutorService pushExecutor;
@@ -95,23 +97,21 @@
   private int nextPingId;
 
   /**
-   * The total number of bytes consumed by the application, but not yet
-   * acknowledged by sending a {@code WINDOW_UPDATE} frame on this connection.
+   * The total number of bytes consumed by the application, but not yet acknowledged by sending a
+   * {@code WINDOW_UPDATE} frame on this connection.
    */
   // Visible for testing
   long unacknowledgedBytesRead = 0;
 
   /**
-   * Count of bytes that can be written on the connection before receiving a
-   * window update.
+   * Count of bytes that can be written on the connection before receiving a window update.
    */
   // Visible for testing
   long bytesLeftInWriteWindow;
 
   /** Settings we communicate to the peer. */
-  // TODO: Do we want to dynamically adjust settings, or KISS and only set once?
-  final Settings okHttpSettings = new Settings();
-      // okHttpSettings.set(Settings.MAX_CONCURRENT_STREAMS, 0, max);
+  Settings okHttpSettings = new Settings();
+
   private static final int OKHTTP_CLIENT_WINDOW_SIZE = 16 * 1024 * 1024;
 
   /** Settings we receive from the peer. */
@@ -126,11 +126,11 @@
   // Visible for testing
   final Reader readerRunnable;
 
-  private SpdyConnection(Builder builder) throws IOException {
+  private FramedConnection(Builder builder) throws IOException {
     protocol = builder.protocol;
     pushObserver = builder.pushObserver;
     client = builder.client;
-    handler = builder.handler;
+    listener = builder.listener;
     // http://tools.ietf.org/html/draft-ietf-httpbis-http2-17#section-5.1.1
     nextStreamId = builder.client ? 1 : 2;
     if (builder.client && protocol == Protocol.HTTP_2) {
@@ -147,14 +147,14 @@ private SpdyConnection(Builder builder) throws IOException {
       okHttpSettings.set(Settings.INITIAL_WINDOW_SIZE, 0, OKHTTP_CLIENT_WINDOW_SIZE);
     }
 
-    hostName = builder.hostName;
+    hostname = builder.hostname;
 
     if (protocol == Protocol.HTTP_2) {
       variant = new Http2();
       // Like newSingleThreadExecutor, except lazy creates the thread.
       pushExecutor = new ThreadPoolExecutor(0, 1, 60, TimeUnit.SECONDS,
           new LinkedBlockingQueue<Runnable>(),
-          Util.threadFactory(String.format("OkHttp %s Push Observer", hostName), true));
+          Util.threadFactory(Util.format("OkHttp %s Push Observer", hostname), true));
       // 1 less than SPDY http://tools.ietf.org/html/draft-ietf-httpbis-http2-17#section-6.9.2
       peerSettings.set(Settings.INITIAL_WINDOW_SIZE, 0, 65535);
       peerSettings.set(Settings.MAX_FRAME_SIZE, 0, Http2.INITIAL_MAX_FRAME_SIZE);
@@ -166,10 +166,9 @@ private SpdyConnection(Builder builder) throws IOException {
     }
     bytesLeftInWriteWindow = peerSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE);
     socket = builder.socket;
-    frameWriter = variant.newWriter(Okio.buffer(Okio.sink(builder.socket)), client);
+    frameWriter = variant.newWriter(builder.sink, client);
 
-    readerRunnable = new Reader();
-    new Thread(readerRunnable).start(); // Not a daemon thread.
+    readerRunnable = new Reader(variant.newReader(builder.source, client));
   }
 
   /** The protocol as selected using ALPN. */
@@ -178,51 +177,34 @@ public Protocol getProtocol() {
   }
 
   /**
-   * Returns the number of {@link SpdyStream#isOpen() open streams} on this
-   * connection.
+   * Returns the number of {@link FramedStream#isOpen() open streams} on this connection.
    */
   public synchronized int openStreamCount() {
     return streams.size();
   }
 
-  synchronized SpdyStream getStream(int id) {
+  synchronized FramedStream getStream(int id) {
     return streams.get(id);
   }
 
-  synchronized SpdyStream removeStream(int streamId) {
-    SpdyStream stream = streams.remove(streamId);
-    if (stream != null && streams.isEmpty()) {
-      setIdle(true);
-    }
+  synchronized FramedStream removeStream(int streamId) {
+    FramedStream stream = streams.remove(streamId);
+    notifyAll(); // The removed stream may be blocked on a connection-wide window update.
     return stream;
   }
 
-  private synchronized void setIdle(boolean value) {
-    idleStartTimeNs = value ? System.nanoTime() : Long.MAX_VALUE;
-  }
-
-  /** Returns true if this connection is idle. */
-  public synchronized boolean isIdle() {
-    return idleStartTimeNs != Long.MAX_VALUE;
-  }
-
-  /**
-   * Returns the time in ns when this connection became idle or Long.MAX_VALUE
-   * if connection is not idle.
-   */
-  public synchronized long getIdleStartTimeNs() {
-    return idleStartTimeNs;
+  public synchronized int maxConcurrentStreams() {
+    return peerSettings.getMaxConcurrentStreams(Integer.MAX_VALUE);
   }
 
   /**
    * Returns a new server-initiated stream.
    *
-   * @param associatedStreamId the stream that triggered the sender to create
-   *     this stream.
-   * @param out true to create an output stream that we can use to send data
-   *     to the remote peer. Corresponds to {@code FLAG_FIN}.
+   * @param associatedStreamId the stream that triggered the sender to create this stream.
+   * @param out true to create an output stream that we can use to send data to the remote peer.
+   * Corresponds to {@code FLAG_FIN}.
    */
-  public SpdyStream pushStream(int associatedStreamId, List<Header> requestHeaders, boolean out)
+  public FramedStream pushStream(int associatedStreamId, List<Header> requestHeaders, boolean out)
       throws IOException {
     if (client) throw new IllegalStateException("Client cannot push requests.");
     if (protocol != Protocol.HTTP_2) throw new IllegalStateException("protocol != HTTP_2");
@@ -233,20 +215,21 @@ public SpdyStream pushStream(int associatedStreamId, List<Header> requestHeaders
    * Returns a new locally-initiated stream.
    *
    * @param out true to create an output stream that we can use to send data to the remote peer.
-   *     Corresponds to {@code FLAG_FIN}.
+   * Corresponds to {@code FLAG_FIN}.
    * @param in true to create an input stream that the remote peer can use to send data to us.
-   *     Corresponds to {@code FLAG_UNIDIRECTIONAL}.
+   * Corresponds to {@code FLAG_UNIDIRECTIONAL}.
    */
-  public SpdyStream newStream(List<Header> requestHeaders, boolean out, boolean in)
+  public FramedStream newStream(List<Header> requestHeaders, boolean out, boolean in)
       throws IOException {
     return newStream(0, requestHeaders, out, in);
   }
 
-  private SpdyStream newStream(int associatedStreamId, List<Header> requestHeaders, boolean out,
+  private FramedStream newStream(int associatedStreamId, List<Header> requestHeaders, boolean out,
       boolean in) throws IOException {
     boolean outFinished = !out;
     boolean inFinished = !in;
-    SpdyStream stream;
+    boolean flushHeaders;
+    FramedStream stream;
     int streamId;
 
     synchronized (frameWriter) {
@@ -256,10 +239,10 @@ private SpdyStream newStream(int associatedStreamId, List<Header> requestHeaders
         }
         streamId = nextStreamId;
         nextStreamId += 2;
-        stream = new SpdyStream(streamId, this, outFinished, inFinished, requestHeaders);
+        stream = new FramedStream(streamId, this, outFinished, inFinished, requestHeaders);
+        flushHeaders = !out || bytesLeftInWriteWindow == 0L || stream.bytesLeftInWriteWindow == 0L;
         if (stream.isOpen()) {
           streams.put(streamId, stream);
-          setIdle(false);
         }
       }
       if (associatedStreamId == 0) {
@@ -272,7 +255,7 @@ private SpdyStream newStream(int associatedStreamId, List<Header> requestHeaders
       }
     }
 
-    if (!out) {
+    if (flushHeaders) {
       frameWriter.flush();
     }
 
@@ -285,19 +268,16 @@ void writeSynReply(int streamId, boolean outFinished, List<Header> alternating)
   }
 
   /**
-   * Callers of this method are not thread safe, and sometimes on application
-   * threads.  Most often, this method will be called to send a buffer worth of
-   * data to the peer.
-   * <p>
-   * Writes are subject to the write window of the stream and the connection.
-   * Until there is a window sufficient to send {@code byteCount}, the caller
-   * will block.  For example, a user of {@code HttpURLConnection} who flushes
-   * more bytes to the output stream than the connection's write window will
-   * block.
-   * <p>
-   * Zero {@code byteCount} writes are not subject to flow control and
-   * will not block.  The only use case for zero {@code byteCount} is closing
-   * a flushed output stream.
+   * Callers of this method are not thread safe, and sometimes on application threads. Most often,
+   * this method will be called to send a buffer worth of data to the peer.
+   *
+   * <p>Writes are subject to the write window of the stream and the connection. Until there is a
+   * window sufficient to send {@code byteCount}, the caller will block. For example, a user of
+   * {@code HttpURLConnection} who flushes more bytes to the output stream than the connection's
+   * write window will block.
+   *
+   * <p>Zero {@code byteCount} writes are not subject to flow control and will not block. The only
+   * use case for zero {@code byteCount} is closing a flushed output stream.
    */
   public void writeData(int streamId, boolean outFinished, Buffer buffer, long byteCount)
       throws IOException {
@@ -308,10 +288,15 @@ public void writeData(int streamId, boolean outFinished, Buffer buffer, long byt
 
     while (byteCount > 0) {
       int toWrite;
-      synchronized (SpdyConnection.this) {
+      synchronized (FramedConnection.this) {
         try {
           while (bytesLeftInWriteWindow <= 0) {
-            SpdyConnection.this.wait(); // Wait until we receive a WINDOW_UPDATE.
+            // Before blocking, confirm that the stream we're writing is still open. It's possible
+            // that the stream has since been closed (such as if this write timed out.)
+            if (!streams.containsKey(streamId)) {
+              throw new IOException("stream closed");
+            }
+            FramedConnection.this.wait(); // Wait until we receive a WINDOW_UPDATE.
           }
         } catch (InterruptedException e) {
           throw new InterruptedIOException();
@@ -328,16 +313,15 @@ public void writeData(int streamId, boolean outFinished, Buffer buffer, long byt
   }
 
   /**
-   * {@code delta} will be negative if a settings frame initial window is
-   * smaller than the last.
+   * {@code delta} will be negative if a settings frame initial window is smaller than the last.
    */
   void addBytesToWriteWindow(long delta) {
     bytesLeftInWriteWindow += delta;
-    if (delta > 0) SpdyConnection.this.notifyAll();
+    if (delta > 0) FramedConnection.this.notifyAll();
   }
 
   void writeSynResetLater(final int streamId, final ErrorCode errorCode) {
-    executor.submit(new NamedRunnable("OkHttp %s stream %d", hostName, streamId) {
+    executor.submit(new NamedRunnable("OkHttp %s stream %d", hostname, streamId) {
       @Override public void execute() {
         try {
           writeSynReset(streamId, errorCode);
@@ -352,7 +336,7 @@ void writeSynReset(int streamId, ErrorCode statusCode) throws IOException {
   }
 
   void writeWindowUpdateLater(final int streamId, final long unacknowledgedBytesRead) {
-    executor.execute(new NamedRunnable("OkHttp Window Update %s stream %d", hostName, streamId) {
+    executor.execute(new NamedRunnable("OkHttp Window Update %s stream %d", hostname, streamId) {
       @Override public void execute() {
         try {
           frameWriter.windowUpdate(streamId, unacknowledgedBytesRead);
@@ -363,8 +347,8 @@ void writeWindowUpdateLater(final int streamId, final long unacknowledgedBytesRe
   }
 
   /**
-   * Sends a ping frame to the peer. Use the returned object to await the
-   * ping's response and observe its round trip time.
+   * Sends a ping frame to the peer. Use the returned object to await the ping's response and
+   * observe its round trip time.
    */
   public Ping ping() throws IOException {
     Ping ping = new Ping();
@@ -385,7 +369,7 @@ public Ping ping() throws IOException {
   private void writePingLater(
       final boolean reply, final int payload1, final int payload2, final Ping ping) {
     executor.execute(new NamedRunnable("OkHttp %s ping %08x%08x",
-        hostName, payload1, payload2) {
+        hostname, payload1, payload2) {
       @Override public void execute() {
         try {
           writePing(reply, payload1, payload2, ping);
@@ -412,10 +396,9 @@ public void flush() throws IOException {
   }
 
   /**
-   * Degrades this connection such that new streams can neither be created
-   * locally, nor accepted from the remote peer. Existing streams are not
-   * impacted. This is intended to permit an endpoint to gracefully stop
-   * accepting new requests without harming previously established streams.
+   * Degrades this connection such that new streams can neither be created locally, nor accepted
+   * from the remote peer. Existing streams are not impacted. This is intended to permit an endpoint
+   * to gracefully stop accepting new requests without harming previously established streams.
    */
   public void shutdown(ErrorCode statusCode) throws IOException {
     synchronized (frameWriter) {
@@ -433,9 +416,8 @@ public void shutdown(ErrorCode statusCode) throws IOException {
   }
 
   /**
-   * Closes this connection. This cancels all open streams and unanswered
-   * pings. It closes the underlying input and output streams and shuts down
-   * internal executor services.
+   * Closes this connection. This cancels all open streams and unanswered pings. It closes the
+   * underlying input and output streams and shuts down internal executor services.
    */
   @Override public void close() throws IOException {
     close(ErrorCode.NO_ERROR, ErrorCode.CANCEL);
@@ -450,13 +432,12 @@ private void close(ErrorCode connectionCode, ErrorCode streamCode) throws IOExce
       thrown = e;
     }
 
-    SpdyStream[] streamsToClose = null;
+    FramedStream[] streamsToClose = null;
     Ping[] pingsToCancel = null;
     synchronized (this) {
       if (!streams.isEmpty()) {
-        streamsToClose = streams.values().toArray(new SpdyStream[streams.size()]);
+        streamsToClose = streams.values().toArray(new FramedStream[streams.size()]);
         streams.clear();
-        setIdle(false);
       }
       if (pings != null) {
         pingsToCancel = pings.values().toArray(new Ping[pings.size()]);
@@ -465,7 +446,7 @@ private void close(ErrorCode connectionCode, ErrorCode streamCode) throws IOExce
     }
 
     if (streamsToClose != null) {
-      for (SpdyStream stream : streamsToClose) {
+      for (FramedStream stream : streamsToClose) {
         try {
           stream.close(streamCode);
         } catch (IOException e) {
@@ -498,42 +479,76 @@ private void close(ErrorCode connectionCode, ErrorCode streamCode) throws IOExce
   }
 
   /**
-   * Sends a connection header if the current variant requires it. This should
-   * be called after {@link Builder#build} for all new connections.
+   * Sends any initial frames and starts reading frames from the remote peer. This should be called
+   * after {@link Builder#build} for all new connections.
+   */
+  public void start() throws IOException {
+    start(true);
+  }
+
+  /**
+   * @param sendConnectionPreface true to send connection preface frames. This should always be true
+   *     except for in tests that don't check for a connection preface.
    */
-  public void sendConnectionPreface() throws IOException {
-    frameWriter.connectionPreface();
-    frameWriter.settings(okHttpSettings);
-    int windowSize = okHttpSettings.getInitialWindowSize(Settings.DEFAULT_INITIAL_WINDOW_SIZE);
-    if (windowSize != Settings.DEFAULT_INITIAL_WINDOW_SIZE) {
-      frameWriter.windowUpdate(0, windowSize - Settings.DEFAULT_INITIAL_WINDOW_SIZE);
+  void start(boolean sendConnectionPreface) throws IOException {
+    if (sendConnectionPreface) {
+      frameWriter.connectionPreface();
+      frameWriter.settings(okHttpSettings);
+      int windowSize = okHttpSettings.getInitialWindowSize(Settings.DEFAULT_INITIAL_WINDOW_SIZE);
+      if (windowSize != Settings.DEFAULT_INITIAL_WINDOW_SIZE) {
+        frameWriter.windowUpdate(0, windowSize - Settings.DEFAULT_INITIAL_WINDOW_SIZE);
+      }
+    }
+    new Thread(readerRunnable).start(); // Not a daemon thread.
+  }
+
+  /** Merges {@code settings} into this peer's settings and sends them to the remote peer. */
+  public void setSettings(Settings settings) throws IOException {
+    synchronized (frameWriter) {
+      synchronized (this) {
+        if (shutdown) {
+          throw new IOException("shutdown");
+        }
+        okHttpSettings.merge(settings);
+        frameWriter.settings(settings);
+      }
     }
   }
 
   public static class Builder {
-    private String hostName;
     private Socket socket;
-    private IncomingStreamHandler handler = IncomingStreamHandler.REFUSE_INCOMING_STREAMS;
+    private String hostname;
+    private BufferedSource source;
+    private BufferedSink sink;
+    private Listener listener = Listener.REFUSE_INCOMING_STREAMS;
     private Protocol protocol = Protocol.SPDY_3;
     private PushObserver pushObserver = PushObserver.CANCEL;
     private boolean client;
 
-    public Builder(boolean client, Socket socket) throws IOException {
-      this(((InetSocketAddress) socket.getRemoteSocketAddress()).getHostName(), client, socket);
-    }
-
     /**
-     * @param client true if this peer initiated the connection; false if this
-     *     peer accepted the connection.
+     * @param client true if this peer initiated the connection; false if this peer accepted the
+     * connection.
      */
-    public Builder(String hostName, boolean client, Socket socket) throws IOException {
-      this.hostName = hostName;
+    public Builder(boolean client) throws IOException {
       this.client = client;
+    }
+
+    public Builder socket(Socket socket) throws IOException {
+      return socket(socket, ((InetSocketAddress) socket.getRemoteSocketAddress()).getHostName(),
+          Okio.buffer(Okio.source(socket)), Okio.buffer(Okio.sink(socket)));
+    }
+
+    public Builder socket(
+        Socket socket, String hostname, BufferedSource source, BufferedSink sink) {
       this.socket = socket;
+      this.hostname = hostname;
+      this.source = source;
+      this.sink = sink;
+      return this;
     }
 
-    public Builder handler(IncomingStreamHandler handler) {
-      this.handler = handler;
+    public Builder listener(Listener listener) {
+      this.listener = listener;
       return this;
     }
 
@@ -547,27 +562,27 @@ public Builder pushObserver(PushObserver pushObserver) {
       return this;
     }
 
-    public SpdyConnection build() throws IOException {
-      return new SpdyConnection(this);
+    public FramedConnection build() throws IOException {
+      return new FramedConnection(this);
     }
   }
 
   /**
-   * Methods in this class must not lock FrameWriter.  If a method needs to
-   * write a frame, create an async task to do so.
+   * Methods in this class must not lock FrameWriter.  If a method needs to write a frame, create an
+   * async task to do so.
    */
   class Reader extends NamedRunnable implements FrameReader.Handler {
-    FrameReader frameReader;
+    final FrameReader frameReader;
 
-    private Reader() {
-      super("OkHttp %s", hostName);
+    private Reader(FrameReader frameReader) {
+      super("OkHttp %s", hostname);
+      this.frameReader = frameReader;
     }
 
     @Override protected void execute() {
       ErrorCode connectionErrorCode = ErrorCode.INTERNAL_ERROR;
       ErrorCode streamErrorCode = ErrorCode.INTERNAL_ERROR;
       try {
-        frameReader = variant.newReader(Okio.buffer(Okio.source(socket)), client);
         if (!client) {
           frameReader.readConnectionPreface();
         }
@@ -593,7 +608,7 @@ private Reader() {
         pushDataLater(streamId, source, length, inFinished);
         return;
       }
-      SpdyStream dataStream = getStream(streamId);
+      FramedStream dataStream = getStream(streamId);
       if (dataStream == null) {
         writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);
         source.skip(length);
@@ -611,8 +626,8 @@ private Reader() {
         pushHeadersLater(streamId, headerBlock, inFinished);
         return;
       }
-      SpdyStream stream;
-      synchronized (SpdyConnection.this) {
+      FramedStream stream;
+      synchronized (FramedConnection.this) {
         // If we're shutdown, don't bother with this stream.
         if (shutdown) return;
 
@@ -632,16 +647,21 @@ private Reader() {
           if (streamId % 2 == nextStreamId % 2) return;
 
           // Create a stream.
-          final SpdyStream newStream = new SpdyStream(streamId, SpdyConnection.this, outFinished,
+          final FramedStream
+              newStream = new FramedStream(streamId, FramedConnection.this, outFinished,
               inFinished, headerBlock);
           lastGoodStreamId = streamId;
           streams.put(streamId, newStream);
-          executor.execute(new NamedRunnable("OkHttp %s stream %d", hostName, streamId) {
+          executor.execute(new NamedRunnable("OkHttp %s stream %d", hostname, streamId) {
             @Override public void execute() {
               try {
-                handler.receive(newStream);
+                listener.onStream(newStream);
               } catch (IOException e) {
-                throw new RuntimeException(e);
+                Platform.get().log(INFO, "FramedConnection.Listener failure for " + hostname, e);
+                try {
+                  newStream.close(ErrorCode.PROTOCOL_ERROR);
+                } catch (IOException ignored) {
+                }
               }
             }
           });
@@ -666,7 +686,7 @@ private Reader() {
         pushResetLater(streamId, errorCode);
         return;
       }
-      SpdyStream rstStream = removeStream(streamId);
+      FramedStream rstStream = removeStream(streamId);
       if (rstStream != null) {
         rstStream.receiveRstStream(errorCode);
       }
@@ -674,8 +694,8 @@ private Reader() {
 
     @Override public void settings(boolean clearPrevious, Settings newSettings) {
       long delta = 0;
-      SpdyStream[] streamsToNotify = null;
-      synchronized (SpdyConnection.this) {
+      FramedStream[] streamsToNotify = null;
+      synchronized (FramedConnection.this) {
         int priorWriteWindowSize = peerSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE);
         if (clearPrevious) peerSettings.clear();
         peerSettings.merge(newSettings);
@@ -690,12 +710,17 @@ private Reader() {
             receivedInitialPeerSettings = true;
           }
           if (!streams.isEmpty()) {
-            streamsToNotify = streams.values().toArray(new SpdyStream[streams.size()]);
+            streamsToNotify = streams.values().toArray(new FramedStream[streams.size()]);
           }
         }
+        executor.execute(new NamedRunnable("OkHttp %s settings", hostname) {
+          @Override public void execute() {
+            listener.onSettings(FramedConnection.this);
+          }
+        });
       }
       if (streamsToNotify != null && delta != 0) {
-        for (SpdyStream stream : streamsToNotify) {
+        for (FramedStream stream : streamsToNotify) {
           synchronized (stream) {
             stream.addBytesToWriteWindow(delta);
           }
@@ -704,7 +729,7 @@ private Reader() {
     }
 
     private void ackSettingsLater(final Settings peerSettings) {
-      executor.execute(new NamedRunnable("OkHttp %s ACK Settings", hostName) {
+      executor.execute(new NamedRunnable("OkHttp %s ACK Settings", hostname) {
         @Override public void execute() {
           try {
             frameWriter.ackSettings(peerSettings);
@@ -735,29 +760,29 @@ private void ackSettingsLater(final Settings peerSettings) {
       }
 
       // Copy the streams first. We don't want to hold a lock when we call receiveRstStream().
-      SpdyStream[] streamsCopy;
-      synchronized (SpdyConnection.this) {
-        streamsCopy = streams.values().toArray(new SpdyStream[streams.size()]);
+      FramedStream[] streamsCopy;
+      synchronized (FramedConnection.this) {
+        streamsCopy = streams.values().toArray(new FramedStream[streams.size()]);
         shutdown = true;
       }
 
       // Fail all streams created after the last good stream ID.
-      for (SpdyStream spdyStream : streamsCopy) {
-        if (spdyStream.getId() > lastGoodStreamId && spdyStream.isLocallyInitiated()) {
-          spdyStream.receiveRstStream(ErrorCode.REFUSED_STREAM);
-          removeStream(spdyStream.getId());
+      for (FramedStream framedStream : streamsCopy) {
+        if (framedStream.getId() > lastGoodStreamId && framedStream.isLocallyInitiated()) {
+          framedStream.receiveRstStream(ErrorCode.REFUSED_STREAM);
+          removeStream(framedStream.getId());
         }
       }
     }
 
     @Override public void windowUpdate(int streamId, long windowSizeIncrement) {
       if (streamId == 0) {
-        synchronized (SpdyConnection.this) {
+        synchronized (FramedConnection.this) {
           bytesLeftInWriteWindow += windowSizeIncrement;
-          SpdyConnection.this.notifyAll();
+          FramedConnection.this.notifyAll();
         }
       } else {
-        SpdyStream stream = getStream(streamId);
+        FramedStream stream = getStream(streamId);
         if (stream != null) {
           synchronized (stream) {
             stream.addBytesToWriteWindow(windowSizeIncrement);
@@ -798,13 +823,13 @@ private void pushRequestLater(final int streamId, final List<Header> requestHead
       }
       currentPushRequests.add(streamId);
     }
-    pushExecutor.execute(new NamedRunnable("OkHttp %s Push Request[%s]", hostName, streamId) {
+    pushExecutor.execute(new NamedRunnable("OkHttp %s Push Request[%s]", hostname, streamId) {
       @Override public void execute() {
         boolean cancel = pushObserver.onRequest(streamId, requestHeaders);
         try {
           if (cancel) {
             frameWriter.rstStream(streamId, ErrorCode.CANCEL);
-            synchronized (SpdyConnection.this) {
+            synchronized (FramedConnection.this) {
               currentPushRequests.remove(streamId);
             }
           }
@@ -816,13 +841,13 @@ private void pushRequestLater(final int streamId, final List<Header> requestHead
 
   private void pushHeadersLater(final int streamId, final List<Header> requestHeaders,
       final boolean inFinished) {
-    pushExecutor.execute(new NamedRunnable("OkHttp %s Push Headers[%s]", hostName, streamId) {
+    pushExecutor.execute(new NamedRunnable("OkHttp %s Push Headers[%s]", hostname, streamId) {
       @Override public void execute() {
         boolean cancel = pushObserver.onHeaders(streamId, requestHeaders, inFinished);
         try {
           if (cancel) frameWriter.rstStream(streamId, ErrorCode.CANCEL);
           if (cancel || inFinished) {
-            synchronized (SpdyConnection.this) {
+            synchronized (FramedConnection.this) {
               currentPushRequests.remove(streamId);
             }
           }
@@ -842,13 +867,13 @@ private void pushDataLater(final int streamId, final BufferedSource source, fina
     source.require(byteCount); // Eagerly read the frame before firing client thread.
     source.read(buffer, byteCount);
     if (buffer.size() != byteCount) throw new IOException(buffer.size() + " != " + byteCount);
-    pushExecutor.execute(new NamedRunnable("OkHttp %s Push Data[%s]", hostName, streamId) {
+    pushExecutor.execute(new NamedRunnable("OkHttp %s Push Data[%s]", hostname, streamId) {
       @Override public void execute() {
         try {
           boolean cancel = pushObserver.onData(streamId, buffer, byteCount, inFinished);
           if (cancel) frameWriter.rstStream(streamId, ErrorCode.CANCEL);
           if (cancel || inFinished) {
-            synchronized (SpdyConnection.this) {
+            synchronized (FramedConnection.this) {
               currentPushRequests.remove(streamId);
             }
           }
@@ -859,13 +884,40 @@ private void pushDataLater(final int streamId, final BufferedSource source, fina
   }
 
   private void pushResetLater(final int streamId, final ErrorCode errorCode) {
-    pushExecutor.execute(new NamedRunnable("OkHttp %s Push Reset[%s]", hostName, streamId) {
+    pushExecutor.execute(new NamedRunnable("OkHttp %s Push Reset[%s]", hostname, streamId) {
       @Override public void execute() {
         pushObserver.onReset(streamId, errorCode);
-        synchronized (SpdyConnection.this) {
+        synchronized (FramedConnection.this) {
           currentPushRequests.remove(streamId);
         }
       }
     });
   }
+
+  /** Listener of streams and settings initiated by the peer. */
+  public abstract static class Listener {
+    public static final Listener REFUSE_INCOMING_STREAMS = new Listener() {
+      @Override public void onStream(FramedStream stream) throws IOException {
+        stream.close(ErrorCode.REFUSED_STREAM);
+      }
+    };
+
+    /**
+     * Handle a new stream from this connection's peer. Implementations should respond by either
+     * {@linkplain FramedStream#reply replying to the stream} or {@linkplain FramedStream#close
+     * closing it}. This response does not need to be synchronous.
+     */
+    public abstract void onStream(FramedStream stream) throws IOException;
+
+    /**
+     * Notification that the connection's peer's settings may have changed. Implementations should
+     * take appropriate action to handle the updated settings.
+     *
+     * <p>It is the implementation's responsibility to handle concurrent calls to this method. A
+     * remote peer that sends multiple settings frames will trigger multiple calls to this method,
+     * and those calls are not necessarily serialized.
+     */
+    public void onSettings(FramedConnection connection) {
+    }
+  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java b/okhttp/src/main/java/okhttp3/internal/framed/FramedStream.java
similarity index 77%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
rename to okhttp/src/main/java/okhttp3/internal/framed/FramedStream.java
index abc5df6516..d6ce15eeb6 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
+++ b/okhttp/src/main/java/okhttp3/internal/framed/FramedStream.java
@@ -13,12 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
-package com.squareup.okhttp.internal.spdy;
+package okhttp3.internal.framed;
 
 import java.io.EOFException;
 import java.io.IOException;
 import java.io.InterruptedIOException;
+import java.net.SocketTimeoutException;
 import java.util.ArrayList;
 import java.util.List;
 import okio.AsyncTimeout;
@@ -28,31 +28,30 @@
 import okio.Source;
 import okio.Timeout;
 
-import static com.squareup.okhttp.internal.spdy.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
+import static okhttp3.internal.framed.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
 
 /** A logical bidirectional stream. */
-public final class SpdyStream {
+public final class FramedStream {
   // Internal state is guarded by this. No long-running or potentially
   // blocking operations are performed while the lock is held.
 
   /**
-   * The total number of bytes consumed by the application (with {@link
-   * SpdyDataSource#read}), but not yet acknowledged by sending a {@code
-   * WINDOW_UPDATE} frame on this stream.
+   * The total number of bytes consumed by the application (with {@link FramedDataSource#read}), but
+   * not yet acknowledged by sending a {@code WINDOW_UPDATE} frame on this stream.
    */
   // Visible for testing
   long unacknowledgedBytesRead = 0;
 
   /**
-   * Count of bytes that can be written on the stream before receiving a
-   * window update. Even if this is positive, writes will block until there
-   * available bytes in {@code connection.bytesLeftInWriteWindow}.
+   * Count of bytes that can be written on the stream before receiving a window update. Even if this
+   * is positive, writes will block until there available bytes in {@code
+   * connection.bytesLeftInWriteWindow}.
    */
   // guarded by this
   long bytesLeftInWriteWindow;
 
   private final int id;
-  private final SpdyConnection connection;
+  private final FramedConnection connection;
 
   /** Headers sent by the stream initiator. Immutable and non null. */
   private final List<Header> requestHeaders;
@@ -60,19 +59,19 @@
   /** Headers sent in the stream reply. Null if reply is either not sent or not sent yet. */
   private List<Header> responseHeaders;
 
-  private final SpdyDataSource source;
-  final SpdyDataSink sink;
-  private final SpdyTimeout readTimeout = new SpdyTimeout();
-  private final SpdyTimeout writeTimeout = new SpdyTimeout();
+  private final FramedDataSource source;
+  final FramedDataSink sink;
+  private final StreamTimeout readTimeout = new StreamTimeout();
+  private final StreamTimeout writeTimeout = new StreamTimeout();
 
   /**
-   * The reason why this stream was abnormally closed. If there are multiple
-   * reasons to abnormally close this stream (such as both peers closing it
-   * near-simultaneously) then this is the first reason known to this peer.
+   * The reason why this stream was abnormally closed. If there are multiple reasons to abnormally
+   * close this stream (such as both peers closing it near-simultaneously) then this is the first
+   * reason known to this peer.
    */
   private ErrorCode errorCode = null;
 
-  SpdyStream(int id, SpdyConnection connection, boolean outFinished, boolean inFinished,
+  FramedStream(int id, FramedConnection connection, boolean outFinished, boolean inFinished,
       List<Header> requestHeaders) {
     if (connection == null) throw new NullPointerException("connection == null");
     if (requestHeaders == null) throw new NullPointerException("requestHeaders == null");
@@ -80,9 +79,9 @@
     this.connection = connection;
     this.bytesLeftInWriteWindow =
         connection.peerSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE);
-    this.source = new SpdyDataSource(
+    this.source = new FramedDataSource(
         connection.okHttpSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE));
-    this.sink = new SpdyDataSink();
+    this.sink = new FramedDataSink();
     this.source.finished = inFinished;
     this.sink.finished = outFinished;
     this.requestHeaders = requestHeaders;
@@ -94,13 +93,14 @@ public int getId() {
 
   /**
    * Returns true if this stream is open. A stream is open until either:
+   *
    * <ul>
-   * <li>A {@code SYN_RESET} frame abnormally terminates the stream.
-   * <li>Both input and output streams have transmitted all data and
-   * headers.
+   *     <li>A {@code SYN_RESET} frame abnormally terminates the stream.
+   *     <li>Both input and output streams have transmitted all data and headers.
    * </ul>
-   * Note that the input stream may continue to yield data even after a stream
-   * reports itself as not open. This is because input data is buffered.
+   *
+   * <p>Note that the input stream may continue to yield data even after a stream reports itself as
+   * not open. This is because input data is buffered.
    */
   public synchronized boolean isOpen() {
     if (errorCode != null) {
@@ -120,7 +120,7 @@ public boolean isLocallyInitiated() {
     return connection.client == streamIsClient;
   }
 
-  public SpdyConnection getConnection() {
+  public FramedConnection getConnection() {
     return connection;
   }
 
@@ -129,8 +129,8 @@ public SpdyConnection getConnection() {
   }
 
   /**
-   * Returns the stream's response headers, blocking if necessary if they
-   * have not been received yet.
+   * Returns the stream's response headers, blocking if necessary if they have not been received
+   * yet.
    */
   public synchronized List<Header> getResponseHeaders() throws IOException {
     readTimeout.enter();
@@ -142,12 +142,12 @@ public SpdyConnection getConnection() {
       readTimeout.exitAndThrowIfTimedOut();
     }
     if (responseHeaders != null) return responseHeaders;
-    throw new IOException("stream was reset: " + errorCode);
+    throw new StreamResetException(errorCode);
   }
 
   /**
-   * Returns the reason why this stream was closed, or null if it closed
-   * normally or has not yet been closed.
+   * Returns the reason why this stream was closed, or null if it closed normally or has not yet
+   * been closed.
    */
   public synchronized ErrorCode getErrorCode() {
     return errorCode;
@@ -156,11 +156,11 @@ public synchronized ErrorCode getErrorCode() {
   /**
    * Sends a reply to an incoming stream.
    *
-   * @param out true to create an output stream that we can use to send data
-   * to the remote peer. Corresponds to {@code FLAG_FIN}.
+   * @param out true to create an output stream that we can use to send data to the remote peer.
+   * Corresponds to {@code FLAG_FIN}.
    */
   public void reply(List<Header> responseHeaders, boolean out) throws IOException {
-    assert (!Thread.holdsLock(SpdyStream.this));
+    assert (!Thread.holdsLock(FramedStream.this));
     boolean outFinished = false;
     synchronized (this) {
       if (responseHeaders == null) {
@@ -198,8 +198,8 @@ public Source getSource() {
   /**
    * Returns a sink that can be used to write data to the peer.
    *
-   * @throws IllegalStateException if this stream was initiated by the peer
-   *     and a {@link #reply} has not yet been sent.
+   * @throws IllegalStateException if this stream was initiated by the peer and a {@link #reply} has
+   * not yet been sent.
    */
   public Sink getSink() {
     synchronized (this) {
@@ -211,8 +211,8 @@ public Sink getSink() {
   }
 
   /**
-   * Abnormally terminate this stream. This blocks until the {@code RST_STREAM}
-   * frame has been transmitted.
+   * Abnormally terminate this stream. This blocks until the {@code RST_STREAM} frame has been
+   * transmitted.
    */
   public void close(ErrorCode rstStatusCode) throws IOException {
     if (!closeInternal(rstStatusCode)) {
@@ -222,8 +222,8 @@ public void close(ErrorCode rstStatusCode) throws IOException {
   }
 
   /**
-   * Abnormally terminate this stream. This enqueues a {@code RST_STREAM}
-   * frame and returns immediately.
+   * Abnormally terminate this stream. This enqueues a {@code RST_STREAM} frame and returns
+   * immediately.
    */
   public void closeLater(ErrorCode errorCode) {
     if (!closeInternal(errorCode)) {
@@ -250,7 +250,7 @@ private boolean closeInternal(ErrorCode errorCode) {
   }
 
   void receiveHeaders(List<Header> headers, HeadersMode headersMode) {
-    assert (!Thread.holdsLock(SpdyStream.this));
+    assert (!Thread.holdsLock(FramedStream.this));
     ErrorCode errorCode = null;
     boolean open = true;
     synchronized (this) {
@@ -281,12 +281,12 @@ void receiveHeaders(List<Header> headers, HeadersMode headersMode) {
   }
 
   void receiveData(BufferedSource in, int length) throws IOException {
-    assert (!Thread.holdsLock(SpdyStream.this));
+    assert (!Thread.holdsLock(FramedStream.this));
     this.source.receive(in, length);
   }
 
   void receiveFin() {
-    assert (!Thread.holdsLock(SpdyStream.this));
+    assert (!Thread.holdsLock(FramedStream.this));
     boolean open;
     synchronized (this) {
       this.source.finished = true;
@@ -306,15 +306,15 @@ synchronized void receiveRstStream(ErrorCode errorCode) {
   }
 
   /**
-   * A source that reads the incoming data frames of a stream. Although this
-   * class uses synchronization to safely receive incoming data frames, it is
-   * not intended for use by multiple readers.
+   * A source that reads the incoming data frames of a stream. Although this class uses
+   * synchronization to safely receive incoming data frames, it is not intended for use by multiple
+   * readers.
    */
-  private final class SpdyDataSource implements Source {
+  private final class FramedDataSource implements Source {
     /** Buffer to receive data from the network into. Only accessed by the reader thread. */
     private final Buffer receiveBuffer = new Buffer();
 
-    /** Buffer with readable data. Guarded by SpdyStream.this. */
+    /** Buffer with readable data. Guarded by FramedStream.this. */
     private final Buffer readBuffer = new Buffer();
 
     /** Maximum number of bytes to buffer before reporting a flow control error. */
@@ -324,12 +324,12 @@ synchronized void receiveRstStream(ErrorCode errorCode) {
     private boolean closed;
 
     /**
-     * True if either side has cleanly shut down this stream. We will
-     * receive no more bytes beyond those already in the buffer.
+     * True if either side has cleanly shut down this stream. We will receive no more bytes beyond
+     * those already in the buffer.
      */
     private boolean finished;
 
-    private SpdyDataSource(long maxByteCount) {
+    private FramedDataSource(long maxByteCount) {
       this.maxByteCount = maxByteCount;
     }
 
@@ -338,7 +338,7 @@ private SpdyDataSource(long maxByteCount) {
       if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
 
       long read;
-      synchronized (SpdyStream.this) {
+      synchronized (FramedStream.this) {
         waitUntilReadable();
         checkNotClosed();
         if (readBuffer.size() == 0) return -1; // This source is exhausted.
@@ -381,12 +381,12 @@ private void waitUntilReadable() throws IOException {
     }
 
     void receive(BufferedSource in, long byteCount) throws IOException {
-      assert (!Thread.holdsLock(SpdyStream.this));
+      assert (!Thread.holdsLock(FramedStream.this));
 
       while (byteCount > 0) {
         boolean finished;
         boolean flowControlError;
-        synchronized (SpdyStream.this) {
+        synchronized (FramedStream.this) {
           finished = this.finished;
           flowControlError = byteCount + readBuffer.size() > maxByteCount;
         }
@@ -410,11 +410,11 @@ void receive(BufferedSource in, long byteCount) throws IOException {
         byteCount -= read;
 
         // Move the received data to the read buffer to the reader can read it.
-        synchronized (SpdyStream.this) {
+        synchronized (FramedStream.this) {
           boolean wasEmpty = readBuffer.size() == 0;
           readBuffer.writeAll(receiveBuffer);
           if (wasEmpty) {
-            SpdyStream.this.notifyAll();
+            FramedStream.this.notifyAll();
           }
         }
       }
@@ -425,10 +425,10 @@ void receive(BufferedSource in, long byteCount) throws IOException {
     }
 
     @Override public void close() throws IOException {
-      synchronized (SpdyStream.this) {
+      synchronized (FramedStream.this) {
         closed = true;
         readBuffer.clear();
-        SpdyStream.this.notifyAll();
+        FramedStream.this.notifyAll();
       }
       cancelStreamIfNecessary();
     }
@@ -438,13 +438,13 @@ private void checkNotClosed() throws IOException {
         throw new IOException("stream closed");
       }
       if (errorCode != null) {
-        throw new IOException("stream was reset: " + errorCode);
+        throw new StreamResetException(errorCode);
       }
     }
   }
 
   private void cancelStreamIfNecessary() throws IOException {
-    assert (!Thread.holdsLock(SpdyStream.this));
+    assert (!Thread.holdsLock(FramedStream.this));
     boolean open;
     boolean cancel;
     synchronized (this) {
@@ -456,35 +456,33 @@ private void cancelStreamIfNecessary() throws IOException {
       // is safe because the input stream is closed (we won't use any
       // further bytes) and the output stream is either finished or closed
       // (so RSTing both streams doesn't cause harm).
-      SpdyStream.this.close(ErrorCode.CANCEL);
+      FramedStream.this.close(ErrorCode.CANCEL);
     } else if (!open) {
       connection.removeStream(id);
     }
   }
 
   /**
-   * A sink that writes outgoing data frames of a stream. This class is not
-   * thread safe.
+   * A sink that writes outgoing data frames of a stream. This class is not thread safe.
    */
-  final class SpdyDataSink implements Sink {
+  final class FramedDataSink implements Sink {
     private static final long EMIT_BUFFER_SIZE = 16384;
 
     /**
-     * Buffer of outgoing data. This batches writes of small writes into this sink as larges
-     * frames written to the outgoing connection. Batching saves the (small) framing overhead.
+     * Buffer of outgoing data. This batches writes of small writes into this sink as larges frames
+     * written to the outgoing connection. Batching saves the (small) framing overhead.
      */
     private final Buffer sendBuffer = new Buffer();
 
     private boolean closed;
 
     /**
-     * True if either side has cleanly shut down this stream. We shall send
-     * no more bytes.
+     * True if either side has cleanly shut down this stream. We shall send no more bytes.
      */
     private boolean finished;
 
     @Override public void write(Buffer source, long byteCount) throws IOException {
-      assert (!Thread.holdsLock(SpdyStream.this));
+      assert (!Thread.holdsLock(FramedStream.this));
       sendBuffer.write(source, byteCount);
       while (sendBuffer.size() >= EMIT_BUFFER_SIZE) {
         emitDataFrame(false);
@@ -497,11 +495,11 @@ private void cancelStreamIfNecessary() throws IOException {
      */
     private void emitDataFrame(boolean outFinished) throws IOException {
       long toWrite;
-      synchronized (SpdyStream.this) {
+      synchronized (FramedStream.this) {
         writeTimeout.enter();
         try {
           while (bytesLeftInWriteWindow <= 0 && !finished && !closed && errorCode == null) {
-            waitForIo(); // Wait until we receive a WINDOW_UPDATE.
+            waitForIo(); // Wait until we receive a WINDOW_UPDATE for this stream.
           }
         } finally {
           writeTimeout.exitAndThrowIfTimedOut();
@@ -512,18 +510,23 @@ private void emitDataFrame(boolean outFinished) throws IOException {
         bytesLeftInWriteWindow -= toWrite;
       }
 
-      connection.writeData(id, outFinished && toWrite == sendBuffer.size(), sendBuffer, toWrite);
+      writeTimeout.enter();
+      try {
+        connection.writeData(id, outFinished && toWrite == sendBuffer.size(), sendBuffer, toWrite);
+      } finally {
+        writeTimeout.exitAndThrowIfTimedOut();
+      }
     }
 
     @Override public void flush() throws IOException {
-      assert (!Thread.holdsLock(SpdyStream.this));
-      synchronized (SpdyStream.this) {
+      assert (!Thread.holdsLock(FramedStream.this));
+      synchronized (FramedStream.this) {
         checkOutNotClosed();
       }
       while (sendBuffer.size() > 0) {
         emitDataFrame(false);
+        connection.flush();
       }
-      connection.flush();
     }
 
     @Override public Timeout timeout() {
@@ -531,8 +534,8 @@ private void emitDataFrame(boolean outFinished) throws IOException {
     }
 
     @Override public void close() throws IOException {
-      assert (!Thread.holdsLock(SpdyStream.this));
-      synchronized (SpdyStream.this) {
+      assert (!Thread.holdsLock(FramedStream.this));
+      synchronized (FramedStream.this) {
         if (closed) return;
       }
       if (!sink.finished) {
@@ -546,7 +549,7 @@ private void emitDataFrame(boolean outFinished) throws IOException {
           connection.writeData(id, true, null, 0);
         }
       }
-      synchronized (SpdyStream.this) {
+      synchronized (FramedStream.this) {
         closed = true;
       }
       connection.flush();
@@ -555,12 +558,11 @@ private void emitDataFrame(boolean outFinished) throws IOException {
   }
 
   /**
-   * {@code delta} will be negative if a settings frame initial window is
-   * smaller than the last.
+   * {@code delta} will be negative if a settings frame initial window is smaller than the last.
    */
   void addBytesToWriteWindow(long delta) {
     bytesLeftInWriteWindow += delta;
-    if (delta > 0) SpdyStream.this.notifyAll();
+    if (delta > 0) FramedStream.this.notifyAll();
   }
 
   private void checkOutNotClosed() throws IOException {
@@ -569,13 +571,13 @@ private void checkOutNotClosed() throws IOException {
     } else if (sink.finished) {
       throw new IOException("stream finished");
     } else if (errorCode != null) {
-      throw new IOException("stream was reset: " + errorCode);
+      throw new StreamResetException(errorCode);
     }
   }
 
   /**
-   * Like {@link #wait}, but throws an {@code InterruptedIOException} when
-   * interrupted instead of the more awkward {@link InterruptedException}.
+   * Like {@link #wait}, but throws an {@code InterruptedIOException} when interrupted instead of
+   * the more awkward {@link InterruptedException}.
    */
   private void waitForIo() throws InterruptedIOException {
     try {
@@ -586,17 +588,24 @@ private void waitForIo() throws InterruptedIOException {
   }
 
   /**
-   * The Okio timeout watchdog will call {@link #timedOut} if the timeout is
-   * reached. In that case we close the stream (asynchronously) which will
-   * notify the waiting thread.
+   * The Okio timeout watchdog will call {@link #timedOut} if the timeout is reached. In that case
+   * we close the stream (asynchronously) which will notify the waiting thread.
    */
-  class SpdyTimeout extends AsyncTimeout {
+  class StreamTimeout extends AsyncTimeout {
     @Override protected void timedOut() {
       closeLater(ErrorCode.CANCEL);
     }
 
-    public void exitAndThrowIfTimedOut() throws InterruptedIOException {
-      if (exit()) throw new InterruptedIOException("timeout");
+    @Override protected IOException newTimeoutException(IOException cause) {
+      SocketTimeoutException socketTimeoutException = new SocketTimeoutException("timeout");
+      if (cause != null) {
+        socketTimeoutException.initCause(cause);
+      }
+      return socketTimeoutException;
+    }
+
+    public void exitAndThrowIfTimedOut() throws IOException {
+      if (exit()) throw newTimeoutException(null /* cause */);
     }
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Header.java b/okhttp/src/main/java/okhttp3/internal/framed/Header.java
similarity index 72%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Header.java
rename to okhttp/src/main/java/okhttp3/internal/framed/Header.java
index d14d13115d..866edc2591 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Header.java
+++ b/okhttp/src/main/java/okhttp3/internal/framed/Header.java
@@ -1,5 +1,21 @@
-package com.squareup.okhttp.internal.spdy;
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.framed;
 
+import okhttp3.internal.Util;
 import okio.ByteString;
 
 /** HTTP header: the name is an ASCII string, but the value can be UTF-8. */
@@ -51,6 +67,6 @@ public Header(ByteString name, ByteString value) {
   }
 
   @Override public String toString() {
-    return String.format("%s: %s", name.utf8(), value.utf8());
+    return Util.format("%s: %s", name.utf8(), value.utf8());
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HeadersMode.java b/okhttp/src/main/java/okhttp3/internal/framed/HeadersMode.java
similarity index 92%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HeadersMode.java
rename to okhttp/src/main/java/okhttp3/internal/framed/HeadersMode.java
index c06327acf4..bc851ed784 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HeadersMode.java
+++ b/okhttp/src/main/java/okhttp3/internal/framed/HeadersMode.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.spdy;
+package okhttp3.internal.framed;
 
 public enum HeadersMode {
   SPDY_SYN_STREAM,
@@ -32,16 +32,14 @@ public boolean failIfStreamPresent() {
   }
 
   /**
-   * Returns true if it is an error these headers to be the initial headers of a
-   * response.
+   * Returns true if it is an error these headers to be the initial headers of a response.
    */
   public boolean failIfHeadersAbsent() {
     return this == SPDY_HEADERS;
   }
 
   /**
-   * Returns true if it is an error these headers to be update existing headers
-   * of a response.
+   * Returns true if it is an error these headers to be update existing headers of a response.
    */
   public boolean failIfHeadersPresent() {
     return this == SPDY_REPLY;
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Hpack.java b/okhttp/src/main/java/okhttp3/internal/framed/Hpack.java
similarity index 96%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Hpack.java
rename to okhttp/src/main/java/okhttp3/internal/framed/Hpack.java
index e8f9e51472..2b49784e9b 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Hpack.java
+++ b/okhttp/src/main/java/okhttp3/internal/framed/Hpack.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.spdy;
+package okhttp3.internal.framed;
 
 import java.io.IOException;
 import java.util.ArrayList;
@@ -33,9 +33,9 @@
  *
  * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12
  *
- * This implementation uses an array for the dynamic table and a list for
- * indexed entries.  Dynamic entries are added to the array, starting in the
- * last position moving forward.  When the array fills, it is doubled.
+ * This implementation uses an array for the dynamic table and a list for indexed entries.  Dynamic
+ * entries are added to the array, starting in the last position moving forward.  When the array
+ * fills, it is doubled.
  */
 final class Hpack {
   private static final int PREFIX_4_BITS = 0x0f;
@@ -136,11 +136,11 @@ int maxDynamicTableByteCount() {
     }
 
     /**
-     * Called by the reader when the peer sent {@link Settings#HEADER_TABLE_SIZE}.
-     * While this establishes the maximum dynamic table size, the
-     * {@link #maxDynamicTableByteCount} set during processing may limit the
-     * table size to a smaller amount.
-     * <p> Evicts entries or clears the table as needed.
+     * Called by the reader when the peer sent {@link Settings#HEADER_TABLE_SIZE}. While this
+     * establishes the maximum dynamic table size, the {@link #maxDynamicTableByteCount} set during
+     * processing may limit the table size to a smaller amount.
+     *
+     * <p>Evicts entries or clears the table as needed.
      */
     void headerTableSizeSetting(int headerTableSizeSetting) {
       this.headerTableSizeSetting = headerTableSizeSetting;
@@ -185,8 +185,8 @@ private int evictToRecoverBytes(int bytesToRecover) {
     }
 
     /**
-     * Read {@code byteCount} bytes of headers from the source stream. This
-     * implementation does not propagate the never indexed flag of a header.
+     * Read {@code byteCount} bytes of headers from the source stream. This implementation does not
+     * propagate the never indexed flag of a header.
      */
     void readHeaders() throws IOException {
       while (!source.exhausted()) {
@@ -420,8 +420,8 @@ void writeByteString(ByteString data) throws IOException {
   }
 
   /**
-   * An HTTP/2 response cannot contain uppercase header characters and must
-   * be treated as malformed.
+   * An HTTP/2 response cannot contain uppercase header characters and must be treated as
+   * malformed.
    */
   private static ByteString checkLowercase(ByteString name) throws IOException {
     for (int i = 0, length = name.size(); i < length; i++) {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Http2.java b/okhttp/src/main/java/okhttp3/internal/framed/Http2.java
similarity index 94%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Http2.java
rename to okhttp/src/main/java/okhttp3/internal/framed/Http2.java
index 34b0df48fc..8ad6c5224e 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Http2.java
+++ b/okhttp/src/main/java/okhttp3/internal/framed/Http2.java
@@ -13,12 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.spdy;
+package okhttp3.internal.framed;
 
-import com.squareup.okhttp.Protocol;
 import java.io.IOException;
 import java.util.List;
 import java.util.logging.Logger;
+import okhttp3.Protocol;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -26,18 +26,17 @@
 import okio.Source;
 import okio.Timeout;
 
-import static com.squareup.okhttp.internal.spdy.Http2.FrameLogger.formatHeader;
-import static java.lang.String.format;
 import static java.util.logging.Level.FINE;
+import static okhttp3.internal.Util.format;
+import static okhttp3.internal.framed.Http2.FrameLogger.formatHeader;
 import static okio.ByteString.EMPTY;
 
 /**
  * Read and write HTTP/2 frames.
- * <p>
- * This implementation assumes we do not send an increased
- * {@link Settings#getMaxFrameSize frame size setting} to the peer. Hence, we
- * expect all frames to have a max length of {@link #INITIAL_MAX_FRAME_SIZE}.
- * <p>http://tools.ietf.org/html/draft-ietf-httpbis-http2-17
+ *
+ * <p>This implementation assumes we do not send an increased {@link Settings#getMaxFrameSize frame
+ * size setting} to the peer. Hence, we expect all frames to have a max length of {@link
+ * #INITIAL_MAX_FRAME_SIZE}. <p>http://tools.ietf.org/html/draft-ietf-httpbis-http2-17
  */
 public final class Http2 implements Variant {
   private static final Logger logger = Logger.getLogger(FrameLogger.class.getName());
@@ -73,8 +72,7 @@
   static final byte FLAG_COMPRESSED = 0x20; // Used for data.
 
   /**
-   * Creates a frame reader with max header table size of 4096 and data frame
-   * compression disabled.
+   * Creates a frame reader with max header table size of 4096 and data frame compression disabled.
    */
   @Override public FrameReader newReader(BufferedSource source, boolean client) {
     return new Reader(source, 4096, client);
@@ -296,7 +294,7 @@ private void readSettings(Handler handler, int length, byte flags, int streamId)
           case 6: // SETTINGS_MAX_HEADER_LIST_SIZE
             break; // Advisory only, so ignored.
           default:
-            throw ioException("PROTOCOL_ERROR invalid settings id: %s", id);
+            break; // Must ignore setting with unknown id.
         }
         settings.set(id, 0, value);
       }
@@ -425,7 +423,6 @@ private void readWindowUpdate(Handler handler, int length, byte flags, int strea
     @Override public synchronized void pushPromise(int streamId, int promisedStreamId,
         List<Header> requestHeaders) throws IOException {
       if (closed) throw new IOException("closed");
-      if (hpackBuffer.size() != 0) throw new IllegalStateException();
       hpackWriter.writeHeaders(requestHeaders);
 
       long byteCount = hpackBuffer.size();
@@ -441,7 +438,6 @@ private void readWindowUpdate(Handler handler, int length, byte flags, int strea
 
     void headers(boolean outFinished, int streamId, List<Header> headerBlock) throws IOException {
       if (closed) throw new IOException("closed");
-      if (hpackBuffer.size() != 0) throw new IllegalStateException();
       hpackWriter.writeHeaders(headerBlock);
 
       long byteCount = hpackBuffer.size();
@@ -467,7 +463,7 @@ private void writeContinuationFrames(int streamId, long byteCount) throws IOExce
     @Override public synchronized void rstStream(int streamId, ErrorCode errorCode)
         throws IOException {
       if (closed) throw new IOException("closed");
-      if (errorCode.spdyRstCode == -1) throw new IllegalArgumentException();
+      if (errorCode.httpCode == -1) throw new IllegalArgumentException();
 
       int length = 4;
       byte type = TYPE_RST_STREAM;
@@ -507,8 +503,11 @@ void dataFrame(int streamId, byte flags, Buffer buffer, int byteCount) throws IO
       for (int i = 0; i < Settings.COUNT; i++) {
         if (!settings.isSet(i)) continue;
         int id = i;
-        if (id == 4) id = 3; // SETTINGS_MAX_CONCURRENT_STREAMS renumbered.
-        else if (id == 7) id = 4; // SETTINGS_INITIAL_WINDOW_SIZE renumbered.
+        if (id == 4) {
+          id = 3; // SETTINGS_MAX_CONCURRENT_STREAMS renumbered.
+        } else if (id == 7) {
+          id = 4; // SETTINGS_INITIAL_WINDOW_SIZE renumbered.
+        }
         sink.writeShort(id);
         sink.writeInt(settings.get(i));
       }
@@ -587,9 +586,8 @@ private static IOException ioException(String message, Object... args) throws IO
   }
 
   /**
-   * Decompression of the header block occurs above the framing layer. This
-   * class lazily reads continuation frames as they are needed by {@link
-   * Hpack.Reader#readHeaders()}.
+   * Decompression of the header block occurs above the framing layer. This class lazily reads
+   * continuation frames as they are needed by {@link Hpack.Reader#readHeaders()}.
    */
   static final class ContinuationSource implements Source {
     private final BufferedSource source;
@@ -659,8 +657,7 @@ private static int lengthWithoutPadding(int length, byte flags, short padding)
    * </pre>
    * Where direction is {@code <<} for inbound and {@code >>} for outbound.
    *
-   * <p> For example, the following would indicate a HEAD request sent from
-   * the client.
+   * <p>For example, the following would indicate a HEAD request sent from the client.
    * <pre>
    * {@code
    *   << 0x0000000f    12 HEADERS       END_HEADERS|END_STREAM
@@ -677,8 +674,8 @@ static String formatHeader(boolean inbound, int streamId, int length, byte type,
     }
 
     /**
-     * Looks up valid string representing flags from the table. Invalid
-     * combinations are represented in binary.
+     * Looks up valid string representing flags from the table. Invalid combinations are represented
+     * in binary.
      */
     // Visible for testing.
     static String formatFlags(byte type, byte flags) {
@@ -718,8 +715,8 @@ static String formatFlags(byte type, byte flags) {
     };
 
     /**
-     * Lookup table for valid flags for DATA, HEADERS, CONTINUATION. Invalid
-     * combinations are represented in binary.
+     * Lookup table for valid flags for DATA, HEADERS, CONTINUATION. Invalid combinations are
+     * represented in binary.
      */
     private static final String[] FLAGS = new String[0x40]; // Highest bit flag is 0x20.
     private static final String[] BINARY = new String[256];
@@ -736,7 +733,7 @@ static String formatFlags(byte type, byte flags) {
 
       FLAGS[FLAG_PADDED] = "PADDED";
       for (int prefixFlag : prefixFlags) {
-         FLAGS[prefixFlag | FLAG_PADDED] = FLAGS[prefixFlag] + "|PADDED";
+        FLAGS[prefixFlag | FLAG_PADDED] = FLAGS[prefixFlag] + "|PADDED";
       }
 
       FLAGS[FLAG_END_HEADERS] = "END_HEADERS"; // Same as END_PUSH_PROMISE.
@@ -761,13 +758,13 @@ static String formatFlags(byte type, byte flags) {
 
   private static int readMedium(BufferedSource source) throws IOException {
     return (source.readByte() & 0xff) << 16
-        |  (source.readByte() & 0xff) <<  8
-        |  (source.readByte() & 0xff);
+        | (source.readByte() & 0xff) << 8
+        | (source.readByte() & 0xff);
   }
 
   private static void writeMedium(BufferedSink sink, int i) throws IOException {
     sink.writeByte((i >>> 16) & 0xff);
-    sink.writeByte((i >>>  8) & 0xff);
-    sink.writeByte(i          & 0xff);
+    sink.writeByte((i >>> 8) & 0xff);
+    sink.writeByte(i & 0xff);
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Huffman.java b/okhttp/src/main/java/okhttp3/internal/framed/Huffman.java
similarity index 96%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Huffman.java
rename to okhttp/src/main/java/okhttp3/internal/framed/Huffman.java
index 06d5243d7e..0c7f3012a7 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Huffman.java
+++ b/okhttp/src/main/java/okhttp3/internal/framed/Huffman.java
@@ -13,19 +13,20 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.spdy;
+package okhttp3.internal.framed;
 
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.io.OutputStream;
 
 /**
- * This class was originally composed from the following classes in
- * <a href="https://github.com/twitter/hpack">Twitter Hpack</a>.
+ * This class was originally composed from the following classes in <a
+ * href="https://github.com/twitter/hpack">Twitter Hpack</a>.
+ *
  * <ul>
- * <li>{@code com.twitter.hpack.HuffmanEncoder}</li>
- * <li>{@code com.twitter.hpack.HuffmanDecoder}</li>
- * <li>{@code com.twitter.hpack.HpackUtil}</li>
+ *     <li>{@code com.twitter.hpack.HuffmanEncoder}</li>
+ *     <li>{@code com.twitter.hpack.HuffmanDecoder}</li>
+ *     <li>{@code com.twitter.hpack.HpackUtil}</li>
  * </ul>
  */
 class Huffman {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java b/okhttp/src/main/java/okhttp3/internal/framed/NameValueBlockReader.java
similarity index 93%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java
rename to okhttp/src/main/java/okhttp3/internal/framed/NameValueBlockReader.java
index 6413f36345..75cd9594f7 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java
+++ b/okhttp/src/main/java/okhttp3/internal/framed/NameValueBlockReader.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.spdy;
+package okhttp3.internal.framed;
 
 import java.io.IOException;
 import java.util.ArrayList;
@@ -29,18 +29,17 @@
 import okio.Source;
 
 /**
- * Reads a SPDY/3 Name/Value header block. This class is made complicated by the
- * requirement that we're strict with which bytes we put in the compressed bytes
- * buffer. We need to put all compressed bytes into that buffer -- but no other
- * bytes.
+ * Reads a SPDY/3 Name/Value header block. This class is made complicated by the requirement that
+ * we're strict with which bytes we put in the compressed bytes buffer. We need to put all
+ * compressed bytes into that buffer -- but no other bytes.
  */
 class NameValueBlockReader {
   /** This source transforms compressed bytes into uncompressed bytes. */
   private final InflaterSource inflaterSource;
 
   /**
-   * How many compressed bytes must be read into inflaterSource before
-   * {@link #readNameValueBlock} returns.
+   * How many compressed bytes must be read into inflaterSource before {@link #readNameValueBlock}
+   * returns.
    */
   private int compressedLimit;
 
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Ping.java b/okhttp/src/main/java/okhttp3/internal/framed/Ping.java
similarity index 87%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Ping.java
rename to okhttp/src/main/java/okhttp3/internal/framed/Ping.java
index 06b0aefccf..d3e0b428d6 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Ping.java
+++ b/okhttp/src/main/java/okhttp3/internal/framed/Ping.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.spdy;
+package okhttp3.internal.framed;
 
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
@@ -47,9 +47,8 @@ void cancel() {
   }
 
   /**
-   * Returns the round trip time for this ping in nanoseconds, waiting for the
-   * response to arrive if necessary. Returns -1 if the response was
-   * canceled.
+   * Returns the round trip time for this ping in nanoseconds, waiting for the response to arrive if
+   * necessary. Returns -1 if the response was canceled.
    */
   public long roundTripTime() throws InterruptedException {
     latch.await();
@@ -57,9 +56,8 @@ public long roundTripTime() throws InterruptedException {
   }
 
   /**
-   * Returns the round trip time for this ping in nanoseconds, or -1 if the
-   * response was canceled, or -2 if the timeout elapsed before the round
-   * trip completed.
+   * Returns the round trip time for this ping in nanoseconds, or -1 if the response was canceled,
+   * or -2 if the timeout elapsed before the round trip completed.
    */
   public long roundTripTime(long timeout, TimeUnit unit) throws InterruptedException {
     if (latch.await(timeout, unit)) {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/PushObserver.java b/okhttp/src/main/java/okhttp3/internal/framed/PushObserver.java
similarity index 77%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/spdy/PushObserver.java
rename to okhttp/src/main/java/okhttp3/internal/framed/PushObserver.java
index cdb51f65a5..95dd41a5b9 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/PushObserver.java
+++ b/okhttp/src/main/java/okhttp3/internal/framed/PushObserver.java
@@ -13,44 +13,44 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.spdy;
+package okhttp3.internal.framed;
 
 import java.io.IOException;
 import java.util.List;
+import okhttp3.Protocol;
 import okio.BufferedSource;
 
 /**
- * {@link com.squareup.okhttp.Protocol#HTTP_2 HTTP/2} only.
- * Processes server-initiated HTTP requests on the client. Implementations must
- * quickly dispatch callbacks to avoid creating a bottleneck.
+ * {@link Protocol#HTTP_2 HTTP/2} only. Processes server-initiated HTTP requests on the client.
+ * Implementations must quickly dispatch callbacks to avoid creating a bottleneck.
+ *
+ * <p>While {@link #onReset} may occur at any time, the following callbacks are expected in order,
+ * correlated by stream ID.
  *
- * <p>While {@link #onReset} may occur at any time, the following callbacks are
- * expected in order, correlated by stream ID.
  * <ul>
- *   <li>{@link #onRequest}</li>
- *   <li>{@link #onHeaders} (unless canceled)</li>
- *   <li>{@link #onData} (optional sequence of data frames)</li>
+ *     <li>{@link #onRequest}</li> <li>{@link #onHeaders} (unless canceled)
+ *     <li>{@link #onData} (optional sequence of data frames)
  * </ul>
  *
- * <p>As a stream ID is scoped to a single HTTP/2 connection, implementations
- * which target multiple connections should expect repetition of stream IDs.
+ * <p>As a stream ID is scoped to a single HTTP/2 connection, implementations which target multiple
+ * connections should expect repetition of stream IDs.
  *
- * <p>Return true to request cancellation of a pushed stream.  Note that this
- * does not guarantee future frames won't arrive on the stream ID.
+ * <p>Return true to request cancellation of a pushed stream.  Note that this does not guarantee
+ * future frames won't arrive on the stream ID.
  */
 public interface PushObserver {
   /**
    * Describes the request that the server intends to push a response for.
    *
    * @param streamId server-initiated stream ID: an even number.
-   * @param requestHeaders minimally includes {@code :method}, {@code :scheme},
-   * {@code :authority}, and (@code :path}.
+   * @param requestHeaders minimally includes {@code :method}, {@code :scheme}, {@code :authority},
+   * and (@code :path}.
    */
   boolean onRequest(int streamId, List<Header> requestHeaders);
 
   /**
-   * The response headers corresponding to a pushed request.  When {@code last}
-   * is true, there are no data frames to follow.
+   * The response headers corresponding to a pushed request.  When {@code last} is true, there are
+   * no data frames to follow.
    *
    * @param streamId server-initiated stream ID: an even number.
    * @param responseHeaders minimally includes {@code :status}.
@@ -59,8 +59,8 @@
   boolean onHeaders(int streamId, List<Header> responseHeaders, boolean last);
 
   /**
-   * A chunk of response data corresponding to a pushed request.  This data
-   * must either be read or skipped.
+   * A chunk of response data corresponding to a pushed request.  This data must either be read or
+   * skipped.
    *
    * @param streamId server-initiated stream ID: an even number.
    * @param source location of data corresponding with this stream ID.
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Settings.java b/okhttp/src/main/java/okhttp3/internal/framed/Settings.java
similarity index 95%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Settings.java
rename to okhttp/src/main/java/okhttp3/internal/framed/Settings.java
index bb67b8311a..f4eab01731 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Settings.java
+++ b/okhttp/src/main/java/okhttp3/internal/framed/Settings.java
@@ -13,18 +13,18 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.spdy;
+package okhttp3.internal.framed;
 
 import java.util.Arrays;
 
 /**
  * Settings describe characteristics of the sending peer, which are used by the receiving peer.
- * Settings are {@link com.squareup.okhttp.internal.spdy.SpdyConnection connection} scoped.
+ * Settings are {@link FramedConnection connection} scoped.
  */
 public final class Settings {
   /**
-   * From the SPDY/3 and HTTP/2 specs, the default initial window size for all
-   * streams is 64 KiB. (Chrome 25 uses 10 MiB).
+   * From the SPDY/3 and HTTP/2 specs, the default initial window size for all streams is 64 KiB.
+   * (Chrome 25 uses 10 MiB).
    */
   static final int DEFAULT_INITIAL_WINDOW_SIZE = 64 * 1024;
 
@@ -212,8 +212,8 @@ boolean isFlowControlDisabled() {
   }
 
   /**
-   * Returns true if this user agent should use this setting in future spdy/3
-   * connections to the same host.
+   * Returns true if this user agent should use this setting in future spdy/3 connections to the
+   * same host.
    */
   boolean persistValue(int id) {
     int bit = 1 << id;
@@ -227,8 +227,8 @@ boolean isPersisted(int id) {
   }
 
   /**
-   * Writes {@code other} into this. If any setting is populated by this and
-   * {@code other}, the value and flags from {@code other} will be kept.
+   * Writes {@code other} into this. If any setting is populated by this and {@code other}, the
+   * value and flags from {@code other} will be kept.
    */
   void merge(Settings other) {
     for (int i = 0; i < COUNT; i++) {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java b/okhttp/src/main/java/okhttp3/internal/framed/Spdy3.java
similarity index 97%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
rename to okhttp/src/main/java/okhttp3/internal/framed/Spdy3.java
index c5cebe7c73..37e1796c5c 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
+++ b/okhttp/src/main/java/okhttp3/internal/framed/Spdy3.java
@@ -13,15 +13,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.spdy;
+package okhttp3.internal.framed;
 
-import com.squareup.okhttp.Protocol;
-import com.squareup.okhttp.internal.Util;
 import java.io.IOException;
 import java.io.UnsupportedEncodingException;
 import java.net.ProtocolException;
 import java.util.List;
 import java.util.zip.Deflater;
+import okhttp3.Protocol;
+import okhttp3.internal.Util;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -30,8 +30,7 @@
 import okio.Okio;
 
 /**
- * Read and write spdy/3.1 frames.
- * http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1
+ * Read and write spdy/3.1 frames. http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1
  */
 public final class Spdy3 implements Variant {
 
@@ -55,6 +54,7 @@
   static final int VERSION = 3;
 
   static final byte[] DICTIONARY;
+
   static {
     try {
       DICTIONARY = ("\u0000\u0000\u0000\u0007options\u0000\u0000\u0000\u0004hea"
@@ -119,8 +119,8 @@
     }
 
     /**
-     * Send the next frame to {@code handler}. Returns true unless there are no
-     * more frames on the stream.
+     * Send the next frame to {@code handler}. Returns true unless there are no more frames on the
+     * stream.
      */
     @Override public boolean nextFrame(Handler handler) throws IOException {
       int w1;
@@ -275,7 +275,7 @@ private void readSettings(Handler handler, int flags, int length) throws IOExcep
     }
 
     private static IOException ioException(String message, Object... args) throws IOException {
-      throw new IOException(String.format(message, args));
+      throw new IOException(Util.format(message, args));
     }
 
     @Override public void close() throws IOException {
@@ -406,7 +406,6 @@ void sendDataFrame(int streamId, int flags, Buffer buffer, int byteCount)
     }
 
     private void writeNameValueBlockToBuffer(List<Header> headerBlock) throws IOException {
-      if (headerBlockBuffer.size() != 0) throw new IllegalStateException();
       headerBlockOut.writeInt(headerBlock.size());
       for (int i = 0, size = headerBlock.size(); i < size; i++) {
         ByteString name = headerBlock.get(i).name;
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/StreamResetException.java b/okhttp/src/main/java/okhttp3/internal/framed/StreamResetException.java
new file mode 100644
index 0000000000..a7af0e4b41
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/framed/StreamResetException.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.framed;
+
+import java.io.IOException;
+
+/** Thrown when an HTTP/2 stream is canceled without damage to the socket that carries it. */
+public final class StreamResetException extends IOException {
+  public final ErrorCode errorCode;
+
+  public StreamResetException(ErrorCode errorCode) {
+    super("stream was reset: " + errorCode);
+    this.errorCode = errorCode;
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Variant.java b/okhttp/src/main/java/okhttp3/internal/framed/Variant.java
similarity index 93%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Variant.java
rename to okhttp/src/main/java/okhttp3/internal/framed/Variant.java
index c4b082d706..4ff3794007 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Variant.java
+++ b/okhttp/src/main/java/okhttp3/internal/framed/Variant.java
@@ -13,9 +13,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.spdy;
+package okhttp3.internal.framed;
 
-import com.squareup.okhttp.Protocol;
+import okhttp3.Protocol;
 import okio.BufferedSink;
 import okio.BufferedSource;
 
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheRequest.java b/okhttp/src/main/java/okhttp3/internal/http/CacheRequest.java
similarity index 94%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheRequest.java
rename to okhttp/src/main/java/okhttp3/internal/http/CacheRequest.java
index b8153e4f07..12c3134e8a 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheRequest.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/CacheRequest.java
@@ -13,12 +13,13 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.http;
+package okhttp3.internal.http;
 
 import java.io.IOException;
 import okio.Sink;
 
 public interface CacheRequest {
   Sink body() throws IOException;
+
   void abort();
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheStrategy.java b/okhttp/src/main/java/okhttp3/internal/http/CacheStrategy.java
similarity index 83%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheStrategy.java
rename to okhttp/src/main/java/okhttp3/internal/http/CacheStrategy.java
index 3f07edd7e1..7aa8af1a4b 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheStrategy.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/CacheStrategy.java
@@ -1,14 +1,26 @@
-package com.squareup.okhttp.internal.http;
-
-import com.squareup.okhttp.CacheControl;
-import com.squareup.okhttp.Headers;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http;
 
 import java.util.Date;
+import okhttp3.CacheControl;
+import okhttp3.Headers;
+import okhttp3.Request;
+import okhttp3.Response;
 
-import static com.squareup.okhttp.internal.http.StatusLine.HTTP_PERM_REDIRECT;
-import static com.squareup.okhttp.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
 import static java.net.HttpURLConnection.HTTP_BAD_METHOD;
 import static java.net.HttpURLConnection.HTTP_GONE;
 import static java.net.HttpURLConnection.HTTP_MOVED_PERM;
@@ -23,12 +35,12 @@
 import static java.util.concurrent.TimeUnit.SECONDS;
 
 /**
- * Given a request and cached response, this figures out whether to use the
- * network, the cache, or both.
+ * Given a request and cached response, this figures out whether to use the network, the cache, or
+ * both.
  *
- * <p>Selecting a cache strategy may add conditions to the request (like the
- * "If-Modified-Since" header for conditional GETs) or warnings to the cached
- * response (if the cached data is potentially stale).
+ * <p>Selecting a cache strategy may add conditions to the request (like the "If-Modified-Since"
+ * header for conditional GETs) or warnings to the cached response (if the cached data is
+ * potentially stale).
  */
 public final class CacheStrategy {
   /** The request to send on the network, or null if this call doesn't use the network. */
@@ -42,10 +54,7 @@ private CacheStrategy(Request networkRequest, Response cacheResponse) {
     this.cacheResponse = cacheResponse;
   }
 
-  /**
-   * Returns true if {@code response} can be stored to later serve another
-   * request.
-   */
+  /** Returns true if {@code response} can be stored to later serve another request. */
   public static boolean isCacheable(Response response, Request request) {
     // Always go to network for uncacheable response codes (RFC 7231 section 6.1),
     // This implementation doesn't support caching partial content.
@@ -60,12 +69,12 @@ public static boolean isCacheable(Response response, Request request) {
       case HTTP_GONE:
       case HTTP_REQ_TOO_LONG:
       case HTTP_NOT_IMPLEMENTED:
-      case HTTP_PERM_REDIRECT:
-      // These codes can be cached unless headers forbid it.
-      break;
+      case StatusLine.HTTP_PERM_REDIRECT:
+        // These codes can be cached unless headers forbid it.
+        break;
 
       case HTTP_MOVED_TEMP:
-      case HTTP_TEMP_REDIRECT:
+      case StatusLine.HTTP_TEMP_REDIRECT:
         // These codes can only be cached with the right response headers.
         // http://tools.ietf.org/html/rfc7234#section-3
         // s-maxage is not checked because OkHttp is a private cache that should ignore s-maxage.
@@ -100,20 +109,20 @@ public static boolean isCacheable(Response response, Request request) {
     private String lastModifiedString;
 
     /**
-     * The expiration date of the cached response, if known. If both this field
-     * and the max age are set, the max age is preferred.
+     * The expiration date of the cached response, if known. If both this field and the max age are
+     * set, the max age is preferred.
      */
     private Date expires;
 
     /**
-     * Extension header set by OkHttp specifying the timestamp when the cached
-     * HTTP request was first initiated.
+     * Extension header set by OkHttp specifying the timestamp when the cached HTTP request was
+     * first initiated.
      */
     private long sentRequestMillis;
 
     /**
-     * Extension header set by OkHttp specifying the timestamp when the cached
-     * HTTP response was first received.
+     * Extension header set by OkHttp specifying the timestamp when the cached HTTP response was
+     * first received.
      */
     private long receivedResponseMillis;
 
@@ -129,6 +138,8 @@ public Factory(long nowMillis, Request request, Response cacheResponse) {
       this.cacheResponse = cacheResponse;
 
       if (cacheResponse != null) {
+        this.sentRequestMillis = cacheResponse.sentRequestAtMillis();
+        this.receivedResponseMillis = cacheResponse.receivedResponseAtMillis();
         Headers headers = cacheResponse.headers();
         for (int i = 0, size = headers.size(); i < size; i++) {
           String fieldName = headers.name(i);
@@ -145,18 +156,13 @@ public Factory(long nowMillis, Request request, Response cacheResponse) {
             etag = value;
           } else if ("Age".equalsIgnoreCase(fieldName)) {
             ageSeconds = HeaderParser.parseSeconds(value, -1);
-          } else if (OkHeaders.SENT_MILLIS.equalsIgnoreCase(fieldName)) {
-            sentRequestMillis = Long.parseLong(value);
-          } else if (OkHeaders.RECEIVED_MILLIS.equalsIgnoreCase(fieldName)) {
-            receivedResponseMillis = Long.parseLong(value);
           }
         }
       }
     }
 
     /**
-     * Returns a strategy to satisfy {@code request} using the a cached response
-     * {@code response}.
+     * Returns a strategy to satisfy {@code request} using the a cached response {@code response}.
      */
     public CacheStrategy get() {
       CacheStrategy candidate = getCandidate();
@@ -240,8 +246,8 @@ private CacheStrategy getCandidate() {
     }
 
     /**
-     * Returns the number of milliseconds that the response was fresh for,
-     * starting from the served date.
+     * Returns the number of milliseconds that the response was fresh for, starting from the served
+     * date.
      */
     private long computeFreshnessLifetime() {
       CacheControl responseCaching = cacheResponse.cacheControl();
@@ -254,7 +260,7 @@ private long computeFreshnessLifetime() {
         long delta = expires.getTime() - servedMillis;
         return delta > 0 ? delta : 0;
       } else if (lastModified != null
-          && cacheResponse.request().url().getQuery() == null) {
+          && cacheResponse.request().url().query() == null) {
         // As recommended by the HTTP RFC and implemented in Firefox, the
         // max age of a document should be defaulted to 10% of the
         // document's age at the time it was served. Default expiration
@@ -269,8 +275,8 @@ private long computeFreshnessLifetime() {
     }
 
     /**
-     * Returns the current age of the response, in milliseconds. The calculation
-     * is specified by RFC 2616, 13.2.3 Age Calculations.
+     * Returns the current age of the response, in milliseconds. The calculation is specified by RFC
+     * 2616, 13.2.3 Age Calculations.
      */
     private long cacheResponseAge() {
       long apparentReceivedAge = servedDate != null
@@ -285,18 +291,17 @@ private long cacheResponseAge() {
     }
 
     /**
-     * Returns true if computeFreshnessLifetime used a heuristic. If we used a
-     * heuristic to serve a cached response older than 24 hours, we are required
-     * to attach a warning.
+     * Returns true if computeFreshnessLifetime used a heuristic. If we used a heuristic to serve a
+     * cached response older than 24 hours, we are required to attach a warning.
      */
     private boolean isFreshnessLifetimeHeuristic() {
       return cacheResponse.cacheControl().maxAgeSeconds() == -1 && expires == null;
     }
 
     /**
-     * Returns true if the request contains conditions that save the server from
-     * sending a response that the client has locally. When a request is enqueued
-     * with its own conditions, the built-in response cache won't be used.
+     * Returns true if the request contains conditions that save the server from sending a response
+     * that the client has locally. When a request is enqueued with its own conditions, the built-in
+     * response cache won't be used.
      */
     private static boolean hasConditions(Request request) {
       return request.header("If-Modified-Since") != null || request.header("If-None-Match") != null;
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HeaderParser.java b/okhttp/src/main/java/okhttp3/internal/http/HeaderParser.java
similarity index 83%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/http/HeaderParser.java
rename to okhttp/src/main/java/okhttp3/internal/http/HeaderParser.java
index 55f82ada47..1e27c988c4 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HeaderParser.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/HeaderParser.java
@@ -13,14 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
-package com.squareup.okhttp.internal.http;
+package okhttp3.internal.http;
 
 public final class HeaderParser {
   /**
-   * Returns the next index in {@code input} at or after {@code pos} that
-   * contains a character from {@code characters}. Returns the input length if
-   * none of the requested characters can be found.
+   * Returns the next index in {@code input} at or after {@code pos} that contains a character from
+   * {@code characters}. Returns the input length if none of the requested characters can be found.
    */
   public static int skipUntil(String input, int pos, String characters) {
     for (; pos < input.length(); pos++) {
@@ -32,8 +30,8 @@ public static int skipUntil(String input, int pos, String characters) {
   }
 
   /**
-   * Returns the next non-whitespace character in {@code input} that is white
-   * space. Result is undefined if input contains newline characters.
+   * Returns the next non-whitespace character in {@code input} that is white space. Result is
+   * undefined if input contains newline characters.
    */
   public static int skipWhitespace(String input, int pos) {
     for (; pos < input.length(); pos++) {
@@ -46,8 +44,8 @@ public static int skipWhitespace(String input, int pos) {
   }
 
   /**
-   * Returns {@code value} as a positive integer, or 0 if it is negative, or
-   * {@code defaultValue} if it cannot be parsed.
+   * Returns {@code value} as a positive integer, or 0 if it is negative, or {@code defaultValue} if
+   * it cannot be parsed.
    */
   public static int parseSeconds(String value, int defaultValue) {
     try {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java b/okhttp/src/main/java/okhttp3/internal/http/Http1xStream.java
similarity index 62%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java
rename to okhttp/src/main/java/okhttp3/internal/http/Http1xStream.java
index 6bf1802c07..d0160c9089 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/Http1xStream.java
@@ -13,53 +13,52 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+package okhttp3.internal.http;
 
-package com.squareup.okhttp.internal.http;
-
-import com.squareup.okhttp.Connection;
-import com.squareup.okhttp.ConnectionPool;
-import com.squareup.okhttp.Headers;
-import com.squareup.okhttp.Response;
-import com.squareup.okhttp.internal.Internal;
-import com.squareup.okhttp.internal.Util;
 import java.io.EOFException;
 import java.io.IOException;
 import java.net.ProtocolException;
-import java.net.Socket;
-import java.net.SocketTimeoutException;
+import okhttp3.Headers;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+import okhttp3.internal.Internal;
+import okhttp3.internal.Util;
+import okhttp3.internal.io.RealConnection;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
+import okio.ForwardingTimeout;
 import okio.Okio;
 import okio.Sink;
 import okio.Source;
 import okio.Timeout;
 
-import static com.squareup.okhttp.internal.Util.checkOffsetAndCount;
-import static com.squareup.okhttp.internal.http.StatusLine.HTTP_CONTINUE;
-import static com.squareup.okhttp.internal.http.Transport.DISCARD_STREAM_TIMEOUT_MILLIS;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static okhttp3.internal.Util.checkOffsetAndCount;
+import static okhttp3.internal.http.StatusLine.HTTP_CONTINUE;
 
 /**
- * A socket connection that can be used to send HTTP/1.1 messages. This class
- * strictly enforces the following lifecycle:
+ * A socket connection that can be used to send HTTP/1.1 messages. This class strictly enforces the
+ * following lifecycle:
+ *
  * <ol>
- *   <li>{@link #writeRequest Send request headers}.
- *   <li>Open a sink to write the request body. Either {@link
- *       #newFixedLengthSink fixed-length} or {@link #newChunkedSink chunked}.
- *   <li>Write to and then close that sink.
- *   <li>{@link #readResponse Read response headers}.
- *   <li>Open a source to read the response body. Either {@link
- *       #newFixedLengthSource fixed-length}, {@link #newChunkedSource chunked}
- *       or {@link #newUnknownLengthSource unknown length}.
- *   <li>Read from and close that source.
+ *     <li>{@linkplain #writeRequest Send request headers}.
+ *     <li>Open a sink to write the request body. Either {@linkplain #newFixedLengthSink
+ *         fixed-length} or {@link #newChunkedSink chunked}.
+ *     <li>Write to and then close that sink.
+ *     <li>{@linkplain #readResponse Read response headers}.
+ *     <li>Open a source to read the response body. Either {@linkplain #newFixedLengthSource
+ *         fixed-length}, {@linkplain #newChunkedSource chunked} or {@linkplain
+ *         #newUnknownLengthSource unknown length}.
+ *     <li>Read from and close that source.
  * </ol>
- * <p>Exchanges that do not have a request body may skip creating and closing
- * the request body. Exchanges that do not have a response body can call {@link
- * #newFixedLengthSource(long) newFixedLengthSource(0)} and may skip reading and
- * closing that source.
+ *
+ * <p>Exchanges that do not have a request body may skip creating and closing the request body.
+ * Exchanges that do not have a response body can call {@link #newFixedLengthSource(long)
+ * newFixedLengthSource(0)} and may skip reading and closing that source.
  */
-public final class HttpConnection {
+public final class Http1xStream implements HttpStream {
   private static final int STATE_IDLE = 0; // Idle connections are ready to write request headers.
   private static final int STATE_OPEN_REQUEST_BODY = 1;
   private static final int STATE_WRITING_REQUEST_BODY = 2;
@@ -68,63 +67,87 @@
   private static final int STATE_READING_RESPONSE_BODY = 5;
   private static final int STATE_CLOSED = 6;
 
-  private static final int ON_IDLE_HOLD = 0;
-  private static final int ON_IDLE_POOL = 1;
-  private static final int ON_IDLE_CLOSE = 2;
-
-  private final ConnectionPool pool;
-  private final Connection connection;
-  private final Socket socket;
+  /** The stream allocation that owns this stream. May be null for HTTPS proxy tunnels. */
+  private final StreamAllocation streamAllocation;
   private final BufferedSource source;
   private final BufferedSink sink;
-
+  private HttpEngine httpEngine;
   private int state = STATE_IDLE;
-  private int onIdle = ON_IDLE_HOLD;
-
-  public HttpConnection(ConnectionPool pool, Connection connection, Socket socket)
-      throws IOException {
-    this.pool = pool;
-    this.connection = connection;
-    this.socket = socket;
-    this.source = Okio.buffer(Okio.source(socket));
-    this.sink = Okio.buffer(Okio.sink(socket));
+
+  public Http1xStream(StreamAllocation streamAllocation, BufferedSource source, BufferedSink sink) {
+    this.streamAllocation = streamAllocation;
+    this.source = source;
+    this.sink = sink;
+  }
+
+  @Override public void setHttpEngine(HttpEngine httpEngine) {
+    this.httpEngine = httpEngine;
   }
 
-  public void setTimeouts(int readTimeoutMillis, int writeTimeoutMillis) {
-    if (readTimeoutMillis != 0) {
-      source.timeout().timeout(readTimeoutMillis, MILLISECONDS);
+  @Override public Sink createRequestBody(Request request, long contentLength) throws IOException {
+    if ("chunked".equalsIgnoreCase(request.header("Transfer-Encoding"))) {
+      // Stream a request body of unknown length.
+      return newChunkedSink();
     }
-    if (writeTimeoutMillis != 0) {
-      sink.timeout().timeout(writeTimeoutMillis, MILLISECONDS);
+
+    if (contentLength != -1) {
+      // Stream a request body of a known length.
+      return newFixedLengthSink(contentLength);
     }
+
+    throw new IllegalStateException(
+        "Cannot stream a request body without chunked encoding or a known content length!");
+  }
+
+  @Override public void cancel() {
+    RealConnection connection = streamAllocation.connection();
+    if (connection != null) connection.cancel();
   }
 
   /**
-   * Configure this connection to put itself back into the connection pool when
-   * the HTTP response body is exhausted.
+   * Prepares the HTTP headers and sends them to the server.
+   *
+   * <p>For streaming requests with a body, headers must be prepared <strong>before</strong> the
+   * output stream has been written to. Otherwise the body would need to be buffered!
+   *
+   * <p>For non-streaming requests with a body, headers must be prepared <strong>after</strong> the
+   * output stream has been written to and closed. This ensures that the {@code Content-Length}
+   * header field receives the proper value.
    */
-  public void poolOnIdle() {
-    onIdle = ON_IDLE_POOL;
+  @Override public void writeRequestHeaders(Request request) throws IOException {
+    httpEngine.writingRequestHeaders();
+    String requestLine = RequestLine.get(
+        request, httpEngine.getConnection().route().proxy().type());
+    writeRequest(request.headers(), requestLine);
+  }
 
-    // If we're already idle, go to the pool immediately.
-    if (state == STATE_IDLE) {
-      onIdle = ON_IDLE_HOLD; // Set the on idle policy back to the default.
-      Internal.instance.recycle(pool, connection);
-    }
+  @Override public Response.Builder readResponseHeaders() throws IOException {
+    return readResponse();
   }
 
-  /**
-   * Configure this connection to close itself when the HTTP response body is
-   * exhausted.
-   */
-  public void closeOnIdle() throws IOException {
-    onIdle = ON_IDLE_CLOSE;
+  @Override public ResponseBody openResponseBody(Response response) throws IOException {
+    Source source = getTransferStream(response);
+    return new RealResponseBody(response.headers(), Okio.buffer(source));
+  }
 
-    // If we're already idle, close immediately.
-    if (state == STATE_IDLE) {
-      state = STATE_CLOSED;
-      connection.getSocket().close();
+  private Source getTransferStream(Response response) throws IOException {
+    if (!HttpEngine.hasBody(response)) {
+      return newFixedLengthSource(0);
     }
+
+    if ("chunked".equalsIgnoreCase(response.header("Transfer-Encoding"))) {
+      return newChunkedSource(httpEngine);
+    }
+
+    long contentLength = OkHeaders.contentLength(response);
+    if (contentLength != -1) {
+      return newFixedLengthSource(contentLength);
+    }
+
+    // Wrap the input stream from the connection (rather than just returning
+    // "socketIn" directly here), so that we can control its use after the
+    // reference escapes.
+    return newUnknownLengthSource();
   }
 
   /** Returns true if this connection is closed. */
@@ -132,44 +155,15 @@ public boolean isClosed() {
     return state == STATE_CLOSED;
   }
 
-  public void closeIfOwnedBy(Object owner) throws IOException {
-    Internal.instance.closeIfOwnedBy(connection, owner);
-  }
-
-  public void flush() throws IOException {
+  @Override public void finishRequest() throws IOException {
     sink.flush();
   }
 
-  /** Returns the number of buffered bytes immediately readable. */
-  public long bufferSize() {
-    return source.buffer().size();
-  }
-
-  /** Test for a stale socket. */
-  public boolean isReadable() {
-    try {
-      int readTimeout = socket.getSoTimeout();
-      try {
-        socket.setSoTimeout(1);
-        if (source.exhausted()) {
-          return false; // Stream is exhausted; socket is closed.
-        }
-        return true;
-      } finally {
-        socket.setSoTimeout(readTimeout);
-      }
-    } catch (SocketTimeoutException ignored) {
-      return true; // Read timed out; socket is good.
-    } catch (IOException e) {
-      return false; // Couldn't read; socket is closed.
-    }
-  }
-
   /** Returns bytes of a request header for sending on an HTTP transport. */
   public void writeRequest(Headers headers, String requestLine) throws IOException {
     if (state != STATE_IDLE) throw new IllegalStateException("state: " + state);
     sink.writeUtf8(requestLine).writeUtf8("\r\n");
-    for (int i = 0, size = headers.size(); i < size; i ++) {
+    for (int i = 0, size = headers.size(); i < size; i++) {
       sink.writeUtf8(headers.name(i))
           .writeUtf8(": ")
           .writeUtf8(headers.value(i))
@@ -192,12 +186,8 @@ public void writeRequest(Headers headers, String requestLine) throws IOException
         Response.Builder responseBuilder = new Response.Builder()
             .protocol(statusLine.protocol)
             .code(statusLine.code)
-            .message(statusLine.message);
-
-        Headers.Builder headersBuilder = new Headers.Builder();
-        readHeaders(headersBuilder);
-        headersBuilder.add(OkHeaders.SELECTED_PROTOCOL, statusLine.protocol.toString());
-        responseBuilder.headers(headersBuilder.build());
+            .message(statusLine.message)
+            .headers(readHeaders());
 
         if (statusLine.code != HTTP_CONTINUE) {
           state = STATE_OPEN_RESPONSE_BODY;
@@ -206,19 +196,20 @@ public void writeRequest(Headers headers, String requestLine) throws IOException
       }
     } catch (EOFException e) {
       // Provide more context if the server ends the stream before sending a response.
-      IOException exception = new IOException("unexpected end of stream on " + connection
-          + " (recycle count=" + Internal.instance.recycleCount(connection) + ")");
+      IOException exception = new IOException("unexpected end of stream on " + streamAllocation);
       exception.initCause(e);
       throw exception;
     }
   }
 
-  /** Reads headers or trailers into {@code builder}. */
-  public void readHeaders(Headers.Builder builder) throws IOException {
+  /** Reads headers or trailers. */
+  public Headers readHeaders() throws IOException {
+    Headers.Builder headers = new Headers.Builder();
     // parse the result headers until the first blank line
     for (String line; (line = source.readUtf8LineStrict()).length() != 0; ) {
-      Internal.instance.addLenient(builder, line);
+      Internal.instance.addLenient(headers, line);
     }
+    return headers.build();
   }
 
   public Sink newChunkedSink() {
@@ -233,12 +224,6 @@ public Sink newFixedLengthSink(long contentLength) {
     return new FixedLengthSink(contentLength);
   }
 
-  public void writeRequestBody(RetryableSink requestBody) throws IOException {
-    if (state != STATE_OPEN_REQUEST_BODY) throw new IllegalStateException("state: " + state);
-    state = STATE_READ_RESPONSE_HEADERS;
-    requestBody.writeToSocket(sink);
-  }
-
   public Source newFixedLengthSource(long length) throws IOException {
     if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
     state = STATE_READING_RESPONSE_BODY;
@@ -253,12 +238,27 @@ public Source newChunkedSource(HttpEngine httpEngine) throws IOException {
 
   public Source newUnknownLengthSource() throws IOException {
     if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
+    if (streamAllocation == null) throw new IllegalStateException("streamAllocation == null");
     state = STATE_READING_RESPONSE_BODY;
+    streamAllocation.noNewStreams();
     return new UnknownLengthSource();
   }
 
+  /**
+   * Sets the delegate of {@code timeout} to {@link Timeout#NONE} and resets its underlying timeout
+   * to the default configuration. Use this to avoid unexpected sharing of timeouts between pooled
+   * connections.
+   */
+  private void detachTimeout(ForwardingTimeout timeout) {
+    Timeout oldDelegate = timeout.delegate();
+    timeout.setDelegate(Timeout.NONE);
+    oldDelegate.clearDeadline();
+    oldDelegate.clearTimeout();
+  }
+
   /** An HTTP body with a fixed length known in advance. */
   private final class FixedLengthSink implements Sink {
+    private final ForwardingTimeout timeout = new ForwardingTimeout(sink.timeout());
     private boolean closed;
     private long bytesRemaining;
 
@@ -267,7 +267,7 @@ private FixedLengthSink(long bytesRemaining) {
     }
 
     @Override public Timeout timeout() {
-      return sink.timeout();
+      return timeout;
     }
 
     @Override public void write(Buffer source, long byteCount) throws IOException {
@@ -290,20 +290,21 @@ private FixedLengthSink(long bytesRemaining) {
       if (closed) return;
       closed = true;
       if (bytesRemaining > 0) throw new ProtocolException("unexpected end of stream");
+      detachTimeout(timeout);
       state = STATE_READ_RESPONSE_HEADERS;
     }
   }
 
   /**
-   * An HTTP body with alternating chunk sizes and chunk bodies. It is the
-   * caller's responsibility to buffer chunks; typically by using a buffered
-   * sink with this sink.
+   * An HTTP body with alternating chunk sizes and chunk bodies. It is the caller's responsibility
+   * to buffer chunks; typically by using a buffered sink with this sink.
    */
   private final class ChunkedSink implements Sink {
+    private final ForwardingTimeout timeout = new ForwardingTimeout(sink.timeout());
     private boolean closed;
 
     @Override public Timeout timeout() {
-      return sink.timeout();
+      return timeout;
     }
 
     @Override public void write(Buffer source, long byteCount) throws IOException {
@@ -325,49 +326,33 @@ private FixedLengthSink(long bytesRemaining) {
       if (closed) return;
       closed = true;
       sink.writeUtf8("0\r\n\r\n");
+      detachTimeout(timeout);
       state = STATE_READ_RESPONSE_HEADERS;
     }
   }
 
   private abstract class AbstractSource implements Source {
+    protected final ForwardingTimeout timeout = new ForwardingTimeout(source.timeout());
     protected boolean closed;
 
     @Override public Timeout timeout() {
-      return source.timeout();
+      return timeout;
     }
 
     /**
-     * Closes the cache entry and makes the socket available for reuse. This
-     * should be invoked when the end of the body has been reached.
+     * Closes the cache entry and makes the socket available for reuse. This should be invoked when
+     * the end of the body has been reached.
      */
-    protected final void endOfInput(boolean recyclable) throws IOException {
+    protected final void endOfInput(boolean reuseConnection) throws IOException {
+      if (state == STATE_CLOSED) return;
       if (state != STATE_READING_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
 
-      state = STATE_IDLE;
-      if (recyclable && onIdle == ON_IDLE_POOL) {
-        onIdle = ON_IDLE_HOLD; // Set the on idle policy back to the default.
-        Internal.instance.recycle(pool, connection);
-      } else if (onIdle == ON_IDLE_CLOSE) {
-        state = STATE_CLOSED;
-        connection.getSocket().close();
-      }
-    }
+      detachTimeout(timeout);
 
-    /**
-     * Calls abort on the cache entry and disconnects the socket. This
-     * should be invoked when the connection is closed unexpectedly to
-     * invalidate the cache entry and to prevent the HTTP connection from
-     * being reused. HTTP messages are sent in serial so whenever a message
-     * cannot be read to completion, subsequent messages cannot be read
-     * either and the connection must be discarded.
-     *
-     * <p>An earlier implementation skipped the remaining bytes, but this
-     * requires that the entire transfer be completed. If the intention was
-     * to cancel the transfer, closing the connection is the only solution.
-     */
-    protected final void unexpectedEndOfInput() {
-      Util.closeQuietly(connection.getSocket());
       state = STATE_CLOSED;
+      if (streamAllocation != null) {
+        streamAllocation.streamFinished(!reuseConnection, Http1xStream.this);
+      }
     }
   }
 
@@ -389,7 +374,7 @@ public FixedLengthSource(long length) throws IOException {
 
       long read = source.read(sink, Math.min(bytesRemaining, byteCount));
       if (read == -1) {
-        unexpectedEndOfInput(); // The server didn't supply the promised content length.
+        endOfInput(false); // The server didn't supply the promised content length.
         throw new ProtocolException("unexpected end of stream");
       }
 
@@ -403,9 +388,8 @@ public FixedLengthSource(long length) throws IOException {
     @Override public void close() throws IOException {
       if (closed) return;
 
-      if (bytesRemaining != 0
-          && !Util.discard(this, DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
-        unexpectedEndOfInput();
+      if (bytesRemaining != 0 && !Util.discard(this, DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
+        endOfInput(false);
       }
 
       closed = true;
@@ -435,8 +419,8 @@ public FixedLengthSource(long length) throws IOException {
 
       long read = source.read(sink, Math.min(byteCount, bytesRemainingInChunk));
       if (read == -1) {
-        unexpectedEndOfInput(); // The server didn't supply the promised chunk length.
-        throw new IOException("unexpected end of stream");
+        endOfInput(false); // The server didn't supply the promised chunk length.
+        throw new ProtocolException("unexpected end of stream");
       }
       bytesRemainingInChunk -= read;
       return read;
@@ -459,9 +443,7 @@ private void readChunkSize() throws IOException {
       }
       if (bytesRemainingInChunk == 0L) {
         hasMoreChunks = false;
-        Headers.Builder trailersBuilder = new Headers.Builder();
-        readHeaders(trailersBuilder);
-        httpEngine.receiveHeaders(trailersBuilder.build());
+        httpEngine.receiveHeaders(readHeaders());
         endOfInput(true);
       }
     }
@@ -469,7 +451,7 @@ private void readChunkSize() throws IOException {
     @Override public void close() throws IOException {
       if (closed) return;
       if (hasMoreChunks && !Util.discard(this, DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
-        unexpectedEndOfInput();
+        endOfInput(false);
       }
       closed = true;
     }
@@ -488,7 +470,7 @@ private void readChunkSize() throws IOException {
       long read = source.read(sink, byteCount);
       if (read == -1) {
         inputExhausted = true;
-        endOfInput(false);
+        endOfInput(true);
         return -1;
       }
       return read;
@@ -497,7 +479,7 @@ private void readChunkSize() throws IOException {
     @Override public void close() throws IOException {
       if (closed) return;
       if (!inputExhausted) {
-        unexpectedEndOfInput();
+        endOfInput(false);
       }
       closed = true;
     }
diff --git a/okhttp/src/main/java/okhttp3/internal/http/Http2xStream.java b/okhttp/src/main/java/okhttp3/internal/http/Http2xStream.java
new file mode 100644
index 0000000000..3f878f633c
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http/Http2xStream.java
@@ -0,0 +1,292 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http;
+
+import java.io.IOException;
+import java.net.ProtocolException;
+import java.util.ArrayList;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Locale;
+import java.util.Set;
+import java.util.concurrent.TimeUnit;
+import okhttp3.Headers;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+import okhttp3.internal.Internal;
+import okhttp3.internal.Util;
+import okhttp3.internal.framed.ErrorCode;
+import okhttp3.internal.framed.FramedConnection;
+import okhttp3.internal.framed.FramedStream;
+import okhttp3.internal.framed.Header;
+import okio.ByteString;
+import okio.ForwardingSource;
+import okio.Okio;
+import okio.Sink;
+import okio.Source;
+
+import static okhttp3.internal.framed.Header.RESPONSE_STATUS;
+import static okhttp3.internal.framed.Header.TARGET_AUTHORITY;
+import static okhttp3.internal.framed.Header.TARGET_HOST;
+import static okhttp3.internal.framed.Header.TARGET_METHOD;
+import static okhttp3.internal.framed.Header.TARGET_PATH;
+import static okhttp3.internal.framed.Header.TARGET_SCHEME;
+import static okhttp3.internal.framed.Header.VERSION;
+
+/** An HTTP stream for HTTP/2 and SPDY. */
+public final class Http2xStream implements HttpStream {
+  private static final ByteString CONNECTION = ByteString.encodeUtf8("connection");
+  private static final ByteString HOST = ByteString.encodeUtf8("host");
+  private static final ByteString KEEP_ALIVE = ByteString.encodeUtf8("keep-alive");
+  private static final ByteString PROXY_CONNECTION = ByteString.encodeUtf8("proxy-connection");
+  private static final ByteString TRANSFER_ENCODING = ByteString.encodeUtf8("transfer-encoding");
+  private static final ByteString TE = ByteString.encodeUtf8("te");
+  private static final ByteString ENCODING = ByteString.encodeUtf8("encoding");
+  private static final ByteString UPGRADE = ByteString.encodeUtf8("upgrade");
+
+  /** See http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1#TOC-3.2.1-Request. */
+  private static final List<ByteString> SPDY_3_SKIPPED_REQUEST_HEADERS = Util.immutableList(
+      CONNECTION,
+      HOST,
+      KEEP_ALIVE,
+      PROXY_CONNECTION,
+      TRANSFER_ENCODING,
+      TARGET_METHOD,
+      TARGET_PATH,
+      TARGET_SCHEME,
+      TARGET_AUTHORITY,
+      TARGET_HOST,
+      VERSION);
+  private static final List<ByteString> SPDY_3_SKIPPED_RESPONSE_HEADERS = Util.immutableList(
+      CONNECTION,
+      HOST,
+      KEEP_ALIVE,
+      PROXY_CONNECTION,
+      TRANSFER_ENCODING);
+
+  /** See http://tools.ietf.org/html/draft-ietf-httpbis-http2-09#section-8.1.3. */
+  private static final List<ByteString> HTTP_2_SKIPPED_REQUEST_HEADERS = Util.immutableList(
+      CONNECTION,
+      HOST,
+      KEEP_ALIVE,
+      PROXY_CONNECTION,
+      TE,
+      TRANSFER_ENCODING,
+      ENCODING,
+      UPGRADE,
+      TARGET_METHOD,
+      TARGET_PATH,
+      TARGET_SCHEME,
+      TARGET_AUTHORITY,
+      TARGET_HOST,
+      VERSION);
+  private static final List<ByteString> HTTP_2_SKIPPED_RESPONSE_HEADERS = Util.immutableList(
+      CONNECTION,
+      HOST,
+      KEEP_ALIVE,
+      PROXY_CONNECTION,
+      TE,
+      TRANSFER_ENCODING,
+      ENCODING,
+      UPGRADE);
+
+  private final StreamAllocation streamAllocation;
+  private final FramedConnection framedConnection;
+  private HttpEngine httpEngine;
+  private FramedStream stream;
+
+  public Http2xStream(StreamAllocation streamAllocation, FramedConnection framedConnection) {
+    this.streamAllocation = streamAllocation;
+    this.framedConnection = framedConnection;
+  }
+
+  @Override public void setHttpEngine(HttpEngine httpEngine) {
+    this.httpEngine = httpEngine;
+  }
+
+  @Override public Sink createRequestBody(Request request, long contentLength) throws IOException {
+    return stream.getSink();
+  }
+
+  @Override public void writeRequestHeaders(Request request) throws IOException {
+    if (stream != null) return;
+
+    httpEngine.writingRequestHeaders();
+    boolean permitsRequestBody = httpEngine.permitsRequestBody(request);
+    List<Header> requestHeaders = framedConnection.getProtocol() == Protocol.HTTP_2
+        ? http2HeadersList(request)
+        : spdy3HeadersList(request);
+    boolean hasResponseBody = true;
+    stream = framedConnection.newStream(requestHeaders, permitsRequestBody, hasResponseBody);
+    stream.readTimeout().timeout(httpEngine.client.readTimeoutMillis(), TimeUnit.MILLISECONDS);
+    stream.writeTimeout().timeout(httpEngine.client.writeTimeoutMillis(), TimeUnit.MILLISECONDS);
+  }
+
+  @Override public void finishRequest() throws IOException {
+    stream.getSink().close();
+  }
+
+  @Override public Response.Builder readResponseHeaders() throws IOException {
+    return framedConnection.getProtocol() == Protocol.HTTP_2
+        ? readHttp2HeadersList(stream.getResponseHeaders())
+        : readSpdy3HeadersList(stream.getResponseHeaders());
+  }
+
+  /**
+   * Returns a list of alternating names and values containing a SPDY request. Names are all
+   * lowercase. No names are repeated. If any name has multiple values, they are concatenated using
+   * "\0" as a delimiter.
+   */
+  public static List<Header> spdy3HeadersList(Request request) {
+    Headers headers = request.headers();
+    List<Header> result = new ArrayList<>(headers.size() + 5);
+    result.add(new Header(TARGET_METHOD, request.method()));
+    result.add(new Header(TARGET_PATH, RequestLine.requestPath(request.url())));
+    result.add(new Header(VERSION, "HTTP/1.1"));
+    result.add(new Header(TARGET_HOST, Util.hostHeader(request.url(), false)));
+    result.add(new Header(TARGET_SCHEME, request.url().scheme()));
+
+    Set<ByteString> names = new LinkedHashSet<>();
+    for (int i = 0, size = headers.size(); i < size; i++) {
+      // header names must be lowercase.
+      ByteString name = ByteString.encodeUtf8(headers.name(i).toLowerCase(Locale.US));
+
+      // Drop headers that are forbidden when layering HTTP over SPDY.
+      if (SPDY_3_SKIPPED_REQUEST_HEADERS.contains(name)) continue;
+
+      // If we haven't seen this name before, add the pair to the end of the list...
+      String value = headers.value(i);
+      if (names.add(name)) {
+        result.add(new Header(name, value));
+        continue;
+      }
+
+      // ...otherwise concatenate the existing values and this value.
+      for (int j = 0; j < result.size(); j++) {
+        if (result.get(j).name.equals(name)) {
+          String concatenated = joinOnNull(result.get(j).value.utf8(), value);
+          result.set(j, new Header(name, concatenated));
+          break;
+        }
+      }
+    }
+    return result;
+  }
+
+  private static String joinOnNull(String first, String second) {
+    return new StringBuilder(first).append('\0').append(second).toString();
+  }
+
+  public static List<Header> http2HeadersList(Request request) {
+    Headers headers = request.headers();
+    List<Header> result = new ArrayList<>(headers.size() + 4);
+    result.add(new Header(TARGET_METHOD, request.method()));
+    result.add(new Header(TARGET_PATH, RequestLine.requestPath(request.url())));
+    result.add(new Header(TARGET_AUTHORITY, Util.hostHeader(request.url(), false))); // Optional.
+    result.add(new Header(TARGET_SCHEME, request.url().scheme()));
+
+    for (int i = 0, size = headers.size(); i < size; i++) {
+      // header names must be lowercase.
+      ByteString name = ByteString.encodeUtf8(headers.name(i).toLowerCase(Locale.US));
+      if (!HTTP_2_SKIPPED_REQUEST_HEADERS.contains(name)) {
+        result.add(new Header(name, headers.value(i)));
+      }
+    }
+    return result;
+  }
+
+  /** Returns headers for a name value block containing a SPDY response. */
+  public static Response.Builder readSpdy3HeadersList(List<Header> headerBlock) throws IOException {
+    String status = null;
+    String version = "HTTP/1.1";
+    Headers.Builder headersBuilder = new Headers.Builder();
+    for (int i = 0, size = headerBlock.size(); i < size; i++) {
+      ByteString name = headerBlock.get(i).name;
+
+      String values = headerBlock.get(i).value.utf8();
+      for (int start = 0; start < values.length(); ) {
+        int end = values.indexOf('\0', start);
+        if (end == -1) {
+          end = values.length();
+        }
+        String value = values.substring(start, end);
+        if (name.equals(RESPONSE_STATUS)) {
+          status = value;
+        } else if (name.equals(VERSION)) {
+          version = value;
+        } else if (!SPDY_3_SKIPPED_RESPONSE_HEADERS.contains(name)) {
+          Internal.instance.addLenient(headersBuilder, name.utf8(), value);
+        }
+        start = end + 1;
+      }
+    }
+    if (status == null) throw new ProtocolException("Expected ':status' header not present");
+
+    StatusLine statusLine = StatusLine.parse(version + " " + status);
+    return new Response.Builder()
+        .protocol(Protocol.SPDY_3)
+        .code(statusLine.code)
+        .message(statusLine.message)
+        .headers(headersBuilder.build());
+  }
+
+  /** Returns headers for a name value block containing an HTTP/2 response. */
+  public static Response.Builder readHttp2HeadersList(List<Header> headerBlock) throws IOException {
+    String status = null;
+
+    Headers.Builder headersBuilder = new Headers.Builder();
+    for (int i = 0, size = headerBlock.size(); i < size; i++) {
+      ByteString name = headerBlock.get(i).name;
+
+      String value = headerBlock.get(i).value.utf8();
+      if (name.equals(RESPONSE_STATUS)) {
+        status = value;
+      } else if (!HTTP_2_SKIPPED_RESPONSE_HEADERS.contains(name)) {
+        Internal.instance.addLenient(headersBuilder, name.utf8(), value);
+      }
+    }
+    if (status == null) throw new ProtocolException("Expected ':status' header not present");
+
+    StatusLine statusLine = StatusLine.parse("HTTP/1.1 " + status);
+    return new Response.Builder()
+        .protocol(Protocol.HTTP_2)
+        .code(statusLine.code)
+        .message(statusLine.message)
+        .headers(headersBuilder.build());
+  }
+
+  @Override public ResponseBody openResponseBody(Response response) throws IOException {
+    Source source = new StreamFinishingSource(stream.getSource());
+    return new RealResponseBody(response.headers(), Okio.buffer(source));
+  }
+
+  @Override public void cancel() {
+    if (stream != null) stream.closeLater(ErrorCode.CANCEL);
+  }
+
+  class StreamFinishingSource extends ForwardingSource {
+    public StreamFinishingSource(Source delegate) {
+      super(delegate);
+    }
+
+    @Override public void close() throws IOException {
+      streamAllocation.streamFinished(false, Http2xStream.this);
+      super.close();
+    }
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpDate.java b/okhttp/src/main/java/okhttp3/internal/http/HttpDate.java
similarity index 93%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpDate.java
rename to okhttp/src/main/java/okhttp3/internal/http/HttpDate.java
index 27511b37ca..2991dd7b51 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpDate.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/HttpDate.java
@@ -13,22 +13,22 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
-package com.squareup.okhttp.internal.http;
+package okhttp3.internal.http;
 
 import java.text.DateFormat;
 import java.text.ParsePosition;
 import java.text.SimpleDateFormat;
 import java.util.Date;
 import java.util.Locale;
-import java.util.TimeZone;
+
+import static okhttp3.internal.Util.UTC;
 
 /**
  * Best-effort parser for HTTP dates.
  */
 public final class HttpDate {
-
-  private static final TimeZone GMT = TimeZone.getTimeZone("GMT");
+  /** The last four-digit year: "Fri, 31 Dec 9999 23:59:59 GMT". */
+  public static final long MAX_DATE = 253402300799999L;
 
   /**
    * Most websites serve cookies in the blessed format. Eagerly create the parser to ensure such
@@ -40,7 +40,7 @@
           // RFC 2616 specified: RFC 822, updated by RFC 1123 format with fixed GMT.
           DateFormat rfc1123 = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss 'GMT'", Locale.US);
           rfc1123.setLenient(false);
-          rfc1123.setTimeZone(GMT);
+          rfc1123.setTimeZone(UTC);
           return rfc1123;
         }
       };
@@ -51,7 +51,7 @@
       "EEE, dd MMM yyyy HH:mm:ss zzz", // RFC 822, updated by RFC 1123 with any TZ
       "EEEE, dd-MMM-yy HH:mm:ss zzz", // RFC 850, obsoleted by RFC 1036 with any TZ.
       "EEE MMM d HH:mm:ss yyyy", // ANSI C's asctime() format
-       // Alternative formats.
+      // Alternative formats.
       "EEE, dd-MMM-yyyy HH:mm:ss z",
       "EEE, dd-MMM-yyyy HH-mm-ss z",
       "EEE, dd MMM yy HH:mm:ss z",
@@ -91,7 +91,7 @@ public static Date parse(String value) {
           format = new SimpleDateFormat(BROWSER_COMPATIBLE_DATE_FORMAT_STRINGS[i], Locale.US);
           // Set the timezone to use when interpreting formats that don't have a timezone. GMT is
           // specified by RFC 2616.
-          format.setTimeZone(GMT);
+          format.setTimeZone(UTC);
           BROWSER_COMPATIBLE_DATE_FORMATS[i] = format;
         }
         position.setIndex(0);
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java b/okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java
similarity index 58%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
rename to okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java
index 78a8cc9f27..c5246df2cf 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java
@@ -14,7 +14,9 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
+package okhttp3.internal.http;
 
+<<<<<<< HEAD:okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
 package com.squareup.okhttp.internal.http;
 
 import com.squareup.okhttp.Address;
@@ -34,23 +36,47 @@
 import com.squareup.okhttp.internal.InternalCache;
 import com.squareup.okhttp.internal.Util;
 
+=======
+>>>>>>> upstream/master:okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java
 import java.io.IOException;
 import java.io.InterruptedIOException;
-import java.net.CookieHandler;
 import java.net.ProtocolException;
 import java.net.Proxy;
-import java.net.URL;
-import java.net.UnknownHostException;
+import java.net.SocketTimeoutException;
 import java.security.cert.CertificateException;
 import java.util.Date;
 import java.util.List;
+<<<<<<< HEAD:okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
 import java.util.Map;
 
+=======
+>>>>>>> upstream/master:okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLHandshakeException;
 import javax.net.ssl.SSLPeerUnverifiedException;
 import javax.net.ssl.SSLSocketFactory;
-
+<<<<<<< HEAD:okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
+
+=======
+import okhttp3.Address;
+import okhttp3.CertificatePinner;
+import okhttp3.Connection;
+import okhttp3.Cookie;
+import okhttp3.CookieJar;
+import okhttp3.Headers;
+import okhttp3.HttpUrl;
+import okhttp3.Interceptor;
+import okhttp3.MediaType;
+import okhttp3.OkHttpClient;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+import okhttp3.Route;
+import okhttp3.internal.Internal;
+import okhttp3.internal.InternalCache;
+import okhttp3.internal.Version;
+>>>>>>> upstream/master:okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -60,12 +86,7 @@
 import okio.Source;
 import okio.Timeout;
 
-import static com.squareup.okhttp.internal.Util.closeQuietly;
-import static com.squareup.okhttp.internal.Util.getDefaultPort;
-import static com.squareup.okhttp.internal.Util.getEffectivePort;
-import static com.squareup.okhttp.internal.http.StatusLine.HTTP_CONTINUE;
-import static com.squareup.okhttp.internal.http.StatusLine.HTTP_PERM_REDIRECT;
-import static com.squareup.okhttp.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
+import static java.net.HttpURLConnection.HTTP_CLIENT_TIMEOUT;
 import static java.net.HttpURLConnection.HTTP_MOVED_PERM;
 import static java.net.HttpURLConnection.HTTP_MOVED_TEMP;
 import static java.net.HttpURLConnection.HTTP_MULT_CHOICE;
@@ -75,21 +96,26 @@
 import static java.net.HttpURLConnection.HTTP_SEE_OTHER;
 import static java.net.HttpURLConnection.HTTP_UNAUTHORIZED;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static okhttp3.internal.Util.closeQuietly;
+import static okhttp3.internal.Util.discard;
+import static okhttp3.internal.Util.hostHeader;
+import static okhttp3.internal.http.StatusLine.HTTP_CONTINUE;
+import static okhttp3.internal.http.StatusLine.HTTP_PERM_REDIRECT;
+import static okhttp3.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
 
 /**
- * Handles a single HTTP request/response pair. Each HTTP engine follows this
- * lifecycle:
+ * Handles a single HTTP request/response pair. Each HTTP engine follows this lifecycle:
+ *
  * <ol>
- * <li>It is created.
- * <li>The HTTP request message is sent with sendRequest(). Once the request
- * is sent it is an error to modify the request headers. After
- * sendRequest() has been called the request body can be written to if
- * it exists.
- * <li>The HTTP response message is read with readResponse(). After the
- * response has been read the response headers and body can be read.
- * All responses have a response body input stream, though in some
- * instances this stream is empty.
+ *     <li>It is created.
+ *     <li>The HTTP request message is sent with sendRequest(). Once the request is sent it is an
+ *         error to modify the request headers. After sendRequest() has been called the request body
+ *         can be written to if it exists.
+ *     <li>The HTTP response message is read with readResponse(). After the response has been read
+ *         the response headers and body can be read. All responses have a response body input
+ *         stream, though in some instances this stream is empty.
  * </ol>
+<<<<<<< HEAD:okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
  * <p/>
  * <p>The request and response may be served by the HTTP response cache, by the
  * network, or by both in the event of a conditional GET.
@@ -106,12 +132,137 @@
         public MediaType contentType() {
             return null;
         }
+=======
+ *
+ * <p>The request and response may be served by the HTTP response cache, by the network, or by both
+ * in the event of a conditional GET.
+ */
+public final class HttpEngine {
+  /**
+   * How many redirects and auth challenges should we attempt? Chrome follows 21 redirects; Firefox,
+   * curl, and wget follow 20; Safari follows 16; and HTTP/1.0 recommends 5.
+   */
+  public static final int MAX_FOLLOW_UPS = 20;
+
+  private static final ResponseBody EMPTY_BODY = new ResponseBody() {
+    @Override public MediaType contentType() {
+      return null;
+    }
+
+    @Override public long contentLength() {
+      return 0;
+    }
+
+    @Override public BufferedSource source() {
+      return new Buffer();
+    }
+  };
+
+  final OkHttpClient client;
+
+  public final StreamAllocation streamAllocation;
+  private final Response priorResponse;
+  private HttpStream httpStream;
+
+  /** The time when the request headers were written, or -1 if they haven't been written yet. */
+  long sentRequestMillis = -1;
+
+  /**
+   * True if this client added an "Accept-Encoding: gzip" header field and is therefore responsible
+   * for also decompressing the transfer stream.
+   */
+  private boolean transparentGzip;
+
+  /**
+   * True if the request body must be completely buffered before transmission; false if it can be
+   * streamed. Buffering has two advantages: we don't need the content-length in advance and we can
+   * retransmit if necessary. The upside of streaming is that we can save memory.
+   */
+  public final boolean bufferRequestBody;
+
+  /**
+   * The original application-provided request. Never modified by OkHttp. When follow-up requests
+   * are necessary, they are derived from this request.
+   */
+  private final Request userRequest;
+
+  /**
+   * The request to send on the network, or null for no network request. This is derived from the
+   * user request, and customized to support OkHttp features like compression and caching.
+   */
+  private Request networkRequest;
+
+  /**
+   * The cached response, or null if the cache doesn't exist or cannot be used for this request.
+   * Conditional caching means this may be non-null even when the network request is non-null. Never
+   * modified by OkHttp.
+   */
+  private Response cacheResponse;
+
+  /**
+   * The user-visible response. This is derived from either the network response, cache response, or
+   * both. It is customized to support OkHttp features like compression and caching.
+   */
+  private Response userResponse;
+
+  private final boolean forWebSocket;
+
+  /** The cache request currently being populated from a network response. */
+  private CacheRequest storeRequest;
+  private CacheStrategy cacheStrategy;
+
+  /**
+   * @param request the HTTP request without a body. The body must be written via the engine's
+   * request body stream.
+   */
+  public HttpEngine(OkHttpClient client, Request request, boolean bufferRequestBody,
+      boolean forWebSocket, StreamAllocation streamAllocation, Response priorResponse) {
+    this.client = client;
+    this.userRequest = request;
+    this.bufferRequestBody = bufferRequestBody;
+    this.forWebSocket = forWebSocket;
+    this.streamAllocation = streamAllocation != null
+        ? streamAllocation
+        : new StreamAllocation(client.connectionPool(), createAddress(client, request));
+    this.priorResponse = priorResponse;
+  }
+
+  /**
+   * Figures out what the response source will be, and opens a socket to that source if necessary.
+   * Prepares the request headers and gets ready to start writing the request body if it exists.
+   *
+   * @throws RouteException if the was a problem during connection via a specific route. Sometimes
+   * recoverable. See {@link #recover}.
+   * @throws IOException if there was a problem while making a request. Sometimes recoverable. See
+   * {@link #recover(IOException, boolean)}.
+   */
+  public void sendRequest() throws RouteException, IOException {
+    if (cacheStrategy != null) return; // Already sent.
+    if (httpStream != null) throw new IllegalStateException();
+
+    Request request = networkRequest(userRequest);
+
+    InternalCache responseCache = Internal.instance.internalCache(client);
+    Response cacheCandidate = responseCache != null
+        ? responseCache.get(request)
+        : null;
+
+    long now = System.currentTimeMillis();
+    cacheStrategy = new CacheStrategy.Factory(now, request, cacheCandidate).get();
+    networkRequest = cacheStrategy.networkRequest;
+    cacheResponse = cacheStrategy.cacheResponse;
+
+    if (responseCache != null) {
+      responseCache.trackResponse(cacheStrategy);
+    }
+>>>>>>> upstream/master:okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java
 
         @Override
         public long contentLength() {
             return 0;
         }
 
+<<<<<<< HEAD:okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
         @Override
         public BufferedSource source() {
             return new Buffer();
@@ -365,11 +516,161 @@ private Connection createNextConnection() throws IOException {
                 return pooled;
             }
             pooled.getSocket().close();
+=======
+    // If we're forbidden from using the network and the cache is insufficient, fail.
+    if (networkRequest == null && cacheResponse == null) {
+      userResponse = new Response.Builder()
+          .request(userRequest)
+          .priorResponse(stripBody(priorResponse))
+          .protocol(Protocol.HTTP_1_1)
+          .code(504)
+          .message("Unsatisfiable Request (only-if-cached)")
+          .body(EMPTY_BODY)
+          .sentRequestAtMillis(sentRequestMillis)
+          .receivedResponseAtMillis(System.currentTimeMillis())
+          .build();
+      return;
+    }
+
+    // If we don't need the network, we're done.
+    if (networkRequest == null) {
+      userResponse = cacheResponse.newBuilder()
+          .request(userRequest)
+          .priorResponse(stripBody(priorResponse))
+          .cacheResponse(stripBody(cacheResponse))
+          .build();
+      userResponse = unzip(userResponse);
+      return;
+    }
+
+    // We need the network to satisfy this request. Possibly for validating a conditional GET.
+    boolean success = false;
+    try {
+      httpStream = connect();
+      httpStream.setHttpEngine(this);
+      success = true;
+    } finally {
+      // If we're crashing on I/O or otherwise, don't leak the cache body.
+      if (!success && cacheCandidate != null) {
+        closeQuietly(cacheCandidate.body());
+      }
+    }
+  }
+
+  private HttpStream connect() throws RouteException, IOException {
+    boolean doExtensiveHealthChecks = !networkRequest.method().equals("GET");
+    return streamAllocation.newStream(client.connectTimeoutMillis(),
+        client.readTimeoutMillis(), client.writeTimeoutMillis(),
+        client.retryOnConnectionFailure(), doExtensiveHealthChecks);
+  }
+
+  private static Response stripBody(Response response) {
+    return response != null && response.body() != null
+        ? response.newBuilder().body(null).build()
+        : response;
+  }
+
+  /**
+   * Called immediately before the transport transmits HTTP request headers. This is used to observe
+   * the sent time should the request be cached.
+   */
+  public void writingRequestHeaders() {
+    if (sentRequestMillis != -1) throw new IllegalStateException();
+    sentRequestMillis = System.currentTimeMillis();
+  }
+
+  boolean permitsRequestBody(Request request) {
+    return HttpMethod.permitsRequestBody(request.method());
+  }
+
+  /** Returns the engine's response. */
+  // TODO: the returned body will always be null.
+  public Response getResponse() {
+    if (userResponse == null) throw new IllegalStateException();
+    return userResponse;
+  }
+
+  public Connection getConnection() {
+    return streamAllocation.connection();
+  }
+
+  /**
+   * Report and attempt to recover from a failure to communicate with a server. Returns a new HTTP
+   * engine that should be used for the retry if {@code e} is recoverable, or null if the failure is
+   * permanent. Requests with a body can only be recovered if the body is buffered.
+   */
+  public HttpEngine recover(IOException e, boolean routeException) {
+    streamAllocation.streamFailed(e);
+
+    if (!client.retryOnConnectionFailure()) {
+      return null; // The application layer has forbidden retries.
+    }
+
+    if (!isRecoverable(e, routeException)) {
+      return null; // This exception is fatal.
+    }
+
+    if (!streamAllocation.hasMoreRoutes()) {
+      return null; // No more routes to attempt.
+    }
+
+    StreamAllocation streamAllocation = close();
+
+    // For failure recovery, use the same route selector with a new connection.
+    return new HttpEngine(client, userRequest, bufferRequestBody,
+        forWebSocket, streamAllocation, priorResponse);
+  }
+
+  private boolean isRecoverable(IOException e, boolean routeException) {
+    // If there was a protocol problem, don't recover.
+    if (e instanceof ProtocolException) {
+      return false;
+    }
+
+    // If there was an interruption don't recover, but if there was a timeout connecting to a route
+    // we should try the next route (if there is one).
+    if (e instanceof InterruptedIOException) {
+      return e instanceof SocketTimeoutException && routeException;
+    }
+
+    // Look for known client-side or negotiation errors that are unlikely to be fixed by trying
+    // again with a different route.
+    if (e instanceof SSLHandshakeException) {
+      // If the problem was a CertificateException from the X509TrustManager,
+      // do not retry.
+      if (e.getCause() instanceof CertificateException) {
+        return false;
+      }
+    }
+    if (e instanceof SSLPeerUnverifiedException) {
+      // e.g. a certificate pinning error.
+      return false;
+    }
+
+    // An example of one we might want to retry with a different route is a problem connecting to a
+    // proxy and would manifest as a standard IOException. Unless it is one we know we should not
+    // retry, we return true and try a new route.
+    return true;
+  }
+
+  private void maybeCache() throws IOException {
+    InternalCache responseCache = Internal.instance.internalCache(client);
+    if (responseCache == null) return;
+
+    // Should we cache this response for this request?
+    if (!CacheStrategy.isCacheable(userResponse, networkRequest)) {
+      if (HttpMethod.invalidatesCache(networkRequest.method())) {
+        try {
+          responseCache.remove(networkRequest);
+        } catch (IOException ignored) {
+          // The cache cannot be written.
+>>>>>>> upstream/master:okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java
         }
         Route route = routeSelector.next();
         return new Connection(pool, route);
     }
 
+<<<<<<< HEAD:okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
     /**
      * Called immediately before the transport transmits HTTP request headers.
      * This is used to observe the sent time should the request be cached.
@@ -408,12 +709,71 @@ public BufferedSink getBufferedRequestBody() {
 
     public boolean hasResponse() {
         return userResponse != null;
+=======
+    // Offer this request to the cache.
+    storeRequest = responseCache.put(userResponse);
+  }
+
+  /**
+   * Configure the socket connection to be either pooled or closed when it is either exhausted or
+   * closed. If it is unneeded when this is called, it will be released immediately.
+   */
+  public void releaseStreamAllocation() throws IOException {
+    streamAllocation.release();
+  }
+
+  /**
+   * Immediately closes the socket connection if it's currently held by this engine. Use this to
+   * interrupt an in-flight request from any thread. It's the caller's responsibility to close the
+   * request body and response body streams; otherwise resources may be leaked.
+   *
+   * <p>This method is safe to be called concurrently, but provides limited guarantees. If a
+   * transport layer connection has been established (such as a HTTP/2 stream) that is terminated.
+   * Otherwise if a socket connection is being established, that is terminated.
+   */
+  public void cancel() {
+    streamAllocation.cancel();
+  }
+
+  /**
+   * Release any resources held by this engine. Returns the stream allocation held by this engine,
+   * which itself must be used or released.
+   */
+  public StreamAllocation close() {
+    if (userResponse != null) {
+      closeQuietly(userResponse.body());
+    } else {
+      // If this engine never achieved a response body, its stream allocation is dead.
+      streamAllocation.streamFailed(null);
+    }
+
+    return streamAllocation;
+  }
+
+  /**
+   * Returns a new response that does gzip decompression on {@code response}, if transparent gzip
+   * was both offered by OkHttp and used by the origin server.
+   *
+   * <p>In addition to decompression, this will also strip the corresponding headers. We strip the
+   * Content-Encoding header to prevent the application from attempting to double decompress. We
+   * strip the Content-Length header because it is the length of the compressed content, but the
+   * application is only interested in the length of the uncompressed content.
+   *
+   * <p>This method should only be used for non-empty response bodies. Response codes like "304 Not
+   * Modified" can include "Content-Encoding: gzip" without a response body and we will crash if we
+   * attempt to decompress the zero-byte source.
+   */
+  private Response unzip(final Response response) throws IOException {
+    if (!transparentGzip || !"gzip".equalsIgnoreCase(userResponse.header("Content-Encoding"))) {
+      return response;
+>>>>>>> upstream/master:okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java
     }
 
     public Request getRequest() {
         return userRequest;
     }
 
+<<<<<<< HEAD:okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
     /**
      * Returns the engine's response.
      */
@@ -423,6 +783,26 @@ public Response getResponse() {
             throw new IllegalStateException();
         }
         return userResponse;
+=======
+    GzipSource responseBody = new GzipSource(response.body().source());
+    Headers strippedHeaders = response.headers().newBuilder()
+        .removeAll("Content-Encoding")
+        .removeAll("Content-Length")
+        .build();
+    return response.newBuilder()
+        .headers(strippedHeaders)
+        .body(new RealResponseBody(strippedHeaders, Okio.buffer(responseBody)))
+        .build();
+  }
+
+  /**
+   * Returns true if the response must have a (possibly 0-length) body. See RFC 2616 section 4.3.
+   */
+  public static boolean hasBody(Response response) {
+    // HEAD requests never yield a body regardless of the response headers.
+    if (response.request().method().equals("HEAD")) {
+      return false;
+>>>>>>> upstream/master:okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java
     }
 
     public Connection getConnection() {
@@ -448,6 +828,7 @@ public HttpEngine recover(IOException e, Sink requestBodyOut) {
             return null;
         }
 
+<<<<<<< HEAD:okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
         Connection connection = close();
 
         // For failure recovery, use the same route selector with a new connection.
@@ -462,12 +843,30 @@ private void connectFailed(RouteSelector routeSelector, IOException e) {
         }
         Route failedRoute = connection.getRoute();
         routeSelector.connectFailed(failedRoute, e);
+=======
+  /**
+   * Populates request with defaults and cookies.
+   *
+   * <p>This client doesn't specify a default {@code Accept} header because it doesn't know what
+   * content types the application is interested in.
+   */
+  private Request networkRequest(Request request) throws IOException {
+    Request.Builder result = request.newBuilder();
+
+    if (request.header("Host") == null) {
+      result.header("Host", hostHeader(request.url(), false));
+    }
+
+    if (request.header("Connection") == null) {
+      result.header("Connection", "Keep-Alive");
+>>>>>>> upstream/master:okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java
     }
 
     public HttpEngine recover(IOException e) {
         return recover(e, requestBodyOut);
     }
 
+<<<<<<< HEAD:okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
     private boolean isRecoverable(IOException e) {
         // If the application has opted-out of recovery, don't recover.
         if (!client.getRetryOnConnectionFailure()) {
@@ -490,16 +889,48 @@ private boolean isRecoverable(IOException e) {
         if (e instanceof InterruptedIOException) {
             return false;
         }
+=======
+    List<Cookie> cookies = client.cookieJar().loadForRequest(request.url());
+    if (!cookies.isEmpty()) {
+      result.header("Cookie", cookieHeader(cookies));
+    }
+>>>>>>> upstream/master:okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java
 
         return true;
     }
 
+<<<<<<< HEAD:okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
     /**
      * Returns the route used to retrieve the response. Null if we haven't
      * connected yet, or if no connection was necessary.
      */
     public Route getRoute() {
         return route;
+=======
+    return result.build();
+  }
+
+  /** Returns a 'Cookie' HTTP request header with all cookies, like {@code a=b; c=d}. */
+  private String cookieHeader(List<Cookie> cookies) {
+    StringBuilder cookieHeader = new StringBuilder();
+    for (int i = 0, size = cookies.size(); i < size; i++) {
+      if (i > 0) {
+        cookieHeader.append("; ");
+      }
+      Cookie cookie = cookies.get(i);
+      cookieHeader.append(cookie.name()).append('=').append(cookie.value());
+    }
+    return cookieHeader.toString();
+  }
+
+  /**
+   * Flushes the remaining request header and body, parses the HTTP response headers and starts
+   * reading the HTTP response body if it exists.
+   */
+  public void readResponse() throws IOException {
+    if (userResponse != null) {
+      return; // Already ready.
+>>>>>>> upstream/master:okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java
     }
 
     private void maybeCache() throws IOException {
@@ -536,6 +967,7 @@ public void releaseConnection() throws IOException {
         connection = null;
     }
 
+<<<<<<< HEAD:okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
     /**
      * Immediately closes the socket connection if it's currently held by this
      * engine. Use this to interrupt an in-flight request from any thread. It's
@@ -581,6 +1013,44 @@ public Connection close() {
             connection = null;
             return null;
         }
+=======
+    Response networkResponse;
+
+    if (forWebSocket) {
+      httpStream.writeRequestHeaders(networkRequest);
+      networkResponse = readNetworkResponse();
+    } else {
+      networkResponse = new NetworkInterceptorChain(0, networkRequest,
+          streamAllocation.connection()).proceed(networkRequest);
+    }
+
+    receiveHeaders(networkResponse.headers());
+
+    // If we have a cache response too, then we're doing a conditional get.
+    if (cacheResponse != null) {
+      if (validate(cacheResponse, networkResponse)) {
+        userResponse = cacheResponse.newBuilder()
+            .request(userRequest)
+            .priorResponse(stripBody(priorResponse))
+            .headers(combine(cacheResponse.headers(), networkResponse.headers()))
+            .cacheResponse(stripBody(cacheResponse))
+            .networkResponse(stripBody(networkResponse))
+            .build();
+        networkResponse.body().close();
+        releaseStreamAllocation();
+
+        // Update the cache after combining headers but before stripping the
+        // Content-Encoding header (as performed by initContentStream()).
+        InternalCache responseCache = Internal.instance.internalCache(client);
+        responseCache.trackConditionalCacheHit();
+        responseCache.update(cacheResponse, userResponse);
+        userResponse = unzip(userResponse);
+        return;
+      } else {
+        closeQuietly(cacheResponse.body());
+      }
+    }
+>>>>>>> upstream/master:okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java
 
         // Prevent this engine from disconnecting a connection it no longer owns.
         if (connection != null && !Internal.instance.clearOwner(connection)) {
@@ -592,6 +1062,7 @@ public Connection close() {
         return result;
     }
 
+<<<<<<< HEAD:okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
     /**
      * Returns a new response that does gzip decompression on {@code response}, if transparent gzip
      * was both offered by OkHttp and used by the origin server.
@@ -613,6 +1084,19 @@ private Response unzip(final Response response) throws IOException {
         if (response.body() == null) {
             return response;
         }
+=======
+  class NetworkInterceptorChain implements Interceptor.Chain {
+    private final int index;
+    private final Request request;
+    private final Connection connection;
+    private int calls;
+
+    NetworkInterceptorChain(int index, Request request, Connection connection) {
+      this.index = index;
+      this.request = request;
+      this.connection = connection;
+    }
+>>>>>>> upstream/master:okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java
 
         GzipSource responseBody = new GzipSource(response.body().source());
         Headers strippedHeaders = response.headers().newBuilder()
@@ -650,6 +1134,7 @@ public static boolean hasBody(Response response) {
             return true;
         }
 
+<<<<<<< HEAD:okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
         return false;
     }
 
@@ -664,16 +1149,46 @@ private Request networkRequest(Request request) throws IOException {
 
         if (request.header("Host") == null) {
             result.header("Host", hostHeader(request.url()));
+=======
+      if (index > 0) {
+        Interceptor caller = client.networkInterceptors().get(index - 1);
+        Address address = connection().route().address();
+
+        // Confirm that the interceptor uses the connection we've already prepared.
+        if (!request.url().host().equals(address.url().host())
+            || request.url().port() != address.url().port()) {
+          throw new IllegalStateException("network interceptor " + caller
+              + " must retain the same host and port");
+>>>>>>> upstream/master:okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java
         }
 
         if ((connection == null || connection.getProtocol() != Protocol.HTTP_1_0)
                 && request.header("Connection") == null) {
             result.header("Connection", "Keep-Alive");
         }
+<<<<<<< HEAD:okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
 
         if (request.header("Accept-Encoding") == null) {
             transparentGzip = true;
             result.header("Accept-Encoding", "gzip");
+=======
+      }
+
+      if (index < client.networkInterceptors().size()) {
+        // There's another interceptor in the chain. Call that.
+        NetworkInterceptorChain chain = new NetworkInterceptorChain(index + 1, request, connection);
+        Interceptor interceptor = client.networkInterceptors().get(index);
+        Response interceptedResponse = interceptor.intercept(chain);
+
+        // Confirm that the interceptor made the required call to chain.proceed().
+        if (chain.calls != 1) {
+          throw new IllegalStateException("network interceptor " + interceptor
+              + " must call proceed() exactly once");
+>>>>>>> upstream/master:okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java
+        }
+        if (interceptedResponse == null) {
+          throw new NullPointerException("network interceptor " + interceptor
+              + " returned null");
         }
 
         CookieHandler cookieHandler = client.getCookieHandler();
@@ -683,6 +1198,7 @@ private Request networkRequest(Request request) throws IOException {
             // affect cookie choice besides "Host".
             Map<String, List<String>> headers = OkHeaders.toMultimap(result.build().headers(), null);
 
+<<<<<<< HEAD:okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
             Map<String, List<String>> cookies = cookieHandler.get(request.uri(), headers);
 
             // Add any new cookies to the request.
@@ -709,6 +1225,84 @@ public static String hostHeader(URL url) {
     public void readResponse() throws IOException {
         if (userResponse != null) {
             return; // Already ready.
+=======
+      httpStream.writeRequestHeaders(request);
+
+      //Update the networkRequest with the possibly updated interceptor request.
+      networkRequest = request;
+
+      if (permitsRequestBody(request) && request.body() != null) {
+        Sink requestBodyOut = httpStream.createRequestBody(request, request.body().contentLength());
+        BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);
+        request.body().writeTo(bufferedRequestBody);
+        bufferedRequestBody.close();
+      }
+
+      Response response = readNetworkResponse();
+
+      int code = response.code();
+      if ((code == 204 || code == 205) && response.body().contentLength() > 0) {
+        throw new ProtocolException(
+            "HTTP " + code + " had non-zero Content-Length: " + response.body().contentLength());
+      }
+
+      return response;
+    }
+  }
+
+  private Response readNetworkResponse() throws IOException {
+    httpStream.finishRequest();
+
+    Response networkResponse = httpStream.readResponseHeaders()
+        .request(networkRequest)
+        .handshake(streamAllocation.connection().handshake())
+        .sentRequestAtMillis(sentRequestMillis)
+        .receivedResponseAtMillis(System.currentTimeMillis())
+        .build();
+
+    if (!forWebSocket || networkResponse.code() != 101) {
+      networkResponse = networkResponse.newBuilder()
+          .body(httpStream.openResponseBody(networkResponse))
+          .build();
+    }
+
+    if ("close".equalsIgnoreCase(networkResponse.request().header("Connection"))
+        || "close".equalsIgnoreCase(networkResponse.header("Connection"))) {
+      streamAllocation.noNewStreams();
+    }
+
+    return networkResponse;
+  }
+
+  /**
+   * Returns a new source that writes bytes to {@code cacheRequest} as they are read by the source
+   * consumer. This is careful to discard bytes left over when the stream is closed; otherwise we
+   * may never exhaust the source stream and therefore not complete the cached response.
+   */
+  private Response cacheWritingResponse(final CacheRequest cacheRequest, Response response)
+      throws IOException {
+    // Some apps return a null body; for compatibility we treat that like a null cache request.
+    if (cacheRequest == null) return response;
+    Sink cacheBodyUnbuffered = cacheRequest.body();
+    if (cacheBodyUnbuffered == null) return response;
+
+    final BufferedSource source = response.body().source();
+    final BufferedSink cacheBody = Okio.buffer(cacheBodyUnbuffered);
+
+    Source cacheWritingSource = new Source() {
+      boolean cacheRequestClosed;
+
+      @Override public long read(Buffer sink, long byteCount) throws IOException {
+        long bytesRead;
+        try {
+          bytesRead = source.read(sink, byteCount);
+        } catch (IOException e) {
+          if (!cacheRequestClosed) {
+            cacheRequestClosed = true;
+            cacheRequest.abort(); // Failed to write a complete cache response.
+          }
+          throw e;
+>>>>>>> upstream/master:okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java
         }
         if (networkRequest == null && cacheResponse == null) {
             throw new IllegalStateException("call sendRequest() first!");
@@ -761,6 +1355,7 @@ public void readResponse() throws IOException {
             networkResponse = readNetworkResponse();
         }
 
+<<<<<<< HEAD:okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
         receiveHeaders(networkResponse.headers());
 
         // If we have a cache response too, then we're doing a conditional get.
@@ -786,8 +1381,16 @@ public void readResponse() throws IOException {
             } else {
                 closeQuietly(cacheResponse.body());
             }
+=======
+      @Override public void close() throws IOException {
+        if (!cacheRequestClosed
+            && !discard(this, HttpStream.DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
+          cacheRequestClosed = true;
+          cacheRequest.abort();
+>>>>>>> upstream/master:okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java
         }
 
+<<<<<<< HEAD:okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
         userResponse = networkResponse.newBuilder()
                 .request(userRequest)
                 .priorResponse(stripBody(priorResponse))
@@ -800,6 +1403,20 @@ public void readResponse() throws IOException {
             maybeCache();
             userResponse = unzip(cacheWritingResponse(storeRequest, userResponse));
         }
+=======
+    return response.newBuilder()
+        .body(new RealResponseBody(response.headers(), Okio.buffer(cacheWritingSource)))
+        .build();
+  }
+
+  /**
+   * Returns true if {@code cached} should be used; false if {@code network} response should be
+   * used.
+   */
+  private static boolean validate(Response cached, Response network) {
+    if (network.code() == HTTP_NOT_MODIFIED) {
+      return true;
+>>>>>>> upstream/master:okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java
     }
 
     class NetworkInterceptorChain implements Interceptor.Chain {
@@ -822,6 +1439,7 @@ public Request request() {
             return request;
         }
 
+<<<<<<< HEAD:okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
         @Override
         public Response proceed(Request request) throws IOException {
             calls++;
@@ -890,6 +1508,36 @@ private Response readNetworkResponse() throws IOException {
 
         Internal.instance.setProtocol(connection, networkResponse.protocol());
         return networkResponse;
+=======
+    return false;
+  }
+
+  /**
+   * Combines cached headers with a network headers as defined by RFC 2616, 13.5.3.
+   */
+  private static Headers combine(Headers cachedHeaders, Headers networkHeaders) throws IOException {
+    Headers.Builder result = new Headers.Builder();
+
+    for (int i = 0, size = cachedHeaders.size(); i < size; i++) {
+      String fieldName = cachedHeaders.name(i);
+      String value = cachedHeaders.value(i);
+      if ("Warning".equalsIgnoreCase(fieldName) && value.startsWith("1")) {
+        continue; // Drop 100-level freshness warnings.
+      }
+      if (!OkHeaders.isEndToEnd(fieldName) || networkHeaders.get(fieldName) == null) {
+        Internal.instance.addLenient(result, fieldName, value);
+      }
+    }
+
+    for (int i = 0, size = networkHeaders.size(); i < size; i++) {
+      String fieldName = networkHeaders.name(i);
+      if ("Content-Length".equalsIgnoreCase(fieldName)) {
+        continue; // Ignore content-length headers of validating responses.
+      }
+      if (OkHeaders.isEndToEnd(fieldName)) {
+        Internal.instance.addLenient(result, fieldName, networkHeaders.value(i));
+      }
+>>>>>>> upstream/master:okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java
     }
 
     /**
@@ -908,6 +1556,7 @@ private Response cacheWritingResponse(final CacheRequest cacheRequest, Response
             return response;
         }
 
+<<<<<<< HEAD:okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
         final BufferedSource source = response.body().source();
         final BufferedSink cacheBody = Okio.buffer(cacheBodyUnbuffered);
 
@@ -1001,6 +1650,81 @@ private static Headers combine(Headers cachedHeaders, Headers networkHeaders) th
             if (!OkHeaders.isEndToEnd(fieldName) || networkHeaders.get(fieldName) == null) {
                 result.add(fieldName, value);
             }
+=======
+  public void receiveHeaders(Headers headers) throws IOException {
+    if (client.cookieJar() == CookieJar.NO_COOKIES) return;
+
+    List<Cookie> cookies = Cookie.parseAll(userRequest.url(), headers);
+    if (cookies.isEmpty()) return;
+
+    client.cookieJar().saveFromResponse(userRequest.url(), cookies);
+  }
+
+  /**
+   * Figures out the HTTP request to make in response to receiving this engine's response. This will
+   * either add authentication headers, follow redirects or handle a client request timeout. If a
+   * follow-up is either unnecessary or not applicable, this returns null.
+   */
+  public Request followUpRequest() throws IOException {
+    if (userResponse == null) throw new IllegalStateException();
+    Connection connection = streamAllocation.connection();
+    Route route = connection != null
+        ? connection.route()
+        : null;
+    int responseCode = userResponse.code();
+
+    final String method = userRequest.method();
+    switch (responseCode) {
+      case HTTP_PROXY_AUTH:
+        Proxy selectedProxy = route != null
+            ? route.proxy()
+            : client.proxy();
+        if (selectedProxy.type() != Proxy.Type.HTTP) {
+          throw new ProtocolException("Received HTTP_PROXY_AUTH (407) code while not using proxy");
+        }
+        return client.proxyAuthenticator().authenticate(route, userResponse);
+
+      case HTTP_UNAUTHORIZED:
+        return client.authenticator().authenticate(route, userResponse);
+
+      case HTTP_PERM_REDIRECT:
+      case HTTP_TEMP_REDIRECT:
+        // "If the 307 or 308 status code is received in response to a request other than GET
+        // or HEAD, the user agent MUST NOT automatically redirect the request"
+        if (!method.equals("GET") && !method.equals("HEAD")) {
+          return null;
+        }
+        // fall-through
+      case HTTP_MULT_CHOICE:
+      case HTTP_MOVED_PERM:
+      case HTTP_MOVED_TEMP:
+      case HTTP_SEE_OTHER:
+        // Does the client allow redirects?
+        if (!client.followRedirects()) return null;
+
+        String location = userResponse.header("Location");
+        if (location == null) return null;
+        HttpUrl url = userRequest.url().resolve(location);
+
+        // Don't follow redirects to unsupported protocols.
+        if (url == null) return null;
+
+        // If configured, don't follow redirects between SSL and non-SSL.
+        boolean sameScheme = url.scheme().equals(userRequest.url().scheme());
+        if (!sameScheme && !client.followSslRedirects()) return null;
+
+        // Redirects don't include a request body.
+        Request.Builder requestBuilder = userRequest.newBuilder();
+        if (HttpMethod.permitsRequestBody(method)) {
+          if (HttpMethod.redirectsToGet(method)) {
+            requestBuilder.method("GET", null);
+          } else {
+            requestBuilder.method(method, null);
+          }
+          requestBuilder.removeHeader("Transfer-Encoding");
+          requestBuilder.removeHeader("Content-Length");
+          requestBuilder.removeHeader("Content-Type");
+>>>>>>> upstream/master:okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java
         }
 
         for (int i = 0, size = networkHeaders.size(); i < size; i++) {
@@ -1016,6 +1740,7 @@ private static Headers combine(Headers cachedHeaders, Headers networkHeaders) th
         return result.build();
     }
 
+<<<<<<< HEAD:okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
     public void receiveHeaders(Headers headers) throws IOException {
         CookieHandler cookieHandler = client.getCookieHandler();
         if (cookieHandler != null) {
@@ -1135,4 +1860,47 @@ private static Address createAddress(OkHttpClient client, Request request)
                 client.getAuthenticator(), client.getProxy(), client.getProtocols(),
                 client.getConnectionSpecs(), client.getProxySelector());
     }
+=======
+      case HTTP_CLIENT_TIMEOUT:
+        // 408's are rare in practice, but some servers like HAProxy use this response code. The
+        // spec says that we may repeat the request without modifications. Modern browsers also
+        // repeat the request (even non-idempotent ones.)
+        if (userRequest.body() instanceof UnrepeatableRequestBody) {
+          return null;
+        }
+
+        return userRequest;
+
+      default:
+        return null;
+    }
+  }
+
+  /**
+   * Returns true if an HTTP request for {@code followUp} can reuse the connection used by this
+   * engine.
+   */
+  public boolean sameConnection(HttpUrl followUp) {
+    HttpUrl url = userRequest.url();
+    return url.host().equals(followUp.host())
+        && url.port() == followUp.port()
+        && url.scheme().equals(followUp.scheme());
+  }
+
+  private static Address createAddress(OkHttpClient client, Request request) {
+    SSLSocketFactory sslSocketFactory = null;
+    HostnameVerifier hostnameVerifier = null;
+    CertificatePinner certificatePinner = null;
+    if (request.isHttps()) {
+      sslSocketFactory = client.sslSocketFactory();
+      hostnameVerifier = client.hostnameVerifier();
+      certificatePinner = client.certificatePinner();
+    }
+
+    return new Address(request.url().host(), request.url().port(), client.dns(),
+        client.socketFactory(), sslSocketFactory, hostnameVerifier, certificatePinner,
+        client.proxyAuthenticator(), client.proxy(), client.protocols(),
+        client.connectionSpecs(), client.proxySelector());
+  }
+>>>>>>> upstream/master:okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpMethod.java b/okhttp/src/main/java/okhttp3/internal/http/HttpMethod.java
similarity index 55%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpMethod.java
rename to okhttp/src/main/java/okhttp3/internal/http/HttpMethod.java
index b5f2a48f86..3629810c0e 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpMethod.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/HttpMethod.java
@@ -13,25 +13,37 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.http;
+package okhttp3.internal.http;
 
 public final class HttpMethod {
   public static boolean invalidatesCache(String method) {
     return method.equals("POST")
         || method.equals("PATCH")
         || method.equals("PUT")
-        || method.equals("DELETE");
+        || method.equals("DELETE")
+        || method.equals("MOVE");     // WebDAV
   }
 
   public static boolean requiresRequestBody(String method) {
     return method.equals("POST")
         || method.equals("PUT")
-        || method.equals("PATCH");
+        || method.equals("PATCH")
+        || method.equals("PROPPATCH") // WebDAV
+        || method.equals("REPORT");   // CalDAV/CardDAV (defined in WebDAV Versioning)
   }
 
   public static boolean permitsRequestBody(String method) {
     return requiresRequestBody(method)
-        || method.equals("DELETE"); // Permitted as spec is ambiguous.
+        || method.equals("OPTIONS")
+        || method.equals("DELETE")    // Permitted as spec is ambiguous.
+        || method.equals("PROPFIND")  // (WebDAV) without body: request <allprop/>
+        || method.equals("MKCOL")     // (WebDAV) may contain a body, but behaviour is unspecified
+        || method.equals("LOCK");     // (WebDAV) body: create lock, without body: refresh lock
+  }
+
+  public static boolean redirectsToGet(String method) {
+    // All requests but PROPFIND should redirect to a GET request.
+    return !method.equals("PROPFIND");
   }
 
   private HttpMethod() {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/Transport.java b/okhttp/src/main/java/okhttp3/internal/http/HttpStream.java
similarity index 61%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/http/Transport.java
rename to okhttp/src/main/java/okhttp3/internal/http/HttpStream.java
index 77f7c9e746..fb47e27704 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/Transport.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/HttpStream.java
@@ -13,20 +13,19 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+package okhttp3.internal.http;
 
-package com.squareup.okhttp.internal.http;
-
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
-import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
 import okio.Sink;
 
-public interface Transport {
+public interface HttpStream {
   /**
-   * The timeout to use while discarding a stream of input data. Since this is
-   * used for connection reuse, this timeout should be significantly less than
-   * the time it takes to establish a new connection.
+   * The timeout to use while discarding a stream of input data. Since this is used for connection
+   * reuse, this timeout should be significantly less than the time it takes to establish a new
+   * connection.
    */
   int DISCARD_STREAM_TIMEOUT_MILLIS = 100;
 
@@ -36,12 +35,6 @@
   /** This should update the HTTP engine's sentRequestMillis field. */
   void writeRequestHeaders(Request request) throws IOException;
 
-  /**
-   * Sends the request body returned by {@link #createRequestBody} to the
-   * remote peer.
-   */
-  void writeRequestBody(RetryableSink requestBody) throws IOException;
-
   /** Flush the request to the underlying socket. */
   void finishRequest() throws IOException;
 
@@ -51,17 +44,11 @@
   /** Returns a stream that reads the response body. */
   ResponseBody openResponseBody(Response response) throws IOException;
 
-  /**
-   * Configures the response body to pool or close the socket connection when
-   * the response body is closed.
-   */
-  void releaseConnectionOnIdle() throws IOException;
-
-  void disconnect(HttpEngine engine) throws IOException;
+  void setHttpEngine(HttpEngine httpEngine);
 
   /**
-   * Returns true if the socket connection held by this transport can be reused
-   * for a follow-up exchange.
+   * Cancel this stream. Resources held by this stream will be cleaned up, though not synchronously.
+   * That may happen later by the connection pool thread.
    */
-  boolean canReuseConnection();
+  void cancel();
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/OkHeaders.java b/okhttp/src/main/java/okhttp3/internal/http/OkHeaders.java
similarity index 56%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/http/OkHeaders.java
rename to okhttp/src/main/java/okhttp3/internal/http/OkHeaders.java
index a39c657efa..db8011c542 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/OkHeaders.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/OkHeaders.java
@@ -1,41 +1,36 @@
-package com.squareup.okhttp.internal.http;
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http;
 
-import com.squareup.okhttp.Authenticator;
-import com.squareup.okhttp.Challenge;
-import com.squareup.okhttp.Headers;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
-import com.squareup.okhttp.internal.Platform;
-import java.io.IOException;
-import java.net.Proxy;
 import java.util.ArrayList;
 import java.util.Collections;
-import java.util.Comparator;
 import java.util.List;
-import java.util.Map;
 import java.util.Set;
-import java.util.TreeMap;
 import java.util.TreeSet;
+import okhttp3.Challenge;
+import okhttp3.Headers;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.internal.Platform;
 
-import static com.squareup.okhttp.internal.Util.equal;
-import static java.net.HttpURLConnection.HTTP_PROXY_AUTH;
+import static okhttp3.internal.Util.equal;
 
 /** Headers and utilities for internal use by OkHttp. */
 public final class OkHeaders {
-  private static final Comparator<String> FIELD_NAME_COMPARATOR = new Comparator<String>() {
-    // @FindBugsSuppressWarnings("ES_COMPARING_PARAMETER_STRING_WITH_EQ")
-    @Override public int compare(String a, String b) {
-      if (a == b) {
-        return 0;
-      } else if (a == null) {
-        return -1;
-      } else if (b == null) {
-        return 1;
-      } else {
-        return String.CASE_INSENSITIVE_ORDER.compare(a, b);
-      }
-    }
-  };
 
   static final String PREFIX = Platform.get().getPrefix();
 
@@ -50,11 +45,14 @@
   public static final String RECEIVED_MILLIS = PREFIX + "-Received-Millis";
 
   /**
-   * Synthetic response header: the selected
-   * {@link com.squareup.okhttp.Protocol protocol} ("spdy/3.1", "http/1.1", etc).
+   * Synthetic response header: the selected {@link Protocol protocol} ("spdy/3.1", "http/1.1",
+   * etc).
    */
   public static final String SELECTED_PROTOCOL = PREFIX + "-Selected-Protocol";
 
+  /** Synthetic response header: the location from which the response was loaded. */
+  public static final String RESPONSE_SOURCE = PREFIX + "-Response-Source";
+
   private OkHeaders() {
   }
 
@@ -80,58 +78,8 @@ private static long stringToLong(String s) {
   }
 
   /**
-   * Returns an immutable map containing each field to its list of values.
-   *
-   * @param valueForNullKey the request line for requests, or the status line
-   *     for responses. If non-null, this value is mapped to the null key.
-   */
-  public static Map<String, List<String>> toMultimap(Headers headers, String valueForNullKey) {
-    Map<String, List<String>> result = new TreeMap<>(FIELD_NAME_COMPARATOR);
-    for (int i = 0, size = headers.size(); i < size; i++) {
-      String fieldName = headers.name(i);
-      String value = headers.value(i);
-
-      List<String> allValues = new ArrayList<>();
-      List<String> otherValues = result.get(fieldName);
-      if (otherValues != null) {
-        allValues.addAll(otherValues);
-      }
-      allValues.add(value);
-      result.put(fieldName, Collections.unmodifiableList(allValues));
-    }
-    if (valueForNullKey != null) {
-      result.put(null, Collections.unmodifiableList(Collections.singletonList(valueForNullKey)));
-    }
-    return Collections.unmodifiableMap(result);
-  }
-
-  public static void addCookies(Request.Builder builder, Map<String, List<String>> cookieHeaders) {
-    for (Map.Entry<String, List<String>> entry : cookieHeaders.entrySet()) {
-      String key = entry.getKey();
-      if (("Cookie".equalsIgnoreCase(key) || "Cookie2".equalsIgnoreCase(key))
-          && !entry.getValue().isEmpty()) {
-        builder.addHeader(key, buildCookieHeader(entry.getValue()));
-      }
-    }
-  }
-
-  /**
-   * Send all cookies in one big header, as recommended by
-   * <a href="http://tools.ietf.org/html/rfc6265#section-4.2.1">RFC 6265</a>.
-   */
-  private static String buildCookieHeader(List<String> cookies) {
-    if (cookies.size() == 1) return cookies.get(0);
-    StringBuilder sb = new StringBuilder();
-    for (int i = 0, size = cookies.size(); i < size; i++) {
-      if (i > 0) sb.append("; ");
-      sb.append(cookies.get(i));
-    }
-    return sb.toString();
-  }
-
-  /**
-   * Returns true if none of the Vary headers have changed between {@code
-   * cachedRequest} and {@code newRequest}.
+   * Returns true if none of the Vary headers have changed between {@code cachedRequest} and {@code
+   * newRequest}.
    */
   public static boolean varyMatches(
       Response cachedResponse, Headers cachedRequest, Request newRequest) {
@@ -142,20 +90,32 @@ public static boolean varyMatches(
   }
 
   /**
-   * Returns true if a Vary header contains an asterisk. Such responses cannot
-   * be cached.
+   * Returns true if a Vary header contains an asterisk. Such responses cannot be cached.
    */
   public static boolean hasVaryAll(Response response) {
-    return varyFields(response).contains("*");
+    return hasVaryAll(response.headers());
+  }
+
+  /**
+   * Returns true if a Vary header contains an asterisk. Such responses cannot be cached.
+   */
+  public static boolean hasVaryAll(Headers responseHeaders) {
+    return varyFields(responseHeaders).contains("*");
   }
 
   private static Set<String> varyFields(Response response) {
+    return varyFields(response.headers());
+  }
+
+  /**
+   * Returns the names of the request headers that need to be checked for equality when caching.
+   */
+  public static Set<String> varyFields(Headers responseHeaders) {
     Set<String> result = Collections.emptySet();
-    Headers headers = response.headers();
-    for (int i = 0, size = headers.size(); i < size; i++) {
-      if (!"Vary".equalsIgnoreCase(headers.name(i))) continue;
+    for (int i = 0, size = responseHeaders.size(); i < size; i++) {
+      if (!"Vary".equalsIgnoreCase(responseHeaders.name(i))) continue;
 
-      String value = headers.value(i);
+      String value = responseHeaders.value(i);
       if (result.isEmpty()) {
         result = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);
       }
@@ -167,17 +127,25 @@ public static boolean hasVaryAll(Response response) {
   }
 
   /**
-   * Returns the subset of the headers in {@code response}'s request that
-   * impact the content of response's body.
+   * Returns the subset of the headers in {@code response}'s request that impact the content of
+   * response's body.
    */
   public static Headers varyHeaders(Response response) {
-    Set<String> varyFields = varyFields(response);
-    if (varyFields.isEmpty()) return new Headers.Builder().build();
-
     // Use the request headers sent over the network, since that's what the
     // response varies on. Otherwise OkHttp-supplied headers like
     // "Accept-Encoding: gzip" may be lost.
     Headers requestHeaders = response.networkResponse().request().headers();
+    Headers responseHeaders = response.headers();
+    return varyHeaders(requestHeaders, responseHeaders);
+  }
+
+  /**
+   * Returns the subset of the headers in {@code requestHeaders} that impact the content of
+   * response's body.
+   */
+  public static Headers varyHeaders(Headers requestHeaders, Headers responseHeaders) {
+    Set<String> varyFields = varyFields(responseHeaders);
+    if (varyFields.isEmpty()) return new Headers.Builder().build();
 
     Headers.Builder result = new Headers.Builder();
     for (int i = 0, size = requestHeaders.size(); i < size; i++) {
@@ -190,8 +158,8 @@ public static Headers varyHeaders(Response response) {
   }
 
   /**
-   * Returns true if {@code fieldName} is an end-to-end HTTP header, as
-   * defined by RFC 2616, 13.5.1.
+   * Returns true if {@code fieldName} is an end-to-end HTTP header, as defined by RFC 2616,
+   * 13.5.1.
    */
   static boolean isEndToEnd(String fieldName) {
     return !"Connection".equalsIgnoreCase(fieldName)
@@ -205,8 +173,7 @@ static boolean isEndToEnd(String fieldName) {
   }
 
   /**
-   * Parse RFC 2617 challenges. This API is only interested in the scheme
-   * name and realm.
+   * Parse RFC 2617 challenges. This API is only interested in the scheme name and realm.
    */
   public static List<Challenge> parseChallenges(Headers responseHeaders, String challengeHeader) {
     // auth-scheme = token
@@ -249,16 +216,4 @@ static boolean isEndToEnd(String fieldName) {
     }
     return result;
   }
-
-  /**
-   * React to a failed authorization response by looking up new credentials.
-   * Returns a request for a subsequent attempt, or null if no further attempts
-   * should be made.
-   */
-  public static Request processAuthHeader(Authenticator authenticator, Response response,
-      Proxy proxy) throws IOException {
-    return response.code() == HTTP_PROXY_AUTH
-        ? authenticator.authenticateProxy(proxy, response)
-        : authenticator.authenticate(proxy, response);
-  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RealResponseBody.java b/okhttp/src/main/java/okhttp3/internal/http/RealResponseBody.java
similarity index 88%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/http/RealResponseBody.java
rename to okhttp/src/main/java/okhttp3/internal/http/RealResponseBody.java
index 18d026f11a..d66fed988c 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RealResponseBody.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/RealResponseBody.java
@@ -13,11 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.http;
+package okhttp3.internal.http;
 
-import com.squareup.okhttp.Headers;
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.ResponseBody;
+import okhttp3.Headers;
+import okhttp3.MediaType;
+import okhttp3.ResponseBody;
 import okio.BufferedSource;
 
 public final class RealResponseBody extends ResponseBody {
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RequestLine.java b/okhttp/src/main/java/okhttp3/internal/http/RequestLine.java
new file mode 100644
index 0000000000..c70a86934e
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http/RequestLine.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http;
+
+import java.net.HttpURLConnection;
+import java.net.Proxy;
+import okhttp3.HttpUrl;
+import okhttp3.Request;
+
+public final class RequestLine {
+  private RequestLine() {
+  }
+
+  /**
+   * Returns the request status line, like "GET / HTTP/1.1". This is exposed to the application by
+   * {@link HttpURLConnection#getHeaderFields}, so it needs to be set even if the transport is
+   * SPDY.
+   */
+  static String get(Request request, Proxy.Type proxyType) {
+    StringBuilder result = new StringBuilder();
+    result.append(request.method());
+    result.append(' ');
+
+    if (includeAuthorityInRequestLine(request, proxyType)) {
+      result.append(request.url());
+    } else {
+      result.append(requestPath(request.url()));
+    }
+
+    result.append(" HTTP/1.1");
+    return result.toString();
+  }
+
+  /**
+   * Returns true if the request line should contain the full URL with host and port (like "GET
+   * http://android.com/foo HTTP/1.1") or only the path (like "GET /foo HTTP/1.1").
+   */
+  private static boolean includeAuthorityInRequestLine(Request request, Proxy.Type proxyType) {
+    return !request.isHttps() && proxyType == Proxy.Type.HTTP;
+  }
+
+  /**
+   * Returns the path to request, like the '/' in 'GET / HTTP/1.1'. Never empty, even if the request
+   * URL is. Includes the query component if it exists.
+   */
+  public static String requestPath(HttpUrl url) {
+    String path = url.encodedPath();
+    String query = url.encodedQuery();
+    return query != null ? (path + '?' + query) : path;
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RouteException.java b/okhttp/src/main/java/okhttp3/internal/http/RouteException.java
new file mode 100644
index 0000000000..030b346a5a
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http/RouteException.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http;
+
+import java.io.IOException;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+
+/**
+ * An exception thrown to indicate a problem connecting via a single Route. Multiple attempts may
+ * have been made with alternative protocols, none of which were successful.
+ */
+public final class RouteException extends Exception {
+  private static final Method addSuppressedExceptionMethod;
+
+  static {
+    Method m;
+    try {
+      m = Throwable.class.getDeclaredMethod("addSuppressed", Throwable.class);
+    } catch (Exception e) {
+      m = null;
+    }
+    addSuppressedExceptionMethod = m;
+  }
+
+  private IOException lastException;
+
+  public RouteException(IOException cause) {
+    super(cause);
+    lastException = cause;
+  }
+
+  public IOException getLastConnectException() {
+    return lastException;
+  }
+
+  public void addConnectException(IOException e) {
+    addSuppressedIfPossible(e, lastException);
+    lastException = e;
+  }
+
+  private void addSuppressedIfPossible(IOException e, IOException suppressed) {
+    if (addSuppressedExceptionMethod != null) {
+      try {
+        addSuppressedExceptionMethod.invoke(e, suppressed);
+      } catch (InvocationTargetException | IllegalAccessException ignored) {
+      }
+    }
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RouteSelector.java b/okhttp/src/main/java/okhttp3/internal/http/RouteSelector.java
similarity index 54%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/http/RouteSelector.java
rename to okhttp/src/main/java/okhttp3/internal/http/RouteSelector.java
index 4a653246cc..3b5725cbe6 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RouteSelector.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/RouteSelector.java
@@ -13,50 +13,34 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.http;
+package okhttp3.internal.http;
 
-import com.squareup.okhttp.Address;
-import com.squareup.okhttp.ConnectionSpec;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Route;
-import com.squareup.okhttp.internal.Internal;
-import com.squareup.okhttp.internal.Network;
-import com.squareup.okhttp.internal.RouteDatabase;
 import java.io.IOException;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.net.Proxy;
 import java.net.SocketAddress;
 import java.net.SocketException;
-import java.net.URI;
-import java.net.UnknownServiceException;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 import java.util.NoSuchElementException;
-import javax.net.ssl.SSLHandshakeException;
-import javax.net.ssl.SSLProtocolException;
-
-import static com.squareup.okhttp.internal.Util.getEffectivePort;
+import okhttp3.Address;
+import okhttp3.HttpUrl;
+import okhttp3.Route;
+import okhttp3.internal.RouteDatabase;
 
 /**
- * Selects routes to connect to an origin server. Each connection requires a
- * choice of proxy server, IP address, and TLS mode. Connections may also be
- * recycled.
+ * Selects routes to connect to an origin server. Each connection requires a choice of proxy server,
+ * IP address, and TLS mode. Connections may also be recycled.
  */
 public final class RouteSelector {
   private final Address address;
-  private final URI uri;
-  private final Network network;
-  private final OkHttpClient client;
   private final RouteDatabase routeDatabase;
-  private final Request request;
 
   /* The most recently attempted route. */
   private Proxy lastProxy;
   private InetSocketAddress lastInetSocketAddress;
-  private ConnectionSpec lastSpec;
 
   /* State for negotiating the next proxy to use. */
   private List<Proxy> proxies = Collections.emptyList();
@@ -66,59 +50,39 @@
   private List<InetSocketAddress> inetSocketAddresses = Collections.emptyList();
   private int nextInetSocketAddressIndex;
 
-  /* Specs to attempt with the connection. */
-  private List<ConnectionSpec> connectionSpecs = Collections.emptyList();
-  private int nextSpecIndex;
-
   /* State for negotiating failed routes */
   private final List<Route> postponedRoutes = new ArrayList<>();
 
-  private RouteSelector(Address address, URI uri, OkHttpClient client, Request request) {
+  public RouteSelector(Address address, RouteDatabase routeDatabase) {
     this.address = address;
-    this.uri = uri;
-    this.client = client;
-    this.routeDatabase = Internal.instance.routeDatabase(client);
-    this.network = Internal.instance.network(client);
-    this.request = request;
-
-    resetNextProxy(uri, address.getProxy());
-  }
+    this.routeDatabase = routeDatabase;
 
-  public static RouteSelector get(Address address, Request request, OkHttpClient client)
-      throws IOException {
-    return new RouteSelector(address, request.uri(), client, request);
+    resetNextProxy(address.url(), address.proxy());
   }
 
   /**
-   * Returns true if there's another route to attempt. Every address has at
-   * least one route.
+   * Returns true if there's another route to attempt. Every address has at least one route.
    */
   public boolean hasNext() {
-    return hasNextConnectionSpec()
-        || hasNextInetSocketAddress()
+    return hasNextInetSocketAddress()
         || hasNextProxy()
         || hasNextPostponed();
   }
 
   public Route next() throws IOException {
     // Compute the next route to attempt.
-    if (!hasNextConnectionSpec()) {
-      if (!hasNextInetSocketAddress()) {
-        if (!hasNextProxy()) {
-          if (!hasNextPostponed()) {
-            throw new NoSuchElementException();
-          }
-          return nextPostponed();
+    if (!hasNextInetSocketAddress()) {
+      if (!hasNextProxy()) {
+        if (!hasNextPostponed()) {
+          throw new NoSuchElementException();
         }
-        lastProxy = nextProxy();
+        return nextPostponed();
       }
-      lastInetSocketAddress = nextInetSocketAddress();
+      lastProxy = nextProxy();
     }
-    lastSpec = nextConnectionSpec();
+    lastInetSocketAddress = nextInetSocketAddress();
 
-    final boolean shouldSendTlsFallbackIndicator = shouldSendTlsFallbackIndicator(lastSpec);
-    Route route = new Route(address, lastProxy, lastInetSocketAddress, lastSpec,
-        shouldSendTlsFallbackIndicator);
+    Route route = new Route(address, lastProxy, lastInetSocketAddress);
     if (routeDatabase.shouldPostpone(route)) {
       postponedRoutes.add(route);
       // We will only recurse in order to skip previously failed routes. They will be tried last.
@@ -128,40 +92,22 @@ public Route next() throws IOException {
     return route;
   }
 
-  private boolean shouldSendTlsFallbackIndicator(ConnectionSpec connectionSpec) {
-    return connectionSpec != connectionSpecs.get(0)
-        && connectionSpec.isTls();
-  }
-
   /**
-   * Clients should invoke this method when they encounter a connectivity
-   * failure on a connection returned by this route selector.
+   * Clients should invoke this method when they encounter a connectivity failure on a connection
+   * returned by this route selector.
    */
   public void connectFailed(Route failedRoute, IOException failure) {
-    if (failedRoute.getProxy().type() != Proxy.Type.DIRECT && address.getProxySelector() != null) {
+    if (failedRoute.proxy().type() != Proxy.Type.DIRECT && address.proxySelector() != null) {
       // Tell the proxy selector when we fail to connect on a fresh connection.
-      address.getProxySelector().connectFailed(uri, failedRoute.getProxy().address(), failure);
+      address.proxySelector().connectFailed(
+          address.url().uri(), failedRoute.proxy().address(), failure);
     }
 
     routeDatabase.failed(failedRoute);
-
-    // If the previously returned route's problem was not related to the connection's spec, and the
-    // next route only changes that, we shouldn't even attempt it. This suppresses it in both this
-    // selector and also in the route database.
-    if (!(failure instanceof SSLHandshakeException) && !(failure instanceof SSLProtocolException)) {
-      while (nextSpecIndex < connectionSpecs.size()) {
-        ConnectionSpec connectionSpec = connectionSpecs.get(nextSpecIndex++);
-        final boolean shouldSendTlsFallbackIndicator =
-            shouldSendTlsFallbackIndicator(connectionSpec);
-        Route toSuppress = new Route(address, lastProxy, lastInetSocketAddress, connectionSpec,
-            shouldSendTlsFallbackIndicator);
-        routeDatabase.failed(toSuppress);
-      }
-    }
   }
 
   /** Prepares the proxy servers to try. */
-  private void resetNextProxy(URI uri, Proxy proxy) {
+  private void resetNextProxy(HttpUrl url, Proxy proxy) {
     if (proxy != null) {
       // If the user specifies a proxy, try that and only that.
       proxies = Collections.singletonList(proxy);
@@ -169,7 +115,7 @@ private void resetNextProxy(URI uri, Proxy proxy) {
       // Try each of the ProxySelector choices until one connection succeeds. If none succeed
       // then we'll try a direct connection below.
       proxies = new ArrayList<>();
-      List<Proxy> selectedProxies = client.getProxySelector().select(uri);
+      List<Proxy> selectedProxies = address.proxySelector().select(url.uri());
       if (selectedProxies != null) proxies.addAll(selectedProxies);
       // Finally try a direct connection. We only try it once!
       proxies.removeAll(Collections.singleton(Proxy.NO_PROXY));
@@ -186,7 +132,7 @@ private boolean hasNextProxy() {
   /** Returns the next proxy to try. May be PROXY.NO_PROXY but never null. */
   private Proxy nextProxy() throws IOException {
     if (!hasNextProxy()) {
-      throw new SocketException("No route to " + address.getUriHost()
+      throw new SocketException("No route to " + address.url().host()
           + "; exhausted proxy configurations: " + proxies);
     }
     Proxy result = proxies.get(nextProxyIndex++);
@@ -202,8 +148,8 @@ private void resetNextInetSocketAddress(Proxy proxy) throws IOException {
     String socketHost;
     int socketPort;
     if (proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.SOCKS) {
-      socketHost = address.getUriHost();
-      socketPort = getEffectivePort(uri);
+      socketHost = address.url().host();
+      socketPort = address.url().port();
     } else {
       SocketAddress proxyAddress = proxy.address();
       if (!(proxyAddress instanceof InetSocketAddress)) {
@@ -220,10 +166,17 @@ private void resetNextInetSocketAddress(Proxy proxy) throws IOException {
           + "; port is out of range");
     }
 
-    // Try each address for best behavior in mixed IPv4/IPv6 environments.
-    for (InetAddress inetAddress : network.resolveInetAddresses(socketHost)) {
-      inetSocketAddresses.add(new InetSocketAddress(inetAddress, socketPort));
+    if (proxy.type() == Proxy.Type.SOCKS) {
+      inetSocketAddresses.add(InetSocketAddress.createUnresolved(socketHost, socketPort));
+    } else {
+      // Try each address for best behavior in mixed IPv4/IPv6 environments.
+      List<InetAddress> addresses = address.dns().lookup(socketHost);
+      for (int i = 0, size = addresses.size(); i < size; i++) {
+        InetAddress inetAddress = addresses.get(i);
+        inetSocketAddresses.add(new InetSocketAddress(inetAddress, socketPort));
+      }
     }
+
     nextInetSocketAddressIndex = 0;
   }
 
@@ -253,45 +206,10 @@ private boolean hasNextInetSocketAddress() {
   /** Returns the next socket address to try. */
   private InetSocketAddress nextInetSocketAddress() throws IOException {
     if (!hasNextInetSocketAddress()) {
-      throw new SocketException("No route to " + address.getUriHost()
+      throw new SocketException("No route to " + address.url().host()
           + "; exhausted inet socket addresses: " + inetSocketAddresses);
     }
-    InetSocketAddress result = inetSocketAddresses.get(nextInetSocketAddressIndex++);
-    resetConnectionSpecs();
-    return result;
-  }
-
-  /** Prepares the connection specs to attempt. */
-  private void resetConnectionSpecs() {
-    connectionSpecs = new ArrayList<>();
-    List<ConnectionSpec> specs = address.getConnectionSpecs();
-    for (int i = 0, size = specs.size(); i < size; i++) {
-      ConnectionSpec spec = specs.get(i);
-      if (request.isHttps() == spec.isTls()) {
-        connectionSpecs.add(spec);
-      }
-    }
-    nextSpecIndex = 0;
-  }
-
-  /** Returns true if there's another connection spec to try. */
-  private boolean hasNextConnectionSpec() {
-    return nextSpecIndex < connectionSpecs.size();
-  }
-
-  /** Returns the next connection spec to try. */
-  private ConnectionSpec nextConnectionSpec() throws IOException {
-    if (connectionSpecs.isEmpty()) {
-      throw new UnknownServiceException("No route to "
-          + ((uri.getScheme() != null) ? (uri.getScheme() + "://") : "//") + address.getUriHost()
-          + "; no connection specs");
-    }
-    if (!hasNextConnectionSpec()) {
-      throw new SocketException("No route to "
-          + ((uri.getScheme() != null) ? (uri.getScheme() + "://") : "//") + address.getUriHost()
-          + "; exhausted connection specs: " + connectionSpecs);
-    }
-    return connectionSpecs.get(nextSpecIndex++);
+    return inetSocketAddresses.get(nextInetSocketAddressIndex++);
   }
 
   /** Returns true if there is another postponed route to try. */
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/StatusLine.java b/okhttp/src/main/java/okhttp3/internal/http/StatusLine.java
similarity index 81%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/http/StatusLine.java
rename to okhttp/src/main/java/okhttp3/internal/http/StatusLine.java
index ab9ebc1535..f3591a6bf9 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/StatusLine.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/StatusLine.java
@@ -1,9 +1,24 @@
-package com.squareup.okhttp.internal.http;
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http;
 
-import com.squareup.okhttp.Protocol;
-import com.squareup.okhttp.Response;
 import java.io.IOException;
 import java.net.ProtocolException;
+import okhttp3.Protocol;
+import okhttp3.Response;
 
 /** An HTTP response status line like "HTTP/1.1 200 OK". */
 public final class StatusLine {
diff --git a/okhttp/src/main/java/okhttp3/internal/http/StreamAllocation.java b/okhttp/src/main/java/okhttp3/internal/http/StreamAllocation.java
new file mode 100644
index 0000000000..aee74cf0bb
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http/StreamAllocation.java
@@ -0,0 +1,336 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http;
+
+import java.io.IOException;
+import java.lang.ref.Reference;
+import java.lang.ref.WeakReference;
+import okhttp3.Address;
+import okhttp3.ConnectionPool;
+import okhttp3.Route;
+import okhttp3.internal.Internal;
+import okhttp3.internal.RouteDatabase;
+import okhttp3.internal.Util;
+import okhttp3.internal.framed.ErrorCode;
+import okhttp3.internal.framed.StreamResetException;
+import okhttp3.internal.io.RealConnection;
+
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+
+/**
+ * This class coordinates the relationship between three entities:
+ *
+ * <ul>
+ *     <li><strong>Connections:</strong> physical socket connections to remote servers. These are
+ *         potentially slow to establish so it is necessary to be able to cancel a connection
+ *         currently being connected.
+ *     <li><strong>Streams:</strong> logical HTTP request/response pairs that are layered on
+ *         connections. Each connection has its own allocation limit, which defines how many
+ *         concurrent streams that connection can carry. HTTP/1.x connections can carry 1 stream
+ *         at a time, SPDY and HTTP/2 typically carry multiple.
+ *     <li><strong>Calls:</strong> a logical sequence of streams, typically an initial request and
+ *         its follow up requests. We prefer to keep all streams of a single call on the same
+ *         connection for better behavior and locality.
+ * </ul>
+ *
+ * <p>Instances of this class act on behalf of the call, using one or more streams over one or more
+ * connections. This class has APIs to release each of the above resources:
+ *
+ * <ul>
+ *     <li>{@link #noNewStreams()} prevents the connection from being used for new streams in the
+ *         future. Use this after a {@code Connection: close} header, or when the connection may be
+ *         inconsistent.
+ *     <li>{@link #streamFinished streamFinished()} releases the active stream from this allocation.
+ *         Note that only one stream may be active at a given time, so it is necessary to call
+ *         {@link #streamFinished streamFinished()} before creating a subsequent stream with {@link
+ *         #newStream newStream()}.
+ *     <li>{@link #release()} removes the call's hold on the connection. Note that this won't
+ *         immediately free the connection if there is a stream still lingering. That happens when a
+ *         call is complete but its response body has yet to be fully consumed.
+ * </ul>
+ *
+ * <p>This class supports {@linkplain #cancel asynchronous canceling}. This is intended to have the
+ * smallest blast radius possible. If an HTTP/2 stream is active, canceling will cancel that stream
+ * but not the other streams sharing its connection. But if the TLS handshake is still in progress
+ * then canceling may break the entire connection.
+ */
+public final class StreamAllocation {
+  public final Address address;
+  private Route route;
+  private final ConnectionPool connectionPool;
+
+  // State guarded by connectionPool.
+  private final RouteSelector routeSelector;
+  private int refusedStreamCount;
+  private RealConnection connection;
+  private boolean released;
+  private boolean canceled;
+  private HttpStream stream;
+
+  public StreamAllocation(ConnectionPool connectionPool, Address address) {
+    this.connectionPool = connectionPool;
+    this.address = address;
+    this.routeSelector = new RouteSelector(address, routeDatabase());
+  }
+
+  public HttpStream newStream(int connectTimeout, int readTimeout, int writeTimeout,
+      boolean connectionRetryEnabled, boolean doExtensiveHealthChecks)
+      throws RouteException, IOException {
+    try {
+      RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,
+          writeTimeout, connectionRetryEnabled, doExtensiveHealthChecks);
+
+      HttpStream resultStream;
+      if (resultConnection.framedConnection != null) {
+        resultStream = new Http2xStream(this, resultConnection.framedConnection);
+      } else {
+        resultConnection.socket().setSoTimeout(readTimeout);
+        resultConnection.source.timeout().timeout(readTimeout, MILLISECONDS);
+        resultConnection.sink.timeout().timeout(writeTimeout, MILLISECONDS);
+        resultStream = new Http1xStream(this, resultConnection.source, resultConnection.sink);
+      }
+
+      synchronized (connectionPool) {
+        stream = resultStream;
+        return resultStream;
+      }
+    } catch (IOException e) {
+      throw new RouteException(e);
+    }
+  }
+
+  /**
+   * Finds a connection and returns it if it is healthy. If it is unhealthy the process is repeated
+   * until a healthy connection is found.
+   */
+  private RealConnection findHealthyConnection(int connectTimeout, int readTimeout,
+      int writeTimeout, boolean connectionRetryEnabled, boolean doExtensiveHealthChecks)
+      throws IOException, RouteException {
+    while (true) {
+      RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,
+          connectionRetryEnabled);
+
+      // If this is a brand new connection, we can skip the extensive health checks.
+      synchronized (connectionPool) {
+        if (candidate.successCount == 0) {
+          return candidate;
+        }
+      }
+
+      // Do a (potentially slow) check to confirm that the pooled connection is still good. If it
+      // isn't, take it out of the pool and start again.
+      if (!candidate.isHealthy(doExtensiveHealthChecks)) {
+        noNewStreams();
+        continue;
+      }
+
+      return candidate;
+    }
+  }
+
+  /**
+   * Returns a connection to host a new stream. This prefers the existing connection if it exists,
+   * then the pool, finally building a new connection.
+   */
+  private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout,
+      boolean connectionRetryEnabled) throws IOException, RouteException {
+    Route selectedRoute;
+    synchronized (connectionPool) {
+      if (released) throw new IllegalStateException("released");
+      if (stream != null) throw new IllegalStateException("stream != null");
+      if (canceled) throw new IOException("Canceled");
+
+      RealConnection allocatedConnection = this.connection;
+      if (allocatedConnection != null && !allocatedConnection.noNewStreams) {
+        return allocatedConnection;
+      }
+
+      // Attempt to get a connection from the pool.
+      RealConnection pooledConnection = Internal.instance.get(connectionPool, address, this);
+      if (pooledConnection != null) {
+        this.connection = pooledConnection;
+        return pooledConnection;
+      }
+
+      selectedRoute = route;
+    }
+
+    if (selectedRoute == null) {
+      selectedRoute = routeSelector.next();
+      synchronized (connectionPool) {
+        route = selectedRoute;
+        refusedStreamCount = 0;
+      }
+    }
+    RealConnection newConnection = new RealConnection(selectedRoute);
+    acquire(newConnection);
+
+    synchronized (connectionPool) {
+      Internal.instance.put(connectionPool, newConnection);
+      this.connection = newConnection;
+      if (canceled) throw new IOException("Canceled");
+    }
+
+    newConnection.connect(connectTimeout, readTimeout, writeTimeout, address.connectionSpecs(),
+        connectionRetryEnabled);
+    routeDatabase().connected(newConnection.route());
+
+    return newConnection;
+  }
+
+  public void streamFinished(boolean noNewStreams, HttpStream stream) {
+    synchronized (connectionPool) {
+      if (stream == null || stream != this.stream) {
+        throw new IllegalStateException("expected " + this.stream + " but was " + stream);
+      }
+      if (!noNewStreams) {
+        connection.successCount++;
+      }
+    }
+    deallocate(noNewStreams, false, true);
+  }
+
+  public HttpStream stream() {
+    synchronized (connectionPool) {
+      return stream;
+    }
+  }
+
+  private RouteDatabase routeDatabase() {
+    return Internal.instance.routeDatabase(connectionPool);
+  }
+
+  public synchronized RealConnection connection() {
+    return connection;
+  }
+
+  public void release() {
+    deallocate(false, true, false);
+  }
+
+  /** Forbid new streams from being created on the connection that hosts this allocation. */
+  public void noNewStreams() {
+    deallocate(true, false, false);
+  }
+
+  /**
+   * Releases resources held by this allocation. If sufficient resources are allocated, the
+   * connection will be detached or closed.
+   */
+  private void deallocate(boolean noNewStreams, boolean released, boolean streamFinished) {
+    RealConnection connectionToClose = null;
+    synchronized (connectionPool) {
+      if (streamFinished) {
+        this.stream = null;
+      }
+      if (released) {
+        this.released = true;
+      }
+      if (connection != null) {
+        if (noNewStreams) {
+          connection.noNewStreams = true;
+        }
+        if (this.stream == null && (this.released || connection.noNewStreams)) {
+          release(connection);
+          if (connection.allocations.isEmpty()) {
+            connection.idleAtNanos = System.nanoTime();
+            if (Internal.instance.connectionBecameIdle(connectionPool, connection)) {
+              connectionToClose = connection;
+            }
+          }
+          connection = null;
+        }
+      }
+    }
+    if (connectionToClose != null) {
+      Util.closeQuietly(connectionToClose.socket());
+    }
+  }
+
+  public void cancel() {
+    HttpStream streamToCancel;
+    RealConnection connectionToCancel;
+    synchronized (connectionPool) {
+      canceled = true;
+      streamToCancel = stream;
+      connectionToCancel = connection;
+    }
+    if (streamToCancel != null) {
+      streamToCancel.cancel();
+    } else if (connectionToCancel != null) {
+      connectionToCancel.cancel();
+    }
+  }
+
+  public void streamFailed(IOException e) {
+    boolean noNewStreams = false;
+
+    synchronized (connectionPool) {
+      if (e instanceof StreamResetException) {
+        StreamResetException streamResetException = (StreamResetException) e;
+        if (streamResetException.errorCode == ErrorCode.REFUSED_STREAM) {
+          refusedStreamCount++;
+        }
+        // On HTTP/2 stream errors, retry REFUSED_STREAM errors once on the same connection. All
+        // other errors must be retried on a new connection.
+        if (streamResetException.errorCode != ErrorCode.REFUSED_STREAM || refusedStreamCount > 1) {
+          noNewStreams = true;
+          route = null;
+        }
+      } else if (connection != null && !connection.isMultiplexed()) {
+        noNewStreams = true;
+
+        // If this route hasn't completed a call, avoid it for new connections.
+        if (connection.successCount == 0) {
+          if (route != null && e != null) {
+            routeSelector.connectFailed(route, e);
+          }
+          route = null;
+        }
+      }
+    }
+
+    deallocate(noNewStreams, false, true);
+  }
+
+  /**
+   * Use this allocation to hold {@code connection}. Each call to this must be paired with a call to
+   * {@link #release} on the same connection.
+   */
+  public void acquire(RealConnection connection) {
+    connection.allocations.add(new WeakReference<>(this));
+  }
+
+  /** Remove this allocation from the connection's list of allocations. */
+  private void release(RealConnection connection) {
+    for (int i = 0, size = connection.allocations.size(); i < size; i++) {
+      Reference<StreamAllocation> reference = connection.allocations.get(i);
+      if (reference.get() == this) {
+        connection.allocations.remove(i);
+        return;
+      }
+    }
+    throw new IllegalStateException();
+  }
+
+  public boolean hasMoreRoutes() {
+    return route != null || routeSelector.hasNext();
+  }
+
+  @Override public String toString() {
+    return address.toString();
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/UnrepeatableRequestBody.java b/okhttp/src/main/java/okhttp3/internal/http/UnrepeatableRequestBody.java
new file mode 100644
index 0000000000..60b893fbf3
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http/UnrepeatableRequestBody.java
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http;
+
+public interface UnrepeatableRequestBody {
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/io/FileSystem.java b/okhttp/src/main/java/okhttp3/internal/io/FileSystem.java
similarity index 93%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/io/FileSystem.java
rename to okhttp/src/main/java/okhttp3/internal/io/FileSystem.java
index 74245997a5..0b1b1cfbc4 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/io/FileSystem.java
+++ b/okhttp/src/main/java/okhttp3/internal/io/FileSystem.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.io;
+package okhttp3.internal.io;
 
 import java.io.File;
 import java.io.FileNotFoundException;
@@ -28,9 +28,9 @@
  * implementations may be used to inject faults (for testing) or to transform stored data (to add
  * encryption, for example).
  *
- * <p>All operations on a file system are racy. For example, guarding a call to {@link #source}
- * with {@link #exists} does not guarantee that {@link FileNotFoundException} will not be thrown.
- * The file may be moved between the two calls!
+ * <p>All operations on a file system are racy. For example, guarding a call to {@link #source} with
+ * {@link #exists} does not guarantee that {@link FileNotFoundException} will not be thrown. The
+ * file may be moved between the two calls!
  *
  * <p>This interface is less ambitious than {@link java.nio.file.FileSystem} introduced in Java 7.
  * It lacks important features like file watching, metadata, permissions, and disk space
@@ -71,7 +71,7 @@
       }
     }
 
-    @Override public boolean exists(File file) throws IOException {
+    @Override public boolean exists(File file) {
       return file.exists();
     }
 
@@ -121,7 +121,7 @@
   void delete(File file) throws IOException;
 
   /** Returns true if {@code file} exists on the file system. */
-  boolean exists(File file) throws IOException;
+  boolean exists(File file);
 
   /** Returns the number of bytes stored in {@code file}, or 0 if it does not exist. */
   long size(File file);
diff --git a/okhttp/src/main/java/okhttp3/internal/io/Pipe.java b/okhttp/src/main/java/okhttp3/internal/io/Pipe.java
new file mode 100644
index 0000000000..82ba9048ad
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/io/Pipe.java
@@ -0,0 +1,182 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.io;
+
+import java.io.IOException;
+import java.net.SocketTimeoutException;
+import okio.Buffer;
+import okio.Sink;
+import okio.Source;
+import okio.Timeout;
+
+/**
+ * A source and a sink that are attached. The sink's output is the source's input. Typically each
+ * is accessed by its own thread: a producer thread writes data to the sink and a consumer thread
+ * reads data from the source.
+ *
+ * <p>This class uses a buffer to decouple source and sink. This buffer has a user-specified maximum
+ * size. When a producer thread outruns its consumer the buffer fills up and eventually writes to
+ * the sink will block until the consumer has caught up. Symmetrically, if a consumer outruns its
+ * producer reads block until there is data to be read. Limits on the amount of time spent waiting
+ * for the other party can be configured with {@linkplain Timeout timeouts} on the source and the
+ * sink.
+ *
+ * <p>When the sink is closed, source reads will continue to complete normally until the buffer has
+ * been exhausted. At that point reads will return -1, indicating the end of the stream. But if the
+ * source is closed first, writes to the sink will immediately fail with an {@link IOException}.
+ */
+public final class Pipe {
+  final long maxBufferSize;
+  final Buffer buffer = new Buffer();
+  boolean sinkClosed;
+  boolean sourceClosed;
+  public final Sink sink = new PipeSink();
+  public final Source source = new PipeSource();
+
+  public Pipe(long maxBufferSize) {
+    if (maxBufferSize < 1L) {
+      throw new IllegalArgumentException("maxBufferSize < 1: " + maxBufferSize);
+    }
+    this.maxBufferSize = maxBufferSize;
+  }
+
+  final class PipeSink implements Sink {
+    final Timeout timeout = new Timeout();
+
+    @Override public void write(Buffer source, long byteCount) throws IOException {
+      synchronized (buffer) {
+        if (sinkClosed) throw new IllegalStateException("closed");
+
+        while (byteCount > 0) {
+          if (sourceClosed) throw new IOException("source is closed");
+
+          long bufferSpaceAvailable = maxBufferSize - buffer.size();
+          if (bufferSpaceAvailable == 0) {
+            waitUntilNotified(buffer, timeout); // Wait until the source drains the buffer.
+            continue;
+          }
+
+          long bytesToWrite = Math.min(bufferSpaceAvailable, byteCount);
+          buffer.write(source, bytesToWrite);
+          byteCount -= bytesToWrite;
+          buffer.notifyAll(); // Notify the source that it can resume reading.
+        }
+      }
+    }
+
+    @Override public void flush() throws IOException {
+      synchronized (buffer) {
+        if (sinkClosed) throw new IllegalStateException("closed");
+
+        while (buffer.size() > 0) {
+          if (sourceClosed) throw new IOException("source is closed");
+          waitUntilNotified(buffer, timeout);
+        }
+      }
+    }
+
+    @Override public void close() throws IOException {
+      synchronized (buffer) {
+        if (sinkClosed) return;
+        try {
+          flush();
+        } finally {
+          sinkClosed = true;
+          buffer.notifyAll(); // Notify the source that no more bytes are coming.
+        }
+      }
+    }
+
+    @Override public Timeout timeout() {
+      return timeout;
+    }
+  }
+
+  final class PipeSource implements Source {
+    final Timeout timeout = new Timeout();
+
+    @Override public long read(Buffer sink, long byteCount) throws IOException {
+      synchronized (buffer) {
+        if (sourceClosed) throw new IllegalStateException("closed");
+
+        while (buffer.size() == 0) {
+          if (sinkClosed) return -1L;
+          waitUntilNotified(buffer, timeout); // Wait until the sink fills the buffer.
+        }
+
+        long result = buffer.read(sink, byteCount);
+        buffer.notifyAll(); // Notify the sink that it can resume writing.
+        return result;
+      }
+    }
+
+    @Override public void close() throws IOException {
+      synchronized (buffer) {
+        sourceClosed = true;
+        buffer.notifyAll(); // Notify the sink that no more bytes are desired.
+      }
+    }
+
+    @Override public Timeout timeout() {
+      return timeout;
+    }
+  }
+
+  /**
+   * Waits on {@code monitor} until it is notified. Throws {@link SocketTimeoutException} if either
+   * the thread is interrupted or if {@code timeout} elapses before {@code monitor} is notified. The
+   * caller must be synchronized on {@code monitor}.
+   */
+  static void waitUntilNotified(Object monitor, Timeout timeout) throws IOException {
+    try {
+      boolean hasDeadline = timeout.hasDeadline();
+      long timeoutNanos = timeout.timeoutNanos();
+
+      if (!hasDeadline && timeoutNanos == 0L) {
+        monitor.wait(); // There is no timeout: wait forever.
+        return;
+      }
+
+      // Compute how long we'll wait.
+      long waitNanos;
+      long start = System.nanoTime();
+      if (hasDeadline && timeoutNanos != 0) {
+        long deadlineNanos = timeout.deadlineNanoTime() - start;
+        waitNanos = Math.min(timeoutNanos, deadlineNanos);
+      } else if (hasDeadline) {
+        waitNanos = timeout.deadlineNanoTime() - start;
+      } else {
+        waitNanos = timeoutNanos;
+      }
+
+      // Attempt to wait that long. This will break out early if the monitor is notified.
+      long elapsedNanos = 0L;
+      if (waitNanos > 0L) {
+        long waitMillis = waitNanos / 1000000L;
+        monitor.wait(waitMillis, (int) (waitNanos - waitMillis * 1000000L));
+        elapsedNanos = System.nanoTime() - start;
+      }
+
+      // Throw if the timeout elapsed before the monitor was notified.
+      if (elapsedNanos >= waitNanos) {
+        throw new SocketTimeoutException("timeout");
+      }
+    } catch (InterruptedException e) {
+      throw new SocketTimeoutException("interrupted");
+    }
+  }
+}
+
diff --git a/okhttp/src/main/java/okhttp3/internal/io/RealConnection.java b/okhttp/src/main/java/okhttp3/internal/io/RealConnection.java
new file mode 100644
index 0000000000..ef6e8f84d9
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/io/RealConnection.java
@@ -0,0 +1,439 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package okhttp3.internal.io;
+
+import java.io.IOException;
+import java.lang.ref.Reference;
+import java.net.ConnectException;
+import java.net.ProtocolException;
+import java.net.Proxy;
+import java.net.Socket;
+import java.net.SocketTimeoutException;
+import java.net.UnknownServiceException;
+import java.security.cert.X509Certificate;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import javax.net.ssl.SSLSocket;
+import javax.net.ssl.SSLSocketFactory;
+import okhttp3.Address;
+import okhttp3.CertificatePinner;
+import okhttp3.Connection;
+import okhttp3.ConnectionSpec;
+import okhttp3.Handshake;
+import okhttp3.HttpUrl;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.Route;
+import okhttp3.internal.ConnectionSpecSelector;
+import okhttp3.internal.Platform;
+import okhttp3.internal.Util;
+import okhttp3.internal.Version;
+import okhttp3.internal.framed.ErrorCode;
+import okhttp3.internal.framed.FramedConnection;
+import okhttp3.internal.framed.FramedStream;
+import okhttp3.internal.http.Http1xStream;
+import okhttp3.internal.http.OkHeaders;
+import okhttp3.internal.http.RouteException;
+import okhttp3.internal.http.StreamAllocation;
+import okhttp3.internal.tls.OkHostnameVerifier;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.Okio;
+import okio.Source;
+
+import static java.net.HttpURLConnection.HTTP_OK;
+import static java.net.HttpURLConnection.HTTP_PROXY_AUTH;
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static okhttp3.internal.Util.closeQuietly;
+
+public final class RealConnection extends FramedConnection.Listener implements Connection {
+  private final Route route;
+
+  /** The low-level TCP socket. */
+  private Socket rawSocket;
+
+  /**
+   * The application layer socket. Either an {@link SSLSocket} layered over {@link #rawSocket}, or
+   * {@link #rawSocket} itself if this connection does not use SSL.
+   */
+  public Socket socket;
+  private Handshake handshake;
+  private Protocol protocol;
+  public volatile FramedConnection framedConnection;
+  public int successCount;
+  public BufferedSource source;
+  public BufferedSink sink;
+  public int allocationLimit;
+  public final List<Reference<StreamAllocation>> allocations = new ArrayList<>();
+  public boolean noNewStreams;
+  public long idleAtNanos = Long.MAX_VALUE;
+
+  public RealConnection(Route route) {
+    this.route = route;
+  }
+
+  public void connect(int connectTimeout, int readTimeout, int writeTimeout,
+      List<ConnectionSpec> connectionSpecs, boolean connectionRetryEnabled) throws RouteException {
+    if (protocol != null) throw new IllegalStateException("already connected");
+
+    RouteException routeException = null;
+    ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);
+
+    if (route.address().sslSocketFactory() == null
+        && !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {
+      throw new RouteException(new UnknownServiceException(
+          "CLEARTEXT communication not supported: " + connectionSpecs));
+    }
+
+    while (protocol == null) {
+      try {
+        if (route.requiresTunnel()) {
+          buildTunneledConnection(connectTimeout, readTimeout, writeTimeout,
+              connectionSpecSelector);
+        } else {
+          buildConnection(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);
+        }
+      } catch (IOException e) {
+        closeQuietly(socket);
+        closeQuietly(rawSocket);
+        socket = null;
+        rawSocket = null;
+        source = null;
+        sink = null;
+        handshake = null;
+        protocol = null;
+
+        if (routeException == null) {
+          routeException = new RouteException(e);
+        } else {
+          routeException.addConnectException(e);
+        }
+
+        if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {
+          throw routeException;
+        }
+      }
+    }
+  }
+
+  /**
+   * Does all the work to build an HTTPS connection over a proxy tunnel. The catch here is that a
+   * proxy server can issue an auth challenge and then close the connection.
+   */
+  private void buildTunneledConnection(int connectTimeout, int readTimeout, int writeTimeout,
+      ConnectionSpecSelector connectionSpecSelector) throws IOException {
+    Request tunnelRequest = createTunnelRequest();
+    HttpUrl url = tunnelRequest.url();
+    int attemptedConnections = 0;
+    int maxAttempts = 21;
+    while (true) {
+      if (++attemptedConnections > maxAttempts) {
+        throw new ProtocolException("Too many tunnel connections attempted: " + maxAttempts);
+      }
+
+      connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);
+      tunnelRequest = createTunnel(readTimeout, writeTimeout, tunnelRequest, url);
+
+      if (tunnelRequest == null) break; // Tunnel successfully created.
+
+      // The proxy decided to close the connection after an auth challenge. We need to create a new
+      // connection, but this time with the auth credentials.
+      closeQuietly(rawSocket);
+      rawSocket = null;
+      sink = null;
+      source = null;
+    }
+
+    establishProtocol(readTimeout, writeTimeout, connectionSpecSelector);
+  }
+
+  /** Does all the work necessary to build a full HTTP or HTTPS connection on a raw socket. */
+  private void buildConnection(int connectTimeout, int readTimeout, int writeTimeout,
+      ConnectionSpecSelector connectionSpecSelector) throws IOException {
+    connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);
+    establishProtocol(readTimeout, writeTimeout, connectionSpecSelector);
+  }
+
+  private void connectSocket(int connectTimeout, int readTimeout, int writeTimeout,
+      ConnectionSpecSelector connectionSpecSelector) throws IOException {
+    Proxy proxy = route.proxy();
+    Address address = route.address();
+
+    rawSocket = proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP
+        ? address.socketFactory().createSocket()
+        : new Socket(proxy);
+
+    rawSocket.setSoTimeout(readTimeout);
+    try {
+      Platform.get().connectSocket(rawSocket, route.socketAddress(), connectTimeout);
+    } catch (ConnectException e) {
+      throw new ConnectException("Failed to connect to " + route.socketAddress());
+    }
+    source = Okio.buffer(Okio.source(rawSocket));
+    sink = Okio.buffer(Okio.sink(rawSocket));
+  }
+
+  private void establishProtocol(int readTimeout, int writeTimeout,
+      ConnectionSpecSelector connectionSpecSelector) throws IOException {
+    if (route.address().sslSocketFactory() != null) {
+      connectTls(readTimeout, writeTimeout, connectionSpecSelector);
+    } else {
+      protocol = Protocol.HTTP_1_1;
+      socket = rawSocket;
+    }
+
+    if (protocol == Protocol.SPDY_3 || protocol == Protocol.HTTP_2) {
+      socket.setSoTimeout(0); // Framed connection timeouts are set per-stream.
+
+      FramedConnection framedConnection = new FramedConnection.Builder(true)
+          .socket(socket, route.address().url().host(), source, sink)
+          .protocol(protocol)
+          .listener(this)
+          .build();
+      framedConnection.start();
+
+      // Only assign the framed connection once the preface has been sent successfully.
+      this.allocationLimit = framedConnection.maxConcurrentStreams();
+      this.framedConnection = framedConnection;
+    } else {
+      this.allocationLimit = 1;
+    }
+  }
+
+  private void connectTls(int readTimeout, int writeTimeout,
+      ConnectionSpecSelector connectionSpecSelector) throws IOException {
+    Address address = route.address();
+    SSLSocketFactory sslSocketFactory = address.sslSocketFactory();
+    boolean success = false;
+    SSLSocket sslSocket = null;
+    try {
+      // Create the wrapper over the connected socket.
+      sslSocket = (SSLSocket) sslSocketFactory.createSocket(
+          rawSocket, address.url().host(), address.url().port(), true /* autoClose */);
+
+      // Configure the socket's ciphers, TLS versions, and extensions.
+      ConnectionSpec connectionSpec = connectionSpecSelector.configureSecureSocket(sslSocket);
+      if (connectionSpec.supportsTlsExtensions()) {
+        Platform.get().configureTlsExtensions(
+            sslSocket, address.url().host(), address.protocols());
+      }
+
+      // Force handshake. This can throw!
+      sslSocket.startHandshake();
+      Handshake unverifiedHandshake = Handshake.get(sslSocket.getSession());
+
+      // Verify that the socket's certificates are acceptable for the target host.
+      if (!address.hostnameVerifier().verify(address.url().host(), sslSocket.getSession())) {
+        X509Certificate cert = (X509Certificate) unverifiedHandshake.peerCertificates().get(0);
+        throw new SSLPeerUnverifiedException("Hostname " + address.url().host() + " not verified:"
+            + "\n    certificate: " + CertificatePinner.pin(cert)
+            + "\n    DN: " + cert.getSubjectDN().getName()
+            + "\n    subjectAltNames: " + OkHostnameVerifier.allSubjectAltNames(cert));
+      }
+
+      // Check that the certificate pinner is satisfied by the certificates presented.
+      address.certificatePinner().check(address.url().host(),
+          unverifiedHandshake.peerCertificates());
+
+      // Success! Save the handshake and the ALPN protocol.
+      String maybeProtocol = connectionSpec.supportsTlsExtensions()
+          ? Platform.get().getSelectedProtocol(sslSocket)
+          : null;
+      socket = sslSocket;
+      source = Okio.buffer(Okio.source(socket));
+      sink = Okio.buffer(Okio.sink(socket));
+      handshake = unverifiedHandshake;
+      protocol = maybeProtocol != null
+          ? Protocol.get(maybeProtocol)
+          : Protocol.HTTP_1_1;
+      success = true;
+    } catch (AssertionError e) {
+      if (Util.isAndroidGetsocknameError(e)) throw new IOException(e);
+      throw e;
+    } finally {
+      if (sslSocket != null) {
+        Platform.get().afterHandshake(sslSocket);
+      }
+      if (!success) {
+        closeQuietly(sslSocket);
+      }
+    }
+  }
+
+  /**
+   * To make an HTTPS connection over an HTTP proxy, send an unencrypted CONNECT request to create
+   * the proxy connection. This may need to be retried if the proxy requires authorization.
+   */
+  private Request createTunnel(int readTimeout, int writeTimeout, Request tunnelRequest,
+      HttpUrl url) throws IOException {
+    // Make an SSL Tunnel on the first message pair of each SSL + proxy connection.
+    String requestLine = "CONNECT " + Util.hostHeader(url, true) + " HTTP/1.1";
+    while (true) {
+      Http1xStream tunnelConnection = new Http1xStream(null, source, sink);
+      source.timeout().timeout(readTimeout, MILLISECONDS);
+      sink.timeout().timeout(writeTimeout, MILLISECONDS);
+      tunnelConnection.writeRequest(tunnelRequest.headers(), requestLine);
+      tunnelConnection.finishRequest();
+      Response response = tunnelConnection.readResponse().request(tunnelRequest).build();
+      // The response body from a CONNECT should be empty, but if it is not then we should consume
+      // it before proceeding.
+      long contentLength = OkHeaders.contentLength(response);
+      if (contentLength == -1L) {
+        contentLength = 0L;
+      }
+      Source body = tunnelConnection.newFixedLengthSource(contentLength);
+      Util.skipAll(body, Integer.MAX_VALUE, TimeUnit.MILLISECONDS);
+      body.close();
+
+      switch (response.code()) {
+        case HTTP_OK:
+          // Assume the server won't send a TLS ServerHello until we send a TLS ClientHello. If
+          // that happens, then we will have buffered bytes that are needed by the SSLSocket!
+          // This check is imperfect: it doesn't tell us whether a handshake will succeed, just
+          // that it will almost certainly fail because the proxy has sent unexpected data.
+          if (!source.buffer().exhausted() || !sink.buffer().exhausted()) {
+            throw new IOException("TLS tunnel buffered too many bytes!");
+          }
+          return null;
+
+        case HTTP_PROXY_AUTH:
+          tunnelRequest = route.address().proxyAuthenticator().authenticate(route, response);
+          if (tunnelRequest == null) throw new IOException("Failed to authenticate with proxy");
+
+          if ("close".equalsIgnoreCase(response.header("Connection"))) {
+            return tunnelRequest;
+          }
+          break;
+
+        default:
+          throw new IOException(
+              "Unexpected response code for CONNECT: " + response.code());
+      }
+    }
+  }
+
+  /**
+   * Returns a request that creates a TLS tunnel via an HTTP proxy. Everything in the tunnel request
+   * is sent unencrypted to the proxy server, so tunnels include only the minimum set of headers.
+   * This avoids sending potentially sensitive data like HTTP cookies to the proxy unencrypted.
+   */
+  private Request createTunnelRequest() throws IOException {
+    return new Request.Builder()
+        .url(route.address().url())
+        .header("Host", Util.hostHeader(route.address().url(), true))
+        .header("Proxy-Connection", "Keep-Alive")
+        .header("User-Agent", Version.userAgent()) // For HTTP/1.0 proxies like Squid.
+        .build();
+  }
+
+  /** Returns true if {@link #connect} has been attempted on this connection. */
+  boolean isConnected() {
+    return protocol != null;
+  }
+
+  @Override public Route route() {
+    return route;
+  }
+
+  public void cancel() {
+    // Close the raw socket so we don't end up doing synchronous I/O.
+    closeQuietly(rawSocket);
+  }
+
+  @Override public Socket socket() {
+    return socket;
+  }
+
+  /** Returns true if this connection is ready to host new streams. */
+  public boolean isHealthy(boolean doExtensiveChecks) {
+    if (socket.isClosed() || socket.isInputShutdown() || socket.isOutputShutdown()) {
+      return false;
+    }
+
+    if (framedConnection != null) {
+      return true; // TODO: check framedConnection.shutdown.
+    }
+
+    if (doExtensiveChecks) {
+      try {
+        int readTimeout = socket.getSoTimeout();
+        try {
+          socket.setSoTimeout(1);
+          if (source.exhausted()) {
+            return false; // Stream is exhausted; socket is closed.
+          }
+          return true;
+        } finally {
+          socket.setSoTimeout(readTimeout);
+        }
+      } catch (SocketTimeoutException ignored) {
+        // Read timed out; socket is good.
+      } catch (IOException e) {
+        return false; // Couldn't read; socket is closed.
+      }
+    }
+
+    return true;
+  }
+
+  /** Refuse incoming streams. */
+  @Override public void onStream(FramedStream stream) throws IOException {
+    stream.close(ErrorCode.REFUSED_STREAM);
+  }
+
+  /** When settings are received, adjust the allocation limit. */
+  @Override public void onSettings(FramedConnection connection) {
+    allocationLimit = connection.maxConcurrentStreams();
+  }
+
+  @Override public Handshake handshake() {
+    return handshake;
+  }
+
+  /**
+   * Returns true if this is a SPDY connection. Such connections can be used in multiple HTTP
+   * requests simultaneously.
+   */
+  public boolean isMultiplexed() {
+    return framedConnection != null;
+  }
+
+  @Override public Protocol protocol() {
+    if (framedConnection == null) {
+      return protocol != null ? protocol : Protocol.HTTP_1_1;
+    } else {
+      return framedConnection.getProtocol();
+    }
+  }
+
+  @Override public String toString() {
+    return "Connection{"
+        + route.address().url().host() + ":" + route.address().url().port()
+        + ", proxy="
+        + route.proxy()
+        + " hostAddress="
+        + route.socketAddress()
+        + " cipherSuite="
+        + (handshake != null ? handshake.cipherSuite() : "none")
+        + " protocol="
+        + protocol
+        + '}';
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/tls/BasicCertificateChainCleaner.java b/okhttp/src/main/java/okhttp3/internal/tls/BasicCertificateChainCleaner.java
new file mode 100644
index 0000000000..be8cab093d
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/tls/BasicCertificateChainCleaner.java
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.tls;
+
+import java.security.GeneralSecurityException;
+import java.security.cert.Certificate;
+import java.security.cert.X509Certificate;
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Deque;
+import java.util.Iterator;
+import java.util.List;
+import javax.net.ssl.SSLPeerUnverifiedException;
+
+/**
+ * A certificate chain cleaner that uses a set of trusted root certificates to build the trusted
+ * chain. This class duplicates the clean chain building performed during the TLS handshake. We
+ * prefer other mechanisms where they exist, such as with
+ * {@link okhttp3.internal.AndroidPlatform.AndroidCertificateChainCleaner}.
+ *
+ * <p>This class includes code from <a href="https://conscrypt.org/">Conscrypt's</a> {@code
+ * TrustManagerImpl} and {@code TrustedCertificateIndex}.
+ */
+public final class BasicCertificateChainCleaner extends CertificateChainCleaner {
+  /** The maximum number of signers in a chain. We use 9 for consistency with OpenSSL. */
+  private static final int MAX_SIGNERS = 9;
+
+  private final TrustRootIndex trustRootIndex;
+
+  public BasicCertificateChainCleaner(TrustRootIndex trustRootIndex) {
+    this.trustRootIndex = trustRootIndex;
+  }
+
+  /**
+   * Returns a cleaned chain for {@code chain}.
+   *
+   * <p>This method throws if the complete chain to a trusted CA certificate cannot be constructed.
+   * This is unexpected unless the trust root index in this class has a different trust manager than
+   * what was used to establish {@code chain}.
+   */
+  @Override public List<Certificate> clean(List<Certificate> chain, String hostname)
+      throws SSLPeerUnverifiedException {
+    Deque<Certificate> queue = new ArrayDeque<>(chain);
+    List<Certificate> result = new ArrayList<>();
+    result.add(queue.removeFirst());
+    boolean foundTrustedCertificate = false;
+
+    followIssuerChain:
+    for (int c = 0; c < MAX_SIGNERS; c++) {
+      X509Certificate toVerify = (X509Certificate) result.get(result.size() - 1);
+
+      // If this cert has been signed by a trusted cert, use that. Add the trusted certificate to
+      // the end of the chain unless it's already present. (That would happen if the first
+      // certificate in the chain is itself a self-signed and trusted CA certificate.)
+      X509Certificate trustedCert = trustRootIndex.findByIssuerAndSignature(toVerify);
+      if (trustedCert != null) {
+        if (result.size() > 1 || !toVerify.equals(trustedCert)) {
+          result.add(trustedCert);
+        }
+        if (verifySignature(trustedCert, trustedCert)) {
+          return result; // The self-signed cert is a root CA. We're done.
+        }
+        foundTrustedCertificate = true;
+        continue;
+      }
+
+      // Search for the certificate in the chain that signed this certificate. This is typically
+      // the next element in the chain, but it could be any element.
+      for (Iterator<Certificate> i = queue.iterator(); i.hasNext(); ) {
+        X509Certificate signingCert = (X509Certificate) i.next();
+        if (verifySignature(toVerify, signingCert)) {
+          i.remove();
+          result.add(signingCert);
+          continue followIssuerChain;
+        }
+      }
+
+      // We've reached the end of the chain. If any cert in the chain is trusted, we're done.
+      if (foundTrustedCertificate) {
+        return result;
+      }
+
+      // The last link isn't trusted. Fail.
+      throw new SSLPeerUnverifiedException(
+          "Failed to find a trusted cert that signed " + toVerify);
+    }
+
+    throw new SSLPeerUnverifiedException("Certificate chain too long: " + result);
+  }
+
+  /** Returns true if {@code toVerify} was signed by {@code signingCert}'s public key. */
+  private boolean verifySignature(X509Certificate toVerify, X509Certificate signingCert) {
+    if (!toVerify.getIssuerDN().equals(signingCert.getSubjectDN())) return false;
+    try {
+      toVerify.verify(signingCert.getPublicKey());
+      return true;
+    } catch (GeneralSecurityException verifyFailed) {
+      return false;
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/tls/CertificateChainCleaner.java b/okhttp/src/main/java/okhttp3/internal/tls/CertificateChainCleaner.java
new file mode 100644
index 0000000000..9b7c2e2a36
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/tls/CertificateChainCleaner.java
@@ -0,0 +1,47 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package okhttp3.internal.tls;
+
+import java.security.cert.Certificate;
+import java.security.cert.X509Certificate;
+import java.util.List;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import javax.net.ssl.X509TrustManager;
+import okhttp3.internal.Platform;
+
+/**
+ * Computes the effective certificate chain from the raw array returned by Java's built in TLS APIs.
+ * Cleaning a chain returns a list of certificates where the first element is {@code chain[0]}, each
+ * certificate is signed by the certificate that follows, and the last certificate is a trusted CA
+ * certificate.
+ *
+ * <p>Use of the chain cleaner is necessary to omit unexpected certificates that aren't relevant to
+ * the TLS handshake and to extract the trusted CA certificate for the benefit of certificate
+ * pinning.
+ */
+public abstract class CertificateChainCleaner {
+  public abstract List<Certificate> clean(List<Certificate> chain, String hostname)
+      throws SSLPeerUnverifiedException;
+
+  public static CertificateChainCleaner get(X509TrustManager trustManager) {
+    return Platform.get().buildCertificateChainCleaner(trustManager);
+  }
+
+  public static CertificateChainCleaner get(X509Certificate... caCerts) {
+    return new BasicCertificateChainCleaner(TrustRootIndex.get(caCerts));
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/tls/DistinguishedNameParser.java b/okhttp/src/main/java/okhttp3/internal/tls/DistinguishedNameParser.java
similarity index 98%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/tls/DistinguishedNameParser.java
rename to okhttp/src/main/java/okhttp3/internal/tls/DistinguishedNameParser.java
index e0aef14916..616bca534a 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/tls/DistinguishedNameParser.java
+++ b/okhttp/src/main/java/okhttp3/internal/tls/DistinguishedNameParser.java
@@ -14,14 +14,13 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-
-package com.squareup.okhttp.internal.tls;
+package okhttp3.internal.tls;
 
 import javax.security.auth.x500.X500Principal;
 
 /**
- * A distinguished name (DN) parser. This parser only supports extracting a
- * string value from a DN. It doesn't support values in the hex-string style.
+ * A distinguished name (DN) parser. This parser only supports extracting a string value from a DN.
+ * It doesn't support values in the hex-string style.
  */
 final class DistinguishedNameParser {
   private final String dn;
@@ -341,8 +340,8 @@ private int getByte(int position) {
   }
 
   /**
-   * Parses the DN and returns the most significant attribute value
-   * for an attribute type, or null if none found.
+   * Parses the DN and returns the most significant attribute value for an attribute type, or null
+   * if none found.
    *
    * @param attributeType attribute type to look for (e.g. "ca")
    */
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/tls/OkHostnameVerifier.java b/okhttp/src/main/java/okhttp3/internal/tls/OkHostnameVerifier.java
similarity index 71%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/tls/OkHostnameVerifier.java
rename to okhttp/src/main/java/okhttp3/internal/tls/OkHostnameVerifier.java
index 740de1bcdf..a85df784d7 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/tls/OkHostnameVerifier.java
+++ b/okhttp/src/main/java/okhttp3/internal/tls/OkHostnameVerifier.java
@@ -14,8 +14,7 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-
-package com.squareup.okhttp.internal.tls;
+package okhttp3.internal.tls;
 
 import java.security.cert.Certificate;
 import java.security.cert.CertificateParsingException;
@@ -25,33 +24,19 @@
 import java.util.Collections;
 import java.util.List;
 import java.util.Locale;
-import java.util.regex.Pattern;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLException;
 import javax.net.ssl.SSLSession;
 import javax.security.auth.x500.X500Principal;
 
+import static okhttp3.internal.Util.verifyAsIpAddress;
+
 /**
- * A HostnameVerifier consistent with <a
- * href="http://www.ietf.org/rfc/rfc2818.txt">RFC 2818</a>.
+ * A HostnameVerifier consistent with <a href="http://www.ietf.org/rfc/rfc2818.txt">RFC 2818</a>.
  */
 public final class OkHostnameVerifier implements HostnameVerifier {
   public static final OkHostnameVerifier INSTANCE = new OkHostnameVerifier();
 
-  /**
-   * Quick and dirty pattern to differentiate IP addresses from hostnames. This
-   * is an approximation of Android's private InetAddress#isNumeric API.
-   *
-   * <p>This matches IPv6 addresses as a hex string containing at least one
-   * colon, and possibly including dots after the first colon. It matches IPv4
-   * addresses as strings containing only decimal digits and dots. This pattern
-   * matches strings like "a:.23" and "54" that are neither IP addresses nor
-   * hostnames; they will be verified as IP addresses (which is a more strict
-   * verification).
-   */
-  private static final Pattern VERIFY_AS_IP_ADDRESS = Pattern.compile(
-      "([0-9a-fA-F]*:[0-9a-fA-F:.]*)|([\\d.]+)");
-
   private static final int ALT_DNS_NAME = 2;
   private static final int ALT_IPA_NAME = 7;
 
@@ -71,16 +56,10 @@ public boolean verify(String host, SSLSession session) {
   public boolean verify(String host, X509Certificate certificate) {
     return verifyAsIpAddress(host)
         ? verifyIpAddress(host, certificate)
-        : verifyHostName(host, certificate);
+        : verifyHostname(host, certificate);
   }
 
-  static boolean verifyAsIpAddress(String host) {
-    return VERIFY_AS_IP_ADDRESS.matcher(host).matches();
-  }
-
-  /**
-   * Returns true if {@code certificate} matches {@code ipAddress}.
-   */
+  /** Returns true if {@code certificate} matches {@code ipAddress}. */
   private boolean verifyIpAddress(String ipAddress, X509Certificate certificate) {
     List<String> altNames = getSubjectAltNames(certificate, ALT_IPA_NAME);
     for (int i = 0, size = altNames.size(); i < size; i++) {
@@ -91,16 +70,14 @@ private boolean verifyIpAddress(String ipAddress, X509Certificate certificate) {
     return false;
   }
 
-  /**
-   * Returns true if {@code certificate} matches {@code hostName}.
-   */
-  private boolean verifyHostName(String hostName, X509Certificate certificate) {
-    hostName = hostName.toLowerCase(Locale.US);
+  /** Returns true if {@code certificate} matches {@code hostname}. */
+  private boolean verifyHostname(String hostname, X509Certificate certificate) {
+    hostname = hostname.toLowerCase(Locale.US);
     boolean hasDns = false;
     List<String> altNames = getSubjectAltNames(certificate, ALT_DNS_NAME);
     for (int i = 0, size = altNames.size(); i < size; i++) {
       hasDns = true;
-      if (verifyHostName(hostName, altNames.get(i))) {
+      if (verifyHostname(hostname, altNames.get(i))) {
         return true;
       }
     }
@@ -110,7 +87,7 @@ private boolean verifyHostName(String hostName, X509Certificate certificate) {
       // RFC 2818 advises using the most specific name for matching.
       String cn = new DistinguishedNameParser(principal).findMostSpecific("cn");
       if (cn != null) {
-        return verifyHostName(hostName, cn);
+        return verifyHostname(hostname, cn);
       }
     }
 
@@ -156,17 +133,17 @@ private boolean verifyHostName(String hostName, X509Certificate certificate) {
   }
 
   /**
-   * Returns {@code true} iff {@code hostName} matches the domain name {@code pattern}.
+   * Returns {@code true} iff {@code hostname} matches the domain name {@code pattern}.
    *
-   * @param hostName lower-case host name.
-   * @param pattern domain name pattern from certificate. May be a wildcard pattern such as
-   *        {@code *.android.com}.
+   * @param hostname lower-case host name.
+   * @param pattern domain name pattern from certificate. May be a wildcard pattern such as {@code
+   * *.android.com}.
    */
-  private boolean verifyHostName(String hostName, String pattern) {
+  private boolean verifyHostname(String hostname, String pattern) {
     // Basic sanity checks
     // Check length == 0 instead of .isEmpty() to support Java 5.
-    if ((hostName == null) || (hostName.length() == 0) || (hostName.startsWith("."))
-        || (hostName.endsWith(".."))) {
+    if ((hostname == null) || (hostname.length() == 0) || (hostname.startsWith("."))
+        || (hostname.endsWith(".."))) {
       // Invalid domain name
       return false;
     }
@@ -176,29 +153,29 @@ private boolean verifyHostName(String hostName, String pattern) {
       return false;
     }
 
-    // Normalize hostName and pattern by turning them into absolute domain names if they are not
+    // Normalize hostname and pattern by turning them into absolute domain names if they are not
     // yet absolute. This is needed because server certificates do not normally contain absolute
-    // names or patterns, but they should be treated as absolute. At the same time, any hostName
+    // names or patterns, but they should be treated as absolute. At the same time, any hostname
     // presented to this method should also be treated as absolute for the purposes of matching
     // to the server certificate.
     //   www.android.com  matches www.android.com
     //   www.android.com  matches www.android.com.
     //   www.android.com. matches www.android.com.
     //   www.android.com. matches www.android.com
-    if (!hostName.endsWith(".")) {
-      hostName += '.';
+    if (!hostname.endsWith(".")) {
+      hostname += '.';
     }
     if (!pattern.endsWith(".")) {
       pattern += '.';
     }
-    // hostName and pattern are now absolute domain names.
+    // hostname and pattern are now absolute domain names.
 
     pattern = pattern.toLowerCase(Locale.US);
-    // hostName and pattern are now in lower case -- domain names are case-insensitive.
+    // hostname and pattern are now in lower case -- domain names are case-insensitive.
 
     if (!pattern.contains("*")) {
-      // Not a wildcard pattern -- hostName and pattern must match exactly.
-      return hostName.equals(pattern);
+      // Not a wildcard pattern -- hostname and pattern must match exactly.
+      return hostname.equals(pattern);
     }
     // Wildcard pattern
 
@@ -218,11 +195,11 @@ private boolean verifyHostName(String hostName, String pattern) {
       return false;
     }
 
-    // Optimization: check whether hostName is too short to match the pattern. hostName must be at
+    // Optimization: check whether hostname is too short to match the pattern. hostName must be at
     // least as long as the pattern because asterisk must match the whole left-most label and
-    // hostName starts with a non-empty label. Thus, asterisk has to match one or more characters.
-    if (hostName.length() < pattern.length()) {
-      // hostName too short to match the pattern.
+    // hostname starts with a non-empty label. Thus, asterisk has to match one or more characters.
+    if (hostname.length() < pattern.length()) {
+      // hostname too short to match the pattern.
       return false;
     }
 
@@ -231,22 +208,22 @@ private boolean verifyHostName(String hostName, String pattern) {
       return false;
     }
 
-    // hostName must end with the region of pattern following the asterisk.
+    // hostname must end with the region of pattern following the asterisk.
     String suffix = pattern.substring(1);
-    if (!hostName.endsWith(suffix)) {
-      // hostName does not end with the suffix
+    if (!hostname.endsWith(suffix)) {
+      // hostname does not end with the suffix
       return false;
     }
 
     // Check that asterisk did not match across domain name labels.
-    int suffixStartIndexInHostName = hostName.length() - suffix.length();
-    if ((suffixStartIndexInHostName > 0)
-        && (hostName.lastIndexOf('.', suffixStartIndexInHostName - 1) != -1)) {
+    int suffixStartIndexInHostname = hostname.length() - suffix.length();
+    if ((suffixStartIndexInHostname > 0)
+        && (hostname.lastIndexOf('.', suffixStartIndexInHostname - 1) != -1)) {
       // Asterisk is matching across domain name labels -- not permitted.
       return false;
     }
 
-    // hostName matches pattern
+    // hostname matches pattern
     return true;
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/tls/TrustRootIndex.java b/okhttp/src/main/java/okhttp3/internal/tls/TrustRootIndex.java
new file mode 100644
index 0000000000..8b5439b182
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/tls/TrustRootIndex.java
@@ -0,0 +1,118 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.tls;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.security.PublicKey;
+import java.security.cert.TrustAnchor;
+import java.security.cert.X509Certificate;
+import java.util.ArrayList;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import javax.net.ssl.X509TrustManager;
+import javax.security.auth.x500.X500Principal;
+
+public abstract class TrustRootIndex {
+  /** Returns the trusted CA certificate that signed {@code cert}. */
+  public abstract X509Certificate findByIssuerAndSignature(X509Certificate cert);
+
+  public static TrustRootIndex get(X509TrustManager trustManager) {
+    try {
+      // From org.conscrypt.TrustManagerImpl, we want the method with this signature:
+      // private TrustAnchor findTrustAnchorByIssuerAndSignature(X509Certificate lastCert);
+      Method method = trustManager.getClass().getDeclaredMethod(
+          "findTrustAnchorByIssuerAndSignature", X509Certificate.class);
+      method.setAccessible(true);
+      return new AndroidTrustRootIndex(trustManager, method);
+    } catch (NoSuchMethodException e) {
+      return get(trustManager.getAcceptedIssuers());
+    }
+  }
+
+  public static TrustRootIndex get(X509Certificate... caCerts) {
+    return new BasicTrustRootIndex(caCerts);
+  }
+
+  /**
+   * An index of trusted root certificates that exploits knowledge of Android implementation
+   * details. This class is potentially much faster to initialize than {@link BasicTrustRootIndex}
+   * because it doesn't need to load and index trusted CA certificates.
+   *
+   * <p>This class uses APIs added to Android in API 14 (Android 4.0, released October 2011). This
+   * class shouldn't be used in Android API 17 or better because those releases are better served by
+   * {@link okhttp3.internal.AndroidPlatform.AndroidCertificateChainCleaner}.
+   */
+  static final class AndroidTrustRootIndex extends TrustRootIndex {
+    private final X509TrustManager trustManager;
+    private final Method findByIssuerAndSignatureMethod;
+
+    AndroidTrustRootIndex(X509TrustManager trustManager, Method findByIssuerAndSignatureMethod) {
+      this.findByIssuerAndSignatureMethod = findByIssuerAndSignatureMethod;
+      this.trustManager = trustManager;
+    }
+
+    @Override public X509Certificate findByIssuerAndSignature(X509Certificate cert) {
+      try {
+        TrustAnchor trustAnchor = (TrustAnchor) findByIssuerAndSignatureMethod.invoke(
+            trustManager, cert);
+        return trustAnchor != null
+            ? trustAnchor.getTrustedCert()
+            : null;
+      } catch (IllegalAccessException e) {
+        throw new AssertionError();
+      } catch (InvocationTargetException e) {
+        return null;
+      }
+    }
+  }
+
+  /** A simple index that of trusted root certificates that have been loaded into memory. */
+  static final class BasicTrustRootIndex extends TrustRootIndex {
+    private final Map<X500Principal, List<X509Certificate>> subjectToCaCerts;
+
+    public BasicTrustRootIndex(X509Certificate... caCerts) {
+      subjectToCaCerts = new LinkedHashMap<>();
+      for (X509Certificate caCert : caCerts) {
+        X500Principal subject = caCert.getSubjectX500Principal();
+        List<X509Certificate> subjectCaCerts = subjectToCaCerts.get(subject);
+        if (subjectCaCerts == null) {
+          subjectCaCerts = new ArrayList<>(1);
+          subjectToCaCerts.put(subject, subjectCaCerts);
+        }
+        subjectCaCerts.add(caCert);
+      }
+    }
+
+    @Override public X509Certificate findByIssuerAndSignature(X509Certificate cert) {
+      X500Principal issuer = cert.getIssuerX500Principal();
+      List<X509Certificate> subjectCaCerts = subjectToCaCerts.get(issuer);
+      if (subjectCaCerts == null) return null;
+
+      for (X509Certificate caCert : subjectCaCerts) {
+        PublicKey publicKey = caCert.getPublicKey();
+        try {
+          cert.verify(publicKey);
+          return caCert;
+        } catch (Exception ignored) {
+        }
+      }
+
+      return null;
+    }
+  }
+}
diff --git a/pom.xml b/pom.xml
index 60c4f01a2c..9d60a40ff0 100644
--- a/pom.xml
+++ b/pom.xml
@@ -9,9 +9,9 @@
     <version>7</version>
   </parent>
 
-  <groupId>com.squareup.okhttp</groupId>
+  <groupId>com.squareup.okhttp3</groupId>
   <artifactId>parent</artifactId>
-  <version>2.4.0-SNAPSHOT</version>
+  <version>3.4.0-SNAPSHOT</version>
   <packaging>pom</packaging>
 
   <name>OkHttp (Parent)</name>
@@ -25,11 +25,14 @@
     <module>okhttp-android-support</module>
 
     <module>okhttp-apache</module>
+    <module>okhttp-testing-support</module>
     <module>okhttp-urlconnection</module>
 
     <module>okhttp-ws</module>
     <module>okhttp-ws-tests</module>
 
+    <module>okhttp-logging-interceptor</module>
+
     <module>okcurl</module>
     <module>mockwebserver</module>
     <module>samples</module>
@@ -40,20 +43,22 @@
     <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
 
     <!-- Compilation -->
-    <java.version>1.7</java.version>
-    <okio.version>1.3.0</okio.version>
+    <airlift.version>0.7</airlift.version>
     <!-- ALPN library targeted to Java 7 -->
     <alpn.jdk7.version>7.1.2.v20141202</alpn.jdk7.version>
-    <!-- ALPN library targeted to Java 8 update 25. -->
-    <alpn.jdk8.version>8.1.2.v20141202</alpn.jdk8.version>
-    <bouncycastle.version>1.50</bouncycastle.version>
-    <gson.version>2.2.3</gson.version>
+    <android.version>4.1.1.4</android.version>
     <apache.http.version>4.2.2</apache.http.version>
-    <airlift.version>0.6</airlift.version>
+    <bouncycastle.version>1.50</bouncycastle.version>
     <guava.version>16.0</guava.version>
+    <java.version>1.7</java.version>
+    <moshi.version>1.1.0</moshi.version>
+    <okio.version>1.8.0</okio.version>
 
     <!-- Test Dependencies -->
-    <junit.version>4.11</junit.version>
+    <junit.version>4.12</junit.version>
+
+    <!-- platform test mode -->
+    <okhttp.platform>platform</okhttp.platform>
   </properties>
 
   <scm>
@@ -92,11 +97,6 @@
         <artifactId>bcprov-jdk15on</artifactId>
         <version>${bouncycastle.version}</version>
       </dependency>
-      <dependency>
-        <groupId>com.google.code.gson</groupId>
-        <artifactId>gson</artifactId>
-        <version>${gson.version}</version>
-      </dependency>
       <dependency>
         <groupId>org.apache.httpcomponents</groupId>
         <artifactId>httpclient</artifactId>
@@ -112,6 +112,16 @@
         <artifactId>guava</artifactId>
         <version>${guava.version}</version>
       </dependency>
+      <dependency>
+        <groupId>com.google.android</groupId>
+        <artifactId>android</artifactId>
+        <version>${android.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>com.squareup.moshi</groupId>
+        <artifactId>moshi</artifactId>
+        <version>${moshi.version}</version>
+      </dependency>
     </dependencies>
   </dependencyManagement>
 
@@ -132,6 +142,22 @@
           <groupId>org.apache.maven.plugins</groupId>
           <artifactId>maven-surefire-plugin</artifactId>
           <version>2.17</version>
+          <configuration>
+            <systemPropertyVariables>
+              <okhttp.platform>${okhttp.platform}</okhttp.platform>
+            </systemPropertyVariables>
+            <properties>
+              <!--
+                Configure a listener for enforcing that no uncaught exceptions issue from OkHttp
+                tests. Every test must have a <scope>test</scope> dependency on
+                okhttp-testing-support.
+                -->
+              <property>
+                <name>listener</name>
+                <value>okhttp3.testing.InstallUncaughtExceptionHandlerListener</value>
+              </property>
+            </properties>
+          </configuration>
           <dependencies>
             <dependency>
               <groupId>org.apache.maven.surefire</groupId>
@@ -215,7 +241,10 @@
         <jdk>1.7</jdk>
       </activation>
       <properties>
-        <bootclasspathPrefix>${settings.localRepository}/org/mortbay/jetty/alpn/alpn-boot/${alpn.jdk7.version}/alpn-boot-${alpn.jdk7.version}.jar</bootclasspathPrefix>
+        <bootclasspathPrefix>
+          ${settings.localRepository}/org/mortbay/jetty/alpn/alpn-boot/${alpn.jdk7.version}/alpn-boot-${alpn.jdk7.version}.jar
+        </bootclasspathPrefix>
+        <okhttp.platform>jdk-with-jetty-boot</okhttp.platform>
       </properties>
       <build>
         <pluginManagement>
@@ -244,7 +273,10 @@
         <jdk>1.8</jdk>
       </activation>
       <properties>
-        <bootclasspathPrefix>${settings.localRepository}/org/mortbay/jetty/alpn/alpn-boot/${alpn.jdk8.version}/alpn-boot-${alpn.jdk8.version}.jar</bootclasspathPrefix>
+        <bootclasspathPrefix>
+          ${settings.localRepository}/org/mortbay/jetty/alpn/alpn-boot/${alpn.jdk8.version}/alpn-boot-${alpn.jdk8.version}.jar
+        </bootclasspathPrefix>
+        <okhttp.platform>jdk-with-jetty-boot</okhttp.platform>
       </properties>
       <build>
         <pluginManagement>
@@ -267,6 +299,180 @@
         </pluginManagement>
       </build>
     </profile>
+    <profile>
+      <id>jdk9</id>
+      <activation>
+        <jdk>9</jdk>
+      </activation>
+      <properties>
+        <okhttp.platform>jdk9</okhttp.platform>
+      </properties>
+    </profile>
+    <!-- ALPN Versions targeted for each Java 8 minor release -->
+    <!-- Check versions with this page: -->
+    <!-- http://www.eclipse.org/jetty/documentation/current/alpn-chapter.html#alpn-chapterchapterversions -->
+        <profile>
+      <id>alpn-when-jdk8_05</id>
+      <activation>
+        <jdk>1.8.0_05</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.0.v20141016</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_11</id>
+      <activation>
+        <jdk>1.8.0_11</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.0.v20141016</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_20</id>
+      <activation>
+        <jdk>1.8.0_20</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.0.v20141016</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_25</id>
+      <activation>
+        <jdk>1.8.0_25</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.2.v20141202</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_31</id>
+      <activation>
+        <jdk>1.8.0_31</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.3.v20150130</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_40</id>
+      <activation>
+        <jdk>1.8.0_40</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.3.v20150130</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_45</id>
+      <activation>
+        <jdk>1.8.0_45</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.3.v20150130</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_51</id>
+      <activation>
+        <jdk>1.8.0_51</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.4.v20150727</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_60</id>
+      <activation>
+        <jdk>1.8.0_60</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.5.v20150921</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_65</id>
+      <activation>
+        <jdk>1.8.0_65</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.6.v20151105</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_66</id>
+      <activation>
+        <jdk>1.8.0_66</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.6.v20151105</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_71</id>
+      <activation>
+        <jdk>1.8.0_71</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.7.v20160121</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_72</id>
+      <activation>
+        <jdk>1.8.0_72</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.7.v20160121</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_73</id>
+      <activation>
+        <jdk>1.8.0_73</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.7.v20160121</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_74</id>
+      <activation>
+        <jdk>1.8.0_74</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.7.v20160121</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_77</id>
+      <activation>
+        <jdk>1.8.0_77</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.7.v20160121</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_91</id>
+      <activation>
+        <jdk>1.8.0_91</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.7.v20160121</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_92</id>
+      <activation>
+        <jdk>1.8.0_92</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.8.v20160420</alpn.jdk8.version>
+      </properties>
+    </profile>
   </profiles>
 </project>
 
diff --git a/samples/crawler/pom.xml b/samples/crawler/pom.xml
index 59f51d38ed..a40fe5b58f 100644
--- a/samples/crawler/pom.xml
+++ b/samples/crawler/pom.xml
@@ -4,9 +4,9 @@
   <modelVersion>4.0.0</modelVersion>
 
   <parent>
-    <groupId>com.squareup.okhttp.sample</groupId>
+    <groupId>com.squareup.okhttp3.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>2.4.0-SNAPSHOT</version>
+    <version>3.4.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>crawler</artifactId>
@@ -14,7 +14,7 @@
 
   <dependencies>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>com.squareup.okhttp3</groupId>
       <artifactId>okhttp</artifactId>
       <version>${project.version}</version>
     </dependency>
diff --git a/samples/crawler/src/main/java/com/squareup/okhttp/sample/Crawler.java b/samples/crawler/src/main/java/okhttp3/sample/Crawler.java
similarity index 75%
rename from samples/crawler/src/main/java/com/squareup/okhttp/sample/Crawler.java
rename to samples/crawler/src/main/java/okhttp3/sample/Crawler.java
index 21d11c7c31..7fad2ee5e1 100644
--- a/samples/crawler/src/main/java/com/squareup/okhttp/sample/Crawler.java
+++ b/samples/crawler/src/main/java/okhttp3/sample/Crawler.java
@@ -13,17 +13,10 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.sample;
+package okhttp3.sample;
 
-import com.squareup.okhttp.Cache;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
-import com.squareup.okhttp.internal.NamedRunnable;
 import java.io.File;
 import java.io.IOException;
-import java.net.MalformedURLException;
-import java.net.URL;
 import java.util.Collections;
 import java.util.LinkedHashSet;
 import java.util.Set;
@@ -32,6 +25,12 @@
 import java.util.concurrent.Executors;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.atomic.AtomicInteger;
+import okhttp3.Cache;
+import okhttp3.HttpUrl;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.internal.NamedRunnable;
 import org.jsoup.Jsoup;
 import org.jsoup.nodes.Document;
 import org.jsoup.nodes.Element;
@@ -41,8 +40,9 @@
  */
 public final class Crawler {
   private final OkHttpClient client;
-  private final Set<URL> fetchedUrls = Collections.synchronizedSet(new LinkedHashSet<URL>());
-  private final LinkedBlockingQueue<URL> queue = new LinkedBlockingQueue<>();
+  private final Set<HttpUrl> fetchedUrls = Collections.synchronizedSet(
+      new LinkedHashSet<HttpUrl>());
+  private final LinkedBlockingQueue<HttpUrl> queue = new LinkedBlockingQueue<>();
   private final ConcurrentHashMap<String, AtomicInteger> hostnames = new ConcurrentHashMap<>();
 
   public Crawler(OkHttpClient client) {
@@ -66,7 +66,7 @@ private void parallelDrainQueue(int threadCount) {
   }
 
   private void drainQueue() throws Exception {
-    for (URL url; (url = queue.take()) != null; ) {
+    for (HttpUrl url; (url = queue.take()) != null; ) {
       if (!fetchedUrls.add(url)) {
         continue;
       }
@@ -79,10 +79,10 @@ private void drainQueue() throws Exception {
     }
   }
 
-  public void fetch(URL url) throws IOException {
+  public void fetch(HttpUrl url) throws IOException {
     // Skip hosts that we've visited many times.
     AtomicInteger hostnameCount = new AtomicInteger();
-    AtomicInteger previous = hostnames.putIfAbsent(url.getHost(), hostnameCount);
+    AtomicInteger previous = hostnames.putIfAbsent(url.host(), hostnameCount);
     if (previous != null) hostnameCount = previous;
     if (hostnameCount.incrementAndGet() > 100) return;
 
@@ -106,22 +106,11 @@ public void fetch(URL url) throws IOException {
     Document document = Jsoup.parse(response.body().string(), url.toString());
     for (Element element : document.select("a[href]")) {
       String href = element.attr("href");
-      URL link = parseUrl(response.request().url(), href);
+      HttpUrl link = response.request().url().resolve(href);
       if (link != null) queue.add(link);
     }
   }
 
-  private URL parseUrl(URL url, String href) {
-    try {
-      URL result = new URL(url, href);
-      return result.getProtocol().equals("http") || result.getProtocol().equals("https")
-          ? result
-          : null;
-    } catch (MalformedURLException e) {
-      return null;
-    }
-  }
-
   public static void main(String[] args) throws IOException {
     if (args.length != 2) {
       System.out.println("Usage: Crawler <cache dir> <root>");
@@ -131,12 +120,13 @@ public static void main(String[] args) throws IOException {
     int threadCount = 20;
     long cacheByteCount = 1024L * 1024L * 100L;
 
-    OkHttpClient client = new OkHttpClient();
     Cache cache = new Cache(new File(args[0]), cacheByteCount);
-    client.setCache(cache);
+    OkHttpClient client = new OkHttpClient.Builder()
+        .cache(cache)
+        .build();
 
     Crawler crawler = new Crawler(client);
-    crawler.queue.add(new URL(args[1]));
+    crawler.queue.add(HttpUrl.parse(args[1]));
     crawler.parallelDrainQueue(threadCount);
   }
 }
diff --git a/samples/guide/pom.xml b/samples/guide/pom.xml
index 299b065afe..569099322c 100644
--- a/samples/guide/pom.xml
+++ b/samples/guide/pom.xml
@@ -4,9 +4,9 @@
   <modelVersion>4.0.0</modelVersion>
 
   <parent>
-    <groupId>com.squareup.okhttp.sample</groupId>
+    <groupId>com.squareup.okhttp3.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>2.4.0-SNAPSHOT</version>
+    <version>3.4.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>guide</artifactId>
@@ -14,18 +14,18 @@
 
   <dependencies>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>com.squareup.okhttp3</groupId>
       <artifactId>okhttp</artifactId>
       <version>${project.version}</version>
     </dependency>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>com.squareup.okhttp3</groupId>
       <artifactId>okhttp-ws</artifactId>
       <version>${project.version}</version>
     </dependency>
     <dependency>
-      <groupId>com.google.code.gson</groupId>
-      <artifactId>gson</artifactId>
+      <groupId>com.squareup.moshi</groupId>
+      <artifactId>moshi</artifactId>
     </dependency>
   </dependencies>
 </project>
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/Authenticate.java b/samples/guide/src/main/java/com/squareup/okhttp/recipes/Authenticate.java
deleted file mode 100644
index 44581aed33..0000000000
--- a/samples/guide/src/main/java/com/squareup/okhttp/recipes/Authenticate.java
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.recipes;
-
-import com.squareup.okhttp.Authenticator;
-import com.squareup.okhttp.Credentials;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
-import java.io.IOException;
-import java.net.Proxy;
-
-public final class Authenticate {
-  private final OkHttpClient client = new OkHttpClient();
-
-  public void run() throws Exception {
-    client.setAuthenticator(new Authenticator() {
-      @Override public Request authenticate(Proxy proxy, Response response) {
-        System.out.println("Authenticating for response: " + response);
-        System.out.println("Challenges: " + response.challenges());
-        String credential = Credentials.basic("jesse", "password1");
-        return response.request().newBuilder()
-            .header("Authorization", credential)
-            .build();
-      }
-
-      @Override public Request authenticateProxy(Proxy proxy, Response response) {
-        return null; // Null indicates no attempt to authenticate.
-      }
-    });
-
-    Request request = new Request.Builder()
-        .url("http://publicobject.com/secrets/hellosecret.txt")
-        .build();
-
-    Response response = client.newCall(request).execute();
-    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
-
-    System.out.println(response.body().string());
-  }
-
-  public static void main(String... args) throws Exception {
-    new Authenticate().run();
-  }
-}
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/WebSocketEcho.java b/samples/guide/src/main/java/com/squareup/okhttp/recipes/WebSocketEcho.java
deleted file mode 100644
index dfe3b90c7b..0000000000
--- a/samples/guide/src/main/java/com/squareup/okhttp/recipes/WebSocketEcho.java
+++ /dev/null
@@ -1,67 +0,0 @@
-package com.squareup.okhttp.recipes;
-
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
-import com.squareup.okhttp.ws.WebSocket;
-import com.squareup.okhttp.ws.WebSocketCall;
-import com.squareup.okhttp.ws.WebSocketListener;
-import java.io.IOException;
-import okio.Buffer;
-import okio.BufferedSource;
-
-import static com.squareup.okhttp.ws.WebSocket.PayloadType;
-import static com.squareup.okhttp.ws.WebSocket.PayloadType.BINARY;
-import static com.squareup.okhttp.ws.WebSocket.PayloadType.TEXT;
-
-public final class WebSocketEcho implements WebSocketListener {
-  private void run() throws IOException {
-    OkHttpClient client = new OkHttpClient();
-
-    Request request = new Request.Builder()
-        .url("ws://echo.websocket.org")
-        .build();
-    WebSocketCall.create(client, request).enqueue(this);
-
-    // Trigger shutdown of the dispatcher's executor so this process can exit cleanly.
-    client.getDispatcher().getExecutorService().shutdown();
-  }
-
-  @Override public void onOpen(WebSocket webSocket, Request request, Response response)
-      throws IOException {
-    webSocket.sendMessage(TEXT, new Buffer().writeUtf8("Hello..."));
-    webSocket.sendMessage(TEXT, new Buffer().writeUtf8("...World!"));
-    webSocket.sendMessage(BINARY, new Buffer().writeInt(0xdeadbeef));
-    webSocket.close(1000, "Goodbye, World!");
-  }
-
-  @Override public void onMessage(BufferedSource payload, PayloadType type) throws IOException {
-    switch (type) {
-      case TEXT:
-        System.out.println(payload.readUtf8());
-        break;
-      case BINARY:
-        System.out.println(payload.readByteString().hex());
-        break;
-      default:
-        throw new IllegalStateException("Unknown payload type: " + type);
-    }
-    payload.close();
-  }
-
-  @Override public void onPong(Buffer payload) {
-    System.out.println("PONG: " + payload.readUtf8());
-  }
-
-  @Override public void onClose(int code, String reason) {
-    System.out.println("CLOSE: " + code + " " + reason);
-  }
-
-  @Override public void onFailure(IOException e) {
-    e.printStackTrace();
-  }
-
-  public static void main(String... args) throws IOException {
-    new WebSocketEcho().run();
-  }
-}
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/guide/GetExample.java b/samples/guide/src/main/java/okhttp3/guide/GetExample.java
similarity index 65%
rename from samples/guide/src/main/java/com/squareup/okhttp/guide/GetExample.java
rename to samples/guide/src/main/java/okhttp3/guide/GetExample.java
index aa2f200e40..35a1cc658c 100644
--- a/samples/guide/src/main/java/com/squareup/okhttp/guide/GetExample.java
+++ b/samples/guide/src/main/java/okhttp3/guide/GetExample.java
@@ -1,9 +1,9 @@
-package com.squareup.okhttp.guide;
+package okhttp3.guide;
 
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
 import java.io.IOException;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
 
 public class GetExample {
   OkHttpClient client = new OkHttpClient();
@@ -13,8 +13,9 @@ String run(String url) throws IOException {
         .url(url)
         .build();
 
-    Response response = client.newCall(request).execute();
-    return response.body().string();
+    try (Response response = client.newCall(request).execute()) {
+      return response.body().string();
+    }
   }
 
   public static void main(String[] args) throws IOException {
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/guide/PostExample.java b/samples/guide/src/main/java/okhttp3/guide/PostExample.java
similarity index 78%
rename from samples/guide/src/main/java/com/squareup/okhttp/guide/PostExample.java
rename to samples/guide/src/main/java/okhttp3/guide/PostExample.java
index 5de644c7d7..b6e70ccc7d 100644
--- a/samples/guide/src/main/java/com/squareup/okhttp/guide/PostExample.java
+++ b/samples/guide/src/main/java/okhttp3/guide/PostExample.java
@@ -1,11 +1,11 @@
-package com.squareup.okhttp.guide;
+package okhttp3.guide;
 
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.Response;
 import java.io.IOException;
+import okhttp3.MediaType;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
 
 public class PostExample {
   public static final MediaType JSON
@@ -19,8 +19,9 @@ String post(String url, String json) throws IOException {
         .url(url)
         .post(body)
         .build();
-    Response response = client.newCall(request).execute();
-    return response.body().string();
+    try (Response response = client.newCall(request).execute()) {
+      return response.body().string();
+    }
   }
 
   String bowlingJson(String player1, String player2) {
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/AccessHeaders.java b/samples/guide/src/main/java/okhttp3/recipes/AccessHeaders.java
similarity index 70%
rename from samples/guide/src/main/java/com/squareup/okhttp/recipes/AccessHeaders.java
rename to samples/guide/src/main/java/okhttp3/recipes/AccessHeaders.java
index 9fe9d1ab67..95fa49241c 100644
--- a/samples/guide/src/main/java/com/squareup/okhttp/recipes/AccessHeaders.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/AccessHeaders.java
@@ -13,12 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.recipes;
+package okhttp3.recipes;
 
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
 import java.io.IOException;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
 
 public final class AccessHeaders {
   private final OkHttpClient client = new OkHttpClient();
@@ -31,12 +31,13 @@ public void run() throws Exception {
         .addHeader("Accept", "application/vnd.github.v3+json")
         .build();
 
-    Response response = client.newCall(request).execute();
-    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+    try (Response response = client.newCall(request).execute()) {
+      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
 
-    System.out.println("Server: " + response.header("Server"));
-    System.out.println("Date: " + response.header("Date"));
-    System.out.println("Vary: " + response.headers("Vary"));
+      System.out.println("Server: " + response.header("Server"));
+      System.out.println("Date: " + response.header("Date"));
+      System.out.println("Vary: " + response.headers("Vary"));
+    }
   }
 
   public static void main(String... args) throws Exception {
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/AsynchronousGet.java b/samples/guide/src/main/java/okhttp3/recipes/AsynchronousGet.java
similarity index 58%
rename from samples/guide/src/main/java/com/squareup/okhttp/recipes/AsynchronousGet.java
rename to samples/guide/src/main/java/okhttp3/recipes/AsynchronousGet.java
index 34cfc584ce..68f1c2d591 100644
--- a/samples/guide/src/main/java/com/squareup/okhttp/recipes/AsynchronousGet.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/AsynchronousGet.java
@@ -13,14 +13,16 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.recipes;
+package okhttp3.recipes;
 
-import com.squareup.okhttp.Callback;
-import com.squareup.okhttp.Headers;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
 import java.io.IOException;
+import okhttp3.Call;
+import okhttp3.Callback;
+import okhttp3.Headers;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
 
 public final class AsynchronousGet {
   private final OkHttpClient client = new OkHttpClient();
@@ -31,19 +33,21 @@ public void run() throws Exception {
         .build();
 
     client.newCall(request).enqueue(new Callback() {
-      @Override public void onFailure(Request request, IOException e) {
+      @Override public void onFailure(Call call, IOException e) {
         e.printStackTrace();
       }
 
-      @Override public void onResponse(Response response) throws IOException {
-        if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+      @Override public void onResponse(Call call, Response response) throws IOException {
+        try (ResponseBody responseBody = response.body()) {
+          if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
 
-        Headers responseHeaders = response.headers();
-        for (int i = 0, size = responseHeaders.size(); i < size; i++) {
-          System.out.println(responseHeaders.name(i) + ": " + responseHeaders.value(i));
-        }
+          Headers responseHeaders = response.headers();
+          for (int i = 0, size = responseHeaders.size(); i < size; i++) {
+            System.out.println(responseHeaders.name(i) + ": " + responseHeaders.value(i));
+          }
 
-        System.out.println(response.body().string());
+          System.out.println(responseBody.string());
+        }
       }
     });
   }
diff --git a/samples/guide/src/main/java/okhttp3/recipes/Authenticate.java b/samples/guide/src/main/java/okhttp3/recipes/Authenticate.java
new file mode 100644
index 0000000000..61eb27f2b1
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/Authenticate.java
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes;
+
+import java.io.IOException;
+import okhttp3.Authenticator;
+import okhttp3.Credentials;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.Route;
+
+public final class Authenticate {
+  private final OkHttpClient client;
+
+  public Authenticate() {
+    client = new OkHttpClient.Builder()
+        .authenticator(new Authenticator() {
+          @Override public Request authenticate(Route route, Response response) throws IOException {
+            System.out.println("Authenticating for response: " + response);
+            System.out.println("Challenges: " + response.challenges());
+            String credential = Credentials.basic("jesse", "password1");
+            return response.request().newBuilder()
+                .header("Authorization", credential)
+                .build();
+          }
+        })
+        .build();
+  }
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("http://publicobject.com/secrets/hellosecret.txt")
+        .build();
+
+    try (Response response = client.newCall(request).execute()) {
+      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+      System.out.println(response.body().string());
+    }
+  }
+
+  public static void main(String... args) throws Exception {
+    new Authenticate().run();
+  }
+}
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/CacheResponse.java b/samples/guide/src/main/java/okhttp3/recipes/CacheResponse.java
similarity index 60%
rename from samples/guide/src/main/java/com/squareup/okhttp/recipes/CacheResponse.java
rename to samples/guide/src/main/java/okhttp3/recipes/CacheResponse.java
index 57d2ede65b..58a2bf0a14 100644
--- a/samples/guide/src/main/java/com/squareup/okhttp/recipes/CacheResponse.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/CacheResponse.java
@@ -13,8 +13,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.recipes;
+package okhttp3.recipes;
 
+<<<<<<< HEAD:samples/guide/src/main/java/com/squareup/okhttp/recipes/CacheResponse.java
 import com.squareup.okhttp.Cache;
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.Request;
@@ -23,6 +24,14 @@
 import java.io.File;
 import java.io.IOException;
 import java.util.logging.Logger;
+=======
+import java.io.File;
+import java.io.IOException;
+import okhttp3.Cache;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+>>>>>>> upstream/master:samples/guide/src/main/java/okhttp3/recipes/CacheResponse.java
 
 public final class CacheResponse {
     private static final Logger logger = Logger.getLogger(LoggingInterceptors.class.getName());
@@ -33,15 +42,23 @@ public CacheResponse(File cacheDirectory) throws Exception {
         int cacheSize = 10 * 1024 * 1024; // 10 MiB
         Cache cache = new Cache(cacheDirectory, cacheSize);
 
+<<<<<<< HEAD:samples/guide/src/main/java/com/squareup/okhttp/recipes/CacheResponse.java
         client = new OkHttpClient();
         client.setCache(cache);
     }
+=======
+    client = new OkHttpClient.Builder()
+        .cache(cache)
+        .build();
+  }
+>>>>>>> upstream/master:samples/guide/src/main/java/okhttp3/recipes/CacheResponse.java
 
     public void run() throws Exception {
         Request request = new Request.Builder()
                 .url("http://publicobject.com/helloworld.txt")
                 .build();
 
+<<<<<<< HEAD:samples/guide/src/main/java/com/squareup/okhttp/recipes/CacheResponse.java
         Response response1 = client.newCall(request).execute();
         if (!response1.isSuccessful()) {
             throw new IOException("Unexpected code " + response1);
@@ -61,6 +78,27 @@ public void run() throws Exception {
         System.out.println("Response 2 response:          " + response2);
         System.out.println("Response 2 cache response:    " + response2.cacheResponse());
         System.out.println("Response 2 network response:  " + response2.networkResponse());
+=======
+    String response1Body;
+    try (Response response1 = client.newCall(request).execute()) {
+      if (!response1.isSuccessful()) throw new IOException("Unexpected code " + response1);
+
+      response1Body = response1.body().string();
+      System.out.println("Response 1 response:          " + response1);
+      System.out.println("Response 1 cache response:    " + response1.cacheResponse());
+      System.out.println("Response 1 network response:  " + response1.networkResponse());
+    }
+
+    String response2Body;
+    try (Response response2 = client.newCall(request).execute()) {
+      if (!response2.isSuccessful()) throw new IOException("Unexpected code " + response2);
+
+      response2Body = response2.body().string();
+      System.out.println("Response 2 response:          " + response2);
+      System.out.println("Response 2 cache response:    " + response2.cacheResponse());
+      System.out.println("Response 2 network response:  " + response2.networkResponse());
+    }
+>>>>>>> upstream/master:samples/guide/src/main/java/okhttp3/recipes/CacheResponse.java
 
         System.out.println("Response 2 equals Response 1? " + response1Body.equals(response2Body));
     }
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/CancelCall.java b/samples/guide/src/main/java/okhttp3/recipes/CancelCall.java
similarity index 85%
rename from samples/guide/src/main/java/com/squareup/okhttp/recipes/CancelCall.java
rename to samples/guide/src/main/java/okhttp3/recipes/CancelCall.java
index 9f8d37305c..644f638300 100644
--- a/samples/guide/src/main/java/com/squareup/okhttp/recipes/CancelCall.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/CancelCall.java
@@ -13,16 +13,16 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.recipes;
+package okhttp3.recipes;
 
-import com.squareup.okhttp.Call;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
 import java.io.IOException;
 import java.util.concurrent.Executors;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.TimeUnit;
+import okhttp3.Call;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
 
 public class CancelCall {
   private final ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);
@@ -45,9 +45,8 @@ public void run() throws Exception {
       }
     }, 1, TimeUnit.SECONDS);
 
-    try {
-      System.out.printf("%.2f Executing call.%n", (System.nanoTime() - startNanos) / 1e9f);
-      Response response = call.execute();
+    System.out.printf("%.2f Executing call.%n", (System.nanoTime() - startNanos) / 1e9f);
+    try (Response response = call.execute()) {
       System.out.printf("%.2f Call was expected to fail, but completed: %s%n",
           (System.nanoTime() - startNanos) / 1e9f, response);
     } catch (IOException e) {
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/CertificatePinning.java b/samples/guide/src/main/java/okhttp3/recipes/CertificatePinning.java
similarity index 53%
rename from samples/guide/src/main/java/com/squareup/okhttp/recipes/CertificatePinning.java
rename to samples/guide/src/main/java/okhttp3/recipes/CertificatePinning.java
index b643d52d03..91c3fcc59f 100644
--- a/samples/guide/src/main/java/com/squareup/okhttp/recipes/CertificatePinning.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/CertificatePinning.java
@@ -13,27 +13,25 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.recipes;
+package okhttp3.recipes;
 
-import com.squareup.okhttp.CertificatePinner;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
 import java.io.IOException;
 import java.security.cert.Certificate;
+import okhttp3.CertificatePinner;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
 
 public final class CertificatePinning {
   private final OkHttpClient client;
 
   public CertificatePinning() {
-    client = new OkHttpClient();
-    client.setCertificatePinner(
-        new CertificatePinner.Builder()
-            .add("publicobject.com", "sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw=")
-            .add("publicobject.com", "sha1/SXxoaOSEzPC6BgGmxAt/EAcsajw=")
-            .add("publicobject.com", "sha1/blhOM3W9V/bVQhsWAcLYwPU6n24=")
-            .add("publicobject.com", "sha1/T5x9IXmcrQ7YuQxXnxoCmeeQ84c=")
-            .build());
+    client = new OkHttpClient.Builder()
+        .certificatePinner(
+            new CertificatePinner.Builder()
+                .add("publicobject.com", "sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=")
+                .build())
+        .build();
   }
 
   public void run() throws Exception {
@@ -41,11 +39,12 @@ public void run() throws Exception {
         .url("https://publicobject.com/robots.txt")
         .build();
 
-    Response response = client.newCall(request).execute();
-    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+    try (Response response = client.newCall(request).execute()) {
+      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
 
-    for (Certificate certificate : response.handshake().peerCertificates()) {
-      System.out.println(CertificatePinner.pin(certificate));
+      for (Certificate certificate : response.handshake().peerCertificates()) {
+        System.out.println(CertificatePinner.pin(certificate));
+      }
     }
   }
 
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/CheckHandshake.java b/samples/guide/src/main/java/okhttp3/recipes/CheckHandshake.java
similarity index 69%
rename from samples/guide/src/main/java/com/squareup/okhttp/recipes/CheckHandshake.java
rename to samples/guide/src/main/java/okhttp3/recipes/CheckHandshake.java
index 0a2e86e7d2..164e879079 100644
--- a/samples/guide/src/main/java/com/squareup/okhttp/recipes/CheckHandshake.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/CheckHandshake.java
@@ -13,17 +13,17 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.recipes;
+package okhttp3.recipes;
 
-import com.squareup.okhttp.CertificatePinner;
-import com.squareup.okhttp.Interceptor;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
 import java.io.IOException;
 import java.security.cert.Certificate;
 import java.util.Collections;
 import java.util.Set;
+import okhttp3.CertificatePinner;
+import okhttp3.Interceptor;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
 
 public final class CheckHandshake {
   /** Rejects otherwise-trusted certificates. */
@@ -31,7 +31,7 @@
     Set<String> blacklist = Collections.singleton("sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw=");
 
     @Override public Response intercept(Chain chain) throws IOException {
-      for (Certificate certificate : chain.connection().getHandshake().peerCertificates()) {
+      for (Certificate certificate : chain.connection().handshake().peerCertificates()) {
         String pin = CertificatePinner.pin(certificate);
         if (blacklist.contains(pin)) {
           throw new IOException("Blacklisted peer certificate: " + pin);
@@ -41,21 +41,20 @@
     }
   };
 
-  private final OkHttpClient client = new OkHttpClient();
-
-  public CheckHandshake() {
-    client.networkInterceptors().add(CHECK_HANDSHAKE_INTERCEPTOR);
-  }
+  private final OkHttpClient client = new OkHttpClient.Builder()
+      .addNetworkInterceptor(CHECK_HANDSHAKE_INTERCEPTOR)
+      .build();
 
   public void run() throws Exception {
     Request request = new Request.Builder()
         .url("https://publicobject.com/helloworld.txt")
         .build();
 
-    Response response = client.newCall(request).execute();
-    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+    try (Response response = client.newCall(request).execute()) {
+      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
 
-    System.out.println(response.body().string());
+      System.out.println(response.body().string());
+    }
   }
 
   public static void main(String... args) throws Exception {
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/ConfigureTimeouts.java b/samples/guide/src/main/java/okhttp3/recipes/ConfigureTimeouts.java
similarity index 70%
rename from samples/guide/src/main/java/com/squareup/okhttp/recipes/ConfigureTimeouts.java
rename to samples/guide/src/main/java/okhttp3/recipes/ConfigureTimeouts.java
index f358a4564f..a6d3000732 100644
--- a/samples/guide/src/main/java/com/squareup/okhttp/recipes/ConfigureTimeouts.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/ConfigureTimeouts.java
@@ -13,21 +13,22 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.recipes;
+package okhttp3.recipes;
 
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
 import java.util.concurrent.TimeUnit;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
 
 public final class ConfigureTimeouts {
   private final OkHttpClient client;
 
   public ConfigureTimeouts() throws Exception {
-    client = new OkHttpClient();
-    client.setConnectTimeout(10, TimeUnit.SECONDS);
-    client.setWriteTimeout(10, TimeUnit.SECONDS);
-    client.setReadTimeout(30, TimeUnit.SECONDS);
+    client = new OkHttpClient.Builder()
+        .connectTimeout(10, TimeUnit.SECONDS)
+        .writeTimeout(10, TimeUnit.SECONDS)
+        .readTimeout(30, TimeUnit.SECONDS)
+        .build();
   }
 
   public void run() throws Exception {
@@ -35,8 +36,9 @@ public void run() throws Exception {
         .url("http://httpbin.org/delay/2") // This URL is served with a 2 second delay.
         .build();
 
-    Response response = client.newCall(request).execute();
-    System.out.println("Response completed: " + response);
+    try (Response response = client.newCall(request).execute()) {
+      System.out.println("Response completed: " + response);
+    }
   }
 
   public static void main(String... args) throws Exception {
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/CustomTrust.java b/samples/guide/src/main/java/okhttp3/recipes/CustomTrust.java
similarity index 73%
rename from samples/guide/src/main/java/com/squareup/okhttp/recipes/CustomTrust.java
rename to samples/guide/src/main/java/okhttp3/recipes/CustomTrust.java
index f99dc627a9..a8df15ba32 100644
--- a/samples/guide/src/main/java/com/squareup/okhttp/recipes/CustomTrust.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/CustomTrust.java
@@ -13,33 +13,47 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.recipes;
+package okhttp3.recipes;
 
-import com.squareup.okhttp.CertificatePinner;
-import com.squareup.okhttp.Headers;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
 import java.io.IOException;
 import java.io.InputStream;
 import java.security.GeneralSecurityException;
 import java.security.KeyStore;
-import java.security.SecureRandom;
 import java.security.cert.Certificate;
 import java.security.cert.CertificateFactory;
+import java.util.Arrays;
 import java.util.Collection;
 import javax.net.ssl.KeyManagerFactory;
 import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSocketFactory;
+import javax.net.ssl.TrustManager;
 import javax.net.ssl.TrustManagerFactory;
+import javax.net.ssl.X509TrustManager;
+import okhttp3.CertificatePinner;
+import okhttp3.Headers;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
 import okio.Buffer;
 
 public final class CustomTrust {
   private final OkHttpClient client;
 
   public CustomTrust() {
-    client = new OkHttpClient();
-    SSLContext sslContext = sslContextForTrustedCertificates(trustedCertificatesInputStream());
-    client.setSslSocketFactory(sslContext.getSocketFactory());
+    X509TrustManager trustManager;
+    SSLSocketFactory sslSocketFactory;
+    try {
+      trustManager = trustManagerForCertificates(trustedCertificatesInputStream());
+      SSLContext sslContext = SSLContext.getInstance("TLS");
+      sslContext.init(null, new TrustManager[] { trustManager }, null);
+      sslSocketFactory = sslContext.getSocketFactory();
+    } catch (GeneralSecurityException e) {
+      throw new RuntimeException(e);
+    }
+
+    client = new OkHttpClient.Builder()
+        .sslSocketFactory(sslSocketFactory, trustManager)
+        .build();
   }
 
   public void run() throws Exception {
@@ -47,15 +61,16 @@ public void run() throws Exception {
         .url("https://publicobject.com/helloworld.txt")
         .build();
 
-    Response response = client.newCall(request).execute();
-    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+    try (Response response = client.newCall(request).execute()) {
+      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
 
-    Headers responseHeaders = response.headers();
-    for (int i = 0; i < responseHeaders.size(); i++) {
-      System.out.println(responseHeaders.name(i) + ": " + responseHeaders.value(i));
-    }
+      Headers responseHeaders = response.headers();
+      for (int i = 0; i < responseHeaders.size(); i++) {
+        System.out.println(responseHeaders.name(i) + ": " + responseHeaders.value(i));
+      }
 
-    System.out.println(response.body().string());
+      System.out.println(response.body().string());
+    }
   }
 
   /**
@@ -138,7 +153,7 @@ private InputStream trustedCertificatesInputStream() {
   }
 
   /**
-   * Returns a SSL context that trusts {@code certificates} and none other. HTTPS services whose
+   * Returns a trust manager that trusts {@code certificates} and none other. HTTPS services whose
    * certificates have not been signed by these certificates will fail with a {@code
    * SSLHandshakeException}.
    *
@@ -150,43 +165,43 @@ private InputStream trustedCertificatesInputStream() {
    * the host platform's built-in trust store.
    *
    * <h3>Warning: Customizing Trusted Certificates is Dangerous!</h3>
-   * Relying on your own trusted certificates limits your server team's ability to update their TLS
-   * certificates. By installing a specific set of trusted certificates, you take on additional
+   *
+   * <p>Relying on your own trusted certificates limits your server team's ability to update their
+   * TLS certificates. By installing a specific set of trusted certificates, you take on additional
    * operational complexity and limit your ability to migrate between certificate authorities. Do
    * not use custom trusted certificates in production without the blessing of your server's TLS
    * administrator.
    */
-  public SSLContext sslContextForTrustedCertificates(InputStream in) {
-    try {
-      CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509");
-      Collection<? extends Certificate> certificates = certificateFactory.generateCertificates(in);
-      if (certificates.isEmpty()) {
-        throw new IllegalArgumentException("expected non-empty set of trusted certificates");
-      }
+  private X509TrustManager trustManagerForCertificates(InputStream in)
+      throws GeneralSecurityException {
+    CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509");
+    Collection<? extends Certificate> certificates = certificateFactory.generateCertificates(in);
+    if (certificates.isEmpty()) {
+      throw new IllegalArgumentException("expected non-empty set of trusted certificates");
+    }
 
-      // Put the certificates a key store.
-      char[] password = "password".toCharArray(); // Any password will work.
-      KeyStore keyStore = newEmptyKeyStore(password);
-      int index = 0;
-      for (Certificate certificate : certificates) {
-        String certificateAlias = Integer.toString(index++);
-        keyStore.setCertificateEntry(certificateAlias, certificate);
-      }
+    // Put the certificates a key store.
+    char[] password = "password".toCharArray(); // Any password will work.
+    KeyStore keyStore = newEmptyKeyStore(password);
+    int index = 0;
+    for (Certificate certificate : certificates) {
+      String certificateAlias = Integer.toString(index++);
+      keyStore.setCertificateEntry(certificateAlias, certificate);
+    }
 
-      // Wrap it up in an SSL context.
-      KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(
-          KeyManagerFactory.getDefaultAlgorithm());
-      keyManagerFactory.init(keyStore, password);
-      TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
-          TrustManagerFactory.getDefaultAlgorithm());
-      trustManagerFactory.init(keyStore);
-      SSLContext sslContext = SSLContext.getInstance("TLS");
-      sslContext.init(keyManagerFactory.getKeyManagers(), trustManagerFactory.getTrustManagers(),
-          new SecureRandom());
-      return sslContext;
-    } catch (GeneralSecurityException e) {
-      throw new RuntimeException(e);
+    // Use it to build an X509 trust manager.
+    KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(
+        KeyManagerFactory.getDefaultAlgorithm());
+    keyManagerFactory.init(keyStore, password);
+    TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
+        TrustManagerFactory.getDefaultAlgorithm());
+    trustManagerFactory.init(keyStore);
+    TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
+    if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {
+      throw new IllegalStateException("Unexpected default trust managers:"
+          + Arrays.toString(trustManagers));
     }
+    return (X509TrustManager) trustManagers[0];
   }
 
   private KeyStore newEmptyKeyStore(char[] password) throws GeneralSecurityException {
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/LoggingInterceptors.java b/samples/guide/src/main/java/okhttp3/recipes/LoggingInterceptors.java
similarity index 56%
rename from samples/guide/src/main/java/com/squareup/okhttp/recipes/LoggingInterceptors.java
rename to samples/guide/src/main/java/okhttp3/recipes/LoggingInterceptors.java
index d70f1070a2..8cb72b4bc8 100644
--- a/samples/guide/src/main/java/com/squareup/okhttp/recipes/LoggingInterceptors.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/LoggingInterceptors.java
@@ -13,35 +13,20 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.recipes;
+package okhttp3.recipes;
 
-import com.squareup.okhttp.Interceptor;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
 import java.io.IOException;
 import java.util.logging.Logger;
+import okhttp3.Interceptor;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
 
 public final class LoggingInterceptors {
   private static final Logger logger = Logger.getLogger(LoggingInterceptors.class.getName());
-  private final OkHttpClient client = new OkHttpClient();
-
-  public LoggingInterceptors() {
-    client.networkInterceptors().add(new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        long t1 = System.nanoTime();
-        Request request = chain.request();
-        logger.info(String.format("Sending request %s on %s%n%s",
-            request.url(), chain.connection(), request.headers()));
-        Response response = chain.proceed(request);
-
-        long t2 = System.nanoTime();
-        logger.info(String.format("Received response for %s in %.1fms%n%s",
-            request.url(), (t2 - t1) / 1e6d, response.headers()));
-        return response;
-      }
-    });
-  }
+  private final OkHttpClient client = new OkHttpClient.Builder()
+      .addInterceptor(new LoggingInterceptor())
+      .build();
 
   public void run() throws Exception {
     Request request = new Request.Builder()
@@ -52,6 +37,21 @@ public void run() throws Exception {
     response.body().close();
   }
 
+  private static class LoggingInterceptor implements Interceptor {
+    @Override public Response intercept(Chain chain) throws IOException {
+      long t1 = System.nanoTime();
+      Request request = chain.request();
+      logger.info(String.format("Sending request %s on %s%n%s",
+          request.url(), chain.connection(), request.headers()));
+      Response response = chain.proceed(request);
+
+      long t2 = System.nanoTime();
+      logger.info(String.format("Received response for %s in %.1fms%n%s",
+          request.url(), (t2 - t1) / 1e6d, response.headers()));
+      return response;
+    }
+  }
+
   public static void main(String... args) throws Exception {
     new LoggingInterceptors().run();
   }
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/ParseResponseWithGson.java b/samples/guide/src/main/java/okhttp3/recipes/ParseResponseWithMoshi.java
similarity index 60%
rename from samples/guide/src/main/java/com/squareup/okhttp/recipes/ParseResponseWithGson.java
rename to samples/guide/src/main/java/okhttp3/recipes/ParseResponseWithMoshi.java
index cf63f0d4b1..68570bf13f 100644
--- a/samples/guide/src/main/java/com/squareup/okhttp/recipes/ParseResponseWithGson.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/ParseResponseWithMoshi.java
@@ -13,30 +13,34 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.recipes;
+package okhttp3.recipes;
 
-import com.google.gson.Gson;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
+import com.squareup.moshi.JsonAdapter;
+import com.squareup.moshi.Moshi;
 import java.io.IOException;
 import java.util.Map;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
 
-public final class ParseResponseWithGson {
+public final class ParseResponseWithMoshi {
   private final OkHttpClient client = new OkHttpClient();
-  private final Gson gson = new Gson();
+  private final Moshi moshi = new Moshi.Builder().build();
+  private final JsonAdapter<Gist> gistJsonAdapter = moshi.adapter(Gist.class);
 
   public void run() throws Exception {
     Request request = new Request.Builder()
         .url("https://api.github.com/gists/c2a7c39532239ff261be")
         .build();
-    Response response = client.newCall(request).execute();
-    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+    try (Response response = client.newCall(request).execute()) {
+      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
 
-    Gist gist = gson.fromJson(response.body().charStream(), Gist.class);
-    for (Map.Entry<String, GistFile> entry : gist.files.entrySet()) {
-      System.out.println(entry.getKey());
-      System.out.println(entry.getValue().content);
+      Gist gist = gistJsonAdapter.fromJson(response.body().source());
+
+      for (Map.Entry<String, GistFile> entry : gist.files.entrySet()) {
+        System.out.println(entry.getKey());
+        System.out.println(entry.getValue().content);
+      }
     }
   }
 
@@ -49,6 +53,6 @@ public void run() throws Exception {
   }
 
   public static void main(String... args) throws Exception {
-    new ParseResponseWithGson().run();
+    new ParseResponseWithMoshi().run();
   }
 }
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/PerCallSettings.java b/samples/guide/src/main/java/okhttp3/recipes/PerCallSettings.java
similarity index 69%
rename from samples/guide/src/main/java/com/squareup/okhttp/recipes/PerCallSettings.java
rename to samples/guide/src/main/java/okhttp3/recipes/PerCallSettings.java
index af4956e17f..6aa266c11d 100644
--- a/samples/guide/src/main/java/com/squareup/okhttp/recipes/PerCallSettings.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/PerCallSettings.java
@@ -13,13 +13,13 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.recipes;
+package okhttp3.recipes;
 
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
 import java.io.IOException;
 import java.util.concurrent.TimeUnit;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
 
 public final class PerCallSettings {
   private final OkHttpClient client = new OkHttpClient();
@@ -29,21 +29,21 @@ public void run() throws Exception {
         .url("http://httpbin.org/delay/1") // This URL is served with a 1 second delay.
         .build();
 
-    try {
-      OkHttpClient cloned = client.clone(); // Clone to make a customized OkHttp for this request.
-      cloned.setReadTimeout(500, TimeUnit.MILLISECONDS);
-
-      Response response = cloned.newCall(request).execute();
+    // Copy to customize OkHttp for this request.
+    OkHttpClient client1 = client.newBuilder()
+        .readTimeout(500, TimeUnit.MILLISECONDS)
+        .build();
+    try (Response response = client1.newCall(request).execute()) {
       System.out.println("Response 1 succeeded: " + response);
     } catch (IOException e) {
       System.out.println("Response 1 failed: " + e);
     }
 
-    try {
-      OkHttpClient cloned = client.clone(); // Clone to make a customized OkHttp for this request.
-      cloned.setReadTimeout(3000, TimeUnit.MILLISECONDS);
-
-      Response response = cloned.newCall(request).execute();
+    // Copy to customize OkHttp for this request.
+    OkHttpClient client2 = client.newBuilder()
+        .readTimeout(3000, TimeUnit.MILLISECONDS)
+        .build();
+    try (Response response = client2.newCall(request).execute()) {
       System.out.println("Response 2 succeeded: " + response);
     } catch (IOException e) {
       System.out.println("Response 2 failed: " + e);
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostFile.java b/samples/guide/src/main/java/okhttp3/recipes/PostFile.java
similarity index 73%
rename from samples/guide/src/main/java/com/squareup/okhttp/recipes/PostFile.java
rename to samples/guide/src/main/java/okhttp3/recipes/PostFile.java
index a0d98df45f..b216b24b3b 100644
--- a/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostFile.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/PostFile.java
@@ -13,15 +13,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.recipes;
+package okhttp3.recipes;
 
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.Response;
 import java.io.File;
 import java.io.IOException;
+import okhttp3.MediaType;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
 
 public final class PostFile {
   public static final MediaType MEDIA_TYPE_MARKDOWN
@@ -37,10 +37,11 @@ public void run() throws Exception {
         .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, file))
         .build();
 
-    Response response = client.newCall(request).execute();
-    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+    try (Response response = client.newCall(request).execute()) {
+      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
 
-    System.out.println(response.body().string());
+      System.out.println(response.body().string());
+    }
   }
 
   public static void main(String... args) throws Exception {
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostForm.java b/samples/guide/src/main/java/okhttp3/recipes/PostForm.java
similarity index 68%
rename from samples/guide/src/main/java/com/squareup/okhttp/recipes/PostForm.java
rename to samples/guide/src/main/java/okhttp3/recipes/PostForm.java
index 30054f1905..eab32b01ab 100644
--- a/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostForm.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/PostForm.java
@@ -13,20 +13,20 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.recipes;
+package okhttp3.recipes;
 
-import com.squareup.okhttp.FormEncodingBuilder;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.Response;
 import java.io.IOException;
+import okhttp3.FormBody;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
 
 public final class PostForm {
   private final OkHttpClient client = new OkHttpClient();
 
   public void run() throws Exception {
-    RequestBody formBody = new FormEncodingBuilder()
+    RequestBody formBody = new FormBody.Builder()
         .add("search", "Jurassic Park")
         .build();
     Request request = new Request.Builder()
@@ -34,10 +34,11 @@ public void run() throws Exception {
         .post(formBody)
         .build();
 
-    Response response = client.newCall(request).execute();
-    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+    try (Response response = client.newCall(request).execute()) {
+      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
 
-    System.out.println(response.body().string());
+      System.out.println(response.body().string());
+    }
   }
 
   public static void main(String... args) throws Exception {
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostMultipart.java b/samples/guide/src/main/java/okhttp3/recipes/PostMultipart.java
similarity index 68%
rename from samples/guide/src/main/java/com/squareup/okhttp/recipes/PostMultipart.java
rename to samples/guide/src/main/java/okhttp3/recipes/PostMultipart.java
index 8e5334aa39..3e93a00e82 100644
--- a/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostMultipart.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/PostMultipart.java
@@ -13,22 +13,21 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.recipes;
-
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.MultipartBuilder;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.Response;
+package okhttp3.recipes;
+
 import java.io.File;
 import java.io.IOException;
+import okhttp3.MediaType;
+import okhttp3.MultipartBody;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
 
 public final class PostMultipart {
   /**
-   * The imgur client ID for OkHttp recipes. If you're using imgur for anything
-   * other than running these examples, please request your own client ID!
-   *   https://api.imgur.com/oauth2
+   * The imgur client ID for OkHttp recipes. If you're using imgur for anything other than running
+   * these examples, please request your own client ID! https://api.imgur.com/oauth2
    */
   private static final String IMGUR_CLIENT_ID = "9199fdef135c122";
   private static final MediaType MEDIA_TYPE_PNG = MediaType.parse("image/png");
@@ -37,10 +36,10 @@
 
   public void run() throws Exception {
     // Use the imgur image upload API as documented at https://api.imgur.com/endpoints/image
-    RequestBody requestBody = new MultipartBuilder()
-        .type(MultipartBuilder.FORM)
+    RequestBody requestBody = new MultipartBody.Builder()
+        .setType(MultipartBody.FORM)
         .addFormDataPart("title", "Square Logo")
-        .addFormDataPart("image", null,
+        .addFormDataPart("image", "logo-square.png",
             RequestBody.create(MEDIA_TYPE_PNG, new File("website/static/logo-square.png")))
         .build();
 
@@ -50,10 +49,11 @@ public void run() throws Exception {
         .post(requestBody)
         .build();
 
-    Response response = client.newCall(request).execute();
-    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+    try (Response response = client.newCall(request).execute()) {
+      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
 
-    System.out.println(response.body().string());
+      System.out.println(response.body().string());
+    }
   }
 
   public static void main(String... args) throws Exception {
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostStreaming.java b/samples/guide/src/main/java/okhttp3/recipes/PostStreaming.java
similarity index 80%
rename from samples/guide/src/main/java/com/squareup/okhttp/recipes/PostStreaming.java
rename to samples/guide/src/main/java/okhttp3/recipes/PostStreaming.java
index 500344c7e9..440c7768ea 100644
--- a/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostStreaming.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/PostStreaming.java
@@ -13,14 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.recipes;
+package okhttp3.recipes;
 
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.Response;
 import java.io.IOException;
+import okhttp3.MediaType;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
 import okio.BufferedSink;
 
 public final class PostStreaming {
@@ -57,10 +57,11 @@ private String factor(int n) {
         .post(requestBody)
         .build();
 
-    Response response = client.newCall(request).execute();
-    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+    try (Response response = client.newCall(request).execute()) {
+      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
 
-    System.out.println(response.body().string());
+      System.out.println(response.body().string());
+    }
   }
 
   public static void main(String... args) throws Exception {
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostString.java b/samples/guide/src/main/java/okhttp3/recipes/PostString.java
similarity index 76%
rename from samples/guide/src/main/java/com/squareup/okhttp/recipes/PostString.java
rename to samples/guide/src/main/java/okhttp3/recipes/PostString.java
index 943636abb5..8a312bde8a 100644
--- a/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostString.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/PostString.java
@@ -13,14 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.recipes;
+package okhttp3.recipes;
 
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.Response;
 import java.io.IOException;
+import okhttp3.MediaType;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
 
 public final class PostString {
   public static final MediaType MEDIA_TYPE_MARKDOWN
@@ -42,10 +42,11 @@ public void run() throws Exception {
         .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, postBody))
         .build();
 
-    Response response = client.newCall(request).execute();
-    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+    try (Response response = client.newCall(request).execute()) {
+      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
 
-    System.out.println(response.body().string());
+      System.out.println(response.body().string());
+    }
   }
 
   public static void main(String... args) throws Exception {
diff --git a/samples/guide/src/main/java/okhttp3/recipes/Progress.java b/samples/guide/src/main/java/okhttp3/recipes/Progress.java
new file mode 100644
index 0000000000..f04de79340
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/Progress.java
@@ -0,0 +1,113 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes;
+
+import java.io.IOException;
+import okhttp3.Interceptor;
+import okhttp3.MediaType;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+import okio.Buffer;
+import okio.BufferedSource;
+import okio.ForwardingSource;
+import okio.Okio;
+import okio.Source;
+
+public final class Progress {
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("https://publicobject.com/helloworld.txt")
+        .build();
+
+    final ProgressListener progressListener = new ProgressListener() {
+      @Override public void update(long bytesRead, long contentLength, boolean done) {
+        System.out.println(bytesRead);
+        System.out.println(contentLength);
+        System.out.println(done);
+        System.out.format("%d%% done\n", (100 * bytesRead) / contentLength);
+      }
+    };
+
+    OkHttpClient client = new OkHttpClient.Builder()
+        .addNetworkInterceptor(new Interceptor() {
+          @Override public Response intercept(Chain chain) throws IOException {
+            Response originalResponse = chain.proceed(chain.request());
+            return originalResponse.newBuilder()
+                .body(new ProgressResponseBody(originalResponse.body(), progressListener))
+                .build();
+          }
+        })
+        .build();
+
+    try (Response response = client.newCall(request).execute()) {
+      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+      System.out.println(response.body().string());
+    }
+  }
+
+  public static void main(String... args) throws Exception {
+    new Progress().run();
+  }
+
+  private static class ProgressResponseBody extends ResponseBody {
+
+    private final ResponseBody responseBody;
+    private final ProgressListener progressListener;
+    private BufferedSource bufferedSource;
+
+    public ProgressResponseBody(ResponseBody responseBody, ProgressListener progressListener) {
+      this.responseBody = responseBody;
+      this.progressListener = progressListener;
+    }
+
+    @Override public MediaType contentType() {
+      return responseBody.contentType();
+    }
+
+    @Override public long contentLength() {
+      return responseBody.contentLength();
+    }
+
+    @Override public BufferedSource source() {
+      if (bufferedSource == null) {
+        bufferedSource = Okio.buffer(source(responseBody.source()));
+      }
+      return bufferedSource;
+    }
+
+    private Source source(Source source) {
+      return new ForwardingSource(source) {
+        long totalBytesRead = 0L;
+
+        @Override public long read(Buffer sink, long byteCount) throws IOException {
+          long bytesRead = super.read(sink, byteCount);
+          // read() returns the number of bytes read, or -1 if this source is exhausted.
+          totalBytesRead += bytesRead != -1 ? bytesRead : 0;
+          progressListener.update(totalBytesRead, responseBody.contentLength(), bytesRead == -1);
+          return bytesRead;
+        }
+      };
+    }
+  }
+
+  interface ProgressListener {
+    void update(long bytesRead, long contentLength, boolean done);
+  }
+}
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/RequestBodyCompression.java b/samples/guide/src/main/java/okhttp3/recipes/RequestBodyCompression.java
similarity index 75%
rename from samples/guide/src/main/java/com/squareup/okhttp/recipes/RequestBodyCompression.java
rename to samples/guide/src/main/java/okhttp3/recipes/RequestBodyCompression.java
index c4805bdeb3..b1a62c0fa3 100644
--- a/samples/guide/src/main/java/com/squareup/okhttp/recipes/RequestBodyCompression.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/RequestBodyCompression.java
@@ -13,18 +13,20 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.recipes;
+package okhttp3.recipes;
 
-import com.google.gson.Gson;
-import com.squareup.okhttp.Interceptor;
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.Response;
+import com.squareup.moshi.JsonAdapter;
+import com.squareup.moshi.Moshi;
+import com.squareup.moshi.Types;
 import java.io.IOException;
 import java.util.LinkedHashMap;
 import java.util.Map;
+import okhttp3.Interceptor;
+import okhttp3.MediaType;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
 import okio.BufferedSink;
 import okio.GzipSink;
 import okio.Okio;
@@ -33,31 +35,34 @@
   /**
    * The Google API KEY for OkHttp recipes. If you're using Google APIs for anything other than
    * running these examples, please request your own client ID!
-   *   https://console.developers.google.com/project
+   *
+   * https://console.developers.google.com/project
    */
   public static final String GOOGLE_API_KEY = "AIzaSyAx2WZYe0My0i-uGurpvraYJxO7XNbwiGs";
   public static final MediaType MEDIA_TYPE_JSON = MediaType.parse("application/json");
 
-  private final OkHttpClient client = new OkHttpClient();
-
-  public RequestBodyCompression() {
-    client.interceptors().add(new GzipRequestInterceptor());
-  }
+  private final OkHttpClient client = new OkHttpClient.Builder()
+      .addInterceptor(new GzipRequestInterceptor())
+      .build();
+  private final Moshi moshi = new Moshi.Builder().build();
+  private final JsonAdapter<Map<String, String>> mapJsonAdapter = moshi.adapter(
+      Types.newParameterizedType(Map.class, String.class, String.class));
 
   public void run() throws Exception {
     Map<String, String> requestBody = new LinkedHashMap<>();
     requestBody.put("longUrl", "https://publicobject.com/2014/12/04/html-formatting-javadocs/");
     RequestBody jsonRequestBody = RequestBody.create(
-        MEDIA_TYPE_JSON, new Gson().toJson(requestBody));
+        MEDIA_TYPE_JSON, mapJsonAdapter.toJson(requestBody));
     Request request = new Request.Builder()
         .url("https://www.googleapis.com/urlshortener/v1/url?key=" + GOOGLE_API_KEY)
         .post(jsonRequestBody)
         .build();
 
-    Response response = client.newCall(request).execute();
-    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+    try (Response response = client.newCall(request).execute()) {
+      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
 
-    System.out.println(response.body().string());
+      System.out.println(response.body().string());
+    }
   }
 
   public static void main(String... args) throws Exception {
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/RewriteResponseCacheControl.java b/samples/guide/src/main/java/okhttp3/recipes/RewriteResponseCacheControl.java
similarity index 73%
rename from samples/guide/src/main/java/com/squareup/okhttp/recipes/RewriteResponseCacheControl.java
rename to samples/guide/src/main/java/okhttp3/recipes/RewriteResponseCacheControl.java
index 63f819e5e5..92d65d8169 100644
--- a/samples/guide/src/main/java/com/squareup/okhttp/recipes/RewriteResponseCacheControl.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/RewriteResponseCacheControl.java
@@ -13,15 +13,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.recipes;
+package okhttp3.recipes;
 
-import com.squareup.okhttp.Cache;
-import com.squareup.okhttp.Interceptor;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
 import java.io.File;
 import java.io.IOException;
+import okhttp3.Cache;
+import okhttp3.Interceptor;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
 
 public final class RewriteResponseCacheControl {
   /** Dangerous interceptor that rewrites the server's cache-control header. */
@@ -40,8 +40,9 @@ public RewriteResponseCacheControl(File cacheDirectory) throws Exception {
     Cache cache = new Cache(cacheDirectory, 1024 * 1024);
     cache.evictAll();
 
-    client = new OkHttpClient();
-    client.setCache(cache);
+    client = new OkHttpClient.Builder()
+        .cache(cache)
+        .build();
   }
 
   public void run() throws Exception {
@@ -52,22 +53,25 @@ public void run() throws Exception {
           .url("https://api.github.com/search/repositories?q=http")
           .build();
 
+      OkHttpClient clientForCall;
       if (i == 2) {
         // Force this request's response to be written to the cache. This way, subsequent responses
         // can be read from the cache.
         System.out.println("Force cache: true");
-        client.networkInterceptors().add(REWRITE_CACHE_CONTROL_INTERCEPTOR);
+        clientForCall = client.newBuilder()
+            .addNetworkInterceptor(REWRITE_CACHE_CONTROL_INTERCEPTOR)
+            .build();
       } else {
         System.out.println("Force cache: false");
-        client.networkInterceptors().clear();
+        clientForCall = client;
       }
 
-      Response response = client.newCall(request).execute();
-      response.body().close();
-      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+      try (Response response = clientForCall.newCall(request).execute()) {
+        if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
 
-      System.out.println("    Network: " + (response.networkResponse() != null));
-      System.out.println();
+        System.out.println("    Network: " + (response.networkResponse() != null));
+        System.out.println();
+      }
     }
   }
 
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/SynchronousGet.java b/samples/guide/src/main/java/okhttp3/recipes/SynchronousGet.java
similarity index 63%
rename from samples/guide/src/main/java/com/squareup/okhttp/recipes/SynchronousGet.java
rename to samples/guide/src/main/java/okhttp3/recipes/SynchronousGet.java
index 6b4cecbe13..38c91a50c2 100644
--- a/samples/guide/src/main/java/com/squareup/okhttp/recipes/SynchronousGet.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/SynchronousGet.java
@@ -13,13 +13,13 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.recipes;
+package okhttp3.recipes;
 
-import com.squareup.okhttp.Headers;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
 import java.io.IOException;
+import okhttp3.Headers;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
 
 public final class SynchronousGet {
   private final OkHttpClient client = new OkHttpClient();
@@ -29,15 +29,16 @@ public void run() throws Exception {
         .url("https://publicobject.com/helloworld.txt")
         .build();
 
-    Response response = client.newCall(request).execute();
-    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+    try (Response response = client.newCall(request).execute()) {
+      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
 
-    Headers responseHeaders = response.headers();
-    for (int i = 0; i < responseHeaders.size(); i++) {
-      System.out.println(responseHeaders.name(i) + ": " + responseHeaders.value(i));
-    }
+      Headers responseHeaders = response.headers();
+      for (int i = 0; i < responseHeaders.size(); i++) {
+        System.out.println(responseHeaders.name(i) + ": " + responseHeaders.value(i));
+      }
 
-    System.out.println(response.body().string());
+      System.out.println(response.body().string());
+    }
   }
 
   public static void main(String... args) throws Exception {
diff --git a/samples/guide/src/main/java/okhttp3/recipes/WebSocketEcho.java b/samples/guide/src/main/java/okhttp3/recipes/WebSocketEcho.java
new file mode 100644
index 0000000000..c7ee9438b0
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/WebSocketEcho.java
@@ -0,0 +1,74 @@
+package okhttp3.recipes;
+
+import java.io.IOException;
+import java.util.concurrent.Executor;
+import java.util.concurrent.Executors;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+import okhttp3.ws.WebSocket;
+import okhttp3.ws.WebSocketCall;
+import okhttp3.ws.WebSocketListener;
+import okio.Buffer;
+import okio.ByteString;
+
+import static okhttp3.ws.WebSocket.BINARY;
+import static okhttp3.ws.WebSocket.TEXT;
+
+public final class WebSocketEcho implements WebSocketListener {
+  private final Executor writeExecutor = Executors.newSingleThreadExecutor();
+
+  private void run() throws IOException {
+    OkHttpClient client = new OkHttpClient();
+
+    Request request = new Request.Builder()
+        .url("ws://echo.websocket.org")
+        .build();
+    WebSocketCall.create(client, request).enqueue(this);
+
+    // Trigger shutdown of the dispatcher's executor so this process can exit cleanly.
+    client.dispatcher().executorService().shutdown();
+  }
+
+  @Override public void onOpen(final WebSocket webSocket, Response response) {
+    writeExecutor.execute(new Runnable() {
+      @Override public void run() {
+        try {
+          webSocket.sendMessage(RequestBody.create(TEXT, "Hello..."));
+          webSocket.sendMessage(RequestBody.create(TEXT, "...World!"));
+          webSocket.sendMessage(RequestBody.create(BINARY, ByteString.decodeHex("deadbeef")));
+          webSocket.close(1000, "Goodbye, World!");
+        } catch (IOException e) {
+          System.err.println("Unable to send messages: " + e.getMessage());
+        }
+      }
+    });
+  }
+
+  @Override public void onMessage(ResponseBody message) throws IOException {
+    if (message.contentType() == TEXT) {
+      System.out.println("MESSAGE: " + message.string());
+    } else {
+      System.out.println("MESSAGE: " + message.source().readByteString().hex());
+    }
+    message.close();
+  }
+
+  @Override public void onPong(Buffer payload) {
+    System.out.println("PONG: " + payload.readUtf8());
+  }
+
+  @Override public void onClose(int code, String reason) {
+    System.out.println("CLOSE: " + code + " " + reason);
+  }
+
+  @Override public void onFailure(IOException e, Response response) {
+    e.printStackTrace();
+  }
+
+  public static void main(String... args) throws IOException {
+    new WebSocketEcho().run();
+  }
+}
diff --git a/samples/pom.xml b/samples/pom.xml
index 83b45a98e1..de77532ea5 100644
--- a/samples/pom.xml
+++ b/samples/pom.xml
@@ -4,12 +4,12 @@
   <modelVersion>4.0.0</modelVersion>
 
   <parent>
-    <groupId>com.squareup.okhttp</groupId>
+    <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>2.4.0-SNAPSHOT</version>
+    <version>3.4.0-SNAPSHOT</version>
   </parent>
 
-  <groupId>com.squareup.okhttp.sample</groupId>
+  <groupId>com.squareup.okhttp3.sample</groupId>
   <artifactId>sample-parent</artifactId>
   <packaging>pom</packaging>
   <name>Samples (Parent)</name>
@@ -20,4 +20,19 @@
     <module>simple-client</module>
     <module>static-server</module>
   </modules>
+
+  <build>
+    <plugins>
+      <plugin>
+        <!-- Fails on Throwable.addSuppressed() in ARM blocks. -->
+        <groupId>org.codehaus.mojo</groupId>
+        <artifactId>animal-sniffer-maven-plugin</artifactId>
+        <executions>
+          <execution>
+            <phase>none</phase>
+          </execution>
+        </executions>
+      </plugin>
+    </plugins>
+  </build>
 </project>
diff --git a/samples/simple-client/pom.xml b/samples/simple-client/pom.xml
index e3cb146fbd..5bb5efe414 100644
--- a/samples/simple-client/pom.xml
+++ b/samples/simple-client/pom.xml
@@ -4,9 +4,9 @@
   <modelVersion>4.0.0</modelVersion>
 
   <parent>
-    <groupId>com.squareup.okhttp.sample</groupId>
+    <groupId>com.squareup.okhttp3.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>2.4.0-SNAPSHOT</version>
+    <version>3.4.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>simple-client</artifactId>
@@ -14,14 +14,14 @@
 
   <dependencies>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>com.squareup.okhttp3</groupId>
       <artifactId>okhttp</artifactId>
       <version>${project.version}</version>
     </dependency>
 
     <dependency>
-      <groupId>com.google.code.gson</groupId>
-      <artifactId>gson</artifactId>
+      <groupId>com.squareup.moshi</groupId>
+      <artifactId>moshi</artifactId>
     </dependency>
   </dependencies>
 </project>
diff --git a/samples/simple-client/src/main/java/com/squareup/okhttp/sample/OkHttpContributors.java b/samples/simple-client/src/main/java/okhttp3/sample/OkHttpContributors.java
similarity index 65%
rename from samples/simple-client/src/main/java/com/squareup/okhttp/sample/OkHttpContributors.java
rename to samples/simple-client/src/main/java/okhttp3/sample/OkHttpContributors.java
index e616d41d51..ec9019110b 100644
--- a/samples/simple-client/src/main/java/com/squareup/okhttp/sample/OkHttpContributors.java
+++ b/samples/simple-client/src/main/java/okhttp3/sample/OkHttpContributors.java
@@ -1,21 +1,21 @@
-package com.squareup.okhttp.sample;
-
-import com.google.gson.Gson;
-import com.google.gson.reflect.TypeToken;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
-import java.io.Reader;
+package okhttp3.sample;
+
+import com.squareup.moshi.JsonAdapter;
+import com.squareup.moshi.Moshi;
+import com.squareup.moshi.Types;
 import java.util.Collections;
 import java.util.Comparator;
 import java.util.List;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
 
 public class OkHttpContributors {
   private static final String ENDPOINT = "https://api.github.com/repos/square/okhttp/contributors";
-  private static final Gson GSON = new Gson();
-  private static final TypeToken<List<Contributor>> CONTRIBUTORS =
-      new TypeToken<List<Contributor>>() {
-      };
+  private static final Moshi MOSHI = new Moshi.Builder().build();
+  private static final JsonAdapter<List<Contributor>> CONTRIBUTORS_JSON_ADAPTER = MOSHI.adapter(
+      Types.newParameterizedType(List.class, Contributor.class));
 
   static class Contributor {
     String login;
@@ -34,8 +34,9 @@ public static void main(String... args) throws Exception {
     Response response = client.newCall(request).execute();
 
     // Deserialize HTTP response to concrete type.
-    Reader body = response.body().charStream();
-    List<Contributor> contributors = GSON.fromJson(body, CONTRIBUTORS.getType());
+    ResponseBody body = response.body();
+    List<Contributor> contributors = CONTRIBUTORS_JSON_ADAPTER.fromJson(body.source());
+    body.close();
 
     // Sort list by the most contributions.
     Collections.sort(contributors, new Comparator<Contributor>() {
diff --git a/samples/static-server/pom.xml b/samples/static-server/pom.xml
index 9771c9e7da..dc446c5a2b 100644
--- a/samples/static-server/pom.xml
+++ b/samples/static-server/pom.xml
@@ -4,9 +4,9 @@
   <modelVersion>4.0.0</modelVersion>
 
   <parent>
-    <groupId>com.squareup.okhttp.sample</groupId>
+    <groupId>com.squareup.okhttp3.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>2.4.0-SNAPSHOT</version>
+    <version>3.4.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>static-server</artifactId>
@@ -14,7 +14,7 @@
 
   <dependencies>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>com.squareup.okhttp3</groupId>
       <artifactId>mockwebserver</artifactId>
       <version>${project.version}</version>
     </dependency>
@@ -33,7 +33,7 @@
           <transformers>
             <transformer implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer">
               <manifestEntries>
-                <Main-Class>com.squareup.okhttp.sample.SampleServer</Main-Class>
+                <Main-Class>okhttp3.sample.SampleServer</Main-Class>
               </manifestEntries>
             </transformer>
           </transformers>
@@ -51,7 +51,9 @@
         <executions>
           <execution>
             <phase>package</phase>
-            <goals><goal>shade</goal></goals>
+            <goals>
+              <goal>shade</goal>
+            </goals>
           </execution>
         </executions>
       </plugin>
diff --git a/samples/static-server/src/main/java/com/squareup/okhttp/sample/SampleServer.java b/samples/static-server/src/main/java/okhttp3/sample/SampleServer.java
similarity index 94%
rename from samples/static-server/src/main/java/com/squareup/okhttp/sample/SampleServer.java
rename to samples/static-server/src/main/java/okhttp3/sample/SampleServer.java
index a2fd19d424..e21432ed20 100644
--- a/samples/static-server/src/main/java/com/squareup/okhttp/sample/SampleServer.java
+++ b/samples/static-server/src/main/java/okhttp3/sample/SampleServer.java
@@ -1,10 +1,5 @@
-package com.squareup.okhttp.sample;
+package okhttp3.sample;
 
-import com.squareup.okhttp.internal.Util;
-import com.squareup.okhttp.mockwebserver.Dispatcher;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-import com.squareup.okhttp.mockwebserver.RecordedRequest;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
@@ -16,6 +11,11 @@
 import javax.net.ssl.KeyManagerFactory;
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.TrustManagerFactory;
+import okhttp3.internal.Util;
+import okhttp3.mockwebserver.Dispatcher;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
 import okio.Buffer;
 import okio.Okio;
 
diff --git a/website/index.html b/website/index.html
index 86695a403a..ff9ec474b3 100644
--- a/website/index.html
+++ b/website/index.html
@@ -4,7 +4,7 @@
     <meta charset="utf-8">
     <title>OkHttp</title>
     <meta name="viewport" content="width=device-width, initial-scale=1.0">
-    <meta name="description" content="An HTTP &amp; SPDY client for Android and Java applications">
+    <meta name="description" content="An HTTP &amp; HTTP/2 client for Android and Java applications">
     <link href="static/bootstrap-combined.min.css" rel="stylesheet">
     <link href="static/app.css" rel="stylesheet">
     <link href="static/app-theme.css" rel="stylesheet">
@@ -33,7 +33,7 @@ <h1>OkHttp</h1>
       <div class="container">
         <div class="row">
           <div class="span12">
-            <h2>An <strong>HTTP &amp; SPDY</strong> client for Android and Java applications</h2>
+            <h2>An <strong>HTTP &amp; HTTP/2</strong> client for Android and Java applications</h2>
           </div>
         </div>
       </div>
@@ -48,8 +48,8 @@ <h3 id="overview">Overview</h3>
 
             <p>OkHttp is an HTTP client that’s efficient by default:</p>
             <ul>
-                <li>HTTP/2 and SPDY support allows all requests to the same host to share a socket.</li>
-                <li>Connection pooling reduces request latency (if SPDY isn’t available).</li>
+                <li>HTTP/2 support allows all requests to the same host to share a socket.</li>
+                <li>Connection pooling reduces request latency (if HTTP/2 isn’t available).</li>
                 <li>Transparent GZIP shrinks download sizes.</li>
                 <li>Response caching avoids the network completely for repeat requests.</li>
             </ul>
@@ -61,20 +61,15 @@ <h3 id="overview">Overview</h3>
                 with modern TLS features (SNI, ALPN), and falls back to TLS 1.0 if the handshake
                 fails.</p>
 
-            <p>Using OkHttp is easy. Its 2.0 API is designed with fluent builders and
+            <p>Using OkHttp is easy. Its request/response API is designed with fluent builders and
                 immutability. It supports both synchronous blocking calls and async calls with
                 callbacks.</p>
 
-            <p>You can try out OkHttp without rewriting your network code. The
-                <code>okhttp-urlconnection</code> module implements the familiar
-                <code>java.net.HttpURLConnection</code> API and the <code>okhttp-apache</code>
-                module implements the Apache <code>HttpClient</code> API.</p>
-
             <p>OkHttp supports Android 2.3 and above. For Java, the minimum requirement is 1.7.</p>
 
             <h3 id="examples">Examples</h3>
             <h4>Get a URL</h4>
-            <p>This program downloads a URL and print its contents as a string. <a href="https://raw.github.com/square/okhttp/master/samples/guide/src/main/java/com/squareup/okhttp/guide/GetExample.java">Full source</a>.
+            <p>This program downloads a URL and print its contents as a string. <a href="https://raw.github.com/square/okhttp/master/samples/guide/src/main/java/okhttp3/guide/GetExample.java">Full source</a>.
 <pre class="prettyprint">
 OkHttpClient client = new OkHttpClient();
 
@@ -88,7 +83,7 @@ <h4>Get a URL</h4>
 }
 </pre>
             <h4>Post to a Server</h4>
-            <p>This program posts data to a service. <a href="https://raw.github.com/square/okhttp/master/samples/guide/src/main/java/com/squareup/okhttp/guide/PostExample.java">Full source</a>.
+            <p>This program posts data to a service. <a href="https://raw.github.com/square/okhttp/master/samples/guide/src/main/java/okhttp3/guide/PostExample.java">Full source</a>.
 
 <pre class="prettyprint">
 public static final MediaType JSON
@@ -108,7 +103,7 @@ <h4>Post to a Server</h4>
 </pre>
 
             <h3 id="download">Download</h3>
-            <p><a href="https://search.maven.org/remote_content?g=com.squareup.okhttp&a=okhttp&v=LATEST" class="dl version-href">&darr; <span class="version-tag">Latest</span> JAR</a></p>
+            <p><a href="https://search.maven.org/remote_content?g=com.squareup.okhttp3&a=okhttp&v=LATEST" class="dl version-href">&darr; <span class="version-tag">Latest</span> JAR</a></p>
             <p>You'll also need <a href="http://github.com/square/okio">Okio</a>, which OkHttp
                 uses for fast I/O and resizable buffers. Download the
                 <a href="https://search.maven.org/remote_content?g=com.squareup.okio&a=okio&v=LATEST">latest JAR</a>.
@@ -116,13 +111,13 @@ <h3 id="download">Download</h3>
 
             <h4>Maven</h4>
             <pre class="prettyprint">&lt;dependency>
-  &lt;groupId>com.squareup.okhttp&lt;/groupId>
+  &lt;groupId>com.squareup.okhttp3&lt;/groupId>
   &lt;artifactId>okhttp&lt;/artifactId>
   &lt;version><span class="version pln"><em>(insert latest version)</em></span>&lt;/version>
 &lt;/dependency></pre>
 
             <h4>Gradle</h4>
-            <pre class="prettyprint">compile 'com.squareup.okhttp:okhttp:<span class="version pln"><em>(insert latest version)</em></span>'</pre>
+            <pre class="prettyprint">compile 'com.squareup.okhttp3:okhttp:<span class="version pln"><em>(insert latest version)</em></span>'</pre>
 
             <h3 id="contributing">Contributing</h3>
             <p>If you would like to contribute code you can do so through GitHub by forking the repository and sending a pull request.</p>
@@ -130,7 +125,7 @@ <h3 id="contributing">Contributing</h3>
             <p>Before your code can be accepted into the project you must also sign the <a href="http://squ.re/sign-the-cla">Individual Contributor License Agreement (CLA)</a>.</p>
 
             <h3 id="license">License</h3>
-            <pre>Copyright 2014 Square, Inc.
+            <pre>Copyright 2016 Square, Inc.
 
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
@@ -155,7 +150,7 @@ <h3 id="license">License</h3>
               </ul>
               <ul class="nav nav-pills nav-stacked secondary">
                 <li><a href="https://github.com/square/okhttp/wiki">Wiki</a></li>
-                <li><a href="javadoc/index.html">Javadoc</a></li>
+                <li><a href="3.x/okhttp/">Javadoc</a></li>
                 <li><a href="http://stackoverflow.com/questions/tagged/okhttp?sort=active">StackOverflow</a></li>
               </ul>
             </div>
@@ -197,7 +192,7 @@ <h3 id="license">License</h3>
 
         // Look up the latest version of the library.
         $.fn.artifactVersion({
-          'groupId': 'com.squareup.okhttp',
+          'groupId': 'com.squareup.okhttp3',
           'artifactId': 'okhttp'
         }, function(version, url) {
           $('.version').text(version);
