diff --git a/okhttp/src/main/java/com/squareup/okhttp/Call.java b/okhttp/src/main/java/com/squareup/okhttp/Call.java
index ed7b6a58e6..4821ea2441 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Call.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Call.java
@@ -27,6 +27,7 @@
 import static com.squareup.okhttp.internal.http.HttpEngine.MAX_FOLLOW_UPS;
 
 /**
+ * 一个Call是一个已经准备好执行的Request，yigeCall可以被取消。因为该类表示单个请求/响应对，所以，只能执行一次。
  * A call is a request that has been prepared for execution. A call can be
  * canceled. As this object represents a single request/response pair (stream),
  * it cannot be executed twice.
@@ -39,6 +40,7 @@
   volatile boolean canceled;
 
   /** The application's original request unadulterated by redirects or auth headers. */
+  /** 从重定向或者Auth认证Header过来的纯正原始请求 */
   Request originalRequest;
   HttpEngine engine;
 
@@ -50,13 +52,20 @@ protected Call(OkHttpClient client, Request originalRequest) {
   }
 
   /**
+   * 立即开始请求,并阻塞，直到响应可以被处理或者是以错误结束.
    * Invokes the request immediately, and blocks until the response can be
    * processed or is in error.
    *
+   *
+   * <p>Caller可以通过response的body方法读取response的body，为了便于连接回收，Caller需要关闭reponse的body。
+   *
    * <p>The caller may read the response body with the response's
    * {@link Response#body} method.  To facilitate connection recycling, callers
    * should always {@link ResponseBody#close() close the response body}.
    *
+   *
+   * <p>需要注意的是传送层成功（接收一个HTTP响应代码，标头和身体）并不一定表示应用层的成功：
+   * 响应可能仍表示相同的404或500不愉快的HTTP响应代码。
    * <p>Note that transport-layer success (receiving a HTTP response code,
    * headers and body) does not necessarily indicate application-layer success:
    * {@code response} may still indicate an unhappy HTTP response code like 404
@@ -67,7 +76,10 @@ protected Call(OkHttpClient client, Request originalRequest) {
    *     fail during an exchange, it is possible that the remote server
    *     accepted the request before the failure.
    *
-   * @throws IllegalStateException when the call has already been executed.
+   *     如果因为该请求因为被取消、连接失败、超时等原因而不能被执行，就抛出IOException。
+   *     因为网络可能在任何一次数据交换时失败，所以远程服务可能已经在客户端得到失败结果前接受了这次请求。
+   *
+   * @throws IllegalStateException when the call has already been executed.如果这个Call已经被执行过了，就抛出IllegalStateException
    */
   public Response execute() throws IOException {
     synchronized (this) {
@@ -90,16 +102,24 @@ Object tag() {
 
   /**
    * Schedules the request to be executed at some point in the future.
+   * 安排请求在未来的某个时候被执行。
    *
    * <p>The {@link OkHttpClient#getDispatcher dispatcher} defines when the
    * request will run: usually immediately unless there are several other
    * requests currently being executed.
    *
+   * <p>{@link OkHttpClient#getDispatcher dispatcher} 决定该请求将在合适被执行。
+   * 如果没有其他几个请求正在被执行，通常会立即被执行。
+   *
    * <p>This client will later call back {@code responseCallback} with either
    * an HTTP response or a failure exception. If you {@link #cancel} a request
    * before it completes the callback will not be invoked.
    *
+   * <p>客户端稍后会得到一个HTTP请求成功的response回调，或者是一个失败的异常。如果你在完成之前取消了该请求，
+   * 那么回调不会被调用。
+   *
    * @throws IllegalStateException when the call has already been executed.
+   * 如果这个Call已经被执行过了，就抛出IllegalStateException
    */
   public void enqueue(Callback responseCallback) {
     enqueue(responseCallback, false);
@@ -114,6 +134,7 @@ void enqueue(Callback responseCallback, boolean forWebSocket) {
   }
 
   /**
+   * 尝试取消请求。已经完成的请求无法被取消掉。
    * Cancels the request, if possible. Requests that are already complete
    * cannot be canceled.
    */
@@ -182,6 +203,7 @@ Call get() {
   }
 
   /**
+   * 返回一个用来描述该call的字符串。因为有可能泄露敏感信息，这里面不包含完整的URL。
    * Returns a string that describes this call. Doesn't include a full URL as that might contain
    * sensitive information.
    */
@@ -217,6 +239,9 @@ private Response getResponseWithInterceptorChain(boolean forWebSocket) throws IO
 
     @Override public Response proceed(Request request) throws IOException {
       // If there's another interceptor in the chain, call that.
+      //如果存在其他拦截器，调用他
+      //先判断是否每个拦截器都有对应的处理，没有的话先继续新建ApplicationInterceptorChain ，并执行当前拦截器的intercept方法
+      //就会去判断是否有拦截器有的话先执行拦截器里的intercept，而在intercept里一般会进行一些自定义操作并且调用procced去判断是否要继续执行拦截器操作还是直接去获取网络请求
       if (index < client.interceptors().size()) {
         Interceptor.Chain chain = new ApplicationInterceptorChain(index + 1, request, forWebSocket);
         Interceptor interceptor = client.interceptors().get(index);
@@ -230,19 +255,23 @@ private Response getResponseWithInterceptorChain(boolean forWebSocket) throws IO
         return interceptedResponse;
       }
 
+      //没有更多的拦截器了，执行HTTP请求
       // No more interceptors. Do HTTP.
       return getResponse(request, forWebSocket);
     }
   }
 
   /**
+   *执行网络请求得到Response。如果该请求被取消了，可能会返回null。
    * Performs the request and returns the response. May return null if this
    * call was canceled.
    */
   Response getResponse(Request request, boolean forWebSocket) throws IOException {
     // Copy body metadata to the appropriate request headers.
+    // 把body的一些的元数据复制到相应的请求头。
     RequestBody body = request.body();
     if (body != null) {
+      //如果是post方式（Body不为空），处理一些头部信息
       Request.Builder requestBuilder = request.newBuilder();
 
       MediaType contentType = body.contentType();
@@ -263,6 +292,7 @@ Response getResponse(Request request, boolean forWebSocket) throws IOException {
     }
 
     // Create the initial HTTP engine. Retries and redirects need new engine for each attempt.
+    //新建HttpEngine，用于进行发送请求和读取答复的细节处理，重试和重定向的每次尝试，都需要新的引擎。
     engine = new HttpEngine(client, request, false, false, forWebSocket, null, null, null, null);
 
     int followUpCount = 0;
@@ -300,6 +330,7 @@ Response getResponse(Request request, boolean forWebSocket) throws IOException {
       }
 
       Response response = engine.getResponse();
+      //得到该请求对应的后续请求，比如重定向之类的
       Request followUp = engine.followUpRequest();
 
       if (followUp == null) {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Connection.java b/okhttp/src/main/java/com/squareup/okhttp/Connection.java
index 1c6188d3d7..bf1af63f54 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Connection.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Connection.java
@@ -155,6 +155,7 @@ void connect(int connectTimeout, int readTimeout, int writeTimeout,
     if (connected) throw new IllegalStateException("already connected");
 
     RouteException routeException = null;
+    //建立Socket连接器
     ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);
     Proxy proxy = route.getProxy();
     Address address = route.getAddress();
@@ -206,6 +207,7 @@ private void connectSocket(int connectTimeout, int readTimeout, int writeTimeout
           .protocol(protocol).build();
       framedConnection.sendConnectionPreface();
     } else {
+      //建立httpConnection
       httpConnection = new HttpConnection(pool, this, socket);
     }
   }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java b/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java
index a9346701fb..7bc72ebad8 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java
@@ -27,8 +27,13 @@
 import java.util.concurrent.TimeUnit;
 
 /**
+ * 异步请求的策略
  * Policy on when async requests are executed.
  *
+ * <p>每个调度者使用一个{@link ExecutorService} 在内部执行请求（calls）。如果你提供了自己的执行者，
+ * 它应该可以同时运行{@linkplain #getMaxRequests the configured maximum}数量的请求。
+ *
+ *
  * <p>Each dispatcher uses an {@link ExecutorService} to run calls internally. If you
  * supply your own executor, it should be able to run {@linkplain #getMaxRequests the
  * configured maximum} number of calls concurrently.
@@ -38,12 +43,15 @@
   private int maxRequestsPerHost = 5;
 
   /** Executes calls. Created lazily. */
+  /** 执行请求(连接池)，懒加载 */
   private ExecutorService executorService;
 
   /** Ready calls in the order they'll be run. */
+  /** 在排队中的请求 */
   private final Deque<AsyncCall> readyCalls = new ArrayDeque<>();
 
   /** Running calls. Includes canceled calls that haven't finished yet. */
+  /** 正在执行的请求，包括在还没有执行完就被取消的请求 */
   private final Deque<AsyncCall> runningCalls = new ArrayDeque<>();
 
   /** In-flight synchronous calls. Includes canceled calls that haven't finished yet. */
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Protocol.java b/okhttp/src/main/java/com/squareup/okhttp/Protocol.java
index 6b02098133..3d3e8cd9d9 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Protocol.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Protocol.java
@@ -18,6 +18,8 @@
 import java.io.IOException;
 
 /**
+ * 网络协议的枚举
+ *
  * Protocols that OkHttp implements for <a
  * href="http://tools.ietf.org/html/draft-ietf-tls-applayerprotoneg">ALPN</a>
  * selection.
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Request.java b/okhttp/src/main/java/com/squareup/okhttp/Request.java
index 2417c132aa..8532bd150c 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Request.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Request.java
@@ -22,6 +22,8 @@
 import java.util.List;
 
 /**
+ * 一个网络请求，如果他们的body是空或者他本身不可变，该类的实例是不可变的。
+ *
  * An HTTP request. Instances of this class are immutable if their {@link #body}
  * is null or itself immutable.
  */
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/NamedRunnable.java b/okhttp/src/main/java/com/squareup/okhttp/internal/NamedRunnable.java
index 7a02ecfbde..f64b63c02b 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/NamedRunnable.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/NamedRunnable.java
@@ -18,6 +18,7 @@
 
 /**
  * Runnable implementation which always sets its thread name.
+ * 一个一直带有自己线程名字的Runnable。
  */
 public abstract class NamedRunnable implements Runnable {
   protected final String name;
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/Platform.java b/okhttp/src/main/java/com/squareup/okhttp/internal/Platform.java
index 4e578aef0f..b949b5d792 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/Platform.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/Platform.java
@@ -36,7 +36,7 @@
 
 /**
  * Access to platform-specific features.
- *
+ * 做平台适应性，针对Android2.3到5.0的网络请求的适配支持。
  * <h3>Server name indication (SNI)</h3>
  * Supported on Android 2.3+.
  *
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
index a7b577a211..6c8590e62e 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
@@ -73,6 +73,15 @@
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 
 /**
+ *
+ * 处理一个HTTP请求/响应对。每个HTTP引擎遵循这一生命周期：
+ * <li>被创建
+ * <li>HTTP请求通过{@code sendRequest()}被发送.请求一旦被发送，再修改请求的Headers将会发生错误。在{@code sendRequest()}
+ * 被调用后，请求的body是可以被写入的（如果存在）。
+ * <li>
+ *
+ *
+ *
  * Handles a single HTTP request/response pair. Each HTTP engine follows this
  * lifecycle:
  * <ol>
@@ -92,6 +101,7 @@
  */
 public final class HttpEngine {
   /**
+   * 我们应该进行多少次重定向和认证挑战的尝试？（多少次重试）
    * How many redirects and auth challenges should we attempt? Chrome follows 21 redirects; Firefox,
    * curl, and wget follow 20; Safari follows 16; and HTTP/1.0 recommends 5.
    */
@@ -169,6 +179,7 @@
   private final boolean forWebSocket;
 
   /** The cache request currently being populated from a network response. */
+  //一个正在从网络response转化过来的缓存请求
   private CacheRequest storeRequest;
   private CacheStrategy cacheStrategy;
 
@@ -208,12 +219,16 @@ public HttpEngine(OkHttpClient client, Request request, boolean bufferRequestBod
    * Figures out what the response source will be, and opens a socket to that
    * source if necessary. Prepares the request headers and gets ready to start
    * writing the request body if it exists.
+   * 计算出反应源是什么，并在必要时打开一个套接字的来源。准备好请求头，并准备好开始写请求body（如果存在）
    *
-   * @throws RequestException if there was a problem with request setup. Unrecoverable.
+   * @throws RequestException if there was a problem with request setup. Unrecoverable
+   * .如果请求的设置有一个问题，抛出该异常。不可会瘦的。
    * @throws RouteException if the was a problem during connection via a specific route. Sometimes
    *     recoverable. See {@link #recover(RouteException)}.
+   *     如果在通过一个路由器进行连接的过程中出错了，抛出该异常，有时是可以挽回的。
    * @throws IOException if there was a problem while making a request. Sometimes recoverable. See
    *     {@link #recover(IOException)}.
+   *     如果在只做一个Request的过程中出错，抛出该异常。
    *
    */
   public void sendRequest() throws RequestException, RouteException, IOException {
@@ -222,7 +237,9 @@ public void sendRequest() throws RequestException, RouteException, IOException {
 
     Request request = networkRequest(userRequest);
 
+    //得到该Client的缓存
     InternalCache responseCache = Internal.instance.internalCache(client);
+    //得到一个候选缓存
     Response cacheCandidate = responseCache != null
         ? responseCache.get(request)
         : null;
@@ -242,16 +259,18 @@ public void sendRequest() throws RequestException, RouteException, IOException {
 
     if (networkRequest != null) {
       // Open a connection unless we inherited one from a redirect.
+      // 打开一个连接，除非我们继承了一个来自重定向。
       if (connection == null) {
         connect();
       }
-
+      //得到HttpTransport(Http请求)
       transport = Internal.instance.newTransport(connection, this);
 
       // If the caller's control flow writes the request body, we need to create that stream
       // immediately. And that means we need to immediately write the request headers, so we can
       // start streaming the request body. (We may already have a request body if we're retrying a
       // failed POST.)
+      //根据条件将一些执行请求头部的写入，具体的写入会调动到httpConnection的sink（就是一个socket请求的outputstream）去write
       if (callerWritesRequestBody && permitsRequestBody(networkRequest) && requestBodyOut == null) {
         long contentLength = OkHeaders.contentLength(request);
         if (bufferRequestBody) {
@@ -270,27 +289,28 @@ public void sendRequest() throws RequestException, RouteException, IOException {
             // Content-Length header correctly.
             requestBodyOut = new RetryableSink();
           }
-        } else {
+        } else {//进入这个判断说明不需要走网络请求，直接读取缓存
           transport.writeRequestHeaders(networkRequest);
           requestBodyOut = transport.createRequestBody(networkRequest, contentLength);
         }
       }
 
     } else {
+      //我们没有使用网络。再有可能来自于一个重定向时，回收一个网络连接(原始请求创建的）。
       // We aren't using the network. Recycle a connection we may have inherited from a redirect.
       if (connection != null) {
         Internal.instance.recycle(client.getConnectionPool(), connection);
         connection = null;
       }
 
-      if (cacheResponse != null) {
+      if (cacheResponse != null) {//组装缓存数据成Response
         // We have a valid cached response. Promote it to the user response immediately.
         this.userResponse = cacheResponse.newBuilder()
             .request(userRequest)
             .priorResponse(stripBody(priorResponse))
             .cacheResponse(stripBody(cacheResponse))
             .build();
-      } else {
+      } else {//我们不能使用网络、但之前又没有充分的缓存则抛出 504的Response
         // We're forbidden from using the network, and the cache is insufficient.
         this.userResponse = new Response.Builder()
             .request(userRequest)
@@ -301,7 +321,7 @@ public void sendRequest() throws RequestException, RouteException, IOException {
             .body(EMPTY_BODY)
             .build();
       }
-
+      //解压请求结果
       userResponse = unzip(userResponse);
     }
   }
@@ -312,28 +332,36 @@ private static Response stripBody(Response response) {
         : response;
   }
 
-  /** Connect to the origin server either directly or via a proxy. */
+  /** Connect to the origin server either directly or via a proxy.
+   * 直接或者通过一个代理连接到远程服务器
+   * */
   private void connect() throws RequestException, RouteException {
     if (connection != null) throw new IllegalStateException();
 
     if (routeSelector == null) {
+      //建立一个Address,用来记录web服务器，以及要连接服务器需要的一些静态配置比如端口号，网络协议等
       address = createAddress(client, networkRequest);
       try {
+        //得到路由选择器，用于记录连接服务器的一些动态配置，比如查询DNS的ip，代理服务器,TLS协议版本
         routeSelector = RouteSelector.get(address, networkRequest, client);
       } catch (IOException e) {
         throw new RequestException(e);
       }
     }
 
+    //得到httpConnection
     connection = createNextConnection();
+    //将connection设置到okhttpclient
     Internal.instance.connectAndSetOwner(client, connection, this);
     route = connection.getRoute();
   }
 
   private Connection createNextConnection() throws RouteException {
+    //拿到连接池，如果用户没有设置pool，将得到默认的ConnectionPool
     ConnectionPool pool = client.getConnectionPool();
 
     // Always prefer pooled connections over new connections.
+    //相比新创建连接，往往更倾向于连接池中的连接
     for (Connection pooled; (pooled = pool.get(address)) != null; ) {
       if (networkRequest.method().equals("GET") || Internal.instance.isReadable(pooled)) {
         return pooled;
@@ -341,7 +369,7 @@ private Connection createNextConnection() throws RouteException {
       closeQuietly(pooled.getSocket());
     }
 
-    try {
+    try {//没有满足条件的Connection,只能建立新的connection
       Route route = routeSelector.next();
       return new Connection(pool, route);
     } catch (IOException e) {
@@ -682,10 +710,14 @@ public static boolean hasBody(Response response) {
   }
 
   /**
+   * 转化一下request，加入一些默认信息
+   *
+   * 用默认值和cookie填充请求
    * Populates request with defaults and cookies.
    *
    * <p>This client doesn't specify a default {@code Accept} header because it
    * doesn't know what content types the application is interested in.
+   * 由于不知道Application对什么内容类型感兴趣，该客户端不会指定一个默认的{@code Accept} header。
    */
   private Request networkRequest(Request request) throws IOException {
     Request.Builder result = request.newBuilder();
@@ -727,6 +759,8 @@ private Request networkRequest(Request request) throws IOException {
   /**
    * Flushes the remaining request header and body, parses the HTTP response
    * headers and starts reading the HTTP response body if it exists.
+   *
+   * 刷新剩余的请求头和身体，解析HTTP响应头并开始读取HTTP响应体(如果它存在的话)。
    */
   public void readResponse() throws IOException {
     if (userResponse != null) {
@@ -822,6 +856,9 @@ public void readResponse() throws IOException {
     }
   }
 
+  /**
+   *网络拦截器链条：
+   */
   class NetworkInterceptorChain implements Interceptor.Chain {
     private final int index;
     private final Request request;
