diff --git a/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java b/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java
index b07c9bb160..c6a84833dc 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java
@@ -143,17 +143,42 @@ public synchronized int getHttpConnectionCount() {
     return connections.size() - getMultiplexedConnectionCount();
   }
 
-  /** Returns a recycled connection to {@code address}, or null if no such connection exists. */
+  /**
+   * Returns a recycled connection to {@code address}, or null if no such connection exists.
+   * This will search for a non idle connection to use. If there are no non idle connections to
+   * recycle then it will search for an idle connection. If no such idle connection exists, null
+   * is returned.
+   */
   public synchronized Connection get(Address address) {
+    // Check for a non idle connection first
+    Connection connection = get(address, true);
+    if (connection == null) {
+      connection = get(address, false);
+    }
+    return connection;
+  }
+
+  /**
+   * Returns a recycled connection to {@code address}, or null if no such connection exists.
+   *
+   * @param requireNonIdle true to only check for non idle connections
+   */
+  public synchronized Connection get(Address address, boolean requireNonIdle) {
     Connection foundConnection = null;
-    for (ListIterator<Connection> i = connections.listIterator(connections.size());
-        i.hasPrevious(); ) {
-      Connection connection = i.previous();
+    // Changed this to iterate in order instead of reverse order. This allows the most recently used
+    // connection to be used for subsequent requests, allowing idle connections to be removed from
+    // the pool.
+    for (ListIterator<Connection> i = connections.listIterator(); i.hasNext(); ) {
+      Connection connection = i.next();
       if (!connection.getRoute().getAddress().equals(address)
           || !connection.isAlive()
           || System.nanoTime() - connection.getIdleStartTimeNs() >= keepAliveDurationNs) {
         continue;
       }
+      if (requireNonIdle && connection.isIdle()) {
+        continue;
+      }
+
       i.remove();
       if (!connection.isSpdy()) {
         try {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
index bef0435b1b..09a9fa699c 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
@@ -102,6 +102,13 @@ public int getId() {
    * </ul>
    * Note that the input stream may continue to yield data even after a stream
    * reports itself as not open. This is because input data is buffered.
+   *
+   * A check was added to also signal streams to be marked as not open if they have no response
+   * headers but have been created by the server (usually via a SYN_STREAM frame). This is needed
+   * because when streams are created in this manner they are not required to receive a SYN_HEADERS
+   * frame per the 3.1 SPDY spec. They would use the headers that are in the `SYN_STREAM` frame.
+   * Streams created via transport push do not include a SYN_HEADERS before the FLAG_FIN so they
+   * will never have responseHeaders set, hence the reasoning for this check.
    */
   public synchronized boolean isOpen() {
     if (errorCode != null) {
@@ -109,7 +116,7 @@ public synchronized boolean isOpen() {
     }
     if ((source.finished || source.closed)
         && (sink.finished || sink.closed)
-        && responseHeaders != null) {
+        && (!isLocallyInitiated() || responseHeaders != null)) {
       return false;
     }
     return true;
