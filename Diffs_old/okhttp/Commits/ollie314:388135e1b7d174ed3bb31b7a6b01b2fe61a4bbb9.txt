diff --git a/CONTRIBUTING.md b/.github/CONTRIBUTING.md
similarity index 100%
rename from CONTRIBUTING.md
rename to .github/CONTRIBUTING.md
diff --git a/.github/ISSUE_TEMPLATE.md b/.github/ISSUE_TEMPLATE.md
new file mode 100644
index 0000000000..e65d371715
--- /dev/null
+++ b/.github/ISSUE_TEMPLATE.md
@@ -0,0 +1,12 @@
+What kind of issue is this?
+
+ - [ ] Question. This issue tracker is not the place for questions. If you want to ask how to do
+       something, or to understand why something isn't working the way you expect it to, use Stack
+       Overflow. https://stackoverflow.com/questions/tagged/okhttp
+
+ - [ ] Bug report. If you’ve found a bug, spend the time to write a failing test. Bugs with tests
+       get fixed. Here’s an example: https://gist.github.com/swankjesse/981fcae102f513eb13ed
+
+ - [ ] Feature Request. Start by telling us what problem you’re trying to solve. Often a solution
+       already exists! Don’t send pull requests to implement new features without first getting our
+       support. Sometimes we leave features out on purpose to keep the project small.
diff --git a/okhttp-tests/src/test/java/okhttp3/CallTest.java b/okhttp-tests/src/test/java/okhttp3/CallTest.java
index 08af3bc11a..3cb960f4bf 100644
--- a/okhttp-tests/src/test/java/okhttp3/CallTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CallTest.java
@@ -31,6 +31,7 @@
 import java.security.cert.Certificate;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.List;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.Callable;
@@ -2149,7 +2150,7 @@ private InetSocketAddress startNullServer() throws IOException {
     assertNull(connect.getHeader("Private"));
     assertEquals(Version.userAgent(), connect.getHeader("User-Agent"));
     assertEquals("Keep-Alive", connect.getHeader("Proxy-Connection"));
-    assertEquals("android.com", connect.getHeader("Host"));
+    assertEquals("android.com:443", connect.getHeader("Host"));
 
     RecordedRequest get = server.takeRequest();
     assertEquals("Secret", get.getHeader("Private"));
@@ -2355,6 +2356,38 @@ private void upload(
         .build());
   }
 
+  /** https://github.com/square/okhttp/issues/2344 */
+  @Test public void ipv6HostHasSquareBraces() throws Exception {
+    // Use a proxy to fake IPv6 connectivity, even if localhost doesn't have IPv6.
+    server.useHttps(sslContext.getSocketFactory(), true);
+    server.setProtocols(Collections.singletonList(Protocol.HTTP_1_1));
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
+        .clearHeaders());
+    server.enqueue(new MockResponse()
+        .setBody("response body"));
+
+    client = client.newBuilder()
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .proxy(server.toProxyAddress())
+        .build();
+
+    Request request = new Request.Builder()
+        .url("https://[::1]/")
+        .build();
+    Response response = client.newCall(request).execute();
+    assertEquals("response body", response.body().string());
+
+    RecordedRequest connect = server.takeRequest();
+    assertEquals("CONNECT [::1]:443 HTTP/1.1", connect.getRequestLine());
+    assertEquals("[::1]:443", connect.getHeader("Host"));
+
+    RecordedRequest get = server.takeRequest();
+    assertEquals("GET / HTTP/1.1", get.getRequestLine());
+    assertEquals("[::1]", get.getHeader("Host"));
+  }
+
   private RequestBody requestBody(final boolean chunked, final long size, final int writeSize) {
     final byte[] buffer = new byte[writeSize];
     Arrays.fill(buffer, (byte) 'x');
diff --git a/okhttp-tests/src/test/java/okhttp3/CertificateChainCleanerTest.java b/okhttp-tests/src/test/java/okhttp3/CertificateChainCleanerTest.java
index 6959f86b31..647ee1a327 100644
--- a/okhttp-tests/src/test/java/okhttp3/CertificateChainCleanerTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CertificateChainCleanerTest.java
@@ -15,7 +15,9 @@
  */
 package okhttp3;
 
+import java.security.GeneralSecurityException;
 import java.security.cert.Certificate;
+import java.security.cert.X509Certificate;
 import java.util.ArrayList;
 import java.util.List;
 import javax.net.ssl.SSLPeerUnverifiedException;
@@ -152,17 +154,17 @@
         council.clean(list(certB, certUnnecessary, certA, root)));
   }
 
-  @Test public void unnecessaryTrustedCertificatesAreOmitted() throws Exception {
-    HeldCertificate superRoot = new HeldCertificate.Builder()
+  @Test public void chainGoesAllTheWayToSelfSignedRoot() throws Exception {
+    HeldCertificate selfSigned = new HeldCertificate.Builder()
         .serialNumber("1")
         .build();
-    HeldCertificate root = new HeldCertificate.Builder()
+    HeldCertificate trusted = new HeldCertificate.Builder()
         .serialNumber("2")
-        .issuedBy(superRoot)
+        .issuedBy(selfSigned)
         .build();
     HeldCertificate certA = new HeldCertificate.Builder()
         .serialNumber("3")
-        .issuedBy(root)
+        .issuedBy(trusted)
         .build();
     HeldCertificate certB = new HeldCertificate.Builder()
         .serialNumber("4")
@@ -170,8 +172,79 @@
         .build();
 
     CertificateChainCleaner council = new CertificateChainCleaner(
-        new RealTrustRootIndex(superRoot.certificate, root.certificate));
-    assertEquals(list(certB, certA, root), council.clean(list(certB, certA, root, superRoot)));
+        new RealTrustRootIndex(selfSigned.certificate, trusted.certificate));
+    assertEquals(list(certB, certA, trusted, selfSigned),
+        council.clean(list(certB, certA)));
+    assertEquals(list(certB, certA, trusted, selfSigned),
+        council.clean(list(certB, certA, trusted)));
+    assertEquals(list(certB, certA, trusted, selfSigned),
+        council.clean(list(certB, certA, trusted, selfSigned)));
+  }
+
+  @Test public void trustedRootNotSelfSigned() throws Exception {
+    HeldCertificate unknownSigner = new HeldCertificate.Builder()
+        .serialNumber("1")
+        .build();
+    HeldCertificate trusted = new HeldCertificate.Builder()
+        .issuedBy(unknownSigner)
+        .serialNumber("2")
+        .build();
+    HeldCertificate intermediateCa = new HeldCertificate.Builder()
+        .issuedBy(trusted)
+        .serialNumber("3")
+        .build();
+    HeldCertificate certificate = new HeldCertificate.Builder()
+        .issuedBy(intermediateCa)
+        .serialNumber("4")
+        .build();
+
+    CertificateChainCleaner council = new CertificateChainCleaner(
+        new RealTrustRootIndex(trusted.certificate));
+    assertEquals(list(certificate, intermediateCa, trusted),
+        council.clean(list(certificate, intermediateCa)));
+    assertEquals(list(certificate, intermediateCa, trusted),
+        council.clean(list(certificate, intermediateCa, trusted)));
+  }
+
+  @Test public void chainMaxLength() throws Exception {
+    List<HeldCertificate> heldCertificates = chainOfLength(10);
+    List<Certificate> certificates = new ArrayList<>();
+    for (HeldCertificate heldCertificate : heldCertificates) {
+      certificates.add(heldCertificate.certificate);
+    }
+
+    X509Certificate root = heldCertificates.get(heldCertificates.size() - 1).certificate;
+    CertificateChainCleaner council = new CertificateChainCleaner(new RealTrustRootIndex(root));
+    assertEquals(certificates, council.clean(certificates));
+    assertEquals(certificates, council.clean(certificates.subList(0, 9)));
+  }
+
+  @Test public void chainTooLong() throws Exception {
+    List<HeldCertificate> heldCertificates = chainOfLength(11);
+    List<Certificate> certificates = new ArrayList<>();
+    for (HeldCertificate heldCertificate : heldCertificates) {
+      certificates.add(heldCertificate.certificate);
+    }
+
+    X509Certificate root = heldCertificates.get(heldCertificates.size() - 1).certificate;
+    CertificateChainCleaner council = new CertificateChainCleaner(new RealTrustRootIndex(root));
+    try {
+      council.clean(certificates);
+      fail();
+    } catch (SSLPeerUnverifiedException expected) {
+    }
+  }
+
+  /** Returns a chain starting at the leaf certificate and progressing to the root. */
+  private List<HeldCertificate> chainOfLength(int length) throws GeneralSecurityException {
+    List<HeldCertificate> result = new ArrayList<>();
+    for (int i = 1; i <= length; i++) {
+      result.add(0, new HeldCertificate.Builder()
+          .issuedBy(!result.isEmpty() ? result.get(0) : null)
+          .serialNumber(Integer.toString(i))
+          .build());
+    }
+    return result;
   }
 
   private List<Certificate> list(HeldCertificate... heldCertificates) {
diff --git a/okhttp-tests/src/test/java/okhttp3/CertificatePinnerTest.java b/okhttp-tests/src/test/java/okhttp3/CertificatePinnerTest.java
index b088f8c141..9442ddaf71 100644
--- a/okhttp-tests/src/test/java/okhttp3/CertificatePinnerTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CertificatePinnerTest.java
@@ -16,58 +16,50 @@
 package okhttp3;
 
 import java.security.GeneralSecurityException;
-import java.util.Set;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
 import javax.net.ssl.SSLPeerUnverifiedException;
+import okhttp3.CertificatePinner.Pin;
 import okhttp3.internal.HeldCertificate;
-import okio.ByteString;
 import org.junit.Test;
 
-import static okhttp3.TestUtil.setOf;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 public final class CertificatePinnerTest {
   static HeldCertificate certA1;
-  static String certA1Pin;
-  static ByteString certA1PinBase64;
+  static String certA1Sha256Pin;
 
   static HeldCertificate certB1;
-  static String certB1Pin;
-  static ByteString certB1PinBase64;
+  static String certB1Sha256Pin;
 
   static HeldCertificate certC1;
-  static String certC1Pin;
+  static String certC1Sha256Pin;
 
   static {
     try {
       certA1 = new HeldCertificate.Builder()
           .serialNumber("100")
           .build();
-      certA1Pin = CertificatePinner.pin(certA1.certificate);
-      certA1PinBase64 = pinToBase64(certA1Pin);
+      certA1Sha256Pin = "sha256/" + CertificatePinner.sha256(certA1.certificate).base64();
 
       certB1 = new HeldCertificate.Builder()
           .serialNumber("200")
           .build();
-      certB1Pin = CertificatePinner.pin(certB1.certificate);
-      certB1PinBase64 = pinToBase64(certB1Pin);
+      certB1Sha256Pin = "sha256/" + CertificatePinner.sha256(certB1.certificate).base64();
 
       certC1 = new HeldCertificate.Builder()
           .serialNumber("300")
           .build();
-      certC1Pin = CertificatePinner.pin(certC1.certificate);
+      certC1Sha256Pin = "sha256/" + CertificatePinner.sha256(certC1.certificate).base64();
     } catch (GeneralSecurityException e) {
       throw new AssertionError(e);
     }
   }
 
-  static ByteString pinToBase64(String pin) {
-    return ByteString.decodeBase64(pin.substring("sha1/".length()));
-  }
-
   @Test public void malformedPin() throws Exception {
     CertificatePinner.Builder builder = new CertificatePinner.Builder();
     try {
@@ -100,14 +92,22 @@ static ByteString pinToBase64(String pin) {
         .build();
     String keypairBCertificate2Pin = CertificatePinner.pin(heldCertificateB2.certificate);
 
-    assertTrue(certA1Pin.equals(keypairACertificate2Pin));
-    assertTrue(certB1Pin.equals(keypairBCertificate2Pin));
-    assertFalse(certA1Pin.equals(certB1Pin));
+    assertTrue(certA1Sha256Pin.equals(keypairACertificate2Pin));
+    assertTrue(certB1Sha256Pin.equals(keypairBCertificate2Pin));
+    assertFalse(certA1Sha256Pin.equals(certB1Sha256Pin));
   }
 
   @Test public void successfulCheck() throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("example.com", certA1Pin)
+        .add("example.com", certA1Sha256Pin)
+        .build();
+
+    certificatePinner.check("example.com", certA1.certificate);
+  }
+
+  @Test public void successfulCheckSha1Pin() throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("example.com", "sha1/" + CertificatePinner.sha1(certA1.certificate).base64())
         .build();
 
     certificatePinner.check("example.com", certA1.certificate);
@@ -115,7 +115,7 @@ static ByteString pinToBase64(String pin) {
 
   @Test public void successfulMatchAcceptsAnyMatchingCertificate() throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("example.com", certB1Pin)
+        .add("example.com", certB1Sha256Pin)
         .build();
 
     certificatePinner.check("example.com", certA1.certificate, certB1.certificate);
@@ -123,7 +123,7 @@ static ByteString pinToBase64(String pin) {
 
   @Test public void unsuccessfulCheck() throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("example.com", certA1Pin)
+        .add("example.com", certA1Sha256Pin)
         .build();
 
     try {
@@ -135,7 +135,7 @@ static ByteString pinToBase64(String pin) {
 
   @Test public void multipleCertificatesForOneHostname() throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("example.com", certA1Pin, certB1Pin)
+        .add("example.com", certA1Sha256Pin, certB1Sha256Pin)
         .build();
 
     certificatePinner.check("example.com", certA1.certificate);
@@ -144,8 +144,8 @@ static ByteString pinToBase64(String pin) {
 
   @Test public void multipleHostnamesForOneCertificate() throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("example.com", certA1Pin)
-        .add("www.example.com", certA1Pin)
+        .add("example.com", certA1Sha256Pin)
+        .add("www.example.com", certA1Sha256Pin)
         .build();
 
     certificatePinner.check("example.com", certA1.certificate);
@@ -159,7 +159,7 @@ static ByteString pinToBase64(String pin) {
 
   @Test public void successfulCheckForWildcardHostname() throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("*.example.com", certA1Pin)
+        .add("*.example.com", certA1Sha256Pin)
         .build();
 
     certificatePinner.check("a.example.com", certA1.certificate);
@@ -168,7 +168,7 @@ static ByteString pinToBase64(String pin) {
   @Test public void successfulMatchAcceptsAnyMatchingCertificateForWildcardHostname()
       throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("*.example.com", certB1Pin)
+        .add("*.example.com", certB1Sha256Pin)
         .build();
 
     certificatePinner.check("a.example.com", certA1.certificate, certB1.certificate);
@@ -176,7 +176,7 @@ static ByteString pinToBase64(String pin) {
 
   @Test public void unsuccessfulCheckForWildcardHostname() throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("*.example.com", certA1Pin)
+        .add("*.example.com", certA1Sha256Pin)
         .build();
 
     try {
@@ -188,7 +188,7 @@ static ByteString pinToBase64(String pin) {
 
   @Test public void multipleCertificatesForOneWildcardHostname() throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("*.example.com", certA1Pin, certB1Pin)
+        .add("*.example.com", certA1Sha256Pin, certB1Sha256Pin)
         .build();
 
     certificatePinner.check("a.example.com", certA1.certificate);
@@ -198,8 +198,8 @@ static ByteString pinToBase64(String pin) {
   @Test public void successfulCheckForOneHostnameWithWildcardAndDirectCertificate()
       throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("*.example.com", certA1Pin)
-        .add("a.example.com", certB1Pin)
+        .add("*.example.com", certA1Sha256Pin)
+        .add("a.example.com", certB1Sha256Pin)
         .build();
 
     certificatePinner.check("a.example.com", certA1.certificate);
@@ -209,8 +209,8 @@ static ByteString pinToBase64(String pin) {
   @Test public void unsuccessfulCheckForOneHostnameWithWildcardAndDirectCertificate()
       throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("*.example.com", certA1Pin)
-        .add("a.example.com", certB1Pin)
+        .add("*.example.com", certA1Sha256Pin)
+        .add("a.example.com", certB1Sha256Pin)
         .build();
 
     try {
@@ -222,35 +222,35 @@ static ByteString pinToBase64(String pin) {
 
   @Test public void successfulFindMatchingPins() {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("first.com", certA1Pin, certB1Pin)
-        .add("second.com", certC1Pin)
+        .add("first.com", certA1Sha256Pin, certB1Sha256Pin)
+        .add("second.com", certC1Sha256Pin)
         .build();
 
-    Set<ByteString> expectedPins = setOf(certA1PinBase64, certB1PinBase64);
-    Set<ByteString> matchedPins = certificatePinner.findMatchingPins("first.com");
-
-    assertEquals(expectedPins, matchedPins);
+    List<Pin> expectedPins = Arrays.asList(
+        new Pin("first.com", certA1Sha256Pin),
+        new Pin("first.com", certB1Sha256Pin));
+    assertEquals(expectedPins, certificatePinner.findMatchingPins("first.com"));
   }
 
   @Test public void successfulFindMatchingPinsForWildcardAndDirectCertificates() {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("*.example.com", certA1Pin)
-        .add("a.example.com", certB1Pin)
-        .add("b.example.com", certC1Pin)
+        .add("*.example.com", certA1Sha256Pin)
+        .add("a.example.com", certB1Sha256Pin)
+        .add("b.example.com", certC1Sha256Pin)
         .build();
 
-    Set<ByteString> expectedPins = setOf(certA1PinBase64, certB1PinBase64);
-    Set<ByteString> matchedPins = certificatePinner.findMatchingPins("a.example.com");
-
-    assertEquals(expectedPins, matchedPins);
+    List<Pin> expectedPins = Arrays.asList(
+        new Pin("*.example.com", certA1Sha256Pin),
+        new Pin("a.example.com", certB1Sha256Pin));
+    assertEquals(expectedPins, certificatePinner.findMatchingPins("a.example.com"));
   }
 
   @Test public void wildcardHostnameShouldNotMatchThroughDot() throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("*.example.com", certA1Pin)
+        .add("*.example.com", certA1Sha256Pin)
         .build();
 
-    assertNull(certificatePinner.findMatchingPins("example.com"));
-    assertNull(certificatePinner.findMatchingPins("a.b.example.com"));
+    assertEquals(Collections.emptyList(), certificatePinner.findMatchingPins("example.com"));
+    assertEquals(Collections.emptyList(), certificatePinner.findMatchingPins("a.b.example.com"));
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java b/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java
index a67dc380d4..f7d655dbf0 100644
--- a/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java
@@ -438,6 +438,15 @@
     assertEquals("::", HttpUrl.parse("http://[0:0:0:0:0:0:0:0]/").host());
   }
 
+  /** The builder permits square braces but does not require them. */
+  @Test public void hostIPv6Builder() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://example.com/");
+    assertEquals("http://[::1]/", base.newBuilder().host("[::1]").build().toString());
+    assertEquals("http://[::1]/", base.newBuilder().host("[::0001]").build().toString());
+    assertEquals("http://[::1]/", base.newBuilder().host("::1").build().toString());
+    assertEquals("http://[::1]/", base.newBuilder().host("::0001").build().toString());
+  }
+
   @Test public void hostIpv4CanonicalForm() throws Exception {
     assertEquals("255.255.255.255", HttpUrl.parse("http://255.255.255.255/").host());
     assertEquals("1.2.3.4", HttpUrl.parse("http://1.2.3.4/").host());
@@ -801,6 +810,64 @@
     assertEquals(3, HttpUrl.parse("http://host/a/b/c").pathSize());
   }
 
+  @Test public void addPathSegments() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+
+    // Add a string with zero slashes: resulting URL gains one slash.
+    assertEquals("/a/b/c/", base.newBuilder().addPathSegments("").build().encodedPath());
+    assertEquals("/a/b/c/d", base.newBuilder().addPathSegments("d").build().encodedPath());
+
+    // Add a string with one slash: resulting URL gains two slashes.
+    assertEquals("/a/b/c//", base.newBuilder().addPathSegments("/").build().encodedPath());
+    assertEquals("/a/b/c/d/", base.newBuilder().addPathSegments("d/").build().encodedPath());
+    assertEquals("/a/b/c//d", base.newBuilder().addPathSegments("/d").build().encodedPath());
+
+    // Add a string with two slashes: resulting URL gains three slashes.
+    assertEquals("/a/b/c///", base.newBuilder().addPathSegments("//").build().encodedPath());
+    assertEquals("/a/b/c//d/", base.newBuilder().addPathSegments("/d/").build().encodedPath());
+    assertEquals("/a/b/c/d//", base.newBuilder().addPathSegments("d//").build().encodedPath());
+    assertEquals("/a/b/c///d", base.newBuilder().addPathSegments("//d").build().encodedPath());
+    assertEquals("/a/b/c/d/e/f", base.newBuilder().addPathSegments("d/e/f").build().encodedPath());
+  }
+
+  @Test public void addPathSegmentsOntoTrailingSlash() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c/");
+
+    // Add a string with zero slashes: resulting URL gains zero slashes.
+    assertEquals("/a/b/c/", base.newBuilder().addPathSegments("").build().encodedPath());
+    assertEquals("/a/b/c/d", base.newBuilder().addPathSegments("d").build().encodedPath());
+
+    // Add a string with one slash: resulting URL gains one slash.
+    assertEquals("/a/b/c//", base.newBuilder().addPathSegments("/").build().encodedPath());
+    assertEquals("/a/b/c/d/", base.newBuilder().addPathSegments("d/").build().encodedPath());
+    assertEquals("/a/b/c//d", base.newBuilder().addPathSegments("/d").build().encodedPath());
+
+    // Add a string with two slashes: resulting URL gains two slashes.
+    assertEquals("/a/b/c///", base.newBuilder().addPathSegments("//").build().encodedPath());
+    assertEquals("/a/b/c//d/", base.newBuilder().addPathSegments("/d/").build().encodedPath());
+    assertEquals("/a/b/c/d//", base.newBuilder().addPathSegments("d//").build().encodedPath());
+    assertEquals("/a/b/c///d", base.newBuilder().addPathSegments("//d").build().encodedPath());
+    assertEquals("/a/b/c/d/e/f", base.newBuilder().addPathSegments("d/e/f").build().encodedPath());
+  }
+
+  @Test public void addPathSegmentsWithBackslash() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/");
+    assertEquals("/d/e", base.newBuilder().addPathSegments("d\\e").build().encodedPath());
+    assertEquals("/d/e", base.newBuilder().addEncodedPathSegments("d\\e").build().encodedPath());
+  }
+
+  @Test public void addPathSegmentsWithEmptyPaths() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    assertEquals("/a/b/c//d/e///f",
+        base.newBuilder().addPathSegments("/d/e///f").build().encodedPath());
+  }
+
+  @Test public void addEncodedPathSegments() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    assertEquals("/a/b/c/d/e/%20/",
+        base.newBuilder().addEncodedPathSegments("d/e/%20/\n").build().encodedPath());
+  }
+
   @Test public void addPathSegmentDotDoesNothing() throws Exception {
     HttpUrl base = HttpUrl.parse("http://host/a/b/c");
     assertEquals("/a/b/c", base.newBuilder().addPathSegment(".").build().encodedPath());
diff --git a/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java b/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
index 5a68c7aade..768adf78fe 100644
--- a/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
@@ -915,7 +915,7 @@ private void testConnectViaHttpProxyToHttps(ProxyConfig proxyConfig) throws Exce
     RecordedRequest connect = server.takeRequest();
     assertEquals("Connect line failure on proxy", "CONNECT android.com:443 HTTP/1.1",
         connect.getRequestLine());
-    assertEquals("android.com", connect.getHeader("Host"));
+    assertEquals("android.com:443", connect.getHeader("Host"));
 
     RecordedRequest get = server.takeRequest();
     assertEquals("GET /foo HTTP/1.1", get.getRequestLine());
@@ -951,7 +951,7 @@ private void testConnectViaHttpProxyToHttps(ProxyConfig proxyConfig) throws Exce
 
     RecordedRequest connect = server.takeRequest();
     assertEquals("CONNECT android.com:443 HTTP/1.1", connect.getRequestLine());
-    assertEquals("android.com", connect.getHeader("Host"));
+    assertEquals("android.com:443", connect.getHeader("Host"));
   }
 
   private void initResponseCache() throws IOException {
@@ -988,7 +988,7 @@ private void initResponseCache() throws IOException {
     assertNull(connect.getHeader("Private"));
     assertNull(connect.getHeader("Proxy-Authorization"));
     assertEquals(Version.userAgent(), connect.getHeader("User-Agent"));
-    assertEquals("android.com", connect.getHeader("Host"));
+    assertEquals("android.com:443", connect.getHeader("Host"));
     assertEquals("Keep-Alive", connect.getHeader("Proxy-Connection"));
 
     RecordedRequest get = server.takeRequest();
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/DiskLruCacheTest.java b/okhttp-tests/src/test/java/okhttp3/internal/DiskLruCacheTest.java
index 955214068e..6a559d3b5e 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/DiskLruCacheTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/DiskLruCacheTest.java
@@ -1073,11 +1073,11 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     set("b", "b", "b");
 
     // We can't begin the edit if writing 'DIRTY' fails.
-    fileSystem.setFaulty(journalFile, true);
+    fileSystem.setFaultyWrite(journalFile, true);
     assertNull(cache.edit("c"));
 
     // Once the journal has a failure, subsequent writes aren't permitted.
-    fileSystem.setFaulty(journalFile, false);
+    fileSystem.setFaultyWrite(journalFile, false);
     assertNull(cache.edit("d"));
 
     // Confirm that the fault didn't corrupt entries stored before the fault was introduced.
@@ -1101,11 +1101,11 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     DiskLruCache.Editor editor = cache.edit("c");
     setString(editor, 0, "c");
     setString(editor, 1, "c");
-    fileSystem.setFaulty(journalFile, true);
+    fileSystem.setFaultyWrite(journalFile, true);
     editor.commit();
 
     // Once the journal has a failure, subsequent writes aren't permitted.
-    fileSystem.setFaulty(journalFile, false);
+    fileSystem.setFaultyWrite(journalFile, false);
     assertNull(cache.edit("d"));
 
     // Confirm that the fault didn't corrupt entries stored before the fault was introduced.
@@ -1125,11 +1125,11 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     DiskLruCache.Editor editor = cache.edit("c");
     setString(editor, 0, "c");
     setString(editor, 1, "c");
-    fileSystem.setFaulty(journalFile, true);
+    fileSystem.setFaultyWrite(journalFile, true);
     editor.abort();
 
     // Once the journal has a failure, subsequent writes aren't permitted.
-    fileSystem.setFaulty(journalFile, false);
+    fileSystem.setFaultyWrite(journalFile, false);
     assertNull(cache.edit("d"));
 
     // Confirm that the fault didn't corrupt entries stored before the fault was introduced.
@@ -1146,17 +1146,202 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     set("b", "b", "b");
 
     // Remove, but the journal write will fail.
-    fileSystem.setFaulty(journalFile, true);
+    fileSystem.setFaultyWrite(journalFile, true);
     assertTrue(cache.remove("a"));
 
     // Confirm that the entry was still removed.
-    fileSystem.setFaulty(journalFile, false);
+    fileSystem.setFaultyWrite(journalFile, false);
     cache.close();
     cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, Integer.MAX_VALUE, executor);
     assertAbsent("a");
     assertValue("b", "b", "b");
   }
 
+  @Test public void cleanupTrimFailurePreventsNewEditors() throws Exception {
+    cache.setMaxSize(8);
+    executor.jobs.pop();
+    set("a", "aa", "aa");
+    set("b", "bb", "bbb");
+
+    // Cause the cache trim job to fail.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
+    executor.jobs.pop().run();
+
+    // Confirm that edits are prevented after a cache trim failure.
+    assertNull(cache.edit("a"));
+    assertNull(cache.edit("b"));
+    assertNull(cache.edit("c"));
+
+    // Allow the test to clean up.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
+  }
+
+  @Test public void cleanupTrimFailureRetriedOnEditors() throws Exception {
+    cache.setMaxSize(8);
+    executor.jobs.pop();
+    set("a", "aa", "aa");
+    set("b", "bb", "bbb");
+
+    // Cause the cache trim job to fail.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
+    executor.jobs.pop().run();
+
+    // An edit should now add a job to clean up if the most recent trim failed.
+    assertNull(cache.edit("b"));
+    executor.jobs.pop().run();
+
+    // Confirm a successful cache trim now allows edits.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
+    assertNull(cache.edit("c"));
+    executor.jobs.pop().run();
+    set("c", "cc", "cc");
+    assertValue("c", "cc", "cc");
+  }
+
+  @Test public void cleanupTrimFailureWithInFlightEditor() throws Exception {
+    cache.setMaxSize(8);
+    executor.jobs.pop();
+    set("a", "aa", "aaa");
+    set("b", "bb", "bb");
+    DiskLruCache.Editor inFlightEditor = cache.edit("c");
+
+    // Cause the cache trim job to fail.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
+    executor.jobs.pop().run();
+
+    // The in-flight editor can still write after a trim failure.
+    setString(inFlightEditor, 0, "cc");
+    setString(inFlightEditor, 1, "cc");
+    inFlightEditor.commit();
+
+    // Confirm the committed values are present after a successful cache trim.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
+    executor.jobs.pop().run();
+    assertValue("c", "cc", "cc");
+  }
+
+  @Test public void cleanupTrimFailureAllowsSnapshotReads() throws Exception {
+    cache.setMaxSize(8);
+    executor.jobs.pop();
+    set("a", "aa", "aa");
+    set("b", "bb", "bbb");
+
+    // Cause the cache trim job to fail.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
+    executor.jobs.pop().run();
+
+    // Confirm we still allow snapshot reads after a trim failure.
+    assertValue("a", "aa", "aa");
+    assertValue("b", "bb", "bbb");
+
+    // Allow the test to clean up.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
+  }
+
+  @Test public void cleanupTrimFailurePreventsSnapshotWrites() throws Exception {
+    cache.setMaxSize(8);
+    executor.jobs.pop();
+    set("a", "aa", "aa");
+    set("b", "bb", "bbb");
+
+    // Cause the cache trim job to fail.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
+    executor.jobs.pop().run();
+
+    // Confirm snapshot writes are prevented after a trim failure.
+    DiskLruCache.Snapshot snapshot1 = cache.get("a");
+    assertNull(snapshot1.edit());
+    snapshot1.close();
+    DiskLruCache.Snapshot snapshot2 = cache.get("b");
+    assertNull(snapshot2.edit());
+    snapshot2.close();
+
+    // Allow the test to clean up.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
+  }
+
+  @Test public void evictAllAfterCleanupTrimFailure() throws Exception {
+    cache.setMaxSize(8);
+    executor.jobs.pop();
+    set("a", "aa", "aa");
+    set("b", "bb", "bbb");
+
+    // Cause the cache trim job to fail.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
+    executor.jobs.pop().run();
+
+    // Confirm we prevent edits after a trim failure.
+    assertNull(cache.edit("c"));
+
+    // A successful eviction should allow new writes.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
+    cache.evictAll();
+    set("c", "cc", "cc");
+    assertValue("c", "cc", "cc");
+  }
+
+  @Test public void manualRemovalAfterCleanupTrimFailure() throws Exception {
+    cache.setMaxSize(8);
+    executor.jobs.pop();
+    set("a", "aa", "aa");
+    set("b", "bb", "bbb");
+
+    // Cause the cache trim job to fail.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
+    executor.jobs.pop().run();
+
+    // Confirm we prevent edits after a trim failure.
+    assertNull(cache.edit("c"));
+
+    // A successful removal which trims the cache should allow new writes.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
+    cache.remove("a");
+    set("c", "cc", "cc");
+    assertValue("c", "cc", "cc");
+  }
+
+  @Test public void flushingAfterCleanupTrimFailure() throws Exception {
+    cache.setMaxSize(8);
+    executor.jobs.pop();
+    set("a", "aa", "aa");
+    set("b", "bb", "bbb");
+
+    // Cause the cache trim job to fail.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
+    executor.jobs.pop().run();
+
+    // Confirm we prevent edits after a trim failure.
+    assertNull(cache.edit("c"));
+
+    // A successful flush trims the cache and should allow new writes.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
+    cache.flush();
+    set("c", "cc", "cc");
+    assertValue("c", "cc", "cc");
+  }
+
+  @Test public void cleanupTrimFailureWithPartialSnapshot() throws Exception {
+    cache.setMaxSize(8);
+    executor.jobs.pop();
+    set("a", "aa", "aa");
+    set("b", "bb", "bbb");
+
+    // Cause the cache trim to fail on the second value leaving a partial snapshot.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.1"), true);
+    executor.jobs.pop().run();
+
+    // Confirm the partial snapshot is not returned.
+    assertNull(cache.get("a"));
+
+    // Confirm we prevent edits after a trim failure.
+    assertNull(cache.edit("a"));
+
+    // Confirm the partial snapshot is not returned after a successful trim.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.1"), false);
+    executor.jobs.pop().run();
+    assertNull(cache.get("a"));
+  }
+
   private void assertJournalEquals(String... expectedBodyLines) throws Exception {
     List<String> expectedLines = new ArrayList<>();
     expectedLines.add(MAGIC);
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/FaultyFileSystem.java b/okhttp-tests/src/test/java/okhttp3/internal/FaultyFileSystem.java
index 22b1758227..bd38dced6b 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/FaultyFileSystem.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/FaultyFileSystem.java
@@ -29,12 +29,13 @@
 public final class FaultyFileSystem implements FileSystem {
   private final FileSystem delegate;
   private final Set<File> writeFaults = new LinkedHashSet<>();
+  private final Set<File> deleteFaults = new LinkedHashSet<>();
 
   public FaultyFileSystem(FileSystem delegate) {
     this.delegate = delegate;
   }
 
-  public void setFaulty(File file, boolean faulty) {
+  public void setFaultyWrite(File file, boolean faulty) {
     if (faulty) {
       writeFaults.add(file);
     } else {
@@ -42,6 +43,14 @@ public void setFaulty(File file, boolean faulty) {
     }
   }
 
+  public void setFaultyDelete(File file, boolean faulty) {
+    if (faulty) {
+      deleteFaults.add(file);
+    } else {
+      deleteFaults.remove(file);
+    }
+  }
+
   @Override public Source source(File file) throws FileNotFoundException {
     return delegate.source(file);
   }
@@ -55,6 +64,7 @@ public void setFaulty(File file, boolean faulty) {
   }
 
   @Override public void delete(File file) throws IOException {
+    if (deleteFaults.contains(file)) throw new IOException("boom!");
     delegate.delete(file);
   }
 
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/tls/CertificatePinnerChainValidationTest.java b/okhttp-tests/src/test/java/okhttp3/internal/tls/CertificatePinnerChainValidationTest.java
new file mode 100644
index 0000000000..8c50399878
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/tls/CertificatePinnerChainValidationTest.java
@@ -0,0 +1,305 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.tls;
+
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLHandshakeException;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import okhttp3.Call;
+import okhttp3.CertificatePinner;
+import okhttp3.OkHttpClient;
+import okhttp3.RecordingHostnameVerifier;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.internal.HeldCertificate;
+import okhttp3.internal.SslContextBuilder;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.SocketPolicy;
+import org.junit.Rule;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class CertificatePinnerChainValidationTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  /** The pinner should pull the root certificate from the trust manager. */
+  @Test public void pinRootNotPresentInChain() throws Exception {
+    HeldCertificate rootCa = new HeldCertificate.Builder()
+        .serialNumber("1")
+        .ca(3)
+        .commonName("root")
+        .build();
+    HeldCertificate intermediateCa = new HeldCertificate.Builder()
+        .issuedBy(rootCa)
+        .ca(2)
+        .serialNumber("2")
+        .commonName("intermediate_ca")
+        .build();
+    HeldCertificate certificate = new HeldCertificate.Builder()
+        .issuedBy(intermediateCa)
+        .serialNumber("3")
+        .commonName(server.getHostName())
+        .build();
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add(server.getHostName(), CertificatePinner.pin(rootCa.certificate))
+        .build();
+    SSLContext clientContext = new SslContextBuilder()
+        .addTrustedCertificate(rootCa.certificate)
+        .build();
+    OkHttpClient client = new OkHttpClient.Builder()
+        .sslSocketFactory(clientContext.getSocketFactory())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .certificatePinner(certificatePinner)
+        .build();
+
+    SSLContext serverSslContext = new SslContextBuilder()
+        .certificateChain(certificate, intermediateCa)
+        .build();
+    server.useHttps(serverSslContext.getSocketFactory(), false);
+
+    // The request should complete successfully.
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END));
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response1 = call1.execute();
+    assertEquals("abc", response1.body().string());
+
+    // Confirm that a second request also succeeds. This should detect caching problems.
+    server.enqueue(new MockResponse()
+        .setBody("def")
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END));
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+    assertEquals("def", response2.body().string());
+  }
+
+  /** The pinner should accept an intermediate from the server's chain. */
+  @Test public void pinIntermediatePresentInChain() throws Exception {
+    HeldCertificate rootCa = new HeldCertificate.Builder()
+        .serialNumber("1")
+        .ca(3)
+        .commonName("root")
+        .build();
+    HeldCertificate intermediateCa = new HeldCertificate.Builder()
+        .issuedBy(rootCa)
+        .ca(2)
+        .serialNumber("2")
+        .commonName("intermediate_ca")
+        .build();
+    HeldCertificate certificate = new HeldCertificate.Builder()
+        .issuedBy(intermediateCa)
+        .serialNumber("3")
+        .commonName(server.getHostName())
+        .build();
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add(server.getHostName(), CertificatePinner.pin(intermediateCa.certificate))
+        .build();
+    SSLContext clientContext = new SslContextBuilder()
+        .addTrustedCertificate(rootCa.certificate)
+        .build();
+    OkHttpClient client = new OkHttpClient.Builder()
+        .sslSocketFactory(clientContext.getSocketFactory())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .certificatePinner(certificatePinner)
+        .build();
+
+    SSLContext serverSslContext = new SslContextBuilder()
+        .certificateChain(certificate, intermediateCa)
+        .build();
+    server.useHttps(serverSslContext.getSocketFactory(), false);
+
+    // The request should complete successfully.
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END));
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response1 = call1.execute();
+    assertEquals("abc", response1.body().string());
+
+    // Confirm that a second request also succeeds. This should detect caching problems.
+    server.enqueue(new MockResponse()
+        .setBody("def")
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END));
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+    assertEquals("def", response2.body().string());
+  }
+
+  @Test public void unrelatedPinnedLeafCertificateInChain() throws Exception {
+    // Start with a trusted root CA certificate.
+    HeldCertificate rootCa = new HeldCertificate.Builder()
+        .serialNumber("1")
+        .ca(3)
+        .commonName("root")
+        .build();
+
+    // Add a good intermediate CA, and have that issue a good certificate to localhost. Prepare an
+    // SSL context for an HTTP client under attack. It includes the trusted CA and a pinned
+    // certificate.
+    HeldCertificate goodIntermediateCa = new HeldCertificate.Builder()
+        .issuedBy(rootCa)
+        .ca(2)
+        .serialNumber("2")
+        .commonName("good_intermediate_ca")
+        .build();
+    HeldCertificate goodCertificate = new HeldCertificate.Builder()
+        .issuedBy(goodIntermediateCa)
+        .serialNumber("3")
+        .commonName(server.getHostName())
+        .build();
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add(server.getHostName(), CertificatePinner.pin(goodCertificate.certificate))
+        .build();
+    SSLContext clientContext = new SslContextBuilder()
+        .addTrustedCertificate(rootCa.certificate)
+        .build();
+    OkHttpClient client = new OkHttpClient.Builder()
+        .sslSocketFactory(clientContext.getSocketFactory())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .certificatePinner(certificatePinner)
+        .build();
+
+    // Add a bad intermediate CA and have that issue a rogue certificate for localhost. Prepare
+    // an SSL context for an attacking webserver. It includes both these rogue certificates plus the
+    // trusted good certificate above. The attack is that by including the good certificate in the
+    // chain, we may trick the certificate pinner into accepting the rouge certificate.
+    HeldCertificate compromisedIntermediateCa = new HeldCertificate.Builder()
+        .issuedBy(rootCa)
+        .ca(2)
+        .serialNumber("4")
+        .commonName("bad_intermediate_ca")
+        .build();
+    HeldCertificate rogueCertificate = new HeldCertificate.Builder()
+        .serialNumber("5")
+        .issuedBy(compromisedIntermediateCa)
+        .commonName(server.getHostName())
+        .build();
+    SSLContext serverSslContext = new SslContextBuilder()
+        .certificateChain(rogueCertificate, compromisedIntermediateCa, goodCertificate, rootCa)
+        .build();
+    server.useHttps(serverSslContext.getSocketFactory(), false);
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .addHeader("Content-Type: text/plain"));
+
+    // Make a request from client to server. It should succeed certificate checks (unfortunately the
+    // rogue CA is trusted) but it should fail certificate pinning.
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    Call call = client.newCall(request);
+    try {
+      call.execute();
+      fail();
+    } catch (SSLPeerUnverifiedException expected) {
+      // Certificate pinning fails!
+      String message = expected.getMessage();
+      assertTrue(message, message.startsWith("Certificate pinning failure!"));
+    }
+  }
+
+  @Test public void unrelatedPinnedIntermediateCertificateInChain() throws Exception {
+    // Start with two root CA certificates, one is good and the other is compromised.
+    HeldCertificate rootCa = new HeldCertificate.Builder()
+        .serialNumber("1")
+        .ca(3)
+        .commonName("root")
+        .build();
+    HeldCertificate compromisedRootCa = new HeldCertificate.Builder()
+        .serialNumber("2")
+        .ca(3)
+        .commonName("compromised_root")
+        .build();
+
+    // Add a good intermediate CA, and have that issue a good certificate to localhost. Prepare an
+    // SSL context for an HTTP client under attack. It includes the trusted CA and a pinned
+    // certificate.
+    HeldCertificate goodIntermediateCa = new HeldCertificate.Builder()
+        .issuedBy(rootCa)
+        .ca(2)
+        .serialNumber("3")
+        .commonName("intermediate_ca")
+        .build();
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add(server.getHostName(), CertificatePinner.pin(goodIntermediateCa.certificate))
+        .build();
+    SSLContext clientContext = new SslContextBuilder()
+        .addTrustedCertificate(rootCa.certificate)
+        .addTrustedCertificate(compromisedRootCa.certificate)
+        .build();
+    OkHttpClient client = new OkHttpClient.Builder()
+        .sslSocketFactory(clientContext.getSocketFactory())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .certificatePinner(certificatePinner)
+        .build();
+
+    // The attacker compromises the root CA, issues an intermediate with the same common name
+    // "intermediate_ca" as the good CA. This signs a rogue certificate for localhost. The server
+    // serves the good CAs certificate in the chain, which means the certificate pinner sees a
+    // different set of certificates than the SSL verifier.
+    HeldCertificate compromisedIntermediateCa = new HeldCertificate.Builder()
+        .issuedBy(compromisedRootCa)
+        .ca(2)
+        .serialNumber("4")
+        .commonName("intermediate_ca")
+        .build();
+    HeldCertificate rogueCertificate = new HeldCertificate.Builder()
+        .serialNumber("5")
+        .issuedBy(compromisedIntermediateCa)
+        .commonName(server.getHostName())
+        .build();
+    SSLContext serverSslContext = new SslContextBuilder()
+        .certificateChain(
+            rogueCertificate, goodIntermediateCa, compromisedIntermediateCa, compromisedRootCa)
+        .build();
+    server.useHttps(serverSslContext.getSocketFactory(), false);
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .addHeader("Content-Type: text/plain"));
+
+    // Make a request from client to server. It should succeed certificate checks (unfortunately the
+    // rogue CA is trusted) but it should fail certificate pinning.
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    Call call = client.newCall(request);
+    try {
+      call.execute();
+      fail();
+    } catch (SSLHandshakeException expected) {
+      // On Android, the handshake fails before the certificate pinner runs.
+      String message = expected.getMessage();
+      assertTrue(message, message.contains("Could not validate certificate"));
+    } catch (SSLPeerUnverifiedException expected) {
+      // On OpenJDK, the handshake succeeds but the certificate pinner fails.
+      String message = expected.getMessage();
+      assertTrue(message, message.startsWith("Certificate pinning failure!"));
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/Call.java b/okhttp/src/main/java/okhttp3/Call.java
index 3baaf647da..58506d1376 100644
--- a/okhttp/src/main/java/okhttp3/Call.java
+++ b/okhttp/src/main/java/okhttp3/Call.java
@@ -51,8 +51,7 @@
    * immediately unless there are several other requests currently being executed.
    *
    * <p>This client will later call back {@code responseCallback} with either an HTTP response or a
-   * failure exception. If you {@link #cancel} a request before it completes the callback will not
-   * be invoked.
+   * failure exception.
    *
    * @throws IllegalStateException when the call has already been executed.
    */
diff --git a/okhttp/src/main/java/okhttp3/CertificatePinner.java b/okhttp/src/main/java/okhttp3/CertificatePinner.java
index e485c87f52..f7a1367649 100644
--- a/okhttp/src/main/java/okhttp3/CertificatePinner.java
+++ b/okhttp/src/main/java/okhttp3/CertificatePinner.java
@@ -17,30 +17,25 @@
 
 import java.security.cert.Certificate;
 import java.security.cert.X509Certificate;
+import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.LinkedHashMap;
-import java.util.LinkedHashSet;
+import java.util.Collections;
 import java.util.List;
-import java.util.Map;
-import java.util.Set;
 import javax.net.ssl.SSLPeerUnverifiedException;
 import okhttp3.internal.Util;
 import okhttp3.internal.tls.CertificateChainCleaner;
 import okhttp3.internal.tls.TrustRootIndex;
 import okio.ByteString;
 
-import static java.util.Collections.unmodifiableSet;
-
 /**
  * Constrains which certificates are trusted. Pinning certificates defends against attacks on
  * certificate authorities. It also prevents connections through man-in-the-middle certificate
  * authorities either known or unknown to the application's user.
  *
  * <p>This class currently pins a certificate's Subject Public Key Info as described on <a
- * href="http://goo.gl/AIx3e5">Adam Langley's Weblog</a>. Pins are base-64 SHA-1 hashes, consistent
- * with the format Chromium uses for <a href="http://goo.gl/XDh6je">static certificates</a>. See
- * Chromium's <a href="http://goo.gl/4CCnGs">pinsets</a> for hostnames that are pinned in that
- * browser.
+ * href="http://goo.gl/AIx3e5">Adam Langley's Weblog</a>. Pins are either base64 SHA-256 hashes as
+ * in <a href="http://tools.ietf.org/html/rfc7469">HTTP Public Key Pinning (HPKP)</a> or SHA-1
+ * base64 hashes as in Chromium's <a href="http://goo.gl/XDh6je">static certificates</a>.
  *
  * <h3>Setting up Certificate Pinning</h3>
  *
@@ -54,7 +49,7 @@
  *
  *     String hostname = "publicobject.com";
  *     CertificatePinner certificatePinner = new CertificatePinner.Builder()
- *         .add(hostname, "sha1/AAAAAAAAAAAAAAAAAAAAAAAAAAA=")
+ *         .add(hostname, "sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=")
  *         .build();
  *     OkHttpClient client = new OkHttpClient();
  *     client.setCertificatePinner(certificatePinner);
@@ -69,12 +64,12 @@
  *
  * javax.net.ssl.SSLPeerUnverifiedException: Certificate pinning failure!
  *   Peer certificate chain:
- *     sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw=: CN=publicobject.com, OU=PositiveSSL
- *     sha1/SXxoaOSEzPC6BgGmxAt/EAcsajw=: CN=COMODO RSA Domain Validation Secure Server CA
- *     sha1/blhOM3W9V/bVQhsWAcLYwPU6n24=: CN=COMODO RSA Certification Authority
- *     sha1/T5x9IXmcrQ7YuQxXnxoCmeeQ84c=: CN=AddTrust External CA Root
+ *     sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=: CN=publicobject.com, OU=PositiveSSL
+ *     sha256/klO23nT2ehFDXCfx3eHTDRESMz3asj1muO+4aIdjiuY=: CN=COMODO RSA Secure Server CA
+ *     sha256/grX4Ta9HpZx6tSHkmCrvpApTQGo67CYDnvprLg5yRME=: CN=COMODO RSA Certification Authority
+ *     sha256/lCppFqbkrlJ3EcVFAkeip0+44VaoJUymbnOaEUk7tEU=: CN=AddTrust External CA Root
  *   Pinned certificates for publicobject.com:
- *     sha1/AAAAAAAAAAAAAAAAAAAAAAAAAAA=
+ *     sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=
  *   at okhttp3.CertificatePinner.check(CertificatePinner.java)
  *   at okhttp3.Connection.upgradeToTls(Connection.java)
  *   at okhttp3.Connection.connect(Connection.java)
@@ -85,10 +80,10 @@
  * certificate pinner's configuration: <pre>   {@code
  *
  *     CertificatePinner certificatePinner = new CertificatePinner.Builder()
- *       .add("publicobject.com", "sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw=")
- *       .add("publicobject.com", "sha1/SXxoaOSEzPC6BgGmxAt/EAcsajw=")
- *       .add("publicobject.com", "sha1/blhOM3W9V/bVQhsWAcLYwPU6n24=")
- *       .add("publicobject.com", "sha1/T5x9IXmcrQ7YuQxXnxoCmeeQ84c=")
+ *       .add("publicobject.com", "sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=")
+ *       .add("publicobject.com", "sha256/klO23nT2ehFDXCfx3eHTDRESMz3asj1muO+4aIdjiuY=")
+ *       .add("publicobject.com", "sha256/grX4Ta9HpZx6tSHkmCrvpApTQGo67CYDnvprLg5yRME=")
+ *       .add("publicobject.com", "sha256/lCppFqbkrlJ3EcVFAkeip0+44VaoJUymbnOaEUk7tEU=")
  *       .build();
  * }</pre>
  *
@@ -129,11 +124,11 @@
 public final class CertificatePinner {
   public static final CertificatePinner DEFAULT = new Builder().build();
 
-  private final Map<String, Set<ByteString>> hostnameToPins;
+  private final List<Pin> pins;
   private final TrustRootIndex trustRootIndex;
 
   private CertificatePinner(Builder builder) {
-    this.hostnameToPins = Util.immutableMap(builder.hostnameToPins);
+    this.pins = Util.immutableList(builder.pins);
     this.trustRootIndex = builder.trustRootIndex;
   }
 
@@ -147,31 +142,47 @@ private CertificatePinner(Builder builder) {
    */
   public void check(String hostname, List<Certificate> peerCertificates)
       throws SSLPeerUnverifiedException {
-    Set<ByteString> pins = findMatchingPins(hostname);
-
-    if (pins == null) return;
+    List<Pin> pins = findMatchingPins(hostname);
+    if (pins.isEmpty()) return;
 
     if (trustRootIndex != null) {
       peerCertificates = new CertificateChainCleaner(trustRootIndex).clean(peerCertificates);
     }
 
-    for (int i = 0, size = peerCertificates.size(); i < size; i++) {
-      X509Certificate x509Certificate = (X509Certificate) peerCertificates.get(i);
-      if (pins.contains(sha1(x509Certificate))) return; // Success!
+    for (int c = 0, certsSize = peerCertificates.size(); c < certsSize; c++) {
+      X509Certificate x509Certificate = (X509Certificate) peerCertificates.get(c);
+
+      // Lazily compute the hashes for each certificate.
+      ByteString sha1 = null;
+      ByteString sha256 = null;
+
+      for (int p = 0, pinsSize = pins.size(); p < pinsSize; p++) {
+        Pin pin = pins.get(p);
+        if (pin.hashAlgorithm.equals("sha256/")) {
+          if (sha256 == null) sha256 = sha256(x509Certificate);
+          if (pin.hash.equals(sha256)) return; // Success!
+        } else if (pin.hashAlgorithm.equals("sha1/")) {
+          if (sha1 == null) sha1 = sha1(x509Certificate);
+          if (pin.hash.equals(sha1)) return; // Success!
+        } else {
+          throw new AssertionError();
+        }
+      }
     }
 
     // If we couldn't find a matching pin, format a nice exception.
     StringBuilder message = new StringBuilder()
         .append("Certificate pinning failure!")
         .append("\n  Peer certificate chain:");
-    for (int i = 0, size = peerCertificates.size(); i < size; i++) {
-      X509Certificate x509Certificate = (X509Certificate) peerCertificates.get(i);
+    for (int c = 0, certsSize = peerCertificates.size(); c < certsSize; c++) {
+      X509Certificate x509Certificate = (X509Certificate) peerCertificates.get(c);
       message.append("\n    ").append(pin(x509Certificate))
           .append(": ").append(x509Certificate.getSubjectDN().getName());
     }
     message.append("\n  Pinned certificates for ").append(hostname).append(":");
-    for (ByteString pin : pins) {
-      message.append("\n    sha1/").append(pin.base64());
+    for (int p = 0, pinsSize = pins.size(); p < pinsSize; p++) {
+      Pin pin = pins.get(p);
+      message.append("\n    ").append(pin);
     }
     throw new SSLPeerUnverifiedException(message.toString());
   }
@@ -183,36 +194,18 @@ public void check(String hostname, Certificate... peerCertificates)
   }
 
   /**
-   * Returns list of matching certificates' pins for the hostname or {@code null} if hostname does
-   * not have pinned certificates.
+   * Returns list of matching certificates' pins for the hostname. Returns an empty list if the
+   * hostname does not have pinned certificates.
    */
-  Set<ByteString> findMatchingPins(String hostname) {
-    Set<ByteString> directPins = hostnameToPins.get(hostname);
-    Set<ByteString> wildcardPins = null;
-
-    int indexOfFirstDot = hostname.indexOf('.');
-    int indexOfLastDot = hostname.lastIndexOf('.');
-
-    // Skip hostnames with one dot symbol for wildcard pattern search
-    //   example.com   will  be skipped
-    //   a.example.com won't be skipped
-    if (indexOfFirstDot != indexOfLastDot) {
-      // a.example.com -> search for wildcard pattern *.example.com
-      wildcardPins = hostnameToPins.get("*." + hostname.substring(indexOfFirstDot + 1));
-    }
-
-    if (directPins == null && wildcardPins == null) return null;
-
-    if (directPins != null && wildcardPins != null) {
-      Set<ByteString> pins = new LinkedHashSet<>();
-      pins.addAll(directPins);
-      pins.addAll(wildcardPins);
-      return pins;
+  List<Pin> findMatchingPins(String hostname) {
+    List<Pin> result = Collections.emptyList();
+    for (Pin pin : pins) {
+      if (pin.matches(hostname)) {
+        if (result.isEmpty()) result = new ArrayList<>();
+        result.add(pin);
+      }
     }
-
-    if (directPins != null) return directPins;
-
-    return wildcardPins;
+    return result;
   }
 
   Builder newBuilder() {
@@ -220,31 +213,89 @@ Builder newBuilder() {
   }
 
   /**
-   * Returns the SHA-1 of {@code certificate}'s public key. This uses the mechanism Moxie
-   * Marlinspike describes in <a href="https://github.com/moxie0/AndroidPinning">Android
-   * Pinning</a>.
+   * Returns the SHA-256 of {@code certificate}'s public key.
+   *
+   * <p>In OkHttp 3.1.2 and earlier, this returned a SHA-1 hash of the public key. Both types are
+   * supported, but SHA-256 is preferred.
    */
   public static String pin(Certificate certificate) {
     if (!(certificate instanceof X509Certificate)) {
       throw new IllegalArgumentException("Certificate pinning requires X509 certificates");
     }
-    return "sha1/" + sha1((X509Certificate) certificate).base64();
+    return "sha256/" + sha256((X509Certificate) certificate).base64();
   }
 
-  private static ByteString sha1(X509Certificate x509Certificate) {
+  static ByteString sha1(X509Certificate x509Certificate) {
     return Util.sha1(ByteString.of(x509Certificate.getPublicKey().getEncoded()));
   }
 
+  static ByteString sha256(X509Certificate x509Certificate) {
+    return Util.sha256(ByteString.of(x509Certificate.getPublicKey().getEncoded()));
+  }
+
+  static final class Pin {
+    /** A hostname like {@code example.com} or a pattern like {@code *.example.com}. */
+    final String pattern;
+    /** Either {@code sha1/} or {@code sha256/}. */
+    final String hashAlgorithm;
+    /** The hash of the pinned certificate using {@link #hashAlgorithm}. */
+    final ByteString hash;
+
+    Pin(String pattern, String pin) {
+      this.pattern = pattern;
+      if (pin.startsWith("sha1/")) {
+        this.hashAlgorithm = "sha1/";
+        this.hash = ByteString.decodeBase64(pin.substring("sha1/".length()));
+      } else if (pin.startsWith("sha256/")) {
+        this.hashAlgorithm = "sha256/";
+        this.hash = ByteString.decodeBase64(pin.substring("sha256/".length()));
+      } else {
+        throw new IllegalArgumentException("pins must start with 'sha256/' or 'sha1/': " + pin);
+      }
+
+      if (this.hash == null) {
+        throw new IllegalArgumentException("pins must be base64: " + pin);
+      }
+    }
+
+    boolean matches(String hostname) {
+      if (pattern.equals(hostname)) return true;
+
+      int firstDot = hostname.indexOf('.');
+      return pattern.startsWith("*.")
+          && hostname.regionMatches(false, firstDot + 1, pattern, 2, pattern.length() - 2);
+    }
+
+    @Override public boolean equals(Object other) {
+      return other instanceof Pin
+          && pattern.equals(((Pin) other).pattern)
+          && hashAlgorithm.equals(((Pin) other).hashAlgorithm)
+          && hash.equals(((Pin) other).hash);
+    }
+
+    @Override public int hashCode() {
+      int result = 17;
+      result = 31 * result + pattern.hashCode();
+      result = 31 * result + hashAlgorithm.hashCode();
+      result = 31 * result + hash.hashCode();
+      return result;
+    }
+
+    @Override public String toString() {
+      return hashAlgorithm + hash.base64();
+    }
+  }
+
   /** Builds a configured certificate pinner. */
   public static final class Builder {
-    private final Map<String, Set<ByteString>> hostnameToPins = new LinkedHashMap<>();
+    private final List<Pin> pins = new ArrayList<>();
     private TrustRootIndex trustRootIndex;
 
     public Builder() {
     }
 
     Builder(CertificatePinner certificatePinner) {
-      this.hostnameToPins.putAll(certificatePinner.hostnameToPins);
+      this.pins.addAll(certificatePinner.pins);
       this.trustRootIndex = certificatePinner.trustRootIndex;
     }
 
@@ -254,30 +305,17 @@ public Builder trustRootIndex(TrustRootIndex trustRootIndex) {
     }
 
     /**
-     * Pins certificates for {@code hostname}.
+     * Pins certificates for {@code pattern}.
      *
-     * @param hostname lower-case host name or wildcard pattern such as {@code *.example.com}.
-     * @param pins SHA-1 hashes. Each pin is a SHA-1 hash of a certificate's Subject Public Key
-     * Info, base64-encoded and prefixed with {@code sha1/}.
+     * @param pattern lower-case host name or wildcard pattern such as {@code *.example.com}.
+     * @param pins SHA-256 or SHA-1 hashes. Each pin is a hash of a certificate's Subject Public Key
+     * Info, base64-encoded and prefixed with either {@code sha256/} or {@code sha1/}.
      */
-    public Builder add(String hostname, String... pins) {
-      if (hostname == null) throw new IllegalArgumentException("hostname == null");
-
-      Set<ByteString> hostPins = new LinkedHashSet<>();
-      Set<ByteString> previousPins = hostnameToPins.put(hostname, unmodifiableSet(hostPins));
-      if (previousPins != null) {
-        hostPins.addAll(previousPins);
-      }
+    public Builder add(String pattern, String... pins) {
+      if (pattern == null) throw new IllegalArgumentException("pattern == null");
 
       for (String pin : pins) {
-        if (!pin.startsWith("sha1/")) {
-          throw new IllegalArgumentException("pins must start with 'sha1/': " + pin);
-        }
-        ByteString decodedPin = ByteString.decodeBase64(pin.substring("sha1/".length()));
-        if (decodedPin == null) {
-          throw new IllegalArgumentException("pins must be base64: " + pin);
-        }
-        hostPins.add(decodedPin);
+        this.pins.add(new Pin(pattern, pin));
       }
 
       return this;
diff --git a/okhttp/src/main/java/okhttp3/HttpUrl.java b/okhttp/src/main/java/okhttp3/HttpUrl.java
index 59cbdd4350..d7c0c35c30 100644
--- a/okhttp/src/main/java/okhttp3/HttpUrl.java
+++ b/okhttp/src/main/java/okhttp3/HttpUrl.java
@@ -772,6 +772,15 @@ public Builder addPathSegment(String pathSegment) {
       return this;
     }
 
+    /**
+     * Adds a set of path segments separated by a slash (either {@code \} or {@code /}). If
+     * {@code pathSegments} starts with a slash, the resulting URL will have empty path segment.
+     */
+    public Builder addPathSegments(String pathSegments) {
+      if (pathSegments == null) throw new IllegalArgumentException("pathSegments == null");
+      return addPathSegments(pathSegments, false);
+    }
+
     public Builder addEncodedPathSegment(String encodedPathSegment) {
       if (encodedPathSegment == null) {
         throw new IllegalArgumentException("encodedPathSegment == null");
@@ -780,6 +789,29 @@ public Builder addEncodedPathSegment(String encodedPathSegment) {
       return this;
     }
 
+    /**
+     * Adds a set of encoded path segments separated by a slash (either {@code \} or {@code /}). If
+     * {@code encodedPathSegments} starts with a slash, the resulting URL will have empty path
+     * segment.
+     */
+    public Builder addEncodedPathSegments(String encodedPathSegments) {
+      if (encodedPathSegments == null) {
+        throw new IllegalArgumentException("encodedPathSegments == null");
+      }
+      return addPathSegments(encodedPathSegments, true);
+    }
+
+    private Builder addPathSegments(String pathSegments, boolean alreadyEncoded) {
+      int offset = 0;
+      do {
+        int segmentEnd = delimiterOffset(pathSegments, offset, pathSegments.length(), "/\\");
+        boolean addTrailingSlash = segmentEnd < pathSegments.length();
+        push(pathSegments, offset, segmentEnd, addTrailingSlash, alreadyEncoded);
+        offset = segmentEnd + 1;
+      } while (offset <= pathSegments.length());
+      return this;
+    }
+
     public Builder setPathSegment(int index, String pathSegment) {
       if (pathSegment == null) throw new IllegalArgumentException("pathSegment == null");
       String canonicalPathSegment = canonicalize(
@@ -1270,9 +1302,12 @@ private static String canonicalizeHost(String input, int pos, int limit) {
       // checked for IPv6 square braces. But Chrome does it first, and that's more lenient.
       String percentDecoded = percentDecode(input, pos, limit, false);
 
-      // If the input is encased in square braces "[...]", drop 'em. We have an IPv6 address.
-      if (percentDecoded.startsWith("[") && percentDecoded.endsWith("]")) {
-        InetAddress inetAddress = decodeIpv6(percentDecoded, 1, percentDecoded.length() - 1);
+      // If the input contains a :, it’s an IPv6 address.
+      if (percentDecoded.contains(":")) {
+        // If the input is encased in square braces "[...]", drop 'em.
+        InetAddress inetAddress = percentDecoded.startsWith("[") && percentDecoded.endsWith("]")
+            ? decodeIpv6(percentDecoded, 1, percentDecoded.length() - 1)
+            : decodeIpv6(percentDecoded, 0, percentDecoded.length());
         if (inetAddress == null) return null;
         byte[] address = inetAddress.getAddress();
         if (address.length == 16) return inet6AddressToAscii(address);
diff --git a/okhttp/src/main/java/okhttp3/internal/DiskLruCache.java b/okhttp/src/main/java/okhttp3/internal/DiskLruCache.java
index 25e12eeb92..1be6a93b4f 100644
--- a/okhttp/src/main/java/okhttp3/internal/DiskLruCache.java
+++ b/okhttp/src/main/java/okhttp3/internal/DiskLruCache.java
@@ -151,6 +151,7 @@
   // Must be read and written when synchronized on 'this'.
   private boolean initialized;
   private boolean closed;
+  private boolean mostRecentTrimFailed;
 
   /**
    * To differentiate between old and current snapshots, each entry is given a sequence number each
@@ -167,8 +168,14 @@ public void run() {
         if (!initialized | closed) {
           return; // Nothing to do
         }
+
         try {
           trimToSize();
+        } catch (IOException ignored) {
+          mostRecentTrimFailed = true;
+        }
+
+        try {
           if (journalRebuildRequired()) {
             rebuildJournal();
             redundantOpCount = 0;
@@ -453,6 +460,11 @@ private synchronized Editor edit(String key, long expectedSequenceNumber) throws
     if (entry != null && entry.currentEditor != null) {
       return null; // Another edit is in progress.
     }
+    if (mostRecentTrimFailed) {
+      // Prevent new writes so the cache doesn't grow any further and retry the clean up operation.
+      executor.execute(cleanupRunnable);
+      return null;
+    }
 
     // Flush the journal before creating files to prevent file leaks.
     journalWriter.writeUtf8(DIRTY).writeByte(' ').writeUtf8(key).writeByte('\n');
@@ -586,7 +598,9 @@ public synchronized boolean remove(String key) throws IOException {
     validateKey(key);
     Entry entry = lruEntries.get(key);
     if (entry == null) return false;
-    return removeEntry(entry);
+    boolean removed = removeEntry(entry);
+    if (removed && size <= maxSize) mostRecentTrimFailed = false;
+    return removed;
   }
 
   private boolean removeEntry(Entry entry) throws IOException {
@@ -654,6 +668,7 @@ private void trimToSize() throws IOException {
       Entry toEvict = lruEntries.values().iterator().next();
       removeEntry(toEvict);
     }
+    mostRecentTrimFailed = false;
   }
 
   /**
@@ -675,6 +690,7 @@ public synchronized void evictAll() throws IOException {
     for (Entry entry : lruEntries.values().toArray(new Entry[lruEntries.size()])) {
       removeEntry(entry);
     }
+    mostRecentTrimFailed = false;
   }
 
   private void validateKey(String key) {
diff --git a/okhttp/src/main/java/okhttp3/internal/Util.java b/okhttp/src/main/java/okhttp3/internal/Util.java
index e9efad04c6..4dc139f4fb 100644
--- a/okhttp/src/main/java/okhttp3/internal/Util.java
+++ b/okhttp/src/main/java/okhttp3/internal/Util.java
@@ -223,6 +223,17 @@ public static ByteString sha1(ByteString s) {
     }
   }
 
+  /** Returns a SHA-256 hash of {@code s}. */
+  public static ByteString sha256(ByteString s) {
+    try {
+      MessageDigest messageDigest = MessageDigest.getInstance("SHA-256");
+      byte[] sha1Bytes = messageDigest.digest(s.toByteArray());
+      return ByteString.of(sha1Bytes);
+    } catch (NoSuchAlgorithmException e) {
+      throw new AssertionError(e);
+    }
+  }
+
   /** Returns an immutable copy of {@code list}. */
   public static <T> List<T> immutableList(List<T> list) {
     return Collections.unmodifiableList(new ArrayList<>(list));
@@ -275,11 +286,13 @@ public static ThreadFactory threadFactory(final String name, final boolean daemo
     return result;
   }
 
-  public static String hostHeader(HttpUrl url) {
-    // TODO: square braces for IPv6 ?
-    return url.port() != HttpUrl.defaultPort(url.scheme())
-        ? url.host() + ":" + url.port()
+  public static String hostHeader(HttpUrl url, boolean includeDefaultPort) {
+    String host = url.host().contains(":")
+        ? "[" + url.host() + "]"
         : url.host();
+    return includeDefaultPort || url.port() != HttpUrl.defaultPort(url.scheme())
+        ? host + ":" + url.port()
+        : host;
   }
 
   /** Returns {@code s} with control characters and non-ASCII characters replaced with '?'. */
diff --git a/okhttp/src/main/java/okhttp3/internal/http/Http2xStream.java b/okhttp/src/main/java/okhttp3/internal/http/Http2xStream.java
index 83cddc3e5a..99151f8371 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/Http2xStream.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/Http2xStream.java
@@ -161,7 +161,7 @@ public Http2xStream(StreamAllocation streamAllocation, FramedConnection framedCo
     result.add(new Header(TARGET_METHOD, request.method()));
     result.add(new Header(TARGET_PATH, RequestLine.requestPath(request.url())));
     result.add(new Header(VERSION, "HTTP/1.1"));
-    result.add(new Header(TARGET_HOST, Util.hostHeader(request.url())));
+    result.add(new Header(TARGET_HOST, Util.hostHeader(request.url(), false)));
     result.add(new Header(TARGET_SCHEME, request.url().scheme()));
 
     Set<ByteString> names = new LinkedHashSet<>();
@@ -200,7 +200,7 @@ private static String joinOnNull(String first, String second) {
     List<Header> result = new ArrayList<>(headers.size() + 4);
     result.add(new Header(TARGET_METHOD, request.method()));
     result.add(new Header(TARGET_PATH, RequestLine.requestPath(request.url())));
-    result.add(new Header(TARGET_AUTHORITY, Util.hostHeader(request.url()))); // Optional.
+    result.add(new Header(TARGET_AUTHORITY, Util.hostHeader(request.url(), false))); // Optional.
     result.add(new Header(TARGET_SCHEME, request.url().scheme()));
 
     for (int i = 0, size = headers.size(); i < size; i++) {
diff --git a/okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java b/okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java
index a4de543bc7..b7c9f6432f 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java
@@ -502,7 +502,7 @@ private Request networkRequest(Request request) throws IOException {
     Request.Builder result = request.newBuilder();
 
     if (request.header("Host") == null) {
-      result.header("Host", hostHeader(request.url()));
+      result.header("Host", hostHeader(request.url(), false));
     }
 
     if (request.header("Connection") == null) {
diff --git a/okhttp/src/main/java/okhttp3/internal/io/RealConnection.java b/okhttp/src/main/java/okhttp3/internal/io/RealConnection.java
index e0fe6ccc7d..ed8019e2f6 100644
--- a/okhttp/src/main/java/okhttp3/internal/io/RealConnection.java
+++ b/okhttp/src/main/java/okhttp3/internal/io/RealConnection.java
@@ -241,7 +241,7 @@ private void createTunnel(int readTimeout, int writeTimeout) throws IOException
     // Make an SSL Tunnel on the first message pair of each SSL + proxy connection.
     Request tunnelRequest = createTunnelRequest();
     HttpUrl url = tunnelRequest.url();
-    String requestLine = "CONNECT " + url.host() + ":" + url.port() + " HTTP/1.1";
+    String requestLine = "CONNECT " + Util.hostHeader(url, true) + " HTTP/1.1";
     while (true) {
       Http1xStream tunnelConnection = new Http1xStream(null, source, sink);
       source.timeout().timeout(readTimeout, MILLISECONDS);
@@ -291,7 +291,7 @@ private void createTunnel(int readTimeout, int writeTimeout) throws IOException
   private Request createTunnelRequest() throws IOException {
     return new Request.Builder()
         .url(route.address().url())
-        .header("Host", Util.hostHeader(route.address().url()))
+        .header("Host", Util.hostHeader(route.address().url(), true))
         .header("Proxy-Connection", "Keep-Alive")
         .header("User-Agent", Version.userAgent()) // For HTTP/1.0 proxies like Squid.
         .build();
diff --git a/okhttp/src/main/java/okhttp3/internal/tls/AndroidTrustRootIndex.java b/okhttp/src/main/java/okhttp3/internal/tls/AndroidTrustRootIndex.java
index 3805939c1c..3074a1e98d 100644
--- a/okhttp/src/main/java/okhttp3/internal/tls/AndroidTrustRootIndex.java
+++ b/okhttp/src/main/java/okhttp3/internal/tls/AndroidTrustRootIndex.java
@@ -40,7 +40,9 @@ public AndroidTrustRootIndex(
     try {
       TrustAnchor trustAnchor = (TrustAnchor) findByIssuerAndSignatureMethod.invoke(
           trustManager, cert);
-      return trustAnchor.getTrustedCert();
+      return trustAnchor != null
+          ? trustAnchor.getTrustedCert()
+          : null;
     } catch (IllegalAccessException e) {
       throw new AssertionError();
     } catch (InvocationTargetException e) {
diff --git a/okhttp/src/main/java/okhttp3/internal/tls/CertificateChainCleaner.java b/okhttp/src/main/java/okhttp3/internal/tls/CertificateChainCleaner.java
index 0121aba30c..d887df615c 100644
--- a/okhttp/src/main/java/okhttp3/internal/tls/CertificateChainCleaner.java
+++ b/okhttp/src/main/java/okhttp3/internal/tls/CertificateChainCleaner.java
@@ -40,6 +40,9 @@
  * TrustManagerImpl} and {@code TrustedCertificateIndex}.
  */
 public final class CertificateChainCleaner {
+  /** The maximum number of signers in a chain. We use 9 for consistency with OpenSSL. */
+  private static final int MAX_SIGNERS = 9;
+
   private final TrustRootIndex trustRootIndex;
 
   public CertificateChainCleaner(TrustRootIndex trustRootIndex) {
@@ -57,40 +60,53 @@ public CertificateChainCleaner(TrustRootIndex trustRootIndex) {
     Deque<Certificate> queue = new ArrayDeque<>(chain);
     List<Certificate> result = new ArrayList<>();
     result.add(queue.removeFirst());
+    boolean foundTrustedCertificate = false;
 
     followIssuerChain:
-    while (true) {
+    for (int c = 0; c < MAX_SIGNERS; c++) {
       X509Certificate toVerify = (X509Certificate) result.get(result.size() - 1);
 
-      // If this cert has been signed by a trusted CA cert, we're done. Add the trusted CA
-      // certificate to the end of the chain, unless it's already present. (That would happen if the
-      // first certificate in the chain is itself a self-signed and trusted CA certificate.)
-      X509Certificate caCert = trustRootIndex.findByIssuerAndSignature(toVerify);
-      if (caCert != null) {
-        if (result.size() > 1 || !toVerify.equals(caCert)) {
-          result.add(caCert);
+      // If this cert has been signed by a trusted cert, use that. Add the trusted certificate to
+      // the end of the chain unless it's already present. (That would happen if the first
+      // certificate in the chain is itself a self-signed and trusted CA certificate.)
+      X509Certificate trustedCert = trustRootIndex.findByIssuerAndSignature(toVerify);
+      if (trustedCert != null) {
+        if (result.size() > 1 || !toVerify.equals(trustedCert)) {
+          result.add(trustedCert);
         }
-        return result;
+        if (verifySignature(trustedCert, trustedCert)) {
+          return result; // The self-signed cert is a root CA. We're done.
+        }
+        foundTrustedCertificate = true;
+        continue;
       }
 
       // Search for the certificate in the chain that signed this certificate. This is typically the
       // next element in the chain, but it could be any element.
       for (Iterator<Certificate> i = queue.iterator(); i.hasNext(); ) {
         X509Certificate signingCert = (X509Certificate) i.next();
-        if (toVerify.getIssuerDN().equals(signingCert.getSubjectDN())
-            && verifySignature(toVerify, signingCert)) {
+        if (verifySignature(toVerify, signingCert)) {
           i.remove();
           result.add(signingCert);
           continue followIssuerChain;
         }
       }
 
-      throw new SSLPeerUnverifiedException("Failed to find a cert that signed " + toVerify);
+      // We've reached the end of the chain. If any cert in the chain is trusted, we're done.
+      if (foundTrustedCertificate) {
+        return result;
+      }
+
+      // The last link isn't trusted. Fail.
+      throw new SSLPeerUnverifiedException("Failed to find a trusted cert that signed " + toVerify);
     }
+
+    throw new SSLPeerUnverifiedException("Certificate chain too long: " + result);
   }
 
   /** Returns true if {@code toVerify} was signed by {@code signingCert}'s public key. */
   private boolean verifySignature(X509Certificate toVerify, X509Certificate signingCert) {
+    if (!toVerify.getIssuerDN().equals(signingCert.getSubjectDN())) return false;
     try {
       toVerify.verify(signingCert.getPublicKey());
       return true;
diff --git a/samples/guide/src/main/java/okhttp3/recipes/CertificatePinning.java b/samples/guide/src/main/java/okhttp3/recipes/CertificatePinning.java
index b890be7577..0dbf7aaf9a 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/CertificatePinning.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/CertificatePinning.java
@@ -29,10 +29,10 @@ public CertificatePinning() {
     client = new OkHttpClient.Builder()
         .certificatePinner(
             new CertificatePinner.Builder()
-                .add("publicobject.com", "sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw=")
-                .add("publicobject.com", "sha1/SXxoaOSEzPC6BgGmxAt/EAcsajw=")
-                .add("publicobject.com", "sha1/blhOM3W9V/bVQhsWAcLYwPU6n24=")
-                .add("publicobject.com", "sha1/T5x9IXmcrQ7YuQxXnxoCmeeQ84c=")
+                .add("publicobject.com", "sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=")
+                .add("publicobject.com", "sha256/klO23nT2ehFDXCfx3eHTDRESMz3asj1muO+4aIdjiuY=")
+                .add("publicobject.com", "sha256/grX4Ta9HpZx6tSHkmCrvpApTQGo67CYDnvprLg5yRME=")
+                .add("publicobject.com", "sha256/lCppFqbkrlJ3EcVFAkeip0+44VaoJUymbnOaEUk7tEU=")
                 .build())
         .build();
   }
