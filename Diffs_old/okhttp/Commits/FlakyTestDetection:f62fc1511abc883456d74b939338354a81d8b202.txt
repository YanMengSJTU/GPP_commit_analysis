diff --git a/okhttp-tests/src/test/java/okhttp3/EventListenerTest.java b/okhttp-tests/src/test/java/okhttp3/EventListenerTest.java
index d11ea05bb4..f74c423f89 100644
--- a/okhttp-tests/src/test/java/okhttp3/EventListenerTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/EventListenerTest.java
@@ -23,21 +23,11 @@
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
-import okhttp3.RecordingEventListener.CallEvent;
 import okhttp3.RecordingEventListener.ConnectEnd;
 import okhttp3.RecordingEventListener.ConnectStart;
 import okhttp3.RecordingEventListener.ConnectionAcquired;
-import okhttp3.RecordingEventListener.ConnectionReleased;
 import okhttp3.RecordingEventListener.DnsEnd;
 import okhttp3.RecordingEventListener.DnsStart;
-import okhttp3.RecordingEventListener.FetchEnd;
-import okhttp3.RecordingEventListener.FetchStart;
-import okhttp3.RecordingEventListener.RequestHeadersEnd;
-import okhttp3.RecordingEventListener.RequestHeadersStart;
-import okhttp3.RecordingEventListener.ResponseBodyEnd;
-import okhttp3.RecordingEventListener.ResponseBodyStart;
-import okhttp3.RecordingEventListener.ResponseHeadersEnd;
-import okhttp3.RecordingEventListener.ResponseHeadersStart;
 import okhttp3.RecordingEventListener.SecureConnectEnd;
 import okhttp3.RecordingEventListener.SecureConnectStart;
 import okhttp3.internal.DoubleInetAddressDns;
@@ -94,12 +84,11 @@
     assertEquals(200, response.code());
     response.body().close();
 
-    // TODO ResponseBodyEnd should not be last event
     List<String> expectedEvents = Arrays.asList("FetchStart",
         "DnsStart", "DnsEnd", "ConnectStart", "ConnectEnd",
         "ConnectionAcquired", "RequestHeadersStart", "RequestHeadersEnd",
         "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
-        "ConnectionReleased", "FetchEnd", "ResponseBodyEnd");
+        "ResponseBodyEnd", "ConnectionReleased", "FetchEnd");
     assertEquals(expectedEvents, listener.recordedEventTypes());
   }
 
@@ -114,13 +103,12 @@
     assertEquals(200, response.code());
     response.body().close();
 
-    // TODO ResponseBodyEnd should not be last event
     List<String> expectedEvents = Arrays.asList("FetchStart",
         "DnsStart", "DnsEnd", "ConnectStart", "SecureConnectStart",
         "SecureConnectEnd", "ConnectEnd",
         "ConnectionAcquired", "RequestHeadersStart", "RequestHeadersEnd",
         "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
-        "ConnectionReleased", "FetchEnd", "ResponseBodyEnd");
+        "ResponseBodyEnd", "ConnectionReleased", "FetchEnd");
     assertEquals(expectedEvents, listener.recordedEventTypes());
   }
 
diff --git a/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java b/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java
index 1421099db0..4618571413 100644
--- a/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java
+++ b/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java
@@ -36,7 +36,6 @@
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
-import okio.ForwardingSource;
 import okio.ForwardingTimeout;
 import okio.Okio;
 import okio.Sink;
@@ -131,35 +130,10 @@ public Http1Codec(OkHttpClient client, StreamAllocation streamAllocation, Buffer
 
   @Override public ResponseBody openResponseBody(Response response) throws IOException {
     streamAllocation.eventListener.responseBodyStart(streamAllocation.call);
-    Source source = new EventListenerSource(getTransferStream(response));
+    Source source = getTransferStream(response);
     return new RealResponseBody(response.headers(), Okio.buffer(source));
   }
 
-  class EventListenerSource extends ForwardingSource {
-    private boolean completed = false;
-
-    EventListenerSource(Source delegate) {
-      super(delegate);
-    }
-
-    @Override public long read(Buffer sink, long byteCount) throws IOException {
-      try {
-        return super.read(sink, byteCount);
-      } catch (IOException ioe) {
-        completed = true;
-        streamAllocation.eventListener.responseBodyEnd(streamAllocation.call, ioe);
-        throw ioe;
-      }
-    }
-
-    @Override public void close() throws IOException {
-      if (!completed) {
-        streamAllocation.eventListener.responseBodyEnd(streamAllocation.call, null);
-      }
-      super.close();
-    }
-  }
-
   private Source getTransferStream(Response response) throws IOException {
     if (!HttpHeaders.hasBody(response)) {
       return newFixedLengthSource(0);
@@ -375,11 +349,20 @@ void detachTimeout(ForwardingTimeout timeout) {
       return timeout;
     }
 
+    @Override public long read(Buffer sink, long byteCount) throws IOException {
+      try {
+        return source.read(sink, byteCount);
+      } catch (IOException e) {
+        endOfInput(false, e);
+        throw e;
+      }
+    }
+
     /**
      * Closes the cache entry and makes the socket available for reuse. This should be invoked when
      * the end of the body has been reached.
      */
-    protected final void endOfInput(boolean reuseConnection) throws IOException {
+    protected final void endOfInput(boolean reuseConnection, IOException e) throws IOException {
       if (state == STATE_CLOSED) return;
       if (state != STATE_READING_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
 
@@ -387,6 +370,7 @@ protected final void endOfInput(boolean reuseConnection) throws IOException {
 
       state = STATE_CLOSED;
       if (streamAllocation != null) {
+        streamAllocation.eventListener.responseBodyEnd(streamAllocation.call, e);
         streamAllocation.streamFinished(!reuseConnection, Http1Codec.this);
       }
     }
@@ -399,7 +383,7 @@ protected final void endOfInput(boolean reuseConnection) throws IOException {
     FixedLengthSource(long length) throws IOException {
       bytesRemaining = length;
       if (bytesRemaining == 0) {
-        endOfInput(true);
+        endOfInput(true, null);
       }
     }
 
@@ -408,15 +392,16 @@ protected final void endOfInput(boolean reuseConnection) throws IOException {
       if (closed) throw new IllegalStateException("closed");
       if (bytesRemaining == 0) return -1;
 
-      long read = source.read(sink, Math.min(bytesRemaining, byteCount));
+      long read = super.read(sink, Math.min(bytesRemaining, byteCount));
       if (read == -1) {
-        endOfInput(false); // The server didn't supply the promised content length.
-        throw new ProtocolException("unexpected end of stream");
+        ProtocolException e = new ProtocolException("unexpected end of stream");
+        endOfInput(false, e); // The server didn't supply the promised content length.
+        throw e;
       }
 
       bytesRemaining -= read;
       if (bytesRemaining == 0) {
-        endOfInput(true);
+        endOfInput(true, null);
       }
       return read;
     }
@@ -425,7 +410,7 @@ protected final void endOfInput(boolean reuseConnection) throws IOException {
       if (closed) return;
 
       if (bytesRemaining != 0 && !Util.discard(this, DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
-        endOfInput(false);
+        endOfInput(false, null);
       }
 
       closed = true;
@@ -453,10 +438,11 @@ protected final void endOfInput(boolean reuseConnection) throws IOException {
         if (!hasMoreChunks) return -1;
       }
 
-      long read = source.read(sink, Math.min(byteCount, bytesRemainingInChunk));
+      long read = super.read(sink, Math.min(byteCount, bytesRemainingInChunk));
       if (read == -1) {
-        endOfInput(false); // The server didn't supply the promised chunk length.
-        throw new ProtocolException("unexpected end of stream");
+        ProtocolException e = new ProtocolException("unexpected end of stream");
+        endOfInput(false, e); // The server didn't supply the promised chunk length.
+        throw e;
       }
       bytesRemainingInChunk -= read;
       return read;
@@ -480,14 +466,14 @@ private void readChunkSize() throws IOException {
       if (bytesRemainingInChunk == 0L) {
         hasMoreChunks = false;
         HttpHeaders.receiveHeaders(client.cookieJar(), url, readHeaders());
-        endOfInput(true);
+        endOfInput(true, null);
       }
     }
 
     @Override public void close() throws IOException {
       if (closed) return;
       if (hasMoreChunks && !Util.discard(this, DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
-        endOfInput(false);
+        endOfInput(false, null);
       }
       closed = true;
     }
@@ -506,10 +492,10 @@ private void readChunkSize() throws IOException {
       if (closed) throw new IllegalStateException("closed");
       if (inputExhausted) return -1;
 
-      long read = source.read(sink, byteCount);
+      long read = super.read(sink, byteCount);
       if (read == -1) {
         inputExhausted = true;
-        endOfInput(true);
+        endOfInput(true, null);
         return -1;
       }
       return read;
@@ -518,7 +504,7 @@ private void readChunkSize() throws IOException {
     @Override public void close() throws IOException {
       if (closed) return;
       if (!inputExhausted) {
-        endOfInput(false);
+        endOfInput(false, null);
       }
       closed = true;
     }
