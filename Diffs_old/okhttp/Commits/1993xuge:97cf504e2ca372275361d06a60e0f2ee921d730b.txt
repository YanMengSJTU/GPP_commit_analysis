diff --git a/okhttp/src/main/java/okhttp3/Dispatcher.java b/okhttp/src/main/java/okhttp3/Dispatcher.java
index 3e33dff6bf..c405f9609f 100644
--- a/okhttp/src/main/java/okhttp3/Dispatcher.java
+++ b/okhttp/src/main/java/okhttp3/Dispatcher.java
@@ -132,6 +132,7 @@ public synchronized void setIdleCallback(@Nullable Runnable idleCallback) {
 
   void enqueue(AsyncCall call) {
     synchronized (this) {
+      // 将 call加入到 readyAsyncCalls队列当中
       readyAsyncCalls.add(call);
     }
     promoteAndExecute();
@@ -168,19 +169,30 @@ private boolean promoteAndExecute() {
     List<AsyncCall> executableCalls = new ArrayList<>();
     boolean isRunning;
     synchronized (this) {
+      // 遍历 readyAsyncCalls
       for (Iterator<AsyncCall> i = readyAsyncCalls.iterator(); i.hasNext(); ) {
         AsyncCall asyncCall = i.next();
 
+        // 如果 runningAsyncCalls的size大于最大请求数，则直接跳出循环，不再遍历readyAsyncCalls
         if (runningAsyncCalls.size() >= maxRequests) break; // Max capacity.
+
+        // 如果 该asyncCall所运行的主机上运行的请求数 大于 最大主机请求数，那么跳过执行该请求
         if (runningCallsForHost(asyncCall) >= maxRequestsPerHost) continue; // Host max capacity.
 
+        // 将该请求从 readyAsyncCalls队列中删除
         i.remove();
+        // 将该请求加入到 executableCalls
         executableCalls.add(asyncCall);
+
+        // 将该请求加入到 runningAsyncCalls中
         runningAsyncCalls.add(asyncCall);
       }
+
+      // runningAsyncCalls.size() + runningSyncCalls.size()
       isRunning = runningCallsCount() > 0;
     }
 
+    // 遍历 executableCalls，将其中的请求对象AsyncCall放入线程池中执行
     for (int i = 0, size = executableCalls.size(); i < size; i++) {
       AsyncCall asyncCall = executableCalls.get(i);
       asyncCall.executeOn(executorService());
@@ -189,7 +201,9 @@ private boolean promoteAndExecute() {
     return isRunning;
   }
 
-  /** Returns the number of running calls that share a host with {@code call}. */
+  /** Returns the number of running calls that share a host with {@code call}.
+   * 返回该主机上运行的请求书
+   * */
   private int runningCallsForHost(AsyncCall call) {
     int result = 0;
     for (AsyncCall c : runningAsyncCalls) {
@@ -199,7 +213,9 @@ private int runningCallsForHost(AsyncCall call) {
     return result;
   }
 
-  /** Used by {@code Call#execute} to signal it is in-flight. */
+  /** Used by {@code Call#execute} to signal it is in-flight.
+   * 调用该方法，将RealCall对象加入到 runningSyncCalls中
+   * */
   synchronized void executed(RealCall call) {
     runningSyncCalls.add(call);
   }
diff --git a/okhttp/src/main/java/okhttp3/RealCall.java b/okhttp/src/main/java/okhttp3/RealCall.java
index a9ba5be366..dc6cbe8a22 100644
--- a/okhttp/src/main/java/okhttp3/RealCall.java
+++ b/okhttp/src/main/java/okhttp3/RealCall.java
@@ -68,9 +68,18 @@ private RealCall(OkHttpClient client, Request originalRequest, boolean forWebSoc
     this.timeout.timeout(client.callTimeoutMillis(), MILLISECONDS);
   }
 
+  /**
+   * 将 OkHttpClient 与 Request对象关联的实际方法
+   * @param client
+   * @param originalRequest
+   * @param forWebSocket
+   * @return
+   */
   static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {
     // Safely publish the Call instance to the EventListener.
+    // 创建newCall对象
     RealCall call = new RealCall(client, originalRequest, forWebSocket);
+    // 创建 EventListener对象
     call.eventListener = client.eventListenerFactory().create(call);
     return call;
   }
@@ -79,24 +88,43 @@ static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolea
     return originalRequest;
   }
 
+  /**
+   * 同步请求
+   * @return
+   * @throws IOException
+   */
   @Override public Response execute() throws IOException {
+    // 1、首先利用 synchronized 加入了对象锁，防止多线程同时调用
     synchronized (this) {
+      // 判断executed是否为true，
+      // true表示当前的call已经被执行了，那么抛出异常。
+      // false表示没有被执行，那么将executed设置为true，并且继续进行执行。
       if (executed) throw new IllegalStateException("Already Executed");
       executed = true;
     }
+    // 2
     captureCallStackTrace();
+
+    // 3
     timeout.enter();
+
+    // 4、回调 callStart
     eventListener.callStart(this);
     try {
+      // 5、将 RealCall对象 加入到 dispatcher的同步队列中
       client.dispatcher().executed(this);
+
+      // 6、
       Response result = getResponseWithInterceptorChain();
       if (result == null) throw new IOException("Canceled");
       return result;
     } catch (IOException e) {
       e = timeoutExit(e);
+      // 发生异常，回调 callFailed
       eventListener.callFailed(this, e);
       throw e;
     } finally {
+      //
       client.dispatcher().finished(this);
     }
   }
@@ -113,16 +141,30 @@ static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolea
 
   private void captureCallStackTrace() {
     Object callStackTrace = Platform.get().getStackTraceForCloseable("response.body().close()");
+    // retryAndFollowUpInterceptor加入了一个用于追踪堆栈信息的callStackTrace
     retryAndFollowUpInterceptor.setCallStackTrace(callStackTrace);
   }
 
+    /**
+     * 异步请求
+     * @param responseCallback
+     */
   @Override public void enqueue(Callback responseCallback) {
+      // 1、首先利用 synchronized 加入了对象锁，防止多线程同时调用
     synchronized (this) {
+        // 判断executed是否为true，
+        // true表示当前的call已经被执行了，那么抛出异常。
+        // false表示没有被执行，那么将executed设置为true，并且继续进行执行。
       if (executed) throw new IllegalStateException("Already Executed");
       executed = true;
     }
+    // 2
     captureCallStackTrace();
+
+    // 3、回调 callStart
     eventListener.callStart(this);
+
+    // 4、使用分发器
     client.dispatcher().enqueue(new AsyncCall(responseCallback));
   }
 
@@ -179,15 +221,25 @@ void executeOn(ExecutorService executorService) {
       assert (!Thread.holdsLock(client.dispatcher()));
       boolean success = false;
       try {
+          // 将该AsyncCall对象加入到线程池中。
+          // 在线程池中，会调用Runnable的run方法，AsyncCall继承自NamedRunnable。
+          // NamedRunnable中的run方法，会执行抽象方法 execute()
         executorService.execute(this);
         success = true;
       } catch (RejectedExecutionException e) {
+           //执行过程中发生了异常
         InterruptedIOException ioException = new InterruptedIOException("executor rejected");
         ioException.initCause(e);
+
+        // 回调 callFailed。eventListener是外部类RealCall的属性
         eventListener.callFailed(RealCall.this, ioException);
+
+        // responseCallback回调onFailure。responseCallback对象是从构造方法中传递过来的
         responseCallback.onFailure(RealCall.this, ioException);
       } finally {
         if (!success) {
+            // 如果线程池处理该请求失败了。调用dispatcher的finish方法。
+            // 成功，在execute()方法中已经执行了dispatcher的finish方法
           client.dispatcher().finished(this); // This call is no longer running!
         }
       }
@@ -197,6 +249,7 @@ void executeOn(ExecutorService executorService) {
       boolean signalledCallback = false;
       timeout.enter();
       try {
+        //
         Response response = getResponseWithInterceptorChain();
         if (retryAndFollowUpInterceptor.isCanceled()) {
           signalledCallback = true;
@@ -234,10 +287,16 @@ String redactedUrl() {
     return originalRequest.url().redact();
   }
 
+  /**
+   * 真正执行 网络请求的方法
+   * @return
+   * @throws IOException
+   */
   Response getResponseWithInterceptorChain() throws IOException {
     // Build a full stack of interceptors.
     List<Interceptor> interceptors = new ArrayList<>();
     interceptors.addAll(client.interceptors());
+
     interceptors.add(retryAndFollowUpInterceptor);
     interceptors.add(new BridgeInterceptor(client.cookieJar()));
     interceptors.add(new CacheInterceptor(client.internalCache()));
