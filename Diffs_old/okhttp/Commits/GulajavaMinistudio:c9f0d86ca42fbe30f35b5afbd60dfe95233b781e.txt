diff --git a/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.kt b/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.kt
index ea756eed0f..97ffcb90c1 100644
--- a/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.kt
+++ b/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.kt
@@ -168,7 +168,7 @@ class DiskLruCache internal constructor(
   private var nextSequenceNumber: Long = 0
 
   private val cleanupQueue = taskRunner.newQueue(this)
-  private val cleanupTask = object : Task("OkHttp DiskLruCache") {
+  private val cleanupTask = object : Task("OkHttp DiskLruCache", cancelable = false) {
     override fun runOnce(): Long {
       synchronized(this@DiskLruCache) {
         if (!initialized || closed) {
diff --git a/okhttp/src/main/java/okhttp3/internal/concurrent/Task.kt b/okhttp/src/main/java/okhttp3/internal/concurrent/Task.kt
index 64c836b736..1100df057c 100644
--- a/okhttp/src/main/java/okhttp3/internal/concurrent/Task.kt
+++ b/okhttp/src/main/java/okhttp3/internal/concurrent/Task.kt
@@ -18,13 +18,6 @@ package okhttp3.internal.concurrent
 /**
  * A unit of work that can be executed one or more times.
  *
- * Cancellation
- * ------------
- *
- * Tasks control their cancellation. If the hosting queue is canceled, the [Task.tryCancel] function
- * returns true if the task should skip the next-scheduled execution. Note that canceling a task is
- * not permanent; it is okay to schedule a task after it has been canceled.
- *
  * Recurrence
  * ----------
  *
@@ -35,6 +28,18 @@ package okhttp3.internal.concurrent
  * earliest one wins. This applies to both executions scheduled with [TaskRunner.Queue.schedule] and
  * those implied by the returned execution delay.
  *
+ * Cancellation
+ * ------------
+ *
+ * Tasks may be canceled while they are waiting to be executed, or while they are executing.
+ *
+ * Canceling a task that is waiting to execute prevents that upcoming execution. Canceling a task
+ * that is currently executing does not impact the ongoing run, but it does prevent a recurrence
+ * from being scheduled.
+ *
+ * Tasks may opt-out of cancellation with `cancelable = false`. Such tasks will recur until they
+ * decide not to by returning -1L.
+ *
  * Task Queues
  * -----------
  *
@@ -42,7 +47,8 @@ package okhttp3.internal.concurrent
  * within it never execute concurrently. It is an error to use a task in multiple queues.
  */
 abstract class Task(
-  val name: String
+  val name: String,
+  val cancelable: Boolean = true
 ) {
   // Guarded by the TaskRunner.
   internal var queue: TaskQueue? = null
@@ -51,14 +57,10 @@ abstract class Task(
   internal var nextExecuteNanoTime = -1L
 
   internal var runRunnable: Runnable? = null
-  internal var cancelRunnable: Runnable? = null
 
   /** Returns the delay in nanoseconds until the next execution, or -1L to not reschedule. */
   abstract fun runOnce(): Long
 
-  /** Return true to skip the scheduled execution. */
-  open fun tryCancel(): Boolean = false
-
   internal fun initQueue(queue: TaskQueue) {
     if (this.queue === queue) return
 
@@ -78,19 +80,5 @@ abstract class Task(
         currentThread.name = oldName
       }
     }
-
-    this.cancelRunnable = Runnable {
-      val currentThread = Thread.currentThread()
-      val oldName = currentThread.name
-      currentThread.name = name
-
-      var skipExecution = false
-      try {
-        skipExecution = tryCancel()
-      } finally {
-        queue.tryCancelCompleted(this, skipExecution)
-        currentThread.name = oldName
-      }
-    }
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/concurrent/TaskQueue.kt b/okhttp/src/main/java/okhttp3/internal/concurrent/TaskQueue.kt
index 5696e73d40..ee4dacf046 100644
--- a/okhttp/src/main/java/okhttp3/internal/concurrent/TaskQueue.kt
+++ b/okhttp/src/main/java/okhttp3/internal/concurrent/TaskQueue.kt
@@ -15,7 +15,6 @@
  */
 package okhttp3.internal.concurrent
 
-import okhttp3.internal.addIfAbsent
 import java.util.concurrent.CountDownLatch
 import java.util.concurrent.RejectedExecutionException
 import java.util.concurrent.TimeUnit
@@ -40,12 +39,12 @@ class TaskQueue internal constructor(
   /** This queue's currently-executing task, or null if none is currently executing. */
   private var activeTask: Task? = null
 
+  /** True if the [activeTask] should not recur when it completes. */
+  private var cancelActiveTask = false
+
   /** Scheduled tasks ordered by [Task.nextExecuteNanoTime]. */
   private val futureTasks = mutableListOf<Task>()
 
-  /** Tasks to cancel. Always either [activeTask] or a member of [futureTasks]. */
-  private val cancelTasks = mutableListOf<Task>()
-
   internal fun isActive(): Boolean {
     check(Thread.holdsLock(taskRunner))
 
@@ -163,17 +162,18 @@ class TaskQueue internal constructor(
 
   /** Returns true if the coordinator should run. */
   private fun cancelAllAndDecide(): Boolean {
-    val runningTask = activeTask
-    if (runningTask != null) {
-      cancelTasks.addIfAbsent(runningTask)
+    if (activeTask != null && activeTask!!.cancelable) {
+      cancelActiveTask = true
     }
 
-    for (task in futureTasks) {
-      cancelTasks.addIfAbsent(task)
+    var tasksCanceled = false
+    for (i in futureTasks.size - 1 downTo 0) {
+      if (futureTasks[i].cancelable) {
+        tasksCanceled = true
+        futureTasks.removeAt(i)
+      }
     }
-
-    // Run the coordinator if tasks were canceled.
-    return cancelTasks.isNotEmpty()
+    return tasksCanceled
   }
 
   /**
@@ -187,15 +187,6 @@ class TaskQueue internal constructor(
 
     if (activeTask != null) return Long.MAX_VALUE // This queue is busy.
 
-    // Find a task to cancel.
-    val cancelTask = cancelTasks.firstOrNull()
-    if (cancelTask != null) {
-      activeTask = cancelTask
-      cancelTasks.removeAt(0)
-      taskRunner.backend.executeTask(cancelTask.cancelRunnable!!)
-      return Long.MAX_VALUE // This queue is busy until the cancel completes.
-    }
-
     // Check if a task is immediately ready.
     val runTask = futureTasks.firstOrNull() ?: return -1L
     val delayNanos = runTask.nextExecuteNanoTime - now
@@ -214,27 +205,12 @@ class TaskQueue internal constructor(
     synchronized(taskRunner) {
       check(activeTask === task)
 
-      if (delayNanos != -1L && !shutdown) {
+      if (delayNanos != -1L && !cancelActiveTask && !shutdown) {
         scheduleAndDecide(task, delayNanos)
-      } else if (!futureTasks.contains(task)) {
-        cancelTasks.remove(task) // We don't need to cancel it because it isn't scheduled.
-      }
-
-      activeTask = null
-      taskRunner.kickCoordinator(this)
-    }
-  }
-
-  internal fun tryCancelCompleted(task: Task, skipExecution: Boolean) {
-    synchronized(taskRunner) {
-      check(activeTask === task)
-
-      if (skipExecution) {
-        futureTasks.remove(task)
-        cancelTasks.remove(task)
       }
 
       activeTask = null
+      cancelActiveTask = false
       taskRunner.kickCoordinator(this)
     }
   }
diff --git a/okhttp/src/main/java/okhttp3/internal/concurrent/TaskRunner.kt b/okhttp/src/main/java/okhttp3/internal/concurrent/TaskRunner.kt
index a7a1eba554..35b9df49e9 100644
--- a/okhttp/src/main/java/okhttp3/internal/concurrent/TaskRunner.kt
+++ b/okhttp/src/main/java/okhttp3/internal/concurrent/TaskRunner.kt
@@ -113,8 +113,8 @@ class TaskRunner(
   }
 
   private fun cancelAll() {
-    for (queue in activeQueues) {
-      queue.cancelAll()
+    for (i in activeQueues.size - 1 downTo 0) {
+      activeQueues[i].cancelAll()
     }
   }
 
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/RealConnectionPool.kt b/okhttp/src/main/java/okhttp3/internal/connection/RealConnectionPool.kt
index 0bd1c7fab5..f61f9d8453 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/RealConnectionPool.kt
+++ b/okhttp/src/main/java/okhttp3/internal/connection/RealConnectionPool.kt
@@ -42,7 +42,6 @@ class RealConnectionPool(
   private val cleanupQueue: TaskQueue = taskRunner.newQueue(this)
   private val cleanupTask = object : Task("OkHttp ConnectionPool") {
     override fun runOnce() = cleanup(System.nanoTime())
-    override fun tryCancel() = true
   }
 
   private val connections = ArrayDeque<RealConnection>()
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.kt b/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.kt
index 6c6665613f..7790edf770 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.kt
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.kt
@@ -146,8 +146,6 @@ class Http2Connection internal constructor(builder: Builder) : Closeable {
           writePing(false, 0, 0)
           return pingIntervalNanos
         }
-
-        override fun tryCancel() = true
       }, pingIntervalNanos)
     }
   }
@@ -329,8 +327,6 @@ class Http2Connection internal constructor(builder: Builder) : Closeable {
         }
         return -1L
       }
-
-      override fun tryCancel() = true
     })
   }
 
@@ -355,8 +351,6 @@ class Http2Connection internal constructor(builder: Builder) : Closeable {
         }
         return -1L
       }
-
-      override fun tryCancel() = true
     })
   }
 
@@ -638,7 +632,7 @@ class Http2Connection internal constructor(builder: Builder) : Closeable {
 
           // Use a different task queue for each stream because they should be handled in parallel.
           val taskName = "OkHttp $connectionName stream $streamId"
-          taskRunner.newQueue(taskName).schedule(object : Task(taskName) {
+          taskRunner.newQueue(taskName).schedule(object : Task(taskName, cancelable = false) {
             override fun runOnce(): Long {
               try {
                 listener.onStream(newStream)
@@ -674,8 +668,6 @@ class Http2Connection internal constructor(builder: Builder) : Closeable {
           applyAndAckSettings(clearPrevious, settings)
           return -1L
         }
-
-        override fun tryCancel() = true
       })
     }
 
@@ -717,7 +709,8 @@ class Http2Connection internal constructor(builder: Builder) : Closeable {
 
           peerSettings = newPeerSettings
 
-          settingsListenerQueue.trySchedule(object : Task("$connectionName Listener") {
+          settingsListenerQueue.trySchedule(object : Task("$connectionName Listener",
+              cancelable = false) {
             override fun runOnce(): Long {
               listener.onSettings(this@Http2Connection, newPeerSettings)
               return -1L
@@ -760,8 +753,6 @@ class Http2Connection internal constructor(builder: Builder) : Closeable {
             writePing(true, payload1, payload2)
             return -1L
           }
-
-          override fun tryCancel() = true
         })
       }
     }
@@ -860,8 +851,6 @@ class Http2Connection internal constructor(builder: Builder) : Closeable {
         }
         return -1L
       }
-
-      override fun tryCancel() = true
     })
   }
 
@@ -883,8 +872,6 @@ class Http2Connection internal constructor(builder: Builder) : Closeable {
         }
         return -1L
       }
-
-      override fun tryCancel() = true
     })
   }
 
@@ -915,13 +902,12 @@ class Http2Connection internal constructor(builder: Builder) : Closeable {
         }
         return -1L
       }
-
-      override fun tryCancel() = true
     })
   }
 
   internal fun pushResetLater(streamId: Int, errorCode: ErrorCode) {
-    pushQueue.trySchedule(object : Task("OkHttp $connectionName Push Reset[$streamId]") {
+    pushQueue.trySchedule(object : Task("OkHttp $connectionName Push Reset[$streamId]",
+        cancelable = false) {
       override fun runOnce(): Long {
         pushObserver.onReset(streamId, errorCode)
         synchronized(this@Http2Connection) {
diff --git a/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.kt b/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.kt
index 4c29d5233d..6875ddd221 100644
--- a/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.kt
+++ b/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.kt
@@ -131,8 +131,6 @@ class RealWebSocket(
         }
         return -1L
       }
-
-      override fun tryCancel() = true
     }
   }
 
@@ -485,8 +483,6 @@ class RealWebSocket(
       writePingFrame()
       return delayNanos
     }
-
-    override fun tryCancel() = true
   }
 
   internal fun writePingFrame() {
@@ -552,8 +548,6 @@ class RealWebSocket(
       cancel()
       return -1L
     }
-
-    override fun tryCancel() = true
   }
 
   companion object {
diff --git a/okhttp/src/test/java/okhttp3/internal/concurrent/TaskRunnerTest.kt b/okhttp/src/test/java/okhttp3/internal/concurrent/TaskRunnerTest.kt
index a6eccbd12d..18ca1bd8e2 100644
--- a/okhttp/src/test/java/okhttp3/internal/concurrent/TaskRunnerTest.kt
+++ b/okhttp/src/test/java/okhttp3/internal/concurrent/TaskRunnerTest.kt
@@ -133,11 +133,6 @@ class TaskRunnerTest {
         log += "run@${taskFaker.nanoTime}"
         return -1L
       }
-
-      override fun tryCancel(): Boolean {
-        log += "cancel@${taskFaker.nanoTime}"
-        return true
-      }
     }, 100L)
 
     taskFaker.advanceUntil(0L)
@@ -146,22 +141,17 @@ class TaskRunnerTest {
     redQueue.cancelAll()
 
     taskFaker.advanceUntil(99L)
-    assertThat(log).containsExactly("cancel@99")
+    assertThat(log).isEmpty()
 
     taskFaker.assertNoMoreTasks()
   }
 
   @Test fun cancelReturnsFalseDoesNotCancel() {
-    redQueue.schedule(object : Task("task") {
+    redQueue.schedule(object : Task("task", cancelable = false) {
       override fun runOnce(): Long {
         log += "run@${taskFaker.nanoTime}"
         return -1L
       }
-
-      override fun tryCancel(): Boolean {
-        log += "cancel@${taskFaker.nanoTime}"
-        return false
-      }
     }, 100L)
 
     taskFaker.advanceUntil(0L)
@@ -170,10 +160,10 @@ class TaskRunnerTest {
     redQueue.cancelAll()
 
     taskFaker.advanceUntil(99L)
-    assertThat(log).containsExactly("cancel@99")
+    assertThat(log).isEmpty()
 
     taskFaker.advanceUntil(100L)
-    assertThat(log).containsExactly("cancel@99", "run@100")
+    assertThat(log).containsExactly("run@100")
 
     taskFaker.assertNoMoreTasks()
   }
@@ -185,18 +175,13 @@ class TaskRunnerTest {
         redQueue.cancelAll()
         return 100L
       }
-
-      override fun tryCancel(): Boolean {
-        log += "cancel@${taskFaker.nanoTime}"
-        return true
-      }
     }, 100L)
 
     taskFaker.advanceUntil(0L)
     assertThat(log).isEmpty()
 
     taskFaker.advanceUntil(100L)
-    assertThat(log).containsExactly("run@100", "cancel@100")
+    assertThat(log).containsExactly("run@100")
 
     taskFaker.assertNoMoreTasks()
   }
@@ -208,10 +193,24 @@ class TaskRunnerTest {
         redQueue.cancelAll()
         return -1L
       }
+    }, 100L)
 
-      override fun tryCancel(): Boolean {
-        log += "cancel@${taskFaker.nanoTime}"
-        return true
+    taskFaker.advanceUntil(0L)
+    assertThat(log).isEmpty()
+
+    taskFaker.advanceUntil(100L)
+    assertThat(log).containsExactly("run@100")
+
+    taskFaker.assertNoMoreTasks()
+  }
+
+  @Test fun cancelWhileExecutingDoesNotStopUncancelableTask() {
+    redQueue.schedule(object : Task("task", cancelable = false) {
+      val delays = mutableListOf(50L, -1L)
+      override fun runOnce(): Long {
+        log += "run@${taskFaker.nanoTime}"
+        redQueue.cancelAll()
+        return delays.removeAt(0)
       }
     }, 100L)
 
@@ -221,6 +220,9 @@ class TaskRunnerTest {
     taskFaker.advanceUntil(100L)
     assertThat(log).containsExactly("run@100")
 
+    taskFaker.advanceUntil(150L)
+    assertThat(log).containsExactly("run@100", "run@150")
+
     taskFaker.assertNoMoreTasks()
   }
 
@@ -230,11 +232,6 @@ class TaskRunnerTest {
         log += "run@${taskFaker.nanoTime}"
         return -1L
       }
-
-      override fun tryCancel(): Boolean {
-        log += "cancel@${taskFaker.nanoTime}"
-        return true
-      }
     }, 100L)
 
     taskFaker.advanceUntil(0L)
@@ -243,22 +240,17 @@ class TaskRunnerTest {
     taskFaker.interruptCoordinatorThread()
 
     taskFaker.advanceUntil(0L)
-    assertThat(log).containsExactly("cancel@0")
+    assertThat(log).isEmpty()
 
     taskFaker.assertNoMoreTasks()
   }
 
   @Test fun interruptingCoordinatorAttemptsToCancelsAndFails() {
-    redQueue.schedule(object : Task("task") {
+    redQueue.schedule(object : Task("task", cancelable = false) {
       override fun runOnce(): Long {
         log += "run@${taskFaker.nanoTime}"
         return -1L
       }
-
-      override fun tryCancel(): Boolean {
-        log += "cancel@${taskFaker.nanoTime}"
-        return false
-      }
     }, 100L)
 
     taskFaker.advanceUntil(0L)
@@ -267,10 +259,10 @@ class TaskRunnerTest {
     taskFaker.interruptCoordinatorThread()
 
     taskFaker.advanceUntil(0L)
-    assertThat(log).containsExactly("cancel@0")
+    assertThat(log).isEmpty()
 
     taskFaker.advanceUntil(100L)
-    assertThat(log).containsExactly("cancel@0", "run@100")
+    assertThat(log).containsExactly("run@100")
 
     taskFaker.assertNoMoreTasks()
   }
@@ -452,38 +444,12 @@ class TaskRunnerTest {
     taskFaker.assertNoMoreTasks()
   }
 
-  @Test fun taskNameIsUsedForThreadNameWhenCanceling() {
-    redQueue.schedule(object : Task("lucky task") {
-      override fun tryCancel(): Boolean {
-        log += "cancel threadName:${Thread.currentThread().name}"
-        return true
-      }
-
-      override fun runOnce() = -1L
-    }, 100L)
-
-    taskFaker.advanceUntil(0L)
-    assertThat(log).isEmpty()
-
-    redQueue.cancelAll()
-
-    taskFaker.advanceUntil(0L)
-    assertThat(log).containsExactly("cancel threadName:lucky task")
-
-    taskFaker.assertNoMoreTasks()
-  }
-
   @Test fun shutdownSuccessfullyCancelsScheduledTasks() {
     redQueue.schedule(object : Task("task") {
       override fun runOnce(): Long {
         log += "run@${taskFaker.nanoTime}"
         return -1L
       }
-
-      override fun tryCancel(): Boolean {
-        log += "cancel@${taskFaker.nanoTime}"
-        return true
-      }
     }, 100L)
 
     taskFaker.advanceUntil(0L)
@@ -492,22 +458,17 @@ class TaskRunnerTest {
     redQueue.shutdown()
 
     taskFaker.advanceUntil(99L)
-    assertThat(log).containsExactly("cancel@99")
+    assertThat(log).isEmpty()
 
     taskFaker.assertNoMoreTasks()
   }
 
   @Test fun shutdownFailsToCancelsScheduledTasks() {
-    redQueue.schedule(object : Task("task") {
+    redQueue.schedule(object : Task("task", cancelable = false) {
       override fun runOnce(): Long {
         log += "run@${taskFaker.nanoTime}"
         return 50L
       }
-
-      override fun tryCancel(): Boolean {
-        log += "cancel@${taskFaker.nanoTime}"
-        return false
-      }
     }, 100L)
 
     taskFaker.advanceUntil(0L)
@@ -516,10 +477,10 @@ class TaskRunnerTest {
     redQueue.shutdown()
 
     taskFaker.advanceUntil(99L)
-    assertThat(log).containsExactly("cancel@99")
+    assertThat(log).isEmpty()
 
     taskFaker.advanceUntil(100L)
-    assertThat(log).containsExactly("cancel@99", "run@100")
+    assertThat(log).containsExactly("run@100")
 
     taskFaker.assertNoMoreTasks()
   }
