diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java
index 68ba1dd4c6..8f2ec381b2 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java
@@ -21,6 +21,7 @@
 import com.squareup.okhttp.mockwebserver.Dispatcher;
 import com.squareup.okhttp.mockwebserver.MockResponse;
 import com.squareup.okhttp.mockwebserver.MockWebServer;
+import com.squareup.okhttp.mockwebserver.PushPromise;
 import com.squareup.okhttp.mockwebserver.RecordedRequest;
 import com.squareup.okhttp.mockwebserver.SocketPolicy;
 import java.io.File;
@@ -292,6 +293,37 @@
     patch();
   }
 
+  @Test public void push_SPDY_3() throws Exception {
+    enableProtocol(Protocol.SPDY_3);
+    server.enqueue(new MockResponse()
+        .withPush(new PushPromise("GET", "/pushed", Arrays.asList("foo: bar"),
+             new MockResponse().setBody("push data")))
+        .setBody("abc"));
+    server.play();
+
+    TestPushObserver pushObserver = new TestPushObserver();
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .build();
+
+    executeSynchronously(request, pushObserver)
+        .assertCode(200)
+        .assertBody("abc");
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("GET", recordedRequest.getMethod());
+    assertEquals(0, recordedRequest.getBody().length);
+
+    synchronized (pushObserver) {
+      if (!pushObserver.gotRequest()) {
+        pushObserver.wait();
+      }
+      assertNull(pushObserver.exception());
+      assertEquals("/pushed", pushObserver.response().header("path"));
+      assertEquals("push data", new String(pushObserver.response().body().bytes()));
+    }
+  }
+
   @Test public void illegalToExecuteTwice() throws Exception {
     server.enqueue(new MockResponse()
         .setBody("abc")
@@ -1204,9 +1236,14 @@
         .assertRequestHeader("Accept-Encoding", "gzip");
   }
 
+  private RecordedResponse executeSynchronously(Request request, PushObserver pushObserver) throws IOException {
+      Call call = client.newCall(request.newBuilder().pushObserver(pushObserver).build());
+      Response response = call.execute();
+      return new RecordedResponse(request, response, response.body().string(), null);
+  }
+
   private RecordedResponse executeSynchronously(Request request) throws IOException {
-    Response response = client.newCall(request).execute();
-    return new RecordedResponse(request, response, response.body().string(), null);
+      return executeSynchronously(request, null);
   }
 
   /**
@@ -1243,4 +1280,33 @@ private void assertContainsNoneMatching(List<String> headers, String pattern) {
       }
     }
   }
+  private class TestPushObserver implements PushObserver {
+    private boolean gotRequest = false;
+    private IOException exception = null;
+    private Response response = null;
+    private String data = null;
+
+    public boolean gotRequest() {
+      return gotRequest;
+    }
+
+    public IOException exception() {
+      return exception;
+    }
+
+    public Response response() {
+      return response;
+    }
+
+
+    @Override public synchronized boolean onPush(Response response) {
+      try {
+          this.response = response;
+        return false;
+      } finally {
+        gotRequest = true;
+        notifyAll();
+      }
+    }
+  };
 }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/huc/JavaApiConverterTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/huc/JavaApiConverterTest.java
index e58730e015..b852ae7fd5 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/huc/JavaApiConverterTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/huc/JavaApiConverterTest.java
@@ -596,7 +596,7 @@ private void assertHeadersContainsMapping(Map<String, List<String>> headers, Str
         .addHeader("key1", "value1_1")
         .addHeader("key2", "value2")
         .addHeader("key1", "value1_2")
-        .body(null)
+        .body((ResponseBody) null)
         .build();
     CacheResponse javaCacheResponse = JavaApiConverter.createJavaCacheResponse(okResponse);
     assertFalse(javaCacheResponse instanceof SecureCacheResponse);
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
index 05072897ed..89aa6bfc38 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
@@ -1530,6 +1530,37 @@ private void headerBlockHasTrailingCompressedBytes(String frame, int length) thr
     assertEquals(expectedResponseHeaders, observer.takeEvent());
   }
 
+  @Test public void pushStream() throws Exception {
+    peer.setVariantAndClient(SPDY3, false);
+
+    // write the mocking script
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    final List<Header> expectedPushHeaders = Arrays.asList(
+        new Header(Header.TARGET_SCHEME, "https"),
+        new Header(Header.TARGET_AUTHORITY, "squareup.com"),
+        new Header(Header.TARGET_PATH, "/cached")
+    );
+    peer.sendFrame().synStream(false, true, 2, 3, expectedPushHeaders);
+    peer.sendFrame().data(true, 3, data(0));
+    peer.sendFrame().data(true, 2, new Buffer().writeUtf8("robot"));
+    peer.play();
+
+    RecordingPushObserver observer = new RecordingPushObserver();
+
+    // play it back
+    SpdyConnection connection = connectionBuilder(peer, SPDY3)
+        .pushObserver(observer).build();
+    SpdyStream client = connection.newStream(headerEntries("b", "banana"), false, true);
+    assertEquals(-1, client.getSource().read(new Buffer(), 1));
+
+    // verify the peer received what was expected
+    assertEquals(TYPE_HEADERS, peer.takeFrame().type);
+
+    assertEquals(expectedPushHeaders, observer.takeEvent());
+    assertEquals("robot", observer.takeEvent());
+  }
+
   @Test public void doublePushPromise() throws Exception {
     peer.setVariantAndClient(HTTP_2, false);
 
@@ -1567,7 +1598,7 @@ private void headerBlockHasTrailingCompressedBytes(String frame, int length) thr
 
     // play it back
     connectionBuilder(peer, HTTP_2)
-        .pushObserver(PushObserver.CANCEL).build();
+        .pushObserver(SpdyPushObserver.CANCEL).build();
 
     // verify the peer received what was expected
     MockSpdyPeer.InFrame rstStream = peer.takeFrame();
@@ -1642,27 +1673,18 @@ static int roundUp(int num, int divisor) {
     return (num + divisor - 1) / divisor;
   }
 
-  static final PushObserver IGNORE = new PushObserver() {
-
-    @Override public boolean onRequest(int streamId, List<Header> requestHeaders) {
-      return false;
-    }
+  static final SpdyPushObserver IGNORE = new SpdyPushObserver() {
 
-    @Override public boolean onHeaders(int streamId, List<Header> responseHeaders, boolean last) {
+    @Override public synchronized boolean onPromise(int streamId, List<Header> requestHeaders) {
       return false;
     }
 
-    @Override public boolean onData(int streamId, BufferedSource source, int byteCount,
-        boolean last) throws IOException {
-      source.skip(byteCount);
+    @Override public synchronized boolean onPush(SpdyStream associated, SpdyStream push) {
       return false;
     }
-
-    @Override public void onReset(int streamId, ErrorCode errorCode) {
-    }
   };
 
-  private static class RecordingPushObserver implements PushObserver {
+  private static class RecordingPushObserver implements SpdyPushObserver {
     final List<Object> events = new ArrayList<Object>();
 
     public synchronized Object takeEvent() throws InterruptedException {
@@ -1672,32 +1694,26 @@ public synchronized Object takeEvent() throws InterruptedException {
       return events.remove(0);
     }
 
-    @Override public synchronized boolean onRequest(int streamId, List<Header> requestHeaders) {
+    @Override public synchronized boolean onPromise(int streamId, List<Header> requestHeaders) {
       assertEquals(2, streamId);
       events.add(requestHeaders);
       notifyAll();
       return false;
     }
 
-    @Override public synchronized boolean onHeaders(
-        int streamId, List<Header> responseHeaders, boolean last) {
-      assertEquals(2, streamId);
-      assertTrue(last);
-      events.add(responseHeaders);
-      notifyAll();
-      return false;
-    }
-
-    @Override public synchronized boolean onData(
-        int streamId, BufferedSource source, int byteCount, boolean last) {
-      events.add(new AssertionError("onData"));
-      notifyAll();
+    @Override public synchronized boolean onPush(SpdyStream associated, SpdyStream push) {
+      assertEquals(2, push.getId());
+      events.add(push.getRequestHeaders());
+      Source in = push.getSource();
+      try {
+        String data = Okio.buffer(in).readByteString(5).utf8();
+
+        events.add(data);
+        notifyAll();
+      } catch (IOException expected) {
+        // Just don't push anything to events
+      }
       return false;
     }
-
-    @Override public synchronized void onReset(int streamId, ErrorCode errorCode) {
-      events.add(new AssertionError("onReset"));
-      notifyAll();
-    }
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Call.java b/okhttp/src/main/java/com/squareup/okhttp/Call.java
index 32edc4fe57..c3c511886b 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Call.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Call.java
@@ -19,12 +19,10 @@
 import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.internal.http.HttpEngine;
 import com.squareup.okhttp.internal.http.HttpMethod;
-import com.squareup.okhttp.internal.http.OkHeaders;
 import com.squareup.okhttp.internal.http.RetryableSink;
 import java.io.IOException;
 import java.net.ProtocolException;
 import okio.BufferedSink;
-import okio.BufferedSource;
 
 import static com.squareup.okhttp.internal.http.HttpEngine.MAX_REDIRECTS;
 
@@ -220,7 +218,7 @@ private Response getResponse() throws IOException {
       if (followUp == null) {
         engine.releaseConnection();
         return response.newBuilder()
-            .body(new RealResponseBody(response, engine.getResponseBody()))
+            .body(engine.getResponseBody())
             .build();
       }
 
@@ -238,27 +236,4 @@ private Response getResponse() throws IOException {
               null, response);
     }
   }
-
-  private static class RealResponseBody extends ResponseBody {
-    private final Response response;
-    private final BufferedSource source;
-
-    RealResponseBody(Response response, BufferedSource source) {
-      this.response = response;
-      this.source = source;
-    }
-
-    @Override public MediaType contentType() {
-      String contentType = response.header("Content-Type");
-      return contentType != null ? MediaType.parse(contentType) : null;
-    }
-
-    @Override public long contentLength() {
-      return OkHeaders.contentLength(response);
-    }
-
-    @Override public BufferedSource source() {
-      return source;
-    }
-  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/PushObserver.java b/okhttp/src/main/java/com/squareup/okhttp/PushObserver.java
new file mode 100644
index 0000000000..222b05d888
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/PushObserver.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+/**
+ * {@link com.squareup.okhttp.Protocol#HTTP_2 HTTP/2} and
+ * {@link com.squareup.okhttp.Protocol#SPDY_3 SPDY/3} only.
+ * Processes server-initiated HTTP requests on the client. Implementations must
+ * quickly dispatch callbacks to avoid creating a bottleneck.
+ *
+ * <p>Return true to request cancellation of a pushed stream.  Note that this
+ * does not guarantee future frames won't arrive on the stream ID.
+ */
+public interface PushObserver {
+  /**
+   * Receive a push initiated by the server. The push is in the form of
+   * an http response, where the request is either a previous client response
+   * (SPDY) or a push promise "request" from the server (HTTP/2).
+   *
+   * @param response The push from the server
+   * @return true to cancel the push stream
+   */
+  boolean onPush(Response response);
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Request.java b/okhttp/src/main/java/com/squareup/okhttp/Request.java
index 5d1ec86482..bd0ecfa687 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Request.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Request.java
@@ -16,6 +16,7 @@
 package com.squareup.okhttp;
 
 import com.squareup.okhttp.internal.Platform;
+
 import java.io.IOException;
 import java.net.MalformedURLException;
 import java.net.URI;
@@ -33,6 +34,7 @@
   private final Headers headers;
   private final RequestBody body;
   private final Object tag;
+  private final PushObserver pushObserver;
 
   private volatile URI uri; // Lazily initialized.
   private volatile CacheControl cacheControl; // Lazily initialized.
@@ -43,6 +45,7 @@ private Request(Builder builder) {
     this.headers = builder.headers.build();
     this.body = builder.body;
     this.tag = builder.tag != null ? builder.tag : this;
+    this.pushObserver = builder.pushObserver;
   }
 
   public URL url() {
@@ -86,6 +89,10 @@ public Object tag() {
     return tag;
   }
 
+  public PushObserver pushObserver() {
+    return pushObserver;
+  }
+
   public Builder newBuilder() {
     return new Builder(this);
   }
@@ -119,6 +126,7 @@ public boolean isHttps() {
     private Headers.Builder headers;
     private RequestBody body;
     private Object tag;
+    private PushObserver pushObserver = null;
 
     public Builder() {
       this.method = "GET";
@@ -131,6 +139,7 @@ private Builder(Request request) {
       this.body = request.body;
       this.tag = request.tag;
       this.headers = request.headers.newBuilder();
+      this.pushObserver = request.pushObserver;
     }
 
     public Builder url(String url) {
@@ -209,6 +218,11 @@ public Builder method(String method, RequestBody body) {
       return this;
     }
 
+    public Builder pushObserver(PushObserver pushObserver) {
+      this.pushObserver = pushObserver;
+      return this;
+    }
+
     /**
      * Attaches {@code tag} to the request. It can be used later to cancel the
      * request. If the tag is unspecified or null, the request is canceled by
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Response.java b/okhttp/src/main/java/com/squareup/okhttp/Response.java
index 2762992229..1afc5bf66a 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Response.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Response.java
@@ -16,6 +16,8 @@
 package com.squareup.okhttp;
 
 import com.squareup.okhttp.internal.http.OkHeaders;
+import okio.BufferedSource;
+
 import java.util.Collections;
 import java.util.List;
 
@@ -296,6 +298,38 @@ public Builder body(ResponseBody body) {
       return this;
     }
 
+    public Builder body(BufferedSource source) {
+      return body(new RealResponseBody(source));
+    }
+
+    private class RealResponseBody extends ResponseBody {
+      private final MediaType mediaType;
+      private final BufferedSource source;
+      private final long contentLength;
+
+      RealResponseBody(BufferedSource source) {
+        if (headers == null) {
+          throw new IllegalStateException("Set headers before setting the body");
+        }
+        String contentType = headers.get("Content-Type");
+        mediaType = contentType != null ? MediaType.parse(contentType) : null;
+        this.source = source;
+        this.contentLength = OkHeaders.contentLength(headers.build());
+      }
+
+      @Override public MediaType contentType() {
+        return mediaType;
+      }
+
+      @Override public long contentLength() {
+        return contentLength;
+      }
+
+      @Override public BufferedSource source() {
+        return source;
+      }
+    }
+
     public Builder networkResponse(Response networkResponse) {
       if (networkResponse != null) checkSupportResponse("networkResponse", networkResponse);
       this.networkResponse = networkResponse;
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
index 675d3a90d1..c4ac949d1b 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
@@ -298,7 +298,7 @@ public void sendRequest() throws IOException {
 
   private static Response stripBody(Response response) {
     return response != null && response.body() != null
-        ? response.newBuilder().body(null).build()
+        ? response.newBuilder().body((ResponseBody) null).build()
         : response;
   }
 
@@ -639,6 +639,10 @@ private Request networkRequest(Request request) throws IOException {
     return result.build();
   }
 
+  public boolean isTransparentGzip() {
+    return transparentGzip;
+  }
+
   public static String getDefaultUserAgent() {
     String agent = System.getProperty("http.agent");
     return agent != null ? agent : ("Java" + System.getProperty("java.version"));
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
index 07713ec472..91f29f6b8d 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
@@ -16,15 +16,17 @@
 
 package com.squareup.okhttp.internal.http;
 
-import com.squareup.okhttp.Headers;
 import com.squareup.okhttp.Protocol;
+import com.squareup.okhttp.PushObserver;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
+import com.squareup.okhttp.Headers;
 import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.internal.spdy.ErrorCode;
 import com.squareup.okhttp.internal.spdy.Header;
 import com.squareup.okhttp.internal.spdy.SpdyConnection;
 import com.squareup.okhttp.internal.spdy.SpdyStream;
+import com.squareup.okhttp.internal.spdy.SpdyPushObserver;
 import java.io.IOException;
 import java.io.OutputStream;
 import java.net.CacheRequest;
@@ -36,7 +38,10 @@
 import java.util.Set;
 import java.util.concurrent.TimeUnit;
 import okio.Buffer;
+import okio.BufferedSource;
+import okio.GzipSource;
 import okio.ByteString;
+import okio.Okio;
 import okio.Sink;
 import okio.Source;
 import okio.Timeout;
@@ -69,6 +74,8 @@
       ByteString.encodeUtf8("encoding"),
       ByteString.encodeUtf8("upgrade"));
 
+  private static final String VALUE_DELIMITER = "0x00";
+
   private final HttpEngine httpEngine;
   private final SpdyConnection spdyConnection;
   private SpdyStream stream;
@@ -84,7 +91,7 @@ public SpdyTransport(HttpEngine httpEngine, SpdyConnection spdyConnection) {
     return stream.getSink();
   }
 
-  @Override public void writeRequestHeaders(Request request) throws IOException {
+  @Override public void writeRequestHeaders(final Request request) throws IOException {
     if (stream != null) return;
 
     httpEngine.writingRequestHeaders();
@@ -95,6 +102,37 @@ public SpdyTransport(HttpEngine httpEngine, SpdyConnection spdyConnection) {
         writeNameValueBlock(request, spdyConnection.getProtocol(), version), hasRequestBody,
         hasResponseBody);
     stream.readTimeout().timeout(httpEngine.client.getReadTimeout(), TimeUnit.MILLISECONDS);
+
+    final PushObserver pushCallback = request.pushObserver();
+    if (pushCallback != null) {
+      stream.pushObserver = new SpdyPushObserver() {
+        @Override public synchronized boolean onPromise(int streamId, List<Header> requestHeaders) {
+          return true;
+        }
+
+        @Override public synchronized boolean onPush(SpdyStream associated, SpdyStream push) {
+          try {
+            Response partialResponse = parsePushResponse(request, push.getRequestHeaders(),
+                    spdyConnection.getProtocol()).build();
+
+            SpdySource source = new SpdySource(push, null);
+            BufferedSource buffer;
+            if (httpEngine.isTransparentGzip()
+                    && "gzip".equalsIgnoreCase(partialResponse.headers().get("Content-Encoding"))) {
+              buffer = Okio.buffer(new GzipSource(source));
+            } else {
+              buffer = Okio.buffer(source);
+            }
+            Response response = partialResponse.newBuilder()
+                    .body(buffer)
+                    .build();
+            return pushCallback.onPush(response);
+          } catch (IOException ignored) {
+            return true;
+          }
+        }
+      };
+    }
   }
 
   @Override public void writeRequestBody(RetryableSink requestBody) throws IOException {
@@ -211,6 +249,44 @@ private static String joinOnNull(String first, String second) {
         .headers(headersBuilder.build());
   }
 
+  /** Returns headers for a name value block containing a SPDY response. */
+  public static Response.Builder parsePushResponse(Request request, List<Header> headerBlock,
+                                                  Protocol protocol) throws IOException {
+    String path = null;
+    String host = null;
+    String scheme = null;
+
+    Headers.Builder headersBuilder = new Headers.Builder();
+    headersBuilder.set(OkHeaders.SELECTED_PROTOCOL, protocol.toString());
+    for (Header header : headerBlock) {
+      ByteString name = header.name;
+      String values = header.value.utf8();
+      for (String value : values.split(VALUE_DELIMITER)) {
+        if (name.equals(TARGET_PATH)) {
+          path = value;
+        } else if (name.equals(TARGET_HOST)) {
+          host = value;
+        } else if (name.equals(TARGET_SCHEME)) {
+          scheme = value;
+        }
+        if (!isProhibitedHeader(protocol, name)) {
+          headersBuilder.add(name.utf8(), value);
+        }
+      }
+    }
+    if (path == null || host == null || scheme == null) {
+      throw new ProtocolException("Expected ':path',':host', ':scheme' headers are not set");
+    }
+
+    return new Response.Builder()
+            .code(200)
+            .message("OK")
+            .request(request)
+            .protocol(protocol)
+            .headers(headersBuilder.build());
+  }
+
+
   @Override public void emptyTransferStream() {
     // Do nothing.
   }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
index 520a28bebf..b065449e40 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
@@ -25,10 +25,8 @@
 import java.net.Socket;
 import java.util.HashMap;
 import java.util.Iterator;
-import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
-import java.util.Set;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.SynchronousQueue;
@@ -92,7 +90,7 @@
   /** Lazily-created map of in-flight pings awaiting a response. Guarded by this. */
   private Map<Integer, Ping> pings;
   /** User code to run in response to push promise events. */
-  private final PushObserver pushObserver;
+  private final SpdyPushObserver pushObserver;
   private int nextPingId;
 
   /**
@@ -129,7 +127,6 @@
 
   private SpdyConnection(Builder builder) throws IOException {
     protocol = builder.protocol;
-    pushObserver = builder.pushObserver;
     client = builder.client;
     handler = builder.handler;
     // http://tools.ietf.org/html/draft-ietf-httpbis-http2-12#section-5.1.1
@@ -148,21 +145,22 @@ private SpdyConnection(Builder builder) throws IOException {
 
     if (protocol == Protocol.HTTP_2) {
       variant = new Http20Draft12();
-      // Like newSingleThreadExecutor, except lazy creates the thread.
-      pushExecutor = new ThreadPoolExecutor(0, 1,
-          0L, TimeUnit.MILLISECONDS,
-          new LinkedBlockingQueue<Runnable>(),
-          Util.threadFactory(String.format("OkHttp %s Push Observer", hostName), true));
     } else if (protocol == Protocol.SPDY_3) {
       variant = new Spdy3();
-      pushExecutor = null;
     } else {
       throw new AssertionError(protocol);
     }
+    // Like newSingleThreadExecutor, except lazy creates the thread.
+    pushExecutor = new ThreadPoolExecutor(0, 1,
+        0L, TimeUnit.MILLISECONDS,
+        new LinkedBlockingQueue<Runnable>(),
+        Util.threadFactory(String.format("OkHttp %s Push Observer", hostName), true));
+
     bytesLeftInWriteWindow = peerSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE);
     socket = builder.socket;
     frameWriter = variant.newWriter(Okio.buffer(Okio.sink(builder.socket)), client);
     maxFrameSize = variant.maxFrameSize();
+    pushObserver = builder.pushObserver;
 
     readerRunnable = new Reader();
     new Thread(readerRunnable).start(); // Not a daemon thread.
@@ -221,7 +219,6 @@ public synchronized long getIdleStartTimeNs() {
   public SpdyStream pushStream(int associatedStreamId, List<Header> requestHeaders, boolean out)
       throws IOException {
     if (client) throw new IllegalStateException("Client cannot push requests.");
-    if (protocol != Protocol.HTTP_2) throw new IllegalStateException("protocol != HTTP_2");
     return newStream(associatedStreamId, requestHeaders, out, false);
   }
 
@@ -258,7 +255,7 @@ private SpdyStream newStream(int associatedStreamId, List<Header> requestHeaders
           setIdle(false);
         }
       }
-      if (associatedStreamId == 0) {
+      if (associatedStreamId == 0 || protocol == Protocol.SPDY_3) {
         frameWriter.synStream(outFinished, inFinished, streamId, associatedStreamId,
             requestHeaders);
       } else if (client) {
@@ -506,7 +503,7 @@ public void sendConnectionPreface() throws IOException {
     private Socket socket;
     private IncomingStreamHandler handler = IncomingStreamHandler.REFUSE_INCOMING_STREAMS;
     private Protocol protocol = Protocol.SPDY_3;
-    private PushObserver pushObserver = PushObserver.CANCEL;
+    private SpdyPushObserver pushObserver = SpdyPushObserver.CANCEL;
     private boolean client;
 
     public Builder(boolean client, Socket socket) throws IOException {
@@ -533,7 +530,7 @@ public Builder protocol(Protocol protocol) {
       return this;
     }
 
-    public Builder pushObserver(PushObserver pushObserver) {
+    public Builder pushObserver(SpdyPushObserver pushObserver) {
       this.pushObserver = pushObserver;
       return this;
     }
@@ -580,10 +577,6 @@ private Reader() {
 
     @Override public void data(boolean inFinished, int streamId, BufferedSource source, int length)
         throws IOException {
-      if (pushedStream(streamId)) {
-        pushDataLater(streamId, source, length, inFinished);
-        return;
-      }
       SpdyStream dataStream = getStream(streamId);
       if (dataStream == null) {
         writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);
@@ -598,17 +591,24 @@ private Reader() {
 
     @Override public void headers(boolean outFinished, boolean inFinished, int streamId,
         int associatedStreamId, List<Header> headerBlock, HeadersMode headersMode) {
-      if (pushedStream(streamId)) {
-        pushHeadersLater(streamId, headerBlock, inFinished);
-        return;
-      }
       SpdyStream stream;
+      SpdyStream associated = null;
       synchronized (SpdyConnection.this) {
         // If we're shutdown, don't bother with this stream.
         if (shutdown) return;
 
         stream = getStream(streamId);
 
+        // Fetch associated stream
+        if (pushedStream(streamId)) {
+          associated = getStream(associatedStreamId);
+
+          if (associated == null) {
+            writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);
+            return;
+          }
+        }
+
         if (stream == null) {
           // The headers claim to be for an existing stream, but we don't have one.
           if (headersMode.failIfStreamAbsent()) {
@@ -627,6 +627,14 @@ private Reader() {
               inFinished, headerBlock);
           lastGoodStreamId = streamId;
           streams.put(streamId, newStream);
+
+          // Handle PUSH streams
+          if (pushedStream(streamId)) {
+            pushStreamLater(associated, newStream);
+            return;
+          }
+
+          // Handle server incoming requests
           executor.submit(new NamedRunnable("OkHttp %s stream %d", hostName, streamId) {
             @Override public void execute() {
               try {
@@ -653,10 +661,6 @@ private Reader() {
     }
 
     @Override public void rstStream(int streamId, ErrorCode errorCode) {
-      if (pushedStream(streamId)) {
-        pushResetLater(streamId, errorCode);
-        return;
-      }
       SpdyStream rstStream = removeStream(streamId);
       if (rstStream != null) {
         rstStream.receiveRstStream(errorCode);
@@ -763,7 +767,7 @@ private void ackSettingsLater() {
 
     @Override
     public void pushPromise(int streamId, int promisedStreamId, List<Header> requestHeaders) {
-      pushRequestLater(promisedStreamId, requestHeaders);
+      pushPromiseLater(promisedStreamId, requestHeaders);
     }
 
     @Override public void alternateService(int streamId, String origin, ByteString protocol,
@@ -772,31 +776,18 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> request
     }
   }
 
-  /** Even, positive numbered streams are pushed streams in HTTP/2. */
+  /** Even, positive numbered streams are pushed streams in HTTP/2 and SPDY/3. */
   private boolean pushedStream(int streamId) {
-    return protocol == Protocol.HTTP_2 && streamId != 0 && (streamId & 1) == 0;
+    return (protocol == Protocol.HTTP_2 || client) && streamId > 0 && (streamId & 1) == 0;
   }
 
-  // Guarded by this.
-  private final Set<Integer> currentPushRequests = new LinkedHashSet<Integer>();
-
-  private void pushRequestLater(final int streamId, final List<Header> requestHeaders) {
-    synchronized (this) {
-      if (currentPushRequests.contains(streamId)) {
-        writeSynResetLater(streamId, ErrorCode.PROTOCOL_ERROR);
-        return;
-      }
-      currentPushRequests.add(streamId);
-    }
+  private void pushPromiseLater(final int streamId, final List<Header> requestHeaders) {
     pushExecutor.submit(new NamedRunnable("OkHttp %s Push Request[%s]", hostName, streamId) {
       @Override public void execute() {
-        boolean cancel = pushObserver.onRequest(streamId, requestHeaders);
+        boolean cancel = pushObserver.onPromise(streamId, requestHeaders);
         try {
           if (cancel) {
             frameWriter.rstStream(streamId, ErrorCode.CANCEL);
-            synchronized (SpdyConnection.this) {
-              currentPushRequests.remove(streamId);
-            }
           }
         } catch (IOException ignored) {
         }
@@ -804,58 +795,30 @@ private void pushRequestLater(final int streamId, final List<Header> requestHead
     });
   }
 
-  private void pushHeadersLater(final int streamId, final List<Header> requestHeaders,
-      final boolean inFinished) {
-    pushExecutor.submit(new NamedRunnable("OkHttp %s Push Headers[%s]", hostName, streamId) {
+  private void pushStreamLater(final SpdyStream associated, final SpdyStream push) {
+    pushExecutor.submit(new NamedRunnable("OkHttp %s Push Request[%s]", hostName, push.getId()) {
       @Override public void execute() {
-        boolean cancel = pushObserver.onHeaders(streamId, requestHeaders, inFinished);
-        try {
-          if (cancel) frameWriter.rstStream(streamId, ErrorCode.CANCEL);
-          if (cancel || inFinished) {
-            synchronized (SpdyConnection.this) {
-              currentPushRequests.remove(streamId);
-            }
+        SpdyPushObserver streamPushObserver;
+        boolean cancel;
+        int pushId;
+        synchronized (associated) {
+          if (associated.pushObserver != null) {
+            streamPushObserver = associated.pushObserver;
+          } else {
+            streamPushObserver = pushObserver;
+          }
+          synchronized (push) {
+            pushId = push.getId();
+            cancel = streamPushObserver.onPush(associated, push);
           }
-        } catch (IOException ignored) {
         }
-      }
-    });
-  }
-
-  /**
-   * Eagerly reads {@code byteCount} bytes from the source before launching a background task to
-   * process the data.  This avoids corrupting the stream.
-   */
-  private void pushDataLater(final int streamId, final BufferedSource source, final int byteCount,
-      final boolean inFinished) throws IOException {
-    final Buffer buffer = new Buffer();
-    source.require(byteCount); // Eagerly read the frame before firing client thread.
-    source.read(buffer, byteCount);
-    if (buffer.size() != byteCount) throw new IOException(buffer.size() + " != " + byteCount);
-    pushExecutor.submit(new NamedRunnable("OkHttp %s Push Data[%s]", hostName, streamId) {
-      @Override public void execute() {
         try {
-          boolean cancel = pushObserver.onData(streamId, buffer, byteCount, inFinished);
-          if (cancel) frameWriter.rstStream(streamId, ErrorCode.CANCEL);
-          if (cancel || inFinished) {
-            synchronized (SpdyConnection.this) {
-              currentPushRequests.remove(streamId);
-            }
+          if (cancel) {
+            frameWriter.rstStream(pushId, ErrorCode.CANCEL);
           }
         } catch (IOException ignored) {
         }
       }
     });
   }
-
-  private void pushResetLater(final int streamId, final ErrorCode errorCode) {
-    pushExecutor.submit(new NamedRunnable("OkHttp %s Push Reset[%s]", hostName, streamId) {
-      @Override public void execute() {
-        pushObserver.onReset(streamId, errorCode);
-        synchronized (SpdyConnection.this) {
-          currentPushRequests.remove(streamId);
-        }
-      }
-    });
-  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/PushObserver.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyPushObserver.java
similarity index 62%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/spdy/PushObserver.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyPushObserver.java
index cdb51f65a5..dda77a5180 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/PushObserver.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyPushObserver.java
@@ -15,9 +15,7 @@
  */
 package com.squareup.okhttp.internal.spdy;
 
-import java.io.IOException;
 import java.util.List;
-import okio.BufferedSource;
 
 /**
  * {@link com.squareup.okhttp.Protocol#HTTP_2 HTTP/2} only.
@@ -38,7 +36,7 @@
  * <p>Return true to request cancellation of a pushed stream.  Note that this
  * does not guarantee future frames won't arrive on the stream ID.
  */
-public interface PushObserver {
+public interface SpdyPushObserver {
   /**
    * Describes the request that the server intends to push a response for.
    *
@@ -46,7 +44,7 @@
    * @param requestHeaders minimally includes {@code :method}, {@code :scheme},
    * {@code :authority}, and (@code :path}.
    */
-  boolean onRequest(int streamId, List<Header> requestHeaders);
+  boolean onPromise(int streamId, List<Header> requestHeaders);
 
   /**
    * The response headers corresponding to a pushed request.  When {@code last}
@@ -56,40 +54,16 @@
    * @param responseHeaders minimally includes {@code :status}.
    * @param last when true, there is no response data.
    */
-  boolean onHeaders(int streamId, List<Header> responseHeaders, boolean last);
+  boolean onPush(SpdyStream associated, SpdyStream push);
 
-  /**
-   * A chunk of response data corresponding to a pushed request.  This data
-   * must either be read or skipped.
-   *
-   * @param streamId server-initiated stream ID: an even number.
-   * @param source location of data corresponding with this stream ID.
-   * @param byteCount number of bytes to read or skip from the source.
-   * @param last when true, there are no data frames to follow.
-   */
-  boolean onData(int streamId, BufferedSource source, int byteCount, boolean last)
-      throws IOException;
-
-  /** Indicates the reason why this stream was canceled. */
-  void onReset(int streamId, ErrorCode errorCode);
-
-  PushObserver CANCEL = new PushObserver() {
+  SpdyPushObserver CANCEL = new SpdyPushObserver() {
 
-    @Override public boolean onRequest(int streamId, List<Header> requestHeaders) {
+    @Override public boolean onPromise(int streamId, List<Header> requestHeaders) {
       return true;
     }
 
-    @Override public boolean onHeaders(int streamId, List<Header> responseHeaders, boolean last) {
+    @Override public boolean onPush(SpdyStream associated, SpdyStream push) {
       return true;
     }
-
-    @Override public boolean onData(int streamId, BufferedSource source, int byteCount,
-        boolean last) throws IOException {
-      source.skip(byteCount);
-      return true;
-    }
-
-    @Override public void onReset(int streamId, ErrorCode errorCode) {
-    }
   };
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
index 30e2ccb3b7..fdb22c4cee 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
@@ -65,6 +65,7 @@
   final SpdyDataSink sink;
   private final SpdyTimeout readTimeout = new SpdyTimeout();
   private final SpdyTimeout writeTimeout = new SpdyTimeout();
+  public SpdyPushObserver pushObserver = null;
 
   /**
    * The reason why this stream was abnormally closed. If there are multiple
