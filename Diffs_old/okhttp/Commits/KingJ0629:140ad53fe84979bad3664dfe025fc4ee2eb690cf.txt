diff --git a/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java b/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java
index d46494d95b..a6070e9a3c 100644
--- a/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java
@@ -50,24 +50,30 @@ public CacheInterceptor(InternalCache cache) {
   }
 
   @Override public Response intercept(Chain chain) throws IOException {
+    // 1.通过 cache 找到之前缓存的响应，但是该缓存如他的名字一样，仅仅是一个候选人。
     Response cacheCandidate = cache != null
         ? cache.get(chain.request())
         : null;
-
+  
+    // 2.获取当前的系统时间。
     long now = System.currentTimeMillis();
-
+  
+    // 3.通过 CacheStrategy 的工厂方法构造出 CacheStrategy 对象，并通过 get 方法返回。
     CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();
+    // 4.在 CacheStrategy 的构造过程中，会初始化 networkRequest 和 cacheResponse 这两个变量，分别表示要发起的网络请求和确定的缓存。
     Request networkRequest = strategy.networkRequest;
     Response cacheResponse = strategy.cacheResponse;
 
     if (cache != null) {
       cache.trackResponse(strategy);
     }
-
+  
+    // 5.如果曾经有候选的缓存，但是经过处理后 cacheResponse 不存在，那么关闭候选的缓存资源。
     if (cacheCandidate != null && cacheResponse == null) {
       closeQuietly(cacheCandidate.body()); // The cache candidate wasn't applicable. Close it.
     }
-
+  
+    // 6.如果要发起的请求为空，并且没有缓存，那么直接返回 504 给调用者。
     // If we're forbidden from using the network and the cache is insufficient, fail.
     if (networkRequest == null && cacheResponse == null) {
       return new Response.Builder()
@@ -80,7 +86,8 @@ public CacheInterceptor(InternalCache cache) {
           .receivedResponseAtMillis(System.currentTimeMillis())
           .build();
     }
-
+  
+    // 7.如果不需要发起网络请求，那么直接将缓存返回给调用者。
     // If we don't need the network, we're done.
     if (networkRequest == null) {
       return cacheResponse.newBuilder()
@@ -90,21 +97,33 @@ public CacheInterceptor(InternalCache cache) {
 
     Response networkResponse = null;
     try {
+      // 8.继续调用链的下一个步骤，按常理来说，走到这里就会真正地发起网络请求了。
       networkResponse = chain.proceed(networkRequest);
     } finally {
+      // 9.保证在发生了异常的情况下，候选的缓存可以正常关闭。
       // If we're crashing on I/O or otherwise, don't leak the cache body.
       if (networkResponse == null && cacheCandidate != null) {
         closeQuietly(cacheCandidate.body());
       }
     }
-
+  
+    // 10.网络请求完成之后，假如之前有缓存，那么首先进行一些额外的处理。
     // If we have a cache response too, then we're doing a conditional get.
     if (cacheResponse != null) {
+      // 10.1 假如是 304，那么根据缓存构造出返回的结果给调用者。
+      /**
+       * 304 Not Modified
+       * 表示资源未被修改，因为请求头指定的版本If-Modified-Since或If-None-Match。
+       * 在这种情况下，由于客户端仍然具有以前下载的副本，因此不需要重新传输资源。
+       */
       if (networkResponse.code() == HTTP_NOT_MODIFIED) {
         Response response = cacheResponse.newBuilder()
+             // 结合两者的头部字段。
             .headers(combine(cacheResponse.headers(), networkResponse.headers()))
+             // 更新发送和接收请求的时间。
             .sentRequestAtMillis(networkResponse.sentRequestAtMillis())
             .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())
+             // 更新缓存和请求的返回结果。
             .cacheResponse(stripBody(cacheResponse))
             .networkResponse(stripBody(networkResponse))
             .build();
@@ -116,10 +135,12 @@ public CacheInterceptor(InternalCache cache) {
         cache.update(cacheResponse, response);
         return response;
       } else {
+        // 10.2 关闭缓存。
         closeQuietly(cacheResponse.body());
       }
     }
-
+    
+    // 11.构造出返回结果。
     Response response = networkResponse.newBuilder()
         .cacheResponse(stripBody(cacheResponse))
         .networkResponse(stripBody(networkResponse))
@@ -127,11 +148,13 @@ public CacheInterceptor(InternalCache cache) {
 
     if (cache != null) {
       if (HttpHeaders.hasBody(response) && CacheStrategy.isCacheable(response, networkRequest)) {
+        // 12.如果符合缓存的要求，那么就缓存该结果。
         // Offer this request to the cache.
         CacheRequest cacheRequest = cache.put(response);
         return cacheWritingResponse(cacheRequest, response);
       }
-
+  
+      // 13.对于某些请求方法，需要移除缓存，例如 PUT/PATCH/POST/DELETE/MOVE
       if (HttpMethod.invalidatesCache(networkRequest.method())) {
         try {
           cache.remove(networkRequest);
diff --git a/okhttp/src/main/java/okhttp3/internal/http/HttpCodec.java b/okhttp/src/main/java/okhttp3/internal/http/HttpCodec.java
index ad9759acce..434d96e539 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/HttpCodec.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/HttpCodec.java
@@ -21,7 +21,10 @@
 import okhttp3.ResponseBody;
 import okio.Sink;
 
-/** Encodes HTTP requests and decodes HTTP responses. */
+/**
+ * Encodes HTTP requests and decodes HTTP responses.
+ * 编码HTTP请求并解码HTTP响应
+ */
 public interface HttpCodec {
   /**
    * The timeout to use while discarding a stream of input data. Since this is used for connection
