diff --git a/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java b/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
index 40e60969dc..ddfa72bf81 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
@@ -175,9 +175,12 @@ private RealConnection findConnection(int connectTimeout, int readTimeout, int w
             // Attempt to use an already-allocated connection. We need to be careful here because our
             // already-allocated connection may have been restricted from creating new streams.
             releasedConnection = this.connection;
+
+            // 如果connection不允许新增stream,返回一个用于关闭的socket
             toClose = releaseIfNoNewStreams();
             if (this.connection != null) {
                 // We had an already-allocated connection and it's good.
+                // 如果当前StreamAllocation持有的连接不为空
                 result = this.connection;
                 releasedConnection = null;
             }
@@ -187,9 +190,10 @@ private RealConnection findConnection(int connectTimeout, int readTimeout, int w
             }
 
             if (result == null) {
-                // Attempt to get a connection from the pool.
+                // Attempt to get a connection from the pool.说明当前分配流还未找到可用连接
                 Internal.instance.acquire(connectionPool, address, this, null);
                 if (connection != null) {
+                    // 找到可用连接
                     foundPooledConnection = true;
                     result = connection;
                 } else {
@@ -206,7 +210,7 @@ private RealConnection findConnection(int connectTimeout, int readTimeout, int w
             eventListener.connectionAcquired(call, result);
         }
         if (result != null) {
-            // If we found an already-allocated or pooled connection, we're done.
+            // If we found an already-allocated or pooled connection, we're done.找到可用连接，直接返回
             return result;
         }
 
@@ -291,6 +295,7 @@ private Socket releaseIfNoNewStreams() {
         assert (Thread.holdsLock(connectionPool));
         RealConnection allocatedConnection = this.connection;
         if (allocatedConnection != null && allocatedConnection.noNewStreams) {
+            // 如果connection不允许创建新stream,返回一个用于关闭的socket
             return deallocate(false, false, true);
         }
         return null;
@@ -407,7 +412,9 @@ private Socket deallocate(boolean noNewStreams, boolean released, boolean stream
             if (this.codec == null && (this.released || connection.noNewStreams)) {
                 release(connection);
                 if (connection.allocations.isEmpty()) {
+                    // 如果connection未分配流，标记闲置时间戳
                     connection.idleAtNanos = System.nanoTime();
+                    // 将connection标记为空闲连接
                     if (Internal.instance.connectionBecameIdle(connectionPool, connection)) {
                         socket = connection.socket();
                     }
@@ -490,7 +497,7 @@ public void acquire(RealConnection connection, boolean reportedAcquired) {
     }
 
     /**
-     * Remove this allocation from the connection's list of allocations.
+     * Remove this allocation from the connection's list of allocations.从分配列表中移除此分配
      */
     private void release(RealConnection connection) {
         for (int i = 0, size = connection.allocations.size(); i < size; i++) {
diff --git a/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
index dbf57cb973..c3696649cd 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
@@ -17,6 +17,7 @@
 
 import java.io.IOException;
 import java.net.ProtocolException;
+
 import okhttp3.Call;
 import okhttp3.Interceptor;
 import okhttp3.Request;
@@ -32,135 +33,139 @@
 import okio.Okio;
 import okio.Sink;
 
-/** This is the last interceptor in the chain. It makes a network call to the server. */
+/**
+ * This is the last interceptor in the chain. It makes a network call to the server.
+ */
 public final class CallServerInterceptor implements Interceptor {
-  private final boolean forWebSocket;
-
-  public CallServerInterceptor(boolean forWebSocket) {
-    this.forWebSocket = forWebSocket;
-  }
-
-  @Override public Response intercept(Chain chain) throws IOException {
-    final RealInterceptorChain realChain = (RealInterceptorChain) chain;
-    Call call = realChain.call();
-    final HttpCodec httpCodec = realChain.httpStream();
-    StreamAllocation streamAllocation = realChain.streamAllocation();
-    RealConnection connection = (RealConnection) realChain.connection();
-    Request request = realChain.request();
-
-    long sentRequestMillis = System.currentTimeMillis();
-
-    realChain.eventListener().requestHeadersStart(call);
-    httpCodec.writeRequestHeaders(request);
-    realChain.eventListener().requestHeadersEnd(call, request);
-
-    Response.Builder responseBuilder = null;
-    if (HttpMethod.permitsRequestBody(request.method()) && request.body() != null) {
-      // If there's a "Expect: 100-continue" header on the request, wait for a "HTTP/1.1 100
-      // Continue" response before transmitting the request body. If we don't get that, return
-      // what we did get (such as a 4xx response) without ever transmitting the request body.
-      if ("100-continue".equalsIgnoreCase(request.header("Expect"))) {
-        httpCodec.flushRequest();
-        realChain.eventListener().responseHeadersStart(call);
-        responseBuilder = httpCodec.readResponseHeaders(true);
-      }
-
-      if (responseBuilder == null) {
-        if (request.body() instanceof DuplexRequestBody) {
-          // Prepare a duplex body so that the application can send a request body later.
-          httpCodec.flushRequest();
-          CountingSink requestBodyOut = new CountingSink(httpCodec.createRequestBody(request, -1L));
-          ((DuplexRequestBody) request.body()).foldSink(requestBodyOut);
-        } else {
-          // Write the request body if the "Expect: 100-continue" expectation was met.
-          realChain.eventListener().requestBodyStart(call);
-          long contentLength = request.body().contentLength();
-          CountingSink requestBodyOut =
-              new CountingSink(httpCodec.createRequestBody(request, contentLength));
-          BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);
-
-          request.body().writeTo(bufferedRequestBody);
-          bufferedRequestBody.close();
-          realChain.eventListener().requestBodyEnd(call, requestBodyOut.successfulCount);
-        }
-      } else if (!connection.isMultiplexed()) {
-        // If the "Expect: 100-continue" expectation wasn't met, prevent the HTTP/1 connection
-        // from being reused. Otherwise we're still obligated to transmit the request body to
-        // leave the connection in a consistent state.
-        streamAllocation.noNewStreams();
-      }
-    }
+    private final boolean forWebSocket;
 
-    if (!(request.body() instanceof DuplexRequestBody)) {
-      httpCodec.finishRequest();
+    public CallServerInterceptor(boolean forWebSocket) {
+        this.forWebSocket = forWebSocket;
     }
 
-    if (responseBuilder == null) {
-      realChain.eventListener().responseHeadersStart(call);
-      responseBuilder = httpCodec.readResponseHeaders(false);
-    }
+    @Override
+    public Response intercept(Chain chain) throws IOException {
+        final RealInterceptorChain realChain = (RealInterceptorChain) chain;
+        Call call = realChain.call();
+        final HttpCodec httpCodec = realChain.httpStream();
+        StreamAllocation streamAllocation = realChain.streamAllocation();
+        RealConnection connection = (RealConnection) realChain.connection();
+        Request request = realChain.request();
+
+        long sentRequestMillis = System.currentTimeMillis();
+
+        realChain.eventListener().requestHeadersStart(call);
+        httpCodec.writeRequestHeaders(request);
+        realChain.eventListener().requestHeadersEnd(call, request);
+
+        Response.Builder responseBuilder = null;
+        if (HttpMethod.permitsRequestBody(request.method()) && request.body() != null) {
+            // If there's a "Expect: 100-continue" header on the request, wait for a "HTTP/1.1 100
+            // Continue" response before transmitting the request body. If we don't get that, return
+            // what we did get (such as a 4xx response) without ever transmitting the request body.
+            if ("100-continue".equalsIgnoreCase(request.header("Expect"))) {
+                httpCodec.flushRequest();
+                realChain.eventListener().responseHeadersStart(call);
+                responseBuilder = httpCodec.readResponseHeaders(true);
+            }
+
+            if (responseBuilder == null) {
+                if (request.body() instanceof DuplexRequestBody) {
+                    // Prepare a duplex body so that the application can send a request body later.
+                    httpCodec.flushRequest();
+                    CountingSink requestBodyOut = new CountingSink(httpCodec.createRequestBody(request, -1L));
+                    ((DuplexRequestBody) request.body()).foldSink(requestBodyOut);
+                } else {
+                    // Write the request body if the "Expect: 100-continue" expectation was met.
+                    realChain.eventListener().requestBodyStart(call);
+                    long contentLength = request.body().contentLength();
+                    CountingSink requestBodyOut =
+                            new CountingSink(httpCodec.createRequestBody(request, contentLength));
+                    BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);
+
+                    request.body().writeTo(bufferedRequestBody);
+                    bufferedRequestBody.close();
+                    realChain.eventListener().requestBodyEnd(call, requestBodyOut.successfulCount);
+                }
+            } else if (!connection.isMultiplexed()) {
+                // If the "Expect: 100-continue" expectation wasn't met, prevent the HTTP/1 connection
+                // from being reused. Otherwise we're still obligated to transmit the request body to
+                // leave the connection in a consistent state.
+                streamAllocation.noNewStreams();
+            }
+        }
 
-    responseBuilder
-        .request(request)
-        .handshake(streamAllocation.connection().handshake())
-        .sentRequestAtMillis(sentRequestMillis)
-        .receivedResponseAtMillis(System.currentTimeMillis());
-    Internal.instance.initCodec(responseBuilder, httpCodec);
-    Response response = responseBuilder.build();
-
-    int code = response.code();
-    if (code == 100) {
-      // server sent a 100-continue even though we did not request one.
-      // try again to read the actual response
-      responseBuilder = httpCodec.readResponseHeaders(false);
-
-      responseBuilder
-          .request(request)
-          .handshake(streamAllocation.connection().handshake())
-          .sentRequestAtMillis(sentRequestMillis)
-          .receivedResponseAtMillis(System.currentTimeMillis());
-      Internal.instance.initCodec(responseBuilder, httpCodec);
-      response = responseBuilder.build();
-
-      code = response.code();
-    }
+        if (!(request.body() instanceof DuplexRequestBody)) {
+            httpCodec.finishRequest();
+        }
 
-    realChain.eventListener().responseHeadersEnd(call, response);
-
-    if (forWebSocket && code == 101) {
-      // Connection is upgrading, but we need to ensure interceptors see a non-null response body.
-      response = response.newBuilder()
-          .body(Util.EMPTY_RESPONSE)
-          .build();
-    } else {
-      response = response.newBuilder()
-          .body(httpCodec.openResponseBody(response))
-          .build();
-    }
+        if (responseBuilder == null) {
+            realChain.eventListener().responseHeadersStart(call);
+            responseBuilder = httpCodec.readResponseHeaders(false);
+        }
 
-    if ("close".equalsIgnoreCase(response.request().header("Connection"))
-        || "close".equalsIgnoreCase(response.header("Connection"))) {
-      streamAllocation.noNewStreams();
-    }
+        responseBuilder
+                .request(request)
+                .handshake(streamAllocation.connection().handshake())
+                .sentRequestAtMillis(sentRequestMillis)
+                .receivedResponseAtMillis(System.currentTimeMillis());
+        Internal.instance.initCodec(responseBuilder, httpCodec);
+        Response response = responseBuilder.build();
+
+        int code = response.code();
+        if (code == 100) {
+            // server sent a 100-continue even though we did not request one.
+            // try again to read the actual response
+            responseBuilder = httpCodec.readResponseHeaders(false);
+
+            responseBuilder
+                    .request(request)
+                    .handshake(streamAllocation.connection().handshake())
+                    .sentRequestAtMillis(sentRequestMillis)
+                    .receivedResponseAtMillis(System.currentTimeMillis());
+            Internal.instance.initCodec(responseBuilder, httpCodec);
+            response = responseBuilder.build();
+
+            code = response.code();
+        }
 
-    if ((code == 204 || code == 205) && response.body().contentLength() > 0) {
-      throw new ProtocolException(
-          "HTTP " + code + " had non-zero Content-Length: " + response.body().contentLength());
-    }
+        realChain.eventListener().responseHeadersEnd(call, response);
 
-    return response;
-  }
+        if (forWebSocket && code == 101) {
+            // Connection is upgrading, but we need to ensure interceptors see a non-null response body.
+            response = response.newBuilder()
+                    .body(Util.EMPTY_RESPONSE)
+                    .build();
+        } else {
+            response = response.newBuilder()
+                    .body(httpCodec.openResponseBody(response))
+                    .build();
+        }
 
-  static final class CountingSink extends ForwardingSink {
-    long successfulCount;
+        if ("close".equalsIgnoreCase(response.request().header("Connection"))
+                || "close".equalsIgnoreCase(response.header("Connection"))) {
+            streamAllocation.noNewStreams();
+        }
 
-    CountingSink(Sink delegate) {
-      super(delegate);
+        if ((code == 204 || code == 205) && response.body().contentLength() > 0) {
+            throw new ProtocolException(
+                    "HTTP " + code + " had non-zero Content-Length: " + response.body().contentLength());
+        }
+
+        return response;
     }
 
-    @Override public void write(Buffer source, long byteCount) throws IOException {
-      super.write(source, byteCount);
-      successfulCount += byteCount;
+    static final class CountingSink extends ForwardingSink {
+        long successfulCount;
+
+        CountingSink(Sink delegate) {
+            super(delegate);
+        }
+
+        @Override
+        public void write(Buffer source, long byteCount) throws IOException {
+            super.write(source, byteCount);
+            successfulCount += byteCount;
+        }
     }
-  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java b/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java
index 6dc70c4865..c3ae5ca233 100644
--- a/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java
+++ b/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java
@@ -18,6 +18,7 @@
 import java.io.EOFException;
 import java.io.IOException;
 import java.net.ProtocolException;
+
 import okhttp3.Headers;
 import okhttp3.HttpUrl;
 import okhttp3.OkHttpClient;
@@ -51,15 +52,15 @@
  * following lifecycle:
  *
  * <ol>
- *     <li>{@linkplain #writeRequest Send request headers}.
- *     <li>Open a sink to write the request body. Either {@linkplain #newFixedLengthSink
- *         fixed-length} or {@link #newChunkedSink chunked}.
- *     <li>Write to and then close that sink.
- *     <li>{@linkplain #readResponseHeaders Read response headers}.
- *     <li>Open a source to read the response body. Either {@linkplain #newFixedLengthSource
- *         fixed-length}, {@linkplain #newChunkedSource chunked} or {@linkplain
- *         #newUnknownLengthSource unknown length}.
- *     <li>Read from and close that source.
+ * <li>{@linkplain #writeRequest Send request headers}.
+ * <li>Open a sink to write the request body. Either {@linkplain #newFixedLengthSink
+ * fixed-length} or {@link #newChunkedSink chunked}.
+ * <li>Write to and then close that sink.
+ * <li>{@linkplain #readResponseHeaders Read response headers}.
+ * <li>Open a source to read the response body. Either {@linkplain #newFixedLengthSource
+ * fixed-length}, {@linkplain #newChunkedSource chunked} or {@linkplain
+ * #newUnknownLengthSource unknown length}.
+ * <li>Read from and close that source.
  * </ol>
  *
  * <p>Exchanges that do not have a request body may skip creating and closing the request body.
@@ -67,470 +68,512 @@
  * newFixedLengthSource(0)} and may skip reading and closing that source.
  */
 public final class Http1Codec implements HttpCodec {
-  private static final int STATE_IDLE = 0; // Idle connections are ready to write request headers.
-  private static final int STATE_OPEN_REQUEST_BODY = 1;
-  private static final int STATE_WRITING_REQUEST_BODY = 2;
-  private static final int STATE_READ_RESPONSE_HEADERS = 3;
-  private static final int STATE_OPEN_RESPONSE_BODY = 4;
-  private static final int STATE_READING_RESPONSE_BODY = 5;
-  private static final int STATE_CLOSED = 6;
-  private static final int HEADER_LIMIT = 256 * 1024;
-
-  /** The client that configures this stream. May be null for HTTPS proxy tunnels. */
-  final OkHttpClient client;
-  /** The stream allocation that owns this stream. May be null for HTTPS proxy tunnels. */
-  final StreamAllocation streamAllocation;
-
-  final BufferedSource source;
-  final BufferedSink sink;
-  int state = STATE_IDLE;
-  private long headerLimit = HEADER_LIMIT;
-
-  /**
-   * Received trailers. Null unless the response body uses chunked transfer-encoding and includes
-   * trailers. Undefined until the end of the response body.
-   */
-  private Headers trailers;
-
-  public Http1Codec(OkHttpClient client, StreamAllocation streamAllocation, BufferedSource source,
-      BufferedSink sink) {
-    this.client = client;
-    this.streamAllocation = streamAllocation;
-    this.source = source;
-    this.sink = sink;
-  }
-
-  @Override public Sink createRequestBody(Request request, long contentLength) {
-    if ("chunked".equalsIgnoreCase(request.header("Transfer-Encoding"))) {
-      // Stream a request body of unknown length.
-      return newChunkedSink();
-    }
+    private static final int STATE_IDLE = 0; // Idle connections are ready to write request headers.
+    private static final int STATE_OPEN_REQUEST_BODY = 1;
+    private static final int STATE_WRITING_REQUEST_BODY = 2;
+    private static final int STATE_READ_RESPONSE_HEADERS = 3;
+    private static final int STATE_OPEN_RESPONSE_BODY = 4;
+    private static final int STATE_READING_RESPONSE_BODY = 5;
+    private static final int STATE_CLOSED = 6;
+    private static final int HEADER_LIMIT = 256 * 1024;
 
-    if (contentLength != -1) {
-      // Stream a request body of a known length.
-      return newFixedLengthSink(contentLength);
-    }
+    /**
+     * The client that configures this stream. May be null for HTTPS proxy tunnels.
+     */
+    final OkHttpClient client;
+    /**
+     * The stream allocation that owns this stream. May be null for HTTPS proxy tunnels.
+     */
+    final StreamAllocation streamAllocation;
 
-    throw new IllegalStateException(
-        "Cannot stream a request body without chunked encoding or a known content length!");
-  }
-
-  @Override public void cancel() {
-    RealConnection connection = streamAllocation.connection();
-    if (connection != null) connection.cancel();
-  }
-
-  /**
-   * Prepares the HTTP headers and sends them to the server.
-   *
-   * <p>For streaming requests with a body, headers must be prepared <strong>before</strong> the
-   * output stream has been written to. Otherwise the body would need to be buffered!
-   *
-   * <p>For non-streaming requests with a body, headers must be prepared <strong>after</strong> the
-   * output stream has been written to and closed. This ensures that the {@code Content-Length}
-   * header field receives the proper value.
-   */
-  @Override public void writeRequestHeaders(Request request) throws IOException {
-    String requestLine = RequestLine.get(
-        request, streamAllocation.connection().route().proxy().type());
-    writeRequest(request.headers(), requestLine);
-  }
-
-  @Override public ResponseBody openResponseBody(Response response) throws IOException {
-    streamAllocation.eventListener.responseBodyStart(streamAllocation.call);
-    String contentType = response.header("Content-Type");
-
-    if (!HttpHeaders.hasBody(response)) {
-      Source source = newFixedLengthSource(0);
-      return new RealResponseBody(contentType, 0, Okio.buffer(source));
-    }
+    final BufferedSource source;
+    final BufferedSink sink;
+    int state = STATE_IDLE;
+    private long headerLimit = HEADER_LIMIT;
 
-    if ("chunked".equalsIgnoreCase(response.header("Transfer-Encoding"))) {
-      Source source = newChunkedSource(response.request().url());
-      return new RealResponseBody(contentType, -1L, Okio.buffer(source));
-    }
+    /**
+     * Received trailers. Null unless the response body uses chunked transfer-encoding and includes
+     * trailers. Undefined until the end of the response body.
+     */
+    private Headers trailers;
 
-    long contentLength = HttpHeaders.contentLength(response);
-    if (contentLength != -1) {
-      Source source = newFixedLengthSource(contentLength);
-      return new RealResponseBody(contentType, contentLength, Okio.buffer(source));
+    public Http1Codec(OkHttpClient client, StreamAllocation streamAllocation, BufferedSource source,
+                      BufferedSink sink) {
+        this.client = client;
+        this.streamAllocation = streamAllocation;
+        this.source = source;
+        this.sink = sink;
     }
 
-    return new RealResponseBody(contentType, -1L, Okio.buffer(newUnknownLengthSource()));
-  }
+    @Override
+    public Sink createRequestBody(Request request, long contentLength) {
+        if ("chunked".equalsIgnoreCase(request.header("Transfer-Encoding"))) {
+            // Stream a request body of unknown length.
+            return newChunkedSink();
+        }
 
-  @Override public Headers trailers() throws IOException {
-    if (state != STATE_CLOSED) {
-      throw new IllegalStateException("too early; can't read the trailers yet");
-    }
-    return trailers != null ? trailers : Util.EMPTY_HEADERS;
-  }
-
-  /** Returns true if this connection is closed. */
-  public boolean isClosed() {
-    return state == STATE_CLOSED;
-  }
-
-  @Override public void flushRequest() throws IOException {
-    sink.flush();
-  }
-
-  @Override public void finishRequest() throws IOException {
-    sink.flush();
-  }
-
-  /** Returns bytes of a request header for sending on an HTTP transport. */
-  public void writeRequest(Headers headers, String requestLine) throws IOException {
-    if (state != STATE_IDLE) throw new IllegalStateException("state: " + state);
-    sink.writeUtf8(requestLine).writeUtf8("\r\n");
-    for (int i = 0, size = headers.size(); i < size; i++) {
-      sink.writeUtf8(headers.name(i))
-          .writeUtf8(": ")
-          .writeUtf8(headers.value(i))
-          .writeUtf8("\r\n");
+        if (contentLength != -1) {
+            // Stream a request body of a known length.
+            return newFixedLengthSink(contentLength);
+        }
+
+        throw new IllegalStateException(
+                "Cannot stream a request body without chunked encoding or a known content length!");
     }
-    sink.writeUtf8("\r\n");
-    state = STATE_OPEN_REQUEST_BODY;
-  }
 
-  @Override public Response.Builder readResponseHeaders(boolean expectContinue) throws IOException {
-    if (state != STATE_OPEN_REQUEST_BODY && state != STATE_READ_RESPONSE_HEADERS) {
-      throw new IllegalStateException("state: " + state);
+    @Override
+    public void cancel() {
+        RealConnection connection = streamAllocation.connection();
+        if (connection != null) connection.cancel();
     }
 
-    try {
-      StatusLine statusLine = StatusLine.parse(readHeaderLine());
-
-      Response.Builder responseBuilder = new Response.Builder()
-          .protocol(statusLine.protocol)
-          .code(statusLine.code)
-          .message(statusLine.message)
-          .headers(readHeaders());
-
-      if (expectContinue && statusLine.code == HTTP_CONTINUE) {
-        return null;
-      } else if (statusLine.code == HTTP_CONTINUE) {
-        state = STATE_READ_RESPONSE_HEADERS;
-        return responseBuilder;
-      }
-
-      state = STATE_OPEN_RESPONSE_BODY;
-      return responseBuilder;
-    } catch (EOFException e) {
-      // Provide more context if the server ends the stream before sending a response.
-      throw new IOException("unexpected end of stream on " + streamAllocation, e);
+    /**
+     * Prepares the HTTP headers and sends them to the server.
+     *
+     * <p>For streaming requests with a body, headers must be prepared <strong>before</strong> the
+     * output stream has been written to. Otherwise the body would need to be buffered!
+     *
+     * <p>For non-streaming requests with a body, headers must be prepared <strong>after</strong> the
+     * output stream has been written to and closed. This ensures that the {@code Content-Length}
+     * header field receives the proper value.
+     */
+    @Override
+    public void writeRequestHeaders(Request request) throws IOException {
+        String requestLine = RequestLine.get(
+                request, streamAllocation.connection().route().proxy().type());
+        writeRequest(request.headers(), requestLine);
     }
-  }
-
-  private String readHeaderLine() throws IOException {
-    String line = source.readUtf8LineStrict(headerLimit);
-    headerLimit -= line.length();
-    return line;
-  }
-
-  /** Reads headers or trailers. */
-  public Headers readHeaders() throws IOException {
-    Headers.Builder headers = new Headers.Builder();
-    // parse the result headers until the first blank line
-    for (String line; (line = readHeaderLine()).length() != 0; ) {
-      Internal.instance.addLenient(headers, line);
+
+    @Override
+    public ResponseBody openResponseBody(Response response) throws IOException {
+        streamAllocation.eventListener.responseBodyStart(streamAllocation.call);
+        String contentType = response.header("Content-Type");
+
+        if (!HttpHeaders.hasBody(response)) {
+            Source source = newFixedLengthSource(0);
+            return new RealResponseBody(contentType, 0, Okio.buffer(source));
+        }
+
+        if ("chunked".equalsIgnoreCase(response.header("Transfer-Encoding"))) {
+            Source source = newChunkedSource(response.request().url());
+            return new RealResponseBody(contentType, -1L, Okio.buffer(source));
+        }
+
+        long contentLength = HttpHeaders.contentLength(response);
+        if (contentLength != -1) {
+            Source source = newFixedLengthSource(contentLength);
+            return new RealResponseBody(contentType, contentLength, Okio.buffer(source));
+        }
+
+        return new RealResponseBody(contentType, -1L, Okio.buffer(newUnknownLengthSource()));
     }
-    return headers.build();
-  }
-
-  public Sink newChunkedSink() {
-    if (state != STATE_OPEN_REQUEST_BODY) throw new IllegalStateException("state: " + state);
-    state = STATE_WRITING_REQUEST_BODY;
-    return new ChunkedSink();
-  }
-
-  public Sink newFixedLengthSink(long contentLength) {
-    if (state != STATE_OPEN_REQUEST_BODY) throw new IllegalStateException("state: " + state);
-    state = STATE_WRITING_REQUEST_BODY;
-    return new FixedLengthSink(contentLength);
-  }
-
-  public Source newFixedLengthSource(long length) throws IOException {
-    if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
-    state = STATE_READING_RESPONSE_BODY;
-    return new FixedLengthSource(length);
-  }
-
-  public Source newChunkedSource(HttpUrl url) throws IOException {
-    if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
-    state = STATE_READING_RESPONSE_BODY;
-    return new ChunkedSource(url);
-  }
-
-  public Source newUnknownLengthSource() throws IOException {
-    if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
-    if (streamAllocation == null) throw new IllegalStateException("streamAllocation == null");
-    state = STATE_READING_RESPONSE_BODY;
-    streamAllocation.noNewStreams();
-    return new UnknownLengthSource();
-  }
-
-  /**
-   * Sets the delegate of {@code timeout} to {@link Timeout#NONE} and resets its underlying timeout
-   * to the default configuration. Use this to avoid unexpected sharing of timeouts between pooled
-   * connections.
-   */
-  void detachTimeout(ForwardingTimeout timeout) {
-    Timeout oldDelegate = timeout.delegate();
-    timeout.setDelegate(Timeout.NONE);
-    oldDelegate.clearDeadline();
-    oldDelegate.clearTimeout();
-  }
-
-  /** An HTTP body with a fixed length known in advance. */
-  private final class FixedLengthSink implements Sink {
-    private final ForwardingTimeout timeout = new ForwardingTimeout(sink.timeout());
-    private boolean closed;
-    private long bytesRemaining;
-
-    FixedLengthSink(long bytesRemaining) {
-      this.bytesRemaining = bytesRemaining;
+
+    @Override
+    public Headers trailers() throws IOException {
+        if (state != STATE_CLOSED) {
+            throw new IllegalStateException("too early; can't read the trailers yet");
+        }
+        return trailers != null ? trailers : Util.EMPTY_HEADERS;
     }
 
-    @Override public Timeout timeout() {
-      return timeout;
+    /**
+     * Returns true if this connection is closed.
+     */
+    public boolean isClosed() {
+        return state == STATE_CLOSED;
     }
 
-    @Override public void write(Buffer source, long byteCount) throws IOException {
-      if (closed) throw new IllegalStateException("closed");
-      checkOffsetAndCount(source.size(), 0, byteCount);
-      if (byteCount > bytesRemaining) {
-        throw new ProtocolException("expected " + bytesRemaining
-            + " bytes but received " + byteCount);
-      }
-      sink.write(source, byteCount);
-      bytesRemaining -= byteCount;
+    @Override
+    public void flushRequest() throws IOException {
+        sink.flush();
     }
 
-    @Override public void flush() throws IOException {
-      if (closed) return; // Don't throw; this stream might have been closed on the caller's behalf.
-      sink.flush();
+    @Override
+    public void finishRequest() throws IOException {
+        sink.flush();
     }
 
-    @Override public void close() throws IOException {
-      if (closed) return;
-      closed = true;
-      if (bytesRemaining > 0) throw new ProtocolException("unexpected end of stream");
-      detachTimeout(timeout);
-      state = STATE_READ_RESPONSE_HEADERS;
+    /**
+     * Returns bytes of a request header for sending on an HTTP transport.
+     */
+    public void writeRequest(Headers headers, String requestLine) throws IOException {
+        if (state != STATE_IDLE) throw new IllegalStateException("state: " + state);
+        sink.writeUtf8(requestLine).writeUtf8("\r\n");
+        for (int i = 0, size = headers.size(); i < size; i++) {
+            sink.writeUtf8(headers.name(i))
+                    .writeUtf8(": ")
+                    .writeUtf8(headers.value(i))
+                    .writeUtf8("\r\n");
+        }
+        sink.writeUtf8("\r\n");
+        state = STATE_OPEN_REQUEST_BODY;
     }
-  }
 
-  /**
-   * An HTTP body with alternating chunk sizes and chunk bodies. It is the caller's responsibility
-   * to buffer chunks; typically by using a buffered sink with this sink.
-   */
-  private final class ChunkedSink implements Sink {
-    private final ForwardingTimeout timeout = new ForwardingTimeout(sink.timeout());
-    private boolean closed;
+    @Override
+    public Response.Builder readResponseHeaders(boolean expectContinue) throws IOException {
+        if (state != STATE_OPEN_REQUEST_BODY && state != STATE_READ_RESPONSE_HEADERS) {
+            throw new IllegalStateException("state: " + state);
+        }
 
-    ChunkedSink() {
+        try {
+            StatusLine statusLine = StatusLine.parse(readHeaderLine());
+
+            Response.Builder responseBuilder = new Response.Builder()
+                    .protocol(statusLine.protocol)
+                    .code(statusLine.code)
+                    .message(statusLine.message)
+                    .headers(readHeaders());
+
+            if (expectContinue && statusLine.code == HTTP_CONTINUE) {
+                return null;
+            } else if (statusLine.code == HTTP_CONTINUE) {
+                state = STATE_READ_RESPONSE_HEADERS;
+                return responseBuilder;
+            }
+
+            state = STATE_OPEN_RESPONSE_BODY;
+            return responseBuilder;
+        } catch (EOFException e) {
+            // Provide more context if the server ends the stream before sending a response.
+            throw new IOException("unexpected end of stream on " + streamAllocation, e);
+        }
     }
 
-    @Override public Timeout timeout() {
-      return timeout;
+    private String readHeaderLine() throws IOException {
+        String line = source.readUtf8LineStrict(headerLimit);
+        headerLimit -= line.length();
+        return line;
     }
 
-    @Override public void write(Buffer source, long byteCount) throws IOException {
-      if (closed) throw new IllegalStateException("closed");
-      if (byteCount == 0) return;
+    /**
+     * Reads headers or trailers.
+     */
+    public Headers readHeaders() throws IOException {
+        Headers.Builder headers = new Headers.Builder();
+        // parse the result headers until the first blank line
+        for (String line; (line = readHeaderLine()).length() != 0; ) {
+            Internal.instance.addLenient(headers, line);
+        }
+        return headers.build();
+    }
 
-      sink.writeHexadecimalUnsignedLong(byteCount);
-      sink.writeUtf8("\r\n");
-      sink.write(source, byteCount);
-      sink.writeUtf8("\r\n");
+    public Sink newChunkedSink() {
+        if (state != STATE_OPEN_REQUEST_BODY) throw new IllegalStateException("state: " + state);
+        state = STATE_WRITING_REQUEST_BODY;
+        return new ChunkedSink();
     }
 
-    @Override public synchronized void flush() throws IOException {
-      if (closed) return; // Don't throw; this stream might have been closed on the caller's behalf.
-      sink.flush();
+    public Sink newFixedLengthSink(long contentLength) {
+        if (state != STATE_OPEN_REQUEST_BODY) throw new IllegalStateException("state: " + state);
+        state = STATE_WRITING_REQUEST_BODY;
+        return new FixedLengthSink(contentLength);
     }
 
-    @Override public synchronized void close() throws IOException {
-      if (closed) return;
-      closed = true;
-      sink.writeUtf8("0\r\n\r\n");
-      detachTimeout(timeout);
-      state = STATE_READ_RESPONSE_HEADERS;
+    public Source newFixedLengthSource(long length) throws IOException {
+        if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
+        state = STATE_READING_RESPONSE_BODY;
+        return new FixedLengthSource(length);
     }
-  }
 
-  private abstract class AbstractSource implements Source {
-    protected final ForwardingTimeout timeout = new ForwardingTimeout(source.timeout());
-    protected boolean closed;
-    protected long bytesRead = 0;
+    public Source newChunkedSource(HttpUrl url) throws IOException {
+        if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
+        state = STATE_READING_RESPONSE_BODY;
+        return new ChunkedSource(url);
+    }
 
-    @Override public Timeout timeout() {
-      return timeout;
+    public Source newUnknownLengthSource() throws IOException {
+        if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
+        if (streamAllocation == null) throw new IllegalStateException("streamAllocation == null");
+        state = STATE_READING_RESPONSE_BODY;
+        streamAllocation.noNewStreams();
+        return new UnknownLengthSource();
     }
 
-    @Override public long read(Buffer sink, long byteCount) throws IOException {
-      try {
-        long read = source.read(sink, byteCount);
-        if (read > 0) {
-          bytesRead += read;
-        }
-        return read;
-      } catch (IOException e) {
-        endOfInput(false, e);
-        throw e;
-      }
+    /**
+     * Sets the delegate of {@code timeout} to {@link Timeout#NONE} and resets its underlying timeout
+     * to the default configuration. Use this to avoid unexpected sharing of timeouts between pooled
+     * connections.
+     */
+    void detachTimeout(ForwardingTimeout timeout) {
+        Timeout oldDelegate = timeout.delegate();
+        timeout.setDelegate(Timeout.NONE);
+        oldDelegate.clearDeadline();
+        oldDelegate.clearTimeout();
     }
 
     /**
-     * Closes the cache entry and makes the socket available for reuse. This should be invoked when
-     * the end of the body has been reached.
+     * An HTTP body with a fixed length known in advance.
      */
-    protected final void endOfInput(boolean reuseConnection, IOException e) throws IOException {
-      if (state == STATE_CLOSED) return;
-      if (state != STATE_READING_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
+    private final class FixedLengthSink implements Sink {
+        private final ForwardingTimeout timeout = new ForwardingTimeout(sink.timeout());
+        private boolean closed;
+        private long bytesRemaining;
 
-      detachTimeout(timeout);
+        FixedLengthSink(long bytesRemaining) {
+            this.bytesRemaining = bytesRemaining;
+        }
 
-      state = STATE_CLOSED;
-      if (streamAllocation != null) {
-        streamAllocation.streamFinished(!reuseConnection, Http1Codec.this, bytesRead, e);
-      }
-    }
-  }
+        @Override
+        public Timeout timeout() {
+            return timeout;
+        }
 
-  /** An HTTP body with a fixed length specified in advance. */
-  private class FixedLengthSource extends AbstractSource {
-    private long bytesRemaining;
+        @Override
+        public void write(Buffer source, long byteCount) throws IOException {
+            if (closed) throw new IllegalStateException("closed");
+            checkOffsetAndCount(source.size(), 0, byteCount);
+            if (byteCount > bytesRemaining) {
+                throw new ProtocolException("expected " + bytesRemaining
+                        + " bytes but received " + byteCount);
+            }
+            sink.write(source, byteCount);
+            bytesRemaining -= byteCount;
+        }
 
-    FixedLengthSource(long length) throws IOException {
-      bytesRemaining = length;
-      if (bytesRemaining == 0) {
-        endOfInput(true, null);
-      }
-    }
+        @Override
+        public void flush() throws IOException {
+            if (closed) return; // Don't throw; this stream might have been closed on the caller's behalf.
+            sink.flush();
+        }
 
-    @Override public long read(Buffer sink, long byteCount) throws IOException {
-      if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
-      if (closed) throw new IllegalStateException("closed");
-      if (bytesRemaining == 0) return -1;
-
-      long read = super.read(sink, Math.min(bytesRemaining, byteCount));
-      if (read == -1) {
-        ProtocolException e = new ProtocolException("unexpected end of stream");
-        endOfInput(false, e); // The server didn't supply the promised content length.
-        throw e;
-      }
-
-      bytesRemaining -= read;
-      if (bytesRemaining == 0) {
-        endOfInput(true, null);
-      }
-      return read;
+        @Override
+        public void close() throws IOException {
+            if (closed) return;
+            closed = true;
+            if (bytesRemaining > 0) throw new ProtocolException("unexpected end of stream");
+            detachTimeout(timeout);
+            state = STATE_READ_RESPONSE_HEADERS;
+        }
     }
 
-    @Override public void close() throws IOException {
-      if (closed) return;
+    /**
+     * An HTTP body with alternating chunk sizes and chunk bodies. It is the caller's responsibility
+     * to buffer chunks; typically by using a buffered sink with this sink.
+     */
+    private final class ChunkedSink implements Sink {
+        private final ForwardingTimeout timeout = new ForwardingTimeout(sink.timeout());
+        private boolean closed;
 
-      if (bytesRemaining != 0 && !Util.discard(this, DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
-        endOfInput(false, null);
-      }
+        ChunkedSink() {
+        }
 
-      closed = true;
-    }
-  }
+        @Override
+        public Timeout timeout() {
+            return timeout;
+        }
 
-  /** An HTTP body with alternating chunk sizes and chunk bodies. */
-  private class ChunkedSource extends AbstractSource {
-    private static final long NO_CHUNK_YET = -1L;
-    private final HttpUrl url;
-    private long bytesRemainingInChunk = NO_CHUNK_YET;
-    private boolean hasMoreChunks = true;
+        @Override
+        public void write(Buffer source, long byteCount) throws IOException {
+            if (closed) throw new IllegalStateException("closed");
+            if (byteCount == 0) return;
 
-    ChunkedSource(HttpUrl url) {
-      this.url = url;
-    }
+            sink.writeHexadecimalUnsignedLong(byteCount);
+            sink.writeUtf8("\r\n");
+            sink.write(source, byteCount);
+            sink.writeUtf8("\r\n");
+        }
 
-    @Override public long read(Buffer sink, long byteCount) throws IOException {
-      if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
-      if (closed) throw new IllegalStateException("closed");
-      if (!hasMoreChunks) return -1;
-
-      if (bytesRemainingInChunk == 0 || bytesRemainingInChunk == NO_CHUNK_YET) {
-        readChunkSize();
-        if (!hasMoreChunks) return -1;
-      }
-
-      long read = super.read(sink, Math.min(byteCount, bytesRemainingInChunk));
-      if (read == -1) {
-        ProtocolException e = new ProtocolException("unexpected end of stream");
-        endOfInput(false, e); // The server didn't supply the promised chunk length.
-        throw e;
-      }
-      bytesRemainingInChunk -= read;
-      return read;
-    }
+        @Override
+        public synchronized void flush() throws IOException {
+            if (closed) return; // Don't throw; this stream might have been closed on the caller's behalf.
+            sink.flush();
+        }
 
-    private void readChunkSize() throws IOException {
-      // Read the suffix of the previous chunk.
-      if (bytesRemainingInChunk != NO_CHUNK_YET) {
-        source.readUtf8LineStrict();
-      }
-      try {
-        bytesRemainingInChunk = source.readHexadecimalUnsignedLong();
-        String extensions = source.readUtf8LineStrict().trim();
-        if (bytesRemainingInChunk < 0 || (!extensions.isEmpty() && !extensions.startsWith(";"))) {
-          throw new ProtocolException("expected chunk size and optional extensions but was \""
-              + bytesRemainingInChunk + extensions + "\"");
-        }
-      } catch (NumberFormatException e) {
-        throw new ProtocolException(e.getMessage());
-      }
-      if (bytesRemainingInChunk == 0L) {
-        hasMoreChunks = false;
-        trailers = readHeaders();
-        HttpHeaders.receiveHeaders(client.cookieJar(), url, trailers);
-        endOfInput(true, null);
-      }
+        @Override
+        public synchronized void close() throws IOException {
+            if (closed) return;
+            closed = true;
+            sink.writeUtf8("0\r\n\r\n");
+            detachTimeout(timeout);
+            state = STATE_READ_RESPONSE_HEADERS;
+        }
     }
 
-    @Override public void close() throws IOException {
-      if (closed) return;
-      if (hasMoreChunks && !Util.discard(this, DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
-        endOfInput(false, null);
-      }
-      closed = true;
+    private abstract class AbstractSource implements Source {
+        protected final ForwardingTimeout timeout = new ForwardingTimeout(source.timeout());
+        protected boolean closed;
+        protected long bytesRead = 0;
+
+        @Override
+        public Timeout timeout() {
+            return timeout;
+        }
+
+        @Override
+        public long read(Buffer sink, long byteCount) throws IOException {
+            try {
+                long read = source.read(sink, byteCount);
+                if (read > 0) {
+                    bytesRead += read;
+                }
+                return read;
+            } catch (IOException e) {
+                endOfInput(false, e);
+                throw e;
+            }
+        }
+
+        /**
+         * Closes the cache entry and makes the socket available for reuse. This should be invoked when
+         * the end of the body has been reached.
+         */
+        protected final void endOfInput(boolean reuseConnection, IOException e) throws IOException {
+            if (state == STATE_CLOSED) return;
+            if (state != STATE_READING_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
+
+            detachTimeout(timeout);
+
+            state = STATE_CLOSED;
+            if (streamAllocation != null) {
+                streamAllocation.streamFinished(!reuseConnection, Http1Codec.this, bytesRead, e);
+            }
+        }
     }
-  }
 
-  /** An HTTP message body terminated by the end of the underlying stream. */
-  private class UnknownLengthSource extends AbstractSource {
-    private boolean inputExhausted;
+    /**
+     * An HTTP body with a fixed length specified in advance.
+     */
+    private class FixedLengthSource extends AbstractSource {
+        private long bytesRemaining;
+
+        FixedLengthSource(long length) throws IOException {
+            bytesRemaining = length;
+            if (bytesRemaining == 0) {
+                endOfInput(true, null);
+            }
+        }
 
-    UnknownLengthSource() {
+        @Override
+        public long read(Buffer sink, long byteCount) throws IOException {
+            if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
+            if (closed) throw new IllegalStateException("closed");
+            if (bytesRemaining == 0) return -1;
+
+            long read = super.read(sink, Math.min(bytesRemaining, byteCount));
+            if (read == -1) {
+                ProtocolException e = new ProtocolException("unexpected end of stream");
+                endOfInput(false, e); // The server didn't supply the promised content length.
+                throw e;
+            }
+
+            bytesRemaining -= read;
+            if (bytesRemaining == 0) {
+                endOfInput(true, null);
+            }
+            return read;
+        }
+
+        @Override
+        public void close() throws IOException {
+            if (closed) return;
+
+            if (bytesRemaining != 0 && !Util.discard(this, DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
+                endOfInput(false, null);
+            }
+
+            closed = true;
+        }
     }
 
-    @Override public long read(Buffer sink, long byteCount)
-        throws IOException {
-      if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
-      if (closed) throw new IllegalStateException("closed");
-      if (inputExhausted) return -1;
-
-      long read = super.read(sink, byteCount);
-      if (read == -1) {
-        inputExhausted = true;
-        endOfInput(true, null);
-        return -1;
-      }
-      return read;
+    /**
+     * An HTTP body with alternating chunk sizes and chunk bodies.
+     */
+    private class ChunkedSource extends AbstractSource {
+        private static final long NO_CHUNK_YET = -1L;
+        private final HttpUrl url;
+        private long bytesRemainingInChunk = NO_CHUNK_YET;
+        private boolean hasMoreChunks = true;
+
+        ChunkedSource(HttpUrl url) {
+            this.url = url;
+        }
+
+        @Override
+        public long read(Buffer sink, long byteCount) throws IOException {
+            if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
+            if (closed) throw new IllegalStateException("closed");
+            if (!hasMoreChunks) return -1;
+
+            if (bytesRemainingInChunk == 0 || bytesRemainingInChunk == NO_CHUNK_YET) {
+                readChunkSize();
+                if (!hasMoreChunks) return -1;
+            }
+
+            long read = super.read(sink, Math.min(byteCount, bytesRemainingInChunk));
+            if (read == -1) {
+                ProtocolException e = new ProtocolException("unexpected end of stream");
+                endOfInput(false, e); // The server didn't supply the promised chunk length.
+                throw e;
+            }
+            bytesRemainingInChunk -= read;
+            return read;
+        }
+
+        private void readChunkSize() throws IOException {
+            // Read the suffix of the previous chunk.
+            if (bytesRemainingInChunk != NO_CHUNK_YET) {
+                source.readUtf8LineStrict();
+            }
+            try {
+                bytesRemainingInChunk = source.readHexadecimalUnsignedLong();
+                String extensions = source.readUtf8LineStrict().trim();
+                if (bytesRemainingInChunk < 0 || (!extensions.isEmpty() && !extensions.startsWith(";"))) {
+                    throw new ProtocolException("expected chunk size and optional extensions but was \""
+                            + bytesRemainingInChunk + extensions + "\"");
+                }
+            } catch (NumberFormatException e) {
+                throw new ProtocolException(e.getMessage());
+            }
+            if (bytesRemainingInChunk == 0L) {
+                hasMoreChunks = false;
+                trailers = readHeaders();
+                HttpHeaders.receiveHeaders(client.cookieJar(), url, trailers);
+                endOfInput(true, null);
+            }
+        }
+
+        @Override
+        public void close() throws IOException {
+            if (closed) return;
+            if (hasMoreChunks && !Util.discard(this, DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
+                endOfInput(false, null);
+            }
+            closed = true;
+        }
     }
 
-    @Override public void close() throws IOException {
-      if (closed) return;
-      if (!inputExhausted) {
-        endOfInput(false, null);
-      }
-      closed = true;
+    /**
+     * An HTTP message body terminated by the end of the underlying stream.
+     */
+    private class UnknownLengthSource extends AbstractSource {
+        private boolean inputExhausted;
+
+        UnknownLengthSource() {
+        }
+
+        @Override
+        public long read(Buffer sink, long byteCount)
+                throws IOException {
+            if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
+            if (closed) throw new IllegalStateException("closed");
+            if (inputExhausted) return -1;
+
+            long read = super.read(sink, byteCount);
+            if (read == -1) {
+                inputExhausted = true;
+                endOfInput(true, null);
+                return -1;
+            }
+            return read;
+        }
+
+        @Override
+        public void close() throws IOException {
+            if (closed) return;
+            if (!inputExhausted) {
+                endOfInput(false, null);
+            }
+            closed = true;
+        }
     }
-  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.java b/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.java
index 9ca9abd146..c04a5a147b 100644
--- a/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.java
+++ b/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.java
@@ -17,6 +17,7 @@
 
 import android.os.Build;
 import android.util.Log;
+
 import java.io.IOException;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
@@ -33,312 +34,330 @@
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
 import javax.net.ssl.X509TrustManager;
+
 import okhttp3.Protocol;
 import okhttp3.internal.Util;
 import okhttp3.internal.tls.CertificateChainCleaner;
 
 import static java.nio.charset.StandardCharsets.UTF_8;
 
-/** Android 5+. */
+/**
+ * Android 5+.
+ */
 class AndroidPlatform extends Platform {
-  private static final int MAX_LOG_LENGTH = 4000;
-
-  private final Class<?> sslParametersClass;
-  private final OptionalMethod<Socket> setUseSessionTickets;
-  private final OptionalMethod<Socket> setHostname;
-  private final OptionalMethod<Socket> getAlpnSelectedProtocol;
-  private final OptionalMethod<Socket> setAlpnProtocols;
-
-  private final CloseGuard closeGuard = CloseGuard.get();
-
-  AndroidPlatform(Class<?> sslParametersClass, OptionalMethod<Socket> setUseSessionTickets,
-      OptionalMethod<Socket> setHostname, OptionalMethod<Socket> getAlpnSelectedProtocol,
-      OptionalMethod<Socket> setAlpnProtocols) {
-    this.sslParametersClass = sslParametersClass;
-    this.setUseSessionTickets = setUseSessionTickets;
-    this.setHostname = setHostname;
-    this.getAlpnSelectedProtocol = getAlpnSelectedProtocol;
-    this.setAlpnProtocols = setAlpnProtocols;
-  }
-
-  @Override public void connectSocket(Socket socket, InetSocketAddress address,
-      int connectTimeout) throws IOException {
-    try {
-      socket.connect(address, connectTimeout);
-    } catch (AssertionError e) {
-      if (Util.isAndroidGetsocknameError(e)) throw new IOException(e);
-      throw e;
-    } catch (ClassCastException e) {
-      // On android 8.0, socket.connect throws a ClassCastException due to a bug
-      // see https://issuetracker.google.com/issues/63649622
-      if (Build.VERSION.SDK_INT == 26) {
-        throw new IOException("Exception in connect", e);
-      } else {
-        throw e;
-      }
+    private static final int MAX_LOG_LENGTH = 4000;
+
+    private final Class<?> sslParametersClass;
+    private final OptionalMethod<Socket> setUseSessionTickets;
+    private final OptionalMethod<Socket> setHostname;
+    private final OptionalMethod<Socket> getAlpnSelectedProtocol;
+    private final OptionalMethod<Socket> setAlpnProtocols;
+
+    private final CloseGuard closeGuard = CloseGuard.get();
+
+    AndroidPlatform(Class<?> sslParametersClass, OptionalMethod<Socket> setUseSessionTickets,
+                    OptionalMethod<Socket> setHostname, OptionalMethod<Socket> getAlpnSelectedProtocol,
+                    OptionalMethod<Socket> setAlpnProtocols) {
+        this.sslParametersClass = sslParametersClass;
+        this.setUseSessionTickets = setUseSessionTickets;
+        this.setHostname = setHostname;
+        this.getAlpnSelectedProtocol = getAlpnSelectedProtocol;
+        this.setAlpnProtocols = setAlpnProtocols;
     }
-  }
-
-  @Override protected @Nullable X509TrustManager trustManager(SSLSocketFactory sslSocketFactory) {
-    Object context = readFieldOrNull(sslSocketFactory, sslParametersClass, "sslParameters");
-    if (context == null) {
-      // If that didn't work, try the Google Play Services SSL provider before giving up. This
-      // must be loaded by the SSLSocketFactory's class loader.
-      try {
-        Class<?> gmsSslParametersClass = Class.forName(
-            "com.google.android.gms.org.conscrypt.SSLParametersImpl", false,
-            sslSocketFactory.getClass().getClassLoader());
-        context = readFieldOrNull(sslSocketFactory, gmsSslParametersClass, "sslParameters");
-      } catch (ClassNotFoundException e) {
-        return super.trustManager(sslSocketFactory);
-      }
+
+    @Override
+    public void connectSocket(Socket socket, InetSocketAddress address,
+                              int connectTimeout) throws IOException {
+        try {
+            socket.connect(address, connectTimeout);
+        } catch (AssertionError e) {
+            if (Util.isAndroidGetsocknameError(e)) throw new IOException(e);
+            throw e;
+        } catch (ClassCastException e) {
+            // On android 8.0, socket.connect throws a ClassCastException due to a bug
+            // see https://issuetracker.google.com/issues/63649622
+            if (Build.VERSION.SDK_INT == 26) {
+                throw new IOException("Exception in connect", e);
+            } else {
+                throw e;
+            }
+        }
     }
 
-    X509TrustManager x509TrustManager = readFieldOrNull(
-        context, X509TrustManager.class, "x509TrustManager");
-    if (x509TrustManager != null) return x509TrustManager;
+    @Override
+    protected @Nullable
+    X509TrustManager trustManager(SSLSocketFactory sslSocketFactory) {
+        Object context = readFieldOrNull(sslSocketFactory, sslParametersClass, "sslParameters");
+        if (context == null) {
+            // If that didn't work, try the Google Play Services SSL provider before giving up. This
+            // must be loaded by the SSLSocketFactory's class loader.
+            try {
+                Class<?> gmsSslParametersClass = Class.forName(
+                        "com.google.android.gms.org.conscrypt.SSLParametersImpl", false,
+                        sslSocketFactory.getClass().getClassLoader());
+                context = readFieldOrNull(sslSocketFactory, gmsSslParametersClass, "sslParameters");
+            } catch (ClassNotFoundException e) {
+                return super.trustManager(sslSocketFactory);
+            }
+        }
 
-    return readFieldOrNull(context, X509TrustManager.class, "trustManager");
-  }
+        X509TrustManager x509TrustManager = readFieldOrNull(
+                context, X509TrustManager.class, "x509TrustManager");
+        if (x509TrustManager != null) return x509TrustManager;
 
-  @Override public void configureTlsExtensions(
-      SSLSocket sslSocket, String hostname, List<Protocol> protocols) {
-    // Enable SNI and session tickets.
-    if (hostname != null) {
-      setUseSessionTickets.invokeOptionalWithoutCheckedException(sslSocket, true);
-      // This is SSLParameters.setServerNames() in API 24+.
-      setHostname.invokeOptionalWithoutCheckedException(sslSocket, hostname);
+        return readFieldOrNull(context, X509TrustManager.class, "trustManager");
     }
 
-    // Enable ALPN.
-    if (setAlpnProtocols.isSupported(sslSocket)) {
-      Object[] parameters = {concatLengthPrefixed(protocols)};
-      setAlpnProtocols.invokeWithoutCheckedException(sslSocket, parameters);
-    }
-  }
-
-  @Override public @Nullable String getSelectedProtocol(SSLSocket socket) {
-    if (!getAlpnSelectedProtocol.isSupported(socket)) return null;
-
-    byte[] alpnResult = (byte[]) getAlpnSelectedProtocol.invokeWithoutCheckedException(socket);
-    return alpnResult != null ? new String(alpnResult, UTF_8) : null;
-  }
-
-  @Override public void log(int level, String message, @Nullable Throwable t) {
-    int logLevel = level == WARN ? Log.WARN : Log.DEBUG;
-    if (t != null) message = message + '\n' + Log.getStackTraceString(t);
-
-    // Split by line, then ensure each line can fit into Log's maximum length.
-    for (int i = 0, length = message.length(); i < length; i++) {
-      int newline = message.indexOf('\n', i);
-      newline = newline != -1 ? newline : length;
-      do {
-        int end = Math.min(newline, i + MAX_LOG_LENGTH);
-        Log.println(logLevel, "OkHttp", message.substring(i, end));
-        i = end;
-      } while (i < newline);
+    @Override
+    public void configureTlsExtensions(
+            SSLSocket sslSocket, String hostname, List<Protocol> protocols) {
+        // Enable SNI and session tickets.
+        if (hostname != null) {
+            setUseSessionTickets.invokeOptionalWithoutCheckedException(sslSocket, true);
+            // This is SSLParameters.setServerNames() in API 24+.
+            setHostname.invokeOptionalWithoutCheckedException(sslSocket, hostname);
+        }
+
+        // Enable ALPN.
+        if (setAlpnProtocols.isSupported(sslSocket)) {
+            Object[] parameters = {concatLengthPrefixed(protocols)};
+            setAlpnProtocols.invokeWithoutCheckedException(sslSocket, parameters);
+        }
     }
-  }
 
-  @Override public Object getStackTraceForCloseable(String closer) {
-    return closeGuard.createAndOpen(closer);
-  }
+    @Override
+    public @Nullable
+    String getSelectedProtocol(SSLSocket socket) {
+        if (!getAlpnSelectedProtocol.isSupported(socket)) return null;
 
-  @Override public void logCloseableLeak(String message, Object stackTrace) {
-    boolean reported = closeGuard.warnIfOpen(stackTrace);
-    if (!reported) {
-      // Unable to report via CloseGuard. As a last-ditch effort, send it to the logger.
-      log(WARN, message, null);
-    }
-  }
-
-  @Override public boolean isCleartextTrafficPermitted(String hostname) {
-    try {
-      Class<?> networkPolicyClass = Class.forName("android.security.NetworkSecurityPolicy");
-      Method getInstanceMethod = networkPolicyClass.getMethod("getInstance");
-      Object networkSecurityPolicy = getInstanceMethod.invoke(null);
-      return api24IsCleartextTrafficPermitted(hostname, networkPolicyClass, networkSecurityPolicy);
-    } catch (ClassNotFoundException | NoSuchMethodException e) {
-      return super.isCleartextTrafficPermitted(hostname);
-    } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
-      throw new AssertionError("unable to determine cleartext support", e);
+        byte[] alpnResult = (byte[]) getAlpnSelectedProtocol.invokeWithoutCheckedException(socket);
+        return alpnResult != null ? new String(alpnResult, UTF_8) : null;
     }
-  }
-
-  private boolean api24IsCleartextTrafficPermitted(String hostname, Class<?> networkPolicyClass,
-      Object networkSecurityPolicy) throws InvocationTargetException, IllegalAccessException {
-    try {
-      Method isCleartextTrafficPermittedMethod = networkPolicyClass
-          .getMethod("isCleartextTrafficPermitted", String.class);
-      return (boolean) isCleartextTrafficPermittedMethod.invoke(networkSecurityPolicy, hostname);
-    } catch (NoSuchMethodException e) {
-      return api23IsCleartextTrafficPermitted(hostname, networkPolicyClass, networkSecurityPolicy);
-    }
-  }
-
-  private boolean api23IsCleartextTrafficPermitted(String hostname, Class<?> networkPolicyClass,
-      Object networkSecurityPolicy) throws InvocationTargetException, IllegalAccessException {
-    try {
-      Method isCleartextTrafficPermittedMethod = networkPolicyClass
-          .getMethod("isCleartextTrafficPermitted");
-      return (boolean) isCleartextTrafficPermittedMethod.invoke(networkSecurityPolicy);
-    } catch (NoSuchMethodException e) {
-      return super.isCleartextTrafficPermitted(hostname);
-    }
-  }
-
-  public CertificateChainCleaner buildCertificateChainCleaner(X509TrustManager trustManager) {
-    try {
-      Class<?> extensionsClass = Class.forName("android.net.http.X509TrustManagerExtensions");
-      Constructor<?> constructor = extensionsClass.getConstructor(X509TrustManager.class);
-      Object extensions = constructor.newInstance(trustManager);
-      Method checkServerTrusted = extensionsClass.getMethod(
-          "checkServerTrusted", X509Certificate[].class, String.class, String.class);
-      return new AndroidCertificateChainCleaner(extensions, checkServerTrusted);
-    } catch (Exception e) {
-      throw new AssertionError(e);
-    }
-  }
-
-  public static @Nullable Platform buildIfSupported() {
-    // Attempt to find Android 5+ APIs.
-    try {
-      Class<?> sslParametersClass = Class.forName("com.android.org.conscrypt.SSLParametersImpl");
-      OptionalMethod<Socket> setUseSessionTickets = new OptionalMethod<>(
-          null, "setUseSessionTickets", boolean.class);
-      OptionalMethod<Socket> setHostname = new OptionalMethod<>(
-          null, "setHostname", String.class);
-      OptionalMethod<Socket> getAlpnSelectedProtocol = new OptionalMethod<>(
-          byte[].class, "getAlpnSelectedProtocol");
-      OptionalMethod<Socket> setAlpnProtocols = new OptionalMethod<>(
-          null, "setAlpnProtocols", byte[].class);
-      return new AndroidPlatform(sslParametersClass, setUseSessionTickets, setHostname,
-          getAlpnSelectedProtocol, setAlpnProtocols);
-    } catch (ClassNotFoundException ignored) {
-      return null; // Not an Android runtime.
-    }
-  }
-
-  /**
-   * X509TrustManagerExtensions was added to Android in API 17 (Android 4.2, released in late 2012).
-   * This is the best way to get a clean chain on Android because it uses the same code as the TLS
-   * handshake.
-   */
-  static final class AndroidCertificateChainCleaner extends CertificateChainCleaner {
-    private final Object x509TrustManagerExtensions;
-    private final Method checkServerTrusted;
-
-    AndroidCertificateChainCleaner(Object x509TrustManagerExtensions, Method checkServerTrusted) {
-      this.x509TrustManagerExtensions = x509TrustManagerExtensions;
-      this.checkServerTrusted = checkServerTrusted;
+
+    @Override
+    public void log(int level, String message, @Nullable Throwable t) {
+        int logLevel = level == WARN ? Log.WARN : Log.DEBUG;
+        if (t != null) message = message + '\n' + Log.getStackTraceString(t);
+
+        // Split by line, then ensure each line can fit into Log's maximum length.
+        for (int i = 0, length = message.length(); i < length; i++) {
+            int newline = message.indexOf('\n', i);
+            newline = newline != -1 ? newline : length;
+            do {
+                int end = Math.min(newline, i + MAX_LOG_LENGTH);
+                Log.println(logLevel, "OkHttp", message.substring(i, end));
+                i = end;
+            } while (i < newline);
+        }
     }
 
-    @SuppressWarnings({"unchecked", "SuspiciousToArrayCall"}) // Reflection on List<Certificate>.
-    @Override public List<Certificate> clean(List<Certificate> chain, String hostname)
-        throws SSLPeerUnverifiedException {
-      try {
-        X509Certificate[] certificates = chain.toArray(new X509Certificate[chain.size()]);
-        return (List<Certificate>) checkServerTrusted.invoke(
-            x509TrustManagerExtensions, certificates, "RSA", hostname);
-      } catch (InvocationTargetException e) {
-        SSLPeerUnverifiedException exception = new SSLPeerUnverifiedException(e.getMessage());
-        exception.initCause(e);
-        throw exception;
-      } catch (IllegalAccessException e) {
-        throw new AssertionError(e);
-      }
+    @Override
+    public Object getStackTraceForCloseable(String closer) {
+        return closeGuard.createAndOpen(closer);
     }
 
-    @Override public boolean equals(Object other) {
-      return other instanceof AndroidCertificateChainCleaner; // All instances are equivalent.
+    @Override
+    public void logCloseableLeak(String message, Object stackTrace) {
+        boolean reported = closeGuard.warnIfOpen(stackTrace);
+        if (!reported) {
+            // Unable to report via CloseGuard. As a last-ditch effort, send it to the logger.
+            log(WARN, message, null);
+        }
     }
 
-    @Override public int hashCode() {
-      return 0;
+    @Override
+    public boolean isCleartextTrafficPermitted(String hostname) {
+        try {
+            Class<?> networkPolicyClass = Class.forName("android.security.NetworkSecurityPolicy");
+            Method getInstanceMethod = networkPolicyClass.getMethod("getInstance");
+            Object networkSecurityPolicy = getInstanceMethod.invoke(null);
+            return api24IsCleartextTrafficPermitted(hostname, networkPolicyClass, networkSecurityPolicy);
+        } catch (ClassNotFoundException | NoSuchMethodException e) {
+            return super.isCleartextTrafficPermitted(hostname);
+        } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
+            throw new AssertionError("unable to determine cleartext support", e);
+        }
     }
-  }
-
-  /**
-   * Provides access to the internal dalvik.system.CloseGuard class. Android uses this in
-   * combination with android.os.StrictMode to report on leaked java.io.Closeable's. Available since
-   * Android API 11.
-   */
-  static final class CloseGuard {
-    private final Method getMethod;
-    private final Method openMethod;
-    private final Method warnIfOpenMethod;
-
-    CloseGuard(Method getMethod, Method openMethod, Method warnIfOpenMethod) {
-      this.getMethod = getMethod;
-      this.openMethod = openMethod;
-      this.warnIfOpenMethod = warnIfOpenMethod;
+
+    private boolean api24IsCleartextTrafficPermitted(String hostname, Class<?> networkPolicyClass,
+                                                     Object networkSecurityPolicy) throws InvocationTargetException, IllegalAccessException {
+        try {
+            Method isCleartextTrafficPermittedMethod = networkPolicyClass
+                    .getMethod("isCleartextTrafficPermitted", String.class);
+            return (boolean) isCleartextTrafficPermittedMethod.invoke(networkSecurityPolicy, hostname);
+        } catch (NoSuchMethodException e) {
+            return api23IsCleartextTrafficPermitted(hostname, networkPolicyClass, networkSecurityPolicy);
+        }
     }
 
-    Object createAndOpen(String closer) {
-      if (getMethod != null) {
+    private boolean api23IsCleartextTrafficPermitted(String hostname, Class<?> networkPolicyClass,
+                                                     Object networkSecurityPolicy) throws InvocationTargetException, IllegalAccessException {
         try {
-          Object closeGuardInstance = getMethod.invoke(null);
-          openMethod.invoke(closeGuardInstance, closer);
-          return closeGuardInstance;
-        } catch (Exception ignored) {
+            Method isCleartextTrafficPermittedMethod = networkPolicyClass
+                    .getMethod("isCleartextTrafficPermitted");
+            return (boolean) isCleartextTrafficPermittedMethod.invoke(networkSecurityPolicy);
+        } catch (NoSuchMethodException e) {
+            return super.isCleartextTrafficPermitted(hostname);
         }
-      }
-      return null;
     }
 
-    boolean warnIfOpen(Object closeGuardInstance) {
-      boolean reported = false;
-      if (closeGuardInstance != null) {
+    public CertificateChainCleaner buildCertificateChainCleaner(X509TrustManager trustManager) {
         try {
-          warnIfOpenMethod.invoke(closeGuardInstance);
-          reported = true;
-        } catch (Exception ignored) {
+            Class<?> extensionsClass = Class.forName("android.net.http.X509TrustManagerExtensions");
+            Constructor<?> constructor = extensionsClass.getConstructor(X509TrustManager.class);
+            Object extensions = constructor.newInstance(trustManager);
+            Method checkServerTrusted = extensionsClass.getMethod(
+                    "checkServerTrusted", X509Certificate[].class, String.class, String.class);
+            return new AndroidCertificateChainCleaner(extensions, checkServerTrusted);
+        } catch (Exception e) {
+            throw new AssertionError(e);
         }
-      }
-      return reported;
     }
 
-    static CloseGuard get() {
-      Method getMethod;
-      Method openMethod;
-      Method warnIfOpenMethod;
-
-      try {
-        Class<?> closeGuardClass = Class.forName("dalvik.system.CloseGuard");
-        getMethod = closeGuardClass.getMethod("get");
-        openMethod = closeGuardClass.getMethod("open", String.class);
-        warnIfOpenMethod = closeGuardClass.getMethod("warnIfOpen");
-      } catch (Exception ignored) {
-        getMethod = null;
-        openMethod = null;
-        warnIfOpenMethod = null;
-      }
-      return new CloseGuard(getMethod, openMethod, warnIfOpenMethod);
+    public static @Nullable
+    Platform buildIfSupported() {
+        // Attempt to find Android 5+ APIs.
+        try {
+            Class<?> sslParametersClass = Class.forName("com.android.org.conscrypt.SSLParametersImpl");
+            OptionalMethod<Socket> setUseSessionTickets = new OptionalMethod<>(
+                    null, "setUseSessionTickets", boolean.class);
+            OptionalMethod<Socket> setHostname = new OptionalMethod<>(
+                    null, "setHostname", String.class);
+            OptionalMethod<Socket> getAlpnSelectedProtocol = new OptionalMethod<>(
+                    byte[].class, "getAlpnSelectedProtocol");
+            OptionalMethod<Socket> setAlpnProtocols = new OptionalMethod<>(
+                    null, "setAlpnProtocols", byte[].class);
+            return new AndroidPlatform(sslParametersClass, setUseSessionTickets, setHostname,
+                    getAlpnSelectedProtocol, setAlpnProtocols);
+        } catch (ClassNotFoundException ignored) {
+            return null; // Not an Android runtime.
+        }
     }
-  }
-
-  @Override public SSLContext getSSLContext() {
-    boolean tryTls12;
-    try {
-      tryTls12 = (Build.VERSION.SDK_INT >= 16 && Build.VERSION.SDK_INT < 22);
-    } catch (NoClassDefFoundError e) {
-      // Not a real Android runtime; probably RoboVM or MoE
-      // Try to load TLS 1.2 explicitly.
-      tryTls12 = true;
+
+    /**
+     * X509TrustManagerExtensions was added to Android in API 17 (Android 4.2, released in late 2012).
+     * This is the best way to get a clean chain on Android because it uses the same code as the TLS
+     * handshake.
+     */
+    static final class AndroidCertificateChainCleaner extends CertificateChainCleaner {
+        private final Object x509TrustManagerExtensions;
+        private final Method checkServerTrusted;
+
+        AndroidCertificateChainCleaner(Object x509TrustManagerExtensions, Method checkServerTrusted) {
+            this.x509TrustManagerExtensions = x509TrustManagerExtensions;
+            this.checkServerTrusted = checkServerTrusted;
+        }
+
+        @SuppressWarnings({"unchecked", "SuspiciousToArrayCall"}) // Reflection on List<Certificate>.
+        @Override
+        public List<Certificate> clean(List<Certificate> chain, String hostname)
+                throws SSLPeerUnverifiedException {
+            try {
+                X509Certificate[] certificates = chain.toArray(new X509Certificate[chain.size()]);
+                return (List<Certificate>) checkServerTrusted.invoke(
+                        x509TrustManagerExtensions, certificates, "RSA", hostname);
+            } catch (InvocationTargetException e) {
+                SSLPeerUnverifiedException exception = new SSLPeerUnverifiedException(e.getMessage());
+                exception.initCause(e);
+                throw exception;
+            } catch (IllegalAccessException e) {
+                throw new AssertionError(e);
+            }
+        }
+
+        @Override
+        public boolean equals(Object other) {
+            return other instanceof AndroidCertificateChainCleaner; // All instances are equivalent.
+        }
+
+        @Override
+        public int hashCode() {
+            return 0;
+        }
     }
 
-    if (tryTls12) {
-      try {
-        return SSLContext.getInstance("TLSv1.2");
-      } catch (NoSuchAlgorithmException e) {
-        // fallback to TLS
-      }
+    /**
+     * Provides access to the internal dalvik.system.CloseGuard class. Android uses this in
+     * combination with android.os.StrictMode to report on leaked java.io.Closeable's. Available since
+     * Android API 11.
+     */
+    static final class CloseGuard {
+        private final Method getMethod;
+        private final Method openMethod;
+        private final Method warnIfOpenMethod;
+
+        CloseGuard(Method getMethod, Method openMethod, Method warnIfOpenMethod) {
+            this.getMethod = getMethod;
+            this.openMethod = openMethod;
+            this.warnIfOpenMethod = warnIfOpenMethod;
+        }
+
+        Object createAndOpen(String closer) {
+            if (getMethod != null) {
+                try {
+                    Object closeGuardInstance = getMethod.invoke(null);
+                    openMethod.invoke(closeGuardInstance, closer);
+                    return closeGuardInstance;
+                } catch (Exception ignored) {
+                }
+            }
+            return null;
+        }
+
+        boolean warnIfOpen(Object closeGuardInstance) {
+            boolean reported = false;
+            if (closeGuardInstance != null) {
+                try {
+                    warnIfOpenMethod.invoke(closeGuardInstance);
+                    reported = true;
+                } catch (Exception ignored) {
+                }
+            }
+            return reported;
+        }
+
+        static CloseGuard get() {
+            Method getMethod;
+            Method openMethod;
+            Method warnIfOpenMethod;
+
+            try {
+                Class<?> closeGuardClass = Class.forName("dalvik.system.CloseGuard");
+                getMethod = closeGuardClass.getMethod("get");
+                openMethod = closeGuardClass.getMethod("open", String.class);
+                warnIfOpenMethod = closeGuardClass.getMethod("warnIfOpen");
+            } catch (Exception ignored) {
+                getMethod = null;
+                openMethod = null;
+                warnIfOpenMethod = null;
+            }
+            return new CloseGuard(getMethod, openMethod, warnIfOpenMethod);
+        }
     }
 
-    try {
-      return SSLContext.getInstance("TLS");
-    } catch (NoSuchAlgorithmException e) {
-      throw new IllegalStateException("No TLS provider", e);
+    @Override
+    public SSLContext getSSLContext() {
+        boolean tryTls12;
+        try {
+            tryTls12 = (Build.VERSION.SDK_INT >= 16 && Build.VERSION.SDK_INT < 22);
+        } catch (NoClassDefFoundError e) {
+            // Not a real Android runtime; probably RoboVM or MoE
+            // Try to load TLS 1.2 explicitly.
+            tryTls12 = true;
+        }
+
+        if (tryTls12) {
+            try {
+                return SSLContext.getInstance("TLSv1.2");
+            } catch (NoSuchAlgorithmException e) {
+                // fallback to TLS
+            }
+        }
+
+        try {
+            return SSLContext.getInstance("TLS");
+        } catch (NoSuchAlgorithmException e) {
+            throw new IllegalStateException("No TLS provider", e);
+        }
     }
-  }
 }
diff --git a/samples/simple-client/src/main/java/okhttp3/sample/OkHttpContributors.java b/samples/simple-client/src/main/java/okhttp3/sample/OkHttpContributors.java
index 1378cdff9a..077b7e4230 100644
--- a/samples/simple-client/src/main/java/okhttp3/sample/OkHttpContributors.java
+++ b/samples/simple-client/src/main/java/okhttp3/sample/OkHttpContributors.java
@@ -3,49 +3,55 @@
 import com.squareup.moshi.JsonAdapter;
 import com.squareup.moshi.Moshi;
 import com.squareup.moshi.Types;
+
 import java.util.Collections;
 import java.util.List;
+
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
 import okhttp3.Response;
 import okhttp3.ResponseBody;
 
+/**
+ * 参考文章
+ * okhttp源码学习笔记（二）-- 连接与连接管理 https://www.jianshu.com/p/671a123ec163
+ */
 public class OkHttpContributors {
-  private static final String ENDPOINT = "https://api.github.com/repos/square/okhttp/contributors";
-  private static final Moshi MOSHI = new Moshi.Builder().build();
-  private static final JsonAdapter<List<Contributor>> CONTRIBUTORS_JSON_ADAPTER = MOSHI.adapter(
-      Types.newParameterizedType(List.class, Contributor.class));
-
-  static class Contributor {
-    String login;
-    int contributions;
-  }
-
-  public static void main(String... args) throws Exception {
-    OkHttpClient client = new OkHttpClient();
-
-    // Create request for remote resource.
-    Request request = new Request.Builder()
-        .url(ENDPOINT)
-        .build();
-
-    // Execute the request and retrieve the response.
-    try (Response response = client.newCall(request).execute()) { 
-      // Deserialize HTTP response to concrete type.
-      ResponseBody body = response.body();
-      List<Contributor> contributors = CONTRIBUTORS_JSON_ADAPTER.fromJson(body.source());
-
-      // Sort list by the most contributions.
-      Collections.sort(contributors, (c1, c2) -> c2.contributions - c1.contributions);
-
-      // Output list of contributors.
-      for (Contributor contributor : contributors) {
-        System.out.println(contributor.login + ": " + contributor.contributions);
-      }
+    private static final String ENDPOINT = "https://api.github.com/repos/square/okhttp/contributors";
+    private static final Moshi MOSHI = new Moshi.Builder().build();
+    private static final JsonAdapter<List<Contributor>> CONTRIBUTORS_JSON_ADAPTER = MOSHI.adapter(
+            Types.newParameterizedType(List.class, Contributor.class));
+
+    static class Contributor {
+        String login;
+        int contributions;
     }
-  }
 
-  private OkHttpContributors() {
-    // No instances.
-  }
+    public static void main(String... args) throws Exception {
+        OkHttpClient client = new OkHttpClient();
+
+        // Create request for remote resource.
+        Request request = new Request.Builder()
+                .url(ENDPOINT)
+                .build();
+
+        // Execute the request and retrieve the response.
+        try (Response response = client.newCall(request).execute()) {
+            // Deserialize HTTP response to concrete type.
+            ResponseBody body = response.body();
+            List<Contributor> contributors = CONTRIBUTORS_JSON_ADAPTER.fromJson(body.source());
+
+            // Sort list by the most contributions.
+            Collections.sort(contributors, (c1, c2) -> c2.contributions - c1.contributions);
+
+            // Output list of contributors.
+            for (Contributor contributor : contributors) {
+                System.out.println(contributor.login + ": " + contributor.contributions);
+            }
+        }
+    }
+
+    private OkHttpContributors() {
+        // No instances.
+    }
 }
