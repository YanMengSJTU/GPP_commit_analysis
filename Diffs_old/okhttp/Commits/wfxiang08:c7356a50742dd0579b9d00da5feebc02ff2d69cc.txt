diff --git a/okhttp/src/main/java/okhttp3/OkHttpClient.java b/okhttp/src/main/java/okhttp3/OkHttpClient.java
index 31778067ed..a35c525ca5 100644
--- a/okhttp/src/main/java/okhttp3/OkHttpClient.java
+++ b/okhttp/src/main/java/okhttp3/OkHttpClient.java
@@ -436,6 +436,7 @@ public Dispatcher dispatcher() {
   @Override
   public Call newCall(Request request) {
     // 如何创建一个网络请求呢?
+    // 注意：创建的是RealCall
     return new RealCall(this, request, false /* for web socket */);
   }
 
diff --git a/okhttp/src/main/java/okhttp3/RealCall.java b/okhttp/src/main/java/okhttp3/RealCall.java
index a7db1820f0..fdf1ef7154 100644
--- a/okhttp/src/main/java/okhttp3/RealCall.java
+++ b/okhttp/src/main/java/okhttp3/RealCall.java
@@ -74,6 +74,7 @@ public Response execute() throws IOException {
       client.dispatcher().executed(this);
 
       Response result = getResponseWithInterceptorChain();
+
       if (result == null) {
         throw new IOException("Canceled");
       }
@@ -151,12 +152,17 @@ RealCall get() {
     protected void execute() {
       boolean signalledCallback = false;
       try {
+        // 如何处理一个请求呢？
+        // 获取Response
         Response response = getResponseWithInterceptorChain();
+
+        // 处理各种不同的回调
         if (retryAndFollowUpInterceptor.isCanceled()) {
           signalledCallback = true;
           responseCallback.onFailure(RealCall.this, new IOException("Canceled"));
         } else {
           signalledCallback = true;
+          // 在callback中可以逐步处理这个response
           responseCallback.onResponse(RealCall.this, response);
         }
       } catch (IOException e) {
@@ -191,14 +197,22 @@ Response getResponseWithInterceptorChain() throws IOException {
     List<Interceptor> interceptors = new ArrayList<>();
 
     // 这些Interceptors是如何工作的呢?
+    //
     interceptors.addAll(client.interceptors());
+
     interceptors.add(retryAndFollowUpInterceptor);
     interceptors.add(new BridgeInterceptor(client.cookieJar()));
+
+    // 缓存管理
     interceptors.add(new CacheInterceptor(client.internalCache())); // 缓存的管理
+    // 连接管理
     interceptors.add(new ConnectInterceptor(client));
+
     if (!forWebSocket) {
       interceptors.addAll(client.networkInterceptors());
     }
+
+    // 最后一步: 直接访问网路?
     interceptors.add(new CallServerInterceptor(forWebSocket));
 
     // 将全部的Interceptors构成一个Chain
diff --git a/okhttp/src/main/java/okhttp3/Response.java b/okhttp/src/main/java/okhttp3/Response.java
index 810309b013..56fd03ad29 100644
--- a/okhttp/src/main/java/okhttp3/Response.java
+++ b/okhttp/src/main/java/okhttp3/Response.java
@@ -47,9 +47,11 @@
   final Handshake handshake;
   final Headers headers;
   final ResponseBody body;
+
   final Response networkResponse;
   final Response cacheResponse;
   final Response priorResponse;
+
   final long sentRequestAtMillis;
   final long receivedResponseAtMillis;
 
diff --git a/okhttp/src/main/java/okhttp3/internal/Util.java b/okhttp/src/main/java/okhttp3/internal/Util.java
index 28c0b79388..d2306bf111 100644
--- a/okhttp/src/main/java/okhttp3/internal/Util.java
+++ b/okhttp/src/main/java/okhttp3/internal/Util.java
@@ -159,6 +159,8 @@ public static boolean skipAll(Source source, int duration, TimeUnit timeUnit) th
     long originalDuration = source.timeout().hasDeadline()
         ? source.timeout().deadlineNanoTime() - now
         : Long.MAX_VALUE;
+
+    // 限制操作的时间
     source.timeout().deadlineNanoTime(now + Math.min(originalDuration, timeUnit.toNanos(duration)));
     try {
       Buffer skipBuffer = new Buffer();
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java b/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java
index 485c3b8c4a..1dfeff6335 100644
--- a/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java
@@ -17,6 +17,7 @@
 package okhttp3.internal.cache;
 
 import java.io.IOException;
+
 import okhttp3.Headers;
 import okhttp3.Interceptor;
 import okhttp3.Protocol;
@@ -41,7 +42,9 @@
 import static okhttp3.internal.Util.closeQuietly;
 import static okhttp3.internal.Util.discard;
 
-/** Serves requests from the cache and writes responses to the cache. */
+/**
+ * Serves requests from the cache and writes responses to the cache.
+ */
 public final class CacheInterceptor implements Interceptor {
   final InternalCache cache;
 
@@ -54,15 +57,18 @@ public Response intercept(Chain chain) throws IOException {
     // 如何通过Inteceptor实现Cache操作呢?
 
     // 1. cache
-    Response cacheCandidate = cache != null  ? cache.get(chain.request()) : null;
+    Response cacheCandidate = cache != null ? cache.get(chain.request()) : null;
 
     long now = System.currentTimeMillis();
 
     // 2. 通过CacheStrategy来处理cacheResponse
     CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();
+
+    // 根据策略，返回cache, 或者network
     Request networkRequest = strategy.networkRequest;
     Response cacheResponse = strategy.cacheResponse;
 
+    // 对于我们的Media文件，我们期望是直接返回，不在执行: 304请求
     if (cache != null) {
       cache.trackResponse(strategy);
     }
@@ -123,6 +129,8 @@ public Response intercept(Chain chain) throws IOException {
         // Content-Encoding header (as performed by initContentStream()).
         // 更新统计数据
         cache.trackConditionalCacheHit();
+
+        // 1. 更新Cache
         cache.update(cacheResponse, response);
         return response;
       } else {
@@ -152,7 +160,7 @@ private static Response stripBody(Response response) {
   }
 
   private CacheRequest maybeCache(Response userResponse, Request networkRequest,
-      InternalCache responseCache) throws IOException {
+                                  InternalCache responseCache) throws IOException {
     if (responseCache == null) return null;
 
     // Should we cache this response for this request?
@@ -167,7 +175,8 @@ private CacheRequest maybeCache(Response userResponse, Request networkRequest,
       return null;
     }
 
-    // Offer this request to the cache.
+    // 2. 添加 Offer this request to the cache.
+    //    然后一个
     return responseCache.put(userResponse);
   }
 
@@ -178,18 +187,27 @@ private CacheRequest maybeCache(Response userResponse, Request networkRequest,
    */
   private Response cacheWritingResponse(final CacheRequest cacheRequest, Response response)
       throws IOException {
+
     // Some apps return a null body; for compatibility we treat that like a null cache request.
     if (cacheRequest == null) return response;
+
+
+    // 需要将: response中的数据写入 cacheRequest，例如: CacheRequestImpl
     Sink cacheBodyUnbuffered = cacheRequest.body();
     if (cacheBodyUnbuffered == null) return response;
 
+    // 从response.body()中读取网络数据，然后写入source中
     final BufferedSource source = response.body().source();
+
     final BufferedSink cacheBody = Okio.buffer(cacheBodyUnbuffered);
 
+    // 封装了source, 在读取数据时
     Source cacheWritingSource = new Source() {
       boolean cacheRequestClosed;
 
-      @Override public long read(Buffer sink, long byteCount) throws IOException {
+      @Override
+      public long read(Buffer sink, long byteCount) throws IOException {
+        // 1. 读取数据，从source中读取出来，放在sink中
         long bytesRead;
         try {
           bytesRead = source.read(sink, byteCount);
@@ -201,6 +219,7 @@ private Response cacheWritingResponse(final CacheRequest cacheRequest, Response
           throw e;
         }
 
+        // 什么时候Close呢？
         if (bytesRead == -1) {
           if (!cacheRequestClosed) {
             cacheRequestClosed = true;
@@ -209,16 +228,23 @@ private Response cacheWritingResponse(final CacheRequest cacheRequest, Response
           return -1;
         }
 
+        // 从sink中拷贝一定的数据，然后保存到: cacheBody中
+        // 这个地方可能timeout
         sink.copyTo(cacheBody.buffer(), sink.size() - bytesRead, bytesRead);
         cacheBody.emitCompleteSegments();
         return bytesRead;
       }
 
-      @Override public Timeout timeout() {
+      @Override
+      public Timeout timeout() {
         return source.timeout();
       }
 
-      @Override public void close() throws IOException {
+      @Override
+      public void close() throws IOException {
+        // 如果没有关闭，并且使劲读取数据
+        // 如果正常，则会触发cacheBody的正常关闭
+        // 期待在: 100ms内完成数据的读取
         if (!cacheRequestClosed
             && !discard(this, HttpCodec.DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
           cacheRequestClosed = true;
@@ -233,7 +259,9 @@ private Response cacheWritingResponse(final CacheRequest cacheRequest, Response
         .build();
   }
 
-  /** Combines cached headers with a network headers as defined by RFC 2616, 13.5.3. */
+  /**
+   * Combines cached headers with a network headers as defined by RFC 2616, 13.5.3.
+   */
   private static Headers combine(Headers cachedHeaders, Headers networkHeaders) {
     Headers.Builder result = new Headers.Builder();
 
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java b/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java
index 3eb9e8f892..39ab899594 100644
--- a/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java
+++ b/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java
@@ -200,6 +200,7 @@ private CacheStrategy getCandidate() {
       }
 
       CacheControl requestCaching = request.cacheControl();
+      // 不使用Cache, 或者需要处理ETag，ModifySince之类的请求
       if (requestCaching.noCache() || hasConditions(request)) {
         return new CacheStrategy(request, null);
       }
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.java b/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.java
index 19c2321414..7ec0dce860 100644
--- a/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.java
+++ b/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.java
@@ -363,6 +363,8 @@ private void processJournal() throws IOException {
     for (Iterator<Entry> i = lruEntries.values().iterator(); i.hasNext(); ) {
       Entry entry = i.next();
       if (entry.currentEditor == null) {
+
+        // 每个Entry中保存几个文件呢？ valueCount
         for (int t = 0; t < valueCount; t++) {
           size += entry.lengths[t];
         }
@@ -452,16 +454,21 @@ public Editor edit(String key) throws IOException {
     return edit(key, ANY_SEQUENCE_NUMBER);
   }
 
+  // 什么情况下会返回null呢?
   synchronized Editor edit(String key, long expectedSequenceNumber) throws IOException {
     initialize();
 
     checkNotClosed();
     validateKey(key);
     Entry entry = lruEntries.get(key);
-    if (expectedSequenceNumber != ANY_SEQUENCE_NUMBER && (entry == null
-        || entry.sequenceNumber != expectedSequenceNumber)) {
+
+
+    // 1. 新添加的元素:
+    // expectedSequenceNumber == ANY_SEQUENCE_NUMBER， 则不存在这个问题
+    if (expectedSequenceNumber != ANY_SEQUENCE_NUMBER && (entry == null || entry.sequenceNumber != expectedSequenceNumber)) {
       return null; // Snapshot is stale.
     }
+
     if (entry != null && entry.currentEditor != null) {
       return null; // Another edit is in progress.
     }
@@ -479,14 +486,19 @@ synchronized Editor edit(String key, long expectedSequenceNumber) throws IOExcep
     journalWriter.writeUtf8(DIRTY).writeByte(' ').writeUtf8(key).writeByte('\n');
     journalWriter.flush();
 
+    // 错误
     if (hasJournalErrors) {
       return null; // Don't edit; the journal can't be written.
     }
 
+    // 新建Entry
     if (entry == null) {
       entry = new Entry(key);
       lruEntries.put(key, entry);
     }
+
+    // 添加一个Editor
+    // Editor和Entry的相互关系
     Editor editor = new Editor(entry);
     entry.currentEditor = editor;
     return editor;
@@ -524,7 +536,10 @@ public synchronized long size() throws IOException {
     return size;
   }
 
+  // 完成编辑?
+  //
   synchronized void completeEdit(Editor editor, boolean success) throws IOException {
+    // 状态一致
     Entry entry = editor.entry;
     if (entry.currentEditor != editor) {
       throw new IllegalStateException();
@@ -607,7 +622,9 @@ public synchronized boolean remove(String key) throws IOException {
     validateKey(key);
     Entry entry = lruEntries.get(key);
     if (entry == null) return false;
+
     boolean removed = removeEntry(entry);
+
     if (removed && size <= maxSize) mostRecentTrimFailed = false;
     return removed;
   }
@@ -617,6 +634,7 @@ boolean removeEntry(Entry entry) throws IOException {
       entry.currentEditor.detach(); // Prevent the edit from completing normally.
     }
 
+    // 从Entry中删除: valueCount个元素
     for (int i = 0; i < valueCount; i++) {
       fileSystem.delete(entry.cleanFiles[i]);
       size -= entry.lengths[i];
@@ -674,6 +692,7 @@ private synchronized void checkNotClosed() {
 
   void trimToSize() throws IOException {
     while (size > maxSize) {
+      // 按照LRU规则淘汰
       Entry toEvict = lruEntries.values().iterator().next();
       removeEntry(toEvict);
     }
@@ -823,6 +842,8 @@ public void close() {
   /** Edits the values for an entry. */
   public final class Editor {
     final Entry entry;
+
+    // 对于的元素是否被修改了
     final boolean[] written;
     private boolean done;
 
@@ -838,6 +859,7 @@ public void close() {
      * an editor has been detached it is possible for another editor to edit the entry.
      */
     void detach() {
+      // 文件系统和这里的关系?
       if (entry.currentEditor == this) {
         for (int i = 0; i < valueCount; i++) {
           try {
diff --git a/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
index f7c0e5a561..2e5b5ce85e 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
@@ -27,6 +27,9 @@
 import okio.Sink;
 
 /** This is the last interceptor in the chain. It makes a network call to the server. */
+//
+// Chain上的最后一个Interceptor
+//
 public final class CallServerInterceptor implements Interceptor {
   private final boolean forWebSocket;
 
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java b/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java
index d6cd94b4e4..e47a900d3f 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java
@@ -94,6 +94,9 @@ public Response proceed(Request request, StreamAllocation streamAllocation, Http
           + " must call proceed() exactly once");
     }
 
+    // 如何组织的呢？
+    // RealInterceptorChain
+    //    执行当前的intercept, 当前的intercept可以得到带有下一个状态的Chain
     // Call the next interceptor in the chain.
     RealInterceptorChain next = new RealInterceptorChain(
         interceptors, streamAllocation, httpCodec, connection, index + 1, request);
