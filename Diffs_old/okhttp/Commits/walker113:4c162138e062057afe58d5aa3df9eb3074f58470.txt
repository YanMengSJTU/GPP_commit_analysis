diff --git a/okhttp/src/main/java/okhttp3/RealCall.java b/okhttp/src/main/java/okhttp3/RealCall.java
index 9541be5035..8abda17d5d 100644
--- a/okhttp/src/main/java/okhttp3/RealCall.java
+++ b/okhttp/src/main/java/okhttp3/RealCall.java
@@ -185,23 +185,31 @@ String redactedUrl() {
     return originalRequest.url().redact();
   }
 
+  // new了一个ArrayList，然后就是不断的add，后面 new了 RealInterceptorChain对象，最后调用了chain.proceed()方法。
   Response getResponseWithInterceptorChain() throws IOException {
     // Build a full stack of interceptors.
     List<Interceptor> interceptors = new ArrayList<>();
+    // 添加开发者应用层自定义的Interceptor
     interceptors.addAll(client.interceptors());
+    // 这个Interceptor是处理请求失败的重试，重定向
     interceptors.add(retryAndFollowUpInterceptor);
+    // 这个Interceptor工作是添加一些请求的头部或其他信息
+    // 并对返回的Response做一些友好的处理（有一些信息你可能并不需要）
     interceptors.add(new BridgeInterceptor(client.cookieJar()));
+    // 这个Interceptor的职责是判断缓存是否存在，读取缓存，更新缓存等等
     interceptors.add(new CacheInterceptor(client.internalCache()));
+    // 这个Interceptor的职责是建立客户端和服务器的连接
     interceptors.add(new ConnectInterceptor(client));
     if (!forWebSocket) {
+      // 添加开发者自定义的网络层拦截器
       interceptors.addAll(client.networkInterceptors());
     }
     interceptors.add(new CallServerInterceptor(forWebSocket));
-
+    // 一个包裹这request的chain
     Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0,
         originalRequest, this, eventListener, client.connectTimeoutMillis(),
         client.readTimeoutMillis(), client.writeTimeoutMillis());
-
+    // 把chain传递到第一个Interceptor手中
     return chain.proceed(originalRequest);
   }
 }
