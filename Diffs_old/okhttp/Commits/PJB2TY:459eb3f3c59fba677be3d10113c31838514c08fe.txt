diff --git a/.github/CONTRIBUTING.md b/.github/CONTRIBUTING.md
index 0b26b8467b..7543438302 100644
--- a/.github/CONTRIBUTING.md
+++ b/.github/CONTRIBUTING.md
@@ -10,6 +10,14 @@ sure your code compiles by running `mvn clean verify`. Checkstyle failures
 during compilation indicate errors in your style and can be viewed in the
 `checkstyle-result.xml` file.
 
+Some general advice
+
+- Don‚Äôt change public API lightly, avoid if possible, and include your reasoning in the PR if essential.  It causes pain for developers who use OkHttp and sometimes runtime errors.
+- Favour a working external library if appropriate.  There are many examples of OkHttp libraries that can sit on top or hook in via existing APIs.
+- Get working code on a personal branch with tests before you submit a PR.
+- OkHttp is a small and light dependency.  Don't introduce new dependencies or major new functionality.
+- OkHttp targets the intersection of RFC correct *and* widely implemented.  Incorrect implementations that are very widely implemented e.g. a bug in Apache, Nginx, Google, Firefox should also be handled.
+
 Before your code can be accepted into the project you must also sign the
 [Individual Contributor License Agreement (CLA)][1].
 
diff --git a/.github/ISSUE_TEMPLATE.md b/.github/ISSUE_TEMPLATE.md
deleted file mode 100644
index e65d371715..0000000000
--- a/.github/ISSUE_TEMPLATE.md
+++ /dev/null
@@ -1,12 +0,0 @@
-What kind of issue is this?
-
- - [ ] Question. This issue tracker is not the place for questions. If you want to ask how to do
-       something, or to understand why something isn't working the way you expect it to, use Stack
-       Overflow. https://stackoverflow.com/questions/tagged/okhttp
-
- - [ ] Bug report. If you‚Äôve found a bug, spend the time to write a failing test. Bugs with tests
-       get fixed. Here‚Äôs an example: https://gist.github.com/swankjesse/981fcae102f513eb13ed
-
- - [ ] Feature Request. Start by telling us what problem you‚Äôre trying to solve. Often a solution
-       already exists! Don‚Äôt send pull requests to implement new features without first getting our
-       support. Sometimes we leave features out on purpose to keep the project small.
diff --git a/.github/ISSUE_TEMPLATE/bug_report.md b/.github/ISSUE_TEMPLATE/bug_report.md
new file mode 100644
index 0000000000..8b276c7dea
--- /dev/null
+++ b/.github/ISSUE_TEMPLATE/bug_report.md
@@ -0,0 +1,13 @@
+---
+name: Bug report
+about: A reproducible problem
+title: ''
+labels: bug
+assignees: ''
+
+---
+
+Good bug reports include a failing test! Writing a test helps you to isolate and describe the problem, and it helps us to fix it fast. Bug reports without a failing test or reproduction steps are likely to be closed.
+
+Here‚Äôs an example test to get you started.
+https://gist.github.com/swankjesse/981fcae102f513eb13ed
diff --git a/.github/ISSUE_TEMPLATE/feature_request.md b/.github/ISSUE_TEMPLATE/feature_request.md
new file mode 100644
index 0000000000..e320e37f4a
--- /dev/null
+++ b/.github/ISSUE_TEMPLATE/feature_request.md
@@ -0,0 +1,12 @@
+---
+name: Feature request
+about: Suggest an idea
+title: ''
+labels: enhancement
+assignees: ''
+
+---
+
+Start by telling us what problem you‚Äôre trying to solve. Often a solution already exists!
+
+Don‚Äôt send pull requests to implement new features without first getting our support. Sometimes we leave features out on purpose to keep the project small.
diff --git a/.github/ISSUE_TEMPLATE/question.md b/.github/ISSUE_TEMPLATE/question.md
new file mode 100644
index 0000000000..73f2b5c1af
--- /dev/null
+++ b/.github/ISSUE_TEMPLATE/question.md
@@ -0,0 +1,16 @@
+---
+name: Question
+about: Use Stack Overflow instead
+title: "\U0001F649"
+labels: ''
+assignees: ''
+
+---
+
+üõë ùôéùôèùôäùôã
+
+This issue tracker is not the place for questions!
+
+If you want to ask how to do something, or to understand why something isn't working the way you expect it to, use Stack Overflow. https://stackoverflow.com/questions/tagged/okhttp
+
+We close all questions without reading them.
diff --git a/CHANGELOG.md b/CHANGELOG.md
index c10297c598..1a1dc66ae1 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,6 +1,63 @@
 Change Log
 ==========
 
+## Version 3.12.1
+
+_2018-12-23_
+
+ *  Fix: Remove overlapping `package-info.java`. This caused issues with some build tools.
+
+
+## Version 3.12.0
+
+_2018-11-16_
+
+ *  **OkHttp now supports TLS 1.3.** This requires either Conscrypt or Java 11+.
+
+ *  **Proxy authenticators are now asked for preemptive authentication.** OkHttp will now request
+    authentication credentials before creating TLS tunnels through HTTP proxies (HTTP `CONNECT`).
+    Authenticators should identify preemptive authentications by the presence of a challenge whose
+    scheme is "OkHttp-Preemptive".
+
+ *  **OkHttp now offers full-operation timeouts.** This sets a limit on how long the entire call may
+    take and covers resolving DNS, connecting, writing the request body, server processing, and
+    reading the full response body. If a call requires redirects or retries all must complete within
+    one timeout period.
+
+    Use `OkHttpClient.Builder.callTimeout()` to specify the default duration and `Call.timeout()` to
+    specify the timeout of an individual call.
+
+ *  New: Return values and fields are now non-null unless otherwise annotated.
+ *  New: `LoggingEventListener` makes it easy to get basic visibility into a call's performance.
+    This class is in the `logging-interceptor` artifact.
+ *  New: `Headers.Builder.addUnsafeNonAscii()` allows non-ASCII values to be added without an
+    immediate exception.
+ *  New: Headers can be redacted in `HttpLoggingInterceptor`.
+ *  New: `Headers.Builder` now accepts dates.
+ *  New: OkHttp now accepts `java.time.Duration` for timeouts on Java 8+ and Android 26+.
+ *  New: `Challenge` includes all authentication parameters.
+ *  New: Upgrade to BouncyCastle 1.60, Conscrypt 1.4.0, and Okio 1.15.0. We don't yet require
+    Kotlin-friendly Okio 2.x but OkHttp works fine with that series.
+
+    ```kotlin
+    implementation("org.bouncycastle:bcprov-jdk15on:1.60")
+    implementation("org.conscrypt:conscrypt-openjdk-uber:1.4.0")
+    implementation("com.squareup.okio:okio:1.15.0")
+    ```
+
+ *  Fix: Handle dispatcher executor shutdowns gracefully. When there aren't any threads to carry a
+    call its callback now gets a `RejectedExecutionException`.
+ *  Fix: Don't permanently cache responses with `Cache-Control: immutable`. We misunderstood the
+    original `immutable` proposal!
+ *  Fix: Change `Authenticator`'s `Route` parameter to be nullable. This was marked as non-null but
+    could be called with null in some cases.
+ *  Fix: Don't create malformed URLs when `MockWebServer` is reached via an IPv6 address.
+ *  Fix: Don't crash if the system default authenticator is null.
+ *  Fix: Don't crash generating elliptic curve certificates on Android.
+ *  Fix: Don't crash doing platform detection on RoboVM.
+ *  Fix: Don't leak socket connections when web socket upgrades fail.
+
+
 ## Version 3.11.0
 
 _2018-07-12_
diff --git a/README.md b/README.md
index 638bf27c82..4f3a71b4bc 100644
--- a/README.md
+++ b/README.md
@@ -1,22 +1,42 @@
 OkHttp
 ======
 
-An HTTP & HTTP/2 client for Android and Java applications. For more information see [the website][1] and [the wiki][2].
+An HTTP & HTTP/2 client for Android and Java applications. For more information see [the
+website][website] and [the wiki][wiki].
+
+
+Requirements
+------------
+
+OkHttp works on Android 5.0+ (API level 21+) and on Java 8+.
+
+OkHttp has one library dependency on [Okio][okio], a small library for high-performance I/O. It
+works with either Okio 1.x (implemented in Java) or Okio 2.x (upgraded to Kotlin).
+
+We highly recommend you keep OkHttp up-to-date. As with auto-updating web browsers, staying current
+with HTTPS clients is an important defense against potential security problems. [We
+track][tls_history] the dynamic TLS ecosystem and adjust OkHttp to improve connectivity and
+security.
+
+OkHttp uses your platform's built-in TLS implementation. On Java platforms OkHttp also supports
+[Conscrypt][conscrypt], which integrates BoringSSL with Java. OkHttp will use Conscrypt if it is
+the first security provider:
+
+```java
+Security.insertProviderAt(Conscrypt.newProvider(), 1);
+```
+
+The OkHttp 3.12.x branch supports Android 2.3+ (API level 9+) and Java 7+. These platforms lack
+support for TLS 1.2 and should not be used. But because upgrading is difficult we will backport
+critical fixes to the [3.12.x branch][okhttp_312x] through December 31, 2020.
 
 Download
 --------
 
-Download [the latest JAR][3] or grab via Maven:
-```xml
-<dependency>
-  <groupId>com.squareup.okhttp3</groupId>
-  <artifactId>okhttp</artifactId>
-  <version>3.11.0</version>
-</dependency>
-```
-or Gradle:
-```groovy
-implementation 'com.squareup.okhttp3:okhttp:3.11.0'
+Download [the latest JAR][okhttp_latest_jar] or configure this dependency:
+
+```kotlin
+implementation("com.squareup.okhttp3:okhttp:3.12.1")
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
@@ -31,25 +51,15 @@ MockWebServer coupling with OkHttp is essential for proper testing of HTTP/2 so
 
 ### Download
 
-Download [the latest JAR][4] or grab via Maven:
+Download [the latest JAR][mockwebserver_latest_jar] or configure this dependency:
 ```xml
-<dependency>
-  <groupId>com.squareup.okhttp3</groupId>
-  <artifactId>mockwebserver</artifactId>
-  <version>3.11.0</version>
-  <scope>test</scope>
-</dependency>
-```
-or Gradle:
-```groovy
-testImplementation 'com.squareup.okhttp3:mockwebserver:3.11.0'
+testImplementation("com.squareup.okhttp3:mockwebserver:3.12.1")
 ```
 
 R8 / ProGuard
 -------------
 
-If you are using R8 or ProGuard add the options from
-[this file](https://github.com/square/okhttp/blob/master/okhttp/src/main/resources/META-INF/proguard/okhttp3.pro).
+If you are using R8 or ProGuard add the options from [`okhttp3.pro`][okhttp3_pro].
 
 You might also need rules for Okio which is a dependency of this library.
 
@@ -70,8 +80,13 @@ License
     limitations under the License.
 
 
- [1]: https://square.github.io/okhttp
- [2]: https://github.com/square/okhttp/wiki
- [3]: https://search.maven.org/remote_content?g=com.squareup.okhttp3&a=okhttp&v=LATEST
- [4]: https://search.maven.org/remote_content?g=com.squareup.okhttp3&a=mockwebserver&v=LATEST
+ [conscrypt]: https://github.com/google/conscrypt/
+ [mockwebserver_latest_jar]: https://search.maven.org/remote_content?g=com.squareup.okhttp3&a=mockwebserver&v=LATEST
+ [okhttp_312x]: https://github.com/square/okhttp/tree/okhttp_3.12.x
+ [okhttp_latest_jar]: https://search.maven.org/remote_content?g=com.squareup.okhttp3&a=okhttp&v=LATEST
+ [okio]: https://github.com/square/okio/
  [snap]: https://oss.sonatype.org/content/repositories/snapshots/
+ [tls_history]: https://github.com/square/okhttp/wiki/TLS-Configuration-History
+ [website]: https://square.github.io/okhttp
+ [wiki]: https://github.com/square/okhttp/wiki
+ [okhttp3_pro]: https://github.com/square/okhttp/blob/master/okhttp/src/main/resources/META-INF/proguard/okhttp3.pro
diff --git a/benchmarks/README.md b/benchmarks/README.md
deleted file mode 100644
index ee9be3ff47..0000000000
--- a/benchmarks/README.md
+++ /dev/null
@@ -1,8 +0,0 @@
-OkHttp Benchmarks
-=======================================
-
-This module allows you to test the performance of HTTP clients.
-
-### Running
-  1. If you made modifications to `Benchmark` run `mvn compile`.
-  2. Run `mvn exec:exec` to launch a new JVM, which will execute the benchmark.
diff --git a/benchmarks/pom.xml b/benchmarks/pom.xml
deleted file mode 100644
index 1ede888fe5..0000000000
--- a/benchmarks/pom.xml
+++ /dev/null
@@ -1,145 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.okhttp3</groupId>
-    <artifactId>parent</artifactId>
-    <version>3.12.0-SNAPSHOT</version>
-  </parent>
-
-  <artifactId>benchmarks</artifactId>
-  <name>Benchmarks</name>
-
-  <dependencies>
-    <dependency>
-      <groupId>com.google.caliper</groupId>
-      <artifactId>caliper</artifactId>
-      <version>1.0-beta-1</version>
-    </dependency>
-    <!-- caliper needs to be updated to be compatible with guava 16 -->
-    <dependency>
-      <groupId>com.google.guava</groupId>
-      <artifactId>guava</artifactId>
-      <version>14.0.1</version>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp-urlconnection</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp-tls</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>mockwebserver</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>org.apache.httpcomponents</groupId>
-      <artifactId>httpclient</artifactId>
-    </dependency>
-    <dependency>
-      <groupId>io.netty</groupId>
-      <artifactId>netty-transport</artifactId>
-      <version>4.0.15.Final</version>
-    </dependency>
-    <dependency>
-      <groupId>io.netty</groupId>
-      <artifactId>netty-handler</artifactId>
-      <version>4.0.15.Final</version>
-    </dependency>
-    <dependency>
-      <groupId>io.netty</groupId>
-      <artifactId>netty-codec-http</artifactId>
-      <version>4.0.15.Final</version>
-    </dependency>
-    <!-- Netty needs this if gzip is enabled. -->
-    <dependency>
-      <groupId>com.jcraft</groupId>
-      <artifactId>jzlib</artifactId>
-      <version>1.1.2</version>
-    </dependency>
-  </dependencies>
-  <build>
-    <plugins>
-      <plugin>
-        <groupId>org.codehaus.mojo</groupId>
-        <artifactId>exec-maven-plugin</artifactId>
-        <version>1.5.0</version>
-        <executions>
-          <execution>
-            <goals>
-              <goal>java</goal>
-            </goals>
-          </execution>
-        </executions>
-        <configuration>
-          <executable>java</executable>
-          <arguments>
-            <argument>-Xms512m</argument>
-            <argument>-Xmx512m</argument>
-            <commandlineArgs>-Xbootclasspath/p:${bootclasspath}</commandlineArgs>
-            <argument>-classpath</argument>
-            <classpath />
-            <argument>okhttp3.benchmarks.Benchmark</argument>
-          </arguments>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-  <profiles>
-    <profile>
-      <id>alpn-when-jdk7</id>
-      <activation>
-        <jdk>1.7</jdk>
-      </activation>
-      <dependencies>
-        <dependency>
-          <groupId>org.mortbay.jetty.alpn</groupId>
-          <artifactId>alpn-boot</artifactId>
-          <version>${alpn.jdk7.version}</version>
-          <scope>provided</scope>
-        </dependency>
-      </dependencies>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8</id>
-      <activation>
-        <jdk>1.8</jdk>
-      </activation>
-      <dependencies>
-        <dependency>
-          <groupId>org.mortbay.jetty.alpn</groupId>
-          <artifactId>alpn-boot</artifactId>
-          <version>${alpn.jdk8.version}</version>
-          <scope>provided</scope>
-        </dependency>
-      </dependencies>
-      <build>
-        <plugins>
-          <plugin>
-            <!-- Fails on caliper's ASM on OpenJDK 8. -->
-            <groupId>org.codehaus.mojo</groupId>
-            <artifactId>animal-sniffer-maven-plugin</artifactId>
-            <version>1.15</version>
-            <executions>
-              <execution>
-                <phase>none</phase>
-              </execution>
-            </executions>
-          </plugin>
-        </plugins>
-      </build>
-    </profile>
-  </profiles>
-</project>
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/ApacheHttpClient.java b/benchmarks/src/main/java/okhttp3/benchmarks/ApacheHttpClient.java
deleted file mode 100644
index e3dbd3084c..0000000000
--- a/benchmarks/src/main/java/okhttp3/benchmarks/ApacheHttpClient.java
+++ /dev/null
@@ -1,86 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.benchmarks;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.concurrent.TimeUnit;
-import java.util.zip.GZIPInputStream;
-import okhttp3.HttpUrl;
-import okhttp3.tls.HandshakeCertificates;
-import org.apache.http.Header;
-import org.apache.http.HttpResponse;
-import org.apache.http.client.HttpClient;
-import org.apache.http.client.methods.HttpGet;
-import org.apache.http.conn.ClientConnectionManager;
-import org.apache.http.conn.scheme.Scheme;
-import org.apache.http.conn.ssl.SSLSocketFactory;
-import org.apache.http.impl.client.DefaultHttpClient;
-import org.apache.http.impl.conn.PoolingClientConnectionManager;
-
-import static okhttp3.tls.internal.TlsUtil.localhost;
-
-/** Benchmark Apache HTTP client. */
-class ApacheHttpClient extends SynchronousHttpClient {
-  private static final boolean VERBOSE = false;
-
-  private HttpClient client;
-
-  @Override public void prepare(Benchmark benchmark) {
-    super.prepare(benchmark);
-    ClientConnectionManager connectionManager = new PoolingClientConnectionManager();
-    if (benchmark.tls) {
-      HandshakeCertificates handshakeCertificates = localhost();
-      connectionManager.getSchemeRegistry().register(
-          new Scheme("https", 443, new SSLSocketFactory(handshakeCertificates.sslContext())));
-    }
-    client = new DefaultHttpClient(connectionManager);
-  }
-
-  @Override public Runnable request(HttpUrl url) {
-    return new ApacheHttpClientRequest(url);
-  }
-
-  class ApacheHttpClientRequest implements Runnable {
-    private final HttpUrl url;
-
-    ApacheHttpClientRequest(HttpUrl url) {
-      this.url = url;
-    }
-
-    public void run() {
-      long start = System.nanoTime();
-      try {
-        HttpResponse response = client.execute(new HttpGet(url.toString()));
-        InputStream in = response.getEntity().getContent();
-        Header contentEncoding = response.getFirstHeader("Content-Encoding");
-        if (contentEncoding != null && contentEncoding.getValue().equals("gzip")) {
-          in = new GZIPInputStream(in);
-        }
-
-        long total = readAllAndClose(in);
-        long finish = System.nanoTime();
-
-        if (VERBOSE) {
-          System.out.println(String.format("Transferred % 8d bytes in %4d ms",
-              total, TimeUnit.NANOSECONDS.toMillis(finish - start)));
-        }
-      } catch (IOException e) {
-        System.out.println("Failed: " + e);
-      }
-    }
-  }
-}
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/Benchmark.java b/benchmarks/src/main/java/okhttp3/benchmarks/Benchmark.java
deleted file mode 100644
index 081fcfccb9..0000000000
--- a/benchmarks/src/main/java/okhttp3/benchmarks/Benchmark.java
+++ /dev/null
@@ -1,218 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.benchmarks;
-
-import com.google.caliper.Param;
-import com.google.caliper.model.ArbitraryMeasurement;
-import com.google.caliper.runner.CaliperMain;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import java.util.Random;
-import java.util.concurrent.TimeUnit;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-import okhttp3.HttpUrl;
-import okhttp3.Protocol;
-import okhttp3.mockwebserver.Dispatcher;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.mockwebserver.RecordedRequest;
-import okhttp3.tls.HandshakeCertificates;
-import okio.Buffer;
-import okio.GzipSink;
-
-import static okhttp3.tls.internal.TlsUtil.localhost;
-
-/**
- * This benchmark is fake, but may be useful for certain relative comparisons. It uses a local
- * connection to a MockWebServer to measure how many identical requests per second can be carried
- * over a fixed number of threads.
- */
-public class Benchmark extends com.google.caliper.Benchmark {
-  private static final int NUM_REPORTS = 10;
-  private static final boolean VERBOSE = false;
-
-  private final Random random = new Random(0);
-
-  /** Which client to run. */
-  @Param
-  Client client;
-
-  /** How many concurrent requests to execute. */
-  @Param({"1", "10"})
-  int concurrencyLevel;
-
-  /** How many requests to enqueue to await threads to execute them. */
-  @Param({"10"})
-  int targetBacklog;
-
-  /** True to use TLS. */
-  // TODO: compare different ciphers?
-  @Param
-  boolean tls;
-
-  /** True to use gzip content-encoding for the response body. */
-  @Param
-  boolean gzip;
-
-  /** Don't combine chunked with HTTP_2; that's not allowed. */
-  @Param
-  boolean chunked;
-
-  /** The size of the HTTP response body, in uncompressed bytes. */
-  @Param({"128", "1048576"})
-  int bodyByteCount;
-
-  /** How many additional headers were included, beyond the built-in ones. */
-  @Param({"0", "20"})
-  int headerCount;
-
-  /** Which ALPN protocols are in use. Only useful with TLS. */
-  List<Protocol> protocols = Arrays.asList(Protocol.HTTP_1_1);
-
-  public static void main(String[] args) {
-    List<String> allArgs = new ArrayList<>();
-    allArgs.add("--instrument");
-    allArgs.add("arbitrary");
-    allArgs.addAll(Arrays.asList(args));
-
-    CaliperMain.main(Benchmark.class, allArgs.toArray(new String[allArgs.size()]));
-  }
-
-  @ArbitraryMeasurement(description = "requests per second")
-  public double run() throws Exception {
-    if (VERBOSE) System.out.println(toString());
-    HttpClient httpClient = client.create();
-
-    // Prepare the client & server
-    httpClient.prepare(this);
-    MockWebServer server = startServer();
-    HttpUrl url = server.url("/");
-
-    int requestCount = 0;
-    long reportStart = System.nanoTime();
-    long reportPeriod = TimeUnit.SECONDS.toNanos(1);
-    int reports = 0;
-    double best = 0.0;
-
-    // Run until we've printed enough reports.
-    while (reports < NUM_REPORTS) {
-      // Print a report if we haven't recently.
-      long now = System.nanoTime();
-      double reportDuration = now - reportStart;
-      if (reportDuration > reportPeriod) {
-        double requestsPerSecond = requestCount / reportDuration * TimeUnit.SECONDS.toNanos(1);
-        if (VERBOSE) {
-          System.out.println(String.format("Requests per second: %.1f", requestsPerSecond));
-        }
-        best = Math.max(best, requestsPerSecond);
-        requestCount = 0;
-        reportStart = now;
-        reports++;
-      }
-
-      // Fill the job queue with work.
-      while (httpClient.acceptingJobs()) {
-        httpClient.enqueue(url);
-        requestCount++;
-      }
-
-      // The job queue is full. Take a break.
-      sleep(1);
-    }
-
-    return best;
-  }
-
-  @Override public String toString() {
-    List<Object> modifiers = new ArrayList<>();
-    if (tls) modifiers.add("tls");
-    if (gzip) modifiers.add("gzip");
-    if (chunked) modifiers.add("chunked");
-    modifiers.addAll(protocols);
-
-    return String.format("%s %s\nbodyByteCount=%s headerCount=%s concurrencyLevel=%s",
-        client, modifiers, bodyByteCount, headerCount, concurrencyLevel);
-  }
-
-  private void sleep(int millis) {
-    try {
-      Thread.sleep(millis);
-    } catch (InterruptedException ignored) {
-    }
-  }
-
-  private MockWebServer startServer() throws IOException {
-    Logger.getLogger(MockWebServer.class.getName()).setLevel(Level.WARNING);
-    MockWebServer server = new MockWebServer();
-
-    if (tls) {
-      HandshakeCertificates handshakeCertificates = localhost();
-      server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-      server.setProtocols(protocols);
-    }
-
-    final MockResponse response = newResponse();
-    server.setDispatcher(new Dispatcher() {
-      @Override public MockResponse dispatch(RecordedRequest request) {
-        return response;
-      }
-    });
-
-    server.start();
-    return server;
-  }
-
-  private MockResponse newResponse() throws IOException {
-    byte[] bytes = new byte[bodyByteCount];
-    random.nextBytes(bytes);
-    Buffer body = new Buffer().write(bytes);
-
-    MockResponse result = new MockResponse();
-
-    if (gzip) {
-      Buffer gzipBody = new Buffer();
-      GzipSink gzipSink = new GzipSink(gzipBody);
-      gzipSink.write(body, body.size());
-      gzipSink.close();
-      body = gzipBody;
-      result.addHeader("Content-Encoding: gzip");
-    }
-
-    if (chunked) {
-      result.setChunkedBody(body, 1024);
-    } else {
-      result.setBody(body);
-    }
-
-    for (int i = 0; i < headerCount; i++) {
-      result.addHeader(randomString(12), randomString(20));
-    }
-
-    return result;
-  }
-
-  private String randomString(int length) {
-    String alphabet = "-abcdefghijklmnopqrstuvwxyz";
-    char[] result = new char[length];
-    for (int i = 0; i < length; i++) {
-      result[i] = alphabet.charAt(random.nextInt(alphabet.length()));
-    }
-    return new String(result);
-  }
-}
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/Client.java b/benchmarks/src/main/java/okhttp3/benchmarks/Client.java
deleted file mode 100644
index b7c6b3f3b9..0000000000
--- a/benchmarks/src/main/java/okhttp3/benchmarks/Client.java
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.benchmarks;
-
-enum Client {
-  OkHttp {
-    @Override HttpClient create() {
-      return new OkHttp();
-    }
-  },
-
-  OkHttpAsync {
-    @Override HttpClient create() {
-      return new OkHttpAsync();
-    }
-  },
-
-  Apache {
-    @Override HttpClient create() {
-      return new ApacheHttpClient();
-    }
-  },
-
-  UrlConnection {
-    @Override HttpClient create() {
-      return new UrlConnection();
-    }
-  },
-
-  Netty {
-    @Override HttpClient create() {
-      return new NettyHttpClient();
-    }
-  };
-
-  abstract HttpClient create();
-}
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/NettyHttpClient.java b/benchmarks/src/main/java/okhttp3/benchmarks/NettyHttpClient.java
deleted file mode 100644
index 35731fa3b1..0000000000
--- a/benchmarks/src/main/java/okhttp3/benchmarks/NettyHttpClient.java
+++ /dev/null
@@ -1,196 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.benchmarks;
-
-import io.netty.bootstrap.Bootstrap;
-import io.netty.buffer.ByteBuf;
-import io.netty.buffer.PooledByteBufAllocator;
-import io.netty.channel.Channel;
-import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInitializer;
-import io.netty.channel.ChannelOption;
-import io.netty.channel.ChannelPipeline;
-import io.netty.channel.SimpleChannelInboundHandler;
-import io.netty.channel.nio.NioEventLoopGroup;
-import io.netty.channel.socket.SocketChannel;
-import io.netty.channel.socket.nio.NioSocketChannel;
-import io.netty.handler.codec.http.DefaultFullHttpRequest;
-import io.netty.handler.codec.http.HttpClientCodec;
-import io.netty.handler.codec.http.HttpContent;
-import io.netty.handler.codec.http.HttpContentDecompressor;
-import io.netty.handler.codec.http.HttpHeaders;
-import io.netty.handler.codec.http.HttpMethod;
-import io.netty.handler.codec.http.HttpObject;
-import io.netty.handler.codec.http.HttpRequest;
-import io.netty.handler.codec.http.HttpResponse;
-import io.netty.handler.codec.http.HttpVersion;
-import io.netty.handler.codec.http.LastHttpContent;
-import io.netty.handler.ssl.SslHandler;
-import java.util.ArrayDeque;
-import java.util.Deque;
-import java.util.concurrent.TimeUnit;
-import javax.net.ssl.SSLEngine;
-import okhttp3.HttpUrl;
-import okhttp3.tls.HandshakeCertificates;
-
-import static okhttp3.tls.internal.TlsUtil.localhost;
-
-/** Netty isn't an HTTP client, but it's almost one. */
-class NettyHttpClient implements HttpClient {
-  private static final boolean VERBOSE = false;
-
-  // Guarded by this. Real apps need more capable connection management.
-  private final Deque<HttpChannel> freeChannels = new ArrayDeque<>();
-  private final Deque<HttpUrl> backlog = new ArrayDeque<>();
-
-  private int totalChannels = 0;
-  private int concurrencyLevel;
-  private int targetBacklog;
-  private Bootstrap bootstrap;
-
-  @Override public void prepare(final Benchmark benchmark) {
-    this.concurrencyLevel = benchmark.concurrencyLevel;
-    this.targetBacklog = benchmark.targetBacklog;
-
-    ChannelInitializer<SocketChannel> channelInitializer = new ChannelInitializer<SocketChannel>() {
-      @Override public void initChannel(SocketChannel channel) {
-        ChannelPipeline pipeline = channel.pipeline();
-
-        if (benchmark.tls) {
-          HandshakeCertificates handshakeCertificates = localhost();
-          SSLEngine engine = handshakeCertificates.sslContext().createSSLEngine();
-          engine.setUseClientMode(true);
-          pipeline.addLast("ssl", new SslHandler(engine));
-        }
-
-        pipeline.addLast("codec", new HttpClientCodec());
-        pipeline.addLast("inflater", new HttpContentDecompressor());
-        pipeline.addLast("handler", new HttpChannel(channel));
-      }
-    };
-
-    bootstrap = new Bootstrap();
-    bootstrap.group(new NioEventLoopGroup(concurrencyLevel))
-        .option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)
-        .channel(NioSocketChannel.class)
-        .handler(channelInitializer);
-  }
-
-  @Override public void enqueue(HttpUrl url) throws Exception {
-    HttpChannel httpChannel = null;
-    synchronized (this) {
-      if (!freeChannels.isEmpty()) {
-        httpChannel = freeChannels.pop();
-      } else if (totalChannels < concurrencyLevel) {
-        totalChannels++; // Create a new channel. (outside of the synchronized block).
-      } else {
-        backlog.add(url); // Enqueue this for later, to be picked up when another request completes.
-        return;
-      }
-    }
-    if (httpChannel == null) {
-      Channel channel = bootstrap.connect(url.host(), url.port())
-          .sync().channel();
-      httpChannel = (HttpChannel) channel.pipeline().last();
-    }
-    httpChannel.sendRequest(url);
-  }
-
-  @Override public synchronized boolean acceptingJobs() {
-    return backlog.size() < targetBacklog || hasFreeChannels();
-  }
-
-  private boolean hasFreeChannels() {
-    int activeChannels = totalChannels - freeChannels.size();
-    return activeChannels < concurrencyLevel;
-  }
-
-  private void release(HttpChannel httpChannel) {
-    HttpUrl url;
-    synchronized (this) {
-      url = backlog.pop();
-      if (url == null) {
-        // There were no URLs in the backlog. Pool this channel for later.
-        freeChannels.push(httpChannel);
-        return;
-      }
-    }
-
-    // We removed a URL from the backlog. Schedule it right away.
-    httpChannel.sendRequest(url);
-  }
-
-  class HttpChannel extends SimpleChannelInboundHandler<HttpObject> {
-    private final SocketChannel channel;
-    byte[] buffer = new byte[1024];
-    int total;
-    long start;
-
-    HttpChannel(SocketChannel channel) {
-      this.channel = channel;
-    }
-
-    private void sendRequest(HttpUrl url) {
-      start = System.nanoTime();
-      total = 0;
-      HttpRequest request = new DefaultFullHttpRequest(
-          HttpVersion.HTTP_1_1, HttpMethod.GET, url.encodedPath());
-      request.headers().set(HttpHeaders.Names.HOST, url.host());
-      request.headers().set(HttpHeaders.Names.ACCEPT_ENCODING, HttpHeaders.Values.GZIP);
-      channel.writeAndFlush(request);
-    }
-
-    @Override protected void channelRead0(
-        ChannelHandlerContext context, HttpObject message) {
-      if (message instanceof HttpResponse) {
-        receive((HttpResponse) message);
-      }
-      if (message instanceof HttpContent) {
-        receive((HttpContent) message);
-        if (message instanceof LastHttpContent) {
-          release(this);
-        }
-      }
-    }
-
-    @Override public void channelInactive(ChannelHandlerContext ctx) throws Exception {
-      super.channelInactive(ctx);
-    }
-
-    void receive(HttpResponse response) {
-      // Don't do anything with headers.
-    }
-
-    void receive(HttpContent content) {
-      // Consume the response body.
-      ByteBuf byteBuf = content.content();
-      for (int toRead; (toRead = byteBuf.readableBytes()) > 0; ) {
-        byteBuf.readBytes(buffer, 0, Math.min(buffer.length, toRead));
-        total += toRead;
-      }
-
-      if (VERBOSE && content instanceof LastHttpContent) {
-        long finish = System.nanoTime();
-        System.out.println(String.format("Transferred % 8d bytes in %4d ms",
-            total, TimeUnit.NANOSECONDS.toMillis(finish - start)));
-      }
-    }
-
-    @Override public void exceptionCaught(ChannelHandlerContext context, Throwable cause) {
-      System.out.println("Failed: " + cause);
-    }
-  }
-}
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/OkHttp.java b/benchmarks/src/main/java/okhttp3/benchmarks/OkHttp.java
deleted file mode 100644
index 86b44523a2..0000000000
--- a/benchmarks/src/main/java/okhttp3/benchmarks/OkHttp.java
+++ /dev/null
@@ -1,86 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.benchmarks;
-
-import java.io.IOException;
-import java.util.concurrent.TimeUnit;
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.SSLSession;
-import javax.net.ssl.SSLSocketFactory;
-import okhttp3.Call;
-import okhttp3.HttpUrl;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.ResponseBody;
-import okhttp3.tls.HandshakeCertificates;
-
-import static okhttp3.tls.internal.TlsUtil.localhost;
-
-class OkHttp extends SynchronousHttpClient {
-  private static final boolean VERBOSE = false;
-
-  private OkHttpClient client;
-
-  @Override public void prepare(Benchmark benchmark) {
-    super.prepare(benchmark);
-    client = new OkHttpClient.Builder()
-        .protocols(benchmark.protocols)
-        .build();
-
-    if (benchmark.tls) {
-      HandshakeCertificates handshakeCertificates = localhost();
-      SSLSocketFactory socketFactory = handshakeCertificates.sslSocketFactory();
-      HostnameVerifier hostnameVerifier = new HostnameVerifier() {
-        @Override public boolean verify(String s, SSLSession session) {
-          return true;
-        }
-      };
-      client = new OkHttpClient.Builder()
-          .sslSocketFactory(socketFactory, handshakeCertificates.trustManager())
-          .hostnameVerifier(hostnameVerifier)
-          .build();
-    }
-  }
-
-  @Override public Runnable request(HttpUrl url) {
-    Call call = client.newCall(new Request.Builder().url(url).build());
-    return new OkHttpRequest(call);
-  }
-
-  class OkHttpRequest implements Runnable {
-    private final Call call;
-
-    OkHttpRequest(Call call) {
-      this.call = call;
-    }
-
-    public void run() {
-      long start = System.nanoTime();
-      try {
-        ResponseBody body = call.execute().body();
-        long total = readAllAndClose(body.byteStream());
-        long finish = System.nanoTime();
-
-        if (VERBOSE) {
-          System.out.println(String.format("Transferred % 8d bytes in %4d ms",
-              total, TimeUnit.NANOSECONDS.toMillis(finish - start)));
-        }
-      } catch (IOException e) {
-        System.out.println("Failed: " + e);
-      }
-    }
-  }
-}
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/OkHttpAsync.java b/benchmarks/src/main/java/okhttp3/benchmarks/OkHttpAsync.java
deleted file mode 100644
index d6d0bc5cb4..0000000000
--- a/benchmarks/src/main/java/okhttp3/benchmarks/OkHttpAsync.java
+++ /dev/null
@@ -1,99 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.benchmarks;
-
-import java.io.IOException;
-import java.util.concurrent.LinkedBlockingQueue;
-import java.util.concurrent.ThreadPoolExecutor;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicInteger;
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.SSLSession;
-import javax.net.ssl.SSLSocketFactory;
-import okhttp3.Call;
-import okhttp3.Callback;
-import okhttp3.Dispatcher;
-import okhttp3.HttpUrl;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.ResponseBody;
-import okhttp3.tls.HandshakeCertificates;
-
-import static okhttp3.tls.internal.TlsUtil.localhost;
-
-class OkHttpAsync implements HttpClient {
-  private static final boolean VERBOSE = false;
-
-  private final AtomicInteger requestsInFlight = new AtomicInteger();
-
-  private OkHttpClient client;
-  private Callback callback;
-  private int concurrencyLevel;
-  private int targetBacklog;
-
-  @Override public void prepare(final Benchmark benchmark) {
-    concurrencyLevel = benchmark.concurrencyLevel;
-    targetBacklog = benchmark.targetBacklog;
-
-    client = new OkHttpClient.Builder()
-        .protocols(benchmark.protocols)
-        .dispatcher(new Dispatcher(new ThreadPoolExecutor(benchmark.concurrencyLevel,
-            benchmark.concurrencyLevel, 60, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>())))
-        .build();
-
-    if (benchmark.tls) {
-      HandshakeCertificates handshakeCertificates = localhost();
-      SSLSocketFactory socketFactory = handshakeCertificates.sslSocketFactory();
-      HostnameVerifier hostnameVerifier = new HostnameVerifier() {
-        @Override public boolean verify(String s, SSLSession session) {
-          return true;
-        }
-      };
-      client = client.newBuilder()
-          .sslSocketFactory(socketFactory, handshakeCertificates.trustManager())
-          .hostnameVerifier(hostnameVerifier)
-          .build();
-    }
-
-    callback = new Callback() {
-      @Override public void onFailure(Call call, IOException e) {
-        System.out.println("Failed: " + e);
-      }
-
-      @Override public void onResponse(Call call, Response response) throws IOException {
-        ResponseBody body = response.body();
-        long total = SynchronousHttpClient.readAllAndClose(body.byteStream());
-        long finish = System.nanoTime();
-        if (VERBOSE) {
-          long start = (Long) response.request().tag();
-          System.out.printf("Transferred % 8d bytes in %4d ms%n",
-              total, TimeUnit.NANOSECONDS.toMillis(finish - start));
-        }
-        requestsInFlight.decrementAndGet();
-      }
-    };
-  }
-
-  @Override public void enqueue(HttpUrl url) throws Exception {
-    requestsInFlight.incrementAndGet();
-    client.newCall(new Request.Builder().tag(System.nanoTime()).url(url).build()).enqueue(callback);
-  }
-
-  @Override public synchronized boolean acceptingJobs() {
-    return requestsInFlight.get() < (concurrencyLevel + targetBacklog);
-  }
-}
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/SynchronousHttpClient.java b/benchmarks/src/main/java/okhttp3/benchmarks/SynchronousHttpClient.java
deleted file mode 100644
index 4a17b8693d..0000000000
--- a/benchmarks/src/main/java/okhttp3/benchmarks/SynchronousHttpClient.java
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.benchmarks;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.concurrent.LinkedBlockingQueue;
-import java.util.concurrent.ThreadPoolExecutor;
-import java.util.concurrent.TimeUnit;
-import okhttp3.HttpUrl;
-
-/** Any HTTP client with a blocking API. */
-abstract class SynchronousHttpClient implements HttpClient {
-  ThreadPoolExecutor executor;
-  int targetBacklog;
-
-  @Override public void prepare(Benchmark benchmark) {
-    this.targetBacklog = benchmark.targetBacklog;
-    executor = new ThreadPoolExecutor(benchmark.concurrencyLevel, benchmark.concurrencyLevel,
-        1, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>());
-  }
-
-  @Override public void enqueue(HttpUrl url) {
-    executor.execute(request(url));
-  }
-
-  @Override public boolean acceptingJobs() {
-    return executor.getQueue().size() < targetBacklog;
-  }
-
-  static long readAllAndClose(InputStream in) throws IOException {
-    byte[] buffer = new byte[1024];
-    long total = 0;
-    for (int count; (count = in.read(buffer)) != -1; ) {
-      total += count;
-    }
-    in.close();
-    return total;
-  }
-
-  abstract Runnable request(HttpUrl url);
-}
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/UrlConnection.java b/benchmarks/src/main/java/okhttp3/benchmarks/UrlConnection.java
deleted file mode 100644
index 96eb7422cd..0000000000
--- a/benchmarks/src/main/java/okhttp3/benchmarks/UrlConnection.java
+++ /dev/null
@@ -1,82 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.benchmarks;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.HttpURLConnection;
-import java.util.concurrent.TimeUnit;
-import java.util.zip.GZIPInputStream;
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.HttpsURLConnection;
-import javax.net.ssl.SSLSession;
-import javax.net.ssl.SSLSocketFactory;
-import okhttp3.HttpUrl;
-import okhttp3.tls.HandshakeCertificates;
-
-import static okhttp3.tls.internal.TlsUtil.localhost;
-
-class UrlConnection extends SynchronousHttpClient {
-  private static final boolean VERBOSE = false;
-
-  @Override public void prepare(Benchmark benchmark) {
-    super.prepare(benchmark);
-    if (benchmark.tls) {
-      HandshakeCertificates handshakeCertificates = localhost();
-      SSLSocketFactory socketFactory = handshakeCertificates.sslSocketFactory();
-      HostnameVerifier hostnameVerifier = new HostnameVerifier() {
-        @Override public boolean verify(String s, SSLSession session) {
-          return true;
-        }
-      };
-      HttpsURLConnection.setDefaultHostnameVerifier(hostnameVerifier);
-      HttpsURLConnection.setDefaultSSLSocketFactory(socketFactory);
-    }
-  }
-
-  @Override public Runnable request(HttpUrl url) {
-    return new UrlConnectionRequest(url);
-  }
-
-  static class UrlConnectionRequest implements Runnable {
-    private final HttpUrl url;
-
-    UrlConnectionRequest(HttpUrl url) {
-      this.url = url;
-    }
-
-    public void run() {
-      long start = System.nanoTime();
-      try {
-        HttpURLConnection urlConnection = (HttpURLConnection) url.url().openConnection();
-        InputStream in = urlConnection.getInputStream();
-        if ("gzip".equals(urlConnection.getHeaderField("Content-Encoding"))) {
-          in = new GZIPInputStream(in);
-        }
-
-        long total = readAllAndClose(in);
-        long finish = System.nanoTime();
-
-        if (VERBOSE) {
-          System.out.println(String.format("Transferred % 8d bytes in %4d ms",
-              total, TimeUnit.NANOSECONDS.toMillis(finish - start)));
-        }
-      } catch (IOException e) {
-        System.out.println("Failed: " + e);
-      }
-    }
-  }
-}
diff --git a/bom/pom.xml b/bom/pom.xml
new file mode 100644
index 0000000000..635932b866
--- /dev/null
+++ b/bom/pom.xml
@@ -0,0 +1,77 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <groupId>com.squareup.okhttp3</groupId>
+  <artifactId>okhttp-bom</artifactId>
+  <version>3.13.0-SNAPSHOT</version>
+  <packaging>pom</packaging>
+  <name>OkHttp (Bill of Materials)</name>
+
+  <dependencyManagement>
+    <dependencies>
+      <dependency>
+        <groupId>${project.groupId}</groupId>
+        <artifactId>okhttp</artifactId>
+        <version>${project.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>${project.groupId}</groupId>
+        <artifactId>okhttp-tests</artifactId>
+        <version>${project.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>${project.groupId}</groupId>
+        <artifactId>okhttp-android-support</artifactId>
+        <version>${project.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>${project.groupId}</groupId>
+        <artifactId>okhttp-apache</artifactId>
+        <version>${project.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>${project.groupId}</groupId>
+        <artifactId>okhttp-sse</artifactId>
+        <version>${project.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>${project.groupId}</groupId>
+        <artifactId>okhttp-testing-support</artifactId>
+        <version>${project.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>${project.groupId}</groupId>
+        <artifactId>okhttp-tls</artifactId>
+        <version>${project.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>${project.groupId}</groupId>
+        <artifactId>okhttp-urlconnection</artifactId>
+        <version>${project.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>${project.groupId}</groupId>
+        <artifactId>logging-interceptor</artifactId>
+        <version>${project.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>${project.groupId}</groupId>
+        <artifactId>okhttp-dnsoverhttps</artifactId>
+        <version>${project.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>${project.groupId}</groupId>
+        <artifactId>okcurl</artifactId>
+        <version>${project.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>${project.groupId}</groupId>
+        <artifactId>mockwebserver</artifactId>
+        <version>${project.version}</version>
+      </dependency>
+    </dependencies>
+  </dependencyManagement>
+
+</project>
diff --git a/mockwebserver/pom.xml b/mockwebserver/pom.xml
index eb19007574..fe7a1c40d3 100644
--- a/mockwebserver/pom.xml
+++ b/mockwebserver/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.12.0-SNAPSHOT</version>
+    <version>3.13.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>mockwebserver</artifactId>
@@ -41,7 +41,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-javadoc-plugin</artifactId>
-        <version>2.10.4</version>
+        <version>3.0.1</version>
         <configuration>
           <links>
             <link>http://square.github.io/okhttp/javadoc/</link>
@@ -52,7 +52,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-assembly-plugin</artifactId>
-        <version>3.0.0</version>
+        <version>3.1.0</version>
         <configuration>
           <descriptorRefs>
             <descriptorRef>jar-with-dependencies</descriptorRef>
@@ -70,7 +70,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-jar-plugin</artifactId>
-        <version>3.0.2</version>
+        <version>3.1.1</version>
         <configuration>
           <archive>
             <manifestEntries>
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/HttpClient.java b/mockwebserver/src/main/java/okhttp3/internal/duplex/MwsDuplexAccess.java
similarity index 54%
rename from benchmarks/src/main/java/okhttp3/benchmarks/HttpClient.java
rename to mockwebserver/src/main/java/okhttp3/internal/duplex/MwsDuplexAccess.java
index 0c0986ffeb..d1eea00397 100644
--- a/benchmarks/src/main/java/okhttp3/benchmarks/HttpClient.java
+++ b/mockwebserver/src/main/java/okhttp3/internal/duplex/MwsDuplexAccess.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Square, Inc.
+ * Copyright (C) 2018 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,15 +13,17 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.benchmarks;
+package okhttp3.internal.duplex;
 
-import okhttp3.HttpUrl;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.internal.duplex.DuplexResponseBody;
 
-/** An HTTP client to benchmark. */
-interface HttpClient {
-  void prepare(Benchmark benchmark);
-
-  void enqueue(HttpUrl url) throws Exception;
+/**
+ * Internal access to MockWebServer APIs. Don't use this, don't use internal, these APIs are not
+ * stable.
+ */
+public abstract class MwsDuplexAccess {
+  public static MwsDuplexAccess instance;
 
-  boolean acceptingJobs();
+  public abstract void setBody(MockResponse mockResponse, DuplexResponseBody duplexResponseBody);
 }
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.java
index 36457229ed..2c9ad33b49 100644
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.java
@@ -22,6 +22,7 @@
 import okhttp3.WebSocketListener;
 import okhttp3.internal.Internal;
 import okhttp3.internal.http2.Settings;
+import okhttp3.mockwebserver.internal.duplex.DuplexResponseBody;
 import okio.Buffer;
 
 /** A scripted response to be replayed by the mock web server. */
@@ -30,6 +31,7 @@
 
   private String status;
   private Headers.Builder headers = new Headers.Builder();
+  private Headers.Builder trailers = new Headers.Builder();
 
   private Buffer body;
 
@@ -49,6 +51,7 @@
   private List<PushPromise> promises = new ArrayList<>();
   private Settings settings;
   private WebSocketListener webSocketListener;
+  private DuplexResponseBody duplexResponseBody;
 
   /** Creates a new mock response with an empty body. */
   public MockResponse() {
@@ -98,6 +101,10 @@ public Headers getHeaders() {
     return headers.build();
   }
 
+  public Headers getTrailers() {
+    return trailers.build();
+  }
+
   /**
    * Removes all HTTP headers including any "Content-Length" and "Transfer-encoding" headers that
    * were added by default.
@@ -143,18 +150,32 @@ public MockResponse setHeader(String name, Object value) {
     return addHeader(name, value);
   }
 
-  /** Replaces all headers with those specified in {@code headers}. */
+  /** Replaces all headers with those specified. */
   public MockResponse setHeaders(Headers headers) {
     this.headers = headers.newBuilder();
     return this;
   }
 
+  /** Replaces all trailers with those specified. */
+  public MockResponse setTrailers(Headers trailers) {
+    this.trailers = trailers.newBuilder();
+    return this;
+  }
+
   /** Removes all headers named {@code name}. */
   public MockResponse removeHeader(String name) {
     headers.removeAll(name);
     return this;
   }
 
+  boolean isDuplex() {
+    return duplexResponseBody != null;
+  }
+
+  DuplexResponseBody getDuplexResponseBody() {
+    return duplexResponseBody;
+  }
+
   /** Returns a copy of the raw HTTP payload. */
   public Buffer getBody() {
     return body != null ? body.clone() : null;
@@ -171,6 +192,11 @@ public MockResponse setBody(String body) {
     return setBody(new Buffer().writeUtf8(body));
   }
 
+  MockResponse setBody(DuplexResponseBody duplexResponseBody) {
+    this.duplexResponseBody = duplexResponseBody;
+    return this;
+  }
+
   /**
    * Sets the response body to {@code body}, chunked every {@code maxChunkSize} bytes.
    */
@@ -186,7 +212,7 @@ public MockResponse setChunkedBody(Buffer body, int maxChunkSize) {
       bytesOut.write(body, chunkSize);
       bytesOut.writeUtf8("\r\n");
     }
-    bytesOut.writeUtf8("0\r\n\r\n"); // Last chunk + empty trailer + CRLF.
+    bytesOut.writeUtf8("0\r\n"); // Last chunk. Trailers follow!
 
     this.body = bytesOut;
     return this;
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
index f85cd96ca5..4b6983d00e 100644
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
@@ -59,6 +59,7 @@
 import okhttp3.internal.Internal;
 import okhttp3.internal.NamedRunnable;
 import okhttp3.internal.Util;
+import okhttp3.internal.duplex.MwsDuplexAccess;
 import okhttp3.internal.http.HttpMethod;
 import okhttp3.internal.http2.ErrorCode;
 import okhttp3.internal.http2.Header;
@@ -68,6 +69,7 @@
 import okhttp3.internal.platform.Platform;
 import okhttp3.internal.ws.RealWebSocket;
 import okhttp3.internal.ws.WebSocketProtocol;
+import okhttp3.mockwebserver.internal.duplex.DuplexResponseBody;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -90,6 +92,7 @@
 import static okhttp3.mockwebserver.SocketPolicy.RESET_STREAM_AT_START;
 import static okhttp3.mockwebserver.SocketPolicy.SHUTDOWN_INPUT_AT_END;
 import static okhttp3.mockwebserver.SocketPolicy.SHUTDOWN_OUTPUT_AT_END;
+import static okhttp3.mockwebserver.SocketPolicy.SHUTDOWN_SERVER_AFTER_RESPONSE;
 import static okhttp3.mockwebserver.SocketPolicy.STALL_SOCKET_AT_START;
 import static okhttp3.mockwebserver.SocketPolicy.UPGRADE_TO_SSL_AT_END;
 
@@ -100,6 +103,12 @@
 public final class MockWebServer extends ExternalResource implements Closeable {
   static {
     Internal.initializeInstanceForTests();
+    MwsDuplexAccess.instance = new MwsDuplexAccess() {
+      @Override public void setBody(
+          MockResponse mockResponse, DuplexResponseBody duplexResponseBody) {
+        mockResponse.setBody(duplexResponseBody);
+      }
+    };
   }
 
   private static final int CLIENT_AUTH_NONE = 0;
@@ -126,9 +135,9 @@
   private final BlockingQueue<RecordedRequest> requestQueue = new LinkedBlockingQueue<>();
 
   private final Set<Socket> openClientSockets =
-      Collections.newSetFromMap(new ConcurrentHashMap<Socket, Boolean>());
+      Collections.newSetFromMap(new ConcurrentHashMap<>());
   private final Set<Http2Connection> openConnections =
-      Collections.newSetFromMap(new ConcurrentHashMap<Http2Connection, Boolean>());
+      Collections.newSetFromMap(new ConcurrentHashMap<>());
   private final AtomicInteger requestCount = new AtomicInteger();
   private long bodyLimit = Long.MAX_VALUE;
   private ServerSocketFactory serverSocketFactory = ServerSocketFactory.getDefault();
@@ -589,6 +598,8 @@ private boolean processOneRequest(Socket socket, BufferedSource source, Buffered
           socket.shutdownInput();
         } else if (response.getSocketPolicy() == SHUTDOWN_OUTPUT_AT_END) {
           socket.shutdownOutput();
+        } else if (response.getSocketPolicy() == SHUTDOWN_SERVER_AFTER_RESPONSE) {
+          shutdown();
         }
 
         sequenceNumber++;
@@ -748,7 +759,19 @@ private void writeHttpResponse(Socket socket, BufferedSink sink, MockResponse re
     sink.writeUtf8(response.getStatus());
     sink.writeUtf8("\r\n");
 
-    Headers headers = response.getHeaders();
+    writeHeaders(sink, response.getHeaders());
+
+    Buffer body = response.getBody();
+    if (body == null) return;
+    sleepIfDelayed(response.getBodyDelay(TimeUnit.MILLISECONDS));
+    throttledTransfer(response, socket, body, sink, body.size(), false);
+
+    if ("chunked".equalsIgnoreCase(response.getHeaders().get("Transfer-Encoding"))) {
+      writeHeaders(sink, response.getTrailers());
+    }
+  }
+
+  private void writeHeaders(BufferedSink sink, Headers headers) throws IOException {
     for (int i = 0, size = headers.size(); i < size; i++) {
       sink.writeUtf8(headers.name(i));
       sink.writeUtf8(": ");
@@ -757,11 +780,6 @@ private void writeHttpResponse(Socket socket, BufferedSink sink, MockResponse re
     }
     sink.writeUtf8("\r\n");
     sink.flush();
-
-    Buffer body = response.getBody();
-    if (body == null) return;
-    sleepIfDelayed(response.getBodyDelay(TimeUnit.MILLISECONDS));
-    throttledTransfer(response, socket, body, sink, body.size(), false);
   }
 
   private void sleepIfDelayed(long delayMs) {
@@ -832,6 +850,14 @@ private void readEmptyLine(BufferedSource source) throws IOException {
     if (line.length() != 0) throw new IllegalStateException("Expected empty but was: " + line);
   }
 
+  /**
+   * Returns the dispatcher used to respond to HTTP requests. The default dispatcher is a {@link
+   * QueueDispatcher} but other dispatchers can be configured.
+   */
+  public Dispatcher getDispatcher() {
+    return dispatcher;
+  }
+
   /**
    * Sets the dispatcher used to match incoming requests to mock responses. The default dispatcher
    * simply serves a fixed sequence of responses from a {@link #enqueue(MockResponse) queue}; custom
@@ -921,7 +947,7 @@ private Http2SocketHandler(Socket socket, Protocol protocol) {
         socket.close();
         return;
       }
-      writeResponse(stream, response);
+      writeResponse(stream, request, response);
       if (logger.isLoggable(Level.INFO)) {
         logger.info(MockWebServer.this + " received request: " + request
             + " and responded: " + response + " protocol is " + protocol.toString());
@@ -934,24 +960,24 @@ private Http2SocketHandler(Socket socket, Protocol protocol) {
     }
 
     private RecordedRequest readRequest(Http2Stream stream) throws IOException {
-      List<Header> streamHeaders = stream.getRequestHeaders();
+      Headers streamHeaders = stream.takeHeaders();
       Headers.Builder httpHeaders = new Headers.Builder();
       String method = "<:method omitted>";
       String path = "<:path omitted>";
       boolean readBody = true;
       for (int i = 0, size = streamHeaders.size(); i < size; i++) {
-        ByteString name = streamHeaders.get(i).name;
-        String value = streamHeaders.get(i).value.utf8();
-        if (name.equals(Header.TARGET_METHOD)) {
+        String name = streamHeaders.name(i);
+        String value = streamHeaders.value(i);
+        if (name.equals(Header.TARGET_METHOD_UTF8)) {
           method = value;
-        } else if (name.equals(Header.TARGET_PATH)) {
+        } else if (name.equals(Header.TARGET_PATH_UTF8)) {
           path = value;
         } else if (protocol == Protocol.HTTP_2 || protocol == Protocol.H2_PRIOR_KNOWLEDGE) {
-          httpHeaders.add(name.utf8(), value);
+          httpHeaders.add(name, value);
         } else {
           throw new IllegalStateException();
         }
-        if (name.utf8().equals("expect") && value.equalsIgnoreCase("100-continue")) {
+        if (name.equals("expect") && value.equalsIgnoreCase("100-continue")) {
           // Don't read the body unless we've invited the client to send it.
           readBody = false;
         }
@@ -959,9 +985,12 @@ private RecordedRequest readRequest(Http2Stream stream) throws IOException {
       Headers headers = httpHeaders.build();
 
       MockResponse peek = dispatcher.peek();
-      if (!readBody && peek.getSocketPolicy() == EXPECT_CONTINUE) {
-        stream.sendResponseHeaders(Collections.singletonList(
-            new Header(Header.RESPONSE_STATUS, ByteString.encodeUtf8("100 Continue"))), true);
+      if (peek.isDuplex()) {
+        readBody = false;
+      } else if (!readBody && peek.getSocketPolicy() == EXPECT_CONTINUE) {
+        List<Header> continueHeaders = Collections.singletonList(
+            new Header(Header.RESPONSE_STATUS, ByteString.encodeUtf8("100 Continue")));
+        stream.writeHeaders(continueHeaders, false, true);
         stream.getConnection().flush();
         readBody = true;
       }
@@ -981,7 +1010,8 @@ private RecordedRequest readRequest(Http2Stream stream) throws IOException {
           sequenceNumber.getAndIncrement(), socket);
     }
 
-    private void writeResponse(Http2Stream stream, MockResponse response) throws IOException {
+    private void writeResponse(final Http2Stream stream,
+        final RecordedRequest request, final MockResponse response) throws IOException {
       Settings settings = response.getSettings();
       if (settings != null) {
         stream.getConnection().setSettings(settings);
@@ -1001,24 +1031,40 @@ private void writeResponse(Http2Stream stream, MockResponse response) throws IOE
       for (int i = 0, size = headers.size(); i < size; i++) {
         http2Headers.add(new Header(headers.name(i), headers.value(i)));
       }
+      Headers trailers = response.getTrailers();
 
       sleepIfDelayed(response.getHeadersDelay(TimeUnit.MILLISECONDS));
 
       Buffer body = response.getBody();
-      boolean closeStreamAfterHeaders = body != null || !response.getPushPromises().isEmpty();
-      stream.sendResponseHeaders(http2Headers, closeStreamAfterHeaders);
-      pushPromises(stream, response.getPushPromises());
+      boolean outFinished = body == null
+          && response.getPushPromises().isEmpty()
+          && !response.isDuplex();
+      boolean flushHeaders = body == null;
+      if (outFinished && trailers.size() > 0) {
+        throw new IllegalStateException("unsupported: no body and non-empty trailers " + trailers);
+      }
+      stream.writeHeaders(http2Headers, outFinished, flushHeaders);
+      if (trailers.size() > 0) {
+        stream.enqueueTrailers(trailers);
+      }
+      pushPromises(stream, request, response.getPushPromises());
       if (body != null) {
         BufferedSink sink = Okio.buffer(stream.getSink());
         sleepIfDelayed(response.getBodyDelay(TimeUnit.MILLISECONDS));
         throttledTransfer(response, socket, body, sink, body.size(), false);
         sink.close();
-      } else if (closeStreamAfterHeaders) {
+      } else if (response.isDuplex()) {
+        BufferedSink sink = Okio.buffer(stream.getSink());
+        BufferedSource source = Okio.buffer(stream.getSource());
+        DuplexResponseBody duplexResponseBody = response.getDuplexResponseBody();
+        duplexResponseBody.onRequest(request, source, sink);
+      } else if (!outFinished) {
         stream.close(ErrorCode.NO_ERROR);
       }
     }
 
-    private void pushPromises(Http2Stream stream, List<PushPromise> promises) throws IOException {
+    private void pushPromises(Http2Stream stream, RecordedRequest request,
+        List<PushPromise> promises) throws IOException {
       for (PushPromise pushPromise : promises) {
         List<Header> pushedHeaders = new ArrayList<>();
         pushedHeaders.add(new Header(Header.TARGET_AUTHORITY, url(pushPromise.path()).host()));
@@ -1035,7 +1081,7 @@ private void pushPromises(Http2Stream stream, List<PushPromise> promises) throws
         boolean hasBody = pushPromise.response().getBody() != null;
         Http2Stream pushedStream =
             stream.getConnection().pushStream(stream.getId(), pushedHeaders, hasBody);
-        writeResponse(pushedStream, pushPromise.response());
+        writeResponse(pushedStream, request, pushPromise.response());
       }
     }
   }
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/RecordedRequest.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/RecordedRequest.java
index f3b79d3e93..52beb79323 100644
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/RecordedRequest.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/RecordedRequest.java
@@ -17,6 +17,8 @@
 package okhttp3.mockwebserver;
 
 import java.io.IOException;
+import java.net.Inet6Address;
+import java.net.InetAddress;
 import java.net.Socket;
 import java.util.List;
 import javax.net.ssl.SSLSocket;
@@ -61,12 +63,24 @@ public RecordedRequest(String requestLine, Headers headers, List<Integer> chunkS
       int methodEnd = requestLine.indexOf(' ');
       int pathEnd = requestLine.indexOf(' ', methodEnd + 1);
       this.method = requestLine.substring(0, methodEnd);
-      this.path = requestLine.substring(methodEnd + 1, pathEnd);
+      String path = requestLine.substring(methodEnd + 1, pathEnd);
+      if (!path.startsWith("/")) {
+        path = "/";
+      }
+      this.path = path;
 
       String scheme = socket instanceof SSLSocket ? "https" : "http";
-      String hostname = socket.getInetAddress().getHostName();
-      int port = socket.getLocalPort();
-      this.requestUrl = HttpUrl.parse(String.format("%s://%s:%s%s", scheme, hostname, port, path));
+      InetAddress inetAddress = socket.getLocalAddress();
+
+      String hostname = inetAddress.getHostName();
+      if (inetAddress instanceof Inet6Address) {
+        hostname = "[" + hostname + "]";
+      }
+
+      int localPort = socket.getLocalPort();
+      // Allow null in failure case to allow for testing bad requests
+      this.requestUrl =
+          HttpUrl.parse(String.format("%s://%s:%s%s", scheme, hostname, localPort, path));
     } else {
       this.requestUrl = null;
       this.method = null;
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/SocketPolicy.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/SocketPolicy.java
index e92da7657f..beeb2c9a6d 100644
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/SocketPolicy.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/SocketPolicy.java
@@ -31,6 +31,11 @@
  */
 public enum SocketPolicy {
 
+  /**
+   * Shutdown {@link MockWebServer} after writing response.
+   */
+  SHUTDOWN_SERVER_AFTER_RESPONSE,
+
   /**
    * Keep the socket open after the response. This is the default HTTP/1.1 behavior.
    */
diff --git a/okhttp/src/main/java/okhttp3/internal/tls/TrustRootIndex.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/internal/duplex/DuplexResponseBody.java
similarity index 60%
rename from okhttp/src/main/java/okhttp3/internal/tls/TrustRootIndex.java
rename to mockwebserver/src/main/java/okhttp3/mockwebserver/internal/duplex/DuplexResponseBody.java
index 499f120e33..79a8245e8f 100644
--- a/okhttp/src/main/java/okhttp3/internal/tls/TrustRootIndex.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/internal/duplex/DuplexResponseBody.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Square, Inc.
+ * Copyright (C) 2018 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,11 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.tls;
+package okhttp3.mockwebserver.internal.duplex;
 
-import java.security.cert.X509Certificate;
+import java.io.IOException;
+import okhttp3.mockwebserver.RecordedRequest;
+import okio.BufferedSink;
+import okio.BufferedSource;
 
-public interface TrustRootIndex {
-  /** Returns the trusted CA certificate that signed {@code cert}. */
-  X509Certificate findByIssuerAndSignature(X509Certificate cert);
+public interface DuplexResponseBody {
+  void onRequest(RecordedRequest request, BufferedSource requestBody, BufferedSink responseBody)
+      throws IOException;
 }
diff --git a/mockwebserver/src/test/java/okhttp3/mockwebserver/CustomDispatcherTest.java b/mockwebserver/src/test/java/okhttp3/mockwebserver/CustomDispatcherTest.java
index ec8317e95e..0a43dd9165 100644
--- a/mockwebserver/src/test/java/okhttp3/mockwebserver/CustomDispatcherTest.java
+++ b/mockwebserver/src/test/java/okhttp3/mockwebserver/CustomDispatcherTest.java
@@ -83,16 +83,14 @@ public MockResponse dispatch(RecordedRequest request) throws InterruptedExceptio
     assertEquals(200, secondResponseCode.get()); // (Still done).
   }
 
-  private Thread buildRequestThread(final String path, final AtomicInteger responseCode) {
-    return new Thread(new Runnable() {
-      @Override public void run() {
-        final URL url = mockWebServer.url(path).url();
-        final HttpURLConnection conn;
-        try {
-          conn = (HttpURLConnection) url.openConnection();
-          responseCode.set(conn.getResponseCode()); // Force the connection to hit the "server".
-        } catch (IOException e) {
-        }
+  private Thread buildRequestThread(String path, AtomicInteger responseCode) {
+    return new Thread(() -> {
+      URL url = mockWebServer.url(path).url();
+      HttpURLConnection conn;
+      try {
+        conn = (HttpURLConnection) url.openConnection();
+        responseCode.set(conn.getResponseCode()); // Force the connection to hit the "server".
+      } catch (IOException ignored) {
       }
     });
   }
diff --git a/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java b/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java
index cb4577b4f0..67f417e73f 100644
--- a/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java
+++ b/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java
@@ -27,7 +27,6 @@
 import java.net.SocketTimeoutException;
 import java.net.URL;
 import java.net.URLConnection;
-import java.nio.charset.StandardCharsets;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
@@ -40,14 +39,15 @@
 import okhttp3.Protocol;
 import okhttp3.RecordingHostnameVerifier;
 import okhttp3.internal.Util;
-import okhttp3.tls.HeldCertificate;
 import okhttp3.tls.HandshakeCertificates;
+import okhttp3.tls.HeldCertificate;
 import org.junit.After;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.Description;
 import org.junit.runners.model.Statement;
 
+import static java.nio.charset.StandardCharsets.UTF_8;
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
 import static java.util.concurrent.TimeUnit.SECONDS;
 import static okhttp3.tls.internal.TlsUtil.localhost;
@@ -165,15 +165,13 @@
    * response is ready.
    */
   @Test public void dispatchBlocksWaitingForEnqueue() throws Exception {
-    new Thread() {
-      @Override public void run() {
-        try {
-          Thread.sleep(1000);
-        } catch (InterruptedException ignored) {
-        }
-        server.enqueue(new MockResponse().setBody("enqueued in the background"));
+    new Thread(() -> {
+      try {
+        Thread.sleep(1000);
+      } catch (InterruptedException ignored) {
       }
-    }.start();
+      server.enqueue(new MockResponse().setBody("enqueued in the background"));
+    }).start();
 
     URLConnection connection = server.url("/").url().openConnection();
     InputStream in = connection.getInputStream();
@@ -248,7 +246,7 @@
     long startNanos = System.nanoTime();
     URLConnection connection = server.url("/").url().openConnection();
     connection.setDoOutput(true);
-    connection.getOutputStream().write("ABCDEF".getBytes("UTF-8"));
+    connection.getOutputStream().write("ABCDEF".getBytes(UTF_8));
     InputStream in = connection.getInputStream();
     assertEquals(-1, in.read());
     long elapsedNanos = System.nanoTime() - startNanos;
@@ -452,6 +450,24 @@
     assertEquals("foo bar", requestUrl.queryParameter("key"));
   }
 
+  @Test public void shutdownServerAfterRequest() throws Exception {
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.SHUTDOWN_SERVER_AFTER_RESPONSE));
+
+    URL url = server.url("/").url();
+
+    HttpURLConnection connection = (HttpURLConnection) url.openConnection();
+    assertEquals(HttpURLConnection.HTTP_OK, connection.getResponseCode());
+
+    HttpURLConnection refusedConnection = (HttpURLConnection) url.openConnection();
+
+    try {
+      refusedConnection.getResponseCode();
+      fail("Second connection should be refused");
+    } catch (ConnectException e ) {
+      assertTrue(e.getMessage().contains("refused"));
+    }
+  }
+
   @Test public void http100Continue() throws Exception {
     server.enqueue(new MockResponse().setBody("response"));
 
@@ -459,7 +475,7 @@
     HttpURLConnection connection = (HttpURLConnection) url.openConnection();
     connection.setDoOutput(true);
     connection.setRequestProperty("Expect", "100-Continue");
-    connection.getOutputStream().write("request".getBytes(StandardCharsets.UTF_8));
+    connection.getOutputStream().write("request".getBytes(UTF_8));
 
     InputStream in = connection.getInputStream();
     BufferedReader reader = new BufferedReader(new InputStreamReader(in));
diff --git a/mockwebserver/src/test/java/okhttp3/mockwebserver/RecordedRequestTest.java b/mockwebserver/src/test/java/okhttp3/mockwebserver/RecordedRequestTest.java
new file mode 100644
index 0000000000..b55a6ddd3f
--- /dev/null
+++ b/mockwebserver/src/test/java/okhttp3/mockwebserver/RecordedRequestTest.java
@@ -0,0 +1,100 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package okhttp3.mockwebserver;
+
+import java.net.Inet4Address;
+import java.net.InetAddress;
+import java.net.Socket;
+import java.net.UnknownHostException;
+import java.util.Collections;
+import okhttp3.Headers;
+import okio.Buffer;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+
+public class RecordedRequestTest {
+  Headers headers = new Headers.Builder().build();
+
+  private class FakeSocket extends Socket {
+    private final InetAddress localAddress;
+    private final int remotePort;
+    private final InetAddress remoteAddress;
+    private final int localPort;
+
+    private FakeSocket(int localPort) {
+      this(Inet4Address.getLoopbackAddress(), localPort);
+    }
+
+    private FakeSocket(InetAddress inetAddress, int localPort) {
+      this(inetAddress, localPort, inetAddress, 1234);
+    }
+
+    private FakeSocket(InetAddress localAddress, int localPort, InetAddress remoteAddress, int remotePort) {
+      this.localAddress = localAddress;
+      this.localPort = localPort;
+      this.remoteAddress = remoteAddress;
+      this.remotePort = remotePort;
+    }
+
+    @Override public InetAddress getInetAddress() {
+      return remoteAddress;
+    }
+
+    @Override public InetAddress getLocalAddress() {
+      return localAddress;
+    }
+
+    @Override public int getLocalPort() {
+      return localPort;
+    }
+
+    @Override public int getPort() {
+      return remotePort;
+    }
+  }
+
+  @Test public void testIPv4() throws UnknownHostException {
+    Socket socket =
+        new FakeSocket(InetAddress.getByAddress("127.0.0.1", new byte[] { 127, 0, 0, 1 }), 80);
+
+    RecordedRequest request = new RecordedRequest("GET / HTTP/1.1", headers,
+        Collections.emptyList(), 0, new Buffer(), 0, socket);
+
+    assertEquals("http://127.0.0.1/", request.getRequestUrl().toString());
+  }
+
+  @Test public void testIpv6() throws UnknownHostException {
+    Socket socket = new FakeSocket(InetAddress.getByAddress("::1",
+        new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 }), 80);
+
+    RecordedRequest request = new RecordedRequest("GET / HTTP/1.1", headers,
+        Collections.emptyList(), 0, new Buffer(), 0, socket);
+
+    assertEquals("http://[::1]/", request.getRequestUrl().toString());
+  }
+
+  @Test public void testUsesLocal() throws UnknownHostException {
+    Socket socket =
+        new FakeSocket(InetAddress.getByAddress("127.0.0.1", new byte[] { 127, 0, 0, 1 }), 80);
+
+    RecordedRequest request = new RecordedRequest("GET / HTTP/1.1", headers,
+        Collections.emptyList(), 0, new Buffer(), 0, socket);
+
+    assertEquals("http://127.0.0.1/", request.getRequestUrl().toString());
+  }
+}
diff --git a/mockwebserver/src/test/java/okhttp3/mockwebserver/internal/http2/Http2Server.java b/mockwebserver/src/test/java/okhttp3/mockwebserver/internal/http2/Http2Server.java
index add3c9f157..b7ca4b2488 100644
--- a/mockwebserver/src/test/java/okhttp3/mockwebserver/internal/http2/Http2Server.java
+++ b/mockwebserver/src/test/java/okhttp3/mockwebserver/internal/http2/Http2Server.java
@@ -28,6 +28,7 @@
 import java.util.logging.Logger;
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
+import okhttp3.Headers;
 import okhttp3.Protocol;
 import okhttp3.internal.Util;
 import okhttp3.internal.http2.Header;
@@ -95,11 +96,11 @@ private SSLSocket doSsl(Socket socket) throws IOException {
 
   @Override public void onStream(Http2Stream stream) throws IOException {
     try {
-      List<Header> requestHeaders = stream.getRequestHeaders();
+      Headers requestHeaders = stream.takeHeaders();
       String path = null;
       for (int i = 0, size = requestHeaders.size(); i < size; i++) {
-        if (requestHeaders.get(i).name.equals(Header.TARGET_PATH)) {
-          path = requestHeaders.get(i).value.utf8();
+        if (requestHeaders.name(i).equals(Header.TARGET_PATH_UTF8)) {
+          path = requestHeaders.value(i);
           break;
         }
       }
@@ -129,7 +130,7 @@ private void send404(Http2Stream stream, String path) throws IOException {
         new Header(":version", "HTTP/1.1"),
         new Header("content-type", "text/plain")
     );
-    stream.sendResponseHeaders(responseHeaders, true);
+    stream.writeHeaders(responseHeaders, false, false);
     BufferedSink out = Okio.buffer(stream.getSink());
     out.writeUtf8("Not found: " + path);
     out.close();
@@ -141,7 +142,7 @@ private void serveDirectory(Http2Stream stream, File[] files) throws IOException
         new Header(":version", "HTTP/1.1"),
         new Header("content-type", "text/html; charset=UTF-8")
     );
-    stream.sendResponseHeaders(responseHeaders, true);
+    stream.writeHeaders(responseHeaders, false, false);
     BufferedSink out = Okio.buffer(stream.getSink());
     for (File file : files) {
       String target = file.isDirectory() ? (file.getName() + "/") : file.getName();
@@ -156,14 +157,9 @@ private void serveFile(Http2Stream stream, File file) throws IOException {
         new Header(":version", "HTTP/1.1"),
         new Header("content-type", contentType(file))
     );
-    stream.sendResponseHeaders(responseHeaders, true);
-    Source source = Okio.source(file);
-    try {
-      BufferedSink out = Okio.buffer(stream.getSink());
-      out.writeAll(source);
-      out.close();
-    } finally {
-      Util.closeQuietly(source);
+    stream.writeHeaders(responseHeaders, false, false);
+    try (Source source = Okio.source(file); BufferedSink sink = Okio.buffer(stream.getSink())) {
+      sink.writeAll(source);
     }
   }
 
diff --git a/okcurl/pom.xml b/okcurl/pom.xml
index 6d1cc5c697..c252ade5b2 100644
--- a/okcurl/pom.xml
+++ b/okcurl/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.12.0-SNAPSHOT</version>
+    <version>3.13.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okcurl</artifactId>
@@ -18,6 +18,11 @@
       <artifactId>okhttp</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>logging-interceptor</artifactId>
+      <version>${project.version}</version>
+    </dependency>
     <dependency>
       <groupId>${project.groupId}</groupId>
       <artifactId>okhttp-testing-support</artifactId>
@@ -52,7 +57,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-assembly-plugin</artifactId>
-        <version>3.0.0</version>
+        <version>3.1.0</version>
         <configuration>
           <descriptorRefs>
             <descriptorRef>jar-with-dependencies</descriptorRef>
@@ -75,7 +80,7 @@
       <plugin>
         <groupId>org.skife.maven</groupId>
         <artifactId>really-executable-jar-maven-plugin</artifactId>
-        <version>1.1.0</version>
+        <version>1.5.0</version>
         <executions>
           <execution>
             <phase>package</phase>
@@ -91,7 +96,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-jar-plugin</artifactId>
-        <version>3.0.2</version>
+        <version>3.1.1</version>
         <configuration>
           <archive>
             <manifestEntries>
diff --git a/okcurl/src/main/java/okhttp3/curl/Main.java b/okcurl/src/main/java/okhttp3/curl/Main.java
index cee2600619..22c8b5c45c 100644
--- a/okcurl/src/main/java/okhttp3/curl/Main.java
+++ b/okcurl/src/main/java/okhttp3/curl/Main.java
@@ -33,7 +33,6 @@
 import java.util.logging.SimpleFormatter;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLSession;
 import javax.net.ssl.SSLSocketFactory;
 import javax.net.ssl.TrustManager;
 import javax.net.ssl.X509TrustManager;
@@ -48,6 +47,8 @@
 import okhttp3.internal.http.StatusLine;
 import okhttp3.internal.http2.Http2;
 import okhttp3.internal.platform.Platform;
+import okhttp3.logging.HttpLoggingInterceptor;
+import okhttp3.logging.LoggingEventListener;
 import okio.BufferedSource;
 import okio.Okio;
 import okio.Sink;
@@ -102,6 +103,11 @@ private static String protocols() {
   @Option(name = "--read-timeout", description = "Maximum time allowed for reading data (seconds)")
   public int readTimeout = DEFAULT_TIMEOUT;
 
+  @Option(
+      name = "--call-timeout",
+      description = "Maximum time allowed for the entire call (seconds)")
+  public int callTimeout = DEFAULT_TIMEOUT;
+
   @Option(name = {"-L", "--location"}, description = "Follow redirects")
   public boolean followRedirects;
 
@@ -121,6 +127,11 @@ private static String protocols() {
   @Option(name = {"-V", "--version"}, description = "Show version number and quit")
   public boolean version;
 
+  @Option(
+      name = {"-v", "--verbose"},
+      description = "Makes " + NAME + " verbose during the operation")
+  public boolean verbose;
+
   @Arguments(title = "url", description = "Remote resource URL")
   public String url;
 
@@ -157,7 +168,7 @@ private static String protocols() {
       Sink out = Okio.sink(System.out);
       BufferedSource source = response.body().source();
       while (!source.exhausted()) {
-        out.write(source.buffer(), source.buffer().size());
+        out.write(source.getBuffer(), source.getBuffer().size());
         out.flush();
       }
 
@@ -178,12 +189,19 @@ private OkHttpClient createClient() {
     if (readTimeout != DEFAULT_TIMEOUT) {
       builder.readTimeout(readTimeout, SECONDS);
     }
+    if (callTimeout != DEFAULT_TIMEOUT) {
+      builder.callTimeout(callTimeout, SECONDS);
+    }
     if (allowInsecure) {
       X509TrustManager trustManager = createInsecureTrustManager();
       SSLSocketFactory sslSocketFactory = createInsecureSslSocketFactory(trustManager);
       builder.sslSocketFactory(sslSocketFactory, trustManager);
       builder.hostnameVerifier(createInsecureHostnameVerifier());
     }
+    if (verbose) {
+      HttpLoggingInterceptor.Logger logger = System.out::println;
+      builder.eventListenerFactory(new LoggingEventListener.Factory(logger));
+    }
     return builder.build();
   }
 
@@ -267,11 +285,7 @@ private static SSLSocketFactory createInsecureSslSocketFactory(TrustManager trus
   }
 
   private static HostnameVerifier createInsecureHostnameVerifier() {
-    return new HostnameVerifier() {
-      @Override public boolean verify(String s, SSLSession sslSession) {
-        return true;
-      }
-    };
+    return (name, session) -> true;
   }
 
   private static void enableHttp2FrameLogging() {
diff --git a/okhttp-android-support/pom.xml b/okhttp-android-support/pom.xml
index ecb19d47a6..1dbcfce02c 100644
--- a/okhttp-android-support/pom.xml
+++ b/okhttp-android-support/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.12.0-SNAPSHOT</version>
+    <version>3.13.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-android-support</artifactId>
@@ -57,7 +57,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-javadoc-plugin</artifactId>
-        <version>2.10.4</version>
+        <version>3.0.1</version>
         <configuration>
           <excludePackageNames>okhttp3.internal.*</excludePackageNames>
           <links>
@@ -68,7 +68,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-jar-plugin</artifactId>
-        <version>3.0.2</version>
+        <version>3.1.1</version>
         <configuration>
           <archive>
             <manifestEntries>
diff --git a/okhttp-android-support/src/main/java/okhttp3/AndroidShimResponseCache.java b/okhttp-android-support/src/main/java/okhttp3/AndroidShimResponseCache.java
index c46a0cb9fd..a0590b2c4b 100644
--- a/okhttp-android-support/src/main/java/okhttp3/AndroidShimResponseCache.java
+++ b/okhttp-android-support/src/main/java/okhttp3/AndroidShimResponseCache.java
@@ -24,6 +24,7 @@
 import java.net.URLConnection;
 import java.util.List;
 import java.util.Map;
+import javax.annotation.Nullable;
 import okhttp3.internal.huc.JavaApiConverter;
 
 /**
@@ -64,7 +65,8 @@ public Cache getCache() {
     return JavaApiConverter.createJavaCacheResponse(okResponse);
   }
 
-  @Override public CacheRequest put(URI uri, URLConnection urlConnection) throws IOException {
+  @Override public @Nullable CacheRequest put(
+      URI uri, URLConnection urlConnection) throws IOException {
     Response okResponse = JavaApiConverter.createOkResponseForCachePut(uri, urlConnection);
     if (okResponse == null) {
       // The URLConnection is not cacheable or could not be converted. Stop.
diff --git a/okhttp-android-support/src/main/java/okhttp3/internal/huc/JavaApiConverter.java b/okhttp-android-support/src/main/java/okhttp3/internal/huc/JavaApiConverter.java
index 1dec85cdc0..51155785e6 100644
--- a/okhttp-android-support/src/main/java/okhttp3/internal/huc/JavaApiConverter.java
+++ b/okhttp-android-support/src/main/java/okhttp3/internal/huc/JavaApiConverter.java
@@ -878,7 +878,7 @@ private static RuntimeException throwResponseBodyAccessException() {
   }
 
   private static <T> List<T> nullSafeImmutableList(T[] elements) {
-    return elements == null ? Collections.<T>emptyList() : Util.immutableList(elements);
+    return elements == null ? Collections.emptyList() : Util.immutableList(elements);
   }
 
   private static long stringToLong(String s) {
diff --git a/okhttp-android-support/src/test/java/okhttp3/AbstractResponseCache.java b/okhttp-android-support/src/test/java/okhttp3/AbstractResponseCache.java
index d755487c92..e5ce90dd34 100644
--- a/okhttp-android-support/src/test/java/okhttp3/AbstractResponseCache.java
+++ b/okhttp-android-support/src/test/java/okhttp3/AbstractResponseCache.java
@@ -25,14 +25,16 @@
 import java.net.URLConnection;
 import java.util.List;
 import java.util.Map;
+import javax.annotation.Nullable;
 
 public class AbstractResponseCache extends ResponseCache {
-  @Override public CacheResponse get(URI uri, String requestMethod,
+  @Override public @Nullable CacheResponse get(URI uri, String requestMethod,
       Map<String, List<String>> requestHeaders) throws IOException {
     return null;
   }
 
-  @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
+  @Override public @Nullable CacheRequest put(
+      URI uri, URLConnection connection) throws IOException {
     return null;
   }
 
diff --git a/okhttp-android-support/src/test/java/okhttp3/internal/huc/CacheAdapterTest.java b/okhttp-android-support/src/test/java/okhttp3/internal/huc/CacheAdapterTest.java
index 09a438807f..c1b4a6f4d2 100644
--- a/okhttp-android-support/src/test/java/okhttp3/internal/huc/CacheAdapterTest.java
+++ b/okhttp-android-support/src/test/java/okhttp3/internal/huc/CacheAdapterTest.java
@@ -23,7 +23,6 @@
 import java.net.URI;
 import java.net.URL;
 import java.net.URLConnection;
-import java.nio.charset.StandardCharsets;
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
@@ -43,6 +42,7 @@
 import org.junit.Before;
 import org.junit.Test;
 
+import static java.nio.charset.StandardCharsets.UTF_8;
 import static okhttp3.tls.internal.TlsUtil.localhost;
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
@@ -137,7 +137,7 @@
 
   @Test public void put_httpGet() throws Exception {
     final String statusLine = "HTTP/1.1 200 Fantastic";
-    final byte[] response = "ResponseString".getBytes(StandardCharsets.UTF_8);
+    final byte[] response = "ResponseString".getBytes(UTF_8);
     final URL serverUrl = configureServer(
         new MockResponse()
             .setStatus(statusLine)
diff --git a/okhttp-android-support/src/test/java/okhttp3/internal/huc/JavaApiConverterTest.java b/okhttp-android-support/src/test/java/okhttp3/internal/huc/JavaApiConverterTest.java
index ad5d3fdfd3..8acbe31519 100644
--- a/okhttp-android-support/src/test/java/okhttp3/internal/huc/JavaApiConverterTest.java
+++ b/okhttp-android-support/src/test/java/okhttp3/internal/huc/JavaApiConverterTest.java
@@ -23,7 +23,6 @@
 import java.net.HttpURLConnection;
 import java.net.SecureCacheResponse;
 import java.net.URI;
-import java.nio.charset.StandardCharsets;
 import java.security.Principal;
 import java.security.cert.Certificate;
 import java.security.cert.CertificateException;
@@ -49,7 +48,6 @@
 import okhttp3.ResponseBody;
 import okhttp3.TlsVersion;
 import okhttp3.internal.Internal;
-import okhttp3.internal.Util;
 import okhttp3.mockwebserver.MockWebServer;
 import okio.Buffer;
 import okio.BufferedSource;
@@ -57,6 +55,7 @@
 import org.junit.Rule;
 import org.junit.Test;
 
+import static java.nio.charset.StandardCharsets.UTF_8;
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
@@ -114,7 +113,7 @@
       }
 
       @Override public InputStream getBody() throws IOException {
-        return new ByteArrayInputStream("HelloWorld".getBytes(StandardCharsets.UTF_8));
+        return new ByteArrayInputStream("HelloWorld".getBytes(UTF_8));
       }
     };
 
@@ -160,9 +159,9 @@
   @Test public void createOkResponseForCacheGet_secure() throws Exception {
     final String statusLine = "HTTP/1.1 200 Fantastic";
     final Principal localPrincipal = LOCAL_CERT.getSubjectX500Principal();
-    final List<Certificate> localCertificates = Arrays.<Certificate>asList(LOCAL_CERT);
+    final List<Certificate> localCertificates = Arrays.asList(LOCAL_CERT);
     final Principal serverPrincipal = SERVER_CERT.getSubjectX500Principal();
-    final List<Certificate> serverCertificates = Arrays.<Certificate>asList(SERVER_CERT);
+    final List<Certificate> serverCertificates = Arrays.asList(SERVER_CERT);
     URI uri = new URI("https://foo/bar");
     Request request = new Request.Builder().url(uri.toURL()).build();
     SecureCacheResponse cacheResponse = new SecureCacheResponse() {
@@ -174,7 +173,7 @@
       }
 
       @Override public InputStream getBody() throws IOException {
-        return new ByteArrayInputStream("HelloWorld".getBytes(StandardCharsets.UTF_8));
+        return new ByteArrayInputStream("HelloWorld".getBytes(UTF_8));
       }
 
       @Override public String getCipherSuite() {
@@ -400,7 +399,7 @@
     }
 
     // Check retrieval of headers by index.
-    assertEquals(null, httpUrlConnection.getHeaderFieldKey(0));
+    assertNull(httpUrlConnection.getHeaderFieldKey(0));
     assertEquals("HTTP/1.1 200 Fantastic", httpUrlConnection.getHeaderField(0));
     // After header zero there may be additional entries provided at the beginning or end by the
     // implementation. It's probably important that the relative ordering of the headers is
@@ -466,7 +465,7 @@ private void assertHeadersContainsMapping(Map<String, List<String>> headers, Str
         .url("https://secure/request")
         .build();
     Handshake handshake = Handshake.get(TlsVersion.SSL_3_0, CipherSuite.TLS_RSA_WITH_NULL_MD5,
-        Arrays.<Certificate>asList(SERVER_CERT), Arrays.<Certificate>asList(LOCAL_CERT));
+        Arrays.asList(SERVER_CERT), Arrays.asList(LOCAL_CERT));
     Response okResponse = createArbitraryOkResponse(okRequest).newBuilder()
         .handshake(handshake)
         .build();
@@ -556,7 +555,7 @@ private void assertHeadersContainsMapping(Map<String, List<String>> headers, Str
             .build();
     ResponseBody responseBody = createResponseBody("ResponseBody");
     Handshake handshake = Handshake.get(TlsVersion.SSL_3_0, CipherSuite.TLS_RSA_WITH_NULL_MD5,
-        Arrays.<Certificate>asList(SERVER_CERT), Arrays.<Certificate>asList(LOCAL_CERT));
+        Arrays.asList(SERVER_CERT), Arrays.asList(LOCAL_CERT));
     Response okResponse = createArbitraryOkResponse(okRequest).newBuilder()
         .protocol(Protocol.HTTP_1_1)
         .code(200)
@@ -612,7 +611,7 @@ private void assertHeadersContainsMapping(Map<String, List<String>> headers, Str
     assertEquals("StatusLine", JavaApiConverter.extractStatusLine(javaResponseHeaders));
 
     try {
-      JavaApiConverter.extractStatusLine(Collections.<String, List<String>>emptyMap());
+      JavaApiConverter.extractStatusLine(Collections.emptyMap());
       fail();
     } catch (IOException expected) {
     }
@@ -626,7 +625,7 @@ private void assertHeadersContainsMapping(Map<String, List<String>> headers, Str
   private static X509Certificate certificate(String certificate) {
     try {
       return (X509Certificate) CertificateFactory.getInstance("X.509").generateCertificate(
-          new ByteArrayInputStream(certificate.getBytes(Util.UTF_8)));
+          new ByteArrayInputStream(certificate.getBytes(UTF_8)));
     } catch (CertificateException e) {
       fail();
       return null;
diff --git a/okhttp-android-support/src/test/java/okhttp3/internal/huc/ResponseCacheTest.java b/okhttp-android-support/src/test/java/okhttp3/internal/huc/ResponseCacheTest.java
index eb95e3ea4e..94c875d814 100644
--- a/okhttp-android-support/src/test/java/okhttp3/internal/huc/ResponseCacheTest.java
+++ b/okhttp-android-support/src/test/java/okhttp3/internal/huc/ResponseCacheTest.java
@@ -16,12 +16,10 @@
 
 package okhttp3.internal.huc;
 
-import java.io.BufferedReader;
 import java.io.ByteArrayInputStream;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
-import java.io.InputStreamReader;
 import java.io.OutputStream;
 import java.net.CacheRequest;
 import java.net.CacheResponse;
@@ -67,6 +65,7 @@
 import okhttp3.tls.HandshakeCertificates;
 import okio.Buffer;
 import okio.BufferedSink;
+import okio.BufferedSource;
 import okio.GzipSink;
 import okio.Okio;
 import org.junit.After;
@@ -493,15 +492,15 @@ private void testServerPrematureDisconnect(TransferKind transferKind) throws IOE
     server.enqueue(new MockResponse()
         .setBody("Request #2"));
 
-    BufferedReader reader = new BufferedReader(
-        new InputStreamReader(openConnection(server.url("/").url()).getInputStream()));
-    assertEquals("ABCDE", reader.readLine());
+    BufferedSource bodySource = Okio.buffer(Okio.source(
+        openConnection(server.url("/").url()).getInputStream()));
+    assertEquals("ABCDE\n", bodySource.readUtf8(6));
     try {
-      reader.readLine();
+      bodySource.readUtf8(21);
       fail("This implementation silently ignored a truncated HTTP body.");
     } catch (IOException expected) {
     } finally {
-      reader.close();
+      bodySource.close();
     }
 
     URLConnection connection = openConnection(server.url("/").url());
@@ -1543,7 +1542,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
 
     URLConnection connection2 = openConnection(server.url("/").url());
     assertEquals("A", readAscii(connection2));
-    assertEquals(null, connection2.getHeaderField("Warning"));
+    assertNull(connection2.getHeaderField("Warning"));
   }
 
   @Test public void getHeadersRetainsCached200LevelWarnings() throws Exception {
@@ -1600,7 +1599,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     // still valid
     HttpURLConnection connection1 = openConnection(server.url("/a").url());
     assertEquals("A", readAscii(connection1));
-    assertEquals(null, connection1.getHeaderField("Allow"));
+    assertNull(connection1.getHeaderField("Allow"));
 
     // conditional cache hit; The cached data should be returned, but the cache is not updated.
     HttpURLConnection connection2 = openConnection(server.url("/a").url());
@@ -1761,17 +1760,17 @@ private MockResponse truncateViolently(MockResponse response, int numBytesToKeep
   }
 
   enum TransferKind {
-    CHUNKED() {
+    CHUNKED {
       @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
         response.setChunkedBody(content, chunkSize);
       }
     },
-    FIXED_LENGTH() {
+    FIXED_LENGTH {
       @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
         response.setBody(content);
       }
     },
-    END_OF_STREAM() {
+    END_OF_STREAM {
       @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
         response.setBody(content);
         response.setSocketPolicy(SocketPolicy.DISCONNECT_AT_END);
diff --git a/okhttp-apache/pom.xml b/okhttp-apache/pom.xml
index 85c666ba92..89b50f68e9 100644
--- a/okhttp-apache/pom.xml
+++ b/okhttp-apache/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.12.0-SNAPSHOT</version>
+    <version>3.13.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-apache</artifactId>
@@ -48,7 +48,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-javadoc-plugin</artifactId>
-        <version>2.10.4</version>
+        <version>3.0.1</version>
         <configuration>
           <links>
             <link>http://square.github.io/okhttp/javadoc/</link>
@@ -60,7 +60,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-jar-plugin</artifactId>
-        <version>3.0.2</version>
+        <version>3.1.1</version>
         <configuration>
           <archive>
             <manifestEntries>
diff --git a/okhttp-apache/src/test/java/okhttp3/apache/OkApacheClientTest.java b/okhttp-apache/src/test/java/okhttp3/apache/OkApacheClientTest.java
index 77493a2540..f8482564ab 100644
--- a/okhttp-apache/src/test/java/okhttp3/apache/OkApacheClientTest.java
+++ b/okhttp-apache/src/test/java/okhttp3/apache/OkApacheClientTest.java
@@ -25,7 +25,7 @@
 import org.junit.Before;
 import org.junit.Test;
 
-import static okhttp3.internal.Util.UTF_8;
+import static java.nio.charset.StandardCharsets.UTF_8;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
diff --git a/okhttp-dnsoverhttps/pom.xml b/okhttp-dnsoverhttps/pom.xml
index 2fb9c3db1a..b5ad646bf9 100644
--- a/okhttp-dnsoverhttps/pom.xml
+++ b/okhttp-dnsoverhttps/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.12.0-SNAPSHOT</version>
+    <version>3.13.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-dnsoverhttps</artifactId>
@@ -53,7 +53,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-jar-plugin</artifactId>
-        <version>3.0.2</version>
+        <version>3.1.1</version>
         <configuration>
           <archive>
             <manifestEntries>
diff --git a/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsOverHttps.java b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsOverHttps.java
index f19b37361e..67442f3313 100644
--- a/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsOverHttps.java
+++ b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsOverHttps.java
@@ -18,11 +18,14 @@
 import java.io.IOException;
 import java.net.InetAddress;
 import java.net.UnknownHostException;
+import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
-import java.util.concurrent.TimeUnit;
+import java.util.concurrent.CountDownLatch;
 import javax.annotation.Nullable;
 import okhttp3.CacheControl;
+import okhttp3.Call;
+import okhttp3.Callback;
 import okhttp3.Dns;
 import okhttp3.HttpUrl;
 import okhttp3.MediaType;
@@ -32,6 +35,7 @@
 import okhttp3.RequestBody;
 import okhttp3.Response;
 import okhttp3.ResponseBody;
+import okhttp3.internal.Util;
 import okhttp3.internal.platform.Platform;
 import okhttp3.internal.publicsuffix.PublicSuffixDatabase;
 import okio.ByteString;
@@ -39,7 +43,7 @@
 /**
  * DNS over HTTPS implementation.
  *
- * Implementation of https://tools.ietf.org/html/draft-ietf-doh-dns-over-https-11
+ * Implementation of https://tools.ietf.org/html/draft-ietf-doh-dns-over-https-13
  *
  * <blockquote>A DNS API client encodes a single DNS query into an HTTP request
  * using either the HTTP GET or POST method and the other requirements
@@ -54,13 +58,11 @@
  */
 public class DnsOverHttps implements Dns {
   public static final MediaType DNS_MESSAGE = MediaType.get("application/dns-message");
-  public static final MediaType UDPWIREFORMAT = MediaType.get("application/dns-udpwireformat");
   public static final int MAX_RESPONSE_SIZE = 64 * 1024;
   private final OkHttpClient client;
   private final HttpUrl url;
   private final boolean includeIPv6;
   private final boolean post;
-  private final MediaType contentType;
   private final boolean resolvePrivateAddresses;
   private final boolean resolvePublicAddresses;
 
@@ -75,7 +77,6 @@
     this.url = builder.url;
     this.includeIPv6 = builder.includeIPv6;
     this.post = builder.post;
-    this.contentType = builder.contentType;
     this.resolvePrivateAddresses = builder.resolvePrivateAddresses;
     this.resolvePublicAddresses = builder.resolvePublicAddresses;
     this.client = builder.client.newBuilder().dns(buildBootstrapClient(builder)).build();
@@ -103,10 +104,6 @@ public boolean includeIPv6() {
     return includeIPv6;
   }
 
-  public MediaType contentType() {
-    return contentType;
-  }
-
   public OkHttpClient client() {
     return client;
   }
@@ -120,8 +117,6 @@ public boolean resolvePublicAddresses() {
   }
 
   @Override public List<InetAddress> lookup(String hostname) throws UnknownHostException {
-    UnknownHostException firstUhe = null;
-
     if (!resolvePrivateAddresses || !resolvePublicAddresses) {
       boolean privateHost = isPrivateHost(hostname);
 
@@ -138,37 +133,117 @@ public boolean resolvePublicAddresses() {
   }
 
   private List<InetAddress> lookupHttps(String hostname) throws UnknownHostException {
-    try {
-      ByteString query = DnsRecordCodec.encodeQuery(hostname, includeIPv6);
+    List<Call> networkRequests = new ArrayList<>(2);
+    List<Exception> failures = new ArrayList<>(2);
+    List<InetAddress> results = new ArrayList<>(5);
+
+    buildRequest(hostname, networkRequests, results, failures, DnsRecordCodec.TYPE_A);
 
-      Request request = buildRequest(query);
-      Response response = executeRequest(request);
+    if (includeIPv6) {
+      buildRequest(hostname, networkRequests, results, failures, DnsRecordCodec.TYPE_AAAA);
+    }
+
+    executeRequests(hostname, networkRequests, results, failures);
+
+    if (!results.isEmpty()) {
+      return results;
+    }
+
+    return throwBestFailure(hostname, failures);
+  }
 
-      return readResponse(hostname, response);
-    } catch (UnknownHostException uhe) {
-      throw uhe;
+  private void buildRequest(String hostname, List<Call> networkRequests, List<InetAddress> results,
+      List<Exception> failures, int type) {
+    Request request = buildRequest(hostname, type);
+    Response response = getCacheOnlyResponse(request);
+
+    if (response != null) {
+      processResponse(response, hostname, results, failures);
+    } else {
+      networkRequests.add(client.newCall(request));
+    }
+  }
+
+  private void executeRequests(final String hostname, List<Call> networkRequests,
+      final List<InetAddress> responses, final List<Exception> failures) {
+    final CountDownLatch latch = new CountDownLatch(networkRequests.size());
+
+    for (Call call : networkRequests) {
+      call.enqueue(new Callback() {
+        @Override public void onFailure(Call call, IOException e) {
+          synchronized (failures) {
+            failures.add(e);
+          }
+          latch.countDown();
+        }
+
+        @Override public void onResponse(Call call, Response response) {
+          processResponse(response, hostname, responses, failures);
+          latch.countDown();
+        }
+      });
+    }
+
+    try {
+      latch.await();
+    } catch (InterruptedException e) {
+      failures.add(e);
+    }
+  }
+
+  private void processResponse(Response response, String hostname, List<InetAddress> results,
+      List<Exception> failures) {
+    try {
+      List<InetAddress> addresses = readResponse(hostname, response);
+      synchronized (results) {
+        results.addAll(addresses);
+      }
     } catch (Exception e) {
-      UnknownHostException unknownHostException = new UnknownHostException(hostname);
-      unknownHostException.initCause(e);
-      throw unknownHostException;
+      synchronized (failures) {
+        failures.add(e);
+      }
+    }
+  }
+
+  private List<InetAddress> throwBestFailure(String hostname, List<Exception> failures)
+      throws UnknownHostException {
+    if (failures.size() == 0) {
+      throw new UnknownHostException(hostname);
+    }
+
+    Exception failure = failures.get(0);
+
+    if (failure instanceof UnknownHostException) {
+      throw (UnknownHostException) failure;
     }
+
+    UnknownHostException unknownHostException = new UnknownHostException(hostname);
+    unknownHostException.initCause(failure);
+
+    for (int i = 1; i < failures.size(); i++) {
+      Util.addSuppressedIfPossible(unknownHostException, failures.get(i));
+    }
+
+    throw unknownHostException;
   }
 
-  private Response executeRequest(Request request) throws IOException {
-    // cached request
+  private @Nullable Response getCacheOnlyResponse(Request request) {
     if (!post && client.cache() != null) {
-      CacheControl cacheControl =
-          new CacheControl.Builder().maxStale(Integer.MAX_VALUE, TimeUnit.SECONDS).build();
-      Request cacheRequest = request.newBuilder().cacheControl(cacheControl).build();
+      try {
+        Request cacheRequest = request.newBuilder().cacheControl(CacheControl.FORCE_CACHE).build();
 
-      Response response = client.newCall(cacheRequest).execute();
+        Response cacheResponse = client.newCall(cacheRequest).execute();
 
-      if (response.isSuccessful()) {
-        return response;
+        if (cacheResponse.code() != 504) {
+          return cacheResponse;
+        }
+      } catch (IOException ioe) {
+        // Failures are ignored as we can fallback to the network
+        // and hopefully repopulate the cache.
       }
     }
 
-    return client.newCall(request).execute();
+    return null;
   }
 
   private List<InetAddress> readResponse(String hostname, Response response) throws Exception {
@@ -199,11 +274,13 @@ private Response executeRequest(Request request) throws IOException {
     }
   }
 
-  private Request buildRequest(ByteString query) {
-    Request.Builder requestBuilder = new Request.Builder().header("Accept", contentType.toString());
+  private Request buildRequest(String hostname, int type) {
+    Request.Builder requestBuilder = new Request.Builder().header("Accept", DNS_MESSAGE.toString());
+
+    ByteString query = DnsRecordCodec.encodeQuery(hostname, type);
 
     if (post) {
-      requestBuilder = requestBuilder.url(url).post(RequestBody.create(contentType, query));
+      requestBuilder = requestBuilder.url(url).post(RequestBody.create(DNS_MESSAGE, query));
     } else {
       String encoded = query.base64Url().replace("=", "");
       HttpUrl requestUrl = url.newBuilder().addQueryParameter("dns", encoded).build();
@@ -223,12 +300,14 @@ static boolean isPrivateHost(String host) {
     @Nullable HttpUrl url = null;
     boolean includeIPv6 = true;
     boolean post = false;
-    MediaType contentType = DNS_MESSAGE;
     Dns systemDns = Dns.SYSTEM;
     @Nullable List<InetAddress> bootstrapDnsHosts = null;
     boolean resolvePrivateAddresses = false;
     boolean resolvePublicAddresses = true;
 
+    public Builder() {
+    }
+
     public DnsOverHttps build() {
       return new DnsOverHttps(this);
     }
@@ -253,11 +332,6 @@ public Builder post(boolean post) {
       return this;
     }
 
-    public Builder contentType(MediaType contentType) {
-      this.contentType = contentType;
-      return this;
-    }
-
     public Builder resolvePrivateAddresses(boolean resolvePrivateAddresses) {
       this.resolvePrivateAddresses = resolvePrivateAddresses;
       return this;
diff --git a/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsRecordCodec.java b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsRecordCodec.java
index 271a05446c..4c1cfc481e 100644
--- a/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsRecordCodec.java
+++ b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsRecordCodec.java
@@ -31,20 +31,20 @@
 class DnsRecordCodec {
   private static final byte SERVFAIL = 2;
   private static final byte NXDOMAIN = 3;
-  private static final int TYPE_A = 0x0001;
-  private static final int TYPE_AAAA = 0x001c;
+  public static final int TYPE_A = 0x0001;
+  public static final int TYPE_AAAA = 0x001c;
   private static final int TYPE_PTR = 0x000c;
   private static final Charset ASCII = Charset.forName("ASCII");
 
   private DnsRecordCodec() {
   }
 
-  public static ByteString encodeQuery(String host, boolean includeIPv6) {
+  public static ByteString encodeQuery(String host, int type) {
     Buffer buf = new Buffer();
 
     buf.writeShort(0); // query id
     buf.writeShort(256); // flags with recursion
-    buf.writeShort(includeIPv6 ? 2 : 1); // question count
+    buf.writeShort(1); // question count
     buf.writeShort(0); // answerCount
     buf.writeShort(0); // authorityResourceCount
     buf.writeShort(0); // additional
@@ -62,15 +62,9 @@ public static ByteString encodeQuery(String host, boolean includeIPv6) {
     nameBuf.writeByte(0); // end
 
     nameBuf.copyTo(buf, 0, nameBuf.size());
-    buf.writeShort(TYPE_A);
+    buf.writeShort(type);
     buf.writeShort(1); // CLASS_IN
 
-    if (includeIPv6) {
-      nameBuf.copyTo(buf, 0, nameBuf.size());
-      buf.writeShort(TYPE_AAAA);
-      buf.writeShort(1); // CLASS_IN
-    }
-
     return buf.readByteString();
   }
 
diff --git a/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/package-info.java b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/package-info.java
index 1469a3bfa4..54da565bc2 100644
--- a/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/package-info.java
+++ b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/package-info.java
@@ -1,3 +1,3 @@
 /** A DNS over HTTPS implementation for OkHttp. */
-@javax.annotation.ParametersAreNonnullByDefault
+@okhttp3.internal.annotations.EverythingIsNonNull
 package okhttp3.dnsoverhttps;
diff --git a/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DnsOverHttpsTest.java b/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DnsOverHttpsTest.java
index 31c8da16ca..c6c16278dd 100644
--- a/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DnsOverHttpsTest.java
+++ b/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DnsOverHttpsTest.java
@@ -20,6 +20,8 @@
 import java.net.InetAddress;
 import java.net.UnknownHostException;
 import java.util.Arrays;
+import java.util.HashSet;
+import java.util.LinkedHashSet;
 import java.util.List;
 import okhttp3.Cache;
 import okhttp3.Dns;
@@ -35,6 +37,7 @@
 import org.junit.Rule;
 import org.junit.Test;
 
+import static java.util.Arrays.asList;
 import static java.util.Collections.singletonList;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
@@ -44,9 +47,8 @@
   @Rule public final MockWebServer server = new MockWebServer();
 
   private final OkHttpClient bootstrapClient =
-      new OkHttpClient.Builder().protocols(Arrays.asList(Protocol.HTTP_2, Protocol.HTTP_1_1))
-          .build();
-  private final Dns dns = buildLocalhost(bootstrapClient);
+      new OkHttpClient.Builder().protocols(asList(Protocol.HTTP_2, Protocol.HTTP_1_1)).build();
+  private Dns dns = buildLocalhost(bootstrapClient, false);
 
   @Before public void setUp() {
     server.setProtocols(bootstrapClient.protocols());
@@ -64,24 +66,38 @@
 
     RecordedRequest recordedRequest = server.takeRequest();
     assertEquals("GET", recordedRequest.getMethod());
-    assertEquals("/lookup?ct&dns=AAABAAACAAAAAAAABmdvb2dsZQNjb20AAAEAAQZnb29nbGUDY29t"
-        + "AAAcAAE", recordedRequest.getPath());
+    assertEquals("/lookup?ct&dns=AAABAAABAAAAAAAABmdvb2dsZQNjb20AAAEAAQ",
+        recordedRequest.getPath());
   }
 
   @Test public void getIpv6() throws Exception {
+    server.enqueue(dnsResponse(
+        "0000818000010003000000000567726170680866616365626f6f6b03636f6d0000010001c00c00050001"
+            + "00000a6d000603617069c012c0300005000100000cde000c04737461720463313072c012c04200010"
+            + "0010000003b00049df00112"));
     server.enqueue(dnsResponse(
         "0000818000010003000000000567726170680866616365626f6f6b03636f6d00001c0001c00c00050001"
             + "00000a1b000603617069c012c0300005000100000b1f000c04737461720463313072c012c042001c0"
             + "0010000003b00102a032880f0290011faceb00c00000002"));
 
+    dns = buildLocalhost(bootstrapClient, true);
+
     List<InetAddress> result = dns.lookup("google.com");
 
-    assertEquals(singletonList(address("2a03:2880:f029:11:face:b00c:0:2")), result);
+    assertEquals(2, result.size());
+    assertTrue(result.contains(address("157.240.1.18")));
+    assertTrue(result.contains(address("2a03:2880:f029:11:face:b00c:0:2")));
 
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals("GET", recordedRequest.getMethod());
-    assertEquals("/lookup?ct&dns=AAABAAACAAAAAAAABmdvb2dsZQNjb20AAAEAAQZnb29nbGUDY29t"
-        + "AAAcAAE", recordedRequest.getPath());
+    RecordedRequest request1 = server.takeRequest();
+    assertEquals("GET", request1.getMethod());
+
+    RecordedRequest request2 = server.takeRequest();
+    assertEquals("GET", request2.getMethod());
+
+    assertEquals(new HashSet<>(
+            Arrays.asList("/lookup?ct&dns=AAABAAABAAAAAAAABmdvb2dsZQNjb20AAAEAAQ",
+                "/lookup?ct&dns=AAABAAABAAAAAAAABmdvb2dsZQNjb20AABwAAQ")),
+        new LinkedHashSet<>(Arrays.asList(request1.getPath(), request2.getPath())));
   }
 
   @Test public void failure() throws Exception {
@@ -100,8 +116,8 @@
 
     RecordedRequest recordedRequest = server.takeRequest();
     assertEquals("GET", recordedRequest.getMethod());
-    assertEquals("/lookup?ct&dns=AAABAAACAAAAAAAABmdvb2dsZQNjb20AAAEAAQZnb29nbGUDY29t"
-        + "AAAcAAE", recordedRequest.getPath());
+    assertEquals("/lookup?ct&dns=AAABAAABAAAAAAAABmdvb2dsZQNjb20AAAEAAQ",
+        recordedRequest.getPath());
   }
 
   @Test public void failOnExcessiveResponse() {
@@ -145,13 +161,12 @@
   @Test public void usesCache() throws Exception {
     Cache cache = new Cache(new File("./target/DnsOverHttpsTest.cache"), 100 * 1024);
     OkHttpClient cachedClient = bootstrapClient.newBuilder().cache(cache).build();
-    DnsOverHttps cachedDns = buildLocalhost(cachedClient);
+    DnsOverHttps cachedDns = buildLocalhost(cachedClient, false);
 
     server.enqueue(dnsResponse(
         "0000818000010003000000000567726170680866616365626f6f6b03636f6d0000010001c00c00050001"
             + "00000a6d000603617069c012c0300005000100000cde000c04737461720463313072c012c04200010"
-            + "0010000003b00049df00112")
-        .setHeader("cache-control", "private, max-age=298"));
+            + "0010000003b00049df00112").setHeader("cache-control", "private, max-age=298"));
 
     List<InetAddress> result = cachedDns.lookup("google.com");
 
@@ -159,23 +174,26 @@
 
     RecordedRequest recordedRequest = server.takeRequest();
     assertEquals("GET", recordedRequest.getMethod());
-    assertEquals("/lookup?ct&dns=AAABAAACAAAAAAAABmdvb2dsZQNjb20AAAEAAQZnb29nbGUDY29t"
-        + "AAAcAAE", recordedRequest.getPath());
+    assertEquals("/lookup?ct&dns=AAABAAABAAAAAAAABmdvb2dsZQNjb20AAAEAAQ",
+        recordedRequest.getPath());
 
     result = cachedDns.lookup("google.com");
     assertEquals(singletonList(address("157.240.1.18")), result);
   }
 
   private MockResponse dnsResponse(String s) {
-    return new MockResponse()
-        .setBody(new Buffer().write(ByteString.decodeHex(s)))
+    return new MockResponse().setBody(new Buffer().write(ByteString.decodeHex(s)))
         .addHeader("content-type", "application/dns-message")
         .addHeader("content-length", s.length() / 2);
   }
 
-  private DnsOverHttps buildLocalhost(OkHttpClient bootstrapClient) {
+  private DnsOverHttps buildLocalhost(OkHttpClient bootstrapClient, boolean includeIPv6) {
     HttpUrl url = server.url("/lookup?ct");
-    return new DnsOverHttps.Builder().client(bootstrapClient).resolvePrivateAddresses(true).url(url).build();
+    return new DnsOverHttps.Builder().client(bootstrapClient)
+        .includeIPv6(includeIPv6)
+        .resolvePrivateAddresses(true)
+        .url(url)
+        .build();
   }
 
   private static InetAddress address(String host) {
diff --git a/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DnsRecordCodecTest.java b/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DnsRecordCodecTest.java
index 32700c2664..3a12b4d254 100644
--- a/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DnsRecordCodecTest.java
+++ b/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DnsRecordCodecTest.java
@@ -22,24 +22,26 @@
 import okio.ByteString;
 import org.junit.Test;
 
+import static okhttp3.dnsoverhttps.DnsRecordCodec.TYPE_A;
+import static okhttp3.dnsoverhttps.DnsRecordCodec.TYPE_AAAA;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 
 public class DnsRecordCodecTest {
   @Test public void testGoogleDotComEncoding() {
-    String encoded = encodeQuery("google.com", false);
+    String encoded = encodeQuery("google.com", TYPE_A);
 
     assertEquals("AAABAAABAAAAAAAABmdvb2dsZQNjb20AAAEAAQ", encoded);
   }
 
-  private String encodeQuery(String host, boolean includeIpv6) {
-    return DnsRecordCodec.encodeQuery(host, includeIpv6).base64Url().replace("=", "");
+  private String encodeQuery(String host, int type) {
+    return DnsRecordCodec.encodeQuery(host, type).base64Url().replace("=", "");
   }
 
   @Test public void testGoogleDotComEncodingWithIPv6() {
-    String encoded = encodeQuery("google.com", true);
+    String encoded = encodeQuery("google.com", TYPE_AAAA);
 
-    assertEquals("AAABAAACAAAAAAAABmdvb2dsZQNjb20AAAEAAQZnb29nbGUDY29tAAAcAAE", encoded);
+    assertEquals("AAABAAABAAAAAAAABmdvb2dsZQNjb20AABwAAQ", encoded);
   }
 
   @Test public void testGoogleDotComDecodingFromCloudflare() throws Exception {
diff --git a/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DohProviders.java b/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DohProviders.java
index 0509e6002e..301eee57ca 100644
--- a/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DohProviders.java
+++ b/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DohProviders.java
@@ -22,8 +22,6 @@
 import okhttp3.HttpUrl;
 import okhttp3.OkHttpClient;
 
-import static okhttp3.dnsoverhttps.DnsOverHttps.UDPWIREFORMAT;
-
 /**
  * Temporary registry of known DNS over HTTPS providers.
  *
@@ -32,9 +30,8 @@
 public class DohProviders {
   static DnsOverHttps buildGoogle(OkHttpClient bootstrapClient) {
     return new DnsOverHttps.Builder().client(bootstrapClient)
-        .url(HttpUrl.get("https://dns.google.com/experimental?ct=" + UDPWIREFORMAT))
+        .url(HttpUrl.get("https://dns.google.com/experimental"))
         .bootstrapDnsHosts(getByIp("216.58.204.78"), getByIp("2a00:1450:4009:814:0:0:0:200e"))
-        .contentType(UDPWIREFORMAT)
         .build();
   }
 
@@ -43,7 +40,6 @@ static DnsOverHttps buildGooglePost(OkHttpClient bootstrapClient) {
         .url(HttpUrl.get("https://dns.google.com/experimental"))
         .bootstrapDnsHosts(getByIp("216.58.204.78"), getByIp("2a00:1450:4009:814:0:0:0:200e"))
         .post(true)
-        .contentType(UDPWIREFORMAT)
         .build();
   }
 
@@ -64,7 +60,7 @@ static DnsOverHttps buildCloudflare(OkHttpClient bootstrapClient) {
 
   static DnsOverHttps buildCloudflarePost(OkHttpClient bootstrapClient) {
     return new DnsOverHttps.Builder().client(bootstrapClient)
-        .url(HttpUrl.get("https://cloudflare-dns.com/dns-query?ct=application/dns-udpwireformat"))
+        .url(HttpUrl.get("https://cloudflare-dns.com/dns-query"))
         .bootstrapDnsHosts(getByIp("104.16.111.25"), getByIp("104.16.112.25"),
             getByIp("2400:cb00:2048:1:0:0:6810:7019"), getByIp("2400:cb00:2048:1:0:0:6810:6f19"))
         .includeIPv6(false)
@@ -74,7 +70,7 @@ static DnsOverHttps buildCloudflarePost(OkHttpClient bootstrapClient) {
 
   static DnsOverHttps buildCleanBrowsing(OkHttpClient bootstrapClient) {
     return new DnsOverHttps.Builder().client(bootstrapClient)
-        .url(HttpUrl.get("https://doh.cleanbrowsing.org/doh/family-filter"))
+        .url(HttpUrl.get("https://doh.cleanbrowsing.org/doh/family-filter/"))
         .includeIPv6(false)
         .build();
   }
@@ -107,11 +103,11 @@ static DnsOverHttps buildCryptoSx(OkHttpClient bootstrapClient) {
     if (!getOnly) {
       result.add(buildCloudflarePost(client));
     }
-    result.add(buildCleanBrowsing(client));
     if (!workingOnly) {
+      //result.add(buildCleanBrowsing(client)); // timeouts
       result.add(buildCryptoSx(client)); // 521 - server down
-      result.add(buildChantra(client)); // 400
     }
+    result.add(buildChantra(client));
 
     return result;
   }
diff --git a/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/TestDohMain.java b/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/TestDohMain.java
index 3c93dfeb91..65975ae5cc 100644
--- a/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/TestDohMain.java
+++ b/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/TestDohMain.java
@@ -27,8 +27,6 @@
 import okhttp3.HttpUrl;
 import okhttp3.OkHttpClient;
 
-import static okhttp3.dnsoverhttps.DnsOverHttps.UDPWIREFORMAT;
-
 public class TestDohMain {
   public static void main(String[] args) throws IOException {
     Security.insertProviderAt(new org.conscrypt.OpenSSLProvider(), 1);
@@ -51,11 +49,7 @@ public static void main(String[] args) throws IOException {
 
       HttpUrl url = HttpUrl.get("https://dns.cloudflare.com/.not-so-well-known/run-dmc-query");
       List<DnsOverHttps> badProviders = Collections.singletonList(
-          new DnsOverHttps.Builder().client(bootstrapClient)
-              .url(url)
-              .post(true)
-              .contentType(UDPWIREFORMAT)
-              .build());
+          new DnsOverHttps.Builder().client(bootstrapClient).url(url).post(true).build());
       runBatch(badProviders, names);
 
       System.out.println("cached first run\n****************\n");
diff --git a/okhttp-hpacktests/pom.xml b/okhttp-hpacktests/pom.xml
index 12bc4e4b49..a2a22ae365 100644
--- a/okhttp-hpacktests/pom.xml
+++ b/okhttp-hpacktests/pom.xml
@@ -8,7 +8,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.5.0-SNAPSHOT</version>
+    <version>3.13.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-hpacktests</artifactId>
diff --git a/okhttp-logging-interceptor/README.md b/okhttp-logging-interceptor/README.md
index f312938fd1..fae2f6e6ca 100644
--- a/okhttp-logging-interceptor/README.md
+++ b/okhttp-logging-interceptor/README.md
@@ -11,7 +11,7 @@ OkHttpClient client = new OkHttpClient.Builder()
   .build();
 ```
 
-You can change the log level at any time by calling `setLevel`.
+You can change the log level at any time by calling `setLevel()`.
 
 To log to a custom location, pass a `Logger` instance to the constructor.
 ```java
@@ -22,11 +22,16 @@ HttpLoggingInterceptor logging = new HttpLoggingInterceptor(new Logger() {
 });
 ```
 
-**Warning**: The logs generated by this interceptor when using the `HEADERS` or `BODY` levels has
+**Warning**: The logs generated by this interceptor when using the `HEADERS` or `BODY` levels have
 the potential to leak sensitive information such as "Authorization" or "Cookie" headers and the
 contents of request and response bodies. This data should only be logged in a controlled way or in
 a non-production environment.
 
+You can redact headers that may contain sensitive information by calling `redactHeader()`.
+```java
+logging.redactHeader("Authorization");
+logging.redactHeader("Cookie");
+```
 
 Download
 --------
diff --git a/okhttp-logging-interceptor/pom.xml b/okhttp-logging-interceptor/pom.xml
index 0e35c12c7b..1841991051 100644
--- a/okhttp-logging-interceptor/pom.xml
+++ b/okhttp-logging-interceptor/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.12.0-SNAPSHOT</version>
+    <version>3.13.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>logging-interceptor</artifactId>
@@ -54,7 +54,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-jar-plugin</artifactId>
-        <version>3.0.2</version>
+        <version>3.1.1</version>
         <configuration>
           <archive>
             <manifestEntries>
diff --git a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java
index e088ea7c64..1c960b74bd 100644
--- a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java
+++ b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java
@@ -18,6 +18,9 @@
 import java.io.EOFException;
 import java.io.IOException;
 import java.nio.charset.Charset;
+import java.util.Collections;
+import java.util.Set;
+import java.util.TreeSet;
 import java.util.concurrent.TimeUnit;
 import okhttp3.Connection;
 import okhttp3.Headers;
@@ -106,11 +109,7 @@
     void log(String message);
 
     /** A {@link Logger} defaults output appropriate for the current platform. */
-    Logger DEFAULT = new Logger() {
-      @Override public void log(String message) {
-        Platform.get().log(INFO, message, null);
-      }
-    };
+    Logger DEFAULT = message -> Platform.get().log(INFO, message, null);
   }
 
   public HttpLoggingInterceptor() {
@@ -123,6 +122,15 @@ public HttpLoggingInterceptor(Logger logger) {
 
   private final Logger logger;
 
+  private volatile Set<String> headersToRedact = Collections.emptySet();
+
+  public void redactHeader(String name) {
+    Set<String> newHeadersToRedact = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);
+    newHeadersToRedact.addAll(headersToRedact);
+    newHeadersToRedact.add(name);
+    headersToRedact = newHeadersToRedact;
+  }
+
   private volatile Level level = Level.NONE;
 
   /** Change the level at which this interceptor logs. */
@@ -177,7 +185,7 @@ public Level getLevel() {
         String name = headers.name(i);
         // Skip headers from the request body as they are explicitly logged above.
         if (!"Content-Type".equalsIgnoreCase(name) && !"Content-Length".equalsIgnoreCase(name)) {
-          logger.log(name + ": " + headers.value(i));
+          logHeader(headers, i);
         }
       }
 
@@ -229,7 +237,7 @@ public Level getLevel() {
     if (logHeaders) {
       Headers headers = response.headers();
       for (int i = 0, count = headers.size(); i < count; i++) {
-        logger.log(headers.name(i) + ": " + headers.value(i));
+        logHeader(headers, i);
       }
 
       if (!logBody || !HttpHeaders.hasBody(response)) {
@@ -239,20 +247,14 @@ public Level getLevel() {
       } else {
         BufferedSource source = responseBody.source();
         source.request(Long.MAX_VALUE); // Buffer the entire body.
-        Buffer buffer = source.buffer();
+        Buffer buffer = source.getBuffer();
 
         Long gzippedLength = null;
         if ("gzip".equalsIgnoreCase(headers.get("Content-Encoding"))) {
           gzippedLength = buffer.size();
-          GzipSource gzippedResponseBody = null;
-          try {
-            gzippedResponseBody = new GzipSource(buffer.clone());
+          try (GzipSource gzippedResponseBody = new GzipSource(buffer.clone())) {
             buffer = new Buffer();
             buffer.writeAll(gzippedResponseBody);
-          } finally {
-            if (gzippedResponseBody != null) {
-              gzippedResponseBody.close();
-            }
           }
         }
 
@@ -285,6 +287,11 @@ public Level getLevel() {
     return response;
   }
 
+  private void logHeader(Headers headers, int i) {
+    String value = headersToRedact.contains(headers.name(i)) ? "‚ñà‚ñà" : headers.value(i);
+    logger.log(headers.name(i) + ": " + value);
+  }
+
   /**
    * Returns true if the body in question probably contains human readable text. Uses a small sample
    * of code points to detect unicode control characters commonly used in binary file signatures.
@@ -309,7 +316,7 @@ static boolean isPlaintext(Buffer buffer) {
     }
   }
 
-  private boolean bodyHasUnknownEncoding(Headers headers) {
+  private static boolean bodyHasUnknownEncoding(Headers headers) {
     String contentEncoding = headers.get("Content-Encoding");
     return contentEncoding != null
         && !contentEncoding.equalsIgnoreCase("identity")
diff --git a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/LoggingEventListener.java b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/LoggingEventListener.java
new file mode 100644
index 0000000000..da38261bfb
--- /dev/null
+++ b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/LoggingEventListener.java
@@ -0,0 +1,178 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.logging;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.Proxy;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+import javax.annotation.Nullable;
+import okhttp3.Call;
+import okhttp3.Connection;
+import okhttp3.EventListener;
+import okhttp3.Handshake;
+import okhttp3.OkHttpClient;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.Response;
+
+/**
+ * An OkHttp EventListener, which logs call events. Can be applied as an
+ * {@linkplain OkHttpClient#eventListenerFactory() event listener factory}.
+ *
+ * <p>The format of the logs created by this class should not be considered stable and may change
+ * slightly between releases. If you need a stable logging format, use your own event listener.
+ */
+public final class LoggingEventListener extends EventListener {
+  private final HttpLoggingInterceptor.Logger logger;
+  private long startNs;
+
+  private LoggingEventListener(HttpLoggingInterceptor.Logger logger) {
+    this.logger = logger;
+  }
+
+  @Override
+  public void callStart(Call call) {
+    startNs = System.nanoTime();
+
+    logWithTime("callStart: " + call.request());
+  }
+
+  @Override
+  public void dnsStart(Call call, String domainName) {
+    logWithTime("dnsStart: " + domainName);
+  }
+
+  @Override
+  public void dnsEnd(Call call, String domainName, List<InetAddress> inetAddressList) {
+    logWithTime("dnsEnd: " + inetAddressList);
+  }
+
+  @Override
+  public void connectStart(Call call, InetSocketAddress inetSocketAddress, Proxy proxy) {
+    logWithTime("connectStart: " + inetSocketAddress + " " + proxy);
+  }
+
+  @Override
+  public void secureConnectStart(Call call) {
+    logWithTime("secureConnectStart");
+  }
+
+  @Override
+  public void secureConnectEnd(Call call, @Nullable Handshake handshake) {
+    logWithTime("secureConnectEnd: " + handshake);
+  }
+
+  @Override
+  public void connectEnd(
+      Call call, InetSocketAddress inetSocketAddress, Proxy proxy, @Nullable Protocol protocol) {
+    logWithTime("connectEnd: " + protocol);
+  }
+
+  @Override
+  public void connectFailed(
+      Call call,
+      InetSocketAddress inetSocketAddress,
+      Proxy proxy,
+      @Nullable Protocol protocol,
+      IOException ioe) {
+    logWithTime("connectFailed: " + protocol + " " + ioe);
+  }
+
+  @Override
+  public void connectionAcquired(Call call, Connection connection) {
+    logWithTime("connectionAcquired: " + connection);
+  }
+
+  @Override
+  public void connectionReleased(Call call, Connection connection) {
+    logWithTime("connectionReleased");
+  }
+
+  @Override
+  public void requestHeadersStart(Call call) {
+    logWithTime("requestHeadersStart");
+  }
+
+  @Override
+  public void requestHeadersEnd(Call call, Request request) {
+    logWithTime("requestHeadersEnd");
+  }
+
+  @Override
+  public void requestBodyStart(Call call) {
+    logWithTime("requestBodyStart");
+  }
+
+  @Override
+  public void requestBodyEnd(Call call, long byteCount) {
+    logWithTime("requestBodyEnd: byteCount=" + byteCount);
+  }
+
+  @Override
+  public void responseHeadersStart(Call call) {
+    logWithTime("responseHeadersStart");
+  }
+
+  @Override
+  public void responseHeadersEnd(Call call, Response response) {
+    logWithTime("responseHeadersEnd: " + response);
+  }
+
+  @Override
+  public void responseBodyStart(Call call) {
+    logWithTime("responseBodyStart");
+  }
+
+  @Override
+  public void responseBodyEnd(Call call, long byteCount) {
+    logWithTime("responseBodyEnd: byteCount=" + byteCount);
+  }
+
+  @Override
+  public void callEnd(Call call) {
+    logWithTime("callEnd");
+  }
+
+  @Override
+  public void callFailed(Call call, IOException ioe) {
+    logWithTime("callFailed: " + ioe);
+  }
+
+  private void logWithTime(String message) {
+    long timeMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNs);
+    logger.log("[" + timeMs + " ms] " + message);
+  }
+
+  public static class Factory implements EventListener.Factory {
+    private final HttpLoggingInterceptor.Logger logger;
+
+    public Factory() {
+      this(HttpLoggingInterceptor.Logger.DEFAULT);
+    }
+
+    public Factory(HttpLoggingInterceptor.Logger logger) {
+      this.logger = logger;
+    }
+
+    @Override
+    public EventListener create(Call call) {
+      return new LoggingEventListener(logger);
+    }
+  }
+}
diff --git a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/package-info.java b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/package-info.java
index 39904701cf..62d0ff5761 100644
--- a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/package-info.java
+++ b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/package-info.java
@@ -1,3 +1,3 @@
 /** An OkHttp interceptor which logs HTTP request and response data. */
-@javax.annotation.ParametersAreNonnullByDefault
+@okhttp3.internal.annotations.EverythingIsNonNull
 package okhttp3.logging;
diff --git a/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java b/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java
index ffac19fd69..bd4b8f79bc 100644
--- a/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java
+++ b/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java
@@ -16,13 +16,11 @@
 package okhttp3.logging;
 
 import java.io.IOException;
-import java.net.InetAddress;
 import java.net.UnknownHostException;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.regex.Pattern;
 import javax.net.ssl.HostnameVerifier;
-import okhttp3.Dns;
 import okhttp3.HttpUrl;
 import okhttp3.MediaType;
 import okhttp3.OkHttpClient;
@@ -58,8 +56,8 @@
 
   @Rule public final MockWebServer server = new MockWebServer();
 
-  private HandshakeCertificates handshakeCertificates = localhost();
-  private HostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
+  private final HandshakeCertificates handshakeCertificates = localhost();
+  private final HostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
   private OkHttpClient client;
   private String host;
   private HttpUrl url;
@@ -649,7 +647,7 @@ private void bodyGetNoBody(int code) throws IOException {
         .assertNoMoreLogs();
   }
 
-  @Test public void isPlaintext() throws IOException {
+  @Test public void isPlaintext() {
     assertTrue(HttpLoggingInterceptor.isPlaintext(new Buffer()));
     assertTrue(HttpLoggingInterceptor.isPlaintext(new Buffer().writeUtf8("abc")));
     assertTrue(HttpLoggingInterceptor.isPlaintext(new Buffer().writeUtf8("new\r\nlines")));
@@ -704,11 +702,7 @@ private void bodyGetNoBody(int code) throws IOException {
   @Test public void connectFail() throws IOException {
     setLevel(Level.BASIC);
     client = new OkHttpClient.Builder()
-        .dns(new Dns() {
-          @Override public List<InetAddress> lookup(String hostname) throws UnknownHostException {
-            throw new UnknownHostException("reason");
-          }
-        })
+        .dns(hostname -> { throw new UnknownHostException("reason"); })
         .addInterceptor(applicationInterceptor)
         .build();
 
@@ -745,11 +739,68 @@ private void bodyGetNoBody(int code) throws IOException {
         .assertNoMoreLogs();
   }
 
+  @Test
+  public void headersAreRedacted() throws Exception {
+    HttpLoggingInterceptor networkInterceptor =
+        new HttpLoggingInterceptor(networkLogs).setLevel(Level.HEADERS);
+    networkInterceptor.redactHeader("sEnSiTiVe");
+
+    HttpLoggingInterceptor applicationInterceptor =
+        new HttpLoggingInterceptor(applicationLogs).setLevel(Level.HEADERS);
+    applicationInterceptor.redactHeader("sEnSiTiVe");
+
+    client =
+        new OkHttpClient.Builder()
+            .addNetworkInterceptor(networkInterceptor)
+            .addInterceptor(applicationInterceptor)
+            .build();
+
+    server.enqueue(
+        new MockResponse().addHeader("SeNsItIvE", "Value").addHeader("Not-Sensitive", "Value"));
+    Response response =
+        client
+            .newCall(
+                request()
+                    .addHeader("SeNsItIvE", "Value")
+                    .addHeader("Not-Sensitive", "Value")
+                    .build())
+            .execute();
+    response.body().close();
+
+    applicationLogs
+        .assertLogEqual("--> GET " + url)
+        .assertLogEqual("SeNsItIvE: ‚ñà‚ñà")
+        .assertLogEqual("Not-Sensitive: Value")
+        .assertLogEqual("--> END GET")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 0")
+        .assertLogEqual("SeNsItIvE: ‚ñà‚ñà")
+        .assertLogEqual("Not-Sensitive: Value")
+        .assertLogEqual("<-- END HTTP")
+        .assertNoMoreLogs();
+
+    networkLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("SeNsItIvE: ‚ñà‚ñà")
+        .assertLogEqual("Not-Sensitive: Value")
+        .assertLogEqual("Host: " + host)
+        .assertLogEqual("Connection: Keep-Alive")
+        .assertLogEqual("Accept-Encoding: gzip")
+        .assertLogMatch("User-Agent: okhttp/.+")
+        .assertLogEqual("--> END GET")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 0")
+        .assertLogEqual("SeNsItIvE: ‚ñà‚ñà")
+        .assertLogEqual("Not-Sensitive: Value")
+        .assertLogEqual("<-- END HTTP")
+        .assertNoMoreLogs();
+  }
+
   private Request.Builder request() {
     return new Request.Builder().url(url);
   }
 
-  private static class LogRecorder implements HttpLoggingInterceptor.Logger {
+  static class LogRecorder implements HttpLoggingInterceptor.Logger {
     private final List<String> logs = new ArrayList<>();
     private int index;
 
@@ -769,7 +820,7 @@ LogRecorder assertLogMatch(String pattern) {
     }
 
     void assertNoMoreLogs() {
-      assertTrue("More messages remain: " + logs.subList(index, logs.size()), index == logs.size());
+      assertEquals("More messages remain: " + logs.subList(index, logs.size()), index, logs.size());
     }
 
     @Override public void log(String message) {
diff --git a/okhttp-logging-interceptor/src/test/java/okhttp3/logging/LoggingEventListenerTest.java b/okhttp-logging-interceptor/src/test/java/okhttp3/logging/LoggingEventListenerTest.java
new file mode 100644
index 0000000000..84aecb571c
--- /dev/null
+++ b/okhttp-logging-interceptor/src/test/java/okhttp3/logging/LoggingEventListenerTest.java
@@ -0,0 +1,223 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.logging;
+
+import java.io.IOException;
+import java.net.UnknownHostException;
+import okhttp3.HttpUrl;
+import okhttp3.MediaType;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.SocketPolicy;
+import okhttp3.tls.HandshakeCertificates;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+
+import static okhttp3.tls.internal.TlsUtil.localhost;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.fail;
+
+public final class LoggingEventListenerTest {
+  private static final MediaType PLAIN = MediaType.get("text/plain");
+
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private final HandshakeCertificates handshakeCertificates = localhost();
+  private final LogRecorder logRecorder = new LogRecorder();
+  private final LoggingEventListener.Factory loggingEventListenerFactory =
+      new LoggingEventListener.Factory(logRecorder);
+  private OkHttpClient client;
+  private HttpUrl url;
+
+  @Before
+  public void setUp() {
+    client =
+        new OkHttpClient.Builder()
+            .eventListenerFactory(loggingEventListenerFactory)
+            .sslSocketFactory(
+                handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
+            .retryOnConnectionFailure(false)
+            .build();
+
+    url = server.url("/");
+  }
+
+  @Test
+  public void get() throws Exception {
+    server.enqueue(new MockResponse().setBody("Hello!").setHeader("Content-Type", PLAIN));
+    Response response = client.newCall(request().build()).execute();
+    assertNotNull(response.body());
+    response.body().bytes();
+
+    logRecorder
+        .assertLogMatch("callStart: Request\\{method=GET, url=" + url + ", tags=\\{\\}\\}")
+        .assertLogMatch("dnsStart: " + url.host())
+        .assertLogMatch("dnsEnd: \\[.+\\]")
+        .assertLogMatch("connectStart: " + url.host() + "/.+ DIRECT")
+        .assertLogMatch("connectEnd: http/1.1")
+        .assertLogMatch(
+            "connectionAcquired: Connection\\{"
+                + url.host()
+                + ":\\d+, proxy=DIRECT hostAddress="
+                + url.host()
+                + "/.+ cipherSuite=none protocol=http/1\\.1\\}")
+        .assertLogMatch("requestHeadersStart")
+        .assertLogMatch("requestHeadersEnd")
+        .assertLogMatch("responseHeadersStart")
+        .assertLogMatch(
+            "responseHeadersEnd: Response\\{protocol=http/1\\.1, code=200, message=OK, url="
+                + url
+                + "}")
+        .assertLogMatch("responseBodyStart")
+        .assertLogMatch("responseBodyEnd: byteCount=6")
+        .assertLogMatch("connectionReleased")
+        .assertLogMatch("callEnd")
+        .assertNoMoreLogs();
+  }
+
+  @Test
+  public void post() throws IOException {
+    server.enqueue(new MockResponse());
+    client.newCall(request().post(RequestBody.create(PLAIN, "Hello!")).build()).execute();
+
+    logRecorder
+        .assertLogMatch("callStart: Request\\{method=POST, url=" + url + ", tags=\\{\\}\\}")
+        .assertLogMatch("dnsStart: " + url.host())
+        .assertLogMatch("dnsEnd: \\[.+\\]")
+        .assertLogMatch("connectStart: " + url.host() + "/.+ DIRECT")
+        .assertLogMatch("connectEnd: http/1.1")
+        .assertLogMatch(
+            "connectionAcquired: Connection\\{"
+                + url.host()
+                + ":\\d+, proxy=DIRECT hostAddress="
+                + url.host()
+                + "/.+ cipherSuite=none protocol=http/1\\.1\\}")
+        .assertLogMatch("requestHeadersStart")
+        .assertLogMatch("requestHeadersEnd")
+        .assertLogMatch("requestBodyStart")
+        .assertLogMatch("requestBodyEnd: byteCount=6")
+        .assertLogMatch("responseHeadersStart")
+        .assertLogMatch(
+            "responseHeadersEnd: Response\\{protocol=http/1\\.1, code=200, message=OK, url="
+                + url
+                + "}")
+        .assertLogMatch("responseBodyStart")
+        .assertLogMatch("responseBodyEnd: byteCount=0")
+        .assertLogMatch("connectionReleased")
+        .assertLogMatch("callEnd")
+        .assertNoMoreLogs();
+  }
+
+  @Test
+  public void secureGet() throws Exception {
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
+    url = server.url("/");
+
+    server.enqueue(new MockResponse());
+    Response response = client.newCall(request().build()).execute();
+    assertNotNull(response.body());
+    response.body().bytes();
+
+    logRecorder
+        .assertLogMatch("callStart: Request\\{method=GET, url=" + url + ", tags=\\{\\}\\}")
+        .assertLogMatch("dnsStart: " + url.host())
+        .assertLogMatch("dnsEnd: \\[.+\\]")
+        .assertLogMatch("connectStart: " + url.host() + "/.+ DIRECT")
+        .assertLogMatch("secureConnectStart")
+        .assertLogMatch("secureConnectEnd: Handshake\\{"
+            + "tlsVersion=TLS_1_2 "
+            + "cipherSuite=TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 "
+            + "peerCertificates=\\[CN=localhost\\] "
+            + "localCertificates=\\[\\]}")
+        .assertLogMatch("connectEnd: h2")
+        .assertLogMatch(
+            "connectionAcquired: Connection\\{"
+                + url.host()
+                + ":\\d+, proxy=DIRECT hostAddress="
+                + url.host()
+                + "/.+ cipherSuite=.+ protocol=h2}")
+        .assertLogMatch("requestHeadersStart")
+        .assertLogMatch("requestHeadersEnd")
+        .assertLogMatch("responseHeadersStart")
+        .assertLogMatch(
+            "responseHeadersEnd: Response\\{protocol=h2, code=200, message=, url=" + url + "}")
+        .assertLogMatch("responseBodyStart")
+        .assertLogMatch("responseBodyEnd: byteCount=0")
+        .assertLogMatch("connectionReleased")
+        .assertLogMatch("callEnd")
+        .assertNoMoreLogs();
+  }
+
+  @Test
+  public void dnsFail() throws IOException {
+    client = new OkHttpClient.Builder()
+        .dns(hostname -> { throw new UnknownHostException("reason"); })
+        .eventListenerFactory(loggingEventListenerFactory)
+        .build();
+
+    try {
+      client.newCall(request().build()).execute();
+      fail();
+    } catch (UnknownHostException expected) {
+    }
+
+    logRecorder
+        .assertLogMatch("callStart: Request\\{method=GET, url=" + url + ", tags=\\{\\}\\}")
+        .assertLogMatch("dnsStart: " + url.host())
+        .assertLogMatch("callFailed: java.net.UnknownHostException: reason")
+        .assertNoMoreLogs();
+  }
+
+  @Test
+  public void connectFail() {
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
+    url = server.url("/");
+
+    try {
+      client.newCall(request().build()).execute();
+      fail();
+    } catch (IOException expected) {
+    }
+
+    logRecorder
+        .assertLogMatch("callStart: Request\\{method=GET, url=" + url + ", tags=\\{\\}\\}")
+        .assertLogMatch("dnsStart: " + url.host())
+        .assertLogMatch("dnsEnd: \\[.+\\]")
+        .assertLogMatch("connectStart: " + url.host() + "/.+ DIRECT")
+        .assertLogMatch("secureConnectStart")
+        .assertLogMatch(
+            "connectFailed: null javax\\.net\\.ssl\\.SSLProtocolException: Handshake message sequence violation, 1")
+        .assertLogMatch(
+            "callFailed: javax.net.ssl.SSLProtocolException: Handshake message sequence violation, 1")
+        .assertNoMoreLogs();
+  }
+
+  private Request.Builder request() {
+    return new Request.Builder().url(url);
+  }
+
+  private static class LogRecorder extends HttpLoggingInterceptorTest.LogRecorder {
+    LogRecorder assertLogMatch(String pattern) {
+      return (LogRecorder) super.assertLogMatch("\\[\\d+ ms] " + pattern);
+    }
+  }
+}
diff --git a/okhttp-sse/pom.xml b/okhttp-sse/pom.xml
index b46d96f098..bfeb54327f 100644
--- a/okhttp-sse/pom.xml
+++ b/okhttp-sse/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.12.0-SNAPSHOT</version>
+    <version>3.13.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-sse</artifactId>
@@ -48,8 +48,9 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-javadoc-plugin</artifactId>
-        <version>2.10.4</version>
+        <version>3.0.1</version>
         <configuration>
+          <excludePackageNames>okhttp3.internal:okhttp3.internal.*</excludePackageNames>
           <links>
             <link>http://square.github.io/okhttp/javadoc/</link>
           </links>
@@ -58,7 +59,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-jar-plugin</artifactId>
-        <version>3.0.2</version>
+        <version>3.1.1</version>
         <configuration>
           <archive>
             <manifestEntries>
diff --git a/okhttp-sse/src/main/java/okhttp3/internal/sse/RealEventSource.java b/okhttp-sse/src/main/java/okhttp3/internal/sse/RealEventSource.java
index be60122fa1..c49e49f4aa 100644
--- a/okhttp-sse/src/main/java/okhttp3/internal/sse/RealEventSource.java
+++ b/okhttp-sse/src/main/java/okhttp3/internal/sse/RealEventSource.java
@@ -35,7 +35,7 @@
   private final Request request;
   private final EventSourceListener listener;
 
-  private Call call;
+  private @Nullable Call call;
 
   public RealEventSource(Request request, EventSourceListener listener) {
     this.request = request;
@@ -47,6 +47,7 @@ public void connect(OkHttpClient client) {
         .eventListener(EventListener.NONE)
         .build();
     call = client.newCall(request);
+    call.timeout().clearTimeout();
     call.enqueue(this);
   }
 
diff --git a/okhttp-sse/src/main/java/okhttp3/internal/sse/ServerSentEventReader.java b/okhttp-sse/src/main/java/okhttp3/internal/sse/ServerSentEventReader.java
index 0e0e775fb6..ae19d3745e 100644
--- a/okhttp-sse/src/main/java/okhttp3/internal/sse/ServerSentEventReader.java
+++ b/okhttp-sse/src/main/java/okhttp3/internal/sse/ServerSentEventReader.java
@@ -63,7 +63,7 @@ boolean processNextEvent() throws IOException {
         return false;
       }
 
-      switch (source.buffer().getByte(0)) {
+      switch (source.getBuffer().getByte(0)) {
         case '\r':
         case '\n':
           completeEvent(id, type, data);
@@ -162,7 +162,7 @@ private void parseRetry(long end) throws IOException {
    */
   private boolean isKey(ByteString key) throws IOException {
     if (source.rangeEquals(0, key)) {
-      byte nextByte = source.buffer().getByte(key.size());
+      byte nextByte = source.getBuffer().getByte(key.size());
       return nextByte == ':'
           || nextByte == '\r'
           || nextByte == '\n';
@@ -174,7 +174,7 @@ private boolean isKey(ByteString key) throws IOException {
   private void skipCrAndOrLf() throws IOException {
     if ((source.readByte() & 0xff) == '\r'
         && source.request(1)
-        && source.buffer().getByte(0) == '\n') {
+        && source.getBuffer().getByte(0) == '\n') {
       source.skip(1);
     }
   }
@@ -186,11 +186,11 @@ private void skipCrAndOrLf() throws IOException {
   private long skipNameAndDivider(long length) throws IOException {
     source.skip(length);
 
-    if (source.buffer().getByte(0) == ':') {
+    if (source.getBuffer().getByte(0) == ':') {
       source.skip(1L);
       length++;
 
-      if (source.buffer().getByte(0) == ' ') {
+      if (source.getBuffer().getByte(0) == ' ') {
         source.skip(1);
         length++;
       }
diff --git a/okhttp-sse/src/main/java/okhttp3/internal/sse/package-info.java b/okhttp-sse/src/main/java/okhttp3/internal/sse/package-info.java
index 5993b09cdc..afcf5f4f9d 100644
--- a/okhttp-sse/src/main/java/okhttp3/internal/sse/package-info.java
+++ b/okhttp-sse/src/main/java/okhttp3/internal/sse/package-info.java
@@ -1,3 +1,3 @@
 /** Private support classes for server-sent events. */
-@javax.annotation.ParametersAreNonnullByDefault
+@okhttp3.internal.annotations.EverythingIsNonNull
 package okhttp3.internal.sse;
diff --git a/okhttp-sse/src/main/java/okhttp3/sse/EventSources.java b/okhttp-sse/src/main/java/okhttp3/sse/EventSources.java
index 77f596c5f2..db0c818d54 100644
--- a/okhttp-sse/src/main/java/okhttp3/sse/EventSources.java
+++ b/okhttp-sse/src/main/java/okhttp3/sse/EventSources.java
@@ -16,18 +16,15 @@
 package okhttp3.sse;
 
 import okhttp3.OkHttpClient;
-import okhttp3.Request;
 import okhttp3.Response;
 import okhttp3.internal.sse.RealEventSource;
 
 public final class EventSources {
   public static EventSource.Factory createFactory(final OkHttpClient client) {
-    return new EventSource.Factory() {
-      @Override public EventSource newEventSource(Request request, EventSourceListener listener) {
-        RealEventSource eventSource = new RealEventSource(request, listener);
-        eventSource.connect(client);
-        return eventSource;
-      }
+    return (request, listener) -> {
+      RealEventSource eventSource = new RealEventSource(request, listener);
+      eventSource.connect(client);
+      return eventSource;
     };
   }
 
diff --git a/okhttp-sse/src/main/java/okhttp3/sse/package-info.java b/okhttp-sse/src/main/java/okhttp3/sse/package-info.java
index 6777492c9c..2a5f883883 100644
--- a/okhttp-sse/src/main/java/okhttp3/sse/package-info.java
+++ b/okhttp-sse/src/main/java/okhttp3/sse/package-info.java
@@ -1,3 +1,3 @@
 /** Support for server-sent events. */
-@javax.annotation.ParametersAreNonnullByDefault
+@okhttp3.internal.annotations.EverythingIsNonNull
 package okhttp3.sse;
diff --git a/okhttp-sse/src/test/java/okhttp3/internal/sse/Event.java b/okhttp-sse/src/test/java/okhttp3/internal/sse/Event.java
index 149be0014c..fade2b978a 100644
--- a/okhttp-sse/src/test/java/okhttp3/internal/sse/Event.java
+++ b/okhttp-sse/src/test/java/okhttp3/internal/sse/Event.java
@@ -15,6 +15,7 @@
  */
 package okhttp3.internal.sse;
 
+import java.util.Objects;
 import javax.annotation.Nullable;
 
 final class Event {
@@ -37,14 +38,14 @@
     if (this == o) return true;
     if (!(o instanceof Event)) return false;
     Event other = (Event) o;
-    return (id != null ? id.equals(other.id) : other.id == null)
-        && (type != null ? type.equals(other.type) : other.type == null)
+    return Objects.equals(id, other.id)
+        && Objects.equals(type, other.type)
         && data.equals(other.data);
   }
 
   @Override public int hashCode() {
-    int result = (id != null ? id.hashCode() : 0);
-    result = 31 * result + (type != null ? type.hashCode() : 0);
+    int result = Objects.hashCode(id);
+    result = 31 * result + Objects.hashCode(type);
     result = 31 * result + data.hashCode();
     return result;
   }
diff --git a/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceHttpTest.java b/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceHttpTest.java
index ffdabbcd14..7f576eece9 100644
--- a/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceHttpTest.java
+++ b/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceHttpTest.java
@@ -15,6 +15,7 @@
  */
 package okhttp3.internal.sse;
 
+import java.util.concurrent.TimeUnit;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
 import okhttp3.mockwebserver.MockResponse;
@@ -25,13 +26,14 @@
 import org.junit.Rule;
 import org.junit.Test;
 
+import static okhttp3.TestUtil.defaultClient;
 import static org.junit.Assert.assertEquals;
 
 public final class EventSourceHttpTest {
   @Rule public final MockWebServer server = new MockWebServer();
 
   private final EventSourceRecorder listener = new EventSourceRecorder();
-  private final EventSource.Factory factory = EventSources.createFactory(new OkHttpClient());
+  private OkHttpClient client = defaultClient();
 
   @After public void after() {
     listener.assertExhausted();
@@ -69,10 +71,30 @@
     listener.assertFailure(null);
   }
 
+  @Test public void callTimeoutIsNotApplied() throws Exception {
+    client = client.newBuilder()
+        .callTimeout(100, TimeUnit.MILLISECONDS)
+        .build();
+
+    server.enqueue(new MockResponse()
+        .setBodyDelay(500, TimeUnit.MILLISECONDS)
+        .setHeader("content-type", "text/event-stream")
+        .setBody("data: hey\n\n"));
+
+    EventSource source = newEventSource();
+
+    assertEquals("/", source.request().url().encodedPath());
+
+    listener.assertOpen();
+    listener.assertEvent(null, null, "hey");
+    listener.assertClose();
+  }
+
   private EventSource newEventSource() {
     Request request = new Request.Builder()
         .url(server.url("/"))
         .build();
+    EventSource.Factory factory = EventSources.createFactory(client);
     return factory.newEventSource(request, listener);
   }
 }
diff --git a/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceRecorder.java b/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceRecorder.java
index 2d2c8afce1..cf4afd4ec9 100644
--- a/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceRecorder.java
+++ b/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceRecorder.java
@@ -49,7 +49,7 @@
   }
 
   @Override
-  public void onFailure(EventSource eventSource, Throwable t, @Nullable Response response) {
+  public void onFailure(EventSource eventSource, @Nullable Throwable t, @Nullable Response response) {
     Platform.get().log(Platform.INFO, "[ES] onFailure", t);
     events.add(new Failure(t, response));
   }
diff --git a/okhttp-testing-support/pom.xml b/okhttp-testing-support/pom.xml
index e8cb9aee54..8457273d97 100644
--- a/okhttp-testing-support/pom.xml
+++ b/okhttp-testing-support/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.12.0-SNAPSHOT</version>
+    <version>3.13.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-testing-support</artifactId>
@@ -35,7 +35,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-jar-plugin</artifactId>
-        <version>3.0.2</version>
+        <version>3.1.1</version>
         <configuration>
           <archive>
             <manifestEntries>
diff --git a/okhttp-tests/src/test/java/okhttp3/TestUtil.java b/okhttp-testing-support/src/main/java/okhttp3/TestUtil.java
similarity index 63%
rename from okhttp-tests/src/test/java/okhttp3/TestUtil.java
rename to okhttp-testing-support/src/main/java/okhttp3/TestUtil.java
index 4957087cf7..81b47ddf55 100644
--- a/okhttp-tests/src/test/java/okhttp3/TestUtil.java
+++ b/okhttp-testing-support/src/main/java/okhttp3/TestUtil.java
@@ -1,16 +1,41 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package okhttp3;
 
+import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.List;
-import okhttp3.internal.SingleInetAddressDns;
 import okhttp3.internal.http2.Header;
 
 public final class TestUtil {
   public static final InetSocketAddress UNREACHABLE_ADDRESS
       = new InetSocketAddress("198.51.100.1", 8080);
 
+  /**
+   * A network that resolves only one IP address per host. Use this when testing route selection
+   * fallbacks to prevent the host machine's various IP addresses from interfering.
+   */
+  private static final Dns SINGLE_INET_ADDRESS_DNS = hostname -> {
+    List<InetAddress> addresses = Dns.SYSTEM.lookup(hostname);
+    return Collections.singletonList(addresses.get(0));
+  };
+
   private TestUtil() {
   }
 
@@ -30,7 +55,7 @@ public static OkHttpClient defaultClient() {
     return new OkHttpClient.Builder()
         .connectionPool(connectionPool)
         .dispatcher(dispatcher)
-        .dns(new SingleInetAddressDns()) // Prevent unexpected fallback addresses.
+        .dns(SINGLE_INET_ADDRESS_DNS) // Prevent unexpected fallback addresses.
         .build();
   }
 
diff --git a/okhttp-testing-support/src/main/java/okhttp3/testing/InstallUncaughtExceptionHandlerListener.java b/okhttp-testing-support/src/main/java/okhttp3/testing/InstallUncaughtExceptionHandlerListener.java
index ae034cd9a6..c1768dcd4b 100644
--- a/okhttp-testing-support/src/main/java/okhttp3/testing/InstallUncaughtExceptionHandlerListener.java
+++ b/okhttp-testing-support/src/main/java/okhttp3/testing/InstallUncaughtExceptionHandlerListener.java
@@ -38,24 +38,22 @@
   @Override public void testRunStarted(Description description) {
     System.err.println("Installing aggressive uncaught exception handler");
     oldDefaultUncaughtExceptionHandler = Thread.getDefaultUncaughtExceptionHandler();
-    Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
-      @Override public void uncaughtException(Thread thread, Throwable throwable) {
-        StringWriter errorText = new StringWriter(256);
-        errorText.append("Uncaught exception in OkHttp thread \"");
-        errorText.append(thread.getName());
-        errorText.append("\"\n");
-        throwable.printStackTrace(new PrintWriter(errorText));
+    Thread.setDefaultUncaughtExceptionHandler((thread, throwable) -> {
+      StringWriter errorText = new StringWriter(256);
+      errorText.append("Uncaught exception in OkHttp thread \"");
+      errorText.append(thread.getName());
+      errorText.append("\"\n");
+      throwable.printStackTrace(new PrintWriter(errorText));
+      errorText.append("\n");
+      if (lastTestStarted != null) {
+        errorText.append("Last test to start was: ");
+        errorText.append(lastTestStarted.getDisplayName());
         errorText.append("\n");
-        if (lastTestStarted != null) {
-          errorText.append("Last test to start was: ");
-          errorText.append(lastTestStarted.getDisplayName());
-          errorText.append("\n");
-        }
-        System.err.print(errorText.toString());
+      }
+      System.err.print(errorText.toString());
 
-        synchronized (exceptions) {
-          exceptions.put(throwable, lastTestStarted.getDisplayName());
-        }
+      synchronized (exceptions) {
+        exceptions.put(throwable, lastTestStarted.getDisplayName());
       }
     });
   }
diff --git a/okhttp-tests/pom.xml b/okhttp-tests/pom.xml
index 024714f310..bd1dbd73da 100644
--- a/okhttp-tests/pom.xml
+++ b/okhttp-tests/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.12.0-SNAPSHOT</version>
+    <version>3.13.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-tests</artifactId>
@@ -97,7 +97,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-deploy-plugin</artifactId>
-        <version>2.7</version>
+        <version>2.8.2</version>
         <configuration>
           <skip>true</skip>
         </configuration>
diff --git a/okhttp-tests/src/main/java/okhttp3/TestTls13Request.java b/okhttp-tests/src/main/java/okhttp3/TestTls13Request.java
index d288cad0a1..9e954b95fe 100644
--- a/okhttp-tests/src/main/java/okhttp3/TestTls13Request.java
+++ b/okhttp-tests/src/main/java/okhttp3/TestTls13Request.java
@@ -6,61 +6,61 @@
 import java.util.List;
 import okhttp3.internal.platform.Platform;
 import org.conscrypt.Conscrypt;
-import org.conscrypt.OpenSSLProvider;
 
 public class TestTls13Request {
+
+  // TLS 1.3
+  private static final CipherSuite[] TLS13_CIPHER_SUITES = new CipherSuite[] {
+      CipherSuite.TLS_AES_128_GCM_SHA256,
+      CipherSuite.TLS_AES_256_GCM_SHA384,
+      CipherSuite.TLS_CHACHA20_POLY1305_SHA256,
+      CipherSuite.TLS_AES_128_CCM_SHA256,
+      CipherSuite.TLS_AES_256_CCM_8_SHA256
+  };
+
+  /**
+   * A TLS 1.3 only Connection Spec. This will be eventually be exposed
+   * as part of MODERN_TLS or folded into the default OkHttp client once published and
+   * available in JDK11 or Conscrypt.
+   */
+  private static final ConnectionSpec TLS_13 = new ConnectionSpec.Builder(true)
+      .cipherSuites(TLS13_CIPHER_SUITES)
+      .tlsVersions(TlsVersion.TLS_1_3)
+      .build();
+
+
+  private static final ConnectionSpec TLS_12 =
+      new ConnectionSpec.Builder(ConnectionSpec.RESTRICTED_TLS).tlsVersions(TlsVersion.TLS_1_2)
+          .build();
+
   private TestTls13Request() {
   }
 
   public static void main(String[] args) {
-    String spec28 = Integer.toString(0x7f00 | 28, 16);
-    System.setProperty("jdk.tls13.version", spec28);
-
     //System.setProperty("javax.net.debug", "ssl:handshake:verbose");
+    Security.insertProviderAt(Conscrypt.newProviderBuilder().provideTrustManager().build(), 1);
 
-    System.out.println("Running tests using "
-        + Platform.get().getClass().getSimpleName()
-        + " "
-        + System.getProperty("java.vm.version"));
-
-    // Allow for TLS_CHACHA20_POLY1305_SHA256 cipher suite
-    if (Conscrypt.isAvailable()) {
-      Security.addProvider(new OpenSSLProvider());
-    }
+    System.out.println(
+        "Running tests using " + Platform.get() + " " + System.getProperty("java.vm.version"));
 
     // https://github.com/tlswg/tls13-spec/wiki/Implementations
     List<String> urls =
         Arrays.asList("https://enabled.tls13.com", "https://www.howsmyssl.com/a/check",
             "https://tls13.cloudflare.com", "https://www.allizom.org/robots.txt",
-            "https://tls13.crypto.mozilla.org/", "https://tls.ctf.network/",
+            "https://tls13.crypto.mozilla.org/", "https://tls.ctf.network/robots.txt",
             "https://rustls.jbp.io/", "https://h2o.examp1e.net", "https://mew.org/",
-            "https://tls13.baishancloud.com/", "https://tls13.akamai.io/", "https://swifttls.org/");
-
-    System.out.println("TLS1.3 only");
-    testClient(urls, buildClient(ConnectionSpec.TLS_13));
-
-    System.out.println("TLS1.3 then fallback");
-    testClient(urls, buildClient(ConnectionSpec.TLS_13, ConnectionSpec.RESTRICTED_TLS));
+            "https://tls13.baishancloud.com/", "https://tls13.akamai.io/", "https://swifttls.org/",
+            "https://www.googleapis.com/robots.txt", "https://graph.facebook.com/robots.txt",
+            "https://api.twitter.com/robots.txt", "https://connect.squareup.com/robots.txt");
 
     System.out.println("TLS1.3+TLS1.2");
-    testClient(urls, buildClient(merge(ConnectionSpec.TLS_13, ConnectionSpec.RESTRICTED_TLS)));
-  }
+    testClient(urls, buildClient(ConnectionSpec.RESTRICTED_TLS));
 
-  private static ConnectionSpec merge(ConnectionSpec first, ConnectionSpec second) {
-    String[] versions = concat(first.tlsVersions, second.tlsVersions);
-    String[] cipherSuites = concat(first.cipherSuites, second.cipherSuites);
+    System.out.println("\nTLS1.3 only");
+    testClient(urls, buildClient(TLS_13));
 
-    return new ConnectionSpec.Builder(true).tlsVersions(versions)
-        .cipherSuites(cipherSuites)
-        .supportsTlsExtensions(true)
-        .build();
-  }
-
-  private static String[] concat(String[] first, String[] second) {
-    String[] result = new String[first.length + second.length];
-    System.arraycopy(first, 0, result, 0, first.length);
-    System.arraycopy(second, 0, result, first.length, second.length);
-    return result;
+    System.out.println("\nTLS1.3 then fallback");
+    testClient(urls, buildClient(TLS_13, TLS_12));
   }
 
   private static void testClient(List<String> urls, OkHttpClient client) {
@@ -82,12 +82,11 @@ private static void sendRequest(OkHttpClient client, String url) {
     System.out.printf("%-40s ", url);
     System.out.flush();
 
-    Request request = new Request.Builder().url(url).build();
+    System.out.println(Platform.get());
 
-    Response response = null;
-    try {
-      response = client.newCall(request).execute();
+    Request request = new Request.Builder().url(url).build();
 
+    try (Response response = client.newCall(request).execute()) {
       Handshake handshake = response.handshake();
       System.out.println(handshake.tlsVersion()
           + " "
@@ -101,10 +100,6 @@ private static void sendRequest(OkHttpClient client, String url) {
           + "b");
     } catch (IOException ioe) {
       System.out.println(ioe.toString());
-    } finally {
-      if (response != null) {
-        response.close();
-      }
     }
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/AddressTest.java b/okhttp-tests/src/test/java/okhttp3/AddressTest.java
index ad07b78241..7a1b7f1bd1 100644
--- a/okhttp-tests/src/test/java/okhttp3/AddressTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/AddressTest.java
@@ -23,7 +23,7 @@
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotEquals;
 
 public final class AddressTest {
   private Dns dns = Dns.SYSTEM;
@@ -47,7 +47,7 @@
         authenticator, null, protocols, connectionSpecs, new RecordingProxySelector());
     Address b = new Address("square.com", 80, dns, socketFactory, null, null, null,
         authenticator, null, protocols, connectionSpecs, new RecordingProxySelector());
-    assertFalse(a.equals(b));
+    assertNotEquals(a, b);
   }
 
   @Test public void addressToString() throws Exception {
diff --git a/okhttp-tests/src/test/java/okhttp3/CacheTest.java b/okhttp-tests/src/test/java/okhttp3/CacheTest.java
index 8673ffa031..c75d5b4163 100644
--- a/okhttp-tests/src/test/java/okhttp3/CacheTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CacheTest.java
@@ -34,7 +34,6 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicReference;
 import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.SSLSession;
 import okhttp3.internal.Internal;
 import okhttp3.internal.io.InMemoryFileSystem;
 import okhttp3.internal.platform.Platform;
@@ -63,11 +62,7 @@
 import static org.junit.Assert.fail;
 
 public final class CacheTest {
-  private static final HostnameVerifier NULL_HOSTNAME_VERIFIER = new HostnameVerifier() {
-    @Override public boolean verify(String s, SSLSession sslSession) {
-      return true;
-    }
-  };
+  private static final HostnameVerifier NULL_HOSTNAME_VERIFIER = (name, session) -> true;
 
   @Rule public MockWebServer server = new MockWebServer();
   @Rule public MockWebServer server2 = new MockWebServer();
@@ -524,7 +519,7 @@ private void testServerPrematureDisconnect(TransferKind transferKind) throws IOE
     BufferedSource bodySource = get(server.url("/")).body().source();
     assertEquals("ABCDE", bodySource.readUtf8Line());
     try {
-      bodySource.readUtf8Line();
+      bodySource.readUtf8(21);
       fail("This implementation silently ignored a truncated HTTP body.");
     } catch (IOException expected) {
     } finally {
@@ -1865,7 +1860,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
 
     Response response2 = get(server.url("/"));
     assertEquals("A", response2.body().string());
-    assertEquals(null, response2.header("Warning"));
+    assertNull(response2.header("Warning"));
   }
 
   @Test public void getHeadersRetainsCached200LevelWarnings() throws Exception {
@@ -1910,7 +1905,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     long t0 = System.currentTimeMillis();
     Response response1 = get(server.url("/a"));
     assertEquals("A", response1.body().string());
-    assertEquals(null, response1.header("Allow"));
+    assertNull(response1.header("Allow"));
     assertEquals(0, response1.receivedResponseAtMillis() - t0, 250.0);
 
     // A conditional cache hit updates the cache.
@@ -2220,12 +2215,11 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
 
     final AtomicReference<String> ifNoneMatch = new AtomicReference<>();
     client = client.newBuilder()
-        .addNetworkInterceptor(new Interceptor() {
-          @Override public Response intercept(Chain chain) throws IOException {
-            ifNoneMatch.compareAndSet(null, chain.request().header("If-None-Match"));
-            return chain.proceed(chain.request());
-          }
-        }).build();
+        .addNetworkInterceptor(chain -> {
+          ifNoneMatch.compareAndSet(null, chain.request().header("If-None-Match"));
+          return chain.proceed(chain.request());
+        })
+        .build();
 
     // Confirm the value is cached and intercepted.
     assertEquals("A", get(url).body().string());
@@ -2243,11 +2237,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
 
     // Confirm the interceptor isn't exercised.
     client = client.newBuilder()
-        .addNetworkInterceptor(new Interceptor() {
-          @Override public Response intercept(Chain chain) throws IOException {
-            throw new AssertionError();
-          }
-        }).build();
+        .addNetworkInterceptor(chain -> { throw new AssertionError(); })
+        .build();
     assertEquals("A", get(url).body().string());
   }
 
@@ -2397,7 +2388,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     assertEquals("B", get(url).body().string());
     assertEquals("B", get(url).body().string());
 
-    assertEquals(null, server.takeRequest().getHeader("If-None-Match"));
+    assertNull(server.takeRequest().getHeader("If-None-Match"));
     assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
     assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
     assertEquals("v2", server.takeRequest().getHeader("If-None-Match"));
@@ -2443,7 +2434,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     Response response2 = get(server.url("/"));
     assertEquals("abcd", response2.body().string());
 
-    assertEquals(null, server.takeRequest().getHeader("If-None-Match"));
+    assertNull(server.takeRequest().getHeader("If-None-Match"));
     assertEquals("Œ±", server.takeRequest().getHeader("If-None-Match"));
   }
 
@@ -2524,7 +2515,7 @@ private RecordedRequest assertConditionallyCached(MockResponse response) throws
 
   @Test public void immutableIsCached() throws Exception {
     server.enqueue(new MockResponse()
-        .addHeader("Cache-Control", "immutable")
+        .addHeader("Cache-Control", "immutable, max-age=10")
         .setBody("A"));
     server.enqueue(new MockResponse()
         .setBody("B"));
@@ -2538,7 +2529,7 @@ private RecordedRequest assertConditionallyCached(MockResponse response) throws
     server.enqueue(new MockResponse()
         .setBody("A"));
     server.enqueue(new MockResponse()
-        .addHeader("Cache-Control", "immutable")
+        .addHeader("Cache-Control", "immutable, max-age=10")
         .setBody("B"));
     server.enqueue(new MockResponse()
         .setBody("C"));
@@ -2549,6 +2540,19 @@ private RecordedRequest assertConditionallyCached(MockResponse response) throws
     assertEquals("B", get(url).body().string());
   }
 
+  @Test public void immutableIsNotCachedBeyondFreshnessLifetime() throws Exception {
+    //      last modified: 115 seconds ago
+    //             served:  15 seconds ago
+    //   default lifetime: (115 - 15) / 10 = 10 seconds
+    //            expires:  10 seconds from served date = 5 seconds ago
+    String lastModifiedDate = formatDate(-115, TimeUnit.SECONDS);
+    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
+        .addHeader("Cache-Control: immutable")
+        .addHeader("Last-Modified: " + lastModifiedDate)
+        .addHeader("Date: " + formatDate(-15, TimeUnit.SECONDS)));
+    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
+  }
+
   private void assertFullyCached(MockResponse response) throws Exception {
     server.enqueue(response.setBody("A"));
     server.enqueue(response.setBody("B"));
@@ -2573,18 +2577,17 @@ private MockResponse truncateViolently(MockResponse response, int numBytesToKeep
   }
 
   enum TransferKind {
-    CHUNKED() {
-      @Override void setBody(MockResponse response, Buffer content, int chunkSize)
-          throws IOException {
+    CHUNKED {
+      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
         response.setChunkedBody(content, chunkSize);
       }
     },
-    FIXED_LENGTH() {
+    FIXED_LENGTH {
       @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
         response.setBody(content);
       }
     },
-    END_OF_STREAM() {
+    END_OF_STREAM {
       @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
         response.setBody(content);
         response.setSocketPolicy(DISCONNECT_AT_END);
diff --git a/okhttp-tests/src/test/java/okhttp3/CallTest.java b/okhttp-tests/src/test/java/okhttp3/CallTest.java
index b879072c02..88135fab44 100644
--- a/okhttp-tests/src/test/java/okhttp3/CallTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CallTest.java
@@ -16,6 +16,7 @@
 package okhttp3;
 
 import java.io.File;
+import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InterruptedIOException;
@@ -36,7 +37,6 @@
 import java.util.List;
 import java.util.Set;
 import java.util.concurrent.BlockingQueue;
-import java.util.concurrent.Callable;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
@@ -44,10 +44,12 @@
 import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 import java.util.logging.SimpleFormatter;
+import javax.annotation.Nullable;
 import javax.net.ssl.SSLException;
 import javax.net.ssl.SSLHandshakeException;
 import javax.net.ssl.SSLPeerUnverifiedException;
@@ -56,7 +58,6 @@
 import javax.net.ssl.SSLSocketFactory;
 import okhttp3.internal.DoubleInetAddressDns;
 import okhttp3.internal.RecordingOkAuthenticator;
-import okhttp3.internal.SingleInetAddressDns;
 import okhttp3.internal.Util;
 import okhttp3.internal.Version;
 import okhttp3.internal.http.RecordingProxySelector;
@@ -66,8 +67,8 @@
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.RecordedRequest;
 import okhttp3.mockwebserver.SocketPolicy;
-import okhttp3.tls.HeldCertificate;
 import okhttp3.tls.HandshakeCertificates;
+import okhttp3.tls.HeldCertificate;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -82,9 +83,9 @@
 import org.junit.rules.Timeout;
 
 import static java.net.CookiePolicy.ACCEPT_ORIGINAL_SERVER;
+import static okhttp3.CipherSuite.TLS_DH_anon_WITH_AES_128_GCM_SHA256;
 import static okhttp3.TestUtil.awaitGarbageCollection;
 import static okhttp3.TestUtil.defaultClient;
-import static okhttp3.internal.platform.PlatformTest.getPlatform;
 import static okhttp3.tls.internal.TlsUtil.localhost;
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
@@ -115,6 +116,10 @@
   @After public void tearDown() throws Exception {
     cache.delete();
     logger.removeHandler(logHandler);
+
+    // Ensure the test has released all connections.
+    client.connectionPool().evictAll();
+    assertEquals(0, client.connectionPool().connectionCount());
   }
 
   @Test public void get() throws Exception {
@@ -343,7 +348,7 @@
     assertEquals("POST", recordedRequest.getMethod());
     assertEquals(0, recordedRequest.getBody().size());
     assertEquals("0", recordedRequest.getHeader("Content-Length"));
-    assertEquals(null, recordedRequest.getHeader("Content-Type"));
+    assertNull(recordedRequest.getHeader("Content-Type"));
   }
 
   @Test public void postZerolength_HTTPS() throws Exception {
@@ -396,7 +401,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     String credential = Credentials.basic("jesse", "secret");
     client = client.newBuilder()
-        .authenticator(new RecordingOkAuthenticator(credential))
+        .authenticator(new RecordingOkAuthenticator(credential, null))
         .build();
 
     Response response = client.newCall(request).execute();
@@ -422,7 +427,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     String credential = Credentials.basic("jesse", "secret");
     client = client.newBuilder()
-        .authenticator(new RecordingOkAuthenticator(credential))
+        .authenticator(new RecordingOkAuthenticator(credential, null))
         .build();
 
     executeSynchronously("/")
@@ -437,7 +442,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     String credential = Credentials.basic("jesse", "secret");
     client = client.newBuilder()
-        .authenticator(new RecordingOkAuthenticator(credential))
+        .authenticator(new RecordingOkAuthenticator(credential, null))
         .build();
 
     try {
@@ -458,7 +463,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .setResponseCode(401)
         .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END));
 
-    RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator(null);
+    RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator(null, null);
 
     client = client.newBuilder()
         .authenticator(authenticator)
@@ -486,7 +491,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     assertEquals("DELETE", recordedRequest.getMethod());
     assertEquals(0, recordedRequest.getBody().size());
     assertEquals("0", recordedRequest.getHeader("Content-Length"));
-    assertEquals(null, recordedRequest.getHeader("Content-Type"));
+    assertNull(recordedRequest.getHeader("Content-Type"));
   }
 
   @Test public void delete_HTTPS() throws Exception {
@@ -604,7 +609,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     executeSynchronously(request).assertCode(200);
 
     RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals(null, recordedRequest.getHeader("Content-Type"));
+    assertNull(recordedRequest.getHeader("Content-Type"));
     assertEquals("3", recordedRequest.getHeader("Content-Length"));
     assertEquals("abc", recordedRequest.getBody().readUtf8());
   }
@@ -668,6 +673,8 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     }
 
     assertEquals("SyncApiTest", server.takeRequest().getHeader("User-Agent"));
+
+    callback.await(request.url()).assertSuccessful();
   }
 
   @Test public void legalToExecuteTwiceCloning() throws Exception {
@@ -921,11 +928,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
   /** https://github.com/square/okhttp/issues/1801 */
   @Test public void asyncCallEngineInitialized() throws Exception {
     OkHttpClient c = defaultClient().newBuilder()
-        .addInterceptor(new Interceptor() {
-          @Override public Response intercept(Chain chain) throws IOException {
-            throw new IOException();
-          }
-        })
+        .addInterceptor(chain -> { throw new IOException(); })
         .build();
     Request request = new Request.Builder().url(server.url("/")).build();
     c.newCall(request).enqueue(callback);
@@ -1088,7 +1091,6 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     client = client.newBuilder()
         .hostnameVerifier(new RecordingHostnameVerifier())
-        .dns(new SingleInetAddressDns())
         // Attempt RESTRICTED_TLS then fall back to MODERN_TLS.
         .connectionSpecs(Arrays.asList(ConnectionSpec.RESTRICTED_TLS, ConnectionSpec.MODERN_TLS))
         .sslSocketFactory(
@@ -1117,7 +1119,6 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         // Attempt RESTRICTED_TLS then fall back to MODERN_TLS.
         .connectionSpecs(Arrays.asList(ConnectionSpec.RESTRICTED_TLS, ConnectionSpec.MODERN_TLS))
         .hostnameVerifier(new RecordingHostnameVerifier())
-        .dns(new SingleInetAddressDns())
         .build();
 
     Request request = new Request.Builder().url(server.url("/")).build();
@@ -1159,7 +1160,6 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     client = client.newBuilder()
         .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.CLEARTEXT))
         .hostnameVerifier(new RecordingHostnameVerifier())
-        .dns(new SingleInetAddressDns())
         .sslSocketFactory(
             suppressTlsFallbackClientSocketFactory(), handshakeCertificates.trustManager())
         .build();
@@ -1182,6 +1182,96 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     }
   }
 
+  /**
+   * When the server doesn't present any certificates we fail the TLS handshake. This test requires
+   * that the client and server are each configured with a cipher suite that permits the server to
+   * be unauthenticated.
+   */
+  @Test public void tlsSuccessWithNoPeerCertificates() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("abc"));
+
+    // The _anon_ cipher suites don't require server certificates.
+    CipherSuite cipherSuite = TLS_DH_anon_WITH_AES_128_GCM_SHA256;
+
+    HandshakeCertificates clientCertificates = new HandshakeCertificates.Builder()
+        .build();
+    client = client.newBuilder()
+        .sslSocketFactory(
+            socketFactoryWithCipherSuite(clientCertificates.sslSocketFactory(), cipherSuite),
+            clientCertificates.trustManager())
+        .connectionSpecs(Arrays.asList(new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
+            .cipherSuites(cipherSuite)
+            .build()))
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build();
+
+    HandshakeCertificates serverCertificates = new HandshakeCertificates.Builder()
+        .build();
+    server.useHttps(socketFactoryWithCipherSuite(
+        serverCertificates.sslSocketFactory(), cipherSuite), false);
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals("abc", response.body().string());
+    assertNull(response.handshake().peerPrincipal());
+    assertEquals(Collections.emptyList(), response.handshake().peerCertificates());
+    assertEquals(cipherSuite, response.handshake().cipherSuite());
+  }
+
+  @Test public void tlsHostnameVerificationFailure() throws Exception {
+    server.enqueue(new MockResponse());
+
+    HeldCertificate serverCertificate = new HeldCertificate.Builder()
+        .commonName("localhost") // Unusued for hostname verification.
+        .addSubjectAlternativeName("wronghostname")
+        .build();
+
+    HandshakeCertificates serverCertificates = new HandshakeCertificates.Builder()
+        .heldCertificate(serverCertificate)
+        .build();
+
+    HandshakeCertificates clientCertificates = new HandshakeCertificates.Builder()
+        .addTrustedCertificate(serverCertificate.certificate())
+        .build();
+
+    client = client.newBuilder()
+        .sslSocketFactory(clientCertificates.sslSocketFactory(), clientCertificates.trustManager())
+        .build();
+    server.useHttps(serverCertificates.sslSocketFactory(), false);
+
+    executeSynchronously("/")
+        .assertFailureMatches("(?s)Hostname localhost not verified.*");
+  }
+
+  @Test public void tlsHostnameVerificationFailureNoPeerCertificates() throws Exception {
+    server.enqueue(new MockResponse());
+
+    // The _anon_ cipher suites don't require server certificates.
+    CipherSuite cipherSuite = TLS_DH_anon_WITH_AES_128_GCM_SHA256;
+
+    HandshakeCertificates clientCertificates = new HandshakeCertificates.Builder()
+        .build();
+    client = client.newBuilder()
+        .sslSocketFactory(
+            socketFactoryWithCipherSuite(clientCertificates.sslSocketFactory(), cipherSuite),
+            clientCertificates.trustManager())
+        .connectionSpecs(Arrays.asList(new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
+            .cipherSuites(cipherSuite)
+            .build()))
+        .build();
+
+    HandshakeCertificates serverCertificates = new HandshakeCertificates.Builder()
+        .build();
+    server.useHttps(socketFactoryWithCipherSuite(
+        serverCertificates.sslSocketFactory(), cipherSuite), false);
+
+    executeSynchronously("/")
+        .assertFailure("Hostname localhost not verified (no certificates)");
+  }
+
   @Test public void cleartextCallsFailWhenCleartextIsDisabled() throws Exception {
     // Configure the client with only TLS configurations. No cleartext!
     client = client.newBuilder()
@@ -1582,7 +1672,6 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .assertBody("A");
 
     // Attempt conditional cache validation and a DNS miss.
-    client.connectionPool().evictAll();
     client = client.newBuilder()
         .dns(new FakeDns())
         .build();
@@ -1880,7 +1969,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .addHeader("Location: " + server2.url("/b")));
 
     client = client.newBuilder()
-        .authenticator(new RecordingOkAuthenticator(Credentials.basic("jesse", "secret")))
+        .authenticator(new RecordingOkAuthenticator(Credentials.basic("jesse", "secret"), null))
         .build();
 
     Request request = new Request.Builder().url(server.url("/a")).build();
@@ -2064,15 +2153,13 @@ private void cancelDuringConnect(String scheme) throws Exception {
     server.enqueue(new MockResponse());
     final CountDownLatch latch = new CountDownLatch(1);
     client = client.newBuilder()
-        .addNetworkInterceptor(new Interceptor() {
-          @Override public Response intercept(Chain chain) throws IOException {
-            try {
-              latch.await();
-            } catch (InterruptedException e) {
-              throw new AssertionError(e);
-            }
-            return chain.proceed(chain.request());
+        .addNetworkInterceptor(chain -> {
+          try {
+            latch.await();
+          } catch (InterruptedException e) {
+            throw new AssertionError(e);
           }
+          return chain.proceed(chain.request());
         })
         .build();
 
@@ -2095,16 +2182,44 @@ private void cancelDuringConnect(String scheme) throws Exception {
     callback.await(server.url("/")).assertFailure("Canceled", "Socket closed");
   }
 
+  @Test
+  public void cancelWhileRequestHeadersAreSent() throws Exception {
+    server.enqueue(new MockResponse().setBody("A"));
+
+    EventListener listener =
+        new EventListener() {
+          @Override
+          public void requestHeadersStart(Call call) {
+            try {
+              // Cancel call from another thread to avoid reentrance.
+              cancelLater(call, 0).join();
+            } catch (InterruptedException e) {
+              throw new AssertionError();
+            }
+          }
+        };
+    client = client.newBuilder().eventListener(listener).build();
+
+    Call call = client.newCall(new Request.Builder().url(server.url("/a")).build());
+    try {
+      call.execute();
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  @Test
+  public void cancelWhileRequestHeadersAreSent_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    cancelWhileRequestHeadersAreSent();
+  }
+
   @Test public void cancelBeforeBodyIsRead() throws Exception {
     server.enqueue(new MockResponse().setBody("def").throttleBody(1, 750, TimeUnit.MILLISECONDS));
 
     final Call call = client.newCall(new Request.Builder().url(server.url("/a")).build());
     ExecutorService executor = Executors.newSingleThreadExecutor();
-    Future<Response> result = executor.submit(new Callable<Response>() {
-      @Override public Response call() throws Exception {
-        return call.execute();
-      }
-    });
+    Future<Response> result = executor.submit(call::execute);
 
     Thread.sleep(100); // wait for it to go in flight.
 
@@ -2268,12 +2383,11 @@ private void cancelDuringConnect(String scheme) throws Exception {
 
   @Test public void cancelWithInterceptor() throws Exception {
     client = client.newBuilder()
-        .addInterceptor(new Interceptor() {
-          @Override public Response intercept(Chain chain) throws IOException {
-            chain.proceed(chain.request());
-            throw new AssertionError(); // We expect an exception.
-          }
-        }).build();
+        .addInterceptor(chain -> {
+          chain.proceed(chain.request());
+          throw new AssertionError(); // We expect an exception.
+        })
+        .build();
 
     Call call = client.newCall(new Request.Builder().url(server.url("/a")).build());
     call.cancel();
@@ -2318,7 +2432,7 @@ private void cancelDuringConnect(String scheme) throws Exception {
         .setBody(gzip("abcabcabc"))
         .addHeader("Content-Encoding: gzip"));
     client = client.newBuilder()
-        .authenticator(new RecordingOkAuthenticator("password"))
+        .authenticator(new RecordingOkAuthenticator("password", null))
         .build();
 
     executeSynchronously("/").assertBody("abcabcabc");
@@ -2722,7 +2836,7 @@ private void cancelDuringConnect(String scheme) throws Exception {
         .sslSocketFactory(
             handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .proxy(server.toProxyAddress())
-        .proxyAuthenticator(new RecordingOkAuthenticator("password"))
+        .proxyAuthenticator(new RecordingOkAuthenticator("password", "Basic"))
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build();
 
@@ -2755,7 +2869,7 @@ private void cancelDuringConnect(String scheme) throws Exception {
 
     client = client.newBuilder()
         .proxy(server.toProxyAddress())
-        .proxyAuthenticator(new RecordingOkAuthenticator("password"))
+        .proxyAuthenticator(new RecordingOkAuthenticator("password", "Basic"))
         .build();
 
     Request request = new Request.Builder()
@@ -2794,7 +2908,7 @@ private void cancelDuringConnect(String scheme) throws Exception {
         .sslSocketFactory(
             handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .proxy(server.toProxyAddress())
-        .proxyAuthenticator(new RecordingOkAuthenticator("password"))
+        .proxyAuthenticator(new RecordingOkAuthenticator("password", "Basic"))
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build();
 
@@ -2828,7 +2942,7 @@ private void cancelDuringConnect(String scheme) throws Exception {
         .sslSocketFactory(
             handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .proxy(server.toProxyAddress())
-        .proxyAuthenticator(new RecordingOkAuthenticator("password"))
+        .proxyAuthenticator(new RecordingOkAuthenticator("password", "Basic"))
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build();
 
@@ -2847,7 +2961,7 @@ private void cancelDuringConnect(String scheme) throws Exception {
    * We used to have that behavior but it is problematic because unrelated requests end up sharing
    * credentials. Worse, that approach leaks proxy credentials to the origin server.
    */
-  @Test public void noProactiveProxyAuthorization() throws Exception {
+  @Test public void noPreemptiveProxyAuthorization() throws Exception {
     server.useHttps(handshakeCertificates.sslSocketFactory(), true);
     server.enqueue(new MockResponse()
         .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
@@ -2869,11 +2983,103 @@ private void cancelDuringConnect(String scheme) throws Exception {
     Response response = client.newCall(request).execute();
     assertEquals("response body", response.body().string());
 
+    RecordedRequest connect1 = server.takeRequest();
+    assertNull(connect1.getHeader("Proxy-Authorization"));
+
+    RecordedRequest connect2 = server.takeRequest();
+    assertEquals("password", connect2.getHeader("Proxy-Authorization"));
+  }
+
+  /** Confirm that we can send authentication information without being prompted first. */
+  @Test public void preemptiveProxyAuthentication() throws Exception {
+    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
+        .clearHeaders());
+    server.enqueue(new MockResponse()
+        .setBody("encrypted response from the origin server"));
+
+    final String credential = Credentials.basic("jesse", "password1");
+
+    client = client.newBuilder()
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
+        .proxy(server.toProxyAddress())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .proxyAuthenticator((route, response) -> {
+          assertEquals("CONNECT", response.request().method());
+          assertEquals(HttpURLConnection.HTTP_PROXY_AUTH, response.code());
+          assertEquals("android.com", response.request().url().host());
+
+          List<Challenge> challenges = response.challenges();
+          assertEquals("OkHttp-Preemptive", challenges.get(0).scheme());
+
+          return response.request().newBuilder()
+              .header("Proxy-Authorization", credential)
+              .build();
+        })
+        .build();
+
+    Request request = new Request.Builder()
+        .url("https://android.com/foo")
+        .build();
+
+    executeSynchronously(request).assertSuccessful();
+
     RecordedRequest connect = server.takeRequest();
-    assertNull(connect.getHeader("Proxy-Authorization"));
+    assertEquals("CONNECT", connect.getMethod());
+    assertEquals(credential, connect.getHeader("Proxy-Authorization"));
+    assertEquals("/", connect.getPath());
 
     RecordedRequest get = server.takeRequest();
-    assertEquals("password", get.getHeader("Proxy-Authorization"));
+    assertEquals("GET", get.getMethod());
+    assertNull(get.getHeader("Proxy-Authorization"));
+    assertEquals("/foo", get.getPath());
+  }
+
+  @Test public void preemptiveThenReactiveProxyAuthentication() throws Exception {
+    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_PROXY_AUTH)
+        .addHeader("Proxy-Authenticate", "Basic realm=\"localhost\"")
+        .setBody("proxy auth required"));
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
+        .clearHeaders());
+    server.enqueue(new MockResponse());
+
+    final List<String> challengeSchemes = new ArrayList<>();
+    final String credential = Credentials.basic("jesse", "password1");
+
+    client = client.newBuilder()
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
+        .proxy(server.toProxyAddress())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .proxyAuthenticator((route, response) -> {
+          List<Challenge> challenges = response.challenges();
+          challengeSchemes.add(challenges.get(0).scheme());
+          return response.request().newBuilder()
+              .header("Proxy-Authorization", credential)
+              .build();
+        })
+        .build();
+
+    Request request = new Request.Builder()
+        .url("https://android.com/foo")
+        .build();
+
+    executeSynchronously(request).assertSuccessful();
+
+    RecordedRequest connect1 = server.takeRequest();
+    assertEquals("CONNECT", connect1.getMethod());
+    assertEquals(credential, connect1.getHeader("Proxy-Authorization"));
+
+    RecordedRequest connect2 = server.takeRequest();
+    assertEquals("CONNECT", connect2.getMethod());
+    assertEquals(credential, connect2.getHeader("Proxy-Authorization"));
+
+    assertEquals(Arrays.asList("OkHttp-Preemptive", "Basic"), challengeSchemes);
   }
 
   @Test public void interceptorGetsHttp2() throws Exception {
@@ -2881,11 +3087,9 @@ private void cancelDuringConnect(String scheme) throws Exception {
 
     // Capture the protocol as it is observed by the interceptor.
     final AtomicReference<Protocol> protocolRef = new AtomicReference<>();
-    Interceptor interceptor = new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        protocolRef.set(chain.connection().protocol());
-        return chain.proceed(chain.request());
-      }
+    Interceptor interceptor = chain -> {
+      protocolRef.set(chain.connection().protocol());
+      return chain.proceed(chain.request());
     };
     client = client.newBuilder()
         .addNetworkInterceptor(interceptor)
@@ -3182,13 +3386,8 @@ private RequestBody requestBody(final boolean chunked, final long size, final in
     server.enqueue(new MockResponse()
         .setResponseCode(401));
 
-    client.connectionPool().evictAll();
     client = client.newBuilder()
-        .authenticator(new Authenticator() {
-          @Override public Request authenticate(Route route, Response response) throws IOException {
-            throw new IOException("IOException!");
-          }
-        })
+        .authenticator((route, response) -> { throw new IOException("IOException!"); })
         .build();
 
     Request request = new Request.Builder()
@@ -3205,13 +3404,8 @@ private RequestBody requestBody(final boolean chunked, final long size, final in
     server.enqueue(new MockResponse()
         .setResponseCode(407));
 
-    client.connectionPool().evictAll();
     client = client.newBuilder()
-        .proxyAuthenticator(new Authenticator() {
-          @Override public Request authenticate(Route route, Response response) throws IOException {
-            throw new IOException("IOException!");
-          }
-        })
+        .proxyAuthenticator((route, response) -> { throw new IOException("IOException!"); })
         .build();
 
     Request request = new Request.Builder()
@@ -3262,6 +3456,89 @@ private RequestBody requestBody(final boolean chunked, final long size, final in
     assertEquals(localIpAddress + ":" + server.getPort(), recordedRequest.getHeader("Host"));
   }
 
+  @Test public void postWithFileNotFound() throws Exception {
+    final AtomicInteger called = new AtomicInteger(0);
+
+    RequestBody body = new RequestBody() {
+      @Nullable @Override public MediaType contentType() {
+        return MediaType.get("application/octet-stream");
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        called.incrementAndGet();
+        throw new FileNotFoundException();
+      }
+    };
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .post(body)
+        .build();
+
+    client = client.newBuilder()
+        .dns(new DoubleInetAddressDns())
+        .build();
+
+    executeSynchronously(request)
+        .assertFailure(FileNotFoundException.class);
+
+    assertEquals(1L, called.get());
+  }
+
+  @Test public void clientReadsHeadersDataTrailersHttp1ChunkedTransferEncoding() throws Exception {
+    MockResponse mockResponse = new MockResponse()
+        .clearHeaders()
+        .addHeader("h1", "v1")
+        .addHeader("h2", "v2")
+        .setChunkedBody("HelloBonjour", 1024)
+        .setTrailers(Headers.of("trailers", "boom"));
+    server.enqueue(mockResponse);
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+
+    Response response = call.execute();
+    BufferedSource source = response.body().source();
+
+    assertEquals("v1", response.header("h1"));
+    assertEquals("v2", response.header("h2"));
+
+    assertEquals("Hello", source.readUtf8(5));
+    assertEquals("Bonjour", source.readUtf8(7));
+
+    assertTrue(source.exhausted());
+    assertEquals(Headers.of("trailers", "boom"), response.trailers());
+  }
+
+  @Test public void clientReadsHeadersDataTrailersHttp2() throws IOException {
+    MockResponse mockResponse = new MockResponse()
+        .clearHeaders()
+        .addHeader("h1", "v1")
+        .addHeader("h2", "v2")
+        .setBody("HelloBonjour")
+        .setTrailers(Headers.of("trailers", "boom"));
+    server.enqueue(mockResponse);
+    enableProtocol(Protocol.HTTP_2);
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+
+    try (Response response = call.execute()) {
+      BufferedSource source = response.body().source();
+
+      assertEquals("v1", response.header("h1"));
+      assertEquals("v2", response.header("h2"));
+
+      assertEquals("Hello", source.readUtf8(5));
+      assertEquals("Bonjour", source.readUtf8(7));
+
+      assertTrue(source.exhausted());
+      assertEquals(Headers.of("trailers", "boom"), response.trailers());
+    }
+  }
+
   private void makeFailingCall() {
     RequestBody requestBody = new RequestBody() {
       @Override public MediaType contentType() {
@@ -3340,8 +3617,8 @@ private Buffer gzip(String data) throws IOException {
     return result;
   }
 
-  private void cancelLater(final Call call, final long delay) {
-    new Thread("canceler") {
+  private Thread cancelLater(final Call call, final long delay) {
+    Thread thread = new Thread("canceler") {
       @Override public void run() {
         try {
           Thread.sleep(delay);
@@ -3350,7 +3627,19 @@ private void cancelLater(final Call call, final long delay) {
         }
         call.cancel();
       }
-    }.start();
+    };
+    thread.start();
+    return thread;
+  }
+
+  private SSLSocketFactory socketFactoryWithCipherSuite(
+      final SSLSocketFactory sslSocketFactory, final CipherSuite cipherSuite) {
+    return new DelegatingSSLSocketFactory(sslSocketFactory) {
+      @Override protected SSLSocket configureSocket(SSLSocket sslSocket) throws IOException {
+        sslSocket.setEnabledCipherSuites(new String[] { cipherSuite.javaName() });
+        return super.configureSocket(sslSocket);
+      }
+    };
   }
 
   private static class RecordingSSLSocketFactory extends DelegatingSSLSocketFactory {
diff --git a/okhttp-tests/src/test/java/okhttp3/CertificatePinnerTest.java b/okhttp-tests/src/test/java/okhttp3/CertificatePinnerTest.java
index 28e2af8423..a0e03cdcc6 100644
--- a/okhttp-tests/src/test/java/okhttp3/CertificatePinnerTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CertificatePinnerTest.java
@@ -24,8 +24,7 @@
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.assertNotEquals;
 import static org.junit.Assert.fail;
 
 public final class CertificatePinnerTest {
@@ -87,9 +86,9 @@
         .build();
     String keypairBCertificate2Pin = CertificatePinner.pin(heldCertificateB2.certificate());
 
-    assertTrue(certA1Sha256Pin.equals(keypairACertificate2Pin));
-    assertTrue(certB1Sha256Pin.equals(keypairBCertificate2Pin));
-    assertFalse(certA1Sha256Pin.equals(certB1Sha256Pin));
+    assertEquals(certA1Sha256Pin, keypairACertificate2Pin);
+    assertEquals(certB1Sha256Pin, keypairBCertificate2Pin);
+    assertNotEquals(certA1Sha256Pin, certB1Sha256Pin);
   }
 
   @Test public void successfulCheck() throws Exception {
diff --git a/okhttp-tests/src/test/java/okhttp3/ConnectionCoalescingTest.java b/okhttp-tests/src/test/java/okhttp3/ConnectionCoalescingTest.java
index be741a0b53..c792d75ba0 100644
--- a/okhttp-tests/src/test/java/okhttp3/ConnectionCoalescingTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/ConnectionCoalescingTest.java
@@ -25,11 +25,10 @@
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
 import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.SSLSession;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.tls.HeldCertificate;
 import okhttp3.tls.HandshakeCertificates;
+import okhttp3.tls.HeldCertificate;
 import org.junit.Before;
 import org.junit.Ignore;
 import org.junit.Rule;
@@ -71,7 +70,7 @@
     dns.set("san.com", serverIps);
     dns.set("nonsan.com", serverIps);
     dns.set("www.wildcard.com", serverIps);
-    dns.set("differentdns.com", Collections.<InetAddress>emptyList());
+    dns.set("differentdns.com", Collections.emptyList());
 
     HandshakeCertificates handshakeCertificates = new HandshakeCertificates.Builder()
         .addTrustedCertificate(rootCa.certificate())
@@ -127,13 +126,11 @@
     server.enqueue(new MockResponse().setResponseCode(200));
     server.enqueue(new MockResponse().setResponseCode(200));
 
-    final AtomicReference<Connection> connection = new AtomicReference<>();
+    AtomicReference<Connection> connection = new AtomicReference<>();
     client = client.newBuilder()
-        .addNetworkInterceptor(new Interceptor() {
-          @Override public Response intercept(Chain chain) throws IOException {
-            connection.set(chain.connection());
-            return chain.proceed(chain.request());
-          }
+        .addNetworkInterceptor(chain -> {
+          connection.set(chain.connection());
+          return chain.proceed(chain.request());
         })
         .build();
     dns.set("san.com", Dns.SYSTEM.lookup(server.getHostName()).subList(0, 1));
@@ -222,11 +219,7 @@
    * verification is a black box.
    */
   @Test public void skipsWhenHostnameVerifierUsed() throws Exception {
-    HostnameVerifier verifier = new HostnameVerifier() {
-      @Override public boolean verify(String s, SSLSession sslSession) {
-        return true;
-      }
-    };
+    HostnameVerifier verifier = (name, session) -> true;
     client = client.newBuilder().hostnameVerifier(verifier).build();
 
     server.enqueue(new MockResponse().setResponseCode(200));
@@ -249,7 +242,7 @@
     server.enqueue(new MockResponse().setResponseCode(200));
     server.enqueue(new MockResponse().setResponseCode(200));
 
-    final AtomicInteger connectCount = new AtomicInteger();
+    AtomicInteger connectCount = new AtomicInteger();
     EventListener listener = new EventListener() {
       @Override public void connectStart(Call call, InetSocketAddress inetSocketAddress,
           Proxy proxy) {
@@ -288,11 +281,9 @@
 
   /** Network interceptors check for changes to target. */
   @Test public void worksWithNetworkInterceptors() throws Exception {
-    client = client.newBuilder().addNetworkInterceptor(new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        return chain.proceed(chain.request());
-      }
-    }).build();
+    client = client.newBuilder()
+        .addNetworkInterceptor(chain -> chain.proceed(chain.request()))
+        .build();
 
     server.enqueue(new MockResponse().setResponseCode(200));
     server.enqueue(new MockResponse().setResponseCode(200));
diff --git a/okhttp-tests/src/test/java/okhttp3/ConnectionPoolTest.java b/okhttp-tests/src/test/java/okhttp3/ConnectionPoolTest.java
index ae8b0a2f6c..b95f8521a5 100644
--- a/okhttp-tests/src/test/java/okhttp3/ConnectionPoolTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/ConnectionPoolTest.java
@@ -193,9 +193,8 @@ private RealConnection newConnection(ConnectionPool pool, Route route, long idle
 
   private Address newAddress(String name) {
     return new Address(name, 1, Dns.SYSTEM, SocketFactory.getDefault(), null, null, null,
-        new RecordingOkAuthenticator("password"), null, Collections.<Protocol>emptyList(),
-        Collections.<ConnectionSpec>emptyList(),
-        ProxySelector.getDefault());
+        new RecordingOkAuthenticator("password", null), null, Collections.emptyList(),
+        Collections.emptyList(), ProxySelector.getDefault());
   }
 
   private Route newRoute(Address address) {
diff --git a/okhttp-tests/src/test/java/okhttp3/ConnectionReuseTest.java b/okhttp-tests/src/test/java/okhttp3/ConnectionReuseTest.java
index f5c8e75c85..f8c4991120 100644
--- a/okhttp-tests/src/test/java/okhttp3/ConnectionReuseTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/ConnectionReuseTest.java
@@ -15,7 +15,6 @@
  */
 package okhttp3;
 
-import java.io.IOException;
 import java.util.Arrays;
 import java.util.concurrent.TimeUnit;
 import javax.net.ssl.SSLException;
@@ -301,14 +300,18 @@
    * https://github.com/square/okhttp/issues/2409
    */
   @Test public void connectionsAreNotReusedIfNetworkInterceptorInterferes() throws Exception {
-    client = client.newBuilder().addNetworkInterceptor(new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        Response response = chain.proceed(chain.request());
-        return response.newBuilder()
-            .body(ResponseBody.create(null, "unrelated response body!"))
-            .build();
-      }
-    }).build();
+    client = client.newBuilder()
+        // Since this test knowingly leaks a connection, avoid using the default shared connection
+        // pool, which should remain clean for subsequent tests.
+        .connectionPool(new ConnectionPool())
+        .addNetworkInterceptor(chain -> {
+          Response response = chain.proceed(chain.request());
+          return response
+              .newBuilder()
+              .body(ResponseBody.create(null, "unrelated response body!"))
+              .build();
+        })
+        .build();
 
     server.enqueue(new MockResponse()
         .setResponseCode(301)
diff --git a/okhttp-tests/src/test/java/okhttp3/ConnectionSpecTest.java b/okhttp-tests/src/test/java/okhttp3/ConnectionSpecTest.java
index c74a6b314c..13b2824f06 100644
--- a/okhttp-tests/src/test/java/okhttp3/ConnectionSpecTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/ConnectionSpecTest.java
@@ -297,6 +297,7 @@
         + "supportsTlsExtensions=true)", connectionSpec.toString());
   }
 
+  @SafeVarargs
   private static <T> Set<T> set(T... values) {
     return new LinkedHashSet<>(Arrays.asList(values));
   }
diff --git a/okhttp-tests/src/test/java/okhttp3/CookieTest.java b/okhttp-tests/src/test/java/okhttp3/CookieTest.java
index b38dd3dd9a..3304fa588a 100644
--- a/okhttp-tests/src/test/java/okhttp3/CookieTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CookieTest.java
@@ -27,6 +27,7 @@
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
@@ -79,20 +80,20 @@
   }
 
   @Test public void invalidCharacters() throws Exception {
-    assertEquals(null, Cookie.parse(url, "a\u0000b=cd"));
-    assertEquals(null, Cookie.parse(url, "ab=c\u0000d"));
-    assertEquals(null, Cookie.parse(url, "a\u0001b=cd"));
-    assertEquals(null, Cookie.parse(url, "ab=c\u0001d"));
-    assertEquals(null, Cookie.parse(url, "a\u0009b=cd"));
-    assertEquals(null, Cookie.parse(url, "ab=c\u0009d"));
-    assertEquals(null, Cookie.parse(url, "a\u001fb=cd"));
-    assertEquals(null, Cookie.parse(url, "ab=c\u001fd"));
-    assertEquals(null, Cookie.parse(url, "a\u007fb=cd"));
-    assertEquals(null, Cookie.parse(url, "ab=c\u007fd"));
-    assertEquals(null, Cookie.parse(url, "a\u0080b=cd"));
-    assertEquals(null, Cookie.parse(url, "ab=c\u0080d"));
-    assertEquals(null, Cookie.parse(url, "a\u00ffb=cd"));
-    assertEquals(null, Cookie.parse(url, "ab=c\u00ffd"));
+    assertNull(Cookie.parse(url, "a\u0000b=cd"));
+    assertNull(Cookie.parse(url, "ab=c\u0000d"));
+    assertNull(Cookie.parse(url, "a\u0001b=cd"));
+    assertNull(Cookie.parse(url, "ab=c\u0001d"));
+    assertNull(Cookie.parse(url, "a\u0009b=cd"));
+    assertNull(Cookie.parse(url, "ab=c\u0009d"));
+    assertNull(Cookie.parse(url, "a\u001fb=cd"));
+    assertNull(Cookie.parse(url, "ab=c\u001fd"));
+    assertNull(Cookie.parse(url, "a\u007fb=cd"));
+    assertNull(Cookie.parse(url, "ab=c\u007fd"));
+    assertNull(Cookie.parse(url, "a\u0080b=cd"));
+    assertNull(Cookie.parse(url, "ab=c\u0080d"));
+    assertNull(Cookie.parse(url, "a\u00ffb=cd"));
+    assertNull(Cookie.parse(url, "ab=c\u00ffd"));
   }
 
   @Test public void maxAge() throws Exception {
@@ -523,7 +524,7 @@
         .hostOnlyDomain("example.com")
         .secure()
         .build();
-    assertEquals(true, cookie.secure());
+    assertTrue(cookie.secure());
   }
 
   @Test public void builderHttpOnly() throws Exception {
@@ -533,7 +534,7 @@
         .hostOnlyDomain("example.com")
         .httpOnly()
         .build();
-    assertEquals(true, cookie.httpOnly());
+    assertTrue(cookie.httpOnly());
   }
 
   @Test public void builderIpv6() throws Exception {
@@ -563,11 +564,11 @@
           assertEquals(cookieA.hashCode(), cookieB.hashCode());
           assertEquals(cookieA, cookieB);
         } else {
-          assertFalse(cookieA.hashCode() == cookieB.hashCode());
-          assertFalse(cookieA.equals(cookieB));
+          assertNotEquals(cookieA.hashCode(), cookieB.hashCode());
+          assertNotEquals(cookieA, cookieB);
         }
       }
-      assertFalse(cookieA.equals(null));
+      assertNotEquals(null, cookieA);
     }
   }
 
diff --git a/okhttp-tests/src/test/java/okhttp3/CookiesTest.java b/okhttp-tests/src/test/java/okhttp3/CookiesTest.java
index 17489b045d..add061e3fe 100644
--- a/okhttp-tests/src/test/java/okhttp3/CookiesTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CookiesTest.java
@@ -36,6 +36,7 @@
 import static java.net.CookiePolicy.ACCEPT_ORIGINAL_SERVER;
 import static okhttp3.TestUtil.defaultClient;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
@@ -66,12 +67,12 @@ public void testNetscapeResponse() throws Exception {
     HttpCookie cookie = cookies.get(0);
     assertEquals("a", cookie.getName());
     assertEquals("android", cookie.getValue());
-    assertEquals(null, cookie.getComment());
-    assertEquals(null, cookie.getCommentURL());
-    assertEquals(false, cookie.getDiscard());
+    assertNull(cookie.getComment());
+    assertNull(cookie.getCommentURL());
+    assertFalse(cookie.getDiscard());
     assertTrue(cookie.getMaxAge() > 100000000000L);
     assertEquals("/path", cookie.getPath());
-    assertEquals(true, cookie.getSecure());
+    assertTrue(cookie.getSecure());
     assertEquals(0, cookie.getVersion());
   }
 
@@ -98,11 +99,11 @@ public void testNetscapeResponse() throws Exception {
     HttpCookie cookie = cookies.get(0);
     assertEquals("a", cookie.getName());
     assertEquals("android", cookie.getValue());
-    assertEquals(null, cookie.getCommentURL());
-    assertEquals(false, cookie.getDiscard());
+    assertNull(cookie.getCommentURL());
+    assertFalse(cookie.getDiscard());
     assertEquals(60.0, cookie.getMaxAge(), 1.0); // Converting to a fixed date can cause rounding!
     assertEquals("/path", cookie.getPath());
-    assertEquals(true, cookie.getSecure());
+    assertTrue(cookie.getSecure());
   }
 
   @Test public void testQuotedAttributeValues() throws Exception {
@@ -133,7 +134,7 @@ public void testNetscapeResponse() throws Exception {
     assertEquals("android", cookie.getValue());
     assertEquals(60.0, cookie.getMaxAge(), 1.0); // Converting to a fixed date can cause rounding!
     assertEquals("/path", cookie.getPath());
-    assertEquals(true, cookie.getSecure());
+    assertTrue(cookie.getSecure());
   }
 
   @Test public void testSendingCookiesFromStore() throws Exception {
diff --git a/okhttp-tests/src/test/java/okhttp3/DelegatingSSLSocket.java b/okhttp-tests/src/test/java/okhttp3/DelegatingSSLSocket.java
index fc863c2022..e6c931b6ad 100644
--- a/okhttp-tests/src/test/java/okhttp3/DelegatingSSLSocket.java
+++ b/okhttp-tests/src/test/java/okhttp3/DelegatingSSLSocket.java
@@ -320,6 +320,7 @@ public String getHandshakeApplicationProtocol() {
     }
   }
 
+  @SuppressWarnings("unchecked") // Using reflection to delegate.
   public <T> T getOption(SocketOption<T> name) throws IOException {
     try {
       return (T) SSLSocket.class.getMethod("getOption", SocketOption.class).invoke(delegate, name);
@@ -328,6 +329,7 @@ public String getHandshakeApplicationProtocol() {
     }
   }
 
+  @SuppressWarnings("unchecked") // Using reflection to delegate.
   public Set<SocketOption<?>> supportedOptions() {
     try {
       return (Set<SocketOption<?>>) SSLSocket.class.getMethod("supportedOptions").invoke(delegate);
diff --git a/okhttp-tests/src/test/java/okhttp3/DispatcherTest.java b/okhttp-tests/src/test/java/okhttp3/DispatcherTest.java
index cba980294c..3e7b1cddef 100644
--- a/okhttp-tests/src/test/java/okhttp3/DispatcherTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/DispatcherTest.java
@@ -1,6 +1,7 @@
 package okhttp3;
 
 import java.io.IOException;
+import java.io.InterruptedIOException;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
@@ -10,6 +11,7 @@
 import java.util.Set;
 import java.util.concurrent.AbstractExecutorService;
 import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.RejectedExecutionException;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 import okhttp3.RealCall.AsyncCall;
@@ -28,13 +30,16 @@
   RecordingCallback callback = new RecordingCallback();
   RecordingWebSocketListener webSocketListener = new RecordingWebSocketListener();
   Dispatcher dispatcher = new Dispatcher(executor);
+  RecordingEventListener listener = new RecordingEventListener();
   OkHttpClient client = defaultClient().newBuilder()
       .dispatcher(dispatcher)
+      .eventListener(listener)
       .build();
 
   @Before public void setUp() throws Exception {
     dispatcher.setMaxRequests(20);
     dispatcher.setMaxRequestsPerHost(10);
+    listener.forbidLock(dispatcher);
   }
 
   @Test public void maxRequestsZero() throws Exception {
@@ -164,21 +169,18 @@
   }
 
   @Test public void synchronousCallAccessors() throws Exception {
-    final CountDownLatch ready = new CountDownLatch(2);
-    final CountDownLatch waiting = new CountDownLatch(1);
+    CountDownLatch ready = new CountDownLatch(2);
+    CountDownLatch waiting = new CountDownLatch(1);
     client = client.newBuilder()
-        .addInterceptor(
-            new Interceptor() {
-              @Override public Response intercept(Chain chain) throws IOException {
-                try {
-                  ready.countDown();
-                  waiting.await();
-                } catch (InterruptedException e) {
-                  throw new AssertionError();
-                }
-                throw new IOException();
-              }
-            })
+        .addInterceptor(chain -> {
+          try {
+            ready.countDown();
+            waiting.await();
+          } catch (InterruptedException e) {
+            throw new AssertionError();
+          }
+          throw new IOException();
+        })
         .build();
 
     Call a1 = client.newCall(newRequest("http://a/1"));
@@ -226,31 +228,25 @@
   }
 
   @Test public void idleCallbackInvokedWhenIdle() throws Exception {
-    final AtomicBoolean idle = new AtomicBoolean();
-    dispatcher.setIdleCallback(new Runnable() {
-      @Override public void run() {
-        idle.set(true);
-      }
-    });
+    AtomicBoolean idle = new AtomicBoolean();
+    dispatcher.setIdleCallback(() -> idle.set(true));
 
     client.newCall(newRequest("http://a/1")).enqueue(callback);
     client.newCall(newRequest("http://a/2")).enqueue(callback);
     executor.finishJob("http://a/1");
     assertFalse(idle.get());
 
-    final CountDownLatch ready = new CountDownLatch(1);
-    final CountDownLatch proceed = new CountDownLatch(1);
+    CountDownLatch ready = new CountDownLatch(1);
+    CountDownLatch proceed = new CountDownLatch(1);
     client = client.newBuilder()
-        .addInterceptor(new Interceptor() {
-          @Override public Response intercept(Chain chain) throws IOException {
-            ready.countDown();
-            try {
-              proceed.await(5, SECONDS);
-            } catch (InterruptedException e) {
-              throw new RuntimeException(e);
-            }
-            return chain.proceed(chain.request());
+        .addInterceptor(chain -> {
+          ready.countDown();
+          try {
+            proceed.await(5, SECONDS);
+          } catch (InterruptedException e) {
+            throw new RuntimeException(e);
           }
+          return chain.proceed(chain.request());
         })
         .build();
 
@@ -264,7 +260,56 @@
     assertTrue(idle.get());
   }
 
-  private <T> Set<T> set(T... values) {
+  @Test public void executionRejectedImmediately() throws Exception {
+    Request request = newRequest("http://a/1");
+    executor.shutdown();
+    client.newCall(request).enqueue(callback);
+    callback.await(request.url()).assertFailure(InterruptedIOException.class);
+    assertEquals(Arrays.asList("CallStart", "CallFailed"), listener.recordedEventTypes());
+  }
+
+  @Test public void executionRejectedAfterMaxRequestsChange() throws Exception {
+    Request request1 = newRequest("http://a/1");
+    Request request2 = newRequest("http://a/2");
+    dispatcher.setMaxRequests(1);
+    client.newCall(request1).enqueue(callback);
+    executor.shutdown();
+    client.newCall(request2).enqueue(callback);
+    dispatcher.setMaxRequests(2); // Trigger promotion.
+    callback.await(request2.url()).assertFailure(InterruptedIOException.class);
+
+    assertEquals(Arrays.asList("CallStart", "CallStart", "CallFailed"),
+        listener.recordedEventTypes());
+  }
+
+  @Test public void executionRejectedAfterMaxRequestsPerHostChange() throws Exception {
+    Request request1 = newRequest("http://a/1");
+    Request request2 = newRequest("http://a/2");
+    dispatcher.setMaxRequestsPerHost(1);
+    client.newCall(request1).enqueue(callback);
+    executor.shutdown();
+    client.newCall(request2).enqueue(callback);
+    dispatcher.setMaxRequestsPerHost(2); // Trigger promotion.
+    callback.await(request2.url()).assertFailure(InterruptedIOException.class);
+    assertEquals(Arrays.asList("CallStart", "CallStart", "CallFailed"),
+        listener.recordedEventTypes());
+  }
+
+  @Test public void executionRejectedAfterPrecedingCallFinishes() throws Exception {
+    Request request1 = newRequest("http://a/1");
+    Request request2 = newRequest("http://a/2");
+    dispatcher.setMaxRequests(1);
+    client.newCall(request1).enqueue(callback);
+    executor.shutdown();
+    client.newCall(request2).enqueue(callback);
+    executor.finishJob("http://a/1"); // Trigger promotion.
+    callback.await(request2.url()).assertFailure(InterruptedIOException.class);
+    assertEquals(Arrays.asList("CallStart", "CallStart", "CallFailed"),
+        listener.recordedEventTypes());
+  }
+
+  @SafeVarargs
+  private final <T> Set<T> set(T... values) {
     return set(Arrays.asList(values));
   }
 
@@ -272,24 +317,24 @@
     return new LinkedHashSet<>(list);
   }
 
-  private Thread makeSynchronousCall(final Call call) {
-    Thread thread = new Thread() {
-      @Override public void run() {
-        try {
-          call.execute();
-          throw new AssertionError();
-        } catch (IOException expected) {
-        }
+  private Thread makeSynchronousCall(Call call) {
+    Thread thread = new Thread(() -> {
+      try {
+        call.execute();
+        throw new AssertionError();
+      } catch (IOException expected) {
       }
-    };
+    });
     thread.start();
     return thread;
   }
 
   class RecordingExecutor extends AbstractExecutorService {
+    private boolean shutdown;
     private List<AsyncCall> calls = new ArrayList<>();
 
     @Override public void execute(Runnable command) {
+      if (shutdown) throw new RejectedExecutionException();
       calls.add((AsyncCall) command);
     }
 
@@ -314,7 +359,7 @@ public void finishJob(String url) {
     }
 
     @Override public void shutdown() {
-      throw new UnsupportedOperationException();
+      shutdown = true;
     }
 
     @Override public List<Runnable> shutdownNow() {
diff --git a/okhttp-tests/src/test/java/okhttp3/DuplexTest.java b/okhttp-tests/src/test/java/okhttp3/DuplexTest.java
new file mode 100644
index 0000000000..c911c700e2
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/DuplexTest.java
@@ -0,0 +1,283 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicReference;
+import okhttp3.internal.duplex.DuplexRequestBody;
+import okhttp3.internal.duplex.MwsDuplexAccess;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
+import okhttp3.mockwebserver.internal.duplex.DuplexResponseBody;
+import okhttp3.tls.HandshakeCertificates;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import org.junit.rules.Timeout;
+
+import static junit.framework.TestCase.assertTrue;
+import static okhttp3.TestUtil.defaultClient;
+import static okhttp3.tls.internal.TlsUtil.localhost;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+
+public final class DuplexTest {
+  @Rule public final TestRule timeout = new Timeout(30_000, TimeUnit.MILLISECONDS);
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private HandshakeCertificates handshakeCertificates = localhost();
+  private OkHttpClient client = defaultClient();
+
+  @Test public void trueDuplexClientWritesFirst() throws IOException {
+    MockResponse mockResponse = new MockResponse();
+    mockResponse.clearHeaders();
+    MwsDuplexAccess.instance.setBody(mockResponse, new DuplexResponseBody() {
+      @Override public void onRequest(RecordedRequest request,
+          BufferedSource requestBody, BufferedSink responseBody) throws IOException {
+
+        assertEquals("request A", requestBody.readUtf8Line());
+        responseBody.writeUtf8("response B\n");
+        responseBody.flush();
+
+        assertEquals("request C", requestBody.readUtf8Line());
+        responseBody.writeUtf8("response D\n");
+        responseBody.flush();
+
+        assertEquals("request E", requestBody.readUtf8Line());
+        responseBody.writeUtf8("response F\n");
+        responseBody.flush();
+
+        assertNull(requestBody.readUtf8Line());
+        requestBody.close();
+        responseBody.close();
+      }
+    });
+    server.enqueue(mockResponse);
+    enableProtocol(Protocol.HTTP_2);
+
+    DuplexRequestBody duplexRequestBody = new DuplexRequestBody(null, 128);
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .post(duplexRequestBody)
+        .build());
+
+    BufferedSink requestBody = duplexRequestBody.createSink();
+    requestBody.writeUtf8("request A\n");
+    requestBody.flush();
+
+    try (Response response = call.execute()) {
+      BufferedSource responseBody = response.body().source();
+      assertEquals("response B", responseBody.readUtf8Line());
+
+      requestBody.writeUtf8("request C\n");
+      requestBody.flush();
+      assertEquals("response D", responseBody.readUtf8Line());
+
+      requestBody.writeUtf8("request E\n");
+      requestBody.flush();
+      assertEquals("response F", responseBody.readUtf8Line());
+
+      requestBody.close();
+      assertNull(responseBody.readUtf8Line());
+    }
+  }
+
+  @Test public void trueDuplexServerWritesFirst() throws IOException {
+    MockResponse mockResponse = new MockResponse();
+    mockResponse.clearHeaders();
+    MwsDuplexAccess.instance.setBody(mockResponse, new DuplexResponseBody() {
+      @Override public void onRequest(RecordedRequest request,
+          BufferedSource requestBody, BufferedSink responseBody) throws IOException {
+        responseBody.writeUtf8("response A\n");
+        responseBody.flush();
+        assertEquals("request B", requestBody.readUtf8Line());
+
+        responseBody.writeUtf8("response C\n");
+        responseBody.flush();
+        assertEquals("request D", requestBody.readUtf8Line());
+
+        responseBody.writeUtf8("response E\n");
+        responseBody.flush();
+        assertEquals("request F", requestBody.readUtf8Line());
+
+        responseBody.close();
+      }
+    });
+    server.enqueue(mockResponse);
+    enableProtocol(Protocol.HTTP_2);
+
+    DuplexRequestBody duplexRequestBody = new DuplexRequestBody(null, 128);
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .post(duplexRequestBody)
+        .build());
+
+    BufferedSink requestBody = duplexRequestBody.createSink();
+
+    try (Response response = call.execute()) {
+      BufferedSource responseBody = response.body().source();
+
+      assertEquals("response A", responseBody.readUtf8Line());
+      requestBody.writeUtf8("request B\n");
+      requestBody.flush();
+
+      assertEquals("response C", responseBody.readUtf8Line());
+      requestBody.writeUtf8("request D\n");
+      requestBody.flush();
+
+      assertEquals("response E", responseBody.readUtf8Line());
+      requestBody.writeUtf8("request F\n");
+      requestBody.flush();
+
+      assertNull(responseBody.readUtf8Line());
+      requestBody.close();
+    }
+  }
+
+  @Test public void clientReadsHeadersDataTrailers() throws IOException {
+    final LatchParty latchParty = new LatchParty();
+    MockResponse mockResponse = new MockResponse()
+        .clearHeaders()
+        .addHeader("h1", "v1")
+        .addHeader("h2", "v2")
+        .setTrailers(Headers.of("trailers", "boom"));
+    MwsDuplexAccess.instance.setBody(mockResponse, new DuplexResponseBody() {
+      @Override public void onRequest(RecordedRequest request,
+          BufferedSource requestBody, BufferedSink responseBody) throws IOException {
+
+        latchParty.step(1);
+        responseBody.writeUtf8("ok");
+        responseBody.flush();
+
+        latchParty.step(3);
+        responseBody.writeUtf8("taco");
+        responseBody.flush();
+
+        latchParty.step(5);
+        responseBody.close();
+      }
+    });
+    server.enqueue(mockResponse);
+    enableProtocol(Protocol.HTTP_2);
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+
+    try (Response response = call.execute()) {
+      assertEquals(Headers.of("h1", "v1", "h2", "v2"), response.headers());
+
+      latchParty.step(2);
+      BufferedSource responseBody = response.body().source();
+      assertEquals("ok", responseBody.readUtf8(2));
+
+      latchParty.step(4);
+      assertEquals("taco", responseBody.readUtf8(4));
+
+      latchParty.step(6);
+      assertTrue(responseBody.exhausted());
+      assertEquals(Headers.of("trailers", "boom"), response.trailers());
+    }
+  }
+
+  @Test public void serverReadsHeadersData() throws IOException {
+    final AtomicReference<BufferedSource> requestBodySourceRef = new AtomicReference<>();
+
+    MockResponse mockResponse = new MockResponse()
+        .clearHeaders()
+        .addHeader("h1", "v1")
+        .addHeader("h2", "v2");
+    MwsDuplexAccess.instance.setBody(mockResponse, new DuplexResponseBody() {
+      @Override public void onRequest(RecordedRequest request,
+          BufferedSource requestBody, BufferedSink responseBody) throws IOException {
+        responseBody.close();
+
+        requestBodySourceRef.set(requestBody);
+      }
+    });
+    server.enqueue(mockResponse);
+    enableProtocol(Protocol.HTTP_2);
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .method("POST", new DuplexRequestBody(null, 1024L))
+        .build();
+    Call call = client.newCall(request);
+
+    BufferedSink sink = ((DuplexRequestBody) request.body).createSink();
+    sink.writeUtf8("hey\n");
+
+    try (Response response = call.execute()) {
+      sink.writeUtf8("whats going on\n");
+      sink.close();
+
+      // check what the server received
+      BufferedSource requestBody = requestBodySourceRef.get();
+      assertEquals("hey", requestBody.readUtf8Line());
+      assertEquals("whats going on", requestBody.readUtf8Line());
+      assertTrue(requestBody.exhausted());
+    }
+  }
+
+  // TODO(oldergod) write tests for headers discarded with 100 Continue
+
+  /**
+   * Tests that use this will fail unless boot classpath is set. Ex. {@code
+   * -Xbootclasspath/p:/tmp/alpn-boot-8.0.0.v20140317}
+   */
+  private void enableProtocol(Protocol protocol) {
+    enableTls();
+    client = client.newBuilder()
+        .protocols(Arrays.asList(protocol, Protocol.HTTP_1_1))
+        .build();
+    server.setProtocols(client.protocols());
+  }
+
+  private void enableTls() {
+    client = client.newBuilder()
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build();
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
+  }
+
+  static final class LatchParty {
+    private int currentRound = 1;
+
+    synchronized void step(int round) {
+      try {
+        // Wait until I can be released.
+        while (currentRound != round) {
+          wait();
+        }
+
+        // Release the other thread.
+        currentRound++;
+        notifyAll();
+      } catch (InterruptedException e) {
+        throw new AssertionError();
+      }
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/EventListenerTest.java b/okhttp-tests/src/test/java/okhttp3/EventListenerTest.java
index cfc22ce7f3..fd5f2c2813 100644
--- a/okhttp-tests/src/test/java/okhttp3/EventListenerTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/EventListenerTest.java
@@ -16,6 +16,7 @@
 package okhttp3;
 
 import java.io.IOException;
+import java.net.HttpURLConnection;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.net.Proxy;
@@ -42,7 +43,6 @@
 import okhttp3.RecordingEventListener.SecureConnectStart;
 import okhttp3.internal.DoubleInetAddressDns;
 import okhttp3.internal.RecordingOkAuthenticator;
-import okhttp3.internal.SingleInetAddressDns;
 import okhttp3.logging.HttpLoggingInterceptor;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
@@ -80,7 +80,6 @@
   public static final Matcher<Response> anyResponse = CoreMatchers.any(Response.class);
   @Rule public final MockWebServer server = new MockWebServer();
 
-  private final SingleInetAddressDns singleDns = new SingleInetAddressDns();
   private final RecordingEventListener listener = new RecordingEventListener();
   private final HandshakeCertificates handshakeCertificates = localhost();
 
@@ -89,7 +88,6 @@
 
   @Before public void setUp() {
     client = defaultClient().newBuilder()
-        .dns(singleDns)
         .eventListener(listener)
         .build();
 
@@ -437,8 +435,8 @@ private void assertBytesReadWritten(RecordingEventListener listener,
     server.enqueue(new MockResponse());
 
     FakeDns dns = new FakeDns();
-    dns.set("fakeurl", singleDns.lookup(server.getHostName()));
-    dns.set("www.fakeurl", singleDns.lookup(server.getHostName()));
+    dns.set("fakeurl", client.dns().lookup(server.getHostName()));
+    dns.set("www.fakeurl", client.dns().lookup(server.getHostName()));
 
     client = client.newBuilder()
         .dns(dns)
@@ -478,11 +476,7 @@ private void assertBytesReadWritten(RecordingEventListener listener,
   }
 
   @Test public void emptyDnsLookup() {
-    Dns emptyDns = new Dns() {
-      @Override public List<InetAddress> lookup(String hostname) {
-        return Collections.emptyList();
-      }
-    };
+    Dns emptyDns = hostname -> Collections.emptyList();
 
     client = client.newBuilder()
         .dns(emptyDns)
@@ -513,7 +507,7 @@ private void assertBytesReadWritten(RecordingEventListener listener,
     assertEquals(200, response.code());
     response.body().close();
 
-    InetAddress address = singleDns.lookup(server.getHostName()).get(0);
+    InetAddress address = client.dns().lookup(server.getHostName()).get(0);
     InetSocketAddress expectedAddress = new InetSocketAddress(address, server.getPort());
 
     ConnectStart connectStart = listener.removeUpToEvent(ConnectStart.class);
@@ -541,7 +535,7 @@ private void assertBytesReadWritten(RecordingEventListener listener,
     } catch (IOException expected) {
     }
 
-    InetAddress address = singleDns.lookup(server.getHostName()).get(0);
+    InetAddress address = client.dns().lookup(server.getHostName()).get(0);
     InetSocketAddress expectedAddress = new InetSocketAddress(address, server.getPort());
 
     ConnectStart connectStart = listener.removeUpToEvent(ConnectStart.class);
@@ -593,7 +587,7 @@ private void assertBytesReadWritten(RecordingEventListener listener,
     assertEquals(200, response.code());
     response.body().close();
 
-    InetAddress address = singleDns.lookup(server.getHostName()).get(0);
+    InetAddress address = client.dns().lookup(server.getHostName()).get(0);
     InetSocketAddress expectedAddress = new InetSocketAddress(address, server.getPort());
 
     ConnectStart connectStart = listener.removeUpToEvent(ConnectStart.class);
@@ -651,7 +645,7 @@ private void assertBytesReadWritten(RecordingEventListener listener,
 
     client = client.newBuilder()
         .proxy(server.toProxyAddress())
-        .proxyAuthenticator(new RecordingOkAuthenticator("password"))
+        .proxyAuthenticator(new RecordingOkAuthenticator("password", "Basic"))
         .build();
 
     Call call = client.newCall(new Request.Builder()
@@ -911,7 +905,6 @@ private void responseBodyFail(Protocol expectedProtocol) throws IOException {
     assertNotNull(callFailed.ioe);
   }
 
-  @Ignore("the CallEnd event is omitted")
   @Test public void emptyResponseBody() throws IOException {
     server.enqueue(new MockResponse()
         .setBody("")
@@ -931,6 +924,25 @@ private void responseBodyFail(Protocol expectedProtocol) throws IOException {
     assertEquals(expectedEvents, listener.recordedEventTypes());
   }
 
+  @Ignore("CallEnd not emitted")
+  @Test public void emptyResponseBodyConnectionClose() throws IOException {
+    server.enqueue(new MockResponse()
+        .addHeader("Connection", "close")
+        .setBody(""));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    response.body().close();
+
+    List<String> expectedEvents = Arrays.asList("CallStart", "DnsStart", "DnsEnd",
+        "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
+        "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
+        "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
+    assertEquals(expectedEvents, listener.recordedEventTypes());
+  }
+
   @Ignore("this reports CallFailed not CallEnd")
   @Test public void responseBodyClosedClosedWithoutReadingAllData() throws IOException {
     server.enqueue(new MockResponse()
@@ -1086,4 +1098,45 @@ private void enableTlsWithTunnel(boolean tunnelProxy) {
         .build();
     server.useHttps(handshakeCertificates.sslSocketFactory(), tunnelProxy);
   }
+
+  @Test public void redirectUsingSameConnectionEventSequence() throws IOException {
+    server.enqueue(
+        new MockResponse()
+            .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+            .addHeader("Location: /foo"));
+    server.enqueue(new MockResponse());
+
+    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
+    Response response = call.execute();
+
+    List<String> expectedEvents = Arrays.asList("CallStart", "DnsStart", "DnsEnd",
+        "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
+        "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
+        "ResponseBodyEnd", "RequestHeadersStart", "RequestHeadersEnd", "ResponseHeadersStart",
+        "ResponseHeadersEnd", "ResponseBodyStart", "ResponseBodyEnd", "ConnectionReleased",
+        "CallEnd");
+    assertEquals(expectedEvents, listener.recordedEventTypes());
+  }
+
+  @Test
+  public void redirectUsingNewConnectionEventSequence() throws IOException {
+    MockWebServer otherServer = new MockWebServer();
+    server.enqueue(
+        new MockResponse()
+            .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+            .addHeader("Location: " + otherServer.url("/foo")));
+    otherServer.enqueue(new MockResponse());
+
+    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
+    Response response = call.execute();
+
+    List<String> expectedEvents = Arrays.asList("CallStart", "DnsStart", "DnsEnd",
+        "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
+        "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
+        "ResponseBodyEnd", "ConnectionReleased", "DnsStart", "DnsEnd", "ConnectStart", "ConnectEnd",
+        "ConnectionAcquired", "RequestHeadersStart", "RequestHeadersEnd", "ResponseHeadersStart",
+        "ResponseHeadersEnd", "ResponseBodyStart", "ResponseBodyEnd", "ConnectionReleased",
+        "CallEnd");
+    assertEquals(expectedEvents, listener.recordedEventTypes());
+  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/HeadersTest.java b/okhttp-tests/src/test/java/okhttp3/HeadersTest.java
index 8480bac638..42dc64111d 100644
--- a/okhttp-tests/src/test/java/okhttp3/HeadersTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/HeadersTest.java
@@ -16,22 +16,28 @@
 package okhttp3;
 
 import java.io.IOException;
+import java.time.Instant;
 import java.util.Arrays;
 import java.util.Collections;
+import java.util.Date;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 import okhttp3.internal.Internal;
-import okhttp3.internal.Util;
 import okhttp3.internal.http.HttpHeaders;
 import okhttp3.internal.http2.Header;
 import okhttp3.internal.http2.Http2Codec;
+import org.junit.Ignore;
 import org.junit.Test;
 
+import static java.util.Collections.emptyList;
+import static java.util.Collections.emptyMap;
+import static java.util.Collections.singletonList;
+import static java.util.Collections.singletonMap;
 import static okhttp3.TestUtil.headerEntries;
 import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.assertNotEquals;
+import static org.junit.Assert.assertNull;
 import static org.junit.Assert.fail;
 
 public final class HeadersTest {
@@ -40,7 +46,7 @@
   }
 
   @Test public void readNameValueBlockDropsForbiddenHeadersHttp2() throws IOException {
-    List<Header> headerBlock = headerEntries(
+    Headers headerBlock = Headers.of(
         ":status", "200 OK",
         ":version", "HTTP/1.1",
         "connection", "close");
@@ -58,6 +64,7 @@
         .header("Connection", "upgrade")
         .header("Upgrade", "websocket")
         .header("Host", "square.com")
+        .header("TE", "gzip")
         .build();
     List<Header> expected = headerEntries(
         ":method", "GET",
@@ -67,6 +74,19 @@
     assertEquals(expected, Http2Codec.http2HeadersList(request));
   }
 
+  @Test public void http2HeadersListDontDropTeIfTrailersHttp2() {
+    Request request = new Request.Builder()
+        .url("http://square.com/")
+        .header("TE", "trailers")
+        .build();
+    List<Header> expected = headerEntries(
+        ":method", "GET",
+        ":path", "/",
+        ":scheme", "http",
+        "te", "trailers");
+    assertEquals(expected, Http2Codec.http2HeadersList(request));
+  }
+
   @Test public void ofTrims() {
     Headers headers = Headers.of("\t User-Agent \n", " \r OkHttp ");
     assertEquals("User-Agent", headers.name(0));
@@ -117,6 +137,25 @@
     }
   }
 
+  @Test public void addUnsafeNonAsciiRejectsUnicodeName() {
+    try {
+      Headers headers = new Headers.Builder()
+          .addUnsafeNonAscii("h√©ader1", "value1")
+          .build();
+      fail("Should have complained about invalid value");
+    } catch (IllegalArgumentException expected) {
+      assertEquals("Unexpected char 0xe9 at 1 in header name: h√©ader1",
+          expected.getMessage());
+    }
+  }
+
+  @Test public void addUnsafeNonAsciiAcceptsUnicodeValue() {
+    Headers headers = new Headers.Builder()
+        .addUnsafeNonAscii("header1", "valu√©1")
+        .build();
+    assertEquals("header1: valu√©1\n", headers.toString());
+  }
+
   @Test public void ofThrowsOddNumberOfHeaders() {
     try {
       Headers.of("User-Agent", "OkHttp", "Content-Length");
@@ -166,7 +205,7 @@
 
   @Test public void ofMapThrowsOnNull() {
     try {
-      Headers.of(Collections.<String, String>singletonMap("User-Agent", null));
+      Headers.of(Collections.singletonMap("User-Agent", null));
       fail();
     } catch (IllegalArgumentException expected) {
     }
@@ -174,7 +213,7 @@
 
   @Test public void ofMapThrowsOnEmptyName() {
     try {
-      Headers.of(Collections.singletonMap("", "OkHttp"));
+      Headers.of(singletonMap("", "OkHttp"));
       fail();
     } catch (IllegalArgumentException expected) {
     }
@@ -182,24 +221,24 @@
 
   @Test public void ofMapThrowsOnBlankName() {
     try {
-      Headers.of(Collections.singletonMap(" ", "OkHttp"));
+      Headers.of(singletonMap(" ", "OkHttp"));
       fail();
     } catch (IllegalArgumentException expected) {
     }
   }
 
   @Test public void ofMapAcceptsEmptyValue() {
-    Headers headers = Headers.of(Collections.singletonMap("User-Agent", ""));
+    Headers headers = Headers.of(singletonMap("User-Agent", ""));
     assertEquals("", headers.value(0));
   }
 
   @Test public void ofMapTrimsKey() {
-    Headers headers = Headers.of(Collections.singletonMap(" User-Agent ", "OkHttp"));
+    Headers headers = Headers.of(singletonMap(" User-Agent ", "OkHttp"));
     assertEquals("User-Agent", headers.name(0));
   }
 
   @Test public void ofMapTrimsValue() {
-    Headers headers = Headers.of(Collections.singletonMap("User-Agent", " OkHttp "));
+    Headers headers = Headers.of(singletonMap("User-Agent", " OkHttp "));
     assertEquals("OkHttp", headers.value(0));
   }
 
@@ -214,7 +253,7 @@
 
   @Test public void ofMapRejectsNullCharInName() {
     try {
-      Headers.of(Collections.singletonMap("User-\u0000Agent", "OkHttp"));
+      Headers.of(singletonMap("User-\u0000Agent", "OkHttp"));
       fail();
     } catch (IllegalArgumentException expected) {
     }
@@ -222,7 +261,7 @@
 
   @Test public void ofMapRejectsNullCharInValue() {
     try {
-      Headers.of(Collections.singletonMap("User-Agent", "Square\u0000OkHttp"));
+      Headers.of(singletonMap("User-Agent", "Square\u0000OkHttp"));
       fail();
     } catch (IllegalArgumentException expected) {
     }
@@ -309,6 +348,46 @@
     }
   }
 
+  @Test public void varargFactoryRejectsUnicodeInHeaderName() {
+    try {
+      Headers.of("h√©ader1", "value1");
+      fail("Should have complained about invalid value");
+    } catch (IllegalArgumentException expected) {
+      assertEquals("Unexpected char 0xe9 at 1 in header name: h√©ader1",
+          expected.getMessage());
+    }
+  }
+
+  @Test public void varargFactoryRejectsUnicodeInHeaderValue() {
+    try {
+      Headers.of("header1", "valu√©1");
+      fail("Should have complained about invalid value");
+    } catch (IllegalArgumentException expected) {
+      assertEquals("Unexpected char 0xe9 at 4 in header1 value: valu√©1",
+          expected.getMessage());
+    }
+  }
+
+  @Test public void mapFactoryRejectsUnicodeInHeaderName() {
+    try {
+      Headers.of(singletonMap("h√©ader1", "value1"));
+      fail("Should have complained about invalid value");
+    } catch (IllegalArgumentException expected) {
+      assertEquals("Unexpected char 0xe9 at 1 in header name: h√©ader1",
+          expected.getMessage());
+    }
+  }
+
+  @Test public void mapFactoryRejectsUnicodeInHeaderValue() {
+    try {
+      Headers.of(singletonMap("header1", "valu√©1"));
+      fail("Should have complained about invalid value");
+    } catch (IllegalArgumentException expected) {
+      assertEquals("Unexpected char 0xe9 at 4 in header1 value: valu√©1",
+          expected.getMessage());
+    }
+  }
+
   @Test public void headersEquals() {
     Headers headers1 = new Headers.Builder()
         .add("Connection", "close")
@@ -318,7 +397,7 @@
         .add("Connection", "close")
         .add("Transfer-Encoding", "chunked")
         .build();
-    assertTrue(headers1.equals(headers2));
+    assertEquals(headers1, headers2);
     assertEquals(headers1.hashCode(), headers2.hashCode());
   }
 
@@ -331,8 +410,8 @@
         .add("Connection", "keep-alive")
         .add("Transfer-Encoding", "chunked")
         .build();
-    assertFalse(headers1.equals(headers2));
-    assertFalse(headers1.hashCode() == headers2.hashCode());
+    assertNotEquals(headers1, headers2);
+    assertNotEquals(headers1.hashCode(), headers2.hashCode());
   }
 
   @Test public void headersToString() {
@@ -358,8 +437,7 @@
   }
 
   /** See https://github.com/square/okhttp/issues/2780. */
-  @Test public void testDigestChallenges() {
-    // Strict RFC 2617 header.
+  @Test public void testDigestChallengeWithStrictRfc2617Header() {
     Headers headers = new Headers.Builder()
         .add("WWW-Authenticate", "Digest realm=\"myrealm\", nonce=\"fjalskdflwejrlaskdfjlaskdjflaks"
             + "jdflkasdf\", qop=\"auth\", stale=\"FALSE\"")
@@ -368,93 +446,160 @@
     assertEquals(1, challenges.size());
     assertEquals("Digest", challenges.get(0).scheme());
     assertEquals("myrealm", challenges.get(0).realm());
+    Map<String, String> expectedAuthParams = new LinkedHashMap<>();
+    expectedAuthParams.put("realm", "myrealm");
+    expectedAuthParams.put("nonce", "fjalskdflwejrlaskdfjlaskdjflaksjdflkasdf");
+    expectedAuthParams.put("qop", "auth");
+    expectedAuthParams.put("stale", "FALSE");
+    assertEquals(expectedAuthParams, challenges.get(0).authParams());
+  }
 
-    // Not strict RFC 2617 header.
-    headers = new Headers.Builder()
+  @Test public void testDigestChallengeWithDifferentlyOrderedAuthParams() {
+    Headers headers = new Headers.Builder()
         .add("WWW-Authenticate", "Digest qop=\"auth\", realm=\"myrealm\", nonce=\"fjalskdflwejrlask"
             + "dfjlaskdjflaksjdflkasdf\", stale=\"FALSE\"")
         .build();
-    challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
+    List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
     assertEquals(1, challenges.size());
     assertEquals("Digest", challenges.get(0).scheme());
     assertEquals("myrealm", challenges.get(0).realm());
+    Map<String, String> expectedAuthParams = new LinkedHashMap<>();
+    expectedAuthParams.put("realm", "myrealm");
+    expectedAuthParams.put("nonce", "fjalskdflwejrlaskdfjlaskdjflaksjdflkasdf");
+    expectedAuthParams.put("qop", "auth");
+    expectedAuthParams.put("stale", "FALSE");
+    assertEquals(expectedAuthParams, challenges.get(0).authParams());
+  }
 
-    // Not strict RFC 2617 header #2.
-    headers = new Headers.Builder()
+  @Test public void testDigestChallengeWithDifferentlyOrderedAuthParams2() {
+    Headers headers = new Headers.Builder()
         .add("WWW-Authenticate", "Digest qop=\"auth\", nonce=\"fjalskdflwejrlaskdfjlaskdjflaksjdflk"
             + "asdf\", realm=\"myrealm\", stale=\"FALSE\"")
         .build();
-    challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
+    List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
     assertEquals(1, challenges.size());
     assertEquals("Digest", challenges.get(0).scheme());
     assertEquals("myrealm", challenges.get(0).realm());
+    Map<String, String> expectedAuthParams = new LinkedHashMap<>();
+    expectedAuthParams.put("realm", "myrealm");
+    expectedAuthParams.put("nonce", "fjalskdflwejrlaskdfjlaskdjflaksjdflkasdf");
+    expectedAuthParams.put("qop", "auth");
+    expectedAuthParams.put("stale", "FALSE");
+    assertEquals(expectedAuthParams, challenges.get(0).authParams());
+  }
 
-    // Wrong header.
-    headers = new Headers.Builder()
+  @Test public void testDigestChallengeWithMissingRealm() {
+    Headers headers = new Headers.Builder()
         .add("WWW-Authenticate", "Digest qop=\"auth\", underrealm=\"myrealm\", nonce=\"fjalskdflwej"
             + "rlaskdfjlaskdjflaksjdflkasdf\", stale=\"FALSE\"")
         .build();
-    challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
-    assertEquals(0, challenges.size());
+    List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
+    assertEquals(1, challenges.size());
+    assertEquals("Digest", challenges.get(0).scheme());
+    assertNull(challenges.get(0).realm());
+    Map<String, String> expectedAuthParams = new LinkedHashMap<>();
+    expectedAuthParams.put("underrealm", "myrealm");
+    expectedAuthParams.put("nonce", "fjalskdflwejrlaskdfjlaskdjflaksjdflkasdf");
+    expectedAuthParams.put("qop", "auth");
+    expectedAuthParams.put("stale", "FALSE");
+    assertEquals(expectedAuthParams, challenges.get(0).authParams());
+  }
 
-    // Not strict RFC 2617 header with some spaces.
-    headers = new Headers.Builder()
+  @Test public void testDigestChallengeWithAdditionalSpaces() {
+    Headers headers = new Headers.Builder()
         .add("WWW-Authenticate", "Digest qop=\"auth\",    realm=\"myrealm\", nonce=\"fjalskdflwejrl"
             + "askdfjlaskdjflaksjdflkasdf\", stale=\"FALSE\"")
         .build();
-    challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
+    List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
     assertEquals(1, challenges.size());
     assertEquals("Digest", challenges.get(0).scheme());
     assertEquals("myrealm", challenges.get(0).realm());
+    Map<String, String> expectedAuthParams = new LinkedHashMap<>();
+    expectedAuthParams.put("realm", "myrealm");
+    expectedAuthParams.put("nonce", "fjalskdflwejrlaskdfjlaskdjflaksjdflkasdf");
+    expectedAuthParams.put("qop", "auth");
+    expectedAuthParams.put("stale", "FALSE");
+    assertEquals(expectedAuthParams, challenges.get(0).authParams());
+  }
 
-    // Strict RFC 2617 header with some spaces.
-    headers = new Headers.Builder()
+  @Test public void testDigestChallengeWithAdditionalSpacesBeforeFirstAuthParam() {
+    Headers headers = new Headers.Builder()
         .add("WWW-Authenticate", "Digest    realm=\"myrealm\", nonce=\"fjalskdflwejrlaskdfjlaskdjfl"
             + "aksjdflkasdf\", qop=\"auth\", stale=\"FALSE\"")
         .build();
-    challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
+    List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
     assertEquals(1, challenges.size());
     assertEquals("Digest", challenges.get(0).scheme());
     assertEquals("myrealm", challenges.get(0).realm());
+    Map<String, String> expectedAuthParams = new LinkedHashMap<>();
+    expectedAuthParams.put("realm", "myrealm");
+    expectedAuthParams.put("nonce", "fjalskdflwejrlaskdfjlaskdjflaksjdflkasdf");
+    expectedAuthParams.put("qop", "auth");
+    expectedAuthParams.put("stale", "FALSE");
+    assertEquals(expectedAuthParams, challenges.get(0).authParams());
+  }
 
-    // Not strict RFC 2617 camelcased.
-    headers = new Headers.Builder()
+  @Test public void testDigestChallengeWithCamelCasedNames() {
+    Headers headers = new Headers.Builder()
         .add("WWW-Authenticate", "DiGeSt qop=\"auth\", rEaLm=\"myrealm\", nonce=\"fjalskdflwejrlask"
             + "dfjlaskdjflaksjdflkasdf\", stale=\"FALSE\"")
         .build();
-    challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
+    List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
     assertEquals(1, challenges.size());
     assertEquals("DiGeSt", challenges.get(0).scheme());
     assertEquals("myrealm", challenges.get(0).realm());
+    Map<String, String> expectedAuthParams = new LinkedHashMap<>();
+    expectedAuthParams.put("realm", "myrealm");
+    expectedAuthParams.put("nonce", "fjalskdflwejrlaskdfjlaskdjflaksjdflkasdf");
+    expectedAuthParams.put("qop", "auth");
+    expectedAuthParams.put("stale", "FALSE");
+    assertEquals(expectedAuthParams, challenges.get(0).authParams());
+  }
 
+  @Test public void testDigestChallengeWithCamelCasedNames2() {
     // Strict RFC 2617 camelcased.
-    headers = new Headers.Builder()
+    Headers headers = new Headers.Builder()
         .add("WWW-Authenticate", "DIgEsT rEaLm=\"myrealm\", nonce=\"fjalskdflwejrlaskdfjlaskdjflaks"
             + "jdflkasdf\", qop=\"auth\", stale=\"FALSE\"")
         .build();
-    challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
+    List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
     assertEquals(1, challenges.size());
     assertEquals("DIgEsT", challenges.get(0).scheme());
     assertEquals("myrealm", challenges.get(0).realm());
+    Map<String, String> expectedAuthParams = new LinkedHashMap<>();
+    expectedAuthParams.put("realm", "myrealm");
+    expectedAuthParams.put("nonce", "fjalskdflwejrlaskdfjlaskdjflaksjdflkasdf");
+    expectedAuthParams.put("qop", "auth");
+    expectedAuthParams.put("stale", "FALSE");
+    assertEquals(expectedAuthParams, challenges.get(0).authParams());
+  }
 
-    // Unquoted.
-    headers = new Headers.Builder()
+  @Test public void testDigestChallengeWithTokenFormOfAuthParam() {
+    Headers headers = new Headers.Builder()
         .add("WWW-Authenticate", "Digest realm=myrealm").build();
-    challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
-    assertEquals(0, challenges.size());
+    List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
+    assertEquals(1, challenges.size());
+    assertEquals("Digest", challenges.get(0).scheme());
+    assertEquals("myrealm", challenges.get(0).realm());
+    assertEquals(singletonMap("realm", "myrealm"), challenges.get(0).authParams());
+  }
 
+  @Test public void testDigestChallengeWithoutAuthParams() {
     // Scheme only.
-    headers = new Headers.Builder()
+    Headers headers = new Headers.Builder()
         .add("WWW-Authenticate", "Digest").build();
-    challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
-    assertEquals(0, challenges.size());
+    List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
+    assertEquals(1, challenges.size());
+    assertEquals("Digest", challenges.get(0).scheme());
+    assertNull(challenges.get(0).realm());
+    assertEquals(emptyMap(), challenges.get(0).authParams());
   }
 
   @Test public void basicChallenge() {
     Headers headers = new Headers.Builder()
         .add("WWW-Authenticate: Basic realm=\"protected area\"")
         .build();
-    assertEquals(Arrays.asList(new Challenge("Basic", "protected area")),
+    assertEquals(singletonList(new Challenge("Basic", singletonMap("realm", "protected area"))),
         HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
   }
 
@@ -462,7 +607,10 @@
     Headers headers = new Headers.Builder()
         .add("WWW-Authenticate: Basic realm=\"protected area\", charset=\"UTF-8\"")
         .build();
-    assertEquals(Arrays.asList(new Challenge("Basic", "protected area").withCharset(Util.UTF_8)),
+    Map<String, String> expectedAuthParams = new LinkedHashMap<>();
+    expectedAuthParams.put("realm", "protected area");
+    expectedAuthParams.put("charset", "UTF-8");
+    assertEquals(singletonList(new Challenge("Basic", expectedAuthParams)),
         HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
   }
 
@@ -470,7 +618,209 @@
     Headers headers = new Headers.Builder()
         .add("WWW-Authenticate: Basic realm=\"protected area\", charset=\"US-ASCII\"")
         .build();
-    assertEquals(Collections.emptyList(), HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+
+    Map<String, String> expectedAuthParams = new LinkedHashMap<>();
+    expectedAuthParams.put("realm", "protected area");
+    expectedAuthParams.put("charset", "US-ASCII");
+    assertEquals(singletonList(new Challenge("Basic", expectedAuthParams)),
+        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Test public void separatorsBeforeFirstChallenge() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", " ,  , Basic realm=myrealm")
+        .build();
+    assertEquals(singletonList(new Challenge("Basic", singletonMap("realm", "myrealm"))),
+        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Test public void spacesAroundKeyValueSeparator() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Basic realm = \"myrealm\"")
+        .build();
+    assertEquals(singletonList(new Challenge("Basic", singletonMap("realm", "myrealm"))),
+        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Test public void multipleChallengesInOneHeader() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Basic realm = \"myrealm\",Digest")
+        .build();
+    assertEquals(Arrays.asList(
+        new Challenge("Basic", singletonMap("realm", "myrealm")),
+        new Challenge("Digest", Collections.emptyMap())),
+        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Test public void multipleChallengesWithSameSchemeButDifferentRealmInOneHeader() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Basic realm = \"myrealm\",Basic realm=myotherrealm")
+        .build();
+    assertEquals(Arrays.asList(
+        new Challenge("Basic", singletonMap("realm", "myrealm")),
+        new Challenge("Basic", singletonMap("realm", "myotherrealm"))),
+        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Test public void separatorsBeforeFirstAuthParam() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Digest, Basic ,,realm=\"myrealm\"")
+        .build();
+    assertEquals(Arrays.asList(
+        new Challenge("Digest", Collections.emptyMap()),
+        new Challenge("Basic", singletonMap("realm", "myrealm"))),
+        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Test public void onlyCommaBetweenChallenges() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Digest,Basic realm=\"myrealm\"")
+        .build();
+    assertEquals(Arrays.asList(
+        new Challenge("Digest", Collections.emptyMap()),
+        new Challenge("Basic", singletonMap("realm", "myrealm"))),
+        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Test public void multipleSeparatorsBetweenChallenges() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Digest,,,, Basic ,,realm=\"myrealm\"")
+        .build();
+    assertEquals(Arrays.asList(
+        new Challenge("Digest", Collections.emptyMap()),
+        new Challenge("Basic", singletonMap("realm", "myrealm"))),
+        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Test public void unknownAuthParams() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Digest,,,, Basic ,,foo=bar,realm=\"myrealm\"")
+        .build();
+
+    Map<String, String> expectedAuthParams = new LinkedHashMap<>();
+    expectedAuthParams.put("realm", "myrealm");
+    expectedAuthParams.put("foo", "bar");
+    assertEquals(Arrays.asList(
+        new Challenge("Digest", Collections.emptyMap()),
+        new Challenge("Basic", expectedAuthParams)),
+        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Test public void escapedCharactersInQuotedString() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Digest,,,, Basic ,,,realm=\"my\\\\\\\"r\\ealm\"")
+        .build();
+
+    assertEquals(Arrays.asList(
+        new Challenge("Digest", Collections.emptyMap()),
+        new Challenge("Basic", singletonMap("realm", "my\\\"realm"))),
+        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Test public void commaInQuotedStringAndBeforeFirstChallenge() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", ",Digest,,,, Basic ,,,realm=\"my, realm,\"")
+        .build();
+
+    assertEquals(Arrays.asList(
+        new Challenge("Digest", Collections.emptyMap()),
+        new Challenge("Basic", singletonMap("realm", "my, realm,"))),
+        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Test public void unescapedDoubleQuoteInQuotedStringWithEvenNumberOfBackslashesInFront() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Digest,,,, Basic ,,,realm=\"my\\\\\\\\\"r\\ealm\"")
+        .build();
+
+    assertEquals(Arrays.asList(
+        new Challenge("Digest", Collections.emptyMap())),
+        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Test public void unescapedDoubleQuoteInQuotedString() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Digest,,,, Basic ,,,realm=\"my\"realm\"")
+        .build();
+
+    assertEquals(Arrays.asList(
+        new Challenge("Digest", Collections.emptyMap())),
+        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Ignore("TODO(jwilson): reject parameters that use invalid characters")
+  @Test public void doubleQuoteInToken() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Digest,,,, Basic ,,,realm=my\"realm")
+        .build();
+
+    assertEquals(Arrays.asList(
+        new Challenge("Digest", Collections.emptyMap())),
+        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Test public void token68InsteadOfAuthParams() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Other abc==")
+        .build();
+
+    assertEquals(singletonList(
+        new Challenge("Other", singletonMap(null, "abc=="))),
+        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Test public void token68AndAuthParams() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Other abc==, realm=myrealm")
+        .build();
+
+    assertEquals(Arrays.asList(
+        new Challenge("Other", singletonMap(null, "abc=="))),
+        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Test public void repeatedAuthParamKey() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Other realm=myotherrealm, realm=myrealm")
+        .build();
+
+    assertEquals(emptyList(), HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Test public void multipleAuthenticateHeaders() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Digest")
+        .add("WWW-Authenticate", "Basic realm=myrealm")
+        .build();
+
+    assertEquals(Arrays.asList(
+        new Challenge("Digest", Collections.emptyMap()),
+        new Challenge("Basic", singletonMap("realm", "myrealm"))),
+        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Test public void multipleAuthenticateHeadersInDifferentOrder() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Basic realm=myrealm")
+        .add("WWW-Authenticate", "Digest")
+        .build();
+
+    assertEquals(Arrays.asList(
+        new Challenge("Basic", singletonMap("realm", "myrealm")),
+        new Challenge("Digest", Collections.emptyMap())),
+        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Test public void multipleBasicAuthenticateHeaders() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Basic realm=myrealm")
+        .add("WWW-Authenticate", "Basic realm=myotherrealm")
+        .build();
+
+    assertEquals(Arrays.asList(
+        new Challenge("Basic", singletonMap("realm", "myrealm")),
+        new Challenge("Basic", singletonMap("realm", "myotherrealm"))),
+        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
   }
 
   @Test public void byteCount() {
@@ -485,4 +835,86 @@
         .build()
         .byteCount());
   }
+
+  @Test public void addDate() {
+    Date expected = new Date(0L);
+    Headers headers = new Headers.Builder()
+        .add("testDate", expected)
+        .build();
+    assertEquals("Thu, 01 Jan 1970 00:00:00 GMT", headers.get("testDate"));
+    assertEquals(new Date(0L), headers.getDate("testDate"));
+  }
+
+  @Test public void addDateNull() {
+    try {
+      new Headers.Builder()
+          .add("testDate", (Date) null)
+          .build();
+      fail();
+    } catch (NullPointerException expected) {
+      assertEquals("value for name testDate == null", expected.getMessage());
+    }
+  }
+
+  @Test public void addInstant() {
+    Instant expected = Instant.ofEpochMilli(0L);
+    Headers headers = new Headers.Builder()
+        .add("Test-Instant", expected)
+        .build();
+    assertEquals("Thu, 01 Jan 1970 00:00:00 GMT", headers.get("Test-Instant"));
+    assertEquals(expected, headers.getInstant("Test-Instant"));
+  }
+
+  @Test public void addInstantNull() {
+    try {
+      new Headers.Builder()
+          .add("Test-Instant", (Instant) null)
+          .build();
+      fail();
+    } catch (NullPointerException expected) {
+      assertEquals("value for name Test-Instant == null", expected.getMessage());
+    }
+  }
+
+  @Test public void setDate() {
+    Date expected = new Date(1000);
+    Headers headers = new Headers.Builder()
+        .add("testDate", new Date(0L))
+        .set("testDate", expected)
+        .build();
+    assertEquals("Thu, 01 Jan 1970 00:00:01 GMT", headers.get("testDate"));
+    assertEquals(expected, headers.getDate("testDate"));
+  }
+
+  @Test public void setDateNull() {
+    try {
+      new Headers.Builder()
+          .set("testDate", (Date) null)
+          .build();
+      fail();
+    } catch (NullPointerException expected) {
+      assertEquals("value for name testDate == null", expected.getMessage());
+    }
+  }
+
+  @Test public void setInstant() {
+    Instant expected = Instant.ofEpochMilli(1000L);
+    Headers headers = new Headers.Builder()
+        .add("Test-Instant", Instant.ofEpochMilli(0L))
+        .set("Test-Instant", expected)
+        .build();
+    assertEquals("Thu, 01 Jan 1970 00:00:01 GMT", headers.get("Test-Instant"));
+    assertEquals(expected, headers.getInstant("Test-Instant"));
+  }
+
+  @Test public void setInstantNull() {
+    try {
+      new Headers.Builder()
+          .set("Test-Instant", (Instant) null)
+          .build();
+      fail();
+    } catch (NullPointerException expected) {
+      assertEquals("value for name Test-Instant == null", expected.getMessage());
+    }
+  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java b/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java
index 1682765e7e..23a32d7e92 100644
--- a/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java
@@ -15,10 +15,8 @@
  */
 package okhttp3;
 
-import java.net.MalformedURLException;
 import java.net.URI;
 import java.net.URL;
-import java.net.UnknownHostException;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
@@ -44,16 +42,16 @@
         new Object[] { false }
     );
   }
-  
+
   @Parameterized.Parameter
   public boolean useGet;
-  
+
   HttpUrl parse(String url) {
     return useGet
         ? HttpUrl.get(url)
         : HttpUrl.parse(url);
   }
-  
+
   @Test public void parseTrimsAsciiWhitespace() throws Exception {
     HttpUrl expected = parse("http://host/");
     assertEquals(expected, parse("http://host/\f\n\t \r")); // Leading.
@@ -140,10 +138,10 @@ HttpUrl parse(String url) {
     assertEquals(parse("http://host/a/b?query"), base.newBuilder("?query").build());
     assertEquals(parse("http://host/a/b#fragment"), base.newBuilder("#fragment").build());
     assertEquals(parse("http://host/a/b"), base.newBuilder("").build());
-    assertEquals(null, base.newBuilder("ftp://b"));
-    assertEquals(null, base.newBuilder("ht+tp://b"));
-    assertEquals(null, base.newBuilder("ht-tp://b"));
-    assertEquals(null, base.newBuilder("ht.tp://b"));
+    assertNull(base.newBuilder("ftp://b"));
+    assertNull(base.newBuilder("ht+tp://b"));
+    assertNull(base.newBuilder("ht-tp://b"));
+    assertNull(base.newBuilder("ht.tp://b"));
   }
 
   @Test public void redactedUrl() {
@@ -168,10 +166,10 @@ HttpUrl parse(String url) {
 
   @Test public void resolveUnsupportedScheme() throws Exception {
     HttpUrl base = parse("http://a/");
-    assertEquals(null, base.resolve("ftp://b"));
-    assertEquals(null, base.resolve("ht+tp://b"));
-    assertEquals(null, base.resolve("ht-tp://b"));
-    assertEquals(null, base.resolve("ht.tp://b"));
+    assertNull(base.resolve("ftp://b"));
+    assertNull(base.resolve("ht+tp://b"));
+    assertNull(base.resolve("ht-tp://b"));
+    assertNull(base.resolve("ht.tp://b"));
   }
 
   @Test public void resolveSchemeLikePath() throws Exception {
@@ -185,7 +183,7 @@ HttpUrl parse(String url) {
   /** https://tools.ietf.org/html/rfc3986#section-5.4.1 */
   @Test public void rfc3886NormalExamples() {
     HttpUrl url = parse("http://a/b/c/d;p?q");
-    assertEquals(null, url.resolve("g:h")); // No 'g:' scheme in HttpUrl.
+    assertNull(url.resolve("g:h")); // No 'g:' scheme in HttpUrl.
     assertEquals(parse("http://a/b/c/g"), url.resolve("g"));
     assertEquals(parse("http://a/b/c/g"), url.resolve("./g"));
     assertEquals(parse("http://a/b/c/g/"), url.resolve("g/"));
@@ -536,6 +534,10 @@ HttpUrl parse(String url) {
         "Invalid URL host: \"[0:0:0:0:0:1:255.255.255]\"");
   }
 
+  @Test public void hostIpv6Malformed() throws Exception {
+    assertInvalid("http://[::g]/", "Invalid URL host: \"[::g]\"");
+  }
+
   @Test public void hostIpv6CanonicalForm() throws Exception {
     assertEquals("abcd:ef01:2345:6789:abcd:ef01:2345:6789",
         parse("http://[abcd:ef01:2345:6789:abcd:ef01:2345:6789]/").host());
@@ -556,10 +558,11 @@ HttpUrl parse(String url) {
     assertEquals("1::", parse("http://[1:0:0:0:0:0:0:0]/").host());
     assertEquals("::1", parse("http://[0:0:0:0:0:0:0:1]/").host());
     assertEquals("::", parse("http://[0:0:0:0:0:0:0:0]/").host());
+    assertEquals("192.168.1.254", parse("http://[::ffff:c0a8:1fe]/").host());
   }
 
   /** The builder permits square braces but does not require them. */
-  @Test public void hostIPv6Builder() throws Exception {
+  @Test public void hostIpv6Builder() throws Exception {
     HttpUrl base = parse("http://example.com/");
     assertEquals("http://[::1]/", base.newBuilder().host("[::1]").build().toString());
     assertEquals("http://[::1]/", base.newBuilder().host("[::0001]").build().toString());
@@ -573,7 +576,6 @@ HttpUrl parse(String url) {
     assertEquals("0.0.0.0", parse("http://0.0.0.0/").host());
   }
 
-  @Ignore("java.net.IDN strips trailing trailing dots on Java 7, but not on Java 8.")
   @Test public void hostWithTrailingDot() throws Exception {
     assertEquals("host.", parse("http://host./").host());
   }
@@ -774,6 +776,19 @@ HttpUrl parse(String url) {
     }
   }
 
+  @Test public void builderToString() {
+    assertEquals("https://host.com/path", parse("https://host.com/path").newBuilder().toString());
+  }
+
+  @Test public void incompleteBuilderToString() {
+    assertEquals("https:///path",
+        new HttpUrl.Builder().scheme("https").encodedPath("/path").toString());
+    assertEquals("//host.com/path",
+        new HttpUrl.Builder().host("host.com").encodedPath("/path").toString());
+    assertEquals("//host.com:8080/path",
+        new HttpUrl.Builder().host("host.com").encodedPath("/path").port(8080).toString());
+  }
+
   @Test public void minimalUrlComposition() throws Exception {
     HttpUrl url = new HttpUrl.Builder().scheme("http").host("host").build();
     assertEquals("http://host/", url.toString());
@@ -783,8 +798,8 @@ HttpUrl parse(String url) {
     assertEquals("host", url.host());
     assertEquals(80, url.port());
     assertEquals("/", url.encodedPath());
-    assertEquals(null, url.query());
-    assertEquals(null, url.fragment());
+    assertNull(url.query());
+    assertNull(url.fragment());
   }
 
   @Test public void fullUrlComposition() throws Exception {
@@ -1357,7 +1372,7 @@ HttpUrl parse(String url) {
 
   @Test public void fromJavaNetUrlUnsupportedScheme() throws Exception {
     URL javaNetUrl = new URL("mailto:user@example.com");
-    assertEquals(null, HttpUrl.get(javaNetUrl));
+    assertNull(HttpUrl.get(javaNetUrl));
   }
 
   @Test public void fromUri() throws Exception {
@@ -1368,12 +1383,12 @@ HttpUrl parse(String url) {
 
   @Test public void fromUriUnsupportedScheme() throws Exception {
     URI uri = new URI("mailto:user@example.com");
-    assertEquals(null, HttpUrl.get(uri));
+    assertNull(HttpUrl.get(uri));
   }
 
   @Test public void fromUriPartial() throws Exception {
     URI uri = new URI("/path");
-    assertEquals(null, HttpUrl.get(uri));
+    assertNull(HttpUrl.get(uri));
   }
 
   @Test public void composeQueryWithComponents() throws Exception {
@@ -1403,7 +1418,7 @@ HttpUrl parse(String url) {
         .removeAllQueryParameters("a+=& b")
         .build();
     assertEquals("http://host/", url.toString());
-    assertEquals(null, url.queryParameter("a+=& b"));
+    assertNull(url.queryParameter("a+=& b"));
   }
 
   @Test public void composeQueryRemoveEncodedQueryParameter() throws Exception {
@@ -1412,7 +1427,7 @@ HttpUrl parse(String url) {
         .removeAllEncodedQueryParameters("a+=& b")
         .build();
     assertEquals("http://host/", url.toString());
-    assertEquals(null, url.queryParameter("a =& b"));
+    assertNull(url.queryParameter("a =& b"));
   }
 
   @Test public void composeQuerySetQueryParameter() throws Exception {
@@ -1458,7 +1473,7 @@ HttpUrl parse(String url) {
         .build();
     assertEquals(1, url.querySize());
     assertEquals("", url.queryParameterName(0));
-    assertEquals(null, url.queryParameterValue(0));
+    assertNull(url.queryParameterValue(0));
   }
 
   @Test public void ampersandQueryIsTwoNameValuePairsWithEmptyKeys() throws Exception {
@@ -1467,9 +1482,9 @@ HttpUrl parse(String url) {
         .build();
     assertEquals(2, url.querySize());
     assertEquals("", url.queryParameterName(0));
-    assertEquals(null, url.queryParameterValue(0));
+    assertNull(url.queryParameterValue(0));
     assertEquals("", url.queryParameterName(1));
-    assertEquals(null, url.queryParameterValue(1));
+    assertNull(url.queryParameterValue(1));
   }
 
   @Test public void removeAllDoesNotRemoveQueryIfNoParametersWereRemoved() throws Exception {
@@ -1485,9 +1500,9 @@ HttpUrl parse(String url) {
     assertEquals(3, url.querySize());
     assertEquals(new LinkedHashSet<>(Arrays.asList("foo", "bar", "baz")),
         url.queryParameterNames());
-    assertEquals(null, url.queryParameterValue(0));
-    assertEquals(null, url.queryParameterValue(1));
-    assertEquals(null, url.queryParameterValue(2));
+    assertNull(url.queryParameterValue(0));
+    assertNull(url.queryParameterValue(1));
+    assertNull(url.queryParameterValue(2));
     assertEquals(singletonList((String) null), url.queryParameterValues("foo"));
     assertEquals(singletonList((String) null), url.queryParameterValues("bar"));
     assertEquals(singletonList((String) null), url.queryParameterValues("baz"));
@@ -1570,8 +1585,8 @@ HttpUrl parse(String url) {
         .fragment(null)
         .build();
     assertEquals("http://host/", url.toString());
-    assertEquals(null, url.fragment());
-    assertEquals(null, url.encodedFragment());
+    assertNull(url.fragment());
+    assertNull(url.encodedFragment());
   }
 
   @Test public void clearEncodedFragment() throws Exception {
@@ -1580,8 +1595,8 @@ HttpUrl parse(String url) {
         .encodedFragment(null)
         .build();
     assertEquals("http://host/", url.toString());
-    assertEquals(null, url.fragment());
-    assertEquals(null, url.encodedFragment());
+    assertNull(url.fragment());
+    assertNull(url.encodedFragment());
   }
 
   @Test public void topPrivateDomain() {
diff --git a/okhttp-tests/src/test/java/okhttp3/InterceptorTest.java b/okhttp-tests/src/test/java/okhttp3/InterceptorTest.java
index a1ad679f34..7de63fc138 100644
--- a/okhttp-tests/src/test/java/okhttp3/InterceptorTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/InterceptorTest.java
@@ -16,6 +16,8 @@
 package okhttp3;
 
 import java.io.IOException;
+import java.net.ServerSocket;
+import java.net.Socket;
 import java.net.SocketTimeoutException;
 import java.util.Arrays;
 import java.util.Locale;
@@ -62,7 +64,7 @@
         .url("https://localhost:1/")
         .build();
 
-    final Response interceptorResponse = new Response.Builder()
+    Response interceptorResponse = new Response.Builder()
         .request(request)
         .protocol(Protocol.HTTP_1_1)
         .code(200)
@@ -71,11 +73,8 @@
         .build();
 
     client = client.newBuilder()
-        .addInterceptor(new Interceptor() {
-          @Override public Response intercept(Chain chain) throws IOException {
-            return interceptorResponse;
-          }
-        }).build();
+        .addInterceptor(chain -> interceptorResponse)
+        .build();
 
     Response response = client.newCall(request).execute();
     assertSame(interceptorResponse, response);
@@ -84,17 +83,13 @@
   @Test public void networkInterceptorsCannotShortCircuitResponses() throws Exception {
     server.enqueue(new MockResponse().setResponseCode(500));
 
-    Interceptor interceptor = new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        return new Response.Builder()
-            .request(chain.request())
-            .protocol(Protocol.HTTP_1_1)
-            .code(200)
-            .message("Intercepted!")
-            .body(ResponseBody.create(MediaType.get("text/plain; charset=utf-8"), "abc"))
-            .build();
-      }
-    };
+    Interceptor interceptor = chain -> new Response.Builder()
+        .request(chain.request())
+        .protocol(Protocol.HTTP_1_1)
+        .code(200)
+        .message("Intercepted!")
+        .body(ResponseBody.create(MediaType.get("text/plain; charset=utf-8"), "abc"))
+        .build();
     client = client.newBuilder()
         .addNetworkInterceptor(interceptor)
         .build();
@@ -116,11 +111,9 @@
     server.enqueue(new MockResponse());
     server.enqueue(new MockResponse());
 
-    Interceptor interceptor = new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        chain.proceed(chain.request());
-        return chain.proceed(chain.request());
-      }
+    Interceptor interceptor = chain -> {
+      chain.proceed(chain.request());
+      return chain.proceed(chain.request());
     };
     client = client.newBuilder()
         .addNetworkInterceptor(interceptor)
@@ -142,15 +135,13 @@
   @Test public void networkInterceptorsCannotChangeServerAddress() throws Exception {
     server.enqueue(new MockResponse().setResponseCode(500));
 
-    Interceptor interceptor = new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        Address address = chain.connection().route().address();
-        String sameHost = address.url().host();
-        int differentPort = address.url().port() + 1;
-        return chain.proceed(chain.request().newBuilder()
-            .url("http://" + sameHost + ":" + differentPort + "/")
-            .build());
-      }
+    Interceptor interceptor = chain -> {
+      Address address = chain.connection().route().address();
+      String sameHost = address.url().host();
+      int differentPort = address.url().port() + 1;
+      return chain.proceed(chain.request().newBuilder()
+          .url("http://" + sameHost + ":" + differentPort + "/")
+          .build());
     };
     client = client.newBuilder()
         .addNetworkInterceptor(interceptor)
@@ -172,12 +163,10 @@
   @Test public void networkInterceptorsHaveConnectionAccess() throws Exception {
     server.enqueue(new MockResponse());
 
-    Interceptor interceptor = new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        Connection connection = chain.connection();
-        assertNotNull(connection);
-        return chain.proceed(chain.request());
-      }
+    Interceptor interceptor = chain -> {
+      Connection connection = chain.connection();
+      assertNotNull(connection);
+      return chain.proceed(chain.request());
     };
     client = client.newBuilder()
         .addNetworkInterceptor(interceptor)
@@ -194,20 +183,18 @@
         .setBody(gzip("abcabcabc"))
         .addHeader("Content-Encoding: gzip"));
 
-    Interceptor interceptor = new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        // The network request has everything: User-Agent, Host, Accept-Encoding.
-        Request networkRequest = chain.request();
-        assertNotNull(networkRequest.header("User-Agent"));
-        assertEquals(server.getHostName() + ":" + server.getPort(),
-            networkRequest.header("Host"));
-        assertNotNull(networkRequest.header("Accept-Encoding"));
-
-        // The network response also has everything, including the raw gzipped content.
-        Response networkResponse = chain.proceed(networkRequest);
-        assertEquals("gzip", networkResponse.header("Content-Encoding"));
-        return networkResponse;
-      }
+    Interceptor interceptor = chain -> {
+      // The network request has everything: User-Agent, Host, Accept-Encoding.
+      Request networkRequest = chain.request();
+      assertNotNull(networkRequest.header("User-Agent"));
+      assertEquals(server.getHostName() + ":" + server.getPort(),
+          networkRequest.header("Host"));
+      assertNotNull(networkRequest.header("Accept-Encoding"));
+
+      // The network response also has everything, including the raw gzipped content.
+      Response networkResponse = chain.proceed(networkRequest);
+      assertEquals("gzip", networkResponse.header("Content-Encoding"));
+      return networkResponse;
     };
     client = client.newBuilder()
         .addNetworkInterceptor(interceptor)
@@ -231,17 +218,15 @@
   @Test public void networkInterceptorsCanChangeRequestMethodFromGetToPost() throws Exception {
     server.enqueue(new MockResponse());
 
-    Interceptor interceptor = new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        Request originalRequest = chain.request();
-        MediaType mediaType = MediaType.get("text/plain");
-        RequestBody body = RequestBody.create(mediaType, "abc");
-        return chain.proceed(originalRequest.newBuilder()
-            .method("POST", body)
-            .header("Content-Type", mediaType.toString())
-            .header("Content-Length", Long.toString(body.contentLength()))
-            .build());
-      }
+    Interceptor interceptor = chain -> {
+      Request originalRequest = chain.request();
+      MediaType mediaType = MediaType.get("text/plain");
+      RequestBody body = RequestBody.create(mediaType, "abc");
+      return chain.proceed(originalRequest.newBuilder()
+          .method("POST", body)
+          .header("Content-Type", mediaType.toString())
+          .header("Content-Length", Long.toString(body.contentLength()))
+          .build());
     };
     client = client.newBuilder()
         .addNetworkInterceptor(interceptor)
@@ -270,14 +255,12 @@
   private void rewriteRequestToServer(boolean network) throws Exception {
     server.enqueue(new MockResponse());
 
-    addInterceptor(network, new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        Request originalRequest = chain.request();
-        return chain.proceed(originalRequest.newBuilder()
-            .method("POST", uppercase(originalRequest.body()))
-            .addHeader("OkHttp-Intercepted", "yep")
-            .build());
-      }
+    addInterceptor(network, chain -> {
+      Request originalRequest = chain.request();
+      return chain.proceed(originalRequest.newBuilder()
+          .method("POST", uppercase(originalRequest.body()))
+          .addHeader("OkHttp-Intercepted", "yep")
+          .build());
     });
 
     Request request = new Request.Builder()
@@ -308,14 +291,12 @@ private void rewriteResponseFromServer(boolean network) throws Exception {
         .addHeader("Original-Header: foo")
         .setBody("abc"));
 
-    addInterceptor(network, new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        Response originalResponse = chain.proceed(chain.request());
-        return originalResponse.newBuilder()
-            .body(uppercase(originalResponse.body()))
-            .addHeader("OkHttp-Intercepted", "yep")
-            .build();
-      }
+    addInterceptor(network, chain -> {
+      Response originalResponse = chain.proceed(chain.request());
+      return originalResponse.newBuilder()
+          .body(uppercase(originalResponse.body()))
+          .addHeader("OkHttp-Intercepted", "yep")
+          .build();
     });
 
     Request request = new Request.Builder()
@@ -339,27 +320,23 @@ private void rewriteResponseFromServer(boolean network) throws Exception {
   private void multipleInterceptors(boolean network) throws Exception {
     server.enqueue(new MockResponse());
 
-    addInterceptor(network, new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        Request originalRequest = chain.request();
-        Response originalResponse = chain.proceed(originalRequest.newBuilder()
-            .addHeader("Request-Interceptor", "Android") // 1. Added first.
-            .build());
-        return originalResponse.newBuilder()
-            .addHeader("Response-Interceptor", "Donut") // 4. Added last.
-            .build();
-      }
+    addInterceptor(network, chain -> {
+      Request originalRequest = chain.request();
+      Response originalResponse = chain.proceed(originalRequest.newBuilder()
+          .addHeader("Request-Interceptor", "Android") // 1. Added first.
+          .build());
+      return originalResponse.newBuilder()
+          .addHeader("Response-Interceptor", "Donut") // 4. Added last.
+          .build();
     });
-    addInterceptor(network, new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        Request originalRequest = chain.request();
-        Response originalResponse = chain.proceed(originalRequest.newBuilder()
-            .addHeader("Request-Interceptor", "Bob") // 2. Added second.
-            .build());
-        return originalResponse.newBuilder()
-            .addHeader("Response-Interceptor", "Cupcake") // 3. Added third.
-            .build();
-      }
+    addInterceptor(network, chain -> {
+      Request originalRequest = chain.request();
+      Response originalResponse = chain.proceed(originalRequest.newBuilder()
+          .addHeader("Request-Interceptor", "Bob") // 2. Added second.
+          .build());
+      return originalResponse.newBuilder()
+          .addHeader("Response-Interceptor", "Cupcake") // 3. Added third.
+          .build();
     });
 
     Request request = new Request.Builder()
@@ -386,13 +363,11 @@ private void multipleInterceptors(boolean network) throws Exception {
   private void asyncInterceptors(boolean network) throws Exception {
     server.enqueue(new MockResponse());
 
-    addInterceptor(network, new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        Response originalResponse = chain.proceed(chain.request());
-        return originalResponse.newBuilder()
-            .addHeader("OkHttp-Intercepted", "yep")
-            .build();
-      }
+    addInterceptor(network, chain -> {
+      Response originalResponse = chain.proceed(chain.request());
+      return originalResponse.newBuilder()
+          .addHeader("OkHttp-Intercepted", "yep")
+          .build();
     });
 
     Request request = new Request.Builder()
@@ -410,13 +385,12 @@ private void asyncInterceptors(boolean network) throws Exception {
     server.enqueue(new MockResponse().setBody("b"));
 
     client = client.newBuilder()
-        .addInterceptor(new Interceptor() {
-          @Override public Response intercept(Chain chain) throws IOException {
-            Response response1 = chain.proceed(chain.request());
-            response1.body().close();
-            return chain.proceed(chain.request());
-          }
-        }).build();
+        .addInterceptor(chain -> {
+          Response response1 = chain.proceed(chain.request());
+          response1.body().close();
+          return chain.proceed(chain.request());
+        })
+        .build();
 
     Request request = new Request.Builder()
         .url(server.url("/"))
@@ -432,19 +406,18 @@ private void asyncInterceptors(boolean network) throws Exception {
     server.enqueue(new MockResponse().setBody("b")); // Fetched directly.
 
     client = client.newBuilder()
-        .addInterceptor(new Interceptor() {
-          @Override public Response intercept(Chain chain) throws IOException {
-            if (chain.request().url().encodedPath().equals("/b")) {
-              Request requestA = new Request.Builder()
-                  .url(server.url("/a"))
-                  .build();
-              Response responseA = client.newCall(requestA).execute();
-              assertEquals("a", responseA.body().string());
-            }
-
-            return chain.proceed(chain.request());
+        .addInterceptor(chain -> {
+          if (chain.request().url().encodedPath().equals("/b")) {
+            Request requestA = new Request.Builder()
+                .url(server.url("/a"))
+                .build();
+            Response responseA = client.newCall(requestA).execute();
+            assertEquals("a", responseA.body().string());
           }
-        }).build();
+
+          return chain.proceed(chain.request());
+        })
+        .build();
 
     Request requestB = new Request.Builder()
         .url(server.url("/b"))
@@ -459,25 +432,24 @@ private void asyncInterceptors(boolean network) throws Exception {
     server.enqueue(new MockResponse().setBody("b")); // Fetched directly.
 
     client = client.newBuilder()
-        .addInterceptor(new Interceptor() {
-          @Override public Response intercept(Chain chain) throws IOException {
-            if (chain.request().url().encodedPath().equals("/b")) {
-              Request requestA = new Request.Builder()
-                  .url(server.url("/a"))
-                  .build();
-
-              try {
-                RecordingCallback callbackA = new RecordingCallback();
-                client.newCall(requestA).enqueue(callbackA);
-                callbackA.await(requestA.url()).assertBody("a");
-              } catch (Exception e) {
-                throw new RuntimeException(e);
-              }
+        .addInterceptor(chain -> {
+          if (chain.request().url().encodedPath().equals("/b")) {
+            Request requestA = new Request.Builder()
+                .url(server.url("/a"))
+                .build();
+
+            try {
+              RecordingCallback callbackA = new RecordingCallback();
+              client.newCall(requestA).enqueue(callbackA);
+              callbackA.await(requestA.url()).assertBody("a");
+            } catch (Exception e) {
+              throw new RuntimeException(e);
             }
-
-            return chain.proceed(chain.request());
           }
-        }).build();
+
+          return chain.proceed(chain.request());
+        })
+        .build();
 
     Request requestB = new Request.Builder()
         .url(server.url("/b"))
@@ -500,11 +472,7 @@ private void asyncInterceptors(boolean network) throws Exception {
    * with it.
    */
   private void interceptorThrowsRuntimeExceptionSynchronous(boolean network) throws Exception {
-    addInterceptor(network, new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        throw new RuntimeException("boom!");
-      }
-    });
+    addInterceptor(network, chain -> { throw new RuntimeException("boom!"); });
 
     Request request = new Request.Builder()
         .url(server.url("/"))
@@ -521,12 +489,12 @@ private void interceptorThrowsRuntimeExceptionSynchronous(boolean network) throw
   @Test public void networkInterceptorModifiedRequestIsReturned() throws IOException {
     server.enqueue(new MockResponse());
 
-    Interceptor modifyHeaderInterceptor = new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        return chain.proceed(chain.request().newBuilder()
-            .header("User-Agent", "intercepted request")
-            .build());
-      }
+    Interceptor modifyHeaderInterceptor = chain -> {
+      Request modifiedRequest = chain.request()
+          .newBuilder()
+          .header("User-Agent", "intercepted request")
+          .build();
+      return chain.proceed(modifiedRequest);
     };
 
     client = client.newBuilder()
@@ -557,11 +525,7 @@ private void interceptorThrowsRuntimeExceptionSynchronous(boolean network) throw
    * exception goes to the uncaught exception handler.
    */
   private void interceptorThrowsRuntimeExceptionAsynchronous(boolean network) throws Exception {
-    addInterceptor(network, new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        throw new RuntimeException("boom!");
-      }
-    });
+    addInterceptor(network, chain -> { throw new RuntimeException("boom!"); });
 
     ExceptionCatchingExecutor executor = new ExceptionCatchingExecutor();
     client = client.newBuilder()
@@ -579,11 +543,9 @@ private void interceptorThrowsRuntimeExceptionAsynchronous(boolean network) thro
   @Test public void applicationInterceptorReturnsNull() throws Exception {
     server.enqueue(new MockResponse());
 
-    Interceptor interceptor = new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        chain.proceed(chain.request());
-        return null;
-      }
+    Interceptor interceptor = chain -> {
+      chain.proceed(chain.request());
+      return null;
     };
     client = client.newBuilder()
         .addInterceptor(interceptor)
@@ -608,11 +570,9 @@ private void interceptorThrowsRuntimeExceptionAsynchronous(boolean network) thro
   @Test public void networkInterceptorReturnsNull() throws Exception {
     server.enqueue(new MockResponse());
 
-    Interceptor interceptor = new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        chain.proceed(chain.request());
-        return null;
-      }
+    Interceptor interceptor = chain -> {
+      chain.proceed(chain.request());
+      return null;
     };
     client = client.newBuilder()
         .addNetworkInterceptor(interceptor)
@@ -639,12 +599,10 @@ private void interceptorThrowsRuntimeExceptionAsynchronous(boolean network) thro
         .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
         .addHeader("Connection", "Close"));
 
-    Interceptor interceptor = new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        Response response = chain.proceed(chain.request());
-        assertNotNull(chain.connection());
-        return response;
-      }
+    Interceptor interceptor = chain -> {
+      Response response = chain.proceed(chain.request());
+      assertNotNull(chain.connection());
+      return response;
     };
 
     client = client.newBuilder()
@@ -662,10 +620,11 @@ private void interceptorThrowsRuntimeExceptionAsynchronous(boolean network) thro
   @Test public void applicationInterceptorResponseMustHaveBody() throws Exception {
     server.enqueue(new MockResponse());
 
-    Interceptor interceptor = new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        return chain.proceed(chain.request()).newBuilder().body(null).build();
-      }
+    Interceptor interceptor = chain -> {
+      Response response = chain.proceed(chain.request());
+      return response.newBuilder()
+          .body(null)
+          .build();
     };
     client = client.newBuilder()
         .addInterceptor(interceptor)
@@ -686,10 +645,11 @@ private void interceptorThrowsRuntimeExceptionAsynchronous(boolean network) thro
   @Test public void networkInterceptorResponseMustHaveBody() throws Exception {
     server.enqueue(new MockResponse());
 
-    Interceptor interceptor = new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        return chain.proceed(chain.request()).newBuilder().body(null).build();
-      }
+    Interceptor interceptor = chain -> {
+      Response response = chain.proceed(chain.request());
+      return response.newBuilder()
+          .body(null)
+          .build();
     };
     client = client.newBuilder()
         .addNetworkInterceptor(interceptor)
@@ -708,33 +668,38 @@ private void interceptorThrowsRuntimeExceptionAsynchronous(boolean network) thro
   }
 
   @Test public void connectTimeout() throws Exception {
-    Interceptor interceptor1 = new Interceptor() {
-      @Override public Response intercept(Chain chainA) throws IOException {
-        assertEquals(5000, chainA.connectTimeoutMillis());
+    Interceptor interceptor1 = chainA -> {
+      assertEquals(5000, chainA.connectTimeoutMillis());
 
-        Chain chainB = chainA.withConnectTimeout(100, TimeUnit.MILLISECONDS);
-        assertEquals(100, chainB.connectTimeoutMillis());
+      Interceptor.Chain chainB = chainA.withConnectTimeout(100, TimeUnit.MILLISECONDS);
+      assertEquals(100, chainB.connectTimeoutMillis());
 
-        return chainB.proceed(chainA.request());
-      }
+      return chainB.proceed(chainA.request());
     };
 
-    Interceptor interceptor2 = new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        assertEquals(100, chain.connectTimeoutMillis());
-        return chain.proceed(chain.request());
-      }
+    Interceptor interceptor2 = chain -> {
+      assertEquals(100, chain.connectTimeoutMillis());
+      return chain.proceed(chain.request());
     };
 
+    ServerSocket serverSocket = new ServerSocket(0, 1);
+    // Fill backlog queue with this request so subsequent requests will be blocked.
+    new Socket().connect(serverSocket.getLocalSocketAddress());
+
     client = client.newBuilder()
         .connectTimeout(5, TimeUnit.SECONDS)
         .addInterceptor(interceptor1)
         .addInterceptor(interceptor2)
         .build();
 
-    Request request1 = new Request.Builder()
-        .url("http://" + TestUtil.UNREACHABLE_ADDRESS)
-        .build();
+    Request request1 =
+        new Request.Builder()
+            .url(
+                "http://"
+                    + serverSocket.getInetAddress().getCanonicalHostName()
+                    + ":"
+                    + serverSocket.getLocalPort())
+            .build();
     Call call = client.newCall(request1);
 
     try {
@@ -742,25 +707,23 @@ private void interceptorThrowsRuntimeExceptionAsynchronous(boolean network) thro
       fail();
     } catch (SocketTimeoutException expected) {
     }
+
+    serverSocket.close();
   }
 
   @Test public void chainWithReadTimeout() throws Exception {
-    Interceptor interceptor1 = new Interceptor() {
-      @Override public Response intercept(Chain chainA) throws IOException {
-        assertEquals(5000, chainA.readTimeoutMillis());
+    Interceptor interceptor1 = chainA -> {
+      assertEquals(5000, chainA.readTimeoutMillis());
 
-        Chain chainB = chainA.withReadTimeout(100, TimeUnit.MILLISECONDS);
-        assertEquals(100, chainB.readTimeoutMillis());
+      Interceptor.Chain chainB = chainA.withReadTimeout(100, TimeUnit.MILLISECONDS);
+      assertEquals(100, chainB.readTimeoutMillis());
 
-        return chainB.proceed(chainA.request());
-      }
+      return chainB.proceed(chainA.request());
     };
 
-    Interceptor interceptor2 = new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        assertEquals(100, chain.readTimeoutMillis());
-        return chain.proceed(chain.request());
-      }
+    Interceptor interceptor2 = chain -> {
+      assertEquals(100, chain.readTimeoutMillis());
+      return chain.proceed(chain.request());
     };
 
     client = client.newBuilder()
@@ -787,22 +750,18 @@ private void interceptorThrowsRuntimeExceptionAsynchronous(boolean network) thro
   }
 
   @Test public void chainWithWriteTimeout() throws Exception {
-    Interceptor interceptor1 = new Interceptor() {
-      @Override public Response intercept(Chain chainA) throws IOException {
-        assertEquals(5000, chainA.writeTimeoutMillis());
+    Interceptor interceptor1 = chainA -> {
+      assertEquals(5000, chainA.writeTimeoutMillis());
 
-        Chain chainB = chainA.withWriteTimeout(100, TimeUnit.MILLISECONDS);
-        assertEquals(100, chainB.writeTimeoutMillis());
+      Interceptor.Chain chainB = chainA.withWriteTimeout(100, TimeUnit.MILLISECONDS);
+      assertEquals(100, chainB.writeTimeoutMillis());
 
-        return chainB.proceed(chainA.request());
-      }
+      return chainB.proceed(chainA.request());
     };
 
-    Interceptor interceptor2 = new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        assertEquals(100, chain.writeTimeoutMillis());
-        return chain.proceed(chain.request());
-      }
+    Interceptor interceptor2 = chain -> {
+      assertEquals(100, chain.writeTimeoutMillis());
+      return chain.proceed(chain.request());
     };
 
     client = client.newBuilder()
@@ -830,19 +789,17 @@ private void interceptorThrowsRuntimeExceptionAsynchronous(boolean network) thro
   }
 
   @Test public void chainCanCancelCall() throws Exception {
-    final AtomicReference<Call> callRef = new AtomicReference<>();
+    AtomicReference<Call> callRef = new AtomicReference<>();
 
-    Interceptor interceptor = new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        Call call = chain.call();
-        callRef.set(call);
+    Interceptor interceptor = chain -> {
+      Call call = chain.call();
+      callRef.set(call);
 
-        assertFalse(call.isCanceled());
-        call.cancel();
-        assertTrue(call.isCanceled());
+      assertFalse(call.isCanceled());
+      call.cancel();
+      assertTrue(call.isCanceled());
 
-        return chain.proceed(chain.request());
-      }
+      return chain.proceed(chain.request());
     };
 
     client = client.newBuilder()
@@ -863,7 +820,7 @@ private void interceptorThrowsRuntimeExceptionAsynchronous(boolean network) thro
     assertSame(call, callRef.get());
   }
 
-  private RequestBody uppercase(final RequestBody original) {
+  private RequestBody uppercase(RequestBody original) {
     return new RequestBody() {
       @Override public MediaType contentType() {
         return original.contentType();
@@ -882,7 +839,7 @@ private RequestBody uppercase(final RequestBody original) {
     };
   }
 
-  private Sink uppercase(final BufferedSink original) {
+  private Sink uppercase(BufferedSink original) {
     return new ForwardingSink(original) {
       @Override public void write(Buffer source, long byteCount) throws IOException {
         original.writeUtf8(source.readUtf8(byteCount).toUpperCase(Locale.US));
@@ -895,7 +852,7 @@ static ResponseBody uppercase(ResponseBody original) throws IOException {
         Okio.buffer(uppercase(original.source())));
   }
 
-  private static Source uppercase(final Source original) {
+  private static Source uppercase(Source original) {
     return new ForwardingSource(original) {
       @Override public long read(Buffer sink, long byteCount) throws IOException {
         Buffer mixedCase = new Buffer();
@@ -929,17 +886,15 @@ private void addInterceptor(boolean network, Interceptor interceptor) {
     private final BlockingQueue<Exception> exceptions = new LinkedBlockingQueue<>();
 
     public ExceptionCatchingExecutor() {
-      super(1, 1, 0, TimeUnit.SECONDS, new SynchronousQueue<Runnable>());
+      super(1, 1, 0, TimeUnit.SECONDS, new SynchronousQueue<>());
     }
 
-    @Override public void execute(final Runnable runnable) {
-      super.execute(new Runnable() {
-        @Override public void run() {
-          try {
-            runnable.run();
-          } catch (Exception e) {
-            exceptions.add(e);
-          }
+    @Override public void execute(Runnable runnable) {
+      super.execute(() -> {
+        try {
+          runnable.run();
+        } catch (Exception e) {
+          exceptions.add(e);
         }
       });
     }
diff --git a/okhttp-tests/src/test/java/okhttp3/MediaTypeTest.java b/okhttp-tests/src/test/java/okhttp3/MediaTypeTest.java
index f0b194713d..1520bcaf8e 100644
--- a/okhttp-tests/src/test/java/okhttp3/MediaTypeTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/MediaTypeTest.java
@@ -19,14 +19,13 @@
 import java.nio.charset.Charset;
 import java.util.Arrays;
 import java.util.Collection;
-import okhttp3.internal.Util;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+import static java.nio.charset.StandardCharsets.UTF_8;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 /**
@@ -60,7 +59,7 @@ private MediaType parse(String string) {
     assertEquals("plain", mediaType.subtype());
     assertEquals("UTF-8", mediaType.charset().name());
     assertEquals("text/plain;boundary=foo;charset=utf-8", mediaType.toString());
-    assertTrue(mediaType.equals(parse("text/plain;boundary=foo;charset=utf-8")));
+    assertEquals(mediaType, parse("text/plain;boundary=foo;charset=utf-8"));
     assertEquals(mediaType.hashCode(),
         parse("text/plain;boundary=foo;charset=utf-8").hashCode());
   }
@@ -188,11 +187,11 @@ private MediaType parse(String string) {
 
   @Test public void testDefaultCharset() throws Exception {
     MediaType noCharset = parse("text/plain");
-    assertEquals("UTF-8", noCharset.charset(Util.UTF_8).name());
+    assertEquals("UTF-8", noCharset.charset(UTF_8).name());
     assertEquals("US-ASCII", noCharset.charset(Charset.forName("US-ASCII")).name());
 
     MediaType charset = parse("text/plain; charset=iso-8859-1");
-    assertEquals("ISO-8859-1", charset.charset(Util.UTF_8).name());
+    assertEquals("ISO-8859-1", charset.charset(UTF_8).name());
     assertEquals("ISO-8859-1", charset.charset(Charset.forName("US-ASCII")).name());
   }
 
diff --git a/okhttp-tests/src/test/java/okhttp3/MultipartBodyTest.java b/okhttp-tests/src/test/java/okhttp3/MultipartBodyTest.java
index a65d850368..320a690f77 100644
--- a/okhttp-tests/src/test/java/okhttp3/MultipartBodyTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/MultipartBodyTest.java
@@ -20,7 +20,7 @@
 import okio.BufferedSink;
 import org.junit.Test;
 
-import static okhttp3.internal.Util.UTF_8;
+import static java.nio.charset.StandardCharsets.UTF_8;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 
@@ -171,7 +171,7 @@
         + "\r\n"
         + "%22\r\n"
         + "--AaB03x\r\n"
-        + "Content-Disposition: form-data; name=\"field with \u0391\"\r\n"
+        + "Content-Disposition: form-data; name=\"field with \u007e\"\r\n"
         + "Content-Length: 5\r\n"
         + "\r\n"
         + "Alpha\r\n"
@@ -183,7 +183,7 @@
             RequestBody.create(MediaType.get("text/plain; charset=utf-8"), "okay"))
         .addFormDataPart("field with \"", "\"")
         .addFormDataPart("field with %22", "%22")
-        .addFormDataPart("field with \u0391", "Alpha")
+        .addFormDataPart("field with \u007e", "Alpha")
         .build();
 
     Buffer buffer = new Buffer();
diff --git a/okhttp-tests/src/test/java/okhttp3/OkHttpClientTest.java b/okhttp-tests/src/test/java/okhttp3/OkHttpClientTest.java
index ebffe84f68..caf43a52db 100644
--- a/okhttp-tests/src/test/java/okhttp3/OkHttpClientTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/OkHttpClientTest.java
@@ -15,14 +15,17 @@
  */
 package okhttp3;
 
-import java.io.IOException;
 import java.net.CookieHandler;
 import java.net.CookieManager;
 import java.net.ProxySelector;
 import java.net.ResponseCache;
 import java.util.Arrays;
 import java.util.concurrent.TimeUnit;
+import javax.net.ssl.SSLSocketFactory;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
 import org.junit.After;
+import org.junit.Before;
 import org.junit.Test;
 
 import static okhttp3.TestUtil.defaultClient;
@@ -35,8 +38,14 @@
   private static final ProxySelector DEFAULT_PROXY_SELECTOR = ProxySelector.getDefault();
   private static final CookieHandler DEFAULT_COOKIE_HANDLER = CookieManager.getDefault();
   private static final ResponseCache DEFAULT_RESPONSE_CACHE = ResponseCache.getDefault();
+  private final MockWebServer server = new MockWebServer();
+
+  @Before public void setUp() throws Exception {
+    server.start();
+  }
 
   @After public void tearDown() throws Exception {
+    server.shutdown();
     ProxySelector.setDefault(DEFAULT_PROXY_SELECTOR);
     CookieManager.setDefault(DEFAULT_COOKIE_HANDLER);
     ResponseCache.setDefault(DEFAULT_RESPONSE_CACHE);
@@ -44,6 +53,7 @@
 
   @Test public void durationDefaults() {
     OkHttpClient client = defaultClient();
+    assertEquals(0, client.callTimeoutMillis());
     assertEquals(10_000, client.connectTimeoutMillis());
     assertEquals(10_000, client.readTimeoutMillis());
     assertEquals(10_000, client.writeTimeoutMillis());
@@ -52,6 +62,10 @@
 
   @Test public void timeoutValidRange() {
     OkHttpClient.Builder builder = new OkHttpClient.Builder();
+    try {
+      builder.callTimeout(1, TimeUnit.NANOSECONDS);
+    } catch (IllegalArgumentException ignored) {
+    }
     try {
       builder.connectTimeout(1, TimeUnit.NANOSECONDS);
     } catch (IllegalArgumentException ignored) {
@@ -64,6 +78,10 @@
       builder.readTimeout(1, TimeUnit.NANOSECONDS);
     } catch (IllegalArgumentException ignored) {
     }
+    try {
+      builder.callTimeout(365, TimeUnit.DAYS);
+    } catch (IllegalArgumentException ignored) {
+    }
     try {
       builder.connectTimeout(365, TimeUnit.DAYS);
     } catch (IllegalArgumentException ignored) {
@@ -79,11 +97,7 @@
   }
 
   @Test public void clonedInterceptorsListsAreIndependent() throws Exception {
-    Interceptor interceptor = new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        return chain.proceed(chain.request());
-      }
-    };
+    Interceptor interceptor = chain -> chain.proceed(chain.request());
     OkHttpClient original = defaultClient();
     original.newBuilder()
         .addInterceptor(interceptor)
@@ -199,4 +213,26 @@
     assertEquals(1, okHttpClient.protocols().size());
     assertEquals(Protocol.H2_PRIOR_KNOWLEDGE, okHttpClient.protocols().get(0));
   }
+
+  @Test public void nullDefaultProxySelector() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    ProxySelector.setDefault(null);
+
+    OkHttpClient client = defaultClient().newBuilder()
+        .build();
+
+    Request request = new Request.Builder().url(server.url("/")).build();
+    Response response = client.newCall(request).execute();
+    assertEquals("abc", response.body().string());
+  }
+
+  @Test public void sslSocketFactorySetAsSocketFactory() throws Exception {
+    OkHttpClient.Builder builder = new OkHttpClient.Builder();
+    try {
+      builder.socketFactory(SSLSocketFactory.getDefault());
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/RecordedResponse.java b/okhttp-tests/src/test/java/okhttp3/RecordedResponse.java
index d34380cc4f..715cbda383 100644
--- a/okhttp-tests/src/test/java/okhttp3/RecordedResponse.java
+++ b/okhttp-tests/src/test/java/okhttp3/RecordedResponse.java
@@ -19,6 +19,7 @@
 import java.text.SimpleDateFormat;
 import java.util.Arrays;
 import java.util.Date;
+import javax.annotation.Nullable;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
@@ -31,13 +32,13 @@
  */
 public final class RecordedResponse {
   public final Request request;
-  public final Response response;
-  public final WebSocket webSocket;
-  public final String body;
-  public final IOException failure;
+  public final @Nullable Response response;
+  public final @Nullable WebSocket webSocket;
+  public final @Nullable String body;
+  public final @Nullable IOException failure;
 
-  public RecordedResponse(Request request, Response response, WebSocket webSocket, String body,
-      IOException failure) {
+  public RecordedResponse(Request request, @Nullable Response response,
+      @Nullable WebSocket webSocket, @Nullable String body, @Nullable IOException failure) {
     this.request = request;
     this.response = response;
     this.webSocket = webSocket;
diff --git a/okhttp-tests/src/test/java/okhttp3/RecordingEventListener.java b/okhttp-tests/src/test/java/okhttp3/RecordingEventListener.java
index 6799300cdf..ee26e6819f 100644
--- a/okhttp-tests/src/test/java/okhttp3/RecordingEventListener.java
+++ b/okhttp-tests/src/test/java/okhttp3/RecordingEventListener.java
@@ -217,7 +217,7 @@ public String getName() {
       this.inetAddressList = inetAddressList;
     }
 
-    @Nullable @Override public CallEvent closes() {
+    @Override public @Nullable CallEvent closes() {
       return new DnsStart(call, domainName);
     }
   }
@@ -265,7 +265,7 @@ public String getName() {
       this.ioe = ioe;
     }
 
-    @Nullable @Override public CallEvent closes() {
+    @Override public @Nullable CallEvent closes() {
       return new ConnectStart(call, inetSocketAddress, proxy);
     }
   }
@@ -284,7 +284,7 @@ public String getName() {
       this.handshake = handshake;
     }
 
-    @Nullable @Override public CallEvent closes() {
+    @Override public @Nullable CallEvent closes() {
       return new SecureConnectStart(call);
     }
   }
@@ -306,7 +306,7 @@ public String getName() {
       this.connection = connection;
     }
 
-    @Nullable @Override public CallEvent closes() {
+    @Override public @Nullable CallEvent closes() {
       return new ConnectionAcquired(call, connection);
     }
   }
@@ -322,7 +322,7 @@ public String getName() {
       super(call);
     }
 
-    @Nullable @Override public CallEvent closes() {
+    @Override public @Nullable CallEvent closes() {
       return new CallStart(call);
     }
   }
@@ -350,7 +350,7 @@ public String getName() {
       this.headerLength = headerLength;
     }
 
-    @Nullable @Override public CallEvent closes() {
+    @Override public @Nullable CallEvent closes() {
       return new RequestHeadersStart(call);
     }
   }
@@ -369,7 +369,7 @@ public String getName() {
       this.bytesWritten = bytesWritten;
     }
 
-    @Nullable @Override public CallEvent closes() {
+    @Override public @Nullable CallEvent closes() {
       return new RequestBodyStart(call);
     }
   }
@@ -388,7 +388,7 @@ public String getName() {
       this.headerLength = headerLength;
     }
 
-    @Nullable @Override public CallEvent closes() {
+    @Override public @Nullable CallEvent closes() {
       return new RequestHeadersStart(call);
     }
   }
@@ -407,7 +407,7 @@ public String getName() {
       this.bytesRead = bytesRead;
     }
 
-    @Nullable @Override public CallEvent closes() {
+    @Override public @Nullable CallEvent closes() {
       return new ResponseBodyStart(call);
     }
   }
diff --git a/okhttp-tests/src/test/java/okhttp3/RequestTest.java b/okhttp-tests/src/test/java/okhttp3/RequestTest.java
index 50b7bcb53d..a335abc2dc 100644
--- a/okhttp-tests/src/test/java/okhttp3/RequestTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/RequestTest.java
@@ -22,10 +22,10 @@
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.UUID;
-import okhttp3.internal.Util;
 import okio.Buffer;
 import org.junit.Test;
 
+import static java.nio.charset.StandardCharsets.UTF_8;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertSame;
@@ -34,7 +34,7 @@
 public final class RequestTest {
   @Test public void string() throws Exception {
     MediaType contentType = MediaType.get("text/plain; charset=utf-8");
-    RequestBody body = RequestBody.create(contentType, "abc".getBytes(Util.UTF_8));
+    RequestBody body = RequestBody.create(contentType, "abc".getBytes(UTF_8));
     assertEquals(contentType, body.contentType());
     assertEquals(3, body.contentLength());
     assertEquals("616263", bodyToHex(body));
@@ -59,7 +59,7 @@
 
   @Test public void byteArray() throws Exception {
     MediaType contentType = MediaType.get("text/plain");
-    RequestBody body = RequestBody.create(contentType, "abc".getBytes(Util.UTF_8));
+    RequestBody body = RequestBody.create(contentType, "abc".getBytes(UTF_8));
     assertEquals(contentType, body.contentType());
     assertEquals(3, body.contentLength());
     assertEquals("616263", bodyToHex(body));
@@ -68,7 +68,7 @@
 
   @Test public void byteArrayRange() throws Exception {
     MediaType contentType = MediaType.get("text/plain");
-    RequestBody body = RequestBody.create(contentType, ".abcd".getBytes(Util.UTF_8), 1, 3);
+    RequestBody body = RequestBody.create(contentType, ".abcd".getBytes(UTF_8), 1, 3);
     assertEquals(contentType, body.contentType());
     assertEquals(3, body.contentLength());
     assertEquals("616263", bodyToHex(body));
diff --git a/okhttp-tests/src/test/java/okhttp3/ResponseBodyTest.java b/okhttp-tests/src/test/java/okhttp3/ResponseBodyTest.java
index 40f994c526..a64ac17d52 100644
--- a/okhttp-tests/src/test/java/okhttp3/ResponseBodyTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/ResponseBodyTest.java
@@ -27,6 +27,7 @@
 import okio.Okio;
 import org.junit.Test;
 
+import static java.nio.charset.StandardCharsets.UTF_8;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
@@ -256,7 +257,7 @@
     assertEquals(0xef, bytes[0] & 0xff);
     assertEquals(0xbb, bytes[1] & 0xff);
     assertEquals(0xbf, bytes[2] & 0xff);
-    assertEquals("hello", new String(bytes, 3, 5, "UTF-8"));
+    assertEquals("hello", new String(bytes, 3, 5, UTF_8));
   }
 
   @Test public void bytesClosesUnderlyingSource() throws IOException {
@@ -340,7 +341,7 @@
     assertEquals(0xef, bytes.read());
     assertEquals(0xbb, bytes.read());
     assertEquals(0xbf, bytes.read());
-    assertEquals("hello", exhaust(new InputStreamReader(bytes, "utf-8")));
+    assertEquals("hello", exhaust(new InputStreamReader(bytes, UTF_8)));
   }
 
   @Test public void byteStreamClosesUnderlyingSource() throws IOException {
diff --git a/okhttp-tests/src/test/java/okhttp3/SocksProxy.java b/okhttp-tests/src/test/java/okhttp3/SocksProxy.java
index d56241ac91..4675171798 100644
--- a/okhttp-tests/src/test/java/okhttp3/SocksProxy.java
+++ b/okhttp-tests/src/test/java/okhttp3/SocksProxy.java
@@ -61,8 +61,7 @@
 
   private ServerSocket serverSocket;
   private AtomicInteger connectionCount = new AtomicInteger();
-  private final Set<Socket> openSockets =
-      Collections.newSetFromMap(new ConcurrentHashMap<Socket, Boolean>());
+  private final Set<Socket> openSockets = Collections.newSetFromMap(new ConcurrentHashMap<>());
 
   public void play() throws IOException {
     serverSocket = new ServerSocket(0);
diff --git a/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java b/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
index 4306fb21d9..aad4bfa34b 100644
--- a/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
@@ -67,7 +67,6 @@
 import okhttp3.internal.Internal;
 import okhttp3.internal.RecordingAuthenticator;
 import okhttp3.internal.RecordingOkAuthenticator;
-import okhttp3.internal.SingleInetAddressDns;
 import okhttp3.internal.Util;
 import okhttp3.internal.Version;
 import okhttp3.internal.huc.OkHttpURLConnection;
@@ -88,10 +87,12 @@
 import org.junit.Test;
 import org.junit.rules.TemporaryFolder;
 
+import static java.nio.charset.StandardCharsets.US_ASCII;
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static java.util.Locale.US;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
 import static okhttp3.TestUtil.defaultClient;
-import static okhttp3.internal.Util.UTF_8;
 import static okhttp3.internal.http.StatusLine.HTTP_PERM_REDIRECT;
 import static okhttp3.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
 import static okhttp3.internal.huc.OkHttpURLConnection.SELECTED_PROTOCOL;
@@ -325,7 +326,7 @@ private void testRequestBodySurvivesRetries(TransferKind transferKind) throws Ex
     connection = urlFactory.open(server.url("/def").url());
     connection.setDoOutput(true);
     transferKind.setForRequest(connection, 4);
-    connection.getOutputStream().write("body".getBytes("UTF-8"));
+    connection.getOutputStream().write("body".getBytes(UTF_8));
     assertContent("abc", connection);
 
     assertEquals("body", server.takeRequest().getBody().readUtf8());
@@ -342,7 +343,7 @@ private void testRequestBodySurvivesRetries(TransferKind transferKind) throws Ex
     connection.setDoOutput(true);
     connection.setChunkedStreamingMode(100);
     OutputStream os = connection.getOutputStream();
-    os.write("OutputStream is no fun.".getBytes("UTF-8"));
+    os.write("OutputStream is no fun.".getBytes(UTF_8));
     os.close();
 
     try {
@@ -469,12 +470,14 @@ private void testServerClosesOutput(SocketPolicy socketPolicy) throws Exception
     assertContent("This comes after a busted connection", connection2);
 
     // Check that a fresh connection was created, either immediately or after attempting reuse.
+    // We know that a fresh connection was created if the server recorded a request with sequence
+    // number 0. Since the client may have attempted to reuse the broken connection just before
+    // creating a fresh connection, the server may have recorded 2 requests at this point. The order
+    // of recording is non-deterministic.
     RecordedRequest requestAfter = server.takeRequest();
-    if (server.getRequestCount() == 3) {
-      requestAfter = server.takeRequest(); // The failure consumed a response.
-    }
-    // sequence number 0 means the HTTP socket connection was not reused
-    assertEquals(0, requestAfter.getSequenceNumber());
+    assertTrue(
+        requestAfter.getSequenceNumber() == 0
+            || server.getRequestCount() == 3 && server.takeRequest().getSequenceNumber() == 0);
   }
 
   enum WriteKind {BYTE_BY_BYTE, SMALL_BUFFERS, LARGE_BUFFERS}
@@ -717,7 +720,6 @@ private void connectViaHttpsReusingConnections(boolean rebuildClient) throws Exc
     server.enqueue(new MockResponse().setSocketPolicy(FAIL_HANDSHAKE));
 
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .dns(new SingleInetAddressDns())
         .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS))
         .hostnameVerifier(new RecordingHostnameVerifier())
         .sslSocketFactory(
@@ -908,11 +910,11 @@ public Socket createSocket(String host, int port, InetAddress localHost, int loc
 
   @Test public void contentDisagreesWithChunkedHeaderBodyTooShort() throws IOException {
     MockResponse mockResponse = new MockResponse();
-    mockResponse.setChunkedBody("abcde", 5);
+    mockResponse.setChunkedBody("abcdefg", 5);
 
     Buffer truncatedBody = new Buffer();
     Buffer fullBody = mockResponse.getBody();
-    truncatedBody.write(fullBody, fullBody.indexOf((byte) 'e'));
+    truncatedBody.write(fullBody, 4);
     mockResponse.setBody(truncatedBody);
 
     mockResponse.clearHeaders();
@@ -922,9 +924,9 @@ public Socket createSocket(String host, int port, InetAddress localHost, int loc
     server.enqueue(mockResponse);
 
     try {
-      readAscii(urlFactory.open(server.url("/").url()).getInputStream(), 5);
+      readAscii(urlFactory.open(server.url("/").url()).getInputStream(), 7);
       fail();
-    } catch (ProtocolException expected) {
+    } catch (IOException expected) {
     }
   }
 
@@ -1019,7 +1021,6 @@ private void testConnectViaHttpProxyToHttps(ProxyConfig proxyConfig) throws Exce
     // Configure a single IP address for the host and a single configuration, so we only need one
     // failure to fail permanently.
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .dns(new SingleInetAddressDns())
         .sslSocketFactory(
             handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .connectionSpecs(Util.immutableList(ConnectionSpec.MODERN_TLS))
@@ -1540,7 +1541,7 @@ private void testEarlyDisconnectDoesntHarmPooling(TransferKind transferKind) thr
     connection.setChunkedStreamingMode(0); // OkHttp does not honor specific chunk sizes.
     connection.setDoOutput(true);
     OutputStream outputStream = connection.getOutputStream();
-    outputStream.write(body.getBytes("US-ASCII"));
+    outputStream.write(body.getBytes(US_ASCII));
     assertEquals(200, connection.getResponseCode());
     connection.getInputStream().close();
 
@@ -1615,13 +1616,13 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     String credential = Credentials.basic("jesse", "secret");
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .authenticator(new RecordingOkAuthenticator(credential))
+        .authenticator(new RecordingOkAuthenticator(credential, null))
         .build());
 
     connection = urlFactory.open(server.url("/").url());
     connection.setDoOutput(true);
     OutputStream outputStream = connection.getOutputStream();
-    outputStream.write(body.getBytes("UTF-8"));
+    outputStream.write(body.getBytes(UTF_8));
     outputStream.close();
     assertEquals(200, connection.getResponseCode());
     connection.getInputStream().close();
@@ -1669,7 +1670,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     assertTrue(call, call.contains("type=" + Authenticator.RequestorType.SERVER));
     assertTrue(call, call.contains("prompt=Bar"));
     assertTrue(call, call.contains("protocol=http"));
-    assertTrue(call, call.toLowerCase().contains("scheme=basic")); // lowercase for the RI.
+    assertTrue(call, call.toLowerCase(US).contains("scheme=basic")); // lowercase for the RI.
   }
 
   @Test public void allAttributesSetInProxyAuthenticationCallbacks() throws Exception {
@@ -1684,7 +1685,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     assertTrue(call, call.contains("type=" + Authenticator.RequestorType.PROXY));
     assertTrue(call, call.contains("prompt=Bar"));
     assertTrue(call, call.contains("protocol=http"));
-    assertTrue(call, call.toLowerCase().contains("scheme=basic")); // lowercase for the RI.
+    assertTrue(call, call.toLowerCase(US).contains("scheme=basic")); // lowercase for the RI.
   }
 
   private List<String> authCallsForHeader(String authHeader) throws IOException {
@@ -2234,7 +2235,7 @@ private void redirectToAnotherOriginServer(boolean https) throws Exception {
         .addHeader("Location: " + server2.url("/b").url()));
 
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .authenticator(new RecordingOkAuthenticator(Credentials.basic("jesse", "secret")))
+        .authenticator(new RecordingOkAuthenticator(Credentials.basic("jesse", "secret"), null))
         .build());
     assertContent("Page 2", urlFactory.open(server.url("/a").url()));
 
@@ -2304,7 +2305,7 @@ private void testResponseRedirectedWithPost(int redirectCode, TransferKind trans
     connection.addRequestProperty("Content-Type", "text/plain; charset=utf-8");
     connection.addRequestProperty("Transfer-Encoding", "identity");
     OutputStream outputStream = connection.getOutputStream();
-    outputStream.write("ABCD".getBytes("UTF-8"));
+    outputStream.write("ABCD".getBytes(UTF_8));
     outputStream.close();
     assertEquals("Page 2", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
 
@@ -2489,7 +2490,7 @@ private void enqueueClientRequestTimeoutResponses() {
 
     HttpURLConnection connection = urlFactory.open(server.url("/").url());
     connection.setRequestMethod("POST");
-    connection.getOutputStream().write("Hello".getBytes("UTF-8"));
+    connection.getOutputStream().write("Hello".getBytes(UTF_8));
 
     assertEquals(200, connection.getResponseCode());
     assertEquals("Body", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
@@ -2507,7 +2508,7 @@ private void enqueueClientRequestTimeoutResponses() {
     HttpURLConnection connection = urlFactory.open(server.url("/").url());
     connection.setRequestMethod("POST");
     connection.setChunkedStreamingMode(0);
-    connection.getOutputStream().write("Hello".getBytes("UTF-8"));
+    connection.getOutputStream().write("Hello".getBytes(UTF_8));
 
     assertEquals(408, connection.getResponseCode());
     assertEquals(1, server.getRequestCount());
@@ -2585,7 +2586,7 @@ protected ServerSocket configureServerSocket(ServerSocket serverSocket)
     connection = urlFactory.open(server.url("/").url());
     connection.setRequestProperty("Transfer-encoding", "chunked");
     connection.setDoOutput(true);
-    connection.getOutputStream().write("ABC".getBytes("UTF-8"));
+    connection.getOutputStream().write("ABC".getBytes(UTF_8));
     assertEquals(200, connection.getResponseCode());
 
     RecordedRequest request = server.takeRequest();
@@ -2646,9 +2647,6 @@ protected ServerSocket configureServerSocket(ServerSocket serverSocket)
    * https://code.google.com/p/android/issues/detail?id=41576
    */
   @Test public void sameConnectionRedirectAndReuse() throws Exception {
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .dns(new SingleInetAddressDns())
-        .build());
     server.enqueue(new MockResponse()
         .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
         .setSocketPolicy(SHUTDOWN_INPUT_AT_END)
@@ -2708,7 +2706,7 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
 
     connection = urlFactory.open(server.url("/").url());
     connection.setDoOutput(true);
-    byte[] upload = "def".getBytes("UTF-8");
+    byte[] upload = "def".getBytes(UTF_8);
 
     if (transferKind == TransferKind.CHUNKED) {
       connection.setChunkedStreamingMode(0);
@@ -2722,7 +2720,7 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
 
     out.flush(); // Dubious but permitted.
     try {
-      out.write("ghi".getBytes("UTF-8"));
+      out.write("ghi".getBytes(UTF_8));
       fail();
     } catch (IOException expected) {
     }
@@ -3184,7 +3182,7 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
     server.enqueue(new MockResponse().setBody("A"));
 
     String credential = Credentials.basic("jesse", "peanutbutter");
-    RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator(credential);
+    RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator(credential, null);
     urlFactory.setClient(urlFactory.client().newBuilder()
         .authenticator(authenticator)
         .build());
@@ -3206,7 +3204,8 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
     server.enqueue(pleaseAuthenticate);
     server.enqueue(new MockResponse().setBody("A"));
 
-    RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator("oauthed abc123");
+    RecordingOkAuthenticator authenticator
+        = new RecordingOkAuthenticator("oauthed abc123", "Bearer");
     urlFactory.setClient(urlFactory.client().newBuilder()
         .authenticator(authenticator)
         .build());
@@ -3230,7 +3229,7 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
     server.enqueue(new MockResponse().setBody("c"));
 
     RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator(
-        Credentials.basic("jesse", "peanutbutter"));
+        Credentials.basic("jesse", "peanutbutter"), "Basic");
     urlFactory.setClient(urlFactory.client().newBuilder()
         .authenticator(authenticator)
         .build());
@@ -3251,7 +3250,7 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
 
     String credential = Credentials.basic("jesse", "peanutbutter");
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .authenticator(new RecordingOkAuthenticator(credential))
+        .authenticator(new RecordingOkAuthenticator(credential, null))
         .build());
 
     connection = urlFactory.open(server.url("/0").url());
@@ -3265,7 +3264,7 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
 
     String credential = Credentials.basic("jesse", "peanutbutter");
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .authenticator(new RecordingOkAuthenticator(credential))
+        .authenticator(new RecordingOkAuthenticator(credential, null))
         .build());
 
     connection = urlFactory.open(server.url("/").url());
@@ -3531,11 +3530,7 @@ private void zeroLengthPayload(String method) throws Exception {
   }
 
   @Test public void interceptorsNotInvoked() throws Exception {
-    Interceptor interceptor = new Interceptor() {
-      @Override public Response intercept(Chain chain) {
-        throw new AssertionError();
-      }
-    };
+    Interceptor interceptor = chain -> { throw new AssertionError(); };
     urlFactory.setClient(urlFactory.client().newBuilder()
         .addInterceptor(interceptor)
         .addNetworkInterceptor(interceptor)
@@ -3616,11 +3611,7 @@ private void zeroLengthPayload(String method) throws Exception {
   /** Confirm that runtime exceptions thrown inside of OkHttp propagate to the caller. */
   @Test public void unexpectedExceptionSync() throws Exception {
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .dns(new Dns() {
-          @Override public List<InetAddress> lookup(String hostname) {
-            throw new RuntimeException("boom!");
-          }
-        })
+        .dns(hostname -> { throw new RuntimeException("boom!"); })
         .build());
 
     server.enqueue(new MockResponse());
@@ -3637,11 +3628,7 @@ private void zeroLengthPayload(String method) throws Exception {
   /** Confirm that runtime exceptions thrown inside of OkHttp propagate to the caller. */
   @Test public void unexpectedExceptionAsync() throws Exception {
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .dns(new Dns() {
-          @Override public List<InetAddress> lookup(String hostname) {
-            throw new RuntimeException("boom!");
-          }
-        })
+        .dns(hostname -> { throw new RuntimeException("boom!"); })
         .build());
 
     server.enqueue(new MockResponse());
@@ -3756,7 +3743,7 @@ private void assertContent(String expected, HttpURLConnection connection) throws
   }
 
   enum TransferKind {
-    CHUNKED() {
+    CHUNKED {
       @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
         response.setChunkedBody(content, chunkSize);
       }
@@ -3765,7 +3752,7 @@ private void assertContent(String expected, HttpURLConnection connection) throws
         connection.setChunkedStreamingMode(5);
       }
     },
-    FIXED_LENGTH() {
+    FIXED_LENGTH {
       @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
         response.setBody(content);
       }
@@ -3774,7 +3761,7 @@ private void assertContent(String expected, HttpURLConnection connection) throws
         connection.setFixedLengthStreamingMode(contentLength);
       }
     },
-    END_OF_STREAM() {
+    END_OF_STREAM {
       @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
         response.setBody(content);
         response.setSocketPolicy(DISCONNECT_AT_END);
diff --git a/okhttp-tests/src/test/java/okhttp3/WebPlatformUrlTest.java b/okhttp-tests/src/test/java/okhttp3/WebPlatformUrlTest.java
index 605d606fb0..d9b3d442f3 100644
--- a/okhttp-tests/src/test/java/okhttp3/WebPlatformUrlTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/WebPlatformUrlTest.java
@@ -46,7 +46,7 @@
     }
   }
 
-  @Parameter(0)
+  @Parameter
   public WebPlatformUrlTestData testData;
 
   private static final List<String> HTTP_URL_SCHEMES
@@ -58,8 +58,6 @@
       "Parsing: <http://f:\n/c> against <http://example.org/foo/bar>",
       "Parsing: <http://f:999999/c> against <http://example.org/foo/bar>",
       "Parsing: <http://192.0x00A80001> against <about:blank>",
-      // This test fails on Java 7 but passes on Java 8. See HttpUrlTest.hostWithTrailingDot().
-      "Parsing: <http://%30%78%63%30%2e%30%32%35%30.01%2e> against <http://other.com/>",
       "Parsing: <http://%30%78%63%30%2e%30%32%35%30.01> against <http://other.com/>",
       "Parsing: <http://192.168.0.257> against <http://other.com/>",
       "Parsing: <http://ÔºêÔº∏ÔΩÉÔºêÔºéÔºêÔºíÔºïÔºêÔºéÔºêÔºë> against <http://other.com/>"
diff --git a/okhttp-tests/src/test/java/okhttp3/WholeOperationTimeoutTest.java b/okhttp-tests/src/test/java/okhttp3/WholeOperationTimeoutTest.java
new file mode 100644
index 0000000000..09adba67f4
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/WholeOperationTimeoutTest.java
@@ -0,0 +1,319 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.io.InterruptedIOException;
+import java.net.HttpURLConnection;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicReference;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okio.BufferedSink;
+import org.junit.Rule;
+import org.junit.Test;
+
+import static okhttp3.TestUtil.defaultClient;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class WholeOperationTimeoutTest {
+  /** A large response body. Smaller bodies might successfully read after the socket is closed! */
+  private static final String BIG_ENOUGH_BODY = TestUtil.repeat('a', 64 * 1024);
+
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private OkHttpClient client = defaultClient();
+
+  @Test public void defaultConfigIsNoTimeout() throws Exception {
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    Call call = client.newCall(request);
+    assertEquals(0, call.timeout().timeoutNanos());
+  }
+
+  @Test public void configureClientDefault() throws Exception {
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    OkHttpClient timeoutClient = client.newBuilder()
+        .callTimeout(456, TimeUnit.MILLISECONDS)
+        .build();
+
+    Call call = timeoutClient.newCall(request);
+    assertEquals(TimeUnit.MILLISECONDS.toNanos(456), call.timeout().timeoutNanos());
+  }
+
+  @Test public void timeoutWritingRequest() throws Exception {
+    server.enqueue(new MockResponse());
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .post(sleepingRequestBody(500))
+        .build();
+
+    Call call = client.newCall(request);
+    call.timeout().timeout(250, TimeUnit.MILLISECONDS);
+    try {
+      call.execute();
+      fail();
+    } catch (IOException e) {
+      assertTrue(call.isCanceled());
+    }
+  }
+
+  @Test public void timeoutWritingRequestWithEnqueue() throws Exception {
+    server.enqueue(new MockResponse());
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .post(sleepingRequestBody(500))
+        .build();
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    final AtomicReference<Throwable> exceptionRef = new AtomicReference<>();
+
+    Call call = client.newCall(request);
+    call.timeout().timeout(250, TimeUnit.MILLISECONDS);
+    call.enqueue(new Callback() {
+      @Override public void onFailure(Call call, IOException e) {
+        exceptionRef.set(e);
+        latch.countDown();
+      }
+
+      @Override public void onResponse(Call call, Response response) throws IOException {
+        response.close();
+        latch.countDown();
+      }
+    });
+
+    latch.await();
+    assertTrue(call.isCanceled());
+    assertNotNull(exceptionRef.get());
+  }
+
+  @Test public void timeoutProcessing() throws Exception {
+    server.enqueue(new MockResponse()
+        .setHeadersDelay(500, TimeUnit.MILLISECONDS));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    Call call = client.newCall(request);
+    call.timeout().timeout(250, TimeUnit.MILLISECONDS);
+    try {
+      call.execute();
+      fail();
+    } catch (IOException e) {
+      assertTrue(call.isCanceled());
+    }
+  }
+
+  @Test public void timeoutProcessingWithEnqueue() throws Exception {
+    server.enqueue(new MockResponse()
+        .setHeadersDelay(500, TimeUnit.MILLISECONDS));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    final AtomicReference<Throwable> exceptionRef = new AtomicReference<>();
+
+    Call call = client.newCall(request);
+    call.timeout().timeout(250, TimeUnit.MILLISECONDS);
+    call.enqueue(new Callback() {
+      @Override public void onFailure(Call call, IOException e) {
+        exceptionRef.set(e);
+        latch.countDown();
+      }
+
+      @Override public void onResponse(Call call, Response response) throws IOException {
+        response.close();
+        latch.countDown();
+      }
+    });
+
+    latch.await();
+    assertTrue(call.isCanceled());
+    assertNotNull(exceptionRef.get());
+  }
+
+  @Test public void timeoutReadingResponse() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody(BIG_ENOUGH_BODY));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    Call call = client.newCall(request);
+    call.timeout().timeout(250, TimeUnit.MILLISECONDS);
+    Response response = call.execute();
+    Thread.sleep(500);
+    try {
+      response.body().source().readUtf8();
+      fail();
+    } catch (IOException e) {
+      assertTrue(call.isCanceled());
+    }
+  }
+
+  @Test public void timeoutReadingResponseWithEnqueue() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody(BIG_ENOUGH_BODY));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    final AtomicReference<Throwable> exceptionRef = new AtomicReference<>();
+
+    Call call = client.newCall(request);
+    call.timeout().timeout(250, TimeUnit.MILLISECONDS);
+    call.enqueue(new Callback() {
+      @Override public void onFailure(Call call, IOException e) {
+        latch.countDown();
+      }
+
+      @Override public void onResponse(Call call, Response response) throws IOException {
+        try {
+          Thread.sleep(500);
+        } catch (InterruptedException e) {
+          throw new AssertionError();
+        }
+        try {
+          response.body().source().readUtf8();
+          fail();
+        } catch (IOException e) {
+          exceptionRef.set(e);
+        } finally {
+          latch.countDown();
+        }
+      }
+    });
+
+    latch.await();
+    assertTrue(call.isCanceled());
+    assertNotNull(exceptionRef.get());
+  }
+
+  @Test public void singleTimeoutForAllFollowUpRequests() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .setHeader("Location", "/b")
+        .setHeadersDelay(100, TimeUnit.MILLISECONDS));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .setHeader("Location", "/c")
+        .setHeadersDelay(100, TimeUnit.MILLISECONDS));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .setHeader("Location", "/d")
+        .setHeadersDelay(100, TimeUnit.MILLISECONDS));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .setHeader("Location", "/e")
+        .setHeadersDelay(100, TimeUnit.MILLISECONDS));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .setHeader("Location", "/f")
+        .setHeadersDelay(100, TimeUnit.MILLISECONDS));
+    server.enqueue(new MockResponse());
+
+    Request request = new Request.Builder()
+        .url(server.url("/a"))
+        .build();
+
+    Call call = client.newCall(request);
+    call.timeout().timeout(250, TimeUnit.MILLISECONDS);
+    try {
+      call.execute();
+      fail();
+    } catch (IOException e) {
+      assertTrue(call.isCanceled());
+    }
+  }
+
+  @Test
+  public void timeoutFollowingRedirectOnNewConnection() throws Exception {
+    MockWebServer otherServer = new MockWebServer();
+
+    server.enqueue(
+        new MockResponse()
+            .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+            .setHeader("Location", otherServer.url("/")));
+
+    otherServer.enqueue(new MockResponse().setHeadersDelay(500, TimeUnit.MILLISECONDS));
+
+    Request request = new Request.Builder().url(server.url("/")).build();
+
+    Call call = client.newCall(request);
+    call.timeout().timeout(250, TimeUnit.MILLISECONDS);
+    try {
+      Response response = call.execute();
+      fail();
+    } catch (IOException e) {
+      assertTrue(call.isCanceled());
+    }
+  }
+
+  @Test public void noTimeout() throws Exception {
+    server.enqueue(new MockResponse()
+        .setHeadersDelay(250, TimeUnit.MILLISECONDS)
+        .setBody(BIG_ENOUGH_BODY));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .post(sleepingRequestBody(250))
+        .build();
+
+    Call call = client.newCall(request);
+    call.timeout().timeout(1000, TimeUnit.MILLISECONDS);
+    Response response = call.execute();
+    Thread.sleep(250);
+    response.body().source().readUtf8();
+    response.close();
+    assertFalse(call.isCanceled());
+  }
+
+  private RequestBody sleepingRequestBody(final int sleepMillis) {
+    return new RequestBody() {
+      @Override public MediaType contentType() {
+        return MediaType.parse("text/plain");
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        try {
+          sink.writeUtf8("abc");
+          sink.flush();
+          Thread.sleep(sleepMillis);
+          sink.writeUtf8("def");
+        } catch (InterruptedException e) {
+          throw new InterruptedIOException();
+        }
+      }
+    };
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/RecordingOkAuthenticator.java b/okhttp-tests/src/test/java/okhttp3/internal/RecordingOkAuthenticator.java
index 2464a910b4..126fce4d7e 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/RecordingOkAuthenticator.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/RecordingOkAuthenticator.java
@@ -18,7 +18,9 @@
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
+import javax.annotation.Nullable;
 import okhttp3.Authenticator;
+import okhttp3.Challenge;
 import okhttp3.Request;
 import okhttp3.Response;
 import okhttp3.Route;
@@ -26,10 +28,12 @@
 public final class RecordingOkAuthenticator implements Authenticator {
   public final List<Response> responses = new ArrayList<>();
   public final List<Route> routes = new ArrayList<>();
-  public final String credential;
+  public @Nullable String credential;
+  public @Nullable String scheme;
 
-  public RecordingOkAuthenticator(String credential) {
+  public RecordingOkAuthenticator(@Nullable String credential, @Nullable String scheme) {
     this.credential = credential;
+    this.scheme = scheme;
   }
 
   public Response onlyResponse() {
@@ -49,10 +53,21 @@ public Route onlyRoute() {
     responses.add(response);
     routes.add(route);
 
-    if (credential == null) return null;
+    if (!schemeMatches(response) || credential == null) return null;
+
     String header = response.code() == 407 ? "Proxy-Authorization" : "Authorization";
     return response.request().newBuilder()
         .addHeader(header, credential)
         .build();
   }
+
+  private boolean schemeMatches(Response response) {
+    if (scheme == null) return true;
+
+    for (Challenge challenge : response.challenges()) {
+      if (challenge.scheme().equalsIgnoreCase(scheme)) return true;
+    }
+
+    return false;
+  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/UtilTest.java b/okhttp-tests/src/test/java/okhttp3/internal/UtilTest.java
index af92f5eb84..dacf8ddaff 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/UtilTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/UtilTest.java
@@ -1,18 +1,18 @@
- /*
-  * Copyright (C) 2012 The Android Open Source Project
-  *
-  * Licensed under the Apache License, Version 2.0 (the "License");
-  * you may not use this file except in compliance with the License.
-  * You may obtain a copy of the License at
-  *
-  *      http://www.apache.org/licenses/LICENSE-2.0
-  *
-  * Unless required by applicable law or agreed to in writing, software
-  * distributed under the License is distributed on an "AS IS" BASIS,
-  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  * See the License for the specific language governing permissions and
-  * limitations under the License.
-  */
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package okhttp3.internal;
 
 import java.util.Collections;
@@ -21,17 +21,9 @@
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertSame;
 import static org.junit.Assert.fail;
 
- public class UtilTest {
-  @Test public void testAssertionError() {
-    NullPointerException nullPointerException = new NullPointerException();
-    AssertionError ae = Util.assertionError("npe", nullPointerException);
-    assertSame(nullPointerException, ae.getCause());
-    assertEquals("npe", ae.getMessage());
-  }
-
+public final class UtilTest {
   @Test public void immutableMap() {
     Map<String, String> map = new LinkedHashMap<>();
     map.put("a", "A");
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java b/okhttp-tests/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java
index 04ba57126b..1d5bf30731 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java
@@ -33,7 +33,6 @@
 import okio.Source;
 import org.junit.After;
 import org.junit.Before;
-import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.TemporaryFolder;
@@ -129,35 +128,35 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     try {
       key = "has_space ";
       cache.edit(key);
-      fail("Exepcting an IllegalArgumentException as the key was invalid.");
+      fail("Expecting an IllegalArgumentException as the key was invalid.");
     } catch (IllegalArgumentException iae) {
       assertEquals("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\"", iae.getMessage());
     }
     try {
       key = "has_CR\r";
       cache.edit(key);
-      fail("Exepcting an IllegalArgumentException as the key was invalid.");
+      fail("Expecting an IllegalArgumentException as the key was invalid.");
     } catch (IllegalArgumentException iae) {
       assertEquals("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\"", iae.getMessage());
     }
     try {
       key = "has_LF\n";
       cache.edit(key);
-      fail("Exepcting an IllegalArgumentException as the key was invalid.");
+      fail("Expecting an IllegalArgumentException as the key was invalid.");
     } catch (IllegalArgumentException iae) {
       assertEquals("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\"", iae.getMessage());
     }
     try {
       key = "has_invalid/";
       cache.edit(key);
-      fail("Exepcting an IllegalArgumentException as the key was invalid.");
+      fail("Expecting an IllegalArgumentException as the key was invalid.");
     } catch (IllegalArgumentException iae) {
       assertEquals("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\"", iae.getMessage());
     }
     try {
       key = "has_invalid\u2603";
       cache.edit(key);
-      fail("Exepcting an IllegalArgumentException as the key was invalid.");
+      fail("Expecting an IllegalArgumentException as the key was invalid.");
     } catch (IllegalArgumentException iae) {
       assertEquals("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\"", iae.getMessage());
     }
@@ -165,7 +164,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
       key = "this_is_way_too_long_this_is_way_too_long_this_is_way_too_long_"
           + "this_is_way_too_long_this_is_way_too_long_this_is_way_too_long";
       cache.edit(key);
-      fail("Exepcting an IllegalArgumentException as the key was too long.");
+      fail("Expecting an IllegalArgumentException as the key was too long.");
     } catch (IllegalArgumentException iae) {
       assertEquals("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\"", iae.getMessage());
     }
@@ -1249,7 +1248,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     a.close();
     iterator.remove();
 
-    assertEquals(null, cache.get("a"));
+    assertNull(cache.get("a"));
   }
 
   @Test public void iteratorRemoveBeforeNext() throws Exception {
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/cache2/RelayTest.java b/okhttp-tests/src/test/java/okhttp3/internal/cache2/RelayTest.java
index cbffa87d09..8ed0c911f7 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/cache2/RelayTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/cache2/RelayTest.java
@@ -227,14 +227,12 @@
 
   /** Returns a callable that reads all of source, closes it, and returns the bytes. */
   private Callable<ByteString> sourceReader(final Source source) {
-    return new Callable<ByteString>() {
-      @Override public ByteString call() throws Exception {
-        Buffer buffer = new Buffer();
-        while (source.read(buffer, 16384) != -1) {
-        }
-        source.close();
-        return buffer.readByteString();
+    return () -> {
+      Buffer buffer = new Buffer();
+      while (source.read(buffer, 16384) != -1) {
       }
+      source.close();
+      return buffer.readByteString();
     };
   }
 
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/connection/ConnectionSpecSelectorTest.java b/okhttp-tests/src/test/java/okhttp3/internal/connection/ConnectionSpecSelectorTest.java
index e366e4081b..25e6b86a4a 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/connection/ConnectionSpecSelectorTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/connection/ConnectionSpecSelectorTest.java
@@ -75,7 +75,8 @@ public void nonRetryableSSLHandshakeException() throws Exception {
   public void retryableSSLHandshakeException() throws Exception {
     ConnectionSpecSelector connectionSpecSelector =
         createConnectionSpecSelector(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS);
-    SSLSocket socket = createSocketWithEnabledProtocols(TlsVersion.TLS_1_1, TlsVersion.TLS_1_0);
+    SSLSocket socket = createSocketWithEnabledProtocols(
+        TlsVersion.TLS_1_2, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0);
     connectionSpecSelector.configureSecureSocket(socket);
 
     boolean retry = connectionSpecSelector.connectionFailed(RETRYABLE_EXCEPTION);
@@ -85,20 +86,21 @@ public void retryableSSLHandshakeException() throws Exception {
 
   @Test
   public void someFallbacksSupported() throws Exception {
-    ConnectionSpec sslV3 =
-        new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
-            .tlsVersions(TlsVersion.SSL_3_0)
-            .build();
+    ConnectionSpec sslV3 = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
+        .tlsVersions(TlsVersion.SSL_3_0)
+        .build();
 
     ConnectionSpecSelector connectionSpecSelector = createConnectionSpecSelector(
         ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS, sslV3);
 
-    TlsVersion[] enabledSocketTlsVersions = {TlsVersion.TLS_1_1, TlsVersion.TLS_1_0};
+    TlsVersion[] enabledSocketTlsVersions = {
+        TlsVersion.TLS_1_2, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0
+    };
     SSLSocket socket = createSocketWithEnabledProtocols(enabledSocketTlsVersions);
 
     // MODERN_TLS is used here.
     connectionSpecSelector.configureSecureSocket(socket);
-    assertEnabledProtocols(socket, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0);
+    assertEnabledProtocols(socket, TlsVersion.TLS_1_2);
 
     boolean retry = connectionSpecSelector.connectionFailed(RETRYABLE_EXCEPTION);
     assertTrue(retry);
@@ -107,7 +109,7 @@ public void someFallbacksSupported() throws Exception {
     // COMPATIBLE_TLS is used here.
     socket = createSocketWithEnabledProtocols(enabledSocketTlsVersions);
     connectionSpecSelector.configureSecureSocket(socket);
-    assertEnabledProtocols(socket, TlsVersion.TLS_1_0);
+    assertEnabledProtocols(socket, TlsVersion.TLS_1_2, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0);
 
     retry = connectionSpecSelector.connectionFailed(RETRYABLE_EXCEPTION);
     assertFalse(retry);
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/DisconnectTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http/DisconnectTest.java
index aad2bfc8dd..0a89a1a567 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http/DisconnectTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http/DisconnectTest.java
@@ -117,17 +117,15 @@
     responseBody.close();
   }
 
-  private void disconnectLater(final HttpURLConnection connection, final int delayMillis) {
-    Thread interruptingCow = new Thread() {
-      @Override public void run() {
-        try {
-          sleep(delayMillis);
-          connection.disconnect();
-        } catch (InterruptedException e) {
-          throw new RuntimeException(e);
-        }
+  private void disconnectLater(HttpURLConnection connection, int delayMillis) {
+    Thread interruptingCow = new Thread(() -> {
+      try {
+        Thread.sleep(delayMillis);
+        connection.disconnect();
+      } catch (InterruptedException e) {
+        throw new RuntimeException(e);
       }
-    };
+    });
     interruptingCow.start();
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/ThreadInterruptTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http/ThreadInterruptTest.java
index e162633f74..8926e10c31 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http/ThreadInterruptTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http/ThreadInterruptTest.java
@@ -93,9 +93,7 @@ protected Socket configureSocket(Socket socket) throws IOException {
       }
       fail("Expected thread to be interrupted");
     } catch (InterruptedIOException expected) {
-      // TODO(jwilson): test that we're interrupted once Okio retains interrupted state.
-      //     https://github.com/square/okhttp/issues/3107
-      if (false) assertTrue(Thread.interrupted());
+      assertTrue(Thread.interrupted());
     }
 
     connection.disconnect();
@@ -119,26 +117,22 @@ protected Socket configureSocket(Socket socket) throws IOException {
       }
       fail("Expected thread to be interrupted");
     } catch (InterruptedIOException expected) {
-      // TODO(jwilson): test that we're interrupted once Okio retains interrupted state.
-      //     https://github.com/square/okhttp/issues/3107
-      if (false) assertTrue(Thread.interrupted());
+      assertTrue(Thread.interrupted());
     }
 
     responseBody.close();
   }
 
-  private void interruptLater(final int delayMillis) {
-    final Thread toInterrupt = Thread.currentThread();
-    Thread interruptingCow = new Thread() {
-      @Override public void run() {
-        try {
-          sleep(delayMillis);
-          toInterrupt.interrupt();
-        } catch (InterruptedException e) {
-          throw new AssertionError(e);
-        }
+  private void interruptLater(int delayMillis) {
+    Thread toInterrupt = Thread.currentThread();
+    Thread interruptingCow = new Thread(() -> {
+      try {
+        Thread.sleep(delayMillis);
+        toInterrupt.interrupt();
+      } catch (InterruptedException e) {
+        throw new AssertionError(e);
       }
-    };
+    });
     interruptingCow.start();
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/HpackTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/HpackTest.java
index 454f5eec99..f8bd931282 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/HpackTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/HpackTest.java
@@ -26,6 +26,7 @@
 import static okhttp3.TestUtil.headerEntries;
 import static okio.ByteString.decodeHex;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
 import static org.junit.Assert.fail;
 
 public final class HpackTest {
@@ -384,7 +385,7 @@
     assertEquals(0, hpackReader.headerCount);
     assertEquals(0, hpackReader.dynamicTableByteCount);
 
-    assertEquals(null, hpackReader.dynamicTable[readerHeaderTableLength() - 1]);
+    assertNull(hpackReader.dynamicTable[readerHeaderTableLength() - 1]);
 
     assertEquals(headerEntries(":method", "GET"), hpackReader.getAndResetHeaderList());
   }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java
index 2f18ab591b..f457f8f822 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java
@@ -24,6 +24,7 @@
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
+import okhttp3.Headers;
 import okhttp3.internal.Util;
 import okhttp3.internal.http2.MockHttp2Peer.InFrame;
 import okio.AsyncTimeout;
@@ -33,15 +34,20 @@
 import okio.Okio;
 import okio.Sink;
 import okio.Source;
+import okio.Utf8;
 import org.junit.After;
+import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.TestRule;
 import org.junit.rules.Timeout;
 
+import static java.nio.charset.StandardCharsets.UTF_8;
 import static okhttp3.TestUtil.headerEntries;
 import static okhttp3.TestUtil.repeat;
+import static okhttp3.internal.Internal.initializeInstanceForTests;
 import static okhttp3.internal.Util.EMPTY_BYTE_ARRAY;
+import static okhttp3.internal.Util.EMPTY_HEADERS;
 import static okhttp3.internal.http2.Http2Connection.Listener.REFUSE_INCOMING_STREAMS;
 import static okhttp3.internal.http2.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
 import static okhttp3.internal.http2.Settings.ENABLE_PUSH;
@@ -49,6 +55,7 @@
 import static okhttp3.internal.http2.Settings.INITIAL_WINDOW_SIZE;
 import static okhttp3.internal.http2.Settings.MAX_CONCURRENT_STREAMS;
 import static okhttp3.internal.http2.Settings.MAX_FRAME_SIZE;
+import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
@@ -59,6 +66,10 @@
 
   @Rule public final TestRule timeout = new Timeout(5_000);
 
+  @Before public void setup() {
+    initializeInstanceForTests();
+  }
+
   @After public void tearDown() throws Exception {
     peer.close();
   }
@@ -185,11 +196,11 @@
     InFrame data1 = peer.takeFrame();
     assertEquals(Http2.TYPE_DATA, data1.type);
     assertEquals(3, data1.streamId);
-    assertTrue(Arrays.equals("abcde".getBytes("UTF-8"), data1.data));
+    assertArrayEquals("abcde".getBytes(UTF_8), data1.data);
     InFrame data2 = peer.takeFrame();
     assertEquals(Http2.TYPE_DATA, data2.type);
     assertEquals(3, data2.streamId);
-    assertTrue(Arrays.equals("fghi".getBytes("UTF-8"), data2.data));
+    assertArrayEquals("fghi".getBytes(UTF_8), data2.data);
   }
 
   /**
@@ -201,7 +212,7 @@
     peer.sendFrame().settings(new Settings());
     peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM 3
-    peer.sendFrame().headers(3, headerEntries("a", "apple"));
+    peer.sendFrame().headers(false, 3, headerEntries("a", "apple"));
     peer.sendFrame().data(false, 3, data(1024), 1024);
     peer.acceptFrame(); // RST_STREAM
     peer.sendFrame().data(true, 3, data(1024), 1024);
@@ -273,7 +284,7 @@
     InFrame data1 = peer.takeFrame();
     assertEquals(Http2.TYPE_DATA, data1.type);
     assertEquals(3, data1.streamId);
-    assertTrue(Arrays.equals("abcdef".getBytes("UTF-8"), data1.data));
+    assertArrayEquals("abcdef".getBytes(UTF_8), data1.data);
   }
 
   @Test public void readSendsWindowUpdateHttp2() throws Exception {
@@ -284,7 +295,7 @@
     peer.sendFrame().settings(new Settings());
     peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
     for (int i = 0; i < 3; i++) {
       // Send frames of summing to size 50, which is windowUpdateThreshold.
       peer.sendFrame().data(false, 3, data(24), 24);
@@ -301,7 +312,7 @@
     connection.okHttpSettings.set(INITIAL_WINDOW_SIZE, windowSize);
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
     assertEquals(0, stream.unacknowledgedBytesRead);
-    assertEquals(headerEntries("a", "android"), stream.takeResponseHeaders());
+    assertEquals(Headers.of("a", "android"), stream.takeHeaders());
     Source in = stream.getSource();
     Buffer buffer = new Buffer();
     buffer.writeAll(in);
@@ -328,7 +339,7 @@
     peer.sendFrame().settings(new Settings());
     peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
     peer.sendFrame().data(true, 3, data(0), 0);
     peer.play();
 
@@ -349,7 +360,7 @@
     peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
     peer.acceptFrame(); // DATA
-    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
     peer.play();
 
     // Play it back.
@@ -374,7 +385,7 @@
     peer.sendFrame().settings(new Settings());
     peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
     peer.acceptFrame(); // DATA
     peer.acceptFrame(); // DATA
     peer.play();
@@ -400,7 +411,7 @@
     peer.sendFrame().settings(new Settings());
     peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
     final List<Header> expectedRequestHeaders = Arrays.asList(
         new Header(Header.TARGET_METHOD, "GET"),
         new Header(Header.TARGET_SCHEME, "https"),
@@ -411,7 +422,7 @@
     final List<Header> expectedResponseHeaders = Arrays.asList(
         new Header(Header.RESPONSE_STATUS, "200")
     );
-    peer.sendFrame().synReply(true, 2, expectedResponseHeaders);
+    peer.sendFrame().headers(true, 2, expectedResponseHeaders);
     peer.sendFrame().data(true, 3, data(0), 0);
     peer.play();
 
@@ -458,7 +469,7 @@
         new Header(Header.TARGET_AUTHORITY, "squareup.com"),
         new Header(Header.TARGET_PATH, "/cached")
     ));
-    peer.sendFrame().synReply(true, 2, Arrays.asList(
+    peer.sendFrame().headers(true, 2, Arrays.asList(
         new Header(Header.RESPONSE_STATUS, "200")
     ));
     peer.acceptFrame(); // RST_STREAM
@@ -511,7 +522,7 @@
     peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
     peer.acceptFrame(); // DATA
-    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
     peer.sendFrame().data(true, 3, new Buffer().writeUtf8("robot"), 5);
     peer.acceptFrame(); // PING
     peer.sendFrame().ping(true, 1, 0); // PING
@@ -523,7 +534,7 @@
     BufferedSink out = Okio.buffer(stream.getSink());
     out.writeUtf8("c3po");
     out.close();
-    assertEquals(headerEntries("a", "android"), stream.takeResponseHeaders());
+    assertEquals(Headers.of("a", "android"), stream.takeHeaders());
     assertStreamData("robot", stream.getSource());
     connection.writePingAndAwaitPong();
     assertEquals(0, connection.openStreamCount());
@@ -536,7 +547,229 @@
     assertEquals(-1, synStream.associatedStreamId);
     assertEquals(headerEntries("b", "banana"), synStream.headerBlock);
     InFrame requestData = peer.takeFrame();
-    assertTrue(Arrays.equals("c3po".getBytes("UTF-8"), requestData.data));
+    assertArrayEquals("c3po".getBytes(UTF_8), requestData.data);
+  }
+
+  @Test public void serverFinishesStreamWithHeaders() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.acceptFrame(); // PING
+    peer.sendFrame().headers(true, 3, headerEntries("headers", "bam"));
+    peer.sendFrame().ping(true, 1, 0); // PONG
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    Http2Stream stream = connection.newStream(headerEntries("a", "artichaut"), false);
+    connection.writePingAndAwaitPong();
+    assertEquals(Headers.of("headers", "bam"), stream.takeHeaders());
+    assertEquals(EMPTY_HEADERS, stream.trailers());
+    assertEquals(0, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    InFrame synStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    assertFalse(synStream.outFinished);
+    assertEquals(3, synStream.streamId);
+    assertEquals(-1, synStream.associatedStreamId);
+    assertEquals(headerEntries("a", "artichaut"), synStream.headerBlock);
+  }
+
+  @Test public void serverWritesTrailersAndClientReadsTrailers() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().headers(false, 3, headerEntries("headers", "bam"));
+    peer.acceptFrame(); // PING
+    peer.sendFrame().headers(true, 3, headerEntries("trailers", "boom"));
+    peer.sendFrame().ping(true, 1, 0); // PONG
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    Http2Stream stream = connection.newStream(headerEntries("a", "artichaut"), false);
+    assertEquals(Headers.of("headers", "bam"), stream.takeHeaders());
+    connection.writePingAndAwaitPong();
+    assertEquals(Headers.of("trailers", "boom"), stream.trailers());
+    assertEquals(0, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    InFrame synStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    assertFalse(synStream.outFinished);
+    assertEquals(3, synStream.streamId);
+    assertEquals(-1, synStream.associatedStreamId);
+    assertEquals(headerEntries("a", "artichaut"), synStream.headerBlock);
+  }
+
+  @Test public void serverWritesTrailersWithData() throws Exception {
+    // We buffer some outbound data and headers and confirm that the END_STREAM flag comes with the
+    // headers (and not with the data).
+
+    // write the mocking script for the client
+    peer.setClient(true);
+
+    // Write the mocking script.
+    peer.sendFrame().settings(new Settings());
+    peer.sendFrame().headers(true, 3, headerEntries("client", "abc"));
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // HEADERS STREAM 3
+    peer.acceptFrame(); // DATA STREAM 3 "abcde"
+    peer.acceptFrame(); // HEADERS STREAM 3
+    peer.play();
+
+    // Play it back.
+    Http2Connection connection = connect(peer);
+    Http2Stream stream = connection.newStream(headerEntries("a", "android"), true);
+    stream.enqueueTrailers(Headers.of("foo", "bar"));
+    BufferedSink sink = Okio.buffer(stream.getSink());
+    sink.writeUtf8("abcdefghi");
+    sink.close();
+
+    // Verify the peer received what was expected.
+    InFrame headers1 = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, headers1.type);
+    InFrame data1 = peer.takeFrame();
+    assertEquals(Http2.TYPE_DATA, data1.type);
+    assertEquals(3, data1.streamId);
+    assertArrayEquals("abcdefghi".getBytes(UTF_8), data1.data);
+    assertFalse(data1.inFinished);
+    InFrame headers2 = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, headers2.type);
+    assertTrue(headers2.inFinished);
+  }
+
+  @Test public void clientCannotReadTrailersWithoutExhaustingStream() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().data(false, 3, new Buffer().writeUtf8("robot"), 5);
+    peer.sendFrame().headers(true, 3, headerEntries("trailers", "boom"));
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 0); // PONG
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    Http2Stream stream = connection.newStream(headerEntries("a", "artichaut"), true);
+    connection.writePingAndAwaitPong();
+    try {
+      stream.trailers();
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+  }
+
+  @Test public void clientCannotReadTrailersIfTheStreamFailed() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().rstStream(3, ErrorCode.PROTOCOL_ERROR);
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 0); // PONG
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    Http2Stream stream = connection.newStream(headerEntries("a", "artichaut"), true);
+    connection.writePingAndAwaitPong();
+    try {
+      stream.trailers();
+      fail();
+    } catch (StreamResetException expected) {
+    }
+  }
+
+  @Test public void serverCannotEnqueueTrailersAfterFinishingTheStream() throws Exception {
+    peer.setClient(true);
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 0);
+    peer.play();
+
+    // Play it back.
+    Http2Connection connection = connect(peer);
+    connection.writePingAndAwaitPong();
+    Http2Stream stream = connection.newStream(headerEntries("a", "android"), true);
+    // finish the stream
+    stream.writeHeaders(headerEntries("b", "berserk"), true, false);
+    try {
+      stream.enqueueTrailers(Headers.of("trailers", "boom"));
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+  }
+
+  @Test public void noTrailersFrameYieldsEmptyTrailers() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().headers(false, 3, headerEntries("headers", "bam"));
+    peer.sendFrame().data(true, 3, new Buffer().writeUtf8("robot"), 5);
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 0); // PONG
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    Http2Stream stream = connection.newStream(headerEntries("a", "artichaut"), false);
+    BufferedSource source = Okio.buffer(stream.getSource());
+    connection.writePingAndAwaitPong();
+    assertEquals(Headers.of("headers", "bam"), stream.takeHeaders());
+    assertEquals("robot", source.readUtf8(5));
+    assertEquals(EMPTY_HEADERS, stream.trailers());
+    assertEquals(0, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    InFrame synStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    assertFalse(synStream.outFinished);
+    assertEquals(3, synStream.streamId);
+    assertEquals(-1, synStream.associatedStreamId);
+    assertEquals(headerEntries("a", "artichaut"), synStream.headerBlock);
+  }
+
+  @Test public void serverReadsHeadersDataHeaders() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.acceptFrame(); // DATA
+    peer.acceptFrame(); // HEADERS
+    peer.sendFrame().headers(true, 3, headerEntries("a", "android"));
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 0); // PING
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
+    BufferedSink out = Okio.buffer(stream.getSink());
+    out.writeUtf8("c3po");
+    out.close();
+    stream.writeHeaders(headerEntries("e", "elephant"), false, false);
+    connection.writePingAndAwaitPong();
+    assertEquals(0, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    InFrame synStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    assertFalse(synStream.outFinished);
+    assertEquals(3, synStream.streamId);
+    assertEquals(-1, synStream.associatedStreamId);
+    assertEquals(headerEntries("b", "banana"), synStream.headerBlock);
+    InFrame requestData = peer.takeFrame();
+    assertArrayEquals("c3po".getBytes(UTF_8), requestData.data);
+
+    InFrame nextFrame = peer.takeFrame();
+    assertEquals(headerEntries("e", "elephant"), nextFrame.headerBlock);
   }
 
   @Test public void clientCreatesStreamAndServerRepliesWithFin() throws Exception {
@@ -545,7 +778,7 @@
     peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
     peer.acceptFrame(); // PING
-    peer.sendFrame().synReply(true, 3, headerEntries("a", "android"));
+    peer.sendFrame().headers(true, 3, headerEntries("a", "android"));
     peer.sendFrame().ping(true, 1, 0);
     peer.play();
 
@@ -745,7 +978,7 @@
     // write the mocking script
     peer.sendFrame().settings(new Settings());
     peer.acceptFrame(); // ACK
-    peer.sendFrame().synReply(false, 41, headerEntries("a", "android"));
+    peer.sendFrame().headers(false, 41, headerEntries("a", "android"));
     peer.sendFrame().ping(false, 2, 0);
     peer.acceptFrame(); // PING
     peer.play();
@@ -876,7 +1109,7 @@
     assertFalse(synStream.outFinished);
     InFrame data = peer.takeFrame();
     assertEquals(Http2.TYPE_DATA, data.type);
-    assertTrue(Arrays.equals("square".getBytes("UTF-8"), data.data));
+    assertArrayEquals("square".getBytes(UTF_8), data.data);
     InFrame fin = peer.takeFrame();
     assertEquals(Http2.TYPE_DATA, fin.type);
     assertTrue(fin.inFinished);
@@ -891,7 +1124,7 @@
     peer.sendFrame().settings(new Settings());
     peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 3, headerEntries("b", "banana"));
+    peer.sendFrame().headers(false, 3, headerEntries("b", "banana"));
     peer.sendFrame().data(true, 3, new Buffer().writeUtf8("square"), 6);
     peer.acceptFrame(); // PING
     peer.sendFrame().ping(true, 1, 0);
@@ -917,16 +1150,16 @@
     peer.sendFrame().settings(new Settings());
     peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
     peer.acceptFrame(); // PING
-    peer.sendFrame().synReply(false, 3, headerEntries("b", "banana"));
+    peer.sendFrame().headers(false, 3, headerEntries("b", "banana"));
     peer.sendFrame().ping(true, 1, 0);
     peer.play();
 
     // play it back
     Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("c", "cola"), false);
-    assertEquals(headerEntries("a", "android"), stream.takeResponseHeaders());
+    assertEquals(Headers.of("a", "android"), stream.takeHeaders());
     connection.writePingAndAwaitPong(); // Ensure that the 2nd SYN REPLY has been received.
 
     // verify the peer received what was expected
@@ -941,7 +1174,7 @@
     peer.sendFrame().settings(new Settings());
     peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
     peer.sendFrame().data(true, 3, new Buffer().writeUtf8("robot"), 5);
     peer.sendFrame().data(true, 3, new Buffer().writeUtf8("c3po"), 4);
     peer.acceptFrame(); // RST_STREAM
@@ -952,7 +1185,7 @@
     // play it back
     Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
-    assertEquals(headerEntries("a", "android"), stream.takeResponseHeaders());
+    assertEquals(Headers.of("a", "android"), stream.takeHeaders());
     assertStreamData("robot", stream.getSource());
 
     // verify the peer received what was expected
@@ -972,7 +1205,7 @@
     peer.sendFrame().settings(new Settings());
     peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 3, headerEntries("b", "banana"));
+    peer.sendFrame().headers(false, 3, headerEntries("b", "banana"));
     peer.sendFrame().data(false, 3, new Buffer().write(new byte[dataLength]), dataLength);
     peer.sendFrame().data(false, 3, new Buffer().write(new byte[dataLength]), dataLength);
     peer.sendFrame().data(false, 3, new Buffer().write(new byte[dataLength]), dataLength);
@@ -985,7 +1218,7 @@
     // play it back
     Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("a", "android"), false);
-    assertEquals(headerEntries("b", "banana"), stream.takeResponseHeaders());
+    assertEquals(Headers.of("b", "banana"), stream.takeHeaders());
 
     // verify the peer received what was expected
     InFrame synStream = peer.takeFrame();
@@ -1009,7 +1242,7 @@
     Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("a", "android"), false);
     try {
-      stream.takeResponseHeaders();
+      stream.takeHeaders();
       fail();
     } catch (IOException expected) {
       assertEquals("stream was reset: REFUSED_STREAM", expected.getMessage());
@@ -1072,7 +1305,7 @@
     InFrame data1 = peer.takeFrame();
     assertEquals(Http2.TYPE_DATA, data1.type);
     assertEquals(3, data1.streamId);
-    assertTrue(Arrays.equals("abcdef".getBytes("UTF-8"), data1.data));
+    assertArrayEquals("abcdef".getBytes(UTF_8), data1.data);
   }
 
   @Test public void sendGoAway() throws Exception {
@@ -1082,7 +1315,7 @@
     peer.acceptFrame(); // SYN_STREAM 1
     peer.acceptFrame(); // GOAWAY
     peer.acceptFrame(); // PING
-    peer.sendFrame().synStream(false, 2, 0, headerEntries("b", "b")); // Should be ignored!
+    peer.sendFrame().headers(false, 2, headerEntries("b", "b")); // Should be ignored!
     peer.sendFrame().ping(true, 1, 0);
     peer.play();
 
@@ -1169,7 +1402,7 @@
     stream.readTimeout().timeout(500, TimeUnit.MILLISECONDS);
     long startNanos = System.nanoTime();
     try {
-      stream.takeResponseHeaders();
+      stream.takeHeaders();
       fail();
     } catch (InterruptedIOException expected) {
     }
@@ -1188,7 +1421,7 @@
     peer.sendFrame().settings(new Settings());
     peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
     peer.acceptFrame(); // RST_STREAM
     peer.play();
 
@@ -1223,7 +1456,7 @@
     peer.acceptFrame(); // PING
     peer.sendFrame().ping(true, 1, 0);
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
     peer.acceptFrame(); // DATA
     peer.acceptFrame(); // RST_STREAM
     peer.play();
@@ -1265,7 +1498,7 @@
     peer.acceptFrame(); // PING
     peer.sendFrame().ping(true, 1, 0);
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
     peer.acceptFrame(); // PING
     peer.sendFrame().ping(true, 3, 0);
     peer.acceptFrame(); // DATA
@@ -1304,7 +1537,7 @@
     peer.sendFrame().settings(new Settings());
     peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
     peer.acceptFrame(); // DATA
     peer.play();
 
@@ -1322,7 +1555,7 @@
     assertEquals(Http2.TYPE_HEADERS, peer.takeFrame().type);
     InFrame data = peer.takeFrame();
     assertEquals(Http2.TYPE_DATA, data.type);
-    assertTrue(Arrays.equals("abcdefghij".getBytes("UTF-8"), data.data));
+    assertArrayEquals("abcdefghij".getBytes(UTF_8), data.data);
     assertTrue(data.inFinished);
   }
 
@@ -1332,8 +1565,8 @@
     peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
     peer.acceptFrame(); // PING
-    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
-    peer.sendFrame().headers(3, headerEntries("c", "c3po"));
+    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().headers(false, 3, headerEntries("c", "c3po"));
     peer.sendFrame().ping(true, 1, 0);
     peer.play();
 
@@ -1341,8 +1574,8 @@
     Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
     connection.writePingAndAwaitPong(); // Ensure that the HEADERS has been received.
-    assertEquals(Arrays.asList(new Header("a", "android"), null, new Header("c", "c3po")),
-        stream.takeResponseHeaders());
+    assertEquals(Headers.of("a", "android"), stream.takeHeaders());
+    assertEquals(Headers.of("c", "c3po"), stream.takeHeaders());
 
     // verify the peer received what was expected
     InFrame synStream = peer.takeFrame();
@@ -1356,19 +1589,19 @@
     peer.sendFrame().settings(new Settings());
     peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
     peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 0); // PING
-    peer.sendFrame().synReply(true, 3, headerEntries("c", "cola"));
+    peer.sendFrame().headers(true, 3, headerEntries("c", "cola"));
+    peer.sendFrame().ping(true, 1, 0); // PONG
     peer.play();
 
     // play it back
     Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
     stream.getConnection().flush();
-    assertEquals(headerEntries("a", "android"), stream.takeResponseHeaders());
+    assertEquals(Headers.of("a", "android"), stream.takeHeaders());
     connection.writePingAndAwaitPong();
-    assertEquals(headerEntries("c", "cola"), stream.takeResponseHeaders());
+    assertEquals(Headers.of("c", "cola"), stream.trailers());
 
     // verify the peer received what was expected
     assertEquals(Http2.TYPE_HEADERS, peer.takeFrame().type);
@@ -1383,7 +1616,7 @@
     peer.sendFrame().settings(new Settings());
     peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
     for (int i = 0; i < 3; i++) {
       // Send frames of summing to size 50, which is windowUpdateThreshold.
       peer.sendFrame().data(false, 3, data(24), 24);
@@ -1400,7 +1633,7 @@
     connection.okHttpSettings.set(INITIAL_WINDOW_SIZE, windowSize);
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
     assertEquals(0, stream.unacknowledgedBytesRead);
-    assertEquals(headerEntries("a", "android"), stream.takeResponseHeaders());
+    assertEquals(Headers.of("a", "android"), stream.takeHeaders());
     Source in = stream.getSource();
     Buffer buffer = new Buffer();
     buffer.writeAll(in);
@@ -1427,7 +1660,7 @@
     peer.sendFrame().settings(new Settings());
     peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
     peer.sendFrame().data(true, 3, data(0), 0);
     peer.play();
 
@@ -1448,7 +1681,7 @@
     peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
     peer.acceptFrame(); // DATA
-    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
     peer.play();
 
     // Play it back.
@@ -1470,7 +1703,7 @@
     peer.sendFrame().settings(new Settings());
     peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
     peer.sendFrame().data(false, 3, data(1024), 1024);
     peer.truncateLastFrame(8 + 100);
     peer.play();
@@ -1478,7 +1711,7 @@
     // play it back
     Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
-    assertEquals(headerEntries("a", "android"), stream.takeResponseHeaders());
+    assertEquals(Headers.of("a", "android"), stream.takeHeaders());
     Source in = stream.getSource();
     try {
       Okio.buffer(in).readByteString(101);
@@ -1533,7 +1766,7 @@
   @Test public void remoteOmitsInitialSettings() throws Exception {
     // Write the mocking script. Note no SETTINGS frame is sent or acknowledged.
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
     peer.acceptFrame(); // GOAWAY
     peer.play();
 
@@ -1544,7 +1777,7 @@
 
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
     try {
-      stream.takeResponseHeaders();
+      stream.takeHeaders();
       fail();
     } catch (IOException expected) {
       assertEquals("stream was reset: PROTOCOL_ERROR", expected.getMessage());
@@ -1567,6 +1800,11 @@ private void assertStreamData(String expected, Source source) throws IOException
     assertEquals(expected, actual);
   }
 
+  /** Reads {@code prefix} from {@code source}. */
+  private void assertStreamPrefix(String prefix, BufferedSource source) throws IOException {
+    assertEquals(prefix, source.readUtf8(Utf8.size(prefix)));
+  }
+
   /**
    * Returns true when all work currently in progress by the watchdog have completed. This method
    * creates more work for the watchdog and waits for that work to be executed. When it is, we know
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2Test.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2Test.java
index 24ec759c2d..684d222693 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2Test.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2Test.java
@@ -240,7 +240,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
       @Override public void settings(boolean clearPrevious, Settings settings) {
         assertFalse(clearPrevious); // No clearPrevious in HTTP/2.
         assertEquals(reducedTableSizeBytes, settings.getHeaderTableSize());
-        assertEquals(false, settings.getEnablePush(true));
+        assertFalse(settings.getEnablePush(true));
       }
     });
   }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
index 05e6419318..6a8bcd0be4 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
@@ -46,12 +46,10 @@
 import okhttp3.Request;
 import okhttp3.RequestBody;
 import okhttp3.Response;
-import okhttp3.Route;
 import okhttp3.TestLogHandler;
 import okhttp3.TestUtil;
 import okhttp3.internal.DoubleInetAddressDns;
 import okhttp3.internal.RecordingOkAuthenticator;
-import okhttp3.internal.SingleInetAddressDns;
 import okhttp3.internal.Util;
 import okhttp3.internal.connection.RealConnection;
 import okhttp3.mockwebserver.Dispatcher;
@@ -76,6 +74,7 @@
 import org.junit.runners.Parameterized;
 import org.junit.runners.Parameterized.Parameters;
 
+import static java.nio.charset.StandardCharsets.UTF_8;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static java.util.concurrent.TimeUnit.SECONDS;
 import static okhttp3.TestUtil.defaultClient;
@@ -89,7 +88,7 @@
 import static org.junit.Assert.fail;
 import static org.junit.Assume.assumeTrue;
 
-/** Test how SPDY interacts with HTTP/2 features. */
+/** Test how HTTP/2 interacts with HTTP features. */
 @RunWith(Parameterized.class)
 public final class HttpOverHttp2Test {
   private static final Logger http2Logger = Logger.getLogger(Http2.class.getName());
@@ -125,7 +124,6 @@ private static OkHttpClient buildH2PriorKnowledgeClient() {
   private static OkHttpClient buildHttp2Client() {
     return defaultClient().newBuilder()
         .protocols(Arrays.asList(Protocol.HTTP_2, Protocol.HTTP_1_1))
-        .dns(new SingleInetAddressDns())
         .sslSocketFactory(
             handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
@@ -151,7 +149,9 @@ private static OkHttpClient buildHttp2Client() {
     http2Logger.removeHandler(http2Handler);
     http2Logger.setLevel(previousLevel);
 
+    // Ensure a fresh connection pool for the next test.
     client.connectionPool().evictAll();
+    assertEquals(0, client.connectionPool().connectionCount());
   }
 
   @Test public void get() throws Exception {
@@ -188,7 +188,7 @@ private static OkHttpClient buildHttp2Client() {
   }
 
   @Test public void noDefaultContentLengthOnStreamingPost() throws Exception {
-    final byte[] postBytes = "FGHIJ".getBytes(Util.UTF_8);
+    byte[] postBytes = "FGHIJ".getBytes(UTF_8);
 
     server.enqueue(new MockResponse().setBody("ABCDE"));
 
@@ -215,7 +215,7 @@ private static OkHttpClient buildHttp2Client() {
   }
 
   @Test public void userSuppliedContentLengthHeader() throws Exception {
-    final byte[] postBytes = "FGHIJ".getBytes(Util.UTF_8);
+    byte[] postBytes = "FGHIJ".getBytes(UTF_8);
 
     server.enqueue(new MockResponse().setBody("ABCDE"));
 
@@ -246,7 +246,7 @@ private static OkHttpClient buildHttp2Client() {
   }
 
   @Test public void closeAfterFlush() throws Exception {
-    final byte[] postBytes = "FGHIJ".getBytes(Util.UTF_8);
+    byte[] postBytes = "FGHIJ".getBytes(UTF_8);
 
     server.enqueue(new MockResponse().setBody("ABCDE"));
 
@@ -354,7 +354,7 @@ private void waitForDataFrames(int dataLength) throws Exception {
     waitForDataFrames(Http2Connection.OKHTTP_CLIENT_WINDOW_SIZE);
 
     // Cancel the call and close the response body. This should discard the buffered data and update
-    // the connnection flow-control window.
+    // the connection flow-control window.
     call1.cancel();
     response1.close();
 
@@ -434,7 +434,7 @@ private void waitForDataFrames(int dataLength) throws Exception {
 
     String credential = Credentials.basic("username", "password");
     client = client.newBuilder()
-        .authenticator(new RecordingOkAuthenticator(credential))
+        .authenticator(new RecordingOkAuthenticator(credential, "Basic"))
         .build();
 
     Call call = client.newCall(new Request.Builder()
@@ -754,13 +754,7 @@ private void waitForDataFrames(int dataLength) throws Exception {
     cookieJar.assertResponseCookies("a=b; path=/");
   }
 
-  /** https://github.com/square/okhttp/issues/1191 */
-  @Ignore // TODO: recover gracefully when a connection is shutdown.
   @Test public void cancelWithStreamNotCompleted() throws Exception {
-    // Ensure that the (shared) connection pool is in a consistent state.
-    client.connectionPool().evictAll();
-    assertEquals(0, client.connectionPool().connectionCount());
-
     server.enqueue(new MockResponse()
         .setBody("abc"));
     server.enqueue(new MockResponse()
@@ -902,8 +896,10 @@ private void callAndCancel(int expectedSequenceNumber) throws Exception {
     Call call = client.newCall(new Request.Builder()
         .url(server.url("/"))
         .build());
+    CountDownLatch latch = new CountDownLatch(1);
     call.enqueue(new Callback() {
       @Override public void onFailure(Call call1, IOException e) {
+        latch.countDown();
       }
 
       @Override public void onResponse(Call call1, Response response) {
@@ -911,6 +907,7 @@ private void callAndCancel(int expectedSequenceNumber) throws Exception {
     });
     assertEquals(expectedSequenceNumber, server.takeRequest().getSequenceNumber());
     call.cancel();
+    latch.await();
   }
 
   @Test public void noRecoveryFromRefusedStreamWithRetryDisabled() throws Exception {
@@ -957,18 +954,16 @@ private void noRecoveryFromErrorWithRetryDisabled(ErrorCode errorCode) throws Ex
     server.enqueue(new MockResponse()
         .setBody("ABC"));
 
-    final CountDownLatch latch = new CountDownLatch(1);
-    final BlockingQueue<String> responses = new SynchronousQueue<>();
-    okhttp3.Authenticator authenticator = new okhttp3.Authenticator() {
-      @Override public Request authenticate(Route route, Response response) throws IOException {
-        responses.offer(response.body().string());
-        try {
-          latch.await();
-        } catch (InterruptedException e) {
-          throw new AssertionError();
-        }
-        return response.request();
+    CountDownLatch latch = new CountDownLatch(1);
+    BlockingQueue<String> responses = new SynchronousQueue<>();
+    okhttp3.Authenticator authenticator = (route, response) -> {
+      responses.offer(response.body().string());
+      try {
+        latch.await();
+      } catch (InterruptedException e) {
+        throw new AssertionError();
       }
+      return response.request();
     };
 
     OkHttpClient blockingAuthClient = client.newBuilder()
@@ -1316,7 +1311,7 @@ private int countFrames(List<String> logs, String message) {
         .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
         .setBody("DEF"));
 
-    final BlockingQueue<String> bodies = new SynchronousQueue<>();
+    BlockingQueue<String> bodies = new SynchronousQueue<>();
     Callback callback = new Callback() {
       @Override public void onResponse(Call call, Response response) throws IOException {
         bodies.add(response.body().string());
@@ -1345,10 +1340,7 @@ private int countFrames(List<String> logs, String message) {
 
     server.useHttps(handshakeCertificates.sslSocketFactory(), true);
 
-    // Force a fresh connection pool for the test.
-    client.connectionPool().evictAll();
-
-    final QueueDispatcher queueDispatcher = new QueueDispatcher();
+    QueueDispatcher queueDispatcher = new QueueDispatcher();
     queueDispatcher.enqueueResponse(new MockResponse()
         .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
         .clearHeaders());
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/HuffmanTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/HuffmanTest.java
index 53642c0ea0..e92445f266 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/HuffmanTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/HuffmanTest.java
@@ -16,14 +16,13 @@
 package okhttp3.internal.http2;
 
 import java.io.IOException;
-import java.util.Arrays;
 import java.util.Random;
 import okio.Buffer;
 import okio.ByteString;
 import org.junit.Test;
 
+import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
 
 /** Original version of this class was lifted from {@code com.twitter.hpack.HuffmanTest}. */
 public final class HuffmanTest {
@@ -45,6 +44,6 @@ private void assertRoundTrip(ByteString data) throws IOException {
     assertEquals(buffer.size(), Huffman.get().encodedLength(data));
 
     byte[] decodedBytes = Huffman.get().decode(buffer.readByteArray());
-    assertTrue(Arrays.equals(data.toByteArray(), decodedBytes));
+    assertArrayEquals(data.toByteArray(), decodedBytes);
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/MockHttp2Peer.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/MockHttp2Peer.java
index 376c46d1f3..1ade5b1dde 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/MockHttp2Peer.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/MockHttp2Peer.java
@@ -110,14 +110,12 @@ public void play() throws IOException {
     serverSocket.setReuseAddress(false);
     serverSocket.bind(new InetSocketAddress("localhost", 0), 1);
     port = serverSocket.getLocalPort();
-    executor.execute(new Runnable() {
-      @Override public void run() {
-        try {
-          readAndWriteFrames();
-        } catch (IOException e) {
-          Util.closeQuietly(MockHttp2Peer.this);
-          logger.info(MockHttp2Peer.this + " done: " + e.getMessage());
-        }
+    executor.execute(() -> {
+      try {
+        readAndWriteFrames();
+      } catch (IOException e) {
+        Util.closeQuietly(MockHttp2Peer.this);
+        logger.info(MockHttp2Peer.this + " done: " + e.getMessage());
       }
     });
   }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/SettingsTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/SettingsTest.java
index a26506ca27..46ec0a82ab 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/SettingsTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/SettingsTest.java
@@ -20,6 +20,7 @@
 import static okhttp3.internal.http2.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
 import static okhttp3.internal.http2.Settings.MAX_CONCURRENT_STREAMS;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
 
 public final class SettingsTest {
   @Test public void unsetField() {
@@ -33,9 +34,9 @@
     settings.set(Settings.HEADER_TABLE_SIZE, 8096);
     assertEquals(8096, settings.getHeaderTableSize());
 
-    assertEquals(true, settings.getEnablePush(true));
+    assertTrue(settings.getEnablePush(true));
     settings.set(Settings.ENABLE_PUSH, 1);
-    assertEquals(true, settings.getEnablePush(false));
+    assertTrue(settings.getEnablePush(false));
     settings.clear();
 
     assertEquals(-3, settings.getMaxConcurrentStreams(-3));
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/platform/JdkWithJettyBootPlatformTest.java b/okhttp-tests/src/test/java/okhttp3/internal/platform/Jdk8WithJettyBootPlatformTest.java
similarity index 89%
rename from okhttp-tests/src/test/java/okhttp3/internal/platform/JdkWithJettyBootPlatformTest.java
rename to okhttp-tests/src/test/java/okhttp3/internal/platform/Jdk8WithJettyBootPlatformTest.java
index afe7145a01..bc981e9a36 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/platform/JdkWithJettyBootPlatformTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/platform/Jdk8WithJettyBootPlatformTest.java
@@ -21,11 +21,11 @@
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assume.assumeTrue;
 
-public class JdkWithJettyBootPlatformTest {
+public class Jdk8WithJettyBootPlatformTest {
   @Test
   public void testBuildsWithJettyBoot() {
     assumeTrue(getPlatform().equals("jdk-with-jetty-boot"));
 
-    assertNotNull(JdkWithJettyBootPlatform.buildIfSupported());
+    assertNotNull(Jdk8WithJettyBootPlatform.buildIfSupported());
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/platform/Jdk9PlatformTest.java b/okhttp-tests/src/test/java/okhttp3/internal/platform/Jdk9PlatformTest.java
index ada8f78969..2889911d52 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/platform/Jdk9PlatformTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/platform/Jdk9PlatformTest.java
@@ -39,4 +39,9 @@ public void findsAlpnMethods() {
     assertEquals("getApplicationProtocol", platform.getProtocolMethod.getName());
     assertEquals("setApplicationProtocols", platform.setProtocolMethod.getName());
   }
+
+  @Test
+  public void testToStringIsClassname() {
+    assertEquals("Jdk9Platform", new Jdk9Platform(null, null).toString());
+  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/platform/OptionalMethodTest.java b/okhttp-tests/src/test/java/okhttp3/internal/platform/OptionalMethodTest.java
deleted file mode 100644
index 7e249bd61f..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/platform/OptionalMethodTest.java
+++ /dev/null
@@ -1,347 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package okhttp3.internal.platform;
-
-import java.io.IOException;
-import java.lang.reflect.InvocationTargetException;
-import org.junit.Ignore;
-import org.junit.Test;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-/**
- * Tests for {@link OptionalMethod}.
- */
-public class OptionalMethodTest {
-  @SuppressWarnings("unused")
-  private static class BaseClass {
-    public String stringMethod() {
-      return "string";
-    }
-
-    public void voidMethod() {
-    }
-  }
-
-  @SuppressWarnings("unused")
-  private static class SubClass1 extends BaseClass {
-    public String subclassMethod() {
-      return "subclassMethod1";
-    }
-
-    public String methodWithArgs(String arg) {
-      return arg;
-    }
-  }
-
-  @SuppressWarnings("unused")
-  private static class SubClass2 extends BaseClass {
-    public int subclassMethod() {
-      return 1234;
-    }
-
-    public String methodWithArgs(String arg) {
-      return arg;
-    }
-
-    public void throwsException() throws IOException {
-      throw new IOException();
-    }
-
-    public void throwsRuntimeException() throws Exception {
-      throw new NumberFormatException();
-    }
-
-    protected void nonPublic() {
-    }
-  }
-
-  private final static OptionalMethod<BaseClass> STRING_METHOD_RETURNS_ANY =
-      new OptionalMethod<>(null, "stringMethod");
-  private final static OptionalMethod<BaseClass> STRING_METHOD_RETURNS_STRING =
-      new OptionalMethod<>(String.class, "stringMethod");
-  private final static OptionalMethod<BaseClass> STRING_METHOD_RETURNS_INT =
-      new OptionalMethod<>(Integer.TYPE, "stringMethod");
-  private final static OptionalMethod<BaseClass> VOID_METHOD_RETURNS_ANY =
-      new OptionalMethod<>(null, "voidMethod");
-  private final static OptionalMethod<BaseClass> VOID_METHOD_RETURNS_VOID =
-      new OptionalMethod<>(Void.TYPE, "voidMethod");
-  private final static OptionalMethod<BaseClass> SUBCLASS_METHOD_RETURNS_ANY =
-      new OptionalMethod<>(null, "subclassMethod");
-  private final static OptionalMethod<BaseClass> SUBCLASS_METHOD_RETURNS_STRING =
-      new OptionalMethod<>(String.class, "subclassMethod");
-  private final static OptionalMethod<BaseClass> SUBCLASS_METHOD_RETURNS_INT =
-      new OptionalMethod<>(Integer.TYPE, "subclassMethod");
-  private final static OptionalMethod<BaseClass> METHOD_WITH_ARGS_WRONG_PARAMS =
-      new OptionalMethod<>(null, "methodWithArgs", Integer.class);
-  private final static OptionalMethod<BaseClass> METHOD_WITH_ARGS_CORRECT_PARAMS =
-      new OptionalMethod<>(null, "methodWithArgs", String.class);
-
-  private final static OptionalMethod<BaseClass> THROWS_EXCEPTION =
-      new OptionalMethod<>(null, "throwsException");
-  private final static OptionalMethod<BaseClass> THROWS_RUNTIME_EXCEPTION =
-      new OptionalMethod<>(null, "throwsRuntimeException");
-  private final static OptionalMethod<BaseClass> NON_PUBLIC =
-      new OptionalMethod<>(null, "nonPublic");
-
-  @Test
-  public void isSupported() throws Exception {
-    {
-      BaseClass base = new BaseClass();
-      assertTrue(STRING_METHOD_RETURNS_ANY.isSupported(base));
-      assertTrue(STRING_METHOD_RETURNS_STRING.isSupported(base));
-      assertFalse(STRING_METHOD_RETURNS_INT.isSupported(base));
-      assertTrue(VOID_METHOD_RETURNS_ANY.isSupported(base));
-      assertTrue(VOID_METHOD_RETURNS_VOID.isSupported(base));
-      assertFalse(SUBCLASS_METHOD_RETURNS_ANY.isSupported(base));
-      assertFalse(SUBCLASS_METHOD_RETURNS_STRING.isSupported(base));
-      assertFalse(SUBCLASS_METHOD_RETURNS_INT.isSupported(base));
-      assertFalse(METHOD_WITH_ARGS_WRONG_PARAMS.isSupported(base));
-      assertFalse(METHOD_WITH_ARGS_CORRECT_PARAMS.isSupported(base));
-    }
-    {
-      SubClass1 subClass1 = new SubClass1();
-      assertTrue(STRING_METHOD_RETURNS_ANY.isSupported(subClass1));
-      assertTrue(STRING_METHOD_RETURNS_STRING.isSupported(subClass1));
-      assertFalse(STRING_METHOD_RETURNS_INT.isSupported(subClass1));
-      assertTrue(VOID_METHOD_RETURNS_ANY.isSupported(subClass1));
-      assertTrue(VOID_METHOD_RETURNS_VOID.isSupported(subClass1));
-      assertTrue(SUBCLASS_METHOD_RETURNS_ANY.isSupported(subClass1));
-      assertTrue(SUBCLASS_METHOD_RETURNS_STRING.isSupported(subClass1));
-      assertFalse(SUBCLASS_METHOD_RETURNS_INT.isSupported(subClass1));
-      assertFalse(METHOD_WITH_ARGS_WRONG_PARAMS.isSupported(subClass1));
-      assertTrue(METHOD_WITH_ARGS_CORRECT_PARAMS.isSupported(subClass1));
-    }
-    {
-      SubClass2 subClass2 = new SubClass2();
-      assertTrue(STRING_METHOD_RETURNS_ANY.isSupported(subClass2));
-      assertTrue(STRING_METHOD_RETURNS_STRING.isSupported(subClass2));
-      assertFalse(STRING_METHOD_RETURNS_INT.isSupported(subClass2));
-      assertTrue(VOID_METHOD_RETURNS_ANY.isSupported(subClass2));
-      assertTrue(VOID_METHOD_RETURNS_VOID.isSupported(subClass2));
-      assertTrue(SUBCLASS_METHOD_RETURNS_ANY.isSupported(subClass2));
-      assertFalse(SUBCLASS_METHOD_RETURNS_STRING.isSupported(subClass2));
-      assertTrue(SUBCLASS_METHOD_RETURNS_INT.isSupported(subClass2));
-      assertFalse(METHOD_WITH_ARGS_WRONG_PARAMS.isSupported(subClass2));
-      assertTrue(METHOD_WITH_ARGS_CORRECT_PARAMS.isSupported(subClass2));
-    }
-  }
-
-  @Test
-  public void invoke() throws Exception {
-    {
-      BaseClass base = new BaseClass();
-      assertEquals("string", STRING_METHOD_RETURNS_STRING.invoke(base));
-      assertEquals("string", STRING_METHOD_RETURNS_ANY.invoke(base));
-      assertErrorOnInvoke(STRING_METHOD_RETURNS_INT, base);
-      assertNull(VOID_METHOD_RETURNS_ANY.invoke(base));
-      assertNull(VOID_METHOD_RETURNS_VOID.invoke(base));
-      assertErrorOnInvoke(SUBCLASS_METHOD_RETURNS_ANY, base);
-      assertErrorOnInvoke(SUBCLASS_METHOD_RETURNS_STRING, base);
-      assertErrorOnInvoke(SUBCLASS_METHOD_RETURNS_INT, base);
-      assertErrorOnInvoke(METHOD_WITH_ARGS_WRONG_PARAMS, base);
-      assertErrorOnInvoke(METHOD_WITH_ARGS_CORRECT_PARAMS, base);
-    }
-    {
-      SubClass1 subClass1 = new SubClass1();
-      assertEquals("string", STRING_METHOD_RETURNS_STRING.invoke(subClass1));
-      assertEquals("string", STRING_METHOD_RETURNS_ANY.invoke(subClass1));
-      assertErrorOnInvoke(STRING_METHOD_RETURNS_INT, subClass1);
-      assertNull(VOID_METHOD_RETURNS_ANY.invoke(subClass1));
-      assertNull(VOID_METHOD_RETURNS_VOID.invoke(subClass1));
-      assertEquals("subclassMethod1", SUBCLASS_METHOD_RETURNS_ANY.invoke(subClass1));
-      assertEquals("subclassMethod1", SUBCLASS_METHOD_RETURNS_STRING.invoke(subClass1));
-      assertErrorOnInvoke(SUBCLASS_METHOD_RETURNS_INT, subClass1);
-      assertErrorOnInvoke(METHOD_WITH_ARGS_WRONG_PARAMS, subClass1);
-      assertEquals("arg", METHOD_WITH_ARGS_CORRECT_PARAMS.invoke(subClass1, "arg"));
-    }
-
-    {
-      SubClass2 subClass2 = new SubClass2();
-      assertEquals("string", STRING_METHOD_RETURNS_STRING.invoke(subClass2));
-      assertEquals("string", STRING_METHOD_RETURNS_ANY.invoke(subClass2));
-      assertErrorOnInvoke(STRING_METHOD_RETURNS_INT, subClass2);
-      assertNull(VOID_METHOD_RETURNS_ANY.invoke(subClass2));
-      assertNull(VOID_METHOD_RETURNS_VOID.invoke(subClass2));
-      assertEquals(1234, SUBCLASS_METHOD_RETURNS_ANY.invoke(subClass2));
-      assertErrorOnInvoke(SUBCLASS_METHOD_RETURNS_STRING, subClass2);
-      assertEquals(1234, SUBCLASS_METHOD_RETURNS_INT.invoke(subClass2));
-      assertErrorOnInvoke(METHOD_WITH_ARGS_WRONG_PARAMS, subClass2);
-      assertEquals("arg", METHOD_WITH_ARGS_CORRECT_PARAMS.invoke(subClass2, "arg"));
-    }
-  }
-
-  @Test
-  public void invokeBadArgs() throws Exception {
-    SubClass1 subClass1 = new SubClass1();
-    assertIllegalArgumentExceptionOnInvoke(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1); // no args
-    assertIllegalArgumentExceptionOnInvoke(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1, 123);
-    assertIllegalArgumentExceptionOnInvoke(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1, true);
-    assertIllegalArgumentExceptionOnInvoke(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1,
-        new Object());
-    assertIllegalArgumentExceptionOnInvoke(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1, "one",
-        "two");
-  }
-
-  @Test
-  public void invokeWithException() throws Exception {
-    SubClass2 subClass2 = new SubClass2();
-    try {
-      THROWS_EXCEPTION.invoke(subClass2);
-    } catch (InvocationTargetException expected) {
-      assertTrue(expected.getTargetException() instanceof IOException);
-    }
-
-    try {
-      THROWS_RUNTIME_EXCEPTION.invoke(subClass2);
-    } catch (InvocationTargetException expected) {
-      assertTrue(expected.getTargetException() instanceof NumberFormatException);
-    }
-  }
-
-  @Test
-  public void invokeNonPublic() throws Exception {
-    SubClass2 subClass2 = new SubClass2();
-    assertFalse(NON_PUBLIC.isSupported(subClass2));
-    assertErrorOnInvoke(NON_PUBLIC, subClass2);
-  }
-
-  @Test
-  public void invokeOptional() throws Exception {
-    {
-      BaseClass base = new BaseClass();
-      assertEquals("string", STRING_METHOD_RETURNS_STRING.invokeOptional(base));
-      assertEquals("string", STRING_METHOD_RETURNS_ANY.invokeOptional(base));
-      assertNull(STRING_METHOD_RETURNS_INT.invokeOptional(base));
-      assertNull(VOID_METHOD_RETURNS_ANY.invokeOptional(base));
-      assertNull(VOID_METHOD_RETURNS_VOID.invokeOptional(base));
-      assertNull(SUBCLASS_METHOD_RETURNS_ANY.invokeOptional(base));
-      assertNull(SUBCLASS_METHOD_RETURNS_STRING.invokeOptional(base));
-      assertNull(SUBCLASS_METHOD_RETURNS_INT.invokeOptional(base));
-      assertNull(METHOD_WITH_ARGS_WRONG_PARAMS.invokeOptional(base));
-      assertNull(METHOD_WITH_ARGS_CORRECT_PARAMS.invokeOptional(base));
-    }
-    {
-      SubClass1 subClass1 = new SubClass1();
-      assertEquals("string", STRING_METHOD_RETURNS_STRING.invokeOptional(subClass1));
-      assertEquals("string", STRING_METHOD_RETURNS_ANY.invokeOptional(subClass1));
-      assertNull(STRING_METHOD_RETURNS_INT.invokeOptional(subClass1));
-      assertNull(VOID_METHOD_RETURNS_ANY.invokeOptional(subClass1));
-      assertNull(VOID_METHOD_RETURNS_VOID.invokeOptional(subClass1));
-      assertEquals("subclassMethod1", SUBCLASS_METHOD_RETURNS_ANY.invokeOptional(subClass1));
-      assertEquals("subclassMethod1", SUBCLASS_METHOD_RETURNS_STRING.invokeOptional(subClass1));
-      assertNull(SUBCLASS_METHOD_RETURNS_INT.invokeOptional(subClass1));
-      assertNull(METHOD_WITH_ARGS_WRONG_PARAMS.invokeOptional(subClass1));
-      assertEquals("arg", METHOD_WITH_ARGS_CORRECT_PARAMS.invokeOptional(subClass1, "arg"));
-    }
-
-    {
-      SubClass2 subClass2 = new SubClass2();
-      assertEquals("string", STRING_METHOD_RETURNS_STRING.invokeOptional(subClass2));
-      assertEquals("string", STRING_METHOD_RETURNS_ANY.invokeOptional(subClass2));
-      assertNull(STRING_METHOD_RETURNS_INT.invokeOptional(subClass2));
-      assertNull(VOID_METHOD_RETURNS_ANY.invokeOptional(subClass2));
-      assertNull(VOID_METHOD_RETURNS_VOID.invokeOptional(subClass2));
-      assertEquals(1234, SUBCLASS_METHOD_RETURNS_ANY.invokeOptional(subClass2));
-      assertNull(SUBCLASS_METHOD_RETURNS_STRING.invokeOptional(subClass2));
-      assertEquals(1234, SUBCLASS_METHOD_RETURNS_INT.invokeOptional(subClass2));
-      assertNull(METHOD_WITH_ARGS_WRONG_PARAMS.invokeOptional(subClass2));
-      assertEquals("arg", METHOD_WITH_ARGS_CORRECT_PARAMS.invokeOptional(subClass2, "arg"));
-    }
-  }
-
-  @Test
-  public void invokeOptionalBadArgs() throws Exception {
-    SubClass1 subClass1 = new SubClass1();
-    assertIllegalArgumentExceptionOnInvokeOptional(METHOD_WITH_ARGS_CORRECT_PARAMS,
-        subClass1); // no args
-    assertIllegalArgumentExceptionOnInvokeOptional(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1, 123);
-    assertIllegalArgumentExceptionOnInvokeOptional(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1,
-        true);
-    assertIllegalArgumentExceptionOnInvokeOptional(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1,
-        new Object());
-    assertIllegalArgumentExceptionOnInvokeOptional(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1,
-        "one", "two");
-  }
-
-  @Test
-  public void invokeOptionalWithException() throws Exception {
-    SubClass2 subClass2 = new SubClass2();
-    try {
-      THROWS_EXCEPTION.invokeOptional(subClass2);
-    } catch (InvocationTargetException expected) {
-      assertTrue(expected.getTargetException() instanceof IOException);
-    }
-
-    try {
-      THROWS_RUNTIME_EXCEPTION.invokeOptional(subClass2);
-    } catch (InvocationTargetException expected) {
-      assertTrue(expected.getTargetException() instanceof NumberFormatException);
-    }
-  }
-
-  @Test
-  @Ignore("Despite returning false for isSupported, invocation actually succeeds.")
-  public void invokeOptionalNonPublic() throws Exception {
-    SubClass2 subClass2 = new SubClass2();
-    assertFalse(NON_PUBLIC.isSupported(subClass2));
-    assertErrorOnInvokeOptional(NON_PUBLIC, subClass2);
-  }
-
-  private static <T> void assertErrorOnInvoke(
-      OptionalMethod<T> optionalMethod, T base, Object... args) throws Exception {
-    try {
-      optionalMethod.invoke(base, args);
-    } catch (Error expected) {
-      return;
-    }
-    fail();
-  }
-
-  private static <T> void assertIllegalArgumentExceptionOnInvoke(
-      OptionalMethod<T> optionalMethod, T base, Object... args) throws Exception {
-    try {
-      optionalMethod.invoke(base, args);
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  private static <T> void assertErrorOnInvokeOptional(
-      OptionalMethod<T> optionalMethod, T base, Object... args) throws Exception {
-    try {
-      optionalMethod.invokeOptional(base, args);
-    } catch (Error expected) {
-      return;
-    }
-    fail();
-  }
-
-  private static <T> void assertIllegalArgumentExceptionOnInvokeOptional(
-      OptionalMethod<T> optionalMethod, T base, Object... args) throws Exception {
-    try {
-      optionalMethod.invokeOptional(base, args);
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/platform/PlatformTest.java b/okhttp-tests/src/test/java/okhttp3/internal/platform/PlatformTest.java
index ffd5842e83..48504202b5 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/platform/PlatformTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/platform/PlatformTest.java
@@ -32,4 +32,9 @@
   public static String getPlatform() {
     return System.getProperty("okhttp.platform", "platform");
   }
+
+  @Test
+  public void testToStringIsClassname() {
+    assertEquals("Platform", new Platform().toString());
+  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/tls/CertificatePinnerChainValidationTest.java b/okhttp-tests/src/test/java/okhttp3/internal/tls/CertificatePinnerChainValidationTest.java
index ffb116eea7..256afe67fe 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/tls/CertificatePinnerChainValidationTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/tls/CertificatePinnerChainValidationTest.java
@@ -37,8 +37,8 @@
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.SocketPolicy;
-import okhttp3.tls.HeldCertificate;
 import okhttp3.tls.HandshakeCertificates;
+import okhttp3.tls.HeldCertificate;
 import org.junit.Rule;
 import org.junit.Test;
 
@@ -335,8 +335,7 @@ private SSLSocketFactory newServerSocketFactory(HeldCertificate heldCertificate,
     // http://hg.openjdk.java.net/jdk9/jdk9/jdk/file/2c1c21d11e58/src/share/classes/sun/security/pkcs12/PKCS12KeyStore.java#l596
     String keystoreType = getPlatform().equals("jdk9") ? "JKS" : null;
     X509KeyManager x509KeyManager = newKeyManager(keystoreType, heldCertificate, intermediates);
-    X509TrustManager trustManager = newTrustManager(
-        keystoreType, Collections.<X509Certificate>emptyList());
+    X509TrustManager trustManager = newTrustManager(keystoreType, Collections.emptyList());
     SSLContext sslContext = Platform.get().getSSLContext();
     sslContext.init(new KeyManager[] { x509KeyManager }, new TrustManager[] { trustManager },
         new SecureRandom());
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/tls/ClientAuthTest.java b/okhttp-tests/src/test/java/okhttp3/internal/tls/ClientAuthTest.java
index ff3fb12270..e88b9fef25 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/tls/ClientAuthTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/tls/ClientAuthTest.java
@@ -36,8 +36,8 @@
 import okhttp3.Response;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.tls.HeldCertificate;
 import okhttp3.tls.HandshakeCertificates;
+import okhttp3.tls.HeldCertificate;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
@@ -47,7 +47,7 @@
 import static okhttp3.tls.internal.TlsUtil.newKeyManager;
 import static okhttp3.tls.internal.TlsUtil.newTrustManager;
 import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.assertNull;
 import static org.junit.Assert.fail;
 
 public final class ClientAuthTest {
@@ -149,7 +149,7 @@ public void setUp() {
     Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
     Response response = call.execute();
     assertEquals(new X500Principal("CN=Local Host"), response.handshake().peerPrincipal());
-    assertEquals(null, response.handshake().localPrincipal());
+    assertNull(response.handshake().localPrincipal());
     assertEquals("abc", response.body().string());
   }
 
@@ -165,7 +165,7 @@ public void setUp() {
     Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
     Response response = call.execute();
     assertEquals(new X500Principal("CN=Local Host"), response.handshake().peerPrincipal());
-    assertEquals(null, response.handshake().localPrincipal());
+    assertNull(response.handshake().localPrincipal());
     assertEquals("abc", response.body().string());
   }
 
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/tls/HostnameVerifierTest.java b/okhttp-tests/src/test/java/okhttp3/internal/tls/HostnameVerifierTest.java
index 6dd5bbbd7c..81f41b0442 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/tls/HostnameVerifierTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/tls/HostnameVerifierTest.java
@@ -28,6 +28,7 @@
 import org.junit.Ignore;
 import org.junit.Test;
 
+import static java.nio.charset.StandardCharsets.UTF_8;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
@@ -544,7 +545,7 @@
 
   private X509Certificate certificate(String certificate) throws Exception {
     return (X509Certificate) CertificateFactory.getInstance("X.509").generateCertificate(
-        new ByteArrayInputStream(certificate.getBytes(Util.UTF_8)));
+        new ByteArrayInputStream(certificate.getBytes(UTF_8)));
   }
 
   private SSLSession session(String certificate) throws Exception {
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketHttpTest.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketHttpTest.java
index 565ffdac58..e4c29b8374 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketHttpTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketHttpTest.java
@@ -17,16 +17,18 @@
 
 import java.io.EOFException;
 import java.io.IOException;
+import java.net.HttpURLConnection;
 import java.net.ProtocolException;
 import java.net.SocketTimeoutException;
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.Random;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.logging.Logger;
-import okhttp3.Interceptor;
 import okhttp3.OkHttpClient;
+import okhttp3.Protocol;
 import okhttp3.RecordingEventListener;
 import okhttp3.RecordingHostnameVerifier;
 import okhttp3.Request;
@@ -67,17 +69,17 @@
   private OkHttpClient client = defaultClient().newBuilder()
       .writeTimeout(500, TimeUnit.MILLISECONDS)
       .readTimeout(500, TimeUnit.MILLISECONDS)
-      .addInterceptor(new Interceptor() {
-        @Override public Response intercept(Chain chain) throws IOException {
-          Response response = chain.proceed(chain.request());
-          assertNotNull(response.body()); // Ensure application interceptors never see a null body.
-          return response;
-        }
+      .addInterceptor(chain -> {
+        Response response = chain.proceed(chain.request());
+        assertNotNull(response.body()); // Ensure application interceptors never see a null body.
+        return response;
       })
       .build();
 
   @After public void tearDown() {
     clientListener.assertExhausted();
+
+    // TODO: assert all connections are released once leaks are fixed
   }
 
   @Test public void textMessage() {
@@ -85,10 +87,12 @@
     WebSocket webSocket = newWebSocket();
 
     clientListener.assertOpen();
-    serverListener.assertOpen();
+    WebSocket server = serverListener.assertOpen();
 
     webSocket.send("Hello, WebSockets!");
     serverListener.assertTextMessage("Hello, WebSockets!");
+
+    closeWebSockets(webSocket, server);
   }
 
   @Test public void binaryMessage() {
@@ -96,10 +100,12 @@
     WebSocket webSocket = newWebSocket();
 
     clientListener.assertOpen();
-    serverListener.assertOpen();
+    WebSocket server = serverListener.assertOpen();
 
     webSocket.send(ByteString.encodeUtf8("Hello!"));
     serverListener.assertBinaryMessage(ByteString.of(new byte[] {'H', 'e', 'l', 'l', 'o', '!'}));
+
+    closeWebSockets(webSocket, server);
   }
 
   @Test public void nullStringThrows() {
@@ -107,12 +113,15 @@
     WebSocket webSocket = newWebSocket();
 
     clientListener.assertOpen();
+    WebSocket server = serverListener.assertOpen();
     try {
       webSocket.send((String) null);
       fail();
     } catch (NullPointerException e) {
       assertEquals("text == null", e.getMessage());
     }
+
+    closeWebSockets(webSocket, server);
   }
 
   @Test public void nullByteStringThrows() {
@@ -120,23 +129,28 @@
     WebSocket webSocket = newWebSocket();
 
     clientListener.assertOpen();
+    WebSocket server = serverListener.assertOpen();
     try {
       webSocket.send((ByteString) null);
       fail();
     } catch (NullPointerException e) {
       assertEquals("bytes == null", e.getMessage());
     }
+
+    closeWebSockets(webSocket, server);
   }
 
   @Test public void serverMessage() {
     webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-    newWebSocket();
+    WebSocket webSocket = newWebSocket();
 
     clientListener.assertOpen();
     WebSocket server = serverListener.assertOpen();
 
     server.send("Hello, WebSockets!");
     clientListener.assertTextMessage("Hello, WebSockets!");
+
+    closeWebSockets(webSocket, server);
   }
 
   @Test public void throwingOnOpenFailsImmediately() {
@@ -240,13 +254,10 @@
     webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
     newWebSocket();
 
-    clientListener.assertOpen();
+    WebSocket webSocket = clientListener.assertOpen();
     WebSocket server = serverListener.assertOpen();
 
-    server.close(1001, "bye");
-    clientListener.assertClosing(1001, "bye");
-    clientListener.assertExhausted();
-    serverListener.assertExhausted();
+    closeWebSockets(webSocket, server);
   }
 
   @Test public void non101RetainsBody() throws IOException {
@@ -278,6 +289,8 @@
 
     server.send("def");
     clientListener.assertTextMessage("def");
+
+    closeWebSockets(webSocket, server);
   }
 
   @Test public void missingConnectionHeader() throws IOException {
@@ -353,16 +366,15 @@
     final AtomicInteger interceptedCount = new AtomicInteger();
 
     client = client.newBuilder()
-        .addInterceptor(new Interceptor() {
-          @Override public Response intercept(Chain chain) throws IOException {
-            assertNull(chain.request().body());
-            Response response = chain.proceed(chain.request());
-            assertEquals("Upgrade", response.header("Connection"));
-            assertTrue(response.body().source().exhausted());
-            interceptedCount.incrementAndGet();
-            return response;
-          }
-        }).build();
+        .addInterceptor(chain -> {
+          assertNull(chain.request().body());
+          Response response = chain.proceed(chain.request());
+          assertEquals("Upgrade", response.header("Connection"));
+          assertTrue(response.body().source().exhausted());
+          interceptedCount.incrementAndGet();
+          return response;
+        })
+        .build();
 
     webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
 
@@ -373,24 +385,24 @@
 
     WebSocket server = serverListener.assertOpen();
     server.close(1000, null);
+    clientListener.assertClosing(1000, "");
+    clientListener.assertClosed(1000, "");
   }
 
   @Test public void webSocketAndNetworkInterceptors() {
     client = client.newBuilder()
-        .addNetworkInterceptor(new Interceptor() {
-          @Override public Response intercept(Chain chain) {
-            throw new AssertionError(); // Network interceptors don't execute.
-          }
-        }).build();
+        .addNetworkInterceptor(chain -> {
+          throw new AssertionError(); // Network interceptors don't execute.
+        })
+        .build();
 
     webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
 
     WebSocket webSocket = newWebSocket();
     clientListener.assertOpen();
-    webSocket.close(1000, null);
-
     WebSocket server = serverListener.assertOpen();
-    server.close(1000, null);
+
+    closeWebSockets(webSocket, server);
   }
 
   @Test public void overflowOutgoingQueue() {
@@ -535,7 +547,7 @@
 
   @Test public void readTimeoutDoesNotApplyAcrossFrames() throws Exception {
     webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-    newWebSocket();
+    WebSocket webSocket = newWebSocket();
 
     clientListener.assertOpen();
     WebSocket server = serverListener.assertOpen();
@@ -545,6 +557,8 @@
 
     server.send("abc");
     clientListener.assertTextMessage("abc");
+
+    closeWebSockets(webSocket, server);
   }
 
   @Test public void clientPingsServerOnInterval() throws Exception {
@@ -574,6 +588,8 @@
     // The server has never pinged the client.
     assertEquals(0, server.receivedPongCount());
     assertEquals(0, webSocket.receivedPingCount());
+
+    closeWebSockets(webSocket, server);
   }
 
   @Test public void clientDoesNotPingServerByDefault() throws Exception {
@@ -592,6 +608,8 @@
     assertEquals(0, server.sentPingCount());
     assertEquals(0, server.receivedPingCount());
     assertEquals(0, server.receivedPongCount());
+
+    closeWebSockets(webSocket, server);
   }
 
   /**
@@ -677,6 +695,55 @@
     assertEquals(Collections.emptyList(), listener.recordedEventTypes());
   }
 
+  @Test public void callTimeoutIsNotApplied() throws Exception {
+    client = client.newBuilder()
+        .callTimeout(100, TimeUnit.MILLISECONDS)
+        .build();
+
+    webServer.enqueue(new MockResponse()
+        .withWebSocketUpgrade(serverListener));
+    WebSocket webSocket = newWebSocket();
+
+    clientListener.assertOpen();
+    WebSocket server = serverListener.assertOpen();
+
+    Thread.sleep(500);
+
+    server.send("Hello, WebSockets!");
+    clientListener.assertTextMessage("Hello, WebSockets!");
+
+    closeWebSockets(webSocket, server);
+  }
+
+  /**
+   * We had a bug where web socket connections were leaked if the HTTP connection upgrade was not
+   * successful. This test confirms that connections are released back to the connection pool!
+   * https://github.com/square/okhttp/issues/4258
+   */
+  @Test public void webSocketConnectionIsReleased() throws Exception {
+    // This test assumes HTTP/1.1 pooling semantics.
+    client = client.newBuilder()
+        .protocols(Arrays.asList(Protocol.HTTP_1_1))
+        .build();
+
+    webServer.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_FOUND)
+        .setBody("not found!"));
+    webServer.enqueue(new MockResponse());
+
+    newWebSocket();
+    clientListener.assertFailure();
+
+    Request regularRequest = new Request.Builder()
+        .url(webServer.url("/"))
+        .build();
+    Response response = client.newCall(regularRequest).execute();
+    response.close();
+
+    assertEquals(0, webServer.takeRequest().getSequenceNumber());
+    assertEquals(1, webServer.takeRequest().getSequenceNumber());
+  }
+
   private MockResponse upgradeResponse(RecordedRequest request) {
     String key = request.getHeader("Sec-WebSocket-Key");
     return new MockResponse()
@@ -695,10 +762,12 @@ private void websocketScheme(String scheme) {
 
     RealWebSocket webSocket = newWebSocket(request);
     clientListener.assertOpen();
-    serverListener.assertOpen();
+    WebSocket server = serverListener.assertOpen();
 
     webSocket.send("abc");
     serverListener.assertTextMessage("abc");
+
+    closeWebSockets(webSocket, server);
   }
 
   private RealWebSocket newWebSocket() {
@@ -711,4 +780,15 @@ private RealWebSocket newWebSocket(Request request) {
     webSocket.connect(client);
     return webSocket;
   }
+
+  private void closeWebSockets(WebSocket webSocket, WebSocket server) {
+    server.close(1001, "");
+    clientListener.assertClosing(1001, "");
+    webSocket.close(1000, "");
+    serverListener.assertClosing(1000, "");
+    clientListener.assertClosed(1001, "");
+    serverListener.assertClosed(1000, "");
+    clientListener.assertExhausted();
+    serverListener.assertExhausted();
+  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java
index f6256ac42f..e8d4353829 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java
@@ -17,6 +17,7 @@
 
 import java.io.IOException;
 import java.util.Arrays;
+import java.util.Objects;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.TimeUnit;
@@ -24,7 +25,6 @@
 import okhttp3.Response;
 import okhttp3.WebSocket;
 import okhttp3.WebSocketListener;
-import okhttp3.internal.Util;
 import okhttp3.internal.platform.Platform;
 import okio.ByteString;
 
@@ -86,7 +86,7 @@ public void setNextEventDelegate(WebSocketListener delegate) {
   }
 
   @Override public void onClosing(WebSocket webSocket, int code, String reason) {
-    Platform.get().log(Platform.INFO, "[WS " + name + "] onClose " + code, null);
+    Platform.get().log(Platform.INFO, "[WS " + name + "] onClosing " + code, null);
 
     WebSocketListener delegate = this.delegate;
     if (delegate != null) {
@@ -98,7 +98,7 @@ public void setNextEventDelegate(WebSocketListener delegate) {
   }
 
   @Override public void onClosed(WebSocket webSocket, int code, String reason) {
-    Platform.get().log(Platform.INFO, "[WS " + name + "] onClose " + code, null);
+    Platform.get().log(Platform.INFO, "[WS " + name + "] onClosed " + code, null);
 
     WebSocketListener delegate = this.delegate;
     if (delegate != null) {
@@ -309,8 +309,8 @@ public Message(String string) {
 
     @Override public boolean equals(Object other) {
       return other instanceof Message
-          && Util.equal(((Message) other).bytes, bytes)
-          && Util.equal(((Message) other).string, string);
+          && Objects.equals(((Message) other).bytes, bytes)
+          && Objects.equals(((Message) other).string, string);
     }
   }
 
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java
index e183d0e2a8..48684f553a 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java
@@ -28,7 +28,6 @@
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.TestRule;
-import org.junit.runner.Description;
 import org.junit.runners.model.Statement;
 
 import static okhttp3.TestUtil.repeat;
@@ -36,7 +35,6 @@
 import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_TEXT;
 import static okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_BYTE_MAX;
 import static okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_SHORT_MAX;
-import static okhttp3.internal.ws.WebSocketProtocol.toggleMask;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
@@ -49,14 +47,10 @@
    * Check all data as verified inside of the test. We do this in a rule instead of @After so that
    * exceptions thrown from the test do not cause this check to fail.
    */
-  @Rule public final TestRule noDataLeftBehind = new TestRule() {
-    @Override public Statement apply(final Statement base, Description description) {
-      return new Statement() {
-        @Override public void evaluate() throws Throwable {
-          base.evaluate();
-          assertEquals("Data not empty", "", data.readByteString().hex());
-        }
-      };
+  @Rule public final TestRule noDataLeftBehind = (base, description) -> new Statement() {
+    @Override public void evaluate() throws Throwable {
+      base.evaluate();
+      assertEquals("Data not empty", "", data.readByteString().hex());
     }
   };
 
diff --git a/okhttp-tls/pom.xml b/okhttp-tls/pom.xml
index 3b40e6e714..0c7d643913 100644
--- a/okhttp-tls/pom.xml
+++ b/okhttp-tls/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.12.0-SNAPSHOT</version>
+    <version>3.13.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-tls</artifactId>
@@ -46,8 +46,9 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-javadoc-plugin</artifactId>
-        <version>2.10.4</version>
+        <version>3.0.1</version>
         <configuration>
+          <excludePackageNames>okhttp3.tls.internal:okhttp3.tls.internal.*</excludePackageNames>
           <links>
             <link>http://square.github.io/okhttp/javadoc/</link>
           </links>
@@ -56,7 +57,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-jar-plugin</artifactId>
-        <version>3.0.2</version>
+        <version>3.1.1</version>
         <configuration>
           <archive>
             <manifestEntries>
diff --git a/okhttp-tls/src/main/java/okhttp3/tls/HandshakeCertificates.java b/okhttp-tls/src/main/java/okhttp3/tls/HandshakeCertificates.java
index 015eb81ed9..34e9e9a497 100644
--- a/okhttp-tls/src/main/java/okhttp3/tls/HandshakeCertificates.java
+++ b/okhttp-tls/src/main/java/okhttp3/tls/HandshakeCertificates.java
@@ -22,6 +22,7 @@
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
+import javax.annotation.Nullable;
 import javax.net.ssl.KeyManager;
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLSocketFactory;
@@ -110,8 +111,8 @@ public SSLContext sslContext() {
   }
 
   public static final class Builder {
-    private HeldCertificate heldCertificate;
-    private X509Certificate[] intermediates;
+    private @Nullable HeldCertificate heldCertificate;
+    private @Nullable X509Certificate[] intermediates;
 
     private final List<X509Certificate> trustedCertificates = new ArrayList<>();
 
diff --git a/okhttp-tls/src/main/java/okhttp3/tls/HeldCertificate.java b/okhttp-tls/src/main/java/okhttp3/tls/HeldCertificate.java
index 68f16db23d..c659f58196 100644
--- a/okhttp-tls/src/main/java/okhttp3/tls/HeldCertificate.java
+++ b/okhttp-tls/src/main/java/okhttp3/tls/HeldCertificate.java
@@ -32,6 +32,7 @@
 import java.util.List;
 import java.util.UUID;
 import java.util.concurrent.TimeUnit;
+import javax.annotation.Nullable;
 import javax.security.auth.x500.X500Principal;
 import okio.ByteString;
 import org.bouncycastle.asn1.ASN1Encodable;
@@ -203,14 +204,14 @@ private void encodeBase64Lines(StringBuilder out, ByteString data) {
 
     private long notBefore = -1L;
     private long notAfter = -1L;
-    private String cn;
-    private String ou;
+    private @Nullable String cn;
+    private @Nullable String ou;
     private final List<String> altNames = new ArrayList<>();
-    private BigInteger serialNumber;
-    private KeyPair keyPair;
-    private HeldCertificate signedBy;
+    private @Nullable BigInteger serialNumber;
+    private @Nullable KeyPair keyPair;
+    private @Nullable HeldCertificate signedBy;
     private int maxIntermediateCas = -1;
-    private String keyAlgorithm;
+    private @Nullable String keyAlgorithm;
     private int keySize;
 
     public Builder() {
@@ -331,7 +332,7 @@ public Builder certificateAuthority(int maxIntermediateCas) {
      * 3.11.0. Note that the default may change in future releases.
      */
     public Builder ecdsa256() {
-      keyAlgorithm = "ECDSA";
+      keyAlgorithm = "EC";
       keySize = 256;
       return this;
     }
@@ -399,8 +400,7 @@ public HeldCertificate build() {
       }
 
       try {
-        X509Certificate certificate = generator.generateX509Certificate(
-            signedByKeyPair.getPrivate(), "BC");
+        X509Certificate certificate = generator.generate(signedByKeyPair.getPrivate());
         return new HeldCertificate(heldKeyPair, certificate);
       } catch (GeneralSecurityException e) {
         throw new AssertionError(e);
@@ -422,7 +422,7 @@ private X500Principal buildSubject() {
 
     private KeyPair generateKeyPair() {
       try {
-        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(keyAlgorithm, "BC");
+        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(keyAlgorithm);
         keyPairGenerator.initialize(keySize, new SecureRandom());
         return keyPairGenerator.generateKeyPair();
       } catch (GeneralSecurityException e) {
diff --git a/okhttp-tls/src/main/java/okhttp3/tls/package-info.java b/okhttp-tls/src/main/java/okhttp3/tls/package-info.java
new file mode 100644
index 0000000000..061e524be6
--- /dev/null
+++ b/okhttp-tls/src/main/java/okhttp3/tls/package-info.java
@@ -0,0 +1,3 @@
+/** OkHttp Transport Layer Security (TLS) library. */
+@okhttp3.internal.annotations.EverythingIsNonNull
+package okhttp3.tls;
diff --git a/okhttp-tls/src/test/java/okhttp3/tls/HandshakeCertificatesTest.java b/okhttp-tls/src/test/java/okhttp3/tls/HandshakeCertificatesTest.java
index c2e4f3a45f..6892e14f0b 100644
--- a/okhttp-tls/src/test/java/okhttp3/tls/HandshakeCertificatesTest.java
+++ b/okhttp-tls/src/test/java/okhttp3/tls/HandshakeCertificatesTest.java
@@ -25,7 +25,6 @@
 import java.util.Arrays;
 import java.util.LinkedHashSet;
 import java.util.Set;
-import java.util.concurrent.Callable;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.Future;
@@ -33,12 +32,12 @@
 import javax.net.SocketFactory;
 import javax.net.ssl.SSLSocket;
 import okhttp3.Handshake;
-import okhttp3.internal.Util;
 import okio.ByteString;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 
+import static okhttp3.internal.Util.closeQuietly;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 
@@ -52,7 +51,7 @@
 
   @After public void tearDown() {
     executorService.shutdown();
-    Util.closeQuietly(serverSocket);
+    closeQuietly(serverSocket);
   }
 
   @Test public void clientAndServer() throws Exception {
@@ -149,45 +148,39 @@ private InetSocketAddress startTlsServer() throws IOException {
     return new InetSocketAddress(serverAddress, serverSocket.getLocalPort());
   }
 
-  private Future<Handshake> doServerHandshake(final HandshakeCertificates server) {
-    return executorService.submit(new Callable<Handshake>() {
-      @Override public Handshake call() throws Exception {
-        Socket rawSocket = null;
-        SSLSocket sslSocket = null;
-        try {
-          rawSocket = serverSocket.accept();
-          sslSocket = (SSLSocket) server.sslSocketFactory().createSocket(rawSocket,
-              rawSocket.getInetAddress().getHostAddress(), rawSocket.getPort(),
-              true /* autoClose */);
-          sslSocket.setUseClientMode(false);
-          sslSocket.setWantClientAuth(true);
-          sslSocket.startHandshake();
-          return Handshake.get(sslSocket.getSession());
-        } finally {
-          Util.closeQuietly(rawSocket);
-          Util.closeQuietly(sslSocket);
-        }
+  private Future<Handshake> doServerHandshake(HandshakeCertificates server) {
+    return executorService.submit(() -> {
+      Socket rawSocket = null;
+      SSLSocket sslSocket = null;
+      try {
+        rawSocket = serverSocket.accept();
+        sslSocket = (SSLSocket) server.sslSocketFactory().createSocket(rawSocket,
+            rawSocket.getInetAddress().getHostAddress(), rawSocket.getPort(), true /* autoClose */);
+        sslSocket.setUseClientMode(false);
+        sslSocket.setWantClientAuth(true);
+        sslSocket.startHandshake();
+        return Handshake.get(sslSocket.getSession());
+      } finally {
+        closeQuietly(rawSocket);
+        closeQuietly(sslSocket);
       }
     });
   }
 
   private Future<Handshake> doClientHandshake(
-      final HandshakeCertificates client, final InetSocketAddress serverAddress) {
-    return executorService.submit(new Callable<Handshake>() {
-      @Override public Handshake call() throws Exception {
-        Socket rawSocket = SocketFactory.getDefault().createSocket();
-        rawSocket.connect(serverAddress);
-        SSLSocket sslSocket = null;
-        try {
-          sslSocket = (SSLSocket) client.sslSocketFactory().createSocket(rawSocket,
-              rawSocket.getInetAddress().getHostAddress(), rawSocket.getPort(),
-              true /* autoClose */);
-          sslSocket.startHandshake();
-          return Handshake.get(sslSocket.getSession());
-        } finally {
-          Util.closeQuietly(rawSocket);
-          Util.closeQuietly(sslSocket);
-        }
+      HandshakeCertificates client, InetSocketAddress serverAddress) {
+    return executorService.submit(() -> {
+      Socket rawSocket = SocketFactory.getDefault().createSocket();
+      rawSocket.connect(serverAddress);
+      SSLSocket sslSocket = null;
+      try {
+        sslSocket = (SSLSocket) client.sslSocketFactory().createSocket(rawSocket,
+            rawSocket.getInetAddress().getHostAddress(), rawSocket.getPort(), true /* autoClose */);
+        sslSocket.startHandshake();
+        return Handshake.get(sslSocket.getSession());
+      } finally {
+        closeQuietly(rawSocket);
+        closeQuietly(sslSocket);
       }
     });
   }
diff --git a/okhttp-tls/src/test/java/okhttp3/tls/HeldCertificateTest.java b/okhttp-tls/src/test/java/okhttp3/tls/HeldCertificateTest.java
index 96c8601b24..ffec150f32 100644
--- a/okhttp-tls/src/test/java/okhttp3/tls/HeldCertificateTest.java
+++ b/okhttp-tls/src/test/java/okhttp3/tls/HeldCertificateTest.java
@@ -52,9 +52,6 @@
     long durationMillis = TimeUnit.MINUTES.toMillis(60 * 24);
     assertEquals((double) now, certificate.getNotBefore().getTime(), deltaMillis);
     assertEquals((double) now + durationMillis, certificate.getNotAfter().getTime(), deltaMillis);
-
-    System.out.println(ByteString.of(heldCertificate.keyPair().getPublic().getEncoded()).base64());
-    System.out.println(ByteString.of(heldCertificate.keyPair().getPrivate().getEncoded()).base64());
   }
 
   @Test public void customInterval() {
diff --git a/okhttp-urlconnection/pom.xml b/okhttp-urlconnection/pom.xml
index 249a90de04..f98e26264b 100644
--- a/okhttp-urlconnection/pom.xml
+++ b/okhttp-urlconnection/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.12.0-SNAPSHOT</version>
+    <version>3.13.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-urlconnection</artifactId>
@@ -60,7 +60,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-javadoc-plugin</artifactId>
-        <version>2.10.4</version>
+        <version>3.0.1</version>
         <configuration>
           <excludePackageNames>okhttp3.internal:okhttp3.internal.*</excludePackageNames>
           <links>
@@ -71,7 +71,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-jar-plugin</artifactId>
-        <version>3.0.2</version>
+        <version>3.1.1</version>
         <configuration>
           <archive>
             <manifestEntries>
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/JavaNetAuthenticator.java b/okhttp-urlconnection/src/main/java/okhttp3/JavaNetAuthenticator.java
index 2649510d35..f1892b7199 100644
--- a/okhttp-urlconnection/src/main/java/okhttp3/JavaNetAuthenticator.java
+++ b/okhttp-urlconnection/src/main/java/okhttp3/JavaNetAuthenticator.java
@@ -22,12 +22,14 @@
 import java.net.PasswordAuthentication;
 import java.net.Proxy;
 import java.util.List;
+import okhttp3.internal.annotations.EverythingIsNonNull;
 
 /**
  * Adapts {@link java.net.Authenticator} to {@link Authenticator}. Configure OkHttp to use {@link
  * java.net.Authenticator} with {@link OkHttpClient.Builder#authenticator} or {@link
  * OkHttpClient.Builder#proxyAuthenticator(Authenticator)}.
  */
+@EverythingIsNonNull
 public final class JavaNetAuthenticator implements Authenticator {
   @Override public Request authenticate(Route route, Response response) throws IOException {
     List<Challenge> challenges = response.challenges();
@@ -66,7 +68,7 @@
   }
 
   private InetAddress getConnectToInetAddress(Proxy proxy, HttpUrl url) throws IOException {
-    return (proxy != null && proxy.type() != Proxy.Type.DIRECT)
+    return proxy.type() != Proxy.Type.DIRECT
         ? ((InetSocketAddress) proxy.address()).getAddress()
         : InetAddress.getByName(url.host());
   }
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/JavaNetCookieJar.java b/okhttp-urlconnection/src/main/java/okhttp3/JavaNetCookieJar.java
index 5d4f671a31..6faf288de7 100644
--- a/okhttp-urlconnection/src/main/java/okhttp3/JavaNetCookieJar.java
+++ b/okhttp-urlconnection/src/main/java/okhttp3/JavaNetCookieJar.java
@@ -22,6 +22,7 @@
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
+import okhttp3.internal.annotations.EverythingIsNonNull;
 import okhttp3.internal.platform.Platform;
 
 import static okhttp3.internal.Util.delimiterOffset;
@@ -29,6 +30,7 @@
 import static okhttp3.internal.platform.Platform.WARN;
 
 /** A cookie jar that delegates to a {@link java.net.CookieHandler}. */
+@EverythingIsNonNull
 public final class JavaNetCookieJar implements CookieJar {
   private final CookieHandler cookieHandler;
 
@@ -76,7 +78,7 @@ public JavaNetCookieJar(CookieHandler cookieHandler) {
 
     return cookies != null
         ? Collections.unmodifiableList(cookies)
-        : Collections.<Cookie>emptyList();
+        : Collections.emptyList();
   }
 
   /**
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/OkUrlFactory.java b/okhttp-urlconnection/src/main/java/okhttp3/OkUrlFactory.java
index 0bbe613492..8e4591e784 100644
--- a/okhttp-urlconnection/src/main/java/okhttp3/OkUrlFactory.java
+++ b/okhttp-urlconnection/src/main/java/okhttp3/OkUrlFactory.java
@@ -21,7 +21,9 @@
 import java.net.URLConnection;
 import java.net.URLStreamHandler;
 import java.net.URLStreamHandlerFactory;
+import javax.annotation.Nullable;
 import okhttp3.internal.URLFilter;
+import okhttp3.internal.annotations.EverythingIsNonNull;
 import okhttp3.internal.huc.OkHttpURLConnection;
 import okhttp3.internal.huc.OkHttpsURLConnection;
 
@@ -30,6 +32,7 @@
  * upcoming release. Applications that need this should either downgrade to the system's built-in
  * {@link HttpURLConnection} or upgrade to OkHttp's Request/Response API.
  */
+@EverythingIsNonNull
 public final class OkUrlFactory implements URLStreamHandlerFactory, Cloneable {
   private OkHttpClient client;
   private URLFilter urlFilter;
@@ -63,7 +66,7 @@ public HttpURLConnection open(URL url) {
     return open(url, client.proxy());
   }
 
-  HttpURLConnection open(URL url, Proxy proxy) {
+  HttpURLConnection open(URL url, @Nullable Proxy proxy) {
     String protocol = url.getProtocol();
     OkHttpClient copy = client.newBuilder()
         .proxy(proxy)
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/JavaNetHeaders.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/JavaNetHeaders.java
index 0b7a02e1f9..1b4290a7ef 100644
--- a/okhttp-urlconnection/src/main/java/okhttp3/internal/JavaNetHeaders.java
+++ b/okhttp-urlconnection/src/main/java/okhttp3/internal/JavaNetHeaders.java
@@ -27,18 +27,16 @@
   private JavaNetHeaders() {
   }
 
-  private static final Comparator<String> FIELD_NAME_COMPARATOR = new Comparator<String>() {
+  private static final Comparator<String> FIELD_NAME_COMPARATOR = (a, b) -> {
     // @FindBugsSuppressWarnings("ES_COMPARING_PARAMETER_STRING_WITH_EQ")
-    @Override public int compare(String a, String b) {
-      if (a == b) {
-        return 0;
-      } else if (a == null) {
-        return -1;
-      } else if (b == null) {
-        return 1;
-      } else {
-        return String.CASE_INSENSITIVE_ORDER.compare(a, b);
-      }
+    if (a == b) {
+      return 0;
+    } else if (a == null) {
+      return -1;
+    } else if (b == null) {
+      return 1;
+    } else {
+      return String.CASE_INSENSITIVE_ORDER.compare(a, b);
     }
   };
 
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/DelegatingHttpsURLConnection.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/DelegatingHttpsURLConnection.java
index a051bf2198..ae066f64b7 100644
--- a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/DelegatingHttpsURLConnection.java
+++ b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/DelegatingHttpsURLConnection.java
@@ -134,7 +134,6 @@
     return delegate.getContent();
   }
 
-  @SuppressWarnings("unchecked") // Spec does not generify
   @Override public Object getContent(Class[] types) throws IOException {
     return delegate.getContent(types);
   }
@@ -147,7 +146,7 @@
     return delegate.getContentLength();
   }
 
-  @IgnoreJRERequirement // Should only be invoked on Java 7+.
+  @IgnoreJRERequirement // Should only be invoked on Java 8+ or Android API 24+.
   @Override public long getContentLengthLong() {
     return delegate.getContentLengthLong();
   }
@@ -196,7 +195,7 @@
     return delegate.getHeaderField(key);
   }
 
-  @IgnoreJRERequirement // Should only be invoked on Java 7+.
+  @IgnoreJRERequirement // Should only be invoked on Java 8+ or Android API 24+.
   @Override public long getHeaderFieldLong(String field, long defaultValue) {
     return delegate.getHeaderFieldLong(field, defaultValue);
   }
@@ -261,7 +260,7 @@
     delegate.setDoOutput(newValue);
   }
 
-  @IgnoreJRERequirement // Should only be invoked on Java 7+.
+  @IgnoreJRERequirement // Should only be invoked on Java 8+ or Android API 24+.
   @Override public void setFixedLengthStreamingMode(long contentLength) {
     delegate.setFixedLengthStreamingMode(contentLength);
   }
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpURLConnection.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpURLConnection.java
index 31e532d0ad..1286cb7f53 100644
--- a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpURLConnection.java
+++ b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpURLConnection.java
@@ -52,6 +52,7 @@
 import okhttp3.internal.Internal;
 import okhttp3.internal.JavaNetHeaders;
 import okhttp3.internal.URLFilter;
+import okhttp3.internal.Util;
 import okhttp3.internal.Version;
 import okhttp3.internal.http.HttpDate;
 import okhttp3.internal.http.HttpHeaders;
@@ -414,7 +415,7 @@ private Call buildCall() throws IOException {
   }
 
   private String defaultUserAgent() {
-    String agent = System.getProperty("http.agent");
+    String agent = Util.getSystemProperty("http.agent", null);
     return agent != null ? toHumanReadableAscii(agent) : Version.userAgent();
   }
 
@@ -594,13 +595,11 @@ private Response getResponse(boolean networkResponseOnError) throws IOException
   }
 
   static final class UnexpectedException extends IOException {
-    static final Interceptor INTERCEPTOR = new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        try {
-          return chain.proceed(chain.request());
-        } catch (Error | RuntimeException e) {
-          throw new UnexpectedException(e);
-        }
+    static final Interceptor INTERCEPTOR = chain -> {
+      try {
+        return chain.proceed(chain.request());
+      } catch (Error | RuntimeException e) {
+        throw new UnexpectedException(e);
       }
     };
 
diff --git a/okhttp-urlconnection/src/test/java/okhttp3/OkUrlFactoryTest.java b/okhttp-urlconnection/src/test/java/okhttp3/OkUrlFactoryTest.java
index 914725fb84..1476dc69c4 100644
--- a/okhttp-urlconnection/src/test/java/okhttp3/OkUrlFactoryTest.java
+++ b/okhttp-urlconnection/src/test/java/okhttp3/OkUrlFactoryTest.java
@@ -14,7 +14,6 @@
 import java.util.TimeZone;
 import java.util.concurrent.TimeUnit;
 import javax.net.ssl.HttpsURLConnection;
-import okhttp3.internal.URLFilter;
 import okhttp3.internal.huc.OkHttpURLConnection;
 import okhttp3.internal.io.InMemoryFileSystem;
 import okhttp3.mockwebserver.MockResponse;
@@ -162,13 +161,8 @@ public void testURLFilter() throws Exception {
     server.enqueue(new MockResponse()
         .setBody("B"));
     final URL blockedURL = server.url("/a").url();
-    factory.setUrlFilter(new URLFilter() {
-      @Override
-      public void checkURLPermitted(URL url) throws IOException {
-        if (blockedURL.equals(url)) {
-          throw new IOException("Blocked");
-        }
-      }
+    factory.setUrlFilter(url -> {
+      if (blockedURL.equals(url)) throw new IOException("Blocked");
     });
     try {
       HttpURLConnection connection = factory.open(server.url("/a").url());
@@ -195,13 +189,8 @@ public void testURLFilterRedirect() {
             handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .followSslRedirects(true)
         .build());
-    factory.setUrlFilter(new URLFilter() {
-      @Override
-      public void checkURLPermitted(URL url) throws IOException {
-        if (blockedURL.equals(url)) {
-          throw new IOException("Blocked");
-        }
-      }
+    factory.setUrlFilter(url -> {
+      if (blockedURL.equals(url)) throw new IOException("Blocked");
     });
 
     server.enqueue(new MockResponse()
diff --git a/okhttp-urlconnection/src/test/java/okhttp3/UrlConnectionCacheTest.java b/okhttp-urlconnection/src/test/java/okhttp3/UrlConnectionCacheTest.java
index 23ff40c89e..d9434abddf 100644
--- a/okhttp-urlconnection/src/test/java/okhttp3/UrlConnectionCacheTest.java
+++ b/okhttp-urlconnection/src/test/java/okhttp3/UrlConnectionCacheTest.java
@@ -16,12 +16,10 @@
 
 package okhttp3;
 
-import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
-import java.io.InputStreamReader;
 import java.io.OutputStream;
 import java.net.CookieManager;
 import java.net.HttpURLConnection;
@@ -40,7 +38,6 @@
 import java.util.concurrent.TimeUnit;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.HttpsURLConnection;
-import javax.net.ssl.SSLSession;
 import okhttp3.internal.Internal;
 import okhttp3.internal.io.InMemoryFileSystem;
 import okhttp3.internal.platform.Platform;
@@ -50,6 +47,7 @@
 import okhttp3.tls.HandshakeCertificates;
 import okio.Buffer;
 import okio.BufferedSink;
+import okio.BufferedSource;
 import okio.GzipSink;
 import okio.Okio;
 import org.junit.After;
@@ -70,11 +68,7 @@
 
 /** Test caching with {@link OkUrlFactory}. */
 public final class UrlConnectionCacheTest {
-  private static final HostnameVerifier NULL_HOSTNAME_VERIFIER = new HostnameVerifier() {
-    @Override public boolean verify(String s, SSLSession sslSession) {
-      return true;
-    }
-  };
+  private static final HostnameVerifier NULL_HOSTNAME_VERIFIER = (name, session) -> true;
 
   @Rule public MockWebServer server = new MockWebServer();
   @Rule public MockWebServer server2 = new MockWebServer();
@@ -428,15 +422,15 @@ private void testServerPrematureDisconnect(TransferKind transferKind) throws IOE
     server.enqueue(truncateViolently(response, 16));
     server.enqueue(new MockResponse().setBody("Request #2"));
 
-    BufferedReader reader = new BufferedReader(
-        new InputStreamReader(urlFactory.open(server.url("/").url()).getInputStream()));
-    assertEquals("ABCDE", reader.readLine());
+    BufferedSource source = Okio.buffer(Okio.source(
+        urlFactory.open(server.url("/").url()).getInputStream()));
+    assertEquals("ABCDE\n", source.readUtf8(6));
     try {
-      reader.readLine();
+      source.readUtf8(21);
       fail("This implementation silently ignored a truncated HTTP body.");
     } catch (IOException expected) {
     } finally {
-      reader.close();
+      source.close();
     }
 
     assertEquals(1, cache.writeAbortCount());
@@ -1501,7 +1495,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
 
     URLConnection connection2 = urlFactory.open(server.url("/").url());
     assertEquals("A", readAscii(connection2));
-    assertEquals(null, connection2.getHeaderField("Warning"));
+    assertNull(connection2.getHeaderField("Warning"));
   }
 
   @Test public void getHeadersRetainsCached200LevelWarnings() throws Exception {
@@ -1539,7 +1533,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     // cache miss; seed the cache
     HttpURLConnection connection1 = urlFactory.open(server.url("/a").url());
     assertEquals("A", readAscii(connection1));
-    assertEquals(null, connection1.getHeaderField("Allow"));
+    assertNull(connection1.getHeaderField("Allow"));
 
     // conditional cache hit; update the cache
     HttpURLConnection connection2 = urlFactory.open(server.url("/a").url());
diff --git a/okhttp/pom.xml b/okhttp/pom.xml
index 0bd07c596c..9be94a0861 100644
--- a/okhttp/pom.xml
+++ b/okhttp/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.12.0-SNAPSHOT</version>
+    <version>3.13.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp</artifactId>
@@ -32,6 +32,12 @@
       <artifactId>jsr305</artifactId>
       <scope>provided</scope>
     </dependency>
+    <dependency>
+      <groupId>org.codehaus.mojo</groupId>
+      <artifactId>animal-sniffer-annotations</artifactId>
+      <version>1.17</version>
+      <scope>provided</scope>
+    </dependency>
   </dependencies>
 
   <build>
@@ -39,7 +45,7 @@
       <plugin>
         <groupId>org.codehaus.mojo</groupId>
         <artifactId>templating-maven-plugin</artifactId>
-        <version>1.0-alpha-3</version>
+        <version>1.0.0</version>
         <executions>
           <execution>
             <goals>
@@ -51,7 +57,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-javadoc-plugin</artifactId>
-        <version>2.10.4</version>
+        <version>3.0.1</version>
         <configuration>
           <excludePackageNames>okhttp3.internal:okhttp3.internal.*</excludePackageNames>
           <links>
@@ -62,7 +68,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-jar-plugin</artifactId>
-        <version>3.0.2</version>
+        <version>3.1.1</version>
         <configuration>
           <archive>
             <manifestEntries>
diff --git a/okhttp/src/main/java/okhttp3/Address.java b/okhttp/src/main/java/okhttp3/Address.java
index 9df666ad78..5ad2a8d455 100644
--- a/okhttp/src/main/java/okhttp3/Address.java
+++ b/okhttp/src/main/java/okhttp3/Address.java
@@ -18,14 +18,13 @@
 import java.net.Proxy;
 import java.net.ProxySelector;
 import java.util.List;
+import java.util.Objects;
 import javax.annotation.Nullable;
 import javax.net.SocketFactory;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLSocketFactory;
 import okhttp3.internal.Util;
 
-import static okhttp3.internal.Util.equal;
-
 /**
  * A specification for a connection to an origin server. For simple connections, this is the
  * server's hostname and port. If an explicit proxy is requested (or {@linkplain Proxy#NO_PROXY no
@@ -165,10 +164,10 @@ public ProxySelector proxySelector() {
     result = 31 * result + protocols.hashCode();
     result = 31 * result + connectionSpecs.hashCode();
     result = 31 * result + proxySelector.hashCode();
-    result = 31 * result + (proxy != null ? proxy.hashCode() : 0);
-    result = 31 * result + (sslSocketFactory != null ? sslSocketFactory.hashCode() : 0);
-    result = 31 * result + (hostnameVerifier != null ? hostnameVerifier.hashCode() : 0);
-    result = 31 * result + (certificatePinner != null ? certificatePinner.hashCode() : 0);
+    result = 31 * result + Objects.hashCode(proxy);
+    result = 31 * result + Objects.hashCode(sslSocketFactory);
+    result = 31 * result + Objects.hashCode(hostnameVerifier);
+    result = 31 * result + Objects.hashCode(certificatePinner);
     return result;
   }
 
@@ -178,10 +177,10 @@ boolean equalsNonHost(Address that) {
         && this.protocols.equals(that.protocols)
         && this.connectionSpecs.equals(that.connectionSpecs)
         && this.proxySelector.equals(that.proxySelector)
-        && equal(this.proxy, that.proxy)
-        && equal(this.sslSocketFactory, that.sslSocketFactory)
-        && equal(this.hostnameVerifier, that.hostnameVerifier)
-        && equal(this.certificatePinner, that.certificatePinner)
+        && Objects.equals(this.proxy, that.proxy)
+        && Objects.equals(this.sslSocketFactory, that.sslSocketFactory)
+        && Objects.equals(this.hostnameVerifier, that.hostnameVerifier)
+        && Objects.equals(this.certificatePinner, that.certificatePinner)
         && this.url().port() == that.url().port();
   }
 
diff --git a/okhttp/src/main/java/okhttp3/Authenticator.java b/okhttp/src/main/java/okhttp3/Authenticator.java
index 9e34bc9706..6e1d1a4fd5 100644
--- a/okhttp/src/main/java/okhttp3/Authenticator.java
+++ b/okhttp/src/main/java/okhttp3/Authenticator.java
@@ -19,17 +19,50 @@
 import javax.annotation.Nullable;
 
 /**
- * Responds to an authentication challenge from either a remote web server or a proxy server.
- * Implementations may either attempt to satisfy the challenge by returning a request that includes
- * an authorization header, or they may refuse the challenge by returning null. In this case the
- * unauthenticated response will be returned to the caller that triggered it.
+ * Performs either <strong>preemptive</strong> authentication before connecting to a proxy server,
+ * or <strong>reactive</strong> authentication after receiving a challenge from either an origin web
+ * server or proxy server.
+ *
+ * <h3>Preemptive Authentication</h3>
+ *
+ * <p>To make HTTPS calls using an HTTP proxy server OkHttp must first negotiate a connection with
+ * the proxy. This proxy connection is called a "TLS Tunnel" and is specified by <a
+ * href="https://tools.ietf.org/html/rfc2817">RFC 2817</a>. The HTTP CONNECT request that creates
+ * this tunnel connection is special: it does not participate in any {@linkplain Interceptor
+ * interceptors} or {@linkplain EventListener event listeners}. It doesn't include the motivating
+ * request's HTTP headers or even its full URL; only the target server's hostname is sent to the
+ * proxy.
+ *
+ * <p>Prior to sending any CONNECT request OkHttp always calls the proxy authenticator so that it
+ * may prepare preemptive authentication. OkHttp will call {@link #authenticate} with a fake {@code
+ * HTTP/1.1 407 Proxy Authentication Required} response that has a {@code Proxy-Authenticate:
+ * OkHttp-Preemptive} challenge. The proxy authenticator may return either either an authenticated
+ * request, or null to connect without authentication.
+ * <pre>   {@code
+ *    for (Challenge challenge : response.challenges()) {
+ *      // If this is preemptive auth, use a preemptive credential.
+ *      if (challenge.scheme().equalsIgnoreCase("OkHttp-Preemptive")) {
+ *        return response.request().newBuilder()
+ *            .header("Proxy-Authorization", "secret")
+ *            .build();
+ *      }
+ *    }
+ *
+ *    return null; // Didn't find a preemptive auth scheme.
+ * }</pre>
+ *
+ * <h3>Reactive Authentication</h3>
+ *
+ * <p>Implementations authenticate by returning a follow-up request that includes an authorization
+ * header, or they may decline the challenge by returning null. In this case the unauthenticated
+ * response will be returned to the caller that triggered it.
  *
  * <p>Implementations should check if the initial request already included an attempt to
  * authenticate. If so it is likely that further attempts will not be useful and the authenticator
  * should give up.
  *
- * <p>When authentication is requested by an origin server, the response code is 401 and the
- * implementation should respond with a new request that sets the "Authorization" header.
+ * <p>When reactive authentication is requested by an origin web server, the response code is 401
+ * and the implementation should respond with a new request that sets the "Authorization" header.
  * <pre>   {@code
  *
  *    if (response.request().header("Authorization") != null) {
@@ -42,7 +75,7 @@
  *        .build();
  * }</pre>
  *
- * <p>When authentication is requested by a proxy server, the response code is 407 and the
+ * <p>When reactive authentication is requested by a proxy server, the response code is 407 and the
  * implementation should respond with a new request that sets the "Proxy-Authorization" header.
  * <pre>   {@code
  *
@@ -56,20 +89,23 @@
  *        .build();
  * }</pre>
  *
+ * <p>The proxy authenticator may implement preemptive authentication, reactive authentication, or
+ * both.
+ *
  * <p>Applications may configure OkHttp with an authenticator for origin servers, or proxy servers,
  * or both.
  */
 public interface Authenticator {
   /** An authenticator that knows no credentials and makes no attempt to authenticate. */
-  Authenticator NONE = new Authenticator() {
-    @Override public Request authenticate(Route route, Response response) {
-      return null;
-    }
-  };
+  Authenticator NONE = (route, response) -> null;
 
   /**
    * Returns a request that includes a credential to satisfy an authentication challenge in {@code
    * response}. Returns null if the challenge cannot be satisfied.
+   *
+   * <p>The route is best effort, it currently may not always be provided even when logically
+   * available. It may also not be provided when an authenticator is re-used manually in an
+   * application interceptor, such as when implementing client-specific retries.
    */
-  @Nullable Request authenticate(Route route, Response response) throws IOException;
+  @Nullable Request authenticate(@Nullable Route route, Response response) throws IOException;
 }
diff --git a/okhttp/src/main/java/okhttp3/Cache.java b/okhttp/src/main/java/okhttp3/Cache.java
index d43d91d257..2ba97ffd0f 100644
--- a/okhttp/src/main/java/okhttp3/Cache.java
+++ b/okhttp/src/main/java/okhttp3/Cache.java
@@ -141,11 +141,11 @@
   private static final int ENTRY_COUNT = 2;
 
   final InternalCache internalCache = new InternalCache() {
-    @Override public Response get(Request request) throws IOException {
+    @Override public @Nullable Response get(Request request) throws IOException {
       return Cache.this.get(request);
     }
 
-    @Override public CacheRequest put(Response response) throws IOException {
+    @Override public @Nullable CacheRequest put(Response response) throws IOException {
       return Cache.this.put(response);
     }
 
@@ -175,6 +175,9 @@
   private int hitCount;
   private int requestCount;
 
+  /**
+   * Create a cache of at most {@code maxSize} bytes in {@code directory}.
+   */
   public Cache(File directory, long maxSize) {
     this(directory, maxSize, FileSystem.SYSTEM);
   }
@@ -336,16 +339,13 @@ public void evictAll() throws IOException {
 
         canRemove = false; // Prevent delegate.remove() on the wrong item!
         while (delegate.hasNext()) {
-          DiskLruCache.Snapshot snapshot = delegate.next();
-          try {
+          try (DiskLruCache.Snapshot snapshot = delegate.next()) {
             BufferedSource metadata = Okio.buffer(snapshot.getSource(ENTRY_METADATA));
             nextUrl = metadata.readUtf8LineStrict();
             return true;
           } catch (IOException ignored) {
             // We couldn't read the metadata for this snapshot; possibly because the host filesystem
             // has disappeared! Skip it.
-          } finally {
-            snapshot.close();
           }
         }
 
@@ -379,6 +379,7 @@ public long size() throws IOException {
     return cache.size();
   }
 
+  /** Max size of the cache (in bytes). */
   public long maxSize() {
     return cache.getMaxSize();
   }
diff --git a/okhttp/src/main/java/okhttp3/Call.java b/okhttp/src/main/java/okhttp3/Call.java
index cb9ac837f7..67d0f88d3d 100644
--- a/okhttp/src/main/java/okhttp3/Call.java
+++ b/okhttp/src/main/java/okhttp3/Call.java
@@ -16,6 +16,7 @@
 package okhttp3;
 
 import java.io.IOException;
+import okio.Timeout;
 
 /**
  * A call is a request that has been prepared for execution. A call can be canceled. As this object
@@ -80,6 +81,15 @@
 
   boolean isCanceled();
 
+  /**
+   * Returns a timeout that spans the entire call: resolving DNS, connecting, writing the request
+   * body, server processing, and reading the response body. If the call requires redirects or
+   * retries all must complete within one timeout period.
+   *
+   * <p>Configure the client's default timeout with {@link OkHttpClient.Builder#callTimeout}.
+   */
+  Timeout timeout();
+
   /**
    * Create a new, identical call to this one which can be enqueued or executed even if this call
    * has already been.
diff --git a/okhttp/src/main/java/okhttp3/CertificatePinner.java b/okhttp/src/main/java/okhttp3/CertificatePinner.java
index d509364544..474c245ae6 100644
--- a/okhttp/src/main/java/okhttp3/CertificatePinner.java
+++ b/okhttp/src/main/java/okhttp3/CertificatePinner.java
@@ -22,14 +22,13 @@
 import java.util.Collections;
 import java.util.LinkedHashSet;
 import java.util.List;
+import java.util.Objects;
 import java.util.Set;
 import javax.annotation.Nullable;
 import javax.net.ssl.SSLPeerUnverifiedException;
 import okhttp3.internal.tls.CertificateChainCleaner;
 import okio.ByteString;
 
-import static okhttp3.internal.Util.equal;
-
 /**
  * Constrains which certificates are trusted. Pinning certificates defends against attacks on
  * certificate authorities. It also prevents connections through man-in-the-middle certificate
@@ -139,12 +138,13 @@
   @Override public boolean equals(@Nullable Object other) {
     if (other == this) return true;
     return other instanceof CertificatePinner
-        && (equal(certificateChainCleaner, ((CertificatePinner) other).certificateChainCleaner)
+        && (Objects.equals(certificateChainCleaner,
+        ((CertificatePinner) other).certificateChainCleaner)
         && pins.equals(((CertificatePinner) other).pins));
   }
 
   @Override public int hashCode() {
-    int result = certificateChainCleaner != null ? certificateChainCleaner.hashCode() : 0;
+    int result = Objects.hashCode(certificateChainCleaner);
     result = 31 * result + pins.hashCode();
     return result;
   }
@@ -228,7 +228,7 @@ public void check(String hostname, Certificate... peerCertificates)
   /** Returns a certificate pinner that uses {@code certificateChainCleaner}. */
   CertificatePinner withCertificateChainCleaner(
       @Nullable CertificateChainCleaner certificateChainCleaner) {
-    return equal(this.certificateChainCleaner, certificateChainCleaner)
+    return Objects.equals(this.certificateChainCleaner, certificateChainCleaner)
         ? this
         : new CertificatePinner(pins, certificateChainCleaner);
   }
diff --git a/okhttp/src/main/java/okhttp3/Challenge.java b/okhttp/src/main/java/okhttp3/Challenge.java
index 4b000eceda..0fb4c868a6 100644
--- a/okhttp/src/main/java/okhttp3/Challenge.java
+++ b/okhttp/src/main/java/okhttp3/Challenge.java
@@ -16,32 +16,46 @@
 package okhttp3;
 
 import java.nio.charset.Charset;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import java.util.Map.Entry;
 import javax.annotation.Nullable;
 
-import static okhttp3.internal.Util.ISO_8859_1;
+import static java.nio.charset.StandardCharsets.ISO_8859_1;
+import static java.util.Collections.singletonMap;
+import static java.util.Collections.unmodifiableMap;
+import static java.util.Locale.US;
 
-/** An RFC 7617 challenge. */
+/** An RFC 7235 challenge. */
 public final class Challenge {
   private final String scheme;
-  private final String realm;
-  private final Charset charset;
+  private final Map<String, String> authParams;
 
-  public Challenge(String scheme, String realm) {
-    this(scheme, realm, ISO_8859_1);
+  public Challenge(String scheme, Map<String, String> authParams) {
+    if (scheme == null) throw new NullPointerException("scheme == null");
+    if (authParams == null) throw new NullPointerException("authParams == null");
+    this.scheme = scheme;
+    Map<String, String> newAuthParams = new LinkedHashMap<>();
+    for (Entry<String, String> authParam : authParams.entrySet()) {
+      String key = (authParam.getKey() == null) ? null : authParam.getKey().toLowerCase(US);
+      newAuthParams.put(key, authParam.getValue());
+    }
+    this.authParams = unmodifiableMap(newAuthParams);
   }
 
-  private Challenge(String scheme, String realm, Charset charset) {
+  public Challenge(String scheme, String realm) {
     if (scheme == null) throw new NullPointerException("scheme == null");
     if (realm == null) throw new NullPointerException("realm == null");
-    if (charset == null) throw new NullPointerException("charset == null");
     this.scheme = scheme;
-    this.realm = realm;
-    this.charset = charset;
+    this.authParams = singletonMap("realm", realm);
   }
 
   /** Returns a copy of this charset that expects a credential encoded with {@code charset}. */
   public Challenge withCharset(Charset charset) {
-    return new Challenge(scheme, realm, charset);
+    if (charset == null) throw new NullPointerException("charset == null");
+    Map<String, String> authParams = new LinkedHashMap<>(this.authParams);
+    authParams.put("charset", charset.name());
+    return new Challenge(scheme, authParams);
   }
 
   /** Returns the authentication scheme, like {@code Basic}. */
@@ -49,34 +63,45 @@ public String scheme() {
     return scheme;
   }
 
+  /**
+   * Returns the auth params, including {@code realm} and {@code charset} if present, but as
+   * strings. The map's keys are lowercase and should be treated case-insensitively.
+   */
+  public Map<String, String> authParams() {
+    return authParams;
+  }
+
   /** Returns the protection space. */
   public String realm() {
-    return realm;
+    return authParams.get("realm");
   }
 
-  /** Returns the charset that should be used to encode the credential. */
+  /** Returns the charset that should be used to encode the credentials. */
   public Charset charset() {
-    return charset;
+    String charset = authParams.get("charset");
+    if (charset != null) {
+      try {
+        return Charset.forName(charset);
+      } catch (Exception ignore) {
+      }
+    }
+    return ISO_8859_1;
   }
 
   @Override public boolean equals(@Nullable Object other) {
     return other instanceof Challenge
         && ((Challenge) other).scheme.equals(scheme)
-        && ((Challenge) other).realm.equals(realm)
-        && ((Challenge) other).charset.equals(charset);
+        && ((Challenge) other).authParams.equals(authParams);
   }
 
   @Override public int hashCode() {
     int result = 29;
-    result = 31 * result + realm.hashCode();
     result = 31 * result + scheme.hashCode();
-    result = 31 * result + charset.hashCode();
+    result = 31 * result + authParams.hashCode();
     return result;
   }
 
   @Override public String toString() {
-    return scheme
-        + " realm=\"" + realm + "\""
-        + " charset=\"" + charset + "\"";
+    return scheme + " authParams=" + authParams;
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/CipherSuite.java b/okhttp/src/main/java/okhttp3/CipherSuite.java
index 80a41afbbb..376e1fe0fa 100644
--- a/okhttp/src/main/java/okhttp3/CipherSuite.java
+++ b/okhttp/src/main/java/okhttp3/CipherSuite.java
@@ -18,9 +18,9 @@
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Comparator;
+import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
-import java.util.TreeMap;
 
 /**
  * <a href="https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml">TLS cipher
@@ -46,362 +46,359 @@
    * the "TLS_" or "SSL_" prefix which is not consistent across platforms. In particular some IBM
    * JVMs use the "SSL_" prefix everywhere whereas Oracle JVMs mix "TLS_" and "SSL_".
    */
-  static final Comparator<String> ORDER_BY_NAME = new Comparator<String>() {
-    @Override public int compare(String a, String b) {
-      for (int i = 4, limit = Math.min(a.length(), b.length()); i < limit; i++) {
-        char charA = a.charAt(i);
-        char charB = b.charAt(i);
-        if (charA != charB) return charA < charB ? -1 : 1;
-      }
-      int lengthA = a.length();
-      int lengthB = b.length();
-      if (lengthA != lengthB) return lengthA < lengthB ? -1 : 1;
-      return 0;
+  static final Comparator<String> ORDER_BY_NAME = (a, b) -> {
+    for (int i = 4, limit = Math.min(a.length(), b.length()); i < limit; i++) {
+      char charA = a.charAt(i);
+      char charB = b.charAt(i);
+      if (charA != charB) return charA < charB ? -1 : 1;
     }
+    int lengthA = a.length();
+    int lengthB = b.length();
+    if (lengthA != lengthB) return lengthA < lengthB ? -1 : 1;
+    return 0;
   };
 
   /**
-   * Holds interned instances. This needs to be above the of() calls below so that it's
+   * Holds interned instances. This needs to be above the init() calls below so that it's
    * initialized by the time those parts of {@code <clinit>()} run. Guarded by CipherSuite.class.
    */
-  private static final Map<String, CipherSuite> INSTANCES = new TreeMap<>(ORDER_BY_NAME);
+  private static final Map<String, CipherSuite> INSTANCES = new LinkedHashMap<>();
 
   // Last updated 2016-07-03 using cipher suites from Android 24 and Java 9.
 
-  // public static final CipherSuite TLS_NULL_WITH_NULL_NULL = of("TLS_NULL_WITH_NULL_NULL", 0x0000);
-  public static final CipherSuite TLS_RSA_WITH_NULL_MD5 = of("SSL_RSA_WITH_NULL_MD5", 0x0001);
-  public static final CipherSuite TLS_RSA_WITH_NULL_SHA = of("SSL_RSA_WITH_NULL_SHA", 0x0002);
-  public static final CipherSuite TLS_RSA_EXPORT_WITH_RC4_40_MD5 = of("SSL_RSA_EXPORT_WITH_RC4_40_MD5", 0x0003);
-  public static final CipherSuite TLS_RSA_WITH_RC4_128_MD5 = of("SSL_RSA_WITH_RC4_128_MD5", 0x0004);
-  public static final CipherSuite TLS_RSA_WITH_RC4_128_SHA = of("SSL_RSA_WITH_RC4_128_SHA", 0x0005);
-  // public static final CipherSuite TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5 = of("SSL_RSA_EXPORT_WITH_RC2_CBC_40_MD5", 0x0006);
-  // public static final CipherSuite TLS_RSA_WITH_IDEA_CBC_SHA = of("TLS_RSA_WITH_IDEA_CBC_SHA", 0x0007);
-  public static final CipherSuite TLS_RSA_EXPORT_WITH_DES40_CBC_SHA = of("SSL_RSA_EXPORT_WITH_DES40_CBC_SHA", 0x0008);
-  public static final CipherSuite TLS_RSA_WITH_DES_CBC_SHA = of("SSL_RSA_WITH_DES_CBC_SHA", 0x0009);
-  public static final CipherSuite TLS_RSA_WITH_3DES_EDE_CBC_SHA = of("SSL_RSA_WITH_3DES_EDE_CBC_SHA", 0x000a);
-  // public static final CipherSuite TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA = of("SSL_DH_DSS_EXPORT_WITH_DES40_CBC_SHA", 0x000b);
-  // public static final CipherSuite TLS_DH_DSS_WITH_DES_CBC_SHA = of("TLS_DH_DSS_WITH_DES_CBC_SHA", 0x000c);
-  // public static final CipherSuite TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA = of("TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA", 0x000d);
-  // public static final CipherSuite TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA = of("SSL_DH_RSA_EXPORT_WITH_DES40_CBC_SHA", 0x000e);
-  // public static final CipherSuite TLS_DH_RSA_WITH_DES_CBC_SHA = of("TLS_DH_RSA_WITH_DES_CBC_SHA", 0x000f);
-  // public static final CipherSuite TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA = of("TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA", 0x0010);
-  public static final CipherSuite TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA = of("SSL_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA", 0x0011);
-  public static final CipherSuite TLS_DHE_DSS_WITH_DES_CBC_SHA = of("SSL_DHE_DSS_WITH_DES_CBC_SHA", 0x0012);
-  public static final CipherSuite TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA = of("SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA", 0x0013);
-  public static final CipherSuite TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA = of("SSL_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA", 0x0014);
-  public static final CipherSuite TLS_DHE_RSA_WITH_DES_CBC_SHA = of("SSL_DHE_RSA_WITH_DES_CBC_SHA", 0x0015);
-  public static final CipherSuite TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA = of("SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA", 0x0016);
-  public static final CipherSuite TLS_DH_anon_EXPORT_WITH_RC4_40_MD5 = of("SSL_DH_anon_EXPORT_WITH_RC4_40_MD5", 0x0017);
-  public static final CipherSuite TLS_DH_anon_WITH_RC4_128_MD5 = of("SSL_DH_anon_WITH_RC4_128_MD5", 0x0018);
-  public static final CipherSuite TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA = of("SSL_DH_anon_EXPORT_WITH_DES40_CBC_SHA", 0x0019);
-  public static final CipherSuite TLS_DH_anon_WITH_DES_CBC_SHA = of("SSL_DH_anon_WITH_DES_CBC_SHA", 0x001a);
-  public static final CipherSuite TLS_DH_anon_WITH_3DES_EDE_CBC_SHA = of("SSL_DH_anon_WITH_3DES_EDE_CBC_SHA", 0x001b);
-  public static final CipherSuite TLS_KRB5_WITH_DES_CBC_SHA = of("TLS_KRB5_WITH_DES_CBC_SHA", 0x001e);
-  public static final CipherSuite TLS_KRB5_WITH_3DES_EDE_CBC_SHA = of("TLS_KRB5_WITH_3DES_EDE_CBC_SHA", 0x001f);
-  public static final CipherSuite TLS_KRB5_WITH_RC4_128_SHA = of("TLS_KRB5_WITH_RC4_128_SHA", 0x0020);
-  // public static final CipherSuite TLS_KRB5_WITH_IDEA_CBC_SHA = of("TLS_KRB5_WITH_IDEA_CBC_SHA", 0x0021);
-  public static final CipherSuite TLS_KRB5_WITH_DES_CBC_MD5 = of("TLS_KRB5_WITH_DES_CBC_MD5", 0x0022);
-  public static final CipherSuite TLS_KRB5_WITH_3DES_EDE_CBC_MD5 = of("TLS_KRB5_WITH_3DES_EDE_CBC_MD5", 0x0023);
-  public static final CipherSuite TLS_KRB5_WITH_RC4_128_MD5 = of("TLS_KRB5_WITH_RC4_128_MD5", 0x0024);
-  // public static final CipherSuite TLS_KRB5_WITH_IDEA_CBC_MD5 = of("TLS_KRB5_WITH_IDEA_CBC_MD5", 0x0025);
-  public static final CipherSuite TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA = of("TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA", 0x0026);
-  // public static final CipherSuite TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA = of("TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA", 0x0027);
-  public static final CipherSuite TLS_KRB5_EXPORT_WITH_RC4_40_SHA = of("TLS_KRB5_EXPORT_WITH_RC4_40_SHA", 0x0028);
-  public static final CipherSuite TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5 = of("TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5", 0x0029);
-  // public static final CipherSuite TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5 = of("TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5", 0x002a);
-  public static final CipherSuite TLS_KRB5_EXPORT_WITH_RC4_40_MD5 = of("TLS_KRB5_EXPORT_WITH_RC4_40_MD5", 0x002b);
-  // public static final CipherSuite TLS_PSK_WITH_NULL_SHA = of("TLS_PSK_WITH_NULL_SHA", 0x002c);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_NULL_SHA = of("TLS_DHE_PSK_WITH_NULL_SHA", 0x002d);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_NULL_SHA = of("TLS_RSA_PSK_WITH_NULL_SHA", 0x002e);
-  public static final CipherSuite TLS_RSA_WITH_AES_128_CBC_SHA = of("TLS_RSA_WITH_AES_128_CBC_SHA", 0x002f);
-  // public static final CipherSuite TLS_DH_DSS_WITH_AES_128_CBC_SHA = of("TLS_DH_DSS_WITH_AES_128_CBC_SHA", 0x0030);
-  // public static final CipherSuite TLS_DH_RSA_WITH_AES_128_CBC_SHA = of("TLS_DH_RSA_WITH_AES_128_CBC_SHA", 0x0031);
-  public static final CipherSuite TLS_DHE_DSS_WITH_AES_128_CBC_SHA = of("TLS_DHE_DSS_WITH_AES_128_CBC_SHA", 0x0032);
-  public static final CipherSuite TLS_DHE_RSA_WITH_AES_128_CBC_SHA = of("TLS_DHE_RSA_WITH_AES_128_CBC_SHA", 0x0033);
-  public static final CipherSuite TLS_DH_anon_WITH_AES_128_CBC_SHA = of("TLS_DH_anon_WITH_AES_128_CBC_SHA", 0x0034);
-  public static final CipherSuite TLS_RSA_WITH_AES_256_CBC_SHA = of("TLS_RSA_WITH_AES_256_CBC_SHA", 0x0035);
-  // public static final CipherSuite TLS_DH_DSS_WITH_AES_256_CBC_SHA = of("TLS_DH_DSS_WITH_AES_256_CBC_SHA", 0x0036);
-  // public static final CipherSuite TLS_DH_RSA_WITH_AES_256_CBC_SHA = of("TLS_DH_RSA_WITH_AES_256_CBC_SHA", 0x0037);
-  public static final CipherSuite TLS_DHE_DSS_WITH_AES_256_CBC_SHA = of("TLS_DHE_DSS_WITH_AES_256_CBC_SHA", 0x0038);
-  public static final CipherSuite TLS_DHE_RSA_WITH_AES_256_CBC_SHA = of("TLS_DHE_RSA_WITH_AES_256_CBC_SHA", 0x0039);
-  public static final CipherSuite TLS_DH_anon_WITH_AES_256_CBC_SHA = of("TLS_DH_anon_WITH_AES_256_CBC_SHA", 0x003a);
-  public static final CipherSuite TLS_RSA_WITH_NULL_SHA256 = of("TLS_RSA_WITH_NULL_SHA256", 0x003b);
-  public static final CipherSuite TLS_RSA_WITH_AES_128_CBC_SHA256 = of("TLS_RSA_WITH_AES_128_CBC_SHA256", 0x003c);
-  public static final CipherSuite TLS_RSA_WITH_AES_256_CBC_SHA256 = of("TLS_RSA_WITH_AES_256_CBC_SHA256", 0x003d);
-  // public static final CipherSuite TLS_DH_DSS_WITH_AES_128_CBC_SHA256 = of("TLS_DH_DSS_WITH_AES_128_CBC_SHA256", 0x003e);
-  // public static final CipherSuite TLS_DH_RSA_WITH_AES_128_CBC_SHA256 = of("TLS_DH_RSA_WITH_AES_128_CBC_SHA256", 0x003f);
-  public static final CipherSuite TLS_DHE_DSS_WITH_AES_128_CBC_SHA256 = of("TLS_DHE_DSS_WITH_AES_128_CBC_SHA256", 0x0040);
-  public static final CipherSuite TLS_RSA_WITH_CAMELLIA_128_CBC_SHA = of("TLS_RSA_WITH_CAMELLIA_128_CBC_SHA", 0x0041);
-  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA = of("TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA", 0x0042);
-  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA = of("TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA", 0x0043);
-  public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA = of("TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA", 0x0044);
-  public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA = of("TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA", 0x0045);
-  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA = of("TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA", 0x0046);
-  public static final CipherSuite TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 = of("TLS_DHE_RSA_WITH_AES_128_CBC_SHA256", 0x0067);
-  // public static final CipherSuite TLS_DH_DSS_WITH_AES_256_CBC_SHA256 = of("TLS_DH_DSS_WITH_AES_256_CBC_SHA256", 0x0068);
-  // public static final CipherSuite TLS_DH_RSA_WITH_AES_256_CBC_SHA256 = of("TLS_DH_RSA_WITH_AES_256_CBC_SHA256", 0x0069);
-  public static final CipherSuite TLS_DHE_DSS_WITH_AES_256_CBC_SHA256 = of("TLS_DHE_DSS_WITH_AES_256_CBC_SHA256", 0x006a);
-  public static final CipherSuite TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 = of("TLS_DHE_RSA_WITH_AES_256_CBC_SHA256", 0x006b);
-  public static final CipherSuite TLS_DH_anon_WITH_AES_128_CBC_SHA256 = of("TLS_DH_anon_WITH_AES_128_CBC_SHA256", 0x006c);
-  public static final CipherSuite TLS_DH_anon_WITH_AES_256_CBC_SHA256 = of("TLS_DH_anon_WITH_AES_256_CBC_SHA256", 0x006d);
-  public static final CipherSuite TLS_RSA_WITH_CAMELLIA_256_CBC_SHA = of("TLS_RSA_WITH_CAMELLIA_256_CBC_SHA", 0x0084);
-  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA = of("TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA", 0x0085);
-  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA = of("TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA", 0x0086);
-  public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA = of("TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA", 0x0087);
-  public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA = of("TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA", 0x0088);
-  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA = of("TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA", 0x0089);
-  public static final CipherSuite TLS_PSK_WITH_RC4_128_SHA = of("TLS_PSK_WITH_RC4_128_SHA", 0x008a);
-  public static final CipherSuite TLS_PSK_WITH_3DES_EDE_CBC_SHA = of("TLS_PSK_WITH_3DES_EDE_CBC_SHA", 0x008b);
-  public static final CipherSuite TLS_PSK_WITH_AES_128_CBC_SHA = of("TLS_PSK_WITH_AES_128_CBC_SHA", 0x008c);
-  public static final CipherSuite TLS_PSK_WITH_AES_256_CBC_SHA = of("TLS_PSK_WITH_AES_256_CBC_SHA", 0x008d);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_RC4_128_SHA = of("TLS_DHE_PSK_WITH_RC4_128_SHA", 0x008e);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA = of("TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA", 0x008f);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_128_CBC_SHA = of("TLS_DHE_PSK_WITH_AES_128_CBC_SHA", 0x0090);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_256_CBC_SHA = of("TLS_DHE_PSK_WITH_AES_256_CBC_SHA", 0x0091);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_RC4_128_SHA = of("TLS_RSA_PSK_WITH_RC4_128_SHA", 0x0092);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA = of("TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA", 0x0093);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_128_CBC_SHA = of("TLS_RSA_PSK_WITH_AES_128_CBC_SHA", 0x0094);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_256_CBC_SHA = of("TLS_RSA_PSK_WITH_AES_256_CBC_SHA", 0x0095);
-  public static final CipherSuite TLS_RSA_WITH_SEED_CBC_SHA = of("TLS_RSA_WITH_SEED_CBC_SHA", 0x0096);
-  // public static final CipherSuite TLS_DH_DSS_WITH_SEED_CBC_SHA = of("TLS_DH_DSS_WITH_SEED_CBC_SHA", 0x0097);
-  // public static final CipherSuite TLS_DH_RSA_WITH_SEED_CBC_SHA = of("TLS_DH_RSA_WITH_SEED_CBC_SHA", 0x0098);
-  // public static final CipherSuite TLS_DHE_DSS_WITH_SEED_CBC_SHA = of("TLS_DHE_DSS_WITH_SEED_CBC_SHA", 0x0099);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_SEED_CBC_SHA = of("TLS_DHE_RSA_WITH_SEED_CBC_SHA", 0x009a);
-  // public static final CipherSuite TLS_DH_anon_WITH_SEED_CBC_SHA = of("TLS_DH_anon_WITH_SEED_CBC_SHA", 0x009b);
-  public static final CipherSuite TLS_RSA_WITH_AES_128_GCM_SHA256 = of("TLS_RSA_WITH_AES_128_GCM_SHA256", 0x009c);
-  public static final CipherSuite TLS_RSA_WITH_AES_256_GCM_SHA384 = of("TLS_RSA_WITH_AES_256_GCM_SHA384", 0x009d);
-  public static final CipherSuite TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 = of("TLS_DHE_RSA_WITH_AES_128_GCM_SHA256", 0x009e);
-  public static final CipherSuite TLS_DHE_RSA_WITH_AES_256_GCM_SHA384 = of("TLS_DHE_RSA_WITH_AES_256_GCM_SHA384", 0x009f);
-  // public static final CipherSuite TLS_DH_RSA_WITH_AES_128_GCM_SHA256 = of("TLS_DH_RSA_WITH_AES_128_GCM_SHA256", 0x00a0);
-  // public static final CipherSuite TLS_DH_RSA_WITH_AES_256_GCM_SHA384 = of("TLS_DH_RSA_WITH_AES_256_GCM_SHA384", 0x00a1);
-  public static final CipherSuite TLS_DHE_DSS_WITH_AES_128_GCM_SHA256 = of("TLS_DHE_DSS_WITH_AES_128_GCM_SHA256", 0x00a2);
-  public static final CipherSuite TLS_DHE_DSS_WITH_AES_256_GCM_SHA384 = of("TLS_DHE_DSS_WITH_AES_256_GCM_SHA384", 0x00a3);
-  // public static final CipherSuite TLS_DH_DSS_WITH_AES_128_GCM_SHA256 = of("TLS_DH_DSS_WITH_AES_128_GCM_SHA256", 0x00a4);
-  // public static final CipherSuite TLS_DH_DSS_WITH_AES_256_GCM_SHA384 = of("TLS_DH_DSS_WITH_AES_256_GCM_SHA384", 0x00a5);
-  public static final CipherSuite TLS_DH_anon_WITH_AES_128_GCM_SHA256 = of("TLS_DH_anon_WITH_AES_128_GCM_SHA256", 0x00a6);
-  public static final CipherSuite TLS_DH_anon_WITH_AES_256_GCM_SHA384 = of("TLS_DH_anon_WITH_AES_256_GCM_SHA384", 0x00a7);
-  // public static final CipherSuite TLS_PSK_WITH_AES_128_GCM_SHA256 = of("TLS_PSK_WITH_AES_128_GCM_SHA256", 0x00a8);
-  // public static final CipherSuite TLS_PSK_WITH_AES_256_GCM_SHA384 = of("TLS_PSK_WITH_AES_256_GCM_SHA384", 0x00a9);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_128_GCM_SHA256 = of("TLS_DHE_PSK_WITH_AES_128_GCM_SHA256", 0x00aa);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_256_GCM_SHA384 = of("TLS_DHE_PSK_WITH_AES_256_GCM_SHA384", 0x00ab);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_128_GCM_SHA256 = of("TLS_RSA_PSK_WITH_AES_128_GCM_SHA256", 0x00ac);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_256_GCM_SHA384 = of("TLS_RSA_PSK_WITH_AES_256_GCM_SHA384", 0x00ad);
-  // public static final CipherSuite TLS_PSK_WITH_AES_128_CBC_SHA256 = of("TLS_PSK_WITH_AES_128_CBC_SHA256", 0x00ae);
-  // public static final CipherSuite TLS_PSK_WITH_AES_256_CBC_SHA384 = of("TLS_PSK_WITH_AES_256_CBC_SHA384", 0x00af);
-  // public static final CipherSuite TLS_PSK_WITH_NULL_SHA256 = of("TLS_PSK_WITH_NULL_SHA256", 0x00b0);
-  // public static final CipherSuite TLS_PSK_WITH_NULL_SHA384 = of("TLS_PSK_WITH_NULL_SHA384", 0x00b1);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_128_CBC_SHA256 = of("TLS_DHE_PSK_WITH_AES_128_CBC_SHA256", 0x00b2);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_256_CBC_SHA384 = of("TLS_DHE_PSK_WITH_AES_256_CBC_SHA384", 0x00b3);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_NULL_SHA256 = of("TLS_DHE_PSK_WITH_NULL_SHA256", 0x00b4);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_NULL_SHA384 = of("TLS_DHE_PSK_WITH_NULL_SHA384", 0x00b5);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_128_CBC_SHA256 = of("TLS_RSA_PSK_WITH_AES_128_CBC_SHA256", 0x00b6);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_256_CBC_SHA384 = of("TLS_RSA_PSK_WITH_AES_256_CBC_SHA384", 0x00b7);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_NULL_SHA256 = of("TLS_RSA_PSK_WITH_NULL_SHA256", 0x00b8);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_NULL_SHA384 = of("TLS_RSA_PSK_WITH_NULL_SHA384", 0x00b9);
-  // public static final CipherSuite TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0x00ba);
-  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256", 0x00bb);
-  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0x00bc);
-  // public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256", 0x00bd);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0x00be);
-  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256", 0x00bf);
-  // public static final CipherSuite TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256 = of("TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256", 0x00c0);
-  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256 = of("TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256", 0x00c1);
-  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256 = of("TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256", 0x00c2);
-  // public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256 = of("TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256", 0x00c3);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256 = of("TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256", 0x00c4);
-  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256 = of("TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256", 0x00c5);
-  public static final CipherSuite TLS_EMPTY_RENEGOTIATION_INFO_SCSV = of("TLS_EMPTY_RENEGOTIATION_INFO_SCSV", 0x00ff);
-  public static final CipherSuite TLS_FALLBACK_SCSV = of("TLS_FALLBACK_SCSV", 0x5600);
-  public static final CipherSuite TLS_ECDH_ECDSA_WITH_NULL_SHA = of("TLS_ECDH_ECDSA_WITH_NULL_SHA", 0xc001);
-  public static final CipherSuite TLS_ECDH_ECDSA_WITH_RC4_128_SHA = of("TLS_ECDH_ECDSA_WITH_RC4_128_SHA", 0xc002);
-  public static final CipherSuite TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA = of("TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA", 0xc003);
-  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA = of("TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA", 0xc004);
-  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA = of("TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA", 0xc005);
-  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_NULL_SHA = of("TLS_ECDHE_ECDSA_WITH_NULL_SHA", 0xc006);
-  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_RC4_128_SHA = of("TLS_ECDHE_ECDSA_WITH_RC4_128_SHA", 0xc007);
-  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA = of("TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA", 0xc008);
-  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA = of("TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA", 0xc009);
-  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA = of("TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA", 0xc00a);
-  public static final CipherSuite TLS_ECDH_RSA_WITH_NULL_SHA = of("TLS_ECDH_RSA_WITH_NULL_SHA", 0xc00b);
-  public static final CipherSuite TLS_ECDH_RSA_WITH_RC4_128_SHA = of("TLS_ECDH_RSA_WITH_RC4_128_SHA", 0xc00c);
-  public static final CipherSuite TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA = of("TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA", 0xc00d);
-  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_128_CBC_SHA = of("TLS_ECDH_RSA_WITH_AES_128_CBC_SHA", 0xc00e);
-  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_256_CBC_SHA = of("TLS_ECDH_RSA_WITH_AES_256_CBC_SHA", 0xc00f);
-  public static final CipherSuite TLS_ECDHE_RSA_WITH_NULL_SHA = of("TLS_ECDHE_RSA_WITH_NULL_SHA", 0xc010);
-  public static final CipherSuite TLS_ECDHE_RSA_WITH_RC4_128_SHA = of("TLS_ECDHE_RSA_WITH_RC4_128_SHA", 0xc011);
-  public static final CipherSuite TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA = of("TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA", 0xc012);
-  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA = of("TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA", 0xc013);
-  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA = of("TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA", 0xc014);
-  public static final CipherSuite TLS_ECDH_anon_WITH_NULL_SHA = of("TLS_ECDH_anon_WITH_NULL_SHA", 0xc015);
-  public static final CipherSuite TLS_ECDH_anon_WITH_RC4_128_SHA = of("TLS_ECDH_anon_WITH_RC4_128_SHA", 0xc016);
-  public static final CipherSuite TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA = of("TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA", 0xc017);
-  public static final CipherSuite TLS_ECDH_anon_WITH_AES_128_CBC_SHA = of("TLS_ECDH_anon_WITH_AES_128_CBC_SHA", 0xc018);
-  public static final CipherSuite TLS_ECDH_anon_WITH_AES_256_CBC_SHA = of("TLS_ECDH_anon_WITH_AES_256_CBC_SHA", 0xc019);
-  // public static final CipherSuite TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA = of("TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA", 0xc01a);
-  // public static final CipherSuite TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA = of("TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA", 0xc01b);
-  // public static final CipherSuite TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA = of("TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA", 0xc01c);
-  // public static final CipherSuite TLS_SRP_SHA_WITH_AES_128_CBC_SHA = of("TLS_SRP_SHA_WITH_AES_128_CBC_SHA", 0xc01d);
-  // public static final CipherSuite TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA = of("TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA", 0xc01e);
-  // public static final CipherSuite TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA = of("TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA", 0xc01f);
-  // public static final CipherSuite TLS_SRP_SHA_WITH_AES_256_CBC_SHA = of("TLS_SRP_SHA_WITH_AES_256_CBC_SHA", 0xc020);
-  // public static final CipherSuite TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA = of("TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA", 0xc021);
-  // public static final CipherSuite TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA = of("TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA", 0xc022);
-  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 = of("TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256", 0xc023);
-  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 = of("TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384", 0xc024);
-  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256 = of("TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256", 0xc025);
-  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384 = of("TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384", 0xc026);
-  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 = of("TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256", 0xc027);
-  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 = of("TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384", 0xc028);
-  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256 = of("TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256", 0xc029);
-  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384 = of("TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384", 0xc02a);
-  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 = of("TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256", 0xc02b);
-  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 = of("TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384", 0xc02c);
-  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256 = of("TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256", 0xc02d);
-  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384 = of("TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384", 0xc02e);
-  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 = of("TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256", 0xc02f);
-  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 = of("TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384", 0xc030);
-  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256 = of("TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256", 0xc031);
-  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384 = of("TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384", 0xc032);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_RC4_128_SHA = of("TLS_ECDHE_PSK_WITH_RC4_128_SHA", 0xc033);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA = of("TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA", 0xc034);
-  public static final CipherSuite TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA = of("TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA", 0xc035);
-  public static final CipherSuite TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA = of("TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA", 0xc036);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256 = of("TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256", 0xc037);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384 = of("TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384", 0xc038);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_NULL_SHA = of("TLS_ECDHE_PSK_WITH_NULL_SHA", 0xc039);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_NULL_SHA256 = of("TLS_ECDHE_PSK_WITH_NULL_SHA256", 0xc03a);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_NULL_SHA384 = of("TLS_ECDHE_PSK_WITH_NULL_SHA384", 0xc03b);
-  // public static final CipherSuite TLS_RSA_WITH_ARIA_128_CBC_SHA256 = of("TLS_RSA_WITH_ARIA_128_CBC_SHA256", 0xc03c);
-  // public static final CipherSuite TLS_RSA_WITH_ARIA_256_CBC_SHA384 = of("TLS_RSA_WITH_ARIA_256_CBC_SHA384", 0xc03d);
-  // public static final CipherSuite TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256 = of("TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256", 0xc03e);
-  // public static final CipherSuite TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384 = of("TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384", 0xc03f);
-  // public static final CipherSuite TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256 = of("TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256", 0xc040);
-  // public static final CipherSuite TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384 = of("TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384", 0xc041);
-  // public static final CipherSuite TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256 = of("TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256", 0xc042);
-  // public static final CipherSuite TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384 = of("TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384", 0xc043);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256 = of("TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256", 0xc044);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384 = of("TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384", 0xc045);
-  // public static final CipherSuite TLS_DH_anon_WITH_ARIA_128_CBC_SHA256 = of("TLS_DH_anon_WITH_ARIA_128_CBC_SHA256", 0xc046);
-  // public static final CipherSuite TLS_DH_anon_WITH_ARIA_256_CBC_SHA384 = of("TLS_DH_anon_WITH_ARIA_256_CBC_SHA384", 0xc047);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256 = of("TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256", 0xc048);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384 = of("TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384", 0xc049);
-  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256 = of("TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256", 0xc04a);
-  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384 = of("TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384", 0xc04b);
-  // public static final CipherSuite TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256 = of("TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256", 0xc04c);
-  // public static final CipherSuite TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384 = of("TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384", 0xc04d);
-  // public static final CipherSuite TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256 = of("TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256", 0xc04e);
-  // public static final CipherSuite TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384 = of("TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384", 0xc04f);
-  // public static final CipherSuite TLS_RSA_WITH_ARIA_128_GCM_SHA256 = of("TLS_RSA_WITH_ARIA_128_GCM_SHA256", 0xc050);
-  // public static final CipherSuite TLS_RSA_WITH_ARIA_256_GCM_SHA384 = of("TLS_RSA_WITH_ARIA_256_GCM_SHA384", 0xc051);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256 = of("TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256", 0xc052);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384 = of("TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384", 0xc053);
-  // public static final CipherSuite TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256 = of("TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256", 0xc054);
-  // public static final CipherSuite TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384 = of("TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384", 0xc055);
-  // public static final CipherSuite TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256 = of("TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256", 0xc056);
-  // public static final CipherSuite TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384 = of("TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384", 0xc057);
-  // public static final CipherSuite TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256 = of("TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256", 0xc058);
-  // public static final CipherSuite TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384 = of("TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384", 0xc059);
-  // public static final CipherSuite TLS_DH_anon_WITH_ARIA_128_GCM_SHA256 = of("TLS_DH_anon_WITH_ARIA_128_GCM_SHA256", 0xc05a);
-  // public static final CipherSuite TLS_DH_anon_WITH_ARIA_256_GCM_SHA384 = of("TLS_DH_anon_WITH_ARIA_256_GCM_SHA384", 0xc05b);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256 = of("TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256", 0xc05c);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384 = of("TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384", 0xc05d);
-  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256 = of("TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256", 0xc05e);
-  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384 = of("TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384", 0xc05f);
-  // public static final CipherSuite TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256 = of("TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256", 0xc060);
-  // public static final CipherSuite TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384 = of("TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384", 0xc061);
-  // public static final CipherSuite TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256 = of("TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256", 0xc062);
-  // public static final CipherSuite TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384 = of("TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384", 0xc063);
-  // public static final CipherSuite TLS_PSK_WITH_ARIA_128_CBC_SHA256 = of("TLS_PSK_WITH_ARIA_128_CBC_SHA256", 0xc064);
-  // public static final CipherSuite TLS_PSK_WITH_ARIA_256_CBC_SHA384 = of("TLS_PSK_WITH_ARIA_256_CBC_SHA384", 0xc065);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256 = of("TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256", 0xc066);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384 = of("TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384", 0xc067);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256 = of("TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256", 0xc068);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384 = of("TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384", 0xc069);
-  // public static final CipherSuite TLS_PSK_WITH_ARIA_128_GCM_SHA256 = of("TLS_PSK_WITH_ARIA_128_GCM_SHA256", 0xc06a);
-  // public static final CipherSuite TLS_PSK_WITH_ARIA_256_GCM_SHA384 = of("TLS_PSK_WITH_ARIA_256_GCM_SHA384", 0xc06b);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256 = of("TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256", 0xc06c);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384 = of("TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384", 0xc06d);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256 = of("TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256", 0xc06e);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384 = of("TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384", 0xc06f);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256 = of("TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256", 0xc070);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384 = of("TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384", 0xc071);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc072);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 = of("TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc073);
-  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc074);
-  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 = of("TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc075);
-  // public static final CipherSuite TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc076);
-  // public static final CipherSuite TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384 = of("TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc077);
-  // public static final CipherSuite TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc078);
-  // public static final CipherSuite TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384 = of("TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc079);
-  // public static final CipherSuite TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc07a);
-  // public static final CipherSuite TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc07b);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc07c);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc07d);
-  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc07e);
-  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc07f);
-  // public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256", 0xc080);
-  // public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384", 0xc081);
-  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256", 0xc082);
-  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384", 0xc083);
-  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256", 0xc084);
-  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384", 0xc085);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc086);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc087);
-  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc088);
-  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc089);
-  // public static final CipherSuite TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc08a);
-  // public static final CipherSuite TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc08b);
-  // public static final CipherSuite TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc08c);
-  // public static final CipherSuite TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc08d);
-  // public static final CipherSuite TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256", 0xc08e);
-  // public static final CipherSuite TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384", 0xc08f);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256", 0xc090);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384", 0xc091);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256", 0xc092);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384", 0xc093);
-  // public static final CipherSuite TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc094);
-  // public static final CipherSuite TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384 = of("TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc095);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc096);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 = of("TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc097);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc098);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384 = of("TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc099);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc09a);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 = of("TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc09b);
-  // public static final CipherSuite TLS_RSA_WITH_AES_128_CCM = of("TLS_RSA_WITH_AES_128_CCM", 0xc09c);
-  // public static final CipherSuite TLS_RSA_WITH_AES_256_CCM = of("TLS_RSA_WITH_AES_256_CCM", 0xc09d);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_AES_128_CCM = of("TLS_DHE_RSA_WITH_AES_128_CCM", 0xc09e);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_AES_256_CCM = of("TLS_DHE_RSA_WITH_AES_256_CCM", 0xc09f);
-  // public static final CipherSuite TLS_RSA_WITH_AES_128_CCM_8 = of("TLS_RSA_WITH_AES_128_CCM_8", 0xc0a0);
-  // public static final CipherSuite TLS_RSA_WITH_AES_256_CCM_8 = of("TLS_RSA_WITH_AES_256_CCM_8", 0xc0a1);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_AES_128_CCM_8 = of("TLS_DHE_RSA_WITH_AES_128_CCM_8", 0xc0a2);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_AES_256_CCM_8 = of("TLS_DHE_RSA_WITH_AES_256_CCM_8", 0xc0a3);
-  // public static final CipherSuite TLS_PSK_WITH_AES_128_CCM = of("TLS_PSK_WITH_AES_128_CCM", 0xc0a4);
-  // public static final CipherSuite TLS_PSK_WITH_AES_256_CCM = of("TLS_PSK_WITH_AES_256_CCM", 0xc0a5);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_128_CCM = of("TLS_DHE_PSK_WITH_AES_128_CCM", 0xc0a6);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_256_CCM = of("TLS_DHE_PSK_WITH_AES_256_CCM", 0xc0a7);
-  // public static final CipherSuite TLS_PSK_WITH_AES_128_CCM_8 = of("TLS_PSK_WITH_AES_128_CCM_8", 0xc0a8);
-  // public static final CipherSuite TLS_PSK_WITH_AES_256_CCM_8 = of("TLS_PSK_WITH_AES_256_CCM_8", 0xc0a9);
-  // public static final CipherSuite TLS_PSK_DHE_WITH_AES_128_CCM_8 = of("TLS_PSK_DHE_WITH_AES_128_CCM_8", 0xc0aa);
-  // public static final CipherSuite TLS_PSK_DHE_WITH_AES_256_CCM_8 = of("TLS_PSK_DHE_WITH_AES_256_CCM_8", 0xc0ab);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CCM = of("TLS_ECDHE_ECDSA_WITH_AES_128_CCM", 0xc0ac);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CCM = of("TLS_ECDHE_ECDSA_WITH_AES_256_CCM", 0xc0ad);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8 = of("TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8", 0xc0ae);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8 = of("TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8", 0xc0af);
-  public static final CipherSuite TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 = of("TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256", 0xcca8);
-  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 = of("TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256", 0xcca9);
-  public static final CipherSuite TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256 = of("TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256", 0xccaa);
-  // public static final CipherSuite TLS_PSK_WITH_CHACHA20_POLY1305_SHA256 = of("TLS_PSK_WITH_CHACHA20_POLY1305_SHA256", 0xccab);
-  public static final CipherSuite TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256 = of("TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256", 0xccac);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256 = of("TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256", 0xccad);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256 = of("TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256", 0xccae);
+  // public static final CipherSuite TLS_NULL_WITH_NULL_NULL = init("TLS_NULL_WITH_NULL_NULL", 0x0000);
+  public static final CipherSuite TLS_RSA_WITH_NULL_MD5 = init("SSL_RSA_WITH_NULL_MD5", 0x0001);
+  public static final CipherSuite TLS_RSA_WITH_NULL_SHA = init("SSL_RSA_WITH_NULL_SHA", 0x0002);
+  public static final CipherSuite TLS_RSA_EXPORT_WITH_RC4_40_MD5 = init("SSL_RSA_EXPORT_WITH_RC4_40_MD5", 0x0003);
+  public static final CipherSuite TLS_RSA_WITH_RC4_128_MD5 = init("SSL_RSA_WITH_RC4_128_MD5", 0x0004);
+  public static final CipherSuite TLS_RSA_WITH_RC4_128_SHA = init("SSL_RSA_WITH_RC4_128_SHA", 0x0005);
+  // public static final CipherSuite TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5 = init("SSL_RSA_EXPORT_WITH_RC2_CBC_40_MD5", 0x0006);
+  // public static final CipherSuite TLS_RSA_WITH_IDEA_CBC_SHA = init("TLS_RSA_WITH_IDEA_CBC_SHA", 0x0007);
+  public static final CipherSuite TLS_RSA_EXPORT_WITH_DES40_CBC_SHA = init("SSL_RSA_EXPORT_WITH_DES40_CBC_SHA", 0x0008);
+  public static final CipherSuite TLS_RSA_WITH_DES_CBC_SHA = init("SSL_RSA_WITH_DES_CBC_SHA", 0x0009);
+  public static final CipherSuite TLS_RSA_WITH_3DES_EDE_CBC_SHA = init("SSL_RSA_WITH_3DES_EDE_CBC_SHA", 0x000a);
+  // public static final CipherSuite TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA = init("SSL_DH_DSS_EXPORT_WITH_DES40_CBC_SHA", 0x000b);
+  // public static final CipherSuite TLS_DH_DSS_WITH_DES_CBC_SHA = init("TLS_DH_DSS_WITH_DES_CBC_SHA", 0x000c);
+  // public static final CipherSuite TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA = init("TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA", 0x000d);
+  // public static final CipherSuite TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA = init("SSL_DH_RSA_EXPORT_WITH_DES40_CBC_SHA", 0x000e);
+  // public static final CipherSuite TLS_DH_RSA_WITH_DES_CBC_SHA = init("TLS_DH_RSA_WITH_DES_CBC_SHA", 0x000f);
+  // public static final CipherSuite TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA = init("TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA", 0x0010);
+  public static final CipherSuite TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA = init("SSL_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA", 0x0011);
+  public static final CipherSuite TLS_DHE_DSS_WITH_DES_CBC_SHA = init("SSL_DHE_DSS_WITH_DES_CBC_SHA", 0x0012);
+  public static final CipherSuite TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA = init("SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA", 0x0013);
+  public static final CipherSuite TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA = init("SSL_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA", 0x0014);
+  public static final CipherSuite TLS_DHE_RSA_WITH_DES_CBC_SHA = init("SSL_DHE_RSA_WITH_DES_CBC_SHA", 0x0015);
+  public static final CipherSuite TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA = init("SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA", 0x0016);
+  public static final CipherSuite TLS_DH_anon_EXPORT_WITH_RC4_40_MD5 = init("SSL_DH_anon_EXPORT_WITH_RC4_40_MD5", 0x0017);
+  public static final CipherSuite TLS_DH_anon_WITH_RC4_128_MD5 = init("SSL_DH_anon_WITH_RC4_128_MD5", 0x0018);
+  public static final CipherSuite TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA = init("SSL_DH_anon_EXPORT_WITH_DES40_CBC_SHA", 0x0019);
+  public static final CipherSuite TLS_DH_anon_WITH_DES_CBC_SHA = init("SSL_DH_anon_WITH_DES_CBC_SHA", 0x001a);
+  public static final CipherSuite TLS_DH_anon_WITH_3DES_EDE_CBC_SHA = init("SSL_DH_anon_WITH_3DES_EDE_CBC_SHA", 0x001b);
+  public static final CipherSuite TLS_KRB5_WITH_DES_CBC_SHA = init("TLS_KRB5_WITH_DES_CBC_SHA", 0x001e);
+  public static final CipherSuite TLS_KRB5_WITH_3DES_EDE_CBC_SHA = init("TLS_KRB5_WITH_3DES_EDE_CBC_SHA", 0x001f);
+  public static final CipherSuite TLS_KRB5_WITH_RC4_128_SHA = init("TLS_KRB5_WITH_RC4_128_SHA", 0x0020);
+  // public static final CipherSuite TLS_KRB5_WITH_IDEA_CBC_SHA = init("TLS_KRB5_WITH_IDEA_CBC_SHA", 0x0021);
+  public static final CipherSuite TLS_KRB5_WITH_DES_CBC_MD5 = init("TLS_KRB5_WITH_DES_CBC_MD5", 0x0022);
+  public static final CipherSuite TLS_KRB5_WITH_3DES_EDE_CBC_MD5 = init("TLS_KRB5_WITH_3DES_EDE_CBC_MD5", 0x0023);
+  public static final CipherSuite TLS_KRB5_WITH_RC4_128_MD5 = init("TLS_KRB5_WITH_RC4_128_MD5", 0x0024);
+  // public static final CipherSuite TLS_KRB5_WITH_IDEA_CBC_MD5 = init("TLS_KRB5_WITH_IDEA_CBC_MD5", 0x0025);
+  public static final CipherSuite TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA = init("TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA", 0x0026);
+  // public static final CipherSuite TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA = init("TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA", 0x0027);
+  public static final CipherSuite TLS_KRB5_EXPORT_WITH_RC4_40_SHA = init("TLS_KRB5_EXPORT_WITH_RC4_40_SHA", 0x0028);
+  public static final CipherSuite TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5 = init("TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5", 0x0029);
+  // public static final CipherSuite TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5 = init("TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5", 0x002a);
+  public static final CipherSuite TLS_KRB5_EXPORT_WITH_RC4_40_MD5 = init("TLS_KRB5_EXPORT_WITH_RC4_40_MD5", 0x002b);
+  // public static final CipherSuite TLS_PSK_WITH_NULL_SHA = init("TLS_PSK_WITH_NULL_SHA", 0x002c);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_NULL_SHA = init("TLS_DHE_PSK_WITH_NULL_SHA", 0x002d);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_NULL_SHA = init("TLS_RSA_PSK_WITH_NULL_SHA", 0x002e);
+  public static final CipherSuite TLS_RSA_WITH_AES_128_CBC_SHA = init("TLS_RSA_WITH_AES_128_CBC_SHA", 0x002f);
+  // public static final CipherSuite TLS_DH_DSS_WITH_AES_128_CBC_SHA = init("TLS_DH_DSS_WITH_AES_128_CBC_SHA", 0x0030);
+  // public static final CipherSuite TLS_DH_RSA_WITH_AES_128_CBC_SHA = init("TLS_DH_RSA_WITH_AES_128_CBC_SHA", 0x0031);
+  public static final CipherSuite TLS_DHE_DSS_WITH_AES_128_CBC_SHA = init("TLS_DHE_DSS_WITH_AES_128_CBC_SHA", 0x0032);
+  public static final CipherSuite TLS_DHE_RSA_WITH_AES_128_CBC_SHA = init("TLS_DHE_RSA_WITH_AES_128_CBC_SHA", 0x0033);
+  public static final CipherSuite TLS_DH_anon_WITH_AES_128_CBC_SHA = init("TLS_DH_anon_WITH_AES_128_CBC_SHA", 0x0034);
+  public static final CipherSuite TLS_RSA_WITH_AES_256_CBC_SHA = init("TLS_RSA_WITH_AES_256_CBC_SHA", 0x0035);
+  // public static final CipherSuite TLS_DH_DSS_WITH_AES_256_CBC_SHA = init("TLS_DH_DSS_WITH_AES_256_CBC_SHA", 0x0036);
+  // public static final CipherSuite TLS_DH_RSA_WITH_AES_256_CBC_SHA = init("TLS_DH_RSA_WITH_AES_256_CBC_SHA", 0x0037);
+  public static final CipherSuite TLS_DHE_DSS_WITH_AES_256_CBC_SHA = init("TLS_DHE_DSS_WITH_AES_256_CBC_SHA", 0x0038);
+  public static final CipherSuite TLS_DHE_RSA_WITH_AES_256_CBC_SHA = init("TLS_DHE_RSA_WITH_AES_256_CBC_SHA", 0x0039);
+  public static final CipherSuite TLS_DH_anon_WITH_AES_256_CBC_SHA = init("TLS_DH_anon_WITH_AES_256_CBC_SHA", 0x003a);
+  public static final CipherSuite TLS_RSA_WITH_NULL_SHA256 = init("TLS_RSA_WITH_NULL_SHA256", 0x003b);
+  public static final CipherSuite TLS_RSA_WITH_AES_128_CBC_SHA256 = init("TLS_RSA_WITH_AES_128_CBC_SHA256", 0x003c);
+  public static final CipherSuite TLS_RSA_WITH_AES_256_CBC_SHA256 = init("TLS_RSA_WITH_AES_256_CBC_SHA256", 0x003d);
+  // public static final CipherSuite TLS_DH_DSS_WITH_AES_128_CBC_SHA256 = init("TLS_DH_DSS_WITH_AES_128_CBC_SHA256", 0x003e);
+  // public static final CipherSuite TLS_DH_RSA_WITH_AES_128_CBC_SHA256 = init("TLS_DH_RSA_WITH_AES_128_CBC_SHA256", 0x003f);
+  public static final CipherSuite TLS_DHE_DSS_WITH_AES_128_CBC_SHA256 = init("TLS_DHE_DSS_WITH_AES_128_CBC_SHA256", 0x0040);
+  public static final CipherSuite TLS_RSA_WITH_CAMELLIA_128_CBC_SHA = init("TLS_RSA_WITH_CAMELLIA_128_CBC_SHA", 0x0041);
+  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA = init("TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA", 0x0042);
+  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA = init("TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA", 0x0043);
+  public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA = init("TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA", 0x0044);
+  public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA = init("TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA", 0x0045);
+  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA = init("TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA", 0x0046);
+  public static final CipherSuite TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 = init("TLS_DHE_RSA_WITH_AES_128_CBC_SHA256", 0x0067);
+  // public static final CipherSuite TLS_DH_DSS_WITH_AES_256_CBC_SHA256 = init("TLS_DH_DSS_WITH_AES_256_CBC_SHA256", 0x0068);
+  // public static final CipherSuite TLS_DH_RSA_WITH_AES_256_CBC_SHA256 = init("TLS_DH_RSA_WITH_AES_256_CBC_SHA256", 0x0069);
+  public static final CipherSuite TLS_DHE_DSS_WITH_AES_256_CBC_SHA256 = init("TLS_DHE_DSS_WITH_AES_256_CBC_SHA256", 0x006a);
+  public static final CipherSuite TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 = init("TLS_DHE_RSA_WITH_AES_256_CBC_SHA256", 0x006b);
+  public static final CipherSuite TLS_DH_anon_WITH_AES_128_CBC_SHA256 = init("TLS_DH_anon_WITH_AES_128_CBC_SHA256", 0x006c);
+  public static final CipherSuite TLS_DH_anon_WITH_AES_256_CBC_SHA256 = init("TLS_DH_anon_WITH_AES_256_CBC_SHA256", 0x006d);
+  public static final CipherSuite TLS_RSA_WITH_CAMELLIA_256_CBC_SHA = init("TLS_RSA_WITH_CAMELLIA_256_CBC_SHA", 0x0084);
+  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA = init("TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA", 0x0085);
+  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA = init("TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA", 0x0086);
+  public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA = init("TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA", 0x0087);
+  public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA = init("TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA", 0x0088);
+  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA = init("TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA", 0x0089);
+  public static final CipherSuite TLS_PSK_WITH_RC4_128_SHA = init("TLS_PSK_WITH_RC4_128_SHA", 0x008a);
+  public static final CipherSuite TLS_PSK_WITH_3DES_EDE_CBC_SHA = init("TLS_PSK_WITH_3DES_EDE_CBC_SHA", 0x008b);
+  public static final CipherSuite TLS_PSK_WITH_AES_128_CBC_SHA = init("TLS_PSK_WITH_AES_128_CBC_SHA", 0x008c);
+  public static final CipherSuite TLS_PSK_WITH_AES_256_CBC_SHA = init("TLS_PSK_WITH_AES_256_CBC_SHA", 0x008d);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_RC4_128_SHA = init("TLS_DHE_PSK_WITH_RC4_128_SHA", 0x008e);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA = init("TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA", 0x008f);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_128_CBC_SHA = init("TLS_DHE_PSK_WITH_AES_128_CBC_SHA", 0x0090);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_256_CBC_SHA = init("TLS_DHE_PSK_WITH_AES_256_CBC_SHA", 0x0091);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_RC4_128_SHA = init("TLS_RSA_PSK_WITH_RC4_128_SHA", 0x0092);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA = init("TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA", 0x0093);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_128_CBC_SHA = init("TLS_RSA_PSK_WITH_AES_128_CBC_SHA", 0x0094);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_256_CBC_SHA = init("TLS_RSA_PSK_WITH_AES_256_CBC_SHA", 0x0095);
+  public static final CipherSuite TLS_RSA_WITH_SEED_CBC_SHA = init("TLS_RSA_WITH_SEED_CBC_SHA", 0x0096);
+  // public static final CipherSuite TLS_DH_DSS_WITH_SEED_CBC_SHA = init("TLS_DH_DSS_WITH_SEED_CBC_SHA", 0x0097);
+  // public static final CipherSuite TLS_DH_RSA_WITH_SEED_CBC_SHA = init("TLS_DH_RSA_WITH_SEED_CBC_SHA", 0x0098);
+  // public static final CipherSuite TLS_DHE_DSS_WITH_SEED_CBC_SHA = init("TLS_DHE_DSS_WITH_SEED_CBC_SHA", 0x0099);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_SEED_CBC_SHA = init("TLS_DHE_RSA_WITH_SEED_CBC_SHA", 0x009a);
+  // public static final CipherSuite TLS_DH_anon_WITH_SEED_CBC_SHA = init("TLS_DH_anon_WITH_SEED_CBC_SHA", 0x009b);
+  public static final CipherSuite TLS_RSA_WITH_AES_128_GCM_SHA256 = init("TLS_RSA_WITH_AES_128_GCM_SHA256", 0x009c);
+  public static final CipherSuite TLS_RSA_WITH_AES_256_GCM_SHA384 = init("TLS_RSA_WITH_AES_256_GCM_SHA384", 0x009d);
+  public static final CipherSuite TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 = init("TLS_DHE_RSA_WITH_AES_128_GCM_SHA256", 0x009e);
+  public static final CipherSuite TLS_DHE_RSA_WITH_AES_256_GCM_SHA384 = init("TLS_DHE_RSA_WITH_AES_256_GCM_SHA384", 0x009f);
+  // public static final CipherSuite TLS_DH_RSA_WITH_AES_128_GCM_SHA256 = init("TLS_DH_RSA_WITH_AES_128_GCM_SHA256", 0x00a0);
+  // public static final CipherSuite TLS_DH_RSA_WITH_AES_256_GCM_SHA384 = init("TLS_DH_RSA_WITH_AES_256_GCM_SHA384", 0x00a1);
+  public static final CipherSuite TLS_DHE_DSS_WITH_AES_128_GCM_SHA256 = init("TLS_DHE_DSS_WITH_AES_128_GCM_SHA256", 0x00a2);
+  public static final CipherSuite TLS_DHE_DSS_WITH_AES_256_GCM_SHA384 = init("TLS_DHE_DSS_WITH_AES_256_GCM_SHA384", 0x00a3);
+  // public static final CipherSuite TLS_DH_DSS_WITH_AES_128_GCM_SHA256 = init("TLS_DH_DSS_WITH_AES_128_GCM_SHA256", 0x00a4);
+  // public static final CipherSuite TLS_DH_DSS_WITH_AES_256_GCM_SHA384 = init("TLS_DH_DSS_WITH_AES_256_GCM_SHA384", 0x00a5);
+  public static final CipherSuite TLS_DH_anon_WITH_AES_128_GCM_SHA256 = init("TLS_DH_anon_WITH_AES_128_GCM_SHA256", 0x00a6);
+  public static final CipherSuite TLS_DH_anon_WITH_AES_256_GCM_SHA384 = init("TLS_DH_anon_WITH_AES_256_GCM_SHA384", 0x00a7);
+  // public static final CipherSuite TLS_PSK_WITH_AES_128_GCM_SHA256 = init("TLS_PSK_WITH_AES_128_GCM_SHA256", 0x00a8);
+  // public static final CipherSuite TLS_PSK_WITH_AES_256_GCM_SHA384 = init("TLS_PSK_WITH_AES_256_GCM_SHA384", 0x00a9);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_128_GCM_SHA256 = init("TLS_DHE_PSK_WITH_AES_128_GCM_SHA256", 0x00aa);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_256_GCM_SHA384 = init("TLS_DHE_PSK_WITH_AES_256_GCM_SHA384", 0x00ab);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_128_GCM_SHA256 = init("TLS_RSA_PSK_WITH_AES_128_GCM_SHA256", 0x00ac);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_256_GCM_SHA384 = init("TLS_RSA_PSK_WITH_AES_256_GCM_SHA384", 0x00ad);
+  // public static final CipherSuite TLS_PSK_WITH_AES_128_CBC_SHA256 = init("TLS_PSK_WITH_AES_128_CBC_SHA256", 0x00ae);
+  // public static final CipherSuite TLS_PSK_WITH_AES_256_CBC_SHA384 = init("TLS_PSK_WITH_AES_256_CBC_SHA384", 0x00af);
+  // public static final CipherSuite TLS_PSK_WITH_NULL_SHA256 = init("TLS_PSK_WITH_NULL_SHA256", 0x00b0);
+  // public static final CipherSuite TLS_PSK_WITH_NULL_SHA384 = init("TLS_PSK_WITH_NULL_SHA384", 0x00b1);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_128_CBC_SHA256 = init("TLS_DHE_PSK_WITH_AES_128_CBC_SHA256", 0x00b2);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_256_CBC_SHA384 = init("TLS_DHE_PSK_WITH_AES_256_CBC_SHA384", 0x00b3);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_NULL_SHA256 = init("TLS_DHE_PSK_WITH_NULL_SHA256", 0x00b4);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_NULL_SHA384 = init("TLS_DHE_PSK_WITH_NULL_SHA384", 0x00b5);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_128_CBC_SHA256 = init("TLS_RSA_PSK_WITH_AES_128_CBC_SHA256", 0x00b6);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_256_CBC_SHA384 = init("TLS_RSA_PSK_WITH_AES_256_CBC_SHA384", 0x00b7);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_NULL_SHA256 = init("TLS_RSA_PSK_WITH_NULL_SHA256", 0x00b8);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_NULL_SHA384 = init("TLS_RSA_PSK_WITH_NULL_SHA384", 0x00b9);
+  // public static final CipherSuite TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0x00ba);
+  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256", 0x00bb);
+  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0x00bc);
+  // public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256", 0x00bd);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0x00be);
+  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256", 0x00bf);
+  // public static final CipherSuite TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256 = init("TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256", 0x00c0);
+  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256 = init("TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256", 0x00c1);
+  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256 = init("TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256", 0x00c2);
+  // public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256 = init("TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256", 0x00c3);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256 = init("TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256", 0x00c4);
+  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256 = init("TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256", 0x00c5);
+  public static final CipherSuite TLS_EMPTY_RENEGOTIATION_INFO_SCSV = init("TLS_EMPTY_RENEGOTIATION_INFO_SCSV", 0x00ff);
+  public static final CipherSuite TLS_FALLBACK_SCSV = init("TLS_FALLBACK_SCSV", 0x5600);
+  public static final CipherSuite TLS_ECDH_ECDSA_WITH_NULL_SHA = init("TLS_ECDH_ECDSA_WITH_NULL_SHA", 0xc001);
+  public static final CipherSuite TLS_ECDH_ECDSA_WITH_RC4_128_SHA = init("TLS_ECDH_ECDSA_WITH_RC4_128_SHA", 0xc002);
+  public static final CipherSuite TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA = init("TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA", 0xc003);
+  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA = init("TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA", 0xc004);
+  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA = init("TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA", 0xc005);
+  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_NULL_SHA = init("TLS_ECDHE_ECDSA_WITH_NULL_SHA", 0xc006);
+  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_RC4_128_SHA = init("TLS_ECDHE_ECDSA_WITH_RC4_128_SHA", 0xc007);
+  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA = init("TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA", 0xc008);
+  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA = init("TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA", 0xc009);
+  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA = init("TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA", 0xc00a);
+  public static final CipherSuite TLS_ECDH_RSA_WITH_NULL_SHA = init("TLS_ECDH_RSA_WITH_NULL_SHA", 0xc00b);
+  public static final CipherSuite TLS_ECDH_RSA_WITH_RC4_128_SHA = init("TLS_ECDH_RSA_WITH_RC4_128_SHA", 0xc00c);
+  public static final CipherSuite TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA = init("TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA", 0xc00d);
+  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_128_CBC_SHA = init("TLS_ECDH_RSA_WITH_AES_128_CBC_SHA", 0xc00e);
+  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_256_CBC_SHA = init("TLS_ECDH_RSA_WITH_AES_256_CBC_SHA", 0xc00f);
+  public static final CipherSuite TLS_ECDHE_RSA_WITH_NULL_SHA = init("TLS_ECDHE_RSA_WITH_NULL_SHA", 0xc010);
+  public static final CipherSuite TLS_ECDHE_RSA_WITH_RC4_128_SHA = init("TLS_ECDHE_RSA_WITH_RC4_128_SHA", 0xc011);
+  public static final CipherSuite TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA = init("TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA", 0xc012);
+  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA = init("TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA", 0xc013);
+  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA = init("TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA", 0xc014);
+  public static final CipherSuite TLS_ECDH_anon_WITH_NULL_SHA = init("TLS_ECDH_anon_WITH_NULL_SHA", 0xc015);
+  public static final CipherSuite TLS_ECDH_anon_WITH_RC4_128_SHA = init("TLS_ECDH_anon_WITH_RC4_128_SHA", 0xc016);
+  public static final CipherSuite TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA = init("TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA", 0xc017);
+  public static final CipherSuite TLS_ECDH_anon_WITH_AES_128_CBC_SHA = init("TLS_ECDH_anon_WITH_AES_128_CBC_SHA", 0xc018);
+  public static final CipherSuite TLS_ECDH_anon_WITH_AES_256_CBC_SHA = init("TLS_ECDH_anon_WITH_AES_256_CBC_SHA", 0xc019);
+  // public static final CipherSuite TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA = init("TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA", 0xc01a);
+  // public static final CipherSuite TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA = init("TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA", 0xc01b);
+  // public static final CipherSuite TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA = init("TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA", 0xc01c);
+  // public static final CipherSuite TLS_SRP_SHA_WITH_AES_128_CBC_SHA = init("TLS_SRP_SHA_WITH_AES_128_CBC_SHA", 0xc01d);
+  // public static final CipherSuite TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA = init("TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA", 0xc01e);
+  // public static final CipherSuite TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA = init("TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA", 0xc01f);
+  // public static final CipherSuite TLS_SRP_SHA_WITH_AES_256_CBC_SHA = init("TLS_SRP_SHA_WITH_AES_256_CBC_SHA", 0xc020);
+  // public static final CipherSuite TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA = init("TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA", 0xc021);
+  // public static final CipherSuite TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA = init("TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA", 0xc022);
+  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 = init("TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256", 0xc023);
+  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 = init("TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384", 0xc024);
+  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256 = init("TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256", 0xc025);
+  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384 = init("TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384", 0xc026);
+  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 = init("TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256", 0xc027);
+  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 = init("TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384", 0xc028);
+  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256 = init("TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256", 0xc029);
+  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384 = init("TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384", 0xc02a);
+  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 = init("TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256", 0xc02b);
+  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 = init("TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384", 0xc02c);
+  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256 = init("TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256", 0xc02d);
+  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384 = init("TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384", 0xc02e);
+  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 = init("TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256", 0xc02f);
+  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 = init("TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384", 0xc030);
+  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256 = init("TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256", 0xc031);
+  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384 = init("TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384", 0xc032);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_RC4_128_SHA = init("TLS_ECDHE_PSK_WITH_RC4_128_SHA", 0xc033);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA = init("TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA", 0xc034);
+  public static final CipherSuite TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA = init("TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA", 0xc035);
+  public static final CipherSuite TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA = init("TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA", 0xc036);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256 = init("TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256", 0xc037);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384 = init("TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384", 0xc038);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_NULL_SHA = init("TLS_ECDHE_PSK_WITH_NULL_SHA", 0xc039);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_NULL_SHA256 = init("TLS_ECDHE_PSK_WITH_NULL_SHA256", 0xc03a);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_NULL_SHA384 = init("TLS_ECDHE_PSK_WITH_NULL_SHA384", 0xc03b);
+  // public static final CipherSuite TLS_RSA_WITH_ARIA_128_CBC_SHA256 = init("TLS_RSA_WITH_ARIA_128_CBC_SHA256", 0xc03c);
+  // public static final CipherSuite TLS_RSA_WITH_ARIA_256_CBC_SHA384 = init("TLS_RSA_WITH_ARIA_256_CBC_SHA384", 0xc03d);
+  // public static final CipherSuite TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256 = init("TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256", 0xc03e);
+  // public static final CipherSuite TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384 = init("TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384", 0xc03f);
+  // public static final CipherSuite TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256 = init("TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256", 0xc040);
+  // public static final CipherSuite TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384 = init("TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384", 0xc041);
+  // public static final CipherSuite TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256 = init("TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256", 0xc042);
+  // public static final CipherSuite TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384 = init("TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384", 0xc043);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256 = init("TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256", 0xc044);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384 = init("TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384", 0xc045);
+  // public static final CipherSuite TLS_DH_anon_WITH_ARIA_128_CBC_SHA256 = init("TLS_DH_anon_WITH_ARIA_128_CBC_SHA256", 0xc046);
+  // public static final CipherSuite TLS_DH_anon_WITH_ARIA_256_CBC_SHA384 = init("TLS_DH_anon_WITH_ARIA_256_CBC_SHA384", 0xc047);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256 = init("TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256", 0xc048);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384 = init("TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384", 0xc049);
+  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256 = init("TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256", 0xc04a);
+  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384 = init("TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384", 0xc04b);
+  // public static final CipherSuite TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256 = init("TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256", 0xc04c);
+  // public static final CipherSuite TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384 = init("TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384", 0xc04d);
+  // public static final CipherSuite TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256 = init("TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256", 0xc04e);
+  // public static final CipherSuite TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384 = init("TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384", 0xc04f);
+  // public static final CipherSuite TLS_RSA_WITH_ARIA_128_GCM_SHA256 = init("TLS_RSA_WITH_ARIA_128_GCM_SHA256", 0xc050);
+  // public static final CipherSuite TLS_RSA_WITH_ARIA_256_GCM_SHA384 = init("TLS_RSA_WITH_ARIA_256_GCM_SHA384", 0xc051);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256 = init("TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256", 0xc052);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384 = init("TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384", 0xc053);
+  // public static final CipherSuite TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256 = init("TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256", 0xc054);
+  // public static final CipherSuite TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384 = init("TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384", 0xc055);
+  // public static final CipherSuite TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256 = init("TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256", 0xc056);
+  // public static final CipherSuite TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384 = init("TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384", 0xc057);
+  // public static final CipherSuite TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256 = init("TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256", 0xc058);
+  // public static final CipherSuite TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384 = init("TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384", 0xc059);
+  // public static final CipherSuite TLS_DH_anon_WITH_ARIA_128_GCM_SHA256 = init("TLS_DH_anon_WITH_ARIA_128_GCM_SHA256", 0xc05a);
+  // public static final CipherSuite TLS_DH_anon_WITH_ARIA_256_GCM_SHA384 = init("TLS_DH_anon_WITH_ARIA_256_GCM_SHA384", 0xc05b);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256 = init("TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256", 0xc05c);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384 = init("TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384", 0xc05d);
+  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256 = init("TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256", 0xc05e);
+  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384 = init("TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384", 0xc05f);
+  // public static final CipherSuite TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256 = init("TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256", 0xc060);
+  // public static final CipherSuite TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384 = init("TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384", 0xc061);
+  // public static final CipherSuite TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256 = init("TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256", 0xc062);
+  // public static final CipherSuite TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384 = init("TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384", 0xc063);
+  // public static final CipherSuite TLS_PSK_WITH_ARIA_128_CBC_SHA256 = init("TLS_PSK_WITH_ARIA_128_CBC_SHA256", 0xc064);
+  // public static final CipherSuite TLS_PSK_WITH_ARIA_256_CBC_SHA384 = init("TLS_PSK_WITH_ARIA_256_CBC_SHA384", 0xc065);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256 = init("TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256", 0xc066);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384 = init("TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384", 0xc067);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256 = init("TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256", 0xc068);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384 = init("TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384", 0xc069);
+  // public static final CipherSuite TLS_PSK_WITH_ARIA_128_GCM_SHA256 = init("TLS_PSK_WITH_ARIA_128_GCM_SHA256", 0xc06a);
+  // public static final CipherSuite TLS_PSK_WITH_ARIA_256_GCM_SHA384 = init("TLS_PSK_WITH_ARIA_256_GCM_SHA384", 0xc06b);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256 = init("TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256", 0xc06c);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384 = init("TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384", 0xc06d);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256 = init("TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256", 0xc06e);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384 = init("TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384", 0xc06f);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256 = init("TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256", 0xc070);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384 = init("TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384", 0xc071);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc072);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 = init("TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc073);
+  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc074);
+  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 = init("TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc075);
+  // public static final CipherSuite TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc076);
+  // public static final CipherSuite TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384 = init("TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc077);
+  // public static final CipherSuite TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc078);
+  // public static final CipherSuite TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384 = init("TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc079);
+  // public static final CipherSuite TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc07a);
+  // public static final CipherSuite TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc07b);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc07c);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc07d);
+  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc07e);
+  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc07f);
+  // public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256", 0xc080);
+  // public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384", 0xc081);
+  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256", 0xc082);
+  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384", 0xc083);
+  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256", 0xc084);
+  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384", 0xc085);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc086);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc087);
+  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc088);
+  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc089);
+  // public static final CipherSuite TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc08a);
+  // public static final CipherSuite TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc08b);
+  // public static final CipherSuite TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc08c);
+  // public static final CipherSuite TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc08d);
+  // public static final CipherSuite TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256", 0xc08e);
+  // public static final CipherSuite TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384", 0xc08f);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256", 0xc090);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384", 0xc091);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256", 0xc092);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384", 0xc093);
+  // public static final CipherSuite TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc094);
+  // public static final CipherSuite TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384 = init("TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc095);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc096);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 = init("TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc097);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc098);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384 = init("TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc099);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc09a);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 = init("TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc09b);
+  // public static final CipherSuite TLS_RSA_WITH_AES_128_CCM = init("TLS_RSA_WITH_AES_128_CCM", 0xc09c);
+  // public static final CipherSuite TLS_RSA_WITH_AES_256_CCM = init("TLS_RSA_WITH_AES_256_CCM", 0xc09d);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_AES_128_CCM = init("TLS_DHE_RSA_WITH_AES_128_CCM", 0xc09e);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_AES_256_CCM = init("TLS_DHE_RSA_WITH_AES_256_CCM", 0xc09f);
+  // public static final CipherSuite TLS_RSA_WITH_AES_128_CCM_8 = init("TLS_RSA_WITH_AES_128_CCM_8", 0xc0a0);
+  // public static final CipherSuite TLS_RSA_WITH_AES_256_CCM_8 = init("TLS_RSA_WITH_AES_256_CCM_8", 0xc0a1);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_AES_128_CCM_8 = init("TLS_DHE_RSA_WITH_AES_128_CCM_8", 0xc0a2);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_AES_256_CCM_8 = init("TLS_DHE_RSA_WITH_AES_256_CCM_8", 0xc0a3);
+  // public static final CipherSuite TLS_PSK_WITH_AES_128_CCM = init("TLS_PSK_WITH_AES_128_CCM", 0xc0a4);
+  // public static final CipherSuite TLS_PSK_WITH_AES_256_CCM = init("TLS_PSK_WITH_AES_256_CCM", 0xc0a5);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_128_CCM = init("TLS_DHE_PSK_WITH_AES_128_CCM", 0xc0a6);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_256_CCM = init("TLS_DHE_PSK_WITH_AES_256_CCM", 0xc0a7);
+  // public static final CipherSuite TLS_PSK_WITH_AES_128_CCM_8 = init("TLS_PSK_WITH_AES_128_CCM_8", 0xc0a8);
+  // public static final CipherSuite TLS_PSK_WITH_AES_256_CCM_8 = init("TLS_PSK_WITH_AES_256_CCM_8", 0xc0a9);
+  // public static final CipherSuite TLS_PSK_DHE_WITH_AES_128_CCM_8 = init("TLS_PSK_DHE_WITH_AES_128_CCM_8", 0xc0aa);
+  // public static final CipherSuite TLS_PSK_DHE_WITH_AES_256_CCM_8 = init("TLS_PSK_DHE_WITH_AES_256_CCM_8", 0xc0ab);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CCM = init("TLS_ECDHE_ECDSA_WITH_AES_128_CCM", 0xc0ac);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CCM = init("TLS_ECDHE_ECDSA_WITH_AES_256_CCM", 0xc0ad);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8 = init("TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8", 0xc0ae);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8 = init("TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8", 0xc0af);
+  public static final CipherSuite TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 = init("TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256", 0xcca8);
+  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 = init("TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256", 0xcca9);
+  public static final CipherSuite TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256 = init("TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256", 0xccaa);
+  // public static final CipherSuite TLS_PSK_WITH_CHACHA20_POLY1305_SHA256 = init("TLS_PSK_WITH_CHACHA20_POLY1305_SHA256", 0xccab);
+  public static final CipherSuite TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256 = init("TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256", 0xccac);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256 = init("TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256", 0xccad);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256 = init("TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256", 0xccae);
 
-  // TLS 1.3 https://tools.ietf.org/html/draft-ietf-tls-tls13-28
-  // Documentation only ids will be updated once assigned by IANA.
-  public static final CipherSuite TLS_AES_128_GCM_SHA256 = of("TLS_AES_128_GCM_SHA256", 0x1301);
-  public static final CipherSuite TLS_AES_256_GCM_SHA384 = of("TLS_AES_256_GCM_SHA384", 0x1302);
-  public static final CipherSuite TLS_CHACHA20_POLY1305_SHA256 = of("TLS_CHACHA20_POLY1305_SHA256", 0x1303);
-  public static final CipherSuite TLS_AES_128_CCM_SHA256 = of("TLS_AES_128_CCM_SHA256", 0x1304);
-  public static final CipherSuite TLS_AES_256_CCM_8_SHA256 = of("TLS_AES_256_CCM_8_SHA256", 0x1305);
+  // TLS 1.3 https://tools.ietf.org/html/rfc8446
+  public static final CipherSuite TLS_AES_128_GCM_SHA256 = init("TLS_AES_128_GCM_SHA256", 0x1301);
+  public static final CipherSuite TLS_AES_256_GCM_SHA384 = init("TLS_AES_256_GCM_SHA384", 0x1302);
+  public static final CipherSuite TLS_CHACHA20_POLY1305_SHA256 = init("TLS_CHACHA20_POLY1305_SHA256", 0x1303);
+  public static final CipherSuite TLS_AES_128_CCM_SHA256 = init("TLS_AES_128_CCM_SHA256", 0x1304);
+  public static final CipherSuite TLS_AES_256_CCM_8_SHA256 = init("TLS_AES_256_CCM_8_SHA256", 0x1305);
 
   final String javaName;
 
@@ -412,12 +409,28 @@
   public static synchronized CipherSuite forJavaName(String javaName) {
     CipherSuite result = INSTANCES.get(javaName);
     if (result == null) {
-      result = new CipherSuite(javaName);
+      result = INSTANCES.get(secondaryName(javaName));
+
+      if (result == null) {
+        result = new CipherSuite(javaName);
+      }
+
+      // Add the new cipher suite, or a confirmed alias.
       INSTANCES.put(javaName, result);
     }
     return result;
   }
 
+  private static String secondaryName(String javaName) {
+    if (javaName.startsWith("TLS_")) {
+      return "SSL_" + javaName.substring(4);
+    } else if (javaName.startsWith("SSL_")) {
+      return "TLS_" + javaName.substring(4);
+    } else {
+      return javaName;
+    }
+  }
+
   static List<CipherSuite> forJavaNames(String... cipherSuites) {
     List<CipherSuite> result = new ArrayList<>(cipherSuites.length);
     for (String cipherSuite : cipherSuites) {
@@ -438,8 +451,10 @@ private CipherSuite(String javaName) {
    *     for older cipher suites because the prefix is {@code SSL_} instead of {@code TLS_}.
    * @param value the integer identifier for this cipher suite. (Documentation only.)
    */
-  private static CipherSuite of(String javaName, int value) {
-    return forJavaName(javaName);
+  private static CipherSuite init(String javaName, int value) {
+    CipherSuite suite = new CipherSuite(javaName);
+    INSTANCES.put(javaName, suite);
+    return suite;
   }
 
   /**
diff --git a/okhttp/src/main/java/okhttp3/ConnectionPool.java b/okhttp/src/main/java/okhttp3/ConnectionPool.java
index 605f275661..2c0c6fffbd 100644
--- a/okhttp/src/main/java/okhttp3/ConnectionPool.java
+++ b/okhttp/src/main/java/okhttp3/ConnectionPool.java
@@ -49,24 +49,22 @@
    */
   private static final Executor executor = new ThreadPoolExecutor(0 /* corePoolSize */,
       Integer.MAX_VALUE /* maximumPoolSize */, 60L /* keepAliveTime */, TimeUnit.SECONDS,
-      new SynchronousQueue<Runnable>(), Util.threadFactory("OkHttp ConnectionPool", true));
+      new SynchronousQueue<>(), Util.threadFactory("OkHttp ConnectionPool", true));
 
   /** The maximum number of idle connections for each address. */
   private final int maxIdleConnections;
   private final long keepAliveDurationNs;
-  private final Runnable cleanupRunnable = new Runnable() {
-    @Override public void run() {
-      while (true) {
-        long waitNanos = cleanup(System.nanoTime());
-        if (waitNanos == -1) return;
-        if (waitNanos > 0) {
-          long waitMillis = waitNanos / 1000000L;
-          waitNanos -= (waitMillis * 1000000L);
-          synchronized (ConnectionPool.this) {
-            try {
-              ConnectionPool.this.wait(waitMillis, (int) waitNanos);
-            } catch (InterruptedException ignored) {
-            }
+  private final Runnable cleanupRunnable = () -> {
+    while (true) {
+      long waitNanos = cleanup(System.nanoTime());
+      if (waitNanos == -1) return;
+      if (waitNanos > 0) {
+        long waitMillis = waitNanos / 1000000L;
+        waitNanos -= (waitMillis * 1000000L);
+        synchronized (ConnectionPool.this) {
+          try {
+            ConnectionPool.this.wait(waitMillis, (int) waitNanos);
+          } catch (InterruptedException ignored) {
           }
         }
       }
@@ -105,29 +103,23 @@ public synchronized int idleConnectionCount() {
     return total;
   }
 
-  /**
-   * Returns total number of connections in the pool. Note that prior to OkHttp 2.7 this included
-   * only idle connections and HTTP/2 connections. Since OkHttp 2.7 this includes all connections,
-   * both active and inactive. Use {@link #idleConnectionCount()} to count connections not currently
-   * in use.
-   */
+  /** Returns total number of connections in the pool. */
   public synchronized int connectionCount() {
     return connections.size();
   }
 
   /**
-   * Returns a recycled connection to {@code address}, or null if no such connection exists. The
-   * route is null if the address has not yet been routed.
+   * Acquires a recycled connection to {@code address} for {@code streamAllocation}. If non-null
+   * {@code route} is the resolved route for a connection.
    */
-  @Nullable RealConnection get(Address address, StreamAllocation streamAllocation, Route route) {
+  void acquire(Address address, StreamAllocation streamAllocation, @Nullable Route route) {
     assert (Thread.holdsLock(this));
     for (RealConnection connection : connections) {
       if (connection.isEligible(address, route)) {
         streamAllocation.acquire(connection, true);
-        return connection;
+        return;
       }
     }
-    return null;
   }
 
   /**
diff --git a/okhttp/src/main/java/okhttp3/ConnectionSpec.java b/okhttp/src/main/java/okhttp3/ConnectionSpec.java
index e5352e4567..83efef4839 100644
--- a/okhttp/src/main/java/okhttp3/ConnectionSpec.java
+++ b/okhttp/src/main/java/okhttp3/ConnectionSpec.java
@@ -17,6 +17,7 @@
 
 import java.util.Arrays;
 import java.util.List;
+import java.util.Objects;
 import javax.annotation.Nullable;
 import javax.net.ssl.SSLSocket;
 import okhttp3.internal.Util;
@@ -37,11 +38,24 @@
  *
  * <p>Use {@link Builder#allEnabledTlsVersions()} and {@link Builder#allEnabledCipherSuites} to
  * defer all feature selection to the underlying SSL socket.
+ *
+ * <p>The configuration of each spec changes with each OkHttp release. This is annoying: upgrading
+ * your OkHttp library can break connectivity to certain web servers! But it‚Äôs a necessary annoyance
+ * because the TLS ecosystem is dynamic and staying up to date is necessary to stay secure. See
+ * <a href="https://github.com/square/okhttp/wiki/TLS-Configuration-History">OkHttp's TLS
+ * Configuration History</a> to track these changes.
  */
 public final class ConnectionSpec {
 
   // Most secure but generally supported list.
   private static final CipherSuite[] RESTRICTED_CIPHER_SUITES = new CipherSuite[] {
+      // TLSv1.3
+      CipherSuite.TLS_AES_128_GCM_SHA256,
+      CipherSuite.TLS_AES_256_GCM_SHA384,
+      CipherSuite.TLS_CHACHA20_POLY1305_SHA256,
+      CipherSuite.TLS_AES_128_CCM_SHA256,
+      CipherSuite.TLS_AES_256_CCM_8_SHA256,
+
       CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
       CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
       CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
@@ -50,19 +64,17 @@
       CipherSuite.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256
   };
 
-  // TLS 1.3
-  private static final CipherSuite[] TLS13_CIPHER_SUITES = new CipherSuite[] {
+  // This is nearly equal to the cipher suites supported in Chrome 51, current as of 2016-05-25.
+  // All of these suites are available on Android 7.0; earlier releases support a subset of these
+  // suites. https://github.com/square/okhttp/issues/1972
+  private static final CipherSuite[] APPROVED_CIPHER_SUITES = new CipherSuite[] {
+      // TLSv1.3
       CipherSuite.TLS_AES_128_GCM_SHA256,
       CipherSuite.TLS_AES_256_GCM_SHA384,
       CipherSuite.TLS_CHACHA20_POLY1305_SHA256,
       CipherSuite.TLS_AES_128_CCM_SHA256,
-      CipherSuite.TLS_AES_256_CCM_8_SHA256
-  };
+      CipherSuite.TLS_AES_256_CCM_8_SHA256,
 
-  // This is nearly equal to the cipher suites supported in Chrome 51, current as of 2016-05-25.
-  // All of these suites are available on Android 7.0; earlier releases support a subset of these
-  // suites. https://github.com/square/okhttp/issues/1972
-  private static final CipherSuite[] APPROVED_CIPHER_SUITES = new CipherSuite[] {
       CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
       CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
       CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
@@ -82,34 +94,31 @@
       CipherSuite.TLS_RSA_WITH_3DES_EDE_CBC_SHA,
   };
 
-  /**
-   * A TLS 1.3 only Connection Spec for testing. This will be eventually be exposed
-   * as part of MODERN_TLS or folded into the default OkHttp client once published and
-   * available in JDK11.
-   */
-  static final ConnectionSpec TLS_13 = new Builder(true)
-      .cipherSuites(TLS13_CIPHER_SUITES)
-      .tlsVersions(TlsVersion.TLS_1_3)
-      .supportsTlsExtensions(true)
-      .build();
-
-  /** A secure TLS connection assuming a modern client platform and server. */
+  /** A secure TLS connection that requires a recent client platform and a recent server. */
   public static final ConnectionSpec RESTRICTED_TLS = new Builder(true)
       .cipherSuites(RESTRICTED_CIPHER_SUITES)
-      .tlsVersions(TlsVersion.TLS_1_2)
+      .tlsVersions(TlsVersion.TLS_1_3, TlsVersion.TLS_1_2)
       .supportsTlsExtensions(true)
       .build();
 
-  /** A modern TLS connection with extensions like SNI and ALPN available. */
+  /**
+   * A modern TLS configuration that works on most client platforms and can connect to most servers.
+   * This is OkHttp's default configuration.
+   */
   public static final ConnectionSpec MODERN_TLS = new Builder(true)
       .cipherSuites(APPROVED_CIPHER_SUITES)
-      .tlsVersions(TlsVersion.TLS_1_2, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0)
+      .tlsVersions(TlsVersion.TLS_1_3, TlsVersion.TLS_1_2)
       .supportsTlsExtensions(true)
       .build();
 
-  /** A backwards-compatible fallback connection for interop with obsolete servers. */
-  public static final ConnectionSpec COMPATIBLE_TLS = new Builder(MODERN_TLS)
-      .tlsVersions(TlsVersion.TLS_1_0)
+  /**
+   * A backwards-compatible fallback configuration that works on obsolete client platforms and can
+   * connect to obsolete servers. When possible, prefer to upgrade your client platform or server
+   * rather than using this configuration.
+   */
+  public static final ConnectionSpec COMPATIBLE_TLS = new Builder(true)
+      .cipherSuites(APPROVED_CIPHER_SUITES)
+      .tlsVersions(TlsVersion.TLS_1_3, TlsVersion.TLS_1_2, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0)
       .supportsTlsExtensions(true)
       .build();
 
@@ -252,11 +261,9 @@ public boolean isCompatible(SSLSocket socket) {
       return "ConnectionSpec()";
     }
 
-    String cipherSuitesString = cipherSuites != null ? cipherSuites().toString() : "[all enabled]";
-    String tlsVersionsString = tlsVersions != null ? tlsVersions().toString() : "[all enabled]";
     return "ConnectionSpec("
-        + "cipherSuites=" + cipherSuitesString
-        + ", tlsVersions=" + tlsVersionsString
+        + "cipherSuites=" + Objects.toString(cipherSuites(), "[all enabled]")
+        + ", tlsVersions=" + Objects.toString(tlsVersions(), "[all enabled]")
         + ", supportsTlsExtensions=" + supportsTlsExtensions
         + ")";
   }
@@ -333,6 +340,11 @@ public Builder tlsVersions(String... tlsVersions) {
       return this;
     }
 
+    /**
+     * @deprecated since OkHttp 3.13 all TLS-connections are expected to support TLS extensions.
+     *     In a future release setting this to true will be unnecessary and setting it to false will
+     *     have no effect.
+     */
     public Builder supportsTlsExtensions(boolean supportsTlsExtensions) {
       if (!tls) throw new IllegalStateException("no TLS extensions for cleartext connections");
       this.supportsTlsExtensions = supportsTlsExtensions;
diff --git a/okhttp/src/main/java/okhttp3/Cookie.java b/okhttp/src/main/java/okhttp3/Cookie.java
index fbfa99c26d..867451e387 100644
--- a/okhttp/src/main/java/okhttp3/Cookie.java
+++ b/okhttp/src/main/java/okhttp3/Cookie.java
@@ -450,7 +450,7 @@ private static String parseDomain(String s) {
 
     return cookies != null
         ? Collections.unmodifiableList(cookies)
-        : Collections.<Cookie>emptyList();
+        : Collections.emptyList();
   }
 
   /**
@@ -458,10 +458,10 @@ private static String parseDomain(String s) {
    * #domain() domain} values must all be set before calling {@link #build}.
    */
   public static final class Builder {
-    String name;
-    String value;
+    @Nullable String name;
+    @Nullable String value;
     long expiresAt = HttpDate.MAX_DATE;
-    String domain;
+    @Nullable String domain;
     String path = "/";
     boolean secure;
     boolean httpOnly;
diff --git a/okhttp/src/main/java/okhttp3/Credentials.java b/okhttp/src/main/java/okhttp3/Credentials.java
index 530863e4a8..c06c1d61f0 100644
--- a/okhttp/src/main/java/okhttp3/Credentials.java
+++ b/okhttp/src/main/java/okhttp3/Credentials.java
@@ -18,7 +18,7 @@
 import java.nio.charset.Charset;
 import okio.ByteString;
 
-import static okhttp3.internal.Util.ISO_8859_1;
+import static java.nio.charset.StandardCharsets.ISO_8859_1;
 
 /** Factory for HTTP authorization credentials. */
 public final class Credentials {
diff --git a/okhttp/src/main/java/okhttp3/Dispatcher.java b/okhttp/src/main/java/okhttp3/Dispatcher.java
index 21013bda11..d3d9b21aff 100644
--- a/okhttp/src/main/java/okhttp3/Dispatcher.java
+++ b/okhttp/src/main/java/okhttp3/Dispatcher.java
@@ -63,7 +63,7 @@ public Dispatcher() {
   public synchronized ExecutorService executorService() {
     if (executorService == null) {
       executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,
-          new SynchronousQueue<Runnable>(), Util.threadFactory("OkHttp Dispatcher", false));
+          new SynchronousQueue<>(), Util.threadFactory("OkHttp Dispatcher", false));
     }
     return executorService;
   }
@@ -75,12 +75,14 @@ public synchronized ExecutorService executorService() {
    * <p>If more than {@code maxRequests} requests are in flight when this is invoked, those requests
    * will remain in flight.
    */
-  public synchronized void setMaxRequests(int maxRequests) {
+  public void setMaxRequests(int maxRequests) {
     if (maxRequests < 1) {
       throw new IllegalArgumentException("max < 1: " + maxRequests);
     }
-    this.maxRequests = maxRequests;
-    promoteCalls();
+    synchronized (this) {
+      this.maxRequests = maxRequests;
+    }
+    promoteAndExecute();
   }
 
   public synchronized int getMaxRequests() {
@@ -98,12 +100,14 @@ public synchronized int getMaxRequests() {
    *
    * <p>WebSocket connections to hosts <b>do not</b> count against this limit.
    */
-  public synchronized void setMaxRequestsPerHost(int maxRequestsPerHost) {
+  public void setMaxRequestsPerHost(int maxRequestsPerHost) {
     if (maxRequestsPerHost < 1) {
       throw new IllegalArgumentException("max < 1: " + maxRequestsPerHost);
     }
-    this.maxRequestsPerHost = maxRequestsPerHost;
-    promoteCalls();
+    synchronized (this) {
+      this.maxRequestsPerHost = maxRequestsPerHost;
+    }
+    promoteAndExecute();
   }
 
   public synchronized int getMaxRequestsPerHost() {
@@ -126,13 +130,11 @@ public synchronized void setIdleCallback(@Nullable Runnable idleCallback) {
     this.idleCallback = idleCallback;
   }
 
-  synchronized void enqueue(AsyncCall call) {
-    if (runningAsyncCalls.size() < maxRequests && runningCallsForHost(call) < maxRequestsPerHost) {
-      runningAsyncCalls.add(call);
-      executorService().execute(call);
-    } else {
+  void enqueue(AsyncCall call) {
+    synchronized (this) {
       readyAsyncCalls.add(call);
     }
+    promoteAndExecute();
   }
 
   /**
@@ -153,21 +155,38 @@ public synchronized void cancelAll() {
     }
   }
 
-  private void promoteCalls() {
-    if (runningAsyncCalls.size() >= maxRequests) return; // Already running max capacity.
-    if (readyAsyncCalls.isEmpty()) return; // No ready calls to promote.
+  /**
+   * Promotes eligible calls from {@link #readyAsyncCalls} to {@link #runningAsyncCalls} and runs
+   * them on the executor service. Must not be called with synchronization because executing calls
+   * can call into user code.
+   *
+   * @return true if the dispatcher is currently running calls.
+   */
+  private boolean promoteAndExecute() {
+    assert (!Thread.holdsLock(this));
+
+    List<AsyncCall> executableCalls = new ArrayList<>();
+    boolean isRunning;
+    synchronized (this) {
+      for (Iterator<AsyncCall> i = readyAsyncCalls.iterator(); i.hasNext(); ) {
+        AsyncCall asyncCall = i.next();
 
-    for (Iterator<AsyncCall> i = readyAsyncCalls.iterator(); i.hasNext(); ) {
-      AsyncCall call = i.next();
+        if (runningAsyncCalls.size() >= maxRequests) break; // Max capacity.
+        if (runningCallsForHost(asyncCall) >= maxRequestsPerHost) continue; // Host max capacity.
 
-      if (runningCallsForHost(call) < maxRequestsPerHost) {
         i.remove();
-        runningAsyncCalls.add(call);
-        executorService().execute(call);
+        executableCalls.add(asyncCall);
+        runningAsyncCalls.add(asyncCall);
       }
+      isRunning = runningCallsCount() > 0;
+    }
 
-      if (runningAsyncCalls.size() >= maxRequests) return; // Reached max capacity.
+    for (int i = 0, size = executableCalls.size(); i < size; i++) {
+      AsyncCall asyncCall = executableCalls.get(i);
+      asyncCall.executeOn(executorService());
     }
+
+    return isRunning;
   }
 
   /** Returns the number of running calls that share a host with {@code call}. */
@@ -187,25 +206,24 @@ synchronized void executed(RealCall call) {
 
   /** Used by {@code AsyncCall#run} to signal completion. */
   void finished(AsyncCall call) {
-    finished(runningAsyncCalls, call, true);
+    finished(runningAsyncCalls, call);
   }
 
   /** Used by {@code Call#execute} to signal completion. */
   void finished(RealCall call) {
-    finished(runningSyncCalls, call, false);
+    finished(runningSyncCalls, call);
   }
 
-  private <T> void finished(Deque<T> calls, T call, boolean promoteCalls) {
-    int runningCallsCount;
+  private <T> void finished(Deque<T> calls, T call) {
     Runnable idleCallback;
     synchronized (this) {
       if (!calls.remove(call)) throw new AssertionError("Call wasn't in-flight!");
-      if (promoteCalls) promoteCalls();
-      runningCallsCount = runningCallsCount();
       idleCallback = this.idleCallback;
     }
 
-    if (runningCallsCount == 0 && idleCallback != null) {
+    boolean isRunning = promoteAndExecute();
+
+    if (!isRunning && idleCallback != null) {
       idleCallback.run();
     }
   }
diff --git a/okhttp/src/main/java/okhttp3/Dns.java b/okhttp/src/main/java/okhttp3/Dns.java
index de3b4cb215..feba0db7c9 100644
--- a/okhttp/src/main/java/okhttp3/Dns.java
+++ b/okhttp/src/main/java/okhttp3/Dns.java
@@ -33,17 +33,15 @@
    * A DNS that uses {@link InetAddress#getAllByName} to ask the underlying operating system to
    * lookup IP addresses. Most custom {@link Dns} implementations should delegate to this instance.
    */
-  Dns SYSTEM = new Dns() {
-    @Override public List<InetAddress> lookup(String hostname) throws UnknownHostException {
-      if (hostname == null) throw new UnknownHostException("hostname == null");
-      try {
-        return Arrays.asList(InetAddress.getAllByName(hostname));
-      } catch (NullPointerException e) {
-        UnknownHostException unknownHostException =
-            new UnknownHostException("Broken system behaviour for dns lookup of " + hostname);
-        unknownHostException.initCause(e);
-        throw unknownHostException;
-      }
+  Dns SYSTEM = hostname -> {
+    if (hostname == null) throw new UnknownHostException("hostname == null");
+    try {
+      return Arrays.asList(InetAddress.getAllByName(hostname));
+    } catch (NullPointerException e) {
+      UnknownHostException unknownHostException =
+          new UnknownHostException("Broken system behaviour for dns lookup of " + hostname);
+      unknownHostException.initCause(e);
+      throw unknownHostException;
     }
   };
 
diff --git a/okhttp/src/main/java/okhttp3/EventListener.java b/okhttp/src/main/java/okhttp3/EventListener.java
index fb8d4c7f4a..bdd9f050c5 100644
--- a/okhttp/src/main/java/okhttp3/EventListener.java
+++ b/okhttp/src/main/java/okhttp3/EventListener.java
@@ -53,12 +53,8 @@
   public static final EventListener NONE = new EventListener() {
   };
 
-  static EventListener.Factory factory(final EventListener listener) {
-    return new EventListener.Factory() {
-      public EventListener create(Call call) {
-        return listener;
-      }
-    };
+  static EventListener.Factory factory(EventListener listener) {
+    return call -> listener;
   }
 
   /**
diff --git a/okhttp/src/main/java/okhttp3/FormBody.java b/okhttp/src/main/java/okhttp3/FormBody.java
index d3937834c3..4216daccd5 100644
--- a/okhttp/src/main/java/okhttp3/FormBody.java
+++ b/okhttp/src/main/java/okhttp3/FormBody.java
@@ -105,13 +105,13 @@ private long writeOrCountBytes(@Nullable BufferedSink sink, boolean countBytes)
   public static final class Builder {
     private final List<String> names = new ArrayList<>();
     private final List<String> values = new ArrayList<>();
-    private final Charset charset;
+    private final @Nullable Charset charset;
 
     public Builder() {
       this(null);
     }
 
-    public Builder(Charset charset) {
+    public Builder(@Nullable Charset charset) {
       this.charset = charset;
     }
 
diff --git a/okhttp/src/main/java/okhttp3/Handshake.java b/okhttp/src/main/java/okhttp3/Handshake.java
index fefe3a5728..d2740c8f87 100644
--- a/okhttp/src/main/java/okhttp3/Handshake.java
+++ b/okhttp/src/main/java/okhttp3/Handshake.java
@@ -19,6 +19,7 @@
 import java.security.Principal;
 import java.security.cert.Certificate;
 import java.security.cert.X509Certificate;
+import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 import javax.annotation.Nullable;
@@ -68,12 +69,12 @@ public static Handshake get(SSLSession session) throws IOException {
     }
     List<Certificate> peerCertificatesList = peerCertificates != null
         ? Util.immutableList(peerCertificates)
-        : Collections.<Certificate>emptyList();
+        : Collections.emptyList();
 
     Certificate[] localCertificates = session.getLocalCertificates();
     List<Certificate> localCertificatesList = localCertificates != null
         ? Util.immutableList(localCertificates)
-        : Collections.<Certificate>emptyList();
+        : Collections.emptyList();
 
     return new Handshake(tlsVersion, cipherSuite, peerCertificatesList, localCertificatesList);
   }
@@ -140,4 +141,31 @@ public CipherSuite cipherSuite() {
     result = 31 * result + localCertificates.hashCode();
     return result;
   }
+
+  @Override public String toString() {
+    return "Handshake{"
+        + "tlsVersion="
+        + tlsVersion
+        + " cipherSuite="
+        + cipherSuite
+        + " peerCertificates="
+        + names(peerCertificates)
+        + " localCertificates="
+        + names(localCertificates)
+        + '}';
+  }
+
+  private List<String> names(List<Certificate> certificates) {
+    ArrayList<String> strings = new ArrayList<>();
+
+    for (Certificate cert : certificates) {
+      if (cert instanceof X509Certificate) {
+        strings.add(String.valueOf(((X509Certificate) cert).getSubjectDN()));
+      } else {
+        strings.add(cert.getType());
+      }
+    }
+
+    return strings;
+  }
 }
diff --git a/okhttp/src/main/java/okhttp3/Headers.java b/okhttp/src/main/java/okhttp3/Headers.java
index e8a0def658..06d2a96ccd 100644
--- a/okhttp/src/main/java/okhttp3/Headers.java
+++ b/okhttp/src/main/java/okhttp3/Headers.java
@@ -17,6 +17,7 @@
 
 package okhttp3;
 
+import java.time.Instant;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
@@ -30,6 +31,7 @@
 import javax.annotation.Nullable;
 import okhttp3.internal.Util;
 import okhttp3.internal.http.HttpDate;
+import org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement;
 
 /**
  * The header fields of a single HTTP message. Values are uninterpreted strings; use {@code Request}
@@ -72,6 +74,16 @@ private Headers(String[] namesAndValues) {
     return value != null ? HttpDate.parse(value) : null;
   }
 
+  /**
+   * Returns the last value corresponding to the specified field parsed as an HTTP date, or null if
+   * either the field is absent or cannot be parsed as a date.
+   */
+  @IgnoreJRERequirement
+  public @Nullable Instant getInstant(String name) {
+    Date value = getDate(name);
+    return value != null ? value.toInstant() : null;
+  }
+
   /** Returns the number of field values. */
   public int size() {
     return namesAndValues.length / 2;
@@ -107,7 +119,7 @@ public String value(int index) {
     }
     return result != null
         ? Collections.unmodifiableList(result)
-        : Collections.<String>emptyList();
+        : Collections.emptyList();
   }
 
   /**
@@ -190,7 +202,7 @@ public Builder newBuilder() {
     return result;
   }
 
-  private static String get(String[] namesAndValues, String name) {
+  private static @Nullable String get(String[] namesAndValues, String name) {
     for (int i = namesAndValues.length - 2; i >= 0; i -= 2) {
       if (name.equalsIgnoreCase(namesAndValues[i])) {
         return namesAndValues[i + 1];
@@ -220,9 +232,8 @@ public static Headers of(String... namesAndValues) {
     for (int i = 0; i < namesAndValues.length; i += 2) {
       String name = namesAndValues[i];
       String value = namesAndValues[i + 1];
-      if (name.length() == 0 || name.indexOf('\0') != -1 || value.indexOf('\0') != -1) {
-        throw new IllegalArgumentException("Unexpected header: " + name + ": " + value);
-      }
+      checkName(name);
+      checkValue(value, name);
     }
 
     return new Headers(namesAndValues);
@@ -243,9 +254,8 @@ public static Headers of(Map<String, String> headers) {
       }
       String name = header.getKey().trim();
       String value = header.getValue().trim();
-      if (name.length() == 0 || name.indexOf('\0') != -1 || value.indexOf('\0') != -1) {
-        throw new IllegalArgumentException("Unexpected header: " + name + ": " + value);
-      }
+      checkName(name);
+      checkValue(value, name);
       namesAndValues[i] = name;
       namesAndValues[i + 1] = value;
       i += 2;
@@ -254,6 +264,29 @@ public static Headers of(Map<String, String> headers) {
     return new Headers(namesAndValues);
   }
 
+  static void checkName(String name) {
+    if (name == null) throw new NullPointerException("name == null");
+    if (name.isEmpty()) throw new IllegalArgumentException("name is empty");
+    for (int i = 0, length = name.length(); i < length; i++) {
+      char c = name.charAt(i);
+      if (c <= '\u0020' || c >= '\u007f') {
+        throw new IllegalArgumentException(Util.format(
+            "Unexpected char %#04x at %d in header name: %s", (int) c, i, name));
+      }
+    }
+  }
+
+  static void checkValue(String value, String name) {
+    if (value == null) throw new NullPointerException("value for name " + name + " == null");
+    for (int i = 0, length = value.length(); i < length; i++) {
+      char c = value.charAt(i);
+      if ((c <= '\u001f' && c != '\t') || c >= '\u007f') {
+        throw new IllegalArgumentException(Util.format(
+            "Unexpected char %#04x at %d in %s value: %s", (int) c, i, name, value));
+      }
+    }
+  }
+
   public static final class Builder {
     final List<String> namesAndValues = new ArrayList<>(20);
 
@@ -287,7 +320,17 @@ public Builder add(String line) {
      * Add a header with the specified name and value. Does validation of header names and values.
      */
     public Builder add(String name, String value) {
-      checkNameAndValue(name, value);
+      checkName(name);
+      checkValue(value, name);
+      return addLenient(name, value);
+    }
+
+    /**
+     * Add a header with the specified name and value. Does validation of header names, allowing
+     * non-ASCII values.
+     */
+    public Builder addUnsafeNonAscii(String name, String value) {
+      checkName(name);
       return addLenient(name, value);
     }
 
@@ -295,14 +338,53 @@ public Builder add(String name, String value) {
      * Adds all headers from an existing collection.
      */
     public Builder addAll(Headers headers) {
-      int size = headers.size();
-      for (int i = 0; i < size; i++) {
+      for (int i = 0, size = headers.size(); i < size; i++) {
         addLenient(headers.name(i), headers.value(i));
       }
 
       return this;
     }
 
+    /**
+     * Add a header with the specified name and formatted date. Does validation of header names and
+     * value.
+     */
+    public Builder add(String name, Date value) {
+      if (value == null) throw new NullPointerException("value for name " + name + " == null");
+      add(name, HttpDate.format(value));
+      return this;
+    }
+
+    /**
+     * Add a header with the specified name and formatted instant. Does validation of header names
+     * and value.
+     */
+    @IgnoreJRERequirement
+    public Builder add(String name, Instant value) {
+      if (value == null) throw new NullPointerException("value for name " + name + " == null");
+      return add(name, new Date(value.toEpochMilli()));
+    }
+
+    /**
+     * Set a field with the specified date. If the field is not found, it is added. If the field is
+     * found, the existing values are replaced.
+     */
+    public Builder set(String name, Date value) {
+      if (value == null) throw new NullPointerException("value for name " + name + " == null");
+      set(name, HttpDate.format(value));
+      return this;
+    }
+
+    /**
+     * Set a field with the specified instant. If the field is not found, it is added. If the field
+     * is found, the existing values are replaced.
+     */
+    @IgnoreJRERequirement
+    public Builder set(String name, Instant value) {
+      if (value == null) throw new NullPointerException("value for name " + name + " == null");
+      return set(name, new Date(value.toEpochMilli()));
+    }
+
     /**
      * Add a field with the specified value without any validation. Only appropriate for headers
      * from the remote peer or cache.
@@ -329,34 +411,15 @@ public Builder removeAll(String name) {
      * found, the existing values are replaced.
      */
     public Builder set(String name, String value) {
-      checkNameAndValue(name, value);
+      checkName(name);
+      checkValue(value, name);
       removeAll(name);
       addLenient(name, value);
       return this;
     }
 
-    private void checkNameAndValue(String name, String value) {
-      if (name == null) throw new NullPointerException("name == null");
-      if (name.isEmpty()) throw new IllegalArgumentException("name is empty");
-      for (int i = 0, length = name.length(); i < length; i++) {
-        char c = name.charAt(i);
-        if (c <= '\u0020' || c >= '\u007f') {
-          throw new IllegalArgumentException(Util.format(
-              "Unexpected char %#04x at %d in header name: %s", (int) c, i, name));
-        }
-      }
-      if (value == null) throw new NullPointerException("value for name " + name + " == null");
-      for (int i = 0, length = value.length(); i < length; i++) {
-        char c = value.charAt(i);
-        if ((c <= '\u001f' && c != '\t') || c >= '\u007f') {
-          throw new IllegalArgumentException(Util.format(
-              "Unexpected char %#04x at %d in %s value: %s", (int) c, i, name, value));
-        }
-      }
-    }
-
     /** Equivalent to {@code build().get(name)}, but potentially faster. */
-    public String get(String name) {
+    public @Nullable String get(String name) {
       for (int i = namesAndValues.size() - 2; i >= 0; i -= 2) {
         if (name.equalsIgnoreCase(namesAndValues.get(i))) {
           return namesAndValues.get(i + 1);
diff --git a/okhttp/src/main/java/okhttp3/HttpUrl.java b/okhttp/src/main/java/okhttp3/HttpUrl.java
index f88dfb6eb3..26125e306d 100644
--- a/okhttp/src/main/java/okhttp3/HttpUrl.java
+++ b/okhttp/src/main/java/okhttp3/HttpUrl.java
@@ -31,6 +31,7 @@
 import okhttp3.internal.publicsuffix.PublicSuffixDatabase;
 import okio.Buffer;
 
+import static java.nio.charset.StandardCharsets.UTF_8;
 import static okhttp3.internal.Util.decodeHexDigit;
 import static okhttp3.internal.Util.delimiterOffset;
 import static okhttp3.internal.Util.skipLeadingAsciiWhitespace;
@@ -1087,9 +1088,8 @@ private Builder addPathSegments(String pathSegments, boolean alreadyEncoded) {
 
     public Builder setPathSegment(int index, String pathSegment) {
       if (pathSegment == null) throw new NullPointerException("pathSegment == null");
-      String canonicalPathSegment = canonicalize(
-          pathSegment, 0, pathSegment.length(), PATH_SEGMENT_ENCODE_SET, false, false, false, true,
-              null);
+      String canonicalPathSegment = canonicalize(pathSegment, 0, pathSegment.length(),
+          PATH_SEGMENT_ENCODE_SET, false, false, false, true, null);
       if (isDot(canonicalPathSegment) || isDotDot(canonicalPathSegment)) {
         throw new IllegalArgumentException("unexpected path segment: " + pathSegment);
       }
@@ -1101,9 +1101,8 @@ public Builder setEncodedPathSegment(int index, String encodedPathSegment) {
       if (encodedPathSegment == null) {
         throw new NullPointerException("encodedPathSegment == null");
       }
-      String canonicalPathSegment = canonicalize(encodedPathSegment,
-          0, encodedPathSegment.length(), PATH_SEGMENT_ENCODE_SET, true, false, false, true,
-          null);
+      String canonicalPathSegment = canonicalize(encodedPathSegment, 0, encodedPathSegment.length(),
+          PATH_SEGMENT_ENCODE_SET, true, false, false, true, null);
       encodedPathSegments.set(index, canonicalPathSegment);
       if (isDot(canonicalPathSegment) || isDotDot(canonicalPathSegment)) {
         throw new IllegalArgumentException("unexpected path segment: " + encodedPathSegment);
@@ -1258,8 +1257,12 @@ public HttpUrl build() {
 
     @Override public String toString() {
       StringBuilder result = new StringBuilder();
-      result.append(scheme);
-      result.append("://");
+      if (scheme != null) {
+        result.append(scheme);
+        result.append("://");
+      } else {
+        result.append("//");
+      }
 
       if (!encodedUsername.isEmpty() || !encodedPassword.isEmpty()) {
         result.append(encodedUsername);
@@ -1270,19 +1273,23 @@ public HttpUrl build() {
         result.append('@');
       }
 
-      if (host.indexOf(':') != -1) {
-        // Host is an IPv6 address.
-        result.append('[');
-        result.append(host);
-        result.append(']');
-      } else {
-        result.append(host);
+      if (host != null) {
+        if (host.indexOf(':') != -1) {
+          // Host is an IPv6 address.
+          result.append('[');
+          result.append(host);
+          result.append(']');
+        } else {
+          result.append(host);
+        }
       }
 
-      int effectivePort = effectivePort();
-      if (effectivePort != defaultPort(scheme)) {
-        result.append(':');
-        result.append(effectivePort);
+      if (port != -1 || scheme != null) {
+        int effectivePort = effectivePort();
+        if (scheme == null || effectivePort != defaultPort(scheme)) {
+          result.append(':');
+          result.append(effectivePort);
+        }
       }
 
       pathSegmentsToString(result, encodedPathSegments);
@@ -1353,9 +1360,8 @@ Builder parse(@Nullable HttpUrl base, String input) {
               if (!hasPassword) {
                 int passwordColonOffset = delimiterOffset(
                     input, pos, componentDelimiterOffset, ':');
-                String canonicalUsername = canonicalize(
-                    input, pos, passwordColonOffset, USERNAME_ENCODE_SET, true, false, false, true,
-                    null);
+                String canonicalUsername = canonicalize(input, pos, passwordColonOffset,
+                    USERNAME_ENCODE_SET, true, false, false, true, null);
                 this.encodedUsername = hasUsername
                     ? this.encodedUsername + "%40" + canonicalUsername
                     : canonicalUsername;
@@ -1368,8 +1374,7 @@ Builder parse(@Nullable HttpUrl base, String input) {
                 hasUsername = true;
               } else {
                 this.encodedPassword = this.encodedPassword + "%40" + canonicalize(input, pos,
-                    componentDelimiterOffset, PASSWORD_ENCODE_SET, true, false, false, true,
-                    null);
+                    componentDelimiterOffset, PASSWORD_ENCODE_SET, true, false, false, true, null);
               }
               pos = componentDelimiterOffset + 1;
               break;
@@ -1577,7 +1582,7 @@ private static int portColonOffset(String input, int pos, int limit) {
       return limit; // No colon.
     }
 
-    private static String canonicalizeHost(String input, int pos, int limit) {
+    private static @Nullable String canonicalizeHost(String input, int pos, int limit) {
       // Start by percent decoding the host. The WHATWG spec suggests doing this only after we've
       // checked for IPv6 square braces. But Chrome does it first, and that's more lenient.
       String percentDecoded = percentDecode(input, pos, limit, false);
@@ -1673,7 +1678,7 @@ static boolean percentEncoded(String encoded, int pos, int limit) {
    */
   static String canonicalize(String input, int pos, int limit, String encodeSet,
       boolean alreadyEncoded, boolean strict, boolean plusIsSpace, boolean asciiOnly,
-      Charset charset) {
+      @Nullable Charset charset) {
     int codePoint;
     for (int i = pos; i < limit; i += Character.charCount(codePoint)) {
       codePoint = input.codePointAt(i);
@@ -1698,7 +1703,7 @@ static String canonicalize(String input, int pos, int limit, String encodeSet,
 
   static void canonicalize(Buffer out, String input, int pos, int limit, String encodeSet,
       boolean alreadyEncoded, boolean strict, boolean plusIsSpace, boolean asciiOnly,
-      Charset charset) {
+      @Nullable Charset charset) {
     Buffer encodedCharBuffer = null; // Lazily allocated.
     int codePoint;
     for (int i = pos; i < limit; i += Character.charCount(codePoint)) {
@@ -1719,7 +1724,7 @@ static void canonicalize(Buffer out, String input, int pos, int limit, String en
           encodedCharBuffer = new Buffer();
         }
 
-        if (charset == null || charset.equals(Util.UTF_8)) {
+        if (charset == null || charset.equals(UTF_8)) {
           encodedCharBuffer.writeUtf8CodePoint(codePoint);
         } else {
           encodedCharBuffer.writeString(input, i, i + Character.charCount(codePoint), charset);
@@ -1739,10 +1744,9 @@ static void canonicalize(Buffer out, String input, int pos, int limit, String en
   }
 
   static String canonicalize(String input, String encodeSet, boolean alreadyEncoded, boolean strict,
-      boolean plusIsSpace, boolean asciiOnly, Charset charset) {
-    return canonicalize(
-        input, 0, input.length(), encodeSet, alreadyEncoded, strict, plusIsSpace, asciiOnly,
-            charset);
+      boolean plusIsSpace, boolean asciiOnly, @Nullable Charset charset) {
+    return canonicalize(input, 0, input.length(), encodeSet, alreadyEncoded, strict, plusIsSpace,
+        asciiOnly, charset);
   }
 
   static String canonicalize(String input, String encodeSet, boolean alreadyEncoded, boolean strict,
diff --git a/okhttp/src/main/java/okhttp3/MultipartBody.java b/okhttp/src/main/java/okhttp3/MultipartBody.java
index 800064cfb5..e5e6eaa17f 100644
--- a/okhttp/src/main/java/okhttp3/MultipartBody.java
+++ b/okhttp/src/main/java/okhttp3/MultipartBody.java
@@ -199,7 +199,7 @@ private long writeOrCountBytes(
    * want to have a good chance of things working, please avoid double-quotes, newlines, percent
    * signs, and the like in your field names.
    */
-  static StringBuilder appendQuotedString(StringBuilder target, String key) {
+  static void appendQuotedString(StringBuilder target, String key) {
     target.append('"');
     for (int i = 0, len = key.length(); i < len; i++) {
       char ch = key.charAt(i);
@@ -219,7 +219,6 @@ static StringBuilder appendQuotedString(StringBuilder target, String key) {
       }
     }
     target.append('"');
-    return target;
   }
 
   public static final class Part {
diff --git a/okhttp/src/main/java/okhttp3/OkHttpClient.java b/okhttp/src/main/java/okhttp3/OkHttpClient.java
index afb388a748..433982e136 100644
--- a/okhttp/src/main/java/okhttp3/OkHttpClient.java
+++ b/okhttp/src/main/java/okhttp3/OkHttpClient.java
@@ -15,10 +15,12 @@
  */
 package okhttp3;
 
+import java.io.IOException;
 import java.net.Proxy;
 import java.net.ProxySelector;
 import java.net.Socket;
 import java.security.GeneralSecurityException;
+import java.time.Duration;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
@@ -39,14 +41,16 @@
 import okhttp3.internal.connection.RealConnection;
 import okhttp3.internal.connection.RouteDatabase;
 import okhttp3.internal.connection.StreamAllocation;
+import okhttp3.internal.http.HttpCodec;
 import okhttp3.internal.platform.Platform;
+import okhttp3.internal.proxy.NullProxySelector;
 import okhttp3.internal.tls.CertificateChainCleaner;
 import okhttp3.internal.tls.OkHostnameVerifier;
 import okhttp3.internal.ws.RealWebSocket;
 import okio.Sink;
 import okio.Source;
+import org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement;
 
-import static okhttp3.internal.Util.assertionError;
 import static okhttp3.internal.Util.checkDuration;
 
 /**
@@ -145,16 +149,16 @@
         return pool.connectionBecameIdle(connection);
       }
 
-      @Override public RealConnection get(ConnectionPool pool, Address address,
-          StreamAllocation streamAllocation, Route route) {
-        return pool.get(address, streamAllocation, route);
+      @Override public void acquire(ConnectionPool pool, Address address,
+          StreamAllocation streamAllocation, @Nullable Route route) {
+        pool.acquire(address, streamAllocation, route);
       }
 
       @Override public boolean equalsNonHost(Address a, Address b) {
         return a.equalsNonHost(b);
       }
 
-      @Override public Socket deduplicate(
+      @Override public @Nullable Socket deduplicate(
           ConnectionPool pool, Address address, StreamAllocation streamAllocation) {
         return pool.deduplicate(address, streamAllocation);
       }
@@ -184,9 +188,17 @@ public void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket, boolean
         return ((RealCall) call).streamAllocation();
       }
 
+      @Override public @Nullable IOException timeoutExit(Call call, @Nullable IOException e) {
+        return ((RealCall) call).timeoutExit(e);
+      }
+
       @Override public Call newWebSocketCall(OkHttpClient client, Request originalRequest) {
         return RealCall.newRealCall(client, originalRequest, true);
       }
+
+      @Override public void initCodec(Response.Builder responseBuilder, HttpCodec httpCodec) {
+        responseBuilder.initCodec(httpCodec);
+      }
     };
   }
 
@@ -213,6 +225,7 @@ public void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket, boolean
   final boolean followSslRedirects;
   final boolean followRedirects;
   final boolean retryOnConnectionFailure;
+  final int callTimeout;
   final int connectTimeout;
   final int readTimeout;
   final int writeTimeout;
@@ -264,6 +277,7 @@ public OkHttpClient() {
     this.followSslRedirects = builder.followSslRedirects;
     this.followRedirects = builder.followRedirects;
     this.retryOnConnectionFailure = builder.retryOnConnectionFailure;
+    this.callTimeout = builder.callTimeout;
     this.connectTimeout = builder.connectTimeout;
     this.readTimeout = builder.readTimeout;
     this.writeTimeout = builder.writeTimeout;
@@ -283,26 +297,34 @@ private static SSLSocketFactory newSslSocketFactory(X509TrustManager trustManage
       sslContext.init(null, new TrustManager[] { trustManager }, null);
       return sslContext.getSocketFactory();
     } catch (GeneralSecurityException e) {
-      throw assertionError("No System TLS", e); // The system has no TLS. Just give up.
+      throw new AssertionError("No System TLS", e); // The system has no TLS. Just give up.
     }
   }
 
-  /** Default connect timeout (in milliseconds). */
+  /**
+   * Default call timeout (in milliseconds). By default there is no timeout for complete calls, but
+   * there is for the connect, write, and read actions within a call.
+   */
+  public int callTimeoutMillis() {
+    return callTimeout;
+  }
+
+  /** Default connect timeout (in milliseconds). The default is 10 seconds. */
   public int connectTimeoutMillis() {
     return connectTimeout;
   }
 
-  /** Default read timeout (in milliseconds). */
+  /** Default read timeout (in milliseconds). The default is 10 seconds. */
   public int readTimeoutMillis() {
     return readTimeout;
   }
 
-  /** Default write timeout (in milliseconds). */
+  /** Default write timeout (in milliseconds). The default is 10 seconds. */
   public int writeTimeoutMillis() {
     return writeTimeout;
   }
 
-  /** Web socket ping interval (in milliseconds). */
+  /** Web socket and HTTP/2 ping interval (in milliseconds). By default pings are not sent. */
   public int pingIntervalMillis() {
     return pingInterval;
   }
@@ -323,7 +345,7 @@ public CookieJar cookieJar() {
     return cache;
   }
 
-  InternalCache internalCache() {
+  @Nullable InternalCache internalCache() {
     return cache != null ? cache.internalCache : internalCache;
   }
 
@@ -449,6 +471,7 @@ public Builder newBuilder() {
     boolean followSslRedirects;
     boolean followRedirects;
     boolean retryOnConnectionFailure;
+    int callTimeout;
     int connectTimeout;
     int readTimeout;
     int writeTimeout;
@@ -460,6 +483,9 @@ public Builder() {
       connectionSpecs = DEFAULT_CONNECTION_SPECS;
       eventListenerFactory = EventListener.factory(EventListener.NONE);
       proxySelector = ProxySelector.getDefault();
+      if (proxySelector == null) {
+        proxySelector = new NullProxySelector();
+      }
       cookieJar = CookieJar.NO_COOKIES;
       socketFactory = SocketFactory.getDefault();
       hostnameVerifier = OkHostnameVerifier.INSTANCE;
@@ -471,6 +497,7 @@ public Builder() {
       followSslRedirects = true;
       followRedirects = true;
       retryOnConnectionFailure = true;
+      callTimeout = 0;
       connectTimeout = 10_000;
       readTimeout = 10_000;
       writeTimeout = 10_000;
@@ -501,18 +528,50 @@ public Builder() {
       this.followSslRedirects = okHttpClient.followSslRedirects;
       this.followRedirects = okHttpClient.followRedirects;
       this.retryOnConnectionFailure = okHttpClient.retryOnConnectionFailure;
+      this.callTimeout = okHttpClient.callTimeout;
       this.connectTimeout = okHttpClient.connectTimeout;
       this.readTimeout = okHttpClient.readTimeout;
       this.writeTimeout = okHttpClient.writeTimeout;
       this.pingInterval = okHttpClient.pingInterval;
     }
 
+    /**
+     * Sets the default timeout for complete calls. A value of 0 means no timeout, otherwise values
+     * must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
+     *
+     * <p>The call timeout spans the entire call: resolving DNS, connecting, writing the request
+     * body, server processing, and reading the response body. If the call requires redirects or
+     * retries all must complete within one timeout period.
+     *
+     * <p>The default value is 0 which imposes no timeout.
+     */
+    public Builder callTimeout(long timeout, TimeUnit unit) {
+      callTimeout = checkDuration("timeout", timeout, unit);
+      return this;
+    }
+
+    /**
+     * Sets the default timeout for complete calls. A value of 0 means no timeout, otherwise values
+     * must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
+     *
+     * <p>The call timeout spans the entire call: resolving DNS, connecting, writing the request
+     * body, server processing, and reading the response body. If the call requires redirects or
+     * retries all must complete within one timeout period.
+     *
+     * <p>The default value is 0 which imposes no timeout.
+     */
+    @IgnoreJRERequirement
+    public Builder callTimeout(Duration duration) {
+      callTimeout = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS);
+      return this;
+    }
+
     /**
      * Sets the default connect timeout for new connections. A value of 0 means no timeout,
      * otherwise values must be between 1 and {@link Integer#MAX_VALUE} when converted to
      * milliseconds.
      *
-     * <p>The connectTimeout is applied when connecting a TCP socket to the target host.
+     * <p>The connect timeout is applied when connecting a TCP socket to the target host.
      * The default value is 10 seconds.
      */
     public Builder connectTimeout(long timeout, TimeUnit unit) {
@@ -520,6 +579,20 @@ public Builder connectTimeout(long timeout, TimeUnit unit) {
       return this;
     }
 
+    /**
+     * Sets the default connect timeout for new connections. A value of 0 means no timeout,
+     * otherwise values must be between 1 and {@link Integer#MAX_VALUE} when converted to
+     * milliseconds.
+     *
+     * <p>The connect timeout is applied when connecting a TCP socket to the target host.
+     * The default value is 10 seconds.
+     */
+    @IgnoreJRERequirement
+    public Builder connectTimeout(Duration duration) {
+      connectTimeout = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS);
+      return this;
+    }
+
     /**
      * Sets the default read timeout for new connections. A value of 0 means no timeout, otherwise
      * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
@@ -535,6 +608,22 @@ public Builder readTimeout(long timeout, TimeUnit unit) {
       return this;
     }
 
+    /**
+     * Sets the default read timeout for new connections. A value of 0 means no timeout, otherwise
+     * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
+     *
+     * <p>The read timeout is applied to both the TCP socket and for individual read IO operations
+     * including on {@link Source} of the {@link Response}. The default value is 10 seconds.
+     *
+     * @see Socket#setSoTimeout(int)
+     * @see Source#timeout()
+     */
+    @IgnoreJRERequirement
+    public Builder readTimeout(Duration duration) {
+      readTimeout = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS);
+      return this;
+    }
+
     /**
      * Sets the default write timeout for new connections. A value of 0 means no timeout, otherwise
      * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
@@ -549,6 +638,21 @@ public Builder writeTimeout(long timeout, TimeUnit unit) {
       return this;
     }
 
+    /**
+     * Sets the default write timeout for new connections. A value of 0 means no timeout, otherwise
+     * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
+     *
+     * <p>The write timeout is applied for individual write IO operations.
+     * The default value is 10 seconds.
+     *
+     * @see Sink#timeout()
+     */
+    @IgnoreJRERequirement
+    public Builder writeTimeout(Duration duration) {
+      writeTimeout = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS);
+      return this;
+    }
+
     /**
      * Sets the interval between HTTP/2 and web socket pings initiated by this client. Use this to
      * automatically send ping frames until either the connection fails or it is closed. This keeps
@@ -567,6 +671,25 @@ public Builder pingInterval(long interval, TimeUnit unit) {
       return this;
     }
 
+    /**
+     * Sets the interval between HTTP/2 and web socket pings initiated by this client. Use this to
+     * automatically send ping frames until either the connection fails or it is closed. This keeps
+     * the connection alive and may detect connectivity failures.
+     *
+     * <p>If the server does not respond to each ping with a pong within {@code interval}, this
+     * client will assume that connectivity has been lost. When this happens on a web socket the
+     * connection is canceled and its listener is {@linkplain WebSocketListener#onFailure notified
+     * of the failure}. When it happens on an HTTP/2 connection the connection is closed and any
+     * calls it is carrying {@linkplain java.io.IOException will fail with an IOException}.
+     *
+     * <p>The default value of 0 disables client-initiated pings.
+     */
+    @IgnoreJRERequirement
+    public Builder pingInterval(Duration duration) {
+      pingInterval = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS);
+      return this;
+    }
+
     /**
      * Sets the HTTP proxy that will be used by connections created by this client. This takes
      * precedence over {@link #proxySelector}, which is only honored when this proxy is null (which
@@ -637,6 +760,9 @@ public Builder dns(Dns dns) {
      */
     public Builder socketFactory(SocketFactory socketFactory) {
       if (socketFactory == null) throw new NullPointerException("socketFactory == null");
+      if (socketFactory instanceof SSLSocketFactory) {
+        throw new IllegalArgumentException("socketFactory instanceof SSLSocketFactory");
+      }
       this.socketFactory = socketFactory;
       return this;
     }
diff --git a/okhttp/src/main/java/okhttp3/RealCall.java b/okhttp/src/main/java/okhttp3/RealCall.java
index 808b3dc7ba..dd155e74f5 100644
--- a/okhttp/src/main/java/okhttp3/RealCall.java
+++ b/okhttp/src/main/java/okhttp3/RealCall.java
@@ -16,8 +16,12 @@
 package okhttp3;
 
 import java.io.IOException;
+import java.io.InterruptedIOException;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.RejectedExecutionException;
+import javax.annotation.Nullable;
 import okhttp3.internal.NamedRunnable;
 import okhttp3.internal.cache.CacheInterceptor;
 import okhttp3.internal.connection.ConnectInterceptor;
@@ -27,18 +31,22 @@
 import okhttp3.internal.http.RealInterceptorChain;
 import okhttp3.internal.http.RetryAndFollowUpInterceptor;
 import okhttp3.internal.platform.Platform;
+import okio.AsyncTimeout;
+import okio.Timeout;
 
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static okhttp3.internal.platform.Platform.INFO;
 
 final class RealCall implements Call {
   final OkHttpClient client;
   final RetryAndFollowUpInterceptor retryAndFollowUpInterceptor;
+  final AsyncTimeout timeout;
 
   /**
    * There is a cycle between the {@link Call} and {@link EventListener} that makes this awkward.
    * This will be set after we create the call instance then create the event listener instance.
    */
-  private EventListener eventListener;
+  private @Nullable EventListener eventListener;
 
   /** The application's original request unadulterated by redirects or auth headers. */
   final Request originalRequest;
@@ -51,7 +59,13 @@ private RealCall(OkHttpClient client, Request originalRequest, boolean forWebSoc
     this.client = client;
     this.originalRequest = originalRequest;
     this.forWebSocket = forWebSocket;
-    this.retryAndFollowUpInterceptor = new RetryAndFollowUpInterceptor(client, forWebSocket);
+    this.retryAndFollowUpInterceptor = new RetryAndFollowUpInterceptor(client);
+    this.timeout = new AsyncTimeout() {
+      @Override protected void timedOut() {
+        cancel();
+      }
+    };
+    this.timeout.timeout(client.callTimeoutMillis(), MILLISECONDS);
   }
 
   static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {
@@ -71,6 +85,7 @@ static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolea
       executed = true;
     }
     captureCallStackTrace();
+    timeout.enter();
     eventListener.callStart(this);
     try {
       client.dispatcher().executed(this);
@@ -78,6 +93,7 @@ static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolea
       if (result == null) throw new IOException("Canceled");
       return result;
     } catch (IOException e) {
+      e = timeoutExit(e);
       eventListener.callFailed(this, e);
       throw e;
     } finally {
@@ -85,6 +101,16 @@ static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolea
     }
   }
 
+  @Nullable IOException timeoutExit(@Nullable IOException cause) {
+    if (!timeout.exit()) return cause;
+
+    InterruptedIOException e = new InterruptedIOException("timeout");
+    if (cause != null) {
+      e.initCause(cause);
+    }
+    return e;
+  }
+
   private void captureCallStackTrace() {
     Object callStackTrace = Platform.get().getStackTraceForCloseable("response.body().close()");
     retryAndFollowUpInterceptor.setCallStackTrace(callStackTrace);
@@ -104,6 +130,10 @@ private void captureCallStackTrace() {
     retryAndFollowUpInterceptor.cancel();
   }
 
+  @Override public Timeout timeout() {
+    return timeout;
+  }
+
   @Override public synchronized boolean isExecuted() {
     return executed;
   }
@@ -141,8 +171,31 @@ RealCall get() {
       return RealCall.this;
     }
 
+    /**
+     * Attempt to enqueue this async call on {@code executorService}. This will attempt to clean up
+     * if the executor has been shut down by reporting the call as failed.
+     */
+    void executeOn(ExecutorService executorService) {
+      assert (!Thread.holdsLock(client.dispatcher()));
+      boolean success = false;
+      try {
+        executorService.execute(this);
+        success = true;
+      } catch (RejectedExecutionException e) {
+        InterruptedIOException ioException = new InterruptedIOException("executor rejected");
+        ioException.initCause(e);
+        eventListener.callFailed(RealCall.this, ioException);
+        responseCallback.onFailure(RealCall.this, ioException);
+      } finally {
+        if (!success) {
+          client.dispatcher().finished(this); // This call is no longer running!
+        }
+      }
+    }
+
     @Override protected void execute() {
       boolean signalledCallback = false;
+      timeout.enter();
       try {
         Response response = getResponseWithInterceptorChain();
         if (retryAndFollowUpInterceptor.isCanceled()) {
@@ -153,6 +206,7 @@ RealCall get() {
           responseCallback.onResponse(RealCall.this, response);
         }
       } catch (IOException e) {
+        e = timeoutExit(e);
         if (signalledCallback) {
           // Do not signal the callback twice!
           Platform.get().log(INFO, "Callback failure for " + toLoggableString(), e);
diff --git a/okhttp/src/main/java/okhttp3/Request.java b/okhttp/src/main/java/okhttp3/Request.java
index 7ffb00c1a5..9bbdc86407 100644
--- a/okhttp/src/main/java/okhttp3/Request.java
+++ b/okhttp/src/main/java/okhttp3/Request.java
@@ -35,7 +35,7 @@
   final @Nullable RequestBody body;
   final Map<Class<?>, Object> tags;
 
-  private volatile CacheControl cacheControl; // Lazily initialized.
+  private volatile @Nullable CacheControl cacheControl; // Lazily initialized.
 
   Request(Builder builder) {
     this.url = builder.url;
@@ -117,10 +117,10 @@ public boolean isHttps() {
   }
 
   public static class Builder {
-    HttpUrl url;
+    @Nullable HttpUrl url;
     String method;
     Headers.Builder headers;
-    RequestBody body;
+    @Nullable RequestBody body;
 
     /** A mutable map of tags, or an immutable empty map if we don't have any. */
     Map<Class<?>, Object> tags = Collections.emptyMap();
@@ -135,7 +135,7 @@ public Builder() {
       this.method = request.method;
       this.body = request.body;
       this.tags = request.tags.isEmpty()
-          ? Collections.<Class<?>, Object>emptyMap()
+          ? Collections.emptyMap()
           : new LinkedHashMap<>(request.tags);
       this.headers = request.headers.newBuilder();
     }
diff --git a/okhttp/src/main/java/okhttp3/RequestBody.java b/okhttp/src/main/java/okhttp3/RequestBody.java
index 3cb29477d3..c0279f3081 100644
--- a/okhttp/src/main/java/okhttp3/RequestBody.java
+++ b/okhttp/src/main/java/okhttp3/RequestBody.java
@@ -25,6 +25,8 @@
 import okio.Okio;
 import okio.Source;
 
+import static java.nio.charset.StandardCharsets.UTF_8;
+
 public abstract class RequestBody {
   /** Returns the Content-Type header for this body. */
   public abstract @Nullable MediaType contentType();
@@ -45,11 +47,11 @@ public long contentLength() throws IOException {
    * and lacks a charset, this will use UTF-8.
    */
   public static RequestBody create(@Nullable MediaType contentType, String content) {
-    Charset charset = Util.UTF_8;
+    Charset charset = UTF_8;
     if (contentType != null) {
       charset = contentType.charset();
       if (charset == null) {
-        charset = Util.UTF_8;
+        charset = UTF_8;
         contentType = MediaType.parse(contentType + "; charset=utf-8");
       }
     }
@@ -102,7 +104,7 @@ public static RequestBody create(final @Nullable MediaType contentType, final by
 
   /** Returns a new request body that transmits the content of {@code file}. */
   public static RequestBody create(final @Nullable MediaType contentType, final File file) {
-    if (file == null) throw new NullPointerException("content == null");
+    if (file == null) throw new NullPointerException("file == null");
 
     return new RequestBody() {
       @Override public @Nullable MediaType contentType() {
@@ -114,12 +116,8 @@ public static RequestBody create(final @Nullable MediaType contentType, final Fi
       }
 
       @Override public void writeTo(BufferedSink sink) throws IOException {
-        Source source = null;
-        try {
-          source = Okio.source(file);
+        try (Source source = Okio.source(file)) {
           sink.writeAll(source);
-        } finally {
-          Util.closeQuietly(source);
         }
       }
     };
diff --git a/okhttp/src/main/java/okhttp3/Response.java b/okhttp/src/main/java/okhttp3/Response.java
index b36ea85c6a..b58c9aac21 100644
--- a/okhttp/src/main/java/okhttp3/Response.java
+++ b/okhttp/src/main/java/okhttp3/Response.java
@@ -20,6 +20,7 @@
 import java.util.Collections;
 import java.util.List;
 import javax.annotation.Nullable;
+import okhttp3.internal.http.HttpCodec;
 import okhttp3.internal.http.HttpHeaders;
 import okio.Buffer;
 import okio.BufferedSource;
@@ -53,8 +54,9 @@
   final @Nullable Response priorResponse;
   final long sentRequestAtMillis;
   final long receivedResponseAtMillis;
+  final @Nullable HttpCodec httpCodec;
 
-  private volatile CacheControl cacheControl; // Lazily initialized.
+  private volatile @Nullable CacheControl cacheControl; // Lazily initialized.
 
   Response(Builder builder) {
     this.request = builder.request;
@@ -69,6 +71,7 @@
     this.priorResponse = builder.priorResponse;
     this.sentRequestAtMillis = builder.sentRequestAtMillis;
     this.receivedResponseAtMillis = builder.receivedResponseAtMillis;
+    this.httpCodec = builder.httpCodec;
   }
 
   /**
@@ -136,6 +139,14 @@ public Headers headers() {
     return headers;
   }
 
+  /**
+   * Returns the trailers after the HTTP response, which may be empty. It is an error to call this
+   * before the entire HTTP response body has been consumed.
+   */
+  public Headers trailers() throws IOException {
+    return httpCodec.trailers();
+  }
+
   /**
    * Peeks up to {@code byteCount} bytes from the response body and returns them as a new response
    * body. If fewer than {@code byteCount} bytes are in the response body, the full response body is
@@ -148,21 +159,11 @@ public Headers headers() {
    * applications should set a modest limit on {@code byteCount}, such as 1 MiB.
    */
   public ResponseBody peekBody(long byteCount) throws IOException {
-    BufferedSource source = body.source();
-    source.request(byteCount);
-    Buffer copy = source.buffer().clone();
-
-    // There may be more than byteCount bytes in source.buffer(). If there is, return a prefix.
-    Buffer result;
-    if (copy.size() > byteCount) {
-      result = new Buffer();
-      result.write(copy, byteCount);
-      copy.clear();
-    } else {
-      result = copy;
-    }
-
-    return ResponseBody.create(body.contentType(), result.size(), result);
+    BufferedSource peeked = body.source().peek();
+    Buffer buffer = new Buffer();
+    peeked.request(byteCount);
+    buffer.write(peeked, Math.min(byteCount, peeked.getBuffer().size()));
+    return ResponseBody.create(body.contentType(), buffer.size(), buffer);
   }
 
   /**
@@ -225,10 +226,15 @@ public boolean isRedirect() {
   }
 
   /**
-   * Returns the authorization challenges appropriate for this response's code. If the response code
-   * is 401 unauthorized, this returns the "WWW-Authenticate" challenges. If the response code is
-   * 407 proxy unauthorized, this returns the "Proxy-Authenticate" challenges. Otherwise this
-   * returns an empty list of challenges.
+   * Returns the RFC 7235 authorization challenges appropriate for this response's code. If the
+   * response code is 401 unauthorized, this returns the "WWW-Authenticate" challenges. If the
+   * response code is 407 proxy unauthorized, this returns the "Proxy-Authenticate" challenges.
+   * Otherwise this returns an empty list of challenges.
+   *
+   * <p>If a challenge uses the {@code token68} variant instead of auth params, there is exactly one
+   * auth param in the challenge at key {@code null}. Invalid headers and challenges are ignored.
+   * No semantic validation is done, for example that {@code Basic} auth must have a {@code realm}
+   * auth param, this is up to the caller that interprets these challenges.
    */
   public List<Challenge> challenges() {
     String responseField;
@@ -296,18 +302,19 @@ public long receivedResponseAtMillis() {
   }
 
   public static class Builder {
-    Request request;
-    Protocol protocol;
+    @Nullable Request request;
+    @Nullable Protocol protocol;
     int code = -1;
     String message;
     @Nullable Handshake handshake;
     Headers.Builder headers;
-    ResponseBody body;
-    Response networkResponse;
-    Response cacheResponse;
-    Response priorResponse;
+    @Nullable ResponseBody body;
+    @Nullable Response networkResponse;
+    @Nullable Response cacheResponse;
+    @Nullable Response priorResponse;
     long sentRequestAtMillis;
     long receivedResponseAtMillis;
+    @Nullable HttpCodec httpCodec;
 
     public Builder() {
       headers = new Headers.Builder();
@@ -326,6 +333,7 @@ public Builder() {
       this.priorResponse = response.priorResponse;
       this.sentRequestAtMillis = response.sentRequestAtMillis;
       this.receivedResponseAtMillis = response.receivedResponseAtMillis;
+      this.httpCodec = response.httpCodec;
     }
 
     public Builder request(Request request) {
@@ -433,6 +441,10 @@ public Builder receivedResponseAtMillis(long receivedResponseAtMillis) {
       return this;
     }
 
+    void initCodec(HttpCodec httpCodec) {
+      this.httpCodec = httpCodec;
+    }
+
     public Response build() {
       if (request == null) throw new IllegalStateException("request == null");
       if (protocol == null) throw new IllegalStateException("protocol == null");
diff --git a/okhttp/src/main/java/okhttp3/ResponseBody.java b/okhttp/src/main/java/okhttp3/ResponseBody.java
index 73c6b93aac..96b7e38a0f 100644
--- a/okhttp/src/main/java/okhttp3/ResponseBody.java
+++ b/okhttp/src/main/java/okhttp3/ResponseBody.java
@@ -27,7 +27,7 @@
 import okio.BufferedSource;
 import okio.ByteString;
 
-import static okhttp3.internal.Util.UTF_8;
+import static java.nio.charset.StandardCharsets.UTF_8;
 
 /**
  * A one-shot stream from the origin server to the client application with the raw bytes of the
@@ -102,7 +102,7 @@
  */
 public abstract class ResponseBody implements Closeable {
   /** Multiple calls to {@link #charStream()} must return the same instance. */
-  private Reader reader;
+  private @Nullable Reader reader;
 
   public abstract @Nullable MediaType contentType();
 
@@ -131,12 +131,9 @@ public final InputStream byteStream() {
       throw new IOException("Cannot buffer entire body for content length: " + contentLength);
     }
 
-    BufferedSource source = source();
     byte[] bytes;
-    try {
+    try (BufferedSource source = source()) {
       bytes = source.readByteArray();
-    } finally {
-      Util.closeQuietly(source);
     }
     if (contentLength != -1 && contentLength != bytes.length) {
       throw new IOException("Content-Length ("
@@ -149,10 +146,15 @@ public final InputStream byteStream() {
   }
 
   /**
-   * Returns the response as a character stream decoded with the charset of the Content-Type header.
-   * If that header is either absent or lacks a charset, this will attempt to decode the response
-   * body in accordance to <a href="https://en.wikipedia.org/wiki/Byte_order_mark">its BOM</a> or
-   * UTF-8.
+   * Returns the response as a character stream.
+   *
+   * <p>If the response starts with a <a href="https://en.wikipedia.org/wiki/Byte_order_mark">Byte
+   * Order Mark (BOM)</a>, it is consumed and used to determine the charset of the response bytes.
+   *
+   * <p>Otherwise if the response has a Content-Type header that specifies a charset, that is used
+   * to determine the charset of the response bytes.
+   *
+   * <p>Otherwise the response bytes are decoded as UTF-8.
    */
   public final Reader charStream() {
     Reader r = reader;
@@ -160,22 +162,24 @@ public final Reader charStream() {
   }
 
   /**
-   * Returns the response as a string decoded with the charset of the Content-Type header. If that
-   * header is either absent or lacks a charset, this will attempt to decode the response body in
-   * accordance to <a href="https://en.wikipedia.org/wiki/Byte_order_mark">its BOM</a> or UTF-8.
-   * Closes {@link ResponseBody} automatically.
+   * Returns the response as a string.
+   *
+   * <p>If the response starts with a <a href="https://en.wikipedia.org/wiki/Byte_order_mark">Byte
+   * Order Mark (BOM)</a>, it is consumed and used to determine the charset of the response bytes.
+   *
+   * <p>Otherwise if the response has a Content-Type header that specifies a charset, that is used
+   * to determine the charset of the response bytes.
+   *
+   * <p>Otherwise the response bytes are decoded as UTF-8.
    *
    * <p>This method loads entire response body into memory. If the response body is very large this
    * may trigger an {@link OutOfMemoryError}. Prefer to stream the response body if this is a
    * possibility for your response.
    */
   public final String string() throws IOException {
-    BufferedSource source = source();
-    try {
+    try (BufferedSource source = source()) {
       Charset charset = Util.bomAwareCharset(source, charset());
       return source.readString(charset);
-    } finally {
-      Util.closeQuietly(source);
     }
   }
 
@@ -241,7 +245,7 @@ public static ResponseBody create(final @Nullable MediaType contentType,
     private final Charset charset;
 
     private boolean closed;
-    private Reader delegate;
+    private @Nullable Reader delegate;
 
     BomAwareReader(BufferedSource source, Charset charset) {
       this.source = source;
diff --git a/okhttp/src/main/java/okhttp3/internal/Internal.java b/okhttp/src/main/java/okhttp3/internal/Internal.java
index 4bb2282756..ac4d607eb4 100644
--- a/okhttp/src/main/java/okhttp3/internal/Internal.java
+++ b/okhttp/src/main/java/okhttp3/internal/Internal.java
@@ -15,7 +15,9 @@
  */
 package okhttp3.internal;
 
+import java.io.IOException;
 import java.net.Socket;
+import javax.annotation.Nullable;
 import javax.net.ssl.SSLSocket;
 import okhttp3.Address;
 import okhttp3.Call;
@@ -30,6 +32,7 @@
 import okhttp3.internal.connection.RealConnection;
 import okhttp3.internal.connection.RouteDatabase;
 import okhttp3.internal.connection.StreamAllocation;
+import okhttp3.internal.http.HttpCodec;
 
 /**
  * Escalate internal APIs in {@code okhttp3} so they can be used from OkHttp's implementation
@@ -50,12 +53,12 @@ public static void initializeInstanceForTests() {
 
   public abstract void setCache(OkHttpClient.Builder builder, InternalCache internalCache);
 
-  public abstract RealConnection get(ConnectionPool pool, Address address,
-      StreamAllocation streamAllocation, Route route);
+  public abstract void acquire(ConnectionPool pool, Address address,
+      StreamAllocation streamAllocation, @Nullable Route route);
 
   public abstract boolean equalsNonHost(Address a, Address b);
 
-  public abstract Socket deduplicate(
+  public abstract @Nullable Socket deduplicate(
       ConnectionPool pool, Address address, StreamAllocation streamAllocation);
 
   public abstract void put(ConnectionPool pool, RealConnection connection);
@@ -73,5 +76,10 @@ public abstract void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket,
 
   public abstract StreamAllocation streamAllocation(Call call);
 
+  public abstract @Nullable IOException timeoutExit(Call call, @Nullable IOException e);
+
   public abstract Call newWebSocketCall(OkHttpClient client, Request request);
+
+  public abstract void initCodec(
+      Response.Builder responseBuilder, HttpCodec httpCodec);
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/Util.java b/okhttp/src/main/java/okhttp3/internal/Util.java
index 6f8a4146b1..5315a6b685 100644
--- a/okhttp/src/main/java/okhttp3/internal/Util.java
+++ b/okhttp/src/main/java/okhttp3/internal/Util.java
@@ -26,6 +26,7 @@
 import java.net.Socket;
 import java.net.UnknownHostException;
 import java.nio.charset.Charset;
+import java.security.AccessControlException;
 import java.security.GeneralSecurityException;
 import java.security.KeyStore;
 import java.util.ArrayList;
@@ -44,43 +45,46 @@
 import javax.net.ssl.TrustManager;
 import javax.net.ssl.TrustManagerFactory;
 import javax.net.ssl.X509TrustManager;
+import okhttp3.Headers;
 import okhttp3.HttpUrl;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
+import okhttp3.internal.http2.Header;
 import okio.Buffer;
 import okio.BufferedSource;
 import okio.ByteString;
+import okio.Options;
 import okio.Source;
 
+import static java.nio.charset.StandardCharsets.UTF_16BE;
+import static java.nio.charset.StandardCharsets.UTF_16LE;
+import static java.nio.charset.StandardCharsets.UTF_8;
+
 /** Junk drawer of utility methods. */
 public final class Util {
   public static final byte[] EMPTY_BYTE_ARRAY = new byte[0];
   public static final String[] EMPTY_STRING_ARRAY = new String[0];
+  public static final Headers EMPTY_HEADERS = Headers.of();
 
   public static final ResponseBody EMPTY_RESPONSE = ResponseBody.create(null, EMPTY_BYTE_ARRAY);
   public static final RequestBody EMPTY_REQUEST = RequestBody.create(null, EMPTY_BYTE_ARRAY);
 
-  private static final ByteString UTF_8_BOM = ByteString.decodeHex("efbbbf");
-  private static final ByteString UTF_16_BE_BOM = ByteString.decodeHex("feff");
-  private static final ByteString UTF_16_LE_BOM = ByteString.decodeHex("fffe");
-  private static final ByteString UTF_32_BE_BOM = ByteString.decodeHex("0000ffff");
-  private static final ByteString UTF_32_LE_BOM = ByteString.decodeHex("ffff0000");
+  /** Byte order marks. */
+  private static final Options UNICODE_BOMS = Options.of(
+      ByteString.decodeHex("efbbbf"),   // UTF-8
+      ByteString.decodeHex("feff"),     // UTF-16BE
+      ByteString.decodeHex("fffe"),     // UTF-16LE
+      ByteString.decodeHex("0000ffff"), // UTF-32BE
+      ByteString.decodeHex("ffff0000")  // UTF-32LE
+  );
 
-  public static final Charset UTF_8 = Charset.forName("UTF-8");
-  public static final Charset ISO_8859_1 = Charset.forName("ISO-8859-1");
-  private static final Charset UTF_16_BE = Charset.forName("UTF-16BE");
-  private static final Charset UTF_16_LE = Charset.forName("UTF-16LE");
-  private static final Charset UTF_32_BE = Charset.forName("UTF-32BE");
-  private static final Charset UTF_32_LE = Charset.forName("UTF-32LE");
+  private static final Charset UTF_32BE = Charset.forName("UTF-32BE");
+  private static final Charset UTF_32LE = Charset.forName("UTF-32LE");
 
   /** GMT and UTC are equivalent for our purposes. */
   public static final TimeZone UTC = TimeZone.getTimeZone("GMT");
 
-  public static final Comparator<String> NATURAL_ORDER = new Comparator<String>() {
-    @Override public int compare(String a, String b) {
-      return a.compareTo(b);
-    }
-  };
+  public static final Comparator<String> NATURAL_ORDER = String::compareTo;
 
   private static final Method addSuppressedExceptionMethod;
 
@@ -125,11 +129,6 @@ public static void checkOffsetAndCount(long arrayLength, long offset, long count
     }
   }
 
-  /** Returns true if two possibly-null objects are equal. */
-  public static boolean equal(Object a, Object b) {
-    return a == b || (a != null && a.equals(b));
-  }
-
   /**
    * Closes {@code closeable}, ignoring any checked exceptions. Does nothing if {@code closeable} is
    * null.
@@ -225,22 +224,21 @@ public static boolean skipAll(Source source, int duration, TimeUnit timeUnit) th
   /** Returns an immutable copy of {@code map}. */
   public static <K, V> Map<K, V> immutableMap(Map<K, V> map) {
     return map.isEmpty()
-        ? Collections.<K, V>emptyMap()
+        ? Collections.emptyMap()
         : Collections.unmodifiableMap(new LinkedHashMap<>(map));
   }
 
   /** Returns an immutable list containing {@code elements}. */
+  @SafeVarargs
   public static <T> List<T> immutableList(T... elements) {
     return Collections.unmodifiableList(Arrays.asList(elements.clone()));
   }
 
-  public static ThreadFactory threadFactory(final String name, final boolean daemon) {
-    return new ThreadFactory() {
-      @Override public Thread newThread(Runnable runnable) {
-        Thread result = new Thread(runnable, name);
-        result.setDaemon(daemon);
-        return result;
-      }
+  public static ThreadFactory threadFactory(String name, boolean daemon) {
+    return runnable -> {
+      Thread result = new Thread(runnable, name);
+      result.setDaemon(daemon);
+      return result;
     };
   }
 
@@ -248,7 +246,6 @@ public static ThreadFactory threadFactory(final String name, final boolean daemo
    * Returns an array containing only elements found in {@code first} and also in {@code
    * second}. The returned elements are in the same order as in {@code first}.
    */
-  @SuppressWarnings("unchecked")
   public static String[] intersect(
       Comparator<? super String> comparator, String[] first, String[] second) {
     List<String> result = new ArrayList<>();
@@ -403,6 +400,7 @@ public static String canonicalizeHost(String host) {
       if (inetAddress == null) return null;
       byte[] address = inetAddress.getAddress();
       if (address.length == 16) return inet6AddressToAscii(address);
+      if (address.length == 4) return inetAddress.getHostAddress(); // An IPv4-mapped IPv6 address.
       throw new AssertionError("Invalid IPv6 address: '" + host + "'");
     }
 
@@ -466,27 +464,15 @@ public static String format(String format, Object... args) {
   }
 
   public static Charset bomAwareCharset(BufferedSource source, Charset charset) throws IOException {
-    if (source.rangeEquals(0, UTF_8_BOM)) {
-      source.skip(UTF_8_BOM.size());
-      return UTF_8;
-    }
-    if (source.rangeEquals(0, UTF_16_BE_BOM)) {
-      source.skip(UTF_16_BE_BOM.size());
-      return UTF_16_BE;
+    switch (source.select(UNICODE_BOMS)) {
+      case 0: return UTF_8;
+      case 1: return UTF_16BE;
+      case 2: return UTF_16LE;
+      case 3: return UTF_32BE;
+      case 4: return UTF_32LE;
+      case -1: return charset;
+      default: throw new AssertionError();
     }
-    if (source.rangeEquals(0, UTF_16_LE_BOM)) {
-      source.skip(UTF_16_LE_BOM.size());
-      return UTF_16_LE;
-    }
-    if (source.rangeEquals(0, UTF_32_BE_BOM)) {
-      source.skip(UTF_32_BE_BOM.size());
-      return UTF_32_BE;
-    }
-    if (source.rangeEquals(0, UTF_32_LE_BOM)) {
-      source.skip(UTF_32_LE_BOM.size());
-      return UTF_32_LE;
-    }
-    return charset;
   }
 
   public static int checkDuration(String name, long duration, TimeUnit unit) {
@@ -498,16 +484,6 @@ public static int checkDuration(String name, long duration, TimeUnit unit) {
     return (int) millis;
   }
 
-  public static AssertionError assertionError(String message, Exception e) {
-    AssertionError assertionError = new AssertionError(message);
-    try {
-      assertionError.initCause(e);
-    } catch (IllegalStateException ise) {
-      // ignored, shouldn't happen
-    }
-    return assertionError;
-  }
-
   public static int decodeHexDigit(char c) {
     if (c >= '0' && c <= '9') return c - '0';
     if (c >= 'a' && c <= 'f') return c - 'a' + 10;
@@ -669,7 +645,37 @@ public static X509TrustManager platformTrustManager() {
       }
       return (X509TrustManager) trustManagers[0];
     } catch (GeneralSecurityException e) {
-      throw assertionError("No System TLS", e); // The system has no TLS. Just give up.
+      throw new AssertionError("No System TLS", e); // The system has no TLS. Just give up.
+    }
+  }
+
+  public static Headers toHeaders(List<Header> headerBlock) {
+    Headers.Builder builder = new Headers.Builder();
+    for (Header header : headerBlock) {
+      Internal.instance.addLenient(builder, header.name.utf8(), header.value.utf8());
+    }
+    return builder.build();
+  }
+
+  public static List<Header> toHeaderBlock(Headers headers) {
+    List<Header> result = new ArrayList<>();
+    for (int i = 0; i < headers.size(); i++) {
+      result.add(new Header(headers.name(i), headers.value(i)));
+    }
+    return result;
+  }
+
+  /**
+   * Returns the system property, or defaultValue if the system property is null or
+   * cannot be read (e.g. because of security policy restrictions).
+   */
+  public static String getSystemProperty(String key, @Nullable String defaultValue) {
+    String value;
+    try {
+      value = System.getProperty(key);
+    } catch (AccessControlException ex) {
+      return defaultValue;
     }
+    return value != null ? value : defaultValue;
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/annotations/EverythingIsNonNull.java b/okhttp/src/main/java/okhttp3/internal/annotations/EverythingIsNonNull.java
new file mode 100644
index 0000000000..e97bb4d9cb
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/annotations/EverythingIsNonNull.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package okhttp3.internal.annotations;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import javax.annotation.Nonnull;
+import javax.annotation.meta.TypeQualifierDefault;
+
+/**
+ * Extends {@code ParametersAreNonnullByDefault} to also apply to Method results and fields.
+ *
+ * @see javax.annotation.ParametersAreNonnullByDefault
+ */
+@Documented
+@Nonnull
+@TypeQualifierDefault({
+    ElementType.FIELD,
+    ElementType.METHOD,
+    ElementType.PARAMETER
+})
+@Retention(RetentionPolicy.RUNTIME)
+public @interface EverythingIsNonNull { }
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java b/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java
index d46494d95b..30c9a135ea 100644
--- a/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java
@@ -17,6 +17,7 @@
 package okhttp3.internal.cache;
 
 import java.io.IOException;
+import javax.annotation.Nullable;
 import okhttp3.Headers;
 import okhttp3.Interceptor;
 import okhttp3.Protocol;
@@ -43,9 +44,9 @@
 
 /** Serves requests from the cache and writes responses to the cache. */
 public final class CacheInterceptor implements Interceptor {
-  final InternalCache cache;
+  final @Nullable InternalCache cache;
 
-  public CacheInterceptor(InternalCache cache) {
+  public CacheInterceptor(@Nullable InternalCache cache) {
     this.cache = cache;
   }
 
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java b/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java
index 3ae1926650..c7fb69ceba 100644
--- a/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java
+++ b/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java
@@ -205,9 +205,6 @@ private CacheStrategy getCandidate() {
       }
 
       CacheControl responseCaching = cacheResponse.cacheControl();
-      if (responseCaching.immutable()) {
-        return new CacheStrategy(null, cacheResponse);
-      }
 
       long ageMillis = cacheResponseAge();
       long freshMillis = computeFreshnessLifetime();
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.java b/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.java
index c3fb740e28..3b193f3b91 100644
--- a/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.java
+++ b/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.java
@@ -267,14 +267,13 @@ public static DiskLruCache create(FileSystem fileSystem, File directory, int app
 
     // Use a single background thread to evict entries.
     Executor executor = new ThreadPoolExecutor(0, 1, 60L, TimeUnit.SECONDS,
-        new LinkedBlockingQueue<Runnable>(), Util.threadFactory("OkHttp DiskLruCache", true));
+        new LinkedBlockingQueue<>(), Util.threadFactory("OkHttp DiskLruCache", true));
 
     return new DiskLruCache(fileSystem, directory, appVersion, valueCount, maxSize, executor);
   }
 
   private void readJournal() throws IOException {
-    BufferedSource source = Okio.buffer(fileSystem.source(journalFile));
-    try {
+    try (BufferedSource source = Okio.buffer(fileSystem.source(journalFile))) {
       String magic = source.readUtf8LineStrict();
       String version = source.readUtf8LineStrict();
       String appVersionString = source.readUtf8LineStrict();
@@ -306,8 +305,6 @@ private void readJournal() throws IOException {
       } else {
         journalWriter = newJournalWriter();
       }
-    } finally {
-      Util.closeQuietly(source);
     }
   }
 
@@ -393,8 +390,7 @@ synchronized void rebuildJournal() throws IOException {
       journalWriter.close();
     }
 
-    BufferedSink writer = Okio.buffer(fileSystem.sink(journalFileTmp));
-    try {
+    try (BufferedSink writer = Okio.buffer(fileSystem.sink(journalFileTmp))) {
       writer.writeUtf8(MAGIC).writeByte('\n');
       writer.writeUtf8(VERSION_1).writeByte('\n');
       writer.writeDecimalLong(appVersion).writeByte('\n');
@@ -413,8 +409,6 @@ synchronized void rebuildJournal() throws IOException {
           writer.writeByte('\n');
         }
       }
-    } finally {
-      writer.close();
     }
 
     if (fileSystem.exists(journalFile)) {
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/InternalCache.java b/okhttp/src/main/java/okhttp3/internal/cache/InternalCache.java
index 6c70465b59..abb953472d 100644
--- a/okhttp/src/main/java/okhttp3/internal/cache/InternalCache.java
+++ b/okhttp/src/main/java/okhttp3/internal/cache/InternalCache.java
@@ -16,6 +16,7 @@
 package okhttp3.internal.cache;
 
 import java.io.IOException;
+import javax.annotation.Nullable;
 import okhttp3.Request;
 import okhttp3.Response;
 
@@ -24,9 +25,9 @@
  * okhttp3.Cache}.
  */
 public interface InternalCache {
-  Response get(Request request) throws IOException;
+  @Nullable Response get(Request request) throws IOException;
 
-  CacheRequest put(Response response) throws IOException;
+  @Nullable CacheRequest put(Response response) throws IOException;
 
   /**
    * Remove any cache entries for the supplied {@code request}. This is invoked when the client
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/ConnectionSpecSelector.java b/okhttp/src/main/java/okhttp3/internal/connection/ConnectionSpecSelector.java
index 34a116464d..285a10ce46 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/ConnectionSpecSelector.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/ConnectionSpecSelector.java
@@ -25,7 +25,6 @@
 import javax.net.ssl.SSLException;
 import javax.net.ssl.SSLHandshakeException;
 import javax.net.ssl.SSLPeerUnverifiedException;
-import javax.net.ssl.SSLProtocolException;
 import javax.net.ssl.SSLSocket;
 import okhttp3.ConnectionSpec;
 import okhttp3.internal.Internal;
@@ -111,8 +110,7 @@ public boolean connectionFailed(IOException e) {
     // Look for known client-side or negotiation errors that are unlikely to be fixed by trying
     // again with a different connection spec.
     if (e instanceof SSLHandshakeException) {
-      // If the problem was a CertificateException from the X509TrustManager,
-      // do not retry.
+      // If the problem was a CertificateException from the X509TrustManager, do not retry.
       if (e.getCause() instanceof CertificateException) {
         return false;
       }
@@ -122,11 +120,8 @@ public boolean connectionFailed(IOException e) {
       return false;
     }
 
-    // On Android, SSLProtocolExceptions can be caused by TLS_FALLBACK_SCSV failures, which means we
-    // retry those when we probably should not.
-    return (e instanceof SSLHandshakeException
-        || e instanceof SSLProtocolException
-        || e instanceof SSLException);
+    // Retry for all other SSL failures.
+    return e instanceof SSLException;
   }
 
   /**
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java b/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
index ce089d1864..d087e5da65 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
@@ -19,12 +19,14 @@
 import java.io.IOException;
 import java.lang.ref.Reference;
 import java.net.ConnectException;
+import java.net.HttpURLConnection;
 import java.net.ProtocolException;
 import java.net.Proxy;
 import java.net.Socket;
 import java.net.SocketException;
 import java.net.SocketTimeoutException;
 import java.net.UnknownServiceException;
+import java.security.cert.Certificate;
 import java.security.cert.X509Certificate;
 import java.util.ArrayList;
 import java.util.List;
@@ -322,11 +324,18 @@ private void connectTls(ConnectionSpecSelector connectionSpecSelector) throws IO
 
       // Verify that the socket's certificates are acceptable for the target host.
       if (!address.hostnameVerifier().verify(address.url().host(), sslSocketSession)) {
-        X509Certificate cert = (X509Certificate) unverifiedHandshake.peerCertificates().get(0);
-        throw new SSLPeerUnverifiedException("Hostname " + address.url().host() + " not verified:"
-            + "\n    certificate: " + CertificatePinner.pin(cert)
-            + "\n    DN: " + cert.getSubjectDN().getName()
-            + "\n    subjectAltNames: " + OkHostnameVerifier.allSubjectAltNames(cert));
+        List<Certificate> peerCertificates = unverifiedHandshake.peerCertificates();
+        if (!peerCertificates.isEmpty()) {
+          X509Certificate cert = (X509Certificate) peerCertificates.get(0);
+          throw new SSLPeerUnverifiedException(
+              "Hostname " + address.url().host() + " not verified:"
+                  + "\n    certificate: " + CertificatePinner.pin(cert)
+                  + "\n    DN: " + cert.getSubjectDN().getName()
+                  + "\n    subjectAltNames: " + OkHostnameVerifier.allSubjectAltNames(cert));
+        } else {
+          throw new SSLPeerUnverifiedException(
+              "Hostname " + address.url().host() + " not verified (no certificates)");
+        }
       }
 
       // Check that the certificate pinner is satisfied by the certificates presented.
@@ -391,7 +400,7 @@ private Request createTunnel(int readTimeout, int writeTimeout, Request tunnelRe
           // that happens, then we will have buffered bytes that are needed by the SSLSocket!
           // This check is imperfect: it doesn't tell us whether a handshake will succeed, just
           // that it will almost certainly fail because the proxy has sent unexpected data.
-          if (!source.buffer().exhausted() || !sink.buffer().exhausted()) {
+          if (!source.getBuffer().exhausted() || !sink.buffer().exhausted()) {
             throw new IOException("TLS tunnel buffered too many bytes!");
           }
           return null;
@@ -416,14 +425,37 @@ private Request createTunnel(int readTimeout, int writeTimeout, Request tunnelRe
    * Returns a request that creates a TLS tunnel via an HTTP proxy. Everything in the tunnel request
    * is sent unencrypted to the proxy server, so tunnels include only the minimum set of headers.
    * This avoids sending potentially sensitive data like HTTP cookies to the proxy unencrypted.
+   *
+   * <p>In order to support preemptive authentication we pass a fake ‚ÄúAuth Failed‚Äù response to the
+   * authenticator. This gives the authenticator the option to customize the CONNECT request. It can
+   * decline to do so by returning null, in which case OkHttp will use it as-is
    */
-  private Request createTunnelRequest() {
-    return new Request.Builder()
+  private Request createTunnelRequest() throws IOException {
+    Request proxyConnectRequest = new Request.Builder()
         .url(route.address().url())
+        .method("CONNECT", null)
         .header("Host", Util.hostHeader(route.address().url(), true))
         .header("Proxy-Connection", "Keep-Alive") // For HTTP/1.0 proxies like Squid.
         .header("User-Agent", Version.userAgent())
         .build();
+
+    Response fakeAuthChallengeResponse = new Response.Builder()
+        .request(proxyConnectRequest)
+        .protocol(Protocol.HTTP_1_1)
+        .code(HttpURLConnection.HTTP_PROXY_AUTH)
+        .message("Preemptive Authenticate")
+        .body(Util.EMPTY_RESPONSE)
+        .sentRequestAtMillis(-1L)
+        .receivedResponseAtMillis(-1L)
+        .header("Proxy-Authenticate", "OkHttp-Preemptive")
+        .build();
+
+    Request authenticatedRequest = route.address().proxyAuthenticator()
+        .authenticate(route, fakeAuthChallengeResponse);
+
+    return authenticatedRequest != null
+        ? authenticatedRequest
+        : proxyConnectRequest;
   }
 
   /**
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java b/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
index 243a1e82f1..b362192907 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
@@ -57,14 +57,14 @@
  * connections. This class has APIs to release each of the above resources:
  *
  * <ul>
- *     <li>{@link #noNewStreams()} prevents the connection from being used for new streams in the
+ *     <li>{@link #noNewStreams} prevents the connection from being used for new streams in the
  *         future. Use this after a {@code Connection: close} header, or when the connection may be
  *         inconsistent.
- *     <li>{@link #streamFinished streamFinished()} releases the active stream from this allocation.
+ *     <li>{@link #streamFinished streamFinished} releases the active stream from this allocation.
  *         Note that only one stream may be active at a given time, so it is necessary to call
  *         {@link #streamFinished streamFinished()} before creating a subsequent stream with {@link
  *         #newStream newStream()}.
- *     <li>{@link #release()} removes the call's hold on the connection. Note that this won't
+ *     <li>{@link #release} removes the call's hold on the connection. Note that this won't
  *         immediately free the connection if there is a stream still lingering. That happens when a
  *         call is complete but its response body has yet to be fully consumed.
  * </ul>
@@ -185,7 +185,7 @@ private RealConnection findConnection(int connectTimeout, int readTimeout, int w
 
       if (result == null) {
         // Attempt to get a connection from the pool.
-        Internal.instance.get(connectionPool, address, this, null);
+        Internal.instance.acquire(connectionPool, address, this, null);
         if (connection != null) {
           foundPooledConnection = true;
           result = connection;
@@ -223,7 +223,7 @@ private RealConnection findConnection(int connectTimeout, int readTimeout, int w
         List<Route> routes = routeSelection.getAll();
         for (int i = 0, size = routes.size(); i < size; i++) {
           Route route = routes.get(i);
-          Internal.instance.get(connectionPool, address, this, route);
+          Internal.instance.acquire(connectionPool, address, this, route);
           if (connection != null) {
             foundPooledConnection = true;
             result = connection;
@@ -317,8 +317,10 @@ public void streamFinished(boolean noNewStreams, HttpCodec codec, long bytesRead
     }
 
     if (e != null) {
+      e = Internal.instance.timeoutExit(call, e);
       eventListener.callFailed(call, e);
     } else if (callEnd) {
+      Internal.instance.timeoutExit(call, null);
       eventListener.callEnd(call);
     }
   }
@@ -341,7 +343,7 @@ public synchronized RealConnection connection() {
     return connection;
   }
 
-  public void release() {
+  public void release(boolean callEnd) {
     Socket socket;
     Connection releasedConnection;
     synchronized (connectionPool) {
@@ -351,8 +353,13 @@ public void release() {
     }
     closeQuietly(socket);
     if (releasedConnection != null) {
+      if (callEnd) {
+        Internal.instance.timeoutExit(call, null);
+      }
       eventListener.connectionReleased(call, releasedConnection);
-      eventListener.callEnd(call);
+      if (callEnd) {
+        eventListener.callEnd(call);
+      }
     }
   }
 
diff --git a/okhttp/src/main/java/okhttp3/internal/duplex/DuplexRequestBody.java b/okhttp/src/main/java/okhttp3/internal/duplex/DuplexRequestBody.java
new file mode 100644
index 0000000000..6afbf86e66
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/duplex/DuplexRequestBody.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.duplex;
+
+import java.io.IOException;
+import javax.annotation.Nullable;
+import okhttp3.MediaType;
+import okhttp3.RequestBody;
+import okio.BufferedSink;
+import okio.Okio;
+import okio.Pipe;
+import okio.Sink;
+
+/**
+ * Duplex request bodies are special. They are called differently and they yield different
+ * interaction patterns over the network.
+ *
+ * <p>Rather than writing the body contents via the {@link #writeTo} callback, callers stream
+ * request bodies by writing to the {@link #createSink sink}. Callers stream out the entire request
+ * body and then {@link Sink#close close} it to signal the end of the request stream. The {@code
+ * maxBufferSize} controls how many outbound bytes may be enqueued without blocking: large values
+ * allow writing without blocking; small values limit a call‚Äôs memory consumption. 64 KiB is a
+ * reasonable size for most applications.
+ *
+ * <p>Calls with duplex bodies may receive HTTP responses before the HTTP request body has
+ * completed streaming. Interleaving of request and response data is why this mechanism is called
+ * duplex. Though any call may be initiated as a duplex call, only web servers that are specially
+ * designed for this nonstandard interaction will use it. As of 2019-01, the only widely-used
+ * implementation of this pattern is gRPC.
+ *
+ * <p>Duplex calls are only supported for HTTP/2 connections. Calls to HTTP/1 servers will fail
+ * before the HTTP request is transmitted.
+ *
+ * <p>Duplex calls may not be used with OkHttp interceptors that log, compress, encrypt, or
+ * otherwise access the request body. This includes OkHttp‚Äôs
+ * {@code okhttp3.logging.HttpLoggingInterceptor logging interceptor}.
+ */
+public final class DuplexRequestBody extends RequestBody {
+  private final Pipe pipe;
+  private final @Nullable MediaType contentType;
+
+  // TODO(jwilson/oldergod): include content-length? Callers might know it!
+  public DuplexRequestBody(@Nullable MediaType contentType, long pipeMaxBufferSize) {
+    this.pipe = new Pipe(pipeMaxBufferSize);
+    this.contentType = contentType;
+  }
+
+  public BufferedSink createSink() {
+    return Okio.buffer(pipe.sink());
+  }
+
+  public void foldSink(Sink requestBodyOut) throws IOException {
+    pipe.fold(requestBodyOut);
+  }
+
+  @Override public @Nullable MediaType contentType() {
+    return contentType;
+  }
+
+  @Override public void writeTo(BufferedSink sink) {
+    throw new UnsupportedOperationException();
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
index 62531aa514..dbf57cb973 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
@@ -17,12 +17,15 @@
 
 import java.io.IOException;
 import java.net.ProtocolException;
+import okhttp3.Call;
 import okhttp3.Interceptor;
 import okhttp3.Request;
 import okhttp3.Response;
+import okhttp3.internal.Internal;
 import okhttp3.internal.Util;
 import okhttp3.internal.connection.RealConnection;
 import okhttp3.internal.connection.StreamAllocation;
+import okhttp3.internal.duplex.DuplexRequestBody;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.ForwardingSink;
@@ -38,17 +41,18 @@ public CallServerInterceptor(boolean forWebSocket) {
   }
 
   @Override public Response intercept(Chain chain) throws IOException {
-    RealInterceptorChain realChain = (RealInterceptorChain) chain;
-    HttpCodec httpCodec = realChain.httpStream();
+    final RealInterceptorChain realChain = (RealInterceptorChain) chain;
+    Call call = realChain.call();
+    final HttpCodec httpCodec = realChain.httpStream();
     StreamAllocation streamAllocation = realChain.streamAllocation();
     RealConnection connection = (RealConnection) realChain.connection();
     Request request = realChain.request();
 
     long sentRequestMillis = System.currentTimeMillis();
 
-    realChain.eventListener().requestHeadersStart(realChain.call());
+    realChain.eventListener().requestHeadersStart(call);
     httpCodec.writeRequestHeaders(request);
-    realChain.eventListener().requestHeadersEnd(realChain.call(), request);
+    realChain.eventListener().requestHeadersEnd(call, request);
 
     Response.Builder responseBuilder = null;
     if (HttpMethod.permitsRequestBody(request.method()) && request.body() != null) {
@@ -57,22 +61,28 @@ public CallServerInterceptor(boolean forWebSocket) {
       // what we did get (such as a 4xx response) without ever transmitting the request body.
       if ("100-continue".equalsIgnoreCase(request.header("Expect"))) {
         httpCodec.flushRequest();
-        realChain.eventListener().responseHeadersStart(realChain.call());
+        realChain.eventListener().responseHeadersStart(call);
         responseBuilder = httpCodec.readResponseHeaders(true);
       }
 
       if (responseBuilder == null) {
-        // Write the request body if the "Expect: 100-continue" expectation was met.
-        realChain.eventListener().requestBodyStart(realChain.call());
-        long contentLength = request.body().contentLength();
-        CountingSink requestBodyOut =
-            new CountingSink(httpCodec.createRequestBody(request, contentLength));
-        BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);
-
-        request.body().writeTo(bufferedRequestBody);
-        bufferedRequestBody.close();
-        realChain.eventListener()
-            .requestBodyEnd(realChain.call(), requestBodyOut.successfulCount);
+        if (request.body() instanceof DuplexRequestBody) {
+          // Prepare a duplex body so that the application can send a request body later.
+          httpCodec.flushRequest();
+          CountingSink requestBodyOut = new CountingSink(httpCodec.createRequestBody(request, -1L));
+          ((DuplexRequestBody) request.body()).foldSink(requestBodyOut);
+        } else {
+          // Write the request body if the "Expect: 100-continue" expectation was met.
+          realChain.eventListener().requestBodyStart(call);
+          long contentLength = request.body().contentLength();
+          CountingSink requestBodyOut =
+              new CountingSink(httpCodec.createRequestBody(request, contentLength));
+          BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);
+
+          request.body().writeTo(bufferedRequestBody);
+          bufferedRequestBody.close();
+          realChain.eventListener().requestBodyEnd(call, requestBodyOut.successfulCount);
+        }
       } else if (!connection.isMultiplexed()) {
         // If the "Expect: 100-continue" expectation wasn't met, prevent the HTTP/1 connection
         // from being reused. Otherwise we're still obligated to transmit the request body to
@@ -81,19 +91,22 @@ public CallServerInterceptor(boolean forWebSocket) {
       }
     }
 
-    httpCodec.finishRequest();
+    if (!(request.body() instanceof DuplexRequestBody)) {
+      httpCodec.finishRequest();
+    }
 
     if (responseBuilder == null) {
-      realChain.eventListener().responseHeadersStart(realChain.call());
+      realChain.eventListener().responseHeadersStart(call);
       responseBuilder = httpCodec.readResponseHeaders(false);
     }
 
-    Response response = responseBuilder
+    responseBuilder
         .request(request)
         .handshake(streamAllocation.connection().handshake())
         .sentRequestAtMillis(sentRequestMillis)
-        .receivedResponseAtMillis(System.currentTimeMillis())
-        .build();
+        .receivedResponseAtMillis(System.currentTimeMillis());
+    Internal.instance.initCodec(responseBuilder, httpCodec);
+    Response response = responseBuilder.build();
 
     int code = response.code();
     if (code == 100) {
@@ -101,18 +114,18 @@ public CallServerInterceptor(boolean forWebSocket) {
       // try again to read the actual response
       responseBuilder = httpCodec.readResponseHeaders(false);
 
-      response = responseBuilder
-              .request(request)
-              .handshake(streamAllocation.connection().handshake())
-              .sentRequestAtMillis(sentRequestMillis)
-              .receivedResponseAtMillis(System.currentTimeMillis())
-              .build();
+      responseBuilder
+          .request(request)
+          .handshake(streamAllocation.connection().handshake())
+          .sentRequestAtMillis(sentRequestMillis)
+          .receivedResponseAtMillis(System.currentTimeMillis());
+      Internal.instance.initCodec(responseBuilder, httpCodec);
+      response = responseBuilder.build();
 
       code = response.code();
     }
 
-    realChain.eventListener()
-            .responseHeadersEnd(realChain.call(), response);
+    realChain.eventListener().responseHeadersEnd(call, response);
 
     if (forWebSocket && code == 101) {
       // Connection is upgrading, but we need to ensure interceptors see a non-null response body.
diff --git a/okhttp/src/main/java/okhttp3/internal/http/HttpCodec.java b/okhttp/src/main/java/okhttp3/internal/http/HttpCodec.java
index ad9759acce..103fce6662 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/HttpCodec.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/HttpCodec.java
@@ -16,6 +16,7 @@
 package okhttp3.internal.http;
 
 import java.io.IOException;
+import okhttp3.Headers;
 import okhttp3.Request;
 import okhttp3.Response;
 import okhttp3.ResponseBody;
@@ -53,6 +54,9 @@
   /** Returns a stream that reads the response body. */
   ResponseBody openResponseBody(Response response) throws IOException;
 
+  /** Returns the trailers after the HTTP response. May be empty. */
+  Headers trailers() throws IOException;
+
   /**
    * Cancel this stream. Resources held by this stream will be cleaned up, though not synchronously.
    * That may happen later by the connection pool thread.
diff --git a/okhttp/src/main/java/okhttp3/internal/http/HttpHeaders.java b/okhttp/src/main/java/okhttp3/internal/http/HttpHeaders.java
index a1d6712906..8823d202bc 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/HttpHeaders.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/HttpHeaders.java
@@ -15,13 +15,16 @@
  */
 package okhttp3.internal.http;
 
+import java.io.EOFException;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collections;
+import java.util.LinkedHashMap;
 import java.util.List;
+import java.util.Map;
+import java.util.Objects;
 import java.util.Set;
 import java.util.TreeSet;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
 import okhttp3.Challenge;
 import okhttp3.Cookie;
 import okhttp3.CookieJar;
@@ -29,19 +32,17 @@
 import okhttp3.HttpUrl;
 import okhttp3.Request;
 import okhttp3.Response;
-import okhttp3.internal.Util;
+import okio.Buffer;
+import okio.ByteString;
 
 import static java.net.HttpURLConnection.HTTP_NOT_MODIFIED;
 import static java.net.HttpURLConnection.HTTP_NO_CONTENT;
-import static okhttp3.internal.Util.equal;
 import static okhttp3.internal.http.StatusLine.HTTP_CONTINUE;
 
 /** Headers and utilities for internal use by OkHttp. */
 public final class HttpHeaders {
-  private static final String TOKEN = "([^ \"=]*)";
-  private static final String QUOTED_STRING = "\"([^\"]*)\"";
-  private static final Pattern PARAMETER
-      = Pattern.compile(" +" + TOKEN + "=(:?" + QUOTED_STRING + "|" + TOKEN + ") *(:?,|$)");
+  private static final ByteString QUOTED_STRING_DELIMITERS = ByteString.encodeUtf8("\"\\");
+  private static final ByteString TOKEN_DELIMITERS = ByteString.encodeUtf8("\t ,=");
 
   private HttpHeaders() {
   }
@@ -70,7 +71,7 @@ private static long stringToLong(String s) {
   public static boolean varyMatches(
       Response cachedResponse, Headers cachedRequest, Request newRequest) {
     for (String field : varyFields(cachedResponse)) {
-      if (!equal(cachedRequest.values(field), newRequest.headers(field))) return false;
+      if (!Objects.equals(cachedRequest.values(field), newRequest.headers(field))) return false;
     }
     return true;
   }
@@ -144,55 +145,168 @@ public static Headers varyHeaders(Headers requestHeaders, Headers responseHeader
   }
 
   /**
-   * Parse RFC 7617 challenges, also wrong ordered ones.
-   * This API is only interested in the scheme name and realm.
+   * Parse RFC 7235 challenges. This is awkward because we need to look ahead to know how to
+   * interpret a token.
+   *
+   * <p>For example, the first line has a parameter name/value pair and the second line has a single
+   * token68:
+   *
+   * <pre>   {@code
+   *
+   *   WWW-Authenticate: Digest foo=bar
+   *   WWW-Authenticate: Digest foo=
+   * }</pre>
+   *
+   * <p>Similarly, the first line has one challenge and the second line has two challenges:
+   *
+   * <pre>   {@code
+   *
+   *   WWW-Authenticate: Digest ,foo=bar
+   *   WWW-Authenticate: Digest ,foo
+   * }</pre>
    */
-  public static List<Challenge> parseChallenges(Headers responseHeaders, String challengeHeader) {
-    // auth-scheme = token
-    // auth-param  = token "=" ( token | quoted-string )
-    // challenge   = auth-scheme 1*SP 1#auth-param
-    // realm       = "realm" "=" realm-value
-    // realm-value = quoted-string
-    List<Challenge> challenges = new ArrayList<>();
-    List<String> authenticationHeaders = responseHeaders.values(challengeHeader);
-    for (String header : authenticationHeaders) {
-      int index = header.indexOf(' ');
-      if (index == -1) continue;
-
-      String scheme = header.substring(0, index);
-      String realm = null;
-      String charset = null;
-
-      Matcher matcher = PARAMETER.matcher(header);
-      for (int i = index; matcher.find(i); i = matcher.end()) {
-        if (header.regionMatches(true, matcher.start(1), "realm", 0, 5)) {
-          realm = matcher.group(3);
-        } else if (header.regionMatches(true, matcher.start(1), "charset", 0, 7)) {
-          charset = matcher.group(3);
-        }
+  public static List<Challenge> parseChallenges(Headers responseHeaders, String headerName) {
+    List<Challenge> result = new ArrayList<>();
+    for (int h = 0; h < responseHeaders.size(); h++) {
+      if (headerName.equalsIgnoreCase(responseHeaders.name(h))) {
+        Buffer header = new Buffer().writeUtf8(responseHeaders.value(h));
+        parseChallengeHeader(result, header);
+      }
+    }
+    return result;
+  }
 
-        if (realm != null && charset != null) {
-          break;
-        }
+  private static void parseChallengeHeader(List<Challenge> result, Buffer header) {
+    String peek = null;
+
+    while (true) {
+      // Read a scheme name for this challenge if we don't have one already.
+      if (peek == null) {
+        skipWhitespaceAndCommas(header);
+        peek = readToken(header);
+        if (peek == null) return;
       }
 
-      // "realm" is required.
-      if (realm == null) continue;
+      String schemeName = peek;
+
+      // Read a token68, a sequence of parameters, or nothing.
+      boolean commaPrefixed = skipWhitespaceAndCommas(header);
+      peek = readToken(header);
+      if (peek == null) {
+        if (!header.exhausted()) return; // Expected a token; got something else.
+        result.add(new Challenge(schemeName, Collections.emptyMap()));
+        return;
+      }
 
-      Challenge challenge = new Challenge(scheme, realm);
+      int eqCount = skipAll(header, (byte) '=');
+      boolean commaSuffixed = skipWhitespaceAndCommas(header);
 
-      // If a charset is provided, RFC 7617 says it must be "UTF-8".
-      if (charset != null) {
-        if (charset.equalsIgnoreCase("UTF-8")) {
-          challenge = challenge.withCharset(Util.UTF_8);
-        } else {
-          continue;
+      // It's a token68 because there isn't a value after it.
+      if (!commaPrefixed && (commaSuffixed || header.exhausted())) {
+        result.add(new Challenge(schemeName, Collections.singletonMap(
+            null, peek + repeat('=', eqCount))));
+        peek = null;
+        continue;
+      }
+
+      // It's a series of parameter names and values.
+      Map<String, String> parameters = new LinkedHashMap<>();
+      eqCount += skipAll(header, (byte) '=');
+      while (true) {
+        if (peek == null) {
+          peek = readToken(header);
+          if (skipWhitespaceAndCommas(header)) break; // We peeked a scheme name followed by ','.
+          eqCount = skipAll(header, (byte) '=');
         }
+        if (eqCount == 0) break; // We peeked a scheme name.
+        if (eqCount > 1) return; // Unexpected '=' characters.
+        if (skipWhitespaceAndCommas(header)) return; // Unexpected ','.
+
+        String parameterValue = !header.exhausted() && header.getByte(0) == '"'
+            ? readQuotedString(header)
+            : readToken(header);
+        if (parameterValue == null) return; // Expected a value.
+        String replaced = parameters.put(peek, parameterValue);
+        peek = null;
+        if (replaced != null) return; // Unexpected duplicate parameter.
+        if (!skipWhitespaceAndCommas(header) && !header.exhausted()) return; // Expected ',' or EOF.
+      }
+      result.add(new Challenge(schemeName, parameters));
+    }
+  }
+
+  /** Returns true if any commas were skipped. */
+  private static boolean skipWhitespaceAndCommas(Buffer buffer) {
+    boolean commaFound = false;
+    while (!buffer.exhausted()) {
+      byte b = buffer.getByte(0);
+      if (b == ',') {
+        buffer.readByte(); // Consume ','.
+        commaFound = true;
+      } else if (b == ' ' || b == '\t') {
+        buffer.readByte(); // Consume space or tab.
+      } else {
+        break;
+      }
+    }
+    return commaFound;
+  }
+
+  private static int skipAll(Buffer buffer, byte b) {
+    int count = 0;
+    while (!buffer.exhausted() && buffer.getByte(0) == b) {
+      count++;
+      buffer.readByte();
+    }
+    return count;
+  }
+
+  /**
+   * Reads a double-quoted string, unescaping quoted pairs like {@code \"} to the 2nd character in
+   * each sequence. Returns the unescaped string, or null if the buffer isn't prefixed with a
+   * double-quoted string.
+   */
+  private static String readQuotedString(Buffer buffer) {
+    if (buffer.readByte() != '\"') throw new IllegalArgumentException();
+    Buffer result = new Buffer();
+    while (true) {
+      long i = buffer.indexOfElement(QUOTED_STRING_DELIMITERS);
+      if (i == -1L) return null; // Unterminated quoted string.
+
+      if (buffer.getByte(i) == '"') {
+        result.write(buffer, i);
+        buffer.readByte(); // Consume '"'.
+        return result.readUtf8();
       }
 
-      challenges.add(challenge);
+      if (buffer.size() == i + 1L) return null; // Dangling escape.
+      result.write(buffer, i);
+      buffer.readByte(); // Consume '\'.
+      result.write(buffer, 1L); // The escaped character.
     }
-    return challenges;
+  }
+
+  /**
+   * Consumes and returns a non-empty token, terminating at special characters in {@link
+   * #TOKEN_DELIMITERS}. Returns null if the buffer is empty or prefixed with a delimiter.
+   */
+  private static String readToken(Buffer buffer) {
+    try {
+      long tokenSize = buffer.indexOfElement(TOKEN_DELIMITERS);
+      if (tokenSize == -1L) tokenSize = buffer.size();
+
+      return tokenSize != 0L
+          ? buffer.readUtf8(tokenSize)
+          : null;
+    } catch (EOFException e) {
+      throw new AssertionError();
+    }
+  }
+
+  private static String repeat(char c, int count) {
+    char[] array = new char[count];
+    Arrays.fill(array, c);
+    return new String(array);
   }
 
   public static void receiveHeaders(CookieJar cookieJar, HttpUrl url, Headers headers) {
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
index ffb75058aa..fa72df373b 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
@@ -15,6 +15,7 @@
  */
 package okhttp3.internal.http;
 
+import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InterruptedIOException;
 import java.net.HttpRetryException;
@@ -65,14 +66,12 @@
   private static final int MAX_FOLLOW_UPS = 20;
 
   private final OkHttpClient client;
-  private final boolean forWebSocket;
   private volatile StreamAllocation streamAllocation;
   private Object callStackTrace;
   private volatile boolean canceled;
 
-  public RetryAndFollowUpInterceptor(OkHttpClient client, boolean forWebSocket) {
+  public RetryAndFollowUpInterceptor(OkHttpClient client) {
     this.client = client;
-    this.forWebSocket = forWebSocket;
   }
 
   /**
@@ -116,7 +115,7 @@ public StreamAllocation streamAllocation() {
     Response priorResponse = null;
     while (true) {
       if (canceled) {
-        streamAllocation.release();
+        streamAllocation.release(true);
         throw new IOException("Canceled");
       }
 
@@ -142,7 +141,7 @@ public StreamAllocation streamAllocation() {
         // We're throwing an unchecked exception. Release any resources.
         if (releaseConnection) {
           streamAllocation.streamFailed(null);
-          streamAllocation.release();
+          streamAllocation.release(true);
         }
       }
 
@@ -159,31 +158,29 @@ public StreamAllocation streamAllocation() {
       try {
         followUp = followUpRequest(response, streamAllocation.route());
       } catch (IOException e) {
-        streamAllocation.release();
+        streamAllocation.release(true);
         throw e;
       }
 
       if (followUp == null) {
-        if (!forWebSocket) {
-          streamAllocation.release();
-        }
+        streamAllocation.release(true);
         return response;
       }
 
       closeQuietly(response.body());
 
       if (++followUpCount > MAX_FOLLOW_UPS) {
-        streamAllocation.release();
+        streamAllocation.release(true);
         throw new ProtocolException("Too many follow-up requests: " + followUpCount);
       }
 
       if (followUp.body() instanceof UnrepeatableRequestBody) {
-        streamAllocation.release();
+        streamAllocation.release(true);
         throw new HttpRetryException("Cannot retry streamed HTTP body", response.code());
       }
 
       if (!sameConnection(response, followUp.url())) {
-        streamAllocation.release();
+        streamAllocation.release(false);
         streamAllocation = new StreamAllocation(client.connectionPool(),
             createAddress(followUp.url()), call, eventListener, callStackTrace);
         this.streamAllocation = streamAllocation;
@@ -226,7 +223,7 @@ private boolean recover(IOException e, StreamAllocation streamAllocation,
     if (!client.retryOnConnectionFailure()) return false;
 
     // We can't send the request body again.
-    if (requestSendStarted && userRequest.body() instanceof UnrepeatableRequestBody) return false;
+    if (requestSendStarted && requestIsUnrepeatable(e, userRequest)) return false;
 
     // This exception is fatal.
     if (!isRecoverable(e, requestSendStarted)) return false;
@@ -238,6 +235,11 @@ private boolean recover(IOException e, StreamAllocation streamAllocation,
     return true;
   }
 
+  private boolean requestIsUnrepeatable(IOException e, Request userRequest) {
+    return userRequest.body() instanceof UnrepeatableRequestBody
+        || e instanceof FileNotFoundException;
+  }
+
   private boolean isRecoverable(IOException e, boolean requestSendStarted) {
     // If there was a protocol problem, don't recover.
     if (e instanceof ProtocolException) {
diff --git a/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java b/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java
index 6c7b4373c4..6dc70c4865 100644
--- a/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java
+++ b/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java
@@ -86,6 +86,12 @@
   int state = STATE_IDLE;
   private long headerLimit = HEADER_LIMIT;
 
+  /**
+   * Received trailers. Null unless the response body uses chunked transfer-encoding and includes
+   * trailers. Undefined until the end of the response body.
+   */
+  private Headers trailers;
+
   public Http1Codec(OkHttpClient client, StreamAllocation streamAllocation, BufferedSource source,
       BufferedSink sink) {
     this.client = client;
@@ -153,6 +159,13 @@ public Http1Codec(OkHttpClient client, StreamAllocation streamAllocation, Buffer
     return new RealResponseBody(contentType, -1L, Okio.buffer(newUnknownLengthSource()));
   }
 
+  @Override public Headers trailers() throws IOException {
+    if (state != STATE_CLOSED) {
+      throw new IllegalStateException("too early; can't read the trailers yet");
+    }
+    return trailers != null ? trailers : Util.EMPTY_HEADERS;
+  }
+
   /** Returns true if this connection is closed. */
   public boolean isClosed() {
     return state == STATE_CLOSED;
@@ -205,9 +218,7 @@ public void writeRequest(Headers headers, String requestLine) throws IOException
       return responseBuilder;
     } catch (EOFException e) {
       // Provide more context if the server ends the stream before sending a response.
-      IOException exception = new IOException("unexpected end of stream on " + streamAllocation);
-      exception.initCause(e);
-      throw exception;
+      throw new IOException("unexpected end of stream on " + streamAllocation, e);
     }
   }
 
@@ -477,7 +488,8 @@ private void readChunkSize() throws IOException {
       }
       if (bytesRemainingInChunk == 0L) {
         hasMoreChunks = false;
-        HttpHeaders.receiveHeaders(client.cookieJar(), url, readHeaders());
+        trailers = readHeaders();
+        HttpHeaders.receiveHeaders(client.cookieJar(), url, trailers);
         endOfInput(true, null);
       }
     }
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Header.java b/okhttp/src/main/java/okhttp3/internal/http2/Header.java
index 3cfd7be8d7..a306ac4622 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Header.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Header.java
@@ -22,11 +22,19 @@
 public final class Header {
   // Special header names defined in HTTP/2 spec.
   public static final ByteString PSEUDO_PREFIX = ByteString.encodeUtf8(":");
-  public static final ByteString RESPONSE_STATUS = ByteString.encodeUtf8(":status");
-  public static final ByteString TARGET_METHOD = ByteString.encodeUtf8(":method");
-  public static final ByteString TARGET_PATH = ByteString.encodeUtf8(":path");
-  public static final ByteString TARGET_SCHEME = ByteString.encodeUtf8(":scheme");
-  public static final ByteString TARGET_AUTHORITY = ByteString.encodeUtf8(":authority");
+
+  public static final String RESPONSE_STATUS_UTF8 = ":status";
+  public static final String TARGET_METHOD_UTF8 = ":method";
+  public static final String TARGET_PATH_UTF8 = ":path";
+  public static final String TARGET_SCHEME_UTF8 = ":scheme";
+  public static final String TARGET_AUTHORITY_UTF8 = ":authority";
+
+  public static final ByteString RESPONSE_STATUS = ByteString.encodeUtf8(RESPONSE_STATUS_UTF8);
+  public static final ByteString TARGET_METHOD = ByteString.encodeUtf8(TARGET_METHOD_UTF8);
+  public static final ByteString TARGET_PATH = ByteString.encodeUtf8(TARGET_PATH_UTF8);
+  public static final ByteString TARGET_SCHEME = ByteString.encodeUtf8(TARGET_SCHEME_UTF8);
+  public static final ByteString TARGET_AUTHORITY = ByteString.encodeUtf8(TARGET_AUTHORITY_UTF8);
+
 
   /** Name in case-insensitive ASCII encoding. */
   public final ByteString name;
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Hpack.java b/okhttp/src/main/java/okhttp3/internal/http2/Hpack.java
index 258ac9b269..615756cc48 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Hpack.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Hpack.java
@@ -22,7 +22,7 @@
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
-import okhttp3.internal.Util;
+import java.util.Objects;
 import okio.Buffer;
 import okio.BufferedSource;
 import okio.ByteString;
@@ -483,9 +483,9 @@ void writeHeaders(List<Header> headerBlock) throws IOException {
             // it's unnecessary to waste cycles looking at them. This check is built on the
             // observation that the header entries we care about are in adjacent pairs, and we
             // always know the first index of the pair.
-            if (Util.equal(STATIC_HEADER_TABLE[headerNameIndex - 1].value, value)) {
+            if (Objects.equals(STATIC_HEADER_TABLE[headerNameIndex - 1].value, value)) {
               headerIndex = headerNameIndex;
-            } else if (Util.equal(STATIC_HEADER_TABLE[headerNameIndex].value, value)) {
+            } else if (Objects.equals(STATIC_HEADER_TABLE[headerNameIndex].value, value)) {
               headerIndex = headerNameIndex + 1;
             }
           }
@@ -493,8 +493,8 @@ void writeHeaders(List<Header> headerBlock) throws IOException {
 
         if (headerIndex == -1) {
           for (int j = nextHeaderIndex + 1, length = dynamicTable.length; j < length; j++) {
-            if (Util.equal(dynamicTable[j].name, name)) {
-              if (Util.equal(dynamicTable[j].value, value)) {
+            if (Objects.equals(dynamicTable[j].name, name)) {
+              if (Objects.equals(dynamicTable[j].value, value)) {
                 headerIndex = j - nextHeaderIndex + STATIC_HEADER_TABLE.length;
                 break;
               } else if (headerNameIndex == -1) {
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java
index 48986270a0..9200e6ef1a 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java
@@ -37,32 +37,35 @@
 import okhttp3.internal.http.RequestLine;
 import okhttp3.internal.http.StatusLine;
 import okio.Buffer;
-import okio.ByteString;
 import okio.ForwardingSource;
 import okio.Okio;
 import okio.Sink;
 import okio.Source;
 
 import static okhttp3.internal.http.StatusLine.HTTP_CONTINUE;
-import static okhttp3.internal.http2.Header.RESPONSE_STATUS;
+import static okhttp3.internal.http2.Header.RESPONSE_STATUS_UTF8;
 import static okhttp3.internal.http2.Header.TARGET_AUTHORITY;
+import static okhttp3.internal.http2.Header.TARGET_AUTHORITY_UTF8;
 import static okhttp3.internal.http2.Header.TARGET_METHOD;
+import static okhttp3.internal.http2.Header.TARGET_METHOD_UTF8;
 import static okhttp3.internal.http2.Header.TARGET_PATH;
+import static okhttp3.internal.http2.Header.TARGET_PATH_UTF8;
 import static okhttp3.internal.http2.Header.TARGET_SCHEME;
+import static okhttp3.internal.http2.Header.TARGET_SCHEME_UTF8;
 
 /** Encode requests and responses using HTTP/2 frames. */
 public final class Http2Codec implements HttpCodec {
-  private static final ByteString CONNECTION = ByteString.encodeUtf8("connection");
-  private static final ByteString HOST = ByteString.encodeUtf8("host");
-  private static final ByteString KEEP_ALIVE = ByteString.encodeUtf8("keep-alive");
-  private static final ByteString PROXY_CONNECTION = ByteString.encodeUtf8("proxy-connection");
-  private static final ByteString TRANSFER_ENCODING = ByteString.encodeUtf8("transfer-encoding");
-  private static final ByteString TE = ByteString.encodeUtf8("te");
-  private static final ByteString ENCODING = ByteString.encodeUtf8("encoding");
-  private static final ByteString UPGRADE = ByteString.encodeUtf8("upgrade");
+  private static final String CONNECTION = "connection";
+  private static final String HOST = "host";
+  private static final String KEEP_ALIVE = "keep-alive";
+  private static final String PROXY_CONNECTION = "proxy-connection";
+  private static final String TRANSFER_ENCODING = "transfer-encoding";
+  private static final String TE = "te";
+  private static final String ENCODING = "encoding";
+  private static final String UPGRADE = "upgrade";
 
   /** See http://tools.ietf.org/html/draft-ietf-httpbis-http2-09#section-8.1.3. */
-  private static final List<ByteString> HTTP_2_SKIPPED_REQUEST_HEADERS = Util.immutableList(
+  private static final List<String> HTTP_2_SKIPPED_REQUEST_HEADERS = Util.immutableList(
       CONNECTION,
       HOST,
       KEEP_ALIVE,
@@ -71,11 +74,11 @@
       TRANSFER_ENCODING,
       ENCODING,
       UPGRADE,
-      TARGET_METHOD,
-      TARGET_PATH,
-      TARGET_SCHEME,
-      TARGET_AUTHORITY);
-  private static final List<ByteString> HTTP_2_SKIPPED_RESPONSE_HEADERS = Util.immutableList(
+      TARGET_METHOD_UTF8,
+      TARGET_PATH_UTF8,
+      TARGET_SCHEME_UTF8,
+      TARGET_AUTHORITY_UTF8);
+  private static final List<String> HTTP_2_SKIPPED_RESPONSE_HEADERS = Util.immutableList(
       CONNECTION,
       HOST,
       KEEP_ALIVE,
@@ -88,8 +91,9 @@
   private final Interceptor.Chain chain;
   final StreamAllocation streamAllocation;
   private final Http2Connection connection;
-  private Http2Stream stream;
+  private volatile Http2Stream stream;
   private final Protocol protocol;
+  private volatile boolean canceled;
 
   public Http2Codec(OkHttpClient client, Interceptor.Chain chain, StreamAllocation streamAllocation,
       Http2Connection connection) {
@@ -111,6 +115,12 @@ public Http2Codec(OkHttpClient client, Interceptor.Chain chain, StreamAllocation
     boolean hasRequestBody = request.body() != null;
     List<Header> requestHeaders = http2HeadersList(request);
     stream = connection.newStream(requestHeaders, hasRequestBody);
+    // We may have been asked to cancel while creating the new stream and sending the request
+    // headers, but there was still no stream to close.
+    if (canceled) {
+      stream.closeLater(ErrorCode.CANCEL);
+      throw new IOException("Canceled");
+    }
     stream.readTimeout().timeout(chain.readTimeoutMillis(), TimeUnit.MILLISECONDS);
     stream.writeTimeout().timeout(chain.writeTimeoutMillis(), TimeUnit.MILLISECONDS);
   }
@@ -124,7 +134,7 @@ public Http2Codec(OkHttpClient client, Interceptor.Chain chain, StreamAllocation
   }
 
   @Override public Response.Builder readResponseHeaders(boolean expectContinue) throws IOException {
-    List<Header> headers = stream.takeResponseHeaders();
+    Headers headers = stream.takeHeaders();
     Response.Builder responseBuilder = readHttp2HeadersList(headers, protocol);
     if (expectContinue && Internal.instance.code(responseBuilder) == HTTP_CONTINUE) {
       return null;
@@ -145,8 +155,9 @@ public Http2Codec(OkHttpClient client, Interceptor.Chain chain, StreamAllocation
 
     for (int i = 0, size = headers.size(); i < size; i++) {
       // header names must be lowercase.
-      ByteString name = ByteString.encodeUtf8(headers.name(i).toLowerCase(Locale.US));
-      if (!HTTP_2_SKIPPED_REQUEST_HEADERS.contains(name)) {
+      String name = headers.name(i).toLowerCase(Locale.US);
+      if (!HTTP_2_SKIPPED_REQUEST_HEADERS.contains(name)
+          || name.equals(TE) && headers.value(i).equals("trailers")) {
         result.add(new Header(name, headers.value(i)));
       }
     }
@@ -154,29 +165,17 @@ public Http2Codec(OkHttpClient client, Interceptor.Chain chain, StreamAllocation
   }
 
   /** Returns headers for a name value block containing an HTTP/2 response. */
-  public static Response.Builder readHttp2HeadersList(List<Header> headerBlock,
+  public static Response.Builder readHttp2HeadersList(Headers headerBlock,
       Protocol protocol) throws IOException {
     StatusLine statusLine = null;
     Headers.Builder headersBuilder = new Headers.Builder();
     for (int i = 0, size = headerBlock.size(); i < size; i++) {
-      Header header = headerBlock.get(i);
-
-      // If there were multiple header blocks they will be delimited by nulls. Discard existing
-      // header blocks if the existing header block is a '100 Continue' intermediate response.
-      if (header == null) {
-        if (statusLine != null && statusLine.code == HTTP_CONTINUE) {
-          statusLine = null;
-          headersBuilder = new Headers.Builder();
-        }
-        continue;
-      }
-
-      ByteString name = header.name;
-      String value = header.value.utf8();
-      if (name.equals(RESPONSE_STATUS)) {
+      String name = headerBlock.name(i);
+      String value = headerBlock.value(i);
+      if (name.equals(RESPONSE_STATUS_UTF8)) {
         statusLine = StatusLine.parse("HTTP/1.1 " + value);
       } else if (!HTTP_2_SKIPPED_RESPONSE_HEADERS.contains(name)) {
-        Internal.instance.addLenient(headersBuilder, name.utf8(), value);
+        Internal.instance.addLenient(headersBuilder, name, value);
       }
     }
     if (statusLine == null) throw new ProtocolException("Expected ':status' header not present");
@@ -196,7 +195,12 @@ public Http2Codec(OkHttpClient client, Interceptor.Chain chain, StreamAllocation
     return new RealResponseBody(contentType, contentLength, Okio.buffer(source));
   }
 
+  @Override public Headers trailers() throws IOException {
+    return stream.trailers();
+  }
+
   @Override public void cancel() {
+    canceled = true;
     if (stream != null) stream.closeLater(ErrorCode.CANCEL);
   }
 
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java
index 0920c41eeb..cf1413f886 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java
@@ -20,6 +20,7 @@
 import java.io.InterruptedIOException;
 import java.net.InetSocketAddress;
 import java.net.Socket;
+import java.net.SocketAddress;
 import java.util.LinkedHashMap;
 import java.util.LinkedHashSet;
 import java.util.List;
@@ -33,7 +34,7 @@
 import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
-import okhttp3.Protocol;
+import okhttp3.Headers;
 import okhttp3.internal.NamedRunnable;
 import okhttp3.internal.Util;
 import okhttp3.internal.platform.Platform;
@@ -78,7 +79,7 @@
    * threads because listeners are not required to return promptly.
    */
   private static final ExecutorService listenerExecutor = new ThreadPoolExecutor(0,
-      Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(),
+      Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue<>(),
       Util.threadFactory("OkHttp Http2Connection", true));
 
   /** True if this peer initiated the connection. */
@@ -90,7 +91,7 @@
    */
   final Listener listener;
   final Map<Integer, Http2Stream> streams = new LinkedHashMap<>();
-  final String hostname;
+  final String connectionName;
   int lastGoodStreamId;
   int nextStreamId;
   boolean shutdown;
@@ -152,19 +153,18 @@
       okHttpSettings.set(Settings.INITIAL_WINDOW_SIZE, OKHTTP_CLIENT_WINDOW_SIZE);
     }
 
-    hostname = builder.hostname;
+    connectionName = builder.connectionName;
 
     writerExecutor = new ScheduledThreadPoolExecutor(1,
-        Util.threadFactory(Util.format("OkHttp %s Writer", hostname), false));
+        Util.threadFactory(Util.format("OkHttp %s Writer", connectionName), false));
     if (builder.pingIntervalMillis != 0) {
       writerExecutor.scheduleAtFixedRate(new PingRunnable(false, 0, 0),
           builder.pingIntervalMillis, builder.pingIntervalMillis, MILLISECONDS);
     }
 
     // Like newSingleThreadExecutor, except lazy creates the thread.
-    pushExecutor = new ThreadPoolExecutor(0, 1, 60, TimeUnit.SECONDS,
-        new LinkedBlockingQueue<Runnable>(),
-        Util.threadFactory(Util.format("OkHttp %s Push Observer", hostname), true));
+    pushExecutor = new ThreadPoolExecutor(0, 1, 60, TimeUnit.SECONDS, new LinkedBlockingQueue<>(),
+        Util.threadFactory(Util.format("OkHttp %s Push Observer", connectionName), true));
     peerSettings.set(Settings.INITIAL_WINDOW_SIZE, DEFAULT_INITIAL_WINDOW_SIZE);
     peerSettings.set(Settings.MAX_FRAME_SIZE, Http2.INITIAL_MAX_FRAME_SIZE);
     bytesLeftInWriteWindow = peerSettings.getInitialWindowSize();
@@ -174,11 +174,6 @@
     readerRunnable = new ReaderRunnable(new Http2Reader(builder.source, client));
   }
 
-  /** The protocol as selected using ALPN. */
-  public Protocol getProtocol() {
-    return Protocol.HTTP_2;
-  }
-
   /**
    * Returns the number of {@link Http2Stream#isOpen() open streams} on this connection.
    */
@@ -248,14 +243,14 @@ private Http2Stream newStream(
         }
         streamId = nextStreamId;
         nextStreamId += 2;
-        stream = new Http2Stream(streamId, this, outFinished, inFinished, requestHeaders);
+        stream = new Http2Stream(streamId, this, outFinished, inFinished, null);
         flushHeaders = !out || bytesLeftInWriteWindow == 0L || stream.bytesLeftInWriteWindow == 0L;
         if (stream.isOpen()) {
           streams.put(streamId, stream);
         }
       }
       if (associatedStreamId == 0) {
-        writer.synStream(outFinished, streamId, associatedStreamId, requestHeaders);
+        writer.headers(outFinished, streamId, requestHeaders);
       } else if (client) {
         throw new IllegalArgumentException("client streams shouldn't have associated stream IDs");
       } else { // HTTP/2 has a PUSH_PROMISE frame.
@@ -270,9 +265,9 @@ private Http2Stream newStream(
     return stream;
   }
 
-  void writeSynReply(int streamId, boolean outFinished, List<Header> alternating)
+  void writeHeaders(int streamId, boolean outFinished, List<Header> alternating)
       throws IOException {
-    writer.synReply(outFinished, streamId, alternating);
+    writer.headers(outFinished, streamId, alternating);
   }
 
   /**
@@ -323,7 +318,7 @@ public void writeData(int streamId, boolean outFinished, Buffer buffer, long byt
 
   void writeSynResetLater(final int streamId, final ErrorCode errorCode) {
     try {
-      writerExecutor.execute(new NamedRunnable("OkHttp %s stream %d", hostname, streamId) {
+      writerExecutor.execute(new NamedRunnable("OkHttp %s stream %d", connectionName, streamId) {
         @Override public void execute() {
           try {
             writeSynReset(streamId, errorCode);
@@ -344,7 +339,7 @@ void writeSynReset(int streamId, ErrorCode statusCode) throws IOException {
   void writeWindowUpdateLater(final int streamId, final long unacknowledgedBytesRead) {
     try {
       writerExecutor.execute(
-          new NamedRunnable("OkHttp Window Update %s stream %d", hostname, streamId) {
+          new NamedRunnable("OkHttp Window Update %s stream %d", connectionName, streamId) {
             @Override public void execute() {
               try {
                 writer.windowUpdate(streamId, unacknowledgedBytesRead);
@@ -364,7 +359,7 @@ void writeWindowUpdateLater(final int streamId, final long unacknowledgedBytesRe
     final int payload2;
 
     PingRunnable(boolean reply, int payload1, int payload2) {
-      super("OkHttp %s ping %08x%08x", hostname, payload1, payload2);
+      super("OkHttp %s ping %08x%08x", connectionName, payload1, payload2);
       this.reply = reply;
       this.payload1 = payload1;
       this.payload2 = payload2;
@@ -539,7 +534,7 @@ public synchronized boolean isShutdown() {
 
   public static class Builder {
     Socket socket;
-    String hostname;
+    String connectionName;
     BufferedSource source;
     BufferedSink sink;
     Listener listener = Listener.REFUSE_INCOMING_STREAMS;
@@ -556,14 +551,18 @@ public Builder(boolean client) {
     }
 
     public Builder socket(Socket socket) throws IOException {
-      return socket(socket, ((InetSocketAddress) socket.getRemoteSocketAddress()).getHostName(),
+      SocketAddress remoteSocketAddress = socket.getRemoteSocketAddress();
+      String connectionName = remoteSocketAddress instanceof InetSocketAddress
+          ? ((InetSocketAddress) remoteSocketAddress).getHostName()
+          : remoteSocketAddress.toString();
+      return socket(socket, connectionName,
           Okio.buffer(Okio.source(socket)), Okio.buffer(Okio.sink(socket)));
     }
 
     public Builder socket(
-        Socket socket, String hostname, BufferedSource source, BufferedSink sink) {
+        Socket socket, String connectionName, BufferedSource source, BufferedSink sink) {
       this.socket = socket;
-      this.hostname = hostname;
+      this.connectionName = connectionName;
       this.source = source;
       this.sink = sink;
       return this;
@@ -597,7 +596,7 @@ public Http2Connection build() {
     final Http2Reader reader;
 
     ReaderRunnable(Http2Reader reader) {
-      super("OkHttp %s", hostname);
+      super("OkHttp %s", connectionName);
       this.reader = reader;
     }
 
@@ -637,7 +636,7 @@ public Http2Connection build() {
       }
       dataStream.receiveData(source, length);
       if (inFinished) {
-        dataStream.receiveFin();
+        dataStream.receiveHeaders(Util.EMPTY_HEADERS, true);
       }
     }
 
@@ -662,16 +661,19 @@ public Http2Connection build() {
           if (streamId % 2 == nextStreamId % 2) return;
 
           // Create a stream.
+          Headers headers = Util.toHeaders(headerBlock);
           final Http2Stream newStream = new Http2Stream(streamId, Http2Connection.this,
-              false, inFinished, headerBlock);
+              false, inFinished, headers);
           lastGoodStreamId = streamId;
           streams.put(streamId, newStream);
-          listenerExecutor.execute(new NamedRunnable("OkHttp %s stream %d", hostname, streamId) {
+          listenerExecutor.execute(new NamedRunnable(
+              "OkHttp %s stream %d", connectionName, streamId) {
             @Override public void execute() {
               try {
                 listener.onStream(newStream);
               } catch (IOException e) {
-                Platform.get().log(INFO, "Http2Connection.Listener failure for " + hostname, e);
+                Platform.get().log(
+                    INFO, "Http2Connection.Listener failure for " + connectionName, e);
                 try {
                   newStream.close(ErrorCode.PROTOCOL_ERROR);
                 } catch (IOException ignored) {
@@ -684,8 +686,7 @@ public Http2Connection build() {
       }
 
       // Update an existing stream.
-      stream.receiveHeaders(headerBlock);
-      if (inFinished) stream.receiveFin();
+      stream.receiveHeaders(Util.toHeaders(headerBlock), inFinished);
     }
 
     @Override public void rstStream(int streamId, ErrorCode errorCode) {
@@ -717,7 +718,7 @@ public Http2Connection build() {
             streamsToNotify = streams.values().toArray(new Http2Stream[streams.size()]);
           }
         }
-        listenerExecutor.execute(new NamedRunnable("OkHttp %s settings", hostname) {
+        listenerExecutor.execute(new NamedRunnable("OkHttp %s settings", connectionName) {
           @Override public void execute() {
             listener.onSettings(Http2Connection.this);
           }
@@ -734,7 +735,7 @@ public Http2Connection build() {
 
     private void applyAndAckSettings(final Settings peerSettings) {
       try {
-        writerExecutor.execute(new NamedRunnable("OkHttp %s ACK Settings", hostname) {
+        writerExecutor.execute(new NamedRunnable("OkHttp %s ACK Settings", connectionName) {
           @Override public void execute() {
             try {
               writer.applyAndAckSettings(peerSettings);
@@ -837,7 +838,8 @@ void pushRequestLater(final int streamId, final List<Header> requestHeaders) {
       currentPushRequests.add(streamId);
     }
     try {
-      pushExecutorExecute(new NamedRunnable("OkHttp %s Push Request[%s]", hostname, streamId) {
+      pushExecutorExecute(new NamedRunnable(
+          "OkHttp %s Push Request[%s]", connectionName, streamId) {
         @Override public void execute() {
           boolean cancel = pushObserver.onRequest(streamId, requestHeaders);
           try {
@@ -859,7 +861,8 @@ void pushRequestLater(final int streamId, final List<Header> requestHeaders) {
   void pushHeadersLater(final int streamId, final List<Header> requestHeaders,
       final boolean inFinished) {
     try {
-      pushExecutorExecute(new NamedRunnable("OkHttp %s Push Headers[%s]", hostname, streamId) {
+      pushExecutorExecute(new NamedRunnable(
+          "OkHttp %s Push Headers[%s]", connectionName, streamId) {
         @Override public void execute() {
           boolean cancel = pushObserver.onHeaders(streamId, requestHeaders, inFinished);
           try {
@@ -888,7 +891,7 @@ void pushDataLater(final int streamId, final BufferedSource source, final int by
     source.require(byteCount); // Eagerly read the frame before firing client thread.
     source.read(buffer, byteCount);
     if (buffer.size() != byteCount) throw new IOException(buffer.size() + " != " + byteCount);
-    pushExecutorExecute(new NamedRunnable("OkHttp %s Push Data[%s]", hostname, streamId) {
+    pushExecutorExecute(new NamedRunnable("OkHttp %s Push Data[%s]", connectionName, streamId) {
       @Override public void execute() {
         try {
           boolean cancel = pushObserver.onData(streamId, buffer, byteCount, inFinished);
@@ -905,7 +908,7 @@ void pushDataLater(final int streamId, final BufferedSource source, final int by
   }
 
   void pushResetLater(final int streamId, final ErrorCode errorCode) {
-    pushExecutorExecute(new NamedRunnable("OkHttp %s Push Reset[%s]", hostname, streamId) {
+    pushExecutorExecute(new NamedRunnable("OkHttp %s Push Reset[%s]", connectionName, streamId) {
       @Override public void execute() {
         pushObserver.onReset(streamId, errorCode);
         synchronized (Http2Connection.this) {
@@ -931,7 +934,7 @@ private synchronized void pushExecutorExecute(NamedRunnable namedRunnable) {
 
     /**
      * Handle a new stream from this connection's peer. Implementations should respond by either
-     * {@linkplain Http2Stream#sendResponseHeaders replying to the stream} or {@linkplain
+     * {@linkplain Http2Stream#writeHeaders replying to the stream} or {@linkplain
      * Http2Stream#close closing it}. This response does not need to be synchronous.
      */
     public abstract void onStream(Http2Stream stream) throws IOException;
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.java
index 5bdcd719d3..3431901fa5 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.java
@@ -19,8 +19,12 @@
 import java.io.IOException;
 import java.io.InterruptedIOException;
 import java.net.SocketTimeoutException;
-import java.util.ArrayList;
+import java.util.ArrayDeque;
+import java.util.Deque;
 import java.util.List;
+import javax.annotation.Nullable;
+import okhttp3.Headers;
+import okhttp3.internal.Util;
 import okio.AsyncTimeout;
 import okio.Buffer;
 import okio.BufferedSource;
@@ -51,11 +55,11 @@
   final int id;
   final Http2Connection connection;
 
-  /** Request headers. Immutable and non null. */
-  private final List<Header> requestHeaders;
-
-  /** Response headers yet to be {@linkplain #takeResponseHeaders taken}. */
-  private List<Header> responseHeaders;
+  /**
+   * Received headers yet to be {@linkplain #takeHeaders taken}, or {@linkplain FramingSource#read
+   * read}.
+   */
+  private final Deque<Headers> headersQueue = new ArrayDeque<>();
 
   /** True if response headers have been sent or received. */
   private boolean hasResponseHeaders;
@@ -73,9 +77,9 @@
   ErrorCode errorCode = null;
 
   Http2Stream(int id, Http2Connection connection, boolean outFinished, boolean inFinished,
-      List<Header> requestHeaders) {
+      @Nullable Headers headers) {
     if (connection == null) throw new NullPointerException("connection == null");
-    if (requestHeaders == null) throw new NullPointerException("requestHeaders == null");
+
     this.id = id;
     this.connection = connection;
     this.bytesLeftInWriteWindow =
@@ -84,7 +88,15 @@
     this.sink = new FramingSink();
     this.source.finished = inFinished;
     this.sink.finished = outFinished;
-    this.requestHeaders = requestHeaders;
+    if (headers != null) {
+      headersQueue.add(headers);
+    }
+
+    if (isLocallyInitiated() && headers != null) {
+      throw new IllegalStateException("locally-initiated streams shouldn't have headers yet");
+    } else if (!isLocallyInitiated() && headers == null) {
+      throw new IllegalStateException("remotely-initiated streams should have headers");
+    }
   }
 
   public int getId() {
@@ -124,35 +136,40 @@ public Http2Connection getConnection() {
     return connection;
   }
 
-  public List<Header> getRequestHeaders() {
-    return requestHeaders;
-  }
-
   /**
    * Removes and returns the stream's received response headers, blocking if necessary until headers
    * have been received. If the returned list contains multiple blocks of headers the blocks will be
    * delimited by 'null'.
    */
-  public synchronized List<Header> takeResponseHeaders() throws IOException {
-    if (!isLocallyInitiated()) {
-      throw new IllegalStateException("servers cannot read response headers");
-    }
+  public synchronized Headers takeHeaders() throws IOException {
     readTimeout.enter();
     try {
-      while (responseHeaders == null && errorCode == null) {
+      while (headersQueue.isEmpty() && errorCode == null) {
         waitForIo();
       }
     } finally {
       readTimeout.exitAndThrowIfTimedOut();
     }
-    List<Header> result = responseHeaders;
-    if (result != null) {
-      responseHeaders = null;
-      return result;
+    if (!headersQueue.isEmpty()) {
+      return headersQueue.removeFirst();
     }
     throw new StreamResetException(errorCode);
   }
 
+  /**
+   * Returns the trailers. It is only safe to call this once the source stream has been completely
+   * exhausted.
+   */
+  public synchronized Headers trailers() throws IOException {
+    if (errorCode != null) {
+      throw new StreamResetException(errorCode);
+    }
+    if (!source.finished || !source.receiveBuffer.exhausted() || !source.readBuffer.exhausted()) {
+      throw new IllegalStateException("too early; can't read the trailers yet");
+    }
+    return source.trailers != null ? source.trailers : Util.EMPTY_HEADERS;
+  }
+
   /**
    * Returns the reason why this stream was closed, or null if it closed normally or has not yet
    * been closed.
@@ -164,22 +181,21 @@ public synchronized ErrorCode getErrorCode() {
   /**
    * Sends a reply to an incoming stream.
    *
-   * @param out true to create an output stream that we can use to send data to the remote peer.
-   * Corresponds to {@code FLAG_FIN}.
+   * @param outFinished true to eagerly finish the output stream to send data to the remote peer.
+   *     Corresponds to {@code FLAG_FIN}.
+   * @param flushHeaders true to force flush the response headers. This should be true unless the
+   *     response body exists and will be written immediately.
    */
-  public void sendResponseHeaders(List<Header> responseHeaders, boolean out) throws IOException {
+  public void writeHeaders(List<Header> responseHeaders, boolean outFinished, boolean flushHeaders)
+      throws IOException {
     assert (!Thread.holdsLock(Http2Stream.this));
     if (responseHeaders == null) {
-      throw new NullPointerException("responseHeaders == null");
+      throw new NullPointerException("headers == null");
     }
-    boolean outFinished = false;
-    boolean flushHeaders = false;
     synchronized (this) {
       this.hasResponseHeaders = true;
-      if (!out) {
+      if (outFinished) {
         this.sink.finished = true;
-        flushHeaders = true;
-        outFinished = true;
       }
     }
 
@@ -191,13 +207,21 @@ public void sendResponseHeaders(List<Header> responseHeaders, boolean out) throw
       }
     }
 
-    connection.writeSynReply(id, outFinished, responseHeaders);
+    connection.writeHeaders(id, outFinished, responseHeaders);
 
     if (flushHeaders) {
       connection.flush();
     }
   }
 
+  public void enqueueTrailers(Headers trailers) {
+    synchronized (this) {
+      if (sink.finished) throw new IllegalStateException("already finished");
+      if (trailers.size() == 0) throw new IllegalArgumentException("trailers.size() == 0");
+      this.sink.trailers = trailers;
+    }
+  }
+
   public Timeout readTimeout() {
     return readTimeout;
   }
@@ -215,7 +239,7 @@ public Source getSource() {
    * Returns a sink that can be used to write data to the peer.
    *
    * @throws IllegalStateException if this stream was initiated by the peer and a {@link
-   * #sendResponseHeaders} has not yet been sent.
+   *     #writeHeaders} has not yet been sent.
    */
   public Sink getSink() {
     synchronized (this) {
@@ -265,38 +289,28 @@ private boolean closeInternal(ErrorCode errorCode) {
     return true;
   }
 
-  void receiveHeaders(List<Header> headers) {
-    assert (!Thread.holdsLock(Http2Stream.this));
-    boolean open = true;
-    synchronized (this) {
-      hasResponseHeaders = true;
-      if (responseHeaders == null) {
-        responseHeaders = headers;
-        open = isOpen();
-        notifyAll();
-      } else {
-        List<Header> newHeaders = new ArrayList<>();
-        newHeaders.addAll(responseHeaders);
-        newHeaders.add(null); // Delimit separate blocks of headers with null.
-        newHeaders.addAll(headers);
-        this.responseHeaders = newHeaders;
-      }
-    }
-    if (!open) {
-      connection.removeStream(id);
-    }
-  }
-
   void receiveData(BufferedSource in, int length) throws IOException {
     assert (!Thread.holdsLock(Http2Stream.this));
     this.source.receive(in, length);
   }
 
-  void receiveFin() {
+  /**
+   * Accept headers from the network and store them until the client calls {@link #takeHeaders}, or
+   * {@link FramingSource#read} them.
+   */
+  void receiveHeaders(Headers headers, boolean inFinished) {
     assert (!Thread.holdsLock(Http2Stream.this));
     boolean open;
     synchronized (this) {
-      this.source.finished = true;
+      if (!hasResponseHeaders || !inFinished) {
+        hasResponseHeaders = true;
+        headersQueue.add(headers);
+      } else {
+        this.source.trailers = headers;
+      }
+      if (inFinished) {
+        this.source.finished = true;
+      }
       open = isOpen();
       notifyAll();
     }
@@ -327,6 +341,12 @@ synchronized void receiveRstStream(ErrorCode errorCode) {
     /** Maximum number of bytes to buffer before reporting a flow control error. */
     private final long maxByteCount;
 
+    /**
+     * Received trailers. Null unless the server has provided trailers. Undefined until the stream
+     * is exhausted. Guarded by Http2Stream.this.
+     */
+    private Headers trailers;
+
     /** True if the caller has closed this stream. */
     boolean closed;
 
@@ -343,45 +363,64 @@ synchronized void receiveRstStream(ErrorCode errorCode) {
     @Override public long read(Buffer sink, long byteCount) throws IOException {
       if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
 
-      long read = -1;
-      ErrorCode errorCode;
-      synchronized (Http2Stream.this) {
-        waitUntilReadable();
-        if (closed) {
-          throw new IOException("stream closed");
-        }
-        errorCode = Http2Stream.this.errorCode;
+      while (true) {
+        long readBytesDelivered = -1;
+        ErrorCode errorCodeToDeliver = null;
 
-        if (readBuffer.size() > 0) {
-          // Move bytes from the read buffer into the caller's buffer.
-          read = readBuffer.read(sink, Math.min(byteCount, readBuffer.size()));
-          unacknowledgedBytesRead += read;
+        // 1. Decide what to do in a synchronized block.
+
+        synchronized (Http2Stream.this) {
+          readTimeout.enter();
+          try {
+            if (errorCode != null) {
+              // Prepare to deliver an error.
+              errorCodeToDeliver = errorCode;
+            }
+
+            if (closed) {
+              throw new IOException("stream closed");
+
+            } else if (readBuffer.size() > 0) {
+              // Prepare to read bytes. Start by moving them to the caller's buffer.
+              readBytesDelivered = readBuffer.read(sink, Math.min(byteCount, readBuffer.size()));
+              unacknowledgedBytesRead += readBytesDelivered;
+
+              if (errorCodeToDeliver == null
+                  && unacknowledgedBytesRead
+                  >= connection.okHttpSettings.getInitialWindowSize() / 2) {
+                // Flow control: notify the peer that we're ready for more data! Only send a
+                // WINDOW_UPDATE if the stream isn't in error.
+                connection.writeWindowUpdateLater(id, unacknowledgedBytesRead);
+                unacknowledgedBytesRead = 0;
+              }
+            } else if (!finished && errorCodeToDeliver == null) {
+              // Nothing to do. Wait until that changes then try again.
+              waitForIo();
+              continue;
+            }
+          } finally {
+            readTimeout.exitAndThrowIfTimedOut();
+          }
         }
 
-        if (errorCode == null
-            && unacknowledgedBytesRead >= connection.okHttpSettings.getInitialWindowSize() / 2) {
-          // Flow control: notify the peer that we're ready for more data! Only send a WINDOW_UPDATE
-          // if the stream isn't in error.
-          connection.writeWindowUpdateLater(id, unacknowledgedBytesRead);
-          unacknowledgedBytesRead = 0;
+        // 2. Do it outside of the synchronized block and timeout.
+
+        if (readBytesDelivered != -1) {
+          // Update connection.unacknowledgedBytesRead outside the synchronized block.
+          updateConnectionFlowControl(readBytesDelivered);
+          return readBytesDelivered;
         }
-      }
 
-      if (read != -1) {
-        // Update connection.unacknowledgedBytesRead outside the stream lock.
-        updateConnectionFlowControl(read);
-        return read;
-      }
+        if (errorCodeToDeliver != null) {
+          // We defer throwing the exception until now so that we can refill the connection
+          // flow-control window. This is necessary because we don't transmit window updates until
+          // the application reads the data. If we throw this prior to updating the connection
+          // flow-control window, we risk having it go to 0 preventing the server from sending data.
+          throw new StreamResetException(errorCodeToDeliver);
+        }
 
-      if (errorCode != null) {
-        // We defer throwing the exception until now so that we can refill the connection
-        // flow-control window. This is necessary because we don't transmit window updates until the
-        // application reads the data. If we throw this prior to updating the connection
-        // flow-control window, we risk having it go to 0 preventing the server from sending data.
-        throw new StreamResetException(errorCode);
+        return -1; // This source is exhausted.
       }
-
-      return -1; // This source is exhausted.
     }
 
     private void updateConnectionFlowControl(long read) {
@@ -389,18 +428,6 @@ private void updateConnectionFlowControl(long read) {
       connection.updateConnectionFlowControl(read);
     }
 
-    /** Returns once the source is either readable or finished. */
-    private void waitUntilReadable() throws IOException {
-      readTimeout.enter();
-      try {
-        while (readBuffer.size() == 0 && !finished && !closed && errorCode == null) {
-          waitForIo();
-        }
-      } finally {
-        readTimeout.exitAndThrowIfTimedOut();
-      }
-    }
-
     void receive(BufferedSource in, long byteCount) throws IOException {
       assert (!Thread.holdsLock(Http2Stream.this));
 
@@ -451,7 +478,7 @@ void receive(BufferedSource in, long byteCount) throws IOException {
         closed = true;
         bytesDiscarded = readBuffer.size();
         readBuffer.clear();
-        Http2Stream.this.notifyAll();
+        Http2Stream.this.notifyAll(); // TODO(jwilson): Unnecessary?
       }
       if (bytesDiscarded > 0) {
         updateConnectionFlowControl(bytesDiscarded);
@@ -489,6 +516,9 @@ void cancelStreamIfNecessary() throws IOException {
      */
     private final Buffer sendBuffer = new Buffer();
 
+    /** Trailers to send at the end of the stream. */
+    private Headers trailers;
+
     boolean closed;
 
     /**
@@ -508,7 +538,7 @@ void cancelStreamIfNecessary() throws IOException {
      * Emit a single data frame to the connection. The frame's size be limited by this stream's
      * write window. This method will block until the write window is nonempty.
      */
-    private void emitFrame(boolean outFinished) throws IOException {
+    private void emitFrame(boolean outFinishedOnLastFrame) throws IOException {
       long toWrite;
       synchronized (Http2Stream.this) {
         writeTimeout.enter();
@@ -527,7 +557,8 @@ private void emitFrame(boolean outFinished) throws IOException {
 
       writeTimeout.enter();
       try {
-        connection.writeData(id, outFinished && toWrite == sendBuffer.size(), sendBuffer, toWrite);
+        boolean outFinished = outFinishedOnLastFrame && toWrite == sendBuffer.size();
+        connection.writeData(id, outFinished, sendBuffer, toWrite);
       } finally {
         writeTimeout.exitAndThrowIfTimedOut();
       }
@@ -554,13 +585,21 @@ private void emitFrame(boolean outFinished) throws IOException {
         if (closed) return;
       }
       if (!sink.finished) {
-        // Emit the remaining data, setting the END_STREAM flag on the last frame.
-        if (sendBuffer.size() > 0) {
+        // We have 0 or more frames of data, and 0 or more frames of trailers. We need to send at
+        // least one frame with the END_STREAM flag set. That must be the last frame, and the
+        // trailers must be sent after all of the data.
+        boolean hasData = sendBuffer.size() > 0;
+        boolean hasTrailers = trailers != null;
+        if (hasTrailers) {
+          while (sendBuffer.size() > 0) {
+            emitFrame(false);
+          }
+          connection.writeHeaders(id, true, Util.toHeaderBlock(trailers));
+        } else if (hasData) {
           while (sendBuffer.size() > 0) {
             emitFrame(true);
           }
         } else {
-          // Send an empty frame just so we can set the END_STREAM flag.
           connection.writeData(id, true, null, 0);
         }
       }
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Writer.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Writer.java
index 5ef6bb9c4a..b6456949de 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Writer.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Writer.java
@@ -121,24 +121,6 @@ public synchronized void flush() throws IOException {
     sink.flush();
   }
 
-  public synchronized void synStream(boolean outFinished, int streamId,
-      int associatedStreamId, List<Header> headerBlock) throws IOException {
-    if (closed) throw new IOException("closed");
-    headers(outFinished, streamId, headerBlock);
-  }
-
-  public synchronized void synReply(boolean outFinished, int streamId,
-      List<Header> headerBlock) throws IOException {
-    if (closed) throw new IOException("closed");
-    headers(outFinished, streamId, headerBlock);
-  }
-
-  public synchronized void headers(int streamId, List<Header> headerBlock)
-      throws IOException {
-    if (closed) throw new IOException("closed");
-    headers(false, streamId, headerBlock);
-  }
-
   public synchronized void rstStream(int streamId, ErrorCode errorCode)
       throws IOException {
     if (closed) throw new IOException("closed");
@@ -294,7 +276,8 @@ private void writeContinuationFrames(int streamId, long byteCount) throws IOExce
     }
   }
 
-  void headers(boolean outFinished, int streamId, List<Header> headerBlock) throws IOException {
+  public synchronized void headers(
+      boolean outFinished, int streamId, List<Header> headerBlock) throws IOException {
     if (closed) throw new IOException("closed");
     hpackWriter.writeHeaders(headerBlock);
 
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.java b/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.java
index 3721b6a5c7..9cbae145d5 100644
--- a/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.java
+++ b/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.java
@@ -24,9 +24,7 @@
 import java.net.InetSocketAddress;
 import java.net.Socket;
 import java.security.NoSuchAlgorithmException;
-import java.security.Security;
 import java.security.cert.Certificate;
-import java.security.cert.TrustAnchor;
 import java.security.cert.X509Certificate;
 import java.util.List;
 import javax.annotation.Nullable;
@@ -37,29 +35,24 @@
 import javax.net.ssl.X509TrustManager;
 import okhttp3.Protocol;
 import okhttp3.internal.Util;
-import okhttp3.internal.tls.BasicTrustRootIndex;
 import okhttp3.internal.tls.CertificateChainCleaner;
-import okhttp3.internal.tls.TrustRootIndex;
 
-import static okhttp3.internal.Util.assertionError;
+import static java.nio.charset.StandardCharsets.UTF_8;
 
-/** Android 2.3 or better. */
+/** Android 5+. */
 class AndroidPlatform extends Platform {
   private static final int MAX_LOG_LENGTH = 4000;
 
   private final Class<?> sslParametersClass;
-  private final OptionalMethod<Socket> setUseSessionTickets;
-  private final OptionalMethod<Socket> setHostname;
-
-  // Non-null on Android 5.0+.
-  private final OptionalMethod<Socket> getAlpnSelectedProtocol;
-  private final OptionalMethod<Socket> setAlpnProtocols;
+  private final Method setUseSessionTickets;
+  private final Method setHostname;
+  private final Method getAlpnSelectedProtocol;
+  private final Method setAlpnProtocols;
 
   private final CloseGuard closeGuard = CloseGuard.get();
 
-  AndroidPlatform(Class<?> sslParametersClass, OptionalMethod<Socket> setUseSessionTickets,
-      OptionalMethod<Socket> setHostname, OptionalMethod<Socket> getAlpnSelectedProtocol,
-      OptionalMethod<Socket> setAlpnProtocols) {
+  AndroidPlatform(Class<?> sslParametersClass, Method setUseSessionTickets, Method setHostname,
+      Method getAlpnSelectedProtocol, Method setAlpnProtocols) {
     this.sslParametersClass = sslParametersClass;
     this.setUseSessionTickets = setUseSessionTickets;
     this.setHostname = setHostname;
@@ -74,19 +67,11 @@
     } catch (AssertionError e) {
       if (Util.isAndroidGetsocknameError(e)) throw new IOException(e);
       throw e;
-    } catch (SecurityException e) {
-      // Before android 4.3, socket.connect could throw a SecurityException
-      // if opening a socket resulted in an EACCES error.
-      IOException ioException = new IOException("Exception in connect");
-      ioException.initCause(e);
-      throw ioException;
     } catch (ClassCastException e) {
       // On android 8.0, socket.connect throws a ClassCastException due to a bug
       // see https://issuetracker.google.com/issues/63649622
       if (Build.VERSION.SDK_INT == 26) {
-        IOException ioException = new IOException("Exception in connect");
-        ioException.initCause(e);
-        throw ioException;
+        throw new IOException("Exception in connect", e);
       } else {
         throw e;
       }
@@ -117,25 +102,28 @@
 
   @Override public void configureTlsExtensions(
       SSLSocket sslSocket, String hostname, List<Protocol> protocols) {
-    // Enable SNI and session tickets.
-    if (hostname != null) {
-      setUseSessionTickets.invokeOptionalWithoutCheckedException(sslSocket, true);
-      setHostname.invokeOptionalWithoutCheckedException(sslSocket, hostname);
-    }
+    try {
+      // Enable SNI and session tickets.
+      if (hostname != null) {
+        setUseSessionTickets.invoke(sslSocket, true);
+        // This is SSLParameters.setServerNames() in API 24+.
+        setHostname.invoke(sslSocket, hostname);
+      }
 
-    // Enable ALPN.
-    if (setAlpnProtocols != null && setAlpnProtocols.isSupported(sslSocket)) {
-      Object[] parameters = {concatLengthPrefixed(protocols)};
-      setAlpnProtocols.invokeWithoutCheckedException(sslSocket, parameters);
+      // Enable ALPN.
+      setAlpnProtocols.invoke(sslSocket, concatLengthPrefixed(protocols));
+    } catch (IllegalAccessException | InvocationTargetException e) {
+      throw new AssertionError(e);
     }
   }
 
   @Override public @Nullable String getSelectedProtocol(SSLSocket socket) {
-    if (getAlpnSelectedProtocol == null) return null;
-    if (!getAlpnSelectedProtocol.isSupported(socket)) return null;
-
-    byte[] alpnResult = (byte[]) getAlpnSelectedProtocol.invokeWithoutCheckedException(socket);
-    return alpnResult != null ? new String(alpnResult, Util.UTF_8) : null;
+    try {
+      byte[] alpnResult = (byte[]) getAlpnSelectedProtocol.invoke(socket);
+      return alpnResult != null ? new String(alpnResult, UTF_8) : null;
+    } catch (IllegalAccessException | InvocationTargetException e) {
+      throw new AssertionError(e);
+    }
   }
 
   @Override public void log(int level, String message, @Nullable Throwable t) {
@@ -175,7 +163,7 @@
     } catch (ClassNotFoundException | NoSuchMethodException e) {
       return super.isCleartextTrafficPermitted(hostname);
     } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
-      throw assertionError("unable to determine cleartext support", e);
+      throw new AssertionError("unable to determine cleartext support", e);
     }
   }
 
@@ -201,23 +189,6 @@ private boolean api23IsCleartextTrafficPermitted(String hostname, Class<?> netwo
     }
   }
 
-  /**
-   * Checks to see if Google Play Services Dynamic Security Provider is present which provides ALPN
-   * support. If it isn't checks to see if device is Android 5.0+ since 4.x device have broken
-   * ALPN support.
-   */
-  private static boolean supportsAlpn() {
-    if (Security.getProvider("GMSCore_OpenSSL") != null) {
-      return true;
-    } else {
-      try {
-        Class.forName("android.net.Network"); // Arbitrary class added in Android 5.0.
-        return true;
-      } catch (ClassNotFoundException ignored) { }
-    }
-    return false;
-  }
-
   public CertificateChainCleaner buildCertificateChainCleaner(X509TrustManager trustManager) {
     try {
       Class<?> extensionsClass = Class.forName("android.net.http.X509TrustManagerExtensions");
@@ -227,58 +198,34 @@ public CertificateChainCleaner buildCertificateChainCleaner(X509TrustManager tru
           "checkServerTrusted", X509Certificate[].class, String.class, String.class);
       return new AndroidCertificateChainCleaner(extensions, checkServerTrusted);
     } catch (Exception e) {
-      return super.buildCertificateChainCleaner(trustManager);
+      throw new AssertionError(e);
     }
   }
 
-  public static Platform buildIfSupported() {
-    // Attempt to find Android 2.3+ APIs.
+  public static @Nullable Platform buildIfSupported() {
+    // Attempt to find Android 5+ APIs.
+    Class<?> sslParametersClass;
+    Class<?> sslSocketClass;
     try {
-      Class<?> sslParametersClass;
-      try {
-        sslParametersClass = Class.forName("com.android.org.conscrypt.SSLParametersImpl");
-      } catch (ClassNotFoundException e) {
-        // Older platform before being unbundled.
-        sslParametersClass = Class.forName(
-            "org.apache.harmony.xnet.provider.jsse.SSLParametersImpl");
-      }
-
-      OptionalMethod<Socket> setUseSessionTickets = new OptionalMethod<>(
-          null, "setUseSessionTickets", boolean.class);
-      OptionalMethod<Socket> setHostname = new OptionalMethod<>(
-          null, "setHostname", String.class);
-      OptionalMethod<Socket> getAlpnSelectedProtocol = null;
-      OptionalMethod<Socket> setAlpnProtocols = null;
-
-      if (supportsAlpn()) {
-        getAlpnSelectedProtocol
-            = new OptionalMethod<>(byte[].class, "getAlpnSelectedProtocol");
-        setAlpnProtocols
-            = new OptionalMethod<>(null, "setAlpnProtocols", byte[].class);
-      }
-
-      return new AndroidPlatform(sslParametersClass, setUseSessionTickets, setHostname,
-          getAlpnSelectedProtocol, setAlpnProtocols);
+      sslParametersClass = Class.forName("com.android.org.conscrypt.SSLParametersImpl");
+      sslSocketClass = Class.forName("com.android.org.conscrypt.OpenSSLSocketImpl");
     } catch (ClassNotFoundException ignored) {
-      // This isn't an Android runtime.
+      return null; // Not an Android runtime.
     }
-
-    return null;
-  }
-
-  @Override
-  public TrustRootIndex buildTrustRootIndex(X509TrustManager trustManager) {
-
-    try {
-      // From org.conscrypt.TrustManagerImpl, we want the method with this signature:
-      // private TrustAnchor findTrustAnchorByIssuerAndSignature(X509Certificate lastCert);
-      Method method = trustManager.getClass().getDeclaredMethod(
-              "findTrustAnchorByIssuerAndSignature", X509Certificate.class);
-      method.setAccessible(true);
-      return new AndroidTrustRootIndex(trustManager, method);
-    } catch (NoSuchMethodException e) {
-      return super.buildTrustRootIndex(trustManager);
+    if (Build.VERSION.SDK_INT >= 21) {
+      try {
+        Method setUseSessionTickets = sslSocketClass.getDeclaredMethod(
+            "setUseSessionTickets", boolean.class);
+        Method setHostname = sslSocketClass.getMethod("setHostname", String.class);
+        Method getAlpnSelectedProtocol = sslSocketClass.getMethod("getAlpnSelectedProtocol");
+        Method setAlpnProtocols = sslSocketClass.getMethod("setAlpnProtocols", byte[].class);
+        return new AndroidPlatform(sslParametersClass, setUseSessionTickets, setHostname,
+            getAlpnSelectedProtocol, setAlpnProtocols);
+      } catch (NoSuchMethodException ignored) {
+      }
     }
+    throw new IllegalStateException(
+        "Expected Android API level 21+ but was " + Build.VERSION.SDK_INT);
   }
 
   /**
@@ -379,59 +326,17 @@ static CloseGuard get() {
     }
   }
 
-  /**
-   * An index of trusted root certificates that exploits knowledge of Android implementation
-   * details. This class is potentially much faster to initialize than {@link BasicTrustRootIndex}
-   * because it doesn't need to load and index trusted CA certificates.
-   *
-   * <p>This class uses APIs added to Android in API 14 (Android 4.0, released October 2011). This
-   * class shouldn't be used in Android API 17 or better because those releases are better served by
-   * {@link AndroidPlatform.AndroidCertificateChainCleaner}.
-   */
-  static final class AndroidTrustRootIndex implements TrustRootIndex {
-    private final X509TrustManager trustManager;
-    private final Method findByIssuerAndSignatureMethod;
-
-    AndroidTrustRootIndex(X509TrustManager trustManager, Method findByIssuerAndSignatureMethod) {
-      this.findByIssuerAndSignatureMethod = findByIssuerAndSignatureMethod;
-      this.trustManager = trustManager;
-    }
-
-    @Override public X509Certificate findByIssuerAndSignature(X509Certificate cert) {
-      try {
-        TrustAnchor trustAnchor = (TrustAnchor) findByIssuerAndSignatureMethod.invoke(
-                trustManager, cert);
-        return trustAnchor != null
-                ? trustAnchor.getTrustedCert()
-                : null;
-      } catch (IllegalAccessException e) {
-        throw assertionError("unable to get issues and signature", e);
-      } catch (InvocationTargetException e) {
-        return null;
-      }
-    }
-
-    @Override
-    public boolean equals(Object obj) {
-      if (obj == this) {
-        return true;
-      }
-      if (!(obj instanceof AndroidTrustRootIndex)) {
-        return false;
-      }
-      AndroidTrustRootIndex that = (AndroidTrustRootIndex) obj;
-      return trustManager.equals(that.trustManager)
-              && findByIssuerAndSignatureMethod.equals(that.findByIssuerAndSignatureMethod);
-    }
-
-    @Override
-    public int hashCode() {
-      return trustManager.hashCode() + 31 * findByIssuerAndSignatureMethod.hashCode();
+  @Override public SSLContext getSSLContext() {
+    boolean tryTls12;
+    try {
+      tryTls12 = (Build.VERSION.SDK_INT >= 16 && Build.VERSION.SDK_INT < 22);
+    } catch (NoClassDefFoundError e) {
+      // Not a real Android runtime; probably RoboVM or MoE
+      // Try to load TLS 1.2 explicitly.
+      tryTls12 = true;
     }
-  }
 
-  @Override public SSLContext getSSLContext() {
-    if (Build.VERSION.SDK_INT >= 16 && Build.VERSION.SDK_INT < 22) {
+    if (tryTls12) {
       try {
         return SSLContext.getInstance("TLSv1.2");
       } catch (NoSuchAlgorithmException e) {
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/ConscryptPlatform.java b/okhttp/src/main/java/okhttp3/internal/platform/ConscryptPlatform.java
index 5050c067cb..e460595329 100644
--- a/okhttp/src/main/java/okhttp3/internal/platform/ConscryptPlatform.java
+++ b/okhttp/src/main/java/okhttp3/internal/platform/ConscryptPlatform.java
@@ -25,7 +25,6 @@
 import javax.net.ssl.X509TrustManager;
 import okhttp3.Protocol;
 import org.conscrypt.Conscrypt;
-import org.conscrypt.OpenSSLProvider;
 
 /**
  * Platform using Conscrypt (conscrypt.org) if installed as the first Security Provider.
@@ -37,7 +36,7 @@ private ConscryptPlatform() {
   }
 
   private Provider getProvider() {
-    return new OpenSSLProvider();
+    return Conscrypt.newProviderBuilder().provideTrustManager().build();
   }
 
   @Override public @Nullable X509TrustManager trustManager(SSLSocketFactory sslSocketFactory) {
@@ -88,16 +87,21 @@ private Provider getProvider() {
 
   @Override public SSLContext getSSLContext() {
     try {
-      return SSLContext.getInstance("TLS", getProvider());
+      return SSLContext.getInstance("TLSv1.3", getProvider());
     } catch (NoSuchAlgorithmException e) {
-      throw new IllegalStateException("No TLS provider", e);
+      try {
+        // Allow for Conscrypt 1.2
+        return SSLContext.getInstance("TLS", getProvider());
+      } catch (NoSuchAlgorithmException e2) {
+        throw new IllegalStateException("No TLS provider", e);
+      }
     }
   }
 
-  public static Platform buildIfSupported() {
+  public static ConscryptPlatform buildIfSupported() {
     try {
-      // trigger early exception over a fatal error
-      Class.forName("org.conscrypt.ConscryptEngineSocket");
+      // Trigger an early exception over a fatal error, prefer a RuntimeException over Error.
+      Class.forName("org.conscrypt.Conscrypt");
 
       if (!Conscrypt.isAvailable()) {
         return null;
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/JdkWithJettyBootPlatform.java b/okhttp/src/main/java/okhttp3/internal/platform/Jdk8WithJettyBootPlatform.java
similarity index 74%
rename from okhttp/src/main/java/okhttp3/internal/platform/JdkWithJettyBootPlatform.java
rename to okhttp/src/main/java/okhttp3/internal/platform/Jdk8WithJettyBootPlatform.java
index dee0b3fe53..64d5096e66 100644
--- a/okhttp/src/main/java/okhttp3/internal/platform/JdkWithJettyBootPlatform.java
+++ b/okhttp/src/main/java/okhttp3/internal/platform/Jdk8WithJettyBootPlatform.java
@@ -25,19 +25,15 @@
 import okhttp3.Protocol;
 import okhttp3.internal.Util;
 
-import static okhttp3.internal.Util.assertionError;
-
-/**
- * OpenJDK 7 or OpenJDK 8 with {@code org.mortbay.jetty.alpn/alpn-boot} in the boot class path.
- */
-class JdkWithJettyBootPlatform extends Platform {
+/** OpenJDK 8 with {@code org.mortbay.jetty.alpn:alpn-boot} in the boot class path. */
+class Jdk8WithJettyBootPlatform extends Platform {
   private final Method putMethod;
   private final Method getMethod;
   private final Method removeMethod;
   private final Class<?> clientProviderClass;
   private final Class<?> serverProviderClass;
 
-  JdkWithJettyBootPlatform(Method putMethod, Method getMethod, Method removeMethod,
+  Jdk8WithJettyBootPlatform(Method putMethod, Method getMethod, Method removeMethod,
       Class<?> clientProviderClass, Class<?> serverProviderClass) {
     this.putMethod = putMethod;
     this.getMethod = getMethod;
@@ -51,11 +47,11 @@
     List<String> names = alpnProtocolNames(protocols);
 
     try {
-      Object provider = Proxy.newProxyInstance(Platform.class.getClassLoader(),
-          new Class[] {clientProviderClass, serverProviderClass}, new JettyNegoProvider(names));
-      putMethod.invoke(null, sslSocket, provider);
+      Object alpnProvider = Proxy.newProxyInstance(Platform.class.getClassLoader(),
+          new Class[] {clientProviderClass, serverProviderClass}, new AlpnProvider(names));
+      putMethod.invoke(null, sslSocket, alpnProvider);
     } catch (InvocationTargetException | IllegalAccessException e) {
-      throw assertionError("unable to set alpn", e);
+      throw new AssertionError("failed to set ALPN", e);
     }
   }
 
@@ -63,14 +59,14 @@
     try {
       removeMethod.invoke(null, sslSocket);
     } catch (IllegalAccessException | InvocationTargetException e) {
-      throw assertionError("unable to remove alpn", e);
+      throw new AssertionError("failed to remove ALPN", e);
     }
   }
 
   @Override public @Nullable String getSelectedProtocol(SSLSocket socket) {
     try {
-      JettyNegoProvider provider =
-          (JettyNegoProvider) Proxy.getInvocationHandler(getMethod.invoke(null, socket));
+      AlpnProvider provider =
+          (AlpnProvider) Proxy.getInvocationHandler(getMethod.invoke(null, socket));
       if (!provider.unsupported && provider.selected == null) {
         Platform.get().log(INFO, "ALPN callback dropped: HTTP/2 is disabled. "
             + "Is alpn-boot on the boot class path?", null);
@@ -78,22 +74,22 @@
       }
       return provider.unsupported ? null : provider.selected;
     } catch (InvocationTargetException | IllegalAccessException e) {
-      throw assertionError("unable to get selected protocol", e);
+      throw new AssertionError("failed to get ALPN selected protocol", e);
     }
   }
 
   public static Platform buildIfSupported() {
     // Find Jetty's ALPN extension for OpenJDK.
     try {
-      String negoClassName = "org.eclipse.jetty.alpn.ALPN";
-      Class<?> negoClass = Class.forName(negoClassName);
-      Class<?> providerClass = Class.forName(negoClassName + "$Provider");
-      Class<?> clientProviderClass = Class.forName(negoClassName + "$ClientProvider");
-      Class<?> serverProviderClass = Class.forName(negoClassName + "$ServerProvider");
-      Method putMethod = negoClass.getMethod("put", SSLSocket.class, providerClass);
-      Method getMethod = negoClass.getMethod("get", SSLSocket.class);
-      Method removeMethod = negoClass.getMethod("remove", SSLSocket.class);
-      return new JdkWithJettyBootPlatform(
+      String alpnClassName = "org.eclipse.jetty.alpn.ALPN";
+      Class<?> alpnClass = Class.forName(alpnClassName);
+      Class<?> providerClass = Class.forName(alpnClassName + "$Provider");
+      Class<?> clientProviderClass = Class.forName(alpnClassName + "$ClientProvider");
+      Class<?> serverProviderClass = Class.forName(alpnClassName + "$ServerProvider");
+      Method putMethod = alpnClass.getMethod("put", SSLSocket.class, providerClass);
+      Method getMethod = alpnClass.getMethod("get", SSLSocket.class);
+      Method removeMethod = alpnClass.getMethod("remove", SSLSocket.class);
+      return new Jdk8WithJettyBootPlatform(
           putMethod, getMethod, removeMethod, clientProviderClass, serverProviderClass);
     } catch (ClassNotFoundException | NoSuchMethodException ignored) {
     }
@@ -105,7 +101,7 @@ public static Platform buildIfSupported() {
    * Handle the methods of ALPN's ClientProvider and ServerProvider without a compile-time
    * dependency on those interfaces.
    */
-  private static class JettyNegoProvider implements InvocationHandler {
+  private static class AlpnProvider implements InvocationHandler {
     /** This peer's supported protocols. */
     private final List<String> protocols;
     /** Set when remote peer notifies ALPN is unsupported. */
@@ -113,7 +109,7 @@ public static Platform buildIfSupported() {
     /** The protocol the server selected. */
     String selected;
 
-    JettyNegoProvider(List<String> protocols) {
+    AlpnProvider(List<String> protocols) {
       this.protocols = protocols;
     }
 
@@ -132,11 +128,12 @@ public static Platform buildIfSupported() {
         return protocols; // Client advertises these protocols.
       } else if ((methodName.equals("selectProtocol") || methodName.equals("select"))
           && String.class == returnType && args.length == 1 && args[0] instanceof List) {
-        List<String> peerProtocols = (List) args[0];
+        List<?> peerProtocols = (List) args[0];
         // Pick the first known protocol the peer advertises.
         for (int i = 0, size = peerProtocols.size(); i < size; i++) {
-          if (protocols.contains(peerProtocols.get(i))) {
-            return selected = peerProtocols.get(i);
+          String protocol = (String) peerProtocols.get(i);
+          if (protocols.contains(protocol)) {
+            return selected = protocol;
           }
         }
         return selected = protocols.get(0); // On no intersection, try peer's first protocol.
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/Jdk9Platform.java b/okhttp/src/main/java/okhttp3/internal/platform/Jdk9Platform.java
index 455e8bcbb8..07cb67c885 100644
--- a/okhttp/src/main/java/okhttp3/internal/platform/Jdk9Platform.java
+++ b/okhttp/src/main/java/okhttp3/internal/platform/Jdk9Platform.java
@@ -25,11 +25,7 @@
 import javax.net.ssl.X509TrustManager;
 import okhttp3.Protocol;
 
-import static okhttp3.internal.Util.assertionError;
-
-/**
- * OpenJDK 9+.
- */
+/** OpenJDK 9+. */
 final class Jdk9Platform extends Platform {
   final Method setProtocolMethod;
   final Method getProtocolMethod;
@@ -52,7 +48,7 @@ public void configureTlsExtensions(SSLSocket sslSocket, String hostname,
 
       sslSocket.setSSLParameters(sslParameters);
     } catch (IllegalAccessException | InvocationTargetException e) {
-      throw assertionError("unable to set ssl parameters", e);
+      throw new AssertionError("failed to set SSL parameters", e);
     }
   }
 
@@ -69,7 +65,7 @@ public void configureTlsExtensions(SSLSocket sslSocket, String hostname,
 
       return protocol;
     } catch (IllegalAccessException | InvocationTargetException e) {
-      throw assertionError("unable to get selected protocols", e);
+      throw new AssertionError("failed to get ALPN selected protocol", e);
     }
   }
 
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/OptionalMethod.java b/okhttp/src/main/java/okhttp3/internal/platform/OptionalMethod.java
deleted file mode 100644
index c26132fedb..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/platform/OptionalMethod.java
+++ /dev/null
@@ -1,174 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package okhttp3.internal.platform;
-
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.lang.reflect.Modifier;
-
-/**
- * Duck-typing for methods: Represents a method that may or may not be present on an object.
- *
- * @param <T> the type of the object the method might be on, typically an interface or base class
- */
-class OptionalMethod<T> {
-
-  /** The return type of the method. null means "don't care". */
-  private final Class<?> returnType;
-
-  private final String methodName;
-
-  private final Class[] methodParams;
-
-  /**
-   * Creates an optional method.
-   *
-   * @param returnType the return type to required, null if it does not matter
-   * @param methodName the name of the method
-   * @param methodParams the method parameter types
-   */
-  OptionalMethod(Class<?> returnType, String methodName, Class... methodParams) {
-    this.returnType = returnType;
-    this.methodName = methodName;
-    this.methodParams = methodParams;
-  }
-
-  /**
-   * Returns true if the method exists on the supplied {@code target}.
-   */
-  public boolean isSupported(T target) {
-    return getMethod(target.getClass()) != null;
-  }
-
-  /**
-   * Invokes the method on {@code target} with {@code args}. If the method does not exist or is not
-   * public then {@code null} is returned. See also {@link #invokeOptionalWithoutCheckedException}.
-   *
-   * @throws IllegalArgumentException if the arguments are invalid
-   * @throws InvocationTargetException if the invocation throws an exception
-   */
-  public Object invokeOptional(T target, Object... args) throws InvocationTargetException {
-    Method m = getMethod(target.getClass());
-    if (m == null) {
-      return null;
-    }
-    try {
-      return m.invoke(target, args);
-    } catch (IllegalAccessException e) {
-      return null;
-    }
-  }
-
-  /**
-   * Invokes the method on {@code target}.  If the method does not exist or is not public then
-   * {@code null} is returned. Any RuntimeException thrown by the method is thrown, checked
-   * exceptions are wrapped in an {@link AssertionError}.
-   *
-   * @throws IllegalArgumentException if the arguments are invalid
-   */
-  public Object invokeOptionalWithoutCheckedException(T target, Object... args) {
-    try {
-      return invokeOptional(target, args);
-    } catch (InvocationTargetException e) {
-      Throwable targetException = e.getTargetException();
-      if (targetException instanceof RuntimeException) {
-        throw (RuntimeException) targetException;
-      }
-      AssertionError error = new AssertionError("Unexpected exception");
-      error.initCause(targetException);
-      throw error;
-    }
-  }
-
-  /**
-   * Invokes the method on {@code target} with {@code args}. Throws an error if the method is not
-   * supported. See also {@link #invokeWithoutCheckedException(Object, Object...)}.
-   *
-   * @throws IllegalArgumentException if the arguments are invalid
-   * @throws InvocationTargetException if the invocation throws an exception
-   */
-  public Object invoke(T target, Object... args) throws InvocationTargetException {
-    Method m = getMethod(target.getClass());
-    if (m == null) {
-      throw new AssertionError("Method " + methodName + " not supported for object " + target);
-    }
-    try {
-      return m.invoke(target, args);
-    } catch (IllegalAccessException e) {
-      // Method should be public: we checked.
-      AssertionError error = new AssertionError("Unexpectedly could not call: " + m);
-      error.initCause(e);
-      throw error;
-    }
-  }
-
-  /**
-   * Invokes the method on {@code target}. Throws an error if the method is not supported. Any
-   * RuntimeException thrown by the method is thrown, checked exceptions are wrapped in an {@link
-   * AssertionError}.
-   *
-   * @throws IllegalArgumentException if the arguments are invalid
-   */
-  public Object invokeWithoutCheckedException(T target, Object... args) {
-    try {
-      return invoke(target, args);
-    } catch (InvocationTargetException e) {
-      Throwable targetException = e.getTargetException();
-      if (targetException instanceof RuntimeException) {
-        throw (RuntimeException) targetException;
-      }
-      AssertionError error = new AssertionError("Unexpected exception");
-      error.initCause(targetException);
-      throw error;
-    }
-  }
-
-  /**
-   * Perform a lookup for the method. No caching. In order to return a method the method name and
-   * arguments must match those specified when the {@link OptionalMethod} was created. If the return
-   * type is specified (i.e. non-null) it must also be compatible. The method must also be public.
-   */
-  private Method getMethod(Class<?> clazz) {
-    Method method = null;
-    if (methodName != null) {
-      method = getPublicMethod(clazz, methodName, methodParams);
-      if (method != null
-          && returnType != null
-          && !returnType.isAssignableFrom(method.getReturnType())) {
-
-        // If the return type is non-null it must be compatible.
-        method = null;
-      }
-    }
-    return method;
-  }
-
-  private static Method getPublicMethod(Class<?> clazz, String methodName, Class[] parameterTypes) {
-    Method method = null;
-    try {
-      method = clazz.getMethod(methodName, parameterTypes);
-      if ((method.getModifiers() & Modifier.PUBLIC) == 0) {
-        method = null;
-      }
-    } catch (NoSuchMethodException e) {
-      // None.
-    }
-    return method;
-  }
-}
-
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/Platform.java b/okhttp/src/main/java/okhttp3/internal/platform/Platform.java
index db136a589f..3d3b00be2d 100644
--- a/okhttp/src/main/java/okhttp3/internal/platform/Platform.java
+++ b/okhttp/src/main/java/okhttp3/internal/platform/Platform.java
@@ -33,10 +33,9 @@
 import javax.net.ssl.X509TrustManager;
 import okhttp3.OkHttpClient;
 import okhttp3.Protocol;
+import okhttp3.internal.Util;
 import okhttp3.internal.tls.BasicCertificateChainCleaner;
-import okhttp3.internal.tls.BasicTrustRootIndex;
 import okhttp3.internal.tls.CertificateChainCleaner;
-import okhttp3.internal.tls.TrustRootIndex;
 import okio.Buffer;
 
 /**
@@ -46,7 +45,7 @@
  *
  * <p>Supported on Android 2.3+.
  *
- * Supported on OpenJDK 7+
+ * <p>Supported on OpenJDK 7+
  *
  * <h3>Session Tickets</h3>
  *
@@ -61,9 +60,9 @@
  * <p>Supported on Android 5.0+. The APIs were present in Android 4.4, but that implementation was
  * unstable.
  *
- * Supported on OpenJDK 7 and 8 (via the JettyALPN-boot library).
+ * <p>Supported on OpenJDK 8 via the JettyALPN-boot library.
  *
- * Supported on OpenJDK 9 via SSLParameters and SSLSocket features.
+ * <p>Supported on OpenJDK 9+ via SSLParameters and SSLSocket features.
  *
  * <h3>Trust Manager Extraction</h3>
  *
@@ -169,7 +168,7 @@ public void logCloseableLeak(String message, Object stackTrace) {
   }
 
   public CertificateChainCleaner buildCertificateChainCleaner(X509TrustManager trustManager) {
-    return new BasicCertificateChainCleaner(buildTrustRootIndex(trustManager));
+    return new BasicCertificateChainCleaner(trustManager.getAcceptedIssuers());
   }
 
   public CertificateChainCleaner buildCertificateChainCleaner(SSLSocketFactory sslSocketFactory) {
@@ -187,7 +186,7 @@ public CertificateChainCleaner buildCertificateChainCleaner(SSLSocketFactory ssl
 
   public static boolean isConscryptPreferred() {
     // mainly to allow tests to run cleanly
-    if ("conscrypt".equals(System.getProperty("okhttp.platform"))) {
+    if ("conscrypt".equals(Util.getSystemProperty("okhttp.platform", null))) {
       return true;
     }
 
@@ -218,7 +217,7 @@ private static Platform findPlatform() {
       return jdk9;
     }
 
-    Platform jdkWithJettyBoot = JdkWithJettyBootPlatform.buildIfSupported();
+    Platform jdkWithJettyBoot = Jdk8WithJettyBootPlatform.buildIfSupported();
 
     if (jdkWithJettyBoot != null) {
       return jdkWithJettyBoot;
@@ -249,7 +248,7 @@ private static Platform findPlatform() {
         Field field = c.getDeclaredField(fieldName);
         field.setAccessible(true);
         Object value = field.get(instance);
-        if (value == null || !fieldType.isInstance(value)) return null;
+        if (!fieldType.isInstance(value)) return null;
         return fieldType.cast(value);
       } catch (NoSuchFieldException ignored) {
       } catch (IllegalAccessException e) {
@@ -267,16 +266,6 @@ private static Platform findPlatform() {
   }
 
   public SSLContext getSSLContext() {
-    String jvmVersion = System.getProperty("java.specification.version");
-    if ("1.7".equals(jvmVersion)) {
-      try {
-        // JDK 1.7 (public version) only support > TLSv1 with named protocols
-        return SSLContext.getInstance("TLSv1.2");
-      } catch (NoSuchAlgorithmException e) {
-        // fallback to TLS
-      }
-    }
-
     try {
       return SSLContext.getInstance("TLS");
     } catch (NoSuchAlgorithmException e) {
@@ -284,10 +273,10 @@ public SSLContext getSSLContext() {
     }
   }
 
-  public TrustRootIndex buildTrustRootIndex(X509TrustManager trustManager) {
-    return new BasicTrustRootIndex(trustManager.getAcceptedIssuers());
+  public void configureSslSocketFactory(SSLSocketFactory socketFactory) {
   }
 
-  public void configureSslSocketFactory(SSLSocketFactory socketFactory) {
+  @Override public String toString() {
+    return getClass().getSimpleName();
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/SingleInetAddressDns.java b/okhttp/src/main/java/okhttp3/internal/proxy/NullProxySelector.java
similarity index 50%
rename from okhttp-tests/src/test/java/okhttp3/internal/SingleInetAddressDns.java
rename to okhttp/src/main/java/okhttp3/internal/proxy/NullProxySelector.java
index 03e8ce08e9..d18b6335f1 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/SingleInetAddressDns.java
+++ b/okhttp/src/main/java/okhttp3/internal/proxy/NullProxySelector.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Square, Inc.
+ * Copyright (C) 2018 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,21 +13,27 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal;
+package okhttp3.internal.proxy;
 
-import java.net.InetAddress;
-import java.net.UnknownHostException;
+import java.io.IOException;
+import java.net.Proxy;
+import java.net.ProxySelector;
+import java.net.SocketAddress;
+import java.net.URI;
 import java.util.Collections;
 import java.util.List;
-import okhttp3.Dns;
 
 /**
- * A network that resolves only one IP address per host. Use this when testing route selection
- * fallbacks to prevent the host machine's various IP addresses from interfering.
+ * A proxy selector that always returns the {@link Proxy#NO_PROXY}.
  */
-public class SingleInetAddressDns implements Dns {
-  @Override public List<InetAddress> lookup(String hostname) throws UnknownHostException {
-    List<InetAddress> addresses = Dns.SYSTEM.lookup(hostname);
-    return Collections.singletonList(addresses.get(0));
+public class NullProxySelector extends ProxySelector {
+  @Override public List<Proxy> select(URI uri) {
+    if (uri == null) {
+      throw new IllegalArgumentException("uri must not be null");
+    }
+    return Collections.singletonList(Proxy.NO_PROXY);
+  }
+
+  @Override public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/publicsuffix/PublicSuffixDatabase.java b/okhttp/src/main/java/okhttp3/internal/publicsuffix/PublicSuffixDatabase.java
index af10898a38..74fbd89b79 100644
--- a/okhttp/src/main/java/okhttp3/internal/publicsuffix/PublicSuffixDatabase.java
+++ b/okhttp/src/main/java/okhttp3/internal/publicsuffix/PublicSuffixDatabase.java
@@ -21,13 +21,12 @@
 import java.net.IDN;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicBoolean;
-import okhttp3.internal.Util;
 import okhttp3.internal.platform.Platform;
 import okio.BufferedSource;
 import okio.GzipSource;
 import okio.Okio;
 
-import static okhttp3.internal.Util.closeQuietly;
+import static java.nio.charset.StandardCharsets.UTF_8;
 
 /**
  * A database of public suffixes provided by
@@ -128,7 +127,7 @@ public String getEffectiveTldPlusOne(String domain) {
     // Break apart the domain into UTF-8 labels, i.e. foo.bar.com turns into [foo, bar, com].
     byte[][] domainLabelsUtf8Bytes = new byte[domainLabels.length][];
     for (int i = 0; i < domainLabels.length; i++) {
-      domainLabelsUtf8Bytes[i] = domainLabels[i].getBytes(Util.UTF_8);
+      domainLabelsUtf8Bytes[i] = domainLabels[i].getBytes(UTF_8);
     }
 
     // Start by looking for exact matches. We start at the leftmost label. For example, foo.bar.com
@@ -271,7 +270,7 @@ private static String binarySearchBytes(byte[] bytesToSearch, byte[][] labels, i
           low = mid + end + 1;
         } else {
           // Found a match.
-          match = new String(bytesToSearch, mid, publicSuffixLength, Util.UTF_8);
+          match = new String(bytesToSearch, mid, publicSuffixLength, UTF_8);
           break;
         }
       }
@@ -292,6 +291,7 @@ private void readTheListUninterruptibly() {
           readTheList();
           return;
         } catch (InterruptedIOException e) {
+          Thread.interrupted(); // Temporarily clear the interrupted state.
           interrupted = true;
         } catch (IOException e) {
           Platform.get().log(Platform.WARN, "Failed to read public suffix list", e);
@@ -312,8 +312,7 @@ private void readTheList() throws IOException {
     InputStream resource = PublicSuffixDatabase.class.getResourceAsStream(PUBLIC_SUFFIX_RESOURCE);
     if (resource == null) return;
 
-    BufferedSource bufferedSource = Okio.buffer(new GzipSource(Okio.source(resource)));
-    try {
+    try (BufferedSource bufferedSource = Okio.buffer(new GzipSource(Okio.source(resource)))) {
       int totalBytes = bufferedSource.readInt();
       publicSuffixListBytes = new byte[totalBytes];
       bufferedSource.readFully(publicSuffixListBytes);
@@ -321,8 +320,6 @@ private void readTheList() throws IOException {
       int totalExceptionBytes = bufferedSource.readInt();
       publicSuffixExceptionListBytes = new byte[totalExceptionBytes];
       bufferedSource.readFully(publicSuffixExceptionListBytes);
-    } finally {
-      closeQuietly(bufferedSource);
     }
 
     synchronized (this) {
diff --git a/okhttp/src/main/java/okhttp3/internal/tls/BasicCertificateChainCleaner.java b/okhttp/src/main/java/okhttp3/internal/tls/BasicCertificateChainCleaner.java
index 8a8c1d11d2..81e1c0adc7 100644
--- a/okhttp/src/main/java/okhttp3/internal/tls/BasicCertificateChainCleaner.java
+++ b/okhttp/src/main/java/okhttp3/internal/tls/BasicCertificateChainCleaner.java
@@ -16,14 +16,20 @@
 package okhttp3.internal.tls;
 
 import java.security.GeneralSecurityException;
+import java.security.PublicKey;
 import java.security.cert.Certificate;
 import java.security.cert.X509Certificate;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Deque;
 import java.util.Iterator;
+import java.util.LinkedHashMap;
+import java.util.LinkedHashSet;
 import java.util.List;
+import java.util.Map;
+import java.util.Set;
 import javax.net.ssl.SSLPeerUnverifiedException;
+import javax.security.auth.x500.X500Principal;
 
 /**
  * A certificate chain cleaner that uses a set of trusted root certificates to build the trusted
@@ -38,10 +44,20 @@
   /** The maximum number of signers in a chain. We use 9 for consistency with OpenSSL. */
   private static final int MAX_SIGNERS = 9;
 
-  private final TrustRootIndex trustRootIndex;
+  /** A simple index that of trusted root certificates that have been loaded into memory. */
+  private final Map<X500Principal, Set<X509Certificate>> subjectToCaCerts;
 
-  public BasicCertificateChainCleaner(TrustRootIndex trustRootIndex) {
-    this.trustRootIndex = trustRootIndex;
+  public BasicCertificateChainCleaner(X509Certificate... caCerts) {
+    subjectToCaCerts = new LinkedHashMap<>();
+    for (X509Certificate caCert : caCerts) {
+      X500Principal subject = caCert.getSubjectX500Principal();
+      Set<X509Certificate> subjectCaCerts = subjectToCaCerts.get(subject);
+      if (subjectCaCerts == null) {
+        subjectCaCerts = new LinkedHashSet<>(1);
+        subjectToCaCerts.put(subject, subjectCaCerts);
+      }
+      subjectCaCerts.add(caCert);
+    }
   }
 
   /**
@@ -65,7 +81,7 @@ public BasicCertificateChainCleaner(TrustRootIndex trustRootIndex) {
       // If this cert has been signed by a trusted cert, use that. Add the trusted certificate to
       // the end of the chain unless it's already present. (That would happen if the first
       // certificate in the chain is itself a self-signed and trusted CA certificate.)
-      X509Certificate trustedCert = trustRootIndex.findByIssuerAndSignature(toVerify);
+      X509Certificate trustedCert = findByIssuerAndSignature(toVerify);
       if (trustedCert != null) {
         if (result.size() > 1 || !toVerify.equals(trustedCert)) {
           result.add(trustedCert);
@@ -112,13 +128,31 @@ private boolean verifySignature(X509Certificate toVerify, X509Certificate signin
     }
   }
 
+  /** Returns the trusted CA certificate that signed {@code cert}. */
+  private X509Certificate findByIssuerAndSignature(X509Certificate cert) {
+    X500Principal issuer = cert.getIssuerX500Principal();
+    Set<X509Certificate> subjectCaCerts = subjectToCaCerts.get(issuer);
+    if (subjectCaCerts == null) return null;
+
+    for (X509Certificate caCert : subjectCaCerts) {
+      PublicKey publicKey = caCert.getPublicKey();
+      try {
+        cert.verify(publicKey);
+        return caCert;
+      } catch (Exception ignored) {
+      }
+    }
+
+    return null;
+  }
+
   @Override public int hashCode() {
-    return trustRootIndex.hashCode();
+    return subjectToCaCerts.hashCode();
   }
 
   @Override public boolean equals(Object other) {
     if (other == this) return true;
     return other instanceof BasicCertificateChainCleaner
-        && ((BasicCertificateChainCleaner) other).trustRootIndex.equals(trustRootIndex);
+        && ((BasicCertificateChainCleaner) other).subjectToCaCerts.equals(subjectToCaCerts);
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/tls/BasicTrustRootIndex.java b/okhttp/src/main/java/okhttp3/internal/tls/BasicTrustRootIndex.java
deleted file mode 100644
index cfd8923668..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/tls/BasicTrustRootIndex.java
+++ /dev/null
@@ -1,70 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.tls;
-
-import java.security.PublicKey;
-import java.security.cert.X509Certificate;
-import java.util.LinkedHashMap;
-import java.util.LinkedHashSet;
-import java.util.Map;
-import java.util.Set;
-import javax.security.auth.x500.X500Principal;
-
-/** A simple index that of trusted root certificates that have been loaded into memory. */
-public final class BasicTrustRootIndex implements TrustRootIndex {
-  private final Map<X500Principal, Set<X509Certificate>> subjectToCaCerts;
-
-  public BasicTrustRootIndex(X509Certificate... caCerts) {
-    subjectToCaCerts = new LinkedHashMap<>();
-    for (X509Certificate caCert : caCerts) {
-      X500Principal subject = caCert.getSubjectX500Principal();
-      Set<X509Certificate> subjectCaCerts = subjectToCaCerts.get(subject);
-      if (subjectCaCerts == null) {
-        subjectCaCerts = new LinkedHashSet<>(1);
-        subjectToCaCerts.put(subject, subjectCaCerts);
-      }
-      subjectCaCerts.add(caCert);
-    }
-  }
-
-  @Override public X509Certificate findByIssuerAndSignature(X509Certificate cert) {
-    X500Principal issuer = cert.getIssuerX500Principal();
-    Set<X509Certificate> subjectCaCerts = subjectToCaCerts.get(issuer);
-    if (subjectCaCerts == null) return null;
-
-    for (X509Certificate caCert : subjectCaCerts) {
-      PublicKey publicKey = caCert.getPublicKey();
-      try {
-        cert.verify(publicKey);
-        return caCert;
-      } catch (Exception ignored) {
-      }
-    }
-
-    return null;
-  }
-
-  @Override public boolean equals(Object other) {
-    if (other == this) return true;
-    return other instanceof okhttp3.internal.tls.BasicTrustRootIndex
-        && ((okhttp3.internal.tls.BasicTrustRootIndex) other).subjectToCaCerts.equals(
-        subjectToCaCerts);
-  }
-
-  @Override public int hashCode() {
-    return subjectToCaCerts.hashCode();
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/tls/CertificateChainCleaner.java b/okhttp/src/main/java/okhttp3/internal/tls/CertificateChainCleaner.java
index 98060db27a..94903e4b7d 100644
--- a/okhttp/src/main/java/okhttp3/internal/tls/CertificateChainCleaner.java
+++ b/okhttp/src/main/java/okhttp3/internal/tls/CertificateChainCleaner.java
@@ -42,6 +42,6 @@ public static CertificateChainCleaner get(X509TrustManager trustManager) {
   }
 
   public static CertificateChainCleaner get(X509Certificate... caCerts) {
-    return new BasicCertificateChainCleaner(new BasicTrustRootIndex(caCerts));
+    return new BasicCertificateChainCleaner(caCerts);
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java b/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java
index 092dc5775e..61a0d27e5e 100644
--- a/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java
+++ b/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java
@@ -153,14 +153,12 @@ public RealWebSocket(Request request, WebSocketListener listener, Random random,
     random.nextBytes(nonce);
     this.key = ByteString.of(nonce).base64();
 
-    this.writerRunnable = new Runnable() {
-      @Override public void run() {
-        try {
-          while (writeOneFrame()) {
-          }
-        } catch (IOException e) {
-          failWebSocket(e, null);
+    this.writerRunnable = () -> {
+      try {
+        while (writeOneFrame()) {
         }
+      } catch (IOException e) {
+        failWebSocket(e, null);
       }
     };
   }
@@ -189,26 +187,29 @@ public void connect(OkHttpClient client) {
         .header("Sec-WebSocket-Version", "13")
         .build();
     call = Internal.instance.newWebSocketCall(client, request);
+    call.timeout().clearTimeout();
     call.enqueue(new Callback() {
       @Override public void onResponse(Call call, Response response) {
+        StreamAllocation streamAllocation = Internal.instance.streamAllocation(call);
+
         try {
           checkResponse(response);
         } catch (ProtocolException e) {
           failWebSocket(e, response);
           closeQuietly(response);
+          streamAllocation.streamFailed(e);
           return;
         }
 
         // Promote the HTTP streams into web socket streams.
-        StreamAllocation streamAllocation = Internal.instance.streamAllocation(call);
         streamAllocation.noNewStreams(); // Prevent connection pooling!
         Streams streams = streamAllocation.connection().newWebSocketStreams(streamAllocation);
 
         // Process all web socket messages.
         try {
-          listener.onOpen(RealWebSocket.this, response);
           String name = "OkHttp WebSocket " + request.url().redact();
           initReaderAndWriter(name, streams);
+          listener.onOpen(RealWebSocket.this, response);
           streamAllocation.connection().socket().setSoTimeout(0);
           loopReader();
         } catch (Exception e) {
diff --git a/okhttp/src/main/java/okhttp3/internal/ws/WebSocketWriter.java b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketWriter.java
index baffe06b19..3ba1204987 100644
--- a/okhttp/src/main/java/okhttp3/internal/ws/WebSocketWriter.java
+++ b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketWriter.java
@@ -246,7 +246,6 @@ void writeMessageFrame(int formatOpcode, long byteCount, boolean isFirstFrame,
       return sink.timeout();
     }
 
-    @SuppressWarnings("PointlessBitwiseExpression")
     @Override public void close() throws IOException {
       if (closed) throw new IOException("closed");
 
diff --git a/okhttp/src/main/java/okhttp3/package-info.java b/okhttp/src/main/java/okhttp3/package-info.java
index a34c5bbf86..725b054363 100644
--- a/okhttp/src/main/java/okhttp3/package-info.java
+++ b/okhttp/src/main/java/okhttp3/package-info.java
@@ -1,3 +1,3 @@
 /** An HTTP+HTTP/2 client for Android and Java applications. */
-@javax.annotation.ParametersAreNonnullByDefault
+@okhttp3.internal.annotations.EverythingIsNonNull
 package okhttp3;
diff --git a/pom.xml b/pom.xml
index c9f70dc54e..af6796f41a 100644
--- a/pom.xml
+++ b/pom.xml
@@ -11,7 +11,7 @@
 
   <groupId>com.squareup.okhttp3</groupId>
   <artifactId>parent</artifactId>
-  <version>3.12.0-SNAPSHOT</version>
+  <version>3.13.0-SNAPSHOT</version>
   <packaging>pom</packaging>
 
   <name>OkHttp (Parent)</name>
@@ -36,27 +36,25 @@
 
     <module>okcurl</module>
     <module>mockwebserver</module>
+    <module>bom</module>
     <module>samples</module>
-    <module>benchmarks</module>
   </modules>
 
   <properties>
     <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
 
     <!-- Compilation -->
-    <airlift.version>0.7</airlift.version>
-    <!-- ALPN library targeted to Java 7 -->
-    <alpn.jdk7.version>7.1.2.v20141202</alpn.jdk7.version>
+    <airlift.version>0.8</airlift.version>
     <android.version>4.1.1.4</android.version>
-    <animal.sniffer.version>1.15</animal.sniffer.version>
-    <apache.http.version>4.2.6</apache.http.version>
-    <bouncycastle.version>1.50</bouncycastle.version>
-    <guava.version>16.0</guava.version>
-    <java.version>1.7</java.version>
-    <moshi.version>1.1.0</moshi.version>
-    <jnr-unixsocket.version>0.19</jnr-unixsocket.version>
-    <okio.version>1.14.0</okio.version>
-    <conscrypt.version>1.1.4</conscrypt.version>
+    <animal.sniffer.version>1.17</animal.sniffer.version>
+    <apache.http.version>4.5.6</apache.http.version>
+    <bouncycastle.version>1.60</bouncycastle.version>
+    <guava.version>27.0.1-jre</guava.version>
+    <java.version>1.8</java.version>
+    <moshi.version>1.8.0</moshi.version>
+    <jnr-unixsocket.version>0.21</jnr-unixsocket.version>
+    <okio.version>1.17.2</okio.version>
+    <conscrypt.version>1.4.2</conscrypt.version>
 
     <!-- Test Dependencies -->
     <junit.version>4.12</junit.version>
@@ -151,7 +149,7 @@
         <plugin>
           <groupId>org.apache.maven.plugins</groupId>
           <artifactId>maven-compiler-plugin</artifactId>
-          <version>3.7.0</version>
+          <version>3.8.0</version>
           <configuration>
             <compilerId>javac-with-errorprone</compilerId>
             <forceJavacCompilerUse>true</forceJavacCompilerUse>
@@ -162,12 +160,12 @@
             <dependency>
               <groupId>org.codehaus.plexus</groupId>
               <artifactId>plexus-compiler-javac-errorprone</artifactId>
-              <version>2.8.4</version>
+              <version>2.8.5</version>
             </dependency>
             <dependency>
               <groupId>com.google.errorprone</groupId>
               <artifactId>error_prone_core</artifactId>
-              <version>2.3.1</version>
+              <version>2.3.2</version>
             </dependency>
           </dependencies>
         </plugin>
@@ -175,7 +173,7 @@
         <plugin>
           <groupId>org.apache.maven.plugins</groupId>
           <artifactId>maven-surefire-plugin</artifactId>
-          <version>2.21.0</version>
+          <version>2.22.1</version>
           <configuration>
             <systemPropertyVariables>
               <okhttp.platform>${okhttp.platform}</okhttp.platform>
@@ -197,7 +195,7 @@
             <dependency>
               <groupId>org.apache.maven.surefire</groupId>
               <artifactId>surefire-junit47</artifactId>
-              <version>2.21.0</version>
+              <version>2.22.1</version>
             </dependency>
           </dependencies>
         </plugin>
@@ -205,7 +203,7 @@
         <plugin>
           <groupId>org.apache.maven.plugins</groupId>
           <artifactId>maven-javadoc-plugin</artifactId>
-          <version>2.10.4</version>
+          <version>3.0.1</version>
         </plugin>
       </plugins>
     </pluginManagement>
@@ -214,12 +212,12 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-release-plugin</artifactId>
-        <version>2.4.2</version>
+        <version>2.5.3</version>
         <dependencies>
           <dependency>
             <groupId>org.apache.maven.scm</groupId>
             <artifactId>maven-scm-provider-gitexe</artifactId>
-            <version>1.9</version>
+            <version>1.11.1</version>
           </dependency>
         </dependencies>
         <configuration>
@@ -230,12 +228,12 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-checkstyle-plugin</artifactId>
-        <version>2.17</version>
+        <version>3.0.0</version>
         <dependencies>
           <dependency>
             <groupId>com.puppycrawl.tools</groupId>
             <artifactId>checkstyle</artifactId>
-            <version>7.7</version>
+            <version>8.15</version>
           </dependency>
         </dependencies>
         <configuration>
@@ -259,56 +257,39 @@
         <version>${animal.sniffer.version}</version>
         <executions>
           <execution>
+            <id>sniff-java18</id>
             <phase>test</phase>
             <goals>
               <goal>check</goal>
             </goals>
+            <configuration>
+              <signature>
+                <groupId>org.codehaus.mojo.signature</groupId>
+                <artifactId>java18</artifactId>
+                <version>1.0</version>
+              </signature>
+            </configuration>
+          </execution>
+          <execution>
+            <id>sniff-android5</id>
+            <phase>test</phase>
+            <goals>
+              <goal>check</goal>
+            </goals>
+            <configuration>
+              <signature>
+                <groupId>net.sf.androidscents.signature</groupId>
+                <artifactId>android-api-level-21</artifactId>
+                <version>5.0.1_r2</version>
+              </signature>
+            </configuration>
           </execution>
         </executions>
-        <configuration>
-          <signature>
-            <groupId>org.codehaus.mojo.signature</groupId>
-            <artifactId>java16</artifactId>
-            <version>1.1</version>
-          </signature>
-        </configuration>
       </plugin>
     </plugins>
   </build>
 
   <profiles>
-    <profile>
-      <id>alpn-when-jdk7</id>
-      <activation>
-        <jdk>1.7</jdk>
-      </activation>
-      <properties>
-        <bootclasspathPrefix>
-          ${settings.localRepository}/org/mortbay/jetty/alpn/alpn-boot/${alpn.jdk7.version}/alpn-boot-${alpn.jdk7.version}.jar
-        </bootclasspathPrefix>
-        <okhttp.platform>jdk-with-jetty-boot</okhttp.platform>
-      </properties>
-      <build>
-        <pluginManagement>
-          <plugins>
-            <plugin>
-              <groupId>org.apache.maven.plugins</groupId>
-              <artifactId>maven-surefire-plugin</artifactId>
-              <configuration>
-                <argLine>-Xbootclasspath/p:${bootclasspathPrefix} -Xms512m -Xmx512m</argLine>
-              </configuration>
-              <dependencies>
-                <dependency>
-                  <groupId>org.mortbay.jetty.alpn</groupId>
-                  <artifactId>alpn-boot</artifactId>
-                  <version>${alpn.jdk7.version}</version>
-                </dependency>
-              </dependencies>
-            </plugin>
-          </plugins>
-        </pluginManagement>
-      </build>
-    </profile>
     <profile>
       <id>alpn-when-jdk8</id>
       <activation>
@@ -662,5 +643,41 @@
         <alpn.jdk8.version>8.1.12.v20180117</alpn.jdk8.version>
       </properties>
     </profile>
+    <profile>
+      <id>alpn-when-jdk8_191</id>
+      <activation>
+        <jdk>1.8.0_191</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.13.v20181017</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_192</id>
+      <activation>
+        <jdk>1.8.0_192</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.13.v20181017</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_201</id>
+      <activation>
+        <jdk>1.8.0_201</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.13.v20181017</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_202</id>
+      <activation>
+        <jdk>1.8.0_202</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.13.v20181017</alpn.jdk8.version>
+      </properties>
+    </profile>
   </profiles>
 </project>
diff --git a/samples/crawler/pom.xml b/samples/crawler/pom.xml
index 97bcf040f2..e251e2054c 100644
--- a/samples/crawler/pom.xml
+++ b/samples/crawler/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>3.12.0-SNAPSHOT</version>
+    <version>3.13.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>crawler</artifactId>
@@ -21,7 +21,7 @@
     <dependency>
       <groupId>org.jsoup</groupId>
       <artifactId>jsoup</artifactId>
-      <version>1.7.3</version>
+      <version>1.11.3</version>
     </dependency>
   </dependencies>
 </project>
diff --git a/samples/crawler/src/main/java/okhttp3/sample/Crawler.java b/samples/crawler/src/main/java/okhttp3/sample/Crawler.java
index 07f61032d3..95ba357def 100644
--- a/samples/crawler/src/main/java/okhttp3/sample/Crawler.java
+++ b/samples/crawler/src/main/java/okhttp3/sample/Crawler.java
@@ -41,8 +41,7 @@
  */
 public final class Crawler {
   private final OkHttpClient client;
-  private final Set<HttpUrl> fetchedUrls = Collections.synchronizedSet(
-      new LinkedHashSet<HttpUrl>());
+  private final Set<HttpUrl> fetchedUrls = Collections.synchronizedSet(new LinkedHashSet<>());
   private final LinkedBlockingQueue<HttpUrl> queue = new LinkedBlockingQueue<>();
   private final ConcurrentHashMap<String, AtomicInteger> hostnames = new ConcurrentHashMap<>();
 
diff --git a/samples/guide/pom.xml b/samples/guide/pom.xml
index 95a9df5bdf..85f5d36f73 100644
--- a/samples/guide/pom.xml
+++ b/samples/guide/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>3.12.0-SNAPSHOT</version>
+    <version>3.13.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>guide</artifactId>
diff --git a/samples/guide/src/main/java/okhttp3/recipes/CancelCall.java b/samples/guide/src/main/java/okhttp3/recipes/CancelCall.java
index 644f638300..58a791adc7 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/CancelCall.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/CancelCall.java
@@ -37,12 +37,10 @@ public void run() throws Exception {
     final Call call = client.newCall(request);
 
     // Schedule a job to cancel the call in 1 second.
-    executor.schedule(new Runnable() {
-      @Override public void run() {
-        System.out.printf("%.2f Canceling call.%n", (System.nanoTime() - startNanos) / 1e9f);
-        call.cancel();
-        System.out.printf("%.2f Canceled call.%n", (System.nanoTime() - startNanos) / 1e9f);
-      }
+    executor.schedule(() -> {
+      System.out.printf("%.2f Canceling call.%n", (System.nanoTime() - startNanos) / 1e9f);
+      call.cancel();
+      System.out.printf("%.2f Canceled call.%n", (System.nanoTime() - startNanos) / 1e9f);
     }, 1, TimeUnit.SECONDS);
 
     System.out.printf("%.2f Executing call.%n", (System.nanoTime() - startNanos) / 1e9f);
diff --git a/samples/guide/src/main/java/okhttp3/recipes/CurrentDateHeader.java b/samples/guide/src/main/java/okhttp3/recipes/CurrentDateHeader.java
new file mode 100644
index 0000000000..6c15d700df
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/CurrentDateHeader.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes;
+
+import java.io.IOException;
+import java.util.Date;
+import okhttp3.Headers;
+import okhttp3.Interceptor;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+
+public final class CurrentDateHeader {
+  private final OkHttpClient client = new OkHttpClient.Builder()
+      .addInterceptor(new CurrentDateInterceptor())
+      .build();
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("https://publicobject.com/helloworld.txt")
+        .build();
+
+    try (Response response = client.newCall(request).execute()) {
+      System.out.println(response.request().header("Date"));
+    }
+  }
+
+  static class CurrentDateInterceptor implements Interceptor {
+    @Override public Response intercept(Chain chain) throws IOException {
+      Request request = chain.request();
+      Headers newHeaders = request.headers()
+          .newBuilder()
+          .add("Date", new Date())
+          .build();
+      Request newRequest = request.newBuilder()
+          .headers(newHeaders)
+          .build();
+      return chain.proceed(newRequest);
+    }
+  }
+
+  public static void main(String... args) throws Exception {
+    new CurrentDateHeader().run();
+  }
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PreemptiveAuth.java b/samples/guide/src/main/java/okhttp3/recipes/PreemptiveAuth.java
new file mode 100644
index 0000000000..abbf0eb0c0
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/PreemptiveAuth.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes;
+
+import java.io.IOException;
+import okhttp3.Credentials;
+import okhttp3.Interceptor;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+
+public final class PreemptiveAuth {
+  private final OkHttpClient client;
+
+  public PreemptiveAuth() {
+    client = new OkHttpClient.Builder()
+        .addInterceptor(
+            new BasicAuthInterceptor("publicobject.com", "jesse", "password1"))
+        .build();
+  }
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("https://publicobject.com/secrets/hellosecret.txt")
+        .build();
+
+    try (Response response = client.newCall(request).execute()) {
+      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+      System.out.println(response.body().string());
+    }
+  }
+
+  public static void main(String... args) throws Exception {
+    new PreemptiveAuth().run();
+  }
+
+  static final class BasicAuthInterceptor implements Interceptor {
+    private final String credentials;
+    private final String host;
+
+    BasicAuthInterceptor(String host, String username, String password) {
+      this.credentials = Credentials.basic(username, password);
+      this.host = host;
+    }
+
+    @Override public Response intercept(Chain chain) throws IOException {
+      Request request = chain.request();
+      if (request.url().host().equals(host)) {
+        request = request.newBuilder()
+            .header("Authorization", credentials)
+            .build();
+      }
+      return chain.proceed(request);
+    }
+  }
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/Progress.java b/samples/guide/src/main/java/okhttp3/recipes/Progress.java
index e75a3cc949..197401f205 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/Progress.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/Progress.java
@@ -16,7 +16,6 @@
 package okhttp3.recipes;
 
 import java.io.IOException;
-import okhttp3.Interceptor;
 import okhttp3.MediaType;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
@@ -61,13 +60,11 @@ public void run() throws Exception {
     };
 
     OkHttpClient client = new OkHttpClient.Builder()
-        .addNetworkInterceptor(new Interceptor() {
-          @Override public Response intercept(Chain chain) throws IOException {
-            Response originalResponse = chain.proceed(chain.request());
-            return originalResponse.newBuilder()
-                .body(new ProgressResponseBody(originalResponse.body(), progressListener))
-                .build();
-          }
+        .addNetworkInterceptor(chain -> {
+          Response originalResponse = chain.proceed(chain.request());
+          return originalResponse.newBuilder()
+              .body(new ProgressResponseBody(originalResponse.body(), progressListener))
+              .build();
         })
         .build();
 
diff --git a/samples/guide/src/main/java/okhttp3/recipes/RewriteResponseCacheControl.java b/samples/guide/src/main/java/okhttp3/recipes/RewriteResponseCacheControl.java
index 92d65d8169..4d876bb201 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/RewriteResponseCacheControl.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/RewriteResponseCacheControl.java
@@ -25,13 +25,11 @@
 
 public final class RewriteResponseCacheControl {
   /** Dangerous interceptor that rewrites the server's cache-control header. */
-  private static final Interceptor REWRITE_CACHE_CONTROL_INTERCEPTOR = new Interceptor() {
-    @Override public Response intercept(Chain chain) throws IOException {
-      Response originalResponse = chain.proceed(chain.request());
-      return originalResponse.newBuilder()
-          .header("Cache-Control", "max-age=60")
-          .build();
-    }
+  private static final Interceptor REWRITE_CACHE_CONTROL_INTERCEPTOR = chain -> {
+    Response originalResponse = chain.proceed(chain.request());
+    return originalResponse.newBuilder()
+        .header("Cache-Control", "max-age=60")
+        .build();
   };
 
   private final OkHttpClient client;
diff --git a/samples/pom.xml b/samples/pom.xml
index f767a9377d..4cb343bce2 100644
--- a/samples/pom.xml
+++ b/samples/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.12.0-SNAPSHOT</version>
+    <version>3.13.0-SNAPSHOT</version>
   </parent>
 
   <groupId>com.squareup.okhttp3.sample</groupId>
diff --git a/samples/simple-client/pom.xml b/samples/simple-client/pom.xml
index d4f3ec0ae7..9b193b2033 100644
--- a/samples/simple-client/pom.xml
+++ b/samples/simple-client/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>3.12.0-SNAPSHOT</version>
+    <version>3.13.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>simple-client</artifactId>
diff --git a/samples/simple-client/src/main/java/okhttp3/sample/OkHttpContributors.java b/samples/simple-client/src/main/java/okhttp3/sample/OkHttpContributors.java
index f2ac973db2..cfd8632cb8 100644
--- a/samples/simple-client/src/main/java/okhttp3/sample/OkHttpContributors.java
+++ b/samples/simple-client/src/main/java/okhttp3/sample/OkHttpContributors.java
@@ -4,7 +4,6 @@
 import com.squareup.moshi.Moshi;
 import com.squareup.moshi.Types;
 import java.util.Collections;
-import java.util.Comparator;
 import java.util.List;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
@@ -37,11 +36,7 @@ public static void main(String... args) throws Exception {
       List<Contributor> contributors = CONTRIBUTORS_JSON_ADAPTER.fromJson(body.source());
 
       // Sort list by the most contributions.
-      Collections.sort(contributors, new Comparator<Contributor>() {
-        @Override public int compare(Contributor c1, Contributor c2) {
-          return c2.contributions - c1.contributions;
-        }
-      });
+      Collections.sort(contributors, (c1, c2) -> c2.contributions - c1.contributions);
 
       // Output list of contributors.
       for (Contributor contributor : contributors) {
diff --git a/samples/slack/pom.xml b/samples/slack/pom.xml
index 26798cddf0..ea003abc2e 100644
--- a/samples/slack/pom.xml
+++ b/samples/slack/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>3.12.0-SNAPSHOT</version>
+    <version>3.13.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>slack</artifactId>
diff --git a/samples/slack/src/main/java/okhttp3/slack/SlackClient.java b/samples/slack/src/main/java/okhttp3/slack/SlackClient.java
index 2aa2608986..508a5fd467 100644
--- a/samples/slack/src/main/java/okhttp3/slack/SlackClient.java
+++ b/samples/slack/src/main/java/okhttp3/slack/SlackClient.java
@@ -39,13 +39,10 @@ public void requestOauthSession(String scopes, String team) throws Exception {
       sessionFactory.start();
     }
 
-    HttpUrl authorizeUrl = sessionFactory.newAuthorizeUrl(scopes, team,
-        new OAuthSessionFactory.Listener() {
-          @Override public void sessionGranted(OAuthSession session) {
-            initOauthSession(session);
-            System.out.printf("session granted: %s\n", session);
-          }
-        });
+    HttpUrl authorizeUrl = sessionFactory.newAuthorizeUrl(scopes, team, session -> {
+      initOauthSession(session);
+      System.out.printf("session granted: %s\n", session);
+    });
 
     System.out.printf("open this URL in a browser: %s\n", authorizeUrl);
   }
diff --git a/samples/static-server/pom.xml b/samples/static-server/pom.xml
index 5c949eeb5b..5dd6cac971 100644
--- a/samples/static-server/pom.xml
+++ b/samples/static-server/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>3.12.0-SNAPSHOT</version>
+    <version>3.13.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>static-server</artifactId>
@@ -26,7 +26,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-shade-plugin</artifactId>
-        <version>2.1</version>
+        <version>3.2.1</version>
         <configuration>
           <shadedArtifactAttached>true</shadedArtifactAttached>
           <shadedClassifierName>shaded</shadedClassifierName>
diff --git a/samples/static-server/src/main/java/okhttp3/sample/SampleServer.java b/samples/static-server/src/main/java/okhttp3/sample/SampleServer.java
index e21432ed20..88e0251bdb 100644
--- a/samples/static-server/src/main/java/okhttp3/sample/SampleServer.java
+++ b/samples/static-server/src/main/java/okhttp3/sample/SampleServer.java
@@ -11,7 +11,6 @@
 import javax.net.ssl.KeyManagerFactory;
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.TrustManagerFactory;
-import okhttp3.internal.Util;
 import okhttp3.mockwebserver.Dispatcher;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
@@ -119,11 +118,8 @@ public static void main(String[] args) throws Exception {
   private static SSLContext sslContext(String keystoreFile, String password)
       throws GeneralSecurityException, IOException {
     KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());
-    InputStream in = new FileInputStream(keystoreFile);
-    try {
+    try (InputStream in = new FileInputStream(keystoreFile)) {
       keystore.load(in, password.toCharArray());
-    } finally {
-      Util.closeQuietly(in);
     }
     KeyManagerFactory keyManagerFactory =
         KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
diff --git a/samples/unixdomainsockets/pom.xml b/samples/unixdomainsockets/pom.xml
index a9ea691926..0f1c5459fb 100644
--- a/samples/unixdomainsockets/pom.xml
+++ b/samples/unixdomainsockets/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>3.12.0-SNAPSHOT</version>
+    <version>3.13.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>unixdomainsockets</artifactId>
diff --git a/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/BlockingUnixSocket.java b/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/BlockingUnixSocket.java
new file mode 100644
index 0000000000..3ba58448c2
--- /dev/null
+++ b/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/BlockingUnixSocket.java
@@ -0,0 +1,119 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.unixdomainsockets;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.SocketAddress;
+import java.nio.ByteBuffer;
+import java.nio.channels.Channels;
+import java.nio.channels.ReadableByteChannel;
+import java.nio.channels.SelectableChannel;
+import java.nio.channels.WritableByteChannel;
+import jnr.unixsocket.UnixSocket;
+import jnr.unixsocket.UnixSocketAddress;
+import jnr.unixsocket.UnixSocketChannel;
+
+/**
+ * Subtype UNIX socket for a higher-fidelity impersonation of TCP sockets.
+ *
+ * <p>This class doesn't pass {@link SelectableChannel} implementations to create input and output
+ * streams. Though that type isn't in the public API, if the channel passed in implements that
+ * interface then additional synchronization is used. This additional synchronization harms
+ * concurrency and can cause deadlocks.
+ *
+ * <p>This class remembers which socket address was connected so that a non-null value can be
+ * returned on calls to {@link #getInetAddress}.
+ */
+final class BlockingUnixSocket extends UnixSocket {
+  private final File path;
+  private final InputStream in;
+  private final OutputStream out;
+  private InetSocketAddress inetSocketAddress;
+
+  BlockingUnixSocket(File path, UnixSocketChannel channel) {
+    super(channel);
+    this.path = path;
+    this.in = Channels.newInputStream(new UnselectableReadableByteChannel());
+    this.out = Channels.newOutputStream(new UnselectableWritableByteChannel());
+  }
+
+  BlockingUnixSocket(File path, UnixSocketChannel channel, InetSocketAddress address) {
+    this(path, channel);
+    this.inetSocketAddress = address;
+  }
+
+  @Override public void connect(SocketAddress endpoint) throws IOException {
+    connect(endpoint, Integer.valueOf(0));
+  }
+
+  @Override public void connect(SocketAddress endpoint, int timeout) throws IOException {
+    connect(endpoint, Integer.valueOf(timeout));
+  }
+
+  @Override public void connect(SocketAddress endpoint, Integer timeout) throws IOException {
+    this.inetSocketAddress = (InetSocketAddress) endpoint;
+    super.connect(new UnixSocketAddress(path), timeout);
+  }
+
+  @Override public InetAddress getInetAddress() {
+    return inetSocketAddress.getAddress(); // TODO(jwilson): fake the remote address?
+  }
+
+  @Override public InputStream getInputStream() throws IOException {
+    if (!isConnected()) throw new IOException("not connected");
+    return in;
+  }
+
+  @Override public OutputStream getOutputStream() throws IOException {
+    if (!isConnected()) throw new IOException("not connected");
+    return out;
+  }
+
+  /** A readable byte channel that doesn't implement {@link SelectableChannel}. */
+  final class UnselectableReadableByteChannel implements ReadableByteChannel {
+    @Override public int read(ByteBuffer dst) throws IOException {
+      return getChannel().read(dst);
+    }
+
+    @Override public boolean isOpen() {
+      return getChannel().isOpen();
+    }
+
+    @Override public void close() throws IOException {
+      getChannel().close();
+    }
+  }
+
+  /** A writable byte channel that doesn't implement {@link SelectableChannel}. */
+  final class UnselectableWritableByteChannel implements WritableByteChannel {
+    @Override public int write(ByteBuffer src) throws IOException {
+      return getChannel().write(src);
+    }
+
+    @Override public boolean isOpen() {
+      return getChannel().isOpen();
+    }
+
+    @Override public void close() throws IOException {
+      getChannel().close();
+    }
+  }
+}
diff --git a/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/ClientAndServer.java b/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/ClientAndServer.java
index 8512c2d38d..f897565f52 100644
--- a/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/ClientAndServer.java
+++ b/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/ClientAndServer.java
@@ -16,7 +16,9 @@
 package okhttp3.unixdomainsockets;
 
 import java.io.File;
+import java.util.Collections;
 import okhttp3.OkHttpClient;
+import okhttp3.Protocol;
 import okhttp3.Request;
 import okhttp3.Response;
 import okhttp3.mockwebserver.MockResponse;
@@ -33,11 +35,13 @@ public void run() throws Exception {
 
     MockWebServer server = new MockWebServer();
     server.setServerSocketFactory(new UnixDomainServerSocketFactory(socketFile));
+    server.setProtocols(Collections.singletonList(Protocol.H2_PRIOR_KNOWLEDGE));
     server.enqueue(new MockResponse().setBody("hello"));
     server.start();
 
     OkHttpClient client = new OkHttpClient.Builder()
         .socketFactory(new UnixDomainSocketFactory(socketFile))
+        .protocols(Collections.singletonList(Protocol.H2_PRIOR_KNOWLEDGE))
         .build();
 
     Request request = new Request.Builder()
diff --git a/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/UnixDomainServerSocketFactory.java b/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/UnixDomainServerSocketFactory.java
index f9ec4a08f8..c1d63b5a32 100644
--- a/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/UnixDomainServerSocketFactory.java
+++ b/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/UnixDomainServerSocketFactory.java
@@ -24,7 +24,6 @@
 import java.net.SocketAddress;
 import javax.net.ServerSocketFactory;
 import jnr.unixsocket.UnixServerSocketChannel;
-import jnr.unixsocket.UnixSocket;
 import jnr.unixsocket.UnixSocketAddress;
 import jnr.unixsocket.UnixSocketChannel;
 
@@ -82,13 +81,8 @@ private ServerSocket createUnixDomainSocket() throws IOException {
     }
 
     @Override public Socket accept() throws IOException {
-      UnixSocketChannel socketChannel = serverSocketChannel.accept();
-
-      return new UnixSocket(socketChannel) {
-        @Override public InetAddress getInetAddress() {
-          return endpoint.getAddress(); // TODO(jwilson): fake the remote address?
-        }
-      };
+      UnixSocketChannel channel = serverSocketChannel.accept();
+      return new BlockingUnixSocket(path, channel, endpoint);
     }
 
     @Override public void close() throws IOException {
diff --git a/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/UnixDomainSocketFactory.java b/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/UnixDomainSocketFactory.java
index 8b16e398f7..e288dc5287 100644
--- a/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/UnixDomainSocketFactory.java
+++ b/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/UnixDomainSocketFactory.java
@@ -18,12 +18,8 @@
 import java.io.File;
 import java.io.IOException;
 import java.net.InetAddress;
-import java.net.InetSocketAddress;
 import java.net.Socket;
-import java.net.SocketAddress;
 import javax.net.SocketFactory;
-import jnr.unixsocket.UnixSocket;
-import jnr.unixsocket.UnixSocketAddress;
 import jnr.unixsocket.UnixSocketChannel;
 
 /** Impersonate TCP-style SocketFactory over UNIX domain sockets. */
@@ -36,27 +32,7 @@ public UnixDomainSocketFactory(File path) {
 
   private Socket createUnixDomainSocket() throws IOException {
     UnixSocketChannel channel = UnixSocketChannel.open();
-
-    return new UnixSocket(channel) {
-      private InetSocketAddress inetSocketAddress;
-
-      @Override public void connect(SocketAddress endpoint) throws IOException {
-        connect(endpoint, Integer.valueOf(0));
-      }
-
-      @Override public void connect(SocketAddress endpoint, int timeout) throws IOException {
-        connect(endpoint, Integer.valueOf(timeout));
-      }
-
-      @Override public void connect(SocketAddress endpoint, Integer timeout) throws IOException {
-        this.inetSocketAddress = (InetSocketAddress) endpoint;
-        super.connect(new UnixSocketAddress(path), timeout);
-      }
-
-      @Override public InetAddress getInetAddress() {
-        return inetSocketAddress.getAddress(); // TODO(jwilson): fake the remote address?
-      }
-    };
+    return new BlockingUnixSocket(path, channel);
   }
 
   @Override public Socket createSocket() throws IOException {
diff --git a/website/index.html b/website/index.html
index 67638d5702..2a32b6edc6 100644
--- a/website/index.html
+++ b/website/index.html
@@ -27,6 +27,7 @@ <h1>OkHttp</h1>
               </ul>
             </menu>
           </div>
+        </div>
       </div>
     </header>
     <section id="subtitle">
@@ -57,15 +58,15 @@ <h3 id="overview">Overview</h3>
             <p>OkHttp perseveres when the network is troublesome: it will silently recover from
                 common connection problems. If your service has multiple IP addresses OkHttp will
                 attempt alternate addresses if the first connect fails. This is necessary for IPv4+IPv6
-                and for services hosted in redundant data centers. OkHttp initiates new connections
-                with modern TLS features (SNI, ALPN), and falls back to TLS 1.0 if the handshake
-                fails.</p>
+                and for services hosted in redundant data centers. OkHttp supports modern TLS
+                features (TLS 1.3, ALPN, certificate pinning). It can be configured to fall back for
+                broad connectivity.</p>
 
             <p>Using OkHttp is easy. Its request/response API is designed with fluent builders and
                 immutability. It supports both synchronous blocking calls and async calls with
                 callbacks.</p>
 
-            <p>OkHttp supports Android 2.3 and above. For Java, the minimum requirement is 1.7.</p>
+            <p>OkHttp supports Android 5.0+ (API level 21+) and Java 8+.</p>
 
             <h3 id="examples">Examples</h3>
             <h4>Get a URL</h4>
@@ -88,7 +89,7 @@ <h4>Post to a Server</h4>
 
 <pre class="prettyprint">
 public static final MediaType JSON
-    = MediaType.parse("application/json; charset=utf-8");
+    = MediaType.get("application/json; charset=utf-8");
 
 OkHttpClient client = new OkHttpClient();
 
@@ -124,6 +125,16 @@ <h4>Gradle</h4>
             <h3 id="contributing">Contributing</h3>
             <p>If you would like to contribute code you can do so through GitHub by forking the repository and sending a pull request.</p>
             <p>When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Please also make sure your code compiles by running <code>mvn clean verify</code>.</p>
+
+            <p>Some general advice</p>
+            <ul>
+                <li>Don‚Äôt change public API lightly, avoid if possible, and include your reasoning in the PR if essential. It causes pain for developers who use OkHttp and sometimes runtime errors.</li>
+                <li>Favour a working external library if appropriate. There are many examples of OkHttp libraries that can sit on top or hook in via existing APIs.</li>
+                <li>Get working code on a personal branch with tests before you submit a PR.</li>
+                <li>OkHttp is a small and light dependency. Don't introduce new dependencies or major new functionality.</li>
+                <li>OkHttp targets the intersection of RFC correct and widely implemented. Incorrect implementations that are very widely implemented e.g. a bug in Apache, Nginx, Google, Firefox should also be handled.</li>
+            </ul>
+
             <p>Before your code can be accepted into the project you must also sign the <a href="https://squ.re/sign-the-cla">Individual Contributor License Agreement (CLA)</a>.</p>
 
             <h3 id="license">License</h3>
