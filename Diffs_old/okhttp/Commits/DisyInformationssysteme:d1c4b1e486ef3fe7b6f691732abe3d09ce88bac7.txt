diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
index e4072033df..40eb1ef4f3 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
@@ -34,8 +34,10 @@
 import okhttp3.Cache;
 import okhttp3.Call;
 import okhttp3.Callback;
+import okhttp3.Connection;
 import okhttp3.Cookie;
 import okhttp3.Credentials;
+import okhttp3.EventListener;
 import okhttp3.Headers;
 import okhttp3.Interceptor;
 import okhttp3.MediaType;
@@ -1500,4 +1502,39 @@ private Buffer gzip(String bytes) throws IOException {
       }
     }
   }
+
+  /** https://github.com/square/okhttp/issues/4875 */
+  @Test
+  public void shutdownAfterLateCoalescing() throws Exception {
+    CountDownLatch latch = new CountDownLatch(2);
+
+    Callback callback = new Callback() {
+      @Override public void onResponse(Call call, Response response) {
+        fail();
+      }
+
+      @Override public void onFailure(Call call, IOException e) {
+        latch.countDown();
+      }
+    };
+
+    client = client.newBuilder().eventListener(new EventListener() {
+      int callCount;
+
+      @Override public void connectionAcquired(Call call, Connection connection) {
+        try {
+          if (callCount++ == 1) {
+            server.shutdown();
+          }
+        } catch(IOException e) {
+          fail();
+        }
+      }
+    }).build();
+
+    client.newCall(new Request.Builder().url(server.url("")).build()).enqueue(callback);
+    client.newCall(new Request.Builder().url(server.url("")).build()).enqueue(callback);
+
+    latch.await();
+  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/ExchangeFinder.java b/okhttp/src/main/java/okhttp3/internal/connection/ExchangeFinder.java
index ef741bd1eb..f8eff2c4a0 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/ExchangeFinder.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/ExchangeFinder.java
@@ -63,6 +63,7 @@
   private final RouteSelector routeSelector;
   private RealConnection connectingConnection;
   private boolean hasStreamFailure;
+  private Route nextRouteToTry;
 
   ExchangeFinder(Transmitter transmitter, RealConnectionPool connectionPool,
       Address address, Call call, EventListener eventListener) {
@@ -140,10 +141,6 @@ private RealConnection findConnection(int connectTimeout, int readTimeout, int w
       if (transmitter.isCanceled()) throw new IOException("Canceled");
       hasStreamFailure = false; // This is a fresh attempt.
 
-      Route previousRoute = retryCurrentRoute()
-          ? transmitter.connection.route()
-          : null;
-
       // Attempt to use an already-allocated connection. We need to be careful here because our
       // already-allocated connection may have been restricted from creating new exchanges.
       releasedConnection = transmitter.connection;
@@ -162,8 +159,11 @@ private RealConnection findConnection(int connectTimeout, int readTimeout, int w
         if (connectionPool.transmitterAcquirePooledConnection(address, transmitter, null, false)) {
           foundPooledConnection = true;
           result = transmitter.connection;
-        } else {
-          selectedRoute = previousRoute;
+        } else if (nextRouteToTry != null) {
+          selectedRoute = nextRouteToTry;
+          nextRouteToTry = null;
+        } else if (retryCurrentRoute()) {
+          selectedRoute = transmitter.connection.route();
         }
       }
     }
@@ -268,8 +268,15 @@ boolean hasStreamFailure() {
   /** Returns true if a current route is still good or if there are routes we haven't tried yet. */
   boolean hasRouteToTry() {
     synchronized (connectionPool) {
-      return retryCurrentRoute()
-          || (routeSelection != null && routeSelection.hasNext())
+      if (nextRouteToTry != null) {
+        return true;
+      }
+      if (retryCurrentRoute()) {
+        // Lock in the route because retryCurrentRoute() is racy and we don't want to call it twice.
+        nextRouteToTry = transmitter.connection.route();
+        return true;
+      }
+      return (routeSelection != null && routeSelection.hasNext())
           || routeSelector.hasNext();
     }
   }
