diff --git a/README.md b/README.md
index 1754c6d0c7..ec18b06d75 100644
--- a/README.md
+++ b/README.md
@@ -1,78 +1,3 @@
-OkHttp
-======
+## ?????
 
-An HTTP & HTTP/2 client for Android and Java applications. For more information see [the website][1] and [the wiki][2].
-
-Download
---------
-
-Download [the latest JAR][3] or grab via Maven:
-```xml
-<dependency>
-  <groupId>com.squareup.okhttp3</groupId>
-  <artifactId>okhttp</artifactId>
-  <version>3.8.1</version>
-</dependency>
-```
-or Gradle:
-```groovy
-compile 'com.squareup.okhttp3:okhttp:3.8.1'
-```
-
-Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
-
-
-MockWebServer
--------------
-
-A library for testing HTTP, HTTPS, and HTTP/2 clients.
-
-MockWebServer coupling with OkHttp is essential for proper testing of HTTP/2 so that code can be shared.
-
-### Download
-
-Download [the latest JAR][4] or grab via Maven:
-```xml
-<dependency>
-  <groupId>com.squareup.okhttp3</groupId>
-  <artifactId>mockwebserver</artifactId>
-  <version>3.8.1</version>
-  <scope>test</scope>
-</dependency>
-```
-or Gradle:
-```groovy
-testCompile 'com.squareup.okhttp3:mockwebserver:3.8.1'
-```
-
-ProGuard
---------
-
-If you are using ProGuard you might need to add the following options:
-```
--dontwarn okio.**
--dontwarn javax.annotation.Nullable
--dontwarn javax.annotation.ParametersAreNonnullByDefault
-```
-
-License
--------
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-
-
- [1]: http://square.github.io/okhttp
- [2]: https://github.com/square/okhttp/wiki
- [3]: https://search.maven.org/remote_content?g=com.squareup.okhttp3&a=okhttp&v=LATEST
- [4]: https://search.maven.org/remote_content?g=com.squareup.okhttp3&a=mockwebserver&v=LATEST
- [snap]: https://oss.sonatype.org/content/repositories/snapshots/
+!()[interceptor_chains.png]
diff --git a/interceptor_chains.png b/interceptor_chains.png
new file mode 100644
index 0000000000..f6693c3c3e
Binary files /dev/null and b/interceptor_chains.png differ
diff --git a/okhttp/src/main/java/okhttp3/Interceptor.java b/okhttp/src/main/java/okhttp3/Interceptor.java
index 3272e41882..b3a7bc7887 100644
--- a/okhttp/src/main/java/okhttp3/Interceptor.java
+++ b/okhttp/src/main/java/okhttp3/Interceptor.java
@@ -25,29 +25,30 @@
  * or response.
  */
 public interface Interceptor {
-  Response intercept(Chain chain) throws IOException;
+    Response intercept(Chain chain) throws IOException;
 
-  interface Chain {
-    Request request();
+    interface Chain {
+        Request request();
 
-    Response proceed(Request request) throws IOException;
+        Response proceed(Request request) throws IOException;
 
-    /**
-     * Returns the connection the request will be executed on. This is only available in the chains
-     * of network interceptors; for application interceptors this is always null.
-     */
-    @Nullable Connection connection();
+        /**
+         * Returns the connection the request will be executed on. This is only available in the chains
+         * of network interceptors; for application interceptors this is always null.
+         */
+        @Nullable
+        Connection connection();
 
-    int connectTimeoutMillis();
+        int connectTimeoutMillis();
 
-    Chain withConnectTimeout(int timeout, TimeUnit unit);
+        Chain withConnectTimeout(int timeout, TimeUnit unit);
 
-    int readTimeoutMillis();
+        int readTimeoutMillis();
 
-    Chain withReadTimeout(int timeout, TimeUnit unit);
+        Chain withReadTimeout(int timeout, TimeUnit unit);
 
-    int writeTimeoutMillis();
+        int writeTimeoutMillis();
 
-    Chain withWriteTimeout(int timeout, TimeUnit unit);
-  }
+        Chain withWriteTimeout(int timeout, TimeUnit unit);
+    }
 }
diff --git a/okhttp/src/main/java/okhttp3/RealCall.java b/okhttp/src/main/java/okhttp3/RealCall.java
index c697bacb34..c7f1d9a6b2 100644
--- a/okhttp/src/main/java/okhttp3/RealCall.java
+++ b/okhttp/src/main/java/okhttp3/RealCall.java
@@ -193,30 +193,38 @@ String redactedUrl() {
         return originalRequest.url().redact();
     }
 
+
     Response getResponseWithInterceptorChain() throws IOException {
+        // 这里采用了责任链模式，将一个流式工作分解为可配置的分段流程
+        // 流程图：https://app.yinxiang.com/shard/s22/nl/5111836/d733b170-92b9-4e3d-95ce-26c91947d5d6//res/4b7a220d-d81c-4694-b85f-08c441ef97a9/1240.png?resizeSmall&width=832
+
         // Build a full stack of interceptors.
-        // 创建连接器栈
+        // 创建拦截器栈
         List<Interceptor> interceptors = new ArrayList<>();
         // 添加自定义拦截器
         interceptors.addAll(client.interceptors());
-        // 重试拦截器
+        // 用来实现连接失败的重试和重定向，创建了 StreamAllocation
         interceptors.add(retryAndFollowUpInterceptor);
-        // 桥接拦截器，主要是重构请求头即header
+        // 桥接拦截器：修改 Request 请求头 header
         interceptors.add(new BridgeInterceptor(client.cookieJar()));
         // 缓存拦截器
         interceptors.add(new CacheInterceptor(client.internalCache()));
-        // 连接拦截器，连接服务器，https包装
+        // 连接拦截器：打开到服务端的连接（调用 StreamAllocation.newStream 方法）
+        // 建联的 TCP 握手，TLS 握手
         interceptors.add(new ConnectInterceptor(client));
 
-        if (!forWebSocket) { // OkHttpClient.newCall()
+        if (!forWebSocket) { // 如果调用 OkHttpClient.newCall() 会走这里
             interceptors.addAll(client.networkInterceptors());
         }
+        // 用来发起请求并且得到响应，把 Request 的请求信息传入流中，并且从流中读取数据封装成 Response 返回
         interceptors.add(new CallServerInterceptor(forWebSocket));
 
+        // RealInterceptorChain 是 Interceptor.Chain 的唯一的实现类，
+        // 所有 Interceptor 的 intercept 方法接收的都是 RealInterceptorChain 的实例
         Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0,
                 originalRequest, this, eventListener, client.connectTimeoutMillis(),
                 client.readTimeoutMillis(), client.writeTimeoutMillis());
-
+        // 开始传递
         return chain.proceed(originalRequest);
     }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/RouteException.java b/okhttp/src/main/java/okhttp3/internal/connection/RouteException.java
index 5f50576611..203b805320 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/RouteException.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/RouteException.java
@@ -22,42 +22,47 @@
 /**
  * An exception thrown to indicate a problem connecting via a single Route. Multiple attempts may
  * have been made with alternative protocols, none of which were successful.
+ * <br> 以下内容不是翻译，来源于网络
+ * <p>
+ *     这个异常发生在 Request 请求还没有发出去前，就是打开 Socket 连接失败。
+ *     这个异常是 OkHttp 自定义的异常，是一个包裹类，包裹住了建联失败中发生的各种 Exception 主要发生 ConnectInterceptor 建立连接环节
+ *     比如连接超时抛出的 SocketTimeoutException，包裹在 RouteException 中
  */
 public final class RouteException extends RuntimeException {
-  private static final Method addSuppressedExceptionMethod;
-
-  static {
-    Method m;
-    try {
-      m = Throwable.class.getDeclaredMethod("addSuppressed", Throwable.class);
-    } catch (Exception e) {
-      m = null;
+    private static final Method addSuppressedExceptionMethod;
+
+    static {
+        Method m;
+        try {
+            m = Throwable.class.getDeclaredMethod("addSuppressed", Throwable.class);
+        } catch (Exception e) {
+            m = null;
+        }
+        addSuppressedExceptionMethod = m;
     }
-    addSuppressedExceptionMethod = m;
-  }
-
-  private IOException lastException;
-
-  public RouteException(IOException cause) {
-    super(cause);
-    lastException = cause;
-  }
-
-  public IOException getLastConnectException() {
-    return lastException;
-  }
-
-  public void addConnectException(IOException e) {
-    addSuppressedIfPossible(e, lastException);
-    lastException = e;
-  }
-
-  private void addSuppressedIfPossible(IOException e, IOException suppressed) {
-    if (addSuppressedExceptionMethod != null) {
-      try {
-        addSuppressedExceptionMethod.invoke(e, suppressed);
-      } catch (InvocationTargetException | IllegalAccessException ignored) {
-      }
+
+    private IOException lastException;
+
+    public RouteException(IOException cause) {
+        super(cause);
+        lastException = cause;
+    }
+
+    public IOException getLastConnectException() {
+        return lastException;
+    }
+
+    public void addConnectException(IOException e) {
+        addSuppressedIfPossible(e, lastException);
+        lastException = e;
+    }
+
+    private void addSuppressedIfPossible(IOException e, IOException suppressed) {
+        if (addSuppressedExceptionMethod != null) {
+            try {
+                addSuppressedExceptionMethod.invoke(e, suppressed);
+            } catch (InvocationTargetException | IllegalAccessException ignored) {
+            }
+        }
     }
-  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java b/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
index 0920121c27..8a04a190eb 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
@@ -20,6 +20,7 @@
 import java.lang.ref.WeakReference;
 import java.net.Socket;
 import java.util.List;
+
 import okhttp3.Address;
 import okhttp3.Call;
 import okhttp3.Connection;
@@ -38,446 +39,471 @@
 import static okhttp3.internal.Util.closeQuietly;
 
 /**
+ * 用来协调 Connection，Stream 和 Calls 的关系。封装了网络连接创建的一些策略。
+ * 比如使用 RouteSelector 和 RouteDatabase 在建联失败后的多 IP 路由的选择；
+ * HttpStream 流的创建；
+ * Connection 的创建和使用 ConnectionPool 进行连接复用等
+ * <p>
  * This class coordinates the relationship between three entities:
- *
+ * <p>
  * <ul>
- *     <li><strong>Connections:</strong> physical socket connections to remote servers. These are
- *         potentially slow to establish so it is necessary to be able to cancel a connection
- *         currently being connected.
- *     <li><strong>Streams:</strong> logical HTTP request/response pairs that are layered on
- *         connections. Each connection has its own allocation limit, which defines how many
- *         concurrent streams that connection can carry. HTTP/1.x connections can carry 1 stream
- *         at a time, HTTP/2 typically carry multiple.
- *     <li><strong>Calls:</strong> a logical sequence of streams, typically an initial request and
- *         its follow up requests. We prefer to keep all streams of a single call on the same
- *         connection for better behavior and locality.
+ * <li><strong>Connections:</strong> physical socket connections to remote servers. These are
+ * potentially slow to establish so it is necessary to be able to cancel a connection
+ * currently being connected.
+ * <br>
+ *     Connections: 和远程服务的物理 socket 连接。可能创建连接很慢，所以要能取消当前的连接。
+ * <li><strong>Streams:</strong> logical HTTP request/response pairs that are layered on
+ * connections. Each connection has its own allocation limit, which defines how many
+ * concurrent streams that connection can carry. HTTP/1.x connections can carry 1 stream
+ * at a time, HTTP/2 typically carry multiple.
+ * <br>
+ *     Streams: 处于连接层中的 HTTP 请求/相应对。每个连接有自己的分配限制（一个连接同时可以有多少个 streams），
+ *     HTTP/1.x 协议上可以有1个，HTTP/2 协议一般可以有多个。
+ * <li><strong>Calls:</strong> a logical sequence of streams, typically an initial request and
+ * its follow up requests. We prefer to keep all streams of a single call on the same
+ * connection for better behavior and locality.
+ * <br>
+ *     Calls: 一个初始的请求和它接连的请求的一系列 streams。为了更好的性能，我们倾向于保持一个单独请求的所有 streams 在同一个连接中
  * </ul>
- *
+ * <p>
  * <p>Instances of this class act on behalf of the call, using one or more streams over one or more
  * connections. This class has APIs to release each of the above resources:
- *
+ * <br>
+ *     此类的实例，能够实现连接复用。提供如下 APIs 来释放上述资源。
+ * <p>
  * <ul>
- *     <li>{@link #noNewStreams()} prevents the connection from being used for new streams in the
- *         future. Use this after a {@code Connection: close} header, or when the connection may be
- *         inconsistent.
- *     <li>{@link #streamFinished streamFinished()} releases the active stream from this allocation.
- *         Note that only one stream may be active at a given time, so it is necessary to call
- *         {@link #streamFinished streamFinished()} before creating a subsequent stream with {@link
- *         #newStream newStream()}.
- *     <li>{@link #release()} removes the call's hold on the connection. Note that this won't
- *         immediately free the connection if there is a stream still lingering. That happens when a
- *         call is complete but its response body has yet to be fully consumed.
- * </ul>
+ * <li>{@link #noNewStreams()} prevents the connection from being used for new streams in the
+ * future. Use this after a {@code Connection: close} header, or when the connection may be
+ * inconsistent.
+ * <br>
+ *     防止连接被新的 streams 使用。在 Connection 关闭 header，或者不正常时下调用。
  *
+ *
+ * <li>{@link #streamFinished streamFinished()} releases the active stream from this allocation.
+ * Note that only one stream may be active at a given time, so it is necessary to call
+ * <br>
+ *
+ * {@link #streamFinished streamFinished()} before creating a subsequent stream with {@link
+ * #newStream newStream()}.
+ * <li>{@link #release()} removes the call's hold on the connection. Note that this won't
+ * immediately free the connection if there is a stream still lingering. That happens when a
+ * call is complete but its response body has yet to be fully consumed.
+ * </ul>
+ * <p>
  * <p>This class supports {@linkplain #cancel asynchronous canceling}. This is intended to have the
  * smallest blast radius possible. If an HTTP/2 stream is active, canceling will cancel that stream
  * but not the other streams sharing its connection. But if the TLS handshake is still in progress
  * then canceling may break the entire connection.
  */
 public final class StreamAllocation {
-  public final Address address;
-  private RouteSelector.Selection routeSelection;
-  private Route route;
-  private final ConnectionPool connectionPool;
-  public final Call call;
-  public final EventListener eventListener;
-  private final Object callStackTrace;
-
-  // State guarded by connectionPool.
-  private final RouteSelector routeSelector;
-  private int refusedStreamCount;
-  private RealConnection connection;
-  private boolean released;
-  private boolean canceled;
-  private HttpCodec codec;
-
-  public StreamAllocation(ConnectionPool connectionPool, Address address, Call call,
-      EventListener eventListener, Object callStackTrace) {
-    this.connectionPool = connectionPool;
-    this.address = address;
-    this.call = call;
-    this.eventListener = eventListener;
-    this.routeSelector = new RouteSelector(address, routeDatabase(), call, eventListener);
-    this.callStackTrace = callStackTrace;
-  }
-
-  public HttpCodec newStream(
-      OkHttpClient client, Interceptor.Chain chain, boolean doExtensiveHealthChecks) {
-    int connectTimeout = chain.connectTimeoutMillis();
-    int readTimeout = chain.readTimeoutMillis();
-    int writeTimeout = chain.writeTimeoutMillis();
-    boolean connectionRetryEnabled = client.retryOnConnectionFailure();
-
-    try {
-      RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,
-          writeTimeout, connectionRetryEnabled, doExtensiveHealthChecks);
-      HttpCodec resultCodec = resultConnection.newCodec(client, chain, this);
-
-      synchronized (connectionPool) {
-        codec = resultCodec;
-        return resultCodec;
-      }
-    } catch (IOException e) {
-      throw new RouteException(e);
+    public final Address address;
+    private RouteSelector.Selection routeSelection;
+    private Route route;
+    private final ConnectionPool connectionPool;
+    public final Call call;
+    public final EventListener eventListener;
+    private final Object callStackTrace;
+
+    // State guarded by connectionPool.
+    private final RouteSelector routeSelector;
+    private int refusedStreamCount;
+    private RealConnection connection;
+    private boolean released;
+    private boolean canceled;
+    private HttpCodec codec;
+
+    public StreamAllocation(ConnectionPool connectionPool, Address address, Call call,
+                            EventListener eventListener, Object callStackTrace) {
+        this.connectionPool = connectionPool;
+        this.address = address;
+        this.call = call;
+        this.eventListener = eventListener;
+        this.routeSelector = new RouteSelector(address, routeDatabase(), call, eventListener);
+        this.callStackTrace = callStackTrace;
     }
-  }
-
-  /**
-   * Finds a connection and returns it if it is healthy. If it is unhealthy the process is repeated
-   * until a healthy connection is found.
-   */
-  private RealConnection findHealthyConnection(int connectTimeout, int readTimeout,
-      int writeTimeout, boolean connectionRetryEnabled, boolean doExtensiveHealthChecks)
-      throws IOException {
-    while (true) {
-      RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,
-          connectionRetryEnabled);
-
-      // If this is a brand new connection, we can skip the extensive health checks.
-      synchronized (connectionPool) {
-        if (candidate.successCount == 0) {
-          return candidate;
-        }
-      }
-
-      // Do a (potentially slow) check to confirm that the pooled connection is still good. If it
-      // isn't, take it out of the pool and start again.
-      if (!candidate.isHealthy(doExtensiveHealthChecks)) {
-        noNewStreams();
-        continue;
-      }
 
-      return candidate;
-    }
-  }
-
-  /**
-   * Returns a connection to host a new stream. This prefers the existing connection if it exists,
-   * then the pool, finally building a new connection.
-   */
-  private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout,
-      boolean connectionRetryEnabled) throws IOException {
-    boolean foundPooledConnection = false;
-    RealConnection result = null;
-    Route selectedRoute = null;
-    synchronized (connectionPool) {
-      if (released) throw new IllegalStateException("released");
-      if (codec != null) throw new IllegalStateException("codec != null");
-      if (canceled) throw new IOException("Canceled");
-
-      // Attempt to use an already-allocated connection.
-      RealConnection allocatedConnection = this.connection;
-      if (allocatedConnection != null && !allocatedConnection.noNewStreams) {
-        return allocatedConnection;
-      }
-
-      // Attempt to get a connection from the pool.
-      Internal.instance.get(connectionPool, address, this, null);
-      if (connection != null) {
-        foundPooledConnection = true;
-        result = connection;
-      } else {
-        selectedRoute = route;
-      }
+    public HttpCodec newStream(
+            OkHttpClient client, Interceptor.Chain chain, boolean doExtensiveHealthChecks) {
+        int connectTimeout = chain.connectTimeoutMillis();
+        int readTimeout = chain.readTimeoutMillis();
+        int writeTimeout = chain.writeTimeoutMillis();
+        boolean connectionRetryEnabled = client.retryOnConnectionFailure();
+
+        try {
+            RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,
+                    writeTimeout, connectionRetryEnabled, doExtensiveHealthChecks);
+            HttpCodec resultCodec = resultConnection.newCodec(client, chain, this);
+
+            synchronized (connectionPool) {
+                codec = resultCodec;
+                return resultCodec;
+            }
+        } catch (IOException e) {
+            throw new RouteException(e);
+        }
     }
 
-    // If we found a pooled connection, we're done.
-    if (foundPooledConnection) {
-      eventListener.connectionAcquired(call, result);
-      return result;
+    /**
+     * Finds a connection and returns it if it is healthy. If it is unhealthy the process is repeated
+     * until a healthy connection is found.
+     */
+    private RealConnection findHealthyConnection(int connectTimeout, int readTimeout,
+                                                 int writeTimeout, boolean connectionRetryEnabled, boolean doExtensiveHealthChecks)
+            throws IOException {
+        while (true) {
+            RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,
+                    connectionRetryEnabled);
+
+            // If this is a brand new connection, we can skip the extensive health checks.
+            synchronized (connectionPool) {
+                if (candidate.successCount == 0) {
+                    return candidate;
+                }
+            }
+
+            // Do a (potentially slow) check to confirm that the pooled connection is still good. If it
+            // isn't, take it out of the pool and start again.
+            if (!candidate.isHealthy(doExtensiveHealthChecks)) {
+                noNewStreams();
+                continue;
+            }
+
+            return candidate;
+        }
     }
 
-    // If we need a route selection, make one. This is a blocking operation.
-    boolean newRouteSelection = false;
-    if (selectedRoute == null && (routeSelection == null || !routeSelection.hasNext())) {
-      newRouteSelection = true;
-      routeSelection = routeSelector.next();
-    }
+    /**
+     * Returns a connection to host a new stream. This prefers the existing connection if it exists,
+     * then the pool, finally building a new connection.
+     */
+    private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout,
+                                          boolean connectionRetryEnabled) throws IOException {
+        boolean foundPooledConnection = false;
+        RealConnection result = null;
+        Route selectedRoute = null;
+        synchronized (connectionPool) {
+            if (released) throw new IllegalStateException("released");
+            if (codec != null) throw new IllegalStateException("codec != null");
+            if (canceled) throw new IOException("Canceled");
+
+            // Attempt to use an already-allocated connection.
+            RealConnection allocatedConnection = this.connection;
+            if (allocatedConnection != null && !allocatedConnection.noNewStreams) {
+                return allocatedConnection;
+            }
+
+            // Attempt to get a connection from the pool.
+            Internal.instance.get(connectionPool, address, this, null);
+            if (connection != null) {
+                foundPooledConnection = true;
+                result = connection;
+            } else {
+                selectedRoute = route;
+            }
+        }
 
-    synchronized (connectionPool) {
-      if (canceled) throw new IOException("Canceled");
-
-      if (newRouteSelection) {
-        // Now that we have a set of IP addresses, make another attempt at getting a connection from
-        // the pool. This could match due to connection coalescing.
-        List<Route> routes = routeSelection.getAll();
-        for (int i = 0, size = routes.size(); i < size; i++) {
-          Route route = routes.get(i);
-          Internal.instance.get(connectionPool, address, this, route);
-          if (connection != null) {
-            foundPooledConnection = true;
-            result = connection;
-            this.route = route;
-            break;
-          }
+        // If we found a pooled connection, we're done.
+        if (foundPooledConnection) {
+            eventListener.connectionAcquired(call, result);
+            return result;
         }
-      }
 
-      if (!foundPooledConnection) {
-        if (selectedRoute == null) {
-          selectedRoute = routeSelection.next();
+        // If we need a route selection, make one. This is a blocking operation.
+        boolean newRouteSelection = false;
+        if (selectedRoute == null && (routeSelection == null || !routeSelection.hasNext())) {
+            newRouteSelection = true;
+            routeSelection = routeSelector.next();
         }
 
-        // Create a connection and assign it to this allocation immediately. This makes it possible
-        // for an asynchronous cancel() to interrupt the handshake we're about to do.
-        route = selectedRoute;
-        refusedStreamCount = 0;
-        result = new RealConnection(connectionPool, selectedRoute);
-        acquire(result);
-      }
-    }
+        synchronized (connectionPool) {
+            if (canceled) throw new IOException("Canceled");
+
+            if (newRouteSelection) {
+                // Now that we have a set of IP addresses, make another attempt at getting a connection from
+                // the pool. This could match due to connection coalescing.
+                List<Route> routes = routeSelection.getAll();
+                for (int i = 0, size = routes.size(); i < size; i++) {
+                    Route route = routes.get(i);
+                    Internal.instance.get(connectionPool, address, this, route);
+                    if (connection != null) {
+                        foundPooledConnection = true;
+                        result = connection;
+                        this.route = route;
+                        break;
+                    }
+                }
+            }
+
+            if (!foundPooledConnection) {
+                if (selectedRoute == null) {
+                    selectedRoute = routeSelection.next();
+                }
+
+                // Create a connection and assign it to this allocation immediately. This makes it possible
+                // for an asynchronous cancel() to interrupt the handshake we're about to do.
+                route = selectedRoute;
+                refusedStreamCount = 0;
+                result = new RealConnection(connectionPool, selectedRoute);
+                acquire(result);
+            }
+        }
 
-    // We have a connection. Either a connected one from the pool, or one we need to connect.
-    eventListener.connectionAcquired(call, result);
+        // We have a connection. Either a connected one from the pool, or one we need to connect.
+        eventListener.connectionAcquired(call, result);
 
-    // If we found a pooled connection on the 2nd time around, we're done.
-    if (foundPooledConnection) {
-      return result;
-    }
+        // If we found a pooled connection on the 2nd time around, we're done.
+        if (foundPooledConnection) {
+            return result;
+        }
 
-    // Do TCP + TLS handshakes. This is a blocking operation.
-    result.connect(
-        connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled, call, eventListener);
-    routeDatabase().connected(result.route());
-
-    Socket socket = null;
-    synchronized (connectionPool) {
-      // Pool the connection.
-      Internal.instance.put(connectionPool, result);
-
-      // If another multiplexed connection to the same address was created concurrently, then
-      // release this connection and acquire that one.
-      if (result.isMultiplexed()) {
-        socket = Internal.instance.deduplicate(connectionPool, address, this);
-        result = connection;
-      }
-    }
-    closeQuietly(socket);
-
-    return result;
-  }
-
-  public void streamFinished(boolean noNewStreams, HttpCodec codec) {
-    Socket socket;
-    Connection releasedConnection;
-    synchronized (connectionPool) {
-      if (codec == null || codec != this.codec) {
-        throw new IllegalStateException("expected " + this.codec + " but was " + codec);
-      }
-      if (!noNewStreams) {
-        connection.successCount++;
-      }
-      releasedConnection = connection;
-      socket = deallocate(noNewStreams, false, true);
-      if (connection != null) releasedConnection = null;
-    }
-    closeQuietly(socket);
-    if (releasedConnection != null) {
-      eventListener.connectionReleased(call, releasedConnection);
-    }
-  }
+        // Do TCP + TLS handshakes. This is a blocking operation.
+        result.connect(
+                connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled, call, eventListener);
+        routeDatabase().connected(result.route());
+
+        Socket socket = null;
+        synchronized (connectionPool) {
+            // Pool the connection.
+            Internal.instance.put(connectionPool, result);
+
+            // If another multiplexed connection to the same address was created concurrently, then
+            // release this connection and acquire that one.
+            if (result.isMultiplexed()) {
+                socket = Internal.instance.deduplicate(connectionPool, address, this);
+                result = connection;
+            }
+        }
+        closeQuietly(socket);
 
-  public HttpCodec codec() {
-    synchronized (connectionPool) {
-      return codec;
-    }
-  }
-
-  private RouteDatabase routeDatabase() {
-    return Internal.instance.routeDatabase(connectionPool);
-  }
-
-  public synchronized RealConnection connection() {
-    return connection;
-  }
-
-  public void release() {
-    Socket socket;
-    Connection releasedConnection;
-    synchronized (connectionPool) {
-      releasedConnection = connection;
-      socket = deallocate(false, true, false);
-      if (connection != null) releasedConnection = null;
+        return result;
     }
-    closeQuietly(socket);
-    if (releasedConnection != null) {
-      eventListener.connectionReleased(call, releasedConnection);
-    }
-  }
-
-  /** Forbid new streams from being created on the connection that hosts this allocation. */
-  public void noNewStreams() {
-    Socket socket;
-    Connection releasedConnection;
-    synchronized (connectionPool) {
-      releasedConnection = connection;
-      socket = deallocate(true, false, false);
-      if (connection != null) releasedConnection = null;
+
+    public void streamFinished(boolean noNewStreams, HttpCodec codec) {
+        Socket socket;
+        Connection releasedConnection;
+        synchronized (connectionPool) {
+            if (codec == null || codec != this.codec) {
+                throw new IllegalStateException("expected " + this.codec + " but was " + codec);
+            }
+            if (!noNewStreams) {
+                connection.successCount++;
+            }
+            releasedConnection = connection;
+            socket = deallocate(noNewStreams, false, true);
+            if (connection != null) releasedConnection = null;
+        }
+        closeQuietly(socket);
+        if (releasedConnection != null) {
+            eventListener.connectionReleased(call, releasedConnection);
+        }
     }
-    closeQuietly(socket);
-    if (releasedConnection != null) {
-      eventListener.connectionReleased(call, releasedConnection);
+
+    public HttpCodec codec() {
+        synchronized (connectionPool) {
+            return codec;
+        }
     }
-  }
-
-  /**
-   * Releases resources held by this allocation. If sufficient resources are allocated, the
-   * connection will be detached or closed. Callers must be synchronized on the connection pool.
-   *
-   * <p>Returns a closeable that the caller should pass to {@link Util#closeQuietly} upon completion
-   * of the synchronized block. (We don't do I/O while synchronized on the connection pool.)
-   */
-  private Socket deallocate(boolean noNewStreams, boolean released, boolean streamFinished) {
-    assert (Thread.holdsLock(connectionPool));
-
-    if (streamFinished) {
-      this.codec = null;
+
+    private RouteDatabase routeDatabase() {
+        return Internal.instance.routeDatabase(connectionPool);
     }
-    if (released) {
-      this.released = true;
+
+    public synchronized RealConnection connection() {
+        return connection;
     }
-    Socket socket = null;
-    if (connection != null) {
-      if (noNewStreams) {
-        connection.noNewStreams = true;
-      }
-      if (this.codec == null && (this.released || connection.noNewStreams)) {
-        release(connection);
-        if (connection.allocations.isEmpty()) {
-          connection.idleAtNanos = System.nanoTime();
-          if (Internal.instance.connectionBecameIdle(connectionPool, connection)) {
-            socket = connection.socket();
-          }
+
+    public void release() {
+        Socket socket;
+        Connection releasedConnection;
+        synchronized (connectionPool) {
+            releasedConnection = connection;
+            socket = deallocate(false, true, false);
+            if (connection != null) releasedConnection = null;
+        }
+        closeQuietly(socket);
+        if (releasedConnection != null) {
+            eventListener.connectionReleased(call, releasedConnection);
         }
-        connection = null;
-      }
     }
-    return socket;
-  }
-
-  public void cancel() {
-    HttpCodec codecToCancel;
-    RealConnection connectionToCancel;
-    synchronized (connectionPool) {
-      canceled = true;
-      codecToCancel = codec;
-      connectionToCancel = connection;
+
+    /**
+     * Forbid new streams from being created on the connection that hosts this allocation.
+     */
+    public void noNewStreams() {
+        Socket socket;
+        Connection releasedConnection;
+        synchronized (connectionPool) {
+            releasedConnection = connection;
+            socket = deallocate(true, false, false);
+            if (connection != null) releasedConnection = null;
+        }
+        closeQuietly(socket);
+        if (releasedConnection != null) {
+            eventListener.connectionReleased(call, releasedConnection);
+        }
     }
-    if (codecToCancel != null) {
-      codecToCancel.cancel();
-    } else if (connectionToCancel != null) {
-      connectionToCancel.cancel();
+
+    /**
+     * Releases resources held by this allocation. If sufficient resources are allocated, the
+     * connection will be detached or closed. Callers must be synchronized on the connection pool.
+     * <p>
+     * <p>Returns a closeable that the caller should pass to {@link Util#closeQuietly} upon completion
+     * of the synchronized block. (We don't do I/O while synchronized on the connection pool.)
+     */
+    private Socket deallocate(boolean noNewStreams, boolean released, boolean streamFinished) {
+        assert (Thread.holdsLock(connectionPool));
+
+        if (streamFinished) {
+            this.codec = null;
+        }
+        if (released) {
+            this.released = true;
+        }
+        Socket socket = null;
+        if (connection != null) {
+            if (noNewStreams) {
+                connection.noNewStreams = true;
+            }
+            if (this.codec == null && (this.released || connection.noNewStreams)) {
+                release(connection);
+                if (connection.allocations.isEmpty()) {
+                    connection.idleAtNanos = System.nanoTime();
+                    if (Internal.instance.connectionBecameIdle(connectionPool, connection)) {
+                        socket = connection.socket();
+                    }
+                }
+                connection = null;
+            }
+        }
+        return socket;
     }
-  }
-
-  public void streamFailed(IOException e) {
-    Socket socket;
-    Connection releasedConnection;
-    boolean noNewStreams = false;
-
-    synchronized (connectionPool) {
-      if (e instanceof StreamResetException) {
-        StreamResetException streamResetException = (StreamResetException) e;
-        if (streamResetException.errorCode == ErrorCode.REFUSED_STREAM) {
-          refusedStreamCount++;
+
+    public void cancel() {
+        HttpCodec codecToCancel;
+        RealConnection connectionToCancel;
+        synchronized (connectionPool) {
+            canceled = true;
+            codecToCancel = codec;
+            connectionToCancel = connection;
         }
-        // On HTTP/2 stream errors, retry REFUSED_STREAM errors once on the same connection. All
-        // other errors must be retried on a new connection.
-        if (streamResetException.errorCode != ErrorCode.REFUSED_STREAM || refusedStreamCount > 1) {
-          noNewStreams = true;
-          route = null;
+        if (codecToCancel != null) {
+            codecToCancel.cancel();
+        } else if (connectionToCancel != null) {
+            connectionToCancel.cancel();
         }
-      } else if (connection != null
-          && (!connection.isMultiplexed() || e instanceof ConnectionShutdownException)) {
-        noNewStreams = true;
-
-        // If this route hasn't completed a call, avoid it for new connections.
-        if (connection.successCount == 0) {
-          if (route != null && e != null) {
-            routeSelector.connectFailed(route, e);
-          }
-          route = null;
+    }
+
+    public void streamFailed(IOException e) {
+        Socket socket;
+        Connection releasedConnection;
+        boolean noNewStreams = false;
+
+        synchronized (connectionPool) {
+            if (e instanceof StreamResetException) {
+                StreamResetException streamResetException = (StreamResetException) e;
+                if (streamResetException.errorCode == ErrorCode.REFUSED_STREAM) {
+                    refusedStreamCount++;
+                }
+                // On HTTP/2 stream errors, retry REFUSED_STREAM errors once on the same connection. All
+                // other errors must be retried on a new connection.
+                if (streamResetException.errorCode != ErrorCode.REFUSED_STREAM || refusedStreamCount > 1) {
+                    noNewStreams = true;
+                    route = null;
+                }
+            } else if (connection != null
+                    && (!connection.isMultiplexed() || e instanceof ConnectionShutdownException)) {
+                noNewStreams = true;
+
+                // If this route hasn't completed a call, avoid it for new connections.
+                if (connection.successCount == 0) {
+                    if (route != null && e != null) {
+                        routeSelector.connectFailed(route, e);
+                    }
+                    route = null;
+                }
+            }
+            releasedConnection = connection;
+            socket = deallocate(noNewStreams, false, true);
+            if (connection != null) releasedConnection = null;
+        }
+
+        closeQuietly(socket);
+        if (releasedConnection != null) {
+            eventListener.connectionReleased(call, releasedConnection);
         }
-      }
-      releasedConnection = connection;
-      socket = deallocate(noNewStreams, false, true);
-      if (connection != null) releasedConnection = null;
     }
 
-    closeQuietly(socket);
-    if (releasedConnection != null) {
-      eventListener.connectionReleased(call, releasedConnection);
+    /**
+     * Use this allocation to hold {@code connection}. Each call to this must be paired with a call to
+     * {@link #release} on the same connection.
+     */
+    public void acquire(RealConnection connection) {
+        assert (Thread.holdsLock(connectionPool));
+        if (this.connection != null) throw new IllegalStateException();
+
+        this.connection = connection;
+        connection.allocations.add(new StreamAllocationReference(this, callStackTrace));
     }
-  }
-
-  /**
-   * Use this allocation to hold {@code connection}. Each call to this must be paired with a call to
-   * {@link #release} on the same connection.
-   */
-  public void acquire(RealConnection connection) {
-    assert (Thread.holdsLock(connectionPool));
-    if (this.connection != null) throw new IllegalStateException();
-
-    this.connection = connection;
-    connection.allocations.add(new StreamAllocationReference(this, callStackTrace));
-  }
-
-  /** Remove this allocation from the connection's list of allocations. */
-  private void release(RealConnection connection) {
-    for (int i = 0, size = connection.allocations.size(); i < size; i++) {
-      Reference<StreamAllocation> reference = connection.allocations.get(i);
-      if (reference.get() == this) {
-        connection.allocations.remove(i);
-        return;
-      }
+
+    /**
+     * Remove this allocation from the connection's list of allocations.
+     */
+    private void release(RealConnection connection) {
+        for (int i = 0, size = connection.allocations.size(); i < size; i++) {
+            Reference<StreamAllocation> reference = connection.allocations.get(i);
+            if (reference.get() == this) {
+                connection.allocations.remove(i);
+                return;
+            }
+        }
+        throw new IllegalStateException();
     }
-    throw new IllegalStateException();
-  }
-
-  /**
-   * Release the connection held by this connection and acquire {@code newConnection} instead. It is
-   * only safe to call this if the held connection is newly connected but duplicated by {@code
-   * newConnection}. Typically this occurs when concurrently connecting to an HTTP/2 webserver.
-   *
-   * <p>Returns a closeable that the caller should pass to {@link Util#closeQuietly} upon completion
-   * of the synchronized block. (We don't do I/O while synchronized on the connection pool.)
-   */
-  public Socket releaseAndAcquire(RealConnection newConnection) {
-    assert (Thread.holdsLock(connectionPool));
-    if (codec != null || connection.allocations.size() != 1) throw new IllegalStateException();
-
-    // Release the old connection.
-    Reference<StreamAllocation> onlyAllocation = connection.allocations.get(0);
-    Socket socket = deallocate(true, false, false);
-
-    // Acquire the new connection.
-    this.connection = newConnection;
-    newConnection.allocations.add(onlyAllocation);
-
-    return socket;
-  }
-
-  public boolean hasMoreRoutes() {
-    return route != null
-        || (routeSelection != null && routeSelection.hasNext())
-        || routeSelector.hasNext();
-  }
-
-  @Override public String toString() {
-    RealConnection connection = connection();
-    return connection != null ? connection.toString() : address.toString();
-  }
-
-  public static final class StreamAllocationReference extends WeakReference<StreamAllocation> {
+
     /**
-     * Captures the stack trace at the time the Call is executed or enqueued. This is helpful for
-     * identifying the origin of connection leaks.
+     * Release the connection held by this connection and acquire {@code newConnection} instead. It is
+     * only safe to call this if the held connection is newly connected but duplicated by {@code
+     * newConnection}. Typically this occurs when concurrently connecting to an HTTP/2 webserver.
+     * <p>
+     * <p>Returns a closeable that the caller should pass to {@link Util#closeQuietly} upon completion
+     * of the synchronized block. (We don't do I/O while synchronized on the connection pool.)
      */
-    public final Object callStackTrace;
+    public Socket releaseAndAcquire(RealConnection newConnection) {
+        assert (Thread.holdsLock(connectionPool));
+        if (codec != null || connection.allocations.size() != 1) throw new IllegalStateException();
+
+        // Release the old connection.
+        Reference<StreamAllocation> onlyAllocation = connection.allocations.get(0);
+        Socket socket = deallocate(true, false, false);
 
-    StreamAllocationReference(StreamAllocation referent, Object callStackTrace) {
-      super(referent);
-      this.callStackTrace = callStackTrace;
+        // Acquire the new connection.
+        this.connection = newConnection;
+        newConnection.allocations.add(onlyAllocation);
+
+        return socket;
+    }
+
+    public boolean hasMoreRoutes() {
+        return route != null
+                || (routeSelection != null && routeSelection.hasNext())
+                || routeSelector.hasNext();
+    }
+
+    @Override
+    public String toString() {
+        RealConnection connection = connection();
+        return connection != null ? connection.toString() : address.toString();
+    }
+
+    public static final class StreamAllocationReference extends WeakReference<StreamAllocation> {
+        /**
+         * Captures the stack trace at the time the Call is executed or enqueued. This is helpful for
+         * identifying the origin of connection leaks.
+         */
+        public final Object callStackTrace;
+
+        StreamAllocationReference(StreamAllocation referent, Object callStackTrace) {
+            super(referent);
+            this.callStackTrace = callStackTrace;
+        }
     }
-  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java b/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java
index 373c08b212..726b55f155 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java
@@ -32,6 +32,8 @@
 /**
  * A concrete interceptor chain that carries the entire interceptor chain: all application
  * interceptors, the OkHttp core, all network interceptors, and finally the network caller.
+ * <br>
+ *     内部维护了所有要执行的拦截器列表，在 proceed 内部会唤醒下一个 Interceptor，调用 intercept 来进行下一步
  */
 public final class RealInterceptorChain implements Interceptor.Chain {
   private final List<Interceptor> interceptors;
@@ -139,11 +141,19 @@ public Response proceed(Request request, StreamAllocation streamAllocation, Http
           + " must call proceed() exactly once");
     }
 
+    // 核心代码
+    // 获取当前位置的拦截器，创建一个 Chain 传递给此拦截器，
+    // 在拦截器的 intercept 方法中调用 Chain 的 proceed 方法，直到最后的拦截器返回 response
+    // 类似递归的过程，但是是不同的 RealInterceptorChain 对象
+    Interceptor interceptor = interceptors.get(index);
+
     // Call the next interceptor in the chain.
     RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,
-        connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,
-        writeTimeout);
-    Interceptor interceptor = interceptors.get(index);
+            connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,
+            writeTimeout);
+
+    // 如果是最后一个拦截器则应该在 intercept 方法内直接返回 Response
+    // 如果不是则应该在 intercept 方法内调用 next 的 proceed 方法，除非自己能返回 Response(如缓存拦截器)
     Response response = interceptor.intercept(next);
 
     // Confirm that the next interceptor made its required call to chain.proceed().
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
index 937ba28ea7..3579b416d9 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
@@ -26,6 +26,7 @@
 import javax.net.ssl.SSLHandshakeException;
 import javax.net.ssl.SSLPeerUnverifiedException;
 import javax.net.ssl.SSLSocketFactory;
+
 import okhttp3.Address;
 import okhttp3.Call;
 import okhttp3.CertificatePinner;
@@ -56,324 +57,408 @@
 /**
  * This interceptor recovers from failures and follows redirects as necessary. It may throw an
  * {@link IOException} if the call was canceled.
+ * <br>错误重试、重定向
  */
 public final class RetryAndFollowUpInterceptor implements Interceptor {
-  /**
-   * How many redirects and auth challenges should we attempt? Chrome follows 21 redirects; Firefox,
-   * curl, and wget follow 20; Safari follows 16; and HTTP/1.0 recommends 5.
-   */
-  private static final int MAX_FOLLOW_UPS = 20;
-
-  private final OkHttpClient client;
-  private final boolean forWebSocket;
-  private StreamAllocation streamAllocation;
-  private Object callStackTrace;
-  private volatile boolean canceled;
-
-  public RetryAndFollowUpInterceptor(OkHttpClient client, boolean forWebSocket) {
-    this.client = client;
-    this.forWebSocket = forWebSocket;
-  }
-
-  /**
-   * Immediately closes the socket connection if it's currently held. Use this to interrupt an
-   * in-flight request from any thread. It's the caller's responsibility to close the request body
-   * and response body streams; otherwise resources may be leaked.
-   *
-   * <p>This method is safe to be called concurrently, but provides limited guarantees. If a
-   * transport layer connection has been established (such as a HTTP/2 stream) that is terminated.
-   * Otherwise if a socket connection is being established, that is terminated.
-   */
-  public void cancel() {
-    canceled = true;
-    StreamAllocation streamAllocation = this.streamAllocation;
-    if (streamAllocation != null) streamAllocation.cancel();
-  }
-
-  public boolean isCanceled() {
-    return canceled;
-  }
-
-  public void setCallStackTrace(Object callStackTrace) {
-    this.callStackTrace = callStackTrace;
-  }
-
-  public StreamAllocation streamAllocation() {
-    return streamAllocation;
-  }
-
-  @Override public Response intercept(Chain chain) throws IOException {
-    Request request = chain.request();
-    RealInterceptorChain realChain = (RealInterceptorChain) chain;
-    Call call = realChain.call();
-    EventListener eventListener = realChain.eventListener();
-
-    streamAllocation = new StreamAllocation(client.connectionPool(), createAddress(request.url()),
-        call, eventListener, callStackTrace);
-
-    int followUpCount = 0;
-    Response priorResponse = null;
-    while (true) {
-      if (canceled) {
-        streamAllocation.release();
-        throw new IOException("Canceled");
-      }
-
-      Response response;
-      boolean releaseConnection = true;
-      try {
-        response = realChain.proceed(request, streamAllocation, null, null);
-        releaseConnection = false;
-      } catch (RouteException e) {
-        // The attempt to connect via a route failed. The request will not have been sent.
-        if (!recover(e.getLastConnectException(), false, request)) {
-          throw e.getLastConnectException();
-        }
-        releaseConnection = false;
-        continue;
-      } catch (IOException e) {
-        // An attempt to communicate with a server failed. The request may have been sent.
-        boolean requestSendStarted = !(e instanceof ConnectionShutdownException);
-        if (!recover(e, requestSendStarted, request)) throw e;
-        releaseConnection = false;
-        continue;
-      } finally {
-        // We're throwing an unchecked exception. Release any resources.
-        if (releaseConnection) {
-          streamAllocation.streamFailed(null);
-          streamAllocation.release();
-        }
-      }
-
-      // Attach the prior response if it exists. Such responses never have a body.
-      if (priorResponse != null) {
-        response = response.newBuilder()
-            .priorResponse(priorResponse.newBuilder()
-                    .body(null)
-                    .build())
-            .build();
-      }
-
-      Request followUp = followUpRequest(response);
-
-      if (followUp == null) {
-        if (!forWebSocket) {
-          streamAllocation.release();
-        }
-        return response;
-      }
-
-      closeQuietly(response.body());
-
-      if (++followUpCount > MAX_FOLLOW_UPS) {
-        streamAllocation.release();
-        throw new ProtocolException("Too many follow-up requests: " + followUpCount);
-      }
-
-      if (followUp.body() instanceof UnrepeatableRequestBody) {
-        streamAllocation.release();
-        throw new HttpRetryException("Cannot retry streamed HTTP body", response.code());
-      }
-
-      if (!sameConnection(response, followUp.url())) {
-        streamAllocation.release();
-        streamAllocation = new StreamAllocation(client.connectionPool(),
-            createAddress(followUp.url()), call, eventListener, callStackTrace);
-      } else if (streamAllocation.codec() != null) {
-        throw new IllegalStateException("Closing the body of " + response
-            + " didn't close its backing stream. Bad interceptor?");
-      }
-
-      request = followUp;
-      priorResponse = response;
-    }
-  }
-
-  private Address createAddress(HttpUrl url) {
-    SSLSocketFactory sslSocketFactory = null;
-    HostnameVerifier hostnameVerifier = null;
-    CertificatePinner certificatePinner = null;
-    if (url.isHttps()) {
-      sslSocketFactory = client.sslSocketFactory();
-      hostnameVerifier = client.hostnameVerifier();
-      certificatePinner = client.certificatePinner();
+    /**
+     * How many redirects and auth challenges should we attempt? Chrome follows 21 redirects; Firefox,
+     * curl, and wget follow 20; Safari follows 16; and HTTP/1.0 recommends 5.
+     */
+    private static final int MAX_FOLLOW_UPS = 20;
+
+    private final OkHttpClient client;
+    private final boolean forWebSocket;
+    private StreamAllocation streamAllocation;
+    private Object callStackTrace;
+    private volatile boolean canceled;
+
+    public RetryAndFollowUpInterceptor(OkHttpClient client, boolean forWebSocket) {
+        this.client = client;
+        this.forWebSocket = forWebSocket;
     }
 
-    return new Address(url.host(), url.port(), client.dns(), client.socketFactory(),
-        sslSocketFactory, hostnameVerifier, certificatePinner, client.proxyAuthenticator(),
-        client.proxy(), client.protocols(), client.connectionSpecs(), client.proxySelector());
-  }
-
-  /**
-   * Report and attempt to recover from a failure to communicate with a server. Returns true if
-   * {@code e} is recoverable, or false if the failure is permanent. Requests with a body can only
-   * be recovered if the body is buffered or if the failure occurred before the request has been
-   * sent.
-   */
-  private boolean recover(IOException e, boolean requestSendStarted, Request userRequest) {
-    streamAllocation.streamFailed(e);
-
-    // The application layer has forbidden retries.
-    if (!client.retryOnConnectionFailure()) return false;
-
-    // We can't send the request body again.
-    if (requestSendStarted && userRequest.body() instanceof UnrepeatableRequestBody) return false;
-
-    // This exception is fatal.
-    if (!isRecoverable(e, requestSendStarted)) return false;
-
-    // No more routes to attempt.
-    if (!streamAllocation.hasMoreRoutes()) return false;
-
-    // For failure recovery, use the same route selector with a new connection.
-    return true;
-  }
+    /**
+     * Immediately closes the socket connection if it's currently held. Use this to interrupt an
+     * in-flight request from any thread. It's the caller's responsibility to close the request body
+     * and response body streams; otherwise resources may be leaked.
+     * <p>
+     * <p>This method is safe to be called concurrently, but provides limited guarantees. If a
+     * transport layer connection has been established (such as a HTTP/2 stream) that is terminated.
+     * Otherwise if a socket connection is being established, that is terminated.
+     */
+    public void cancel() {
+        canceled = true;
+        StreamAllocation streamAllocation = this.streamAllocation;
+        if (streamAllocation != null) streamAllocation.cancel();
+    }
 
-  private boolean isRecoverable(IOException e, boolean requestSendStarted) {
-    // If there was a protocol problem, don't recover.
-    if (e instanceof ProtocolException) {
-      return false;
+    public boolean isCanceled() {
+        return canceled;
     }
 
-    // If there was an interruption don't recover, but if there was a timeout connecting to a route
-    // we should try the next route (if there is one).
-    if (e instanceof InterruptedIOException) {
-      return e instanceof SocketTimeoutException && !requestSendStarted;
+    public void setCallStackTrace(Object callStackTrace) {
+        this.callStackTrace = callStackTrace;
     }
 
-    // Look for known client-side or negotiation errors that are unlikely to be fixed by trying
-    // again with a different route.
-    if (e instanceof SSLHandshakeException) {
-      // If the problem was a CertificateException from the X509TrustManager,
-      // do not retry.
-      if (e.getCause() instanceof CertificateException) {
-        return false;
-      }
+    public StreamAllocation streamAllocation() {
+        return streamAllocation;
     }
-    if (e instanceof SSLPeerUnverifiedException) {
-      // e.g. a certificate pinning error.
-      return false;
+
+    /**
+     * 主要逻辑伪码
+     * <pre> {@code
+     *
+     *   Request request = chain.request();
+     *   ...
+     *   int followUpCount = 0;
+     *   Response priorResponse = null;
+     *
+     *   //循环入口
+     *   while (true) {
+     *      ...
+     *      Response response = null;
+     *      try {
+     *          //一次请求处理，获得结果
+     *          response = ((RealInterceptorChain) chain).proceed(request, streamAllocation, null, null);
+     *      } catch (RouteException e) {
+     *          ...
+     *          continue;
+     *      } catch (IOException e) {
+     *          ...
+     *          continue;
+     *      } finally {
+     *          ...
+     *      }
+     *      // 如果前一次请求结果不为空，讲它添加到新的请求结果中。通常第一次请求一定是异常请求结果，一定没有body。
+     *      if (priorResponse != null) {
+     *          response = response.newBuilder()
+     *                             .priorResponse(priorResponse.newBuilder()
+     *                             .body(null)
+     *                             .build())
+     *                             .build();
+     *      }
+     *      //获取后续的请求，比如验证，重定向，失败重连...
+     *      Request followUp = followUpRequest(response);
+     *      if (followUp == null) {
+     *          ...
+     *          //如果没有后续的请求了，直接返回请求结果
+     *          return response;
+     *      }
+     *      ...
+     *      request = followUp;
+     *      priorResponse = response;
+     *  }
+     * }</pre>
+     */
+    @Override
+    public Response intercept(Chain chain) throws IOException {
+        Request request = chain.request();
+        RealInterceptorChain realChain = (RealInterceptorChain) chain;
+        Call call = realChain.call();
+        EventListener eventListener = realChain.eventListener();
+
+        streamAllocation = new StreamAllocation(client.connectionPool(), createAddress(request.url()),
+                call, eventListener, callStackTrace);
+
+        int followUpCount = 0;
+        Response priorResponse = null;
+        while (true) {
+            if (canceled) {
+                streamAllocation.release();
+                throw new IOException("Canceled");
+            }
+
+            Response response;
+            boolean releaseConnection = true;
+            try {
+                response = realChain.proceed(request, streamAllocation, null, null);
+                releaseConnection = false;
+            } catch (RouteException e) {
+                // The attempt to connect via a route failed. The request will not have been sent.
+                // 尝试通过路由连接失败，请求还没有发出
+                if (!recover(e.getLastConnectException(), false, request)) {
+                    throw e.getLastConnectException();
+                }
+                releaseConnection = false;
+                continue;
+            } catch (IOException e) {
+                // An attempt to communicate with a server failed. The request may have been sent.
+                // 尝试与服务器通讯失败，请求可能已经发出
+                boolean requestSendStarted = !(e instanceof ConnectionShutdownException);
+                if (!recover(e, requestSendStarted, request)) throw e;
+                releaseConnection = false;
+                continue;
+            } finally {
+                // We're throwing an unchecked exception. Release any resources.
+                // 抛出未捕获的异常，释放资源
+                if (releaseConnection) {
+                    streamAllocation.streamFailed(null);
+                    streamAllocation.release();
+                }
+            }
+
+            // Attach the prior response if it exists. Such responses never have a body.
+            // 如果前一次请求结果不为空，将它添加到新的请求结果中。
+            // 通常第一次请求一定是异常请求结果，一定没有body。
+            if (priorResponse != null) {
+                response = response.newBuilder()
+                        .priorResponse(priorResponse.newBuilder()
+                                .body(null)
+                                .build())
+                        .build();
+            }
+            // 继续请求，比如验证，重定向，失败重连.
+            Request followUp = followUpRequest(response);
+
+            // 不继续请求，则释放资源
+            if (followUp == null) {
+                if (!forWebSocket) {
+                    streamAllocation.release();
+                }
+                return response;
+            }
+            // 关闭
+            closeQuietly(response.body());
+
+            if (++followUpCount > MAX_FOLLOW_UPS) {
+                streamAllocation.release();
+                throw new ProtocolException("Too many follow-up requests: " + followUpCount);
+            }
+
+            if (followUp.body() instanceof UnrepeatableRequestBody) {
+                streamAllocation.release();
+                throw new HttpRetryException("Cannot retry streamed HTTP body", response.code());
+            }
+            // 不是同一个连接，重新创建 StreamAllocation
+            if (!sameConnection(response, followUp.url())) {
+                streamAllocation.release();
+                streamAllocation = new StreamAllocation(client.connectionPool(),
+                        createAddress(followUp.url()), call, eventListener, callStackTrace);
+            } else if (streamAllocation.codec() != null) {
+                throw new IllegalStateException("Closing the body of " + response
+                        + " didn't close its backing stream. Bad interceptor?");
+            }
+
+            request = followUp;
+            priorResponse = response;
+        }
     }
 
-    // An example of one we might want to retry with a different route is a problem connecting to a
-    // proxy and would manifest as a standard IOException. Unless it is one we know we should not
-    // retry, we return true and try a new route.
-    return true;
-  }
-
-  /**
-   * Figures out the HTTP request to make in response to receiving {@code userResponse}. This will
-   * either add authentication headers, follow redirects or handle a client request timeout. If a
-   * follow-up is either unnecessary or not applicable, this returns null.
-   */
-  private Request followUpRequest(Response userResponse) throws IOException {
-    if (userResponse == null) throw new IllegalStateException();
-    Connection connection = streamAllocation.connection();
-    Route route = connection != null
-        ? connection.route()
-        : null;
-    int responseCode = userResponse.code();
-
-    final String method = userResponse.request().method();
-    switch (responseCode) {
-      case HTTP_PROXY_AUTH:
-        Proxy selectedProxy = route != null
-            ? route.proxy()
-            : client.proxy();
-        if (selectedProxy.type() != Proxy.Type.HTTP) {
-          throw new ProtocolException("Received HTTP_PROXY_AUTH (407) code while not using proxy");
+    private Address createAddress(HttpUrl url) {
+        SSLSocketFactory sslSocketFactory = null;
+        HostnameVerifier hostnameVerifier = null;
+        CertificatePinner certificatePinner = null;
+        if (url.isHttps()) {
+            sslSocketFactory = client.sslSocketFactory();
+            hostnameVerifier = client.hostnameVerifier();
+            certificatePinner = client.certificatePinner();
         }
-        return client.proxyAuthenticator().authenticate(route, userResponse);
 
-      case HTTP_UNAUTHORIZED:
-        return client.authenticator().authenticate(route, userResponse);
+        return new Address(url.host(), url.port(), client.dns(), client.socketFactory(),
+                sslSocketFactory, hostnameVerifier, certificatePinner, client.proxyAuthenticator(),
+                client.proxy(), client.protocols(), client.connectionSpecs(), client.proxySelector());
+    }
 
-      case HTTP_PERM_REDIRECT:
-      case HTTP_TEMP_REDIRECT:
-        // "If the 307 or 308 status code is received in response to a request other than GET
-        // or HEAD, the user agent MUST NOT automatically redirect the request"
-        if (!method.equals("GET") && !method.equals("HEAD")) {
-          return null;
-        }
-        // fall-through
-      case HTTP_MULT_CHOICE:
-      case HTTP_MOVED_PERM:
-      case HTTP_MOVED_TEMP:
-      case HTTP_SEE_OTHER:
-        // Does the client allow redirects?
-        if (!client.followRedirects()) return null;
-
-        String location = userResponse.header("Location");
-        if (location == null) return null;
-        HttpUrl url = userResponse.request().url().resolve(location);
-
-        // Don't follow redirects to unsupported protocols.
-        if (url == null) return null;
-
-        // If configured, don't follow redirects between SSL and non-SSL.
-        boolean sameScheme = url.scheme().equals(userResponse.request().url().scheme());
-        if (!sameScheme && !client.followSslRedirects()) return null;
-
-        // Most redirects don't include a request body.
-        Request.Builder requestBuilder = userResponse.request().newBuilder();
-        if (HttpMethod.permitsRequestBody(method)) {
-          final boolean maintainBody = HttpMethod.redirectsWithBody(method);
-          if (HttpMethod.redirectsToGet(method)) {
-            requestBuilder.method("GET", null);
-          } else {
-            RequestBody requestBody = maintainBody ? userResponse.request().body() : null;
-            requestBuilder.method(method, requestBody);
-          }
-          if (!maintainBody) {
-            requestBuilder.removeHeader("Transfer-Encoding");
-            requestBuilder.removeHeader("Content-Length");
-            requestBuilder.removeHeader("Content-Type");
-          }
-        }
+    /**
+     * Report and attempt to recover from a failure to communicate with a server. Returns true if
+     * {@code e} is recoverable, or false if the failure is permanent. Requests with a body can only
+     * be recovered if the body is buffered or if the failure occurred before the request has been
+     * sent.
+     *<br>
+     *     在服务器通讯失败的情况下，尝试重试，并返回重试的结果。
+     *     如果可重试，返回 true，如果错误是永久性的，返回 false。
+     *     有请求体的请求，只有当请求体是缓存的或者错误发生在请求发送前，才可重试
+     */
+    private boolean recover(IOException e, boolean requestSendStarted, Request userRequest) {
+        streamAllocation.streamFailed(e);
+
+        // The application layer has forbidden retries.
+        // 应用没有配置连接失败后重试
+        if (!client.retryOnConnectionFailure()) return false;
+
+        // We can't send the request body again.
+        // 请求体不能再次发送
+        // 不是被 RouteException 包裹的异常，并且请求体被 UnrepeatableRequestBody 标记
+        if (requestSendStarted && userRequest.body() instanceof UnrepeatableRequestBody) return false;
+
+        // This exception is fatal.
+        // 致命的异常，不可重试
+        if (!isRecoverable(e, requestSendStarted)) return false;
+
+        // No more routes to attempt.
+        // 已经没有其他的路由可以使用
+        if (!streamAllocation.hasMoreRoutes()) return false;
+
+        // For failure recovery, use the same route selector with a new connection.
+        return true;
+    }
 
-        // When redirecting across hosts, drop all authentication headers. This
-        // is potentially annoying to the application layer since they have no
-        // way to retain them.
-        if (!sameConnection(userResponse, url)) {
-          requestBuilder.removeHeader("Authorization");
+    private boolean isRecoverable(IOException e, boolean requestSendStarted) {
+        // If there was a protocol problem, don't recover.
+        // 协议异常不可重试
+        if (e instanceof ProtocolException) {
+            return false;
         }
 
-        return requestBuilder.url(url).build();
-
-      case HTTP_CLIENT_TIMEOUT:
-        // 408's are rare in practice, but some servers like HAProxy use this response code. The
-        // spec says that we may repeat the request without modifications. Modern browsers also
-        // repeat the request (even non-idempotent ones.)
-        if (!client.retryOnConnectionFailure()) {
-          // The application layer has directed us not to retry the request.
-          return null;
+        // If there was an interruption don't recover, but if there was a timeout connecting to a route
+        // we should try the next route (if there is one).
+        // 如果连接路由超时，则应该尝试下一个路由（如果有的话）
+        if (e instanceof InterruptedIOException) {
+            return e instanceof SocketTimeoutException && !requestSendStarted;
         }
 
-        if (userResponse.request().body() instanceof UnrepeatableRequestBody) {
-          return null;
+        // Look for known client-side or negotiation errors that are unlikely to be fixed by trying
+        // again with a different route.
+        if (e instanceof SSLHandshakeException) {
+            // If the problem was a CertificateException from the X509TrustManager,
+            // do not retry.
+            // 证书错误导致的异常，不重试
+            if (e.getCause() instanceof CertificateException) {
+                return false;
+            }
         }
 
-        if (userResponse.priorResponse() != null
-            && userResponse.priorResponse().code() == HTTP_CLIENT_TIMEOUT) {
-          // We attempted to retry and got another timeout. Give up.
-          return null;
+        // 证书不在可以信任的证书列表中
+        if (e instanceof SSLPeerUnverifiedException) {
+            // e.g. a certificate pinning error.
+            return false;
         }
 
-        return userResponse.request();
+        // An example of one we might want to retry with a different route is a problem connecting to a
+        // proxy and would manifest as a standard IOException. Unless it is one we know we should not
+        // retry, we return true and try a new route.
+        return true;
+    }
+
+    /**
+     * Figures out the HTTP request to make in response to receiving {@code userResponse}. This will
+     * either add authentication headers, follow redirects or handle a client request timeout. If a
+     * follow-up is either unnecessary or not applicable, this returns null.
+     */
+    private Request followUpRequest(Response userResponse) throws IOException {
+        if (userResponse == null) throw new IllegalStateException();
+        Connection connection = streamAllocation.connection();
+        Route route = connection != null
+                ? connection.route()
+                : null;
+        int responseCode = userResponse.code();
+
+        final String method = userResponse.request().method();
+        switch (responseCode) {
+            // 407 需要授权代理
+            case HTTP_PROXY_AUTH:
+                Proxy selectedProxy = route != null
+                        ? route.proxy()
+                        : client.proxy();
+                if (selectedProxy.type() != Proxy.Type.HTTP) {
+                    throw new ProtocolException("Received HTTP_PROXY_AUTH (407) code while not using proxy");
+                }
+                return client.proxyAuthenticator().authenticate(route, userResponse);
+            // 401 未授权
+            case HTTP_UNAUTHORIZED:
+                return client.authenticator().authenticate(route, userResponse);
+
+            // 308
+            case HTTP_PERM_REDIRECT:
+            // 307
+            case HTTP_TEMP_REDIRECT:
+                // "If the 307 or 308 status code is received in response to a request other than GET
+                // or HEAD, the user agent MUST NOT automatically redirect the request"
+                // 如果不是 GET 或 HEAD 请求，不能重定向
+                if (!method.equals("GET") && !method.equals("HEAD")) {
+                    return null;
+                }
+                // fall-through
+            case HTTP_MULT_CHOICE: // 300
+            case HTTP_MOVED_PERM: // 301
+            case HTTP_MOVED_TEMP: // 302
+            case HTTP_SEE_OTHER: // 303
+                // Does the client allow redirects?
+                // 是否设置允许重定向（默认为 false）
+                if (!client.followRedirects()) return null;
+                // 从响应中获取 Location
+                String location = userResponse.header("Location");
+                if (location == null) return null;
+                HttpUrl url = userResponse.request().url().resolve(location);
+
+                // Don't follow redirects to unsupported protocols.
+                // 不支持的协议不重定向
+                if (url == null) return null;
+
+                // If configured, don't follow redirects between SSL and non-SSL.
+                // HTTPS 和 HTTP 之间的重定向，需要根据配置 followSslRedirects(默认 true) 来判断
+                boolean sameScheme = url.scheme().equals(userResponse.request().url().scheme());
+                if (!sameScheme && !client.followSslRedirects()) return null;
+
+                // Most redirects don't include a request body.
+                Request.Builder requestBuilder = userResponse.request().newBuilder();
+                if (HttpMethod.permitsRequestBody(method)) {
+                    final boolean maintainBody = HttpMethod.redirectsWithBody(method);
+                    if (HttpMethod.redirectsToGet(method)) {
+                        requestBuilder.method("GET", null);
+                    } else {
+                        RequestBody requestBody = maintainBody ? userResponse.request().body() : null;
+                        requestBuilder.method(method, requestBody);
+                    }
+                    if (!maintainBody) {
+                        requestBuilder.removeHeader("Transfer-Encoding");
+                        requestBuilder.removeHeader("Content-Length");
+                        requestBuilder.removeHeader("Content-Type");
+                    }
+                }
+
+                // When redirecting across hosts, drop all authentication headers. This
+                // is potentially annoying to the application layer since they have no
+                // way to retain them.
+                // 如果不是同一个连接（比如 host 不同），去掉授权头部 “Authorization”
+                if (!sameConnection(userResponse, url)) {
+                    requestBuilder.removeHeader("Authorization");
+                }
+
+                return requestBuilder.url(url).build();
+
+            case HTTP_CLIENT_TIMEOUT: // 408
+                // 408's are rare in practice, but some servers like HAProxy use this response code. The
+                // spec says that we may repeat the request without modifications. Modern browsers also
+                // repeat the request (even non-idempotent ones.)
+                // 实际情况下 408 很少出现，但有些服务端，如 HAProxy，使用 408。
+                // 408 表示不修改原请求，再重新发送
+                if (!client.retryOnConnectionFailure()) {
+                    // The application layer has directed us not to retry the request.
+                    // 应用层配置连接失败不需要重试
+                    return null;
+                }
+
+                if (userResponse.request().body() instanceof UnrepeatableRequestBody) {
+                    return null;
+                }
+
+                if (userResponse.priorResponse() != null
+                        && userResponse.priorResponse().code() == HTTP_CLIENT_TIMEOUT) {
+                    // We attempted to retry and got another timeout. Give up.
+                    // 尝试重试了，但又超时了，放弃
+                    return null;
+                }
+
+                return userResponse.request();
+
+            default:
+                return null;
+        }
+    }
 
-      default:
-        return null;
+    /**
+     * Returns true if an HTTP request for {@code followUp} can reuse the connection used by this
+     * engine.
+     * <br>
+     *     host 相同
+     *     port 相同
+     *     scheme 相同，http 或 https
+     */
+    private boolean sameConnection(Response response, HttpUrl followUp) {
+        HttpUrl url = response.request().url();
+        return url.host().equals(followUp.host())
+                && url.port() == followUp.port()
+                && url.scheme().equals(followUp.scheme());
     }
-  }
-
-  /**
-   * Returns true if an HTTP request for {@code followUp} can reuse the connection used by this
-   * engine.
-   */
-  private boolean sameConnection(Response response, HttpUrl followUp) {
-    HttpUrl url = response.request().url();
-    return url.host().equals(followUp.host())
-        && url.port() == followUp.port()
-        && url.scheme().equals(followUp.scheme());
-  }
 }
