diff --git a/android-test/build.gradle b/android-test/build.gradle
index 995d5bef1f..d9559fe201 100644
--- a/android-test/build.gradle
+++ b/android-test/build.gradle
@@ -32,6 +32,7 @@ dependencies {
   implementation "org.jetbrains.kotlin:kotlin-stdlib-jdk8:${versions.kotlin}"
   implementation project(':okhttp')
   testImplementation 'junit:junit:4.12'
+  androidTestImplementation project(':okhttp-testing-support')
   androidTestImplementation project(':mockwebserver')
   androidTestImplementation project(':okhttp-tls')
   androidTestImplementation 'com.android.support.test:runner:1.0.2'
diff --git a/android-test/src/androidTest/java/okhttp/android/test/OkHttpTest.kt b/android-test/src/androidTest/java/okhttp/android/test/OkHttpTest.kt
index 9af2d997c4..3aec4cab37 100644
--- a/android-test/src/androidTest/java/okhttp/android/test/OkHttpTest.kt
+++ b/android-test/src/androidTest/java/okhttp/android/test/OkHttpTest.kt
@@ -23,11 +23,13 @@ import okhttp3.Connection
 import okhttp3.EventListener
 import okhttp3.OkHttpClient
 import okhttp3.Protocol
+import okhttp3.RecordingEventListener
 import okhttp3.Request
 import okhttp3.TlsVersion
 import okhttp3.mockwebserver.MockResponse
 import okhttp3.mockwebserver.MockWebServer
 import okhttp3.tls.internal.TlsUtil.localhost
+import okio.ByteString.Companion.toByteString
 import org.junit.After
 import org.junit.Assert.assertEquals
 import org.junit.Assert.assertTrue
@@ -41,6 +43,7 @@ import org.junit.runner.RunWith
 import java.net.InetAddress
 import java.net.UnknownHostException
 import javax.net.ssl.SSLPeerUnverifiedException
+import javax.net.ssl.SSLSocket
 
 /**
  * Run with "./gradlew :android-test:connectedCheck" and make sure ANDROID_SDK_ROOT is set.
@@ -190,6 +193,75 @@ class OkHttpTest {
     }
   }
 
+  @Test
+  fun testEventListener() {
+    val eventListener = RecordingEventListener()
+
+    client = client.newBuilder().eventListener(eventListener).build()
+
+    enableTls()
+
+    server.enqueue(MockResponse().setBody("abc1"))
+    server.enqueue(MockResponse().setBody("abc2"))
+
+    val request = Request.Builder().url(server.url("/")).build()
+
+    client.newCall(request).execute().use { response ->
+      assertEquals(200, response.code)
+    }
+
+    assertEquals(listOf("CallStart", "ProxySelectStart", "ProxySelectEnd", "DnsStart", "DnsEnd",
+        "ConnectStart", "SecureConnectStart", "SecureConnectEnd", "ConnectEnd",
+        "ConnectionAcquired", "RequestHeadersStart", "RequestHeadersEnd", "ResponseHeadersStart",
+        "ResponseHeadersEnd", "ResponseBodyStart", "ResponseBodyEnd", "ConnectionReleased",
+        "CallEnd"), eventListener.recordedEventTypes())
+
+    eventListener.clearAllEvents()
+
+    client.newCall(request).execute().use { response ->
+      assertEquals(200, response.code)
+    }
+
+    assertEquals(listOf("CallStart", "ProxySelectStart", "ProxySelectEnd",
+        "ConnectionAcquired", "RequestHeadersStart", "RequestHeadersEnd", "ResponseHeadersStart",
+        "ResponseHeadersEnd", "ResponseBodyStart", "ResponseBodyEnd", "ConnectionReleased",
+        "CallEnd"), eventListener.recordedEventTypes())
+  }
+
+  @Test
+  fun testSessionReuse() {
+    val sessionIds = mutableListOf<String>()
+
+    client = client.newBuilder().eventListener(object : EventListener() {
+      override fun connectionAcquired(call: Call, connection: Connection) {
+        val sslSocket = connection.socket() as SSLSocket
+
+        sessionIds.add(sslSocket.session.id.toByteString().hex())
+      }
+    }).build()
+
+    enableTls()
+
+    server.enqueue(MockResponse().setBody("abc1"))
+    server.enqueue(MockResponse().setBody("abc2"))
+
+    val request = Request.Builder().url(server.url("/")).build()
+
+    client.newCall(request).execute().use { response ->
+      assertEquals(200, response.code)
+    }
+
+    client.connectionPool.evictAll()
+    assertEquals(0, client.connectionPool.connectionCount())
+
+    client.newCall(request).execute().use { response ->
+      assertEquals(200, response.code)
+    }
+
+    assertEquals(2, sessionIds.size)
+    assertEquals(sessionIds[0], sessionIds[1])
+  }
+
   private fun enableTls() {
     client = client.newBuilder()
         .sslSocketFactory(
diff --git a/build.gradle b/build.gradle
index a1fb6a0740..22f122ecc5 100644
--- a/build.gradle
+++ b/build.gradle
@@ -19,7 +19,8 @@ buildscript {
       'moshi': '1.8.0',
       'okio': '2.2.2',
       'ktlint': '0.31.0',
-      'picocli': '4.0.1'
+      'picocli': '4.0.1',
+      'openjsse': '1.1.0'
   ]
 
   ext.deps = [
@@ -37,7 +38,8 @@ buildscript {
       'junit': "junit:junit:${versions.junit}",
       'kotlinStdlib': "org.jetbrains.kotlin:kotlin-stdlib:${versions.kotlin}",
       'moshi': "com.squareup.moshi:moshi:${versions.moshi}",
-      'okio': "com.squareup.okio:okio:${versions.okio}"
+      'okio': "com.squareup.okio:okio:${versions.okio}",
+      'openjsse': "org.openjsse:openjsse:${versions.openjsse}"
   ]
 
   dependencies {
diff --git a/okhttp/src/test/java/okhttp3/RecordingEventListener.java b/okhttp-testing-support/src/main/java/okhttp3/RecordingEventListener.java
similarity index 99%
rename from okhttp/src/test/java/okhttp3/RecordingEventListener.java
rename to okhttp-testing-support/src/main/java/okhttp3/RecordingEventListener.java
index dd2b5d68c9..8bd4f86f57 100644
--- a/okhttp/src/test/java/okhttp3/RecordingEventListener.java
+++ b/okhttp-testing-support/src/main/java/okhttp3/RecordingEventListener.java
@@ -27,6 +27,7 @@
 
 import static java.util.Arrays.asList;
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertTrue;
 
 public class RecordingEventListener extends EventListener {
   final Deque<CallEvent> eventSequence = new ConcurrentLinkedDeque<>();
@@ -75,7 +76,7 @@ private void logEvent(CallEvent e) {
     CallEvent startEvent = e.closes();
 
     if (startEvent != null) {
-      assertThat(eventSequence).contains(startEvent);
+      assertTrue(eventSequence.contains(startEvent));
     }
 
     eventSequence.offer(e);
diff --git a/okhttp/build.gradle b/okhttp/build.gradle
index a03f3d8ec3..1e8a450258 100644
--- a/okhttp/build.gradle
+++ b/okhttp/build.gradle
@@ -38,6 +38,7 @@ dependencies {
   testImplementation deps.conscrypt
   testImplementation deps.junit
   testImplementation deps.assertj
+  testImplementation deps.openjsse
   testCompileOnly deps.jsr305
 }
 
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.kt b/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.kt
index b47772f4a6..d992b69d6c 100644
--- a/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.kt
+++ b/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.kt
@@ -15,9 +15,14 @@
  */
 package okhttp3.internal.platform
 
+import android.annotation.SuppressLint
 import android.os.Build
-import android.util.Log
 import okhttp3.Protocol
+import okhttp3.internal.platform.android.CloseGuard
+import okhttp3.internal.platform.android.ConscryptSocketAdapter
+import okhttp3.internal.platform.android.DeferredSocketAdapter
+import okhttp3.internal.platform.android.StandardAndroidSocketAdapter
+import okhttp3.internal.platform.android.androidLog
 import okhttp3.internal.tls.BasicTrustRootIndex
 import okhttp3.internal.tls.CertificateChainCleaner
 import okhttp3.internal.tls.TrustRootIndex
@@ -26,7 +31,6 @@ import java.lang.reflect.InvocationTargetException
 import java.lang.reflect.Method
 import java.net.InetSocketAddress
 import java.net.Socket
-import java.nio.charset.StandardCharsets.UTF_8
 import java.security.cert.Certificate
 import java.security.cert.TrustAnchor
 import java.security.cert.X509Certificate
@@ -36,14 +40,13 @@ import javax.net.ssl.SSLSocketFactory
 import javax.net.ssl.X509TrustManager
 
 /** Android 5+. */
-class AndroidPlatform(
-  private val sslParametersClass: Class<*>,
-  private val sslSocketClass: Class<*>,
-  private val setUseSessionTickets: Method,
-  private val setHostname: Method,
-  private val getAlpnSelectedProtocol: Method,
-  private val setAlpnProtocols: Method
-) : Platform() {
+class AndroidPlatform : Platform() {
+  private val socketAdapters = listOfNotNull(
+      StandardAndroidSocketAdapter.buildIfSupported(),
+      ConscryptSocketAdapter.buildIfSupported(),
+      DeferredSocketAdapter("com.google.android.gms.org.conscrypt")
+  ).filter { it.isSupported() }
+
   private val closeGuard = CloseGuard.get()
 
   @Throws(IOException::class)
@@ -65,87 +68,26 @@ class AndroidPlatform(
     }
   }
 
-  override fun trustManager(sslSocketFactory: SSLSocketFactory): X509TrustManager? {
-    var context: Any? =
-        readFieldOrNull(sslSocketFactory, sslParametersClass, "sslParameters")
-    if (context == null) {
-      // If that didn't work, try the Google Play Services SSL provider before giving up. This
-      // must be loaded by the SSLSocketFactory's class loader.
-      try {
-        val gmsSslParametersClass = Class.forName(
-            "com.google.android.gms.org.conscrypt.SSLParametersImpl", false,
-            sslSocketFactory.javaClass.classLoader)
-        context = readFieldOrNull(sslSocketFactory, gmsSslParametersClass,
-            "sslParameters")
-      } catch (e: ClassNotFoundException) {
-        return super.trustManager(sslSocketFactory)
-      }
-    }
-
-    val x509TrustManager = readFieldOrNull(
-        context!!, X509TrustManager::class.java, "x509TrustManager")
-    return x509TrustManager ?: readFieldOrNull(context, X509TrustManager::class.java,
-        "trustManager")
-  }
+  override fun trustManager(sslSocketFactory: SSLSocketFactory): X509TrustManager? =
+      socketAdapters.find { it.matchesSocketFactory(sslSocketFactory) }
+          ?.trustManager(sslSocketFactory)
 
   override fun configureTlsExtensions(
     sslSocket: SSLSocket,
     hostname: String?,
     protocols: List<Protocol>
   ) {
-    if (!sslSocketClass.isInstance(sslSocket)) {
-      return // No TLS extensions if the socket class is custom.
-    }
-    try {
-      // Enable SNI and session tickets.
-      if (hostname != null) {
-        setUseSessionTickets.invoke(sslSocket, true)
-        // This is SSLParameters.setServerNames() in API 24+.
-        setHostname.invoke(sslSocket, hostname)
-      }
-
-      // Enable ALPN.
-      setAlpnProtocols.invoke(sslSocket, concatLengthPrefixed(protocols))
-    } catch (e: IllegalAccessException) {
-      throw AssertionError(e)
-    } catch (e: InvocationTargetException) {
-      throw AssertionError(e)
-    }
+    // No TLS extensions if the socket class is custom.
+    socketAdapters.find { it.matchesSocket(sslSocket) }
+        ?.configureTlsExtensions(sslSocket, hostname, protocols)
   }
 
-  override fun getSelectedProtocol(socket: SSLSocket): String? {
-    return if (sslSocketClass.isInstance(socket))
-      try {
-        val alpnResult = getAlpnSelectedProtocol.invoke(socket) as ByteArray?
-        if (alpnResult != null) String(alpnResult, UTF_8) else null
-      } catch (e: IllegalAccessException) {
-        throw AssertionError(e)
-      } catch (e: InvocationTargetException) {
-        throw AssertionError(e)
-      }
-    else {
-      null // No TLS extensions if the socket class is custom.
-    }
-  }
+  override fun getSelectedProtocol(sslSocket: SSLSocket) =
+      // No TLS extensions if the socket class is custom.
+      socketAdapters.find { it.matchesSocket(sslSocket) }?.getSelectedProtocol(sslSocket)
 
   override fun log(level: Int, message: String, t: Throwable?) {
-    var logMessage = message
-    val logLevel = if (level == WARN) Log.WARN else Log.DEBUG
-    if (t != null) logMessage = logMessage + '\n'.toString() + Log.getStackTraceString(t)
-
-    // Split by line, then ensure each line can fit into Log's maximum length.
-    var i = 0
-    val length = logMessage.length
-    while (i < length) {
-      var newline = logMessage.indexOf('\n', i)
-      newline = if (newline != -1) newline else length
-      do {
-        val end = minOf(newline, i + MAX_LOG_LENGTH)
-        Log.println(logLevel, "OkHttp", logMessage.substring(i, end))
-        i = end
-      } while (i < newline)
-      i++
-    }
+    androidLog(level, message, t)
   }
 
   override fun getStackTraceForCloseable(closer: String): Any? = closeGuard.createAndOpen(closer)
@@ -164,9 +106,9 @@ class AndroidPlatform(
       val getInstanceMethod = networkPolicyClass.getMethod("getInstance")
       val networkSecurityPolicy = getInstanceMethod.invoke(null)
       api24IsCleartextTrafficPermitted(hostname, networkPolicyClass, networkSecurityPolicy)
-    } catch (e: ClassNotFoundException) {
+    } catch (_: ClassNotFoundException) {
       super.isCleartextTrafficPermitted(hostname)
-    } catch (e: NoSuchMethodException) {
+    } catch (_: NoSuchMethodException) {
       super.isCleartextTrafficPermitted(hostname)
     } catch (e: IllegalAccessException) {
       throw AssertionError("unable to determine cleartext support", e)
@@ -186,7 +128,7 @@ class AndroidPlatform(
     val isCleartextTrafficPermittedMethod = networkPolicyClass
         .getMethod("isCleartextTrafficPermitted", String::class.java)
     isCleartextTrafficPermittedMethod.invoke(networkSecurityPolicy, hostname) as Boolean
-  } catch (e: NoSuchMethodException) {
+  } catch (_: NoSuchMethodException) {
     api23IsCleartextTrafficPermitted(hostname, networkPolicyClass, networkSecurityPolicy)
   }
 
@@ -199,7 +141,7 @@ class AndroidPlatform(
     val isCleartextTrafficPermittedMethod = networkPolicyClass
         .getMethod("isCleartextTrafficPermitted")
     isCleartextTrafficPermittedMethod.invoke(networkSecurityPolicy) as Boolean
-  } catch (e: NoSuchMethodException) {
+  } catch (_: NoSuchMethodException) {
     super.isCleartextTrafficPermitted(hostname)
   }
 
@@ -212,7 +154,7 @@ class AndroidPlatform(
             "checkServerTrusted", Array<X509Certificate>::class.java, String::class.java,
             String::class.java)
         AndroidCertificateChainCleaner(extensions, checkServerTrusted)
-      } catch (e: Exception) {
+      } catch (_: Exception) {
         super.buildCertificateChainCleaner(trustManager)
       }
 
@@ -258,67 +200,9 @@ class AndroidPlatform(
     override fun hashCode(): Int = 0
   }
 
-  /**
-   * Provides access to the internal dalvik.system.CloseGuard class. Android uses this in
-   * combination with android.os.StrictMode to report on leaked java.io.Closeable's. Available since
-   * Android API 11.
-   */
-  internal class CloseGuard(
-    private val getMethod: Method?,
-    private val openMethod: Method?,
-    private val warnIfOpenMethod: Method?
-  ) {
-
-    fun createAndOpen(closer: String): Any? {
-      if (getMethod != null) {
-        try {
-          val closeGuardInstance = getMethod.invoke(null)
-          openMethod!!.invoke(closeGuardInstance, closer)
-          return closeGuardInstance
-        } catch (_: Exception) {
-        }
-      }
-      return null
-    }
-
-    fun warnIfOpen(closeGuardInstance: Any?): Boolean {
-      var reported = false
-      if (closeGuardInstance != null) {
-        try {
-          warnIfOpenMethod!!.invoke(closeGuardInstance)
-          reported = true
-        } catch (_: Exception) {
-        }
-      }
-      return reported
-    }
-
-    companion object {
-      fun get(): CloseGuard {
-        var getMethod: Method?
-        var openMethod: Method?
-        var warnIfOpenMethod: Method?
-
-        try {
-          val closeGuardClass = Class.forName("dalvik.system.CloseGuard")
-          getMethod = closeGuardClass.getMethod("get")
-          openMethod = closeGuardClass.getMethod("open", String::class.java)
-          warnIfOpenMethod = closeGuardClass.getMethod("warnIfOpen")
-        } catch (_: Exception) {
-          getMethod = null
-          openMethod = null
-          warnIfOpenMethod = null
-        }
-
-        return CloseGuard(getMethod, openMethod, warnIfOpenMethod)
-      }
-    }
-  }
-
   /**
    * A trust manager for Android applications that customize the trust manager.
    *
-   *
    * This class exploits knowledge of Android implementation details. This class is potentially
    * much faster to initialize than [BasicTrustRootIndex] because it doesn't need to load and
    * index trusted CA certificates.
@@ -327,7 +211,6 @@ class AndroidPlatform(
     private val trustManager: X509TrustManager,
     private val findByIssuerAndSignatureMethod: Method
   ) : TrustRootIndex {
-
     override fun findByIssuerAndSignature(cert: X509Certificate): X509Certificate? {
       return try {
         val trustAnchor = findByIssuerAndSignatureMethod.invoke(
@@ -335,39 +218,26 @@ class AndroidPlatform(
         trustAnchor.trustedCert
       } catch (e: IllegalAccessException) {
         throw AssertionError("unable to get issues and signature", e)
-      } catch (e: InvocationTargetException) {
+      } catch (_: InvocationTargetException) {
         null
       }
     }
   }
 
   companion object {
-    private const val MAX_LOG_LENGTH = 4000
+    @SuppressLint("PrivateApi")
+    val isSupported: Boolean = try {
+      // Trigger an early exception over a fatal error, prefer a RuntimeException over Error.
+      Class.forName("com.android.org.conscrypt.OpenSSLSocketImpl")
 
-    fun buildIfSupported(): Platform? {
-      // Attempt to find Android 5+ APIs.
-      val sslParametersClass: Class<*>
-      val sslSocketClass: Class<*>
-      try {
-        sslParametersClass = Class.forName("com.android.org.conscrypt.SSLParametersImpl")
-        sslSocketClass = Class.forName("com.android.org.conscrypt.OpenSSLSocketImpl")
-      } catch (_: ClassNotFoundException) {
-        return null // Not an Android runtime.
-      }
+      // Fail Fast
+      check(Build.VERSION.SDK_INT >= 21) { "Expected Android API level 21+ but was ${Build.VERSION.SDK_INT}" }
 
-      if (Build.VERSION.SDK_INT >= 21) {
-        try {
-          val setUseSessionTickets = sslSocketClass.getDeclaredMethod(
-              "setUseSessionTickets", Boolean::class.javaPrimitiveType)
-          val setHostname = sslSocketClass.getMethod("setHostname", String::class.java)
-          val getAlpnSelectedProtocol = sslSocketClass.getMethod("getAlpnSelectedProtocol")
-          val setAlpnProtocols = sslSocketClass.getMethod("setAlpnProtocols", ByteArray::class.java)
-          return AndroidPlatform(sslParametersClass, sslSocketClass, setUseSessionTickets,
-              setHostname, getAlpnSelectedProtocol, setAlpnProtocols)
-        } catch (_: NoSuchMethodException) {
-        }
-      }
-      throw IllegalStateException("Expected Android API level 21+ but was ${Build.VERSION.SDK_INT}")
+      true
+    } catch (_: ClassNotFoundException) {
+      false
     }
+
+    fun buildIfSupported(): Platform? = if (isSupported) AndroidPlatform() else null
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/ConscryptPlatform.kt b/okhttp/src/main/java/okhttp3/internal/platform/ConscryptPlatform.kt
index 882653c6fc..22670dee6e 100644
--- a/okhttp/src/main/java/okhttp3/internal/platform/ConscryptPlatform.kt
+++ b/okhttp/src/main/java/okhttp3/internal/platform/ConscryptPlatform.kt
@@ -85,11 +85,11 @@ class ConscryptPlatform private constructor() : Platform() {
     }
   }
 
-  override fun getSelectedProtocol(socket: SSLSocket): String? =
-      if (Conscrypt.isConscrypt(socket)) {
-        Conscrypt.getApplicationProtocol(socket)
+  override fun getSelectedProtocol(sslSocket: SSLSocket): String? =
+      if (Conscrypt.isConscrypt(sslSocket)) {
+        Conscrypt.getApplicationProtocol(sslSocket)
       } else {
-        super.getSelectedProtocol(socket)
+        super.getSelectedProtocol(sslSocket)
       }
 
   override fun configureSslSocketFactory(socketFactory: SSLSocketFactory) {
@@ -106,18 +106,20 @@ class ConscryptPlatform private constructor() : Platform() {
   }
 
   companion object {
-    fun buildIfSupported(): ConscryptPlatform? = try {
+    val isSupported: Boolean = try {
       // Trigger an early exception over a fatal error, prefer a RuntimeException over Error.
       Class.forName("org.conscrypt.Conscrypt\$Version")
 
       when {
-        Conscrypt.isAvailable() && atLeastVersion(2, 1, 0) -> ConscryptPlatform()
-        else -> null
+        Conscrypt.isAvailable() && atLeastVersion(2, 1, 0) -> true
+        else -> false
       }
     } catch (e: ClassNotFoundException) {
-      null
+      false
     }
 
+    fun buildIfSupported(): ConscryptPlatform? = if (isSupported) ConscryptPlatform() else null
+
     fun atLeastVersion(major: Int, minor: Int = 0, patch: Int = 0): Boolean {
       val conscryptVersion = Conscrypt.version()
 
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/Platform.kt b/okhttp/src/main/java/okhttp3/internal/platform/Platform.kt
index bd86cdaf6c..fda0ed0102 100644
--- a/okhttp/src/main/java/okhttp3/internal/platform/Platform.kt
+++ b/okhttp/src/main/java/okhttp3/internal/platform/Platform.kt
@@ -119,7 +119,7 @@ open class Platform {
   }
 
   /** Returns the negotiated protocol, or null if no protocol was negotiated. */
-  open fun getSelectedProtocol(socket: SSLSocket): String? = null
+  open fun getSelectedProtocol(sslSocket: SSLSocket): String? = null
 
   @Throws(IOException::class)
   open fun connectSocket(socket: Socket, address: InetSocketAddress, connectTimeout: Int) {
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/android/AndroidSocketAdapter.kt b/okhttp/src/main/java/okhttp3/internal/platform/android/AndroidSocketAdapter.kt
new file mode 100644
index 0000000000..4ac9e4c0cf
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/platform/android/AndroidSocketAdapter.kt
@@ -0,0 +1,103 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.platform.android
+
+import okhttp3.Protocol
+import okhttp3.internal.platform.AndroidPlatform
+import okhttp3.internal.platform.Platform
+import java.lang.reflect.InvocationTargetException
+import java.lang.reflect.Method
+import java.nio.charset.StandardCharsets
+import javax.net.ssl.SSLSocket
+import javax.net.ssl.SSLSocketFactory
+import javax.net.ssl.X509TrustManager
+
+/**
+ * Modern reflection based SocketAdapter for Conscrypt class SSLSockets.
+ */
+open class AndroidSocketAdapter(private val sslSocketClass: Class<in SSLSocket>) :
+    SocketAdapter {
+  private val setUseSessionTickets: Method =
+      sslSocketClass.getDeclaredMethod("setUseSessionTickets", Boolean::class.javaPrimitiveType)
+  private val setHostname = sslSocketClass.getMethod("setHostname", String::class.java)
+  private val getAlpnSelectedProtocol = sslSocketClass.getMethod("getAlpnSelectedProtocol")
+  private val setAlpnProtocols =
+      sslSocketClass.getMethod("setAlpnProtocols", ByteArray::class.java)
+
+  override fun isSupported(): Boolean = AndroidPlatform.isSupported
+
+  override fun trustManager(sslSocketFactory: SSLSocketFactory): X509TrustManager? = null
+
+  override fun matchesSocket(sslSocket: SSLSocket): Boolean = sslSocketClass.isInstance(sslSocket)
+
+  override fun matchesSocketFactory(sslSocketFactory: SSLSocketFactory): Boolean = false
+
+  override fun configureTlsExtensions(
+    sslSocket: SSLSocket,
+    hostname: String?,
+    protocols: List<Protocol>
+  ) {
+    // No TLS extensions if the socket class is custom.
+    if (matchesSocket(sslSocket)) {
+      try {
+        // Enable SNI and session tickets.
+        if (hostname != null) {
+          setUseSessionTickets.invoke(sslSocket, true)
+          // This is SSLParameters.setServerNames() in API 24+.
+          setHostname.invoke(sslSocket, hostname)
+        }
+
+        // Enable ALPN.
+        setAlpnProtocols.invoke(sslSocket,
+            Platform.concatLengthPrefixed(protocols))
+      } catch (e: IllegalAccessException) {
+        throw AssertionError(e)
+      } catch (e: InvocationTargetException) {
+        throw AssertionError(e)
+      }
+    }
+  }
+
+  override fun getSelectedProtocol(sslSocket: SSLSocket): String? {
+    // No TLS extensions if the socket class is custom.
+    if (!matchesSocket(sslSocket)) {
+      return null
+    }
+
+    return try {
+      val alpnResult = getAlpnSelectedProtocol.invoke(sslSocket) as ByteArray?
+      if (alpnResult != null) String(alpnResult, StandardCharsets.UTF_8) else null
+    } catch (e: IllegalAccessException) {
+      throw AssertionError(e)
+    } catch (e: InvocationTargetException) {
+      throw AssertionError(e)
+    }
+  }
+
+  companion object {
+    fun buildIfSupported(packageName: String): SocketAdapter? {
+      return try {
+        @Suppress("UNCHECKED_CAST")
+        val sslSocketClass = Class.forName("$packageName.OpenSSLSocketImpl") as Class<in SSLSocket>
+
+        AndroidSocketAdapter(sslSocketClass)
+      } catch (e: Exception) {
+        androidLog(Platform.WARN, "unable to load android socket classes", e)
+        null
+      }
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/android/CloseGuard.kt b/okhttp/src/main/java/okhttp3/internal/platform/android/CloseGuard.kt
new file mode 100644
index 0000000000..b3930aafd7
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/platform/android/CloseGuard.kt
@@ -0,0 +1,75 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.platform.android
+
+import java.lang.reflect.Method
+
+/**
+ * Provides access to the internal dalvik.system.CloseGuard class. Android uses this in
+ * combination with android.os.StrictMode to report on leaked java.io.Closeable's. Available since
+ * Android API 11.
+ */
+internal class CloseGuard(
+  private val getMethod: Method?,
+  private val openMethod: Method?,
+  private val warnIfOpenMethod: Method?
+) {
+
+  fun createAndOpen(closer: String): Any? {
+    if (getMethod != null) {
+      try {
+        val closeGuardInstance = getMethod.invoke(null)
+        openMethod!!.invoke(closeGuardInstance, closer)
+        return closeGuardInstance
+      } catch (_: Exception) {
+      }
+    }
+    return null
+  }
+
+  fun warnIfOpen(closeGuardInstance: Any?): Boolean {
+    var reported = false
+    if (closeGuardInstance != null) {
+      try {
+        warnIfOpenMethod!!.invoke(closeGuardInstance)
+        reported = true
+      } catch (_: Exception) {
+      }
+    }
+    return reported
+  }
+
+  companion object {
+    fun get(): CloseGuard {
+      var getMethod: Method?
+      var openMethod: Method?
+      var warnIfOpenMethod: Method?
+
+      try {
+        val closeGuardClass = Class.forName("dalvik.system.CloseGuard")
+        getMethod = closeGuardClass.getMethod("get")
+        openMethod = closeGuardClass.getMethod("open", String::class.java)
+        warnIfOpenMethod = closeGuardClass.getMethod("warnIfOpen")
+      } catch (_: Exception) {
+        getMethod = null
+        openMethod = null
+        warnIfOpenMethod = null
+      }
+
+      return CloseGuard(getMethod, openMethod, warnIfOpenMethod)
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/android/ConscryptSocketAdapter.kt b/okhttp/src/main/java/okhttp3/internal/platform/android/ConscryptSocketAdapter.kt
new file mode 100644
index 0000000000..11f574b544
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/platform/android/ConscryptSocketAdapter.kt
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.platform.android
+
+import okhttp3.Protocol
+import okhttp3.internal.platform.ConscryptPlatform
+import okhttp3.internal.platform.Platform
+import org.conscrypt.Conscrypt
+import javax.net.ssl.SSLSocket
+import javax.net.ssl.SSLSocketFactory
+import javax.net.ssl.X509TrustManager
+
+/**
+ * Simple non-reflection SocketAdapter for Conscrypt.
+ */
+object ConscryptSocketAdapter : SocketAdapter {
+  override fun trustManager(sslSocketFactory: SSLSocketFactory): X509TrustManager? = null
+
+  override fun matchesSocketFactory(sslSocketFactory: SSLSocketFactory): Boolean = false
+
+  override fun matchesSocket(sslSocket: SSLSocket): Boolean = Conscrypt.isConscrypt(sslSocket)
+
+  override fun isSupported(): Boolean = ConscryptPlatform.isSupported
+
+  override fun getSelectedProtocol(sslSocket: SSLSocket): String? =
+      when {
+        matchesSocket(sslSocket) -> Conscrypt.getApplicationProtocol(sslSocket)
+        else -> null // No TLS extensions if the socket class is custom.
+      }
+
+  override fun configureTlsExtensions(
+    sslSocket: SSLSocket,
+    hostname: String?,
+    protocols: List<Protocol>
+  ) {
+    // No TLS extensions if the socket class is custom.
+    if (matchesSocket(sslSocket)) {
+      // Enable SNI and session tickets.
+      if (hostname != null) {
+        Conscrypt.setUseSessionTickets(sslSocket, true)
+        Conscrypt.setHostname(sslSocket, hostname)
+      }
+
+      // Enable ALPN.
+      val names = Platform.alpnProtocolNames(protocols)
+      Conscrypt.setApplicationProtocols(sslSocket, names.toTypedArray())
+    }
+  }
+
+  fun buildIfSupported(): SocketAdapter? =
+      if (ConscryptPlatform.isSupported) ConscryptSocketAdapter else null
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/android/DeferredSocketAdapter.kt b/okhttp/src/main/java/okhttp3/internal/platform/android/DeferredSocketAdapter.kt
new file mode 100644
index 0000000000..87d1277f2e
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/platform/android/DeferredSocketAdapter.kt
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.platform.android
+
+import okhttp3.Protocol
+import okhttp3.internal.platform.Platform
+import javax.net.ssl.SSLSocket
+import javax.net.ssl.SSLSocketFactory
+import javax.net.ssl.X509TrustManager
+
+/**
+ * Deferred implementation of SocketAdapter that can only work by observing the socket
+ * and initializing on first use.
+ */
+class DeferredSocketAdapter(private val socketPackage: String) : SocketAdapter {
+  private var initialized = false
+  private var delegate: SocketAdapter? = null
+
+  override fun isSupported(): Boolean {
+    return true
+  }
+
+  override fun matchesSocket(sslSocket: SSLSocket): Boolean {
+    return sslSocket.javaClass.name.startsWith(socketPackage)
+  }
+
+  override fun configureTlsExtensions(
+    sslSocket: SSLSocket,
+    hostname: String?,
+    protocols: List<Protocol>
+  ) {
+    getDelegate(sslSocket)?.configureTlsExtensions(sslSocket, hostname, protocols)
+  }
+
+  override fun getSelectedProtocol(sslSocket: SSLSocket): String? {
+    return getDelegate(sslSocket)?.getSelectedProtocol(sslSocket)
+  }
+
+  @Synchronized private fun getDelegate(actualSSLSocketClass: SSLSocket): SocketAdapter? {
+    if (!initialized) {
+      try {
+        var possibleClass: Class<in SSLSocket> = actualSSLSocketClass.javaClass
+        while (possibleClass.name != "$socketPackage.OpenSSLSocketImpl") {
+          possibleClass = possibleClass.superclass
+
+          if (possibleClass == null) {
+            throw AssertionError(
+                "No OpenSSLSocketImpl superclass of socket of type $actualSSLSocketClass")
+          }
+        }
+
+        delegate = AndroidSocketAdapter(possibleClass)
+      } catch (e: Exception) {
+        Platform.get()
+            .log(Platform.WARN, "Failed to initialize DeferredSocketAdapter $socketPackage", e)
+      }
+
+      initialized = true
+    }
+
+    return delegate
+  }
+
+  override fun trustManager(sslSocketFactory: SSLSocketFactory): X509TrustManager? {
+    // not supported with modern Android and opt-in Gms Provider
+    return null
+  }
+
+  override fun matchesSocketFactory(sslSocketFactory: SSLSocketFactory): Boolean {
+    return false
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/android/SocketAdapter.kt b/okhttp/src/main/java/okhttp3/internal/platform/android/SocketAdapter.kt
new file mode 100644
index 0000000000..5555f1c695
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/platform/android/SocketAdapter.kt
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.platform.android
+
+import okhttp3.Protocol
+import javax.net.ssl.SSLSocket
+import javax.net.ssl.SSLSocketFactory
+import javax.net.ssl.X509TrustManager
+
+interface SocketAdapter {
+  open fun isSupported(): Boolean
+  fun trustManager(sslSocketFactory: SSLSocketFactory): X509TrustManager?
+  fun matchesSocket(sslSocket: SSLSocket): Boolean
+  fun matchesSocketFactory(sslSocketFactory: SSLSocketFactory): Boolean
+
+  open fun configureTlsExtensions(
+    sslSocket: SSLSocket,
+    hostname: String?,
+    protocols: List<Protocol>
+  )
+
+  open fun getSelectedProtocol(sslSocket: SSLSocket): String?
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/android/StandardAndroidSocketAdapter.kt b/okhttp/src/main/java/okhttp3/internal/platform/android/StandardAndroidSocketAdapter.kt
new file mode 100644
index 0000000000..bb66604ff4
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/platform/android/StandardAndroidSocketAdapter.kt
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.platform.android
+
+import okhttp3.internal.platform.Platform
+import javax.net.ssl.SSLSocket
+import javax.net.ssl.SSLSocketFactory
+import javax.net.ssl.X509TrustManager
+
+/**
+ * Base Android reflection based SocketAdapter for the built in Android SSLSocket.
+ */
+class StandardAndroidSocketAdapter(
+  sslSocketClass: Class<in SSLSocket>,
+  private val sslSocketFactoryClass: Class<in SSLSocketFactory>,
+  private val paramClass: Class<*>
+) : AndroidSocketAdapter(
+    sslSocketClass) {
+
+  override fun matchesSocketFactory(sslSocketFactory: SSLSocketFactory): Boolean =
+      sslSocketFactoryClass.isInstance(sslSocketFactory)
+
+  override fun trustManager(sslSocketFactory: SSLSocketFactory): X509TrustManager? {
+    val context: Any? =
+        Platform.readFieldOrNull(sslSocketFactory, paramClass,
+            "sslParameters")
+    val x509TrustManager = Platform.readFieldOrNull(
+        context!!, X509TrustManager::class.java, "x509TrustManager")
+    return x509TrustManager ?: Platform.readFieldOrNull(context,
+        X509TrustManager::class.java,
+        "trustManager")
+  }
+
+  companion object {
+    @Suppress("UNCHECKED_CAST")
+    fun buildIfSupported(packageName: String = "com.android.org.conscrypt"): SocketAdapter? {
+      return try {
+        val sslSocketClass = Class.forName("$packageName.OpenSSLSocketImpl") as Class<in SSLSocket>
+        val sslSocketFactoryClass =
+            Class.forName("$packageName.OpenSSLSocketFactoryImpl") as Class<in SSLSocketFactory>
+        val paramsClass = Class.forName("$packageName.SSLParametersImpl")
+
+        StandardAndroidSocketAdapter(sslSocketClass, sslSocketFactoryClass, paramsClass)
+      } catch (e: Exception) {
+        androidLog(Platform.WARN, "unable to load android socket classes", e)
+        null
+      }
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/android/util.kt b/okhttp/src/main/java/okhttp3/internal/platform/android/util.kt
new file mode 100644
index 0000000000..4a3bf12e42
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/platform/android/util.kt
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.platform.android
+
+import android.util.Log
+import okhttp3.internal.platform.Platform
+
+private const val MAX_LOG_LENGTH = 4000
+
+internal fun androidLog(level: Int, message: String, t: Throwable?) {
+  var logMessage = message
+  val logLevel = if (level == Platform.WARN) Log.WARN else Log.DEBUG
+  if (t != null) logMessage = logMessage + '\n'.toString() + Log.getStackTraceString(t)
+
+  // Split by line, then ensure each line can fit into Log's maximum length.
+  var i = 0
+  val length = logMessage.length
+  while (i < length) {
+    var newline = logMessage.indexOf('\n', i)
+    newline = if (newline != -1) newline else length
+    do {
+      val end = minOf(newline, i + MAX_LOG_LENGTH)
+      Log.println(logLevel, "OkHttp", logMessage.substring(i, end))
+      i = end
+    } while (i < newline)
+    i++
+  }
+}
\ No newline at end of file
diff --git a/okhttp/src/test/java/okhttp3/OpenJSSETest.kt b/okhttp/src/test/java/okhttp3/OpenJSSETest.kt
new file mode 100644
index 0000000000..7b1943c3f8
--- /dev/null
+++ b/okhttp/src/test/java/okhttp3/OpenJSSETest.kt
@@ -0,0 +1,102 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import okhttp3.Protocol.HTTP_2
+import okhttp3.mockwebserver.MockResponse
+import okhttp3.mockwebserver.MockWebServer
+import okhttp3.testing.PlatformRule
+import okhttp3.tls.HandshakeCertificates
+import okhttp3.tls.HeldCertificate
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.After
+import org.junit.Assert.assertEquals
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+import org.openjsse.net.ssl.OpenJSSE
+import org.openjsse.sun.security.ssl.SSLSocketFactoryImpl
+import org.openjsse.sun.security.ssl.SSLSocketImpl
+import java.net.InetAddress
+import java.security.Security
+
+class OpenJSSETest {
+  @JvmField @Rule var platform = PlatformRule()
+  @JvmField @Rule val clientTestRule = OkHttpClientTestRule()
+  @JvmField @Rule val server = MockWebServer()
+  lateinit var client: OkHttpClient
+
+  @Before
+  fun setUp() {
+    platform.assumeJdk8()
+
+    Security.insertProviderAt(OpenJSSE(), 1)
+    client = clientTestRule.newClient()
+  }
+
+  @After
+  fun cleanup() {
+    Security.removeProvider("OpenJSSE")
+  }
+
+  @Test
+  fun testTlsv13Works() {
+    enableTls()
+
+    server.enqueue(MockResponse().setBody("abc"))
+
+    val request = Request.Builder().url(server.url("/")).build()
+
+    val response = client.newCall(request).execute()
+
+    response.use {
+      assertEquals(200, response.code)
+      assertEquals(TlsVersion.TLS_1_3, response.handshake?.tlsVersion)
+      assertEquals(Protocol.HTTP_1_1, response.protocol)
+
+      assertThat(response.exchange?.connection()?.socket()).isInstanceOf(SSLSocketImpl::class.java)
+    }
+  }
+
+  @Test
+  fun testSupportedProtocols() {
+    val factory = SSLSocketFactoryImpl()
+    val s = factory.createSocket() as SSLSocketImpl
+
+    // A Public API available is available to use in a custom Platform
+    s.setHandshakeApplicationProtocolSelector { _, _ -> HTTP_2.toString() }
+    assertEquals(listOf("TLSv1.3", "TLSv1.2", "TLSv1.1", "TLSv1"), s.enabledProtocols.toList())
+  }
+
+  private fun enableTls() {
+    // Generate a self-signed cert for the server to serve and the client to trust.
+    // can't use localhost with a non OpenJSSE trust manager
+    val heldCertificate = HeldCertificate.Builder()
+        .commonName("localhost")
+        .addSubjectAlternativeName(InetAddress.getByName("localhost").canonicalHostName)
+        .build()
+    val handshakeCertificates = HandshakeCertificates.Builder()
+        .heldCertificate(heldCertificate)
+        .addTrustedCertificate(heldCertificate.certificate)
+        .build()
+
+    client = client.newBuilder()
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager)
+        .build()
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false)
+  }
+}
\ No newline at end of file
diff --git a/okhttp/src/test/java/okhttp3/internal/platform/android/AndroidSocketAdapterTest.kt b/okhttp/src/test/java/okhttp3/internal/platform/android/AndroidSocketAdapterTest.kt
new file mode 100644
index 0000000000..d9d6017336
--- /dev/null
+++ b/okhttp/src/test/java/okhttp3/internal/platform/android/AndroidSocketAdapterTest.kt
@@ -0,0 +1,100 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.platform.android
+
+import okhttp3.DelegatingSSLSocket
+import okhttp3.DelegatingSSLSocketFactory
+import okhttp3.Protocol.HTTP_1_1
+import okhttp3.Protocol.HTTP_2
+import org.conscrypt.Conscrypt
+import org.junit.Assert.assertFalse
+import org.junit.Assert.assertNotNull
+import org.junit.Assert.assertNull
+import org.junit.Assert.assertTrue
+import org.junit.Assume.assumeFalse
+import org.junit.Assume.assumeTrue
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.junit.runners.Parameterized
+import java.security.Provider
+import javax.net.ssl.SSLContext
+import javax.net.ssl.SSLSocket
+
+@RunWith(Parameterized::class)
+class AndroidSocketAdapterTest(private val adapter: SocketAdapter) {
+  private val provider: Provider = Conscrypt.newProviderBuilder().provideTrustManager(true).build()
+  val context: SSLContext = SSLContext.getInstance("TLS", provider)
+
+  init {
+    context.init(null, null, null)
+  }
+
+  @Test
+  fun testMatchesSupportedSocket() {
+    val socketFactory = context.socketFactory
+
+    val sslSocket = socketFactory.createSocket() as SSLSocket
+    assertTrue(adapter.matchesSocket(sslSocket))
+
+    adapter.configureTlsExtensions(sslSocket, "example.com", listOf(HTTP_2, HTTP_1_1))
+    // not connected
+    assertNull(adapter.getSelectedProtocol(sslSocket))
+  }
+
+  @Test
+  fun testMatchesSupportedAndroidSocketFactory() {
+    assumeTrue(adapter is StandardAndroidSocketAdapter)
+
+    assertTrue(adapter.matchesSocketFactory(context.socketFactory))
+    assertNotNull(adapter.trustManager(context.socketFactory))
+  }
+
+  @Test
+  fun testDoesntMatchSupportedCustomSocketFactory() {
+    assumeFalse(adapter is StandardAndroidSocketAdapter)
+
+    assertFalse(adapter.matchesSocketFactory(context.socketFactory))
+    assertNull(adapter.trustManager(context.socketFactory))
+  }
+
+  @Test
+  fun testCustomSocket() {
+    val socketFactory = DelegatingSSLSocketFactory(context.socketFactory)
+
+    assertFalse(adapter.matchesSocketFactory(socketFactory))
+
+    val sslSocket =
+        object : DelegatingSSLSocket(context.socketFactory.createSocket() as SSLSocket) {}
+    assertFalse(adapter.matchesSocket(sslSocket))
+
+    adapter.configureTlsExtensions(sslSocket, "example.com", listOf(HTTP_2, HTTP_1_1))
+    // not connected
+    assertNull(adapter.getSelectedProtocol(sslSocket))
+  }
+
+  companion object {
+    @JvmStatic
+    @Parameterized.Parameters(name = "{0}")
+    fun data(): Collection<SocketAdapter> {
+      return listOf(
+          ConscryptSocketAdapter,
+          DeferredSocketAdapter("org.conscrypt"),
+          AndroidSocketAdapter.buildIfSupported("org.conscrypt")!!,
+          StandardAndroidSocketAdapter.buildIfSupported("org.conscrypt")!!
+      )
+    }
+  }
+}
