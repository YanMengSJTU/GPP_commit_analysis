diff --git a/okhttp/src/main/java/okhttp3/Call.java b/okhttp/src/main/java/okhttp3/Call.java
index 5b4669ad21..9e0d700389 100644
--- a/okhttp/src/main/java/okhttp3/Call.java
+++ b/okhttp/src/main/java/okhttp3/Call.java
@@ -18,32 +18,18 @@
 import java.io.IOException;
 
 /**
- * A call is a request that has been prepared for execution. A call can be canceled. As this object
- * represents a single request/response pair (stream), it cannot be executed twice.
+ * 调用请求,准备执行。一个call可以取消。这个对象表示一个单一的请求/响应对(流),它不能被执行两次。
  */
 public interface Call extends Cloneable {
   /** Returns the original request that initiated this call. */
   Request request();
 
   /**
-   * Invokes the request immediately, and blocks until the response can be processed or is in
-   * error.
+   * 立即调用请求,直到可以处理或在错误的响应
    *
-   * <p>To avoid leaking resources callers should close the {@link Response} which in turn will
-   * close the underlying {@link ResponseBody}.
+   * 为了避免泄漏资源调用者应该关闭Response，进而将关闭底层.
    *
-   * <pre>@{code
-   *
-   *   // ensure the response (and underlying response body) is closed
-   *   try (Response response = client.newCall(request).execute()) {
-   *     ...
-   *   }
-   *
-   * }</pre>
-   *
-   * <p>The caller may read the response body with the response's {@link Response#body} method. To
-   * avoid leaking resources callers must {@linkplain ResponseBody close the response body} or the
-   * Response.
+   * 调用者可能会读取response body。为了避免泄漏资源调用者必须关闭response body或Response。
    *
    * <p>Note that transport-layer success (receiving a HTTP response code, headers and body) does
    * not necessarily indicate application-layer success: {@code response} may still indicate an
@@ -52,37 +38,32 @@
    * @throws IOException if the request could not be executed due to cancellation, a connectivity
    * problem or timeout. Because networks can fail during an exchange, it is possible that the
    * remote server accepted the request before the failure.
-   * @throws IllegalStateException when the call has already been executed.
+   * @throws IllegalStateException 当调用已经执行
    */
   Response execute() throws IOException;
 
   /**
    * Schedules the request to be executed at some point in the future.
+   * 请求将会执行，除非有几个请求正在执行
    *
-   * <p>The {@link OkHttpClient#dispatcher dispatcher} defines when the request will run: usually
-   * immediately unless there are several other requests currently being executed.
-   *
-   * <p>This client will later call back {@code responseCallback} with either an HTTP response or a
-   * failure exception.
+   * client将会通过回调返回response或者失败的exception
    *
    * @throws IllegalStateException when the call has already been executed.
    */
   void enqueue(Callback responseCallback);
 
-  /** Cancels the request, if possible. Requests that are already complete cannot be canceled. */
+  /** 取消请求，不是一定能取消，假如请求已完成就不能取消了 */
   void cancel();
 
   /**
-   * Returns true if this call has been either {@linkplain #execute() executed} or {@linkplain
-   * #enqueue(Callback) enqueued}. It is an error to execute a call more than once.
+   * 当call调用过了execute或者enqueue就返回true，记住call只能调用一次上述方法，否则报错
    */
   boolean isExecuted();
 
   boolean isCanceled();
 
   /**
-   * Create a new, identical call to this one which can be enqueued or executed even if this call
-   * has already been.
+   * 创建一个全新的完全相同的call，可以执行execute或者enqueue，即使原来的call已经执行过了这两个方法
    */
   Call clone();
 
diff --git a/okhttp/src/main/java/okhttp3/Dispatcher.java b/okhttp/src/main/java/okhttp3/Dispatcher.java
index 43f5aa48e7..55c0efbc69 100644
--- a/okhttp/src/main/java/okhttp3/Dispatcher.java
+++ b/okhttp/src/main/java/okhttp3/Dispatcher.java
@@ -30,27 +30,33 @@
 import okhttp3.internal.Util;
 
 /**
- * Policy on when async requests are executed.
+ * 当异步请求执行政策。
  *
  * <p>Each dispatcher uses an {@link ExecutorService} to run calls internally. If you supply your
  * own executor, it should be able to run {@linkplain #getMaxRequests the configured maximum} number
  * of calls concurrently.
  */
 public final class Dispatcher {
+  // 最多请求数
   private int maxRequests = 64;
+  // 每台主机最多的并发请求数
   private int maxRequestsPerHost = 5;
   private @Nullable Runnable idleCallback;
 
   /** Executes calls. Created lazily. */
+  /* 懒加载 */
   private @Nullable ExecutorService executorService;
 
   /** Ready async calls in the order they'll be run. */
+  // 双端队列，准备好的异步请求队列
   private final Deque<AsyncCall> readyAsyncCalls = new ArrayDeque<>();
 
   /** Running asynchronous calls. Includes canceled calls that haven't finished yet. */
+  // 双端队列，运行异步调用。包括取消了call还没完成的
   private final Deque<AsyncCall> runningAsyncCalls = new ArrayDeque<>();
 
   /** Running synchronous calls. Includes canceled calls that haven't finished yet. */
+  // 双端队列，运行同步调用。包括取消了call还没完成的
   private final Deque<RealCall> runningSyncCalls = new ArrayDeque<>();
 
   public Dispatcher(ExecutorService executorService) {
@@ -69,11 +75,7 @@ public synchronized ExecutorService executorService() {
   }
 
   /**
-   * Set the maximum number of requests to execute concurrently. Above this requests queue in
-   * memory, waiting for the running calls to complete.
-   *
-   * <p>If more than {@code maxRequests} requests are in flight when this is invoked, those requests
-   * will remain in flight.
+   * 设置请求并发执行的最大数量。在内存中高于这个请求队列,等待运行调用完成。
    */
   public synchronized void setMaxRequests(int maxRequests) {
     if (maxRequests < 1) {
@@ -109,8 +111,7 @@ public synchronized int getMaxRequestsPerHost() {
   }
 
   /**
-   * Set a callback to be invoked each time the dispatcher becomes idle (when the number of running
-   * calls returns to zero).
+   * 设置回调将每次调用调度程序变为空闲时(当运行调用的数量为零)。
    *
    * <p>Note: The time at which a {@linkplain Call call} is considered idle is different depending
    * on whether it was run {@linkplain Call#enqueue(Callback) asynchronously} or
@@ -125,6 +126,7 @@ public synchronized void setIdleCallback(@Nullable Runnable idleCallback) {
   }
 
   synchronized void enqueue(AsyncCall call) {
+    // 先判断是否符合各种max数
     if (runningAsyncCalls.size() < maxRequests && runningCallsForHost(call) < maxRequestsPerHost) {
       runningAsyncCalls.add(call);
       executorService().execute(call);
@@ -134,8 +136,7 @@ synchronized void enqueue(AsyncCall call) {
   }
 
   /**
-   * Cancel all calls currently enqueued or executing. Includes calls executed both {@linkplain
-   * Call#execute() synchronously} and {@linkplain Call#enqueue asynchronously}.
+   * 取消所有请求
    */
   public synchronized void cancelAll() {
     for (AsyncCall call : readyAsyncCalls) {
@@ -151,6 +152,9 @@ public synchronized void cancelAll() {
     }
   }
 
+  /**
+   * 这里是在每次设置了两个max数都会调用的方法，先判断当前runningAsyncCalls有没有大于最大值再判断准备好的队列是否为空，true则return，false则将请求从准备好队列添加到运行队列
+   */
   private void promoteCalls() {
     if (runningAsyncCalls.size() >= maxRequests) return; // Already running max capacity.
     if (readyAsyncCalls.isEmpty()) return; // No ready calls to promote.
@@ -168,7 +172,7 @@ private void promoteCalls() {
     }
   }
 
-  /** Returns the number of running calls that share a host with {@code call}. */
+  /** 返回runningAsyncCalls中对应的call对应的host主机的链接请求数 */
   private int runningCallsForHost(AsyncCall call) {
     int result = 0;
     for (AsyncCall c : runningAsyncCalls) {
@@ -192,6 +196,9 @@ void finished(RealCall call) {
     finished(runningSyncCalls, call, false);
   }
 
+  /**
+   * 每个请求结束回到这里，异步请求则promoteCalls，同步请求则不用。假如结束回调不为空则会在异步请求队列和同步请求队列都为空的情况下回调。
+   */
   private <T> void finished(Deque<T> calls, T call, boolean promoteCalls) {
     int runningCallsCount;
     Runnable idleCallback;
diff --git a/okhttp/src/main/java/okhttp3/RealCall.java b/okhttp/src/main/java/okhttp3/RealCall.java
index 922d8a3b41..cadfd89809 100644
--- a/okhttp/src/main/java/okhttp3/RealCall.java
+++ b/okhttp/src/main/java/okhttp3/RealCall.java
@@ -32,6 +32,7 @@
 
 final class RealCall implements Call {
   final OkHttpClient client;
+  // 重试和跟踪拦截器
   final RetryAndFollowUpInterceptor retryAndFollowUpInterceptor;
   final EventListener eventListener;
 
@@ -60,13 +61,16 @@
 
   @Override public Response execute() throws IOException {
     synchronized (this) {
+      // 这里锁住使得每一个call只能用一次execute或者execute
       if (executed) throw new IllegalStateException("Already Executed");
       executed = true;
     }
+    // TODO: 2017/5/11 这里我暂时还不知道是啥玩意，难道是追踪调用器栈堆？
     captureCallStackTrace();
     try {
       client.dispatcher().executed(this);
       Response result = getResponseWithInterceptorChain();
+      // 下面这句其实不知道能不能来得到的，因为response为空的话在getResponseWithInterceptorChain里面的RealInterceptorChain就会抛出NullPointerException了
       if (result == null) throw new IOException("Canceled");
       return result;
     } finally {
@@ -172,14 +176,19 @@ Response getResponseWithInterceptorChain() throws IOException {
     List<Interceptor> interceptors = new ArrayList<>();
     interceptors.addAll(client.interceptors());
     interceptors.add(retryAndFollowUpInterceptor);
+    // 网桥拦截器
     interceptors.add(new BridgeInterceptor(client.cookieJar()));
+    // 缓存拦截器
     interceptors.add(new CacheInterceptor(client.internalCache()));
+    // 链接拦截器
     interceptors.add(new ConnectInterceptor(client));
     if (!forWebSocket) {
       interceptors.addAll(client.networkInterceptors());
     }
+    // 每一个拦截器链的最后一个，这里从网络得到结果
     interceptors.add(new CallServerInterceptor(forWebSocket));
 
+    // 拦截器链
     Interceptor.Chain chain = new RealInterceptorChain(
         interceptors, null, null, null, 0, originalRequest);
     return chain.proceed(originalRequest);
diff --git a/okhttp/src/main/java/okhttp3/Request.java b/okhttp/src/main/java/okhttp3/Request.java
index cb88696260..3cabb79a5e 100644
--- a/okhttp/src/main/java/okhttp3/Request.java
+++ b/okhttp/src/main/java/okhttp3/Request.java
@@ -24,6 +24,7 @@
 /**
  * An HTTP request. Instances of this class are immutable if their {@link #body} is null or itself
  * immutable.
+ * Http请求，假如body为null或者自身不可变的话，则不可变。
  */
 public final class Request {
   final HttpUrl url;
@@ -77,6 +78,7 @@ public Builder newBuilder() {
   /**
    * Returns the cache control directives for this response. This is never null, even if this
    * response contains no {@code Cache-Control} header.
+   * 懒加载，且永不为空，即使header没有Cache-Control的header
    */
   public CacheControl cacheControl() {
     CacheControl result = cacheControl;
@@ -104,6 +106,9 @@ public boolean isHttps() {
     RequestBody body;
     Object tag;
 
+    /**
+     * 默认是get
+     */
     public Builder() {
       this.method = "GET";
       this.headers = new Headers.Builder();
diff --git a/okhttp/src/main/java/okhttp3/RequestBody.java b/okhttp/src/main/java/okhttp3/RequestBody.java
index 11497b9f2f..f57b851112 100644
--- a/okhttp/src/main/java/okhttp3/RequestBody.java
+++ b/okhttp/src/main/java/okhttp3/RequestBody.java
@@ -27,6 +27,7 @@
 
 public abstract class RequestBody {
   /** Returns the Content-Type header for this body. */
+  /* 返回header的内容类型 */
   public abstract @Nullable MediaType contentType();
 
   /**
diff --git a/okhttp/src/main/java/okhttp3/Response.java b/okhttp/src/main/java/okhttp3/Response.java
index 31475178ae..6ace87ee55 100644
--- a/okhttp/src/main/java/okhttp3/Response.java
+++ b/okhttp/src/main/java/okhttp3/Response.java
@@ -34,8 +34,7 @@
 import static okhttp3.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
 
 /**
- * An HTTP response. Instances of this class are not immutable: the response body is a one-shot
- * value that may be consumed only once and then closed. All other properties are immutable.
+ * 一个HTTP响应。这个类的实例不是一成不变的:response的body是一个镜头值,只能使用一次,然后关闭。所有其他属性是不可变的。
  *
  * <p>This class implements {@link Closeable}. Closing it simply closes its response body. See
  * {@link ResponseBody} for an explanation and examples.
@@ -48,10 +47,15 @@
   final @Nullable Handshake handshake;
   final Headers headers;
   final @Nullable ResponseBody body;
+  // 网络响应
   final @Nullable Response networkResponse;
+  // 缓存响应
   final @Nullable Response cacheResponse;
+  // 之前的响应
   final @Nullable Response priorResponse;
+  // 发送request的时间
   final long sentRequestAtMillis;
+  // 接收到response的时间
   final long receivedResponseAtMillis;
 
   private volatile CacheControl cacheControl; // Lazily initialized.
@@ -99,8 +103,7 @@ public int code() {
   }
 
   /**
-   * Returns true if the code is in [200..300), which means the request was successfully received,
-   * understood, and accepted.
+   * 返回true,如果代码是在[200 . . 300),这意味着请求已成功收到,理解,和接受。
    */
   public boolean isSuccessful() {
     return code >= 200 && code < 300;
@@ -181,7 +184,7 @@ public Builder newBuilder() {
     return new Builder(this);
   }
 
-  /** Returns true if this response redirects to another resource. */
+  /** 如果这种反应重定向到另一个资源则返回true. */
   public boolean isRedirect() {
     switch (code) {
       case HTTP_PERM_REDIRECT:
@@ -197,18 +200,14 @@ public boolean isRedirect() {
   }
 
   /**
-   * Returns the raw response received from the network. Will be null if this response didn't use
-   * the network, such as when the response is fully cached. The body of the returned response
-   * should not be read.
+   * 返回原始响应来自网络。如果这个反应没有使用网络,将是null,例如当完全缓存的响应.返回响应的主体不应读
    */
   public @Nullable Response networkResponse() {
     return networkResponse;
   }
 
   /**
-   * Returns the raw response received from the cache. Will be null if this response didn't use the
-   * cache. For conditional get requests the cache response and network response may both be
-   * non-null. The body of the returned response should not be read.
+   * 从缓存中返回原始的响应了。如果没有使用缓存响应,将是null.如果是get请求缓存响应和网络响应可能两个都不为null。返回响应的主体不应读。
    */
   public @Nullable Response cacheResponse() {
     return cacheResponse;
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java b/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java
index 398f29d661..852929681a 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java
@@ -27,13 +27,20 @@
 /**
  * A concrete interceptor chain that carries the entire interceptor chain: all application
  * interceptors, the OkHttp core, all network interceptors, and finally the network caller.
+ * 一个具体的拦截器链携带整个拦截器链:所有应用程序拦截器,okHttp核心,所有网络拦截器,最后网络调用者。
  */
 public final class RealInterceptorChain implements Interceptor.Chain {
+  // 拦截器list
   private final List<Interceptor> interceptors;
+  // 流分配
   private final StreamAllocation streamAllocation;
+  // 编解码器
   private final HttpCodec httpCodec;
+  // 真正的连接
   private final RealConnection connection;
+  // index
   private final int index;
+  // 请求
   private final Request request;
   private int calls;
 
@@ -69,6 +76,7 @@ public HttpCodec httpStream() {
 
   public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,
       RealConnection connection) throws IOException {
+    // index可以控制从拦截器链的哪里开始拦截（即忽略小于index的拦截器了）
     if (index >= interceptors.size()) throw new AssertionError();
 
     calls++;
@@ -80,24 +88,25 @@ public Response proceed(Request request, StreamAllocation streamAllocation, Http
     }
 
     // If we already have a stream, confirm that this is the only call to chain.proceed().
+    // 这里应该是确保每个拦截器链只能proceed一次的吧
     if (this.httpCodec != null && calls > 1) {
       throw new IllegalStateException("network interceptor " + interceptors.get(index - 1)
           + " must call proceed() exactly once");
     }
 
-    // Call the next interceptor in the chain.
+    // 通过对index的控制，进而一层一层的对拦截器链的每一个拦截器进行拦截处理，最后得到response
     RealInterceptorChain next = new RealInterceptorChain(
         interceptors, streamAllocation, httpCodec, connection, index + 1, request);
     Interceptor interceptor = interceptors.get(index);
     Response response = interceptor.intercept(next);
 
-    // Confirm that the next interceptor made its required call to chain.proceed().
+    // 这里通过对list的长度和index进行对比，确保每一个拦截器都有调用到，否则报错（这是要求每一拦截器都需要处理拦截器链的下一层）.
     if (httpCodec != null && index + 1 < interceptors.size() && next.calls != 1) {
       throw new IllegalStateException("network interceptor " + interceptor
           + " must call proceed() exactly once");
     }
 
-    // Confirm that the intercepted response isn't null.
+    // 确保拦截器返回response不为空
     if (response == null) {
       throw new NullPointerException("interceptor " + interceptor + " returned null");
     }
