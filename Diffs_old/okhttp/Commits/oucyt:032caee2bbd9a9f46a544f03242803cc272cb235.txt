diff --git a/okhttp/src/main/java/okhttp3/Authenticator.java b/okhttp/src/main/java/okhttp3/Authenticator.java
index 6e1d1a4fd5..45b7feb81d 100644
--- a/okhttp/src/main/java/okhttp3/Authenticator.java
+++ b/okhttp/src/main/java/okhttp3/Authenticator.java
@@ -96,16 +96,19 @@
  * or both.
  */
 public interface Authenticator {
-  /** An authenticator that knows no credentials and makes no attempt to authenticate. */
-  Authenticator NONE = (route, response) -> null;
+    /**
+     * An authenticator that knows no credentials and makes no attempt to authenticate.
+     */
+    Authenticator NONE = (route, response) -> null;
 
-  /**
-   * Returns a request that includes a credential to satisfy an authentication challenge in {@code
-   * response}. Returns null if the challenge cannot be satisfied.
-   *
-   * <p>The route is best effort, it currently may not always be provided even when logically
-   * available. It may also not be provided when an authenticator is re-used manually in an
-   * application interceptor, such as when implementing client-specific retries.
-   */
-  @Nullable Request authenticate(@Nullable Route route, Response response) throws IOException;
+    /**
+     * Returns a request that includes a credential to satisfy an authentication challenge in {@code
+     * response}. Returns null if the challenge cannot be satisfied.
+     *
+     * <p>The route is best effort, it currently may not always be provided even when logically
+     * available. It may also not be provided when an authenticator is re-used manually in an
+     * application interceptor, such as when implementing client-specific retries.
+     */
+    @Nullable
+    Request authenticate(@Nullable Route route, Response response) throws IOException;
 }
diff --git a/okhttp/src/main/java/okhttp3/Cache.java b/okhttp/src/main/java/okhttp3/Cache.java
index 2ba97ffd0f..d9f6961b0b 100644
--- a/okhttp/src/main/java/okhttp3/Cache.java
+++ b/okhttp/src/main/java/okhttp3/Cache.java
@@ -29,6 +29,7 @@
 import java.util.List;
 import java.util.NoSuchElementException;
 import javax.annotation.Nullable;
+
 import okhttp3.internal.Util;
 import okhttp3.internal.cache.CacheRequest;
 import okhttp3.internal.cache.CacheStrategy;
@@ -57,14 +58,14 @@
  *
  * <p>To measure cache effectiveness, this class tracks three statistics:
  * <ul>
- *     <li><strong>{@linkplain #requestCount() Request Count:}</strong> the number of HTTP
- *         requests issued since this cache was created.
- *     <li><strong>{@linkplain #networkCount() Network Count:}</strong> the number of those
- *         requests that required network use.
- *     <li><strong>{@linkplain #hitCount() Hit Count:}</strong> the number of those requests
- *         whose responses were served by the cache.
+ * <li><strong>{@linkplain #requestCount() Request Count:}</strong> the number of HTTP
+ * requests issued since this cache was created.
+ * <li><strong>{@linkplain #networkCount() Network Count:}</strong> the number of those
+ * requests that required network use.
+ * <li><strong>{@linkplain #hitCount() Hit Count:}</strong> the number of those requests
+ * whose responses were served by the cache.
  * </ul>
- *
+ * <p>
  * Sometimes a request will result in a conditional cache hit. If the cache contains a stale copy of
  * the response, the client will issue a conditional {@code GET}. The server will then send either
  * the updated response if it has changed, or a short 'not modified' response if the client's copy
@@ -86,7 +87,7 @@
  *       .url("http://publicobject.com/helloworld.txt")
  *       .build();
  * }</pre>
- *
+ * <p>
  * If it is only necessary to force a cached response to be validated by the server, use the more
  * efficient {@code max-age=0} directive instead: <pre>   {@code
  *
@@ -135,637 +136,669 @@
  * {@link CacheControl#FORCE_CACHE} that address the use cases above.
  */
 public final class Cache implements Closeable, Flushable {
-  private static final int VERSION = 201105;
-  private static final int ENTRY_METADATA = 0;
-  private static final int ENTRY_BODY = 1;
-  private static final int ENTRY_COUNT = 2;
-
-  final InternalCache internalCache = new InternalCache() {
-    @Override public @Nullable Response get(Request request) throws IOException {
-      return Cache.this.get(request);
-    }
+    private static final int VERSION = 201105;
+    private static final int ENTRY_METADATA = 0;
+    private static final int ENTRY_BODY = 1;
+    private static final int ENTRY_COUNT = 2;
+
+    final InternalCache internalCache = new InternalCache() {
+        @Override
+        public @Nullable
+        Response get(Request request) throws IOException {
+            return Cache.this.get(request);
+        }
 
-    @Override public @Nullable CacheRequest put(Response response) throws IOException {
-      return Cache.this.put(response);
-    }
+        @Override
+        public @Nullable
+        CacheRequest put(Response response) throws IOException {
+            return Cache.this.put(response);
+        }
 
-    @Override public void remove(Request request) throws IOException {
-      Cache.this.remove(request);
-    }
+        @Override
+        public void remove(Request request) throws IOException {
+            Cache.this.remove(request);
+        }
 
-    @Override public void update(Response cached, Response network) {
-      Cache.this.update(cached, network);
-    }
+        @Override
+        public void update(Response cached, Response network) {
+            Cache.this.update(cached, network);
+        }
 
-    @Override public void trackConditionalCacheHit() {
-      Cache.this.trackConditionalCacheHit();
-    }
+        @Override
+        public void trackConditionalCacheHit() {
+            Cache.this.trackConditionalCacheHit();
+        }
 
-    @Override public void trackResponse(CacheStrategy cacheStrategy) {
-      Cache.this.trackResponse(cacheStrategy);
+        @Override
+        public void trackResponse(CacheStrategy cacheStrategy) {
+            Cache.this.trackResponse(cacheStrategy);
+        }
+    };
+
+    final DiskLruCache cache;
+
+    /* read and write statistics, all guarded by 'this' */
+    int writeSuccessCount;
+    int writeAbortCount;
+    private int networkCount;
+    private int hitCount;
+    private int requestCount;
+
+    /**
+     * Create a cache of at most {@code maxSize} bytes in {@code directory}.
+     */
+    public Cache(File directory, long maxSize) {
+        this(directory, maxSize, FileSystem.SYSTEM);
     }
-  };
-
-  final DiskLruCache cache;
-
-  /* read and write statistics, all guarded by 'this' */
-  int writeSuccessCount;
-  int writeAbortCount;
-  private int networkCount;
-  private int hitCount;
-  private int requestCount;
-
-  /**
-   * Create a cache of at most {@code maxSize} bytes in {@code directory}.
-   */
-  public Cache(File directory, long maxSize) {
-    this(directory, maxSize, FileSystem.SYSTEM);
-  }
-
-  Cache(File directory, long maxSize, FileSystem fileSystem) {
-    this.cache = DiskLruCache.create(fileSystem, directory, VERSION, ENTRY_COUNT, maxSize);
-  }
-
-  public static String key(HttpUrl url) {
-    return ByteString.encodeUtf8(url.toString()).md5().hex();
-  }
-
-  @Nullable Response get(Request request) {
-    String key = key(request.url());
-    DiskLruCache.Snapshot snapshot;
-    Entry entry;
-    try {
-      snapshot = cache.get(key);
-      if (snapshot == null) {
-        return null;
-      }
-    } catch (IOException e) {
-      // Give up because the cache cannot be read.
-      return null;
+
+    Cache(File directory, long maxSize, FileSystem fileSystem) {
+        this.cache = DiskLruCache.create(fileSystem, directory, VERSION, ENTRY_COUNT, maxSize);
     }
 
-    try {
-      entry = new Entry(snapshot.getSource(ENTRY_METADATA));
-    } catch (IOException e) {
-      Util.closeQuietly(snapshot);
-      return null;
+    public static String key(HttpUrl url) {
+        return ByteString.encodeUtf8(url.toString()).md5().hex();
     }
 
-    Response response = entry.response(snapshot);
+    @Nullable
+    Response get(Request request) {
+        String key = key(request.url());
+        DiskLruCache.Snapshot snapshot;
+        Entry entry;
+        try {
+            snapshot = cache.get(key);
+            if (snapshot == null) {
+                return null;
+            }
+        } catch (IOException e) {
+            // Give up because the cache cannot be read.
+            return null;
+        }
+
+        try {
+            entry = new Entry(snapshot.getSource(ENTRY_METADATA));
+        } catch (IOException e) {
+            Util.closeQuietly(snapshot);
+            return null;
+        }
+
+        Response response = entry.response(snapshot);
 
-    if (!entry.matches(request, response)) {
-      Util.closeQuietly(response.body());
-      return null;
+        if (!entry.matches(request, response)) {
+            Util.closeQuietly(response.body());
+            return null;
+        }
+
+        return response;
     }
 
-    return response;
-  }
+    @Nullable
+    CacheRequest put(Response response) {
+        String requestMethod = response.request().method();
 
-  @Nullable CacheRequest put(Response response) {
-    String requestMethod = response.request().method();
+        if (HttpMethod.invalidatesCache(response.request().method())) {
+            try {
+                remove(response.request());
+            } catch (IOException ignored) {
+                // The cache cannot be written.
+            }
+            return null;
+        }
+        if (!requestMethod.equals("GET")) {
+            // Don't cache non-GET responses. We're technically allowed to cache
+            // HEAD requests and some POST requests, but the complexity of doing
+            // so is high and the benefit is low.
+            return null;
+        }
+
+        if (HttpHeaders.hasVaryAll(response)) {
+            return null;
+        }
 
-    if (HttpMethod.invalidatesCache(response.request().method())) {
-      try {
-        remove(response.request());
-      } catch (IOException ignored) {
-        // The cache cannot be written.
-      }
-      return null;
+        Entry entry = new Entry(response);
+        DiskLruCache.Editor editor = null;
+        try {
+            editor = cache.edit(key(response.request().url()));
+            if (editor == null) {
+                return null;
+            }
+            entry.writeTo(editor);
+            return new CacheRequestImpl(editor);
+        } catch (IOException e) {
+            abortQuietly(editor);
+            return null;
+        }
     }
-    if (!requestMethod.equals("GET")) {
-      // Don't cache non-GET responses. We're technically allowed to cache
-      // HEAD requests and some POST requests, but the complexity of doing
-      // so is high and the benefit is low.
-      return null;
+
+    void remove(Request request) throws IOException {
+        cache.remove(key(request.url()));
     }
 
-    if (HttpHeaders.hasVaryAll(response)) {
-      return null;
+    void update(Response cached, Response network) {
+        Entry entry = new Entry(network);
+        DiskLruCache.Snapshot snapshot = ((CacheResponseBody) cached.body()).snapshot;
+        DiskLruCache.Editor editor = null;
+        try {
+            editor = snapshot.edit(); // Returns null if snapshot is not current.
+            if (editor != null) {
+                entry.writeTo(editor);
+                editor.commit();
+            }
+        } catch (IOException e) {
+            abortQuietly(editor);
+        }
     }
 
-    Entry entry = new Entry(response);
-    DiskLruCache.Editor editor = null;
-    try {
-      editor = cache.edit(key(response.request().url()));
-      if (editor == null) {
-        return null;
-      }
-      entry.writeTo(editor);
-      return new CacheRequestImpl(editor);
-    } catch (IOException e) {
-      abortQuietly(editor);
-      return null;
+    private void abortQuietly(@Nullable DiskLruCache.Editor editor) {
+        // Give up because the cache cannot be written.
+        try {
+            if (editor != null) {
+                editor.abort();
+            }
+        } catch (IOException ignored) {
+        }
     }
-  }
-
-  void remove(Request request) throws IOException {
-    cache.remove(key(request.url()));
-  }
-
-  void update(Response cached, Response network) {
-    Entry entry = new Entry(network);
-    DiskLruCache.Snapshot snapshot = ((CacheResponseBody) cached.body()).snapshot;
-    DiskLruCache.Editor editor = null;
-    try {
-      editor = snapshot.edit(); // Returns null if snapshot is not current.
-      if (editor != null) {
-        entry.writeTo(editor);
-        editor.commit();
-      }
-    } catch (IOException e) {
-      abortQuietly(editor);
+
+    /**
+     * Initialize the cache. This will include reading the journal files from the storage and building
+     * up the necessary in-memory cache information.
+     *
+     * <p>The initialization time may vary depending on the journal file size and the current actual
+     * cache size. The application needs to be aware of calling this function during the
+     * initialization phase and preferably in a background worker thread.
+     *
+     * <p>Note that if the application chooses to not call this method to initialize the cache. By
+     * default, the okhttp will perform lazy initialization upon the first usage of the cache.
+     */
+    public void initialize() throws IOException {
+        cache.initialize();
     }
-  }
-
-  private void abortQuietly(@Nullable DiskLruCache.Editor editor) {
-    // Give up because the cache cannot be written.
-    try {
-      if (editor != null) {
-        editor.abort();
-      }
-    } catch (IOException ignored) {
+
+    /**
+     * Closes the cache and deletes all of its stored values. This will delete all files in the cache
+     * directory including files that weren't created by the cache.
+     */
+    public void delete() throws IOException {
+        cache.delete();
     }
-  }
-
-  /**
-   * Initialize the cache. This will include reading the journal files from the storage and building
-   * up the necessary in-memory cache information.
-   *
-   * <p>The initialization time may vary depending on the journal file size and the current actual
-   * cache size. The application needs to be aware of calling this function during the
-   * initialization phase and preferably in a background worker thread.
-   *
-   * <p>Note that if the application chooses to not call this method to initialize the cache. By
-   * default, the okhttp will perform lazy initialization upon the first usage of the cache.
-   */
-  public void initialize() throws IOException {
-    cache.initialize();
-  }
-
-  /**
-   * Closes the cache and deletes all of its stored values. This will delete all files in the cache
-   * directory including files that weren't created by the cache.
-   */
-  public void delete() throws IOException {
-    cache.delete();
-  }
-
-  /**
-   * Deletes all values stored in the cache. In-flight writes to the cache will complete normally,
-   * but the corresponding responses will not be stored.
-   */
-  public void evictAll() throws IOException {
-    cache.evictAll();
-  }
-
-  /**
-   * Returns an iterator over the URLs in this cache. This iterator doesn't throw {@code
-   * ConcurrentModificationException}, but if new responses are added while iterating, their URLs
-   * will not be returned. If existing responses are evicted during iteration, they will be absent
-   * (unless they were already returned).
-   *
-   * <p>The iterator supports {@linkplain Iterator#remove}. Removing a URL from the iterator evicts
-   * the corresponding response from the cache. Use this to evict selected responses.
-   */
-  public Iterator<String> urls() throws IOException {
-    return new Iterator<String>() {
-      final Iterator<DiskLruCache.Snapshot> delegate = cache.snapshots();
-
-      @Nullable String nextUrl;
-      boolean canRemove;
-
-      @Override public boolean hasNext() {
-        if (nextUrl != null) return true;
-
-        canRemove = false; // Prevent delegate.remove() on the wrong item!
-        while (delegate.hasNext()) {
-          try (DiskLruCache.Snapshot snapshot = delegate.next()) {
-            BufferedSource metadata = Okio.buffer(snapshot.getSource(ENTRY_METADATA));
-            nextUrl = metadata.readUtf8LineStrict();
-            return true;
-          } catch (IOException ignored) {
-            // We couldn't read the metadata for this snapshot; possibly because the host filesystem
-            // has disappeared! Skip it.
-          }
-        }
-
-        return false;
-      }
-
-      @Override public String next() {
-        if (!hasNext()) throw new NoSuchElementException();
-        String result = nextUrl;
-        nextUrl = null;
-        canRemove = true;
-        return result;
-      }
-
-      @Override public void remove() {
-        if (!canRemove) throw new IllegalStateException("remove() before next()");
-        delegate.remove();
-      }
-    };
-  }
-
-  public synchronized int writeAbortCount() {
-    return writeAbortCount;
-  }
-
-  public synchronized int writeSuccessCount() {
-    return writeSuccessCount;
-  }
-
-  public long size() throws IOException {
-    return cache.size();
-  }
-
-  /** Max size of the cache (in bytes). */
-  public long maxSize() {
-    return cache.getMaxSize();
-  }
-
-  @Override public void flush() throws IOException {
-    cache.flush();
-  }
-
-  @Override public void close() throws IOException {
-    cache.close();
-  }
-
-  public File directory() {
-    return cache.getDirectory();
-  }
-
-  public boolean isClosed() {
-    return cache.isClosed();
-  }
-
-  synchronized void trackResponse(CacheStrategy cacheStrategy) {
-    requestCount++;
-
-    if (cacheStrategy.networkRequest != null) {
-      // If this is a conditional request, we'll increment hitCount if/when it hits.
-      networkCount++;
-    } else if (cacheStrategy.cacheResponse != null) {
-      // This response uses the cache and not the network. That's a cache hit.
-      hitCount++;
+
+    /**
+     * Deletes all values stored in the cache. In-flight writes to the cache will complete normally,
+     * but the corresponding responses will not be stored.
+     */
+    public void evictAll() throws IOException {
+        cache.evictAll();
     }
-  }
-
-  synchronized void trackConditionalCacheHit() {
-    hitCount++;
-  }
-
-  public synchronized int networkCount() {
-    return networkCount;
-  }
-
-  public synchronized int hitCount() {
-    return hitCount;
-  }
-
-  public synchronized int requestCount() {
-    return requestCount;
-  }
-
-  private final class CacheRequestImpl implements CacheRequest {
-    private final DiskLruCache.Editor editor;
-    private Sink cacheOut;
-    private Sink body;
-    boolean done;
-
-    CacheRequestImpl(final DiskLruCache.Editor editor) {
-      this.editor = editor;
-      this.cacheOut = editor.newSink(ENTRY_BODY);
-      this.body = new ForwardingSink(cacheOut) {
-        @Override public void close() throws IOException {
-          synchronized (Cache.this) {
-            if (done) {
-              return;
+
+    /**
+     * Returns an iterator over the URLs in this cache. This iterator doesn't throw {@code
+     * ConcurrentModificationException}, but if new responses are added while iterating, their URLs
+     * will not be returned. If existing responses are evicted during iteration, they will be absent
+     * (unless they were already returned).
+     *
+     * <p>The iterator supports {@linkplain Iterator#remove}. Removing a URL from the iterator evicts
+     * the corresponding response from the cache. Use this to evict selected responses.
+     */
+    public Iterator<String> urls() throws IOException {
+        return new Iterator<String>() {
+            final Iterator<DiskLruCache.Snapshot> delegate = cache.snapshots();
+
+            @Nullable
+            String nextUrl;
+            boolean canRemove;
+
+            @Override
+            public boolean hasNext() {
+                if (nextUrl != null) return true;
+
+                canRemove = false; // Prevent delegate.remove() on the wrong item!
+                while (delegate.hasNext()) {
+                    try (DiskLruCache.Snapshot snapshot = delegate.next()) {
+                        BufferedSource metadata = Okio.buffer(snapshot.getSource(ENTRY_METADATA));
+                        nextUrl = metadata.readUtf8LineStrict();
+                        return true;
+                    } catch (IOException ignored) {
+                        // We couldn't read the metadata for this snapshot; possibly because the host filesystem
+                        // has disappeared! Skip it.
+                    }
+                }
+
+                return false;
             }
-            done = true;
-            writeSuccessCount++;
-          }
-          super.close();
-          editor.commit();
-        }
-      };
+
+            @Override
+            public String next() {
+                if (!hasNext()) throw new NoSuchElementException();
+                String result = nextUrl;
+                nextUrl = null;
+                canRemove = true;
+                return result;
+            }
+
+            @Override
+            public void remove() {
+                if (!canRemove) throw new IllegalStateException("remove() before next()");
+                delegate.remove();
+            }
+        };
     }
 
-    @Override public void abort() {
-      synchronized (Cache.this) {
-        if (done) {
-          return;
-        }
-        done = true;
-        writeAbortCount++;
-      }
-      Util.closeQuietly(cacheOut);
-      try {
-        editor.abort();
-      } catch (IOException ignored) {
-      }
+    public synchronized int writeAbortCount() {
+        return writeAbortCount;
     }
 
-    @Override public Sink body() {
-      return body;
+    public synchronized int writeSuccessCount() {
+        return writeSuccessCount;
+    }
+
+    public long size() throws IOException {
+        return cache.size();
     }
-  }
-
-  private static final class Entry {
-    /** Synthetic response header: the local time when the request was sent. */
-    private static final String SENT_MILLIS = Platform.get().getPrefix() + "-Sent-Millis";
-
-    /** Synthetic response header: the local time when the response was received. */
-    private static final String RECEIVED_MILLIS = Platform.get().getPrefix() + "-Received-Millis";
-
-    private final String url;
-    private final Headers varyHeaders;
-    private final String requestMethod;
-    private final Protocol protocol;
-    private final int code;
-    private final String message;
-    private final Headers responseHeaders;
-    private final @Nullable Handshake handshake;
-    private final long sentRequestMillis;
-    private final long receivedResponseMillis;
 
     /**
-     * Reads an entry from an input stream. A typical entry looks like this:
-     * <pre>{@code
-     *   http://google.com/foo
-     *   GET
-     *   2
-     *   Accept-Language: fr-CA
-     *   Accept-Charset: UTF-8
-     *   HTTP/1.1 200 OK
-     *   3
-     *   Content-Type: image/png
-     *   Content-Length: 100
-     *   Cache-Control: max-age=600
-     * }</pre>
-     *
-     * <p>A typical HTTPS file looks like this:
-     * <pre>{@code
-     *   https://google.com/foo
-     *   GET
-     *   2
-     *   Accept-Language: fr-CA
-     *   Accept-Charset: UTF-8
-     *   HTTP/1.1 200 OK
-     *   3
-     *   Content-Type: image/png
-     *   Content-Length: 100
-     *   Cache-Control: max-age=600
-     *
-     *   AES_256_WITH_MD5
-     *   2
-     *   base64-encoded peerCertificate[0]
-     *   base64-encoded peerCertificate[1]
-     *   -1
-     *   TLSv1.2
-     * }</pre>
-     * The file is newline separated. The first two lines are the URL and the request method. Next
-     * is the number of HTTP Vary request header lines, followed by those lines.
-     *
-     * <p>Next is the response status line, followed by the number of HTTP response header lines,
-     * followed by those lines.
-     *
-     * <p>HTTPS responses also contain SSL session information. This begins with a blank line, and
-     * then a line containing the cipher suite. Next is the length of the peer certificate chain.
-     * These certificates are base64-encoded and appear each on their own line. The next line
-     * contains the length of the local certificate chain. These certificates are also
-     * base64-encoded and appear each on their own line. A length of -1 is used to encode a null
-     * array. The last line is optional. If present, it contains the TLS version.
+     * Max size of the cache (in bytes).
      */
-    Entry(Source in) throws IOException {
-      try {
-        BufferedSource source = Okio.buffer(in);
-        url = source.readUtf8LineStrict();
-        requestMethod = source.readUtf8LineStrict();
-        Headers.Builder varyHeadersBuilder = new Headers.Builder();
-        int varyRequestHeaderLineCount = readInt(source);
-        for (int i = 0; i < varyRequestHeaderLineCount; i++) {
-          varyHeadersBuilder.addLenient(source.readUtf8LineStrict());
-        }
-        varyHeaders = varyHeadersBuilder.build();
-
-        StatusLine statusLine = StatusLine.parse(source.readUtf8LineStrict());
-        protocol = statusLine.protocol;
-        code = statusLine.code;
-        message = statusLine.message;
-        Headers.Builder responseHeadersBuilder = new Headers.Builder();
-        int responseHeaderLineCount = readInt(source);
-        for (int i = 0; i < responseHeaderLineCount; i++) {
-          responseHeadersBuilder.addLenient(source.readUtf8LineStrict());
-        }
-        String sendRequestMillisString = responseHeadersBuilder.get(SENT_MILLIS);
-        String receivedResponseMillisString = responseHeadersBuilder.get(RECEIVED_MILLIS);
-        responseHeadersBuilder.removeAll(SENT_MILLIS);
-        responseHeadersBuilder.removeAll(RECEIVED_MILLIS);
-        sentRequestMillis = sendRequestMillisString != null
-            ? Long.parseLong(sendRequestMillisString)
-            : 0L;
-        receivedResponseMillis = receivedResponseMillisString != null
-            ? Long.parseLong(receivedResponseMillisString)
-            : 0L;
-        responseHeaders = responseHeadersBuilder.build();
-
-        if (isHttps()) {
-          String blank = source.readUtf8LineStrict();
-          if (blank.length() > 0) {
-            throw new IOException("expected \"\" but was \"" + blank + "\"");
-          }
-          String cipherSuiteString = source.readUtf8LineStrict();
-          CipherSuite cipherSuite = CipherSuite.forJavaName(cipherSuiteString);
-          List<Certificate> peerCertificates = readCertificateList(source);
-          List<Certificate> localCertificates = readCertificateList(source);
-          TlsVersion tlsVersion = !source.exhausted()
-              ? TlsVersion.forJavaName(source.readUtf8LineStrict())
-              : TlsVersion.SSL_3_0;
-          handshake = Handshake.get(tlsVersion, cipherSuite, peerCertificates, localCertificates);
-        } else {
-          handshake = null;
-        }
-      } finally {
-        in.close();
-      }
+    public long maxSize() {
+        return cache.getMaxSize();
     }
 
-    Entry(Response response) {
-      this.url = response.request().url().toString();
-      this.varyHeaders = HttpHeaders.varyHeaders(response);
-      this.requestMethod = response.request().method();
-      this.protocol = response.protocol();
-      this.code = response.code();
-      this.message = response.message();
-      this.responseHeaders = response.headers();
-      this.handshake = response.handshake();
-      this.sentRequestMillis = response.sentRequestAtMillis();
-      this.receivedResponseMillis = response.receivedResponseAtMillis();
+    @Override
+    public void flush() throws IOException {
+        cache.flush();
     }
 
-    public void writeTo(DiskLruCache.Editor editor) throws IOException {
-      BufferedSink sink = Okio.buffer(editor.newSink(ENTRY_METADATA));
-
-      sink.writeUtf8(url)
-          .writeByte('\n');
-      sink.writeUtf8(requestMethod)
-          .writeByte('\n');
-      sink.writeDecimalLong(varyHeaders.size())
-          .writeByte('\n');
-      for (int i = 0, size = varyHeaders.size(); i < size; i++) {
-        sink.writeUtf8(varyHeaders.name(i))
-            .writeUtf8(": ")
-            .writeUtf8(varyHeaders.value(i))
-            .writeByte('\n');
-      }
-
-      sink.writeUtf8(new StatusLine(protocol, code, message).toString())
-          .writeByte('\n');
-      sink.writeDecimalLong(responseHeaders.size() + 2)
-          .writeByte('\n');
-      for (int i = 0, size = responseHeaders.size(); i < size; i++) {
-        sink.writeUtf8(responseHeaders.name(i))
-            .writeUtf8(": ")
-            .writeUtf8(responseHeaders.value(i))
-            .writeByte('\n');
-      }
-      sink.writeUtf8(SENT_MILLIS)
-          .writeUtf8(": ")
-          .writeDecimalLong(sentRequestMillis)
-          .writeByte('\n');
-      sink.writeUtf8(RECEIVED_MILLIS)
-          .writeUtf8(": ")
-          .writeDecimalLong(receivedResponseMillis)
-          .writeByte('\n');
-
-      if (isHttps()) {
-        sink.writeByte('\n');
-        sink.writeUtf8(handshake.cipherSuite().javaName())
-            .writeByte('\n');
-        writeCertList(sink, handshake.peerCertificates());
-        writeCertList(sink, handshake.localCertificates());
-        sink.writeUtf8(handshake.tlsVersion().javaName()).writeByte('\n');
-      }
-      sink.close();
+    @Override
+    public void close() throws IOException {
+        cache.close();
     }
 
-    private boolean isHttps() {
-      return url.startsWith("https://");
+    public File directory() {
+        return cache.getDirectory();
     }
 
-    private List<Certificate> readCertificateList(BufferedSource source) throws IOException {
-      int length = readInt(source);
-      if (length == -1) return Collections.emptyList(); // OkHttp v1.2 used -1 to indicate null.
-
-      try {
-        CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509");
-        List<Certificate> result = new ArrayList<>(length);
-        for (int i = 0; i < length; i++) {
-          String line = source.readUtf8LineStrict();
-          Buffer bytes = new Buffer();
-          bytes.write(ByteString.decodeBase64(line));
-          result.add(certificateFactory.generateCertificate(bytes.inputStream()));
-        }
-        return result;
-      } catch (CertificateException e) {
-        throw new IOException(e.getMessage());
-      }
+    public boolean isClosed() {
+        return cache.isClosed();
+    }
+
+    synchronized void trackResponse(CacheStrategy cacheStrategy) {
+        requestCount++;
+
+        if (cacheStrategy.networkRequest != null) {
+            // If this is a conditional request, we'll increment hitCount if/when it hits.
+            networkCount++;
+        } else if (cacheStrategy.cacheResponse != null) {
+            // This response uses the cache and not the network. That's a cache hit.
+            hitCount++;
+        }
     }
 
-    private void writeCertList(BufferedSink sink, List<Certificate> certificates)
-        throws IOException {
-      try {
-        sink.writeDecimalLong(certificates.size())
-            .writeByte('\n');
-        for (int i = 0, size = certificates.size(); i < size; i++) {
-          byte[] bytes = certificates.get(i).getEncoded();
-          String line = ByteString.of(bytes).base64();
-          sink.writeUtf8(line)
-              .writeByte('\n');
-        }
-      } catch (CertificateEncodingException e) {
-        throw new IOException(e.getMessage());
-      }
+    synchronized void trackConditionalCacheHit() {
+        hitCount++;
     }
 
-    public boolean matches(Request request, Response response) {
-      return url.equals(request.url().toString())
-          && requestMethod.equals(request.method())
-          && HttpHeaders.varyMatches(response, varyHeaders, request);
+    public synchronized int networkCount() {
+        return networkCount;
     }
 
-    public Response response(DiskLruCache.Snapshot snapshot) {
-      String contentType = responseHeaders.get("Content-Type");
-      String contentLength = responseHeaders.get("Content-Length");
-      Request cacheRequest = new Request.Builder()
-          .url(url)
-          .method(requestMethod, null)
-          .headers(varyHeaders)
-          .build();
-      return new Response.Builder()
-          .request(cacheRequest)
-          .protocol(protocol)
-          .code(code)
-          .message(message)
-          .headers(responseHeaders)
-          .body(new CacheResponseBody(snapshot, contentType, contentLength))
-          .handshake(handshake)
-          .sentRequestAtMillis(sentRequestMillis)
-          .receivedResponseAtMillis(receivedResponseMillis)
-          .build();
+    public synchronized int hitCount() {
+        return hitCount;
     }
-  }
-
-  static int readInt(BufferedSource source) throws IOException {
-    try {
-      long result = source.readDecimalLong();
-      String line = source.readUtf8LineStrict();
-      if (result < 0 || result > Integer.MAX_VALUE || !line.isEmpty()) {
-        throw new IOException("expected an int but was \"" + result + line + "\"");
-      }
-      return (int) result;
-    } catch (NumberFormatException e) {
-      throw new IOException(e.getMessage());
+
+    public synchronized int requestCount() {
+        return requestCount;
     }
-  }
-
-  private static class CacheResponseBody extends ResponseBody {
-    final DiskLruCache.Snapshot snapshot;
-    private final BufferedSource bodySource;
-    private final @Nullable String contentType;
-    private final @Nullable String contentLength;
-
-    CacheResponseBody(final DiskLruCache.Snapshot snapshot,
-        String contentType, String contentLength) {
-      this.snapshot = snapshot;
-      this.contentType = contentType;
-      this.contentLength = contentLength;
-
-      Source source = snapshot.getSource(ENTRY_BODY);
-      bodySource = Okio.buffer(new ForwardingSource(source) {
-        @Override public void close() throws IOException {
-          snapshot.close();
-          super.close();
-        }
-      });
+
+    private final class CacheRequestImpl implements CacheRequest {
+        private final DiskLruCache.Editor editor;
+        private Sink cacheOut;
+        private Sink body;
+        boolean done;
+
+        CacheRequestImpl(final DiskLruCache.Editor editor) {
+            this.editor = editor;
+            this.cacheOut = editor.newSink(ENTRY_BODY);
+            this.body = new ForwardingSink(cacheOut) {
+                @Override
+                public void close() throws IOException {
+                    synchronized (Cache.this) {
+                        if (done) {
+                            return;
+                        }
+                        done = true;
+                        writeSuccessCount++;
+                    }
+                    super.close();
+                    editor.commit();
+                }
+            };
+        }
+
+        @Override
+        public void abort() {
+            synchronized (Cache.this) {
+                if (done) {
+                    return;
+                }
+                done = true;
+                writeAbortCount++;
+            }
+            Util.closeQuietly(cacheOut);
+            try {
+                editor.abort();
+            } catch (IOException ignored) {
+            }
+        }
+
+        @Override
+        public Sink body() {
+            return body;
+        }
     }
 
-    @Override public MediaType contentType() {
-      return contentType != null ? MediaType.parse(contentType) : null;
+    private static final class Entry {
+        /**
+         * Synthetic response header: the local time when the request was sent.
+         */
+        private static final String SENT_MILLIS = Platform.get().getPrefix() + "-Sent-Millis";
+
+        /**
+         * Synthetic response header: the local time when the response was received.
+         */
+        private static final String RECEIVED_MILLIS = Platform.get().getPrefix() + "-Received-Millis";
+
+        private final String url;
+        private final Headers varyHeaders;
+        private final String requestMethod;
+        private final Protocol protocol;
+        private final int code;
+        private final String message;
+        private final Headers responseHeaders;
+        private final @Nullable
+        Handshake handshake;
+        private final long sentRequestMillis;
+        private final long receivedResponseMillis;
+
+        /**
+         * Reads an entry from an input stream. A typical entry looks like this:
+         * <pre>{@code
+         *   http://google.com/foo
+         *   GET
+         *   2
+         *   Accept-Language: fr-CA
+         *   Accept-Charset: UTF-8
+         *   HTTP/1.1 200 OK
+         *   3
+         *   Content-Type: image/png
+         *   Content-Length: 100
+         *   Cache-Control: max-age=600
+         * }</pre>
+         *
+         * <p>A typical HTTPS file looks like this:
+         * <pre>{@code
+         *   https://google.com/foo
+         *   GET
+         *   2
+         *   Accept-Language: fr-CA
+         *   Accept-Charset: UTF-8
+         *   HTTP/1.1 200 OK
+         *   3
+         *   Content-Type: image/png
+         *   Content-Length: 100
+         *   Cache-Control: max-age=600
+         *
+         *   AES_256_WITH_MD5
+         *   2
+         *   base64-encoded peerCertificate[0]
+         *   base64-encoded peerCertificate[1]
+         *   -1
+         *   TLSv1.2
+         * }</pre>
+         * The file is newline separated. The first two lines are the URL and the request method. Next
+         * is the number of HTTP Vary request header lines, followed by those lines.
+         *
+         * <p>Next is the response status line, followed by the number of HTTP response header lines,
+         * followed by those lines.
+         *
+         * <p>HTTPS responses also contain SSL session information. This begins with a blank line, and
+         * then a line containing the cipher suite. Next is the length of the peer certificate chain.
+         * These certificates are base64-encoded and appear each on their own line. The next line
+         * contains the length of the local certificate chain. These certificates are also
+         * base64-encoded and appear each on their own line. A length of -1 is used to encode a null
+         * array. The last line is optional. If present, it contains the TLS version.
+         */
+        Entry(Source in) throws IOException {
+            try {
+                BufferedSource source = Okio.buffer(in);
+                url = source.readUtf8LineStrict();
+                requestMethod = source.readUtf8LineStrict();
+                Headers.Builder varyHeadersBuilder = new Headers.Builder();
+                int varyRequestHeaderLineCount = readInt(source);
+                for (int i = 0; i < varyRequestHeaderLineCount; i++) {
+                    varyHeadersBuilder.addLenient(source.readUtf8LineStrict());
+                }
+                varyHeaders = varyHeadersBuilder.build();
+
+                StatusLine statusLine = StatusLine.parse(source.readUtf8LineStrict());
+                protocol = statusLine.protocol;
+                code = statusLine.code;
+                message = statusLine.message;
+                Headers.Builder responseHeadersBuilder = new Headers.Builder();
+                int responseHeaderLineCount = readInt(source);
+                for (int i = 0; i < responseHeaderLineCount; i++) {
+                    responseHeadersBuilder.addLenient(source.readUtf8LineStrict());
+                }
+                String sendRequestMillisString = responseHeadersBuilder.get(SENT_MILLIS);
+                String receivedResponseMillisString = responseHeadersBuilder.get(RECEIVED_MILLIS);
+                responseHeadersBuilder.removeAll(SENT_MILLIS);
+                responseHeadersBuilder.removeAll(RECEIVED_MILLIS);
+                sentRequestMillis = sendRequestMillisString != null
+                        ? Long.parseLong(sendRequestMillisString)
+                        : 0L;
+                receivedResponseMillis = receivedResponseMillisString != null
+                        ? Long.parseLong(receivedResponseMillisString)
+                        : 0L;
+                responseHeaders = responseHeadersBuilder.build();
+
+                if (isHttps()) {
+                    String blank = source.readUtf8LineStrict();
+                    if (blank.length() > 0) {
+                        throw new IOException("expected \"\" but was \"" + blank + "\"");
+                    }
+                    String cipherSuiteString = source.readUtf8LineStrict();
+                    CipherSuite cipherSuite = CipherSuite.forJavaName(cipherSuiteString);
+                    List<Certificate> peerCertificates = readCertificateList(source);
+                    List<Certificate> localCertificates = readCertificateList(source);
+                    TlsVersion tlsVersion = !source.exhausted()
+                            ? TlsVersion.forJavaName(source.readUtf8LineStrict())
+                            : TlsVersion.SSL_3_0;
+                    handshake = Handshake.get(tlsVersion, cipherSuite, peerCertificates, localCertificates);
+                } else {
+                    handshake = null;
+                }
+            } finally {
+                in.close();
+            }
+        }
+
+        Entry(Response response) {
+            this.url = response.request().url().toString();
+            this.varyHeaders = HttpHeaders.varyHeaders(response);
+            this.requestMethod = response.request().method();
+            this.protocol = response.protocol();
+            this.code = response.code();
+            this.message = response.message();
+            this.responseHeaders = response.headers();
+            this.handshake = response.handshake();
+            this.sentRequestMillis = response.sentRequestAtMillis();
+            this.receivedResponseMillis = response.receivedResponseAtMillis();
+        }
+
+        public void writeTo(DiskLruCache.Editor editor) throws IOException {
+            BufferedSink sink = Okio.buffer(editor.newSink(ENTRY_METADATA));
+
+            sink.writeUtf8(url)
+                    .writeByte('\n');
+            sink.writeUtf8(requestMethod)
+                    .writeByte('\n');
+            sink.writeDecimalLong(varyHeaders.size())
+                    .writeByte('\n');
+            for (int i = 0, size = varyHeaders.size(); i < size; i++) {
+                sink.writeUtf8(varyHeaders.name(i))
+                        .writeUtf8(": ")
+                        .writeUtf8(varyHeaders.value(i))
+                        .writeByte('\n');
+            }
+
+            sink.writeUtf8(new StatusLine(protocol, code, message).toString())
+                    .writeByte('\n');
+            sink.writeDecimalLong(responseHeaders.size() + 2)
+                    .writeByte('\n');
+            for (int i = 0, size = responseHeaders.size(); i < size; i++) {
+                sink.writeUtf8(responseHeaders.name(i))
+                        .writeUtf8(": ")
+                        .writeUtf8(responseHeaders.value(i))
+                        .writeByte('\n');
+            }
+            sink.writeUtf8(SENT_MILLIS)
+                    .writeUtf8(": ")
+                    .writeDecimalLong(sentRequestMillis)
+                    .writeByte('\n');
+            sink.writeUtf8(RECEIVED_MILLIS)
+                    .writeUtf8(": ")
+                    .writeDecimalLong(receivedResponseMillis)
+                    .writeByte('\n');
+
+            if (isHttps()) {
+                sink.writeByte('\n');
+                sink.writeUtf8(handshake.cipherSuite().javaName())
+                        .writeByte('\n');
+                writeCertList(sink, handshake.peerCertificates());
+                writeCertList(sink, handshake.localCertificates());
+                sink.writeUtf8(handshake.tlsVersion().javaName()).writeByte('\n');
+            }
+            sink.close();
+        }
+
+        private boolean isHttps() {
+            return url.startsWith("https://");
+        }
+
+        private List<Certificate> readCertificateList(BufferedSource source) throws IOException {
+            int length = readInt(source);
+            if (length == -1) return Collections.emptyList(); // OkHttp v1.2 used -1 to indicate null.
+
+            try {
+                CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509");
+                List<Certificate> result = new ArrayList<>(length);
+                for (int i = 0; i < length; i++) {
+                    String line = source.readUtf8LineStrict();
+                    Buffer bytes = new Buffer();
+                    bytes.write(ByteString.decodeBase64(line));
+                    result.add(certificateFactory.generateCertificate(bytes.inputStream()));
+                }
+                return result;
+            } catch (CertificateException e) {
+                throw new IOException(e.getMessage());
+            }
+        }
+
+        private void writeCertList(BufferedSink sink, List<Certificate> certificates)
+                throws IOException {
+            try {
+                sink.writeDecimalLong(certificates.size())
+                        .writeByte('\n');
+                for (int i = 0, size = certificates.size(); i < size; i++) {
+                    byte[] bytes = certificates.get(i).getEncoded();
+                    String line = ByteString.of(bytes).base64();
+                    sink.writeUtf8(line)
+                            .writeByte('\n');
+                }
+            } catch (CertificateEncodingException e) {
+                throw new IOException(e.getMessage());
+            }
+        }
+
+        public boolean matches(Request request, Response response) {
+            return url.equals(request.url().toString())
+                    && requestMethod.equals(request.method())
+                    && HttpHeaders.varyMatches(response, varyHeaders, request);
+        }
+
+        public Response response(DiskLruCache.Snapshot snapshot) {
+            String contentType = responseHeaders.get("Content-Type");
+            String contentLength = responseHeaders.get("Content-Length");
+            Request cacheRequest = new Request.Builder()
+                    .url(url)
+                    .method(requestMethod, null)
+                    .headers(varyHeaders)
+                    .build();
+            return new Response.Builder()
+                    .request(cacheRequest)
+                    .protocol(protocol)
+                    .code(code)
+                    .message(message)
+                    .headers(responseHeaders)
+                    .body(new CacheResponseBody(snapshot, contentType, contentLength))
+                    .handshake(handshake)
+                    .sentRequestAtMillis(sentRequestMillis)
+                    .receivedResponseAtMillis(receivedResponseMillis)
+                    .build();
+        }
     }
 
-    @Override public long contentLength() {
-      try {
-        return contentLength != null ? Long.parseLong(contentLength) : -1;
-      } catch (NumberFormatException e) {
-        return -1;
-      }
+    static int readInt(BufferedSource source) throws IOException {
+        try {
+            long result = source.readDecimalLong();
+            String line = source.readUtf8LineStrict();
+            if (result < 0 || result > Integer.MAX_VALUE || !line.isEmpty()) {
+                throw new IOException("expected an int but was \"" + result + line + "\"");
+            }
+            return (int) result;
+        } catch (NumberFormatException e) {
+            throw new IOException(e.getMessage());
+        }
     }
 
-    @Override public BufferedSource source() {
-      return bodySource;
+    private static class CacheResponseBody extends ResponseBody {
+        final DiskLruCache.Snapshot snapshot;
+        private final BufferedSource bodySource;
+        private final @Nullable
+        String contentType;
+        private final @Nullable
+        String contentLength;
+
+        CacheResponseBody(final DiskLruCache.Snapshot snapshot,
+                          String contentType, String contentLength) {
+            this.snapshot = snapshot;
+            this.contentType = contentType;
+            this.contentLength = contentLength;
+
+            Source source = snapshot.getSource(ENTRY_BODY);
+            bodySource = Okio.buffer(new ForwardingSource(source) {
+                @Override
+                public void close() throws IOException {
+                    snapshot.close();
+                    super.close();
+                }
+            });
+        }
+
+        @Override
+        public MediaType contentType() {
+            return contentType != null ? MediaType.parse(contentType) : null;
+        }
+
+        @Override
+        public long contentLength() {
+            try {
+                return contentLength != null ? Long.parseLong(contentLength) : -1;
+            } catch (NumberFormatException e) {
+                return -1;
+            }
+        }
+
+        @Override
+        public BufferedSource source() {
+            return bodySource;
+        }
     }
-  }
 }
diff --git a/okhttp/src/main/java/okhttp3/Call.java b/okhttp/src/main/java/okhttp3/Call.java
index 67d0f88d3d..781916882d 100644
--- a/okhttp/src/main/java/okhttp3/Call.java
+++ b/okhttp/src/main/java/okhttp3/Call.java
@@ -16,6 +16,7 @@
 package okhttp3;
 
 import java.io.IOException;
+
 import okio.Timeout;
 
 /**
@@ -23,80 +24,84 @@
  * represents a single request/response pair (stream), it cannot be executed twice.
  */
 public interface Call extends Cloneable {
-  /** Returns the original request that initiated this call. */
-  Request request();
+    /**
+     * Returns the original request that initiated this call.
+     */
+    Request request();
 
-  /**
-   * Invokes the request immediately, and blocks until the response can be processed or is in
-   * error.
-   *
-   * <p>To avoid leaking resources callers should close the {@link Response} which in turn will
-   * close the underlying {@link ResponseBody}.
-   *
-   * <pre>{@code
-   *
-   *   // ensure the response (and underlying response body) is closed
-   *   try (Response response = client.newCall(request).execute()) {
-   *     ...
-   *   }
-   *
-   * }</pre>
-   *
-   * <p>The caller may read the response body with the response's {@link Response#body} method. To
-   * avoid leaking resources callers must {@linkplain ResponseBody close the response body} or the
-   * Response.
-   *
-   * <p>Note that transport-layer success (receiving a HTTP response code, headers and body) does
-   * not necessarily indicate application-layer success: {@code response} may still indicate an
-   * unhappy HTTP response code like 404 or 500.
-   *
-   * @throws IOException if the request could not be executed due to cancellation, a connectivity
-   * problem or timeout. Because networks can fail during an exchange, it is possible that the
-   * remote server accepted the request before the failure.
-   * @throws IllegalStateException when the call has already been executed.
-   */
-  Response execute() throws IOException;
+    /**
+     * Invokes the request immediately, and blocks until the response can be processed or is in
+     * error.
+     *
+     * <p>To avoid leaking resources callers should close the {@link Response} which in turn will
+     * close the underlying {@link ResponseBody}.
+     *
+     * <pre>{@code
+     *
+     *   // ensure the response (and underlying response body) is closed
+     *   try (Response response = client.newCall(request).execute()) {
+     *     ...
+     *   }
+     *
+     * }</pre>
+     *
+     * <p>The caller may read the response body with the response's {@link Response#body} method. To
+     * avoid leaking resources callers must {@linkplain ResponseBody close the response body} or the
+     * Response.
+     *
+     * <p>Note that transport-layer success (receiving a HTTP response code, headers and body) does
+     * not necessarily indicate application-layer success: {@code response} may still indicate an
+     * unhappy HTTP response code like 404 or 500.
+     *
+     * @throws IOException           if the request could not be executed due to cancellation, a connectivity
+     *                               problem or timeout. Because networks can fail during an exchange, it is possible that the
+     *                               remote server accepted the request before the failure.
+     * @throws IllegalStateException when the call has already been executed.
+     */
+    Response execute() throws IOException;
 
-  /**
-   * Schedules the request to be executed at some point in the future.
-   *
-   * <p>The {@link OkHttpClient#dispatcher dispatcher} defines when the request will run: usually
-   * immediately unless there are several other requests currently being executed.
-   *
-   * <p>This client will later call back {@code responseCallback} with either an HTTP response or a
-   * failure exception.
-   *
-   * @throws IllegalStateException when the call has already been executed.
-   */
-  void enqueue(Callback responseCallback);
+    /**
+     * Schedules the request to be executed at some point in the future.
+     *
+     * <p>The {@link OkHttpClient#dispatcher dispatcher} defines when the request will run: usually
+     * immediately unless there are several other requests currently being executed.
+     *
+     * <p>This client will later call back {@code responseCallback} with either an HTTP response or a
+     * failure exception.
+     *
+     * @throws IllegalStateException when the call has already been executed.
+     */
+    void enqueue(Callback responseCallback);
 
-  /** Cancels the request, if possible. Requests that are already complete cannot be canceled. */
-  void cancel();
+    /**
+     * Cancels the request, if possible. Requests that are already complete cannot be canceled.
+     */
+    void cancel();
 
-  /**
-   * Returns true if this call has been either {@linkplain #execute() executed} or {@linkplain
-   * #enqueue(Callback) enqueued}. It is an error to execute a call more than once.
-   */
-  boolean isExecuted();
+    /**
+     * Returns true if this call has been either {@linkplain #execute() executed} or {@linkplain
+     * #enqueue(Callback) enqueued}. It is an error to execute a call more than once.
+     */
+    boolean isExecuted();
 
-  boolean isCanceled();
+    boolean isCanceled();
 
-  /**
-   * Returns a timeout that spans the entire call: resolving DNS, connecting, writing the request
-   * body, server processing, and reading the response body. If the call requires redirects or
-   * retries all must complete within one timeout period.
-   *
-   * <p>Configure the client's default timeout with {@link OkHttpClient.Builder#callTimeout}.
-   */
-  Timeout timeout();
+    /**
+     * Returns a timeout that spans the entire call: resolving DNS, connecting, writing the request
+     * body, server processing, and reading the response body. If the call requires redirects or
+     * retries all must complete within one timeout period.
+     *
+     * <p>Configure the client's default timeout with {@link OkHttpClient.Builder#callTimeout}.
+     */
+    Timeout timeout();
 
-  /**
-   * Create a new, identical call to this one which can be enqueued or executed even if this call
-   * has already been.
-   */
-  Call clone();
+    /**
+     * Create a new, identical call to this one which can be enqueued or executed even if this call
+     * has already been.
+     */
+    Call clone();
 
-  interface Factory {
-    Call newCall(Request request);
-  }
+    interface Factory {
+        Call newCall(Request request);
+    }
 }
diff --git a/okhttp/src/main/java/okhttp3/ConnectionPool.java b/okhttp/src/main/java/okhttp3/ConnectionPool.java
index 762326a75b..735ddd26a8 100644
--- a/okhttp/src/main/java/okhttp3/ConnectionPool.java
+++ b/okhttp/src/main/java/okhttp3/ConnectionPool.java
@@ -73,7 +73,7 @@ public void run() {
                     waitNanos -= (waitMillis * 1000000L);
                     synchronized (ConnectionPool.this) {
                         try {
-                            // 线程休眠指定时长重新唤醒
+                            // 线程等待唤醒，或者指定时长自动唤醒
                             ConnectionPool.this.wait(waitMillis, (int) waitNanos);
                         } catch (InterruptedException ignored) {
                         }
diff --git a/okhttp/src/main/java/okhttp3/CookieJar.java b/okhttp/src/main/java/okhttp3/CookieJar.java
index bdb3cd552e..cf9cdbc488 100644
--- a/okhttp/src/main/java/okhttp3/CookieJar.java
+++ b/okhttp/src/main/java/okhttp3/CookieJar.java
@@ -32,31 +32,35 @@
  * policies for updating and expiring cookies.
  */
 public interface CookieJar {
-  /** A cookie jar that never accepts any cookies. */
-  CookieJar NO_COOKIES = new CookieJar() {
-    @Override public void saveFromResponse(HttpUrl url, List<Cookie> cookies) {
-    }
+    /**
+     * A cookie jar that never accepts any cookies.
+     */
+    CookieJar NO_COOKIES = new CookieJar() {
+        @Override
+        public void saveFromResponse(HttpUrl url, List<Cookie> cookies) {
+        }
 
-    @Override public List<Cookie> loadForRequest(HttpUrl url) {
-      return Collections.emptyList();
-    }
-  };
+        @Override
+        public List<Cookie> loadForRequest(HttpUrl url) {
+            return Collections.emptyList();
+        }
+    };
 
-  /**
-   * Saves {@code cookies} from an HTTP response to this store according to this jar's policy.
-   *
-   * <p>Note that this method may be called a second time for a single HTTP response if the response
-   * includes a trailer. For this obscure HTTP feature, {@code cookies} contains only the trailer's
-   * cookies.
-   */
-  void saveFromResponse(HttpUrl url, List<Cookie> cookies);
+    /**
+     * Saves {@code cookies} from an HTTP response to this store according to this jar's policy.
+     *
+     * <p>Note that this method may be called a second time for a single HTTP response if the response
+     * includes a trailer. For this obscure HTTP feature, {@code cookies} contains only the trailer's
+     * cookies.
+     */
+    void saveFromResponse(HttpUrl url, List<Cookie> cookies);
 
-  /**
-   * Load cookies from the jar for an HTTP request to {@code url}. This method returns a possibly
-   * empty list of cookies for the network request.
-   *
-   * <p>Simple implementations will return the accepted cookies that have not yet expired and that
-   * {@linkplain Cookie#matches match} {@code url}.
-   */
-  List<Cookie> loadForRequest(HttpUrl url);
+    /**
+     * Load cookies from the jar for an HTTP request to {@code url}. This method returns a possibly
+     * empty list of cookies for the network request.
+     *
+     * <p>Simple implementations will return the accepted cookies that have not yet expired and that
+     * {@linkplain Cookie#matches match} {@code url}.
+     */
+    List<Cookie> loadForRequest(HttpUrl url);
 }
diff --git a/okhttp/src/main/java/okhttp3/Dispatcher.java b/okhttp/src/main/java/okhttp3/Dispatcher.java
index d3d9b21aff..f6a2745732 100644
--- a/okhttp/src/main/java/okhttp3/Dispatcher.java
+++ b/okhttp/src/main/java/okhttp3/Dispatcher.java
@@ -26,6 +26,7 @@
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
 import javax.annotation.Nullable;
+
 import okhttp3.RealCall.AsyncCall;
 import okhttp3.internal.Util;
 
@@ -37,221 +38,248 @@
  * of calls concurrently.
  */
 public final class Dispatcher {
-  private int maxRequests = 64;
-  private int maxRequestsPerHost = 5;
-  private @Nullable Runnable idleCallback;
-
-  /** Executes calls. Created lazily. */
-  private @Nullable ExecutorService executorService;
-
-  /** Ready async calls in the order they'll be run. */
-  private final Deque<AsyncCall> readyAsyncCalls = new ArrayDeque<>();
-
-  /** Running asynchronous calls. Includes canceled calls that haven't finished yet. */
-  private final Deque<AsyncCall> runningAsyncCalls = new ArrayDeque<>();
-
-  /** Running synchronous calls. Includes canceled calls that haven't finished yet. */
-  private final Deque<RealCall> runningSyncCalls = new ArrayDeque<>();
-
-  public Dispatcher(ExecutorService executorService) {
-    this.executorService = executorService;
-  }
+    private int maxRequests = 64;
+    private int maxRequestsPerHost = 5;
+    private @Nullable
+    Runnable idleCallback;
 
-  public Dispatcher() {
-  }
+    /**
+     * Executes calls. Created lazily.
+     */
+    private @Nullable
+    ExecutorService executorService;
+
+    /**
+     * Ready async calls in the order they'll be run.
+     */
+    private final Deque<AsyncCall> readyAsyncCalls = new ArrayDeque<>();
+
+    /**
+     * Running asynchronous calls. Includes canceled calls that haven't finished yet.
+     */
+    private final Deque<AsyncCall> runningAsyncCalls = new ArrayDeque<>();
+
+    /**
+     * Running synchronous calls. Includes canceled calls that haven't finished yet.
+     */
+    private final Deque<RealCall> runningSyncCalls = new ArrayDeque<>();
+
+    public Dispatcher(ExecutorService executorService) {
+        this.executorService = executorService;
+    }
 
-  public synchronized ExecutorService executorService() {
-    if (executorService == null) {
-      executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,
-          new SynchronousQueue<>(), Util.threadFactory("OkHttp Dispatcher", false));
+    public Dispatcher() {
     }
-    return executorService;
-  }
-
-  /**
-   * Set the maximum number of requests to execute concurrently. Above this requests queue in
-   * memory, waiting for the running calls to complete.
-   *
-   * <p>If more than {@code maxRequests} requests are in flight when this is invoked, those requests
-   * will remain in flight.
-   */
-  public void setMaxRequests(int maxRequests) {
-    if (maxRequests < 1) {
-      throw new IllegalArgumentException("max < 1: " + maxRequests);
+
+    public synchronized ExecutorService executorService() {
+        if (executorService == null) {
+            executorService = new ThreadPoolExecutor(0,
+                    Integer.MAX_VALUE,
+                    60,
+                    TimeUnit.SECONDS,
+                    new SynchronousQueue<>(),
+                    Util.threadFactory("OkHttp Dispatcher",
+                            false));
+        }
+        return executorService;
     }
-    synchronized (this) {
-      this.maxRequests = maxRequests;
+
+    /**
+     * Set the maximum number of requests to execute concurrently. Above this requests queue in
+     * memory, waiting for the running calls to complete.
+     *
+     * <p>If more than {@code maxRequests} requests are in flight when this is invoked, those requests
+     * will remain in flight.
+     */
+    public void setMaxRequests(int maxRequests) {
+        if (maxRequests < 1) {
+            throw new IllegalArgumentException("max < 1: " + maxRequests);
+        }
+        synchronized (this) {
+            this.maxRequests = maxRequests;
+        }
+        promoteAndExecute();
     }
-    promoteAndExecute();
-  }
-
-  public synchronized int getMaxRequests() {
-    return maxRequests;
-  }
-
-  /**
-   * Set the maximum number of requests for each host to execute concurrently. This limits requests
-   * by the URL's host name. Note that concurrent requests to a single IP address may still exceed
-   * this limit: multiple hostnames may share an IP address or be routed through the same HTTP
-   * proxy.
-   *
-   * <p>If more than {@code maxRequestsPerHost} requests are in flight when this is invoked, those
-   * requests will remain in flight.
-   *
-   * <p>WebSocket connections to hosts <b>do not</b> count against this limit.
-   */
-  public void setMaxRequestsPerHost(int maxRequestsPerHost) {
-    if (maxRequestsPerHost < 1) {
-      throw new IllegalArgumentException("max < 1: " + maxRequestsPerHost);
+
+    public synchronized int getMaxRequests() {
+        return maxRequests;
     }
-    synchronized (this) {
-      this.maxRequestsPerHost = maxRequestsPerHost;
+
+    /**
+     * Set the maximum number of requests for each host to execute concurrently. This limits requests
+     * by the URL's host name. Note that concurrent requests to a single IP address may still exceed
+     * this limit: multiple hostnames may share an IP address or be routed through the same HTTP
+     * proxy.
+     *
+     * <p>If more than {@code maxRequestsPerHost} requests are in flight when this is invoked, those
+     * requests will remain in flight.
+     *
+     * <p>WebSocket connections to hosts <b>do not</b> count against this limit.
+     */
+    public void setMaxRequestsPerHost(int maxRequestsPerHost) {
+        if (maxRequestsPerHost < 1) {
+            throw new IllegalArgumentException("max < 1: " + maxRequestsPerHost);
+        }
+        synchronized (this) {
+            this.maxRequestsPerHost = maxRequestsPerHost;
+        }
+        promoteAndExecute();
     }
-    promoteAndExecute();
-  }
-
-  public synchronized int getMaxRequestsPerHost() {
-    return maxRequestsPerHost;
-  }
-
-  /**
-   * Set a callback to be invoked each time the dispatcher becomes idle (when the number of running
-   * calls returns to zero).
-   *
-   * <p>Note: The time at which a {@linkplain Call call} is considered idle is different depending
-   * on whether it was run {@linkplain Call#enqueue(Callback) asynchronously} or
-   * {@linkplain Call#execute() synchronously}. Asynchronous calls become idle after the
-   * {@link Callback#onResponse onResponse} or {@link Callback#onFailure onFailure} callback has
-   * returned. Synchronous calls become idle once {@link Call#execute() execute()} returns. This
-   * means that if you are doing synchronous calls the network layer will not truly be idle until
-   * every returned {@link Response} has been closed.
-   */
-  public synchronized void setIdleCallback(@Nullable Runnable idleCallback) {
-    this.idleCallback = idleCallback;
-  }
-
-  void enqueue(AsyncCall call) {
-    synchronized (this) {
-      readyAsyncCalls.add(call);
+
+    public synchronized int getMaxRequestsPerHost() {
+        return maxRequestsPerHost;
     }
-    promoteAndExecute();
-  }
-
-  /**
-   * Cancel all calls currently enqueued or executing. Includes calls executed both {@linkplain
-   * Call#execute() synchronously} and {@linkplain Call#enqueue asynchronously}.
-   */
-  public synchronized void cancelAll() {
-    for (AsyncCall call : readyAsyncCalls) {
-      call.get().cancel();
+
+    /**
+     * Set a callback to be invoked each time the dispatcher becomes idle (when the number of running
+     * calls returns to zero).
+     *
+     * <p>Note: The time at which a {@linkplain Call call} is considered idle is different depending
+     * on whether it was run {@linkplain Call#enqueue(Callback) asynchronously} or
+     * {@linkplain Call#execute() synchronously}. Asynchronous calls become idle after the
+     * {@link Callback#onResponse onResponse} or {@link Callback#onFailure onFailure} callback has
+     * returned. Synchronous calls become idle once {@link Call#execute() execute()} returns. This
+     * means that if you are doing synchronous calls the network layer will not truly be idle until
+     * every returned {@link Response} has been closed.
+     */
+    public synchronized void setIdleCallback(@Nullable Runnable idleCallback) {
+        this.idleCallback = idleCallback;
     }
 
-    for (AsyncCall call : runningAsyncCalls) {
-      call.get().cancel();
+    void enqueue(AsyncCall call) {
+        synchronized (this) {
+            readyAsyncCalls.add(call);
+        }
+        promoteAndExecute();
     }
 
-    for (RealCall call : runningSyncCalls) {
-      call.cancel();
+    /**
+     * Cancel all calls currently enqueued or executing. Includes calls executed both {@linkplain
+     * Call#execute() synchronously} and {@linkplain Call#enqueue asynchronously}.
+     */
+    public synchronized void cancelAll() {
+        for (AsyncCall call : readyAsyncCalls) {
+            call.get().cancel();
+        }
+
+        for (AsyncCall call : runningAsyncCalls) {
+            call.get().cancel();
+        }
+
+        for (RealCall call : runningSyncCalls) {
+            call.cancel();
+        }
     }
-  }
-
-  /**
-   * Promotes eligible calls from {@link #readyAsyncCalls} to {@link #runningAsyncCalls} and runs
-   * them on the executor service. Must not be called with synchronization because executing calls
-   * can call into user code.
-   *
-   * @return true if the dispatcher is currently running calls.
-   */
-  private boolean promoteAndExecute() {
-    assert (!Thread.holdsLock(this));
-
-    List<AsyncCall> executableCalls = new ArrayList<>();
-    boolean isRunning;
-    synchronized (this) {
-      for (Iterator<AsyncCall> i = readyAsyncCalls.iterator(); i.hasNext(); ) {
-        AsyncCall asyncCall = i.next();
-
-        if (runningAsyncCalls.size() >= maxRequests) break; // Max capacity.
-        if (runningCallsForHost(asyncCall) >= maxRequestsPerHost) continue; // Host max capacity.
-
-        i.remove();
-        executableCalls.add(asyncCall);
-        runningAsyncCalls.add(asyncCall);
-      }
-      isRunning = runningCallsCount() > 0;
+
+    /**
+     * Promotes eligible calls from {@link #readyAsyncCalls} to {@link #runningAsyncCalls} and runs
+     * them on the executor service. Must not be called with synchronization because executing calls
+     * can call into user code.
+     *
+     * @return true if the dispatcher is currently running calls.
+     */
+    private boolean promoteAndExecute() {
+        assert (!Thread.holdsLock(this));
+
+        List<AsyncCall> executableCalls = new ArrayList<>();
+        boolean isRunning;
+        synchronized (this) {
+            for (Iterator<AsyncCall> i = readyAsyncCalls.iterator(); i.hasNext(); ) {
+                AsyncCall asyncCall = i.next();
+
+                if (runningAsyncCalls.size() >= maxRequests) break; // Max capacity.
+                if (runningCallsForHost(asyncCall) >= maxRequestsPerHost) continue; // Host max capacity.
+
+                i.remove();
+                executableCalls.add(asyncCall);
+                runningAsyncCalls.add(asyncCall);
+            }
+            isRunning = runningCallsCount() > 0;
+        }
+
+        for (int i = 0, size = executableCalls.size(); i < size; i++) {
+            AsyncCall asyncCall = executableCalls.get(i);
+            asyncCall.executeOn(executorService());
+        }
+
+        return isRunning;
     }
 
-    for (int i = 0, size = executableCalls.size(); i < size; i++) {
-      AsyncCall asyncCall = executableCalls.get(i);
-      asyncCall.executeOn(executorService());
+    /**
+     * Returns the number of running calls that share a host with {@code call}.
+     */
+    private int runningCallsForHost(AsyncCall call) {
+        int result = 0;
+        for (AsyncCall c : runningAsyncCalls) {
+            if (c.get().forWebSocket) continue;
+            if (c.host().equals(call.host())) result++;
+        }
+        return result;
     }
 
-    return isRunning;
-  }
+    /**
+     * Used by {@code Call#execute} to signal it is in-flight.
+     */
+    synchronized void executed(RealCall call) {
+        runningSyncCalls.add(call);
+    }
 
-  /** Returns the number of running calls that share a host with {@code call}. */
-  private int runningCallsForHost(AsyncCall call) {
-    int result = 0;
-    for (AsyncCall c : runningAsyncCalls) {
-      if (c.get().forWebSocket) continue;
-      if (c.host().equals(call.host())) result++;
+    /**
+     * Used by {@code AsyncCall#run} to signal completion.
+     */
+    void finished(AsyncCall call) {
+        finished(runningAsyncCalls, call);
     }
-    return result;
-  }
 
-  /** Used by {@code Call#execute} to signal it is in-flight. */
-  synchronized void executed(RealCall call) {
-    runningSyncCalls.add(call);
-  }
+    /**
+     * Used by {@code Call#execute} to signal completion.
+     */
+    void finished(RealCall call) {
+        finished(runningSyncCalls, call);
+    }
 
-  /** Used by {@code AsyncCall#run} to signal completion. */
-  void finished(AsyncCall call) {
-    finished(runningAsyncCalls, call);
-  }
+    private <T> void finished(Deque<T> calls, T call) {
+        Runnable idleCallback;
+        synchronized (this) {
+            if (!calls.remove(call)) throw new AssertionError("Call wasn't in-flight!");
+            idleCallback = this.idleCallback;
+        }
 
-  /** Used by {@code Call#execute} to signal completion. */
-  void finished(RealCall call) {
-    finished(runningSyncCalls, call);
-  }
+        boolean isRunning = promoteAndExecute();
 
-  private <T> void finished(Deque<T> calls, T call) {
-    Runnable idleCallback;
-    synchronized (this) {
-      if (!calls.remove(call)) throw new AssertionError("Call wasn't in-flight!");
-      idleCallback = this.idleCallback;
+        if (!isRunning && idleCallback != null) {
+            idleCallback.run();
+        }
     }
 
-    boolean isRunning = promoteAndExecute();
-
-    if (!isRunning && idleCallback != null) {
-      idleCallback.run();
+    /**
+     * Returns a snapshot of the calls currently awaiting execution.
+     */
+    public synchronized List<Call> queuedCalls() {
+        List<Call> result = new ArrayList<>();
+        for (AsyncCall asyncCall : readyAsyncCalls) {
+            result.add(asyncCall.get());
+        }
+        return Collections.unmodifiableList(result);
     }
-  }
 
-  /** Returns a snapshot of the calls currently awaiting execution. */
-  public synchronized List<Call> queuedCalls() {
-    List<Call> result = new ArrayList<>();
-    for (AsyncCall asyncCall : readyAsyncCalls) {
-      result.add(asyncCall.get());
-    }
-    return Collections.unmodifiableList(result);
-  }
-
-  /** Returns a snapshot of the calls currently being executed. */
-  public synchronized List<Call> runningCalls() {
-    List<Call> result = new ArrayList<>();
-    result.addAll(runningSyncCalls);
-    for (AsyncCall asyncCall : runningAsyncCalls) {
-      result.add(asyncCall.get());
+    /**
+     * Returns a snapshot of the calls currently being executed.
+     */
+    public synchronized List<Call> runningCalls() {
+        List<Call> result = new ArrayList<>();
+        result.addAll(runningSyncCalls);
+        for (AsyncCall asyncCall : runningAsyncCalls) {
+            result.add(asyncCall.get());
+        }
+        return Collections.unmodifiableList(result);
     }
-    return Collections.unmodifiableList(result);
-  }
 
-  public synchronized int queuedCallsCount() {
-    return readyAsyncCalls.size();
-  }
+    public synchronized int queuedCallsCount() {
+        return readyAsyncCalls.size();
+    }
 
-  public synchronized int runningCallsCount() {
-    return runningAsyncCalls.size() + runningSyncCalls.size();
-  }
+    public synchronized int runningCallsCount() {
+        return runningAsyncCalls.size() + runningSyncCalls.size();
+    }
 }
diff --git a/okhttp/src/main/java/okhttp3/FormBody.java b/okhttp/src/main/java/okhttp3/FormBody.java
index 4216daccd5..440b31a8ae 100644
--- a/okhttp/src/main/java/okhttp3/FormBody.java
+++ b/okhttp/src/main/java/okhttp3/FormBody.java
@@ -20,6 +20,7 @@
 import java.util.ArrayList;
 import java.util.List;
 import javax.annotation.Nullable;
+
 import okhttp3.internal.Util;
 import okio.Buffer;
 import okio.BufferedSink;
@@ -28,113 +29,119 @@
 import static okhttp3.HttpUrl.percentDecode;
 
 public final class FormBody extends RequestBody {
-  private static final MediaType CONTENT_TYPE = MediaType.get("application/x-www-form-urlencoded");
-
-  private final List<String> encodedNames;
-  private final List<String> encodedValues;
-
-  FormBody(List<String> encodedNames, List<String> encodedValues) {
-    this.encodedNames = Util.immutableList(encodedNames);
-    this.encodedValues = Util.immutableList(encodedValues);
-  }
-
-  /** The number of key-value pairs in this form-encoded body. */
-  public int size() {
-    return encodedNames.size();
-  }
-
-  public String encodedName(int index) {
-    return encodedNames.get(index);
-  }
-
-  public String name(int index) {
-    return percentDecode(encodedName(index), true);
-  }
-
-  public String encodedValue(int index) {
-    return encodedValues.get(index);
-  }
-
-  public String value(int index) {
-    return percentDecode(encodedValue(index), true);
-  }
-
-  @Override public MediaType contentType() {
-    return CONTENT_TYPE;
-  }
-
-  @Override public long contentLength() {
-    return writeOrCountBytes(null, true);
-  }
-
-  @Override public void writeTo(BufferedSink sink) throws IOException {
-    writeOrCountBytes(sink, false);
-  }
-
-  /**
-   * Either writes this request to {@code sink} or measures its content length. We have one method
-   * do double-duty to make sure the counting and content are consistent, particularly when it comes
-   * to awkward operations like measuring the encoded length of header strings, or the
-   * length-in-digits of an encoded integer.
-   */
-  private long writeOrCountBytes(@Nullable BufferedSink sink, boolean countBytes) {
-    long byteCount = 0L;
-
-    Buffer buffer;
-    if (countBytes) {
-      buffer = new Buffer();
-    } else {
-      buffer = sink.buffer();
-    }
+    private static final MediaType CONTENT_TYPE = MediaType.get("application/x-www-form-urlencoded");
 
-    for (int i = 0, size = encodedNames.size(); i < size; i++) {
-      if (i > 0) buffer.writeByte('&');
-      buffer.writeUtf8(encodedNames.get(i));
-      buffer.writeByte('=');
-      buffer.writeUtf8(encodedValues.get(i));
+    private final List<String> encodedNames;
+    private final List<String> encodedValues;
+
+    FormBody(List<String> encodedNames, List<String> encodedValues) {
+        this.encodedNames = Util.immutableList(encodedNames);
+        this.encodedValues = Util.immutableList(encodedValues);
     }
 
-    if (countBytes) {
-      byteCount = buffer.size();
-      buffer.clear();
+    /**
+     * The number of key-value pairs in this form-encoded body.
+     */
+    public int size() {
+        return encodedNames.size();
     }
 
-    return byteCount;
-  }
+    public String encodedName(int index) {
+        return encodedNames.get(index);
+    }
 
-  public static final class Builder {
-    private final List<String> names = new ArrayList<>();
-    private final List<String> values = new ArrayList<>();
-    private final @Nullable Charset charset;
+    public String name(int index) {
+        return percentDecode(encodedName(index), true);
+    }
 
-    public Builder() {
-      this(null);
+    public String encodedValue(int index) {
+        return encodedValues.get(index);
     }
 
-    public Builder(@Nullable Charset charset) {
-      this.charset = charset;
+    public String value(int index) {
+        return percentDecode(encodedValue(index), true);
     }
 
-    public Builder add(String name, String value) {
-      if (name == null) throw new NullPointerException("name == null");
-      if (value == null) throw new NullPointerException("value == null");
+    @Override
+    public MediaType contentType() {
+        return CONTENT_TYPE;
+    }
 
-      names.add(HttpUrl.canonicalize(name, FORM_ENCODE_SET, false, false, true, true, charset));
-      values.add(HttpUrl.canonicalize(value, FORM_ENCODE_SET, false, false, true, true, charset));
-      return this;
+    @Override
+    public long contentLength() {
+        return writeOrCountBytes(null, true);
     }
 
-    public Builder addEncoded(String name, String value) {
-      if (name == null) throw new NullPointerException("name == null");
-      if (value == null) throw new NullPointerException("value == null");
+    @Override
+    public void writeTo(BufferedSink sink) throws IOException {
+        writeOrCountBytes(sink, false);
+    }
 
-      names.add(HttpUrl.canonicalize(name, FORM_ENCODE_SET, true, false, true, true, charset));
-      values.add(HttpUrl.canonicalize(value, FORM_ENCODE_SET, true, false, true, true, charset));
-      return this;
+    /**
+     * Either writes this request to {@code sink} or measures its content length. We have one method
+     * do double-duty to make sure the counting and content are consistent, particularly when it comes
+     * to awkward operations like measuring the encoded length of header strings, or the
+     * length-in-digits of an encoded integer.
+     */
+    private long writeOrCountBytes(@Nullable BufferedSink sink, boolean countBytes) {
+        long byteCount = 0L;
+
+        Buffer buffer;
+        if (countBytes) {
+            buffer = new Buffer();
+        } else {
+            buffer = sink.buffer();
+        }
+
+        for (int i = 0, size = encodedNames.size(); i < size; i++) {
+            if (i > 0) buffer.writeByte('&');
+            buffer.writeUtf8(encodedNames.get(i));
+            buffer.writeByte('=');
+            buffer.writeUtf8(encodedValues.get(i));
+        }
+
+        if (countBytes) {
+            byteCount = buffer.size();
+            buffer.clear();
+        }
+
+        return byteCount;
     }
 
-    public FormBody build() {
-      return new FormBody(names, values);
+    public static final class Builder {
+        private final List<String> names = new ArrayList<>();
+        private final List<String> values = new ArrayList<>();
+        private final @Nullable
+        Charset charset;
+
+        public Builder() {
+            this(null);
+        }
+
+        public Builder(@Nullable Charset charset) {
+            this.charset = charset;
+        }
+
+        public Builder add(String name, String value) {
+            if (name == null) throw new NullPointerException("name == null");
+            if (value == null) throw new NullPointerException("value == null");
+
+            names.add(HttpUrl.canonicalize(name, FORM_ENCODE_SET, false, false, true, true, charset));
+            values.add(HttpUrl.canonicalize(value, FORM_ENCODE_SET, false, false, true, true, charset));
+            return this;
+        }
+
+        public Builder addEncoded(String name, String value) {
+            if (name == null) throw new NullPointerException("name == null");
+            if (value == null) throw new NullPointerException("value == null");
+
+            names.add(HttpUrl.canonicalize(name, FORM_ENCODE_SET, true, false, true, true, charset));
+            values.add(HttpUrl.canonicalize(value, FORM_ENCODE_SET, true, false, true, true, charset));
+            return this;
+        }
+
+        public FormBody build() {
+            return new FormBody(names, values);
+        }
     }
-  }
 }
diff --git a/okhttp/src/main/java/okhttp3/OkHttpClient.java b/okhttp/src/main/java/okhttp3/OkHttpClient.java
index 433982e136..1b5695a52e 100644
--- a/okhttp/src/main/java/okhttp3/OkHttpClient.java
+++ b/okhttp/src/main/java/okhttp3/OkHttpClient.java
@@ -35,6 +35,7 @@
 import javax.net.ssl.SSLSocketFactory;
 import javax.net.ssl.TrustManager;
 import javax.net.ssl.X509TrustManager;
+
 import okhttp3.internal.Internal;
 import okhttp3.internal.Util;
 import okhttp3.internal.cache.InternalCache;
@@ -124,934 +125,978 @@
  * remain idle.
  */
 public class OkHttpClient implements Cloneable, Call.Factory, WebSocket.Factory {
-  static final List<Protocol> DEFAULT_PROTOCOLS = Util.immutableList(
-      Protocol.HTTP_2, Protocol.HTTP_1_1);
-
-  static final List<ConnectionSpec> DEFAULT_CONNECTION_SPECS = Util.immutableList(
-      ConnectionSpec.MODERN_TLS, ConnectionSpec.CLEARTEXT);
-
-  static {
-    Internal.instance = new Internal() {
-      @Override public void addLenient(Headers.Builder builder, String line) {
-        builder.addLenient(line);
-      }
-
-      @Override public void addLenient(Headers.Builder builder, String name, String value) {
-        builder.addLenient(name, value);
-      }
-
-      @Override public void setCache(OkHttpClient.Builder builder, InternalCache internalCache) {
-        builder.setInternalCache(internalCache);
-      }
-
-      @Override public boolean connectionBecameIdle(
-          ConnectionPool pool, RealConnection connection) {
-        return pool.connectionBecameIdle(connection);
-      }
-
-      @Override public void acquire(ConnectionPool pool, Address address,
-          StreamAllocation streamAllocation, @Nullable Route route) {
-        pool.acquire(address, streamAllocation, route);
-      }
-
-      @Override public boolean equalsNonHost(Address a, Address b) {
-        return a.equalsNonHost(b);
-      }
-
-      @Override public @Nullable Socket deduplicate(
-          ConnectionPool pool, Address address, StreamAllocation streamAllocation) {
-        return pool.deduplicate(address, streamAllocation);
-      }
-
-      @Override public void put(ConnectionPool pool, RealConnection connection) {
-        pool.put(connection);
-      }
-
-      @Override public RouteDatabase routeDatabase(ConnectionPool connectionPool) {
-        return connectionPool.routeDatabase;
-      }
-
-      @Override public int code(Response.Builder responseBuilder) {
-        return responseBuilder.code;
-      }
-
-      @Override
-      public void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket, boolean isFallback) {
-        tlsConfiguration.apply(sslSocket, isFallback);
-      }
-
-      @Override public boolean isInvalidHttpUrlHost(IllegalArgumentException e) {
-        return e.getMessage().startsWith(HttpUrl.Builder.INVALID_HOST);
-      }
-
-      @Override public StreamAllocation streamAllocation(Call call) {
-        return ((RealCall) call).streamAllocation();
-      }
-
-      @Override public @Nullable IOException timeoutExit(Call call, @Nullable IOException e) {
-        return ((RealCall) call).timeoutExit(e);
-      }
-
-      @Override public Call newWebSocketCall(OkHttpClient client, Request originalRequest) {
-        return RealCall.newRealCall(client, originalRequest, true);
-      }
-
-      @Override public void initCodec(Response.Builder responseBuilder, HttpCodec httpCodec) {
-        responseBuilder.initCodec(httpCodec);
-      }
-    };
-  }
-
-  final Dispatcher dispatcher;
-  final @Nullable Proxy proxy;
-  final List<Protocol> protocols;
-  final List<ConnectionSpec> connectionSpecs;
-  final List<Interceptor> interceptors;
-  final List<Interceptor> networkInterceptors;
-  final EventListener.Factory eventListenerFactory;
-  final ProxySelector proxySelector;
-  final CookieJar cookieJar;
-  final @Nullable Cache cache;
-  final @Nullable InternalCache internalCache;
-  final SocketFactory socketFactory;
-  final SSLSocketFactory sslSocketFactory;
-  final CertificateChainCleaner certificateChainCleaner;
-  final HostnameVerifier hostnameVerifier;
-  final CertificatePinner certificatePinner;
-  final Authenticator proxyAuthenticator;
-  final Authenticator authenticator;
-  final ConnectionPool connectionPool;
-  final Dns dns;
-  final boolean followSslRedirects;
-  final boolean followRedirects;
-  final boolean retryOnConnectionFailure;
-  final int callTimeout;
-  final int connectTimeout;
-  final int readTimeout;
-  final int writeTimeout;
-  final int pingInterval;
-
-  public OkHttpClient() {
-    this(new Builder());
-  }
-
-  OkHttpClient(Builder builder) {
-    this.dispatcher = builder.dispatcher;
-    this.proxy = builder.proxy;
-    this.protocols = builder.protocols;
-    this.connectionSpecs = builder.connectionSpecs;
-    this.interceptors = Util.immutableList(builder.interceptors);
-    this.networkInterceptors = Util.immutableList(builder.networkInterceptors);
-    this.eventListenerFactory = builder.eventListenerFactory;
-    this.proxySelector = builder.proxySelector;
-    this.cookieJar = builder.cookieJar;
-    this.cache = builder.cache;
-    this.internalCache = builder.internalCache;
-    this.socketFactory = builder.socketFactory;
-
-    boolean isTLS = false;
-    for (ConnectionSpec spec : connectionSpecs) {
-      isTLS = isTLS || spec.isTls();
-    }
-
-    if (builder.sslSocketFactory != null || !isTLS) {
-      this.sslSocketFactory = builder.sslSocketFactory;
-      this.certificateChainCleaner = builder.certificateChainCleaner;
-    } else {
-      X509TrustManager trustManager = Util.platformTrustManager();
-      this.sslSocketFactory = newSslSocketFactory(trustManager);
-      this.certificateChainCleaner = CertificateChainCleaner.get(trustManager);
-    }
-
-    if (sslSocketFactory != null) {
-      Platform.get().configureSslSocketFactory(sslSocketFactory);
-    }
-
-    this.hostnameVerifier = builder.hostnameVerifier;
-    this.certificatePinner = builder.certificatePinner.withCertificateChainCleaner(
-        certificateChainCleaner);
-    this.proxyAuthenticator = builder.proxyAuthenticator;
-    this.authenticator = builder.authenticator;
-    this.connectionPool = builder.connectionPool;
-    this.dns = builder.dns;
-    this.followSslRedirects = builder.followSslRedirects;
-    this.followRedirects = builder.followRedirects;
-    this.retryOnConnectionFailure = builder.retryOnConnectionFailure;
-    this.callTimeout = builder.callTimeout;
-    this.connectTimeout = builder.connectTimeout;
-    this.readTimeout = builder.readTimeout;
-    this.writeTimeout = builder.writeTimeout;
-    this.pingInterval = builder.pingInterval;
-
-    if (interceptors.contains(null)) {
-      throw new IllegalStateException("Null interceptor: " + interceptors);
-    }
-    if (networkInterceptors.contains(null)) {
-      throw new IllegalStateException("Null network interceptor: " + networkInterceptors);
-    }
-  }
-
-  private static SSLSocketFactory newSslSocketFactory(X509TrustManager trustManager) {
-    try {
-      SSLContext sslContext = Platform.get().getSSLContext();
-      sslContext.init(null, new TrustManager[] { trustManager }, null);
-      return sslContext.getSocketFactory();
-    } catch (GeneralSecurityException e) {
-      throw new AssertionError("No System TLS", e); // The system has no TLS. Just give up.
-    }
-  }
-
-  /**
-   * Default call timeout (in milliseconds). By default there is no timeout for complete calls, but
-   * there is for the connect, write, and read actions within a call.
-   */
-  public int callTimeoutMillis() {
-    return callTimeout;
-  }
-
-  /** Default connect timeout (in milliseconds). The default is 10 seconds. */
-  public int connectTimeoutMillis() {
-    return connectTimeout;
-  }
-
-  /** Default read timeout (in milliseconds). The default is 10 seconds. */
-  public int readTimeoutMillis() {
-    return readTimeout;
-  }
-
-  /** Default write timeout (in milliseconds). The default is 10 seconds. */
-  public int writeTimeoutMillis() {
-    return writeTimeout;
-  }
-
-  /** Web socket and HTTP/2 ping interval (in milliseconds). By default pings are not sent. */
-  public int pingIntervalMillis() {
-    return pingInterval;
-  }
-
-  public @Nullable Proxy proxy() {
-    return proxy;
-  }
-
-  public ProxySelector proxySelector() {
-    return proxySelector;
-  }
-
-  public CookieJar cookieJar() {
-    return cookieJar;
-  }
-
-  public @Nullable Cache cache() {
-    return cache;
-  }
-
-  @Nullable InternalCache internalCache() {
-    return cache != null ? cache.internalCache : internalCache;
-  }
-
-  public Dns dns() {
-    return dns;
-  }
-
-  public SocketFactory socketFactory() {
-    return socketFactory;
-  }
-
-  public SSLSocketFactory sslSocketFactory() {
-    return sslSocketFactory;
-  }
-
-  public HostnameVerifier hostnameVerifier() {
-    return hostnameVerifier;
-  }
-
-  public CertificatePinner certificatePinner() {
-    return certificatePinner;
-  }
-
-  public Authenticator authenticator() {
-    return authenticator;
-  }
-
-  public Authenticator proxyAuthenticator() {
-    return proxyAuthenticator;
-  }
-
-  public ConnectionPool connectionPool() {
-    return connectionPool;
-  }
-
-  public boolean followSslRedirects() {
-    return followSslRedirects;
-  }
-
-  public boolean followRedirects() {
-    return followRedirects;
-  }
-
-  public boolean retryOnConnectionFailure() {
-    return retryOnConnectionFailure;
-  }
-
-  public Dispatcher dispatcher() {
-    return dispatcher;
-  }
-
-  public List<Protocol> protocols() {
-    return protocols;
-  }
-
-  public List<ConnectionSpec> connectionSpecs() {
-    return connectionSpecs;
-  }
-
-  /**
-   * Returns an immutable list of interceptors that observe the full span of each call: from before
-   * the connection is established (if any) until after the response source is selected (either the
-   * origin server, cache, or both).
-   */
-  public List<Interceptor> interceptors() {
-    return interceptors;
-  }
-
-  /**
-   * Returns an immutable list of interceptors that observe a single network request and response.
-   * These interceptors must call {@link Interceptor.Chain#proceed} exactly once: it is an error for
-   * a network interceptor to short-circuit or repeat a network request.
-   */
-  public List<Interceptor> networkInterceptors() {
-    return networkInterceptors;
-  }
-
-  public EventListener.Factory eventListenerFactory() {
-    return eventListenerFactory;
-  }
-
-  /**
-   * Prepares the {@code request} to be executed at some point in the future.
-   */
-  @Override public Call newCall(Request request) {
-    return RealCall.newRealCall(this, request, false /* for web socket */);
-  }
-
-  /**
-   * Uses {@code request} to connect a new web socket.
-   */
-  @Override public WebSocket newWebSocket(Request request, WebSocketListener listener) {
-    RealWebSocket webSocket = new RealWebSocket(request, listener, new Random(), pingInterval);
-    webSocket.connect(this);
-    return webSocket;
-  }
-
-  public Builder newBuilder() {
-    return new Builder(this);
-  }
-
-  public static final class Builder {
-    Dispatcher dispatcher;
-    @Nullable Proxy proxy;
-    List<Protocol> protocols;
-    List<ConnectionSpec> connectionSpecs;
-    final List<Interceptor> interceptors = new ArrayList<>();
-    final List<Interceptor> networkInterceptors = new ArrayList<>();
-    EventListener.Factory eventListenerFactory;
-    ProxySelector proxySelector;
-    CookieJar cookieJar;
-    @Nullable Cache cache;
-    @Nullable InternalCache internalCache;
-    SocketFactory socketFactory;
-    @Nullable SSLSocketFactory sslSocketFactory;
-    @Nullable CertificateChainCleaner certificateChainCleaner;
-    HostnameVerifier hostnameVerifier;
-    CertificatePinner certificatePinner;
-    Authenticator proxyAuthenticator;
-    Authenticator authenticator;
-    ConnectionPool connectionPool;
-    Dns dns;
-    boolean followSslRedirects;
-    boolean followRedirects;
-    boolean retryOnConnectionFailure;
-    int callTimeout;
-    int connectTimeout;
-    int readTimeout;
-    int writeTimeout;
-    int pingInterval;
-
-    public Builder() {
-      dispatcher = new Dispatcher();
-      protocols = DEFAULT_PROTOCOLS;
-      connectionSpecs = DEFAULT_CONNECTION_SPECS;
-      eventListenerFactory = EventListener.factory(EventListener.NONE);
-      proxySelector = ProxySelector.getDefault();
-      if (proxySelector == null) {
-        proxySelector = new NullProxySelector();
-      }
-      cookieJar = CookieJar.NO_COOKIES;
-      socketFactory = SocketFactory.getDefault();
-      hostnameVerifier = OkHostnameVerifier.INSTANCE;
-      certificatePinner = CertificatePinner.DEFAULT;
-      proxyAuthenticator = Authenticator.NONE;
-      authenticator = Authenticator.NONE;
-      connectionPool = new ConnectionPool();
-      dns = Dns.SYSTEM;
-      followSslRedirects = true;
-      followRedirects = true;
-      retryOnConnectionFailure = true;
-      callTimeout = 0;
-      connectTimeout = 10_000;
-      readTimeout = 10_000;
-      writeTimeout = 10_000;
-      pingInterval = 0;
-    }
-
-    Builder(OkHttpClient okHttpClient) {
-      this.dispatcher = okHttpClient.dispatcher;
-      this.proxy = okHttpClient.proxy;
-      this.protocols = okHttpClient.protocols;
-      this.connectionSpecs = okHttpClient.connectionSpecs;
-      this.interceptors.addAll(okHttpClient.interceptors);
-      this.networkInterceptors.addAll(okHttpClient.networkInterceptors);
-      this.eventListenerFactory = okHttpClient.eventListenerFactory;
-      this.proxySelector = okHttpClient.proxySelector;
-      this.cookieJar = okHttpClient.cookieJar;
-      this.internalCache = okHttpClient.internalCache;
-      this.cache = okHttpClient.cache;
-      this.socketFactory = okHttpClient.socketFactory;
-      this.sslSocketFactory = okHttpClient.sslSocketFactory;
-      this.certificateChainCleaner = okHttpClient.certificateChainCleaner;
-      this.hostnameVerifier = okHttpClient.hostnameVerifier;
-      this.certificatePinner = okHttpClient.certificatePinner;
-      this.proxyAuthenticator = okHttpClient.proxyAuthenticator;
-      this.authenticator = okHttpClient.authenticator;
-      this.connectionPool = okHttpClient.connectionPool;
-      this.dns = okHttpClient.dns;
-      this.followSslRedirects = okHttpClient.followSslRedirects;
-      this.followRedirects = okHttpClient.followRedirects;
-      this.retryOnConnectionFailure = okHttpClient.retryOnConnectionFailure;
-      this.callTimeout = okHttpClient.callTimeout;
-      this.connectTimeout = okHttpClient.connectTimeout;
-      this.readTimeout = okHttpClient.readTimeout;
-      this.writeTimeout = okHttpClient.writeTimeout;
-      this.pingInterval = okHttpClient.pingInterval;
-    }
-
-    /**
-     * Sets the default timeout for complete calls. A value of 0 means no timeout, otherwise values
-     * must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
-     *
-     * <p>The call timeout spans the entire call: resolving DNS, connecting, writing the request
-     * body, server processing, and reading the response body. If the call requires redirects or
-     * retries all must complete within one timeout period.
-     *
-     * <p>The default value is 0 which imposes no timeout.
-     */
-    public Builder callTimeout(long timeout, TimeUnit unit) {
-      callTimeout = checkDuration("timeout", timeout, unit);
-      return this;
+    static final List<Protocol> DEFAULT_PROTOCOLS = Util.immutableList(
+            Protocol.HTTP_2, Protocol.HTTP_1_1);
+
+    static final List<ConnectionSpec> DEFAULT_CONNECTION_SPECS = Util.immutableList(
+            ConnectionSpec.MODERN_TLS, ConnectionSpec.CLEARTEXT);
+
+    static {
+        Internal.instance = new Internal() {
+            @Override
+            public void addLenient(Headers.Builder builder, String line) {
+                builder.addLenient(line);
+            }
+
+            @Override
+            public void addLenient(Headers.Builder builder, String name, String value) {
+                builder.addLenient(name, value);
+            }
+
+            @Override
+            public void setCache(OkHttpClient.Builder builder, InternalCache internalCache) {
+                builder.setInternalCache(internalCache);
+            }
+
+            @Override
+            public boolean connectionBecameIdle(
+                    ConnectionPool pool, RealConnection connection) {
+                return pool.connectionBecameIdle(connection);
+            }
+
+            @Override
+            public void acquire(ConnectionPool pool, Address address,
+                                StreamAllocation streamAllocation, @Nullable Route route) {
+                pool.acquire(address, streamAllocation, route);
+            }
+
+            @Override
+            public boolean equalsNonHost(Address a, Address b) {
+                return a.equalsNonHost(b);
+            }
+
+            @Override
+            public @Nullable
+            Socket deduplicate(
+                    ConnectionPool pool, Address address, StreamAllocation streamAllocation) {
+                return pool.deduplicate(address, streamAllocation);
+            }
+
+            @Override
+            public void put(ConnectionPool pool, RealConnection connection) {
+                pool.put(connection);
+            }
+
+            @Override
+            public RouteDatabase routeDatabase(ConnectionPool connectionPool) {
+                return connectionPool.routeDatabase;
+            }
+
+            @Override
+            public int code(Response.Builder responseBuilder) {
+                return responseBuilder.code;
+            }
+
+            @Override
+            public void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket, boolean isFallback) {
+                tlsConfiguration.apply(sslSocket, isFallback);
+            }
+
+            @Override
+            public boolean isInvalidHttpUrlHost(IllegalArgumentException e) {
+                return e.getMessage().startsWith(HttpUrl.Builder.INVALID_HOST);
+            }
+
+            @Override
+            public StreamAllocation streamAllocation(Call call) {
+                return ((RealCall) call).streamAllocation();
+            }
+
+            @Override
+            public @Nullable
+            IOException timeoutExit(Call call, @Nullable IOException e) {
+                return ((RealCall) call).timeoutExit(e);
+            }
+
+            @Override
+            public Call newWebSocketCall(OkHttpClient client, Request originalRequest) {
+                return RealCall.newRealCall(client, originalRequest, true);
+            }
+
+            @Override
+            public void initCodec(Response.Builder responseBuilder, HttpCodec httpCodec) {
+                responseBuilder.initCodec(httpCodec);
+            }
+        };
     }
 
-    /**
-     * Sets the default timeout for complete calls. A value of 0 means no timeout, otherwise values
-     * must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
-     *
-     * <p>The call timeout spans the entire call: resolving DNS, connecting, writing the request
-     * body, server processing, and reading the response body. If the call requires redirects or
-     * retries all must complete within one timeout period.
-     *
-     * <p>The default value is 0 which imposes no timeout.
-     */
-    @IgnoreJRERequirement
-    public Builder callTimeout(Duration duration) {
-      callTimeout = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS);
-      return this;
-    }
-
-    /**
-     * Sets the default connect timeout for new connections. A value of 0 means no timeout,
-     * otherwise values must be between 1 and {@link Integer#MAX_VALUE} when converted to
-     * milliseconds.
-     *
-     * <p>The connect timeout is applied when connecting a TCP socket to the target host.
-     * The default value is 10 seconds.
-     */
-    public Builder connectTimeout(long timeout, TimeUnit unit) {
-      connectTimeout = checkDuration("timeout", timeout, unit);
-      return this;
-    }
-
-    /**
-     * Sets the default connect timeout for new connections. A value of 0 means no timeout,
-     * otherwise values must be between 1 and {@link Integer#MAX_VALUE} when converted to
-     * milliseconds.
-     *
-     * <p>The connect timeout is applied when connecting a TCP socket to the target host.
-     * The default value is 10 seconds.
-     */
-    @IgnoreJRERequirement
-    public Builder connectTimeout(Duration duration) {
-      connectTimeout = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS);
-      return this;
+    final Dispatcher dispatcher;
+    final @Nullable
+    Proxy proxy;
+    final List<Protocol> protocols;
+    final List<ConnectionSpec> connectionSpecs;
+    final List<Interceptor> interceptors;
+    final List<Interceptor> networkInterceptors;
+    final EventListener.Factory eventListenerFactory;
+    final ProxySelector proxySelector;
+    final CookieJar cookieJar;
+    final @Nullable
+    Cache cache;
+    final @Nullable
+    InternalCache internalCache;
+    final SocketFactory socketFactory;
+    final SSLSocketFactory sslSocketFactory;
+    final CertificateChainCleaner certificateChainCleaner;
+    final HostnameVerifier hostnameVerifier;
+    final CertificatePinner certificatePinner;
+    final Authenticator proxyAuthenticator;
+    final Authenticator authenticator;
+    final ConnectionPool connectionPool;
+    final Dns dns;
+    final boolean followSslRedirects;
+    final boolean followRedirects;
+    final boolean retryOnConnectionFailure;
+    final int callTimeout;
+    final int connectTimeout;
+    final int readTimeout;
+    final int writeTimeout;
+    final int pingInterval;
+
+    public OkHttpClient() {
+        this(new Builder());
     }
 
-    /**
-     * Sets the default read timeout for new connections. A value of 0 means no timeout, otherwise
-     * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
-     *
-     * <p>The read timeout is applied to both the TCP socket and for individual read IO operations
-     * including on {@link Source} of the {@link Response}. The default value is 10 seconds.
-     *
-     * @see Socket#setSoTimeout(int)
-     * @see Source#timeout()
-     */
-    public Builder readTimeout(long timeout, TimeUnit unit) {
-      readTimeout = checkDuration("timeout", timeout, unit);
-      return this;
+    OkHttpClient(Builder builder) {
+        this.dispatcher = builder.dispatcher;
+        this.proxy = builder.proxy;
+        this.protocols = builder.protocols;
+        this.connectionSpecs = builder.connectionSpecs;
+        this.interceptors = Util.immutableList(builder.interceptors);
+        this.networkInterceptors = Util.immutableList(builder.networkInterceptors);
+        this.eventListenerFactory = builder.eventListenerFactory;
+        this.proxySelector = builder.proxySelector;
+        this.cookieJar = builder.cookieJar;
+        this.cache = builder.cache;
+        this.internalCache = builder.internalCache;
+        this.socketFactory = builder.socketFactory;
+
+        boolean isTLS = false;
+        for (ConnectionSpec spec : connectionSpecs) {
+            isTLS = isTLS || spec.isTls();
+        }
+
+        if (builder.sslSocketFactory != null || !isTLS) {
+            this.sslSocketFactory = builder.sslSocketFactory;
+            this.certificateChainCleaner = builder.certificateChainCleaner;
+        } else {
+            X509TrustManager trustManager = Util.platformTrustManager();
+            this.sslSocketFactory = newSslSocketFactory(trustManager);
+            this.certificateChainCleaner = CertificateChainCleaner.get(trustManager);
+        }
+
+        if (sslSocketFactory != null) {
+            Platform.get().configureSslSocketFactory(sslSocketFactory);
+        }
+
+        this.hostnameVerifier = builder.hostnameVerifier;
+        this.certificatePinner = builder.certificatePinner.withCertificateChainCleaner(
+                certificateChainCleaner);
+        this.proxyAuthenticator = builder.proxyAuthenticator;
+        this.authenticator = builder.authenticator;
+        this.connectionPool = builder.connectionPool;
+        this.dns = builder.dns;
+        this.followSslRedirects = builder.followSslRedirects;
+        this.followRedirects = builder.followRedirects;
+        this.retryOnConnectionFailure = builder.retryOnConnectionFailure;
+        this.callTimeout = builder.callTimeout;
+        this.connectTimeout = builder.connectTimeout;
+        this.readTimeout = builder.readTimeout;
+        this.writeTimeout = builder.writeTimeout;
+        this.pingInterval = builder.pingInterval;
+
+        if (interceptors.contains(null)) {
+            throw new IllegalStateException("Null interceptor: " + interceptors);
+        }
+        if (networkInterceptors.contains(null)) {
+            throw new IllegalStateException("Null network interceptor: " + networkInterceptors);
+        }
     }
 
-    /**
-     * Sets the default read timeout for new connections. A value of 0 means no timeout, otherwise
-     * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
-     *
-     * <p>The read timeout is applied to both the TCP socket and for individual read IO operations
-     * including on {@link Source} of the {@link Response}. The default value is 10 seconds.
-     *
-     * @see Socket#setSoTimeout(int)
-     * @see Source#timeout()
-     */
-    @IgnoreJRERequirement
-    public Builder readTimeout(Duration duration) {
-      readTimeout = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS);
-      return this;
+    private static SSLSocketFactory newSslSocketFactory(X509TrustManager trustManager) {
+        try {
+            SSLContext sslContext = Platform.get().getSSLContext();
+            sslContext.init(null, new TrustManager[]{trustManager}, null);
+            return sslContext.getSocketFactory();
+        } catch (GeneralSecurityException e) {
+            throw new AssertionError("No System TLS", e); // The system has no TLS. Just give up.
+        }
     }
 
     /**
-     * Sets the default write timeout for new connections. A value of 0 means no timeout, otherwise
-     * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
-     *
-     * <p>The write timeout is applied for individual write IO operations.
-     * The default value is 10 seconds.
-     *
-     * @see Sink#timeout()
+     * Default call timeout (in milliseconds). By default there is no timeout for complete calls, but
+     * there is for the connect, write, and read actions within a call.
      */
-    public Builder writeTimeout(long timeout, TimeUnit unit) {
-      writeTimeout = checkDuration("timeout", timeout, unit);
-      return this;
+    public int callTimeoutMillis() {
+        return callTimeout;
     }
 
     /**
-     * Sets the default write timeout for new connections. A value of 0 means no timeout, otherwise
-     * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
-     *
-     * <p>The write timeout is applied for individual write IO operations.
-     * The default value is 10 seconds.
-     *
-     * @see Sink#timeout()
+     * Default connect timeout (in milliseconds). The default is 10 seconds.
      */
-    @IgnoreJRERequirement
-    public Builder writeTimeout(Duration duration) {
-      writeTimeout = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS);
-      return this;
+    public int connectTimeoutMillis() {
+        return connectTimeout;
     }
 
     /**
-     * Sets the interval between HTTP/2 and web socket pings initiated by this client. Use this to
-     * automatically send ping frames until either the connection fails or it is closed. This keeps
-     * the connection alive and may detect connectivity failures.
-     *
-     * <p>If the server does not respond to each ping with a pong within {@code interval}, this
-     * client will assume that connectivity has been lost. When this happens on a web socket the
-     * connection is canceled and its listener is {@linkplain WebSocketListener#onFailure notified
-     * of the failure}. When it happens on an HTTP/2 connection the connection is closed and any
-     * calls it is carrying {@linkplain java.io.IOException will fail with an IOException}.
-     *
-     * <p>The default value of 0 disables client-initiated pings.
+     * Default read timeout (in milliseconds). The default is 10 seconds.
      */
-    public Builder pingInterval(long interval, TimeUnit unit) {
-      pingInterval = checkDuration("interval", interval, unit);
-      return this;
+    public int readTimeoutMillis() {
+        return readTimeout;
     }
 
     /**
-     * Sets the interval between HTTP/2 and web socket pings initiated by this client. Use this to
-     * automatically send ping frames until either the connection fails or it is closed. This keeps
-     * the connection alive and may detect connectivity failures.
-     *
-     * <p>If the server does not respond to each ping with a pong within {@code interval}, this
-     * client will assume that connectivity has been lost. When this happens on a web socket the
-     * connection is canceled and its listener is {@linkplain WebSocketListener#onFailure notified
-     * of the failure}. When it happens on an HTTP/2 connection the connection is closed and any
-     * calls it is carrying {@linkplain java.io.IOException will fail with an IOException}.
-     *
-     * <p>The default value of 0 disables client-initiated pings.
+     * Default write timeout (in milliseconds). The default is 10 seconds.
      */
-    @IgnoreJRERequirement
-    public Builder pingInterval(Duration duration) {
-      pingInterval = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS);
-      return this;
+    public int writeTimeoutMillis() {
+        return writeTimeout;
     }
 
     /**
-     * Sets the HTTP proxy that will be used by connections created by this client. This takes
-     * precedence over {@link #proxySelector}, which is only honored when this proxy is null (which
-     * it is by default). To disable proxy use completely, call {@code proxy(Proxy.NO_PROXY)}.
+     * Web socket and HTTP/2 ping interval (in milliseconds). By default pings are not sent.
      */
-    public Builder proxy(@Nullable Proxy proxy) {
-      this.proxy = proxy;
-      return this;
+    public int pingIntervalMillis() {
+        return pingInterval;
     }
 
-    /**
-     * Sets the proxy selection policy to be used if no {@link #proxy proxy} is specified
-     * explicitly. The proxy selector may return multiple proxies; in that case they will be tried
-     * in sequence until a successful connection is established.
-     *
-     * <p>If unset, the {@link ProxySelector#getDefault() system-wide default} proxy selector will
-     * be used.
-     */
-    public Builder proxySelector(ProxySelector proxySelector) {
-      if (proxySelector == null) throw new NullPointerException("proxySelector == null");
-      this.proxySelector = proxySelector;
-      return this;
+    public @Nullable
+    Proxy proxy() {
+        return proxy;
     }
 
-    /**
-     * Sets the handler that can accept cookies from incoming HTTP responses and provides cookies to
-     * outgoing HTTP requests.
-     *
-     * <p>If unset, {@linkplain CookieJar#NO_COOKIES no cookies} will be accepted nor provided.
-     */
-    public Builder cookieJar(CookieJar cookieJar) {
-      if (cookieJar == null) throw new NullPointerException("cookieJar == null");
-      this.cookieJar = cookieJar;
-      return this;
+    public ProxySelector proxySelector() {
+        return proxySelector;
     }
 
-    /** Sets the response cache to be used to read and write cached responses. */
-    void setInternalCache(@Nullable InternalCache internalCache) {
-      this.internalCache = internalCache;
-      this.cache = null;
+    public CookieJar cookieJar() {
+        return cookieJar;
     }
 
-    /** Sets the response cache to be used to read and write cached responses. */
-    public Builder cache(@Nullable Cache cache) {
-      this.cache = cache;
-      this.internalCache = null;
-      return this;
+    public @Nullable
+    Cache cache() {
+        return cache;
     }
 
-    /**
-     * Sets the DNS service used to lookup IP addresses for hostnames.
-     *
-     * <p>If unset, the {@link Dns#SYSTEM system-wide default} DNS will be used.
-     */
-    public Builder dns(Dns dns) {
-      if (dns == null) throw new NullPointerException("dns == null");
-      this.dns = dns;
-      return this;
+    @Nullable
+    InternalCache internalCache() {
+        return cache != null ? cache.internalCache : internalCache;
     }
 
-    /**
-     * Sets the socket factory used to create connections. OkHttp only uses the parameterless {@link
-     * SocketFactory#createSocket() createSocket()} method to create unconnected sockets. Overriding
-     * this method, e. g., allows the socket to be bound to a specific local address.
-     *
-     * <p>If unset, the {@link SocketFactory#getDefault() system-wide default} socket factory will
-     * be used.
-     */
-    public Builder socketFactory(SocketFactory socketFactory) {
-      if (socketFactory == null) throw new NullPointerException("socketFactory == null");
-      if (socketFactory instanceof SSLSocketFactory) {
-        throw new IllegalArgumentException("socketFactory instanceof SSLSocketFactory");
-      }
-      this.socketFactory = socketFactory;
-      return this;
+    public Dns dns() {
+        return dns;
     }
 
-    /**
-     * Sets the socket factory used to secure HTTPS connections. If unset, the system default will
-     * be used.
-     *
-     * @deprecated {@code SSLSocketFactory} does not expose its {@link X509TrustManager}, which is
-     *     a field that OkHttp needs to build a clean certificate chain. This method instead must
-     *     use reflection to extract the trust manager. Applications should prefer to call {@link
-     *     #sslSocketFactory(SSLSocketFactory, X509TrustManager)}, which avoids such reflection.
-     */
-    public Builder sslSocketFactory(SSLSocketFactory sslSocketFactory) {
-      if (sslSocketFactory == null) throw new NullPointerException("sslSocketFactory == null");
-      this.sslSocketFactory = sslSocketFactory;
-      this.certificateChainCleaner = Platform.get().buildCertificateChainCleaner(sslSocketFactory);
-      return this;
+    public SocketFactory socketFactory() {
+        return socketFactory;
     }
 
-    /**
-     * Sets the socket factory and trust manager used to secure HTTPS connections. If unset, the
-     * system defaults will be used.
-     *
-     * <p>Most applications should not call this method, and instead use the system defaults. Those
-     * classes include special optimizations that can be lost if the implementations are decorated.
-     *
-     * <p>If necessary, you can create and configure the defaults yourself with the following code:
-     *
-     * <pre>   {@code
-     *
-     *   TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
-     *       TrustManagerFactory.getDefaultAlgorithm());
-     *   trustManagerFactory.init((KeyStore) null);
-     *   TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
-     *   if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {
-     *     throw new IllegalStateException("Unexpected default trust managers:"
-     *         + Arrays.toString(trustManagers));
-     *   }
-     *   X509TrustManager trustManager = (X509TrustManager) trustManagers[0];
-     *
-     *   SSLContext sslContext = SSLContext.getInstance("TLS");
-     *   sslContext.init(null, new TrustManager[] { trustManager }, null);
-     *   SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();
-     *
-     *   OkHttpClient client = new OkHttpClient.Builder()
-     *       .sslSocketFactory(sslSocketFactory, trustManager)
-     *       .build();
-     * }</pre>
-     */
-    public Builder sslSocketFactory(
-        SSLSocketFactory sslSocketFactory, X509TrustManager trustManager) {
-      if (sslSocketFactory == null) throw new NullPointerException("sslSocketFactory == null");
-      if (trustManager == null) throw new NullPointerException("trustManager == null");
-      this.sslSocketFactory = sslSocketFactory;
-      this.certificateChainCleaner = CertificateChainCleaner.get(trustManager);
-      return this;
+    public SSLSocketFactory sslSocketFactory() {
+        return sslSocketFactory;
     }
 
-    /**
-     * Sets the verifier used to confirm that response certificates apply to requested hostnames for
-     * HTTPS connections.
-     *
-     * <p>If unset, a default hostname verifier will be used.
-     */
-    public Builder hostnameVerifier(HostnameVerifier hostnameVerifier) {
-      if (hostnameVerifier == null) throw new NullPointerException("hostnameVerifier == null");
-      this.hostnameVerifier = hostnameVerifier;
-      return this;
+    public HostnameVerifier hostnameVerifier() {
+        return hostnameVerifier;
     }
 
-    /**
-     * Sets the certificate pinner that constrains which certificates are trusted. By default HTTPS
-     * connections rely on only the {@link #sslSocketFactory SSL socket factory} to establish trust.
-     * Pinning certificates avoids the need to trust certificate authorities.
-     */
-    public Builder certificatePinner(CertificatePinner certificatePinner) {
-      if (certificatePinner == null) throw new NullPointerException("certificatePinner == null");
-      this.certificatePinner = certificatePinner;
-      return this;
+    public CertificatePinner certificatePinner() {
+        return certificatePinner;
     }
 
-    /**
-     * Sets the authenticator used to respond to challenges from origin servers. Use {@link
-     * #proxyAuthenticator} to set the authenticator for proxy servers.
-     *
-     * <p>If unset, the {@linkplain Authenticator#NONE no authentication will be attempted}.
-     */
-    public Builder authenticator(Authenticator authenticator) {
-      if (authenticator == null) throw new NullPointerException("authenticator == null");
-      this.authenticator = authenticator;
-      return this;
+    public Authenticator authenticator() {
+        return authenticator;
     }
 
-    /**
-     * Sets the authenticator used to respond to challenges from proxy servers. Use {@link
-     * #authenticator} to set the authenticator for origin servers.
-     *
-     * <p>If unset, the {@linkplain Authenticator#NONE no authentication will be attempted}.
-     */
-    public Builder proxyAuthenticator(Authenticator proxyAuthenticator) {
-      if (proxyAuthenticator == null) throw new NullPointerException("proxyAuthenticator == null");
-      this.proxyAuthenticator = proxyAuthenticator;
-      return this;
+    public Authenticator proxyAuthenticator() {
+        return proxyAuthenticator;
     }
 
-    /**
-     * Sets the connection pool used to recycle HTTP and HTTPS connections.
-     *
-     * <p>If unset, a new connection pool will be used.
-     */
-    public Builder connectionPool(ConnectionPool connectionPool) {
-      if (connectionPool == null) throw new NullPointerException("connectionPool == null");
-      this.connectionPool = connectionPool;
-      return this;
+    public ConnectionPool connectionPool() {
+        return connectionPool;
     }
 
-    /**
-     * Configure this client to follow redirects from HTTPS to HTTP and from HTTP to HTTPS.
-     *
-     * <p>If unset, protocol redirects will be followed. This is different than the built-in {@code
-     * HttpURLConnection}'s default.
-     */
-    public Builder followSslRedirects(boolean followProtocolRedirects) {
-      this.followSslRedirects = followProtocolRedirects;
-      return this;
+    public boolean followSslRedirects() {
+        return followSslRedirects;
     }
 
-    /** Configure this client to follow redirects. If unset, redirects will be followed. */
-    public Builder followRedirects(boolean followRedirects) {
-      this.followRedirects = followRedirects;
-      return this;
+    public boolean followRedirects() {
+        return followRedirects;
     }
 
-    /**
-     * Configure this client to retry or not when a connectivity problem is encountered. By default,
-     * this client silently recovers from the following problems:
-     *
-     * <ul>
-     *   <li><strong>Unreachable IP addresses.</strong> If the URL's host has multiple IP addresses,
-     *       failure to reach any individual IP address doesn't fail the overall request. This can
-     *       increase availability of multi-homed services.
-     *   <li><strong>Stale pooled connections.</strong> The {@link ConnectionPool} reuses sockets
-     *       to decrease request latency, but these connections will occasionally time out.
-     *   <li><strong>Unreachable proxy servers.</strong> A {@link ProxySelector} can be used to
-     *       attempt multiple proxy servers in sequence, eventually falling back to a direct
-     *       connection.
-     * </ul>
-     *
-     * Set this to false to avoid retrying requests when doing so is destructive. In this case the
-     * calling application should do its own recovery of connectivity failures.
-     */
-    public Builder retryOnConnectionFailure(boolean retryOnConnectionFailure) {
-      this.retryOnConnectionFailure = retryOnConnectionFailure;
-      return this;
+    public boolean retryOnConnectionFailure() {
+        return retryOnConnectionFailure;
     }
 
-    /**
-     * Sets the dispatcher used to set policy and execute asynchronous requests. Must not be null.
-     */
-    public Builder dispatcher(Dispatcher dispatcher) {
-      if (dispatcher == null) throw new IllegalArgumentException("dispatcher == null");
-      this.dispatcher = dispatcher;
-      return this;
+    public Dispatcher dispatcher() {
+        return dispatcher;
     }
 
-    /**
-     * Configure the protocols used by this client to communicate with remote servers. By default
-     * this client will prefer the most efficient transport available, falling back to more
-     * ubiquitous protocols. Applications should only call this method to avoid specific
-     * compatibility problems, such as web servers that behave incorrectly when HTTP/2 is enabled.
-     *
-     * <p>The following protocols are currently supported:
-     *
-     * <ul>
-     *     <li><a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html">http/1.1</a>
-     *     <li><a href="https://tools.ietf.org/html/rfc7540">h2</a>
-     *     <li><a href="https://tools.ietf.org/html/rfc7540#section-3.4">h2 with prior knowledge
-     *         (cleartext only)</a>
-     * </ul>
-     *
-     * <p><strong>This is an evolving set.</strong> Future releases include support for transitional
-     * protocols. The http/1.1 transport will never be dropped.
-     *
-     * <p>If multiple protocols are specified, <a
-     * href="http://tools.ietf.org/html/draft-ietf-tls-applayerprotoneg">ALPN</a> will be used to
-     * negotiate a transport. Protocol negotiation is only attempted for HTTPS URLs.
-     *
-     * <p>{@link Protocol#HTTP_1_0} is not supported in this set. Requests are initiated with {@code
-     * HTTP/1.1}. If the server responds with {@code HTTP/1.0}, that will be exposed by {@link
-     * Response#protocol()}.
-     *
-     * @param protocols the protocols to use, in order of preference. If the list contains {@link
-     *     Protocol#H2_PRIOR_KNOWLEDGE} then that must be the only protocol and HTTPS URLs will not
-     *     be supported. Otherwise the list must contain {@link Protocol#HTTP_1_1}. The list must
-     *     not contain null or {@link Protocol#HTTP_1_0}.
-     */
-    public Builder protocols(List<Protocol> protocols) {
-      // Create a private copy of the list.
-      protocols = new ArrayList<>(protocols);
-
-      // Validate that the list has everything we require and nothing we forbid.
-      if (!protocols.contains(Protocol.H2_PRIOR_KNOWLEDGE)
-          && !protocols.contains(Protocol.HTTP_1_1)) {
-        throw new IllegalArgumentException(
-            "protocols must contain h2_prior_knowledge or http/1.1: " + protocols);
-      }
-      if (protocols.contains(Protocol.H2_PRIOR_KNOWLEDGE) && protocols.size() > 1) {
-        throw new IllegalArgumentException(
-            "protocols containing h2_prior_knowledge cannot use other protocols: " + protocols);
-      }
-      if (protocols.contains(Protocol.HTTP_1_0)) {
-        throw new IllegalArgumentException("protocols must not contain http/1.0: " + protocols);
-      }
-      if (protocols.contains(null)) {
-        throw new IllegalArgumentException("protocols must not contain null");
-      }
-
-      // Remove protocols that we no longer support.
-      protocols.remove(Protocol.SPDY_3);
-
-      // Assign as an unmodifiable list. This is effectively immutable.
-      this.protocols = Collections.unmodifiableList(protocols);
-      return this;
+    public List<Protocol> protocols() {
+        return protocols;
     }
 
-    public Builder connectionSpecs(List<ConnectionSpec> connectionSpecs) {
-      this.connectionSpecs = Util.immutableList(connectionSpecs);
-      return this;
+    public List<ConnectionSpec> connectionSpecs() {
+        return connectionSpecs;
     }
 
     /**
-     * Returns a modifiable list of interceptors that observe the full span of each call: from
-     * before the connection is established (if any) until after the response source is selected
-     * (either the origin server, cache, or both).
+     * Returns an immutable list of interceptors that observe the full span of each call: from before
+     * the connection is established (if any) until after the response source is selected (either the
+     * origin server, cache, or both).
      */
     public List<Interceptor> interceptors() {
-      return interceptors;
-    }
-
-    public Builder addInterceptor(Interceptor interceptor) {
-      if (interceptor == null) throw new IllegalArgumentException("interceptor == null");
-      interceptors.add(interceptor);
-      return this;
+        return interceptors;
     }
 
     /**
-     * Returns a modifiable list of interceptors that observe a single network request and response.
-     * These interceptors must call {@link Interceptor.Chain#proceed} exactly once: it is an error
-     * for a network interceptor to short-circuit or repeat a network request.
+     * Returns an immutable list of interceptors that observe a single network request and response.
+     * These interceptors must call {@link Interceptor.Chain#proceed} exactly once: it is an error for
+     * a network interceptor to short-circuit or repeat a network request.
      */
     public List<Interceptor> networkInterceptors() {
-      return networkInterceptors;
+        return networkInterceptors;
     }
 
-    public Builder addNetworkInterceptor(Interceptor interceptor) {
-      if (interceptor == null) throw new IllegalArgumentException("interceptor == null");
-      networkInterceptors.add(interceptor);
-      return this;
+    public EventListener.Factory eventListenerFactory() {
+        return eventListenerFactory;
     }
 
     /**
-     * Configure a single client scoped listener that will receive all analytic events
-     * for this client.
-     *
-     * @see EventListener for semantics and restrictions on listener implementations.
+     * Prepares the {@code request} to be executed at some point in the future.
      */
-    public Builder eventListener(EventListener eventListener) {
-      if (eventListener == null) throw new NullPointerException("eventListener == null");
-      this.eventListenerFactory = EventListener.factory(eventListener);
-      return this;
+    @Override
+    public Call newCall(Request request) {
+        return RealCall.newRealCall(this, request, false /* for web socket */);
     }
 
     /**
-     * Configure a factory to provide per-call scoped listeners that will receive analytic events
-     * for this client.
-     *
-     * @see EventListener for semantics and restrictions on listener implementations.
+     * Uses {@code request} to connect a new web socket.
      */
-    public Builder eventListenerFactory(EventListener.Factory eventListenerFactory) {
-      if (eventListenerFactory == null) {
-        throw new NullPointerException("eventListenerFactory == null");
-      }
-      this.eventListenerFactory = eventListenerFactory;
-      return this;
+    @Override
+    public WebSocket newWebSocket(Request request, WebSocketListener listener) {
+        RealWebSocket webSocket = new RealWebSocket(request, listener, new Random(), pingInterval);
+        webSocket.connect(this);
+        return webSocket;
+    }
+
+    public Builder newBuilder() {
+        return new Builder(this);
     }
 
-    public OkHttpClient build() {
-      return new OkHttpClient(this);
+    public static final class Builder {
+        Dispatcher dispatcher;
+        @Nullable
+        Proxy proxy;
+        List<Protocol> protocols;
+        List<ConnectionSpec> connectionSpecs;
+        final List<Interceptor> interceptors = new ArrayList<>();
+        final List<Interceptor> networkInterceptors = new ArrayList<>();
+        EventListener.Factory eventListenerFactory;
+        ProxySelector proxySelector;
+        CookieJar cookieJar;
+        @Nullable
+        Cache cache;
+        @Nullable
+        InternalCache internalCache;
+        SocketFactory socketFactory;
+        @Nullable
+        SSLSocketFactory sslSocketFactory;
+        @Nullable
+        CertificateChainCleaner certificateChainCleaner;
+        HostnameVerifier hostnameVerifier;
+        CertificatePinner certificatePinner;
+        Authenticator proxyAuthenticator;
+        Authenticator authenticator;
+        ConnectionPool connectionPool;
+        Dns dns;
+        boolean followSslRedirects;
+        boolean followRedirects;
+        boolean retryOnConnectionFailure;
+        int callTimeout;
+        int connectTimeout;
+        int readTimeout;
+        int writeTimeout;
+        int pingInterval;
+
+        public Builder() {
+            dispatcher = new Dispatcher();
+            protocols = DEFAULT_PROTOCOLS;
+            connectionSpecs = DEFAULT_CONNECTION_SPECS;
+            eventListenerFactory = EventListener.factory(EventListener.NONE);
+            proxySelector = ProxySelector.getDefault();
+            if (proxySelector == null) {
+                proxySelector = new NullProxySelector();
+            }
+            cookieJar = CookieJar.NO_COOKIES;
+            socketFactory = SocketFactory.getDefault();
+            hostnameVerifier = OkHostnameVerifier.INSTANCE;
+            certificatePinner = CertificatePinner.DEFAULT;
+            proxyAuthenticator = Authenticator.NONE;
+            authenticator = Authenticator.NONE;
+            connectionPool = new ConnectionPool();
+            dns = Dns.SYSTEM;
+            followSslRedirects = true;
+            followRedirects = true;
+            retryOnConnectionFailure = true;
+            callTimeout = 0;
+            connectTimeout = 10_000;
+            readTimeout = 10_000;
+            writeTimeout = 10_000;
+            pingInterval = 0;
+        }
+
+        Builder(OkHttpClient okHttpClient) {
+            this.dispatcher = okHttpClient.dispatcher;
+            this.proxy = okHttpClient.proxy;
+            this.protocols = okHttpClient.protocols;
+            this.connectionSpecs = okHttpClient.connectionSpecs;
+            this.interceptors.addAll(okHttpClient.interceptors);
+            this.networkInterceptors.addAll(okHttpClient.networkInterceptors);
+            this.eventListenerFactory = okHttpClient.eventListenerFactory;
+            this.proxySelector = okHttpClient.proxySelector;
+            this.cookieJar = okHttpClient.cookieJar;
+            this.internalCache = okHttpClient.internalCache;
+            this.cache = okHttpClient.cache;
+            this.socketFactory = okHttpClient.socketFactory;
+            this.sslSocketFactory = okHttpClient.sslSocketFactory;
+            this.certificateChainCleaner = okHttpClient.certificateChainCleaner;
+            this.hostnameVerifier = okHttpClient.hostnameVerifier;
+            this.certificatePinner = okHttpClient.certificatePinner;
+            this.proxyAuthenticator = okHttpClient.proxyAuthenticator;
+            this.authenticator = okHttpClient.authenticator;
+            this.connectionPool = okHttpClient.connectionPool;
+            this.dns = okHttpClient.dns;
+            this.followSslRedirects = okHttpClient.followSslRedirects;
+            this.followRedirects = okHttpClient.followRedirects;
+            this.retryOnConnectionFailure = okHttpClient.retryOnConnectionFailure;
+            this.callTimeout = okHttpClient.callTimeout;
+            this.connectTimeout = okHttpClient.connectTimeout;
+            this.readTimeout = okHttpClient.readTimeout;
+            this.writeTimeout = okHttpClient.writeTimeout;
+            this.pingInterval = okHttpClient.pingInterval;
+        }
+
+        /**
+         * Sets the default timeout for complete calls. A value of 0 means no timeout, otherwise values
+         * must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
+         *
+         * <p>The call timeout spans the entire call: resolving DNS, connecting, writing the request
+         * body, server processing, and reading the response body. If the call requires redirects or
+         * retries all must complete within one timeout period.
+         *
+         * <p>The default value is 0 which imposes no timeout.
+         */
+        public Builder callTimeout(long timeout, TimeUnit unit) {
+            callTimeout = checkDuration("timeout", timeout, unit);
+            return this;
+        }
+
+        /**
+         * Sets the default timeout for complete calls. A value of 0 means no timeout, otherwise values
+         * must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
+         *
+         * <p>The call timeout spans the entire call: resolving DNS, connecting, writing the request
+         * body, server processing, and reading the response body. If the call requires redirects or
+         * retries all must complete within one timeout period.
+         *
+         * <p>The default value is 0 which imposes no timeout.
+         */
+        @IgnoreJRERequirement
+        public Builder callTimeout(Duration duration) {
+            callTimeout = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS);
+            return this;
+        }
+
+        /**
+         * Sets the default connect timeout for new connections. A value of 0 means no timeout,
+         * otherwise values must be between 1 and {@link Integer#MAX_VALUE} when converted to
+         * milliseconds.
+         *
+         * <p>The connect timeout is applied when connecting a TCP socket to the target host.
+         * The default value is 10 seconds.
+         */
+        public Builder connectTimeout(long timeout, TimeUnit unit) {
+            connectTimeout = checkDuration("timeout", timeout, unit);
+            return this;
+        }
+
+        /**
+         * Sets the default connect timeout for new connections. A value of 0 means no timeout,
+         * otherwise values must be between 1 and {@link Integer#MAX_VALUE} when converted to
+         * milliseconds.
+         *
+         * <p>The connect timeout is applied when connecting a TCP socket to the target host.
+         * The default value is 10 seconds.
+         */
+        @IgnoreJRERequirement
+        public Builder connectTimeout(Duration duration) {
+            connectTimeout = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS);
+            return this;
+        }
+
+        /**
+         * Sets the default read timeout for new connections. A value of 0 means no timeout, otherwise
+         * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
+         *
+         * <p>The read timeout is applied to both the TCP socket and for individual read IO operations
+         * including on {@link Source} of the {@link Response}. The default value is 10 seconds.
+         *
+         * @see Socket#setSoTimeout(int)
+         * @see Source#timeout()
+         */
+        public Builder readTimeout(long timeout, TimeUnit unit) {
+            readTimeout = checkDuration("timeout", timeout, unit);
+            return this;
+        }
+
+        /**
+         * Sets the default read timeout for new connections. A value of 0 means no timeout, otherwise
+         * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
+         *
+         * <p>The read timeout is applied to both the TCP socket and for individual read IO operations
+         * including on {@link Source} of the {@link Response}. The default value is 10 seconds.
+         *
+         * @see Socket#setSoTimeout(int)
+         * @see Source#timeout()
+         */
+        @IgnoreJRERequirement
+        public Builder readTimeout(Duration duration) {
+            readTimeout = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS);
+            return this;
+        }
+
+        /**
+         * Sets the default write timeout for new connections. A value of 0 means no timeout, otherwise
+         * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
+         *
+         * <p>The write timeout is applied for individual write IO operations.
+         * The default value is 10 seconds.
+         *
+         * @see Sink#timeout()
+         */
+        public Builder writeTimeout(long timeout, TimeUnit unit) {
+            writeTimeout = checkDuration("timeout", timeout, unit);
+            return this;
+        }
+
+        /**
+         * Sets the default write timeout for new connections. A value of 0 means no timeout, otherwise
+         * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
+         *
+         * <p>The write timeout is applied for individual write IO operations.
+         * The default value is 10 seconds.
+         *
+         * @see Sink#timeout()
+         */
+        @IgnoreJRERequirement
+        public Builder writeTimeout(Duration duration) {
+            writeTimeout = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS);
+            return this;
+        }
+
+        /**
+         * Sets the interval between HTTP/2 and web socket pings initiated by this client. Use this to
+         * automatically send ping frames until either the connection fails or it is closed. This keeps
+         * the connection alive and may detect connectivity failures.
+         *
+         * <p>If the server does not respond to each ping with a pong within {@code interval}, this
+         * client will assume that connectivity has been lost. When this happens on a web socket the
+         * connection is canceled and its listener is {@linkplain WebSocketListener#onFailure notified
+         * of the failure}. When it happens on an HTTP/2 connection the connection is closed and any
+         * calls it is carrying {@linkplain java.io.IOException will fail with an IOException}.
+         *
+         * <p>The default value of 0 disables client-initiated pings.
+         */
+        public Builder pingInterval(long interval, TimeUnit unit) {
+            pingInterval = checkDuration("interval", interval, unit);
+            return this;
+        }
+
+        /**
+         * Sets the interval between HTTP/2 and web socket pings initiated by this client. Use this to
+         * automatically send ping frames until either the connection fails or it is closed. This keeps
+         * the connection alive and may detect connectivity failures.
+         *
+         * <p>If the server does not respond to each ping with a pong within {@code interval}, this
+         * client will assume that connectivity has been lost. When this happens on a web socket the
+         * connection is canceled and its listener is {@linkplain WebSocketListener#onFailure notified
+         * of the failure}. When it happens on an HTTP/2 connection the connection is closed and any
+         * calls it is carrying {@linkplain java.io.IOException will fail with an IOException}.
+         *
+         * <p>The default value of 0 disables client-initiated pings.
+         */
+        @IgnoreJRERequirement
+        public Builder pingInterval(Duration duration) {
+            pingInterval = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS);
+            return this;
+        }
+
+        /**
+         * Sets the HTTP proxy that will be used by connections created by this client. This takes
+         * precedence over {@link #proxySelector}, which is only honored when this proxy is null (which
+         * it is by default). To disable proxy use completely, call {@code proxy(Proxy.NO_PROXY)}.
+         */
+        public Builder proxy(@Nullable Proxy proxy) {
+            this.proxy = proxy;
+            return this;
+        }
+
+        /**
+         * Sets the proxy selection policy to be used if no {@link #proxy proxy} is specified
+         * explicitly. The proxy selector may return multiple proxies; in that case they will be tried
+         * in sequence until a successful connection is established.
+         *
+         * <p>If unset, the {@link ProxySelector#getDefault() system-wide default} proxy selector will
+         * be used.
+         */
+        public Builder proxySelector(ProxySelector proxySelector) {
+            if (proxySelector == null) throw new NullPointerException("proxySelector == null");
+            this.proxySelector = proxySelector;
+            return this;
+        }
+
+        /**
+         * Sets the handler that can accept cookies from incoming HTTP responses and provides cookies to
+         * outgoing HTTP requests.
+         *
+         * <p>If unset, {@linkplain CookieJar#NO_COOKIES no cookies} will be accepted nor provided.
+         */
+        public Builder cookieJar(CookieJar cookieJar) {
+            if (cookieJar == null) throw new NullPointerException("cookieJar == null");
+            this.cookieJar = cookieJar;
+            return this;
+        }
+
+        /**
+         * Sets the response cache to be used to read and write cached responses.
+         */
+        void setInternalCache(@Nullable InternalCache internalCache) {
+            this.internalCache = internalCache;
+            this.cache = null;
+        }
+
+        /**
+         * Sets the response cache to be used to read and write cached responses.
+         */
+        public Builder cache(@Nullable Cache cache) {
+            this.cache = cache;
+            this.internalCache = null;
+            return this;
+        }
+
+        /**
+         * Sets the DNS service used to lookup IP addresses for hostnames.
+         *
+         * <p>If unset, the {@link Dns#SYSTEM system-wide default} DNS will be used.
+         */
+        public Builder dns(Dns dns) {
+            if (dns == null) throw new NullPointerException("dns == null");
+            this.dns = dns;
+            return this;
+        }
+
+        /**
+         * Sets the socket factory used to create connections. OkHttp only uses the parameterless {@link
+         * SocketFactory#createSocket() createSocket()} method to create unconnected sockets. Overriding
+         * this method, e. g., allows the socket to be bound to a specific local address.
+         *
+         * <p>If unset, the {@link SocketFactory#getDefault() system-wide default} socket factory will
+         * be used.
+         */
+        public Builder socketFactory(SocketFactory socketFactory) {
+            if (socketFactory == null) throw new NullPointerException("socketFactory == null");
+            if (socketFactory instanceof SSLSocketFactory) {
+                throw new IllegalArgumentException("socketFactory instanceof SSLSocketFactory");
+            }
+            this.socketFactory = socketFactory;
+            return this;
+        }
+
+        /**
+         * Sets the socket factory used to secure HTTPS connections. If unset, the system default will
+         * be used.
+         *
+         * @deprecated {@code SSLSocketFactory} does not expose its {@link X509TrustManager}, which is
+         * a field that OkHttp needs to build a clean certificate chain. This method instead must
+         * use reflection to extract the trust manager. Applications should prefer to call {@link
+         * #sslSocketFactory(SSLSocketFactory, X509TrustManager)}, which avoids such reflection.
+         */
+        public Builder sslSocketFactory(SSLSocketFactory sslSocketFactory) {
+            if (sslSocketFactory == null) throw new NullPointerException("sslSocketFactory == null");
+            this.sslSocketFactory = sslSocketFactory;
+            this.certificateChainCleaner = Platform.get().buildCertificateChainCleaner(sslSocketFactory);
+            return this;
+        }
+
+        /**
+         * Sets the socket factory and trust manager used to secure HTTPS connections. If unset, the
+         * system defaults will be used.
+         *
+         * <p>Most applications should not call this method, and instead use the system defaults. Those
+         * classes include special optimizations that can be lost if the implementations are decorated.
+         *
+         * <p>If necessary, you can create and configure the defaults yourself with the following code:
+         *
+         * <pre>   {@code
+         *
+         *   TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
+         *       TrustManagerFactory.getDefaultAlgorithm());
+         *   trustManagerFactory.init((KeyStore) null);
+         *   TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
+         *   if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {
+         *     throw new IllegalStateException("Unexpected default trust managers:"
+         *         + Arrays.toString(trustManagers));
+         *   }
+         *   X509TrustManager trustManager = (X509TrustManager) trustManagers[0];
+         *
+         *   SSLContext sslContext = SSLContext.getInstance("TLS");
+         *   sslContext.init(null, new TrustManager[] { trustManager }, null);
+         *   SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();
+         *
+         *   OkHttpClient client = new OkHttpClient.Builder()
+         *       .sslSocketFactory(sslSocketFactory, trustManager)
+         *       .build();
+         * }</pre>
+         */
+        public Builder sslSocketFactory(
+                SSLSocketFactory sslSocketFactory, X509TrustManager trustManager) {
+            if (sslSocketFactory == null) throw new NullPointerException("sslSocketFactory == null");
+            if (trustManager == null) throw new NullPointerException("trustManager == null");
+            this.sslSocketFactory = sslSocketFactory;
+            this.certificateChainCleaner = CertificateChainCleaner.get(trustManager);
+            return this;
+        }
+
+        /**
+         * Sets the verifier used to confirm that response certificates apply to requested hostnames for
+         * HTTPS connections.
+         *
+         * <p>If unset, a default hostname verifier will be used.
+         */
+        public Builder hostnameVerifier(HostnameVerifier hostnameVerifier) {
+            if (hostnameVerifier == null) throw new NullPointerException("hostnameVerifier == null");
+            this.hostnameVerifier = hostnameVerifier;
+            return this;
+        }
+
+        /**
+         * Sets the certificate pinner that constrains which certificates are trusted. By default HTTPS
+         * connections rely on only the {@link #sslSocketFactory SSL socket factory} to establish trust.
+         * Pinning certificates avoids the need to trust certificate authorities.
+         */
+        public Builder certificatePinner(CertificatePinner certificatePinner) {
+            if (certificatePinner == null) throw new NullPointerException("certificatePinner == null");
+            this.certificatePinner = certificatePinner;
+            return this;
+        }
+
+        /**
+         * Sets the authenticator used to respond to challenges from origin servers. Use {@link
+         * #proxyAuthenticator} to set the authenticator for proxy servers.
+         *
+         * <p>If unset, the {@linkplain Authenticator#NONE no authentication will be attempted}.
+         */
+        public Builder authenticator(Authenticator authenticator) {
+            if (authenticator == null) throw new NullPointerException("authenticator == null");
+            this.authenticator = authenticator;
+            return this;
+        }
+
+        /**
+         * Sets the authenticator used to respond to challenges from proxy servers. Use {@link
+         * #authenticator} to set the authenticator for origin servers.
+         *
+         * <p>If unset, the {@linkplain Authenticator#NONE no authentication will be attempted}.
+         */
+        public Builder proxyAuthenticator(Authenticator proxyAuthenticator) {
+            if (proxyAuthenticator == null) throw new NullPointerException("proxyAuthenticator == null");
+            this.proxyAuthenticator = proxyAuthenticator;
+            return this;
+        }
+
+        /**
+         * Sets the connection pool used to recycle HTTP and HTTPS connections.
+         *
+         * <p>If unset, a new connection pool will be used.
+         */
+        public Builder connectionPool(ConnectionPool connectionPool) {
+            if (connectionPool == null) throw new NullPointerException("connectionPool == null");
+            this.connectionPool = connectionPool;
+            return this;
+        }
+
+        /**
+         * Configure this client to follow redirects from HTTPS to HTTP and from HTTP to HTTPS.
+         *
+         * <p>If unset, protocol redirects will be followed. This is different than the built-in {@code
+         * HttpURLConnection}'s default.
+         */
+        public Builder followSslRedirects(boolean followProtocolRedirects) {
+            this.followSslRedirects = followProtocolRedirects;
+            return this;
+        }
+
+        /**
+         * Configure this client to follow redirects. If unset, redirects will be followed.
+         */
+        public Builder followRedirects(boolean followRedirects) {
+            this.followRedirects = followRedirects;
+            return this;
+        }
+
+        /**
+         * Configure this client to retry or not when a connectivity problem is encountered. By default,
+         * this client silently recovers from the following problems:
+         *
+         * <ul>
+         * <li><strong>Unreachable IP addresses.</strong> If the URL's host has multiple IP addresses,
+         * failure to reach any individual IP address doesn't fail the overall request. This can
+         * increase availability of multi-homed services.
+         * <li><strong>Stale pooled connections.</strong> The {@link ConnectionPool} reuses sockets
+         * to decrease request latency, but these connections will occasionally time out.
+         * <li><strong>Unreachable proxy servers.</strong> A {@link ProxySelector} can be used to
+         * attempt multiple proxy servers in sequence, eventually falling back to a direct
+         * connection.
+         * </ul>
+         * <p>
+         * Set this to false to avoid retrying requests when doing so is destructive. In this case the
+         * calling application should do its own recovery of connectivity failures.
+         */
+        public Builder retryOnConnectionFailure(boolean retryOnConnectionFailure) {
+            this.retryOnConnectionFailure = retryOnConnectionFailure;
+            return this;
+        }
+
+        /**
+         * Sets the dispatcher used to set policy and execute asynchronous requests. Must not be null.
+         */
+        public Builder dispatcher(Dispatcher dispatcher) {
+            if (dispatcher == null) throw new IllegalArgumentException("dispatcher == null");
+            this.dispatcher = dispatcher;
+            return this;
+        }
+
+        /**
+         * Configure the protocols used by this client to communicate with remote servers. By default
+         * this client will prefer the most efficient transport available, falling back to more
+         * ubiquitous protocols. Applications should only call this method to avoid specific
+         * compatibility problems, such as web servers that behave incorrectly when HTTP/2 is enabled.
+         *
+         * <p>The following protocols are currently supported:
+         *
+         * <ul>
+         * <li><a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html">http/1.1</a>
+         * <li><a href="https://tools.ietf.org/html/rfc7540">h2</a>
+         * <li><a href="https://tools.ietf.org/html/rfc7540#section-3.4">h2 with prior knowledge
+         * (cleartext only)</a>
+         * </ul>
+         *
+         * <p><strong>This is an evolving set.</strong> Future releases include support for transitional
+         * protocols. The http/1.1 transport will never be dropped.
+         *
+         * <p>If multiple protocols are specified, <a
+         * href="http://tools.ietf.org/html/draft-ietf-tls-applayerprotoneg">ALPN</a> will be used to
+         * negotiate a transport. Protocol negotiation is only attempted for HTTPS URLs.
+         *
+         * <p>{@link Protocol#HTTP_1_0} is not supported in this set. Requests are initiated with {@code
+         * HTTP/1.1}. If the server responds with {@code HTTP/1.0}, that will be exposed by {@link
+         * Response#protocol()}.
+         *
+         * @param protocols the protocols to use, in order of preference. If the list contains {@link
+         *                  Protocol#H2_PRIOR_KNOWLEDGE} then that must be the only protocol and HTTPS URLs will not
+         *                  be supported. Otherwise the list must contain {@link Protocol#HTTP_1_1}. The list must
+         *                  not contain null or {@link Protocol#HTTP_1_0}.
+         */
+        public Builder protocols(List<Protocol> protocols) {
+            // Create a private copy of the list.
+            protocols = new ArrayList<>(protocols);
+
+            // Validate that the list has everything we require and nothing we forbid.
+            if (!protocols.contains(Protocol.H2_PRIOR_KNOWLEDGE)
+                    && !protocols.contains(Protocol.HTTP_1_1)) {
+                throw new IllegalArgumentException(
+                        "protocols must contain h2_prior_knowledge or http/1.1: " + protocols);
+            }
+            if (protocols.contains(Protocol.H2_PRIOR_KNOWLEDGE) && protocols.size() > 1) {
+                throw new IllegalArgumentException(
+                        "protocols containing h2_prior_knowledge cannot use other protocols: " + protocols);
+            }
+            if (protocols.contains(Protocol.HTTP_1_0)) {
+                throw new IllegalArgumentException("protocols must not contain http/1.0: " + protocols);
+            }
+            if (protocols.contains(null)) {
+                throw new IllegalArgumentException("protocols must not contain null");
+            }
+
+            // Remove protocols that we no longer support.
+            protocols.remove(Protocol.SPDY_3);
+
+            // Assign as an unmodifiable list. This is effectively immutable.
+            this.protocols = Collections.unmodifiableList(protocols);
+            return this;
+        }
+
+        public Builder connectionSpecs(List<ConnectionSpec> connectionSpecs) {
+            this.connectionSpecs = Util.immutableList(connectionSpecs);
+            return this;
+        }
+
+        /**
+         * Returns a modifiable list of interceptors that observe the full span of each call: from
+         * before the connection is established (if any) until after the response source is selected
+         * (either the origin server, cache, or both).
+         */
+        public List<Interceptor> interceptors() {
+            return interceptors;
+        }
+
+        public Builder addInterceptor(Interceptor interceptor) {
+            if (interceptor == null) throw new IllegalArgumentException("interceptor == null");
+            interceptors.add(interceptor);
+            return this;
+        }
+
+        /**
+         * Returns a modifiable list of interceptors that observe a single network request and response.
+         * These interceptors must call {@link Interceptor.Chain#proceed} exactly once: it is an error
+         * for a network interceptor to short-circuit or repeat a network request.
+         */
+        public List<Interceptor> networkInterceptors() {
+            return networkInterceptors;
+        }
+
+        public Builder addNetworkInterceptor(Interceptor interceptor) {
+            if (interceptor == null) throw new IllegalArgumentException("interceptor == null");
+            networkInterceptors.add(interceptor);
+            return this;
+        }
+
+        /**
+         * Configure a single client scoped listener that will receive all analytic events
+         * for this client.
+         *
+         * @see EventListener for semantics and restrictions on listener implementations.
+         */
+        public Builder eventListener(EventListener eventListener) {
+            if (eventListener == null) throw new NullPointerException("eventListener == null");
+            this.eventListenerFactory = EventListener.factory(eventListener);
+            return this;
+        }
+
+        /**
+         * Configure a factory to provide per-call scoped listeners that will receive analytic events
+         * for this client.
+         *
+         * @see EventListener for semantics and restrictions on listener implementations.
+         */
+        public Builder eventListenerFactory(EventListener.Factory eventListenerFactory) {
+            if (eventListenerFactory == null) {
+                throw new NullPointerException("eventListenerFactory == null");
+            }
+            this.eventListenerFactory = eventListenerFactory;
+            return this;
+        }
+
+        public OkHttpClient build() {
+            return new OkHttpClient(this);
+        }
     }
-  }
 }
diff --git a/okhttp/src/main/java/okhttp3/Request.java b/okhttp/src/main/java/okhttp3/Request.java
index 9bbdc86407..3d21c3b368 100644
--- a/okhttp/src/main/java/okhttp3/Request.java
+++ b/okhttp/src/main/java/okhttp3/Request.java
@@ -21,6 +21,7 @@
 import java.util.List;
 import java.util.Map;
 import javax.annotation.Nullable;
+
 import okhttp3.internal.Util;
 import okhttp3.internal.http.HttpMethod;
 
@@ -29,268 +30,285 @@
  * immutable.
  */
 public final class Request {
-  final HttpUrl url;
-  final String method;
-  final Headers headers;
-  final @Nullable RequestBody body;
-  final Map<Class<?>, Object> tags;
-
-  private volatile @Nullable CacheControl cacheControl; // Lazily initialized.
-
-  Request(Builder builder) {
-    this.url = builder.url;
-    this.method = builder.method;
-    this.headers = builder.headers.build();
-    this.body = builder.body;
-    this.tags = Util.immutableMap(builder.tags);
-  }
-
-  public HttpUrl url() {
-    return url;
-  }
-
-  public String method() {
-    return method;
-  }
-
-  public Headers headers() {
-    return headers;
-  }
-
-  public @Nullable String header(String name) {
-    return headers.get(name);
-  }
-
-  public List<String> headers(String name) {
-    return headers.values(name);
-  }
-
-  public @Nullable RequestBody body() {
-    return body;
-  }
-
-  /**
-   * Returns the tag attached with {@code Object.class} as a key, or null if no tag is attached with
-   * that key.
-   *
-   * <p>Prior to OkHttp 3.11, this method never returned null if no tag was attached. Instead it
-   * returned either this request, or the request upon which this request was derived with {@link
-   * #newBuilder()}.
-   */
-  public @Nullable Object tag() {
-    return tag(Object.class);
-  }
-
-  /**
-   * Returns the tag attached with {@code type} as a key, or null if no tag is attached with that
-   * key.
-   */
-  public @Nullable <T> T tag(Class<? extends T> type) {
-    return type.cast(tags.get(type));
-  }
-
-  public Builder newBuilder() {
-    return new Builder(this);
-  }
-
-  /**
-   * Returns the cache control directives for this response. This is never null, even if this
-   * response contains no {@code Cache-Control} header.
-   */
-  public CacheControl cacheControl() {
-    CacheControl result = cacheControl;
-    return result != null ? result : (cacheControl = CacheControl.parse(headers));
-  }
-
-  public boolean isHttps() {
-    return url.isHttps();
-  }
-
-  @Override public String toString() {
-    return "Request{method="
-        + method
-        + ", url="
-        + url
-        + ", tags="
-        + tags
-        + '}';
-  }
-
-  public static class Builder {
-    @Nullable HttpUrl url;
-    String method;
-    Headers.Builder headers;
-    @Nullable RequestBody body;
-
-    /** A mutable map of tags, or an immutable empty map if we don't have any. */
-    Map<Class<?>, Object> tags = Collections.emptyMap();
-
-    public Builder() {
-      this.method = "GET";
-      this.headers = new Headers.Builder();
+    final HttpUrl url;
+    final String method;
+    final Headers headers;
+    final @Nullable
+    RequestBody body;
+    final Map<Class<?>, Object> tags;
+
+    private volatile @Nullable
+    CacheControl cacheControl; // Lazily initialized.
+
+    Request(Builder builder) {
+        this.url = builder.url;
+        this.method = builder.method;
+        this.headers = builder.headers.build();
+        this.body = builder.body;
+        this.tags = Util.immutableMap(builder.tags);
     }
 
-    Builder(Request request) {
-      this.url = request.url;
-      this.method = request.method;
-      this.body = request.body;
-      this.tags = request.tags.isEmpty()
-          ? Collections.emptyMap()
-          : new LinkedHashMap<>(request.tags);
-      this.headers = request.headers.newBuilder();
+    public HttpUrl url() {
+        return url;
     }
 
-    public Builder url(HttpUrl url) {
-      if (url == null) throw new NullPointerException("url == null");
-      this.url = url;
-      return this;
+    public String method() {
+        return method;
     }
 
-    /**
-     * Sets the URL target of this request.
-     *
-     * @throws IllegalArgumentException if {@code url} is not a valid HTTP or HTTPS URL. Avoid this
-     * exception by calling {@link HttpUrl#parse}; it returns null for invalid URLs.
-     */
-    public Builder url(String url) {
-      if (url == null) throw new NullPointerException("url == null");
-
-      // Silently replace web socket URLs with HTTP URLs.
-      if (url.regionMatches(true, 0, "ws:", 0, 3)) {
-        url = "http:" + url.substring(3);
-      } else if (url.regionMatches(true, 0, "wss:", 0, 4)) {
-        url = "https:" + url.substring(4);
-      }
+    public Headers headers() {
+        return headers;
+    }
 
-      return url(HttpUrl.get(url));
+    public @Nullable
+    String header(String name) {
+        return headers.get(name);
     }
 
-    /**
-     * Sets the URL target of this request.
-     *
-     * @throws IllegalArgumentException if the scheme of {@code url} is not {@code http} or {@code
-     * https}.
-     */
-    public Builder url(URL url) {
-      if (url == null) throw new NullPointerException("url == null");
-      return url(HttpUrl.get(url.toString()));
+    public List<String> headers(String name) {
+        return headers.values(name);
     }
 
-    /**
-     * Sets the header named {@code name} to {@code value}. If this request already has any headers
-     * with that name, they are all replaced.
-     */
-    public Builder header(String name, String value) {
-      headers.set(name, value);
-      return this;
+    public @Nullable
+    RequestBody body() {
+        return body;
     }
 
     /**
-     * Adds a header with {@code name} and {@code value}. Prefer this method for multiply-valued
-     * headers like "Cookie".
+     * Returns the tag attached with {@code Object.class} as a key, or null if no tag is attached with
+     * that key.
      *
-     * <p>Note that for some headers including {@code Content-Length} and {@code Content-Encoding},
-     * OkHttp may replace {@code value} with a header derived from the request body.
+     * <p>Prior to OkHttp 3.11, this method never returned null if no tag was attached. Instead it
+     * returned either this request, or the request upon which this request was derived with {@link
+     * #newBuilder()}.
      */
-    public Builder addHeader(String name, String value) {
-      headers.add(name, value);
-      return this;
-    }
-
-    /** Removes all headers named {@code name} on this builder. */
-    public Builder removeHeader(String name) {
-      headers.removeAll(name);
-      return this;
-    }
-
-    /** Removes all headers on this builder and adds {@code headers}. */
-    public Builder headers(Headers headers) {
-      this.headers = headers.newBuilder();
-      return this;
+    public @Nullable
+    Object tag() {
+        return tag(Object.class);
     }
 
     /**
-     * Sets this request's {@code Cache-Control} header, replacing any cache control headers already
-     * present. If {@code cacheControl} doesn't define any directives, this clears this request's
-     * cache-control headers.
+     * Returns the tag attached with {@code type} as a key, or null if no tag is attached with that
+     * key.
      */
-    public Builder cacheControl(CacheControl cacheControl) {
-      String value = cacheControl.toString();
-      if (value.isEmpty()) return removeHeader("Cache-Control");
-      return header("Cache-Control", value);
-    }
-
-    public Builder get() {
-      return method("GET", null);
+    public @Nullable
+    <T> T tag(Class<? extends T> type) {
+        return type.cast(tags.get(type));
     }
 
-    public Builder head() {
-      return method("HEAD", null);
-    }
-
-    public Builder post(RequestBody body) {
-      return method("POST", body);
-    }
-
-    public Builder delete(@Nullable RequestBody body) {
-      return method("DELETE", body);
-    }
-
-    public Builder delete() {
-      return delete(Util.EMPTY_REQUEST);
-    }
-
-    public Builder put(RequestBody body) {
-      return method("PUT", body);
-    }
-
-    public Builder patch(RequestBody body) {
-      return method("PATCH", body);
-    }
-
-    public Builder method(String method, @Nullable RequestBody body) {
-      if (method == null) throw new NullPointerException("method == null");
-      if (method.length() == 0) throw new IllegalArgumentException("method.length() == 0");
-      if (body != null && !HttpMethod.permitsRequestBody(method)) {
-        throw new IllegalArgumentException("method " + method + " must not have a request body.");
-      }
-      if (body == null && HttpMethod.requiresRequestBody(method)) {
-        throw new IllegalArgumentException("method " + method + " must have a request body.");
-      }
-      this.method = method;
-      this.body = body;
-      return this;
-    }
-
-    /** Attaches {@code tag} to the request using {@code Object.class} as a key. */
-    public Builder tag(@Nullable Object tag) {
-      return tag(Object.class, tag);
+    public Builder newBuilder() {
+        return new Builder(this);
     }
 
     /**
-     * Attaches {@code tag} to the request using {@code type} as a key. Tags can be read from a
-     * request using {@link Request#tag}. Use null to remove any existing tag assigned for {@code
-     * type}.
-     *
-     * <p>Use this API to attach timing, debugging, or other application data to a request so that
-     * you may read it in interceptors, event listeners, or callbacks.
+     * Returns the cache control directives for this response. This is never null, even if this
+     * response contains no {@code Cache-Control} header.
      */
-    public <T> Builder tag(Class<? super T> type, @Nullable T tag) {
-      if (type == null) throw new NullPointerException("type == null");
+    public CacheControl cacheControl() {
+        CacheControl result = cacheControl;
+        return result != null ? result : (cacheControl = CacheControl.parse(headers));
+    }
 
-      if (tag == null) {
-        tags.remove(type);
-      } else {
-        if (tags.isEmpty()) tags = new LinkedHashMap<>();
-        tags.put(type, type.cast(tag));
-      }
+    public boolean isHttps() {
+        return url.isHttps();
+    }
 
-      return this;
+    @Override
+    public String toString() {
+        return "Request{method="
+                + method
+                + ", url="
+                + url
+                + ", tags="
+                + tags
+                + '}';
     }
 
-    public Request build() {
-      if (url == null) throw new IllegalStateException("url == null");
-      return new Request(this);
+    public static class Builder {
+        @Nullable
+        HttpUrl url;
+        String method;
+        Headers.Builder headers;
+        @Nullable
+        RequestBody body;
+
+        /**
+         * A mutable map of tags, or an immutable empty map if we don't have any.
+         */
+        Map<Class<?>, Object> tags = Collections.emptyMap();
+
+        public Builder() {
+            this.method = "GET";
+            this.headers = new Headers.Builder();
+        }
+
+        Builder(Request request) {
+            this.url = request.url;
+            this.method = request.method;
+            this.body = request.body;
+            this.tags = request.tags.isEmpty()
+                    ? Collections.emptyMap()
+                    : new LinkedHashMap<>(request.tags);
+            this.headers = request.headers.newBuilder();
+        }
+
+        public Builder url(HttpUrl url) {
+            if (url == null) throw new NullPointerException("url == null");
+            this.url = url;
+            return this;
+        }
+
+        /**
+         * Sets the URL target of this request.
+         *
+         * @throws IllegalArgumentException if {@code url} is not a valid HTTP or HTTPS URL. Avoid this
+         *                                  exception by calling {@link HttpUrl#parse}; it returns null for invalid URLs.
+         */
+        public Builder url(String url) {
+            if (url == null) throw new NullPointerException("url == null");
+
+            // Silently replace web socket URLs with HTTP URLs.
+            if (url.regionMatches(true, 0, "ws:", 0, 3)) {
+                url = "http:" + url.substring(3);
+            } else if (url.regionMatches(true, 0, "wss:", 0, 4)) {
+                url = "https:" + url.substring(4);
+            }
+
+            return url(HttpUrl.get(url));
+        }
+
+        /**
+         * Sets the URL target of this request.
+         *
+         * @throws IllegalArgumentException if the scheme of {@code url} is not {@code http} or {@code
+         *                                  https}.
+         */
+        public Builder url(URL url) {
+            if (url == null) throw new NullPointerException("url == null");
+            return url(HttpUrl.get(url.toString()));
+        }
+
+        /**
+         * Sets the header named {@code name} to {@code value}. If this request already has any headers
+         * with that name, they are all replaced.
+         */
+        public Builder header(String name, String value) {
+            headers.set(name, value);
+            return this;
+        }
+
+        /**
+         * Adds a header with {@code name} and {@code value}. Prefer this method for multiply-valued
+         * headers like "Cookie".
+         *
+         * <p>Note that for some headers including {@code Content-Length} and {@code Content-Encoding},
+         * OkHttp may replace {@code value} with a header derived from the request body.
+         */
+        public Builder addHeader(String name, String value) {
+            headers.add(name, value);
+            return this;
+        }
+
+        /**
+         * Removes all headers named {@code name} on this builder.
+         */
+        public Builder removeHeader(String name) {
+            headers.removeAll(name);
+            return this;
+        }
+
+        /**
+         * Removes all headers on this builder and adds {@code headers}.
+         */
+        public Builder headers(Headers headers) {
+            this.headers = headers.newBuilder();
+            return this;
+        }
+
+        /**
+         * Sets this request's {@code Cache-Control} header, replacing any cache control headers already
+         * present. If {@code cacheControl} doesn't define any directives, this clears this request's
+         * cache-control headers.
+         */
+        public Builder cacheControl(CacheControl cacheControl) {
+            String value = cacheControl.toString();
+            if (value.isEmpty()) return removeHeader("Cache-Control");
+            return header("Cache-Control", value);
+        }
+
+        public Builder get() {
+            return method("GET", null);
+        }
+
+        public Builder head() {
+            return method("HEAD", null);
+        }
+
+        public Builder post(RequestBody body) {
+            return method("POST", body);
+        }
+
+        public Builder delete(@Nullable RequestBody body) {
+            return method("DELETE", body);
+        }
+
+        public Builder delete() {
+            return delete(Util.EMPTY_REQUEST);
+        }
+
+        public Builder put(RequestBody body) {
+            return method("PUT", body);
+        }
+
+        public Builder patch(RequestBody body) {
+            return method("PATCH", body);
+        }
+
+        public Builder method(String method, @Nullable RequestBody body) {
+            if (method == null) throw new NullPointerException("method == null");
+            if (method.length() == 0) throw new IllegalArgumentException("method.length() == 0");
+            if (body != null && !HttpMethod.permitsRequestBody(method)) {
+                throw new IllegalArgumentException("method " + method + " must not have a request body.");
+            }
+            if (body == null && HttpMethod.requiresRequestBody(method)) {
+                throw new IllegalArgumentException("method " + method + " must have a request body.");
+            }
+            this.method = method;
+            this.body = body;
+            return this;
+        }
+
+        /**
+         * Attaches {@code tag} to the request using {@code Object.class} as a key.
+         */
+        public Builder tag(@Nullable Object tag) {
+            return tag(Object.class, tag);
+        }
+
+        /**
+         * Attaches {@code tag} to the request using {@code type} as a key. Tags can be read from a
+         * request using {@link Request#tag}. Use null to remove any existing tag assigned for {@code
+         * type}.
+         *
+         * <p>Use this API to attach timing, debugging, or other application data to a request so that
+         * you may read it in interceptors, event listeners, or callbacks.
+         */
+        public <T> Builder tag(Class<? super T> type, @Nullable T tag) {
+            if (type == null) throw new NullPointerException("type == null");
+
+            if (tag == null) {
+                tags.remove(type);
+            } else {
+                if (tags.isEmpty()) tags = new LinkedHashMap<>();
+                tags.put(type, type.cast(tag));
+            }
+
+            return this;
+        }
+
+        public Request build() {
+            if (url == null) throw new IllegalStateException("url == null");
+            return new Request(this);
+        }
     }
-  }
 }
diff --git a/okhttp/src/main/java/okhttp3/RequestBody.java b/okhttp/src/main/java/okhttp3/RequestBody.java
index c0279f3081..ab863df184 100644
--- a/okhttp/src/main/java/okhttp3/RequestBody.java
+++ b/okhttp/src/main/java/okhttp3/RequestBody.java
@@ -19,6 +19,7 @@
 import java.io.IOException;
 import java.nio.charset.Charset;
 import javax.annotation.Nullable;
+
 import okhttp3.internal.Util;
 import okio.BufferedSink;
 import okio.ByteString;
@@ -28,98 +29,123 @@
 import static java.nio.charset.StandardCharsets.UTF_8;
 
 public abstract class RequestBody {
-  /** Returns the Content-Type header for this body. */
-  public abstract @Nullable MediaType contentType();
-
-  /**
-   * Returns the number of bytes that will be written to {@code sink} in a call to {@link #writeTo},
-   * or -1 if that count is unknown.
-   */
-  public long contentLength() throws IOException {
-    return -1;
-  }
-
-  /** Writes the content of this request to {@code sink}. */
-  public abstract void writeTo(BufferedSink sink) throws IOException;
-
-  /**
-   * Returns a new request body that transmits {@code content}. If {@code contentType} is non-null
-   * and lacks a charset, this will use UTF-8.
-   */
-  public static RequestBody create(@Nullable MediaType contentType, String content) {
-    Charset charset = UTF_8;
-    if (contentType != null) {
-      charset = contentType.charset();
-      if (charset == null) {
-        charset = UTF_8;
-        contentType = MediaType.parse(contentType + "; charset=utf-8");
-      }
+    /**
+     * Returns the Content-Type header for this body.
+     */
+    public abstract @Nullable
+    MediaType contentType();
+
+    /**
+     * Returns the number of bytes that will be written to {@code sink} in a call to {@link #writeTo},
+     * or -1 if that count is unknown.
+     */
+    public long contentLength() throws IOException {
+        return -1;
     }
-    byte[] bytes = content.getBytes(charset);
-    return create(contentType, bytes);
-  }
-
-  /** Returns a new request body that transmits {@code content}. */
-  public static RequestBody create(
-      final @Nullable MediaType contentType, final ByteString content) {
-    return new RequestBody() {
-      @Override public @Nullable MediaType contentType() {
-        return contentType;
-      }
-
-      @Override public long contentLength() throws IOException {
-        return content.size();
-      }
-
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        sink.write(content);
-      }
-    };
-  }
-
-  /** Returns a new request body that transmits {@code content}. */
-  public static RequestBody create(final @Nullable MediaType contentType, final byte[] content) {
-    return create(contentType, content, 0, content.length);
-  }
-
-  /** Returns a new request body that transmits {@code content}. */
-  public static RequestBody create(final @Nullable MediaType contentType, final byte[] content,
-      final int offset, final int byteCount) {
-    if (content == null) throw new NullPointerException("content == null");
-    Util.checkOffsetAndCount(content.length, offset, byteCount);
-    return new RequestBody() {
-      @Override public @Nullable MediaType contentType() {
-        return contentType;
-      }
-
-      @Override public long contentLength() {
-        return byteCount;
-      }
-
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        sink.write(content, offset, byteCount);
-      }
-    };
-  }
-
-  /** Returns a new request body that transmits the content of {@code file}. */
-  public static RequestBody create(final @Nullable MediaType contentType, final File file) {
-    if (file == null) throw new NullPointerException("file == null");
-
-    return new RequestBody() {
-      @Override public @Nullable MediaType contentType() {
-        return contentType;
-      }
-
-      @Override public long contentLength() {
-        return file.length();
-      }
-
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        try (Source source = Okio.source(file)) {
-          sink.writeAll(source);
+
+    /**
+     * Writes the content of this request to {@code sink}.
+     */
+    public abstract void writeTo(BufferedSink sink) throws IOException;
+
+    /**
+     * Returns a new request body that transmits {@code content}. If {@code contentType} is non-null
+     * and lacks a charset, this will use UTF-8.
+     */
+    public static RequestBody create(@Nullable MediaType contentType, String content) {
+        Charset charset = UTF_8;
+        if (contentType != null) {
+            charset = contentType.charset();
+            if (charset == null) {
+                charset = UTF_8;
+                contentType = MediaType.parse(contentType + "; charset=utf-8");
+            }
         }
-      }
-    };
-  }
+        byte[] bytes = content.getBytes(charset);
+        return create(contentType, bytes);
+    }
+
+    /**
+     * Returns a new request body that transmits {@code content}.
+     */
+    public static RequestBody create(
+            final @Nullable MediaType contentType, final ByteString content) {
+        return new RequestBody() {
+            @Override
+            public @Nullable
+            MediaType contentType() {
+                return contentType;
+            }
+
+            @Override
+            public long contentLength() throws IOException {
+                return content.size();
+            }
+
+            @Override
+            public void writeTo(BufferedSink sink) throws IOException {
+                sink.write(content);
+            }
+        };
+    }
+
+    /**
+     * Returns a new request body that transmits {@code content}.
+     */
+    public static RequestBody create(final @Nullable MediaType contentType, final byte[] content) {
+        return create(contentType, content, 0, content.length);
+    }
+
+    /**
+     * Returns a new request body that transmits {@code content}.
+     */
+    public static RequestBody create(final @Nullable MediaType contentType, final byte[] content,
+                                     final int offset, final int byteCount) {
+        if (content == null) throw new NullPointerException("content == null");
+        Util.checkOffsetAndCount(content.length, offset, byteCount);
+        return new RequestBody() {
+            @Override
+            public @Nullable
+            MediaType contentType() {
+                return contentType;
+            }
+
+            @Override
+            public long contentLength() {
+                return byteCount;
+            }
+
+            @Override
+            public void writeTo(BufferedSink sink) throws IOException {
+                sink.write(content, offset, byteCount);
+            }
+        };
+    }
+
+    /**
+     * Returns a new request body that transmits the content of {@code file}.
+     */
+    public static RequestBody create(final @Nullable MediaType contentType, final File file) {
+        if (file == null) throw new NullPointerException("file == null");
+
+        return new RequestBody() {
+            @Override
+            public @Nullable
+            MediaType contentType() {
+                return contentType;
+            }
+
+            @Override
+            public long contentLength() {
+                return file.length();
+            }
+
+            @Override
+            public void writeTo(BufferedSink sink) throws IOException {
+                try (Source source = Okio.source(file)) {
+                    sink.writeAll(source);
+                }
+            }
+        };
+    }
 }
diff --git a/okhttp/src/main/java/okhttp3/Route.java b/okhttp/src/main/java/okhttp3/Route.java
index 14158673ca..76b649c7cf 100644
--- a/okhttp/src/main/java/okhttp3/Route.java
+++ b/okhttp/src/main/java/okhttp3/Route.java
@@ -22,7 +22,7 @@
 /**
  * The concrete route used by a connection to reach an abstract origin server. When creating a
  * connection the client has many options:
- *
+ * 一个Connection可以使用具体的路由与抽象服务器相连
  * <ul>
  *     <li><strong>HTTP proxy:</strong> a proxy server may be explicitly configured for the client.
  *         Otherwise the {@linkplain java.net.ProxySelector proxy selector} is used. It may return
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java b/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java
index 30c9a135ea..a89a49ca2f 100644
--- a/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java
@@ -18,6 +18,7 @@
 
 import java.io.IOException;
 import javax.annotation.Nullable;
+
 import okhttp3.Headers;
 import okhttp3.Interceptor;
 import okhttp3.Protocol;
@@ -42,227 +43,236 @@
 import static okhttp3.internal.Util.closeQuietly;
 import static okhttp3.internal.Util.discard;
 
-/** Serves requests from the cache and writes responses to the cache. */
+/**
+ * Serves requests from the cache and writes responses to the cache.
+ */
 public final class CacheInterceptor implements Interceptor {
-  final @Nullable InternalCache cache;
-
-  public CacheInterceptor(@Nullable InternalCache cache) {
-    this.cache = cache;
-  }
-
-  @Override public Response intercept(Chain chain) throws IOException {
-    Response cacheCandidate = cache != null
-        ? cache.get(chain.request())
-        : null;
+    final @Nullable
+    InternalCache cache;
 
-    long now = System.currentTimeMillis();
-
-    CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();
-    Request networkRequest = strategy.networkRequest;
-    Response cacheResponse = strategy.cacheResponse;
-
-    if (cache != null) {
-      cache.trackResponse(strategy);
+    public CacheInterceptor(@Nullable InternalCache cache) {
+        this.cache = cache;
     }
 
-    if (cacheCandidate != null && cacheResponse == null) {
-      closeQuietly(cacheCandidate.body()); // The cache candidate wasn't applicable. Close it.
-    }
+    @Override
+    public Response intercept(Chain chain) throws IOException {
+        Response cacheCandidate = cache != null
+                ? cache.get(chain.request())
+                : null;
 
-    // If we're forbidden from using the network and the cache is insufficient, fail.
-    if (networkRequest == null && cacheResponse == null) {
-      return new Response.Builder()
-          .request(chain.request())
-          .protocol(Protocol.HTTP_1_1)
-          .code(504)
-          .message("Unsatisfiable Request (only-if-cached)")
-          .body(Util.EMPTY_RESPONSE)
-          .sentRequestAtMillis(-1L)
-          .receivedResponseAtMillis(System.currentTimeMillis())
-          .build();
-    }
+        long now = System.currentTimeMillis();
 
-    // If we don't need the network, we're done.
-    if (networkRequest == null) {
-      return cacheResponse.newBuilder()
-          .cacheResponse(stripBody(cacheResponse))
-          .build();
-    }
+        CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();
+        Request networkRequest = strategy.networkRequest;
+        Response cacheResponse = strategy.cacheResponse;
 
-    Response networkResponse = null;
-    try {
-      networkResponse = chain.proceed(networkRequest);
-    } finally {
-      // If we're crashing on I/O or otherwise, don't leak the cache body.
-      if (networkResponse == null && cacheCandidate != null) {
-        closeQuietly(cacheCandidate.body());
-      }
-    }
+        if (cache != null) {
+            cache.trackResponse(strategy);
+        }
 
-    // If we have a cache response too, then we're doing a conditional get.
-    if (cacheResponse != null) {
-      if (networkResponse.code() == HTTP_NOT_MODIFIED) {
-        Response response = cacheResponse.newBuilder()
-            .headers(combine(cacheResponse.headers(), networkResponse.headers()))
-            .sentRequestAtMillis(networkResponse.sentRequestAtMillis())
-            .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())
-            .cacheResponse(stripBody(cacheResponse))
-            .networkResponse(stripBody(networkResponse))
-            .build();
-        networkResponse.body().close();
-
-        // Update the cache after combining headers but before stripping the
-        // Content-Encoding header (as performed by initContentStream()).
-        cache.trackConditionalCacheHit();
-        cache.update(cacheResponse, response);
-        return response;
-      } else {
-        closeQuietly(cacheResponse.body());
-      }
-    }
+        if (cacheCandidate != null && cacheResponse == null) {
+            closeQuietly(cacheCandidate.body()); // The cache candidate wasn't applicable. Close it.
+        }
 
-    Response response = networkResponse.newBuilder()
-        .cacheResponse(stripBody(cacheResponse))
-        .networkResponse(stripBody(networkResponse))
-        .build();
+        // If we're forbidden from using the network and the cache is insufficient, fail.
+        if (networkRequest == null && cacheResponse == null) {
+            return new Response.Builder()
+                    .request(chain.request())
+                    .protocol(Protocol.HTTP_1_1)
+                    .code(504)
+                    .message("Unsatisfiable Request (only-if-cached)")
+                    .body(Util.EMPTY_RESPONSE)
+                    .sentRequestAtMillis(-1L)
+                    .receivedResponseAtMillis(System.currentTimeMillis())
+                    .build();
+        }
 
-    if (cache != null) {
-      if (HttpHeaders.hasBody(response) && CacheStrategy.isCacheable(response, networkRequest)) {
-        // Offer this request to the cache.
-        CacheRequest cacheRequest = cache.put(response);
-        return cacheWritingResponse(cacheRequest, response);
-      }
+        // If we don't need the network, we're done.
+        if (networkRequest == null) {
+            return cacheResponse.newBuilder()
+                    .cacheResponse(stripBody(cacheResponse))
+                    .build();
+        }
 
-      if (HttpMethod.invalidatesCache(networkRequest.method())) {
+        Response networkResponse = null;
         try {
-          cache.remove(networkRequest);
-        } catch (IOException ignored) {
-          // The cache cannot be written.
+            networkResponse = chain.proceed(networkRequest);
+        } finally {
+            // If we're crashing on I/O or otherwise, don't leak the cache body.
+            if (networkResponse == null && cacheCandidate != null) {
+                closeQuietly(cacheCandidate.body());
+            }
         }
-      }
-    }
 
-    return response;
-  }
-
-  private static Response stripBody(Response response) {
-    return response != null && response.body() != null
-        ? response.newBuilder().body(null).build()
-        : response;
-  }
-
-  /**
-   * Returns a new source that writes bytes to {@code cacheRequest} as they are read by the source
-   * consumer. This is careful to discard bytes left over when the stream is closed; otherwise we
-   * may never exhaust the source stream and therefore not complete the cached response.
-   */
-  private Response cacheWritingResponse(final CacheRequest cacheRequest, Response response)
-      throws IOException {
-    // Some apps return a null body; for compatibility we treat that like a null cache request.
-    if (cacheRequest == null) return response;
-    Sink cacheBodyUnbuffered = cacheRequest.body();
-    if (cacheBodyUnbuffered == null) return response;
-
-    final BufferedSource source = response.body().source();
-    final BufferedSink cacheBody = Okio.buffer(cacheBodyUnbuffered);
-
-    Source cacheWritingSource = new Source() {
-      boolean cacheRequestClosed;
-
-      @Override public long read(Buffer sink, long byteCount) throws IOException {
-        long bytesRead;
-        try {
-          bytesRead = source.read(sink, byteCount);
-        } catch (IOException e) {
-          if (!cacheRequestClosed) {
-            cacheRequestClosed = true;
-            cacheRequest.abort(); // Failed to write a complete cache response.
-          }
-          throw e;
+        // If we have a cache response too, then we're doing a conditional get.
+        if (cacheResponse != null) {
+            if (networkResponse.code() == HTTP_NOT_MODIFIED) {
+                Response response = cacheResponse.newBuilder()
+                        .headers(combine(cacheResponse.headers(), networkResponse.headers()))
+                        .sentRequestAtMillis(networkResponse.sentRequestAtMillis())
+                        .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())
+                        .cacheResponse(stripBody(cacheResponse))
+                        .networkResponse(stripBody(networkResponse))
+                        .build();
+                networkResponse.body().close();
+
+                // Update the cache after combining headers but before stripping the
+                // Content-Encoding header (as performed by initContentStream()).
+                cache.trackConditionalCacheHit();
+                cache.update(cacheResponse, response);
+                return response;
+            } else {
+                closeQuietly(cacheResponse.body());
+            }
         }
 
-        if (bytesRead == -1) {
-          if (!cacheRequestClosed) {
-            cacheRequestClosed = true;
-            cacheBody.close(); // The cache response is complete!
-          }
-          return -1;
+        Response response = networkResponse.newBuilder()
+                .cacheResponse(stripBody(cacheResponse))
+                .networkResponse(stripBody(networkResponse))
+                .build();
+
+        if (cache != null) {
+            if (HttpHeaders.hasBody(response) && CacheStrategy.isCacheable(response, networkRequest)) {
+                // Offer this request to the cache.
+                CacheRequest cacheRequest = cache.put(response);
+                return cacheWritingResponse(cacheRequest, response);
+            }
+
+            if (HttpMethod.invalidatesCache(networkRequest.method())) {
+                try {
+                    cache.remove(networkRequest);
+                } catch (IOException ignored) {
+                    // The cache cannot be written.
+                }
+            }
         }
 
-        sink.copyTo(cacheBody.buffer(), sink.size() - bytesRead, bytesRead);
-        cacheBody.emitCompleteSegments();
-        return bytesRead;
-      }
+        return response;
+    }
 
-      @Override public Timeout timeout() {
-        return source.timeout();
-      }
+    private static Response stripBody(Response response) {
+        return response != null && response.body() != null
+                ? response.newBuilder().body(null).build()
+                : response;
+    }
 
-      @Override public void close() throws IOException {
-        if (!cacheRequestClosed
-            && !discard(this, HttpCodec.DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
-          cacheRequestClosed = true;
-          cacheRequest.abort();
+    /**
+     * Returns a new source that writes bytes to {@code cacheRequest} as they are read by the source
+     * consumer. This is careful to discard bytes left over when the stream is closed; otherwise we
+     * may never exhaust the source stream and therefore not complete the cached response.
+     */
+    private Response cacheWritingResponse(final CacheRequest cacheRequest, Response response)
+            throws IOException {
+        // Some apps return a null body; for compatibility we treat that like a null cache request.
+        if (cacheRequest == null) return response;
+        Sink cacheBodyUnbuffered = cacheRequest.body();
+        if (cacheBodyUnbuffered == null) return response;
+
+        final BufferedSource source = response.body().source();
+        final BufferedSink cacheBody = Okio.buffer(cacheBodyUnbuffered);
+
+        Source cacheWritingSource = new Source() {
+            boolean cacheRequestClosed;
+
+            @Override
+            public long read(Buffer sink, long byteCount) throws IOException {
+                long bytesRead;
+                try {
+                    bytesRead = source.read(sink, byteCount);
+                } catch (IOException e) {
+                    if (!cacheRequestClosed) {
+                        cacheRequestClosed = true;
+                        cacheRequest.abort(); // Failed to write a complete cache response.
+                    }
+                    throw e;
+                }
+
+                if (bytesRead == -1) {
+                    if (!cacheRequestClosed) {
+                        cacheRequestClosed = true;
+                        cacheBody.close(); // The cache response is complete!
+                    }
+                    return -1;
+                }
+
+                sink.copyTo(cacheBody.buffer(), sink.size() - bytesRead, bytesRead);
+                cacheBody.emitCompleteSegments();
+                return bytesRead;
+            }
+
+            @Override
+            public Timeout timeout() {
+                return source.timeout();
+            }
+
+            @Override
+            public void close() throws IOException {
+                if (!cacheRequestClosed
+                        && !discard(this, HttpCodec.DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
+                    cacheRequestClosed = true;
+                    cacheRequest.abort();
+                }
+                source.close();
+            }
+        };
+
+        String contentType = response.header("Content-Type");
+        long contentLength = response.body().contentLength();
+        return response.newBuilder()
+                .body(new RealResponseBody(contentType, contentLength, Okio.buffer(cacheWritingSource)))
+                .build();
+    }
+
+    /**
+     * Combines cached headers with a network headers as defined by RFC 7234, 4.3.4.
+     */
+    private static Headers combine(Headers cachedHeaders, Headers networkHeaders) {
+        Headers.Builder result = new Headers.Builder();
+
+        for (int i = 0, size = cachedHeaders.size(); i < size; i++) {
+            String fieldName = cachedHeaders.name(i);
+            String value = cachedHeaders.value(i);
+            if ("Warning".equalsIgnoreCase(fieldName) && value.startsWith("1")) {
+                continue; // Drop 100-level freshness warnings.
+            }
+            if (isContentSpecificHeader(fieldName) || !isEndToEnd(fieldName)
+                    || networkHeaders.get(fieldName) == null) {
+                Internal.instance.addLenient(result, fieldName, value);
+            }
+        }
+
+        for (int i = 0, size = networkHeaders.size(); i < size; i++) {
+            String fieldName = networkHeaders.name(i);
+            if (!isContentSpecificHeader(fieldName) && isEndToEnd(fieldName)) {
+                Internal.instance.addLenient(result, fieldName, networkHeaders.value(i));
+            }
         }
-        source.close();
-      }
-    };
-
-    String contentType = response.header("Content-Type");
-    long contentLength = response.body().contentLength();
-    return response.newBuilder()
-        .body(new RealResponseBody(contentType, contentLength, Okio.buffer(cacheWritingSource)))
-        .build();
-  }
-
-  /** Combines cached headers with a network headers as defined by RFC 7234, 4.3.4. */
-  private static Headers combine(Headers cachedHeaders, Headers networkHeaders) {
-    Headers.Builder result = new Headers.Builder();
-
-    for (int i = 0, size = cachedHeaders.size(); i < size; i++) {
-      String fieldName = cachedHeaders.name(i);
-      String value = cachedHeaders.value(i);
-      if ("Warning".equalsIgnoreCase(fieldName) && value.startsWith("1")) {
-        continue; // Drop 100-level freshness warnings.
-      }
-      if (isContentSpecificHeader(fieldName) || !isEndToEnd(fieldName)
-              || networkHeaders.get(fieldName) == null) {
-        Internal.instance.addLenient(result, fieldName, value);
-      }
+
+        return result.build();
     }
 
-    for (int i = 0, size = networkHeaders.size(); i < size; i++) {
-      String fieldName = networkHeaders.name(i);
-      if (!isContentSpecificHeader(fieldName) && isEndToEnd(fieldName)) {
-        Internal.instance.addLenient(result, fieldName, networkHeaders.value(i));
-      }
+    /**
+     * Returns true if {@code fieldName} is an end-to-end HTTP header, as defined by RFC 2616,
+     * 13.5.1.
+     */
+    static boolean isEndToEnd(String fieldName) {
+        return !"Connection".equalsIgnoreCase(fieldName)
+                && !"Keep-Alive".equalsIgnoreCase(fieldName)
+                && !"Proxy-Authenticate".equalsIgnoreCase(fieldName)
+                && !"Proxy-Authorization".equalsIgnoreCase(fieldName)
+                && !"TE".equalsIgnoreCase(fieldName)
+                && !"Trailers".equalsIgnoreCase(fieldName)
+                && !"Transfer-Encoding".equalsIgnoreCase(fieldName)
+                && !"Upgrade".equalsIgnoreCase(fieldName);
     }
 
-    return result.build();
-  }
-
-  /**
-   * Returns true if {@code fieldName} is an end-to-end HTTP header, as defined by RFC 2616,
-   * 13.5.1.
-   */
-  static boolean isEndToEnd(String fieldName) {
-    return !"Connection".equalsIgnoreCase(fieldName)
-        && !"Keep-Alive".equalsIgnoreCase(fieldName)
-        && !"Proxy-Authenticate".equalsIgnoreCase(fieldName)
-        && !"Proxy-Authorization".equalsIgnoreCase(fieldName)
-        && !"TE".equalsIgnoreCase(fieldName)
-        && !"Trailers".equalsIgnoreCase(fieldName)
-        && !"Transfer-Encoding".equalsIgnoreCase(fieldName)
-        && !"Upgrade".equalsIgnoreCase(fieldName);
-  }
-
-  /**
-   * Returns true if {@code fieldName} is content specific and therefore should always be used
-   * from cached headers.
-   */
-  static boolean isContentSpecificHeader(String fieldName) {
-    return "Content-Length".equalsIgnoreCase(fieldName)
-        || "Content-Encoding".equalsIgnoreCase(fieldName)
-        || "Content-Type".equalsIgnoreCase(fieldName);
-  }
+    /**
+     * Returns true if {@code fieldName} is content specific and therefore should always be used
+     * from cached headers.
+     */
+    static boolean isContentSpecificHeader(String fieldName) {
+        return "Content-Length".equalsIgnoreCase(fieldName)
+                || "Content-Encoding".equalsIgnoreCase(fieldName)
+                || "Content-Type".equalsIgnoreCase(fieldName);
+    }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/ConnectInterceptor.java b/okhttp/src/main/java/okhttp3/internal/connection/ConnectInterceptor.java
index b8a346c03a..542e0946d1 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/ConnectInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/ConnectInterceptor.java
@@ -17,6 +17,7 @@
 package okhttp3.internal.connection;
 
 import java.io.IOException;
+
 import okhttp3.Interceptor;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
@@ -24,24 +25,27 @@
 import okhttp3.internal.http.HttpCodec;
 import okhttp3.internal.http.RealInterceptorChain;
 
-/** Opens a connection to the target server and proceeds to the next interceptor. */
+/**
+ * Opens a connection to the target server and proceeds to the next interceptor.
+ */
 public final class ConnectInterceptor implements Interceptor {
-  public final OkHttpClient client;
+    public final OkHttpClient client;
 
-  public ConnectInterceptor(OkHttpClient client) {
-    this.client = client;
-  }
+    public ConnectInterceptor(OkHttpClient client) {
+        this.client = client;
+    }
 
-  @Override public Response intercept(Chain chain) throws IOException {
-    RealInterceptorChain realChain = (RealInterceptorChain) chain;
-    Request request = realChain.request();
-    StreamAllocation streamAllocation = realChain.streamAllocation();
+    @Override
+    public Response intercept(Chain chain) throws IOException {
+        RealInterceptorChain realChain = (RealInterceptorChain) chain;
+        Request request = realChain.request();
+        StreamAllocation streamAllocation = realChain.streamAllocation();
 
-    // We need the network to satisfy this request. Possibly for validating a conditional GET.
-    boolean doExtensiveHealthChecks = !request.method().equals("GET");
-    HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks);
-    RealConnection connection = streamAllocation.connection();
+        // We need the network to satisfy this request. Possibly for validating a conditional GET.
+        boolean doExtensiveHealthChecks = !request.method().equals("GET");
+        HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks);
+        RealConnection connection = streamAllocation.connection();
 
-    return realChain.proceed(request, streamAllocation, httpCodec, connection);
-  }
+        return realChain.proceed(request, streamAllocation, httpCodec, connection);
+    }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java b/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
index 3c621721e0..e1291cc8c2 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
@@ -287,6 +287,7 @@ private void connectSocket(int connectTimeout, int readTimeout, Call call,
     private void establishProtocol(ConnectionSpecSelector connectionSpecSelector,
                                    int pingIntervalMillis, Call call, EventListener eventListener) throws IOException {
         if (route.address().sslSocketFactory() == null) {
+            // 如果是http,Address中的SSLSocketFactory的实例为null,也就不执行后面的TSL握手
             if (route.address().protocols().contains(Protocol.H2_PRIOR_KNOWLEDGE)) {
                 socket = rawSocket;
                 protocol = Protocol.H2_PRIOR_KNOWLEDGE;
diff --git a/okhttp/src/main/java/okhttp3/internal/duplex/DuplexRequestBody.java b/okhttp/src/main/java/okhttp3/internal/duplex/DuplexRequestBody.java
index bc128b5f06..684bf23744 100644
--- a/okhttp/src/main/java/okhttp3/internal/duplex/DuplexRequestBody.java
+++ b/okhttp/src/main/java/okhttp3/internal/duplex/DuplexRequestBody.java
@@ -18,6 +18,7 @@
 import java.io.IOException;
 import java.io.InterruptedIOException;
 import javax.annotation.Nullable;
+
 import okhttp3.Call;
 import okhttp3.Callback;
 import okhttp3.MediaType;
@@ -54,69 +55,78 @@
  * {@link okhttp3.logging.HttpLoggingInterceptor logging interceptor}.
  */
 public final class DuplexRequestBody extends RequestBody implements Callback {
-  private final Pipe pipe;
-  private final @Nullable MediaType contentType;
-  private @Nullable IOException failure;
-  private @Nullable Response response;
-  private boolean enqueued;
+    private final Pipe pipe;
+    private final @Nullable
+    MediaType contentType;
+    private @Nullable
+    IOException failure;
+    private @Nullable
+    Response response;
+    private boolean enqueued;
 
-  // TODO(jwilson/oldergod): include content-length? Callers might know it!
-  public DuplexRequestBody(@Nullable MediaType contentType, long pipeMaxBufferSize) {
-    this.pipe = new Pipe(pipeMaxBufferSize);
-    this.contentType = contentType;
-  }
+    // TODO(jwilson/oldergod): include content-length? Callers might know it!
+    public DuplexRequestBody(@Nullable MediaType contentType, long pipeMaxBufferSize) {
+        this.pipe = new Pipe(pipeMaxBufferSize);
+        this.contentType = contentType;
+    }
 
-  public BufferedSink createSink(Call call) {
-    call.enqueue(this);
-    enqueued = true;
-    return Okio.buffer(pipe.sink());
-  }
+    public BufferedSink createSink(Call call) {
+        call.enqueue(this);
+        enqueued = true;
+        return Okio.buffer(pipe.sink());
+    }
 
-  public void foldSink(Sink requestBodyOut) throws IOException {
-    // TODO: replace with okio Pipe#fold when released
-    Thread thread = new Thread("duplex folder thingy") {
-      @Override public void run() {
-        try (BufferedSink requestBody = Okio.buffer(requestBodyOut)) {
-          requestBody.writeAll(pipe.source());
-        } catch (IOException e) {
-          e.printStackTrace(); // TODO: actual fold should fix this.
-        }
-      }
-    };
-    thread.start();
-  }
+    public void foldSink(Sink requestBodyOut) throws IOException {
+        // TODO: replace with okio Pipe#fold when released
+        Thread thread = new Thread("duplex folder thingy") {
+            @Override
+            public void run() {
+                try (BufferedSink requestBody = Okio.buffer(requestBodyOut)) {
+                    requestBody.writeAll(pipe.source());
+                } catch (IOException e) {
+                    e.printStackTrace(); // TODO: actual fold should fix this.
+                }
+            }
+        };
+        thread.start();
+    }
 
-  @Override public synchronized void onFailure(Call call, IOException e) {
-    if (this.failure != null || this.response != null) throw new IllegalStateException();
-    this.failure = e;
-    notifyAll();
-  }
+    @Override
+    public synchronized void onFailure(Call call, IOException e) {
+        if (this.failure != null || this.response != null) throw new IllegalStateException();
+        this.failure = e;
+        notifyAll();
+    }
 
-  @Override public synchronized void onResponse(Call call, Response response) {
-    if (this.failure != null || this.response != null) throw new IllegalStateException();
-    this.response = response;
-    notifyAll();
-  }
+    @Override
+    public synchronized void onResponse(Call call, Response response) {
+        if (this.failure != null || this.response != null) throw new IllegalStateException();
+        this.response = response;
+        notifyAll();
+    }
 
-  public synchronized Response awaitExecute() throws IOException {
-    if (!enqueued) throw new IllegalStateException("body isn't enqueued.");
-    try {
-      while (failure == null && response == null) {
-        wait();
-      }
-      if (failure != null) throw failure;
-      return response;
-    } catch (InterruptedException e) {
-      Thread.currentThread().interrupt(); // Retain interrupted status.
-      throw new InterruptedIOException();
+    public synchronized Response awaitExecute() throws IOException {
+        if (!enqueued) throw new IllegalStateException("body isn't enqueued.");
+        try {
+            while (failure == null && response == null) {
+                wait();
+            }
+            if (failure != null) throw failure;
+            return response;
+        } catch (InterruptedException e) {
+            Thread.currentThread().interrupt(); // Retain interrupted status.
+            throw new InterruptedIOException();
+        }
     }
-  }
 
-  @Override public @Nullable MediaType contentType() {
-    return contentType;
-  }
+    @Override
+    public @Nullable
+    MediaType contentType() {
+        return contentType;
+    }
 
-  @Override public void writeTo(BufferedSink sink) {
-    throw new UnsupportedOperationException();
-  }
+    @Override
+    public void writeTo(BufferedSink sink) {
+        throw new UnsupportedOperationException();
+    }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.java
index c10dc34cdc..402f1bf78f 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.java
@@ -18,6 +18,7 @@
 
 import java.io.IOException;
 import java.util.List;
+
 import okhttp3.Cookie;
 import okhttp3.CookieJar;
 import okhttp3.Headers;
@@ -38,91 +39,94 @@
  * response.
  */
 public final class BridgeInterceptor implements Interceptor {
-  private final CookieJar cookieJar;
-
-  public BridgeInterceptor(CookieJar cookieJar) {
-    this.cookieJar = cookieJar;
-  }
-
-  @Override public Response intercept(Chain chain) throws IOException {
-    Request userRequest = chain.request();
-    Request.Builder requestBuilder = userRequest.newBuilder();
-
-    RequestBody body = userRequest.body();
-    if (body != null) {
-      MediaType contentType = body.contentType();
-      if (contentType != null) {
-        requestBuilder.header("Content-Type", contentType.toString());
-      }
-
-      long contentLength = body.contentLength();
-      if (contentLength != -1) {
-        requestBuilder.header("Content-Length", Long.toString(contentLength));
-        requestBuilder.removeHeader("Transfer-Encoding");
-      } else {
-        requestBuilder.header("Transfer-Encoding", "chunked");
-        requestBuilder.removeHeader("Content-Length");
-      }
-    }
-
-    if (userRequest.header("Host") == null) {
-      requestBuilder.header("Host", hostHeader(userRequest.url(), false));
-    }
+    private final CookieJar cookieJar;
 
-    if (userRequest.header("Connection") == null) {
-      requestBuilder.header("Connection", "Keep-Alive");
+    public BridgeInterceptor(CookieJar cookieJar) {
+        this.cookieJar = cookieJar;
     }
 
-    // If we add an "Accept-Encoding: gzip" header field we're responsible for also decompressing
-    // the transfer stream.
-    boolean transparentGzip = false;
-    if (userRequest.header("Accept-Encoding") == null && userRequest.header("Range") == null) {
-      transparentGzip = true;
-      requestBuilder.header("Accept-Encoding", "gzip");
-    }
-
-    List<Cookie> cookies = cookieJar.loadForRequest(userRequest.url());
-    if (!cookies.isEmpty()) {
-      requestBuilder.header("Cookie", cookieHeader(cookies));
-    }
-
-    if (userRequest.header("User-Agent") == null) {
-      requestBuilder.header("User-Agent", Version.userAgent());
-    }
-
-    Response networkResponse = chain.proceed(requestBuilder.build());
-
-    HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());
-
-    Response.Builder responseBuilder = networkResponse.newBuilder()
-        .request(userRequest);
-
-    if (transparentGzip
-        && "gzip".equalsIgnoreCase(networkResponse.header("Content-Encoding"))
-        && HttpHeaders.hasBody(networkResponse)) {
-      GzipSource responseBody = new GzipSource(networkResponse.body().source());
-      Headers strippedHeaders = networkResponse.headers().newBuilder()
-          .removeAll("Content-Encoding")
-          .removeAll("Content-Length")
-          .build();
-      responseBuilder.headers(strippedHeaders);
-      String contentType = networkResponse.header("Content-Type");
-      responseBuilder.body(new RealResponseBody(contentType, -1L, Okio.buffer(responseBody)));
+    @Override
+    public Response intercept(Chain chain) throws IOException {
+        Request userRequest = chain.request();
+        Request.Builder requestBuilder = userRequest.newBuilder();
+
+        RequestBody body = userRequest.body();
+        if (body != null) {
+            MediaType contentType = body.contentType();
+            if (contentType != null) {
+                requestBuilder.header("Content-Type", contentType.toString());
+            }
+
+            long contentLength = body.contentLength();
+            if (contentLength != -1) {
+                requestBuilder.header("Content-Length", Long.toString(contentLength));
+                requestBuilder.removeHeader("Transfer-Encoding");
+            } else {
+                requestBuilder.header("Transfer-Encoding", "chunked");
+                requestBuilder.removeHeader("Content-Length");
+            }
+        }
+
+        if (userRequest.header("Host") == null) {
+            requestBuilder.header("Host", hostHeader(userRequest.url(), false));
+        }
+
+        if (userRequest.header("Connection") == null) {
+            requestBuilder.header("Connection", "Keep-Alive");
+        }
+
+        // If we add an "Accept-Encoding: gzip" header field we're responsible for also decompressing
+        // the transfer stream.
+        boolean transparentGzip = false;
+        if (userRequest.header("Accept-Encoding") == null && userRequest.header("Range") == null) {
+            transparentGzip = true;
+            requestBuilder.header("Accept-Encoding", "gzip");
+        }
+
+        List<Cookie> cookies = cookieJar.loadForRequest(userRequest.url());
+        if (!cookies.isEmpty()) {
+            requestBuilder.header("Cookie", cookieHeader(cookies));
+        }
+
+        if (userRequest.header("User-Agent") == null) {
+            requestBuilder.header("User-Agent", Version.userAgent());
+        }
+
+        Response networkResponse = chain.proceed(requestBuilder.build());
+
+        HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());
+
+        Response.Builder responseBuilder = networkResponse.newBuilder()
+                .request(userRequest);
+
+        if (transparentGzip
+                && "gzip".equalsIgnoreCase(networkResponse.header("Content-Encoding"))
+                && HttpHeaders.hasBody(networkResponse)) {
+            GzipSource responseBody = new GzipSource(networkResponse.body().source());
+            Headers strippedHeaders = networkResponse.headers().newBuilder()
+                    .removeAll("Content-Encoding")
+                    .removeAll("Content-Length")
+                    .build();
+            responseBuilder.headers(strippedHeaders);
+            String contentType = networkResponse.header("Content-Type");
+            responseBuilder.body(new RealResponseBody(contentType, -1L, Okio.buffer(responseBody)));
+        }
+
+        return responseBuilder.build();
     }
 
-    return responseBuilder.build();
-  }
-
-  /** Returns a 'Cookie' HTTP request header with all cookies, like {@code a=b; c=d}. */
-  private String cookieHeader(List<Cookie> cookies) {
-    StringBuilder cookieHeader = new StringBuilder();
-    for (int i = 0, size = cookies.size(); i < size; i++) {
-      if (i > 0) {
-        cookieHeader.append("; ");
-      }
-      Cookie cookie = cookies.get(i);
-      cookieHeader.append(cookie.name()).append('=').append(cookie.value());
+    /**
+     * Returns a 'Cookie' HTTP request header with all cookies, like {@code a=b; c=d}.
+     */
+    private String cookieHeader(List<Cookie> cookies) {
+        StringBuilder cookieHeader = new StringBuilder();
+        for (int i = 0, size = cookies.size(); i < size; i++) {
+            if (i > 0) {
+                cookieHeader.append("; ");
+            }
+            Cookie cookie = cookies.get(i);
+            cookieHeader.append(cookie.name()).append('=').append(cookie.value());
+        }
+        return cookieHeader.toString();
     }
-    return cookieHeader.toString();
-  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java b/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java
index 52f9880892..a024de7c2e 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java
@@ -18,6 +18,7 @@
 import java.io.IOException;
 import java.util.List;
 import java.util.concurrent.TimeUnit;
+
 import okhttp3.Call;
 import okhttp3.Connection;
 import okhttp3.EventListener;
@@ -34,134 +35,144 @@
  * interceptors, the OkHttp core, all network interceptors, and finally the network caller.
  */
 public final class RealInterceptorChain implements Interceptor.Chain {
-  private final List<Interceptor> interceptors;
-  private final StreamAllocation streamAllocation;
-  private final HttpCodec httpCodec;
-  private final RealConnection connection;
-  private final int index;
-  private final Request request;
-  private final Call call;
-  private final EventListener eventListener;
-  private final int connectTimeout;
-  private final int readTimeout;
-  private final int writeTimeout;
-  private int calls;
-
-  public RealInterceptorChain(List<Interceptor> interceptors, StreamAllocation streamAllocation,
-      HttpCodec httpCodec, RealConnection connection, int index, Request request, Call call,
-      EventListener eventListener, int connectTimeout, int readTimeout, int writeTimeout) {
-    this.interceptors = interceptors;
-    this.connection = connection;
-    this.streamAllocation = streamAllocation;
-    this.httpCodec = httpCodec;
-    this.index = index;
-    this.request = request;
-    this.call = call;
-    this.eventListener = eventListener;
-    this.connectTimeout = connectTimeout;
-    this.readTimeout = readTimeout;
-    this.writeTimeout = writeTimeout;
-  }
-
-  @Override public Connection connection() {
-    return connection;
-  }
-
-  @Override public int connectTimeoutMillis() {
-    return connectTimeout;
-  }
-
-  @Override public Interceptor.Chain withConnectTimeout(int timeout, TimeUnit unit) {
-    int millis = checkDuration("timeout", timeout, unit);
-    return new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index,
-        request, call, eventListener, millis, readTimeout, writeTimeout);
-  }
-
-  @Override public int readTimeoutMillis() {
-    return readTimeout;
-  }
-
-  @Override public Interceptor.Chain withReadTimeout(int timeout, TimeUnit unit) {
-    int millis = checkDuration("timeout", timeout, unit);
-    return new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index,
-        request, call, eventListener, connectTimeout, millis, writeTimeout);
-  }
-
-  @Override public int writeTimeoutMillis() {
-    return writeTimeout;
-  }
-
-  @Override public Interceptor.Chain withWriteTimeout(int timeout, TimeUnit unit) {
-    int millis = checkDuration("timeout", timeout, unit);
-    return new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index,
-        request, call, eventListener, connectTimeout, readTimeout, millis);
-  }
-
-  public StreamAllocation streamAllocation() {
-    return streamAllocation;
-  }
-
-  public HttpCodec httpStream() {
-    return httpCodec;
-  }
-
-  @Override public Call call() {
-    return call;
-  }
-
-  public EventListener eventListener() {
-    return eventListener;
-  }
-
-  @Override public Request request() {
-    return request;
-  }
-
-  @Override public Response proceed(Request request) throws IOException {
-    return proceed(request, streamAllocation, httpCodec, connection);
-  }
-
-  public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,
-      RealConnection connection) throws IOException {
-    if (index >= interceptors.size()) throw new AssertionError();
-
-    calls++;
-
-    // If we already have a stream, confirm that the incoming request will use it.
-    if (this.httpCodec != null && !this.connection.supportsUrl(request.url())) {
-      throw new IllegalStateException("network interceptor " + interceptors.get(index - 1)
-          + " must retain the same host and port");
+    private final List<Interceptor> interceptors;
+    private final StreamAllocation streamAllocation;
+    private final HttpCodec httpCodec;
+    private final RealConnection connection;
+    private final int index;
+    private final Request request;
+    private final Call call;
+    private final EventListener eventListener;
+    private final int connectTimeout;
+    private final int readTimeout;
+    private final int writeTimeout;
+    private int calls;
+
+    public RealInterceptorChain(List<Interceptor> interceptors, StreamAllocation streamAllocation,
+                                HttpCodec httpCodec, RealConnection connection, int index, Request request, Call call,
+                                EventListener eventListener, int connectTimeout, int readTimeout, int writeTimeout) {
+        this.interceptors = interceptors;
+        this.connection = connection;
+        this.streamAllocation = streamAllocation;
+        this.httpCodec = httpCodec;
+        this.index = index;
+        this.request = request;
+        this.call = call;
+        this.eventListener = eventListener;
+        this.connectTimeout = connectTimeout;
+        this.readTimeout = readTimeout;
+        this.writeTimeout = writeTimeout;
+    }
+
+    @Override
+    public Connection connection() {
+        return connection;
+    }
+
+    @Override
+    public int connectTimeoutMillis() {
+        return connectTimeout;
+    }
+
+    @Override
+    public Interceptor.Chain withConnectTimeout(int timeout, TimeUnit unit) {
+        int millis = checkDuration("timeout", timeout, unit);
+        return new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index,
+                request, call, eventListener, millis, readTimeout, writeTimeout);
+    }
+
+    @Override
+    public int readTimeoutMillis() {
+        return readTimeout;
+    }
+
+    @Override
+    public Interceptor.Chain withReadTimeout(int timeout, TimeUnit unit) {
+        int millis = checkDuration("timeout", timeout, unit);
+        return new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index,
+                request, call, eventListener, connectTimeout, millis, writeTimeout);
+    }
+
+    @Override
+    public int writeTimeoutMillis() {
+        return writeTimeout;
+    }
+
+    @Override
+    public Interceptor.Chain withWriteTimeout(int timeout, TimeUnit unit) {
+        int millis = checkDuration("timeout", timeout, unit);
+        return new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index,
+                request, call, eventListener, connectTimeout, readTimeout, millis);
     }
 
-    // If we already have a stream, confirm that this is the only call to chain.proceed().
-    if (this.httpCodec != null && calls > 1) {
-      throw new IllegalStateException("network interceptor " + interceptors.get(index - 1)
-          + " must call proceed() exactly once");
+    public StreamAllocation streamAllocation() {
+        return streamAllocation;
     }
 
-    // Call the next interceptor in the chain.
-    RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,
-        connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,
-        writeTimeout);
-    Interceptor interceptor = interceptors.get(index);
-    Response response = interceptor.intercept(next);
-
-    // Confirm that the next interceptor made its required call to chain.proceed().
-    if (httpCodec != null && index + 1 < interceptors.size() && next.calls != 1) {
-      throw new IllegalStateException("network interceptor " + interceptor
-          + " must call proceed() exactly once");
+    public HttpCodec httpStream() {
+        return httpCodec;
     }
 
-    // Confirm that the intercepted response isn't null.
-    if (response == null) {
-      throw new NullPointerException("interceptor " + interceptor + " returned null");
+    @Override
+    public Call call() {
+        return call;
     }
 
-    if (response.body() == null) {
-      throw new IllegalStateException(
-          "interceptor " + interceptor + " returned a response with no body");
+    public EventListener eventListener() {
+        return eventListener;
     }
 
-    return response;
-  }
+    @Override
+    public Request request() {
+        return request;
+    }
+
+    @Override
+    public Response proceed(Request request) throws IOException {
+        return proceed(request, streamAllocation, httpCodec, connection);
+    }
+
+    public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,
+                            RealConnection connection) throws IOException {
+        if (index >= interceptors.size()) throw new AssertionError();
+
+        calls++;
+
+        // If we already have a stream, confirm that the incoming request will use it.
+        if (this.httpCodec != null && !this.connection.supportsUrl(request.url())) {
+            throw new IllegalStateException("network interceptor " + interceptors.get(index - 1)
+                    + " must retain the same host and port");
+        }
+
+        // If we already have a stream, confirm that this is the only call to chain.proceed().
+        if (this.httpCodec != null && calls > 1) {
+            throw new IllegalStateException("network interceptor " + interceptors.get(index - 1)
+                    + " must call proceed() exactly once");
+        }
+
+        // Call the next interceptor in the chain.
+        RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,
+                connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,
+                writeTimeout);
+        Interceptor interceptor = interceptors.get(index);
+        Response response = interceptor.intercept(next);
+
+        // Confirm that the next interceptor made its required call to chain.proceed().
+        if (httpCodec != null && index + 1 < interceptors.size() && next.calls != 1) {
+            throw new IllegalStateException("network interceptor " + interceptor
+                    + " must call proceed() exactly once");
+        }
+
+        // Confirm that the intercepted response isn't null.
+        if (response == null) {
+            throw new NullPointerException("interceptor " + interceptor + " returned null");
+        }
+
+        if (response.body() == null) {
+            throw new IllegalStateException(
+                    "interceptor " + interceptor + " returned a response with no body");
+        }
+
+        return response;
+    }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
index fa72df373b..00e8ea7c3f 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
@@ -27,6 +27,7 @@
 import javax.net.ssl.SSLHandshakeException;
 import javax.net.ssl.SSLPeerUnverifiedException;
 import javax.net.ssl.SSLSocketFactory;
+
 import okhttp3.Address;
 import okhttp3.Call;
 import okhttp3.CertificatePinner;
@@ -59,362 +60,363 @@
  * {@link IOException} if the call was canceled.
  */
 public final class RetryAndFollowUpInterceptor implements Interceptor {
-  /**
-   * How many redirects and auth challenges should we attempt? Chrome follows 21 redirects; Firefox,
-   * curl, and wget follow 20; Safari follows 16; and HTTP/1.0 recommends 5.
-   */
-  private static final int MAX_FOLLOW_UPS = 20;
-
-  private final OkHttpClient client;
-  private volatile StreamAllocation streamAllocation;
-  private Object callStackTrace;
-  private volatile boolean canceled;
-
-  public RetryAndFollowUpInterceptor(OkHttpClient client) {
-    this.client = client;
-  }
-
-  /**
-   * Immediately closes the socket connection if it's currently held. Use this to interrupt an
-   * in-flight request from any thread. It's the caller's responsibility to close the request body
-   * and response body streams; otherwise resources may be leaked.
-   *
-   * <p>This method is safe to be called concurrently, but provides limited guarantees. If a
-   * transport layer connection has been established (such as a HTTP/2 stream) that is terminated.
-   * Otherwise if a socket connection is being established, that is terminated.
-   */
-  public void cancel() {
-    canceled = true;
-    StreamAllocation streamAllocation = this.streamAllocation;
-    if (streamAllocation != null) streamAllocation.cancel();
-  }
-
-  public boolean isCanceled() {
-    return canceled;
-  }
-
-  public void setCallStackTrace(Object callStackTrace) {
-    this.callStackTrace = callStackTrace;
-  }
-
-  public StreamAllocation streamAllocation() {
-    return streamAllocation;
-  }
-
-  @Override public Response intercept(Chain chain) throws IOException {
-    Request request = chain.request();
-    RealInterceptorChain realChain = (RealInterceptorChain) chain;
-    Call call = realChain.call();
-    EventListener eventListener = realChain.eventListener();
-
-    StreamAllocation streamAllocation = new StreamAllocation(client.connectionPool(),
-        createAddress(request.url()), call, eventListener, callStackTrace);
-    this.streamAllocation = streamAllocation;
-
-    int followUpCount = 0;
-    Response priorResponse = null;
-    while (true) {
-      if (canceled) {
-        streamAllocation.release(true);
-        throw new IOException("Canceled");
-      }
-
-      Response response;
-      boolean releaseConnection = true;
-      try {
-        response = realChain.proceed(request, streamAllocation, null, null);
-        releaseConnection = false;
-      } catch (RouteException e) {
-        // The attempt to connect via a route failed. The request will not have been sent.
-        if (!recover(e.getLastConnectException(), streamAllocation, false, request)) {
-          throw e.getFirstConnectException();
-        }
-        releaseConnection = false;
-        continue;
-      } catch (IOException e) {
-        // An attempt to communicate with a server failed. The request may have been sent.
-        boolean requestSendStarted = !(e instanceof ConnectionShutdownException);
-        if (!recover(e, streamAllocation, requestSendStarted, request)) throw e;
-        releaseConnection = false;
-        continue;
-      } finally {
-        // We're throwing an unchecked exception. Release any resources.
-        if (releaseConnection) {
-          streamAllocation.streamFailed(null);
-          streamAllocation.release(true);
-        }
-      }
-
-      // Attach the prior response if it exists. Such responses never have a body.
-      if (priorResponse != null) {
-        response = response.newBuilder()
-            .priorResponse(priorResponse.newBuilder()
-                    .body(null)
-                    .build())
-            .build();
-      }
-
-      Request followUp;
-      try {
-        followUp = followUpRequest(response, streamAllocation.route());
-      } catch (IOException e) {
-        streamAllocation.release(true);
-        throw e;
-      }
-
-      if (followUp == null) {
-        streamAllocation.release(true);
-        return response;
-      }
-
-      closeQuietly(response.body());
-
-      if (++followUpCount > MAX_FOLLOW_UPS) {
-        streamAllocation.release(true);
-        throw new ProtocolException("Too many follow-up requests: " + followUpCount);
-      }
-
-      if (followUp.body() instanceof UnrepeatableRequestBody) {
-        streamAllocation.release(true);
-        throw new HttpRetryException("Cannot retry streamed HTTP body", response.code());
-      }
-
-      if (!sameConnection(response, followUp.url())) {
-        streamAllocation.release(false);
-        streamAllocation = new StreamAllocation(client.connectionPool(),
-            createAddress(followUp.url()), call, eventListener, callStackTrace);
-        this.streamAllocation = streamAllocation;
-      } else if (streamAllocation.codec() != null) {
-        throw new IllegalStateException("Closing the body of " + response
-            + " didn't close its backing stream. Bad interceptor?");
-      }
-
-      request = followUp;
-      priorResponse = response;
-    }
-  }
-
-  private Address createAddress(HttpUrl url) {
-    SSLSocketFactory sslSocketFactory = null;
-    HostnameVerifier hostnameVerifier = null;
-    CertificatePinner certificatePinner = null;
-    if (url.isHttps()) {
-      sslSocketFactory = client.sslSocketFactory();
-      hostnameVerifier = client.hostnameVerifier();
-      certificatePinner = client.certificatePinner();
+    /**
+     * How many redirects and auth challenges should we attempt? Chrome follows 21 redirects; Firefox,
+     * curl, and wget follow 20; Safari follows 16; and HTTP/1.0 recommends 5.
+     */
+    private static final int MAX_FOLLOW_UPS = 20;
+
+    private final OkHttpClient client;
+    private volatile StreamAllocation streamAllocation;
+    private Object callStackTrace;
+    private volatile boolean canceled;
+
+    public RetryAndFollowUpInterceptor(OkHttpClient client) {
+        this.client = client;
     }
 
-    return new Address(url.host(), url.port(), client.dns(), client.socketFactory(),
-        sslSocketFactory, hostnameVerifier, certificatePinner, client.proxyAuthenticator(),
-        client.proxy(), client.protocols(), client.connectionSpecs(), client.proxySelector());
-  }
-
-  /**
-   * Report and attempt to recover from a failure to communicate with a server. Returns true if
-   * {@code e} is recoverable, or false if the failure is permanent. Requests with a body can only
-   * be recovered if the body is buffered or if the failure occurred before the request has been
-   * sent.
-   */
-  private boolean recover(IOException e, StreamAllocation streamAllocation,
-      boolean requestSendStarted, Request userRequest) {
-    streamAllocation.streamFailed(e);
-
-    // The application layer has forbidden retries.
-    if (!client.retryOnConnectionFailure()) return false;
-
-    // We can't send the request body again.
-    if (requestSendStarted && requestIsUnrepeatable(e, userRequest)) return false;
-
-    // This exception is fatal.
-    if (!isRecoverable(e, requestSendStarted)) return false;
-
-    // No more routes to attempt.
-    if (!streamAllocation.hasMoreRoutes()) return false;
-
-    // For failure recovery, use the same route selector with a new connection.
-    return true;
-  }
-
-  private boolean requestIsUnrepeatable(IOException e, Request userRequest) {
-    return userRequest.body() instanceof UnrepeatableRequestBody
-        || e instanceof FileNotFoundException;
-  }
-
-  private boolean isRecoverable(IOException e, boolean requestSendStarted) {
-    // If there was a protocol problem, don't recover.
-    if (e instanceof ProtocolException) {
-      return false;
+    /**
+     * Immediately closes the socket connection if it's currently held. Use this to interrupt an
+     * in-flight request from any thread. It's the caller's responsibility to close the request body
+     * and response body streams; otherwise resources may be leaked.
+     *
+     * <p>This method is safe to be called concurrently, but provides limited guarantees. If a
+     * transport layer connection has been established (such as a HTTP/2 stream) that is terminated.
+     * Otherwise if a socket connection is being established, that is terminated.
+     */
+    public void cancel() {
+        canceled = true;
+        StreamAllocation streamAllocation = this.streamAllocation;
+        if (streamAllocation != null) streamAllocation.cancel();
     }
 
-    // If there was an interruption don't recover, but if there was a timeout connecting to a route
-    // we should try the next route (if there is one).
-    if (e instanceof InterruptedIOException) {
-      return e instanceof SocketTimeoutException && !requestSendStarted;
+    public boolean isCanceled() {
+        return canceled;
     }
 
-    // Look for known client-side or negotiation errors that are unlikely to be fixed by trying
-    // again with a different route.
-    if (e instanceof SSLHandshakeException) {
-      // If the problem was a CertificateException from the X509TrustManager,
-      // do not retry.
-      if (e.getCause() instanceof CertificateException) {
-        return false;
-      }
+    public void setCallStackTrace(Object callStackTrace) {
+        this.callStackTrace = callStackTrace;
     }
-    if (e instanceof SSLPeerUnverifiedException) {
-      // e.g. a certificate pinning error.
-      return false;
+
+    public StreamAllocation streamAllocation() {
+        return streamAllocation;
     }
 
-    // An example of one we might want to retry with a different route is a problem connecting to a
-    // proxy and would manifest as a standard IOException. Unless it is one we know we should not
-    // retry, we return true and try a new route.
-    return true;
-  }
-
-  /**
-   * Figures out the HTTP request to make in response to receiving {@code userResponse}. This will
-   * either add authentication headers, follow redirects or handle a client request timeout. If a
-   * follow-up is either unnecessary or not applicable, this returns null.
-   */
-  private Request followUpRequest(Response userResponse, Route route) throws IOException {
-    if (userResponse == null) throw new IllegalStateException();
-    int responseCode = userResponse.code();
-
-    final String method = userResponse.request().method();
-    switch (responseCode) {
-      case HTTP_PROXY_AUTH:
-        Proxy selectedProxy = route != null
-            ? route.proxy()
-            : client.proxy();
-        if (selectedProxy.type() != Proxy.Type.HTTP) {
-          throw new ProtocolException("Received HTTP_PROXY_AUTH (407) code while not using proxy");
-        }
-        return client.proxyAuthenticator().authenticate(route, userResponse);
+    @Override
+    public Response intercept(Chain chain) throws IOException {
+        Request request = chain.request();
+        RealInterceptorChain realChain = (RealInterceptorChain) chain;
+        Call call = realChain.call();
+        EventListener eventListener = realChain.eventListener();
 
-      case HTTP_UNAUTHORIZED:
-        return client.authenticator().authenticate(route, userResponse);
+        StreamAllocation streamAllocation = new StreamAllocation(client.connectionPool(),
+                createAddress(request.url()), call, eventListener, callStackTrace);
+        this.streamAllocation = streamAllocation;
 
-      case HTTP_PERM_REDIRECT:
-      case HTTP_TEMP_REDIRECT:
-        // "If the 307 or 308 status code is received in response to a request other than GET
-        // or HEAD, the user agent MUST NOT automatically redirect the request"
-        if (!method.equals("GET") && !method.equals("HEAD")) {
-          return null;
-        }
-        // fall-through
-      case HTTP_MULT_CHOICE:
-      case HTTP_MOVED_PERM:
-      case HTTP_MOVED_TEMP:
-      case HTTP_SEE_OTHER:
-        // Does the client allow redirects?
-        if (!client.followRedirects()) return null;
-
-        String location = userResponse.header("Location");
-        if (location == null) return null;
-        HttpUrl url = userResponse.request().url().resolve(location);
-
-        // Don't follow redirects to unsupported protocols.
-        if (url == null) return null;
-
-        // If configured, don't follow redirects between SSL and non-SSL.
-        boolean sameScheme = url.scheme().equals(userResponse.request().url().scheme());
-        if (!sameScheme && !client.followSslRedirects()) return null;
-
-        // Most redirects don't include a request body.
-        Request.Builder requestBuilder = userResponse.request().newBuilder();
-        if (HttpMethod.permitsRequestBody(method)) {
-          final boolean maintainBody = HttpMethod.redirectsWithBody(method);
-          if (HttpMethod.redirectsToGet(method)) {
-            requestBuilder.method("GET", null);
-          } else {
-            RequestBody requestBody = maintainBody ? userResponse.request().body() : null;
-            requestBuilder.method(method, requestBody);
-          }
-          if (!maintainBody) {
-            requestBuilder.removeHeader("Transfer-Encoding");
-            requestBuilder.removeHeader("Content-Length");
-            requestBuilder.removeHeader("Content-Type");
-          }
+        int followUpCount = 0;
+        Response priorResponse = null;
+        while (true) {
+            if (canceled) {
+                streamAllocation.release(true);
+                throw new IOException("Canceled");
+            }
+
+            Response response;
+            boolean releaseConnection = true;
+            try {
+                response = realChain.proceed(request, streamAllocation, null, null);
+                releaseConnection = false;
+            } catch (RouteException e) {
+                // The attempt to connect via a route failed. The request will not have been sent.
+                if (!recover(e.getLastConnectException(), streamAllocation, false, request)) {
+                    throw e.getFirstConnectException();
+                }
+                releaseConnection = false;
+                continue;
+            } catch (IOException e) {
+                // An attempt to communicate with a server failed. The request may have been sent.
+                boolean requestSendStarted = !(e instanceof ConnectionShutdownException);
+                if (!recover(e, streamAllocation, requestSendStarted, request)) throw e;
+                releaseConnection = false;
+                continue;
+            } finally {
+                // We're throwing an unchecked exception. Release any resources.
+                if (releaseConnection) {
+                    streamAllocation.streamFailed(null);
+                    streamAllocation.release(true);
+                }
+            }
+
+            // Attach the prior response if it exists. Such responses never have a body.
+            if (priorResponse != null) {
+                response = response.newBuilder()
+                        .priorResponse(priorResponse.newBuilder()
+                                .body(null)
+                                .build())
+                        .build();
+            }
+
+            Request followUp;
+            try {
+                followUp = followUpRequest(response, streamAllocation.route());
+            } catch (IOException e) {
+                streamAllocation.release(true);
+                throw e;
+            }
+
+            if (followUp == null) {
+                streamAllocation.release(true);
+                return response;
+            }
+
+            closeQuietly(response.body());
+
+            if (++followUpCount > MAX_FOLLOW_UPS) {
+                streamAllocation.release(true);
+                throw new ProtocolException("Too many follow-up requests: " + followUpCount);
+            }
+
+            if (followUp.body() instanceof UnrepeatableRequestBody) {
+                streamAllocation.release(true);
+                throw new HttpRetryException("Cannot retry streamed HTTP body", response.code());
+            }
+
+            if (!sameConnection(response, followUp.url())) {
+                streamAllocation.release(false);
+                streamAllocation = new StreamAllocation(client.connectionPool(),
+                        createAddress(followUp.url()), call, eventListener, callStackTrace);
+                this.streamAllocation = streamAllocation;
+            } else if (streamAllocation.codec() != null) {
+                throw new IllegalStateException("Closing the body of " + response
+                        + " didn't close its backing stream. Bad interceptor?");
+            }
+
+            request = followUp;
+            priorResponse = response;
         }
+    }
 
-        // When redirecting across hosts, drop all authentication headers. This
-        // is potentially annoying to the application layer since they have no
-        // way to retain them.
-        if (!sameConnection(userResponse, url)) {
-          requestBuilder.removeHeader("Authorization");
+    private Address createAddress(HttpUrl url) {
+        SSLSocketFactory sslSocketFactory = null;
+        HostnameVerifier hostnameVerifier = null;
+        CertificatePinner certificatePinner = null;
+        if (url.isHttps()) {
+            sslSocketFactory = client.sslSocketFactory();
+            hostnameVerifier = client.hostnameVerifier();
+            certificatePinner = client.certificatePinner();
         }
 
-        return requestBuilder.url(url).build();
+        return new Address(url.host(), url.port(), client.dns(), client.socketFactory(),
+                sslSocketFactory, hostnameVerifier, certificatePinner, client.proxyAuthenticator(),
+                client.proxy(), client.protocols(), client.connectionSpecs(), client.proxySelector());
+    }
 
-      case HTTP_CLIENT_TIMEOUT:
-        // 408's are rare in practice, but some servers like HAProxy use this response code. The
-        // spec says that we may repeat the request without modifications. Modern browsers also
-        // repeat the request (even non-idempotent ones.)
-        if (!client.retryOnConnectionFailure()) {
-          // The application layer has directed us not to retry the request.
-          return null;
-        }
+    /**
+     * Report and attempt to recover from a failure to communicate with a server. Returns true if
+     * {@code e} is recoverable, or false if the failure is permanent. Requests with a body can only
+     * be recovered if the body is buffered or if the failure occurred before the request has been
+     * sent.
+     */
+    private boolean recover(IOException e, StreamAllocation streamAllocation,
+                            boolean requestSendStarted, Request userRequest) {
+        streamAllocation.streamFailed(e);
 
-        if (userResponse.request().body() instanceof UnrepeatableRequestBody) {
-          return null;
-        }
+        // The application layer has forbidden retries.
+        if (!client.retryOnConnectionFailure()) return false;
 
-        if (userResponse.priorResponse() != null
-            && userResponse.priorResponse().code() == HTTP_CLIENT_TIMEOUT) {
-          // We attempted to retry and got another timeout. Give up.
-          return null;
-        }
+        // We can't send the request body again.
+        if (requestSendStarted && requestIsUnrepeatable(e, userRequest)) return false;
 
-        if (retryAfter(userResponse, 0) > 0) {
-          return null;
-        }
+        // This exception is fatal.
+        if (!isRecoverable(e, requestSendStarted)) return false;
+
+        // No more routes to attempt.
+        if (!streamAllocation.hasMoreRoutes()) return false;
+
+        // For failure recovery, use the same route selector with a new connection.
+        return true;
+    }
 
-        return userResponse.request();
+    private boolean requestIsUnrepeatable(IOException e, Request userRequest) {
+        return userRequest.body() instanceof UnrepeatableRequestBody
+                || e instanceof FileNotFoundException;
+    }
 
-      case HTTP_UNAVAILABLE:
-        if (userResponse.priorResponse() != null
-            && userResponse.priorResponse().code() == HTTP_UNAVAILABLE) {
-          // We attempted to retry and got another timeout. Give up.
-          return null;
+    private boolean isRecoverable(IOException e, boolean requestSendStarted) {
+        // If there was a protocol problem, don't recover.
+        if (e instanceof ProtocolException) {
+            return false;
         }
 
-        if (retryAfter(userResponse, Integer.MAX_VALUE) == 0) {
-          // specifically received an instruction to retry without delay
-          return userResponse.request();
+        // If there was an interruption don't recover, but if there was a timeout connecting to a route
+        // we should try the next route (if there is one).
+        if (e instanceof InterruptedIOException) {
+            return e instanceof SocketTimeoutException && !requestSendStarted;
         }
 
-        return null;
+        // Look for known client-side or negotiation errors that are unlikely to be fixed by trying
+        // again with a different route.
+        if (e instanceof SSLHandshakeException) {
+            // If the problem was a CertificateException from the X509TrustManager,
+            // do not retry.
+            if (e.getCause() instanceof CertificateException) {
+                return false;
+            }
+        }
+        if (e instanceof SSLPeerUnverifiedException) {
+            // e.g. a certificate pinning error.
+            return false;
+        }
 
-      default:
-        return null;
+        // An example of one we might want to retry with a different route is a problem connecting to a
+        // proxy and would manifest as a standard IOException. Unless it is one we know we should not
+        // retry, we return true and try a new route.
+        return true;
     }
-  }
-
-  private int retryAfter(Response userResponse, int defaultDelay) {
-    String header = userResponse.header("Retry-After");
 
-    if (header == null) {
-      return defaultDelay;
+    /**
+     * Figures out the HTTP request to make in response to receiving {@code userResponse}. This will
+     * either add authentication headers, follow redirects or handle a client request timeout. If a
+     * follow-up is either unnecessary or not applicable, this returns null.
+     */
+    private Request followUpRequest(Response userResponse, Route route) throws IOException {
+        if (userResponse == null) throw new IllegalStateException();
+        int responseCode = userResponse.code();
+
+        final String method = userResponse.request().method();
+        switch (responseCode) {
+            case HTTP_PROXY_AUTH:
+                Proxy selectedProxy = route != null
+                        ? route.proxy()
+                        : client.proxy();
+                if (selectedProxy.type() != Proxy.Type.HTTP) {
+                    throw new ProtocolException("Received HTTP_PROXY_AUTH (407) code while not using proxy");
+                }
+                return client.proxyAuthenticator().authenticate(route, userResponse);
+
+            case HTTP_UNAUTHORIZED:
+                return client.authenticator().authenticate(route, userResponse);
+
+            case HTTP_PERM_REDIRECT:
+            case HTTP_TEMP_REDIRECT:
+                // "If the 307 or 308 status code is received in response to a request other than GET
+                // or HEAD, the user agent MUST NOT automatically redirect the request"
+                if (!method.equals("GET") && !method.equals("HEAD")) {
+                    return null;
+                }
+                // fall-through
+            case HTTP_MULT_CHOICE:
+            case HTTP_MOVED_PERM:
+            case HTTP_MOVED_TEMP:
+            case HTTP_SEE_OTHER:
+                // Does the client allow redirects?
+                if (!client.followRedirects()) return null;
+
+                String location = userResponse.header("Location");
+                if (location == null) return null;
+                HttpUrl url = userResponse.request().url().resolve(location);
+
+                // Don't follow redirects to unsupported protocols.
+                if (url == null) return null;
+
+                // If configured, don't follow redirects between SSL and non-SSL.
+                boolean sameScheme = url.scheme().equals(userResponse.request().url().scheme());
+                if (!sameScheme && !client.followSslRedirects()) return null;
+
+                // Most redirects don't include a request body.
+                Request.Builder requestBuilder = userResponse.request().newBuilder();
+                if (HttpMethod.permitsRequestBody(method)) {
+                    final boolean maintainBody = HttpMethod.redirectsWithBody(method);
+                    if (HttpMethod.redirectsToGet(method)) {
+                        requestBuilder.method("GET", null);
+                    } else {
+                        RequestBody requestBody = maintainBody ? userResponse.request().body() : null;
+                        requestBuilder.method(method, requestBody);
+                    }
+                    if (!maintainBody) {
+                        requestBuilder.removeHeader("Transfer-Encoding");
+                        requestBuilder.removeHeader("Content-Length");
+                        requestBuilder.removeHeader("Content-Type");
+                    }
+                }
+
+                // When redirecting across hosts, drop all authentication headers. This
+                // is potentially annoying to the application layer since they have no
+                // way to retain them.
+                if (!sameConnection(userResponse, url)) {
+                    requestBuilder.removeHeader("Authorization");
+                }
+
+                return requestBuilder.url(url).build();
+
+            case HTTP_CLIENT_TIMEOUT:
+                // 408's are rare in practice, but some servers like HAProxy use this response code. The
+                // spec says that we may repeat the request without modifications. Modern browsers also
+                // repeat the request (even non-idempotent ones.)
+                if (!client.retryOnConnectionFailure()) {
+                    // The application layer has directed us not to retry the request.
+                    return null;
+                }
+
+                if (userResponse.request().body() instanceof UnrepeatableRequestBody) {
+                    return null;
+                }
+
+                if (userResponse.priorResponse() != null
+                        && userResponse.priorResponse().code() == HTTP_CLIENT_TIMEOUT) {
+                    // We attempted to retry and got another timeout. Give up.
+                    return null;
+                }
+
+                if (retryAfter(userResponse, 0) > 0) {
+                    return null;
+                }
+
+                return userResponse.request();
+
+            case HTTP_UNAVAILABLE:
+                if (userResponse.priorResponse() != null
+                        && userResponse.priorResponse().code() == HTTP_UNAVAILABLE) {
+                    // We attempted to retry and got another timeout. Give up.
+                    return null;
+                }
+
+                if (retryAfter(userResponse, Integer.MAX_VALUE) == 0) {
+                    // specifically received an instruction to retry without delay
+                    return userResponse.request();
+                }
+
+                return null;
+
+            default:
+                return null;
+        }
     }
 
-    // https://tools.ietf.org/html/rfc7231#section-7.1.3
-    // currently ignores a HTTP-date, and assumes any non int 0 is a delay
-    if (header.matches("\\d+")) {
-      return Integer.valueOf(header);
+    private int retryAfter(Response userResponse, int defaultDelay) {
+        String header = userResponse.header("Retry-After");
+
+        if (header == null) {
+            return defaultDelay;
+        }
+
+        // https://tools.ietf.org/html/rfc7231#section-7.1.3
+        // currently ignores a HTTP-date, and assumes any non int 0 is a delay
+        if (header.matches("\\d+")) {
+            return Integer.valueOf(header);
+        }
+
+        return Integer.MAX_VALUE;
     }
 
-    return Integer.MAX_VALUE;
-  }
-
-  /**
-   * Returns true if an HTTP request for {@code followUp} can reuse the connection used by this
-   * engine.
-   */
-  private boolean sameConnection(Response response, HttpUrl followUp) {
-    HttpUrl url = response.request().url();
-    return url.host().equals(followUp.host())
-        && url.port() == followUp.port()
-        && url.scheme().equals(followUp.scheme());
-  }
+    /**
+     * Returns true if an HTTP request for {@code followUp} can reuse the connection used by this
+     * engine.
+     */
+    private boolean sameConnection(Response response, HttpUrl followUp) {
+        HttpUrl url = response.request().url();
+        return url.host().equals(followUp.host())
+                && url.port() == followUp.port()
+                && url.scheme().equals(followUp.scheme());
+    }
 }
diff --git a/samples/guide/src/main/java/okhttp3/guide/GetExample.java b/samples/guide/src/main/java/okhttp3/guide/GetExample.java
index 35a1cc658c..68391528fa 100644
--- a/samples/guide/src/main/java/okhttp3/guide/GetExample.java
+++ b/samples/guide/src/main/java/okhttp3/guide/GetExample.java
@@ -1,26 +1,86 @@
 package okhttp3.guide;
 
 import java.io.IOException;
+import java.lang.reflect.Array;
+import java.util.ArrayList;
+import java.util.List;
+
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
 import okhttp3.Response;
 
 public class GetExample {
-  OkHttpClient client = new OkHttpClient();
+    OkHttpClient client = new OkHttpClient();
 
-  String run(String url) throws IOException {
-    Request request = new Request.Builder()
-        .url(url)
-        .build();
+    String run(String url) throws IOException {
+        Request request = new Request.Builder()
+                .url(url)
+                .build();
 
-    try (Response response = client.newCall(request).execute()) {
-      return response.body().string();
+        try (Response response = new OkHttpClient().newCall(request).execute()) {
+            return response.body().string();
+        }
     }
-  }
 
-  public static void main(String[] args) throws IOException {
-    GetExample example = new GetExample();
-    String response = example.run("https://raw.github.com/square/okhttp/master/README.md");
-    System.out.println(response);
-  }
+    public static void main(String[] args) throws IOException {
+        GetExample example = new GetExample();
+        String response = example.run("http://www.cnblogs.com/sharpxiajun/p/3936268.html#!comments");
+//        String response = example.run("https://raw.githubusercontent.com/square/okhttp/master/README.md");
+//        String response = example.run("https://raw.github.com/square/okhttp/master/README.md");
+        System.out.println(response);
+
+
+//        //获取本机的InetAddress实例
+//        InetAddress address = InetAddress.getLocalHost();
+//        //获取计算机名
+//        System.out.println(address.getHostName());
+//        //获取IP地址
+//        System.out.println(address.getHostAddress());
+//        //获取字节数组形式的IP地址,以点分隔的四部分
+//        System.out.println(address.getAddress());
+
+        //获取其他主机的InetAddress实例
+        //        InetAddress address2 =InetAddress.getByName("其他主机名");
+        //        InetAddress address3 =InetAddress.getByName("IP地址");
+
+
+//
+//        //创建一个URL的实例
+//        URL myBlog = new URL("https://3dot141.cn");
+//        URL url = new URL(myBlog, "/blogs/33521.html?username=3dot141#test");//？表示参数，#表示锚点
+//        //获取协议
+//        System.out.println(url.getProtocol());
+//        //获取主机
+//        System.out.println(url.getHost());
+//        //如果没有指定端口号，根据协议不同使用默认端口。此时getPort()方法的返回值为 -1
+//        System.out.println(url.getPort());
+//        //获取文件路径
+//        System.out.println(url.getPath());
+//        //文件名，包括文件路径+参数
+//        System.out.println(url.getFile());
+//        //相对路径，就是锚点，即#号后面的内容
+//        System.out.println(url.getRef());
+//        //查询字符串，即参数
+//        System.out.println(url.getQuery());
+
+        //使用URL读取网页内容
+        //创建一个URL实例
+
+//        URL url = new URL("http://www.baidu.com");
+//        InputStream is = url.openStream();//通过openStream方法获取资源的字节输入流
+//        InputStreamReader isr = new InputStreamReader(is, "UTF-8");//将字节输入流转换为字符输入流,如果不指定编码，中文可能会出现乱码
+//        BufferedReader br = new BufferedReader(isr);//为字符输入流添加缓冲，提高读取效率
+//        String data = br.readLine();//读取数据
+//        while (data != null) {
+//            System.out.println(data);//输出数据
+//            data = br.readLine();
+//        }
+//        br.close();
+//        isr.close();
+//        is.close();
+
+
+    }
+
+
 }
diff --git a/samples/guide/src/main/java/okhttp3/guide/PostExample.java b/samples/guide/src/main/java/okhttp3/guide/PostExample.java
index ddaacb6c5e..ba785ec01a 100644
--- a/samples/guide/src/main/java/okhttp3/guide/PostExample.java
+++ b/samples/guide/src/main/java/okhttp3/guide/PostExample.java
@@ -1,6 +1,11 @@
 package okhttp3.guide;
 
 import java.io.IOException;
+import java.util.HashMap;
+
+import com.squareup.moshi.JsonAdapter;
+import com.squareup.moshi.Moshi;
+import com.squareup.moshi.ToJson;
 import okhttp3.MediaType;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
@@ -8,37 +13,48 @@
 import okhttp3.Response;
 
 public class PostExample {
-  public static final MediaType JSON = MediaType.get("application/json; charset=utf-8");
-
-  OkHttpClient client = new OkHttpClient();
-
-  String post(String url, String json) throws IOException {
-    RequestBody body = RequestBody.create(JSON, json);
-    Request request = new Request.Builder()
-        .url(url)
-        .post(body)
-        .build();
-    try (Response response = client.newCall(request).execute()) {
-      return response.body().string();
+    public static final MediaType JSON = MediaType.get("application/json; charset=utf-8");
+
+    OkHttpClient client = new OkHttpClient();
+
+    String post(String url, String json) throws IOException {
+        RequestBody body = RequestBody.create(JSON, json);
+        Request request = new Request.Builder()
+                .url(url)
+                .post(body)
+                .build();
+        try (Response response = client.newCall(request).execute()) {
+            return response.body().string();
+        }
+    }
+
+    String bowlingJson(String player1, String player2) {
+        return "{'winCondition':'HIGH_SCORE',"
+                + "'name':'Bowling',"
+                + "'round':4,"
+                + "'lastSaved':1367702411696,"
+                + "'dateStarted':1367702378785,"
+                + "'players':["
+                + "{'name':'" + player1 + "','history':[10,8,6,7,8],'color':-13388315,'total':39},"
+                + "{'name':'" + player2 + "','history':[6,10,5,10,10],'color':-48060,'total':41}"
+                + "]}";
+    }
+
+    public static void main(String[] args) throws IOException {
+//        PostExample example = new PostExample();
+//        String json = example.bowlingJson("Jesse", "Jake");
+//        String response = example.post("http://www.roundsapp.com/post", json);
+//        System.out.println(response);
+
+        PostExample example = new PostExample();
+        HashMap<String, String> map = new HashMap<>();
+        map.put("username", "876271327");
+        map.put("password", "wanandroid02");
+
+
+        String json = "{\"device_id\":\"02F5AB8A765884CF159E98731F7A9672\"}";
+        String response = example.post("https://wqt.fortrun.cn/p/master/libra/get_config", json);
+        System.out.println(response);
+
     }
-  }
-
-  String bowlingJson(String player1, String player2) {
-    return "{'winCondition':'HIGH_SCORE',"
-        + "'name':'Bowling',"
-        + "'round':4,"
-        + "'lastSaved':1367702411696,"
-        + "'dateStarted':1367702378785,"
-        + "'players':["
-        + "{'name':'" + player1 + "','history':[10,8,6,7,8],'color':-13388315,'total':39},"
-        + "{'name':'" + player2 + "','history':[6,10,5,10,10],'color':-48060,'total':41}"
-        + "]}";
-  }
-
-  public static void main(String[] args) throws IOException {
-    PostExample example = new PostExample();
-    String json = example.bowlingJson("Jesse", "Jake");
-    String response = example.post("http://www.roundsapp.com/post", json);
-    System.out.println(response);
-  }
 }
