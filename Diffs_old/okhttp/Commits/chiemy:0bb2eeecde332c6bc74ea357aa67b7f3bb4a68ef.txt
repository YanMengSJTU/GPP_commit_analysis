diff --git a/okhttp/src/main/java/okhttp3/Cache.java b/okhttp/src/main/java/okhttp3/Cache.java
index d43d91d257..4ac101190a 100644
--- a/okhttp/src/main/java/okhttp3/Cache.java
+++ b/okhttp/src/main/java/okhttp3/Cache.java
@@ -52,17 +52,26 @@
 /**
  * Caches HTTP and HTTPS responses to the filesystem so they may be reused, saving time and
  * bandwidth.
+ *<br>
+ *    将 HTTP 和 HTTPS 响应数据缓存到文件系统中，可以重用这些数据，以便节省时间和带宽
+ * <h3>Cache Optimization
+ * <br>缓存优化
+ * </h3>
  *
- * <h3>Cache Optimization</h3>
  *
  * <p>To measure cache effectiveness, this class tracks three statistics:
+ * <br>
+ *     此类通过三个指标评估缓存有效性：
  * <ul>
  *     <li><strong>{@linkplain #requestCount() Request Count:}</strong> the number of HTTP
  *         requests issued since this cache was created.
+ *         <br> 自缓存创建，HTTP 请求发送次数
  *     <li><strong>{@linkplain #networkCount() Network Count:}</strong> the number of those
  *         requests that required network use.
+ *         <br> 这些请求中使用网络的数量
  *     <li><strong>{@linkplain #hitCount() Hit Count:}</strong> the number of those requests
  *         whose responses were served by the cache.
+ *         <br> 这些请求中使用缓存的数量
  * </ul>
  *
  * Sometimes a request will result in a conditional cache hit. If the cache contains a stale copy of
@@ -70,16 +79,25 @@
  * the updated response if it has changed, or a short 'not modified' response if the client's copy
  * is still valid. Such responses increment both the network count and hit count.
  *
+ * <br> 有时请求会导致条件缓存命中。如果缓存包含旧的响应数据，客户端会发送一个条件的 GET 请求，如果内容有变化，
+ * 服务端会返回新的数据，如果客户端的缓存依然有效，则返回 ‘not modified’ 的响应，此时，网络请求数和缓存命中数都会增加。
+ *
  * <p>The best way to improve the cache hit rate is by configuring the web server to return
  * cacheable responses. Although this client honors all <a
  * href="http://tools.ietf.org/html/rfc7234">HTTP/1.1 (RFC 7234)</a> cache headers, it doesn't cache
  * partial responses.
+ * <br> 最好的提高缓存命中率的方法是，配置 web 服务返回可缓存的相应
+ * （翻译的有问题，不明白）尽管客户端遵从所有 HTTP/1.1 (RFC 7234) 缓存头，部分请求也不会缓存
  *
- * <h3>Force a Network Response</h3>
+ * <h3>Force a Network Response
+ * <br>强制网络请求
+ * </h3>
  *
  * <p>In some situations, such as after a user clicks a 'refresh' button, it may be necessary to
  * skip the cache, and fetch data directly from the server. To force a full refresh, add the {@code
- * no-cache} directive: <pre>   {@code
+ * no-cache} directive:
+ * <br> 在某些情况下，如用户点击刷新按钮后，有必要跳过缓存，直接从服务器获取数据。强制完全刷新，代码如下：
+ * <pre>   {@code
  *
  *   Request request = new Request.Builder()
  *       .cacheControl(new CacheControl.Builder().noCache().build())
@@ -88,7 +106,8 @@
  * }</pre>
  *
  * If it is only necessary to force a cached response to be validated by the server, use the more
- * efficient {@code max-age=0} directive instead: <pre>   {@code
+ * efficient {@code max-age=0} directive instead:
+ * <pre>   {@code
  *
  *   Request request = new Request.Builder()
  *       .cacheControl(new CacheControl.Builder()
diff --git a/okhttp/src/main/java/okhttp3/ConnectionPool.java b/okhttp/src/main/java/okhttp3/ConnectionPool.java
index 6e305ab7bd..4b39a6bd7f 100644
--- a/okhttp/src/main/java/okhttp3/ConnectionPool.java
+++ b/okhttp/src/main/java/okhttp3/ConnectionPool.java
@@ -118,6 +118,8 @@ public synchronized int connectionCount() {
   /**
    * Returns a recycled connection to {@code address}, or null if no such connection exists. The
    * route is null if the address has not yet been routed.
+   * <br>
+   *     根据地址返回一个已回收的连接，如果没有则返回 null。如果地址还没有被路由，则 route 为 null
    */
   @Nullable RealConnection get(Address address, StreamAllocation streamAllocation, Route route) {
     assert (Thread.holdsLock(this));
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java b/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java
index e4d7e2f1d6..0af1e822b2 100644
--- a/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java
@@ -17,6 +17,7 @@
 package okhttp3.internal.cache;
 
 import java.io.IOException;
+
 import okhttp3.Headers;
 import okhttp3.Interceptor;
 import okhttp3.Protocol;
@@ -41,217 +42,226 @@
 import static okhttp3.internal.Util.closeQuietly;
 import static okhttp3.internal.Util.discard;
 
-/** Serves requests from the cache and writes responses to the cache. */
+/**
+ * Serves requests from the cache and writes responses to the cache.
+ */
 public final class CacheInterceptor implements Interceptor {
-  final InternalCache cache;
+    final InternalCache cache;
 
-  public CacheInterceptor(InternalCache cache) {
-    this.cache = cache;
-  }
+    public CacheInterceptor(InternalCache cache) {
+        this.cache = cache;
+    }
 
-  @Override public Response intercept(Chain chain) throws IOException {
-    Response cacheCandidate = cache != null
-        ? cache.get(chain.request())
-        : null;
+    @Override
+    public Response intercept(Chain chain) throws IOException {
+        Response cacheCandidate = cache != null
+                ? cache.get(chain.request())
+                : null;
 
-    long now = System.currentTimeMillis();
+        long now = System.currentTimeMillis();
+        // 提取响应缓存相关 Header 信息，添加到 Request 中
+        CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();
+        Request networkRequest = strategy.networkRequest;
+        Response cacheResponse = strategy.cacheResponse;
 
-    CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();
-    Request networkRequest = strategy.networkRequest;
-    Response cacheResponse = strategy.cacheResponse;
+        if (cache != null) {
+            cache.trackResponse(strategy);
+        }
 
-    if (cache != null) {
-      cache.trackResponse(strategy);
-    }
+        if (cacheCandidate != null && cacheResponse == null) {
+            closeQuietly(cacheCandidate.body()); // The cache candidate wasn't applicable. Close it.
+        }
 
-    if (cacheCandidate != null && cacheResponse == null) {
-      closeQuietly(cacheCandidate.body()); // The cache candidate wasn't applicable. Close it.
-    }
+        // If we're forbidden from using the network and the cache is insufficient, fail.
+        if (networkRequest == null && cacheResponse == null) {
+            return new Response.Builder()
+                    .request(chain.request())
+                    .protocol(Protocol.HTTP_1_1)
+                    .code(504)
+                    .message("Unsatisfiable Request (only-if-cached)")
+                    .body(Util.EMPTY_RESPONSE)
+                    .sentRequestAtMillis(-1L)
+                    .receivedResponseAtMillis(System.currentTimeMillis())
+                    .build();
+        }
 
-    // If we're forbidden from using the network and the cache is insufficient, fail.
-    if (networkRequest == null && cacheResponse == null) {
-      return new Response.Builder()
-          .request(chain.request())
-          .protocol(Protocol.HTTP_1_1)
-          .code(504)
-          .message("Unsatisfiable Request (only-if-cached)")
-          .body(Util.EMPTY_RESPONSE)
-          .sentRequestAtMillis(-1L)
-          .receivedResponseAtMillis(System.currentTimeMillis())
-          .build();
-    }
+        // If we don't need the network, we're done.
+        if (networkRequest == null) {
+            return cacheResponse.newBuilder()
+                    .cacheResponse(stripBody(cacheResponse))
+                    .build();
+        }
 
-    // If we don't need the network, we're done.
-    if (networkRequest == null) {
-      return cacheResponse.newBuilder()
-          .cacheResponse(stripBody(cacheResponse))
-          .build();
-    }
+        Response networkResponse = null;
+        try {
+            networkResponse = chain.proceed(networkRequest);
+        } finally {
+            // If we're crashing on I/O or otherwise, don't leak the cache body.
+            if (networkResponse == null && cacheCandidate != null) {
+                closeQuietly(cacheCandidate.body());
+            }
+        }
 
-    Response networkResponse = null;
-    try {
-      networkResponse = chain.proceed(networkRequest);
-    } finally {
-      // If we're crashing on I/O or otherwise, don't leak the cache body.
-      if (networkResponse == null && cacheCandidate != null) {
-        closeQuietly(cacheCandidate.body());
-      }
-    }
+        // If we have a cache response too, then we're doing a conditional get.
+        if (cacheResponse != null) {
+            // 304 内容为变化
+            if (networkResponse.code() == HTTP_NOT_MODIFIED) {
+                Response response = cacheResponse.newBuilder()
+                        .headers(combine(cacheResponse.headers(), networkResponse.headers()))
+                        .sentRequestAtMillis(networkResponse.sentRequestAtMillis())
+                        .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())
+                        .cacheResponse(stripBody(cacheResponse))
+                        .networkResponse(stripBody(networkResponse))
+                        .build();
+                networkResponse.body().close();
+
+                // Update the cache after combining headers but before stripping the
+                // Content-Encoding header (as performed by initContentStream()).
+                cache.trackConditionalCacheHit();
+                cache.update(cacheResponse, response);
+                return response;
+            } else {
+                closeQuietly(cacheResponse.body());
+            }
+        }
+
+        Response response = networkResponse.newBuilder()
+                .cacheResponse(stripBody(cacheResponse))
+                .networkResponse(stripBody(networkResponse))
+                .build();
+
+        if (cache != null) {
+            if (HttpHeaders.hasBody(response) && CacheStrategy.isCacheable(response, networkRequest)) {
+                // Offer this request to the cache.
+                CacheRequest cacheRequest = cache.put(response);
+                return cacheWritingResponse(cacheRequest, response);
+            }
+
+            if (HttpMethod.invalidatesCache(networkRequest.method())) {
+                try {
+                    cache.remove(networkRequest);
+                } catch (IOException ignored) {
+                    // The cache cannot be written.
+                }
+            }
+        }
 
-    // If we have a cache response too, then we're doing a conditional get.
-    if (cacheResponse != null) {
-      if (networkResponse.code() == HTTP_NOT_MODIFIED) {
-        Response response = cacheResponse.newBuilder()
-            .headers(combine(cacheResponse.headers(), networkResponse.headers()))
-            .sentRequestAtMillis(networkResponse.sentRequestAtMillis())
-            .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())
-            .cacheResponse(stripBody(cacheResponse))
-            .networkResponse(stripBody(networkResponse))
-            .build();
-        networkResponse.body().close();
-
-        // Update the cache after combining headers but before stripping the
-        // Content-Encoding header (as performed by initContentStream()).
-        cache.trackConditionalCacheHit();
-        cache.update(cacheResponse, response);
         return response;
-      } else {
-        closeQuietly(cacheResponse.body());
-      }
     }
 
-    Response response = networkResponse.newBuilder()
-        .cacheResponse(stripBody(cacheResponse))
-        .networkResponse(stripBody(networkResponse))
-        .build();
-
-    if (cache != null) {
-      if (HttpHeaders.hasBody(response) && CacheStrategy.isCacheable(response, networkRequest)) {
-        // Offer this request to the cache.
-        CacheRequest cacheRequest = cache.put(response);
-        return cacheWritingResponse(cacheRequest, response);
-      }
+    private static Response stripBody(Response response) {
+        return response != null && response.body() != null
+                ? response.newBuilder().body(null).build()
+                : response;
+    }
 
-      if (HttpMethod.invalidatesCache(networkRequest.method())) {
-        try {
-          cache.remove(networkRequest);
-        } catch (IOException ignored) {
-          // The cache cannot be written.
-        }
-      }
+    /**
+     * Returns a new source that writes bytes to {@code cacheRequest} as they are read by the source
+     * consumer. This is careful to discard bytes left over when the stream is closed; otherwise we
+     * may never exhaust the source stream and therefore not complete the cached response.
+     */
+    private Response cacheWritingResponse(final CacheRequest cacheRequest, Response response)
+            throws IOException {
+        // Some apps return a null body; for compatibility we treat that like a null cache request.
+        if (cacheRequest == null) return response;
+        Sink cacheBodyUnbuffered = cacheRequest.body();
+        if (cacheBodyUnbuffered == null) return response;
+
+        final BufferedSource source = response.body().source();
+        final BufferedSink cacheBody = Okio.buffer(cacheBodyUnbuffered);
+
+        Source cacheWritingSource = new Source() {
+            boolean cacheRequestClosed;
+
+            @Override
+            public long read(Buffer sink, long byteCount) throws IOException {
+                long bytesRead;
+                try {
+                    bytesRead = source.read(sink, byteCount);
+                } catch (IOException e) {
+                    if (!cacheRequestClosed) {
+                        cacheRequestClosed = true;
+                        cacheRequest.abort(); // Failed to write a complete cache response.
+                    }
+                    throw e;
+                }
+
+                if (bytesRead == -1) {
+                    if (!cacheRequestClosed) {
+                        cacheRequestClosed = true;
+                        cacheBody.close(); // The cache response is complete!
+                    }
+                    return -1;
+                }
+
+                sink.copyTo(cacheBody.buffer(), sink.size() - bytesRead, bytesRead);
+                cacheBody.emitCompleteSegments();
+                return bytesRead;
+            }
+
+            @Override
+            public Timeout timeout() {
+                return source.timeout();
+            }
+
+            @Override
+            public void close() throws IOException {
+                if (!cacheRequestClosed
+                        && !discard(this, HttpCodec.DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
+                    cacheRequestClosed = true;
+                    cacheRequest.abort();
+                }
+                source.close();
+            }
+        };
+
+        return response.newBuilder()
+                .body(new RealResponseBody(response.headers(), Okio.buffer(cacheWritingSource)))
+                .build();
     }
 
-    return response;
-  }
-
-  private static Response stripBody(Response response) {
-    return response != null && response.body() != null
-        ? response.newBuilder().body(null).build()
-        : response;
-  }
-
-  /**
-   * Returns a new source that writes bytes to {@code cacheRequest} as they are read by the source
-   * consumer. This is careful to discard bytes left over when the stream is closed; otherwise we
-   * may never exhaust the source stream and therefore not complete the cached response.
-   */
-  private Response cacheWritingResponse(final CacheRequest cacheRequest, Response response)
-      throws IOException {
-    // Some apps return a null body; for compatibility we treat that like a null cache request.
-    if (cacheRequest == null) return response;
-    Sink cacheBodyUnbuffered = cacheRequest.body();
-    if (cacheBodyUnbuffered == null) return response;
-
-    final BufferedSource source = response.body().source();
-    final BufferedSink cacheBody = Okio.buffer(cacheBodyUnbuffered);
-
-    Source cacheWritingSource = new Source() {
-      boolean cacheRequestClosed;
-
-      @Override public long read(Buffer sink, long byteCount) throws IOException {
-        long bytesRead;
-        try {
-          bytesRead = source.read(sink, byteCount);
-        } catch (IOException e) {
-          if (!cacheRequestClosed) {
-            cacheRequestClosed = true;
-            cacheRequest.abort(); // Failed to write a complete cache response.
-          }
-          throw e;
+    /**
+     * Combines cached headers with a network headers as defined by RFC 2616, 13.5.3.
+     */
+    private static Headers combine(Headers cachedHeaders, Headers networkHeaders) {
+        Headers.Builder result = new Headers.Builder();
+
+        for (int i = 0, size = cachedHeaders.size(); i < size; i++) {
+            String fieldName = cachedHeaders.name(i);
+            String value = cachedHeaders.value(i);
+            if ("Warning".equalsIgnoreCase(fieldName) && value.startsWith("1")) {
+                continue; // Drop 100-level freshness warnings.
+            }
+            if (!isEndToEnd(fieldName) || networkHeaders.get(fieldName) == null) {
+                Internal.instance.addLenient(result, fieldName, value);
+            }
         }
 
-        if (bytesRead == -1) {
-          if (!cacheRequestClosed) {
-            cacheRequestClosed = true;
-            cacheBody.close(); // The cache response is complete!
-          }
-          return -1;
+        for (int i = 0, size = networkHeaders.size(); i < size; i++) {
+            String fieldName = networkHeaders.name(i);
+            if ("Content-Length".equalsIgnoreCase(fieldName)) {
+                continue; // Ignore content-length headers of validating responses.
+            }
+            if (isEndToEnd(fieldName)) {
+                Internal.instance.addLenient(result, fieldName, networkHeaders.value(i));
+            }
         }
 
-        sink.copyTo(cacheBody.buffer(), sink.size() - bytesRead, bytesRead);
-        cacheBody.emitCompleteSegments();
-        return bytesRead;
-      }
-
-      @Override public Timeout timeout() {
-        return source.timeout();
-      }
-
-      @Override public void close() throws IOException {
-        if (!cacheRequestClosed
-            && !discard(this, HttpCodec.DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
-          cacheRequestClosed = true;
-          cacheRequest.abort();
-        }
-        source.close();
-      }
-    };
-
-    return response.newBuilder()
-        .body(new RealResponseBody(response.headers(), Okio.buffer(cacheWritingSource)))
-        .build();
-  }
-
-  /** Combines cached headers with a network headers as defined by RFC 2616, 13.5.3. */
-  private static Headers combine(Headers cachedHeaders, Headers networkHeaders) {
-    Headers.Builder result = new Headers.Builder();
-
-    for (int i = 0, size = cachedHeaders.size(); i < size; i++) {
-      String fieldName = cachedHeaders.name(i);
-      String value = cachedHeaders.value(i);
-      if ("Warning".equalsIgnoreCase(fieldName) && value.startsWith("1")) {
-        continue; // Drop 100-level freshness warnings.
-      }
-      if (!isEndToEnd(fieldName) || networkHeaders.get(fieldName) == null) {
-        Internal.instance.addLenient(result, fieldName, value);
-      }
+        return result.build();
     }
 
-    for (int i = 0, size = networkHeaders.size(); i < size; i++) {
-      String fieldName = networkHeaders.name(i);
-      if ("Content-Length".equalsIgnoreCase(fieldName)) {
-        continue; // Ignore content-length headers of validating responses.
-      }
-      if (isEndToEnd(fieldName)) {
-        Internal.instance.addLenient(result, fieldName, networkHeaders.value(i));
-      }
+    /**
+     * Returns true if {@code fieldName} is an end-to-end HTTP header, as defined by RFC 2616,
+     * 13.5.1.
+     */
+    static boolean isEndToEnd(String fieldName) {
+        return !"Connection".equalsIgnoreCase(fieldName)
+                && !"Keep-Alive".equalsIgnoreCase(fieldName)
+                && !"Proxy-Authenticate".equalsIgnoreCase(fieldName)
+                && !"Proxy-Authorization".equalsIgnoreCase(fieldName)
+                && !"TE".equalsIgnoreCase(fieldName)
+                && !"Trailers".equalsIgnoreCase(fieldName)
+                && !"Transfer-Encoding".equalsIgnoreCase(fieldName)
+                && !"Upgrade".equalsIgnoreCase(fieldName);
     }
-
-    return result.build();
-  }
-
-  /**
-   * Returns true if {@code fieldName} is an end-to-end HTTP header, as defined by RFC 2616,
-   * 13.5.1.
-   */
-  static boolean isEndToEnd(String fieldName) {
-    return !"Connection".equalsIgnoreCase(fieldName)
-        && !"Keep-Alive".equalsIgnoreCase(fieldName)
-        && !"Proxy-Authenticate".equalsIgnoreCase(fieldName)
-        && !"Proxy-Authorization".equalsIgnoreCase(fieldName)
-        && !"TE".equalsIgnoreCase(fieldName)
-        && !"Trailers".equalsIgnoreCase(fieldName)
-        && !"Transfer-Encoding".equalsIgnoreCase(fieldName)
-        && !"Upgrade".equalsIgnoreCase(fieldName);
-  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java b/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java
index 9b6cc1a375..aff5481017 100644
--- a/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java
+++ b/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java
@@ -17,6 +17,7 @@
 
 import java.util.Date;
 import javax.annotation.Nullable;
+
 import okhttp3.CacheControl;
 import okhttp3.Headers;
 import okhttp3.Request;
@@ -42,288 +43,331 @@
 /**
  * Given a request and cached response, this figures out whether to use the network, the cache, or
  * both.
- *
+ * <p>
  * <p>Selecting a cache strategy may add conditions to the request (like the "If-Modified-Since"
  * header for conditional GETs) or warnings to the cached response (if the cached data is
  * potentially stale).
  */
 public final class CacheStrategy {
-  /** The request to send on the network, or null if this call doesn't use the network. */
-  public final @Nullable Request networkRequest;
-
-  /** The cached response to return or validate; or null if this call doesn't use a cache. */
-  public final @Nullable Response cacheResponse;
-
-  CacheStrategy(Request networkRequest, Response cacheResponse) {
-    this.networkRequest = networkRequest;
-    this.cacheResponse = cacheResponse;
-  }
-
-  /** Returns true if {@code response} can be stored to later serve another request. */
-  public static boolean isCacheable(Response response, Request request) {
-    // Always go to network for uncacheable response codes (RFC 7231 section 6.1),
-    // This implementation doesn't support caching partial content.
-    switch (response.code()) {
-      case HTTP_OK:
-      case HTTP_NOT_AUTHORITATIVE:
-      case HTTP_NO_CONTENT:
-      case HTTP_MULT_CHOICE:
-      case HTTP_MOVED_PERM:
-      case HTTP_NOT_FOUND:
-      case HTTP_BAD_METHOD:
-      case HTTP_GONE:
-      case HTTP_REQ_TOO_LONG:
-      case HTTP_NOT_IMPLEMENTED:
-      case StatusLine.HTTP_PERM_REDIRECT:
-        // These codes can be cached unless headers forbid it.
-        break;
-
-      case HTTP_MOVED_TEMP:
-      case StatusLine.HTTP_TEMP_REDIRECT:
-        // These codes can only be cached with the right response headers.
-        // http://tools.ietf.org/html/rfc7234#section-3
-        // s-maxage is not checked because OkHttp is a private cache that should ignore s-maxage.
-        if (response.header("Expires") != null
-            || response.cacheControl().maxAgeSeconds() != -1
-            || response.cacheControl().isPublic()
-            || response.cacheControl().isPrivate()) {
-          break;
-        }
-        // Fall-through.
-
-      default:
-        // All other codes cannot be cached.
-        return false;
-    }
-
-    // A 'no-store' directive on request or response prevents the response from being cached.
-    return !response.cacheControl().noStore() && !request.cacheControl().noStore();
-  }
-
-  public static class Factory {
-    final long nowMillis;
-    final Request request;
-    final Response cacheResponse;
-
-    /** The server's time when the cached response was served, if known. */
-    private Date servedDate;
-    private String servedDateString;
-
-    /** The last modified date of the cached response, if known. */
-    private Date lastModified;
-    private String lastModifiedString;
-
     /**
-     * The expiration date of the cached response, if known. If both this field and the max age are
-     * set, the max age is preferred.
+     * The request to send on the network, or null if this call doesn't use the network.
      */
-    private Date expires;
+    public final @Nullable
+    Request networkRequest;
 
     /**
-     * Extension header set by OkHttp specifying the timestamp when the cached HTTP request was
-     * first initiated.
+     * The cached response to return or validate; or null if this call doesn't use a cache.
      */
-    private long sentRequestMillis;
+    public final @Nullable
+    Response cacheResponse;
+
+    CacheStrategy(Request networkRequest, Response cacheResponse) {
+        this.networkRequest = networkRequest;
+        this.cacheResponse = cacheResponse;
+    }
 
     /**
-     * Extension header set by OkHttp specifying the timestamp when the cached HTTP response was
-     * first received.
+     * Returns true if {@code response} can be stored to later serve another request.
      */
-    private long receivedResponseMillis;
-
-    /** Etag of the cached response. */
-    private String etag;
-
-    /** Age of the cached response. */
-    private int ageSeconds = -1;
-
-    public Factory(long nowMillis, Request request, Response cacheResponse) {
-      this.nowMillis = nowMillis;
-      this.request = request;
-      this.cacheResponse = cacheResponse;
-
-      if (cacheResponse != null) {
-        this.sentRequestMillis = cacheResponse.sentRequestAtMillis();
-        this.receivedResponseMillis = cacheResponse.receivedResponseAtMillis();
-        Headers headers = cacheResponse.headers();
-        for (int i = 0, size = headers.size(); i < size; i++) {
-          String fieldName = headers.name(i);
-          String value = headers.value(i);
-          if ("Date".equalsIgnoreCase(fieldName)) {
-            servedDate = HttpDate.parse(value);
-            servedDateString = value;
-          } else if ("Expires".equalsIgnoreCase(fieldName)) {
-            expires = HttpDate.parse(value);
-          } else if ("Last-Modified".equalsIgnoreCase(fieldName)) {
-            lastModified = HttpDate.parse(value);
-            lastModifiedString = value;
-          } else if ("ETag".equalsIgnoreCase(fieldName)) {
-            etag = value;
-          } else if ("Age".equalsIgnoreCase(fieldName)) {
-            ageSeconds = HttpHeaders.parseSeconds(value, -1);
-          }
+    public static boolean isCacheable(Response response, Request request) {
+        // Always go to network for uncacheable response codes (RFC 7231 section 6.1),
+        // This implementation doesn't support caching partial content.
+        switch (response.code()) {
+            case HTTP_OK:
+            case HTTP_NOT_AUTHORITATIVE:
+            case HTTP_NO_CONTENT:
+            case HTTP_MULT_CHOICE:
+            case HTTP_MOVED_PERM:
+            case HTTP_NOT_FOUND:
+            case HTTP_BAD_METHOD:
+            case HTTP_GONE:
+            case HTTP_REQ_TOO_LONG:
+            case HTTP_NOT_IMPLEMENTED:
+            case StatusLine.HTTP_PERM_REDIRECT:
+                // These codes can be cached unless headers forbid it.
+                break;
+
+            case HTTP_MOVED_TEMP:
+            case StatusLine.HTTP_TEMP_REDIRECT:
+                // These codes can only be cached with the right response headers.
+                // http://tools.ietf.org/html/rfc7234#section-3
+                // s-maxage is not checked because OkHttp is a private cache that should ignore s-maxage.
+                if (response.header("Expires") != null
+                        || response.cacheControl().maxAgeSeconds() != -1
+                        || response.cacheControl().isPublic()
+                        || response.cacheControl().isPrivate()) {
+                    break;
+                }
+                // Fall-through.
+
+            default:
+                // All other codes cannot be cached.
+                return false;
         }
-      }
+
+        // A 'no-store' directive on request or response prevents the response from being cached.
+        return !response.cacheControl().noStore() && !request.cacheControl().noStore();
     }
 
-    /**
-     * Returns a strategy to satisfy {@code request} using the a cached response {@code response}.
-     */
-    public CacheStrategy get() {
-      CacheStrategy candidate = getCandidate();
+    public static class Factory {
+        final long nowMillis;
+        final Request request;
+        final Response cacheResponse;
+
+        /**
+         * The server's time when the cached response was served, if known.
+         */
+        private Date servedDate;
+        private String servedDateString;
+
+        /**
+         * The last modified date of the cached response, if known.
+         */
+        private Date lastModified;
+        private String lastModifiedString;
+
+        /**
+         * The expiration date of the cached response, if known. If both this field and the max age are
+         * set, the max age is preferred.
+         */
+        private Date expires;
+
+        /**
+         * Extension header set by OkHttp specifying the timestamp when the cached HTTP request was
+         * first initiated.
+         * <br> OkHttp 定义的扩展头：请求第一次初始化的时间
+         */
+        private long sentRequestMillis;
+
+        /**
+         * Extension header set by OkHttp specifying the timestamp when the cached HTTP response was
+         * first received.
+         * <br> OkHttp 定义的扩展头：缓存的 HTTP 响应返回的时间
+         */
+        private long receivedResponseMillis;
+
+        /**
+         * Etag of the cached response.
+         */
+        private String etag;
+
+        /**
+         * Age of the cached response.
+         */
+        private int ageSeconds = -1;
+
+        public Factory(long nowMillis, Request request, Response cacheResponse) {
+            this.nowMillis = nowMillis;
+            this.request = request;
+            this.cacheResponse = cacheResponse;
+
+            // 从缓存响应的 Header 中提取缓存相关信息，用于构建请求头
+            if (cacheResponse != null) {
+                this.sentRequestMillis = cacheResponse.sentRequestAtMillis();
+                this.receivedResponseMillis = cacheResponse.receivedResponseAtMillis();
+                Headers headers = cacheResponse.headers();
+                for (int i = 0, size = headers.size(); i < size; i++) {
+                    String fieldName = headers.name(i);
+                    String value = headers.value(i);
+                    // 生成消息的具体时间和日期，即当前的GMT时间
+                    if ("Date".equalsIgnoreCase(fieldName)) {
+                        servedDate = HttpDate.parse(value);
+                        servedDateString = value;
+                    }
+                    // 过期时间
+                    else if ("Expires".equalsIgnoreCase(fieldName)) {
+                        expires = HttpDate.parse(value);
+                    }
+                    // 最后编辑时间
+                    else if ("Last-Modified".equalsIgnoreCase(fieldName)) {
+                        lastModified = HttpDate.parse(value);
+                        lastModifiedString = value;
+                    }
+                    // 资源标识，和If-None-Match 配合使用
+                    else if ("ETag".equalsIgnoreCase(fieldName)) {
+                        etag = value;
+                    }
+                    // 当代理服务器用自己缓存的实体去响应请求时，用该头部表明该实体从产生到现在经过多长时间了
+                    else if ("Age".equalsIgnoreCase(fieldName)) {
+                        ageSeconds = HttpHeaders.parseSeconds(value, -1);
+                    }
+                }
+            }
+        }
 
-      if (candidate.networkRequest != null && request.cacheControl().onlyIfCached()) {
-        // We're forbidden from using the network and the cache is insufficient.
-        return new CacheStrategy(null, null);
-      }
+        /**
+         * Returns a strategy to satisfy {@code request} using the a cached response {@code response}.
+         */
+        public CacheStrategy get() {
+            CacheStrategy candidate = getCandidate();
 
-      return candidate;
-    }
+            if (candidate.networkRequest != null && request.cacheControl().onlyIfCached()) {
+                // We're forbidden from using the network and the cache is insufficient.
+                return new CacheStrategy(null, null);
+            }
 
-    /** Returns a strategy to use assuming the request can use the network. */
-    private CacheStrategy getCandidate() {
-      // No cached response.
-      if (cacheResponse == null) {
-        return new CacheStrategy(request, null);
-      }
-
-      // Drop the cached response if it's missing a required handshake.
-      if (request.isHttps() && cacheResponse.handshake() == null) {
-        return new CacheStrategy(request, null);
-      }
-
-      // If this response shouldn't have been stored, it should never be used
-      // as a response source. This check should be redundant as long as the
-      // persistence store is well-behaved and the rules are constant.
-      if (!isCacheable(cacheResponse, request)) {
-        return new CacheStrategy(request, null);
-      }
-
-      CacheControl requestCaching = request.cacheControl();
-      if (requestCaching.noCache() || hasConditions(request)) {
-        return new CacheStrategy(request, null);
-      }
-
-      CacheControl responseCaching = cacheResponse.cacheControl();
-      if (responseCaching.immutable()) {
-        return new CacheStrategy(null, cacheResponse);
-      }
-
-      long ageMillis = cacheResponseAge();
-      long freshMillis = computeFreshnessLifetime();
-
-      if (requestCaching.maxAgeSeconds() != -1) {
-        freshMillis = Math.min(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds()));
-      }
-
-      long minFreshMillis = 0;
-      if (requestCaching.minFreshSeconds() != -1) {
-        minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds());
-      }
-
-      long maxStaleMillis = 0;
-      if (!responseCaching.mustRevalidate() && requestCaching.maxStaleSeconds() != -1) {
-        maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds());
-      }
-
-      if (!responseCaching.noCache() && ageMillis + minFreshMillis < freshMillis + maxStaleMillis) {
-        Response.Builder builder = cacheResponse.newBuilder();
-        if (ageMillis + minFreshMillis >= freshMillis) {
-          builder.addHeader("Warning", "110 HttpURLConnection \"Response is stale\"");
+            return candidate;
         }
-        long oneDayMillis = 24 * 60 * 60 * 1000L;
-        if (ageMillis > oneDayMillis && isFreshnessLifetimeHeuristic()) {
-          builder.addHeader("Warning", "113 HttpURLConnection \"Heuristic expiration\"");
+
+        /**
+         * Returns a strategy to use assuming the request can use the network.
+         * <br> 返回一个策略，假设请求可以使用网络
+         */
+        private CacheStrategy getCandidate() {
+            // No cached response.
+            // 没有缓存数据
+            if (cacheResponse == null) {
+                return new CacheStrategy(request, null);
+            }
+
+            // Drop the cached response if it's missing a required handshake.
+            // 缓存的响应丢失握手数据，则丢弃缓存
+            if (request.isHttps() && cacheResponse.handshake() == null) {
+                return new CacheStrategy(request, null);
+            }
+
+            // If this response shouldn't have been stored, it should never be used
+            // as a response source. This check should be redundant as long as the
+            // persistence store is well-behaved and the rules are constant.
+            // 如果缓存的响应不能被缓存，就不应该作为响应返回。
+            // 只要持久化保存没有问题并且规则不变，这个校验就是多余的。（作者是为了以防万一？）
+            if (!isCacheable(cacheResponse, request)) {
+                return new CacheStrategy(request, null);
+            }
+
+            CacheControl requestCaching = request.cacheControl();
+            // 不缓存或请求头配置了 If-Modified-Since / If-None-Match
+            if (requestCaching.noCache() || hasConditions(request)) {
+                return new CacheStrategy(request, null);
+            }
+
+            CacheControl responseCaching = cacheResponse.cacheControl();
+            // 永不过期的资源
+            if (responseCaching.immutable()) {
+                return new CacheStrategy(null, cacheResponse);
+            }
+
+            long ageMillis = cacheResponseAge();
+            long freshMillis = computeFreshnessLifetime();
+
+            if (requestCaching.maxAgeSeconds() != -1) {
+                freshMillis = Math.min(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds()));
+            }
+
+            long minFreshMillis = 0;
+            if (requestCaching.minFreshSeconds() != -1) {
+                minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds());
+            }
+
+            long maxStaleMillis = 0;
+            if (!responseCaching.mustRevalidate() && requestCaching.maxStaleSeconds() != -1) {
+                maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds());
+            }
+
+            if (!responseCaching.noCache() && ageMillis + minFreshMillis < freshMillis + maxStaleMillis) {
+                Response.Builder builder = cacheResponse.newBuilder();
+                if (ageMillis + minFreshMillis >= freshMillis) {
+                    builder.addHeader("Warning", "110 HttpURLConnection \"Response is stale\"");
+                }
+                long oneDayMillis = 24 * 60 * 60 * 1000L;
+                if (ageMillis > oneDayMillis && isFreshnessLifetimeHeuristic()) {
+                    builder.addHeader("Warning", "113 HttpURLConnection \"Heuristic expiration\"");
+                }
+                return new CacheStrategy(null, builder.build());
+            }
+
+            // Find a condition to add to the request. If the condition is satisfied, the response body
+            // will not be transmitted.
+            String conditionName;
+            String conditionValue;
+            if (etag != null) {
+                conditionName = "If-None-Match";
+                conditionValue = etag;
+            } else if (lastModified != null) {
+                conditionName = "If-Modified-Since";
+                conditionValue = lastModifiedString;
+            } else if (servedDate != null) {
+                conditionName = "If-Modified-Since";
+                conditionValue = servedDateString;
+            } else {
+                return new CacheStrategy(request, null); // No condition! Make a regular request.
+            }
+
+            Headers.Builder conditionalRequestHeaders = request.headers().newBuilder();
+            Internal.instance.addLenient(conditionalRequestHeaders, conditionName, conditionValue);
+
+            Request conditionalRequest = request.newBuilder()
+                    .headers(conditionalRequestHeaders.build())
+                    .build();
+            return new CacheStrategy(conditionalRequest, cacheResponse);
         }
-        return new CacheStrategy(null, builder.build());
-      }
-
-      // Find a condition to add to the request. If the condition is satisfied, the response body
-      // will not be transmitted.
-      String conditionName;
-      String conditionValue;
-      if (etag != null) {
-        conditionName = "If-None-Match";
-        conditionValue = etag;
-      } else if (lastModified != null) {
-        conditionName = "If-Modified-Since";
-        conditionValue = lastModifiedString;
-      } else if (servedDate != null) {
-        conditionName = "If-Modified-Since";
-        conditionValue = servedDateString;
-      } else {
-        return new CacheStrategy(request, null); // No condition! Make a regular request.
-      }
-
-      Headers.Builder conditionalRequestHeaders = request.headers().newBuilder();
-      Internal.instance.addLenient(conditionalRequestHeaders, conditionName, conditionValue);
-
-      Request conditionalRequest = request.newBuilder()
-          .headers(conditionalRequestHeaders.build())
-          .build();
-      return new CacheStrategy(conditionalRequest, cacheResponse);
-    }
 
-    /**
-     * Returns the number of milliseconds that the response was fresh for, starting from the served
-     * date.
-     */
-    private long computeFreshnessLifetime() {
-      CacheControl responseCaching = cacheResponse.cacheControl();
-      if (responseCaching.maxAgeSeconds() != -1) {
-        return SECONDS.toMillis(responseCaching.maxAgeSeconds());
-      } else if (expires != null) {
-        long servedMillis = servedDate != null
-            ? servedDate.getTime()
-            : receivedResponseMillis;
-        long delta = expires.getTime() - servedMillis;
-        return delta > 0 ? delta : 0;
-      } else if (lastModified != null
-          && cacheResponse.request().url().query() == null) {
-        // As recommended by the HTTP RFC and implemented in Firefox, the
-        // max age of a document should be defaulted to 10% of the
-        // document's age at the time it was served. Default expiration
-        // dates aren't used for URIs containing a query.
-        long servedMillis = servedDate != null
-            ? servedDate.getTime()
-            : sentRequestMillis;
-        long delta = servedMillis - lastModified.getTime();
-        return delta > 0 ? (delta / 10) : 0;
-      }
-      return 0;
-    }
+        /**
+         * Returns the number of milliseconds that the response was fresh for, starting from the served
+         * date.
+         * <br> 缓存还能保留的时长
+         */
+        private long computeFreshnessLifetime() {
+            CacheControl responseCaching = cacheResponse.cacheControl();
+            if (responseCaching.maxAgeSeconds() != -1) {
+                return SECONDS.toMillis(responseCaching.maxAgeSeconds());
+            } else if (expires != null) {
+                long servedMillis = servedDate != null
+                        ? servedDate.getTime()
+                        : receivedResponseMillis;
+                long delta = expires.getTime() - servedMillis;
+                return delta > 0 ? delta : 0;
+            } else if (lastModified != null
+                    && cacheResponse.request().url().query() == null) {
+                // As recommended by the HTTP RFC and implemented in Firefox, the
+                // max age of a document should be defaulted to 10% of the
+                // document's age at the time it was served. Default expiration
+                // dates aren't used for URIs containing a query.
+                long servedMillis = servedDate != null
+                        ? servedDate.getTime()
+                        : sentRequestMillis;
+                long delta = servedMillis - lastModified.getTime();
+                return delta > 0 ? (delta / 10) : 0;
+            }
+            return 0;
+        }
 
-    /**
-     * Returns the current age of the response, in milliseconds. The calculation is specified by RFC
-     * 2616, 13.2.3 Age Calculations.
-     */
-    private long cacheResponseAge() {
-      long apparentReceivedAge = servedDate != null
-          ? Math.max(0, receivedResponseMillis - servedDate.getTime())
-          : 0;
-      long receivedAge = ageSeconds != -1
-          ? Math.max(apparentReceivedAge, SECONDS.toMillis(ageSeconds))
-          : apparentReceivedAge;
-      long responseDuration = receivedResponseMillis - sentRequestMillis;
-      long residentDuration = nowMillis - receivedResponseMillis;
-      return receivedAge + responseDuration + residentDuration;
-    }
+        /**
+         * Returns the current age of the response, in milliseconds. The calculation is specified by RFC
+         * 2616, 13.2.3 Age Calculations.
+         * <br>
+         */
+        private long cacheResponseAge() {
+            // 获取的时间 - 服务器时间
+            long apparentReceivedAge = servedDate != null
+                    ? Math.max(0, receivedResponseMillis - servedDate.getTime())
+                    : 0;
+            // 放入缓存的时间 - 服务器时间
+            long receivedAge = ageSeconds != -1
+                    ? Math.max(apparentReceivedAge, SECONDS.toMillis(ageSeconds))
+                    : apparentReceivedAge;
+            // 响应耗时
+            long responseDuration = receivedResponseMillis - sentRequestMillis;
+            // 从得到响应到现在的时长
+            long residentDuration = nowMillis - receivedResponseMillis;
+            return receivedAge + responseDuration + residentDuration;
+        }
 
-    /**
-     * Returns true if computeFreshnessLifetime used a heuristic. If we used a heuristic to serve a
-     * cached response older than 24 hours, we are required to attach a warning.
-     */
-    private boolean isFreshnessLifetimeHeuristic() {
-      return cacheResponse.cacheControl().maxAgeSeconds() == -1 && expires == null;
-    }
+        /**
+         * Returns true if computeFreshnessLifetime used a heuristic. If we used a heuristic to serve a
+         * cached response older than 24 hours, we are required to attach a warning.
+         */
+        private boolean isFreshnessLifetimeHeuristic() {
+            return cacheResponse.cacheControl().maxAgeSeconds() == -1 && expires == null;
+        }
 
-    /**
-     * Returns true if the request contains conditions that save the server from sending a response
-     * that the client has locally. When a request is enqueued with its own conditions, the built-in
-     * response cache won't be used.
-     */
-    private static boolean hasConditions(Request request) {
-      return request.header("If-Modified-Since") != null || request.header("If-None-Match") != null;
+        /**
+         * Returns true if the request contains conditions that save the server from sending a response
+         * that the client has locally. When a request is enqueued with its own conditions, the built-in
+         * response cache won't be used.
+         */
+        private static boolean hasConditions(Request request) {
+            return request.header("If-Modified-Since") != null || request.header("If-None-Match") != null;
+        }
     }
-  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java b/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
index a63fcc26f1..c27525ca69 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
@@ -96,7 +96,11 @@
 
   // The fields below track connection state and are guarded by connectionPool.
 
-  /** If true, no new streams can be created on this connection. Once true this is always true. */
+  /**
+   * If true, no new streams can be created on this connection. Once true this is always true.
+   * <br>
+   *     如果为true，则不能在该连接上创建新的 stream，一旦为 true 则一直为 true
+   */
   public boolean noNewStreams;
 
   public int successCount;
@@ -413,6 +417,8 @@ private Request createTunnelRequest() {
   /**
    * Returns true if this connection can carry a stream allocation to {@code address}. If non-null
    * {@code route} is the resolved route for a connection.
+   * <br>
+   *     如果此连接可以承接一个对此地址分配的 stream，则返回 true。如果路由非空，连接会使用此路由
    */
   public boolean isEligible(Address address, @Nullable Route route) {
     // If this connection is not accepting new streams, we're done.
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java b/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
index 60b7b8fe3b..3ce30cb3a4 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
@@ -155,6 +155,7 @@ private RealConnection findHealthyConnection(int connectTimeout, int readTimeout
                     connectionRetryEnabled);
 
             // If this is a brand new connection, we can skip the extensive health checks.
+            // 如果是个全新的连接，可以跳过进一步检查
             synchronized (connectionPool) {
                 if (candidate.successCount == 0) {
                     return candidate;
@@ -188,12 +189,15 @@ private RealConnection findConnection(int connectTimeout, int readTimeout, int w
             if (canceled) throw new IOException("Canceled");
 
             // Attempt to use an already-allocated connection.
+            // 尝试使用已经分配的连接
             RealConnection allocatedConnection = this.connection;
             if (allocatedConnection != null && !allocatedConnection.noNewStreams) {
                 return allocatedConnection;
             }
 
             // Attempt to get a connection from the pool.
+            // 尝试从连接池中获取
+            // Internal.instance 在 OkHttpClient 中实例化的 --> ConnectionPool.get --> this.acquire
             Internal.instance.get(connectionPool, address, this, null);
             if (connection != null) {
                 foundPooledConnection = true;
@@ -329,6 +333,8 @@ public void release() {
 
     /**
      * Forbid new streams from being created on the connection that hosts this allocation.
+     * <br>
+     *     禁止 host 在此的连接创建新的 stream
      */
     public void noNewStreams() {
         Socket socket;
@@ -437,6 +443,8 @@ public void streamFailed(IOException e) {
     /**
      * Use this allocation to hold {@code connection}. Each call to this must be paired with a call to
      * {@link #release} on the same connection.
+     * <br>
+     *     让此 allocation 持有连接。同一个连接，此方法的调用要和 release 方法成对出现。
      */
     public void acquire(RealConnection connection) {
         assert (Thread.holdsLock(connectionPool));
diff --git a/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.java
index 54b561da88..18066dc629 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.java
@@ -18,6 +18,7 @@
 
 import java.io.IOException;
 import java.util.List;
+
 import okhttp3.Cookie;
 import okhttp3.CookieJar;
 import okhttp3.Headers;
@@ -38,90 +39,93 @@
  * response.
  */
 public final class BridgeInterceptor implements Interceptor {
-  private final CookieJar cookieJar;
-
-  public BridgeInterceptor(CookieJar cookieJar) {
-    this.cookieJar = cookieJar;
-  }
-
-  @Override public Response intercept(Chain chain) throws IOException {
-    Request userRequest = chain.request();
-    Request.Builder requestBuilder = userRequest.newBuilder();
-
-    RequestBody body = userRequest.body();
-    if (body != null) {
-      MediaType contentType = body.contentType();
-      if (contentType != null) {
-        requestBuilder.header("Content-Type", contentType.toString());
-      }
-
-      long contentLength = body.contentLength();
-      if (contentLength != -1) {
-        requestBuilder.header("Content-Length", Long.toString(contentLength));
-        requestBuilder.removeHeader("Transfer-Encoding");
-      } else {
-        requestBuilder.header("Transfer-Encoding", "chunked");
-        requestBuilder.removeHeader("Content-Length");
-      }
-    }
-
-    if (userRequest.header("Host") == null) {
-      requestBuilder.header("Host", hostHeader(userRequest.url(), false));
-    }
+    private final CookieJar cookieJar;
 
-    if (userRequest.header("Connection") == null) {
-      requestBuilder.header("Connection", "Keep-Alive");
+    public BridgeInterceptor(CookieJar cookieJar) {
+        this.cookieJar = cookieJar;
     }
 
-    // If we add an "Accept-Encoding: gzip" header field we're responsible for also decompressing
-    // the transfer stream.
-    boolean transparentGzip = false;
-    if (userRequest.header("Accept-Encoding") == null && userRequest.header("Range") == null) {
-      transparentGzip = true;
-      requestBuilder.header("Accept-Encoding", "gzip");
-    }
-
-    List<Cookie> cookies = cookieJar.loadForRequest(userRequest.url());
-    if (!cookies.isEmpty()) {
-      requestBuilder.header("Cookie", cookieHeader(cookies));
-    }
-
-    if (userRequest.header("User-Agent") == null) {
-      requestBuilder.header("User-Agent", Version.userAgent());
-    }
-
-    Response networkResponse = chain.proceed(requestBuilder.build());
-
-    HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());
-
-    Response.Builder responseBuilder = networkResponse.newBuilder()
-        .request(userRequest);
-
-    if (transparentGzip
-        && "gzip".equalsIgnoreCase(networkResponse.header("Content-Encoding"))
-        && HttpHeaders.hasBody(networkResponse)) {
-      GzipSource responseBody = new GzipSource(networkResponse.body().source());
-      Headers strippedHeaders = networkResponse.headers().newBuilder()
-          .removeAll("Content-Encoding")
-          .removeAll("Content-Length")
-          .build();
-      responseBuilder.headers(strippedHeaders);
-      responseBuilder.body(new RealResponseBody(strippedHeaders, Okio.buffer(responseBody)));
+    @Override
+    public Response intercept(Chain chain) throws IOException {
+        Request userRequest = chain.request();
+        Request.Builder requestBuilder = userRequest.newBuilder();
+
+        RequestBody body = userRequest.body();
+        if (body != null) {
+            MediaType contentType = body.contentType();
+            if (contentType != null) {
+                requestBuilder.header("Content-Type", contentType.toString());
+            }
+
+            long contentLength = body.contentLength();
+            if (contentLength != -1) {
+                requestBuilder.header("Content-Length", Long.toString(contentLength));
+                requestBuilder.removeHeader("Transfer-Encoding");
+            } else {
+                requestBuilder.header("Transfer-Encoding", "chunked");
+                requestBuilder.removeHeader("Content-Length");
+            }
+        }
+
+        if (userRequest.header("Host") == null) {
+            requestBuilder.header("Host", hostHeader(userRequest.url(), false));
+        }
+
+        if (userRequest.header("Connection") == null) {
+            requestBuilder.header("Connection", "Keep-Alive");
+        }
+
+        // If we add an "Accept-Encoding: gzip" header field we're responsible for also decompressing
+        // the transfer stream.
+        boolean transparentGzip = false;
+        if (userRequest.header("Accept-Encoding") == null && userRequest.header("Range") == null) {
+            transparentGzip = true;
+            requestBuilder.header("Accept-Encoding", "gzip");
+        }
+
+        List<Cookie> cookies = cookieJar.loadForRequest(userRequest.url());
+        if (!cookies.isEmpty()) {
+            requestBuilder.header("Cookie", cookieHeader(cookies));
+        }
+
+        if (userRequest.header("User-Agent") == null) {
+            requestBuilder.header("User-Agent", Version.userAgent());
+        }
+
+        Response networkResponse = chain.proceed(requestBuilder.build());
+
+        HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());
+
+        Response.Builder responseBuilder = networkResponse.newBuilder()
+                .request(userRequest);
+
+        if (transparentGzip
+                && "gzip".equalsIgnoreCase(networkResponse.header("Content-Encoding"))
+                && HttpHeaders.hasBody(networkResponse)) {
+            GzipSource responseBody = new GzipSource(networkResponse.body().source());
+            Headers strippedHeaders = networkResponse.headers().newBuilder()
+                    .removeAll("Content-Encoding")
+                    .removeAll("Content-Length")
+                    .build();
+            responseBuilder.headers(strippedHeaders);
+            responseBuilder.body(new RealResponseBody(strippedHeaders, Okio.buffer(responseBody)));
+        }
+
+        return responseBuilder.build();
     }
 
-    return responseBuilder.build();
-  }
-
-  /** Returns a 'Cookie' HTTP request header with all cookies, like {@code a=b; c=d}. */
-  private String cookieHeader(List<Cookie> cookies) {
-    StringBuilder cookieHeader = new StringBuilder();
-    for (int i = 0, size = cookies.size(); i < size; i++) {
-      if (i > 0) {
-        cookieHeader.append("; ");
-      }
-      Cookie cookie = cookies.get(i);
-      cookieHeader.append(cookie.name()).append('=').append(cookie.value());
+    /**
+     * Returns a 'Cookie' HTTP request header with all cookies, like {@code a=b; c=d}.
+     */
+    private String cookieHeader(List<Cookie> cookies) {
+        StringBuilder cookieHeader = new StringBuilder();
+        for (int i = 0, size = cookies.size(); i < size; i++) {
+            if (i > 0) {
+                cookieHeader.append("; ");
+            }
+            Cookie cookie = cookies.get(i);
+            cookieHeader.append(cookie.name()).append('=').append(cookie.value());
+        }
+        return cookieHeader.toString();
     }
-    return cookieHeader.toString();
-  }
 }
