diff --git a/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java b/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java
index 3ae1926650..7013047b6a 100644
--- a/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java
+++ b/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java
@@ -140,11 +140,14 @@ public static boolean isCacheable(Response response, Request request) {
     public Factory(long nowMillis, Request request, Response cacheResponse) {
       this.nowMillis = nowMillis;
       this.request = request;
+      // 1.从磁盘中直接读取出来的原始缓存，没有对头部的字段进行校验。
       this.cacheResponse = cacheResponse;
 
       if (cacheResponse != null) {
+        // 读取发送请求和收到结果的时间。
         this.sentRequestMillis = cacheResponse.sentRequestAtMillis();
         this.receivedResponseMillis = cacheResponse.receivedResponseAtMillis();
+        // 遍历头部字段，解析完毕后赋值给成员变量。
         Headers headers = cacheResponse.headers();
         for (int i = 0, size = headers.size(); i < size; i++) {
           String fieldName = headers.name(i);
@@ -170,8 +173,10 @@ public Factory(long nowMillis, Request request, Response cacheResponse) {
      * Returns a strategy to satisfy {@code request} using the a cached response {@code response}.
      */
     public CacheStrategy get() {
+      // 通过 getCandidate 方法来对 networkRequest 和 cacheResponse 赋值。
       CacheStrategy candidate = getCandidate();
-
+  
+      // 如果网络请求不为空，但是 request 设置了 onlyIfCached 标志位，那么把两个请求都赋值为空。
       if (candidate.networkRequest != null && request.cacheControl().onlyIfCached()) {
         // We're forbidden from using the network and the cache is insufficient.
         return new CacheStrategy(null, null);
@@ -182,11 +187,13 @@ public CacheStrategy get() {
 
     /** Returns a strategy to use assuming the request can use the network. */
     private CacheStrategy getCandidate() {
+      // 1.如果缓存为空，那么直接返回带有网络请求的策略。
       // No cached response.
       if (cacheResponse == null) {
         return new CacheStrategy(request, null);
       }
-
+  
+      // 2.请求是 Https 的，并且握手不成功，就放弃缓存，直接返回带有网络请求的策略。
       // Drop the cached response if it's missing a required handshake.
       if (request.isHttps() && cacheResponse.handshake() == null) {
         return new CacheStrategy(request, null);
@@ -195,37 +202,46 @@ private CacheStrategy getCandidate() {
       // If this response shouldn't have been stored, it should never be used
       // as a response source. This check should be redundant as long as the
       // persistence store is well-behaved and the rules are constant.
+      // 3.根据缓存的状态判断是否需要该缓存，在规则一致的时候一般不会在这一步返回。
       if (!isCacheable(cacheResponse, request)) {
         return new CacheStrategy(request, null);
       }
-
+  
+      // 4.获得当前请求的 cacheControl，如果配置了不缓存，或者当前的请求配置了 If-Modified-Since/If-None-Match 字段。
       CacheControl requestCaching = request.cacheControl();
       if (requestCaching.noCache() || hasConditions(request)) {
         return new CacheStrategy(request, null);
       }
-
+  
+      // 5.获取缓存的 cacheControl，如果是可变的，那么就直接返回该缓存。
       CacheControl responseCaching = cacheResponse.cacheControl();
       if (responseCaching.immutable()) {
         return new CacheStrategy(null, cacheResponse);
       }
-
+  
+      // 6.1 计算缓存的年龄。
       long ageMillis = cacheResponseAge();
+      // 6.2 计算刷新的时机。
       long freshMillis = computeFreshnessLifetime();
-
+  
+      // 7.请求所允许的最大年龄。
       if (requestCaching.maxAgeSeconds() != -1) {
         freshMillis = Math.min(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds()));
       }
-
+  
+      // 8.请求所允许的最小年龄。
       long minFreshMillis = 0;
       if (requestCaching.minFreshSeconds() != -1) {
         minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds());
       }
-
+  
+      // 9.最大的 Stale() 时间。
       long maxStaleMillis = 0;
       if (!responseCaching.mustRevalidate() && requestCaching.maxStaleSeconds() != -1) {
         maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds());
       }
-
+  
+      // 10.根据几个时间点确定是否返回缓存，并且去掉网络请求，如果客户端需要强行去掉网络请求，那么就是修改这个条件。
       if (!responseCaching.noCache() && ageMillis + minFreshMillis < freshMillis + maxStaleMillis) {
         Response.Builder builder = cacheResponse.newBuilder();
         if (ageMillis + minFreshMillis >= freshMillis) {
@@ -237,7 +253,8 @@ private CacheStrategy getCandidate() {
         }
         return new CacheStrategy(null, builder.build());
       }
-
+  
+      // 填入条件请求的字段。
       // Find a condition to add to the request. If the condition is satisfied, the response body
       // will not be transmitted.
       String conditionName;
@@ -252,6 +269,7 @@ private CacheStrategy getCandidate() {
         conditionName = "If-Modified-Since";
         conditionValue = servedDateString;
       } else {
+        // 如果不是条件请求，那么去掉原始缓存。
         return new CacheStrategy(request, null); // No condition! Make a regular request.
       }
 
@@ -261,6 +279,7 @@ private CacheStrategy getCandidate() {
       Request conditionalRequest = request.newBuilder()
           .headers(conditionalRequestHeaders.build())
           .build();
+      // 返回带有条件请求的 conditionalRequest，和原始的缓存，这样在出现 304 的时候就可以处理。
       return new CacheStrategy(conditionalRequest, cacheResponse);
     }
 
