diff --git a/okhttp/src/main/java/okhttp3/ConnectionPool.java b/okhttp/src/main/java/okhttp3/ConnectionPool.java
index a589e3ad1d..376fefa0f8 100644
--- a/okhttp/src/main/java/okhttp3/ConnectionPool.java
+++ b/okhttp/src/main/java/okhttp3/ConnectionPool.java
@@ -27,6 +27,7 @@
 import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
+
 import okhttp3.internal.Util;
 import okhttp3.internal.connection.RealConnection;
 import okhttp3.internal.connection.RouteDatabase;
@@ -41,241 +42,259 @@
  * of which connections to keep open for future use.
  */
 public final class ConnectionPool {
-  /**
-   * Background threads are used to cleanup expired connections. There will be at most a single
-   * thread running per connection pool. The thread pool executor permits the pool itself to be
-   * garbage collected.
-   */
-  private static final Executor executor = new ThreadPoolExecutor(0 /* corePoolSize */,
-      Integer.MAX_VALUE /* maximumPoolSize */, 60L /* keepAliveTime */, TimeUnit.SECONDS,
-      new SynchronousQueue<Runnable>(), Util.threadFactory("OkHttp ConnectionPool", true));
+    /**
+     * Background threads are used to cleanup expired connections. There will be at most a single
+     * thread running per connection pool. The thread pool executor permits the pool itself to be
+     * garbage collected.
+     */
+    private static final Executor executor = new ThreadPoolExecutor(0 /* corePoolSize */,
+            Integer.MAX_VALUE /* maximumPoolSize */, 60L /* keepAliveTime */, TimeUnit.SECONDS,
+            new SynchronousQueue<Runnable>(), Util.threadFactory("OkHttp ConnectionPool", true));
 
-  /** The maximum number of idle connections for each address. */
-  private final int maxIdleConnections;
-  private final long keepAliveDurationNs;
-  private final Runnable cleanupRunnable = new Runnable() {
-    @Override public void run() {
-      while (true) {
-        long waitNanos = cleanup(System.nanoTime());
-        if (waitNanos == -1) return;
-        if (waitNanos > 0) {
-          long waitMillis = waitNanos / 1000000L;
-          waitNanos -= (waitMillis * 1000000L);
-          synchronized (ConnectionPool.this) {
-            try {
-              ConnectionPool.this.wait(waitMillis, (int) waitNanos);
-            } catch (InterruptedException ignored) {
+    /**
+     * The maximum number of idle connections for each address.
+     */
+    private final int maxIdleConnections;// 最大空闲链接数
+    private final long keepAliveDurationNs;// 存活时间
+    private final Runnable cleanupRunnable = new Runnable() {
+        @Override
+        public void run() {
+            while (true) {
+                long waitNanos = cleanup(System.nanoTime());
+                if (waitNanos == -1) return;
+                if (waitNanos > 0) {
+                    long waitMillis = waitNanos / 1000000L;
+                    waitNanos -= (waitMillis * 1000000L);
+                    synchronized (ConnectionPool.this) {
+                        try {
+                            // wait会释放锁
+                            ConnectionPool.this.wait(waitMillis, (int) waitNanos);
+                        } catch (InterruptedException ignored) {
+                        }
+                    }
+                }
             }
-          }
         }
-      }
-    }
-  };
+    };
 
-  private final Deque<RealConnection> connections = new ArrayDeque<>();
-  final RouteDatabase routeDatabase = new RouteDatabase();
-  boolean cleanupRunning;
+    private final Deque<RealConnection> connections = new ArrayDeque<>();
+    final RouteDatabase routeDatabase = new RouteDatabase();
+    boolean cleanupRunning;
 
-  /**
-   * Create a new connection pool with tuning parameters appropriate for a single-user application.
-   * The tuning parameters in this pool are subject to change in future OkHttp releases. Currently
-   * this pool holds up to 5 idle connections which will be evicted after 5 minutes of inactivity.
-   */
-  public ConnectionPool() {
-    this(5, 5, TimeUnit.MINUTES);
-  }
+    /**
+     * Create a new connection pool with tuning parameters appropriate for a single-user application.
+     * The tuning parameters in this pool are subject to change in future OkHttp releases. Currently
+     * this pool holds up to 5 idle connections which will be evicted after 5 minutes of inactivity.
+     * 链接池的配置参数，未来可能发生更改，当前设定：5个空闲链接，5分钟
+     */
+    public ConnectionPool() {
+        this(5, 5, TimeUnit.MINUTES);
+    }
 
-  public ConnectionPool(int maxIdleConnections, long keepAliveDuration, TimeUnit timeUnit) {
-    this.maxIdleConnections = maxIdleConnections;
-    this.keepAliveDurationNs = timeUnit.toNanos(keepAliveDuration);
+    public ConnectionPool(int maxIdleConnections, long keepAliveDuration, TimeUnit timeUnit) {
+        this.maxIdleConnections = maxIdleConnections;
+        this.keepAliveDurationNs = timeUnit.toNanos(keepAliveDuration);
 
-    // Put a floor on the keep alive duration, otherwise cleanup will spin loop.
-    if (keepAliveDuration <= 0) {
-      throw new IllegalArgumentException("keepAliveDuration <= 0: " + keepAliveDuration);
+        // Put a floor on the keep alive duration, otherwise cleanup will spin loop.
+        if (keepAliveDuration <= 0) {
+            throw new IllegalArgumentException("keepAliveDuration <= 0: " + keepAliveDuration);
+        }
     }
-  }
 
-  /** Returns the number of idle connections in the pool. */
-  public synchronized int idleConnectionCount() {
-    int total = 0;
-    for (RealConnection connection : connections) {
-      if (connection.allocations.isEmpty()) total++;
+    /**
+     * Returns the number of idle connections in the pool.
+     */
+    public synchronized int idleConnectionCount() {
+        int total = 0;
+        for (RealConnection connection : connections) {
+            if (connection.allocations.isEmpty()) total++;
+        }
+        return total;
     }
-    return total;
-  }
-
-  /**
-   * Returns total number of connections in the pool. Note that prior to OkHttp 2.7 this included
-   * only idle connections and HTTP/2 connections. Since OkHttp 2.7 this includes all connections,
-   * both active and inactive. Use {@link #idleConnectionCount()} to count connections not currently
-   * in use.
-   */
-  public synchronized int connectionCount() {
-    return connections.size();
-  }
 
-  /** Returns a recycled connection to {@code address}, or null if no such connection exists. */
-  RealConnection get(Address address, StreamAllocation streamAllocation) {
-    assert (Thread.holdsLock(this));
-    for (RealConnection connection : connections) {
-      if (connection.isEligible(address)) {
-        streamAllocation.acquire(connection);
-        return connection;
-      }
+    /**
+     * Returns total number of connections in the pool. Note that prior to OkHttp 2.7 this included
+     * only idle connections and HTTP/2 connections. Since OkHttp 2.7 this includes all connections,
+     * both active and inactive. Use {@link #idleConnectionCount()} to count connections not currently
+     * in use.
+     */
+    public synchronized int connectionCount() {
+        return connections.size();
     }
-    return null;
-  }
 
-  /**
-   * Replaces the connection held by {@code streamAllocation} with a shared connection if possible.
-   * This recovers when multiple multiplexed connections are created concurrently.
-   */
-  Socket deduplicate(Address address, StreamAllocation streamAllocation) {
-    assert (Thread.holdsLock(this));
-    for (RealConnection connection : connections) {
-      if (connection.isEligible(address)
-          && connection.isMultiplexed()
-          && connection != streamAllocation.connection()) {
-        return streamAllocation.releaseAndAcquire(connection);
-      }
+    /**
+     * Returns a recycled connection to {@code address}, or null if no such connection exists.
+     */
+    RealConnection get(Address address, StreamAllocation streamAllocation) {
+        assert (Thread.holdsLock(this));
+        for (RealConnection connection : connections) {
+            if (connection.isEligible(address)) {// 如果符合条件
+                streamAllocation.acquire(connection);// 增加引用计数
+                return connection;
+            }
+        }
+        return null;
     }
-    return null;
-  }
 
-  void put(RealConnection connection) {
-    assert (Thread.holdsLock(this));
-    if (!cleanupRunning) {
-      cleanupRunning = true;
-      executor.execute(cleanupRunnable);
+    /**
+     * Replaces the connection held by {@code streamAllocation} with a shared connection if possible.
+     * This recovers when multiple multiplexed connections are created concurrently.
+     */
+    Socket deduplicate(Address address, StreamAllocation streamAllocation) {
+        assert (Thread.holdsLock(this));
+        for (RealConnection connection : connections) {
+            if (connection.isEligible(address)
+                    && connection.isMultiplexed()
+                    && connection != streamAllocation.connection()) {
+                return streamAllocation.releaseAndAcquire(connection);
+            }
+        }
+        return null;
     }
-    connections.add(connection);
-  }
 
-  /**
-   * Notify this pool that {@code connection} has become idle. Returns true if the connection has
-   * been removed from the pool and should be closed.
-   */
-  boolean connectionBecameIdle(RealConnection connection) {
-    assert (Thread.holdsLock(this));
-    if (connection.noNewStreams || maxIdleConnections == 0) {
-      connections.remove(connection);
-      return true;
-    } else {
-      notifyAll(); // Awake the cleanup thread: we may have exceeded the idle connection limit.
-      return false;
+    void put(RealConnection connection) {
+        assert (Thread.holdsLock(this));
+        if (!cleanupRunning) {
+            cleanupRunning = true;
+            executor.execute(cleanupRunnable);
+        }
+        connections.add(connection);
     }
-  }
 
-  /** Close and remove all idle connections in the pool. */
-  public void evictAll() {
-    List<RealConnection> evictedConnections = new ArrayList<>();
-    synchronized (this) {
-      for (Iterator<RealConnection> i = connections.iterator(); i.hasNext(); ) {
-        RealConnection connection = i.next();
-        if (connection.allocations.isEmpty()) {
-          connection.noNewStreams = true;
-          evictedConnections.add(connection);
-          i.remove();
+    /**
+     * Notify this pool that {@code connection} has become idle. Returns true if the connection has
+     * been removed from the pool and should be closed.
+     * 移除链接。
+     */
+    boolean connectionBecameIdle(RealConnection connection) {
+        assert (Thread.holdsLock(this));
+        if (connection.noNewStreams || maxIdleConnections == 0) {
+            connections.remove(connection);
+            return true;
+        } else {
+            // 唤醒cleanupRunnable。
+            notifyAll(); // Awake the cleanup thread: we may have exceeded the idle connection limit.
+            return false;
         }
-      }
     }
 
-    for (RealConnection connection : evictedConnections) {
-      closeQuietly(connection.socket());
+    /**
+     * Close and remove all idle connections in the pool.
+     * 移除所有空闲链接
+     */
+    public void evictAll() {
+        List<RealConnection> evictedConnections = new ArrayList<>();
+        synchronized (this) {
+            for (Iterator<RealConnection> i = connections.iterator(); i.hasNext(); ) {
+                RealConnection connection = i.next();
+                if (connection.allocations.isEmpty()) {
+                    connection.noNewStreams = true;
+                    evictedConnections.add(connection);
+                    i.remove();
+                }
+            }
+        }
+
+        for (RealConnection connection : evictedConnections) {
+            closeQuietly(connection.socket());// 关闭socket
+        }
     }
-  }
 
-  /**
-   * Performs maintenance on this pool, evicting the connection that has been idle the longest if
-   * either it has exceeded the keep alive limit or the idle connections limit.
-   *
-   * <p>Returns the duration in nanos to sleep until the next scheduled call to this method. Returns
-   * -1 if no further cleanups are required.
-   */
-  long cleanup(long now) {
-    int inUseConnectionCount = 0;
-    int idleConnectionCount = 0;
-    RealConnection longestIdleConnection = null;
-    long longestIdleDurationNs = Long.MIN_VALUE;
+    /**
+     * Performs maintenance on this pool, evicting the connection that has been idle the longest if
+     * either it has exceeded the keep alive limit or the idle connections limit.
+     * <p>
+     * <p>Returns the duration in nanos to sleep until the next scheduled call to this method. Returns
+     * -1 if no further cleanups are required.
+     */
+    long cleanup(long now) {
+        int inUseConnectionCount = 0;
+        int idleConnectionCount = 0;
+        RealConnection longestIdleConnection = null;
+        long longestIdleDurationNs = Long.MIN_VALUE;
 
-    // Find either a connection to evict, or the time that the next eviction is due.
-    synchronized (this) {
-      for (Iterator<RealConnection> i = connections.iterator(); i.hasNext(); ) {
-        RealConnection connection = i.next();
+        // Find either a connection to evict, or the time that the next eviction is due.
+        synchronized (this) {
+            for (Iterator<RealConnection> i = connections.iterator(); i.hasNext(); ) {
+                RealConnection connection = i.next();
 
-        // If the connection is in use, keep searching.
-        if (pruneAndGetAllocationCount(connection, now) > 0) {
-          inUseConnectionCount++;
-          continue;
-        }
+                // If the connection is in use, keep searching.
+                if (pruneAndGetAllocationCount(connection, now) > 0) {// 查询此连接内部StreamAllocation的引用数量
+                    inUseConnectionCount++;
+                    continue;
+                }
 
-        idleConnectionCount++;
+                idleConnectionCount++;
 
-        // If the connection is ready to be evicted, we're done.
-        long idleDurationNs = now - connection.idleAtNanos;
-        if (idleDurationNs > longestIdleDurationNs) {
-          longestIdleDurationNs = idleDurationNs;
-          longestIdleConnection = connection;
-        }
-      }
+                // If the connection is ready to be evicted, we're done.
+                long idleDurationNs = now - connection.idleAtNanos;
+                if (idleDurationNs > longestIdleDurationNs) {// 存储离到期时间最近的那个时间以及链接
+                    longestIdleDurationNs = idleDurationNs;
+                    longestIdleConnection = connection;
+                }
+            }
 
-      if (longestIdleDurationNs >= this.keepAliveDurationNs
-          || idleConnectionCount > this.maxIdleConnections) {
-        // We've found a connection to evict. Remove it from the list, then close it below (outside
-        // of the synchronized block).
-        connections.remove(longestIdleConnection);
-      } else if (idleConnectionCount > 0) {
-        // A connection will be ready to evict soon.
-        return keepAliveDurationNs - longestIdleDurationNs;
-      } else if (inUseConnectionCount > 0) {
-        // All connections are in use. It'll be at least the keep alive duration 'til we run again.
-        return keepAliveDurationNs;
-      } else {
-        // No connections, idle or in use.
-        cleanupRunning = false;
-        return -1;
-      }
-    }
+            if (longestIdleDurationNs >= this.keepAliveDurationNs
+                    || idleConnectionCount > this.maxIdleConnections) {
+                // We've found a connection to evict. Remove it from the list, then close it below (outside
+                // of the synchronized block). 空闲链接大于5，且超过5分钟，移除
+                connections.remove(longestIdleConnection);
+            } else if (idleConnectionCount > 0) {
+                // A connection will be ready to evict soon.
+                //返回此连接最快即将到期的时间，供下次清理
+                return keepAliveDurationNs - longestIdleDurationNs;
+            } else if (inUseConnectionCount > 0) {
+                // All connections are in use. It'll be at least the keep alive duration 'til we run again.
+                //全部都是活跃的连接，5分钟后再次清理
+                return keepAliveDurationNs;
+            } else {
+                // No connections, idle or in use.
+                //没有任何连接，跳出循环
+                cleanupRunning = false;
+                return -1;
+            }
+        }
 
-    closeQuietly(longestIdleConnection.socket());
+        closeQuietly(longestIdleConnection.socket());// 关闭
 
-    // Cleanup again immediately.
-    return 0;
-  }
+        // Cleanup again immediately.
+        return 0;
+    }
 
-  /**
-   * Prunes any leaked allocations and then returns the number of remaining live allocations on
-   * {@code connection}. Allocations are leaked if the connection is tracking them but the
-   * application code has abandoned them. Leak detection is imprecise and relies on garbage
-   * collection.
-   */
-  private int pruneAndGetAllocationCount(RealConnection connection, long now) {
-    List<Reference<StreamAllocation>> references = connection.allocations;
-    for (int i = 0; i < references.size(); ) {
-      Reference<StreamAllocation> reference = references.get(i);
+    /**
+     * Prunes any leaked allocations and then returns the number of remaining live allocations on
+     * {@code connection}. Allocations are leaked if the connection is tracking them but the
+     * application code has abandoned them. Leak detection is imprecise and relies on garbage
+     * collection.
+     */
+    private int pruneAndGetAllocationCount(RealConnection connection, long now) {
+        List<Reference<StreamAllocation>> references = connection.allocations;
+        for (int i = 0; i < references.size(); ) {
+            Reference<StreamAllocation> reference = references.get(i);
 
-      if (reference.get() != null) {
-        i++;
-        continue;
-      }
+            if (reference.get() != null) {// 还在被引用着
+                i++;// 计数增加
+                continue;
+            }
 
-      // We've discovered a leaked allocation. This is an application bug.
-      StreamAllocation.StreamAllocationReference streamAllocRef =
-          (StreamAllocation.StreamAllocationReference) reference;
-      String message = "A connection to " + connection.route().address().url()
-          + " was leaked. Did you forget to close a response body?";
-      Platform.get().logCloseableLeak(message, streamAllocRef.callStackTrace);
+            // We've discovered a leaked allocation. This is an application bug.
+            StreamAllocation.StreamAllocationReference streamAllocRef =
+                    (StreamAllocation.StreamAllocationReference) reference;
+            String message = "A connection to " + connection.route().address().url()
+                    + " was leaked. Did you forget to close a response body?";
+            Platform.get().logCloseableLeak(message, streamAllocRef.callStackTrace);
+            // 移除引用
+            references.remove(i);
+            connection.noNewStreams = true;
 
-      references.remove(i);
-      connection.noNewStreams = true;
+            // If this was the last allocation, the connection is eligible for immediate eviction.
+            //如果所有分配的流均没了，则这个链接符合被移除的条件
+            if (references.isEmpty()) {
+                connection.idleAtNanos = now - keepAliveDurationNs;
+                return 0;
+            }
+        }
 
-      // If this was the last allocation, the connection is eligible for immediate eviction.
-      if (references.isEmpty()) {
-        connection.idleAtNanos = now - keepAliveDurationNs;
-        return 0;
-      }
+        return references.size();
     }
-
-    return references.size();
-  }
 }
diff --git a/okhttp/src/main/java/okhttp3/Dispatcher.java b/okhttp/src/main/java/okhttp3/Dispatcher.java
index d6f90bb3ac..9135d6725f 100644
--- a/okhttp/src/main/java/okhttp3/Dispatcher.java
+++ b/okhttp/src/main/java/okhttp3/Dispatcher.java
@@ -25,211 +25,240 @@
 import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
+
 import okhttp3.RealCall.AsyncCall;
 import okhttp3.internal.Util;
 
 /**
  * Policy on when async requests are executed.
- *
+ * <p>
  * <p>Each dispatcher uses an {@link ExecutorService} to run calls internally. If you supply your
  * own executor, it should be able to run {@linkplain #getMaxRequests the configured maximum} number
  * of calls concurrently.
+ * 请求分发器
  */
 public final class Dispatcher {
-  private int maxRequests = 64;
-  private int maxRequestsPerHost = 5;
-  private Runnable idleCallback;
-
-  /** Executes calls. Created lazily. */
-  private ExecutorService executorService;
-
-  /** Ready async calls in the order they'll be run. */
-  private final Deque<AsyncCall> readyAsyncCalls = new ArrayDeque<>();
-
-  /** Running asynchronous calls. Includes canceled calls that haven't finished yet. */
-  private final Deque<AsyncCall> runningAsyncCalls = new ArrayDeque<>();
-
-  /** Running synchronous calls. Includes canceled calls that haven't finished yet. */
-  private final Deque<RealCall> runningSyncCalls = new ArrayDeque<>();
-
-  public Dispatcher(ExecutorService executorService) {
-    this.executorService = executorService;
-  }
-
-  public Dispatcher() {
-  }
-
-  public synchronized ExecutorService executorService() {
-    if (executorService == null) {
-      executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,
-          new SynchronousQueue<Runnable>(), Util.threadFactory("OkHttp Dispatcher", false));
-    }
-    return executorService;
-  }
-
-  /**
-   * Set the maximum number of requests to execute concurrently. Above this requests queue in
-   * memory, waiting for the running calls to complete.
-   *
-   * <p>If more than {@code maxRequests} requests are in flight when this is invoked, those requests
-   * will remain in flight.
-   */
-  public synchronized void setMaxRequests(int maxRequests) {
-    if (maxRequests < 1) {
-      throw new IllegalArgumentException("max < 1: " + maxRequests);
-    }
-    this.maxRequests = maxRequests;
-    promoteCalls();
-  }
-
-  public synchronized int getMaxRequests() {
-    return maxRequests;
-  }
-
-  /**
-   * Set the maximum number of requests for each host to execute concurrently. This limits requests
-   * by the URL's host name. Note that concurrent requests to a single IP address may still exceed
-   * this limit: multiple hostnames may share an IP address or be routed through the same HTTP
-   * proxy.
-   *
-   * <p>If more than {@code maxRequestsPerHost} requests are in flight when this is invoked, those
-   * requests will remain in flight.
-   */
-  public synchronized void setMaxRequestsPerHost(int maxRequestsPerHost) {
-    if (maxRequestsPerHost < 1) {
-      throw new IllegalArgumentException("max < 1: " + maxRequestsPerHost);
-    }
-    this.maxRequestsPerHost = maxRequestsPerHost;
-    promoteCalls();
-  }
-
-  public synchronized int getMaxRequestsPerHost() {
-    return maxRequestsPerHost;
-  }
-
-  /**
-   * Set a callback to be invoked each time the dispatcher becomes idle (when the number of running
-   * calls returns to zero).
-   *
-   * <p>Note: The time at which a {@linkplain Call call} is considered idle is different depending
-   * on whether it was run {@linkplain Call#enqueue(Callback) asynchronously} or
-   * {@linkplain Call#execute() synchronously}. Asynchronous calls become idle after the
-   * {@link Callback#onResponse onResponse} or {@link Callback#onFailure onFailure} callback has
-   * returned. Synchronous calls become idle once {@link Call#execute() execute()} returns. This
-   * means that if you are doing synchronous calls the network layer will not truly be idle until
-   * every returned {@link Response} has been closed.
-   */
-  public synchronized void setIdleCallback(Runnable idleCallback) {
-    this.idleCallback = idleCallback;
-  }
-
-  synchronized void enqueue(AsyncCall call) {
-    if (runningAsyncCalls.size() < maxRequests && runningCallsForHost(call) < maxRequestsPerHost) {
-      runningAsyncCalls.add(call);
-      executorService().execute(call);
-    } else {
-      readyAsyncCalls.add(call);
-    }
-  }
-
-  /**
-   * Cancel all calls currently enqueued or executing. Includes calls executed both {@linkplain
-   * Call#execute() synchronously} and {@linkplain Call#enqueue asynchronously}.
-   */
-  public synchronized void cancelAll() {
-    for (AsyncCall call : readyAsyncCalls) {
-      call.get().cancel();
-    }
-
-    for (AsyncCall call : runningAsyncCalls) {
-      call.get().cancel();
-    }
-
-    for (RealCall call : runningSyncCalls) {
-      call.cancel();
-    }
-  }
-
-  private void promoteCalls() {
-    if (runningAsyncCalls.size() >= maxRequests) return; // Already running max capacity.
-    if (readyAsyncCalls.isEmpty()) return; // No ready calls to promote.
-
-    for (Iterator<AsyncCall> i = readyAsyncCalls.iterator(); i.hasNext(); ) {
-      AsyncCall call = i.next();
-
-      if (runningCallsForHost(call) < maxRequestsPerHost) {
-        i.remove();
-        runningAsyncCalls.add(call);
-        executorService().execute(call);
-      }
-
-      if (runningAsyncCalls.size() >= maxRequests) return; // Reached max capacity.
-    }
-  }
-
-  /** Returns the number of running calls that share a host with {@code call}. */
-  private int runningCallsForHost(AsyncCall call) {
-    int result = 0;
-    for (AsyncCall c : runningAsyncCalls) {
-      if (c.host().equals(call.host())) result++;
-    }
-    return result;
-  }
-
-  /** Used by {@code Call#execute} to signal it is in-flight. */
-  synchronized void executed(RealCall call) {
-    runningSyncCalls.add(call);
-  }
-
-  /** Used by {@code AsyncCall#run} to signal completion. */
-  void finished(AsyncCall call) {
-    finished(runningAsyncCalls, call, true);
-  }
-
-  /** Used by {@code Call#execute} to signal completion. */
-  void finished(RealCall call) {
-    finished(runningSyncCalls, call, false);
-  }
-
-  private <T> void finished(Deque<T> calls, T call, boolean promoteCalls) {
-    int runningCallsCount;
-    Runnable idleCallback;
-    synchronized (this) {
-      if (!calls.remove(call)) throw new AssertionError("Call wasn't in-flight!");
-      if (promoteCalls) promoteCalls();
-      runningCallsCount = runningCallsCount();
-      idleCallback = this.idleCallback;
-    }
-
-    if (runningCallsCount == 0 && idleCallback != null) {
-      idleCallback.run();
-    }
-  }
-
-  /** Returns a snapshot of the calls currently awaiting execution. */
-  public synchronized List<Call> queuedCalls() {
-    List<Call> result = new ArrayList<>();
-    for (AsyncCall asyncCall : readyAsyncCalls) {
-      result.add(asyncCall.get());
-    }
-    return Collections.unmodifiableList(result);
-  }
-
-  /** Returns a snapshot of the calls currently being executed. */
-  public synchronized List<Call> runningCalls() {
-    List<Call> result = new ArrayList<>();
-    result.addAll(runningSyncCalls);
-    for (AsyncCall asyncCall : runningAsyncCalls) {
-      result.add(asyncCall.get());
+    private int maxRequests = 64;// 最大请求数量
+    private int maxRequestsPerHost = 5;// 每个host的最大请求数
+    private Runnable idleCallback;
+
+    /**
+     * Executes calls. Created lazily.
+     * 懒加载的线程池
+     */
+    private ExecutorService executorService;
+
+    /**
+     * Ready async calls in the order they'll be run. 已经准备好的异步请求
+     */
+    private final Deque<AsyncCall> readyAsyncCalls = new ArrayDeque<>();
+
+    /**
+     * Running asynchronous calls. Includes canceled calls that haven't finished yet.
+     * 正在执行的异步请求，包含已经取消但还未完成的请求
+     */
+    private final Deque<AsyncCall> runningAsyncCalls = new ArrayDeque<>();
+
+    /**
+     * Running synchronous calls. Includes canceled calls that haven't finished yet.
+     * 正在执行的同步请求，包含已经取消但还未完成的请求
+     */
+    private final Deque<RealCall> runningSyncCalls = new ArrayDeque<>();
+
+    public Dispatcher(ExecutorService executorService) {
+        this.executorService = executorService;
+    }
+
+    public Dispatcher() {
+    }
+
+    public synchronized ExecutorService executorService() {
+        if (executorService == null) {// 0核心，最大值的线程数量，60s存活
+            executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,
+                    new SynchronousQueue<Runnable>(), Util.threadFactory("OkHttp Dispatcher", false));
+        }
+        return executorService;
+    }
+
+    /**
+     * Set the maximum number of requests to execute concurrently. Above this requests queue in
+     * memory, waiting for the running calls to complete.
+     * <p>
+     * <p>If more than {@code maxRequests} requests are in flight when this is invoked, those requests
+     * will remain in flight.
+     */
+    public synchronized void setMaxRequests(int maxRequests) {
+        if (maxRequests < 1) {
+            throw new IllegalArgumentException("max < 1: " + maxRequests);
+        }
+        this.maxRequests = maxRequests;
+        promoteCalls();
+    }
+
+    public synchronized int getMaxRequests() {
+        return maxRequests;
+    }
+
+    /**
+     * Set the maximum number of requests for each host to execute concurrently. This limits requests
+     * by the URL's host name. Note that concurrent requests to a single IP address may still exceed
+     * this limit: multiple hostnames may share an IP address or be routed through the same HTTP
+     * proxy.
+     * <p>
+     * <p>If more than {@code maxRequestsPerHost} requests are in flight when this is invoked, those
+     * requests will remain in flight.
+     */
+    public synchronized void setMaxRequestsPerHost(int maxRequestsPerHost) {
+        if (maxRequestsPerHost < 1) {
+            throw new IllegalArgumentException("max < 1: " + maxRequestsPerHost);
+        }
+        this.maxRequestsPerHost = maxRequestsPerHost;
+        promoteCalls();
+    }
+
+    public synchronized int getMaxRequestsPerHost() {
+        return maxRequestsPerHost;
+    }
+
+    /**
+     * Set a callback to be invoked each time the dispatcher becomes idle (when the number of running
+     * calls returns to zero).
+     * <p>
+     * <p>Note: The time at which a {@linkplain Call call} is considered idle is different depending
+     * on whether it was run {@linkplain Call#enqueue(Callback) asynchronously} or
+     * {@linkplain Call#execute() synchronously}. Asynchronous calls become idle after the
+     * {@link Callback#onResponse onResponse} or {@link Callback#onFailure onFailure} callback has
+     * returned. Synchronous calls become idle once {@link Call#execute() execute()} returns. This
+     * means that if you are doing synchronous calls the network layer will not truly be idle until
+     * every returned {@link Response} has been closed.
+     */
+    public synchronized void setIdleCallback(Runnable idleCallback) {
+        this.idleCallback = idleCallback;
+    }
+
+    synchronized void enqueue(AsyncCall call) {// 分情况加入 正在执行请求/准备好要执行 的队列
+        if (runningAsyncCalls.size() < maxRequests && runningCallsForHost(call) < maxRequestsPerHost) {
+            runningAsyncCalls.add(call);
+            executorService().execute(call);
+        } else {
+            readyAsyncCalls.add(call);
+        }
+    }
+
+    /**
+     * Cancel all calls currently enqueued or executing. Includes calls executed both {@linkplain
+     * Call#execute() synchronously} and {@linkplain Call#enqueue asynchronously}.
+     */
+    public synchronized void cancelAll() {
+        for (AsyncCall call : readyAsyncCalls) {
+            call.get().cancel();
+        }
+
+        for (AsyncCall call : runningAsyncCalls) {
+            call.get().cancel();
+        }
+
+        for (RealCall call : runningSyncCalls) {
+            call.cancel();
+        }
+    }
+
+    private void promoteCalls() {// 继续执行异步请求
+        if (runningAsyncCalls.size() >= maxRequests) return; // Already running max capacity.
+        if (readyAsyncCalls.isEmpty()) return; // No ready calls to promote.
+
+        for (Iterator<AsyncCall> i = readyAsyncCalls.iterator(); i.hasNext(); ) {
+            AsyncCall call = i.next();
+            // 检查该请求对应的host当前的请求数量
+            if (runningCallsForHost(call) < maxRequestsPerHost) {
+                i.remove();
+                runningAsyncCalls.add(call);
+                executorService().execute(call);
+            }
+
+            if (runningAsyncCalls.size() >= maxRequests) return; // Reached max capacity.
+        }
+    }
+
+    /**
+     * Returns the number of running calls that share a host with {@code call}.
+     * 返回正在执行的同一个host的请求数量
+     */
+    private int runningCallsForHost(AsyncCall call) {
+        int result = 0;
+        for (AsyncCall c : runningAsyncCalls) {
+            if (c.host().equals(call.host())) result++;
+        }
+        return result;
     }
-    return Collections.unmodifiableList(result);
-  }
 
-  public synchronized int queuedCallsCount() {
-    return readyAsyncCalls.size();
-  }
+    /**
+     * Used by {@code Call#execute} to signal it is in-flight.
+     * 同步的直接添加至正在运行的队列，不像异步那样需要检查
+     */
+    synchronized void executed(RealCall call) {
+        runningSyncCalls.add(call);
+    }
+
+    /**
+     * Used by {@code AsyncCall#run} to signal completion.
+     */
+    void finished(AsyncCall call) {
+        finished(runningAsyncCalls, call, true);
+    }
+
+    /**
+     * Used by {@code Call#execute} to signal completion.
+     */
+    void finished(RealCall call) {
+        finished(runningSyncCalls, call, false);
+    }
 
-  public synchronized int runningCallsCount() {
-    return runningAsyncCalls.size() + runningSyncCalls.size();
-  }
+    private <T> void finished(Deque<T> calls, T call, boolean promoteCalls) {
+        int runningCallsCount;
+        Runnable idleCallback;
+        synchronized (this) {
+            if (!calls.remove(call)) throw new AssertionError("Call wasn't in-flight!");
+            if (promoteCalls) promoteCalls();// 异步需要，同步的不需要
+            runningCallsCount = runningCallsCount();
+            idleCallback = this.idleCallback;
+        }
+
+        if (runningCallsCount == 0 && idleCallback != null) {
+            idleCallback.run();// 空闲请求的回调
+        }
+    }
+
+    /**
+     * Returns a snapshot of the calls currently awaiting execution.
+     * 返回当前正在等待的异步请求。不可编辑
+     */
+    public synchronized List<Call> queuedCalls() {
+        List<Call> result = new ArrayList<>();
+        for (AsyncCall asyncCall : readyAsyncCalls) {
+            result.add(asyncCall.get());
+        }
+        return Collections.unmodifiableList(result);
+    }
+
+    /**
+     * Returns a snapshot of the calls currently being executed.
+     * 返回当前正在运行的同步+异步的请求集合
+     */
+    public synchronized List<Call> runningCalls() {
+        List<Call> result = new ArrayList<>();
+        result.addAll(runningSyncCalls);
+        for (AsyncCall asyncCall : runningAsyncCalls) {
+            result.add(asyncCall.get());
+        }
+        return Collections.unmodifiableList(result);
+    }
+
+    public synchronized int queuedCallsCount() {
+        return readyAsyncCalls.size();
+    }
+
+    public synchronized int runningCallsCount() {// 正在执行的请求数量 包含同步和异步
+        return runningAsyncCalls.size() + runningSyncCalls.size();
+    }
 }
diff --git a/okhttp/src/main/java/okhttp3/OkHttpClient.java b/okhttp/src/main/java/okhttp3/OkHttpClient.java
index e9a636d179..ebdfa5f911 100644
--- a/okhttp/src/main/java/okhttp3/OkHttpClient.java
+++ b/okhttp/src/main/java/okhttp3/OkHttpClient.java
@@ -37,6 +37,7 @@
 import javax.net.ssl.TrustManager;
 import javax.net.ssl.TrustManagerFactory;
 import javax.net.ssl.X509TrustManager;
+
 import okhttp3.internal.Internal;
 import okhttp3.internal.Util;
 import okhttp3.internal.cache.InternalCache;
@@ -51,21 +52,21 @@
 /**
  * Factory for {@linkplain Call calls}, which can be used to send HTTP requests and read their
  * responses.
- *
+ * <p>
  * <h3>OkHttpClients should be shared</h3>
- *
+ * <p>
  * <p>OkHttp performs best when you create a single {@code OkHttpClient} instance and reuse it for
  * all of your HTTP calls. This is because each client holds its own connection pool and thread
  * pools. Reusing connections and threads reduces latency and saves memory. Conversely, creating a
  * client for each request wastes resources on idle pools.
- *
+ * <p>
  * <p>Use {@code new OkHttpClient()} to create a shared instance with the default settings:
  * <pre>   {@code
  *
  *   // The singleton HTTP client.
  *   public final OkHttpClient client = new OkHttpClient();
  * }</pre>
- *
+ * <p>
  * <p>Or use {@code new OkHttpClient.Builder()} to create a shared instance with custom settings:
  * <pre>   {@code
  *
@@ -75,807 +76,836 @@
  *       .cache(new Cache(cacheDir, cacheSize))
  *       .build();
  * }</pre>
- *
+ * <p>
  * <h3>Customize your client with newBuilder()</h3>
- *
+ * <p>
  * <p>You can customize a shared OkHttpClient instance with {@link #newBuilder()}. This builds a
  * client that shares the same connection pool, thread pools, and configuration. Use the builder
  * methods to configure the derived client for a specific purpose.
- *
+ * <p>
  * <p>This example shows a call with a short 500 millisecond timeout: <pre>   {@code
- *
+ * <p>
  *   OkHttpClient eagerClient = client.newBuilder()
  *       .readTimeout(500, TimeUnit.MILLISECONDS)
  *       .build();
  *   Response response = eagerClient.newCall(request).execute();
  * }</pre>
- *
+ * <p>
  * <h3>Shutdown isn't necessary</h3>
- *
+ * <p>
  * <p>The threads and connections that are held will be released automatically if they remain idle.
  * But if you are writing a application that needs to aggressively release unused resources you may
  * do so.
- *
+ * <p>
  * <p>Shutdown the dispatcher's executor service with {@link ExecutorService#shutdown shutdown()}.
  * This will also cause future calls to the client to be rejected. <pre>   {@code
- *
+ * <p>
  *     client.dispatcher().executorService().shutdown();
  * }</pre>
- *
+ * <p>
  * <p>Clear the connection pool with {@link ConnectionPool#evictAll() evictAll()}. Note that the
  * connection pool's daemon thread may not exit immediately. <pre>   {@code
- *
+ * <p>
  *     client.connectionPool().evictAll();
  * }</pre>
- *
+ * <p>
  * <p>If your client has a cache, call {@link Cache#close close()}. Note that it is an error to
  * create calls against a cache that is closed, and doing so will cause the call to crash.
  * <pre>   {@code
  *
  *     client.cache().close();
  * }</pre>
- *
+ * <p>
  * <p>OkHttp also uses daemon threads for HTTP/2 connections. These will exit automatically if they
  * remain idle.
  */
 public class OkHttpClient implements Cloneable, Call.Factory, WebSocket.Factory {
-  static final List<Protocol> DEFAULT_PROTOCOLS = Util.immutableList(
-      Protocol.HTTP_2, Protocol.HTTP_1_1);
-
-  static final List<ConnectionSpec> DEFAULT_CONNECTION_SPECS = Util.immutableList(
-      ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS, ConnectionSpec.CLEARTEXT);
-
-  static {
-    Internal.instance = new Internal() {
-      @Override public void addLenient(Headers.Builder builder, String line) {
-        builder.addLenient(line);
-      }
-
-      @Override public void addLenient(Headers.Builder builder, String name, String value) {
-        builder.addLenient(name, value);
-      }
-
-      @Override public void setCache(OkHttpClient.Builder builder, InternalCache internalCache) {
-        builder.setInternalCache(internalCache);
-      }
-
-      @Override public boolean connectionBecameIdle(
-          ConnectionPool pool, RealConnection connection) {
-        return pool.connectionBecameIdle(connection);
-      }
-
-      @Override public RealConnection get(
-          ConnectionPool pool, Address address, StreamAllocation streamAllocation) {
-        return pool.get(address, streamAllocation);
-      }
-
-      @Override public Socket deduplicate(
-          ConnectionPool pool, Address address, StreamAllocation streamAllocation) {
-        return pool.deduplicate(address, streamAllocation);
-      }
-
-      @Override public void put(ConnectionPool pool, RealConnection connection) {
-        pool.put(connection);
-      }
-
-      @Override public RouteDatabase routeDatabase(ConnectionPool connectionPool) {
-        return connectionPool.routeDatabase;
-      }
-
-      @Override public int code(Response.Builder responseBuilder) {
-        return responseBuilder.code;
-      }
-
-      @Override
-      public void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket, boolean isFallback) {
-        tlsConfiguration.apply(sslSocket, isFallback);
-      }
-
-      @Override public HttpUrl getHttpUrlChecked(String url)
-          throws MalformedURLException, UnknownHostException {
-        return HttpUrl.getChecked(url);
-      }
-
-      @Override public StreamAllocation streamAllocation(Call call) {
-        return ((RealCall) call).streamAllocation();
-      }
-
-      @Override public Call newWebSocketCall(OkHttpClient client, Request originalRequest) {
-        return new RealCall(client, originalRequest, true);
-      }
-    };
-  }
-
-  final Dispatcher dispatcher;
-  final Proxy proxy;
-  final List<Protocol> protocols;
-  final List<ConnectionSpec> connectionSpecs;
-  final List<Interceptor> interceptors;
-  final List<Interceptor> networkInterceptors;
-  final ProxySelector proxySelector;
-  final CookieJar cookieJar;
-  final Cache cache;
-  final InternalCache internalCache;
-  final SocketFactory socketFactory;
-  final SSLSocketFactory sslSocketFactory;
-  final CertificateChainCleaner certificateChainCleaner;
-  final HostnameVerifier hostnameVerifier;
-  final CertificatePinner certificatePinner;
-  final Authenticator proxyAuthenticator;
-  final Authenticator authenticator;
-  final ConnectionPool connectionPool;
-  final Dns dns;
-  final boolean followSslRedirects;
-  final boolean followRedirects;
-  final boolean retryOnConnectionFailure;
-  final int connectTimeout;
-  final int readTimeout;
-  final int writeTimeout;
-  final int pingInterval;
-
-  public OkHttpClient() {
-    this(new Builder());
-  }
-
-  OkHttpClient(Builder builder) {
-    this.dispatcher = builder.dispatcher;
-    this.proxy = builder.proxy;
-    this.protocols = builder.protocols;
-    this.connectionSpecs = builder.connectionSpecs;
-    this.interceptors = Util.immutableList(builder.interceptors);
-    this.networkInterceptors = Util.immutableList(builder.networkInterceptors);
-    this.proxySelector = builder.proxySelector;
-    this.cookieJar = builder.cookieJar;
-    this.cache = builder.cache;
-    this.internalCache = builder.internalCache;
-    this.socketFactory = builder.socketFactory;
-
-    boolean isTLS = false;
-    for (ConnectionSpec spec : connectionSpecs) {
-      isTLS = isTLS || spec.isTls();
-    }
-
-    if (builder.sslSocketFactory != null || !isTLS) {
-      this.sslSocketFactory = builder.sslSocketFactory;
-      this.certificateChainCleaner = builder.certificateChainCleaner;
-    } else {
-      X509TrustManager trustManager = systemDefaultTrustManager();
-      this.sslSocketFactory = systemDefaultSslSocketFactory(trustManager);
-      this.certificateChainCleaner = CertificateChainCleaner.get(trustManager);
-    }
-
-    this.hostnameVerifier = builder.hostnameVerifier;
-    this.certificatePinner = builder.certificatePinner.withCertificateChainCleaner(
-        certificateChainCleaner);
-    this.proxyAuthenticator = builder.proxyAuthenticator;
-    this.authenticator = builder.authenticator;
-    this.connectionPool = builder.connectionPool;
-    this.dns = builder.dns;
-    this.followSslRedirects = builder.followSslRedirects;
-    this.followRedirects = builder.followRedirects;
-    this.retryOnConnectionFailure = builder.retryOnConnectionFailure;
-    this.connectTimeout = builder.connectTimeout;
-    this.readTimeout = builder.readTimeout;
-    this.writeTimeout = builder.writeTimeout;
-    this.pingInterval = builder.pingInterval;
-  }
-
-  private X509TrustManager systemDefaultTrustManager() {
-    try {
-      TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
-          TrustManagerFactory.getDefaultAlgorithm());
-      trustManagerFactory.init((KeyStore) null);
-      TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
-      if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {
-        throw new IllegalStateException("Unexpected default trust managers:"
-            + Arrays.toString(trustManagers));
-      }
-      return (X509TrustManager) trustManagers[0];
-    } catch (GeneralSecurityException e) {
-      throw new AssertionError(); // The system has no TLS. Just give up.
-    }
-  }
-
-  private SSLSocketFactory systemDefaultSslSocketFactory(X509TrustManager trustManager) {
-    try {
-      SSLContext sslContext = SSLContext.getInstance("TLS");
-      sslContext.init(null, new TrustManager[] { trustManager }, null);
-      return sslContext.getSocketFactory();
-    } catch (GeneralSecurityException e) {
-      throw new AssertionError(); // The system has no TLS. Just give up.
-    }
-  }
-
-  /** Default connect timeout (in milliseconds). */
-  public int connectTimeoutMillis() {
-    return connectTimeout;
-  }
-
-  /** Default read timeout (in milliseconds). */
-  public int readTimeoutMillis() {
-    return readTimeout;
-  }
-
-  /** Default write timeout (in milliseconds). */
-  public int writeTimeoutMillis() {
-    return writeTimeout;
-  }
-
-  /** Web socket ping interval (in milliseconds). */
-  public int pingIntervalMillis() {
-    return pingInterval;
-  }
-
-  public Proxy proxy() {
-    return proxy;
-  }
-
-  public ProxySelector proxySelector() {
-    return proxySelector;
-  }
-
-  public CookieJar cookieJar() {
-    return cookieJar;
-  }
-
-  public Cache cache() {
-    return cache;
-  }
-
-  InternalCache internalCache() {
-    return cache != null ? cache.internalCache : internalCache;
-  }
-
-  public Dns dns() {
-    return dns;
-  }
-
-  public SocketFactory socketFactory() {
-    return socketFactory;
-  }
-
-  public SSLSocketFactory sslSocketFactory() {
-    return sslSocketFactory;
-  }
-
-  public HostnameVerifier hostnameVerifier() {
-    return hostnameVerifier;
-  }
-
-  public CertificatePinner certificatePinner() {
-    return certificatePinner;
-  }
-
-  public Authenticator authenticator() {
-    return authenticator;
-  }
-
-  public Authenticator proxyAuthenticator() {
-    return proxyAuthenticator;
-  }
-
-  public ConnectionPool connectionPool() {
-    return connectionPool;
-  }
-
-  public boolean followSslRedirects() {
-    return followSslRedirects;
-  }
-
-  public boolean followRedirects() {
-    return followRedirects;
-  }
-
-  public boolean retryOnConnectionFailure() {
-    return retryOnConnectionFailure;
-  }
-
-  public Dispatcher dispatcher() {
-    return dispatcher;
-  }
-
-  public List<Protocol> protocols() {
-    return protocols;
-  }
-
-  public List<ConnectionSpec> connectionSpecs() {
-    return connectionSpecs;
-  }
-
-  /**
-   * Returns an immutable list of interceptors that observe the full span of each call: from before
-   * the connection is established (if any) until after the response source is selected (either the
-   * origin server, cache, or both).
-   */
-  public List<Interceptor> interceptors() {
-    return interceptors;
-  }
-
-  /**
-   * Returns an immutable list of interceptors that observe a single network request and response.
-   * These interceptors must call {@link Interceptor.Chain#proceed} exactly once: it is an error for
-   * a network interceptor to short-circuit or repeat a network request.
-   */
-  public List<Interceptor> networkInterceptors() {
-    return networkInterceptors;
-  }
-
-  /**
-   * Prepares the {@code request} to be executed at some point in the future.
-   */
-  @Override public Call newCall(Request request) {
-    return new RealCall(this, request, false /* for web socket */);
-  }
-
-  /**
-   * Uses {@code request} to connect a new web socket.
-   */
-  @Override public WebSocket newWebSocket(Request request, WebSocketListener listener) {
-    RealWebSocket webSocket = new RealWebSocket(request, listener, new SecureRandom());
-    webSocket.connect(this);
-    return webSocket;
-  }
-
-  public Builder newBuilder() {
-    return new Builder(this);
-  }
-
-  public static final class Builder {
-    Dispatcher dispatcher;
-    Proxy proxy;
-    List<Protocol> protocols;
-    List<ConnectionSpec> connectionSpecs;
-    final List<Interceptor> interceptors = new ArrayList<>();
-    final List<Interceptor> networkInterceptors = new ArrayList<>();
-    ProxySelector proxySelector;
-    CookieJar cookieJar;
-    Cache cache;
-    InternalCache internalCache;
-    SocketFactory socketFactory;
-    SSLSocketFactory sslSocketFactory;
-    CertificateChainCleaner certificateChainCleaner;
-    HostnameVerifier hostnameVerifier;
-    CertificatePinner certificatePinner;
-    Authenticator proxyAuthenticator;
-    Authenticator authenticator;
-    ConnectionPool connectionPool;
-    Dns dns;
-    boolean followSslRedirects;
-    boolean followRedirects;
-    boolean retryOnConnectionFailure;
-    int connectTimeout;
-    int readTimeout;
-    int writeTimeout;
-    int pingInterval;
-
-    public Builder() {
-      dispatcher = new Dispatcher();
-      protocols = DEFAULT_PROTOCOLS;
-      connectionSpecs = DEFAULT_CONNECTION_SPECS;
-      proxySelector = ProxySelector.getDefault();
-      cookieJar = CookieJar.NO_COOKIES;
-      socketFactory = SocketFactory.getDefault();
-      hostnameVerifier = OkHostnameVerifier.INSTANCE;
-      certificatePinner = CertificatePinner.DEFAULT;
-      proxyAuthenticator = Authenticator.NONE;
-      authenticator = Authenticator.NONE;
-      connectionPool = new ConnectionPool();
-      dns = Dns.SYSTEM;
-      followSslRedirects = true;
-      followRedirects = true;
-      retryOnConnectionFailure = true;
-      connectTimeout = 10_000;
-      readTimeout = 10_000;
-      writeTimeout = 10_000;
-      pingInterval = 0;
-    }
-
-    Builder(OkHttpClient okHttpClient) {
-      this.dispatcher = okHttpClient.dispatcher;
-      this.proxy = okHttpClient.proxy;
-      this.protocols = okHttpClient.protocols;
-      this.connectionSpecs = okHttpClient.connectionSpecs;
-      this.interceptors.addAll(okHttpClient.interceptors);
-      this.networkInterceptors.addAll(okHttpClient.networkInterceptors);
-      this.proxySelector = okHttpClient.proxySelector;
-      this.cookieJar = okHttpClient.cookieJar;
-      this.internalCache = okHttpClient.internalCache;
-      this.cache = okHttpClient.cache;
-      this.socketFactory = okHttpClient.socketFactory;
-      this.sslSocketFactory = okHttpClient.sslSocketFactory;
-      this.certificateChainCleaner = okHttpClient.certificateChainCleaner;
-      this.hostnameVerifier = okHttpClient.hostnameVerifier;
-      this.certificatePinner = okHttpClient.certificatePinner;
-      this.proxyAuthenticator = okHttpClient.proxyAuthenticator;
-      this.authenticator = okHttpClient.authenticator;
-      this.connectionPool = okHttpClient.connectionPool;
-      this.dns = okHttpClient.dns;
-      this.followSslRedirects = okHttpClient.followSslRedirects;
-      this.followRedirects = okHttpClient.followRedirects;
-      this.retryOnConnectionFailure = okHttpClient.retryOnConnectionFailure;
-      this.connectTimeout = okHttpClient.connectTimeout;
-      this.readTimeout = okHttpClient.readTimeout;
-      this.writeTimeout = okHttpClient.writeTimeout;
-      this.pingInterval = okHttpClient.pingInterval;
+    static final List<Protocol> DEFAULT_PROTOCOLS = Util.immutableList(
+            Protocol.HTTP_2, Protocol.HTTP_1_1);
+
+    static final List<ConnectionSpec> DEFAULT_CONNECTION_SPECS = Util.immutableList(
+            ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS, ConnectionSpec.CLEARTEXT);
+
+    static {
+        // 利用这个间接的解除了访问权限的问题。
+        Internal.instance = new Internal() {
+            @Override
+            public void addLenient(Headers.Builder builder, String line) {
+                builder.addLenient(line);
+            }
+
+            @Override
+            public void addLenient(Headers.Builder builder, String name, String value) {
+                builder.addLenient(name, value);
+            }
+
+            @Override
+            public void setCache(OkHttpClient.Builder builder, InternalCache internalCache) {
+                builder.setInternalCache(internalCache);
+            }
+
+            @Override
+            public boolean connectionBecameIdle(
+                    ConnectionPool pool, RealConnection connection) {
+                return pool.connectionBecameIdle(connection);
+            }
+
+            @Override
+            public RealConnection get(
+                    ConnectionPool pool, Address address, StreamAllocation streamAllocation) {
+                return pool.get(address, streamAllocation);
+            }
+
+            @Override
+            public Socket deduplicate(
+                    ConnectionPool pool, Address address, StreamAllocation streamAllocation) {
+                return pool.deduplicate(address, streamAllocation);
+            }
+
+            @Override
+            public void put(ConnectionPool pool, RealConnection connection) {
+                pool.put(connection);
+            }
+
+            @Override
+            public RouteDatabase routeDatabase(ConnectionPool connectionPool) {
+                return connectionPool.routeDatabase;
+            }
+
+            @Override
+            public int code(Response.Builder responseBuilder) {
+                return responseBuilder.code;
+            }
+
+            @Override
+            public void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket, boolean isFallback) {
+                tlsConfiguration.apply(sslSocket, isFallback);
+            }
+
+            @Override
+            public HttpUrl getHttpUrlChecked(String url)
+                    throws MalformedURLException, UnknownHostException {
+                return HttpUrl.getChecked(url);
+            }
+
+            @Override
+            public StreamAllocation streamAllocation(Call call) {
+                return ((RealCall) call).streamAllocation();
+            }
+
+            @Override
+            public Call newWebSocketCall(OkHttpClient client, Request originalRequest) {
+                return new RealCall(client, originalRequest, true);
+            }
+        };
+    }
+
+    final Dispatcher dispatcher;// OkHttpClient初始化的时候new了一个
+    final Proxy proxy;
+    final List<Protocol> protocols;
+    final List<ConnectionSpec> connectionSpecs;
+    final List<Interceptor> interceptors;
+    final List<Interceptor> networkInterceptors;
+    final ProxySelector proxySelector;
+    final CookieJar cookieJar;
+    final Cache cache;
+    final InternalCache internalCache;
+    final SocketFactory socketFactory;// 使用默认的
+    final SSLSocketFactory sslSocketFactory;
+    final CertificateChainCleaner certificateChainCleaner;
+    final HostnameVerifier hostnameVerifier;
+    final CertificatePinner certificatePinner;
+    final Authenticator proxyAuthenticator;
+    final Authenticator authenticator;
+    final ConnectionPool connectionPool;// OkHttpClient初始化的时候new了一个
+    final Dns dns;
+    final boolean followSslRedirects;
+    final boolean followRedirects;
+    final boolean retryOnConnectionFailure;
+    final int connectTimeout;
+    final int readTimeout;
+    final int writeTimeout;
+    final int pingInterval;
+
+    public OkHttpClient() {
+        this(new Builder());
+    }
+
+    OkHttpClient(Builder builder) {
+        this.dispatcher = builder.dispatcher;
+        this.proxy = builder.proxy;
+        this.protocols = builder.protocols;
+        this.connectionSpecs = builder.connectionSpecs;
+        this.interceptors = Util.immutableList(builder.interceptors);
+        this.networkInterceptors = Util.immutableList(builder.networkInterceptors);
+        this.proxySelector = builder.proxySelector;
+        this.cookieJar = builder.cookieJar;
+        this.cache = builder.cache;
+        this.internalCache = builder.internalCache;
+        this.socketFactory = builder.socketFactory;
+
+        boolean isTLS = false;
+        for (ConnectionSpec spec : connectionSpecs) {
+            isTLS = isTLS || spec.isTls();
+        }
+
+        if (builder.sslSocketFactory != null || !isTLS) {
+            this.sslSocketFactory = builder.sslSocketFactory;
+            this.certificateChainCleaner = builder.certificateChainCleaner;
+        } else {
+            X509TrustManager trustManager = systemDefaultTrustManager();
+            this.sslSocketFactory = systemDefaultSslSocketFactory(trustManager);
+            this.certificateChainCleaner = CertificateChainCleaner.get(trustManager);
+        }
+
+        this.hostnameVerifier = builder.hostnameVerifier;
+        this.certificatePinner = builder.certificatePinner.withCertificateChainCleaner(
+                certificateChainCleaner);
+        this.proxyAuthenticator = builder.proxyAuthenticator;
+        this.authenticator = builder.authenticator;
+        this.connectionPool = builder.connectionPool;
+        this.dns = builder.dns;
+        this.followSslRedirects = builder.followSslRedirects;
+        this.followRedirects = builder.followRedirects;
+        this.retryOnConnectionFailure = builder.retryOnConnectionFailure;
+        this.connectTimeout = builder.connectTimeout;
+        this.readTimeout = builder.readTimeout;
+        this.writeTimeout = builder.writeTimeout;
+        this.pingInterval = builder.pingInterval;
+    }
+
+    private X509TrustManager systemDefaultTrustManager() {
+        try {
+            TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
+                    TrustManagerFactory.getDefaultAlgorithm());
+            trustManagerFactory.init((KeyStore) null);
+            TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
+            if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {
+                throw new IllegalStateException("Unexpected default trust managers:"
+                        + Arrays.toString(trustManagers));
+            }
+            return (X509TrustManager) trustManagers[0];
+        } catch (GeneralSecurityException e) {
+            throw new AssertionError(); // The system has no TLS. Just give up.
+        }
+    }
+
+    private SSLSocketFactory systemDefaultSslSocketFactory(X509TrustManager trustManager) {
+        try {
+            SSLContext sslContext = SSLContext.getInstance("TLS");
+            sslContext.init(null, new TrustManager[]{trustManager}, null);
+            return sslContext.getSocketFactory();
+        } catch (GeneralSecurityException e) {
+            throw new AssertionError(); // The system has no TLS. Just give up.
+        }
     }
 
     /**
-     * Sets the default connect timeout for new connections. A value of 0 means no timeout,
-     * otherwise values must be between 1 and {@link Integer#MAX_VALUE} when converted to
-     * milliseconds.
+     * Default connect timeout (in milliseconds).
      */
-    public Builder connectTimeout(long timeout, TimeUnit unit) {
-      connectTimeout = checkDuration("timeout", timeout, unit);
-      return this;
+    public int connectTimeoutMillis() {
+        return connectTimeout;
     }
 
     /**
-     * Sets the default read timeout for new connections. A value of 0 means no timeout, otherwise
-     * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
+     * Default read timeout (in milliseconds).
      */
-    public Builder readTimeout(long timeout, TimeUnit unit) {
-      readTimeout = checkDuration("timeout", timeout, unit);
-      return this;
+    public int readTimeoutMillis() {
+        return readTimeout;
     }
 
     /**
-     * Sets the default write timeout for new connections. A value of 0 means no timeout, otherwise
-     * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
+     * Default write timeout (in milliseconds).
      */
-    public Builder writeTimeout(long timeout, TimeUnit unit) {
-      writeTimeout = checkDuration("timeout", timeout, unit);
-      return this;
+    public int writeTimeoutMillis() {
+        return writeTimeout;
     }
 
     /**
-     * Sets the interval between web socket pings initiated by this client. Use this to
-     * automatically send web socket ping frames until either the web socket fails or it is closed.
-     * This keeps the connection alive and may detect connectivity failures early. No timeouts are
-     * enforced on the acknowledging pongs.
-     *
-     * <p>The default value of 0 disables client-initiated pings.
+     * Web socket ping interval (in milliseconds).
      */
-    public Builder pingInterval(long interval, TimeUnit unit) {
-      pingInterval = checkDuration("interval", interval, unit);
-      return this;
+    public int pingIntervalMillis() {
+        return pingInterval;
     }
 
-    private static int checkDuration(String name, long duration, TimeUnit unit) {
-      if (duration < 0) throw new IllegalArgumentException(name + " < 0");
-      if (unit == null) throw new NullPointerException("unit == null");
-      long millis = unit.toMillis(duration);
-      if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException(name + " too large.");
-      if (millis == 0 && duration > 0) throw new IllegalArgumentException(name + " too small.");
-      return (int) millis;
+    public Proxy proxy() {
+        return proxy;
     }
 
-    /**
-     * Sets the HTTP proxy that will be used by connections created by this client. This takes
-     * precedence over {@link #proxySelector}, which is only honored when this proxy is null (which
-     * it is by default). To disable proxy use completely, call {@code setProxy(Proxy.NO_PROXY)}.
-     */
-    public Builder proxy(Proxy proxy) {
-      this.proxy = proxy;
-      return this;
+    public ProxySelector proxySelector() {
+        return proxySelector;
     }
 
-    /**
-     * Sets the proxy selection policy to be used if no {@link #proxy proxy} is specified
-     * explicitly. The proxy selector may return multiple proxies; in that case they will be tried
-     * in sequence until a successful connection is established.
-     *
-     * <p>If unset, the {@link ProxySelector#getDefault() system-wide default} proxy selector will
-     * be used.
-     */
-    public Builder proxySelector(ProxySelector proxySelector) {
-      this.proxySelector = proxySelector;
-      return this;
+    public CookieJar cookieJar() {
+        return cookieJar;
     }
 
-    /**
-     * Sets the handler that can accept cookies from incoming HTTP responses and provides cookies to
-     * outgoing HTTP requests.
-     *
-     * <p>If unset, {@linkplain CookieJar#NO_COOKIES no cookies} will be accepted nor provided.
-     */
-    public Builder cookieJar(CookieJar cookieJar) {
-      if (cookieJar == null) throw new NullPointerException("cookieJar == null");
-      this.cookieJar = cookieJar;
-      return this;
+    public Cache cache() {
+        return cache;
     }
 
-    /** Sets the response cache to be used to read and write cached responses. */
-    void setInternalCache(InternalCache internalCache) {
-      this.internalCache = internalCache;
-      this.cache = null;
+    InternalCache internalCache() {
+        return cache != null ? cache.internalCache : internalCache;
     }
 
-    /** Sets the response cache to be used to read and write cached responses. */
-    public Builder cache(Cache cache) {
-      this.cache = cache;
-      this.internalCache = null;
-      return this;
-    }
-
-    /**
-     * Sets the DNS service used to lookup IP addresses for hostnames.
-     *
-     * <p>If unset, the {@link Dns#SYSTEM system-wide default} DNS will be used.
-     */
-    public Builder dns(Dns dns) {
-      if (dns == null) throw new NullPointerException("dns == null");
-      this.dns = dns;
-      return this;
-    }
-
-    /**
-     * Sets the socket factory used to create connections. OkHttp only uses the parameterless {@link
-     * SocketFactory#createSocket() createSocket()} method to create unconnected sockets. Overriding
-     * this method, e. g., allows the socket to be bound to a specific local address.
-     *
-     * <p>If unset, the {@link SocketFactory#getDefault() system-wide default} socket factory will
-     * be used.
-     */
-    public Builder socketFactory(SocketFactory socketFactory) {
-      if (socketFactory == null) throw new NullPointerException("socketFactory == null");
-      this.socketFactory = socketFactory;
-      return this;
+    public Dns dns() {
+        return dns;
     }
 
-    /**
-     * Sets the socket factory used to secure HTTPS connections. If unset, the system default will
-     * be used.
-     *
-     * @deprecated {@code SSLSocketFactory} does not expose its {@link X509TrustManager}, which is
-     *     a field that OkHttp needs to build a clean certificate chain. This method instead must
-     *     use reflection to extract the trust manager. Applications should prefer to call {@link
-     *     #sslSocketFactory(SSLSocketFactory, X509TrustManager)}, which avoids such reflection.
-     */
-    public Builder sslSocketFactory(SSLSocketFactory sslSocketFactory) {
-      if (sslSocketFactory == null) throw new NullPointerException("sslSocketFactory == null");
-      X509TrustManager trustManager = Platform.get().trustManager(sslSocketFactory);
-      if (trustManager == null) {
-        throw new IllegalStateException("Unable to extract the trust manager on " + Platform.get()
-            + ", sslSocketFactory is " + sslSocketFactory.getClass());
-      }
-      this.sslSocketFactory = sslSocketFactory;
-      this.certificateChainCleaner = CertificateChainCleaner.get(trustManager);
-      return this;
+    public SocketFactory socketFactory() {
+        return socketFactory;
     }
 
-    /**
-     * Sets the socket factory and trust manager used to secure HTTPS connections. If unset, the
-     * system defaults will be used.
-     *
-     * <p>Most applications should not call this method, and instead use the system defaults. Those
-     * classes include special optimizations that can be lost if the implementations are decorated.
-     *
-     * <p>If necessary, you can create and configure the defaults yourself with the following code:
-     *
-     * <pre>   {@code
-     *
-     *   TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
-     *       TrustManagerFactory.getDefaultAlgorithm());
-     *   trustManagerFactory.init((KeyStore) null);
-     *   TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
-     *   if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {
-     *     throw new IllegalStateException("Unexpected default trust managers:"
-     *         + Arrays.toString(trustManagers));
-     *   }
-     *   X509TrustManager trustManager = (X509TrustManager) trustManagers[0];
-     *
-     *   SSLContext sslContext = SSLContext.getInstance("TLS");
-     *   sslContext.init(null, new TrustManager[] { trustManager }, null);
-     *   SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();
-     *
-     *   OkHttpClient client = new OkHttpClient.Builder()
-     *       .sslSocketFactory(sslSocketFactory, trustManager);
-     *       .build();
-     * }</pre>
-     */
-    public Builder sslSocketFactory(
-        SSLSocketFactory sslSocketFactory, X509TrustManager trustManager) {
-      if (sslSocketFactory == null) throw new NullPointerException("sslSocketFactory == null");
-      if (trustManager == null) throw new NullPointerException("trustManager == null");
-      this.sslSocketFactory = sslSocketFactory;
-      this.certificateChainCleaner = CertificateChainCleaner.get(trustManager);
-      return this;
+    public SSLSocketFactory sslSocketFactory() {
+        return sslSocketFactory;
     }
 
-    /**
-     * Sets the verifier used to confirm that response certificates apply to requested hostnames for
-     * HTTPS connections.
-     *
-     * <p>If unset, a default hostname verifier will be used.
-     */
-    public Builder hostnameVerifier(HostnameVerifier hostnameVerifier) {
-      if (hostnameVerifier == null) throw new NullPointerException("hostnameVerifier == null");
-      this.hostnameVerifier = hostnameVerifier;
-      return this;
+    public HostnameVerifier hostnameVerifier() {
+        return hostnameVerifier;
     }
 
-    /**
-     * Sets the certificate pinner that constrains which certificates are trusted. By default HTTPS
-     * connections rely on only the {@link #sslSocketFactory SSL socket factory} to establish trust.
-     * Pinning certificates avoids the need to trust certificate authorities.
-     */
-    public Builder certificatePinner(CertificatePinner certificatePinner) {
-      if (certificatePinner == null) throw new NullPointerException("certificatePinner == null");
-      this.certificatePinner = certificatePinner;
-      return this;
+    public CertificatePinner certificatePinner() {
+        return certificatePinner;
     }
 
-    /**
-     * Sets the authenticator used to respond to challenges from origin servers. Use {@link
-     * #proxyAuthenticator} to set the authenticator for proxy servers.
-     *
-     * <p>If unset, the {@linkplain Authenticator#NONE no authentication will be attempted}.
-     */
-    public Builder authenticator(Authenticator authenticator) {
-      if (authenticator == null) throw new NullPointerException("authenticator == null");
-      this.authenticator = authenticator;
-      return this;
+    public Authenticator authenticator() {
+        return authenticator;
     }
 
-    /**
-     * Sets the authenticator used to respond to challenges from proxy servers. Use {@link
-     * #authenticator} to set the authenticator for origin servers.
-     *
-     * <p>If unset, the {@linkplain Authenticator#NONE no authentication will be attempted}.
-     */
-    public Builder proxyAuthenticator(Authenticator proxyAuthenticator) {
-      if (proxyAuthenticator == null) throw new NullPointerException("proxyAuthenticator == null");
-      this.proxyAuthenticator = proxyAuthenticator;
-      return this;
+    public Authenticator proxyAuthenticator() {
+        return proxyAuthenticator;
     }
 
-    /**
-     * Sets the connection pool used to recycle HTTP and HTTPS connections.
-     *
-     * <p>If unset, a new connection pool will be used.
-     */
-    public Builder connectionPool(ConnectionPool connectionPool) {
-      if (connectionPool == null) throw new NullPointerException("connectionPool == null");
-      this.connectionPool = connectionPool;
-      return this;
+    public ConnectionPool connectionPool() {
+        return connectionPool;
     }
 
-    /**
-     * Configure this client to follow redirects from HTTPS to HTTP and from HTTP to HTTPS.
-     *
-     * <p>If unset, protocol redirects will be followed. This is different than the built-in {@code
-     * HttpURLConnection}'s default.
-     */
-    public Builder followSslRedirects(boolean followProtocolRedirects) {
-      this.followSslRedirects = followProtocolRedirects;
-      return this;
+    public boolean followSslRedirects() {
+        return followSslRedirects;
     }
 
-    /** Configure this client to follow redirects. If unset, redirects will be followed. */
-    public Builder followRedirects(boolean followRedirects) {
-      this.followRedirects = followRedirects;
-      return this;
+    public boolean followRedirects() {
+        return followRedirects;
     }
 
-    /**
-     * Configure this client to retry or not when a connectivity problem is encountered. By default,
-     * this client silently recovers from the following problems:
-     *
-     * <ul>
-     *   <li><strong>Unreachable IP addresses.</strong> If the URL's host has multiple IP addresses,
-     *       failure to reach any individual IP address doesn't fail the overall request. This can
-     *       increase availability of multi-homed services.
-     *   <li><strong>Stale pooled connections.</strong> The {@link ConnectionPool} reuses sockets
-     *       to decrease request latency, but these connections will occasionally time out.
-     *   <li><strong>Unreachable proxy servers.</strong> A {@link ProxySelector} can be used to
-     *       attempt multiple proxy servers in sequence, eventually falling back to a direct
-     *       connection.
-     * </ul>
-     *
-     * Set this to false to avoid retrying requests when doing so is destructive. In this case the
-     * calling application should do its own recovery of connectivity failures.
-     */
-    public Builder retryOnConnectionFailure(boolean retryOnConnectionFailure) {
-      this.retryOnConnectionFailure = retryOnConnectionFailure;
-      return this;
+    public boolean retryOnConnectionFailure() {
+        return retryOnConnectionFailure;
     }
 
-    /**
-     * Sets the dispatcher used to set policy and execute asynchronous requests. Must not be null.
-     */
-    public Builder dispatcher(Dispatcher dispatcher) {
-      if (dispatcher == null) throw new IllegalArgumentException("dispatcher == null");
-      this.dispatcher = dispatcher;
-      return this;
+    public Dispatcher dispatcher() {
+        return dispatcher;
     }
 
-    /**
-     * Configure the protocols used by this client to communicate with remote servers. By default
-     * this client will prefer the most efficient transport available, falling back to more
-     * ubiquitous protocols. Applications should only call this method to avoid specific
-     * compatibility problems, such as web servers that behave incorrectly when HTTP/2 is enabled.
-     *
-     * <p>The following protocols are currently supported:
-     *
-     * <ul>
-     *     <li><a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html">http/1.1</a>
-     *     <li><a href="http://tools.ietf.org/html/draft-ietf-httpbis-http2-17">h2</a>
-     * </ul>
-     *
-     * <p><strong>This is an evolving set.</strong> Future releases include support for transitional
-     * protocols. The http/1.1 transport will never be dropped.
-     *
-     * <p>If multiple protocols are specified, <a
-     * href="http://tools.ietf.org/html/draft-ietf-tls-applayerprotoneg">ALPN</a> will be used to
-     * negotiate a transport.
-     *
-     * <p>{@link Protocol#HTTP_1_0} is not supported in this set. Requests are initiated with {@code
-     * HTTP/1.1} only. If the server responds with {@code HTTP/1.0}, that will be exposed by {@link
-     * Response#protocol()}.
-     *
-     * @param protocols the protocols to use, in order of preference. The list must contain {@link
-     * Protocol#HTTP_1_1}. It must not contain null or {@link Protocol#HTTP_1_0}.
-     */
-    public Builder protocols(List<Protocol> protocols) {
-      // Create a private copy of the list.
-      protocols = new ArrayList<>(protocols);
-
-      // Validate that the list has everything we require and nothing we forbid.
-      if (!protocols.contains(Protocol.HTTP_1_1)) {
-        throw new IllegalArgumentException("protocols doesn't contain http/1.1: " + protocols);
-      }
-      if (protocols.contains(Protocol.HTTP_1_0)) {
-        throw new IllegalArgumentException("protocols must not contain http/1.0: " + protocols);
-      }
-      if (protocols.contains(null)) {
-        throw new IllegalArgumentException("protocols must not contain null");
-      }
-
-      // Remove protocols that we no longer support.
-      if (protocols.contains(Protocol.SPDY_3)) {
-        protocols.remove(Protocol.SPDY_3);
-      }
-
-      // Assign as an unmodifiable list. This is effectively immutable.
-      this.protocols = Collections.unmodifiableList(protocols);
-      return this;
+    public List<Protocol> protocols() {
+        return protocols;
     }
 
-    public Builder connectionSpecs(List<ConnectionSpec> connectionSpecs) {
-      this.connectionSpecs = Util.immutableList(connectionSpecs);
-      return this;
+    public List<ConnectionSpec> connectionSpecs() {
+        return connectionSpecs;
     }
 
     /**
-     * Returns a modifiable list of interceptors that observe the full span of each call: from
-     * before the connection is established (if any) until after the response source is selected
-     * (either the origin server, cache, or both).
+     * Returns an immutable list of interceptors that observe the full span of each call: from before
+     * the connection is established (if any) until after the response source is selected (either the
+     * origin server, cache, or both).
      */
     public List<Interceptor> interceptors() {
-      return interceptors;
-    }
-
-    public Builder addInterceptor(Interceptor interceptor) {
-      interceptors.add(interceptor);
-      return this;
+        return interceptors;
     }
 
     /**
-     * Returns a modifiable list of interceptors that observe a single network request and response.
-     * These interceptors must call {@link Interceptor.Chain#proceed} exactly once: it is an error
-     * for a network interceptor to short-circuit or repeat a network request.
+     * Returns an immutable list of interceptors that observe a single network request and response.
+     * These interceptors must call {@link Interceptor.Chain#proceed} exactly once: it is an error for
+     * a network interceptor to short-circuit or repeat a network request.
      */
     public List<Interceptor> networkInterceptors() {
-      return networkInterceptors;
+        return networkInterceptors;
     }
 
-    public Builder addNetworkInterceptor(Interceptor interceptor) {
-      networkInterceptors.add(interceptor);
-      return this;
+    /**
+     * Prepares the {@code request} to be executed at some point in the future.
+     */
+    @Override
+    public Call newCall(Request request) {
+        return new RealCall(this, request, false /* for web socket */);
     }
 
-    public OkHttpClient build() {
-      return new OkHttpClient(this);
+    /**
+     * Uses {@code request} to connect a new web socket.
+     */
+    @Override
+    public WebSocket newWebSocket(Request request, WebSocketListener listener) {
+        RealWebSocket webSocket = new RealWebSocket(request, listener, new SecureRandom());
+        webSocket.connect(this);
+        return webSocket;
+    }
+
+    public Builder newBuilder() {
+        return new Builder(this);
+    }
+
+    public static final class Builder {
+        Dispatcher dispatcher;
+        Proxy proxy;
+        List<Protocol> protocols;
+        List<ConnectionSpec> connectionSpecs;
+        final List<Interceptor> interceptors = new ArrayList<>();
+        final List<Interceptor> networkInterceptors = new ArrayList<>();
+        ProxySelector proxySelector;
+        CookieJar cookieJar;
+        Cache cache;
+        InternalCache internalCache;
+        SocketFactory socketFactory;
+        SSLSocketFactory sslSocketFactory;
+        CertificateChainCleaner certificateChainCleaner;
+        HostnameVerifier hostnameVerifier;
+        CertificatePinner certificatePinner;
+        Authenticator proxyAuthenticator;
+        Authenticator authenticator;
+        ConnectionPool connectionPool;
+        Dns dns;
+        boolean followSslRedirects;
+        boolean followRedirects;
+        boolean retryOnConnectionFailure;
+        int connectTimeout;
+        int readTimeout;
+        int writeTimeout;
+        int pingInterval;
+
+        public Builder() {
+            dispatcher = new Dispatcher();
+            protocols = DEFAULT_PROTOCOLS;
+            connectionSpecs = DEFAULT_CONNECTION_SPECS;
+            proxySelector = ProxySelector.getDefault();
+            cookieJar = CookieJar.NO_COOKIES;
+            socketFactory = SocketFactory.getDefault();
+            hostnameVerifier = OkHostnameVerifier.INSTANCE;
+            certificatePinner = CertificatePinner.DEFAULT;
+            proxyAuthenticator = Authenticator.NONE;
+            authenticator = Authenticator.NONE;
+            connectionPool = new ConnectionPool();
+            dns = Dns.SYSTEM;
+            followSslRedirects = true;
+            followRedirects = true;
+            retryOnConnectionFailure = true;
+            connectTimeout = 10_000;
+            readTimeout = 10_000;
+            writeTimeout = 10_000;
+            pingInterval = 0;
+        }
+
+        Builder(OkHttpClient okHttpClient) {
+            this.dispatcher = okHttpClient.dispatcher;
+            this.proxy = okHttpClient.proxy;
+            this.protocols = okHttpClient.protocols;
+            this.connectionSpecs = okHttpClient.connectionSpecs;
+            this.interceptors.addAll(okHttpClient.interceptors);
+            this.networkInterceptors.addAll(okHttpClient.networkInterceptors);
+            this.proxySelector = okHttpClient.proxySelector;
+            this.cookieJar = okHttpClient.cookieJar;
+            this.internalCache = okHttpClient.internalCache;
+            this.cache = okHttpClient.cache;
+            this.socketFactory = okHttpClient.socketFactory;
+            this.sslSocketFactory = okHttpClient.sslSocketFactory;
+            this.certificateChainCleaner = okHttpClient.certificateChainCleaner;
+            this.hostnameVerifier = okHttpClient.hostnameVerifier;
+            this.certificatePinner = okHttpClient.certificatePinner;
+            this.proxyAuthenticator = okHttpClient.proxyAuthenticator;
+            this.authenticator = okHttpClient.authenticator;
+            this.connectionPool = okHttpClient.connectionPool;
+            this.dns = okHttpClient.dns;
+            this.followSslRedirects = okHttpClient.followSslRedirects;
+            this.followRedirects = okHttpClient.followRedirects;
+            this.retryOnConnectionFailure = okHttpClient.retryOnConnectionFailure;
+            this.connectTimeout = okHttpClient.connectTimeout;
+            this.readTimeout = okHttpClient.readTimeout;
+            this.writeTimeout = okHttpClient.writeTimeout;
+            this.pingInterval = okHttpClient.pingInterval;
+        }
+
+        /**
+         * Sets the default connect timeout for new connections. A value of 0 means no timeout,
+         * otherwise values must be between 1 and {@link Integer#MAX_VALUE} when converted to
+         * milliseconds.
+         */
+        public Builder connectTimeout(long timeout, TimeUnit unit) {
+            connectTimeout = checkDuration("timeout", timeout, unit);
+            return this;
+        }
+
+        /**
+         * Sets the default read timeout for new connections. A value of 0 means no timeout, otherwise
+         * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
+         */
+        public Builder readTimeout(long timeout, TimeUnit unit) {
+            readTimeout = checkDuration("timeout", timeout, unit);
+            return this;
+        }
+
+        /**
+         * Sets the default write timeout for new connections. A value of 0 means no timeout, otherwise
+         * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
+         */
+        public Builder writeTimeout(long timeout, TimeUnit unit) {
+            writeTimeout = checkDuration("timeout", timeout, unit);
+            return this;
+        }
+
+        /**
+         * Sets the interval between web socket pings initiated by this client. Use this to
+         * automatically send web socket ping frames until either the web socket fails or it is closed.
+         * This keeps the connection alive and may detect connectivity failures early. No timeouts are
+         * enforced on the acknowledging pongs.
+         * <p>
+         * <p>The default value of 0 disables client-initiated pings.
+         */
+        public Builder pingInterval(long interval, TimeUnit unit) {
+            pingInterval = checkDuration("interval", interval, unit);
+            return this;
+        }
+
+        private static int checkDuration(String name, long duration, TimeUnit unit) {
+            if (duration < 0) throw new IllegalArgumentException(name + " < 0");
+            if (unit == null) throw new NullPointerException("unit == null");
+            long millis = unit.toMillis(duration);
+            if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException(name + " too large.");
+            if (millis == 0 && duration > 0) throw new IllegalArgumentException(name + " too small.");
+            return (int) millis;
+        }
+
+        /**
+         * Sets the HTTP proxy that will be used by connections created by this client. This takes
+         * precedence over {@link #proxySelector}, which is only honored when this proxy is null (which
+         * it is by default). To disable proxy use completely, call {@code setProxy(Proxy.NO_PROXY)}.
+         */
+        public Builder proxy(Proxy proxy) {
+            this.proxy = proxy;
+            return this;
+        }
+
+        /**
+         * Sets the proxy selection policy to be used if no {@link #proxy proxy} is specified
+         * explicitly. The proxy selector may return multiple proxies; in that case they will be tried
+         * in sequence until a successful connection is established.
+         * <p>
+         * <p>If unset, the {@link ProxySelector#getDefault() system-wide default} proxy selector will
+         * be used.
+         */
+        public Builder proxySelector(ProxySelector proxySelector) {
+            this.proxySelector = proxySelector;
+            return this;
+        }
+
+        /**
+         * Sets the handler that can accept cookies from incoming HTTP responses and provides cookies to
+         * outgoing HTTP requests.
+         * <p>
+         * <p>If unset, {@linkplain CookieJar#NO_COOKIES no cookies} will be accepted nor provided.
+         */
+        public Builder cookieJar(CookieJar cookieJar) {
+            if (cookieJar == null) throw new NullPointerException("cookieJar == null");
+            this.cookieJar = cookieJar;
+            return this;
+        }
+
+        /**
+         * Sets the response cache to be used to read and write cached responses.
+         */
+        void setInternalCache(InternalCache internalCache) {
+            this.internalCache = internalCache;
+            this.cache = null;
+        }
+
+        /**
+         * Sets the response cache to be used to read and write cached responses.
+         */
+        public Builder cache(Cache cache) {
+            this.cache = cache;
+            this.internalCache = null;
+            return this;
+        }
+
+        /**
+         * Sets the DNS service used to lookup IP addresses for hostnames.
+         * <p>
+         * <p>If unset, the {@link Dns#SYSTEM system-wide default} DNS will be used.
+         */
+        public Builder dns(Dns dns) {
+            if (dns == null) throw new NullPointerException("dns == null");
+            this.dns = dns;
+            return this;
+        }
+
+        /**
+         * Sets the socket factory used to create connections. OkHttp only uses the parameterless {@link
+         * SocketFactory#createSocket() createSocket()} method to create unconnected sockets. Overriding
+         * this method, e. g., allows the socket to be bound to a specific local address.
+         * <p>
+         * <p>If unset, the {@link SocketFactory#getDefault() system-wide default} socket factory will
+         * be used.
+         */
+        public Builder socketFactory(SocketFactory socketFactory) {
+            if (socketFactory == null) throw new NullPointerException("socketFactory == null");
+            this.socketFactory = socketFactory;
+            return this;
+        }
+
+        /**
+         * Sets the socket factory used to secure HTTPS connections. If unset, the system default will
+         * be used.
+         *
+         * @deprecated {@code SSLSocketFactory} does not expose its {@link X509TrustManager}, which is
+         * a field that OkHttp needs to build a clean certificate chain. This method instead must
+         * use reflection to extract the trust manager. Applications should prefer to call {@link
+         * #sslSocketFactory(SSLSocketFactory, X509TrustManager)}, which avoids such reflection.
+         */
+        public Builder sslSocketFactory(SSLSocketFactory sslSocketFactory) {
+            if (sslSocketFactory == null) throw new NullPointerException("sslSocketFactory == null");
+            X509TrustManager trustManager = Platform.get().trustManager(sslSocketFactory);
+            if (trustManager == null) {
+                throw new IllegalStateException("Unable to extract the trust manager on " + Platform.get()
+                        + ", sslSocketFactory is " + sslSocketFactory.getClass());
+            }
+            this.sslSocketFactory = sslSocketFactory;
+            this.certificateChainCleaner = CertificateChainCleaner.get(trustManager);
+            return this;
+        }
+
+        /**
+         * Sets the socket factory and trust manager used to secure HTTPS connections. If unset, the
+         * system defaults will be used.
+         * <p>
+         * <p>Most applications should not call this method, and instead use the system defaults. Those
+         * classes include special optimizations that can be lost if the implementations are decorated.
+         * <p>
+         * <p>If necessary, you can create and configure the defaults yourself with the following code:
+         * <p>
+         * <pre>   {@code
+         *
+         *   TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
+         *       TrustManagerFactory.getDefaultAlgorithm());
+         *   trustManagerFactory.init((KeyStore) null);
+         *   TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
+         *   if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {
+         *     throw new IllegalStateException("Unexpected default trust managers:"
+         *         + Arrays.toString(trustManagers));
+         *   }
+         *   X509TrustManager trustManager = (X509TrustManager) trustManagers[0];
+         *
+         *   SSLContext sslContext = SSLContext.getInstance("TLS");
+         *   sslContext.init(null, new TrustManager[] { trustManager }, null);
+         *   SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();
+         *
+         *   OkHttpClient client = new OkHttpClient.Builder()
+         *       .sslSocketFactory(sslSocketFactory, trustManager);
+         *       .build();
+         * }</pre>
+         */
+        public Builder sslSocketFactory(
+                SSLSocketFactory sslSocketFactory, X509TrustManager trustManager) {
+            if (sslSocketFactory == null) throw new NullPointerException("sslSocketFactory == null");
+            if (trustManager == null) throw new NullPointerException("trustManager == null");
+            this.sslSocketFactory = sslSocketFactory;
+            this.certificateChainCleaner = CertificateChainCleaner.get(trustManager);
+            return this;
+        }
+
+        /**
+         * Sets the verifier used to confirm that response certificates apply to requested hostnames for
+         * HTTPS connections.
+         * <p>
+         * <p>If unset, a default hostname verifier will be used.
+         */
+        public Builder hostnameVerifier(HostnameVerifier hostnameVerifier) {
+            if (hostnameVerifier == null) throw new NullPointerException("hostnameVerifier == null");
+            this.hostnameVerifier = hostnameVerifier;
+            return this;
+        }
+
+        /**
+         * Sets the certificate pinner that constrains which certificates are trusted. By default HTTPS
+         * connections rely on only the {@link #sslSocketFactory SSL socket factory} to establish trust.
+         * Pinning certificates avoids the need to trust certificate authorities.
+         */
+        public Builder certificatePinner(CertificatePinner certificatePinner) {
+            if (certificatePinner == null) throw new NullPointerException("certificatePinner == null");
+            this.certificatePinner = certificatePinner;
+            return this;
+        }
+
+        /**
+         * Sets the authenticator used to respond to challenges from origin servers. Use {@link
+         * #proxyAuthenticator} to set the authenticator for proxy servers.
+         * <p>
+         * <p>If unset, the {@linkplain Authenticator#NONE no authentication will be attempted}.
+         */
+        public Builder authenticator(Authenticator authenticator) {
+            if (authenticator == null) throw new NullPointerException("authenticator == null");
+            this.authenticator = authenticator;
+            return this;
+        }
+
+        /**
+         * Sets the authenticator used to respond to challenges from proxy servers. Use {@link
+         * #authenticator} to set the authenticator for origin servers.
+         * <p>
+         * <p>If unset, the {@linkplain Authenticator#NONE no authentication will be attempted}.
+         */
+        public Builder proxyAuthenticator(Authenticator proxyAuthenticator) {
+            if (proxyAuthenticator == null) throw new NullPointerException("proxyAuthenticator == null");
+            this.proxyAuthenticator = proxyAuthenticator;
+            return this;
+        }
+
+        /**
+         * Sets the connection pool used to recycle HTTP and HTTPS connections.
+         * <p>
+         * <p>If unset, a new connection pool will be used.
+         */
+        public Builder connectionPool(ConnectionPool connectionPool) {
+            if (connectionPool == null) throw new NullPointerException("connectionPool == null");
+            this.connectionPool = connectionPool;
+            return this;
+        }
+
+        /**
+         * Configure this client to follow redirects from HTTPS to HTTP and from HTTP to HTTPS.
+         * <p>
+         * <p>If unset, protocol redirects will be followed. This is different than the built-in {@code
+         * HttpURLConnection}'s default.
+         */
+        public Builder followSslRedirects(boolean followProtocolRedirects) {
+            this.followSslRedirects = followProtocolRedirects;
+            return this;
+        }
+
+        /**
+         * Configure this client to follow redirects. If unset, redirects will be followed.
+         */
+        public Builder followRedirects(boolean followRedirects) {
+            this.followRedirects = followRedirects;
+            return this;
+        }
+
+        /**
+         * Configure this client to retry or not when a connectivity problem is encountered. By default,
+         * this client silently recovers from the following problems:
+         * <p>
+         * <ul>
+         * <li><strong>Unreachable IP addresses.</strong> If the URL's host has multiple IP addresses,
+         * failure to reach any individual IP address doesn't fail the overall request. This can
+         * increase availability of multi-homed services.
+         * <li><strong>Stale pooled connections.</strong> The {@link ConnectionPool} reuses sockets
+         * to decrease request latency, but these connections will occasionally time out.
+         * <li><strong>Unreachable proxy servers.</strong> A {@link ProxySelector} can be used to
+         * attempt multiple proxy servers in sequence, eventually falling back to a direct
+         * connection.
+         * </ul>
+         * <p>
+         * Set this to false to avoid retrying requests when doing so is destructive. In this case the
+         * calling application should do its own recovery of connectivity failures.
+         */
+        public Builder retryOnConnectionFailure(boolean retryOnConnectionFailure) {
+            this.retryOnConnectionFailure = retryOnConnectionFailure;
+            return this;
+        }
+
+        /**
+         * Sets the dispatcher used to set policy and execute asynchronous requests. Must not be null.
+         */
+        public Builder dispatcher(Dispatcher dispatcher) {
+            if (dispatcher == null) throw new IllegalArgumentException("dispatcher == null");
+            this.dispatcher = dispatcher;
+            return this;
+        }
+
+        /**
+         * Configure the protocols used by this client to communicate with remote servers. By default
+         * this client will prefer the most efficient transport available, falling back to more
+         * ubiquitous protocols. Applications should only call this method to avoid specific
+         * compatibility problems, such as web servers that behave incorrectly when HTTP/2 is enabled.
+         * <p>
+         * <p>The following protocols are currently supported:
+         * <p>
+         * <ul>
+         * <li><a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html">http/1.1</a>
+         * <li><a href="http://tools.ietf.org/html/draft-ietf-httpbis-http2-17">h2</a>
+         * </ul>
+         * <p>
+         * <p><strong>This is an evolving set.</strong> Future releases include support for transitional
+         * protocols. The http/1.1 transport will never be dropped.
+         * <p>
+         * <p>If multiple protocols are specified, <a
+         * href="http://tools.ietf.org/html/draft-ietf-tls-applayerprotoneg">ALPN</a> will be used to
+         * negotiate a transport.
+         * <p>
+         * <p>{@link Protocol#HTTP_1_0} is not supported in this set. Requests are initiated with {@code
+         * HTTP/1.1} only. If the server responds with {@code HTTP/1.0}, that will be exposed by {@link
+         * Response#protocol()}.
+         *
+         * @param protocols the protocols to use, in order of preference. The list must contain {@link
+         *                  Protocol#HTTP_1_1}. It must not contain null or {@link Protocol#HTTP_1_0}.
+         */
+        public Builder protocols(List<Protocol> protocols) {
+            // Create a private copy of the list.
+            protocols = new ArrayList<>(protocols);
+
+            // Validate that the list has everything we require and nothing we forbid.
+            if (!protocols.contains(Protocol.HTTP_1_1)) {
+                throw new IllegalArgumentException("protocols doesn't contain http/1.1: " + protocols);
+            }
+            if (protocols.contains(Protocol.HTTP_1_0)) {
+                throw new IllegalArgumentException("protocols must not contain http/1.0: " + protocols);
+            }
+            if (protocols.contains(null)) {
+                throw new IllegalArgumentException("protocols must not contain null");
+            }
+
+            // Remove protocols that we no longer support.
+            if (protocols.contains(Protocol.SPDY_3)) {
+                protocols.remove(Protocol.SPDY_3);
+            }
+
+            // Assign as an unmodifiable list. This is effectively immutable.
+            this.protocols = Collections.unmodifiableList(protocols);
+            return this;
+        }
+
+        public Builder connectionSpecs(List<ConnectionSpec> connectionSpecs) {
+            this.connectionSpecs = Util.immutableList(connectionSpecs);
+            return this;
+        }
+
+        /**
+         * Returns a modifiable list of interceptors that observe the full span of each call: from
+         * before the connection is established (if any) until after the response source is selected
+         * (either the origin server, cache, or both).
+         */
+        public List<Interceptor> interceptors() {
+            return interceptors;
+        }
+
+        public Builder addInterceptor(Interceptor interceptor) {
+            interceptors.add(interceptor);
+            return this;
+        }
+
+        /**
+         * Returns a modifiable list of interceptors that observe a single network request and response.
+         * These interceptors must call {@link Interceptor.Chain#proceed} exactly once: it is an error
+         * for a network interceptor to short-circuit or repeat a network request.
+         */
+        public List<Interceptor> networkInterceptors() {
+            return networkInterceptors;
+        }
+
+        public Builder addNetworkInterceptor(Interceptor interceptor) {
+            networkInterceptors.add(interceptor);
+            return this;
+        }
+
+        public OkHttpClient build() {
+            return new OkHttpClient(this);
+        }
     }
-  }
 }
diff --git a/okhttp/src/main/java/okhttp3/RealCall.java b/okhttp/src/main/java/okhttp3/RealCall.java
index ab3ddb088f..27d31e6e56 100644
--- a/okhttp/src/main/java/okhttp3/RealCall.java
+++ b/okhttp/src/main/java/okhttp3/RealCall.java
@@ -18,6 +18,7 @@
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
+
 import okhttp3.internal.NamedRunnable;
 import okhttp3.internal.cache.CacheInterceptor;
 import okhttp3.internal.connection.ConnectInterceptor;
@@ -31,151 +32,169 @@
 import static okhttp3.internal.platform.Platform.INFO;
 
 final class RealCall implements Call {
-  final OkHttpClient client;
-  final RetryAndFollowUpInterceptor retryAndFollowUpInterceptor;
-
-  /** The application's original request unadulterated by redirects or auth headers. */
-  final Request originalRequest;
-  final boolean forWebSocket;
-
-  // Guarded by this.
-  private boolean executed;
-
-  RealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {
-    this.client = client;
-    this.originalRequest = originalRequest;
-    this.forWebSocket = forWebSocket;
-    this.retryAndFollowUpInterceptor = new RetryAndFollowUpInterceptor(client, forWebSocket);
-  }
-
-  @Override public Request request() {
-    return originalRequest;
-  }
-
-  @Override public Response execute() throws IOException {
-    synchronized (this) {
-      if (executed) throw new IllegalStateException("Already Executed");
-      executed = true;
-    }
-    captureCallStackTrace();
-    try {
-      client.dispatcher().executed(this);
-      Response result = getResponseWithInterceptorChain();
-      if (result == null) throw new IOException("Canceled");
-      return result;
-    } finally {
-      client.dispatcher().finished(this);
+    final OkHttpClient client;
+    final RetryAndFollowUpInterceptor retryAndFollowUpInterceptor;
+
+    /**
+     * The application's original request unadulterated by redirects or auth headers.
+     */
+    final Request originalRequest;
+    final boolean forWebSocket;
+
+    // Guarded by this.
+    private boolean executed;
+
+    RealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {
+        this.client = client;
+        this.originalRequest = originalRequest;
+        this.forWebSocket = forWebSocket;
+        this.retryAndFollowUpInterceptor = new RetryAndFollowUpInterceptor(client, forWebSocket);
     }
-  }
 
-  private void captureCallStackTrace() {
-    Object callStackTrace = Platform.get().getStackTraceForCloseable("response.body().close()");
-    retryAndFollowUpInterceptor.setCallStackTrace(callStackTrace);
-  }
-
-  @Override public void enqueue(Callback responseCallback) {
-    synchronized (this) {
-      if (executed) throw new IllegalStateException("Already Executed");
-      executed = true;
+    @Override
+    public Request request() {
+        return originalRequest;
     }
-    captureCallStackTrace();
-    client.dispatcher().enqueue(new AsyncCall(responseCallback));
-  }
-
-  @Override public void cancel() {
-    retryAndFollowUpInterceptor.cancel();
-  }
 
-  @Override public synchronized boolean isExecuted() {
-    return executed;
-  }
-
-  @Override public boolean isCanceled() {
-    return retryAndFollowUpInterceptor.isCanceled();
-  }
+    @Override
+    public Response execute() throws IOException {// 同步执行
+        synchronized (this) {
+            if (executed) throw new IllegalStateException("Already Executed");
+            executed = true;
+        }
+        captureCallStackTrace();// 捕获请求轨迹？？
+        try {
+            client.dispatcher().executed(this);
+            Response result = getResponseWithInterceptorChain();
+            if (result == null) throw new IOException("Canceled");
+            return result;
+        } finally {
+            client.dispatcher().finished(this);
+        }
+    }
 
-  @SuppressWarnings("CloneDoesntCallSuperClone") // We are a final type & this saves clearing state.
-  @Override public RealCall clone() {
-    return new RealCall(client, originalRequest, forWebSocket);
-  }
+    private void captureCallStackTrace() {
+        Object callStackTrace = Platform.get().getStackTraceForCloseable("response.body().close()");
+        retryAndFollowUpInterceptor.setCallStackTrace(callStackTrace);
+    }
 
-  StreamAllocation streamAllocation() {
-    return retryAndFollowUpInterceptor.streamAllocation();
-  }
+    @Override
+    public void enqueue(Callback responseCallback) {
+        synchronized (this) {
+            if (executed) throw new IllegalStateException("Already Executed");
+            executed = true;
+        }
+        captureCallStackTrace();
+        client.dispatcher().enqueue(new AsyncCall(responseCallback));
+    }
 
-  final class AsyncCall extends NamedRunnable {
-    private final Callback responseCallback;
+    @Override
+    public void cancel() {
+        retryAndFollowUpInterceptor.cancel();
+    }
 
-    AsyncCall(Callback responseCallback) {
-      super("OkHttp %s", redactedUrl());
-      this.responseCallback = responseCallback;
+    @Override
+    public synchronized boolean isExecuted() {
+        return executed;
     }
 
-    String host() {
-      return originalRequest.url().host();
+    @Override
+    public boolean isCanceled() {
+        return retryAndFollowUpInterceptor.isCanceled();
     }
 
-    Request request() {
-      return originalRequest;
+    @SuppressWarnings("CloneDoesntCallSuperClone") // We are a final type & this saves clearing state.
+    @Override
+    public RealCall clone() {
+        return new RealCall(client, originalRequest, forWebSocket);
     }
 
-    RealCall get() {
-      return RealCall.this;
+    StreamAllocation streamAllocation() {
+        return retryAndFollowUpInterceptor.streamAllocation();
     }
 
-    @Override protected void execute() {
-      boolean signalledCallback = false;
-      try {
-        Response response = getResponseWithInterceptorChain();
-        if (retryAndFollowUpInterceptor.isCanceled()) {
-          signalledCallback = true;
-          responseCallback.onFailure(RealCall.this, new IOException("Canceled"));
-        } else {
-          signalledCallback = true;
-          responseCallback.onResponse(RealCall.this, response);
+    final class AsyncCall extends NamedRunnable {
+        private final Callback responseCallback;
+
+        AsyncCall(Callback responseCallback) {
+            super("OkHttp %s", redactedUrl());
+            this.responseCallback = responseCallback;
         }
-      } catch (IOException e) {
-        if (signalledCallback) {
-          // Do not signal the callback twice!
-          Platform.get().log(INFO, "Callback failure for " + toLoggableString(), e);
-        } else {
-          responseCallback.onFailure(RealCall.this, e);
+
+        String host() {
+            return originalRequest.url().host();
+        }
+
+        Request request() {
+            return originalRequest;
+        }
+
+        RealCall get() {
+            return RealCall.this;
+        }
+
+        @Override//最终执行的这个方法
+        protected void execute() {
+            boolean signalledCallback = false;
+            try {
+                Response response = getResponseWithInterceptorChain();
+                if (retryAndFollowUpInterceptor.isCanceled()) {
+                    signalledCallback = true;
+                    // 回调
+                    responseCallback.onFailure(RealCall.this, new IOException("Canceled"));
+                } else {
+                    signalledCallback = true;
+                    responseCallback.onResponse(RealCall.this, response);
+                }
+            } catch (IOException e) {
+                if (signalledCallback) {
+                    // Do not signal the callback twice!
+                    Platform.get().log(INFO, "Callback failure for " + toLoggableString(), e);
+                } else {
+                    responseCallback.onFailure(RealCall.this, e);
+                }
+            } finally {
+                // 终结任务.
+                client.dispatcher().finished(this);
+            }
         }
-      } finally {
-        client.dispatcher().finished(this);
-      }
     }
-  }
-
-  /**
-   * Returns a string that describes this call. Doesn't include a full URL as that might contain
-   * sensitive information.
-   */
-  String toLoggableString() {
-    return (isCanceled() ? "canceled " : "")
-        + (forWebSocket ? "web socket" : "call")
-        + " to " + redactedUrl();
-  }
-
-  String redactedUrl() {
-    return originalRequest.url().redact();
-  }
-
-  Response getResponseWithInterceptorChain() throws IOException {
-    // Build a full stack of interceptors.
-    List<Interceptor> interceptors = new ArrayList<>();
-    interceptors.addAll(client.interceptors());
-    interceptors.add(retryAndFollowUpInterceptor);
-    interceptors.add(new BridgeInterceptor(client.cookieJar()));
-    interceptors.add(new CacheInterceptor(client.internalCache()));
-    interceptors.add(new ConnectInterceptor(client));
-    if (!forWebSocket) {
-      interceptors.addAll(client.networkInterceptors());
+
+    /**
+     * Returns a string that describes this call. Doesn't include a full URL as that might contain
+     * sensitive information.
+     */
+    String toLoggableString() {
+        return (isCanceled() ? "canceled " : "")
+                + (forWebSocket ? "web socket" : "call")
+                + " to " + redactedUrl();
+    }
+
+    String redactedUrl() {
+        return originalRequest.url().redact();
     }
-    interceptors.add(new CallServerInterceptor(forWebSocket));
 
-    Interceptor.Chain chain = new RealInterceptorChain(
-        interceptors, null, null, null, 0, originalRequest);
-    return chain.proceed(originalRequest);
-  }
+    /**
+     * 执行请求任务
+     *
+     * @return 请求结果
+     * @throws IOException
+     */
+    Response getResponseWithInterceptorChain() throws IOException {
+        // Build a full stack of interceptors.
+        List<Interceptor> interceptors = new ArrayList<>();
+        interceptors.addAll(client.interceptors());
+        interceptors.add(retryAndFollowUpInterceptor);
+        interceptors.add(new BridgeInterceptor(client.cookieJar()));
+        interceptors.add(new CacheInterceptor(client.internalCache()));
+        interceptors.add(new ConnectInterceptor(client));
+        if (!forWebSocket) {
+            interceptors.addAll(client.networkInterceptors());
+        }
+        interceptors.add(new CallServerInterceptor(forWebSocket));
+
+        Interceptor.Chain chain = new RealInterceptorChain(
+                interceptors, null, null, null, 0, originalRequest);
+        return chain.proceed(originalRequest);
+    }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java b/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java
index 18d4fd9813..02337bd85a 100644
--- a/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java
@@ -17,6 +17,7 @@
 package okhttp3.internal.cache;
 
 import java.io.IOException;
+
 import okhttp3.Headers;
 import okhttp3.Interceptor;
 import okhttp3.Protocol;
@@ -41,226 +42,234 @@
 import static okhttp3.internal.Util.closeQuietly;
 import static okhttp3.internal.Util.discard;
 
-/** Serves requests from the cache and writes responses to the cache. */
+/**
+ * Serves requests from the cache and writes responses to the cache.
+ */
 public final class CacheInterceptor implements Interceptor {
-  final InternalCache cache;
+    final InternalCache cache;
 
-  public CacheInterceptor(InternalCache cache) {
-    this.cache = cache;
-  }
+    public CacheInterceptor(InternalCache cache) {
+        this.cache = cache;
+    }
 
-  @Override public Response intercept(Chain chain) throws IOException {
-    Response cacheCandidate = cache != null
-        ? cache.get(chain.request())
-        : null;
+    @Override
+    public Response intercept(Chain chain) throws IOException {
+        Response cacheCandidate = cache != null
+                ? cache.get(chain.request())
+                : null;
 
-    long now = System.currentTimeMillis();
+        long now = System.currentTimeMillis();
 
-    CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();
-    Request networkRequest = strategy.networkRequest;
-    Response cacheResponse = strategy.cacheResponse;
+        CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();
+        Request networkRequest = strategy.networkRequest;
+        Response cacheResponse = strategy.cacheResponse;
 
-    if (cache != null) {
-      cache.trackResponse(strategy);
-    }
+        if (cache != null) {// 跟踪响应，更新各种次数
+            cache.trackResponse(strategy);
+        }
 
-    if (cacheCandidate != null && cacheResponse == null) {
-      closeQuietly(cacheCandidate.body()); // The cache candidate wasn't applicable. Close it.
-    }
+        if (cacheCandidate != null && cacheResponse == null) {// 缓存不可用
+            closeQuietly(cacheCandidate.body()); // The cache candidate wasn't applicable. Close it.
+        }
 
-    // If we're forbidden from using the network and the cache is insufficient, fail.
-    if (networkRequest == null && cacheResponse == null) {
-      return new Response.Builder()
-          .request(chain.request())
-          .protocol(Protocol.HTTP_1_1)
-          .code(504)
-          .message("Unsatisfiable Request (only-if-cached)")
-          .body(Util.EMPTY_RESPONSE)
-          .sentRequestAtMillis(-1L)
-          .receivedResponseAtMillis(System.currentTimeMillis())
-          .build();
-    }
+        // If we're forbidden from using the network and the cache is insufficient, fail.
+        if (networkRequest == null && cacheResponse == null) {// 不做请求，也没有缓存，返回异常
+            return new Response.Builder()
+                    .request(chain.request())
+                    .protocol(Protocol.HTTP_1_1)
+                    .code(504)
+                    .message("Unsatisfiable Request (only-if-cached)")
+                    .body(Util.EMPTY_RESPONSE)
+                    .sentRequestAtMillis(-1L)
+                    .receivedResponseAtMillis(System.currentTimeMillis())
+                    .build();
+        }
 
-    // If we don't need the network, we're done.
-    if (networkRequest == null) {
-      return cacheResponse.newBuilder()
-          .cacheResponse(stripBody(cacheResponse))
-          .build();
-    }
+        // If we don't need the network, we're done.
+        if (networkRequest == null) {// 不需要网络请求，直接利用缓存
+            return cacheResponse.newBuilder()
+                    .cacheResponse(stripBody(cacheResponse))
+                    .build();
+        }
 
-    Response networkResponse = null;
-    try {
-      networkResponse = chain.proceed(networkRequest);
-    } finally {
-      // If we're crashing on I/O or otherwise, don't leak the cache body.
-      if (networkResponse == null && cacheCandidate != null) {
-        closeQuietly(cacheCandidate.body());
-      }
-    }
+        Response networkResponse = null;
+        try {// 再次请求
+            networkResponse = chain.proceed(networkRequest);
+        } finally {
+            // If we're crashing on I/O or otherwise, don't leak the cache body.
+            if (networkResponse == null && cacheCandidate != null) {
+                closeQuietly(cacheCandidate.body());
+            }
+        }
 
-    // If we have a cache response too, then we're doing a conditional get.
-    if (cacheResponse != null) {
-      if (networkResponse.code() == HTTP_NOT_MODIFIED) {
-        Response response = cacheResponse.newBuilder()
-            .headers(combine(cacheResponse.headers(), networkResponse.headers()))
-            .sentRequestAtMillis(networkResponse.sentRequestAtMillis())
-            .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())
-            .cacheResponse(stripBody(cacheResponse))
-            .networkResponse(stripBody(networkResponse))
-            .build();
-        networkResponse.body().close();
-
-        // Update the cache after combining headers but before stripping the
-        // Content-Encoding header (as performed by initContentStream()).
-        cache.trackConditionalCacheHit();
-        cache.update(cacheResponse, response);
-        return response;
-      } else {
-        closeQuietly(cacheResponse.body());
-      }
-    }
+        // If we have a cache response too, then we're doing a conditional get.
+        if (cacheResponse != null) {// 有缓存
+            if (networkResponse.code() == HTTP_NOT_MODIFIED) {// 没有改动，更新响应信息
+                Response response = cacheResponse.newBuilder()
+                        .headers(combine(cacheResponse.headers(), networkResponse.headers()))
+                        .sentRequestAtMillis(networkResponse.sentRequestAtMillis())
+                        .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())
+                        .cacheResponse(stripBody(cacheResponse))
+                        .networkResponse(stripBody(networkResponse))
+                        .build();
+                networkResponse.body().close();
+
+                // Update the cache after combining headers but before stripping the
+                // Content-Encoding header (as performed by initContentStream()).
+                cache.trackConditionalCacheHit();
+                cache.update(cacheResponse, response);
+                return response;
+            } else {
+                closeQuietly(cacheResponse.body());
+            }
+        }
 
-    Response response = networkResponse.newBuilder()
-        .cacheResponse(stripBody(cacheResponse))
-        .networkResponse(stripBody(networkResponse))
-        .build();
+        Response response = networkResponse.newBuilder()
+                .cacheResponse(stripBody(cacheResponse))
+                .networkResponse(stripBody(networkResponse))
+                .build();// 使用请求返回来的响应
 
-    if (HttpHeaders.hasBody(response)) {
-      CacheRequest cacheRequest = maybeCache(response, networkResponse.request(), cache);
-      response = cacheWritingResponse(cacheRequest, response);
+        if (HttpHeaders.hasBody(response)) {// 缓存响应
+            CacheRequest cacheRequest = maybeCache(response, networkResponse.request(), cache);
+            response = cacheWritingResponse(cacheRequest, response);
+        }
+
+        return response;
     }
 
-    return response;
-  }
-
-  private static Response stripBody(Response response) {
-    return response != null && response.body() != null
-        ? response.newBuilder().body(null).build()
-        : response;
-  }
-
-  private CacheRequest maybeCache(Response userResponse, Request networkRequest,
-      InternalCache responseCache) throws IOException {
-    if (responseCache == null) return null;
-
-    // Should we cache this response for this request?
-    if (!CacheStrategy.isCacheable(userResponse, networkRequest)) {
-      if (HttpMethod.invalidatesCache(networkRequest.method())) {
-        try {
-          responseCache.remove(networkRequest);
-        } catch (IOException ignored) {
-          // The cache cannot be written.
-        }
-      }
-      return null;
+    private static Response stripBody(Response response) {
+        return response != null && response.body() != null
+                ? response.newBuilder().body(null).build()
+                : response;
     }
 
-    // Offer this request to the cache.
-    return responseCache.put(userResponse);
-  }
-
-  /**
-   * Returns a new source that writes bytes to {@code cacheRequest} as they are read by the source
-   * consumer. This is careful to discard bytes left over when the stream is closed; otherwise we
-   * may never exhaust the source stream and therefore not complete the cached response.
-   */
-  private Response cacheWritingResponse(final CacheRequest cacheRequest, Response response)
-      throws IOException {
-    // Some apps return a null body; for compatibility we treat that like a null cache request.
-    if (cacheRequest == null) return response;
-    Sink cacheBodyUnbuffered = cacheRequest.body();
-    if (cacheBodyUnbuffered == null) return response;
-
-    final BufferedSource source = response.body().source();
-    final BufferedSink cacheBody = Okio.buffer(cacheBodyUnbuffered);
-
-    Source cacheWritingSource = new Source() {
-      boolean cacheRequestClosed;
-
-      @Override public long read(Buffer sink, long byteCount) throws IOException {
-        long bytesRead;
-        try {
-          bytesRead = source.read(sink, byteCount);
-        } catch (IOException e) {
-          if (!cacheRequestClosed) {
-            cacheRequestClosed = true;
-            cacheRequest.abort(); // Failed to write a complete cache response.
-          }
-          throw e;
+    private CacheRequest maybeCache(Response userResponse, Request networkRequest,
+                                    InternalCache responseCache) throws IOException {
+        if (responseCache == null) return null;
+
+        // Should we cache this response for this request? 判断是否可缓存
+        if (!CacheStrategy.isCacheable(userResponse, networkRequest)) {
+            if (HttpMethod.invalidatesCache(networkRequest.method())) {
+                try {
+                    responseCache.remove(networkRequest);
+                } catch (IOException ignored) {
+                    // The cache cannot be written.
+                }
+            }
+            return null;
         }
 
-        if (bytesRead == -1) {
-          if (!cacheRequestClosed) {
-            cacheRequestClosed = true;
-            cacheBody.close(); // The cache response is complete!
-          }
-          return -1;
-        }
+        // Offer this request to the cache.
+        return responseCache.put(userResponse);
+    }
 
-        sink.copyTo(cacheBody.buffer(), sink.size() - bytesRead, bytesRead);
-        cacheBody.emitCompleteSegments();
-        return bytesRead;
-      }
+    /**
+     * Returns a new source that writes bytes to {@code cacheRequest} as they are read by the source
+     * consumer. This is careful to discard bytes left over when the stream is closed; otherwise we
+     * may never exhaust the source stream and therefore not complete the cached response.
+     */
+    private Response cacheWritingResponse(final CacheRequest cacheRequest, Response response)
+            throws IOException {
+        // Some apps return a null body; for compatibility we treat that like a null cache request.
+        if (cacheRequest == null) return response;
+        Sink cacheBodyUnbuffered = cacheRequest.body();
+        if (cacheBodyUnbuffered == null) return response;
+
+        final BufferedSource source = response.body().source();
+        final BufferedSink cacheBody = Okio.buffer(cacheBodyUnbuffered);
+
+        Source cacheWritingSource = new Source() {
+            boolean cacheRequestClosed;
+
+            @Override
+            public long read(Buffer sink, long byteCount) throws IOException {
+                long bytesRead;
+                try {
+                    bytesRead = source.read(sink, byteCount);
+                } catch (IOException e) {
+                    if (!cacheRequestClosed) {
+                        cacheRequestClosed = true;
+                        cacheRequest.abort(); // Failed to write a complete cache response.
+                    }
+                    throw e;
+                }
+
+                if (bytesRead == -1) {
+                    if (!cacheRequestClosed) {
+                        cacheRequestClosed = true;
+                        cacheBody.close(); // The cache response is complete!
+                    }
+                    return -1;
+                }
+
+                sink.copyTo(cacheBody.buffer(), sink.size() - bytesRead, bytesRead);
+                cacheBody.emitCompleteSegments();
+                return bytesRead;
+            }
+
+            @Override
+            public Timeout timeout() {
+                return source.timeout();
+            }
+
+            @Override
+            public void close() throws IOException {
+                if (!cacheRequestClosed
+                        && !discard(this, HttpCodec.DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
+                    cacheRequestClosed = true;
+                    cacheRequest.abort();
+                }
+                source.close();
+            }
+        };
+
+        return response.newBuilder()
+                .body(new RealResponseBody(response.headers(), Okio.buffer(cacheWritingSource)))
+                .build();
+    }
 
-      @Override public Timeout timeout() {
-        return source.timeout();
-      }
+    /**
+     * Combines cached headers with a network headers as defined by RFC 2616, 13.5.3.
+     */
+    private static Headers combine(Headers cachedHeaders, Headers networkHeaders) {
+        Headers.Builder result = new Headers.Builder();
+
+        for (int i = 0, size = cachedHeaders.size(); i < size; i++) {
+            String fieldName = cachedHeaders.name(i);
+            String value = cachedHeaders.value(i);
+            if ("Warning".equalsIgnoreCase(fieldName) && value.startsWith("1")) {
+                continue; // Drop 100-level freshness warnings.
+            }
+            if (!isEndToEnd(fieldName) || networkHeaders.get(fieldName) == null) {
+                Internal.instance.addLenient(result, fieldName, value);
+            }
+        }
 
-      @Override public void close() throws IOException {
-        if (!cacheRequestClosed
-            && !discard(this, HttpCodec.DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
-          cacheRequestClosed = true;
-          cacheRequest.abort();
+        for (int i = 0, size = networkHeaders.size(); i < size; i++) {
+            String fieldName = networkHeaders.name(i);
+            if ("Content-Length".equalsIgnoreCase(fieldName)) {
+                continue; // Ignore content-length headers of validating responses.
+            }
+            if (isEndToEnd(fieldName)) {
+                Internal.instance.addLenient(result, fieldName, networkHeaders.value(i));
+            }
         }
-        source.close();
-      }
-    };
-
-    return response.newBuilder()
-        .body(new RealResponseBody(response.headers(), Okio.buffer(cacheWritingSource)))
-        .build();
-  }
-
-  /** Combines cached headers with a network headers as defined by RFC 2616, 13.5.3. */
-  private static Headers combine(Headers cachedHeaders, Headers networkHeaders) {
-    Headers.Builder result = new Headers.Builder();
-
-    for (int i = 0, size = cachedHeaders.size(); i < size; i++) {
-      String fieldName = cachedHeaders.name(i);
-      String value = cachedHeaders.value(i);
-      if ("Warning".equalsIgnoreCase(fieldName) && value.startsWith("1")) {
-        continue; // Drop 100-level freshness warnings.
-      }
-      if (!isEndToEnd(fieldName) || networkHeaders.get(fieldName) == null) {
-        Internal.instance.addLenient(result, fieldName, value);
-      }
-    }
 
-    for (int i = 0, size = networkHeaders.size(); i < size; i++) {
-      String fieldName = networkHeaders.name(i);
-      if ("Content-Length".equalsIgnoreCase(fieldName)) {
-        continue; // Ignore content-length headers of validating responses.
-      }
-      if (isEndToEnd(fieldName)) {
-        Internal.instance.addLenient(result, fieldName, networkHeaders.value(i));
-      }
+        return result.build();
     }
 
-    return result.build();
-  }
-
-  /**
-   * Returns true if {@code fieldName} is an end-to-end HTTP header, as defined by RFC 2616,
-   * 13.5.1.
-   */
-  static boolean isEndToEnd(String fieldName) {
-    return !"Connection".equalsIgnoreCase(fieldName)
-        && !"Keep-Alive".equalsIgnoreCase(fieldName)
-        && !"Proxy-Authenticate".equalsIgnoreCase(fieldName)
-        && !"Proxy-Authorization".equalsIgnoreCase(fieldName)
-        && !"TE".equalsIgnoreCase(fieldName)
-        && !"Trailers".equalsIgnoreCase(fieldName)
-        && !"Transfer-Encoding".equalsIgnoreCase(fieldName)
-        && !"Upgrade".equalsIgnoreCase(fieldName);
-  }
+    /**
+     * Returns true if {@code fieldName} is an end-to-end HTTP header, as defined by RFC 2616,
+     * 13.5.1.
+     */
+    static boolean isEndToEnd(String fieldName) {
+        return !"Connection".equalsIgnoreCase(fieldName)
+                && !"Keep-Alive".equalsIgnoreCase(fieldName)
+                && !"Proxy-Authenticate".equalsIgnoreCase(fieldName)
+                && !"Proxy-Authorization".equalsIgnoreCase(fieldName)
+                && !"TE".equalsIgnoreCase(fieldName)
+                && !"Trailers".equalsIgnoreCase(fieldName)
+                && !"Transfer-Encoding".equalsIgnoreCase(fieldName)
+                && !"Upgrade".equalsIgnoreCase(fieldName);
+    }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java b/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java
index dae556bb98..7e03f058f1 100644
--- a/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java
+++ b/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java
@@ -16,6 +16,7 @@
 package okhttp3.internal.cache;
 
 import java.util.Date;
+
 import okhttp3.CacheControl;
 import okhttp3.Headers;
 import okhttp3.Request;
@@ -41,284 +42,301 @@
 /**
  * Given a request and cached response, this figures out whether to use the network, the cache, or
  * both.
- *
+ * <p>
  * <p>Selecting a cache strategy may add conditions to the request (like the "If-Modified-Since"
  * header for conditional GETs) or warnings to the cached response (if the cached data is
  * potentially stale).
  */
 public final class CacheStrategy {
-  /** The request to send on the network, or null if this call doesn't use the network. */
-  public final Request networkRequest;
-
-  /** The cached response to return or validate; or null if this call doesn't use a cache. */
-  public final Response cacheResponse;
-
-  CacheStrategy(Request networkRequest, Response cacheResponse) {
-    this.networkRequest = networkRequest;
-    this.cacheResponse = cacheResponse;
-  }
-
-  /** Returns true if {@code response} can be stored to later serve another request. */
-  public static boolean isCacheable(Response response, Request request) {
-    // Always go to network for uncacheable response codes (RFC 7231 section 6.1),
-    // This implementation doesn't support caching partial content.
-    switch (response.code()) {
-      case HTTP_OK:
-      case HTTP_NOT_AUTHORITATIVE:
-      case HTTP_NO_CONTENT:
-      case HTTP_MULT_CHOICE:
-      case HTTP_MOVED_PERM:
-      case HTTP_NOT_FOUND:
-      case HTTP_BAD_METHOD:
-      case HTTP_GONE:
-      case HTTP_REQ_TOO_LONG:
-      case HTTP_NOT_IMPLEMENTED:
-      case StatusLine.HTTP_PERM_REDIRECT:
-        // These codes can be cached unless headers forbid it.
-        break;
-
-      case HTTP_MOVED_TEMP:
-      case StatusLine.HTTP_TEMP_REDIRECT:
-        // These codes can only be cached with the right response headers.
-        // http://tools.ietf.org/html/rfc7234#section-3
-        // s-maxage is not checked because OkHttp is a private cache that should ignore s-maxage.
-        if (response.header("Expires") != null
-            || response.cacheControl().maxAgeSeconds() != -1
-            || response.cacheControl().isPublic()
-            || response.cacheControl().isPrivate()) {
-          break;
-        }
-        // Fall-through.
-
-      default:
-        // All other codes cannot be cached.
-        return false;
-    }
-
-    // A 'no-store' directive on request or response prevents the response from being cached.
-    return !response.cacheControl().noStore() && !request.cacheControl().noStore();
-  }
-
-  public static class Factory {
-    final long nowMillis;
-    final Request request;
-    final Response cacheResponse;
-
-    /** The server's time when the cached response was served, if known. */
-    private Date servedDate;
-    private String servedDateString;
-
-    /** The last modified date of the cached response, if known. */
-    private Date lastModified;
-    private String lastModifiedString;
-
     /**
-     * The expiration date of the cached response, if known. If both this field and the max age are
-     * set, the max age is preferred.
+     * The request to send on the network, or null if this call doesn't use the network.
      */
-    private Date expires;
+    public final Request networkRequest;
 
     /**
-     * Extension header set by OkHttp specifying the timestamp when the cached HTTP request was
-     * first initiated.
+     * The cached response to return or validate; or null if this call doesn't use a cache.
      */
-    private long sentRequestMillis;
+    public final Response cacheResponse;
+
+    CacheStrategy(Request networkRequest, Response cacheResponse) {
+        this.networkRequest = networkRequest;
+        this.cacheResponse = cacheResponse;
+    }
 
     /**
-     * Extension header set by OkHttp specifying the timestamp when the cached HTTP response was
-     * first received.
+     * Returns true if {@code response} can be stored to later serve another request.
      */
-    private long receivedResponseMillis;
-
-    /** Etag of the cached response. */
-    private String etag;
-
-    /** Age of the cached response. */
-    private int ageSeconds = -1;
-
-    public Factory(long nowMillis, Request request, Response cacheResponse) {
-      this.nowMillis = nowMillis;
-      this.request = request;
-      this.cacheResponse = cacheResponse;
-
-      if (cacheResponse != null) {
-        this.sentRequestMillis = cacheResponse.sentRequestAtMillis();
-        this.receivedResponseMillis = cacheResponse.receivedResponseAtMillis();
-        Headers headers = cacheResponse.headers();
-        for (int i = 0, size = headers.size(); i < size; i++) {
-          String fieldName = headers.name(i);
-          String value = headers.value(i);
-          if ("Date".equalsIgnoreCase(fieldName)) {
-            servedDate = HttpDate.parse(value);
-            servedDateString = value;
-          } else if ("Expires".equalsIgnoreCase(fieldName)) {
-            expires = HttpDate.parse(value);
-          } else if ("Last-Modified".equalsIgnoreCase(fieldName)) {
-            lastModified = HttpDate.parse(value);
-            lastModifiedString = value;
-          } else if ("ETag".equalsIgnoreCase(fieldName)) {
-            etag = value;
-          } else if ("Age".equalsIgnoreCase(fieldName)) {
-            ageSeconds = HttpHeaders.parseSeconds(value, -1);
-          }
+    public static boolean isCacheable(Response response, Request request) {
+        // Always go to network for uncacheable response codes (RFC 7231 section 6.1),
+        // This implementation doesn't support caching partial content.
+        switch (response.code()) {
+            case HTTP_OK:
+            case HTTP_NOT_AUTHORITATIVE:
+            case HTTP_NO_CONTENT:
+            case HTTP_MULT_CHOICE:
+            case HTTP_MOVED_PERM:
+            case HTTP_NOT_FOUND:
+            case HTTP_BAD_METHOD:
+            case HTTP_GONE:
+            case HTTP_REQ_TOO_LONG:
+            case HTTP_NOT_IMPLEMENTED:
+            case StatusLine.HTTP_PERM_REDIRECT:
+                // These codes can be cached unless headers forbid it.
+                break;
+
+            case HTTP_MOVED_TEMP:
+            case StatusLine.HTTP_TEMP_REDIRECT:
+                // These codes can only be cached with the right response headers.
+                // http://tools.ietf.org/html/rfc7234#section-3
+                // s-maxage is not checked because OkHttp is a private cache that should ignore s-maxage.
+                if (response.header("Expires") != null
+                        || response.cacheControl().maxAgeSeconds() != -1
+                        || response.cacheControl().isPublic()
+                        || response.cacheControl().isPrivate()) {
+                    break;
+                }
+                // Fall-through.
+
+            default:
+                // All other codes cannot be cached.
+                return false;
         }
-      }
+
+        // A 'no-store' directive on request or response prevents the response from being cached.
+        return !response.cacheControl().noStore() && !request.cacheControl().noStore();
     }
 
-    /**
-     * Returns a strategy to satisfy {@code request} using the a cached response {@code response}.
-     */
-    public CacheStrategy get() {
-      CacheStrategy candidate = getCandidate();
+    public static class Factory {
+        final long nowMillis;
+        final Request request;
+        final Response cacheResponse;
+
+        /**
+         * The server's time when the cached response was served, if known.
+         */
+        private Date servedDate;
+        private String servedDateString;
+
+        /**
+         * The last modified date of the cached response, if known.
+         */
+        private Date lastModified;
+        private String lastModifiedString;
+
+        /**
+         * The expiration date of the cached response, if known. If both this field and the max age are
+         * set, the max age is preferred.
+         */
+        private Date expires;
+
+        /**
+         * Extension header set by OkHttp specifying the timestamp when the cached HTTP request was
+         * first initiated.
+         */
+        private long sentRequestMillis;
+
+        /**
+         * Extension header set by OkHttp specifying the timestamp when the cached HTTP response was
+         * first received.
+         */
+        private long receivedResponseMillis;
+
+        /**
+         * Etag of the cached response.
+         */
+        private String etag;
+
+        /**
+         * Age of the cached response.
+         */
+        private int ageSeconds = -1;
+
+        public Factory(long nowMillis, Request request, Response cacheResponse) {
+            this.nowMillis = nowMillis;
+            this.request = request;
+            this.cacheResponse = cacheResponse;
+
+            if (cacheResponse != null) {// 缓存不为空，获取之前的缓存时间信息
+                this.sentRequestMillis = cacheResponse.sentRequestAtMillis();
+                this.receivedResponseMillis = cacheResponse.receivedResponseAtMillis();
+                Headers headers = cacheResponse.headers();
+                for (int i = 0, size = headers.size(); i < size; i++) {
+                    String fieldName = headers.name(i);
+                    String value = headers.value(i);
+                    if ("Date".equalsIgnoreCase(fieldName)) {
+                        servedDate = HttpDate.parse(value);
+                        servedDateString = value;
+                    } else if ("Expires".equalsIgnoreCase(fieldName)) {
+                        expires = HttpDate.parse(value);
+                    } else if ("Last-Modified".equalsIgnoreCase(fieldName)) {
+                        lastModified = HttpDate.parse(value);
+                        lastModifiedString = value;
+                    } else if ("ETag".equalsIgnoreCase(fieldName)) {
+                        etag = value;
+                    } else if ("Age".equalsIgnoreCase(fieldName)) {
+                        ageSeconds = HttpHeaders.parseSeconds(value, -1);
+                    }
+                }
+            }
+        }
 
-      if (candidate.networkRequest != null && request.cacheControl().onlyIfCached()) {
-        // We're forbidden from using the network and the cache is insufficient.
-        return new CacheStrategy(null, null);
-      }
+        /**
+         * Returns a strategy to satisfy {@code request} using the a cached response {@code response}.
+         */
+        public CacheStrategy get() {
+            CacheStrategy candidate = getCandidate();
 
-      return candidate;
-    }
+            if (candidate.networkRequest != null && request.cacheControl().onlyIfCached()) {
+                // We're forbidden from using the network and the cache is insufficient.
+                return new CacheStrategy(null, null);
+            }
 
-    /** Returns a strategy to use assuming the request can use the network. */
-    private CacheStrategy getCandidate() {
-      // No cached response.
-      if (cacheResponse == null) {
-        return new CacheStrategy(request, null);
-      }
-
-      // Drop the cached response if it's missing a required handshake.
-      if (request.isHttps() && cacheResponse.handshake() == null) {
-        return new CacheStrategy(request, null);
-      }
-
-      // If this response shouldn't have been stored, it should never be used
-      // as a response source. This check should be redundant as long as the
-      // persistence store is well-behaved and the rules are constant.
-      if (!isCacheable(cacheResponse, request)) {
-        return new CacheStrategy(request, null);
-      }
-
-      CacheControl requestCaching = request.cacheControl();
-      if (requestCaching.noCache() || hasConditions(request)) {
-        return new CacheStrategy(request, null);
-      }
-
-      long ageMillis = cacheResponseAge();
-      long freshMillis = computeFreshnessLifetime();
-
-      if (requestCaching.maxAgeSeconds() != -1) {
-        freshMillis = Math.min(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds()));
-      }
-
-      long minFreshMillis = 0;
-      if (requestCaching.minFreshSeconds() != -1) {
-        minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds());
-      }
-
-      long maxStaleMillis = 0;
-      CacheControl responseCaching = cacheResponse.cacheControl();
-      if (!responseCaching.mustRevalidate() && requestCaching.maxStaleSeconds() != -1) {
-        maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds());
-      }
-
-      if (!responseCaching.noCache() && ageMillis + minFreshMillis < freshMillis + maxStaleMillis) {
-        Response.Builder builder = cacheResponse.newBuilder();
-        if (ageMillis + minFreshMillis >= freshMillis) {
-          builder.addHeader("Warning", "110 HttpURLConnection \"Response is stale\"");
+            return candidate;
         }
-        long oneDayMillis = 24 * 60 * 60 * 1000L;
-        if (ageMillis > oneDayMillis && isFreshnessLifetimeHeuristic()) {
-          builder.addHeader("Warning", "113 HttpURLConnection \"Heuristic expiration\"");
+
+        /**
+         * Returns a strategy to use assuming the request can use the network.
+         * 根据不同情况构建不同的缓存策略
+         */
+        private CacheStrategy getCandidate() {
+            // No cached response.
+            if (cacheResponse == null) {
+                return new CacheStrategy(request, null);
+            }
+
+            // Drop the cached response if it's missing a required handshake.
+            if (request.isHttps() && cacheResponse.handshake() == null) {
+                return new CacheStrategy(request, null);
+            }
+
+            // If this response shouldn't have been stored, it should never be used
+            // as a response source. This check should be redundant as long as the
+            // persistence store is well-behaved and the rules are constant.
+            if (!isCacheable(cacheResponse, request)) {
+                return new CacheStrategy(request, null);
+            }
+
+            CacheControl requestCaching = request.cacheControl();
+            if (requestCaching.noCache() || hasConditions(request)) {
+                return new CacheStrategy(request, null);
+            }
+
+            long ageMillis = cacheResponseAge();
+            long freshMillis = computeFreshnessLifetime();
+
+            if (requestCaching.maxAgeSeconds() != -1) {
+                freshMillis = Math.min(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds()));
+            }
+
+            long minFreshMillis = 0;
+            if (requestCaching.minFreshSeconds() != -1) {
+                minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds());
+            }
+
+            long maxStaleMillis = 0;
+            CacheControl responseCaching = cacheResponse.cacheControl();
+            if (!responseCaching.mustRevalidate() && requestCaching.maxStaleSeconds() != -1) {
+                maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds());
+            }
+
+            if (!responseCaching.noCache() && ageMillis + minFreshMillis < freshMillis + maxStaleMillis) {
+                Response.Builder builder = cacheResponse.newBuilder();
+                if (ageMillis + minFreshMillis >= freshMillis) {
+                    builder.addHeader("Warning", "110 HttpURLConnection \"Response is stale\"");
+                }
+                long oneDayMillis = 24 * 60 * 60 * 1000L;
+                if (ageMillis > oneDayMillis && isFreshnessLifetimeHeuristic()) {
+                    builder.addHeader("Warning", "113 HttpURLConnection \"Heuristic expiration\"");
+                }
+                return new CacheStrategy(null, builder.build());
+            }
+
+            // Find a condition to add to the request. If the condition is satisfied, the response body
+            // will not be transmitted.
+            String conditionName;
+            String conditionValue;
+            if (etag != null) {
+                conditionName = "If-None-Match";
+                conditionValue = etag;
+            } else if (lastModified != null) {
+                conditionName = "If-Modified-Since";
+                conditionValue = lastModifiedString;
+            } else if (servedDate != null) {
+                conditionName = "If-Modified-Since";
+                conditionValue = servedDateString;
+            } else {
+                return new CacheStrategy(request, null); // No condition! Make a regular request.
+            }
+
+            Headers.Builder conditionalRequestHeaders = request.headers().newBuilder();
+            Internal.instance.addLenient(conditionalRequestHeaders, conditionName, conditionValue);
+
+            Request conditionalRequest = request.newBuilder()
+                    .headers(conditionalRequestHeaders.build())
+                    .build();
+            return new CacheStrategy(conditionalRequest, cacheResponse);
         }
-        return new CacheStrategy(null, builder.build());
-      }
-
-      // Find a condition to add to the request. If the condition is satisfied, the response body
-      // will not be transmitted.
-      String conditionName;
-      String conditionValue;
-      if (etag != null) {
-        conditionName = "If-None-Match";
-        conditionValue = etag;
-      } else if (lastModified != null) {
-        conditionName = "If-Modified-Since";
-        conditionValue = lastModifiedString;
-      } else if (servedDate != null) {
-        conditionName = "If-Modified-Since";
-        conditionValue = servedDateString;
-      } else {
-        return new CacheStrategy(request, null); // No condition! Make a regular request.
-      }
-
-      Headers.Builder conditionalRequestHeaders = request.headers().newBuilder();
-      Internal.instance.addLenient(conditionalRequestHeaders, conditionName, conditionValue);
-
-      Request conditionalRequest = request.newBuilder()
-          .headers(conditionalRequestHeaders.build())
-          .build();
-      return new CacheStrategy(conditionalRequest, cacheResponse);
-    }
 
-    /**
-     * Returns the number of milliseconds that the response was fresh for, starting from the served
-     * date.
-     */
-    private long computeFreshnessLifetime() {
-      CacheControl responseCaching = cacheResponse.cacheControl();
-      if (responseCaching.maxAgeSeconds() != -1) {
-        return SECONDS.toMillis(responseCaching.maxAgeSeconds());
-      } else if (expires != null) {
-        long servedMillis = servedDate != null
-            ? servedDate.getTime()
-            : receivedResponseMillis;
-        long delta = expires.getTime() - servedMillis;
-        return delta > 0 ? delta : 0;
-      } else if (lastModified != null
-          && cacheResponse.request().url().query() == null) {
-        // As recommended by the HTTP RFC and implemented in Firefox, the
-        // max age of a document should be defaulted to 10% of the
-        // document's age at the time it was served. Default expiration
-        // dates aren't used for URIs containing a query.
-        long servedMillis = servedDate != null
-            ? servedDate.getTime()
-            : sentRequestMillis;
-        long delta = servedMillis - lastModified.getTime();
-        return delta > 0 ? (delta / 10) : 0;
-      }
-      return 0;
-    }
+        /**
+         * Returns the number of milliseconds that the response was fresh for, starting from the served
+         * date.
+         */
+        private long computeFreshnessLifetime() {
+            CacheControl responseCaching = cacheResponse.cacheControl();
+            if (responseCaching.maxAgeSeconds() != -1) {
+                return SECONDS.toMillis(responseCaching.maxAgeSeconds());
+            } else if (expires != null) {
+                long servedMillis = servedDate != null
+                        ? servedDate.getTime()
+                        : receivedResponseMillis;
+                long delta = expires.getTime() - servedMillis;
+                return delta > 0 ? delta : 0;
+            } else if (lastModified != null
+                    && cacheResponse.request().url().query() == null) {
+                // As recommended by the HTTP RFC and implemented in Firefox, the
+                // max age of a document should be defaulted to 10% of the
+                // document's age at the time it was served. Default expiration
+                // dates aren't used for URIs containing a query.
+                long servedMillis = servedDate != null
+                        ? servedDate.getTime()
+                        : sentRequestMillis;
+                long delta = servedMillis - lastModified.getTime();
+                return delta > 0 ? (delta / 10) : 0;
+            }
+            return 0;
+        }
 
-    /**
-     * Returns the current age of the response, in milliseconds. The calculation is specified by RFC
-     * 2616, 13.2.3 Age Calculations.
-     */
-    private long cacheResponseAge() {
-      long apparentReceivedAge = servedDate != null
-          ? Math.max(0, receivedResponseMillis - servedDate.getTime())
-          : 0;
-      long receivedAge = ageSeconds != -1
-          ? Math.max(apparentReceivedAge, SECONDS.toMillis(ageSeconds))
-          : apparentReceivedAge;
-      long responseDuration = receivedResponseMillis - sentRequestMillis;
-      long residentDuration = nowMillis - receivedResponseMillis;
-      return receivedAge + responseDuration + residentDuration;
-    }
+        /**
+         * Returns the current age of the response, in milliseconds. The calculation is specified by RFC
+         * 2616, 13.2.3 Age Calculations.
+         */
+        private long cacheResponseAge() {
+            long apparentReceivedAge = servedDate != null
+                    ? Math.max(0, receivedResponseMillis - servedDate.getTime())
+                    : 0;
+            long receivedAge = ageSeconds != -1
+                    ? Math.max(apparentReceivedAge, SECONDS.toMillis(ageSeconds))
+                    : apparentReceivedAge;
+            long responseDuration = receivedResponseMillis - sentRequestMillis;
+            long residentDuration = nowMillis - receivedResponseMillis;
+            return receivedAge + responseDuration + residentDuration;
+        }
 
-    /**
-     * Returns true if computeFreshnessLifetime used a heuristic. If we used a heuristic to serve a
-     * cached response older than 24 hours, we are required to attach a warning.
-     */
-    private boolean isFreshnessLifetimeHeuristic() {
-      return cacheResponse.cacheControl().maxAgeSeconds() == -1 && expires == null;
-    }
+        /**
+         * Returns true if computeFreshnessLifetime used a heuristic. If we used a heuristic to serve a
+         * cached response older than 24 hours, we are required to attach a warning.
+         */
+        private boolean isFreshnessLifetimeHeuristic() {
+            return cacheResponse.cacheControl().maxAgeSeconds() == -1 && expires == null;
+        }
 
-    /**
-     * Returns true if the request contains conditions that save the server from sending a response
-     * that the client has locally. When a request is enqueued with its own conditions, the built-in
-     * response cache won't be used.
-     */
-    private static boolean hasConditions(Request request) {
-      return request.header("If-Modified-Since") != null || request.header("If-None-Match") != null;
+        /**
+         * Returns true if the request contains conditions that save the server from sending a response
+         * that the client has locally. When a request is enqueued with its own conditions, the built-in
+         * response cache won't be used.
+         */
+        private static boolean hasConditions(Request request) {
+            return request.header("If-Modified-Since") != null || request.header("If-None-Match") != null;
+        }
     }
-  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/ConnectInterceptor.java b/okhttp/src/main/java/okhttp3/internal/connection/ConnectInterceptor.java
index cabd065813..90d38e40d9 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/ConnectInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/ConnectInterceptor.java
@@ -17,6 +17,7 @@
 package okhttp3.internal.connection;
 
 import java.io.IOException;
+
 import okhttp3.Interceptor;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
@@ -24,24 +25,27 @@
 import okhttp3.internal.http.HttpCodec;
 import okhttp3.internal.http.RealInterceptorChain;
 
-/** Opens a connection to the target server and proceeds to the next interceptor. */
+/**
+ * Opens a connection to the target server and proceeds to the next interceptor.
+ */
 public final class ConnectInterceptor implements Interceptor {
-  public final OkHttpClient client;
-
-  public ConnectInterceptor(OkHttpClient client) {
-    this.client = client;
-  }
+    public final OkHttpClient client;
 
-  @Override public Response intercept(Chain chain) throws IOException {
-    RealInterceptorChain realChain = (RealInterceptorChain) chain;
-    Request request = realChain.request();
-    StreamAllocation streamAllocation = realChain.streamAllocation();
+    public ConnectInterceptor(OkHttpClient client) {
+        this.client = client;
+    }
 
-    // We need the network to satisfy this request. Possibly for validating a conditional GET.
-    boolean doExtensiveHealthChecks = !request.method().equals("GET");
-    HttpCodec httpCodec = streamAllocation.newStream(client, doExtensiveHealthChecks);
-    RealConnection connection = streamAllocation.connection();
+    @Override
+    public Response intercept(Chain chain) throws IOException {
+        RealInterceptorChain realChain = (RealInterceptorChain) chain;
+        Request request = realChain.request();
+        StreamAllocation streamAllocation = realChain.streamAllocation();
 
-    return realChain.proceed(request, streamAllocation, httpCodec, connection);
-  }
+        // We need the network to satisfy this request. Possibly for validating a conditional GET.
+        boolean doExtensiveHealthChecks = !request.method().equals("GET");
+        HttpCodec httpCodec = streamAllocation.newStream(client, doExtensiveHealthChecks);
+        RealConnection connection = streamAllocation.connection();
+        // 如果没有用户自定义的网络拦截器，则转入CallServerInterceptor
+        return realChain.proceed(request, streamAllocation, httpCodec, connection);
+    }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java b/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
index 6ed7806c45..799f4cc526 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
@@ -29,9 +29,11 @@
 import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.TimeUnit;
+
 import javax.net.ssl.SSLPeerUnverifiedException;
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
+
 import okhttp3.Address;
 import okhttp3.CertificatePinner;
 import okhttp3.Connection;
@@ -66,424 +68,455 @@
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static okhttp3.internal.Util.closeQuietly;
 
+// TODO: 17/9/7 连接逻辑分析
 public final class RealConnection extends Http2Connection.Listener implements Connection {
-  private final ConnectionPool connectionPool;
-  private final Route route;
-
-  // The fields below are initialized by connect() and never reassigned.
-
-  /** The low-level TCP socket. */
-  private Socket rawSocket;
-
-  /**
-   * The application layer socket. Either an {@link SSLSocket} layered over {@link #rawSocket}, or
-   * {@link #rawSocket} itself if this connection does not use SSL.
-   */
-  private Socket socket;
-  private Handshake handshake;
-  private Protocol protocol;
-  private Http2Connection http2Connection;
-  private BufferedSource source;
-  private BufferedSink sink;
-
-  // The fields below track connection state and are guarded by connectionPool.
-
-  /** If true, no new streams can be created on this connection. Once true this is always true. */
-  public boolean noNewStreams;
-
-  public int successCount;
-
-  /**
-   * The maximum number of concurrent streams that can be carried by this connection. If {@code
-   * allocations.size() < allocationLimit} then new streams can be created on this connection.
-   */
-  public int allocationLimit = 1;
-
-  /** Current streams carried by this connection. */
-  public final List<Reference<StreamAllocation>> allocations = new ArrayList<>();
-
-  /** Nanotime timestamp when {@code allocations.size()} reached zero. */
-  public long idleAtNanos = Long.MAX_VALUE;
-
-  public RealConnection(ConnectionPool connectionPool, Route route) {
-    this.connectionPool = connectionPool;
-    this.route = route;
-  }
-
-  public static RealConnection testConnection(
-      ConnectionPool connectionPool, Route route, Socket socket, long idleAtNanos) {
-    RealConnection result = new RealConnection(connectionPool, route);
-    result.socket = socket;
-    result.idleAtNanos = idleAtNanos;
-    return result;
-  }
-
-  public void connect(
-      int connectTimeout, int readTimeout, int writeTimeout, boolean connectionRetryEnabled) {
-    if (protocol != null) throw new IllegalStateException("already connected");
-
-    RouteException routeException = null;
-    List<ConnectionSpec> connectionSpecs = route.address().connectionSpecs();
-    ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);
-
-    if (route.address().sslSocketFactory() == null) {
-      if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {
-        throw new RouteException(new UnknownServiceException(
-            "CLEARTEXT communication not enabled for client"));
-      }
-      String host = route.address().url().host();
-      if (!Platform.get().isCleartextTrafficPermitted(host)) {
-        throw new RouteException(new UnknownServiceException(
-            "CLEARTEXT communication to " + host + " not permitted by network security policy"));
-      }
+    private final ConnectionPool connectionPool;
+    private final Route route;
+
+    // The fields below are initialized by connect() and never reassigned.
+
+    /**
+     * The low-level TCP socket.
+     */
+    private Socket rawSocket;
+
+    /**
+     * The application layer socket. Either an {@link SSLSocket} layered over {@link #rawSocket}, or
+     * {@link #rawSocket} itself if this connection does not use SSL.
+     */
+    private Socket socket;
+    private Handshake handshake;
+    private Protocol protocol;
+    private Http2Connection http2Connection;
+    private BufferedSource source;
+    private BufferedSink sink;
+
+    // The fields below track connection state and are guarded by connectionPool.
+
+    /**
+     * If true, no new streams can be created on this connection. Once true this is always true.
+     */
+    public boolean noNewStreams;// 一旦为true，就永远为true
+
+    public int successCount;
+
+    /**
+     * The maximum number of concurrent streams that can be carried by this connection. If {@code
+     * allocations.size() < allocationLimit} then new streams can be created on this connection.
+     */
+    public int allocationLimit = 1;
+
+    /**
+     * Current streams carried by this connection.
+     */
+    public final List<Reference<StreamAllocation>> allocations = new ArrayList<>();
+
+    /**
+     * Nanotime timestamp when {@code allocations.size()} reached zero.
+     */
+    public long idleAtNanos = Long.MAX_VALUE;// 空闲开始的时间
+
+    public RealConnection(ConnectionPool connectionPool, Route route) {
+        this.connectionPool = connectionPool;
+        this.route = route;
     }
 
-    while (true) {
-      try {
-        if (route.requiresTunnel()) {
-          connectTunnel(connectTimeout, readTimeout, writeTimeout);
-        } else {
-          connectSocket(connectTimeout, readTimeout);
+    public static RealConnection testConnection(
+            ConnectionPool connectionPool, Route route, Socket socket, long idleAtNanos) {
+        RealConnection result = new RealConnection(connectionPool, route);
+        result.socket = socket;
+        result.idleAtNanos = idleAtNanos;
+        return result;
+    }
+
+    public void connect(
+            int connectTimeout, int readTimeout, int writeTimeout, boolean connectionRetryEnabled) {
+        if (protocol != null) throw new IllegalStateException("already connected");
+
+        RouteException routeException = null;
+        List<ConnectionSpec> connectionSpecs = route.address().connectionSpecs();
+        ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);
+
+        if (route.address().sslSocketFactory() == null) {
+            if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {
+                throw new RouteException(new UnknownServiceException(
+                        "CLEARTEXT communication not enabled for client"));
+            }
+            String host = route.address().url().host();
+            if (!Platform.get().isCleartextTrafficPermitted(host)) {
+                throw new RouteException(new UnknownServiceException(
+                        "CLEARTEXT communication to " + host + " not permitted by network security policy"));
+            }
         }
-        establishProtocol(connectionSpecSelector);
-        break;
-      } catch (IOException e) {
-        closeQuietly(socket);
-        closeQuietly(rawSocket);
-        socket = null;
-        rawSocket = null;
-        source = null;
-        sink = null;
-        handshake = null;
-        protocol = null;
-        http2Connection = null;
-
-        if (routeException == null) {
-          routeException = new RouteException(e);
-        } else {
-          routeException.addConnectException(e);
+
+        while (true) {
+            try {
+                // 最终都走了connectSocket
+                if (route.requiresTunnel()) {
+                    connectTunnel(connectTimeout, readTimeout, writeTimeout);
+                } else {
+                    connectSocket(connectTimeout, readTimeout);
+                }
+                establishProtocol(connectionSpecSelector);
+                break;
+            } catch (IOException e) {
+                closeQuietly(socket);
+                closeQuietly(rawSocket);
+                socket = null;
+                rawSocket = null;
+                source = null;
+                sink = null;
+                handshake = null;
+                protocol = null;
+                http2Connection = null;
+
+                if (routeException == null) {
+                    routeException = new RouteException(e);
+                } else {
+                    routeException.addConnectException(e);
+                }
+
+                if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {
+                    throw routeException;
+                }
+            }
+        }
+
+        if (http2Connection != null) {
+            synchronized (connectionPool) {
+                allocationLimit = http2Connection.maxConcurrentStreams();
+            }
         }
+    }
 
-        if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {
-          throw routeException;
+    /**
+     * Does all the work to build an HTTPS connection over a proxy tunnel. The catch here is that a
+     * proxy server can issue an auth challenge and then close the connection.
+     */
+    private void connectTunnel(int connectTimeout, int readTimeout, int writeTimeout)
+            throws IOException {
+        Request tunnelRequest = createTunnelRequest();
+        HttpUrl url = tunnelRequest.url();
+        int attemptedConnections = 0;
+        int maxAttempts = 21;
+        while (true) {
+            if (++attemptedConnections > maxAttempts) {
+                throw new ProtocolException("Too many tunnel connections attempted: " + maxAttempts);
+            }
+
+            connectSocket(connectTimeout, readTimeout);
+            tunnelRequest = createTunnel(readTimeout, writeTimeout, tunnelRequest, url);
+
+            if (tunnelRequest == null) break; // Tunnel successfully created.
+
+            // The proxy decided to close the connection after an auth challenge. We need to create a new
+            // connection, but this time with the auth credentials.
+            closeQuietly(rawSocket);
+            rawSocket = null;
+            sink = null;
+            source = null;
         }
-      }
     }
 
-    if (http2Connection != null) {
-      synchronized (connectionPool) {
-        allocationLimit = http2Connection.maxConcurrentStreams();
-      }
+    /**
+     * Does all the work necessary to build a full HTTP or HTTPS connection on a raw socket.
+     */
+    private void connectSocket(int connectTimeout, int readTimeout) throws IOException {
+        Proxy proxy = route.proxy();
+        Address address = route.address();
+
+        rawSocket = proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP
+                ? address.socketFactory().createSocket()
+                : new Socket(proxy);
+
+        rawSocket.setSoTimeout(readTimeout);
+        try {
+            Platform.get().connectSocket(rawSocket, route.socketAddress(), connectTimeout);
+        } catch (ConnectException e) {
+            ConnectException ce = new ConnectException("Failed to connect to " + route.socketAddress());
+            ce.initCause(e);
+            throw ce;
+        }
+        // 输入输出流
+        source = Okio.buffer(Okio.source(rawSocket));// 输入
+        sink = Okio.buffer(Okio.sink(rawSocket));// 输出
+    }
+
+    private void establishProtocol(ConnectionSpecSelector connectionSpecSelector) throws IOException {
+        if (route.address().sslSocketFactory() == null) {
+            protocol = Protocol.HTTP_1_1;
+            socket = rawSocket;
+            return;
+        }
+
+        connectTls(connectionSpecSelector);
+
+        if (protocol == Protocol.HTTP_2) {
+            socket.setSoTimeout(0); // Framed connection timeouts are set per-stream.
+            // http2Connection 唯一赋值处
+            http2Connection = new Http2Connection.Builder(true)
+                    .socket(socket, route.address().url().host(), source, sink)
+                    .listener(this)
+                    .build();
+            http2Connection.start();
+        }
+    }
+
+    private void connectTls(ConnectionSpecSelector connectionSpecSelector) throws IOException {
+        Address address = route.address();
+        SSLSocketFactory sslSocketFactory = address.sslSocketFactory();
+        boolean success = false;
+        SSLSocket sslSocket = null;
+        try {
+            // Create the wrapper over the connected socket.
+            sslSocket = (SSLSocket) sslSocketFactory.createSocket(
+                    rawSocket, address.url().host(), address.url().port(), true /* autoClose */);
+
+            // Configure the socket's ciphers, TLS versions, and extensions.
+            ConnectionSpec connectionSpec = connectionSpecSelector.configureSecureSocket(sslSocket);
+            if (connectionSpec.supportsTlsExtensions()) {
+                Platform.get().configureTlsExtensions(
+                        sslSocket, address.url().host(), address.protocols());
+            }
+
+            // Force handshake. This can throw!
+            sslSocket.startHandshake();
+            Handshake unverifiedHandshake = Handshake.get(sslSocket.getSession());
+
+            // Verify that the socket's certificates are acceptable for the target host.
+            if (!address.hostnameVerifier().verify(address.url().host(), sslSocket.getSession())) {
+                X509Certificate cert = (X509Certificate) unverifiedHandshake.peerCertificates().get(0);
+                throw new SSLPeerUnverifiedException("Hostname " + address.url().host() + " not verified:"
+                        + "\n    certificate: " + CertificatePinner.pin(cert)
+                        + "\n    DN: " + cert.getSubjectDN().getName()
+                        + "\n    subjectAltNames: " + OkHostnameVerifier.allSubjectAltNames(cert));
+            }
+
+            // Check that the certificate pinner is satisfied by the certificates presented.
+            address.certificatePinner().check(address.url().host(),
+                    unverifiedHandshake.peerCertificates());
+
+            // Success! Save the handshake and the ALPN protocol.
+            String maybeProtocol = connectionSpec.supportsTlsExtensions()
+                    ? Platform.get().getSelectedProtocol(sslSocket)
+                    : null;
+            socket = sslSocket;
+            source = Okio.buffer(Okio.source(socket));
+            sink = Okio.buffer(Okio.sink(socket));
+            handshake = unverifiedHandshake;
+            protocol = maybeProtocol != null
+                    ? Protocol.get(maybeProtocol)
+                    : Protocol.HTTP_1_1;
+            success = true;
+        } catch (AssertionError e) {
+            if (Util.isAndroidGetsocknameError(e)) throw new IOException(e);
+            throw e;
+        } finally {
+            if (sslSocket != null) {
+                Platform.get().afterHandshake(sslSocket);
+            }
+            if (!success) {
+                closeQuietly(sslSocket);
+            }
+        }
     }
-  }
-
-  /**
-   * Does all the work to build an HTTPS connection over a proxy tunnel. The catch here is that a
-   * proxy server can issue an auth challenge and then close the connection.
-   */
-  private void connectTunnel(int connectTimeout, int readTimeout, int writeTimeout)
-      throws IOException {
-    Request tunnelRequest = createTunnelRequest();
-    HttpUrl url = tunnelRequest.url();
-    int attemptedConnections = 0;
-    int maxAttempts = 21;
-    while (true) {
-      if (++attemptedConnections > maxAttempts) {
-        throw new ProtocolException("Too many tunnel connections attempted: " + maxAttempts);
-      }
-
-      connectSocket(connectTimeout, readTimeout);
-      tunnelRequest = createTunnel(readTimeout, writeTimeout, tunnelRequest, url);
-
-      if (tunnelRequest == null) break; // Tunnel successfully created.
-
-      // The proxy decided to close the connection after an auth challenge. We need to create a new
-      // connection, but this time with the auth credentials.
-      closeQuietly(rawSocket);
-      rawSocket = null;
-      sink = null;
-      source = null;
+
+    /**
+     * To make an HTTPS connection over an HTTP proxy, send an unencrypted CONNECT request to create
+     * the proxy connection. This may need to be retried if the proxy requires authorization.
+     */
+    private Request createTunnel(int readTimeout, int writeTimeout, Request tunnelRequest,
+                                 HttpUrl url) throws IOException {
+        // Make an SSL Tunnel on the first message pair of each SSL + proxy connection.
+        String requestLine = "CONNECT " + Util.hostHeader(url, true) + " HTTP/1.1";
+        while (true) {
+            Http1Codec tunnelConnection = new Http1Codec(null, null, source, sink);
+            source.timeout().timeout(readTimeout, MILLISECONDS);
+            sink.timeout().timeout(writeTimeout, MILLISECONDS);
+            tunnelConnection.writeRequest(tunnelRequest.headers(), requestLine);
+            tunnelConnection.finishRequest();
+            Response response = tunnelConnection.readResponseHeaders(false)
+                    .request(tunnelRequest)
+                    .build();
+            // The response body from a CONNECT should be empty, but if it is not then we should consume
+            // it before proceeding.
+            long contentLength = HttpHeaders.contentLength(response);
+            if (contentLength == -1L) {
+                contentLength = 0L;
+            }
+            Source body = tunnelConnection.newFixedLengthSource(contentLength);
+            Util.skipAll(body, Integer.MAX_VALUE, TimeUnit.MILLISECONDS);
+            body.close();
+
+            switch (response.code()) {
+                case HTTP_OK:
+                    // Assume the server won't send a TLS ServerHello until we send a TLS ClientHello. If
+                    // that happens, then we will have buffered bytes that are needed by the SSLSocket!
+                    // This check is imperfect: it doesn't tell us whether a handshake will succeed, just
+                    // that it will almost certainly fail because the proxy has sent unexpected data.
+                    if (!source.buffer().exhausted() || !sink.buffer().exhausted()) {
+                        throw new IOException("TLS tunnel buffered too many bytes!");
+                    }
+                    return null;
+
+                case HTTP_PROXY_AUTH:
+                    tunnelRequest = route.address().proxyAuthenticator().authenticate(route, response);
+                    if (tunnelRequest == null)
+                        throw new IOException("Failed to authenticate with proxy");
+
+                    if ("close".equalsIgnoreCase(response.header("Connection"))) {
+                        return tunnelRequest;
+                    }
+                    break;
+
+                default:
+                    throw new IOException(
+                            "Unexpected response code for CONNECT: " + response.code());
+            }
+        }
     }
-  }
-
-  /** Does all the work necessary to build a full HTTP or HTTPS connection on a raw socket. */
-  private void connectSocket(int connectTimeout, int readTimeout) throws IOException {
-    Proxy proxy = route.proxy();
-    Address address = route.address();
-
-    rawSocket = proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP
-        ? address.socketFactory().createSocket()
-        : new Socket(proxy);
-
-    rawSocket.setSoTimeout(readTimeout);
-    try {
-      Platform.get().connectSocket(rawSocket, route.socketAddress(), connectTimeout);
-    } catch (ConnectException e) {
-      ConnectException ce = new ConnectException("Failed to connect to " + route.socketAddress());
-      ce.initCause(e);
-      throw ce;
+
+    /**
+     * Returns a request that creates a TLS tunnel via an HTTP proxy. Everything in the tunnel request
+     * is sent unencrypted to the proxy server, so tunnels include only the minimum set of headers.
+     * This avoids sending potentially sensitive data like HTTP cookies to the proxy unencrypted.
+     */
+    private Request createTunnelRequest() {
+        return new Request.Builder()
+                .url(route.address().url())
+                .header("Host", Util.hostHeader(route.address().url(), true))
+                .header("Proxy-Connection", "Keep-Alive") // For HTTP/1.0 proxies like Squid.
+                .header("User-Agent", Version.userAgent())
+                .build();
     }
-    source = Okio.buffer(Okio.source(rawSocket));
-    sink = Okio.buffer(Okio.sink(rawSocket));
-  }
-
-  private void establishProtocol(ConnectionSpecSelector connectionSpecSelector) throws IOException {
-    if (route.address().sslSocketFactory() == null) {
-      protocol = Protocol.HTTP_1_1;
-      socket = rawSocket;
-      return;
+
+    /**
+     * Returns true if this connection can carry a stream allocation to {@code address}.
+     */
+    public boolean isEligible(Address address) {
+        return allocations.size() < allocationLimit
+                && address.equals(route().address())
+                && !noNewStreams;
     }
 
-    connectTls(connectionSpecSelector);
+    public HttpCodec newCodec(
+            OkHttpClient client, StreamAllocation streamAllocation) throws SocketException {
+        if (http2Connection != null) {
+            return new Http2Codec(client, streamAllocation, http2Connection);
+        } else {
+            socket.setSoTimeout(client.readTimeoutMillis());
+            source.timeout().timeout(client.readTimeoutMillis(), MILLISECONDS);
+            sink.timeout().timeout(client.writeTimeoutMillis(), MILLISECONDS);
+            return new Http1Codec(client, streamAllocation, source, sink);
+        }
+    }
 
-    if (protocol == Protocol.HTTP_2) {
-      socket.setSoTimeout(0); // Framed connection timeouts are set per-stream.
-      http2Connection = new Http2Connection.Builder(true)
-          .socket(socket, route.address().url().host(), source, sink)
-          .listener(this)
-          .build();
-      http2Connection.start();
+    public RealWebSocket.Streams newWebSocketStreams(final StreamAllocation streamAllocation) {
+        return new RealWebSocket.Streams(true, source, sink) {
+            @Override
+            public void close() throws IOException {
+                streamAllocation.streamFinished(true, streamAllocation.codec());
+            }
+        };
     }
-  }
-
-  private void connectTls(ConnectionSpecSelector connectionSpecSelector) throws IOException {
-    Address address = route.address();
-    SSLSocketFactory sslSocketFactory = address.sslSocketFactory();
-    boolean success = false;
-    SSLSocket sslSocket = null;
-    try {
-      // Create the wrapper over the connected socket.
-      sslSocket = (SSLSocket) sslSocketFactory.createSocket(
-          rawSocket, address.url().host(), address.url().port(), true /* autoClose */);
-
-      // Configure the socket's ciphers, TLS versions, and extensions.
-      ConnectionSpec connectionSpec = connectionSpecSelector.configureSecureSocket(sslSocket);
-      if (connectionSpec.supportsTlsExtensions()) {
-        Platform.get().configureTlsExtensions(
-            sslSocket, address.url().host(), address.protocols());
-      }
-
-      // Force handshake. This can throw!
-      sslSocket.startHandshake();
-      Handshake unverifiedHandshake = Handshake.get(sslSocket.getSession());
-
-      // Verify that the socket's certificates are acceptable for the target host.
-      if (!address.hostnameVerifier().verify(address.url().host(), sslSocket.getSession())) {
-        X509Certificate cert = (X509Certificate) unverifiedHandshake.peerCertificates().get(0);
-        throw new SSLPeerUnverifiedException("Hostname " + address.url().host() + " not verified:"
-            + "\n    certificate: " + CertificatePinner.pin(cert)
-            + "\n    DN: " + cert.getSubjectDN().getName()
-            + "\n    subjectAltNames: " + OkHostnameVerifier.allSubjectAltNames(cert));
-      }
-
-      // Check that the certificate pinner is satisfied by the certificates presented.
-      address.certificatePinner().check(address.url().host(),
-          unverifiedHandshake.peerCertificates());
-
-      // Success! Save the handshake and the ALPN protocol.
-      String maybeProtocol = connectionSpec.supportsTlsExtensions()
-          ? Platform.get().getSelectedProtocol(sslSocket)
-          : null;
-      socket = sslSocket;
-      source = Okio.buffer(Okio.source(socket));
-      sink = Okio.buffer(Okio.sink(socket));
-      handshake = unverifiedHandshake;
-      protocol = maybeProtocol != null
-          ? Protocol.get(maybeProtocol)
-          : Protocol.HTTP_1_1;
-      success = true;
-    } catch (AssertionError e) {
-      if (Util.isAndroidGetsocknameError(e)) throw new IOException(e);
-      throw e;
-    } finally {
-      if (sslSocket != null) {
-        Platform.get().afterHandshake(sslSocket);
-      }
-      if (!success) {
-        closeQuietly(sslSocket);
-      }
+
+    @Override
+    public Route route() {
+        return route;
     }
-  }
-
-  /**
-   * To make an HTTPS connection over an HTTP proxy, send an unencrypted CONNECT request to create
-   * the proxy connection. This may need to be retried if the proxy requires authorization.
-   */
-  private Request createTunnel(int readTimeout, int writeTimeout, Request tunnelRequest,
-      HttpUrl url) throws IOException {
-    // Make an SSL Tunnel on the first message pair of each SSL + proxy connection.
-    String requestLine = "CONNECT " + Util.hostHeader(url, true) + " HTTP/1.1";
-    while (true) {
-      Http1Codec tunnelConnection = new Http1Codec(null, null, source, sink);
-      source.timeout().timeout(readTimeout, MILLISECONDS);
-      sink.timeout().timeout(writeTimeout, MILLISECONDS);
-      tunnelConnection.writeRequest(tunnelRequest.headers(), requestLine);
-      tunnelConnection.finishRequest();
-      Response response = tunnelConnection.readResponseHeaders(false)
-          .request(tunnelRequest)
-          .build();
-      // The response body from a CONNECT should be empty, but if it is not then we should consume
-      // it before proceeding.
-      long contentLength = HttpHeaders.contentLength(response);
-      if (contentLength == -1L) {
-        contentLength = 0L;
-      }
-      Source body = tunnelConnection.newFixedLengthSource(contentLength);
-      Util.skipAll(body, Integer.MAX_VALUE, TimeUnit.MILLISECONDS);
-      body.close();
-
-      switch (response.code()) {
-        case HTTP_OK:
-          // Assume the server won't send a TLS ServerHello until we send a TLS ClientHello. If
-          // that happens, then we will have buffered bytes that are needed by the SSLSocket!
-          // This check is imperfect: it doesn't tell us whether a handshake will succeed, just
-          // that it will almost certainly fail because the proxy has sent unexpected data.
-          if (!source.buffer().exhausted() || !sink.buffer().exhausted()) {
-            throw new IOException("TLS tunnel buffered too many bytes!");
-          }
-          return null;
-
-        case HTTP_PROXY_AUTH:
-          tunnelRequest = route.address().proxyAuthenticator().authenticate(route, response);
-          if (tunnelRequest == null) throw new IOException("Failed to authenticate with proxy");
-
-          if ("close".equalsIgnoreCase(response.header("Connection"))) {
-            return tunnelRequest;
-          }
-          break;
-
-        default:
-          throw new IOException(
-              "Unexpected response code for CONNECT: " + response.code());
-      }
+
+    public void cancel() {
+        // Close the raw socket so we don't end up doing synchronous I/O.
+        closeQuietly(rawSocket);
     }
-  }
-
-  /**
-   * Returns a request that creates a TLS tunnel via an HTTP proxy. Everything in the tunnel request
-   * is sent unencrypted to the proxy server, so tunnels include only the minimum set of headers.
-   * This avoids sending potentially sensitive data like HTTP cookies to the proxy unencrypted.
-   */
-  private Request createTunnelRequest() {
-    return new Request.Builder()
-        .url(route.address().url())
-        .header("Host", Util.hostHeader(route.address().url(), true))
-        .header("Proxy-Connection", "Keep-Alive") // For HTTP/1.0 proxies like Squid.
-        .header("User-Agent", Version.userAgent())
-        .build();
-  }
-
-  /** Returns true if this connection can carry a stream allocation to {@code address}. */
-  public boolean isEligible(Address address) {
-    return allocations.size() < allocationLimit
-        && address.equals(route().address())
-        && !noNewStreams;
-  }
-
-  public HttpCodec newCodec(
-      OkHttpClient client, StreamAllocation streamAllocation) throws SocketException {
-    if (http2Connection != null) {
-      return new Http2Codec(client, streamAllocation, http2Connection);
-    } else {
-      socket.setSoTimeout(client.readTimeoutMillis());
-      source.timeout().timeout(client.readTimeoutMillis(), MILLISECONDS);
-      sink.timeout().timeout(client.writeTimeoutMillis(), MILLISECONDS);
-      return new Http1Codec(client, streamAllocation, source, sink);
+
+    @Override
+    public Socket socket() {
+        return socket;
     }
-  }
-
-  public RealWebSocket.Streams newWebSocketStreams(final StreamAllocation streamAllocation) {
-    return new RealWebSocket.Streams(true, source, sink) {
-      @Override public void close() throws IOException {
-        streamAllocation.streamFinished(true, streamAllocation.codec());
-      }
-    };
-  }
-
-  @Override public Route route() {
-    return route;
-  }
-
-  public void cancel() {
-    // Close the raw socket so we don't end up doing synchronous I/O.
-    closeQuietly(rawSocket);
-  }
-
-  @Override public Socket socket() {
-    return socket;
-  }
-
-  /** Returns true if this connection is ready to host new streams. */
-  public boolean isHealthy(boolean doExtensiveChecks) {
-    if (socket.isClosed() || socket.isInputShutdown() || socket.isOutputShutdown()) {
-      return false;
+
+    /**
+     * Returns true if this connection is ready to host new streams.
+     */
+    public boolean isHealthy(boolean doExtensiveChecks) {
+        if (socket.isClosed() || socket.isInputShutdown() || socket.isOutputShutdown()) {
+            return false;
+        }
+
+        if (http2Connection != null) {
+            return !http2Connection.isShutdown();
+        }
+
+        if (doExtensiveChecks) {
+            try {
+                int readTimeout = socket.getSoTimeout();
+                try {
+                    socket.setSoTimeout(1);
+                    if (source.exhausted()) {
+                        return false; // Stream is exhausted; socket is closed.
+                    }
+                    return true;
+                } finally {
+                    socket.setSoTimeout(readTimeout);
+                }
+            } catch (SocketTimeoutException ignored) {
+                // Read timed out; socket is good.
+            } catch (IOException e) {
+                return false; // Couldn't read; socket is closed.
+            }
+        }
+
+        return true;
     }
 
-    if (http2Connection != null) {
-      return !http2Connection.isShutdown();
+    /**
+     * Refuse incoming streams.
+     */
+    @Override
+    public void onStream(Http2Stream stream) throws IOException {
+        stream.close(ErrorCode.REFUSED_STREAM);
     }
 
-    if (doExtensiveChecks) {
-      try {
-        int readTimeout = socket.getSoTimeout();
-        try {
-          socket.setSoTimeout(1);
-          if (source.exhausted()) {
-            return false; // Stream is exhausted; socket is closed.
-          }
-          return true;
-        } finally {
-          socket.setSoTimeout(readTimeout);
+    /**
+     * When settings are received, adjust the allocation limit.
+     */
+    @Override
+    public void onSettings(Http2Connection connection) {
+        synchronized (connectionPool) {
+            allocationLimit = connection.maxConcurrentStreams();
         }
-      } catch (SocketTimeoutException ignored) {
-        // Read timed out; socket is good.
-      } catch (IOException e) {
-        return false; // Couldn't read; socket is closed.
-      }
     }
 
-    return true;
-  }
+    @Override
+    public Handshake handshake() {
+        return handshake;
+    }
+
+    /**
+     * Returns true if this is an HTTP/2 connection. Such connections can be used in multiple HTTP
+     * requests simultaneously.
+     */
+    public boolean isMultiplexed() {
+        return http2Connection != null;
+    }
 
-  /** Refuse incoming streams. */
-  @Override public void onStream(Http2Stream stream) throws IOException {
-    stream.close(ErrorCode.REFUSED_STREAM);
-  }
+    @Override
+    public Protocol protocol() {
+        return protocol;
+    }
 
-  /** When settings are received, adjust the allocation limit. */
-  @Override public void onSettings(Http2Connection connection) {
-    synchronized (connectionPool) {
-      allocationLimit = connection.maxConcurrentStreams();
+    @Override
+    public String toString() {
+        return "Connection{"
+                + route.address().url().host() + ":" + route.address().url().port()
+                + ", proxy="
+                + route.proxy()
+                + " hostAddress="
+                + route.socketAddress()
+                + " cipherSuite="
+                + (handshake != null ? handshake.cipherSuite() : "none")
+                + " protocol="
+                + protocol
+                + '}';
     }
-  }
-
-  @Override public Handshake handshake() {
-    return handshake;
-  }
-
-  /**
-   * Returns true if this is an HTTP/2 connection. Such connections can be used in multiple HTTP
-   * requests simultaneously.
-   */
-  public boolean isMultiplexed() {
-    return http2Connection != null;
-  }
-
-  @Override public Protocol protocol() {
-    return protocol;
-  }
-
-  @Override public String toString() {
-    return "Connection{"
-        + route.address().url().host() + ":" + route.address().url().port()
-        + ", proxy="
-        + route.proxy()
-        + " hostAddress="
-        + route.socketAddress()
-        + " cipherSuite="
-        + (handshake != null ? handshake.cipherSuite() : "none")
-        + " protocol="
-        + protocol
-        + '}';
-  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/RouteDatabase.java b/okhttp/src/main/java/okhttp3/internal/connection/RouteDatabase.java
index 1cc3f311b9..66539d411a 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/RouteDatabase.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/RouteDatabase.java
@@ -17,6 +17,7 @@
 
 import java.util.LinkedHashSet;
 import java.util.Set;
+
 import okhttp3.Route;
 
 /**
@@ -24,22 +25,29 @@
  * used so that OkHttp can learn from its mistakes: if there was a failure attempting to connect to
  * a specific IP address or proxy server, that failure is remembered and alternate routes are
  * preferred.
+ * 黑名单，记录失败的，以便重新选择一个更好的路线
  */
 public final class RouteDatabase {
-  private final Set<Route> failedRoutes = new LinkedHashSet<>();
+    private final Set<Route> failedRoutes = new LinkedHashSet<>();
 
-  /** Records a failure connecting to {@code failedRoute}. */
-  public synchronized void failed(Route failedRoute) {
-    failedRoutes.add(failedRoute);
-  }
+    /**
+     * Records a failure connecting to {@code failedRoute}.
+     */
+    public synchronized void failed(Route failedRoute) {
+        failedRoutes.add(failedRoute);
+    }
 
-  /** Records success connecting to {@code failedRoute}. */
-  public synchronized void connected(Route route) {
-    failedRoutes.remove(route);
-  }
+    /**
+     * Records success connecting to {@code failedRoute}.
+     */
+    public synchronized void connected(Route route) {
+        failedRoutes.remove(route);
+    }
 
-  /** Returns true if {@code route} has failed recently and should be avoided. */
-  public synchronized boolean shouldPostpone(Route route) {
-    return failedRoutes.contains(route);
-  }
+    /**
+     * Returns true if {@code route} has failed recently and should be avoided.
+     */
+    public synchronized boolean shouldPostpone(Route route) {
+        return failedRoutes.contains(route);
+    }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java b/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
index fbe83067ab..82aaacc5e3 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
@@ -19,6 +19,7 @@
 import java.lang.ref.Reference;
 import java.lang.ref.WeakReference;
 import java.net.Socket;
+
 import okhttp3.Address;
 import okhttp3.ConnectionPool;
 import okhttp3.OkHttpClient;
@@ -34,370 +35,384 @@
 
 /**
  * This class coordinates the relationship between three entities:
- *
+ * <p>
  * <ul>
- *     <li><strong>Connections:</strong> physical socket connections to remote servers. These are
- *         potentially slow to establish so it is necessary to be able to cancel a connection
- *         currently being connected.
- *     <li><strong>Streams:</strong> logical HTTP request/response pairs that are layered on
- *         connections. Each connection has its own allocation limit, which defines how many
- *         concurrent streams that connection can carry. HTTP/1.x connections can carry 1 stream
- *         at a time, HTTP/2 typically carry multiple.
- *     <li><strong>Calls:</strong> a logical sequence of streams, typically an initial request and
- *         its follow up requests. We prefer to keep all streams of a single call on the same
- *         connection for better behavior and locality.
+ * <li><strong>Connections:</strong> physical socket connections to remote servers. These are
+ * potentially slow to establish so it is necessary to be able to cancel a connection
+ * currently being connected.
+ * <li><strong>Streams:</strong> logical HTTP request/response pairs that are layered on
+ * connections. Each connection has its own allocation limit, which defines how many
+ * concurrent streams that connection can carry. HTTP/1.x connections can carry 1 stream
+ * at a time, HTTP/2 typically carry multiple.
+ * <li><strong>Calls:</strong> a logical sequence of streams, typically an initial request and
+ * its follow up requests. We prefer to keep all streams of a single call on the same
+ * connection for better behavior and locality.
  * </ul>
- *
+ * <p>
  * <p>Instances of this class act on behalf of the call, using one or more streams over one or more
  * connections. This class has APIs to release each of the above resources:
- *
+ * <p>
  * <ul>
- *     <li>{@link #noNewStreams()} prevents the connection from being used for new streams in the
- *         future. Use this after a {@code Connection: close} header, or when the connection may be
- *         inconsistent.
- *     <li>{@link #streamFinished streamFinished()} releases the active stream from this allocation.
- *         Note that only one stream may be active at a given time, so it is necessary to call
- *         {@link #streamFinished streamFinished()} before creating a subsequent stream with {@link
- *         #newStream newStream()}.
- *     <li>{@link #release()} removes the call's hold on the connection. Note that this won't
- *         immediately free the connection if there is a stream still lingering. That happens when a
- *         call is complete but its response body has yet to be fully consumed.
+ * <li>{@link #noNewStreams()} prevents the connection from being used for new streams in the
+ * future. Use this after a {@code Connection: close} header, or when the connection may be
+ * inconsistent.
+ * <li>{@link #streamFinished streamFinished()} releases the active stream from this allocation.
+ * Note that only one stream may be active at a given time, so it is necessary to call
+ * {@link #streamFinished streamFinished()} before creating a subsequent stream with {@link
+ * #newStream newStream()}.
+ * <li>{@link #release()} removes the call's hold on the connection. Note that this won't
+ * immediately free the connection if there is a stream still lingering. That happens when a
+ * call is complete but its response body has yet to be fully consumed.
  * </ul>
- *
+ * <p>
  * <p>This class supports {@linkplain #cancel asynchronous canceling}. This is intended to have the
  * smallest blast radius possible. If an HTTP/2 stream is active, canceling will cancel that stream
  * but not the other streams sharing its connection. But if the TLS handshake is still in progress
  * then canceling may break the entire connection.
  */
 public final class StreamAllocation {
-  public final Address address;
-  private Route route;
-  private final ConnectionPool connectionPool;
-  private final Object callStackTrace;
-
-  // State guarded by connectionPool.
-  private final RouteSelector routeSelector;
-  private int refusedStreamCount;
-  private RealConnection connection;
-  private boolean released;
-  private boolean canceled;
-  private HttpCodec codec;
-
-  public StreamAllocation(ConnectionPool connectionPool, Address address, Object callStackTrace) {
-    this.connectionPool = connectionPool;
-    this.address = address;
-    this.routeSelector = new RouteSelector(address, routeDatabase());
-    this.callStackTrace = callStackTrace;
-  }
-
-  public HttpCodec newStream(OkHttpClient client, boolean doExtensiveHealthChecks) {
-    int connectTimeout = client.connectTimeoutMillis();
-    int readTimeout = client.readTimeoutMillis();
-    int writeTimeout = client.writeTimeoutMillis();
-    boolean connectionRetryEnabled = client.retryOnConnectionFailure();
-
-    try {
-      RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,
-          writeTimeout, connectionRetryEnabled, doExtensiveHealthChecks);
-      HttpCodec resultCodec = resultConnection.newCodec(client, this);
-
-      synchronized (connectionPool) {
-        codec = resultCodec;
-        return resultCodec;
-      }
-    } catch (IOException e) {
-      throw new RouteException(e);
+    public final Address address;
+    private Route route;
+    private final ConnectionPool connectionPool;
+    private final Object callStackTrace;
+
+    // State guarded by connectionPool.
+    private final RouteSelector routeSelector;
+    private int refusedStreamCount;
+    private RealConnection connection;
+    private boolean released;
+    private boolean canceled;
+    private HttpCodec codec;
+
+    public StreamAllocation(ConnectionPool connectionPool, Address address, Object callStackTrace) {
+        this.connectionPool = connectionPool;
+        this.address = address;
+        this.routeSelector = new RouteSelector(address, routeDatabase());
+        this.callStackTrace = callStackTrace;
     }
-  }
-
-  /**
-   * Finds a connection and returns it if it is healthy. If it is unhealthy the process is repeated
-   * until a healthy connection is found.
-   */
-  private RealConnection findHealthyConnection(int connectTimeout, int readTimeout,
-      int writeTimeout, boolean connectionRetryEnabled, boolean doExtensiveHealthChecks)
-      throws IOException {
-    while (true) {
-      RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,
-          connectionRetryEnabled);
-
-      // If this is a brand new connection, we can skip the extensive health checks.
-      synchronized (connectionPool) {
-        if (candidate.successCount == 0) {
-          return candidate;
-        }
-      }
 
-      // Do a (potentially slow) check to confirm that the pooled connection is still good. If it
-      // isn't, take it out of the pool and start again.
-      if (!candidate.isHealthy(doExtensiveHealthChecks)) {
-        noNewStreams();
-        continue;
-      }
+    public HttpCodec newStream(OkHttpClient client, boolean doExtensiveHealthChecks) {
+        int connectTimeout = client.connectTimeoutMillis();
+        int readTimeout = client.readTimeoutMillis();
+        int writeTimeout = client.writeTimeoutMillis();
+        boolean connectionRetryEnabled = client.retryOnConnectionFailure();
+
+        try {
+            // 寻找/创建一个RealConnection
+            RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,
+                    writeTimeout, connectionRetryEnabled, doExtensiveHealthChecks);
+            HttpCodec resultCodec = resultConnection.newCodec(client, this);
+
+            synchronized (connectionPool) {
+                codec = resultCodec;
+                return resultCodec;
+            }
+        } catch (IOException e) {
+            throw new RouteException(e);
+        }
+    }
 
-      return candidate;
+    /**
+     * Finds a connection and returns it if it is healthy. If it is unhealthy the process is repeated
+     * until a healthy connection is found.
+     * 循环直至找到合适的connection
+     */
+    private RealConnection findHealthyConnection(int connectTimeout, int readTimeout,
+                                                 int writeTimeout, boolean connectionRetryEnabled, boolean doExtensiveHealthChecks)
+            throws IOException {
+        while (true) {
+            RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,
+                    connectionRetryEnabled);
+
+            // If this is a brand new connection, we can skip the extensive health checks.
+            synchronized (connectionPool) {// 新连接，跳过检查
+                if (candidate.successCount == 0) {
+                    return candidate;
+                }
+            }
+
+            // Do a (potentially slow) check to confirm that the pooled connection is still good. If it
+            // isn't, take it out of the pool and start again.
+            if (!candidate.isHealthy(doExtensiveHealthChecks)) {// 检查
+                noNewStreams();
+                continue;
+            }
+
+            return candidate;
+        }
     }
-  }
-
-  /**
-   * Returns a connection to host a new stream. This prefers the existing connection if it exists,
-   * then the pool, finally building a new connection.
-   */
-  private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout,
-      boolean connectionRetryEnabled) throws IOException {
-    Route selectedRoute;
-    synchronized (connectionPool) {
-      if (released) throw new IllegalStateException("released");
-      if (codec != null) throw new IllegalStateException("codec != null");
-      if (canceled) throw new IOException("Canceled");
-
-      // Attempt to use an already-allocated connection.
-      RealConnection allocatedConnection = this.connection;
-      if (allocatedConnection != null && !allocatedConnection.noNewStreams) {
-        return allocatedConnection;
-      }
-
-      // Attempt to get a connection from the pool.
-      Internal.instance.get(connectionPool, address, this);
-      if (connection != null) {
-        return connection;
-      }
 
-      selectedRoute = route;
+    /**
+     * Returns a connection to host a new stream. This prefers the existing connection if it exists,
+     * then the pool, finally building a new connection.
+     * 优先级：已存在的连接>连接池>构建新的连接
+     */
+    private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout,
+                                          boolean connectionRetryEnabled) throws IOException {
+        Route selectedRoute;
+        synchronized (connectionPool) {
+            if (released) throw new IllegalStateException("released");
+            if (codec != null) throw new IllegalStateException("codec != null");
+            if (canceled) throw new IOException("Canceled");
+
+            // Attempt to use an already-allocated connection. 尝试使用一个已经分配好的连接
+            RealConnection allocatedConnection = this.connection;
+            if (allocatedConnection != null && !allocatedConnection.noNewStreams) {
+                return allocatedConnection;
+            }
+
+            // Attempt to get a connection from the pool.
+            // 这个方法如果找到合适的连接，则最终会回调至本类的acquire(RealConnection)方法。
+            // 并在该方法中对this.connection进行赋值。所以此处看起来只是调用，并没有进行赋值。
+            Internal.instance.get(connectionPool, address, this);
+            if (connection != null) {
+                return connection;
+            }
+
+            selectedRoute = route;
+        }
+
+        // If we need a route, make one. This is a blocking operation.
+        if (selectedRoute == null) {
+            // TODO: 17/9/7 获取route的逻辑
+            selectedRoute = routeSelector.next();
+        }
+
+        // Create a connection and assign it to this allocation immediately. This makes it possible for
+        // an asynchronous cancel() to interrupt the handshake we're about to do.
+        RealConnection result;
+        synchronized (connectionPool) {
+            route = selectedRoute;
+            refusedStreamCount = 0;
+            result = new RealConnection(connectionPool, selectedRoute);
+            acquire(result);// 增加计数
+            if (canceled) throw new IOException("Canceled");
+        }
+
+        // Do TCP + TLS handshakes. This is a blocking operation.开始握手连接
+        // TODO: 17/9/7 连接逻辑
+        result.connect(connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled);
+        routeDatabase().connected(result.route());// 更新黑名单
+
+        Socket socket = null;
+        synchronized (connectionPool) {
+            // Pool the connection. 连接池存一份
+            Internal.instance.put(connectionPool, result);
+
+            // If another multiplexed connection to the same address was created concurrently, then
+            // release this connection and acquire that one.
+            if (result.isMultiplexed()) {
+                // 这里和之前的情况有点类似，这个是最终会回调本类的releaseAndAcquire(RealConnection)方法，
+                // 并最终更新this.connection的引用。
+                socket = Internal.instance.deduplicate(connectionPool, address, this);
+                result = connection;
+            }
+        }
+        closeQuietly(socket);
+
+        return result;
     }
 
-    // If we need a route, make one. This is a blocking operation.
-    if (selectedRoute == null) {
-      selectedRoute = routeSelector.next();
+    public void streamFinished(boolean noNewStreams, HttpCodec codec) {
+        Socket socket;
+        synchronized (connectionPool) {
+            if (codec == null || codec != this.codec) {
+                throw new IllegalStateException("expected " + this.codec + " but was " + codec);
+            }
+            if (!noNewStreams) {
+                connection.successCount++;
+            }
+            socket = deallocate(noNewStreams, false, true);
+        }
+        closeQuietly(socket);
     }
 
-    // Create a connection and assign it to this allocation immediately. This makes it possible for
-    // an asynchronous cancel() to interrupt the handshake we're about to do.
-    RealConnection result;
-    synchronized (connectionPool) {
-      route = selectedRoute;
-      refusedStreamCount = 0;
-      result = new RealConnection(connectionPool, selectedRoute);
-      acquire(result);
-      if (canceled) throw new IOException("Canceled");
+    public HttpCodec codec() {
+        synchronized (connectionPool) {
+            return codec;
+        }
     }
 
-    // Do TCP + TLS handshakes. This is a blocking operation.
-    result.connect(connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled);
-    routeDatabase().connected(result.route());
-
-    Socket socket = null;
-    synchronized (connectionPool) {
-      // Pool the connection.
-      Internal.instance.put(connectionPool, result);
-
-      // If another multiplexed connection to the same address was created concurrently, then
-      // release this connection and acquire that one.
-      if (result.isMultiplexed()) {
-        socket = Internal.instance.deduplicate(connectionPool, address, this);
-        result = connection;
-      }
+    private RouteDatabase routeDatabase() {
+        return Internal.instance.routeDatabase(connectionPool);
     }
-    closeQuietly(socket);
-
-    return result;
-  }
-
-  public void streamFinished(boolean noNewStreams, HttpCodec codec) {
-    Socket socket;
-    synchronized (connectionPool) {
-      if (codec == null || codec != this.codec) {
-        throw new IllegalStateException("expected " + this.codec + " but was " + codec);
-      }
-      if (!noNewStreams) {
-        connection.successCount++;
-      }
-      socket = deallocate(noNewStreams, false, true);
+
+    public synchronized RealConnection connection() {
+        return connection;
     }
-    closeQuietly(socket);
-  }
 
-  public HttpCodec codec() {
-    synchronized (connectionPool) {
-      return codec;
+    public void release() {
+        Socket socket;
+        synchronized (connectionPool) {
+            socket = deallocate(false, true, false);
+        }
+        closeQuietly(socket);
     }
-  }
 
-  private RouteDatabase routeDatabase() {
-    return Internal.instance.routeDatabase(connectionPool);
-  }
+    /**
+     * Forbid new streams from being created on the connection that hosts this allocation.
+     */
+    public void noNewStreams() {
+        Socket socket;
+        synchronized (connectionPool) {
+            socket = deallocate(true, false, false);
+        }
+        closeQuietly(socket);
+    }
 
-  public synchronized RealConnection connection() {
-    return connection;
-  }
+    /**
+     * Releases resources held by this allocation. If sufficient resources are allocated, the
+     * connection will be detached or closed. Callers must be synchronized on the connection pool.
+     * <p>
+     * <p>Returns a closeable that the caller should pass to {@link Util#closeQuietly} upon completion
+     * of the synchronized block. (We don't do I/O while synchronized on the connection pool.)
+     */
+    private Socket deallocate(boolean noNewStreams, boolean released, boolean streamFinished) {
+        assert (Thread.holdsLock(connectionPool));
 
-  public void release() {
-    Socket socket;
-    synchronized (connectionPool) {
-      socket = deallocate(false, true, false);
-    }
-    closeQuietly(socket);
-  }
-
-  /** Forbid new streams from being created on the connection that hosts this allocation. */
-  public void noNewStreams() {
-    Socket socket;
-    synchronized (connectionPool) {
-      socket = deallocate(true, false, false);
-    }
-    closeQuietly(socket);
-  }
-
-  /**
-   * Releases resources held by this allocation. If sufficient resources are allocated, the
-   * connection will be detached or closed. Callers must be synchronized on the connection pool.
-   *
-   * <p>Returns a closeable that the caller should pass to {@link Util#closeQuietly} upon completion
-   * of the synchronized block. (We don't do I/O while synchronized on the connection pool.)
-   */
-  private Socket deallocate(boolean noNewStreams, boolean released, boolean streamFinished) {
-    assert (Thread.holdsLock(connectionPool));
-
-    if (streamFinished) {
-      this.codec = null;
-    }
-    if (released) {
-      this.released = true;
-    }
-    Socket socket = null;
-    if (connection != null) {
-      if (noNewStreams) {
-        connection.noNewStreams = true;
-      }
-      if (this.codec == null && (this.released || connection.noNewStreams)) {
-        release(connection);
-        if (connection.allocations.isEmpty()) {
-          connection.idleAtNanos = System.nanoTime();
-          if (Internal.instance.connectionBecameIdle(connectionPool, connection)) {
-            socket = connection.socket();
-          }
+        if (streamFinished) {
+            this.codec = null;
         }
-        connection = null;
-      }
-    }
-    return socket;
-  }
-
-  public void cancel() {
-    HttpCodec codecToCancel;
-    RealConnection connectionToCancel;
-    synchronized (connectionPool) {
-      canceled = true;
-      codecToCancel = codec;
-      connectionToCancel = connection;
-    }
-    if (codecToCancel != null) {
-      codecToCancel.cancel();
-    } else if (connectionToCancel != null) {
-      connectionToCancel.cancel();
+        if (released) {
+            this.released = true;
+        }
+        Socket socket = null;
+        if (connection != null) {
+            if (noNewStreams) {
+                connection.noNewStreams = true;
+            }
+            if (this.codec == null && (this.released || connection.noNewStreams)) {
+                release(connection);
+                if (connection.allocations.isEmpty()) {
+                    connection.idleAtNanos = System.nanoTime();
+                    if (Internal.instance.connectionBecameIdle(connectionPool, connection)) {
+                        socket = connection.socket();
+                    }
+                }
+                connection = null;
+            }
+        }
+        return socket;
     }
-  }
-
-  public void streamFailed(IOException e) {
-    Socket socket;
-    boolean noNewStreams = false;
 
-    synchronized (connectionPool) {
-      if (e instanceof StreamResetException) {
-        StreamResetException streamResetException = (StreamResetException) e;
-        if (streamResetException.errorCode == ErrorCode.REFUSED_STREAM) {
-          refusedStreamCount++;
+    public void cancel() {
+        HttpCodec codecToCancel;
+        RealConnection connectionToCancel;
+        synchronized (connectionPool) {
+            canceled = true;
+            codecToCancel = codec;
+            connectionToCancel = connection;
         }
-        // On HTTP/2 stream errors, retry REFUSED_STREAM errors once on the same connection. All
-        // other errors must be retried on a new connection.
-        if (streamResetException.errorCode != ErrorCode.REFUSED_STREAM || refusedStreamCount > 1) {
-          noNewStreams = true;
-          route = null;
+        if (codecToCancel != null) {
+            codecToCancel.cancel();
+        } else if (connectionToCancel != null) {
+            connectionToCancel.cancel();
         }
-      } else if (connection != null
-          && (!connection.isMultiplexed() || e instanceof ConnectionShutdownException)) {
-        noNewStreams = true;
-
-        // If this route hasn't completed a call, avoid it for new connections.
-        if (connection.successCount == 0) {
-          if (route != null && e != null) {
-            routeSelector.connectFailed(route, e);
-          }
-          route = null;
+    }
+
+    public void streamFailed(IOException e) {
+        Socket socket;
+        boolean noNewStreams = false;
+
+        synchronized (connectionPool) {
+            if (e instanceof StreamResetException) {
+                StreamResetException streamResetException = (StreamResetException) e;
+                if (streamResetException.errorCode == ErrorCode.REFUSED_STREAM) {
+                    refusedStreamCount++;
+                }
+                // On HTTP/2 stream errors, retry REFUSED_STREAM errors once on the same connection. All
+                // other errors must be retried on a new connection.
+                if (streamResetException.errorCode != ErrorCode.REFUSED_STREAM || refusedStreamCount > 1) {
+                    noNewStreams = true;
+                    route = null;
+                }
+            } else if (connection != null
+                    && (!connection.isMultiplexed() || e instanceof ConnectionShutdownException)) {
+                noNewStreams = true;
+
+                // If this route hasn't completed a call, avoid it for new connections.
+                if (connection.successCount == 0) {
+                    if (route != null && e != null) {
+                        routeSelector.connectFailed(route, e);
+                    }
+                    route = null;
+                }
+            }
+            socket = deallocate(noNewStreams, false, true);
         }
-      }
-      socket = deallocate(noNewStreams, false, true);
+
+        closeQuietly(socket);
+    }
+
+    /**
+     * Use this allocation to hold {@code connection}. Each call to this must be paired with a call to
+     * {@link #release} on the same connection.
+     */
+    public void acquire(RealConnection connection) {
+        assert (Thread.holdsLock(connectionPool));
+        if (this.connection != null) throw new IllegalStateException();
+
+        this.connection = connection;
+        connection.allocations.add(new StreamAllocationReference(this, callStackTrace));
     }
 
-    closeQuietly(socket);
-  }
-
-  /**
-   * Use this allocation to hold {@code connection}. Each call to this must be paired with a call to
-   * {@link #release} on the same connection.
-   */
-  public void acquire(RealConnection connection) {
-    assert (Thread.holdsLock(connectionPool));
-    if (this.connection != null) throw new IllegalStateException();
-
-    this.connection = connection;
-    connection.allocations.add(new StreamAllocationReference(this, callStackTrace));
-  }
-
-  /** Remove this allocation from the connection's list of allocations. */
-  private void release(RealConnection connection) {
-    for (int i = 0, size = connection.allocations.size(); i < size; i++) {
-      Reference<StreamAllocation> reference = connection.allocations.get(i);
-      if (reference.get() == this) {
-        connection.allocations.remove(i);
-        return;
-      }
+    /**
+     * Remove this allocation from the connection's list of allocations.
+     */
+    private void release(RealConnection connection) {
+        for (int i = 0, size = connection.allocations.size(); i < size; i++) {
+            Reference<StreamAllocation> reference = connection.allocations.get(i);
+            if (reference.get() == this) {
+                connection.allocations.remove(i);
+                return;
+            }
+        }
+        throw new IllegalStateException();
     }
-    throw new IllegalStateException();
-  }
-
-  /**
-   * Release the connection held by this connection and acquire {@code newConnection} instead. It is
-   * only safe to call this if the held connection is newly connected but duplicated by {@code
-   * newConnection}. Typically this occurs when concurrently connecting to an HTTP/2 webserver.
-   *
-   * <p>Returns a closeable that the caller should pass to {@link Util#closeQuietly} upon completion
-   * of the synchronized block. (We don't do I/O while synchronized on the connection pool.)
-   */
-  public Socket releaseAndAcquire(RealConnection newConnection) {
-    assert (Thread.holdsLock(connectionPool));
-    if (codec != null || connection.allocations.size() != 1) throw new IllegalStateException();
-
-    // Release the old connection.
-    Reference<StreamAllocation> onlyAllocation = connection.allocations.get(0);
-    Socket socket = deallocate(true, false, false);
-
-    // Acquire the new connection.
-    this.connection = newConnection;
-    newConnection.allocations.add(onlyAllocation);
-
-    return socket;
-  }
-
-  public boolean hasMoreRoutes() {
-    return route != null || routeSelector.hasNext();
-  }
-
-  @Override public String toString() {
-    RealConnection connection = connection();
-    return connection != null ? connection.toString() : address.toString();
-  }
-
-  public static final class StreamAllocationReference extends WeakReference<StreamAllocation> {
+
     /**
-     * Captures the stack trace at the time the Call is executed or enqueued. This is helpful for
-     * identifying the origin of connection leaks.
+     * Release the connection held by this connection and acquire {@code newConnection} instead. It is
+     * only safe to call this if the held connection is newly connected but duplicated by {@code
+     * newConnection}. Typically this occurs when concurrently connecting to an HTTP/2 webserver.
+     * <p>
+     * <p>Returns a closeable that the caller should pass to {@link Util#closeQuietly} upon completion
+     * of the synchronized block. (We don't do I/O while synchronized on the connection pool.)
      */
-    public final Object callStackTrace;
+    public Socket releaseAndAcquire(RealConnection newConnection) {
+        assert (Thread.holdsLock(connectionPool));
+        if (codec != null || connection.allocations.size() != 1) throw new IllegalStateException();
+
+        // Release the old connection. 释放旧的connection
+        Reference<StreamAllocation> onlyAllocation = connection.allocations.get(0);
+        Socket socket = deallocate(true, false, false);
+
+        // Acquire the new connection.
+        this.connection = newConnection;
+        newConnection.allocations.add(onlyAllocation);
 
-    StreamAllocationReference(StreamAllocation referent, Object callStackTrace) {
-      super(referent);
-      this.callStackTrace = callStackTrace;
+        return socket;
+    }
+
+    public boolean hasMoreRoutes() {
+        return route != null || routeSelector.hasNext();
+    }
+
+    @Override
+    public String toString() {
+        RealConnection connection = connection();
+        return connection != null ? connection.toString() : address.toString();
+    }
+
+    public static final class StreamAllocationReference extends WeakReference<StreamAllocation> {
+        /**
+         * Captures the stack trace at the time the Call is executed or enqueued. This is helpful for
+         * identifying the origin of connection leaks.
+         */
+        public final Object callStackTrace;
+
+        StreamAllocationReference(StreamAllocation referent, Object callStackTrace) {
+            super(referent);
+            this.callStackTrace = callStackTrace;
+        }
     }
-  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.java
index 54b561da88..5b335b4a5b 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.java
@@ -18,6 +18,7 @@
 
 import java.io.IOException;
 import java.util.List;
+
 import okhttp3.Cookie;
 import okhttp3.CookieJar;
 import okhttp3.Headers;
@@ -26,7 +27,6 @@
 import okhttp3.Request;
 import okhttp3.RequestBody;
 import okhttp3.Response;
-import okhttp3.internal.Version;
 import okio.GzipSource;
 import okio.Okio;
 
@@ -38,90 +38,94 @@
  * response.
  */
 public final class BridgeInterceptor implements Interceptor {
-  private final CookieJar cookieJar;
-
-  public BridgeInterceptor(CookieJar cookieJar) {
-    this.cookieJar = cookieJar;
-  }
-
-  @Override public Response intercept(Chain chain) throws IOException {
-    Request userRequest = chain.request();
-    Request.Builder requestBuilder = userRequest.newBuilder();
-
-    RequestBody body = userRequest.body();
-    if (body != null) {
-      MediaType contentType = body.contentType();
-      if (contentType != null) {
-        requestBuilder.header("Content-Type", contentType.toString());
-      }
-
-      long contentLength = body.contentLength();
-      if (contentLength != -1) {
-        requestBuilder.header("Content-Length", Long.toString(contentLength));
-        requestBuilder.removeHeader("Transfer-Encoding");
-      } else {
-        requestBuilder.header("Transfer-Encoding", "chunked");
-        requestBuilder.removeHeader("Content-Length");
-      }
-    }
-
-    if (userRequest.header("Host") == null) {
-      requestBuilder.header("Host", hostHeader(userRequest.url(), false));
-    }
+    private final CookieJar cookieJar;
 
-    if (userRequest.header("Connection") == null) {
-      requestBuilder.header("Connection", "Keep-Alive");
+    public BridgeInterceptor(CookieJar cookieJar) {
+        this.cookieJar = cookieJar;
     }
 
-    // If we add an "Accept-Encoding: gzip" header field we're responsible for also decompressing
-    // the transfer stream.
-    boolean transparentGzip = false;
-    if (userRequest.header("Accept-Encoding") == null && userRequest.header("Range") == null) {
-      transparentGzip = true;
-      requestBuilder.header("Accept-Encoding", "gzip");
-    }
-
-    List<Cookie> cookies = cookieJar.loadForRequest(userRequest.url());
-    if (!cookies.isEmpty()) {
-      requestBuilder.header("Cookie", cookieHeader(cookies));
-    }
-
-    if (userRequest.header("User-Agent") == null) {
-      requestBuilder.header("User-Agent", Version.userAgent());
-    }
-
-    Response networkResponse = chain.proceed(requestBuilder.build());
-
-    HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());
-
-    Response.Builder responseBuilder = networkResponse.newBuilder()
-        .request(userRequest);
-
-    if (transparentGzip
-        && "gzip".equalsIgnoreCase(networkResponse.header("Content-Encoding"))
-        && HttpHeaders.hasBody(networkResponse)) {
-      GzipSource responseBody = new GzipSource(networkResponse.body().source());
-      Headers strippedHeaders = networkResponse.headers().newBuilder()
-          .removeAll("Content-Encoding")
-          .removeAll("Content-Length")
-          .build();
-      responseBuilder.headers(strippedHeaders);
-      responseBuilder.body(new RealResponseBody(strippedHeaders, Okio.buffer(responseBody)));
+    @Override
+    public Response intercept(Chain chain) throws IOException {
+        Request userRequest = chain.request();
+        Request.Builder requestBuilder = userRequest.newBuilder();
+
+        RequestBody body = userRequest.body();
+        if (body != null) {
+            MediaType contentType = body.contentType();
+            if (contentType != null) {
+                requestBuilder.header("Content-Type", contentType.toString());
+            }
+
+            long contentLength = body.contentLength();
+            if (contentLength != -1) {
+                requestBuilder.header("Content-Length", Long.toString(contentLength));
+                requestBuilder.removeHeader("Transfer-Encoding");
+            } else {
+                requestBuilder.header("Transfer-Encoding", "chunked");
+                requestBuilder.removeHeader("Content-Length");
+            }
+        }
+
+        if (userRequest.header("Host") == null) {
+            requestBuilder.header("Host", hostHeader(userRequest.url(), false));
+        }
+
+        if (userRequest.header("Connection") == null) {
+            requestBuilder.header("Connection", "Keep-Alive");
+        }
+
+        // If we add an "Accept-Encoding: gzip" header field we're responsible for also decompressing
+        // the transfer stream.
+        boolean transparentGzip = false;
+        if (userRequest.header("Accept-Encoding") == null && userRequest.header("Range") == null) {
+            transparentGzip = true;
+            requestBuilder.header("Accept-Encoding", "gzip");
+        }
+        // 获取Cookie，默认是空的
+        List<Cookie> cookies = cookieJar.loadForRequest(userRequest.url());
+        if (!cookies.isEmpty()) {
+            requestBuilder.header("Cookie", cookieHeader(cookies));
+        }
+
+        if (userRequest.header("User-Agent") == null) {// 添加ua
+            requestBuilder.header("User-Agent", Version.userAgent());
+        }
+        // 分割线之前做的操作就是添加请求头
+        /*****************************分割线*****************************/
+        Response networkResponse = chain.proceed(requestBuilder.build());// 转入缓存拦截器
+        // 保存Cookie
+        HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());
+
+        Response.Builder responseBuilder = networkResponse.newBuilder()
+                .request(userRequest);
+
+        if (transparentGzip
+                && "gzip".equalsIgnoreCase(networkResponse.header("Content-Encoding"))
+                && HttpHeaders.hasBody(networkResponse)) {// 解gzip压缩
+            GzipSource responseBody = new GzipSource(networkResponse.body().source());
+            Headers strippedHeaders = networkResponse.headers().newBuilder()
+                    .removeAll("Content-Encoding")
+                    .removeAll("Content-Length")
+                    .build();
+            responseBuilder.headers(strippedHeaders);
+            responseBuilder.body(new RealResponseBody(strippedHeaders, Okio.buffer(responseBody)));
+        }
+
+        return responseBuilder.build();
     }
 
-    return responseBuilder.build();
-  }
-
-  /** Returns a 'Cookie' HTTP request header with all cookies, like {@code a=b; c=d}. */
-  private String cookieHeader(List<Cookie> cookies) {
-    StringBuilder cookieHeader = new StringBuilder();
-    for (int i = 0, size = cookies.size(); i < size; i++) {
-      if (i > 0) {
-        cookieHeader.append("; ");
-      }
-      Cookie cookie = cookies.get(i);
-      cookieHeader.append(cookie.name()).append('=').append(cookie.value());
+    /**
+     * Returns a 'Cookie' HTTP request header with all cookies, like {@code a=b; c=d}.
+     */
+    private String cookieHeader(List<Cookie> cookies) {
+        StringBuilder cookieHeader = new StringBuilder();
+        for (int i = 0, size = cookies.size(); i < size; i++) {
+            if (i > 0) {
+                cookieHeader.append("; ");
+            }
+            Cookie cookie = cookies.get(i);
+            cookieHeader.append(cookie.name()).append('=').append(cookie.value());
+        }
+        return cookieHeader.toString();
     }
-    return cookieHeader.toString();
-  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
index f7c0e5a561..e2ed495b09 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
@@ -17,6 +17,7 @@
 
 import java.io.IOException;
 import java.net.ProtocolException;
+
 import okhttp3.Interceptor;
 import okhttp3.Request;
 import okhttp3.Response;
@@ -26,76 +27,80 @@
 import okio.Okio;
 import okio.Sink;
 
-/** This is the last interceptor in the chain. It makes a network call to the server. */
+/**
+ * This is the last interceptor in the chain. It makes a network call to the server.
+ */
 public final class CallServerInterceptor implements Interceptor {
-  private final boolean forWebSocket;
+    private final boolean forWebSocket;
 
-  public CallServerInterceptor(boolean forWebSocket) {
-    this.forWebSocket = forWebSocket;
-  }
+    public CallServerInterceptor(boolean forWebSocket) {
+        this.forWebSocket = forWebSocket;
+    }
 
-  @Override public Response intercept(Chain chain) throws IOException {
-    HttpCodec httpCodec = ((RealInterceptorChain) chain).httpStream();
-    StreamAllocation streamAllocation = ((RealInterceptorChain) chain).streamAllocation();
-    Request request = chain.request();
+    @Override
+    public Response intercept(Chain chain) throws IOException {
+        HttpCodec httpCodec = ((RealInterceptorChain) chain).httpStream();
+        StreamAllocation streamAllocation = ((RealInterceptorChain) chain).streamAllocation();
+        Request request = chain.request();
 
-    long sentRequestMillis = System.currentTimeMillis();
-    httpCodec.writeRequestHeaders(request);
+        long sentRequestMillis = System.currentTimeMillis();
+        httpCodec.writeRequestHeaders(request);// 请求头写入
 
-    Response.Builder responseBuilder = null;
-    if (HttpMethod.permitsRequestBody(request.method()) && request.body() != null) {
-      // If there's a "Expect: 100-continue" header on the request, wait for a "HTTP/1.1 100
-      // Continue" response before transmitting the request body. If we don't get that, return what
-      // we did get (such as a 4xx response) without ever transmitting the request body.
-      if ("100-continue".equalsIgnoreCase(request.header("Expect"))) {
-        httpCodec.flushRequest();
-        responseBuilder = httpCodec.readResponseHeaders(true);
-      }
+        Response.Builder responseBuilder = null;
+        if (HttpMethod.permitsRequestBody(request.method()) && request.body() != null) {
+            // If there's a "Expect: 100-continue" header on the request, wait for a "HTTP/1.1 100
+            // Continue" response before transmitting the request body. If we don't get that, return what
+            // we did get (such as a 4xx response) without ever transmitting the request body.
+            if ("100-continue".equalsIgnoreCase(request.header("Expect"))) {
+                httpCodec.flushRequest();
+                responseBuilder = httpCodec.readResponseHeaders(true);
+            }
 
-      // Write the request body, unless an "Expect: 100-continue" expectation failed.
-      if (responseBuilder == null) {
-        Sink requestBodyOut = httpCodec.createRequestBody(request, request.body().contentLength());
-        BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);
-        request.body().writeTo(bufferedRequestBody);
-        bufferedRequestBody.close();
-      }
-    }
+            // Write the request body, unless an "Expect: 100-continue" expectation failed.
+            if (responseBuilder == null) {// 请求体写入
+                Sink requestBodyOut = httpCodec.createRequestBody(request, request.body().contentLength());
+                BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);
+                request.body().writeTo(bufferedRequestBody);
+                bufferedRequestBody.close();
+            }
+        }
 
-    httpCodec.finishRequest();
+        httpCodec.finishRequest();// 刷新了输出流
 
-    if (responseBuilder == null) {
-      responseBuilder = httpCodec.readResponseHeaders(false);
-    }
+        if (responseBuilder == null) {// 读取响应头
+            responseBuilder = httpCodec.readResponseHeaders(false);
+        }
+        // 补充完善响应信息
+        Response response = responseBuilder
+                .request(request)
+                .handshake(streamAllocation.connection().handshake())
+                .sentRequestAtMillis(sentRequestMillis)
+                .receivedResponseAtMillis(System.currentTimeMillis())
+                .build();
 
-    Response response = responseBuilder
-        .request(request)
-        .handshake(streamAllocation.connection().handshake())
-        .sentRequestAtMillis(sentRequestMillis)
-        .receivedResponseAtMillis(System.currentTimeMillis())
-        .build();
+        int code = response.code();
+        if (forWebSocket && code == 101) {
+            // Connection is upgrading, but we need to ensure interceptors see a non-null response body.
+            response = response.newBuilder()
+                    .body(Util.EMPTY_RESPONSE)
+                    .build();
+        } else {
+            // 读取响应体
+            response = response.newBuilder()
+                    .body(httpCodec.openResponseBody(response))
+                    .build();
+        }
 
-    int code = response.code();
-    if (forWebSocket && code == 101) {
-      // Connection is upgrading, but we need to ensure interceptors see a non-null response body.
-      response = response.newBuilder()
-          .body(Util.EMPTY_RESPONSE)
-          .build();
-    } else {
-      response = response.newBuilder()
-          .body(httpCodec.openResponseBody(response))
-          .build();
-    }
+        if ("close".equalsIgnoreCase(response.request().header("Connection"))
+                || "close".equalsIgnoreCase(response.header("Connection"))) {
+            streamAllocation.noNewStreams();
+        }
 
-    if ("close".equalsIgnoreCase(response.request().header("Connection"))
-        || "close".equalsIgnoreCase(response.header("Connection"))) {
-      streamAllocation.noNewStreams();
-    }
+        if ((code == 204 || code == 205) && response.body().contentLength() > 0) {
+            throw new ProtocolException(
+                    "HTTP " + code + " had non-zero Content-Length: " + response.body().contentLength());
+        }
 
-    if ((code == 204 || code == 205) && response.body().contentLength() > 0) {
-      throw new ProtocolException(
-          "HTTP " + code + " had non-zero Content-Length: " + response.body().contentLength());
+        return response;
     }
-
-    return response;
-  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
index 792ddc9299..455e4b7045 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
@@ -26,6 +26,7 @@
 import javax.net.ssl.SSLHandshakeException;
 import javax.net.ssl.SSLPeerUnverifiedException;
 import javax.net.ssl.SSLSocketFactory;
+
 import okhttp3.Address;
 import okhttp3.CertificatePinner;
 import okhttp3.Connection;
@@ -56,308 +57,319 @@
  * {@link IOException} if the call was canceled.
  */
 public final class RetryAndFollowUpInterceptor implements Interceptor {
-  /**
-   * How many redirects and auth challenges should we attempt? Chrome follows 21 redirects; Firefox,
-   * curl, and wget follow 20; Safari follows 16; and HTTP/1.0 recommends 5.
-   */
-  private static final int MAX_FOLLOW_UPS = 20;
-
-  private final OkHttpClient client;
-  private final boolean forWebSocket;
-  private StreamAllocation streamAllocation;
-  private Object callStackTrace;
-  private volatile boolean canceled;
-
-  public RetryAndFollowUpInterceptor(OkHttpClient client, boolean forWebSocket) {
-    this.client = client;
-    this.forWebSocket = forWebSocket;
-  }
-
-  /**
-   * Immediately closes the socket connection if it's currently held. Use this to interrupt an
-   * in-flight request from any thread. It's the caller's responsibility to close the request body
-   * and response body streams; otherwise resources may be leaked.
-   *
-   * <p>This method is safe to be called concurrently, but provides limited guarantees. If a
-   * transport layer connection has been established (such as a HTTP/2 stream) that is terminated.
-   * Otherwise if a socket connection is being established, that is terminated.
-   */
-  public void cancel() {
-    canceled = true;
-    StreamAllocation streamAllocation = this.streamAllocation;
-    if (streamAllocation != null) streamAllocation.cancel();
-  }
-
-  public boolean isCanceled() {
-    return canceled;
-  }
-
-  public void setCallStackTrace(Object callStackTrace) {
-    this.callStackTrace = callStackTrace;
-  }
-
-  public StreamAllocation streamAllocation() {
-    return streamAllocation;
-  }
-
-  @Override public Response intercept(Chain chain) throws IOException {
-    Request request = chain.request();
-
-    streamAllocation = new StreamAllocation(
-        client.connectionPool(), createAddress(request.url()), callStackTrace);
-
-    int followUpCount = 0;
-    Response priorResponse = null;
-    while (true) {
-      if (canceled) {
-        streamAllocation.release();
-        throw new IOException("Canceled");
-      }
-
-      Response response = null;
-      boolean releaseConnection = true;
-      try {
-        response = ((RealInterceptorChain) chain).proceed(request, streamAllocation, null, null);
-        releaseConnection = false;
-      } catch (RouteException e) {
-        // The attempt to connect via a route failed. The request will not have been sent.
-        if (!recover(e.getLastConnectException(), false, request)) {
-          throw e.getLastConnectException();
-        }
-        releaseConnection = false;
-        continue;
-      } catch (IOException e) {
-        // An attempt to communicate with a server failed. The request may have been sent.
-        boolean requestSendStarted = !(e instanceof ConnectionShutdownException);
-        if (!recover(e, requestSendStarted, request)) throw e;
-        releaseConnection = false;
-        continue;
-      } finally {
-        // We're throwing an unchecked exception. Release any resources.
-        if (releaseConnection) {
-          streamAllocation.streamFailed(null);
-          streamAllocation.release();
-        }
-      }
-
-      // Attach the prior response if it exists. Such responses never have a body.
-      if (priorResponse != null) {
-        response = response.newBuilder()
-            .priorResponse(priorResponse.newBuilder()
-                    .body(null)
-                    .build())
-            .build();
-      }
-
-      Request followUp = followUpRequest(response);
-
-      if (followUp == null) {
-        if (!forWebSocket) {
-          streamAllocation.release();
-        }
-        return response;
-      }
-
-      closeQuietly(response.body());
+    /**
+     * How many redirects and auth challenges should we attempt? Chrome follows 21 redirects; Firefox,
+     * curl, and wget follow 20; Safari follows 16; and HTTP/1.0 recommends 5.
+     * 跟踪重定向的次数
+     */
+    private static final int MAX_FOLLOW_UPS = 20;
+
+    private final OkHttpClient client;
+    private final boolean forWebSocket;
+    private StreamAllocation streamAllocation;
+    private Object callStackTrace;
+    private volatile boolean canceled;
+
+    public RetryAndFollowUpInterceptor(OkHttpClient client, boolean forWebSocket) {
+        this.client = client;
+        this.forWebSocket = forWebSocket;
+    }
 
-      if (++followUpCount > MAX_FOLLOW_UPS) {
-        streamAllocation.release();
-        throw new ProtocolException("Too many follow-up requests: " + followUpCount);
-      }
+    /**
+     * Immediately closes the socket connection if it's currently held. Use this to interrupt an
+     * in-flight request from any thread. It's the caller's responsibility to close the request body
+     * and response body streams; otherwise resources may be leaked.
+     * <p>
+     * <p>This method is safe to be called concurrently, but provides limited guarantees. If a
+     * transport layer connection has been established (such as a HTTP/2 stream) that is terminated.
+     * Otherwise if a socket connection is being established, that is terminated.
+     */
+    public void cancel() {
+        canceled = true;
+        StreamAllocation streamAllocation = this.streamAllocation;
+        if (streamAllocation != null) streamAllocation.cancel();
+    }
 
-      if (followUp.body() instanceof UnrepeatableRequestBody) {
-        streamAllocation.release();
-        throw new HttpRetryException("Cannot retry streamed HTTP body", response.code());
-      }
+    public boolean isCanceled() {
+        return canceled;
+    }
 
-      if (!sameConnection(response, followUp.url())) {
-        streamAllocation.release();
-        streamAllocation = new StreamAllocation(
-            client.connectionPool(), createAddress(followUp.url()), callStackTrace);
-      } else if (streamAllocation.codec() != null) {
-        throw new IllegalStateException("Closing the body of " + response
-            + " didn't close its backing stream. Bad interceptor?");
-      }
-
-      request = followUp;
-      priorResponse = response;
+    public void setCallStackTrace(Object callStackTrace) {
+        this.callStackTrace = callStackTrace;
     }
-  }
-
-  private Address createAddress(HttpUrl url) {
-    SSLSocketFactory sslSocketFactory = null;
-    HostnameVerifier hostnameVerifier = null;
-    CertificatePinner certificatePinner = null;
-    if (url.isHttps()) {
-      sslSocketFactory = client.sslSocketFactory();
-      hostnameVerifier = client.hostnameVerifier();
-      certificatePinner = client.certificatePinner();
+
+    public StreamAllocation streamAllocation() {
+        return streamAllocation;
     }
 
-    return new Address(url.host(), url.port(), client.dns(), client.socketFactory(),
-        sslSocketFactory, hostnameVerifier, certificatePinner, client.proxyAuthenticator(),
-        client.proxy(), client.protocols(), client.connectionSpecs(), client.proxySelector());
-  }
+    @Override
+    public Response intercept(Chain chain) throws IOException {
+        Request request = chain.request();
 
-  /**
-   * Report and attempt to recover from a failure to communicate with a server. Returns true if
-   * {@code e} is recoverable, or false if the failure is permanent. Requests with a body can only
-   * be recovered if the body is buffered or if the failure occurred before the request has been
-   * sent.
-   */
-  private boolean recover(IOException e, boolean requestSendStarted, Request userRequest) {
-    streamAllocation.streamFailed(e);
+        streamAllocation = new StreamAllocation(
+                client.connectionPool(), createAddress(request.url()), callStackTrace);
+
+        int followUpCount = 0;
+        Response priorResponse = null;
+        while (true) {
+            if (canceled) {
+                streamAllocation.release();
+                throw new IOException("Canceled");
+            }
+
+            Response response = null;
+            boolean releaseConnection = true;
+            try {
+                // 转入桥拦截器
+                response = ((RealInterceptorChain) chain).proceed(request, streamAllocation, null, null);
+                releaseConnection = false;
+            } catch (RouteException e) {
+                // The attempt to connect via a route failed. The request will not have been sent.
+                if (!recover(e.getLastConnectException(), false, request)) {
+                    throw e.getLastConnectException();
+                }
+                releaseConnection = false;
+                continue;
+            } catch (IOException e) {
+                // An attempt to communicate with a server failed. The request may have been sent.
+                boolean requestSendStarted = !(e instanceof ConnectionShutdownException);
+                if (!recover(e, requestSendStarted, request)) throw e;
+                releaseConnection = false;
+                continue;
+            } finally {
+                // We're throwing an unchecked exception. Release any resources.
+                if (releaseConnection) {
+                    streamAllocation.streamFailed(null);
+                    streamAllocation.release();
+                }
+            }
+
+            // Attach the prior response if it exists. Such responses never have a body.
+            if (priorResponse != null) {
+                response = response.newBuilder()
+                        .priorResponse(priorResponse.newBuilder()
+                                .body(null)
+                                .build())
+                        .build();
+            }
+
+            // 处理重定向
+            Request followUp = followUpRequest(response);
+
+            if (followUp == null) {
+                if (!forWebSocket) {
+                    streamAllocation.release();
+                }
+                return response;
+            }
+
+            closeQuietly(response.body());
+
+            if (++followUpCount > MAX_FOLLOW_UPS) {// 超过最大重试次数
+                streamAllocation.release();
+                throw new ProtocolException("Too many follow-up requests: " + followUpCount);
+            }
+
+            if (followUp.body() instanceof UnrepeatableRequestBody) {
+                streamAllocation.release();
+                throw new HttpRetryException("Cannot retry streamed HTTP body", response.code());
+            }
+
+            if (!sameConnection(response, followUp.url())) {
+                streamAllocation.release();
+                streamAllocation = new StreamAllocation(
+                        client.connectionPool(), createAddress(followUp.url()), callStackTrace);
+            } else if (streamAllocation.codec() != null) {
+                throw new IllegalStateException("Closing the body of " + response
+                        + " didn't close its backing stream. Bad interceptor?");
+            }
+
+            request = followUp;
+            priorResponse = response;
+        }
+    }
 
-    // The application layer has forbidden retries.
-    if (!client.retryOnConnectionFailure()) return false;
+    /**
+     * 创建一个Address。只是存储了诸多请求信息
+     */
+    private Address createAddress(HttpUrl url) {
+        SSLSocketFactory sslSocketFactory = null;
+        HostnameVerifier hostnameVerifier = null;
+        CertificatePinner certificatePinner = null;
+        if (url.isHttps()) {
+            sslSocketFactory = client.sslSocketFactory();
+            hostnameVerifier = client.hostnameVerifier();
+            certificatePinner = client.certificatePinner();
+        }
 
-    // We can't send the request body again.
-    if (requestSendStarted && userRequest.body() instanceof UnrepeatableRequestBody) return false;
+        return new Address(url.host(), url.port(), client.dns(), client.socketFactory(),
+                sslSocketFactory, hostnameVerifier, certificatePinner, client.proxyAuthenticator(),
+                client.proxy(), client.protocols(), client.connectionSpecs(), client.proxySelector());
+    }
 
-    // This exception is fatal.
-    if (!isRecoverable(e, requestSendStarted)) return false;
+    /**
+     * Report and attempt to recover from a failure to communicate with a server. Returns true if
+     * {@code e} is recoverable, or false if the failure is permanent. Requests with a body can only
+     * be recovered if the body is buffered or if the failure occurred before the request has been
+     * sent.
+     * 判断是否能恢复/重试
+     */
+    private boolean recover(IOException e, boolean requestSendStarted, Request userRequest) {
+        streamAllocation.streamFailed(e);
 
-    // No more routes to attempt.
-    if (!streamAllocation.hasMoreRoutes()) return false;
+        // The application layer has forbidden retries. 用户禁止重试
+        if (!client.retryOnConnectionFailure()) return false;
 
-    // For failure recovery, use the same route selector with a new connection.
-    return true;
-  }
+        // We can't send the request body again.  已经发送过了或者 请求体不可重复
+        if (requestSendStarted && userRequest.body() instanceof UnrepeatableRequestBody) return false;
 
-  private boolean isRecoverable(IOException e, boolean requestSendStarted) {
-    // If there was a protocol problem, don't recover.
-    if (e instanceof ProtocolException) {
-      return false;
-    }
+        // This exception is fatal.  致命异常：协议错误，非连接超时，证书错误，SSLPeerUnverifiedException
+        if (!isRecoverable(e, requestSendStarted)) return false;
 
-    // If there was an interruption don't recover, but if there was a timeout connecting to a route
-    // we should try the next route (if there is one).
-    if (e instanceof InterruptedIOException) {
-      return e instanceof SocketTimeoutException && !requestSendStarted;
-    }
+        // No more routes to attempt. 没有更多的路线可供尝试
+        if (!streamAllocation.hasMoreRoutes()) return false;
 
-    // Look for known client-side or negotiation errors that are unlikely to be fixed by trying
-    // again with a different route.
-    if (e instanceof SSLHandshakeException) {
-      // If the problem was a CertificateException from the X509TrustManager,
-      // do not retry.
-      if (e.getCause() instanceof CertificateException) {
-        return false;
-      }
-    }
-    if (e instanceof SSLPeerUnverifiedException) {
-      // e.g. a certificate pinning error.
-      return false;
+        // For failure recovery, use the same route selector with a new connection.
+        return true;
     }
 
-    // An example of one we might want to retry with a different route is a problem connecting to a
-    // proxy and would manifest as a standard IOException. Unless it is one we know we should not
-    // retry, we return true and try a new route.
-    return true;
-  }
-
-  /**
-   * Figures out the HTTP request to make in response to receiving {@code userResponse}. This will
-   * either add authentication headers, follow redirects or handle a client request timeout. If a
-   * follow-up is either unnecessary or not applicable, this returns null.
-   */
-  private Request followUpRequest(Response userResponse) throws IOException {
-    if (userResponse == null) throw new IllegalStateException();
-    Connection connection = streamAllocation.connection();
-    Route route = connection != null
-        ? connection.route()
-        : null;
-    int responseCode = userResponse.code();
-
-    final String method = userResponse.request().method();
-    switch (responseCode) {
-      case HTTP_PROXY_AUTH:
-        Proxy selectedProxy = route != null
-            ? route.proxy()
-            : client.proxy();
-        if (selectedProxy.type() != Proxy.Type.HTTP) {
-          throw new ProtocolException("Received HTTP_PROXY_AUTH (407) code while not using proxy");
+    /**
+     * 是否还能恢复
+     */
+    private boolean isRecoverable(IOException e, boolean requestSendStarted) {
+        // If there was a protocol problem, don't recover.
+        if (e instanceof ProtocolException) {
+            return false;
         }
-        return client.proxyAuthenticator().authenticate(route, userResponse);
 
-      case HTTP_UNAUTHORIZED:
-        return client.authenticator().authenticate(route, userResponse);
-
-      case HTTP_PERM_REDIRECT:
-      case HTTP_TEMP_REDIRECT:
-        // "If the 307 or 308 status code is received in response to a request other than GET
-        // or HEAD, the user agent MUST NOT automatically redirect the request"
-        if (!method.equals("GET") && !method.equals("HEAD")) {
-          return null;
-        }
-        // fall-through
-      case HTTP_MULT_CHOICE:
-      case HTTP_MOVED_PERM:
-      case HTTP_MOVED_TEMP:
-      case HTTP_SEE_OTHER:
-        // Does the client allow redirects?
-        if (!client.followRedirects()) return null;
-
-        String location = userResponse.header("Location");
-        if (location == null) return null;
-        HttpUrl url = userResponse.request().url().resolve(location);
-
-        // Don't follow redirects to unsupported protocols.
-        if (url == null) return null;
-
-        // If configured, don't follow redirects between SSL and non-SSL.
-        boolean sameScheme = url.scheme().equals(userResponse.request().url().scheme());
-        if (!sameScheme && !client.followSslRedirects()) return null;
-
-        // Most redirects don't include a request body.
-        Request.Builder requestBuilder = userResponse.request().newBuilder();
-        if (HttpMethod.permitsRequestBody(method)) {
-          final boolean maintainBody = HttpMethod.redirectsWithBody(method);
-          if (HttpMethod.redirectsToGet(method)) {
-            requestBuilder.method("GET", null);
-          } else {
-            RequestBody requestBody = maintainBody ? userResponse.request().body() : null;
-            requestBuilder.method(method, requestBody);
-          }
-          if (!maintainBody) {
-            requestBuilder.removeHeader("Transfer-Encoding");
-            requestBuilder.removeHeader("Content-Length");
-            requestBuilder.removeHeader("Content-Type");
-          }
+        // If there was an interruption don't recover, but if there was a timeout connecting to a route
+        // we should try the next route (if there is one).
+        if (e instanceof InterruptedIOException) {
+            return e instanceof SocketTimeoutException && !requestSendStarted;
         }
 
-        // When redirecting across hosts, drop all authentication headers. This
-        // is potentially annoying to the application layer since they have no
-        // way to retain them.
-        if (!sameConnection(userResponse, url)) {
-          requestBuilder.removeHeader("Authorization");
+        // Look for known client-side or negotiation errors that are unlikely to be fixed by trying
+        // again with a different route.
+        if (e instanceof SSLHandshakeException) {
+            // If the problem was a CertificateException from the X509TrustManager,
+            // do not retry.
+            if (e.getCause() instanceof CertificateException) {
+                return false;
+            }
+        }
+        if (e instanceof SSLPeerUnverifiedException) {
+            // e.g. a certificate pinning error.
+            return false;
         }
 
-        return requestBuilder.url(url).build();
+        // An example of one we might want to retry with a different route is a problem connecting to a
+        // proxy and would manifest as a standard IOException. Unless it is one we know we should not
+        // retry, we return true and try a new route.
+        return true;
+    }
 
-      case HTTP_CLIENT_TIMEOUT:
-        // 408's are rare in practice, but some servers like HAProxy use this response code. The
-        // spec says that we may repeat the request without modifications. Modern browsers also
-        // repeat the request (even non-idempotent ones.)
-        if (userResponse.request().body() instanceof UnrepeatableRequestBody) {
-          return null;
+    /**
+     * Figures out the HTTP request to make in response to receiving {@code userResponse}. This will
+     * either add authentication headers, follow redirects or handle a client request timeout. If a
+     * follow-up is either unnecessary or not applicable, this returns null.
+     */
+    private Request followUpRequest(Response userResponse) throws IOException {
+        if (userResponse == null) throw new IllegalStateException();
+        Connection connection = streamAllocation.connection();
+        Route route = connection != null
+                ? connection.route()
+                : null;
+        int responseCode = userResponse.code();
+
+        final String method = userResponse.request().method();
+        switch (responseCode) {
+            case HTTP_PROXY_AUTH:
+                Proxy selectedProxy = route != null
+                        ? route.proxy()
+                        : client.proxy();
+                if (selectedProxy.type() != Proxy.Type.HTTP) {
+                    throw new ProtocolException("Received HTTP_PROXY_AUTH (407) code while not using proxy");
+                }
+                return client.proxyAuthenticator().authenticate(route, userResponse);
+
+            case HTTP_UNAUTHORIZED:
+                return client.authenticator().authenticate(route, userResponse);
+
+            case HTTP_PERM_REDIRECT:
+            case HTTP_TEMP_REDIRECT:
+                // "If the 307 or 308 status code is received in response to a request other than GET
+                // or HEAD, the user agent MUST NOT automatically redirect the request"
+                if (!method.equals("GET") && !method.equals("HEAD")) {
+                    return null;
+                }
+                // fall-through
+            case HTTP_MULT_CHOICE:
+            case HTTP_MOVED_PERM:
+            case HTTP_MOVED_TEMP:
+            case HTTP_SEE_OTHER:
+                // Does the client allow redirects?
+                if (!client.followRedirects()) return null;
+
+                String location = userResponse.header("Location");
+                if (location == null) return null;
+                HttpUrl url = userResponse.request().url().resolve(location);
+
+                // Don't follow redirects to unsupported protocols.
+                if (url == null) return null;
+
+                // If configured, don't follow redirects between SSL and non-SSL.
+                boolean sameScheme = url.scheme().equals(userResponse.request().url().scheme());
+                if (!sameScheme && !client.followSslRedirects()) return null;
+
+                // Most redirects don't include a request body.
+                Request.Builder requestBuilder = userResponse.request().newBuilder();
+                if (HttpMethod.permitsRequestBody(method)) {
+                    final boolean maintainBody = HttpMethod.redirectsWithBody(method);
+                    if (HttpMethod.redirectsToGet(method)) {
+                        requestBuilder.method("GET", null);
+                    } else {
+                        RequestBody requestBody = maintainBody ? userResponse.request().body() : null;
+                        requestBuilder.method(method, requestBody);
+                    }
+                    if (!maintainBody) {
+                        requestBuilder.removeHeader("Transfer-Encoding");
+                        requestBuilder.removeHeader("Content-Length");
+                        requestBuilder.removeHeader("Content-Type");
+                    }
+                }
+
+                // When redirecting across hosts, drop all authentication headers. This
+                // is potentially annoying to the application layer since they have no
+                // way to retain them.
+                if (!sameConnection(userResponse, url)) {
+                    requestBuilder.removeHeader("Authorization");
+                }
+
+                return requestBuilder.url(url).build();
+
+            case HTTP_CLIENT_TIMEOUT:
+                // 408's are rare in practice, but some servers like HAProxy use this response code. The
+                // spec says that we may repeat the request without modifications. Modern browsers also
+                // repeat the request (even non-idempotent ones.)
+                if (userResponse.request().body() instanceof UnrepeatableRequestBody) {
+                    return null;
+                }
+
+                return userResponse.request();
+
+            default:
+                return null;
         }
+    }
 
-        return userResponse.request();
-
-      default:
-        return null;
+    /**
+     * Returns true if an HTTP request for {@code followUp} can reuse the connection used by this
+     * engine.
+     */
+    private boolean sameConnection(Response response, HttpUrl followUp) {
+        HttpUrl url = response.request().url();
+        return url.host().equals(followUp.host())
+                && url.port() == followUp.port()
+                && url.scheme().equals(followUp.scheme());
     }
-  }
-
-  /**
-   * Returns true if an HTTP request for {@code followUp} can reuse the connection used by this
-   * engine.
-   */
-  private boolean sameConnection(Response response, HttpUrl followUp) {
-    HttpUrl url = response.request().url();
-    return url.host().equals(followUp.host())
-        && url.port() == followUp.port()
-        && url.scheme().equals(followUp.scheme());
-  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java b/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java
index 625c173bf3..c32865de49 100644
--- a/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java
+++ b/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java
@@ -18,6 +18,7 @@
 import java.io.EOFException;
 import java.io.IOException;
 import java.net.ProtocolException;
+
 import okhttp3.Headers;
 import okhttp3.HttpUrl;
 import okhttp3.OkHttpClient;
@@ -49,451 +50,492 @@
 /**
  * A socket connection that can be used to send HTTP/1.1 messages. This class strictly enforces the
  * following lifecycle:
- *
+ * <p>
  * <ol>
- *     <li>{@linkplain #writeRequest Send request headers}.
- *     <li>Open a sink to write the request body. Either {@linkplain #newFixedLengthSink
- *         fixed-length} or {@link #newChunkedSink chunked}.
- *     <li>Write to and then close that sink.
- *     <li>{@linkplain #readResponseHeaders Read response headers}.
- *     <li>Open a source to read the response body. Either {@linkplain #newFixedLengthSource
- *         fixed-length}, {@linkplain #newChunkedSource chunked} or {@linkplain
- *         #newUnknownLengthSource unknown length}.
- *     <li>Read from and close that source.
+ * <li>{@linkplain #writeRequest Send request headers}.
+ * <li>Open a sink to write the request body. Either {@linkplain #newFixedLengthSink
+ * fixed-length} or {@link #newChunkedSink chunked}.
+ * <li>Write to and then close that sink.
+ * <li>{@linkplain #readResponseHeaders Read response headers}.
+ * <li>Open a source to read the response body. Either {@linkplain #newFixedLengthSource
+ * fixed-length}, {@linkplain #newChunkedSource chunked} or {@linkplain
+ * #newUnknownLengthSource unknown length}.
+ * <li>Read from and close that source.
  * </ol>
- *
+ * <p>
  * <p>Exchanges that do not have a request body may skip creating and closing the request body.
  * Exchanges that do not have a response body can call {@link #newFixedLengthSource(long)
  * newFixedLengthSource(0)} and may skip reading and closing that source.
  */
 public final class Http1Codec implements HttpCodec {
-  private static final int STATE_IDLE = 0; // Idle connections are ready to write request headers.
-  private static final int STATE_OPEN_REQUEST_BODY = 1;
-  private static final int STATE_WRITING_REQUEST_BODY = 2;
-  private static final int STATE_READ_RESPONSE_HEADERS = 3;
-  private static final int STATE_OPEN_RESPONSE_BODY = 4;
-  private static final int STATE_READING_RESPONSE_BODY = 5;
-  private static final int STATE_CLOSED = 6;
-
-  /** The client that configures this stream. May be null for HTTPS proxy tunnels. */
-  final OkHttpClient client;
-  /** The stream allocation that owns this stream. May be null for HTTPS proxy tunnels. */
-  final StreamAllocation streamAllocation;
-
-  final BufferedSource source;
-  final BufferedSink sink;
-  int state = STATE_IDLE;
-
-  public Http1Codec(OkHttpClient client, StreamAllocation streamAllocation, BufferedSource source,
-      BufferedSink sink) {
-    this.client = client;
-    this.streamAllocation = streamAllocation;
-    this.source = source;
-    this.sink = sink;
-  }
-
-  @Override public Sink createRequestBody(Request request, long contentLength) {
-    if ("chunked".equalsIgnoreCase(request.header("Transfer-Encoding"))) {
-      // Stream a request body of unknown length.
-      return newChunkedSink();
-    }
+    private static final int STATE_IDLE = 0; // Idle connections are ready to write request headers.
+    private static final int STATE_OPEN_REQUEST_BODY = 1;
+    private static final int STATE_WRITING_REQUEST_BODY = 2;
+    private static final int STATE_READ_RESPONSE_HEADERS = 3;
+    private static final int STATE_OPEN_RESPONSE_BODY = 4;
+    private static final int STATE_READING_RESPONSE_BODY = 5;
+    private static final int STATE_CLOSED = 6;
 
-    if (contentLength != -1) {
-      // Stream a request body of a known length.
-      return newFixedLengthSink(contentLength);
+    /**
+     * The client that configures this stream. May be null for HTTPS proxy tunnels.
+     */
+    final OkHttpClient client;
+    /**
+     * The stream allocation that owns this stream. May be null for HTTPS proxy tunnels.
+     */
+    final StreamAllocation streamAllocation;
+
+    final BufferedSource source;
+    final BufferedSink sink;
+    int state = STATE_IDLE;
+
+    public Http1Codec(OkHttpClient client, StreamAllocation streamAllocation, BufferedSource source,
+                      BufferedSink sink) {
+        this.client = client;
+        this.streamAllocation = streamAllocation;
+        this.source = source;
+        this.sink = sink;
     }
 
-    throw new IllegalStateException(
-        "Cannot stream a request body without chunked encoding or a known content length!");
-  }
-
-  @Override public void cancel() {
-    RealConnection connection = streamAllocation.connection();
-    if (connection != null) connection.cancel();
-  }
-
-  /**
-   * Prepares the HTTP headers and sends them to the server.
-   *
-   * <p>For streaming requests with a body, headers must be prepared <strong>before</strong> the
-   * output stream has been written to. Otherwise the body would need to be buffered!
-   *
-   * <p>For non-streaming requests with a body, headers must be prepared <strong>after</strong> the
-   * output stream has been written to and closed. This ensures that the {@code Content-Length}
-   * header field receives the proper value.
-   */
-  @Override public void writeRequestHeaders(Request request) throws IOException {
-    String requestLine = RequestLine.get(
-        request, streamAllocation.connection().route().proxy().type());
-    writeRequest(request.headers(), requestLine);
-  }
-
-  @Override public ResponseBody openResponseBody(Response response) throws IOException {
-    Source source = getTransferStream(response);
-    return new RealResponseBody(response.headers(), Okio.buffer(source));
-  }
-
-  private Source getTransferStream(Response response) throws IOException {
-    if (!HttpHeaders.hasBody(response)) {
-      return newFixedLengthSource(0);
-    }
+    @Override
+    public Sink createRequestBody(Request request, long contentLength) {
+        if ("chunked".equalsIgnoreCase(request.header("Transfer-Encoding"))) {
+            // Stream a request body of unknown length.
+            return newChunkedSink();
+        }
 
-    if ("chunked".equalsIgnoreCase(response.header("Transfer-Encoding"))) {
-      return newChunkedSource(response.request().url());
-    }
+        if (contentLength != -1) {
+            // Stream a request body of a known length.
+            return newFixedLengthSink(contentLength);
+        }
 
-    long contentLength = HttpHeaders.contentLength(response);
-    if (contentLength != -1) {
-      return newFixedLengthSource(contentLength);
+        throw new IllegalStateException(
+                "Cannot stream a request body without chunked encoding or a known content length!");
     }
 
-    // Wrap the input stream from the connection (rather than just returning
-    // "socketIn" directly here), so that we can control its use after the
-    // reference escapes.
-    return newUnknownLengthSource();
-  }
-
-  /** Returns true if this connection is closed. */
-  public boolean isClosed() {
-    return state == STATE_CLOSED;
-  }
-
-  @Override public void flushRequest() throws IOException {
-    sink.flush();
-  }
-
-  @Override public void finishRequest() throws IOException {
-    sink.flush();
-  }
-
-  /** Returns bytes of a request header for sending on an HTTP transport. */
-  public void writeRequest(Headers headers, String requestLine) throws IOException {
-    if (state != STATE_IDLE) throw new IllegalStateException("state: " + state);
-    sink.writeUtf8(requestLine).writeUtf8("\r\n");
-    for (int i = 0, size = headers.size(); i < size; i++) {
-      sink.writeUtf8(headers.name(i))
-          .writeUtf8(": ")
-          .writeUtf8(headers.value(i))
-          .writeUtf8("\r\n");
+    @Override
+    public void cancel() {
+        RealConnection connection = streamAllocation.connection();
+        if (connection != null) connection.cancel();
     }
-    sink.writeUtf8("\r\n");
-    state = STATE_OPEN_REQUEST_BODY;
-  }
 
-  @Override public Response.Builder readResponseHeaders(boolean expectContinue) throws IOException {
-    if (state != STATE_OPEN_REQUEST_BODY && state != STATE_READ_RESPONSE_HEADERS) {
-      throw new IllegalStateException("state: " + state);
+    /**
+     * Prepares the HTTP headers and sends them to the server.
+     * <p>
+     * <p>For streaming requests with a body, headers must be prepared <strong>before</strong> the
+     * output stream has been written to. Otherwise the body would need to be buffered!
+     * <p>
+     * <p>For non-streaming requests with a body, headers must be prepared <strong>after</strong> the
+     * output stream has been written to and closed. This ensures that the {@code Content-Length}
+     * header field receives the proper value.
+     */
+    @Override
+    public void writeRequestHeaders(Request request) throws IOException {
+        String requestLine = RequestLine.get(
+                request, streamAllocation.connection().route().proxy().type());
+        writeRequest(request.headers(), requestLine);
     }
 
-    try {
-      StatusLine statusLine = StatusLine.parse(source.readUtf8LineStrict());
-
-      Response.Builder responseBuilder = new Response.Builder()
-          .protocol(statusLine.protocol)
-          .code(statusLine.code)
-          .message(statusLine.message)
-          .headers(readHeaders());
-
-      if (expectContinue && statusLine.code == HTTP_CONTINUE) {
-        return null;
-      }
-
-      state = STATE_OPEN_RESPONSE_BODY;
-      return responseBuilder;
-    } catch (EOFException e) {
-      // Provide more context if the server ends the stream before sending a response.
-      IOException exception = new IOException("unexpected end of stream on " + streamAllocation);
-      exception.initCause(e);
-      throw exception;
+    @Override
+    public ResponseBody openResponseBody(Response response) throws IOException {
+        Source source = getTransferStream(response);
+        return new RealResponseBody(response.headers(), Okio.buffer(source));
     }
-  }
-
-  /** Reads headers or trailers. */
-  public Headers readHeaders() throws IOException {
-    Headers.Builder headers = new Headers.Builder();
-    // parse the result headers until the first blank line
-    for (String line; (line = source.readUtf8LineStrict()).length() != 0; ) {
-      Internal.instance.addLenient(headers, line);
-    }
-    return headers.build();
-  }
-
-  public Sink newChunkedSink() {
-    if (state != STATE_OPEN_REQUEST_BODY) throw new IllegalStateException("state: " + state);
-    state = STATE_WRITING_REQUEST_BODY;
-    return new ChunkedSink();
-  }
-
-  public Sink newFixedLengthSink(long contentLength) {
-    if (state != STATE_OPEN_REQUEST_BODY) throw new IllegalStateException("state: " + state);
-    state = STATE_WRITING_REQUEST_BODY;
-    return new FixedLengthSink(contentLength);
-  }
-
-  public Source newFixedLengthSource(long length) throws IOException {
-    if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
-    state = STATE_READING_RESPONSE_BODY;
-    return new FixedLengthSource(length);
-  }
-
-  public Source newChunkedSource(HttpUrl url) throws IOException {
-    if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
-    state = STATE_READING_RESPONSE_BODY;
-    return new ChunkedSource(url);
-  }
-
-  public Source newUnknownLengthSource() throws IOException {
-    if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
-    if (streamAllocation == null) throw new IllegalStateException("streamAllocation == null");
-    state = STATE_READING_RESPONSE_BODY;
-    streamAllocation.noNewStreams();
-    return new UnknownLengthSource();
-  }
-
-  /**
-   * Sets the delegate of {@code timeout} to {@link Timeout#NONE} and resets its underlying timeout
-   * to the default configuration. Use this to avoid unexpected sharing of timeouts between pooled
-   * connections.
-   */
-  void detachTimeout(ForwardingTimeout timeout) {
-    Timeout oldDelegate = timeout.delegate();
-    timeout.setDelegate(Timeout.NONE);
-    oldDelegate.clearDeadline();
-    oldDelegate.clearTimeout();
-  }
-
-  /** An HTTP body with a fixed length known in advance. */
-  private final class FixedLengthSink implements Sink {
-    private final ForwardingTimeout timeout = new ForwardingTimeout(sink.timeout());
-    private boolean closed;
-    private long bytesRemaining;
-
-    FixedLengthSink(long bytesRemaining) {
-      this.bytesRemaining = bytesRemaining;
+
+    private Source getTransferStream(Response response) throws IOException {
+        if (!HttpHeaders.hasBody(response)) {
+            return newFixedLengthSource(0);
+        }
+
+        if ("chunked".equalsIgnoreCase(response.header("Transfer-Encoding"))) {
+            return newChunkedSource(response.request().url());
+        }
+
+        long contentLength = HttpHeaders.contentLength(response);
+        if (contentLength != -1) {
+            return newFixedLengthSource(contentLength);
+        }
+
+        // Wrap the input stream from the connection (rather than just returning
+        // "socketIn" directly here), so that we can control its use after the
+        // reference escapes.
+        return newUnknownLengthSource();
     }
 
-    @Override public Timeout timeout() {
-      return timeout;
+    /**
+     * Returns true if this connection is closed.
+     */
+    public boolean isClosed() {
+        return state == STATE_CLOSED;
     }
 
-    @Override public void write(Buffer source, long byteCount) throws IOException {
-      if (closed) throw new IllegalStateException("closed");
-      checkOffsetAndCount(source.size(), 0, byteCount);
-      if (byteCount > bytesRemaining) {
-        throw new ProtocolException("expected " + bytesRemaining
-            + " bytes but received " + byteCount);
-      }
-      sink.write(source, byteCount);
-      bytesRemaining -= byteCount;
+    @Override
+    public void flushRequest() throws IOException {
+        sink.flush();
     }
 
-    @Override public void flush() throws IOException {
-      if (closed) return; // Don't throw; this stream might have been closed on the caller's behalf.
-      sink.flush();
+    @Override
+    public void finishRequest() throws IOException {
+        sink.flush();
     }
 
-    @Override public void close() throws IOException {
-      if (closed) return;
-      closed = true;
-      if (bytesRemaining > 0) throw new ProtocolException("unexpected end of stream");
-      detachTimeout(timeout);
-      state = STATE_READ_RESPONSE_HEADERS;
+    /**
+     * Returns bytes of a request header for sending on an HTTP transport.
+     */
+    public void writeRequest(Headers headers, String requestLine) throws IOException {
+        if (state != STATE_IDLE) throw new IllegalStateException("state: " + state);
+        sink.writeUtf8(requestLine).writeUtf8("\r\n");
+        for (int i = 0, size = headers.size(); i < size; i++) {
+            sink.writeUtf8(headers.name(i))
+                    .writeUtf8(": ")
+                    .writeUtf8(headers.value(i))
+                    .writeUtf8("\r\n");
+        }
+        sink.writeUtf8("\r\n");
+        state = STATE_OPEN_REQUEST_BODY;
     }
-  }
 
-  /**
-   * An HTTP body with alternating chunk sizes and chunk bodies. It is the caller's responsibility
-   * to buffer chunks; typically by using a buffered sink with this sink.
-   */
-  private final class ChunkedSink implements Sink {
-    private final ForwardingTimeout timeout = new ForwardingTimeout(sink.timeout());
-    private boolean closed;
+    @Override
+    public Response.Builder readResponseHeaders(boolean expectContinue) throws IOException {
+        if (state != STATE_OPEN_REQUEST_BODY && state != STATE_READ_RESPONSE_HEADERS) {
+            throw new IllegalStateException("state: " + state);
+        }
 
-    ChunkedSink() {
+        try {
+            // 读取响应行
+            StatusLine statusLine = StatusLine.parse(source.readUtf8LineStrict());
+
+            Response.Builder responseBuilder = new Response.Builder()
+                    .protocol(statusLine.protocol)
+                    .code(statusLine.code)
+                    .message(statusLine.message)
+                    .headers(readHeaders());
+
+            if (expectContinue && statusLine.code == HTTP_CONTINUE) {
+                return null;
+            }
+
+            state = STATE_OPEN_RESPONSE_BODY;
+            return responseBuilder;
+        } catch (EOFException e) {
+            // Provide more context if the server ends the stream before sending a response.
+            IOException exception = new IOException("unexpected end of stream on " + streamAllocation);
+            exception.initCause(e);
+            throw exception;
+        }
     }
 
-    @Override public Timeout timeout() {
-      return timeout;
+    /**
+     * Reads headers or trailers. 读取响应头
+     */
+    public Headers readHeaders() throws IOException {
+        Headers.Builder headers = new Headers.Builder();
+        // parse the result headers until the first blank line
+        for (String line; (line = source.readUtf8LineStrict()).length() != 0; ) {
+            Internal.instance.addLenient(headers, line);
+        }
+        return headers.build();
     }
 
-    @Override public void write(Buffer source, long byteCount) throws IOException {
-      if (closed) throw new IllegalStateException("closed");
-      if (byteCount == 0) return;
+    public Sink newChunkedSink() {
+        if (state != STATE_OPEN_REQUEST_BODY) throw new IllegalStateException("state: " + state);
+        state = STATE_WRITING_REQUEST_BODY;
+        return new ChunkedSink();
+    }
 
-      sink.writeHexadecimalUnsignedLong(byteCount);
-      sink.writeUtf8("\r\n");
-      sink.write(source, byteCount);
-      sink.writeUtf8("\r\n");
+    public Sink newFixedLengthSink(long contentLength) {
+        if (state != STATE_OPEN_REQUEST_BODY) throw new IllegalStateException("state: " + state);
+        state = STATE_WRITING_REQUEST_BODY;
+        return new FixedLengthSink(contentLength);
     }
 
-    @Override public synchronized void flush() throws IOException {
-      if (closed) return; // Don't throw; this stream might have been closed on the caller's behalf.
-      sink.flush();
+    public Source newFixedLengthSource(long length) throws IOException {
+        if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
+        state = STATE_READING_RESPONSE_BODY;
+        return new FixedLengthSource(length);
     }
 
-    @Override public synchronized void close() throws IOException {
-      if (closed) return;
-      closed = true;
-      sink.writeUtf8("0\r\n\r\n");
-      detachTimeout(timeout);
-      state = STATE_READ_RESPONSE_HEADERS;
+    public Source newChunkedSource(HttpUrl url) throws IOException {
+        if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
+        state = STATE_READING_RESPONSE_BODY;
+        return new ChunkedSource(url);
     }
-  }
 
-  private abstract class AbstractSource implements Source {
-    protected final ForwardingTimeout timeout = new ForwardingTimeout(source.timeout());
-    protected boolean closed;
+    public Source newUnknownLengthSource() throws IOException {
+        if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
+        if (streamAllocation == null) throw new IllegalStateException("streamAllocation == null");
+        state = STATE_READING_RESPONSE_BODY;
+        streamAllocation.noNewStreams();
+        return new UnknownLengthSource();
+    }
 
-    @Override public Timeout timeout() {
-      return timeout;
+    /**
+     * Sets the delegate of {@code timeout} to {@link Timeout#NONE} and resets its underlying timeout
+     * to the default configuration. Use this to avoid unexpected sharing of timeouts between pooled
+     * connections.
+     */
+    void detachTimeout(ForwardingTimeout timeout) {
+        Timeout oldDelegate = timeout.delegate();
+        timeout.setDelegate(Timeout.NONE);
+        oldDelegate.clearDeadline();
+        oldDelegate.clearTimeout();
     }
 
     /**
-     * Closes the cache entry and makes the socket available for reuse. This should be invoked when
-     * the end of the body has been reached.
+     * An HTTP body with a fixed length known in advance.
      */
-    protected final void endOfInput(boolean reuseConnection) throws IOException {
-      if (state == STATE_CLOSED) return;
-      if (state != STATE_READING_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
+    private final class FixedLengthSink implements Sink {
+        private final ForwardingTimeout timeout = new ForwardingTimeout(sink.timeout());
+        private boolean closed;
+        private long bytesRemaining;
 
-      detachTimeout(timeout);
+        FixedLengthSink(long bytesRemaining) {
+            this.bytesRemaining = bytesRemaining;
+        }
 
-      state = STATE_CLOSED;
-      if (streamAllocation != null) {
-        streamAllocation.streamFinished(!reuseConnection, Http1Codec.this);
-      }
-    }
-  }
+        @Override
+        public Timeout timeout() {
+            return timeout;
+        }
 
-  /** An HTTP body with a fixed length specified in advance. */
-  private class FixedLengthSource extends AbstractSource {
-    private long bytesRemaining;
+        @Override
+        public void write(Buffer source, long byteCount) throws IOException {
+            if (closed) throw new IllegalStateException("closed");
+            checkOffsetAndCount(source.size(), 0, byteCount);
+            if (byteCount > bytesRemaining) {
+                throw new ProtocolException("expected " + bytesRemaining
+                        + " bytes but received " + byteCount);
+            }
+            sink.write(source, byteCount);
+            bytesRemaining -= byteCount;
+        }
 
-    public FixedLengthSource(long length) throws IOException {
-      bytesRemaining = length;
-      if (bytesRemaining == 0) {
-        endOfInput(true);
-      }
-    }
+        @Override
+        public void flush() throws IOException {
+            if (closed) return; // Don't throw; this stream might have been closed on the caller's behalf.
+            sink.flush();
+        }
 
-    @Override public long read(Buffer sink, long byteCount) throws IOException {
-      if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
-      if (closed) throw new IllegalStateException("closed");
-      if (bytesRemaining == 0) return -1;
-
-      long read = source.read(sink, Math.min(bytesRemaining, byteCount));
-      if (read == -1) {
-        endOfInput(false); // The server didn't supply the promised content length.
-        throw new ProtocolException("unexpected end of stream");
-      }
-
-      bytesRemaining -= read;
-      if (bytesRemaining == 0) {
-        endOfInput(true);
-      }
-      return read;
+        @Override
+        public void close() throws IOException {
+            if (closed) return;
+            closed = true;
+            if (bytesRemaining > 0) throw new ProtocolException("unexpected end of stream");
+            detachTimeout(timeout);
+            state = STATE_READ_RESPONSE_HEADERS;
+        }
     }
 
-    @Override public void close() throws IOException {
-      if (closed) return;
+    /**
+     * An HTTP body with alternating chunk sizes and chunk bodies. It is the caller's responsibility
+     * to buffer chunks; typically by using a buffered sink with this sink.
+     */
+    private final class ChunkedSink implements Sink {
+        private final ForwardingTimeout timeout = new ForwardingTimeout(sink.timeout());
+        private boolean closed;
 
-      if (bytesRemaining != 0 && !Util.discard(this, DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
-        endOfInput(false);
-      }
+        ChunkedSink() {
+        }
 
-      closed = true;
-    }
-  }
+        @Override
+        public Timeout timeout() {
+            return timeout;
+        }
 
-  /** An HTTP body with alternating chunk sizes and chunk bodies. */
-  private class ChunkedSource extends AbstractSource {
-    private static final long NO_CHUNK_YET = -1L;
-    private final HttpUrl url;
-    private long bytesRemainingInChunk = NO_CHUNK_YET;
-    private boolean hasMoreChunks = true;
+        @Override
+        public void write(Buffer source, long byteCount) throws IOException {
+            if (closed) throw new IllegalStateException("closed");
+            if (byteCount == 0) return;
 
-    ChunkedSource(HttpUrl url) {
-      this.url = url;
-    }
+            sink.writeHexadecimalUnsignedLong(byteCount);
+            sink.writeUtf8("\r\n");
+            sink.write(source, byteCount);
+            sink.writeUtf8("\r\n");
+        }
 
-    @Override public long read(Buffer sink, long byteCount) throws IOException {
-      if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
-      if (closed) throw new IllegalStateException("closed");
-      if (!hasMoreChunks) return -1;
-
-      if (bytesRemainingInChunk == 0 || bytesRemainingInChunk == NO_CHUNK_YET) {
-        readChunkSize();
-        if (!hasMoreChunks) return -1;
-      }
-
-      long read = source.read(sink, Math.min(byteCount, bytesRemainingInChunk));
-      if (read == -1) {
-        endOfInput(false); // The server didn't supply the promised chunk length.
-        throw new ProtocolException("unexpected end of stream");
-      }
-      bytesRemainingInChunk -= read;
-      return read;
-    }
+        @Override
+        public synchronized void flush() throws IOException {
+            if (closed) return; // Don't throw; this stream might have been closed on the caller's behalf.
+            sink.flush();
+        }
 
-    private void readChunkSize() throws IOException {
-      // Read the suffix of the previous chunk.
-      if (bytesRemainingInChunk != NO_CHUNK_YET) {
-        source.readUtf8LineStrict();
-      }
-      try {
-        bytesRemainingInChunk = source.readHexadecimalUnsignedLong();
-        String extensions = source.readUtf8LineStrict().trim();
-        if (bytesRemainingInChunk < 0 || (!extensions.isEmpty() && !extensions.startsWith(";"))) {
-          throw new ProtocolException("expected chunk size and optional extensions but was \""
-              + bytesRemainingInChunk + extensions + "\"");
+        @Override
+        public synchronized void close() throws IOException {
+            if (closed) return;
+            closed = true;
+            sink.writeUtf8("0\r\n\r\n");
+            detachTimeout(timeout);
+            state = STATE_READ_RESPONSE_HEADERS;
         }
-      } catch (NumberFormatException e) {
-        throw new ProtocolException(e.getMessage());
-      }
-      if (bytesRemainingInChunk == 0L) {
-        hasMoreChunks = false;
-        HttpHeaders.receiveHeaders(client.cookieJar(), url, readHeaders());
-        endOfInput(true);
-      }
     }
 
-    @Override public void close() throws IOException {
-      if (closed) return;
-      if (hasMoreChunks && !Util.discard(this, DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
-        endOfInput(false);
-      }
-      closed = true;
+    private abstract class AbstractSource implements Source {
+        protected final ForwardingTimeout timeout = new ForwardingTimeout(source.timeout());
+        protected boolean closed;
+
+        @Override
+        public Timeout timeout() {
+            return timeout;
+        }
+
+        /**
+         * Closes the cache entry and makes the socket available for reuse. This should be invoked when
+         * the end of the body has been reached.
+         */
+        protected final void endOfInput(boolean reuseConnection) throws IOException {
+            if (state == STATE_CLOSED) return;
+            if (state != STATE_READING_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
+
+            detachTimeout(timeout);
+
+            state = STATE_CLOSED;
+            if (streamAllocation != null) {
+                streamAllocation.streamFinished(!reuseConnection, Http1Codec.this);
+            }
+        }
     }
-  }
 
-  /** An HTTP message body terminated by the end of the underlying stream. */
-  private class UnknownLengthSource extends AbstractSource {
-    private boolean inputExhausted;
+    /**
+     * An HTTP body with a fixed length specified in advance.
+     */
+    private class FixedLengthSource extends AbstractSource {
+        private long bytesRemaining;
+
+        public FixedLengthSource(long length) throws IOException {
+            bytesRemaining = length;
+            if (bytesRemaining == 0) {
+                endOfInput(true);
+            }
+        }
+
+        @Override
+        public long read(Buffer sink, long byteCount) throws IOException {
+            if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
+            if (closed) throw new IllegalStateException("closed");
+            if (bytesRemaining == 0) return -1;
+
+            long read = source.read(sink, Math.min(bytesRemaining, byteCount));
+            if (read == -1) {
+                endOfInput(false); // The server didn't supply the promised content length.
+                throw new ProtocolException("unexpected end of stream");
+            }
+
+            bytesRemaining -= read;
+            if (bytesRemaining == 0) {
+                endOfInput(true);
+            }
+            return read;
+        }
 
-    UnknownLengthSource() {
+        @Override
+        public void close() throws IOException {
+            if (closed) return;
+
+            if (bytesRemaining != 0 && !Util.discard(this, DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
+                endOfInput(false);
+            }
+
+            closed = true;
+        }
     }
 
-    @Override public long read(Buffer sink, long byteCount)
-        throws IOException {
-      if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
-      if (closed) throw new IllegalStateException("closed");
-      if (inputExhausted) return -1;
-
-      long read = source.read(sink, byteCount);
-      if (read == -1) {
-        inputExhausted = true;
-        endOfInput(true);
-        return -1;
-      }
-      return read;
+    /**
+     * An HTTP body with alternating chunk sizes and chunk bodies.
+     */
+    private class ChunkedSource extends AbstractSource {
+        private static final long NO_CHUNK_YET = -1L;
+        private final HttpUrl url;
+        private long bytesRemainingInChunk = NO_CHUNK_YET;
+        private boolean hasMoreChunks = true;
+
+        ChunkedSource(HttpUrl url) {
+            this.url = url;
+        }
+
+        @Override
+        public long read(Buffer sink, long byteCount) throws IOException {
+            if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
+            if (closed) throw new IllegalStateException("closed");
+            if (!hasMoreChunks) return -1;
+
+            if (bytesRemainingInChunk == 0 || bytesRemainingInChunk == NO_CHUNK_YET) {
+                readChunkSize();
+                if (!hasMoreChunks) return -1;
+            }
+
+            long read = source.read(sink, Math.min(byteCount, bytesRemainingInChunk));
+            if (read == -1) {
+                endOfInput(false); // The server didn't supply the promised chunk length.
+                throw new ProtocolException("unexpected end of stream");
+            }
+            bytesRemainingInChunk -= read;
+            return read;
+        }
+
+        private void readChunkSize() throws IOException {
+            // Read the suffix of the previous chunk.
+            if (bytesRemainingInChunk != NO_CHUNK_YET) {
+                source.readUtf8LineStrict();
+            }
+            try {
+                bytesRemainingInChunk = source.readHexadecimalUnsignedLong();
+                String extensions = source.readUtf8LineStrict().trim();
+                if (bytesRemainingInChunk < 0 || (!extensions.isEmpty() && !extensions.startsWith(";"))) {
+                    throw new ProtocolException("expected chunk size and optional extensions but was \""
+                            + bytesRemainingInChunk + extensions + "\"");
+                }
+            } catch (NumberFormatException e) {
+                throw new ProtocolException(e.getMessage());
+            }
+            if (bytesRemainingInChunk == 0L) {
+                hasMoreChunks = false;
+                HttpHeaders.receiveHeaders(client.cookieJar(), url, readHeaders());
+                endOfInput(true);
+            }
+        }
+
+        @Override
+        public void close() throws IOException {
+            if (closed) return;
+            if (hasMoreChunks && !Util.discard(this, DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
+                endOfInput(false);
+            }
+            closed = true;
+        }
     }
 
-    @Override public void close() throws IOException {
-      if (closed) return;
-      if (!inputExhausted) {
-        endOfInput(false);
-      }
-      closed = true;
+    /**
+     * An HTTP message body terminated by the end of the underlying stream.
+     */
+    private class UnknownLengthSource extends AbstractSource {
+        private boolean inputExhausted;
+
+        UnknownLengthSource() {
+        }
+
+        @Override
+        public long read(Buffer sink, long byteCount)
+                throws IOException {
+            if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
+            if (closed) throw new IllegalStateException("closed");
+            if (inputExhausted) return -1;
+
+            long read = source.read(sink, byteCount);
+            if (read == -1) {
+                inputExhausted = true;
+                endOfInput(true);
+                return -1;
+            }
+            return read;
+        }
+
+        @Override
+        public void close() throws IOException {
+            if (closed) return;
+            if (!inputExhausted) {
+                endOfInput(false);
+            }
+            closed = true;
+        }
     }
-  }
 }
