diff --git a/okhttp/src/main/java/okhttp3/Address.java b/okhttp/src/main/java/okhttp3/Address.java
index 8c9cf5f9f7..d4d80e7501 100644
--- a/okhttp/src/main/java/okhttp3/Address.java
+++ b/okhttp/src/main/java/okhttp3/Address.java
@@ -39,7 +39,7 @@
   final HttpUrl url;
   final Dns dns;
   final SocketFactory socketFactory;
-  final Authenticator proxyAuthenticator;
+
   final List<Protocol> protocols;
   final List<ConnectionSpec> connectionSpecs;
   final ProxySelector proxySelector;
@@ -50,7 +50,6 @@
 
   public Address(String uriHost, int uriPort, Dns dns, SocketFactory socketFactory,
       @Nullable SSLSocketFactory sslSocketFactory, @Nullable HostnameVerifier hostnameVerifier,
-       Authenticator proxyAuthenticator,
       @Nullable Proxy proxy, List<Protocol> protocols, List<ConnectionSpec> connectionSpecs,
       ProxySelector proxySelector) {
     this.url = new HttpUrl.Builder()
@@ -65,10 +64,7 @@ public Address(String uriHost, int uriPort, Dns dns, SocketFactory socketFactory
     if (socketFactory == null) throw new NullPointerException("socketFactory == null");
     this.socketFactory = socketFactory;
 
-    if (proxyAuthenticator == null) {
-      throw new NullPointerException("proxyAuthenticator == null");
-    }
-    this.proxyAuthenticator = proxyAuthenticator;
+
 
     if (protocols == null) throw new NullPointerException("protocols == null");
     this.protocols = Util.immutableList(protocols);
@@ -103,10 +99,7 @@ public SocketFactory socketFactory() {
     return socketFactory;
   }
 
-  /** Returns the client's proxy authenticator. */
-  public Authenticator proxyAuthenticator() {
-    return proxyAuthenticator;
-  }
+
 
   /**
    * Returns the protocols the client supports. This method always returns a non-null list that
@@ -157,7 +150,7 @@ public ProxySelector proxySelector() {
     int result = 17;
     result = 31 * result + url.hashCode();
     result = 31 * result + dns.hashCode();
-    result = 31 * result + proxyAuthenticator.hashCode();
+
     result = 31 * result + protocols.hashCode();
     result = 31 * result + connectionSpecs.hashCode();
     result = 31 * result + proxySelector.hashCode();
@@ -169,7 +162,6 @@ public ProxySelector proxySelector() {
 
   boolean equalsNonHost(Address that) {
     return this.dns.equals(that.dns)
-        && this.proxyAuthenticator.equals(that.proxyAuthenticator)
         && this.protocols.equals(that.protocols)
         && this.connectionSpecs.equals(that.connectionSpecs)
         && this.proxySelector.equals(that.proxySelector)
diff --git a/okhttp/src/main/java/okhttp3/Authenticator.java b/okhttp/src/main/java/okhttp3/Authenticator.java
deleted file mode 100644
index 9e34bc9706..0000000000
--- a/okhttp/src/main/java/okhttp3/Authenticator.java
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import javax.annotation.Nullable;
-
-/**
- * Responds to an authentication challenge from either a remote web server or a proxy server.
- * Implementations may either attempt to satisfy the challenge by returning a request that includes
- * an authorization header, or they may refuse the challenge by returning null. In this case the
- * unauthenticated response will be returned to the caller that triggered it.
- *
- * <p>Implementations should check if the initial request already included an attempt to
- * authenticate. If so it is likely that further attempts will not be useful and the authenticator
- * should give up.
- *
- * <p>When authentication is requested by an origin server, the response code is 401 and the
- * implementation should respond with a new request that sets the "Authorization" header.
- * <pre>   {@code
- *
- *    if (response.request().header("Authorization") != null) {
- *      return null; // Give up, we've already failed to authenticate.
- *    }
- *
- *    String credential = Credentials.basic(...)
- *    return response.request().newBuilder()
- *        .header("Authorization", credential)
- *        .build();
- * }</pre>
- *
- * <p>When authentication is requested by a proxy server, the response code is 407 and the
- * implementation should respond with a new request that sets the "Proxy-Authorization" header.
- * <pre>   {@code
- *
- *    if (response.request().header("Proxy-Authorization") != null) {
- *      return null; // Give up, we've already failed to authenticate.
- *    }
- *
- *    String credential = Credentials.basic(...)
- *    return response.request().newBuilder()
- *        .header("Proxy-Authorization", credential)
- *        .build();
- * }</pre>
- *
- * <p>Applications may configure OkHttp with an authenticator for origin servers, or proxy servers,
- * or both.
- */
-public interface Authenticator {
-  /** An authenticator that knows no credentials and makes no attempt to authenticate. */
-  Authenticator NONE = new Authenticator() {
-    @Override public Request authenticate(Route route, Response response) {
-      return null;
-    }
-  };
-
-  /**
-   * Returns a request that includes a credential to satisfy an authentication challenge in {@code
-   * response}. Returns null if the challenge cannot be satisfied.
-   */
-  @Nullable Request authenticate(Route route, Response response) throws IOException;
-}
diff --git a/okhttp/src/main/java/okhttp3/OkHttpClient.java b/okhttp/src/main/java/okhttp3/OkHttpClient.java
index 2245d913ea..5b4daaf264 100644
--- a/okhttp/src/main/java/okhttp3/OkHttpClient.java
+++ b/okhttp/src/main/java/okhttp3/OkHttpClient.java
@@ -419,8 +419,7 @@ public Builder() {
       proxySelector = ProxySelector.getDefault();
 
       socketFactory = SocketFactory.getDefault();
-      proxyAuthenticator = Authenticator.NONE;
-      authenticator = Authenticator.NONE;
+
       connectionPool = new ConnectionPool();
       dns = Dns.SYSTEM;
       followSslRedirects = true;
@@ -617,29 +616,8 @@ public Builder hostnameVerifier(HostnameVerifier hostnameVerifier) {
 
 
 
-    /**
-     * Sets the authenticator used to respond to challenges from origin servers. Use {@link
-     * #proxyAuthenticator} to set the authenticator for proxy servers.
-     *
-     * <p>If unset, the {@linkplain Authenticator#NONE no authentication will be attempted}.
-     */
-    public Builder authenticator(Authenticator authenticator) {
-      if (authenticator == null) throw new NullPointerException("authenticator == null");
-      this.authenticator = authenticator;
-      return this;
-    }
 
-    /**
-     * Sets the authenticator used to respond to challenges from proxy servers. Use {@link
-     * #authenticator} to set the authenticator for origin servers.
-     *
-     * <p>If unset, the {@linkplain Authenticator#NONE no authentication will be attempted}.
-     */
-    public Builder proxyAuthenticator(Authenticator proxyAuthenticator) {
-      if (proxyAuthenticator == null) throw new NullPointerException("proxyAuthenticator == null");
-      this.proxyAuthenticator = proxyAuthenticator;
-      return this;
-    }
+
 
     /**
      * Sets the connection pool used to recycle HTTP and HTTPS connections.
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java b/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
index 3530e6848a..061d9a8a13 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
@@ -350,15 +350,6 @@ private Request createTunnel(int readTimeout, int writeTimeout, Request tunnelRe
                     }
                     return null;
 
-                case HTTP_PROXY_AUTH:
-                    tunnelRequest = route.address().proxyAuthenticator().authenticate(route, response);
-                    if (tunnelRequest == null) throw new IOException("Failed to authenticate with proxy");
-
-                    if ("close".equalsIgnoreCase(response.header("Connection"))) {
-                        return tunnelRequest;
-                    }
-                    break;
-
                 default:
                     throw new IOException(
                             "Unexpected response code for CONNECT: " + response.code());
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
index af2ceb4ca3..21aa1a1742 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
@@ -194,7 +194,7 @@ private Address createAddress(HttpUrl url) {
     }
 
     return new Address(url.host(), url.port(), client.dns(), client.socketFactory(),
-        sslSocketFactory, hostnameVerifier, client.proxyAuthenticator(),
+        sslSocketFactory, hostnameVerifier,
         client.proxy(), client.protocols(), client.connectionSpecs(), client.proxySelector());
   }
 
@@ -268,18 +268,6 @@ private Request followUpRequest(Response userResponse) throws IOException {
 
     final String method = userResponse.request().method();
     switch (responseCode) {
-      case HTTP_PROXY_AUTH:
-        Proxy selectedProxy = route != null
-            ? route.proxy()
-            : client.proxy();
-        if (selectedProxy.type() != Proxy.Type.HTTP) {
-          throw new ProtocolException("Received HTTP_PROXY_AUTH (407) code while not using proxy");
-        }
-        return client.proxyAuthenticator().authenticate(route, userResponse);
-
-      case HTTP_UNAUTHORIZED:
-        return client.authenticator().authenticate(route, userResponse);
-
       case HTTP_PERM_REDIRECT:
       case HTTP_TEMP_REDIRECT:
         // "If the 307 or 308 status code is received in response to a request other than GET
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/OptionalMethod.java b/okhttp/src/main/java/okhttp3/internal/platform/OptionalMethod.java
deleted file mode 100644
index c26132fedb..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/platform/OptionalMethod.java
+++ /dev/null
@@ -1,174 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package okhttp3.internal.platform;
-
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.lang.reflect.Modifier;
-
-/**
- * Duck-typing for methods: Represents a method that may or may not be present on an object.
- *
- * @param <T> the type of the object the method might be on, typically an interface or base class
- */
-class OptionalMethod<T> {
-
-  /** The return type of the method. null means "don't care". */
-  private final Class<?> returnType;
-
-  private final String methodName;
-
-  private final Class[] methodParams;
-
-  /**
-   * Creates an optional method.
-   *
-   * @param returnType the return type to required, null if it does not matter
-   * @param methodName the name of the method
-   * @param methodParams the method parameter types
-   */
-  OptionalMethod(Class<?> returnType, String methodName, Class... methodParams) {
-    this.returnType = returnType;
-    this.methodName = methodName;
-    this.methodParams = methodParams;
-  }
-
-  /**
-   * Returns true if the method exists on the supplied {@code target}.
-   */
-  public boolean isSupported(T target) {
-    return getMethod(target.getClass()) != null;
-  }
-
-  /**
-   * Invokes the method on {@code target} with {@code args}. If the method does not exist or is not
-   * public then {@code null} is returned. See also {@link #invokeOptionalWithoutCheckedException}.
-   *
-   * @throws IllegalArgumentException if the arguments are invalid
-   * @throws InvocationTargetException if the invocation throws an exception
-   */
-  public Object invokeOptional(T target, Object... args) throws InvocationTargetException {
-    Method m = getMethod(target.getClass());
-    if (m == null) {
-      return null;
-    }
-    try {
-      return m.invoke(target, args);
-    } catch (IllegalAccessException e) {
-      return null;
-    }
-  }
-
-  /**
-   * Invokes the method on {@code target}.  If the method does not exist or is not public then
-   * {@code null} is returned. Any RuntimeException thrown by the method is thrown, checked
-   * exceptions are wrapped in an {@link AssertionError}.
-   *
-   * @throws IllegalArgumentException if the arguments are invalid
-   */
-  public Object invokeOptionalWithoutCheckedException(T target, Object... args) {
-    try {
-      return invokeOptional(target, args);
-    } catch (InvocationTargetException e) {
-      Throwable targetException = e.getTargetException();
-      if (targetException instanceof RuntimeException) {
-        throw (RuntimeException) targetException;
-      }
-      AssertionError error = new AssertionError("Unexpected exception");
-      error.initCause(targetException);
-      throw error;
-    }
-  }
-
-  /**
-   * Invokes the method on {@code target} with {@code args}. Throws an error if the method is not
-   * supported. See also {@link #invokeWithoutCheckedException(Object, Object...)}.
-   *
-   * @throws IllegalArgumentException if the arguments are invalid
-   * @throws InvocationTargetException if the invocation throws an exception
-   */
-  public Object invoke(T target, Object... args) throws InvocationTargetException {
-    Method m = getMethod(target.getClass());
-    if (m == null) {
-      throw new AssertionError("Method " + methodName + " not supported for object " + target);
-    }
-    try {
-      return m.invoke(target, args);
-    } catch (IllegalAccessException e) {
-      // Method should be public: we checked.
-      AssertionError error = new AssertionError("Unexpectedly could not call: " + m);
-      error.initCause(e);
-      throw error;
-    }
-  }
-
-  /**
-   * Invokes the method on {@code target}. Throws an error if the method is not supported. Any
-   * RuntimeException thrown by the method is thrown, checked exceptions are wrapped in an {@link
-   * AssertionError}.
-   *
-   * @throws IllegalArgumentException if the arguments are invalid
-   */
-  public Object invokeWithoutCheckedException(T target, Object... args) {
-    try {
-      return invoke(target, args);
-    } catch (InvocationTargetException e) {
-      Throwable targetException = e.getTargetException();
-      if (targetException instanceof RuntimeException) {
-        throw (RuntimeException) targetException;
-      }
-      AssertionError error = new AssertionError("Unexpected exception");
-      error.initCause(targetException);
-      throw error;
-    }
-  }
-
-  /**
-   * Perform a lookup for the method. No caching. In order to return a method the method name and
-   * arguments must match those specified when the {@link OptionalMethod} was created. If the return
-   * type is specified (i.e. non-null) it must also be compatible. The method must also be public.
-   */
-  private Method getMethod(Class<?> clazz) {
-    Method method = null;
-    if (methodName != null) {
-      method = getPublicMethod(clazz, methodName, methodParams);
-      if (method != null
-          && returnType != null
-          && !returnType.isAssignableFrom(method.getReturnType())) {
-
-        // If the return type is non-null it must be compatible.
-        method = null;
-      }
-    }
-    return method;
-  }
-
-  private static Method getPublicMethod(Class<?> clazz, String methodName, Class[] parameterTypes) {
-    Method method = null;
-    try {
-      method = clazz.getMethod(methodName, parameterTypes);
-      if ((method.getModifiers() & Modifier.PUBLIC) == 0) {
-        method = null;
-      }
-    } catch (NoSuchMethodException e) {
-      // None.
-    }
-    return method;
-  }
-}
-
