diff --git a/okhttp-tests/src/test/java/okhttp3/EventListenerTest.java b/okhttp-tests/src/test/java/okhttp3/EventListenerTest.java
index 38f7130811..d767ab240b 100644
--- a/okhttp-tests/src/test/java/okhttp3/EventListenerTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/EventListenerTest.java
@@ -24,13 +24,16 @@
 import java.util.Collections;
 import java.util.List;
 import java.util.concurrent.TimeUnit;
+import javax.annotation.Nullable;
 import okhttp3.RecordingEventListener.ConnectEnd;
 import okhttp3.RecordingEventListener.ConnectStart;
 import okhttp3.RecordingEventListener.ConnectionAcquired;
 import okhttp3.RecordingEventListener.DnsEnd;
 import okhttp3.RecordingEventListener.DnsStart;
 import okhttp3.RecordingEventListener.RequestBodyEnd;
+import okhttp3.RecordingEventListener.RequestHeadersEnd;
 import okhttp3.RecordingEventListener.ResponseBodyEnd;
+import okhttp3.RecordingEventListener.ResponseHeadersEnd;
 import okhttp3.RecordingEventListener.SecureConnectEnd;
 import okhttp3.RecordingEventListener.SecureConnectStart;
 import okhttp3.internal.DoubleInetAddressDns;
@@ -42,6 +45,10 @@
 import okhttp3.mockwebserver.SocketPolicy;
 import okio.Buffer;
 import okio.BufferedSink;
+import org.hamcrest.BaseMatcher;
+import org.hamcrest.CoreMatchers;
+import org.hamcrest.Description;
+import org.hamcrest.Matcher;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Rule;
@@ -49,15 +56,20 @@
 
 import static java.util.Arrays.asList;
 import static okhttp3.TestUtil.defaultClient;
+import static org.hamcrest.CoreMatchers.any;
+import static org.hamcrest.CoreMatchers.equalTo;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertThat;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
+import static org.junit.Assume.assumeThat;
 
 public final class EventListenerTest {
+  public static final Matcher<Response> anyResponse = CoreMatchers.any(Response.class);
   @Rule public final MockWebServer server = new MockWebServer();
 
   private final SingleInetAddressDns singleDns = new SingleInetAddressDns();
@@ -102,7 +114,7 @@
     assertEquals(expectedEvents, listener.recordedEventTypes());
   }
 
-  private void assertSuccessfulEventOrder() throws IOException {
+  private void assertSuccessfulEventOrder(Matcher<Response> responseMatcher) throws IOException {
     Call call = client.newCall(new Request.Builder()
         .url(server.url("/"))
         .build());
@@ -111,6 +123,8 @@ private void assertSuccessfulEventOrder() throws IOException {
     response.body().string();
     response.body().close();
 
+    assumeThat(response, responseMatcher);
+
     List<String> expectedEvents = asList("CallStart", "DnsStart", "DnsEnd", "ConnectionAcquired",
         "ConnectStart", "SecureConnectStart", "SecureConnectEnd", "ConnectEnd",
         "RequestHeadersStart", "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd",
@@ -119,12 +133,84 @@ private void assertSuccessfulEventOrder() throws IOException {
     assertEquals(expectedEvents, listener.recordedEventTypes());
   }
 
+  private void assertBytesReadWritten(RecordingEventListener listener,
+      @Nullable Matcher<Long> requestHeaderLength, @Nullable Matcher<Long> requestBodyBytes,
+      @Nullable Matcher<Long> responseHeaderLength, @Nullable Matcher<Long> responseBodyBytes) {
+
+    if (requestHeaderLength != null) {
+      RequestHeadersEnd responseHeadersEnd = listener.removeUpToEvent(RequestHeadersEnd.class);
+      assertThat("request header length", responseHeadersEnd.headerLength, requestHeaderLength);
+    } else {
+      assertFalse("Found RequestHeadersEnd", listener.recordedEventTypes().contains("RequestHeadersEnd"));
+    }
+
+    if (requestBodyBytes != null) {
+      RequestBodyEnd responseBodyEnd = listener.removeUpToEvent(RequestBodyEnd.class);
+      assertThat("request body bytes", responseBodyEnd.bytesWritten, requestBodyBytes);
+    } else {
+      assertFalse("Found RequestBodyEnd", listener.recordedEventTypes().contains("RequestBodyEnd"));
+    }
+
+    if (responseHeaderLength != null) {
+      ResponseHeadersEnd responseHeadersEnd = listener.removeUpToEvent(ResponseHeadersEnd.class);
+      assertThat("response header length", responseHeadersEnd.headerLength, responseHeaderLength);
+    } else {
+      assertFalse("Found ResponseHeadersEnd", listener.recordedEventTypes().contains("ResponseHeadersEnd"));
+    }
+
+    if (responseBodyBytes != null) {
+      ResponseBodyEnd responseBodyEnd = listener.removeUpToEvent(ResponseBodyEnd.class);
+      assertThat("response body bytes", responseBodyEnd.bytesRead, responseBodyBytes);
+    } else {
+      assertFalse("Found ResponseBodyEnd", listener.recordedEventTypes().contains("ResponseBodyEnd"));
+    }
+  }
+
+  private Matcher<Long> greaterThan(final long value) {
+    return new BaseMatcher<Long>() {
+      @Override public void describeTo(Description description) {
+        description.appendText("> " + value);
+      }
+
+      @Override public boolean matches(Object o) {
+        return ((Long)o) > value;
+      }
+    };
+  }
+
+  private Matcher<Long> lessThan(final long value) {
+    return new BaseMatcher<Long>() {
+      @Override public void describeTo(Description description) {
+        description.appendText("< " + value);
+      }
+
+      @Override public boolean matches(Object o) {
+        return ((Long)o) < value;
+      }
+    };
+  }
+
+  private Matcher<Response> matchesProtocol(final Protocol protocol) {
+    return new BaseMatcher<Response>() {
+      @Override public void describeTo(Description description) {
+        description.appendText("is HTTP/2");
+      }
+
+      @Override public boolean matches(Object o) {
+        return ((Response)o).protocol == protocol;
+      }
+    };
+  }
+
   @Test public void successfulEmptyH2CallEventSequence() throws IOException {
     enableTlsWithTunnel(false);
     server.setProtocols(Arrays.asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
     server.enqueue(new MockResponse());
 
-    assertSuccessfulEventOrder();
+    assertSuccessfulEventOrder(matchesProtocol(Protocol.HTTP_2));
+
+    assertBytesReadWritten(listener, any(Long.class), null, greaterThan(0L),
+        equalTo(0L));
   }
 
   @Test public void successfulEmptyHttpsCallEventSequence() throws IOException {
@@ -133,7 +219,10 @@ private void assertSuccessfulEventOrder() throws IOException {
     server.enqueue(new MockResponse()
         .setBody("abc"));
 
-    assertSuccessfulEventOrder();
+    assertSuccessfulEventOrder(anyResponse);
+
+    assertBytesReadWritten(listener, any(Long.class), null, greaterThan(0L),
+        equalTo(3L));
   }
 
   @Test public void successfulChunkedHttpsCallEventSequence() throws IOException {
@@ -142,7 +231,10 @@ private void assertSuccessfulEventOrder() throws IOException {
     server.enqueue(
         new MockResponse().setBodyDelay(100, TimeUnit.MILLISECONDS).setChunkedBody("Hello!", 2));
 
-    assertSuccessfulEventOrder();
+    assertSuccessfulEventOrder(anyResponse);
+
+    assertBytesReadWritten(listener, any(Long.class), null, greaterThan(0L),
+        equalTo(6L));
   }
 
   @Test public void successfulChunkedH2CallEventSequence() throws IOException {
@@ -151,7 +243,10 @@ private void assertSuccessfulEventOrder() throws IOException {
     server.enqueue(
         new MockResponse().setBodyDelay(100, TimeUnit.MILLISECONDS).setChunkedBody("Hello!", 2));
 
-    assertSuccessfulEventOrder();
+    assertSuccessfulEventOrder(matchesProtocol(Protocol.HTTP_2));
+
+    assertBytesReadWritten(listener, any(Long.class), null, equalTo(0L),
+        greaterThan(6L));
   }
 
   @Test public void successfulDnsLookup() throws IOException {
@@ -172,7 +267,7 @@ private void assertSuccessfulEventOrder() throws IOException {
     assertSame(call, dnsEnd.call);
     assertEquals("localhost", dnsEnd.domainName);
     assertEquals(1, dnsEnd.inetAddressList.size());
-    assertNull(dnsEnd.throwable);
+    assertNull(dnsEnd.ioe);
   }
 
   @Test public void noDnsLookupOnPooledConnection() throws IOException {
@@ -247,7 +342,7 @@ private void assertSuccessfulEventOrder() throws IOException {
     assertSame(call, dnsEnd.call);
     assertEquals("fakeurl", dnsEnd.domainName);
     assertNull(dnsEnd.inetAddressList);
-    assertTrue(dnsEnd.throwable instanceof UnknownHostException);
+    assertTrue(dnsEnd.ioe instanceof UnknownHostException);
   }
 
   @Test public void emptyDnsLookup() {
@@ -275,7 +370,7 @@ private void assertSuccessfulEventOrder() throws IOException {
     assertSame(call, dnsEnd.call);
     assertEquals("fakeurl", dnsEnd.domainName);
     assertNull(dnsEnd.inetAddressList);
-    assertTrue(dnsEnd.throwable instanceof UnknownHostException);
+    assertTrue(dnsEnd.ioe instanceof UnknownHostException);
   }
 
   @Test public void successfulConnect() throws IOException {
@@ -300,7 +395,7 @@ private void assertSuccessfulEventOrder() throws IOException {
     assertSame(call, connectEnd.call);
     assertEquals(expectedAddress, connectEnd.inetSocketAddress);
     assertEquals(Protocol.HTTP_1_1, connectEnd.protocol);
-    assertNull(connectEnd.throwable);
+    assertNull(connectEnd.ioe);
   }
 
   @Test public void failedConnect() throws UnknownHostException {
@@ -329,7 +424,7 @@ private void assertSuccessfulEventOrder() throws IOException {
     assertSame(call, connectEnd.call);
     assertEquals(expectedAddress, connectEnd.inetSocketAddress);
     assertNull(connectEnd.protocol);
-    assertTrue(connectEnd.throwable instanceof IOException);
+    assertNotNull(connectEnd.ioe);
   }
 
   @Test public void multipleConnectsForSingleCall() throws IOException {
@@ -381,7 +476,7 @@ private void assertSuccessfulEventOrder() throws IOException {
     assertSame(call, connectEnd.call);
     assertEquals(expectedAddress, connectEnd.inetSocketAddress);
     assertEquals(Protocol.HTTP_1_1, connectEnd.protocol);
-    assertNull(connectEnd.throwable);
+    assertNull(connectEnd.ioe);
   }
 
   @Test public void successfulSocksProxyConnect() throws Exception {
@@ -414,7 +509,7 @@ private void assertSuccessfulEventOrder() throws IOException {
     assertSame(call, connectEnd.call);
     assertEquals(expectedAddress, connectEnd.inetSocketAddress);
     assertEquals(Protocol.HTTP_1_1, connectEnd.protocol);
-    assertNull(connectEnd.throwable);
+    assertNull(connectEnd.ioe);
   }
 
   @Test public void authenticatingTunnelProxyConnect() throws IOException {
@@ -443,7 +538,7 @@ private void assertSuccessfulEventOrder() throws IOException {
 
     ConnectEnd connectEnd = listener.removeUpToEvent(ConnectEnd.class);
     assertNull(connectEnd.protocol);
-    assertNull(connectEnd.throwable);
+    assertNull(connectEnd.ioe);
 
     listener.removeUpToEvent(ConnectStart.class);
     listener.removeUpToEvent(ConnectEnd.class);
@@ -466,7 +561,7 @@ private void assertSuccessfulEventOrder() throws IOException {
     SecureConnectEnd secureEnd = listener.removeUpToEvent(SecureConnectEnd.class);
     assertSame(call, secureEnd.call);
     assertNotNull(secureEnd.handshake);
-    assertNull(secureEnd.throwable);
+    assertNull(secureEnd.ioe);
   }
 
   @Test public void failedSecureConnect() {
@@ -489,7 +584,7 @@ private void assertSuccessfulEventOrder() throws IOException {
     SecureConnectEnd secureEnd = listener.removeUpToEvent(SecureConnectEnd.class);
     assertSame(call, secureEnd.call);
     assertNull(secureEnd.handshake);
-    assertTrue(secureEnd.throwable instanceof IOException);
+    assertNotNull(secureEnd.ioe);
   }
 
   @Test public void secureConnectWithTunnel() throws IOException {
@@ -515,7 +610,7 @@ private void assertSuccessfulEventOrder() throws IOException {
     SecureConnectEnd secureEnd = listener.removeUpToEvent(SecureConnectEnd.class);
     assertSame(call, secureEnd.call);
     assertNotNull(secureEnd.handshake);
-    assertNull(secureEnd.throwable);
+    assertNull(secureEnd.ioe);
   }
 
   @Test public void multipleSecureConnectsForSingleCall() throws IOException {
@@ -678,6 +773,10 @@ private void responseBodyFail(Protocol expectedProtocol) throws IOException {
         .url(server.url("/"))
         .build());
     Response response = call.execute();
+    if (expectedProtocol == Protocol.HTTP_2) {
+      // soft failure since client may not support depending on Platform
+      assumeThat(response, matchesProtocol(Protocol.HTTP_2));
+    }
     assertEquals(expectedProtocol, response.protocol());
     try {
       response.body.string();
@@ -686,7 +785,8 @@ private void responseBodyFail(Protocol expectedProtocol) throws IOException {
     }
 
     ResponseBodyEnd responseBodyEnd = listener.removeUpToEvent(ResponseBodyEnd.class);
-    assertNotNull(responseBodyEnd.throwable);
+    assertNotNull(responseBodyEnd.ioe);
+    assertThat("response body bytes", responseBodyEnd.bytesRead, lessThan(responseBodySize));
   }
 
   @Test public void requestBodyFailHttp1OverHttps() throws IOException {
@@ -738,7 +838,61 @@ private void requestBodyFail() throws IOException {
     }
 
     RequestBodyEnd responseBodyEnd = listener.removeUpToEvent(RequestBodyEnd.class);
-    assertNotNull(responseBodyEnd.throwable);
+    assertNotNull(responseBodyEnd.ioe);
+  }
+
+  @Test public void requestBodySuccessHttp1OverHttps() throws IOException {
+    enableTlsWithTunnel(false);
+    server.setProtocols(Arrays.asList(Protocol.HTTP_1_1));
+    requestBodySuccess(RequestBody.create(MediaType.parse("text/plain"), "Hello"), equalTo(5L),
+        equalTo(15L));
+  }
+
+  @Test public void requestBodySuccessHttp2OverHttps() throws IOException {
+    enableTlsWithTunnel(false);
+    server.setProtocols(Arrays.asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
+    requestBodySuccess(RequestBody.create(MediaType.parse("text/plain"), "Hello"), equalTo(5L),
+        equalTo(15L));
+  }
+
+  @Test public void requestBodySuccessHttp() throws IOException {
+    requestBodySuccess(RequestBody.create(MediaType.parse("text/plain"), "Hello"), equalTo(5L),
+        equalTo(15L));
+  }
+
+  @Test public void requestBodySuccessStreaming() throws IOException {
+    RequestBody requestBody = new RequestBody() {
+      @Override public MediaType contentType() {
+        return MediaType.parse("text/plain");
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        sink.write(new byte[8192]);
+        sink.flush();
+      }
+    };
+
+    requestBodySuccess(requestBody, equalTo(8192L), equalTo(15L));
+  }
+
+  @Test public void requestBodySuccessEmpty() throws IOException {
+    requestBodySuccess(RequestBody.create(MediaType.parse("text/plain"), ""), equalTo(0L),
+        equalTo(15L));
+  }
+
+  private void requestBodySuccess(RequestBody body, Matcher<Long> requestBodyBytes,
+      Matcher<Long> responseHeaderLength) throws IOException {
+    server.enqueue(new MockResponse().setResponseCode(200).setBody("World!"));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .post(body)
+        .build());
+    Response response = call.execute();
+    assertEquals("World!", response.body().string());
+
+    assertBytesReadWritten(listener, any(Long.class), requestBodyBytes, responseHeaderLength,
+        equalTo(6L));
   }
 
   private void enableTlsWithTunnel(boolean tunnelProxy) {
diff --git a/okhttp-tests/src/test/java/okhttp3/RecordingEventListener.java b/okhttp-tests/src/test/java/okhttp3/RecordingEventListener.java
index 2b0f0e9b2f..9a7d667614 100644
--- a/okhttp-tests/src/test/java/okhttp3/RecordingEventListener.java
+++ b/okhttp-tests/src/test/java/okhttp3/RecordingEventListener.java
@@ -15,6 +15,7 @@
  */
 package okhttp3;
 
+import java.io.IOException;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.net.Proxy;
@@ -83,8 +84,8 @@ private void logEvent(CallEvent e) {
   }
 
   @Override public void dnsEnd(Call call, String domainName, List<InetAddress> inetAddressList,
-      Throwable throwable) {
-    logEvent(new DnsEnd(call, domainName, inetAddressList, throwable));
+      IOException ioe) {
+    logEvent(new DnsEnd(call, domainName, inetAddressList, ioe));
   }
 
   @Override public void connectStart(Call call, InetSocketAddress inetSocketAddress,
@@ -96,13 +97,13 @@ private void logEvent(CallEvent e) {
     logEvent(new SecureConnectStart(call));
   }
 
-  @Override public void secureConnectEnd(Call call, Handshake handshake, Throwable throwable) {
-    logEvent(new SecureConnectEnd(call, handshake, throwable));
+  @Override public void secureConnectEnd(Call call, Handshake handshake, IOException ioe) {
+    logEvent(new SecureConnectEnd(call, handshake, ioe));
   }
 
   @Override public void connectEnd(Call call, InetSocketAddress inetSocketAddress,
-      @Nullable Proxy proxy, Protocol protocol, Throwable throwable) {
-    logEvent(new ConnectEnd(call, inetSocketAddress, proxy, protocol, throwable));
+      @Nullable Proxy proxy, Protocol protocol, IOException ioe) {
+    logEvent(new ConnectEnd(call, inetSocketAddress, proxy, protocol, ioe));
   }
 
   @Override public void connectionAcquired(Call call, Connection connection) {
@@ -121,36 +122,36 @@ private void logEvent(CallEvent e) {
     logEvent(new RequestHeadersStart(call));
   }
 
-  @Override public void requestHeadersEnd(Call call, Throwable throwable) {
-    logEvent(new RequestHeadersEnd(call, throwable));
+  @Override public void requestHeadersEnd(Call call, long headerLength, IOException ioe) {
+    logEvent(new RequestHeadersEnd(call, headerLength, ioe));
   }
 
   @Override public void requestBodyStart(Call call) {
     logEvent(new RequestBodyStart(call));
   }
 
-  @Override public void requestBodyEnd(Call call, Throwable throwable) {
-    logEvent(new RequestBodyEnd(call, throwable));
+  @Override public void requestBodyEnd(Call call, long bytesWritten, IOException ioe) {
+    logEvent(new RequestBodyEnd(call, bytesWritten, ioe));
   }
 
   @Override public void responseHeadersStart(Call call) {
     logEvent(new ResponseHeadersStart(call));
   }
 
-  @Override public void responseHeadersEnd(Call call, Throwable throwable) {
-    logEvent(new ResponseHeadersEnd(call, throwable));
+  @Override public void responseHeadersEnd(Call call, long headerLength, IOException ioe) {
+    logEvent(new ResponseHeadersEnd(call, headerLength, ioe));
   }
 
   @Override public void responseBodyStart(Call call) {
     logEvent(new ResponseBodyStart(call));
   }
 
-  @Override public void responseBodyEnd(Call call, Throwable throwable) {
-    logEvent(new ResponseBodyEnd(call, throwable));
+  @Override public void responseBodyEnd(Call call, long bytesRead, IOException ioe) {
+    logEvent(new ResponseBodyEnd(call, bytesRead, ioe));
   }
 
-  @Override public void callEnd(Call call, Throwable throwable) {
-    logEvent(new CallEnd(call, throwable));
+  @Override public void callEnd(Call call, IOException ioe) {
+    logEvent(new CallEnd(call, ioe));
   }
 
   static class CallEvent {
@@ -201,13 +202,13 @@ public String getName() {
   static final class DnsEnd extends CallEvent {
     final String domainName;
     final List<InetAddress> inetAddressList;
-    final Throwable throwable;
+    final IOException ioe;
 
-    DnsEnd(Call call, String domainName, List<InetAddress> inetAddressList, Throwable throwable) {
-      super(call, domainName, inetAddressList, throwable);
+    DnsEnd(Call call, String domainName, List<InetAddress> inetAddressList, IOException ioe) {
+      super(call, domainName, inetAddressList, ioe);
       this.domainName = domainName;
       this.inetAddressList = inetAddressList;
-      this.throwable = throwable;
+      this.ioe = ioe;
     }
 
     @Nullable @Override public CallEvent closes() {
@@ -229,16 +230,16 @@ public String getName() {
   static final class ConnectEnd extends CallEvent {
     final InetSocketAddress inetSocketAddress;
     final Protocol protocol;
-    final Throwable throwable;
+    final IOException ioe;
     final Proxy proxy;
 
     ConnectEnd(Call call, InetSocketAddress inetSocketAddress, Proxy proxy, Protocol protocol,
-        Throwable throwable) {
-      super(call, inetSocketAddress, proxy, protocol, throwable);
+        IOException ioe) {
+      super(call, inetSocketAddress, proxy, protocol, ioe);
       this.inetSocketAddress = inetSocketAddress;
       this.proxy = proxy;
       this.protocol = protocol;
-      this.throwable = throwable;
+      this.ioe = ioe;
     }
 
     @Nullable @Override public CallEvent closes() {
@@ -254,12 +255,12 @@ public String getName() {
 
   static final class SecureConnectEnd extends CallEvent {
     final Handshake handshake;
-    final Throwable throwable;
+    final IOException ioe;
 
-    SecureConnectEnd(Call call, Handshake handshake, Throwable throwable) {
-      super(call, handshake, throwable);
+    SecureConnectEnd(Call call, Handshake handshake, IOException ioe) {
+      super(call, handshake, ioe);
       this.handshake = handshake;
-      this.throwable = throwable;
+      this.ioe = ioe;
     }
 
     @Nullable @Override public CallEvent closes() {
@@ -296,11 +297,11 @@ public String getName() {
   }
 
   static final class CallEnd extends CallEvent {
-    final Throwable throwable;
+    final IOException ioe;
 
-    CallEnd(Call call, Throwable throwable) {
-      super(call, throwable);
-      this.throwable = throwable;
+    CallEnd(Call call, IOException ioe) {
+      super(call, ioe);
+      this.ioe = ioe;
     }
 
     @Nullable @Override public CallEvent closes() {
@@ -315,11 +316,13 @@ public String getName() {
   }
 
   static final class RequestHeadersEnd extends CallEvent {
-    final Throwable throwable;
+    final IOException ioe;
+    final long headerLength;
 
-    RequestHeadersEnd(Call call, Throwable throwable) {
-      super(call, throwable);
-      this.throwable = throwable;
+    RequestHeadersEnd(Call call, long headerLength, IOException ioe) {
+      super(call, headerLength, ioe);
+      this.ioe = ioe;
+      this.headerLength = headerLength;
     }
 
     @Nullable @Override public CallEvent closes() {
@@ -334,11 +337,13 @@ public String getName() {
   }
 
   static final class RequestBodyEnd extends CallEvent {
-    final Throwable throwable;
+    final IOException ioe;
+    final long bytesWritten;
 
-    RequestBodyEnd(Call call, Throwable throwable) {
-      super(call, throwable);
-      this.throwable = throwable;
+    RequestBodyEnd(Call call, long bytesWritten, IOException ioe) {
+      super(call, bytesWritten, ioe);
+      this.ioe = ioe;
+      this.bytesWritten = bytesWritten;
     }
 
     @Nullable @Override public CallEvent closes() {
@@ -353,11 +358,13 @@ public String getName() {
   }
 
   static final class ResponseHeadersEnd extends CallEvent {
-    final Throwable throwable;
+    final IOException ioe;
+    final long headerLength;
 
-    ResponseHeadersEnd(Call call, Throwable throwable) {
-      super(call, throwable);
-      this.throwable = throwable;
+    ResponseHeadersEnd(Call call, long headerLength, IOException ioe) {
+      super(call, headerLength, ioe);
+      this.ioe = ioe;
+      this.headerLength = headerLength;
     }
 
     @Nullable @Override public CallEvent closes() {
@@ -372,11 +379,13 @@ public String getName() {
   }
 
   static final class ResponseBodyEnd extends CallEvent {
-    final Throwable throwable;
+    final IOException ioe;
+    final long bytesRead;
 
-    ResponseBodyEnd(Call call, Throwable throwable) {
-      super(call, throwable);
-      this.throwable = throwable;
+    ResponseBodyEnd(Call call, long bytesRead, IOException ioe) {
+      super(call, bytesRead, ioe);
+      this.ioe = ioe;
+      this.bytesRead = bytesRead;
     }
 
     @Nullable @Override public CallEvent closes() {
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
index f3564997f2..af26aa095c 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
@@ -34,6 +34,7 @@
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
 public final class RealWebSocketTest {
   // NOTE: Fields are named 'client' and 'server' for cognitive simplicity. This differentiation has
@@ -79,6 +80,15 @@
     assertFalse(client.webSocket.send("Hello!"));
   }
 
+  @Test public void clientCloseWith0Fails() throws IOException {
+    try {
+      client.webSocket.close(0, null);
+      fail();
+    } catch (IllegalArgumentException expected) {
+      assertEquals(expected.getMessage(), "Code must be in range [1000,5000): 0");
+    }
+  }
+
   @Test public void afterSocketClosedPingFailsWebSocket() throws IOException {
     client2Server.source().close();
     client.webSocket.pong(ByteString.encodeUtf8("Ping!"));
diff --git a/okhttp/src/main/java/okhttp3/CertificatePinner.java b/okhttp/src/main/java/okhttp3/CertificatePinner.java
index 1d8eb97750..d8c351b013 100644
--- a/okhttp/src/main/java/okhttp3/CertificatePinner.java
+++ b/okhttp/src/main/java/okhttp3/CertificatePinner.java
@@ -182,7 +182,7 @@ public void check(String hostname, List<Certificate> peerCertificates)
           if (sha1 == null) sha1 = sha1(x509Certificate);
           if (pin.hash.equals(sha1)) return; // Success!
         } else {
-          throw new AssertionError();
+          throw new AssertionError("unsupported hashAlgorithm: " + pin.hashAlgorithm);
         }
       }
     }
diff --git a/okhttp/src/main/java/okhttp3/EventListener.java b/okhttp/src/main/java/okhttp3/EventListener.java
index b56b867c85..1f25074522 100644
--- a/okhttp/src/main/java/okhttp3/EventListener.java
+++ b/okhttp/src/main/java/okhttp3/EventListener.java
@@ -15,6 +15,7 @@
  */
 package okhttp3;
 
+import java.io.IOException;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.net.Proxy;
@@ -64,7 +65,7 @@ public EventListener create(Call call) {
    *
    * <p>This will be invoked only once for a single {@link Call}. Retries of different routes
    * or redirects will be handled within the boundaries of a single callStart and
-   * {@link #callEnd(Call, Throwable)} pair.
+   * {@link #callEnd(Call, IOException)} pair.
    */
   public void callStart(Call call) {
   }
@@ -86,14 +87,14 @@ public void dnsStart(Call call, String domainName) {
    *
    * <p>This method is always invoked after {@link #dnsStart(Call, String)}.
    *
-   * <p>{@code inetAddressList} will be non-null and {@code throwable} will be null in the case of a
+   * <p>{@code inetAddressList} will be non-null and {@code ioe} will be null in the case of a
    * successful DNS lookup.
    *
-   * <p>{@code inetAddressList} will be null and {@code throwable} will be non-null in the case of a
+   * <p>{@code inetAddressList} will be null and {@code ioe} will be non-null in the case of a
    * failed DNS lookup.
    */
   public void dnsEnd(Call call, String domainName, @Nullable List<InetAddress> inetAddressList,
-      @Nullable Throwable throwable) {
+      @Nullable IOException ioe) {
   }
 
   /**
@@ -128,32 +129,32 @@ public void secureConnectStart(Call call) {
    *
    * <p>This method is always invoked after {@link #secureConnectStart(Call)}.
    *
-   * <p>{@code handshake} will be non-null and {@code throwable} will be null in the case of a
+   * <p>{@code handshake} will be non-null and {@code ioe} will be null in the case of a
    * successful TLS connection.
    *
-   * <p>{@code handshake} will be null and {@code throwable} will be non-null in the case of a
+   * <p>{@code handshake} will be null and {@code ioe} will be non-null in the case of a
    * failed TLS connection attempt.
    */
   public void secureConnectEnd(Call call, @Nullable Handshake handshake,
-      @Nullable Throwable throwable) {
+      @Nullable IOException ioe) {
   }
 
   /**
    * Invoked immediately after a socket connection was attempted.
    *
    * <p>If the {@code call} uses HTTPS, this will be invoked after
-   * {@link #secureConnectEnd(Call, Handshake, Throwable)}, otherwise it will invoked after
+   * {@link #secureConnectEnd(Call, Handshake, IOException)}, otherwise it will invoked after
    * {@link #connectStart(Call, InetSocketAddress, Proxy)}.
    *
-   * <p>{@code protocol} and {@code proxy} will be non-null and {@code throwable} will be null when
+   * <p>{@code protocol} and {@code proxy} will be non-null and {@code ioe} will be null when
    * the connection is successfully established.
    *
-   * <p>{@code protocol} and {@code proxy} will be null and {@code throwable} will be non-null in
+   * <p>{@code protocol} and {@code proxy} will be null and {@code ioe} will be non-null in
    * the case of a failed connection attempt.
    */
   public void connectEnd(Call call, InetSocketAddress inetSocketAddress,
       @Nullable Proxy proxy, @Nullable Protocol protocol,
-      @Nullable Throwable throwable) {
+      @Nullable IOException ioe) {
   }
 
   /**
@@ -193,11 +194,10 @@ public void requestHeadersStart(Call call) {
    *
    * <p>This method is always invoked after {@link #requestHeadersStart(Call)}.
    *
-   * <p>{@code throwable} will be null in the case of a successful attempt to send the headers.
-   *
-   * <p>{@code throwable} will be non-null in the case of a failed attempt to send the headers.
+   * @param headerLength the length in java characters of headers to be written.
+   * @param ioe null if request body was successfully written, non-null otherwise.
    */
-  public void requestHeadersEnd(Call call, @Nullable Throwable throwable) {
+  public void requestHeadersEnd(Call call, long headerLength, @Nullable IOException ioe) {
   }
 
   /**
@@ -218,11 +218,14 @@ public void requestBodyStart(Call call) {
    *
    * <p>This method is always invoked after {@link #requestBodyStart(Call)}.
    *
-   * <p>{@code throwable} will be null in the case of a successful attempt to send the body.
+   * <p>{@code ioe} will be null in the case of a successful attempt to send the body.
+   *
+   * <p>{@code ioe} will be non-null in the case of a failed attempt to send the body.
    *
-   * <p>{@code throwable} will be non-null in the case of a failed attempt to send the body.
+   * @param bytesWritten the length in bytes of body written, including partial success.
+   * @param ioe null if request body was successfully written, non-null otherwise.
    */
-  public void requestBodyEnd(Call call, @Nullable Throwable throwable) {
+  public void requestBodyEnd(Call call, long bytesWritten, @Nullable IOException ioe) {
   }
 
   /**
@@ -242,11 +245,10 @@ public void responseHeadersStart(Call call) {
    *
    * <p>This method is always invoked after {@link #responseHeadersStart(Call)}.
    *
-   * <p>{@code throwable} will be null in the case of a successful attempt to receive the headers.
-   *
-   * <p>{@code throwable} will be non-null in the case of a failed attempt to receive the headers.
+   * @param headerLength the length in bytes of headers read, or -1 if failed to read.
+   * @param ioe null if response headers were successfully received, non-null otherwise.
    */
-  public void responseHeadersEnd(Call call, @Nullable Throwable throwable) {
+  public void responseHeadersEnd(Call call, long headerLength, @Nullable IOException ioe) {
   }
 
   /**
@@ -269,11 +271,10 @@ public void responseBodyStart(Call call) {
    *
    * <p>This method is always invoked after {@link #requestBodyStart(Call)}.
    *
-   * <p>{@code throwable} will be null in the case of a successful attempt to send the body.
-   *
-   * <p>{@code throwable} will be non-null in the case of a failed attempt to send the body.
+   * @param bytesRead the length in bytes of the body read, including partial success.
+   * @param ioe null if response body was successfully received, non-null otherwise.
    */
-  public void responseBodyEnd(Call call, @Nullable Throwable throwable) {
+  public void responseBodyEnd(Call call, long bytesRead, @Nullable IOException ioe) {
   }
 
   /**
@@ -282,11 +283,11 @@ public void responseBodyEnd(Call call, @Nullable Throwable throwable) {
    *
    * <p>This method is always invoked after {@link #callStart(Call)}.
    *
-   * <p>{@code throwable} will be null in the case of a successful attempt to execute the call.
+   * <p>{@code ioe} will be null in the case of a successful attempt to execute the call.
    *
-   * <p>{@code throwable} will be non-null in the case of a failed attempt to execute the call.
+   * <p>{@code ioe} will be non-null in the case of a failed attempt to execute the call.
    */
-  public void callEnd(Call call, @Nullable Throwable throwable) {
+  public void callEnd(Call call, @Nullable IOException ioe) {
   }
 
   public interface Factory {
diff --git a/okhttp/src/main/java/okhttp3/HttpUrl.java b/okhttp/src/main/java/okhttp3/HttpUrl.java
index 5498c3125f..08c10ce3c2 100644
--- a/okhttp/src/main/java/okhttp3/HttpUrl.java
+++ b/okhttp/src/main/java/okhttp3/HttpUrl.java
@@ -1599,7 +1599,7 @@ private static String canonicalizeHost(String input, int pos, int limit) {
         if (inetAddress == null) return null;
         byte[] address = inetAddress.getAddress();
         if (address.length == 16) return inet6AddressToAscii(address);
-        throw new AssertionError();
+        throw new AssertionError("Invalid IPv6 address: '" + percentDecoded + "'");
       }
 
       return domainToAscii(percentDecoded);
diff --git a/okhttp/src/main/java/okhttp3/OkHttpClient.java b/okhttp/src/main/java/okhttp3/OkHttpClient.java
index 70c9fc0a7d..f9df7752ae 100644
--- a/okhttp/src/main/java/okhttp3/OkHttpClient.java
+++ b/okhttp/src/main/java/okhttp3/OkHttpClient.java
@@ -49,6 +49,7 @@
 import okhttp3.internal.tls.OkHostnameVerifier;
 import okhttp3.internal.ws.RealWebSocket;
 
+import static okhttp3.internal.Util.assertionError;
 import static okhttp3.internal.Util.checkDuration;
 
 /**
@@ -281,7 +282,7 @@ private X509TrustManager systemDefaultTrustManager() {
       }
       return (X509TrustManager) trustManagers[0];
     } catch (GeneralSecurityException e) {
-      throw new AssertionError(); // The system has no TLS. Just give up.
+      throw assertionError("No System TLS", e); // The system has no TLS. Just give up.
     }
   }
 
@@ -291,7 +292,7 @@ private SSLSocketFactory systemDefaultSslSocketFactory(X509TrustManager trustMan
       sslContext.init(null, new TrustManager[] { trustManager }, null);
       return sslContext.getSocketFactory();
     } catch (GeneralSecurityException e) {
-      throw new AssertionError(); // The system has no TLS. Just give up.
+      throw assertionError("No System TLS", e); // The system has no TLS. Just give up.
     }
   }
 
diff --git a/okhttp/src/main/java/okhttp3/WebSocket.java b/okhttp/src/main/java/okhttp3/WebSocket.java
index 83b585c968..42daf90594 100644
--- a/okhttp/src/main/java/okhttp3/WebSocket.java
+++ b/okhttp/src/main/java/okhttp3/WebSocket.java
@@ -99,8 +99,9 @@
    * a graceful shutdown was already underway or if the web socket is already closed or canceled.
    *
    * @param code Status code as defined by <a
-   * href="http://tools.ietf.org/html/rfc6455#section-7.4">Section 7.4 of RFC 6455</a> or {@code 0}.
+   * href="http://tools.ietf.org/html/rfc6455#section-7.4">Section 7.4 of RFC 6455</a>.
    * @param reason Reason for shutting down or {@code null}.
+   * @throws IllegalArgumentException if code is invalid.
    */
   boolean close(int code, @Nullable String reason);
 
diff --git a/okhttp/src/main/java/okhttp3/internal/Util.java b/okhttp/src/main/java/okhttp3/internal/Util.java
index 17927ce0fe..4c38afe1bb 100644
--- a/okhttp/src/main/java/okhttp3/internal/Util.java
+++ b/okhttp/src/main/java/okhttp3/internal/Util.java
@@ -459,4 +459,8 @@ public static int checkDuration(String name, long duration, TimeUnit unit) {
     if (millis == 0 && duration > 0) throw new IllegalArgumentException(name + " too small.");
     return (int) millis;
   }
+
+  public static AssertionError assertionError(String message, Exception e) {
+    return (AssertionError) new AssertionError(message).initCause(e);
+  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java b/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
index 2e0458a8cf..148cb2c640 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
@@ -268,9 +268,9 @@ private void establishProtocol(ConnectionSpecSelector connectionSpecSelector, Ca
     try {
       connectTls(connectionSpecSelector);
       eventListener.secureConnectEnd(call, handshake, null);
-    } catch (Exception e) {
-      eventListener.secureConnectEnd(call, null, e);
-      throw e;
+    } catch (IOException ioe) {
+      eventListener.secureConnectEnd(call, null, ioe);
+      throw ioe;
     }
 
     if (protocol == Protocol.HTTP_2) {
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/RouteSelector.java b/okhttp/src/main/java/okhttp3/internal/connection/RouteSelector.java
index 981c63ebf7..9a17852269 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/RouteSelector.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/RouteSelector.java
@@ -185,9 +185,9 @@ private void resetNextInetSocketAddress(Proxy proxy) throws IOException {
       List<InetAddress> addresses;
       try {
         addresses = address.dns().lookup(socketHost);
-      } catch (Exception e) {
-        eventListener.dnsEnd(call, socketHost, null, e);
-        throw e;
+      } catch (IOException ioe) {
+        eventListener.dnsEnd(call, socketHost, null, ioe);
+        throw ioe;
       }
       if (addresses.isEmpty()) {
         UnknownHostException exception = new UnknownHostException(
diff --git a/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
index 65fd234e24..c976c69f2a 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
@@ -17,13 +17,16 @@
 
 import java.io.IOException;
 import java.net.ProtocolException;
+import okhttp3.Headers;
 import okhttp3.Interceptor;
 import okhttp3.Request;
 import okhttp3.Response;
 import okhttp3.internal.Util;
 import okhttp3.internal.connection.RealConnection;
 import okhttp3.internal.connection.StreamAllocation;
+import okio.Buffer;
 import okio.BufferedSink;
+import okio.ForwardingSink;
 import okio.Okio;
 import okio.Sink;
 
@@ -47,55 +50,63 @@ public CallServerInterceptor(boolean forWebSocket) {
     realChain.eventListener().requestHeadersStart(realChain.call());
     try {
       httpCodec.writeRequestHeaders(request);
-      realChain.eventListener().requestHeadersEnd(realChain.call(), null);
+      realChain.eventListener()
+          .requestHeadersEnd(realChain.call(), headerLength(request.headers()), null);
     } catch (IOException ioe) {
-      realChain.eventListener().requestHeadersEnd(realChain.call(), ioe);
+      realChain.eventListener()
+          .requestHeadersEnd(realChain.call(), headerLength(request.headers()), ioe);
       throw ioe;
     }
 
     Response.Builder responseBuilder = null;
     if (HttpMethod.permitsRequestBody(request.method()) && request.body() != null) {
-      realChain.eventListener().requestBodyStart(realChain.call());
-      try {
-        // If there's a "Expect: 100-continue" header on the request, wait for a "HTTP/1.1 100
-        // Continue" response before transmitting the request body. If we don't get that, return
-        // what we did get (such as a 4xx response) without ever transmitting the request body.
-        if ("100-continue".equalsIgnoreCase(request.header("Expect"))) {
-          httpCodec.flushRequest();
-          // TODO event listener
+      // If there's a "Expect: 100-continue" header on the request, wait for a "HTTP/1.1 100
+      // Continue" response before transmitting the request body. If we don't get that, return
+      // what we did get (such as a 4xx response) without ever transmitting the request body.
+      if ("100-continue".equalsIgnoreCase(request.header("Expect"))) {
+        httpCodec.flushRequest();
+        try {
+          realChain.eventListener().responseHeadersStart(realChain.call());
           responseBuilder = httpCodec.readResponseHeaders(true);
+        } catch (IOException ioe) {
+          realChain.eventListener().responseHeadersEnd(realChain.call(), -1, ioe);
+          throw ioe;
         }
+      }
 
-        if (responseBuilder == null) {
-          // Write the request body if the "Expect: 100-continue" expectation was met.
-          Sink requestBodyOut =
-              httpCodec.createRequestBody(request, request.body().contentLength());
+      if (responseBuilder == null) {
+        // Write the request body if the "Expect: 100-continue" expectation was met.
+        realChain.eventListener().requestBodyStart(realChain.call());
+        try {
+          long contentLength = request.body().contentLength();
+          CountingSink requestBodyOut =
+              new CountingSink(httpCodec.createRequestBody(request, contentLength));
           BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);
 
           request.body().writeTo(bufferedRequestBody);
           bufferedRequestBody.close();
-        } else if (!connection.isMultiplexed()) {
-          // If the "Expect: 100-continue" expectation wasn't met, prevent the HTTP/1 connection
-          // from being reused. Otherwise we're still obligated to transmit the request body to
-          // leave the connection in a consistent state.
-          streamAllocation.noNewStreams();
+          realChain.eventListener()
+              .requestBodyEnd(realChain.call(), requestBodyOut.successfulCount, null);
+        } catch (IOException ioe) {
+          realChain.eventListener().requestBodyEnd(realChain.call(), -1, ioe);
+          throw ioe;
         }
-        realChain.eventListener().requestBodyEnd(realChain.call(), null);
-      } catch (IOException ioe) {
-        realChain.eventListener().requestBodyEnd(realChain.call(), ioe);
-        throw ioe;
+      } else if (!connection.isMultiplexed()) {
+        // If the "Expect: 100-continue" expectation wasn't met, prevent the HTTP/1 connection
+        // from being reused. Otherwise we're still obligated to transmit the request body to
+        // leave the connection in a consistent state.
+        streamAllocation.noNewStreams();
       }
     }
 
     httpCodec.finishRequest();
 
     if (responseBuilder == null) {
-      realChain.eventListener().responseHeadersStart(realChain.call());
       try {
+        realChain.eventListener().responseHeadersStart(realChain.call());
         responseBuilder = httpCodec.readResponseHeaders(false);
-        realChain.eventListener().responseHeadersEnd(realChain.call(), null);
       } catch (IOException ioe) {
-        realChain.eventListener().responseHeadersEnd(realChain.call(), ioe);
+        realChain.eventListener().responseHeadersEnd(realChain.call(), -1, ioe);
         throw ioe;
       }
     }
@@ -107,6 +118,9 @@ public CallServerInterceptor(boolean forWebSocket) {
         .receivedResponseAtMillis(System.currentTimeMillis())
         .build();
 
+    realChain.eventListener()
+        .responseHeadersEnd(realChain.call(), headerLength(response.headers()), null);
+
     int code = response.code();
     if (forWebSocket && code == 101) {
       // Connection is upgrading, but we need to ensure interceptors see a non-null response body.
@@ -131,4 +145,28 @@ public CallServerInterceptor(boolean forWebSocket) {
 
     return response;
   }
+
+  private long headerLength(Headers headers) {
+    long length = 0;
+
+    for (int i = 0, size = headers.size(); i < size; i++) {
+      length += headers.name(i).length();
+      length += headers.value(i).length();
+    }
+
+    return length;
+  }
+
+  static final class CountingSink extends ForwardingSink {
+    long successfulCount;
+
+    CountingSink(Sink delegate) {
+      super(delegate);
+    }
+
+    @Override public void write(Buffer source, long byteCount) throws IOException {
+      super.write(source, byteCount);
+      successfulCount += byteCount;
+    }
+  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java b/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java
index 4618571413..ee5c74f2de 100644
--- a/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java
+++ b/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java
@@ -344,6 +344,7 @@ void detachTimeout(ForwardingTimeout timeout) {
   private abstract class AbstractSource implements Source {
     protected final ForwardingTimeout timeout = new ForwardingTimeout(source.timeout());
     protected boolean closed;
+    protected long bytesRead = 0;
 
     @Override public Timeout timeout() {
       return timeout;
@@ -351,7 +352,11 @@ void detachTimeout(ForwardingTimeout timeout) {
 
     @Override public long read(Buffer sink, long byteCount) throws IOException {
       try {
-        return source.read(sink, byteCount);
+        long read = source.read(sink, byteCount);
+        if (read > 0) {
+          bytesRead += read;
+        }
+        return read;
       } catch (IOException e) {
         endOfInput(false, e);
         throw e;
@@ -370,7 +375,7 @@ protected final void endOfInput(boolean reuseConnection, IOException e) throws I
 
       state = STATE_CLOSED;
       if (streamAllocation != null) {
-        streamAllocation.eventListener.responseBodyEnd(streamAllocation.call, e);
+        streamAllocation.eventListener.responseBodyEnd(streamAllocation.call, bytesRead, e);
         streamAllocation.streamFinished(!reuseConnection, Http1Codec.this);
       }
     }
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java
index 99bc77d393..bd4af1fcbb 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java
@@ -196,6 +196,7 @@ public Http2Codec(OkHttpClient client, Interceptor.Chain chain, StreamAllocation
 
   class StreamFinishingSource extends ForwardingSource {
     boolean completed = false;
+    long bytesRead = 0;
 
     StreamFinishingSource(Source delegate) {
       super(delegate);
@@ -203,7 +204,11 @@ public Http2Codec(OkHttpClient client, Interceptor.Chain chain, StreamAllocation
 
     @Override public long read(Buffer sink, long byteCount) throws IOException {
       try {
-        return delegate().read(sink, byteCount);
+        long read = delegate().read(sink, byteCount);
+        if (read > 0) {
+          bytesRead += read;
+        }
+        return read;
       } catch (IOException e) {
         endOfInput(e);
         throw e;
@@ -218,7 +223,7 @@ public Http2Codec(OkHttpClient client, Interceptor.Chain chain, StreamAllocation
     private void endOfInput(IOException e) {
       if (completed) return;
       completed = true;
-      streamAllocation.eventListener.responseBodyEnd(streamAllocation.call, e);
+      streamAllocation.eventListener.responseBodyEnd(streamAllocation.call, bytesRead, e);
       streamAllocation.streamFinished(false, Http2Codec.this);
     }
   }
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.java b/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.java
index 899ccfacac..e220fe9d82 100644
--- a/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.java
+++ b/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.java
@@ -37,6 +37,8 @@
 import okhttp3.internal.tls.CertificateChainCleaner;
 import okhttp3.internal.tls.TrustRootIndex;
 
+import static okhttp3.internal.Util.assertionError;
+
 /** Android 2.3 or better. */
 class AndroidPlatform extends Platform {
   private static final int MAX_LOG_LENGTH = 4000;
@@ -159,7 +161,7 @@
     } catch (ClassNotFoundException | NoSuchMethodException e) {
       return super.isCleartextTrafficPermitted(hostname);
     } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
-      throw new AssertionError();
+      throw assertionError("unable to determine cleartext support", e);
     }
   }
 
@@ -389,7 +391,7 @@ static CloseGuard get() {
                 ? trustAnchor.getTrustedCert()
                 : null;
       } catch (IllegalAccessException e) {
-        throw new AssertionError();
+        throw assertionError("unable to get issues and signature", e);
       } catch (InvocationTargetException e) {
         return null;
       }
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/Jdk9Platform.java b/okhttp/src/main/java/okhttp3/internal/platform/Jdk9Platform.java
index 19f444dd55..24b75217b0 100644
--- a/okhttp/src/main/java/okhttp3/internal/platform/Jdk9Platform.java
+++ b/okhttp/src/main/java/okhttp3/internal/platform/Jdk9Platform.java
@@ -24,6 +24,8 @@
 import javax.net.ssl.X509TrustManager;
 import okhttp3.Protocol;
 
+import static okhttp3.internal.Util.assertionError;
+
 /**
  * OpenJDK 9+.
  */
@@ -49,7 +51,7 @@ public void configureTlsExtensions(SSLSocket sslSocket, String hostname,
 
       sslSocket.setSSLParameters(sslParameters);
     } catch (IllegalAccessException | InvocationTargetException e) {
-      throw new AssertionError();
+      throw assertionError("unable to set ssl parameters", e);
     }
   }
 
@@ -66,7 +68,7 @@ public String getSelectedProtocol(SSLSocket socket) {
 
       return protocol;
     } catch (IllegalAccessException | InvocationTargetException e) {
-      throw new AssertionError();
+      throw assertionError("unable to get selected protocols", e);
     }
   }
 
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/JdkWithJettyBootPlatform.java b/okhttp/src/main/java/okhttp3/internal/platform/JdkWithJettyBootPlatform.java
index 5dd11ee362..bfb4ed8c89 100644
--- a/okhttp/src/main/java/okhttp3/internal/platform/JdkWithJettyBootPlatform.java
+++ b/okhttp/src/main/java/okhttp3/internal/platform/JdkWithJettyBootPlatform.java
@@ -24,6 +24,8 @@
 import okhttp3.Protocol;
 import okhttp3.internal.Util;
 
+import static okhttp3.internal.Util.assertionError;
+
 /**
  * OpenJDK 7 or OpenJDK 8 with {@code org.mortbay.jetty.alpn/alpn-boot} in the boot class path.
  */
@@ -52,15 +54,15 @@
           new Class[] {clientProviderClass, serverProviderClass}, new JettyNegoProvider(names));
       putMethod.invoke(null, sslSocket, provider);
     } catch (InvocationTargetException | IllegalAccessException e) {
-      throw new AssertionError(e);
+      throw assertionError("unable to set alpn", e);
     }
   }
 
   @Override public void afterHandshake(SSLSocket sslSocket) {
     try {
       removeMethod.invoke(null, sslSocket);
-    } catch (IllegalAccessException | InvocationTargetException ignored) {
-      throw new AssertionError();
+    } catch (IllegalAccessException | InvocationTargetException e) {
+      throw assertionError("unable to remove alpn", e);
     }
   }
 
@@ -75,7 +77,7 @@
       }
       return provider.unsupported ? null : provider.selected;
     } catch (InvocationTargetException | IllegalAccessException e) {
-      throw new AssertionError();
+      throw assertionError("unable to get selected protocol", e);
     }
   }
 
