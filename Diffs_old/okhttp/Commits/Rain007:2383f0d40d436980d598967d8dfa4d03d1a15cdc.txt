diff --git a/okhttp/src/main/java/okhttp3/OkHttpClient.java b/okhttp/src/main/java/okhttp3/OkHttpClient.java
index a8ae6dcb15..f49ac07a1f 100644
--- a/okhttp/src/main/java/okhttp3/OkHttpClient.java
+++ b/okhttp/src/main/java/okhttp3/OkHttpClient.java
@@ -201,6 +201,7 @@ public void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket, boolean
   final int connectTimeout;
   final int readTimeout;
   final int writeTimeout;
+  final int maxFailTry;
 
   public OkHttpClient() {
     this(new Builder());
@@ -246,6 +247,7 @@ private OkHttpClient(Builder builder) {
     this.connectTimeout = builder.connectTimeout;
     this.readTimeout = builder.readTimeout;
     this.writeTimeout = builder.writeTimeout;
+    this.maxFailTry = builder.maxFailTry;
   }
 
   private X509TrustManager systemDefaultTrustManager() {
@@ -365,7 +367,12 @@ public Dispatcher dispatcher() {
     return connectionSpecs;
   }
 
-  /**
+  // Limit the maximum fail try times, setting to equal or less than 0 means no limit.
+  public int getMaxFailTry() {
+    return maxFailTry;
+  }
+
+    /**
    * Returns an immutable list of interceptors that observe the full span of each call: from before
    * the connection is established (if any) until after the response source is selected (either the
    * origin server, cache, or both).
@@ -429,6 +436,7 @@ public Builder newBuilder() {
     int connectTimeout;
     int readTimeout;
     int writeTimeout;
+    int maxFailTry;
 
     public Builder() {
       dispatcher = new Dispatcher();
@@ -449,6 +457,7 @@ public Builder() {
       connectTimeout = 10_000;
       readTimeout = 10_000;
       writeTimeout = 10_000;
+      maxFailTry = 3;
     }
 
     Builder(OkHttpClient okHttpClient) {
@@ -477,9 +486,18 @@ public Builder() {
       this.connectTimeout = okHttpClient.connectTimeout;
       this.readTimeout = okHttpClient.readTimeout;
       this.writeTimeout = okHttpClient.writeTimeout;
+      this.maxFailTry = okHttpClient.maxFailTry;
     }
 
-    /**
+      /**
+       * Limit the maximum fail try times, setting to equal or less than 0 means no limit.
+       */
+      public Builder maxFailTry(int maxFailTry) {
+          this.maxFailTry = maxFailTry;
+          return this;
+      }
+
+      /**
      * Sets the default connect timeout for new connections. A value of 0 means no timeout,
      * otherwise values must be between 1 and {@link Integer#MAX_VALUE} when converted to
      * milliseconds.
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
index 792ddc9299..7368a44ab3 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
@@ -67,6 +67,7 @@
   private StreamAllocation streamAllocation;
   private Object callStackTrace;
   private volatile boolean canceled;
+    private int failTryCount;
 
   public RetryAndFollowUpInterceptor(OkHttpClient client, boolean forWebSocket) {
     this.client = client;
@@ -108,6 +109,7 @@ public StreamAllocation streamAllocation() {
 
     int followUpCount = 0;
     Response priorResponse = null;
+      failTryCount = 0;
     while (true) {
       if (canceled) {
         streamAllocation.release();
@@ -125,12 +127,14 @@ public StreamAllocation streamAllocation() {
           throw e.getLastConnectException();
         }
         releaseConnection = false;
+          failTryCount++;
         continue;
       } catch (IOException e) {
         // An attempt to communicate with a server failed. The request may have been sent.
         boolean requestSendStarted = !(e instanceof ConnectionShutdownException);
         if (!recover(e, requestSendStarted, request)) throw e;
         releaseConnection = false;
+          failTryCount++;
         continue;
       } finally {
         // We're throwing an unchecked exception. Release any resources.
@@ -211,6 +215,9 @@ private boolean recover(IOException e, boolean requestSendStarted, Request userR
     // The application layer has forbidden retries.
     if (!client.retryOnConnectionFailure()) return false;
 
+      // Limit the maximum fail try times, setting to equal or less than 0 means no limit.
+      if(client.getMaxFailTry() > 0 && failTryCount >= client.getMaxFailTry()) return false;
+
     // We can't send the request body again.
     if (requestSendStarted && userRequest.body() instanceof UnrepeatableRequestBody) return false;
 
