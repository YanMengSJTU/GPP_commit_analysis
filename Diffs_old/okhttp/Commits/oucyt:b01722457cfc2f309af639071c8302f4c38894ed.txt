diff --git a/okhttp/src/main/java/okhttp3/ConnectionPool.java b/okhttp/src/main/java/okhttp3/ConnectionPool.java
index 2c0c6fffbd..9fd1946d85 100644
--- a/okhttp/src/main/java/okhttp3/ConnectionPool.java
+++ b/okhttp/src/main/java/okhttp3/ConnectionPool.java
@@ -27,7 +27,9 @@
 import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
+
 import javax.annotation.Nullable;
+
 import okhttp3.internal.Util;
 import okhttp3.internal.connection.RealConnection;
 import okhttp3.internal.connection.RouteDatabase;
@@ -42,236 +44,248 @@
  * of which connections to keep open for future use.
  */
 public final class ConnectionPool {
-  /**
-   * Background threads are used to cleanup expired connections. There will be at most a single
-   * thread running per connection pool. The thread pool executor permits the pool itself to be
-   * garbage collected.
-   */
-  private static final Executor executor = new ThreadPoolExecutor(0 /* corePoolSize */,
-      Integer.MAX_VALUE /* maximumPoolSize */, 60L /* keepAliveTime */, TimeUnit.SECONDS,
-      new SynchronousQueue<>(), Util.threadFactory("OkHttp ConnectionPool", true));
-
-  /** The maximum number of idle connections for each address. */
-  private final int maxIdleConnections;
-  private final long keepAliveDurationNs;
-  private final Runnable cleanupRunnable = () -> {
-    while (true) {
-      long waitNanos = cleanup(System.nanoTime());
-      if (waitNanos == -1) return;
-      if (waitNanos > 0) {
-        long waitMillis = waitNanos / 1000000L;
-        waitNanos -= (waitMillis * 1000000L);
-        synchronized (ConnectionPool.this) {
-          try {
-            ConnectionPool.this.wait(waitMillis, (int) waitNanos);
-          } catch (InterruptedException ignored) {
-          }
+    /**
+     * Background threads are used to cleanup expired connections. There will be at most a single
+     * thread running per connection pool. The thread pool executor permits the pool itself to be
+     * garbage collected.
+     */
+    private static final Executor executor = new ThreadPoolExecutor(0 /* corePoolSize */,
+            Integer.MAX_VALUE /* maximumPoolSize */, 60L /* keepAliveTime */, TimeUnit.SECONDS,
+            new SynchronousQueue<>(), Util.threadFactory("OkHttp ConnectionPool", true));
+
+    /**
+     * The maximum number of idle connections for each address.
+     */
+    private final int maxIdleConnections;
+    private final long keepAliveDurationNs;
+    private final Runnable cleanupRunnable = new Runnable() {
+        @Override
+        public void run() {
+            while (true) {
+                long waitNanos = ConnectionPool.this.cleanup(System.nanoTime());
+                if (waitNanos == -1) return;
+                if (waitNanos > 0) {
+                    long waitMillis = waitNanos / 1000000L;
+                    waitNanos -= (waitMillis * 1000000L);
+                    synchronized (ConnectionPool.this) {
+                        try {
+                            ConnectionPool.this.wait(waitMillis, (int) waitNanos);
+                        } catch (InterruptedException ignored) {
+                        }
+                    }
+                }
+            }
         }
-      }
-    }
-  };
-
-  private final Deque<RealConnection> connections = new ArrayDeque<>();
-  final RouteDatabase routeDatabase = new RouteDatabase();
-  boolean cleanupRunning;
-
-  /**
-   * Create a new connection pool with tuning parameters appropriate for a single-user application.
-   * The tuning parameters in this pool are subject to change in future OkHttp releases. Currently
-   * this pool holds up to 5 idle connections which will be evicted after 5 minutes of inactivity.
-   */
-  public ConnectionPool() {
-    this(5, 5, TimeUnit.MINUTES);
-  }
-
-  public ConnectionPool(int maxIdleConnections, long keepAliveDuration, TimeUnit timeUnit) {
-    this.maxIdleConnections = maxIdleConnections;
-    this.keepAliveDurationNs = timeUnit.toNanos(keepAliveDuration);
-
-    // Put a floor on the keep alive duration, otherwise cleanup will spin loop.
-    if (keepAliveDuration <= 0) {
-      throw new IllegalArgumentException("keepAliveDuration <= 0: " + keepAliveDuration);
-    }
-  }
+    };
 
-  /** Returns the number of idle connections in the pool. */
-  public synchronized int idleConnectionCount() {
-    int total = 0;
-    for (RealConnection connection : connections) {
-      if (connection.allocations.isEmpty()) total++;
+    private final Deque<RealConnection> connections = new ArrayDeque<>();
+    final RouteDatabase routeDatabase = new RouteDatabase();
+    boolean cleanupRunning;
+
+    /**
+     * Create a new connection pool with tuning parameters appropriate for a single-user application.
+     * The tuning parameters in this pool are subject to change in future OkHttp releases. Currently
+     * this pool holds up to 5 idle connections which will be evicted after 5 minutes of inactivity.
+     */
+    public ConnectionPool() {
+        this(5, 5, TimeUnit.MINUTES);
     }
-    return total;
-  }
-
-  /** Returns total number of connections in the pool. */
-  public synchronized int connectionCount() {
-    return connections.size();
-  }
-
-  /**
-   * Acquires a recycled connection to {@code address} for {@code streamAllocation}. If non-null
-   * {@code route} is the resolved route for a connection.
-   */
-  void acquire(Address address, StreamAllocation streamAllocation, @Nullable Route route) {
-    assert (Thread.holdsLock(this));
-    for (RealConnection connection : connections) {
-      if (connection.isEligible(address, route)) {
-        streamAllocation.acquire(connection, true);
-        return;
-      }
+
+    public ConnectionPool(int maxIdleConnections, long keepAliveDuration, TimeUnit timeUnit) {
+        this.maxIdleConnections = maxIdleConnections;
+        this.keepAliveDurationNs = timeUnit.toNanos(keepAliveDuration);
+
+        // Put a floor on the keep alive duration, otherwise cleanup will spin loop.
+        if (keepAliveDuration <= 0) {
+            throw new IllegalArgumentException("keepAliveDuration <= 0: " + keepAliveDuration);
+        }
     }
-  }
-
-  /**
-   * Replaces the connection held by {@code streamAllocation} with a shared connection if possible.
-   * This recovers when multiple multiplexed connections are created concurrently.
-   */
-  @Nullable Socket deduplicate(Address address, StreamAllocation streamAllocation) {
-    assert (Thread.holdsLock(this));
-    for (RealConnection connection : connections) {
-      if (connection.isEligible(address, null)
-          && connection.isMultiplexed()
-          && connection != streamAllocation.connection()) {
-        return streamAllocation.releaseAndAcquire(connection);
-      }
+
+    /**
+     * Returns the number of idle connections in the pool.
+     */
+    public synchronized int idleConnectionCount() {
+        int total = 0;
+        for (RealConnection connection : connections) {
+            if (connection.allocations.isEmpty()) total++;
+        }
+        return total;
     }
-    return null;
-  }
-
-  void put(RealConnection connection) {
-    assert (Thread.holdsLock(this));
-    if (!cleanupRunning) {
-      cleanupRunning = true;
-      executor.execute(cleanupRunnable);
+
+    /**
+     * Returns total number of connections in the pool.
+     */
+    public synchronized int connectionCount() {
+        return connections.size();
     }
-    connections.add(connection);
-  }
-
-  /**
-   * Notify this pool that {@code connection} has become idle. Returns true if the connection has
-   * been removed from the pool and should be closed.
-   */
-  boolean connectionBecameIdle(RealConnection connection) {
-    assert (Thread.holdsLock(this));
-    if (connection.noNewStreams || maxIdleConnections == 0) {
-      connections.remove(connection);
-      return true;
-    } else {
-      notifyAll(); // Awake the cleanup thread: we may have exceeded the idle connection limit.
-      return false;
+
+    /**
+     * Acquires a recycled connection to {@code address} for {@code streamAllocation}. If non-null
+     * {@code route} is the resolved route for a connection.
+     */
+    void acquire(Address address, StreamAllocation streamAllocation, @Nullable Route route) {
+        assert (Thread.holdsLock(this));
+        for (RealConnection connection : connections) {
+            if (connection.isEligible(address, route)) {
+                streamAllocation.acquire(connection, true);
+                return;
+            }
+        }
     }
-  }
-
-  /** Close and remove all idle connections in the pool. */
-  public void evictAll() {
-    List<RealConnection> evictedConnections = new ArrayList<>();
-    synchronized (this) {
-      for (Iterator<RealConnection> i = connections.iterator(); i.hasNext(); ) {
-        RealConnection connection = i.next();
-        if (connection.allocations.isEmpty()) {
-          connection.noNewStreams = true;
-          evictedConnections.add(connection);
-          i.remove();
+
+    /**
+     * Replaces the connection held by {@code streamAllocation} with a shared connection if possible.
+     * This recovers when multiple multiplexed connections are created concurrently.
+     */
+    @Nullable
+    Socket deduplicate(Address address, StreamAllocation streamAllocation) {
+        assert (Thread.holdsLock(this));
+        for (RealConnection connection : connections) {
+            if (connection.isEligible(address, null)
+                    && connection.isMultiplexed()
+                    && connection != streamAllocation.connection()) {
+                return streamAllocation.releaseAndAcquire(connection);
+            }
         }
-      }
+        return null;
     }
 
-    for (RealConnection connection : evictedConnections) {
-      closeQuietly(connection.socket());
+    void put(RealConnection connection) {
+        assert (Thread.holdsLock(this));
+        if (!cleanupRunning) {
+            cleanupRunning = true;
+            executor.execute(cleanupRunnable);
+        }
+        connections.add(connection);
     }
-  }
-
-  /**
-   * Performs maintenance on this pool, evicting the connection that has been idle the longest if
-   * either it has exceeded the keep alive limit or the idle connections limit.
-   *
-   * <p>Returns the duration in nanos to sleep until the next scheduled call to this method. Returns
-   * -1 if no further cleanups are required.
-   */
-  long cleanup(long now) {
-    int inUseConnectionCount = 0;
-    int idleConnectionCount = 0;
-    RealConnection longestIdleConnection = null;
-    long longestIdleDurationNs = Long.MIN_VALUE;
-
-    // Find either a connection to evict, or the time that the next eviction is due.
-    synchronized (this) {
-      for (Iterator<RealConnection> i = connections.iterator(); i.hasNext(); ) {
-        RealConnection connection = i.next();
-
-        // If the connection is in use, keep searching.
-        if (pruneAndGetAllocationCount(connection, now) > 0) {
-          inUseConnectionCount++;
-          continue;
+
+    /**
+     * Notify this pool that {@code connection} has become idle. Returns true if the connection has
+     * been removed from the pool and should be closed.
+     */
+    boolean connectionBecameIdle(RealConnection connection) {
+        assert (Thread.holdsLock(this));
+        if (connection.noNewStreams || maxIdleConnections == 0) {
+            connections.remove(connection);
+            return true;
+        } else {
+            notifyAll(); // Awake the cleanup thread: we may have exceeded the idle connection limit.
+            return false;
         }
+    }
 
-        idleConnectionCount++;
+    /**
+     * Close and remove all idle connections in the pool.
+     */
+    public void evictAll() {
+        List<RealConnection> evictedConnections = new ArrayList<>();
+        synchronized (this) {
+            for (Iterator<RealConnection> i = connections.iterator(); i.hasNext(); ) {
+                RealConnection connection = i.next();
+                if (connection.allocations.isEmpty()) {
+                    connection.noNewStreams = true;
+                    evictedConnections.add(connection);
+                    i.remove();
+                }
+            }
+        }
 
-        // If the connection is ready to be evicted, we're done.
-        long idleDurationNs = now - connection.idleAtNanos;
-        if (idleDurationNs > longestIdleDurationNs) {
-          longestIdleDurationNs = idleDurationNs;
-          longestIdleConnection = connection;
+        for (RealConnection connection : evictedConnections) {
+            closeQuietly(connection.socket());
         }
-      }
-
-      if (longestIdleDurationNs >= this.keepAliveDurationNs
-          || idleConnectionCount > this.maxIdleConnections) {
-        // We've found a connection to evict. Remove it from the list, then close it below (outside
-        // of the synchronized block).
-        connections.remove(longestIdleConnection);
-      } else if (idleConnectionCount > 0) {
-        // A connection will be ready to evict soon.
-        return keepAliveDurationNs - longestIdleDurationNs;
-      } else if (inUseConnectionCount > 0) {
-        // All connections are in use. It'll be at least the keep alive duration 'til we run again.
-        return keepAliveDurationNs;
-      } else {
-        // No connections, idle or in use.
-        cleanupRunning = false;
-        return -1;
-      }
     }
 
-    closeQuietly(longestIdleConnection.socket());
-
-    // Cleanup again immediately.
-    return 0;
-  }
-
-  /**
-   * Prunes any leaked allocations and then returns the number of remaining live allocations on
-   * {@code connection}. Allocations are leaked if the connection is tracking them but the
-   * application code has abandoned them. Leak detection is imprecise and relies on garbage
-   * collection.
-   */
-  private int pruneAndGetAllocationCount(RealConnection connection, long now) {
-    List<Reference<StreamAllocation>> references = connection.allocations;
-    for (int i = 0; i < references.size(); ) {
-      Reference<StreamAllocation> reference = references.get(i);
-
-      if (reference.get() != null) {
-        i++;
-        continue;
-      }
-
-      // We've discovered a leaked allocation. This is an application bug.
-      StreamAllocation.StreamAllocationReference streamAllocRef =
-          (StreamAllocation.StreamAllocationReference) reference;
-      String message = "A connection to " + connection.route().address().url()
-          + " was leaked. Did you forget to close a response body?";
-      Platform.get().logCloseableLeak(message, streamAllocRef.callStackTrace);
-
-      references.remove(i);
-      connection.noNewStreams = true;
-
-      // If this was the last allocation, the connection is eligible for immediate eviction.
-      if (references.isEmpty()) {
-        connection.idleAtNanos = now - keepAliveDurationNs;
+    /**
+     * Performs maintenance on this pool, evicting the connection that has been idle the longest if
+     * either it has exceeded the keep alive limit or the idle connections limit.
+     * <p>
+     * <p>Returns the duration in nanos to sleep until the next scheduled call to this method. Returns
+     * -1 if no further cleanups are required.
+     */
+    long cleanup(long now) {
+        int inUseConnectionCount = 0;
+        int idleConnectionCount = 0;
+        RealConnection longestIdleConnection = null;
+        long longestIdleDurationNs = Long.MIN_VALUE;
+
+        // Find either a connection to evict, or the time that the next eviction is due.
+        synchronized (this) {
+            for (Iterator<RealConnection> i = connections.iterator(); i.hasNext(); ) {
+                RealConnection connection = i.next();
+
+                // If the connection is in use, keep searching.
+                if (pruneAndGetAllocationCount(connection, now) > 0) {
+                    inUseConnectionCount++;
+                    continue;
+                }
+
+                idleConnectionCount++;
+
+                // If the connection is ready to be evicted, we're done.
+                long idleDurationNs = now - connection.idleAtNanos;
+                if (idleDurationNs > longestIdleDurationNs) {
+                    longestIdleDurationNs = idleDurationNs;
+                    longestIdleConnection = connection;
+                }
+            }
+
+            if (longestIdleDurationNs >= this.keepAliveDurationNs
+                    || idleConnectionCount > this.maxIdleConnections) {
+                // We've found a connection to evict. Remove it from the list, then close it below (outside
+                // of the synchronized block).
+                connections.remove(longestIdleConnection);
+            } else if (idleConnectionCount > 0) {
+                // A connection will be ready to evict soon.
+                return keepAliveDurationNs - longestIdleDurationNs;
+            } else if (inUseConnectionCount > 0) {
+                // All connections are in use. It'll be at least the keep alive duration 'til we run again.
+                return keepAliveDurationNs;
+            } else {
+                // No connections, idle or in use.
+                cleanupRunning = false;
+                return -1;
+            }
+        }
+
+        closeQuietly(longestIdleConnection.socket());
+
+        // Cleanup again immediately.
         return 0;
-      }
     }
 
-    return references.size();
-  }
+    /**
+     * Prunes any leaked allocations and then returns the number of remaining live allocations on
+     * {@code connection}. Allocations are leaked if the connection is tracking them but the
+     * application code has abandoned them. Leak detection is imprecise and relies on garbage
+     * collection.
+     */
+    private int pruneAndGetAllocationCount(RealConnection connection, long now) {
+        List<Reference<StreamAllocation>> references = connection.allocations;
+        for (int i = 0; i < references.size(); ) {
+            Reference<StreamAllocation> reference = references.get(i);
+
+            if (reference.get() != null) {
+                i++;
+                continue;
+            }
+
+            // We've discovered a leaked allocation. This is an application bug.
+            StreamAllocation.StreamAllocationReference streamAllocRef =
+                    (StreamAllocation.StreamAllocationReference) reference;
+            String message = "A connection to " + connection.route().address().url()
+                    + " was leaked. Did you forget to close a response body?";
+            Platform.get().logCloseableLeak(message, streamAllocRef.callStackTrace);
+
+            references.remove(i);
+            connection.noNewStreams = true;
+
+            // If this was the last allocation, the connection is eligible for immediate eviction.
+            if (references.isEmpty()) {
+                connection.idleAtNanos = now - keepAliveDurationNs;
+                return 0;
+            }
+        }
+
+        return references.size();
+    }
 }
diff --git a/okhttp/src/main/java/okhttp3/RealCall.java b/okhttp/src/main/java/okhttp3/RealCall.java
index eb54263bce..23a8250add 100644
--- a/okhttp/src/main/java/okhttp3/RealCall.java
+++ b/okhttp/src/main/java/okhttp3/RealCall.java
@@ -21,7 +21,9 @@
 import java.util.List;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.RejectedExecutionException;
+
 import javax.annotation.Nullable;
+
 import okhttp3.internal.NamedRunnable;
 import okhttp3.internal.cache.CacheInterceptor;
 import okhttp3.internal.connection.ConnectInterceptor;
@@ -39,223 +41,238 @@
 import static okhttp3.internal.platform.Platform.INFO;
 
 final class RealCall implements Call {
-  final OkHttpClient client;
-  final RetryAndFollowUpInterceptor retryAndFollowUpInterceptor;
-  final AsyncTimeout timeout;
-
-  /**
-   * There is a cycle between the {@link Call} and {@link EventListener} that makes this awkward.
-   * This will be set after we create the call instance then create the event listener instance.
-   */
-  private @Nullable EventListener eventListener;
-
-  /** The application's original request unadulterated by redirects or auth headers. */
-  final Request originalRequest;
-  final boolean forWebSocket;
-
-  // Guarded by this.
-  private boolean executed;
-
-  private RealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {
-    this.client = client;
-    this.originalRequest = originalRequest;
-    this.forWebSocket = forWebSocket;
-    this.retryAndFollowUpInterceptor = new RetryAndFollowUpInterceptor(client);
-    this.timeout = new AsyncTimeout() {
-      @Override protected void timedOut() {
-        cancel();
-      }
-    };
-    this.timeout.timeout(client.callTimeoutMillis(), MILLISECONDS);
-  }
-
-  static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {
-    // Safely publish the Call instance to the EventListener.
-    RealCall call = new RealCall(client, originalRequest, forWebSocket);
-    call.eventListener = client.eventListenerFactory().create(call);
-    return call;
-  }
-
-  @Override public Request request() {
-    return originalRequest;
-  }
-
-  @Override public Response execute() throws IOException {
-    if (originalRequest.body instanceof DuplexRequestBody) {
-      DuplexRequestBody duplexRequestBody = (DuplexRequestBody) originalRequest.body;
-      return duplexRequestBody.awaitExecute();
+    final OkHttpClient client;
+    final RetryAndFollowUpInterceptor retryAndFollowUpInterceptor;
+    final AsyncTimeout timeout;
+
+    /**
+     * There is a cycle between the {@link Call} and {@link EventListener} that makes this awkward.
+     * This will be set after we create the call instance then create the event listener instance.
+     */
+    private @Nullable
+    EventListener eventListener;
+
+    /**
+     * The application's original request unadulterated by redirects or auth headers.
+     */
+    final Request originalRequest;
+    final boolean forWebSocket;
+
+    // Guarded by this.
+    private boolean executed;
+
+    private RealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {
+        this.client = client;
+        this.originalRequest = originalRequest;
+        this.forWebSocket = forWebSocket;
+        this.retryAndFollowUpInterceptor = new RetryAndFollowUpInterceptor(client);
+        this.timeout = new AsyncTimeout() {
+            @Override
+            protected void timedOut() {
+                cancel();
+            }
+        };
+        this.timeout.timeout(client.callTimeoutMillis(), MILLISECONDS);
     }
-    synchronized (this) {
-      if (executed) throw new IllegalStateException("Already Executed");
-      executed = true;
+
+    static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {
+        // Safely publish the Call instance to the EventListener.
+        RealCall call = new RealCall(client, originalRequest, forWebSocket);
+        call.eventListener = client.eventListenerFactory().create(call);
+        return call;
+    }
+
+    @Override
+    public Request request() {
+        return originalRequest;
     }
-    captureCallStackTrace();
-    timeout.enter();
-    eventListener.callStart(this);
-    try {
-      client.dispatcher().executed(this);
-      Response result = getResponseWithInterceptorChain();
-      if (result == null) throw new IOException("Canceled");
-      return result;
-    } catch (IOException e) {
-      e = timeoutExit(e);
-      eventListener.callFailed(this, e);
-      throw e;
-    } finally {
-      client.dispatcher().finished(this);
+
+    @Override
+    public Response execute() throws IOException {
+        if (originalRequest.body instanceof DuplexRequestBody) {
+            DuplexRequestBody duplexRequestBody = (DuplexRequestBody) originalRequest.body;
+            return duplexRequestBody.awaitExecute();
+        }
+        synchronized (this) {
+            if (executed) throw new IllegalStateException("Already Executed");
+            executed = true;
+        }
+        captureCallStackTrace();
+        timeout.enter();
+        eventListener.callStart(this);
+        try {
+            client.dispatcher().executed(this);
+            Response result = getResponseWithInterceptorChain();
+            if (result == null) throw new IOException("Canceled");
+            return result;
+        } catch (IOException e) {
+            e = timeoutExit(e);
+            eventListener.callFailed(this, e);
+            throw e;
+        } finally {
+            client.dispatcher().finished(this);
+        }
     }
-  }
 
-  @Nullable IOException timeoutExit(@Nullable IOException cause) {
-    if (!timeout.exit()) return cause;
+    @Nullable
+    IOException timeoutExit(@Nullable IOException cause) {
+        if (!timeout.exit()) return cause;
 
-    InterruptedIOException e = new InterruptedIOException("timeout");
-    if (cause != null) {
-      e.initCause(cause);
+        InterruptedIOException e = new InterruptedIOException("timeout");
+        if (cause != null) {
+            e.initCause(cause);
+        }
+        return e;
     }
-    return e;
-  }
-
-  private void captureCallStackTrace() {
-    Object callStackTrace = Platform.get().getStackTraceForCloseable("response.body().close()");
-    retryAndFollowUpInterceptor.setCallStackTrace(callStackTrace);
-  }
-
-  @Override public void enqueue(Callback responseCallback) {
-    synchronized (this) {
-      if (executed) throw new IllegalStateException("Already Executed");
-      executed = true;
+
+    private void captureCallStackTrace() {
+        Object callStackTrace = Platform.get().getStackTraceForCloseable("response.body().close()");
+        retryAndFollowUpInterceptor.setCallStackTrace(callStackTrace);
     }
-    captureCallStackTrace();
-    eventListener.callStart(this);
-    client.dispatcher().enqueue(new AsyncCall(responseCallback));
-  }
-
-  @Override public void cancel() {
-    retryAndFollowUpInterceptor.cancel();
-  }
-
-  @Override public Timeout timeout() {
-    return timeout;
-  }
-
-  @Override public synchronized boolean isExecuted() {
-    return executed;
-  }
-
-  @Override public boolean isCanceled() {
-    return retryAndFollowUpInterceptor.isCanceled();
-  }
-
-  @SuppressWarnings("CloneDoesntCallSuperClone") // We are a final type & this saves clearing state.
-  @Override public RealCall clone() {
-    return RealCall.newRealCall(client, originalRequest, forWebSocket);
-  }
-
-  StreamAllocation streamAllocation() {
-    return retryAndFollowUpInterceptor.streamAllocation();
-  }
-
-  final class AsyncCall extends NamedRunnable {
-    private final Callback responseCallback;
-
-    AsyncCall(Callback responseCallback) {
-      super("OkHttp %s", redactedUrl());
-      this.responseCallback = responseCallback;
+
+    @Override
+    public void enqueue(Callback responseCallback) {
+        synchronized (this) {
+            if (executed) throw new IllegalStateException("Already Executed");
+            executed = true;
+        }
+        captureCallStackTrace();
+        eventListener.callStart(this);
+        client.dispatcher().enqueue(new AsyncCall(responseCallback));
     }
 
-    String host() {
-      return originalRequest.url().host();
+    @Override
+    public void cancel() {
+        retryAndFollowUpInterceptor.cancel();
     }
 
-    Request request() {
-      return originalRequest;
+    @Override
+    public Timeout timeout() {
+        return timeout;
     }
 
-    RealCall get() {
-      return RealCall.this;
+    @Override
+    public synchronized boolean isExecuted() {
+        return executed;
     }
 
-    /**
-     * Attempt to enqueue this async call on {@code executorService}. This will attempt to clean up
-     * if the executor has been shut down by reporting the call as failed.
-     */
-    void executeOn(ExecutorService executorService) {
-      assert (!Thread.holdsLock(client.dispatcher()));
-      boolean success = false;
-      try {
-        executorService.execute(this);
-        success = true;
-      } catch (RejectedExecutionException e) {
-        InterruptedIOException ioException = new InterruptedIOException("executor rejected");
-        ioException.initCause(e);
-        eventListener.callFailed(RealCall.this, ioException);
-        responseCallback.onFailure(RealCall.this, ioException);
-      } finally {
-        if (!success) {
-          client.dispatcher().finished(this); // This call is no longer running!
-        }
-      }
+    @Override
+    public boolean isCanceled() {
+        return retryAndFollowUpInterceptor.isCanceled();
     }
 
-    @Override protected void execute() {
-      boolean signalledCallback = false;
-      timeout.enter();
-      try {
-        Response response = getResponseWithInterceptorChain();
-        if (retryAndFollowUpInterceptor.isCanceled()) {
-          signalledCallback = true;
-          responseCallback.onFailure(RealCall.this, new IOException("Canceled"));
-        } else {
-          signalledCallback = true;
-          responseCallback.onResponse(RealCall.this, response);
+    @SuppressWarnings("CloneDoesntCallSuperClone")
+    // We are a final type & this saves clearing state.
+    @Override
+    public RealCall clone() {
+        return RealCall.newRealCall(client, originalRequest, forWebSocket);
+    }
+
+    StreamAllocation streamAllocation() {
+        return retryAndFollowUpInterceptor.streamAllocation();
+    }
+
+    final class AsyncCall extends NamedRunnable {
+        private final Callback responseCallback;
+
+        AsyncCall(Callback responseCallback) {
+            super("OkHttp %s", redactedUrl());
+            this.responseCallback = responseCallback;
+        }
+
+        String host() {
+            return originalRequest.url().host();
+        }
+
+        Request request() {
+            return originalRequest;
+        }
+
+        RealCall get() {
+            return RealCall.this;
         }
-      } catch (IOException e) {
-        e = timeoutExit(e);
-        if (signalledCallback) {
-          // Do not signal the callback twice!
-          Platform.get().log(INFO, "Callback failure for " + toLoggableString(), e);
-        } else {
-          eventListener.callFailed(RealCall.this, e);
-          responseCallback.onFailure(RealCall.this, e);
+
+        /**
+         * Attempt to enqueue this async call on {@code executorService}. This will attempt to clean up
+         * if the executor has been shut down by reporting the call as failed.
+         */
+        void executeOn(ExecutorService executorService) {
+            assert (!Thread.holdsLock(client.dispatcher()));
+            boolean success = false;
+            try {
+                executorService.execute(this);
+                success = true;
+            } catch (RejectedExecutionException e) {
+                InterruptedIOException ioException = new InterruptedIOException("executor rejected");
+                ioException.initCause(e);
+                eventListener.callFailed(RealCall.this, ioException);
+                responseCallback.onFailure(RealCall.this, ioException);
+            } finally {
+                if (!success) {
+                    client.dispatcher().finished(this); // This call is no longer running!
+                }
+            }
+        }
+
+        @Override
+        protected void execute() {
+            boolean signalledCallback = false;
+            timeout.enter();
+            try {
+                Response response = getResponseWithInterceptorChain();
+                if (retryAndFollowUpInterceptor.isCanceled()) {
+                    signalledCallback = true;
+                    responseCallback.onFailure(RealCall.this, new IOException("Canceled"));
+                } else {
+                    signalledCallback = true;
+                    responseCallback.onResponse(RealCall.this, response);
+                }
+            } catch (IOException e) {
+                e = timeoutExit(e);
+                if (signalledCallback) {
+                    // Do not signal the callback twice!
+                    Platform.get().log(INFO, "Callback failure for " + toLoggableString(), e);
+                } else {
+                    eventListener.callFailed(RealCall.this, e);
+                    responseCallback.onFailure(RealCall.this, e);
+                }
+            } finally {
+                client.dispatcher().finished(this);
+            }
         }
-      } finally {
-        client.dispatcher().finished(this);
-      }
     }
-  }
-
-  /**
-   * Returns a string that describes this call. Doesn't include a full URL as that might contain
-   * sensitive information.
-   */
-  String toLoggableString() {
-    return (isCanceled() ? "canceled " : "")
-        + (forWebSocket ? "web socket" : "call")
-        + " to " + redactedUrl();
-  }
-
-  String redactedUrl() {
-    return originalRequest.url().redact();
-  }
-
-  Response getResponseWithInterceptorChain() throws IOException {
-    // Build a full stack of interceptors.
-    List<Interceptor> interceptors = new ArrayList<>();
-    interceptors.addAll(client.interceptors());
-    interceptors.add(retryAndFollowUpInterceptor);
-    interceptors.add(new BridgeInterceptor(client.cookieJar()));
-    interceptors.add(new CacheInterceptor(client.internalCache()));
-    interceptors.add(new ConnectInterceptor(client));
-    if (!forWebSocket) {
-      interceptors.addAll(client.networkInterceptors());
+
+    /**
+     * Returns a string that describes this call. Doesn't include a full URL as that might contain
+     * sensitive information.
+     */
+    String toLoggableString() {
+        return (isCanceled() ? "canceled " : "")
+                + (forWebSocket ? "web socket" : "call")
+                + " to " + redactedUrl();
     }
-    interceptors.add(new CallServerInterceptor(forWebSocket));
 
-    Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0,
-        originalRequest, this, eventListener, client.connectTimeoutMillis(),
-        client.readTimeoutMillis(), client.writeTimeoutMillis());
+    String redactedUrl() {
+        return originalRequest.url().redact();
+    }
+
+    Response getResponseWithInterceptorChain() throws IOException {
+        // Build a full stack of interceptors.
+        List<Interceptor> interceptors = new ArrayList<>();
+        interceptors.addAll(client.interceptors());
+        interceptors.add(retryAndFollowUpInterceptor);
+        interceptors.add(new BridgeInterceptor(client.cookieJar()));
+        interceptors.add(new CacheInterceptor(client.internalCache()));
+        interceptors.add(new ConnectInterceptor(client));
+        if (!forWebSocket) {
+            interceptors.addAll(client.networkInterceptors());
+        }
+        interceptors.add(new CallServerInterceptor(forWebSocket));
 
-    return chain.proceed(originalRequest);
-  }
+        Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0,
+                originalRequest, this, eventListener, client.connectTimeoutMillis(),
+                client.readTimeoutMillis(), client.writeTimeoutMillis());
+
+        return chain.proceed(originalRequest);
+    }
 }
