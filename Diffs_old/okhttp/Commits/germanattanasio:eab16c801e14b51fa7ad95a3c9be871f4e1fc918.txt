diff --git a/benchmarks/pom.xml b/benchmarks/pom.xml
index 500c20d451..4236ffbec5 100644
--- a/benchmarks/pom.xml
+++ b/benchmarks/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.3.1</version>
+    <version>3.3.1.java16</version>
   </parent>
 
   <artifactId>benchmarks</artifactId>
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/Benchmark.java b/benchmarks/src/main/java/okhttp3/benchmarks/Benchmark.java
index 8d4d04386a..df6e7eee37 100644
--- a/benchmarks/src/main/java/okhttp3/benchmarks/Benchmark.java
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/Benchmark.java
@@ -84,7 +84,7 @@
   List<Protocol> protocols = Arrays.asList(Protocol.HTTP_1_1);
 
   public static void main(String[] args) {
-    List<String> allArgs = new ArrayList<>();
+    List<String> allArgs = new ArrayList<String>();
     allArgs.add("--instrument");
     allArgs.add("arbitrary");
     allArgs.addAll(Arrays.asList(args));
@@ -138,7 +138,7 @@ public double run() throws Exception {
   }
 
   @Override public String toString() {
-    List<Object> modifiers = new ArrayList<>();
+    List<Object> modifiers = new ArrayList<Object>();
     if (tls) modifiers.add("tls");
     if (gzip) modifiers.add("gzip");
     if (chunked) modifiers.add("chunked");
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/NettyHttpClient.java b/benchmarks/src/main/java/okhttp3/benchmarks/NettyHttpClient.java
index 01e6f6e257..01cbcd4405 100644
--- a/benchmarks/src/main/java/okhttp3/benchmarks/NettyHttpClient.java
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/NettyHttpClient.java
@@ -51,8 +51,8 @@
   private static final boolean VERBOSE = false;
 
   // Guarded by this. Real apps need more capable connection management.
-  private final Deque<HttpChannel> freeChannels = new ArrayDeque<>();
-  private final Deque<HttpUrl> backlog = new ArrayDeque<>();
+  private final Deque<HttpChannel> freeChannels = new ArrayDeque<HttpChannel>();
+  private final Deque<HttpUrl> backlog = new ArrayDeque<HttpUrl>();
 
   private int totalChannels = 0;
   private int concurrencyLevel;
diff --git a/mockwebserver/pom.xml b/mockwebserver/pom.xml
index 354f15a4bb..550b379b7d 100644
--- a/mockwebserver/pom.xml
+++ b/mockwebserver/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.3.1</version>
+    <version>3.3.1.java16</version>
   </parent>
 
   <artifactId>mockwebserver</artifactId>
diff --git a/mockwebserver/src/main/java/okhttp3/internal/tls/SslClient.java b/mockwebserver/src/main/java/okhttp3/internal/tls/SslClient.java
index 7cc061b668..f38a502dda 100644
--- a/mockwebserver/src/main/java/okhttp3/internal/tls/SslClient.java
+++ b/mockwebserver/src/main/java/okhttp3/internal/tls/SslClient.java
@@ -1,24 +1,21 @@
 /*
  * Copyright (C) 2012 Square, Inc.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+ * in compliance with the License. You may obtain a copy of the License at
  *
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
  */
 package okhttp3.internal.tls;
 
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.InetAddress;
-import java.net.UnknownHostException;
 import java.security.GeneralSecurityException;
 import java.security.KeyPair;
 import java.security.KeyStore;
@@ -28,6 +25,7 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
+
 import javax.net.ssl.KeyManagerFactory;
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLSocketFactory;
@@ -54,29 +52,27 @@ private SslClient(SSLContext sslContext, X509TrustManager trustManager) {
 
   /** Returns an SSL client for this host's localhost address. */
   public static synchronized SslClient localhost() {
-    if (localhost != null) return localhost;
+    if (localhost != null)
+      return localhost;
 
     try {
       // Generate a self-signed cert for the server to serve and the client to trust.
-      HeldCertificate heldCertificate = new HeldCertificate.Builder()
-          .serialNumber("1")
-          .commonName(InetAddress.getByName("localhost").getHostName())
-          .build();
+      HeldCertificate heldCertificate = new HeldCertificate.Builder().serialNumber("1")
+          .commonName(InetAddress.getByName("localhost").getHostName()).build();
 
-      localhost = new Builder()
-          .certificateChain(heldCertificate.keyPair, heldCertificate.certificate)
-          .addTrustedCertificate(heldCertificate.certificate)
-          .build();
+      localhost =
+          new Builder().certificateChain(heldCertificate.keyPair, heldCertificate.certificate)
+              .addTrustedCertificate(heldCertificate.certificate).build();
 
       return localhost;
-    } catch (GeneralSecurityException | UnknownHostException e) {
+    } catch (Exception e) {
       throw new RuntimeException(e);
     }
   }
 
   public static class Builder {
-    private final List<X509Certificate> chainCertificates = new ArrayList<>();
-    private final List<X509Certificate> certificates = new ArrayList<>();
+    private final List<X509Certificate> chainCertificates = new ArrayList<X509Certificate>();
+    private final List<X509Certificate> certificates = new ArrayList<X509Certificate>();
     private KeyPair keyPair;
 
     /**
@@ -117,8 +113,8 @@ public SslClient build() {
         KeyStore keyStore = newEmptyKeyStore(password);
 
         if (keyPair != null) {
-          Certificate[] certificates = chainCertificates.toArray(
-              new Certificate[chainCertificates.size()]);
+          Certificate[] certificates =
+              chainCertificates.toArray(new Certificate[chainCertificates.size()]);
           keyStore.setKeyEntry("private", keyPair.getPrivate(), password, certificates);
         }
 
@@ -127,17 +123,17 @@ public SslClient build() {
         }
 
         // Wrap it up in an SSL context.
-        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(
-            KeyManagerFactory.getDefaultAlgorithm());
+        KeyManagerFactory keyManagerFactory =
+            KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
         keyManagerFactory.init(keyStore, password);
-        TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
-            TrustManagerFactory.getDefaultAlgorithm());
+        TrustManagerFactory trustManagerFactory =
+            TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
         trustManagerFactory.init(keyStore);
         TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
 
         if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {
-          throw new IllegalStateException("Unexpected default trust managers:"
-              + Arrays.toString(trustManagers));
+          throw new IllegalStateException(
+              "Unexpected default trust managers:" + Arrays.toString(trustManagers));
         }
 
         SSLContext sslContext = SSLContext.getInstance("TLS");
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.java
index 1826aa4fff..aec79c06db 100644
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.java
@@ -43,7 +43,7 @@
   private long bodyDelayAmount = 0;
   private TimeUnit bodyDelayUnit = TimeUnit.MILLISECONDS;
 
-  private List<PushPromise> promises = new ArrayList<>();
+  private List<PushPromise> promises = new ArrayList<PushPromise>();
   private Settings settings;
   private WebSocketListener webSocketListener;
 
@@ -57,7 +57,7 @@ public MockResponse() {
     try {
       MockResponse result = (MockResponse) super.clone();
       result.headers = headers.build().newBuilder();
-      result.promises = new ArrayList<>(promises);
+      result.promises = new ArrayList<PushPromise>(promises);
       return result;
     } catch (CloneNotSupportedException e) {
       throw new AssertionError();
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
index 89df442534..ff9e60e9e6 100644
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
@@ -1,18 +1,15 @@
 /*
- * Copyright (C) 2011 Google Inc.
- * Copyright (C) 2013 Square, Inc.
+ * Copyright (C) 2011 Google Inc. Copyright (C) 2013 Square, Inc.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+ * in compliance with the License. You may obtain a copy of the License at
  *
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
  */
 
 package okhttp3.mockwebserver;
@@ -100,23 +97,27 @@
  */
 public final class MockWebServer implements TestRule {
   private static final X509TrustManager UNTRUSTED_TRUST_MANAGER = new X509TrustManager() {
-    @Override public void checkClientTrusted(X509Certificate[] chain, String authType)
+    @Override
+    public void checkClientTrusted(X509Certificate[] chain, String authType)
         throws CertificateException {
       throw new CertificateException();
     }
 
-    @Override public void checkServerTrusted(X509Certificate[] chain, String authType) {
+    @Override
+    public void checkServerTrusted(X509Certificate[] chain, String authType) {
       throw new AssertionError();
     }
 
-    @Override public X509Certificate[] getAcceptedIssuers() {
+    @Override
+    public X509Certificate[] getAcceptedIssuers() {
       throw new AssertionError();
     }
   };
 
   private static final Logger logger = Logger.getLogger(MockWebServer.class.getName());
 
-  private final BlockingQueue<RecordedRequest> requestQueue = new LinkedBlockingQueue<>();
+  private final BlockingQueue<RecordedRequest> requestQueue =
+      new LinkedBlockingQueue<RecordedRequest>();
 
   private final Set<Socket> openClientSockets =
       Collections.newSetFromMap(new ConcurrentHashMap<Socket, Boolean>());
@@ -134,13 +135,14 @@
   private int port = -1;
   private InetSocketAddress inetSocketAddress;
   private boolean protocolNegotiationEnabled = true;
-  private List<Protocol> protocols
-      = Util.immutableList(Protocol.HTTP_2, Protocol.SPDY_3, Protocol.HTTP_1_1);
+  private List<Protocol> protocols =
+      Util.immutableList(Protocol.HTTP_2, Protocol.SPDY_3, Protocol.HTTP_1_1);
 
   private boolean started;
 
   private synchronized void maybeStart() {
-    if (started) return;
+    if (started)
+      return;
     try {
       start();
     } catch (IOException e) {
@@ -148,9 +150,11 @@ private synchronized void maybeStart() {
     }
   }
 
-  @Override public Statement apply(final Statement base, Description description) {
+  @Override
+  public Statement apply(final Statement base, Description description) {
     return new Statement() {
-      @Override public void evaluate() throws Throwable {
+      @Override
+      public void evaluate() throws Throwable {
         maybeStart();
         try {
           base.evaluate();
@@ -183,8 +187,7 @@ public Proxy toProxyAddress() {
 
   public void setServerSocketFactory(ServerSocketFactory serverSocketFactory) {
     if (executor != null) {
-      throw new IllegalStateException(
-          "setServerSocketFactory() must be called before start()");
+      throw new IllegalStateException("setServerSocketFactory() must be called before start()");
     }
     this.serverSocketFactory = serverSocketFactory;
   }
@@ -195,12 +198,8 @@ public void setServerSocketFactory(ServerSocketFactory serverSocketFactory) {
    * @param path the request path, such as "/".
    */
   public HttpUrl url(String path) {
-    return new HttpUrl.Builder()
-        .scheme(sslSocketFactory != null ? "https" : "http")
-        .host(getHostName())
-        .port(getPort())
-        .build()
-        .resolve(path);
+    return new HttpUrl.Builder().scheme(sslSocketFactory != null ? "https" : "http")
+        .host(getHostName()).port(getPort()).build().resolve(path);
   }
 
   /**
@@ -223,7 +222,7 @@ public void setProtocolNegotiationEnabled(boolean protocolNegotiationEnabled) {
    * when {@link #setProtocolNegotiationEnabled negotiation is disabled}.
    *
    * @param protocols the protocols to use, in order of preference. The list must contain
-   * {@linkplain Protocol#HTTP_1_1}. It must not contain null.
+   *        {@linkplain Protocol#HTTP_1_1}. It must not contain null.
    */
   public void setProtocols(List<Protocol> protocols) {
     protocols = Util.immutableList(protocols);
@@ -283,8 +282,8 @@ public int getRequestCount() {
    * served by the first enqueued response; the second request by the second enqueued response; and
    * so on.
    *
-   * @throws ClassCastException if the default dispatcher has been replaced with {@link
-   * #setDispatcher(Dispatcher)}.
+   * @throws ClassCastException if the default dispatcher has been replaced with
+   *         {@link #setDispatcher(Dispatcher)}.
    */
   public void enqueue(MockResponse response) {
     ((QueueDispatcher) dispatcher).enqueueResponse(response.clone());
@@ -299,7 +298,7 @@ public void start() throws IOException {
    * Starts the server on the loopback interface for the given port.
    *
    * @param port the port to listen to, or 0 for any available port. Automated tests should always
-   * use port 0 to avoid flakiness when a specific port is unavailable.
+   *        use port 0 to avoid flakiness when a specific port is unavailable.
    */
   public void start(int port) throws IOException {
     start(InetAddress.getByName("localhost"), port);
@@ -310,7 +309,7 @@ public void start(int port) throws IOException {
    *
    * @param inetAddress the address to create the server socket on
    * @param port the port to listen to, or 0 for any available port. Automated tests should always
-   * use port 0 to avoid flakiness when a specific port is unavailable.
+   *        use port 0 to avoid flakiness when a specific port is unavailable.
    */
   public void start(InetAddress inetAddress, int port) throws IOException {
     start(new InetSocketAddress(inetAddress, port));
@@ -322,7 +321,8 @@ public void start(InetAddress inetAddress, int port) throws IOException {
    * @param inetSocketAddress the socket address to bind the server on
    */
   private synchronized void start(InetSocketAddress inetSocketAddress) throws IOException {
-    if (started) throw new IllegalStateException("start() already called");
+    if (started)
+      throw new IllegalStateException("start() already called");
     started = true;
 
     executor = Executors.newCachedThreadPool(Util.threadFactory("MockWebServer", false));
@@ -334,7 +334,8 @@ private synchronized void start(InetSocketAddress inetSocketAddress) throws IOEx
 
     port = serverSocket.getLocalPort();
     executor.execute(new NamedRunnable("MockWebServer %s", port) {
-      @Override protected void execute() {
+      @Override
+      protected void execute() {
         try {
           logger.info(MockWebServer.this + " starting to accept connections");
           acceptConnections();
@@ -344,11 +345,11 @@ private synchronized void start(InetSocketAddress inetSocketAddress) throws IOEx
 
         // Release all sockets and all threads, even if any close fails.
         Util.closeQuietly(serverSocket);
-        for (Iterator<Socket> s = openClientSockets.iterator(); s.hasNext(); ) {
+        for (Iterator<Socket> s = openClientSockets.iterator(); s.hasNext();) {
           Util.closeQuietly(s.next());
           s.remove();
         }
-        for (Iterator<FramedConnection> s = openFramedConnections.iterator(); s.hasNext(); ) {
+        for (Iterator<FramedConnection> s = openFramedConnections.iterator(); s.hasNext();) {
           Util.closeQuietly(s.next());
           s.remove();
         }
@@ -379,8 +380,10 @@ private void acceptConnections() throws Exception {
   }
 
   public synchronized void shutdown() throws IOException {
-    if (!started) return;
-    if (serverSocket == null) throw new IllegalStateException("shutdown() before start()");
+    if (!started)
+      return;
+    if (serverSocket == null)
+      throw new IllegalStateException("shutdown() before start()");
 
     // Cause acceptConnections() to break out.
     serverSocket.close();
@@ -399,7 +402,8 @@ private void serveConnection(final Socket raw) {
     executor.execute(new NamedRunnable("MockWebServer %s", raw.getRemoteSocketAddress()) {
       int sequenceNumber = 0;
 
-      @Override protected void execute() {
+      @Override
+      protected void execute() {
         try {
           processConnection();
         } catch (IOException e) {
@@ -447,11 +451,8 @@ public void processConnection() throws Exception {
 
         if (protocol != Protocol.HTTP_1_1) {
           FramedSocketHandler framedSocketListener = new FramedSocketHandler(socket, protocol);
-          FramedConnection framedConnection = new FramedConnection.Builder(false)
-              .socket(socket)
-              .protocol(protocol)
-              .listener(framedSocketListener)
-              .build();
+          FramedConnection framedConnection = new FramedConnection.Builder(false).socket(socket)
+              .protocol(protocol).listener(framedSocketListener).build();
           framedConnection.start();
           openFramedConnections.add(framedConnection);
           openClientSockets.remove(socket);
@@ -465,9 +466,7 @@ public void processConnection() throws Exception {
         }
 
         if (sequenceNumber == 0) {
-          logger.warning(MockWebServer.this
-              + " connection from "
-              + raw.getInetAddress()
+          logger.warning(MockWebServer.this + " connection from " + raw.getInetAddress()
               + " didn't make a request");
         }
 
@@ -478,8 +477,7 @@ public void processConnection() throws Exception {
       }
 
       /**
-       * Respond to CONNECT requests until a SWITCH_TO_SSL_AT_END response is
-       * dispatched.
+       * Respond to CONNECT requests until a SWITCH_TO_SSL_AT_END response is dispatched.
        */
       private void createTunnel() throws IOException, InterruptedException {
         BufferedSource source = Okio.buffer(Okio.source(raw));
@@ -489,7 +487,8 @@ private void createTunnel() throws IOException, InterruptedException {
           if (!processOneRequest(raw, source, sink)) {
             throw new IllegalStateException("Tunnel without any CONNECT!");
           }
-          if (socketPolicy == UPGRADE_TO_SSL_AT_END) return;
+          if (socketPolicy == UPGRADE_TO_SSL_AT_END)
+            return;
         }
       }
 
@@ -500,7 +499,8 @@ private void createTunnel() throws IOException, InterruptedException {
       private boolean processOneRequest(Socket socket, BufferedSource source, BufferedSink sink)
           throws IOException, InterruptedException {
         RecordedRequest request = readRequest(socket, source, sink, sequenceNumber);
-        if (request == null) return false;
+        if (request == null)
+          return false;
 
         requestCount.incrementAndGet();
         requestQueue.add(request);
@@ -512,7 +512,8 @@ private boolean processOneRequest(Socket socket, BufferedSource source, Buffered
         }
         if (response.getSocketPolicy() == NO_RESPONSE) {
           // This read should block until the socket is closed. (Because nobody is writing.)
-          if (source.exhausted()) return false;
+          if (source.exhausted())
+            return false;
           throw new ProtocolException("unexpected data");
         }
 
@@ -528,8 +529,8 @@ private boolean processOneRequest(Socket socket, BufferedSource source, Buffered
         }
 
         if (logger.isLoggable(Level.INFO)) {
-          logger.info(MockWebServer.this + " received request: " + request
-              + " and responded: " + response);
+          logger.info(
+              MockWebServer.this + " received request: " + request + " and responded: " + response);
         }
 
         // See warnings associated with these socket policies in SocketPolicy.
@@ -552,8 +553,8 @@ private void processHandshakeFailure(Socket raw) throws Exception {
     SSLContext context = SSLContext.getInstance("TLS");
     context.init(null, new TrustManager[] {UNTRUSTED_TRUST_MANAGER}, new SecureRandom());
     SSLSocketFactory sslSocketFactory = context.getSocketFactory();
-    SSLSocket socket = (SSLSocket) sslSocketFactory.createSocket(
-        raw, raw.getInetAddress().getHostAddress(), raw.getPort(), true);
+    SSLSocket socket = (SSLSocket) sslSocketFactory.createSocket(raw,
+        raw.getInetAddress().getHostAddress(), raw.getPort(), true);
     try {
       socket.startHandshake(); // we're testing a handshake failure
       throw new AssertionError();
@@ -564,14 +565,16 @@ private void processHandshakeFailure(Socket raw) throws Exception {
 
   private void dispatchBookkeepingRequest(int sequenceNumber, Socket socket)
       throws InterruptedException {
-    RecordedRequest request = new RecordedRequest(
-        null, null, null, -1, null, sequenceNumber, socket);
+    RecordedRequest request =
+        new RecordedRequest(null, null, null, -1, null, sequenceNumber, socket);
     requestCount.incrementAndGet();
     requestQueue.add(request);
     dispatcher.dispatch(request);
   }
 
-  /** @param sequenceNumber the index of this request on this connection. */
+  /**
+   * @param sequenceNumber the index of this request on this connection.
+   */
   private RecordedRequest readRequest(Socket socket, BufferedSource source, BufferedSink sink,
       int sequenceNumber) throws IOException {
     String request;
@@ -614,7 +617,7 @@ private RecordedRequest readRequest(Socket socket, BufferedSource source, Buffer
 
     boolean hasBody = false;
     TruncatingBuffer requestBody = new TruncatingBuffer(bodyLimit);
-    List<Integer> chunkSizes = new ArrayList<>();
+    List<Integer> chunkSizes = new ArrayList<Integer>();
     MockResponse policy = dispatcher.peek();
     if (contentLength != -1) {
       hasBody = contentLength > 0;
@@ -655,31 +658,25 @@ private void handleWebSocketUpgrade(Socket socket, BufferedSource source, Buffer
 
     ThreadPoolExecutor replyExecutor =
         new ThreadPoolExecutor(1, 1, 1, SECONDS, new LinkedBlockingDeque<Runnable>(),
-            Util.threadFactory(Util.format("MockWebServer %s WebSocket", request.getPath()),
-                true));
+            Util.threadFactory(Util.format("MockWebServer %s WebSocket", request.getPath()), true));
     replyExecutor.allowCoreThreadTimeOut(true);
-    final RealWebSocket webSocket =
-        new RealWebSocket(false /* is server */, source, sink, new SecureRandom(), replyExecutor,
-            listener, request.getPath()) {
-          @Override protected void close() throws IOException {
-            connectionClose.countDown();
-          }
-        };
+    final RealWebSocket webSocket = new RealWebSocket(false /* is server */, source, sink,
+        new SecureRandom(), replyExecutor, listener, request.getPath()) {
+      @Override
+      protected void close() throws IOException {
+        connectionClose.countDown();
+      }
+    };
 
     // Adapt the request and response into our Request and Response domain model.
     String scheme = request.getTlsVersion() != null ? "https" : "http";
     String authority = request.getHeader("Host"); // Has host and port.
-    final Request fancyRequest = new Request.Builder()
-        .url(scheme + "://" + authority + "/")
-        .headers(request.getHeaders())
-        .build();
-    final Response fancyResponse = new Response.Builder()
-        .code(Integer.parseInt(response.getStatus().split(" ")[1]))
-        .message(response.getStatus().split(" ", 3)[2])
-        .headers(response.getHeaders())
-        .request(fancyRequest)
-        .protocol(Protocol.HTTP_1_1)
-        .build();
+    final Request fancyRequest = new Request.Builder().url(scheme + "://" + authority + "/")
+        .headers(request.getHeaders()).build();
+    final Response fancyResponse =
+        new Response.Builder().code(Integer.parseInt(response.getStatus().split(" ")[1]))
+            .message(response.getStatus().split(" ", 3)[2]).headers(response.getHeaders())
+            .request(fancyRequest).protocol(Protocol.HTTP_1_1).build();
 
     listener.onOpen(webSocket, fancyResponse);
 
@@ -714,7 +711,8 @@ private void writeHttpResponse(Socket socket, BufferedSink sink, MockResponse re
     sink.flush();
 
     Buffer body = response.getBody();
-    if (body == null) return;
+    if (body == null)
+      return;
     sleepIfDelayed(response);
     throttledTransfer(response, socket, body, sink, body.size(), false);
   }
@@ -737,19 +735,20 @@ private void sleepIfDelayed(MockResponse response) {
    */
   private void throttledTransfer(MockResponse policy, Socket socket, BufferedSource source,
       BufferedSink sink, long byteCount, boolean isRequest) throws IOException {
-    if (byteCount == 0) return;
+    if (byteCount == 0)
+      return;
 
     Buffer buffer = new Buffer();
     long bytesPerPeriod = policy.getThrottleBytesPerPeriod();
     long periodDelayMs = policy.getThrottlePeriod(TimeUnit.MILLISECONDS);
 
     long halfByteCount = byteCount / 2;
-    boolean disconnectHalfway = isRequest
-        ? policy.getSocketPolicy() == DISCONNECT_DURING_REQUEST_BODY
-        : policy.getSocketPolicy() == DISCONNECT_DURING_RESPONSE_BODY;
+    boolean disconnectHalfway =
+        isRequest ? policy.getSocketPolicy() == DISCONNECT_DURING_REQUEST_BODY
+            : policy.getSocketPolicy() == DISCONNECT_DURING_RESPONSE_BODY;
 
     while (!socket.isClosed()) {
-      for (int b = 0; b < bytesPerPeriod; ) {
+      for (int b = 0; b < bytesPerPeriod;) {
         // Ensure we do not read past the allotted bytes in this period.
         long toRead = Math.min(byteCount, bytesPerPeriod - b);
         // Ensure we do not read past halfway if the policy will kill the connection.
@@ -758,7 +757,8 @@ private void throttledTransfer(MockResponse policy, Socket socket, BufferedSourc
         }
 
         long read = source.read(buffer, toRead);
-        if (read == -1) return;
+        if (read == -1)
+          return;
 
         sink.write(buffer, read);
         sink.flush();
@@ -770,7 +770,8 @@ private void throttledTransfer(MockResponse policy, Socket socket, BufferedSourc
           return;
         }
 
-        if (byteCount == 0) return;
+        if (byteCount == 0)
+          return;
       }
 
       if (periodDelayMs != 0) {
@@ -785,7 +786,8 @@ private void throttledTransfer(MockResponse policy, Socket socket, BufferedSourc
 
   private void readEmptyLine(BufferedSource source) throws IOException {
     String line = source.readUtf8LineStrict();
-    if (line.length() != 0) throw new IllegalStateException("Expected empty but was: " + line);
+    if (line.length() != 0)
+      throw new IllegalStateException("Expected empty but was: " + line);
   }
 
   /**
@@ -794,11 +796,13 @@ private void readEmptyLine(BufferedSource source) throws IOException {
    * dispatchers can vary the response based on timing or the content of the request.
    */
   public void setDispatcher(Dispatcher dispatcher) {
-    if (dispatcher == null) throw new NullPointerException();
+    if (dispatcher == null)
+      throw new NullPointerException();
     this.dispatcher = dispatcher;
   }
 
-  @Override public String toString() {
+  @Override
+  public String toString() {
     return "MockWebServer[" + port + "]";
   }
 
@@ -812,7 +816,8 @@ public void setDispatcher(Dispatcher dispatcher) {
       remainingByteCount = bodyLimit;
     }
 
-    @Override public void write(Buffer source, long byteCount) throws IOException {
+    @Override
+    public void write(Buffer source, long byteCount) throws IOException {
       long toRead = Math.min(remainingByteCount, byteCount);
       if (toRead > 0) {
         source.read(buffer, toRead);
@@ -825,15 +830,16 @@ public void setDispatcher(Dispatcher dispatcher) {
       receivedByteCount += byteCount;
     }
 
-    @Override public void flush() throws IOException {
-    }
+    @Override
+    public void flush() throws IOException { }
 
-    @Override public Timeout timeout() {
+    @Override
+    public Timeout timeout() {
       return Timeout.NONE;
     }
 
-    @Override public void close() throws IOException {
-    }
+    @Override
+    public void close() throws IOException { }
   }
 
   /** Processes HTTP requests layered over framed protocols. */
@@ -847,7 +853,8 @@ private FramedSocketHandler(Socket socket, Protocol protocol) {
       this.protocol = protocol;
     }
 
-    @Override public void onStream(FramedStream stream) throws IOException {
+    @Override
+    public void onStream(FramedStream stream) throws IOException {
       MockResponse peekedResponse = dispatcher.peek();
       if (peekedResponse.getSocketPolicy() == RESET_STREAM_AT_START) {
         try {
@@ -870,8 +877,8 @@ private FramedSocketHandler(Socket socket, Protocol protocol) {
       }
       writeResponse(stream, response);
       if (logger.isLoggable(Level.INFO)) {
-        logger.info(MockWebServer.this + " received request: " + request
-            + " and responded: " + response + " protocol is " + protocol.toString());
+        logger.info(MockWebServer.this + " received request: " + request + " and responded: "
+            + response + " protocol is " + protocol.toString());
       }
     }
 
@@ -920,7 +927,7 @@ private void writeResponse(FramedStream stream, MockResponse response) throws IO
       if (response.getSocketPolicy() == NO_RESPONSE) {
         return;
       }
-      List<Header> spdyHeaders = new ArrayList<>();
+      List<Header> spdyHeaders = new ArrayList<Header>();
       String[] statusParts = response.getStatus().split(" ", 2);
       if (statusParts.length != 2) {
         throw new AssertionError("Unexpected status: " + response.getStatus());
@@ -951,10 +958,9 @@ private void writeResponse(FramedStream stream, MockResponse response) throws IO
 
     private void pushPromises(FramedStream stream, List<PushPromise> promises) throws IOException {
       for (PushPromise pushPromise : promises) {
-        List<Header> pushedHeaders = new ArrayList<>();
+        List<Header> pushedHeaders = new ArrayList<Header>();
         pushedHeaders.add(new Header(stream.getConnection().getProtocol() == Protocol.SPDY_3
-            ? Header.TARGET_HOST
-            : Header.TARGET_AUTHORITY, url(pushPromise.path()).host()));
+            ? Header.TARGET_HOST : Header.TARGET_AUTHORITY, url(pushPromise.path()).host()));
         pushedHeaders.add(new Header(Header.TARGET_METHOD, pushPromise.method()));
         pushedHeaders.add(new Header(Header.TARGET_PATH, pushPromise.path()));
         Headers pushPromiseHeaders = pushPromise.headers();
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/QueueDispatcher.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/QueueDispatcher.java
index 4071d4718b..71286ee386 100644
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/QueueDispatcher.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/QueueDispatcher.java
@@ -1,17 +1,15 @@
 /*
  * Copyright (C) 2012 Google Inc.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+ * in compliance with the License. You may obtain a copy of the License at
  *
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
  */
 package okhttp3.mockwebserver;
 
@@ -21,22 +19,24 @@
 import java.util.logging.Logger;
 
 /**
- * Default dispatcher that processes a script of responses. Populate the script by calling {@link
- * #enqueueResponse(MockResponse)}.
+ * Default dispatcher that processes a script of responses. Populate the script by calling
+ * {@link #enqueueResponse(MockResponse)}.
  */
 public class QueueDispatcher extends Dispatcher {
   /**
    * Enqueued on shutdown to release threads waiting on {@link #dispatch}. Note that this response
    * isn't transmitted because the connection is closed before this response is returned.
    */
-  private static final MockResponse DEAD_LETTER = new MockResponse()
-      .setStatus("HTTP/1.1 " + 503 + " shutting down");
+  private static final MockResponse DEAD_LETTER =
+      new MockResponse().setStatus("HTTP/1.1 " + 503 + " shutting down");
 
   private static final Logger logger = Logger.getLogger(QueueDispatcher.class.getName());
-  protected final BlockingQueue<MockResponse> responseQueue = new LinkedBlockingQueue<>();
+  protected final BlockingQueue<MockResponse> responseQueue =
+      new LinkedBlockingQueue<MockResponse>();
   private MockResponse failFastResponse;
 
-  @Override public MockResponse dispatch(RecordedRequest request) throws InterruptedException {
+  @Override
+  public MockResponse dispatch(RecordedRequest request) throws InterruptedException {
     // To permit interactive/browser testing, ignore requests for favicons.
     final String requestLine = request.getRequestLine();
     if (requestLine != null && requestLine.equals("GET /favicon.ico HTTP/1.1")) {
@@ -53,15 +53,19 @@
 
     // If take() returned because we're shutting down, then enqueue another dead letter so that any
     // other threads waiting on take() will also return.
-    if (result == DEAD_LETTER) responseQueue.add(DEAD_LETTER);
+    if (result == DEAD_LETTER)
+      responseQueue.add(DEAD_LETTER);
 
     return result;
   }
 
-  @Override public MockResponse peek() {
+  @Override
+  public MockResponse peek() {
     MockResponse peek = responseQueue.peek();
-    if (peek != null) return peek;
-    if (failFastResponse != null) return failFastResponse;
+    if (peek != null)
+      return peek;
+    if (failFastResponse != null)
+      return failFastResponse;
     return super.peek();
   }
 
@@ -69,14 +73,14 @@ public void enqueueResponse(MockResponse response) {
     responseQueue.add(response);
   }
 
-  @Override public void shutdown() {
+  @Override
+  public void shutdown() {
     responseQueue.add(DEAD_LETTER);
   }
 
   public void setFailFast(boolean failFast) {
-    MockResponse failFastResponse = failFast
-        ? new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_FOUND)
-        : null;
+    MockResponse failFastResponse =
+        failFast ? new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_FOUND) : null;
     setFailFast(failFastResponse);
   }
 
diff --git a/mockwebserver/src/test/java/okhttp3/mockwebserver/CustomDispatcherTest.java b/mockwebserver/src/test/java/okhttp3/mockwebserver/CustomDispatcherTest.java
index 5f189dc608..7949d5ebc3 100644
--- a/mockwebserver/src/test/java/okhttp3/mockwebserver/CustomDispatcherTest.java
+++ b/mockwebserver/src/test/java/okhttp3/mockwebserver/CustomDispatcherTest.java
@@ -36,7 +36,7 @@
 
   @Test public void simpleDispatch() throws Exception {
     mockWebServer.start();
-    final List<RecordedRequest> requestsMade = new ArrayList<>();
+    final List<RecordedRequest> requestsMade = new ArrayList<RecordedRequest>();
     final Dispatcher dispatcher = new Dispatcher() {
       @Override
       public MockResponse dispatch(RecordedRequest request) throws InterruptedException {
diff --git a/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java b/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java
index fe96642940..5715d48eb4 100644
--- a/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java
+++ b/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java
@@ -324,7 +324,7 @@
   private List<String> headersToList(MockResponse response) {
     Headers headers = response.getHeaders();
     int size = headers.size();
-    List<String> headerList = new ArrayList<>(size);
+    List<String> headerList = new ArrayList<String>(size);
     for (int i = 0; i < size; i++) {
       headerList.add(headers.name(i) + ": " + headers.value(i));
     }
diff --git a/okcurl/pom.xml b/okcurl/pom.xml
index fe81b59a7d..285585ee31 100644
--- a/okcurl/pom.xml
+++ b/okcurl/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.3.1</version>
+    <version>3.3.1.java16</version>
   </parent>
 
   <artifactId>okcurl</artifactId>
diff --git a/okhttp-android-support/pom.xml b/okhttp-android-support/pom.xml
index c01f21722d..6456876657 100644
--- a/okhttp-android-support/pom.xml
+++ b/okhttp-android-support/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.3.1</version>
+    <version>3.3.1.java16</version>
   </parent>
 
   <artifactId>okhttp-android-support</artifactId>
diff --git a/okhttp-android-support/src/test/java/okhttp3/internal/huc/JavaApiConverterTest.java b/okhttp-android-support/src/test/java/okhttp3/internal/huc/JavaApiConverterTest.java
index f4c9b95dab..61f4de8611 100644
--- a/okhttp-android-support/src/test/java/okhttp3/internal/huc/JavaApiConverterTest.java
+++ b/okhttp-android-support/src/test/java/okhttp3/internal/huc/JavaApiConverterTest.java
@@ -106,7 +106,7 @@
     Request request = new Request.Builder().url(uri.toURL()).build();
     CacheResponse cacheResponse = new CacheResponse() {
       @Override public Map<String, List<String>> getHeaders() throws IOException {
-        Map<String, List<String>> headers = new HashMap<>();
+        Map<String, List<String>> headers = new HashMap<String, List<String>>();
         headers.put(null, Collections.singletonList(statusLine));
         headers.put("xyzzy", Arrays.asList("bar", "baz"));
         return headers;
@@ -138,7 +138,7 @@
     Request request = new Request.Builder().url(uri.toURL()).build();
     CacheResponse cacheResponse = new CacheResponse() {
       @Override public Map<String, List<String>> getHeaders() throws IOException {
-        Map<String, List<String>> headers = new HashMap<>();
+        Map<String, List<String>> headers = new HashMap<String, List<String>>();
         // Headers is deliberately missing an entry with a null key.
         headers.put("xyzzy", Arrays.asList("bar", "baz"));
         return headers;
@@ -166,7 +166,7 @@
     Request request = new Request.Builder().url(uri.toURL()).build();
     SecureCacheResponse cacheResponse = new SecureCacheResponse() {
       @Override public Map<String, List<String>> getHeaders() throws IOException {
-        Map<String, List<String>> headers = new HashMap<>();
+        Map<String, List<String>> headers = new HashMap<String, List<String>>();
         headers.put(null, Collections.singletonList(statusLine));
         headers.put("xyzzy", Arrays.asList("bar", "baz"));
         return headers;
@@ -235,7 +235,7 @@
   @Test public void createOkRequest_nonNullRequestHeaders() throws Exception {
     URI uri = new URI("https://foo/bar");
 
-    Map<String, List<String>> javaRequestHeaders = new HashMap<>();
+    Map<String, List<String>> javaRequestHeaders = new HashMap<String, List<String>>();
     javaRequestHeaders.put("Foo", Arrays.asList("Bar"));
     Request request = JavaApiConverter.createOkRequest(uri, "POST", javaRequestHeaders);
     assertTrue(request.isHttps());
@@ -253,7 +253,7 @@
   @Test public void createOkRequest_nullRequestHeaderKey() throws Exception {
     URI uri = new URI("https://foo/bar");
 
-    Map<String, List<String>> javaRequestHeaders = new HashMap<>();
+    Map<String, List<String>> javaRequestHeaders = new HashMap<String, List<String>>();
     javaRequestHeaders.put(null, Arrays.asList("GET / HTTP 1.1"));
     javaRequestHeaders.put("Foo", Arrays.asList("Bar"));
     Request request = JavaApiConverter.createOkRequest(uri, "POST", javaRequestHeaders);
@@ -592,7 +592,7 @@ private void assertHeadersContainsMapping(Map<String, List<String>> headers, Str
   }
 
   @Test public void extractOkHeaders() {
-    Map<String, List<String>> javaResponseHeaders = new HashMap<>();
+    Map<String, List<String>> javaResponseHeaders = new HashMap<String, List<String>>();
     javaResponseHeaders.put(null, Arrays.asList("StatusLine"));
     javaResponseHeaders.put("key1", Arrays.asList("value1_1", "value1_2"));
     javaResponseHeaders.put("key2", Arrays.asList("value2"));
@@ -604,7 +604,7 @@ private void assertHeadersContainsMapping(Map<String, List<String>> headers, Str
   }
 
   @Test public void extractStatusLine() throws Exception {
-    Map<String, List<String>> javaResponseHeaders = new HashMap<>();
+    Map<String, List<String>> javaResponseHeaders = new HashMap<String, List<String>>();
     javaResponseHeaders.put(null, Arrays.asList("StatusLine"));
     javaResponseHeaders.put("key1", Arrays.asList("value1_1", "value1_2"));
     javaResponseHeaders.put("key2", Arrays.asList("value2"));
@@ -638,7 +638,7 @@ private static X509Certificate certificate(String certificate) {
   }
 
   private static <T> Set<T> newSet(List<T> elements) {
-    return new LinkedHashSet<>(elements);
+    return new LinkedHashSet<T>(elements);
   }
 
   private static Request createArbitraryOkRequest() {
diff --git a/okhttp-android-support/src/test/java/okhttp3/internal/huc/ResponseCacheTest.java b/okhttp-android-support/src/test/java/okhttp3/internal/huc/ResponseCacheTest.java
index a533b919b7..6e1395f71c 100644
--- a/okhttp-android-support/src/test/java/okhttp3/internal/huc/ResponseCacheTest.java
+++ b/okhttp-android-support/src/test/java/okhttp3/internal/huc/ResponseCacheTest.java
@@ -1558,7 +1558,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
   }
 
   public void assertCookies(URL url, String... expectedCookies) throws Exception {
-    List<String> actualCookies = new ArrayList<>();
+    List<String> actualCookies = new ArrayList<String>();
     for (HttpCookie cookie : cookieManager.getCookieStore().get(url.toURI())) {
       actualCookies.add(cookie.toString());
     }
@@ -1923,7 +1923,7 @@ public CacheResponse get(URI uri, String requestMethod,
         return new CacheResponse() {
           @Override public Map<String, List<String>> getHeaders() throws IOException {
             String contentType = "text/plain";
-            Map<String, List<String>> headers = new HashMap<>();
+            Map<String, List<String>> headers = new HashMap<String, List<String>>();
             headers.put("Content-Length", Arrays.asList(Integer.toString(cachedContent.length)));
             headers.put("Content-Type", Arrays.asList(contentType));
             headers.put("Expires", Arrays.asList(formatDate(-1, TimeUnit.HOURS)));
@@ -2002,7 +2002,7 @@ private InsecureResponseCache(ResponseCache delegate) {
     server.enqueue(new MockResponse()
         .setBody("ABC"));
 
-    final AtomicReference<Map<String, List<String>>> requestHeadersRef = new AtomicReference<>();
+    final AtomicReference<Map<String, List<String>>> requestHeadersRef = new AtomicReference<Map<String, List<String>>>();
     setInternalCache(new CacheAdapter(new AbstractResponseCache() {
       @Override public CacheResponse get(URI uri, String requestMethod,
           Map<String, List<String>> requestHeaders) throws IOException {
diff --git a/okhttp-apache/pom.xml b/okhttp-apache/pom.xml
index e4ba3a1aed..dfbb64d912 100644
--- a/okhttp-apache/pom.xml
+++ b/okhttp-apache/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.3.1</version>
+    <version>3.3.1.java16</version>
   </parent>
 
   <artifactId>okhttp-apache</artifactId>
diff --git a/okhttp-hpacktests/src/test/java/okhttp3/internal/framed/HpackDecodeTestBase.java b/okhttp-hpacktests/src/test/java/okhttp3/internal/framed/HpackDecodeTestBase.java
index a77c4d8a02..8177c01f47 100644
--- a/okhttp-hpacktests/src/test/java/okhttp3/internal/framed/HpackDecodeTestBase.java
+++ b/okhttp-hpacktests/src/test/java/okhttp3/internal/framed/HpackDecodeTestBase.java
@@ -37,7 +37,7 @@
    */
   protected static Collection<Story[]> createStories(String[] interopTests)
       throws Exception {
-    List<Story[]> result = new ArrayList<>();
+    List<Story[]> result = new ArrayList<Story[]>();
     for (String interopTestName : interopTests) {
       List<Story> stories = HpackJsonUtil.readStories(interopTestName);
       if (stories.isEmpty()) {
@@ -83,7 +83,7 @@ protected void testDecoder(Story story) throws Exception {
    */
   private static void assertSetEquals(
       String message, List<Header> expected, List<Header> observed) {
-    assertEquals(message, new LinkedHashSet<>(expected), new LinkedHashSet<>(observed));
+    assertEquals(message, new LinkedHashSet<Header>(expected), new LinkedHashSet<Header>(observed));
   }
 
   protected Story getStory() {
diff --git a/okhttp-hpacktests/src/test/java/okhttp3/internal/framed/hpackjson/Case.java b/okhttp-hpacktests/src/test/java/okhttp3/internal/framed/hpackjson/Case.java
index 4c931b7c0e..8b44688921 100644
--- a/okhttp-hpacktests/src/test/java/okhttp3/internal/framed/hpackjson/Case.java
+++ b/okhttp-hpacktests/src/test/java/okhttp3/internal/framed/hpackjson/Case.java
@@ -33,7 +33,7 @@
   private List<Map<String, String>> headers;
 
   public List<Header> getHeaders() {
-    List<Header> result = new ArrayList<>();
+    List<Header> result = new ArrayList<Header>();
     for (Map<String, String> inputHeader : headers) {
       Map.Entry<String, String> entry = inputHeader.entrySet().iterator().next();
       result.add(new Header(entry.getKey(), entry.getValue()));
@@ -58,7 +58,7 @@ protected Case clone() throws CloneNotSupportedException {
     Case result = new Case();
     result.seqno = seqno;
     result.wire = wire;
-    result.headers = new ArrayList<>();
+    result.headers = new ArrayList<Header>();
     for (Map<String, String> header : headers) {
       result.headers.add(new LinkedHashMap<String, String>(header));
     }
diff --git a/okhttp-hpacktests/src/test/java/okhttp3/internal/framed/hpackjson/HpackJsonUtil.java b/okhttp-hpacktests/src/test/java/okhttp3/internal/framed/hpackjson/HpackJsonUtil.java
index 1d38261c53..b2db9d4de8 100644
--- a/okhttp-hpacktests/src/test/java/okhttp3/internal/framed/hpackjson/HpackJsonUtil.java
+++ b/okhttp-hpacktests/src/test/java/okhttp3/internal/framed/hpackjson/HpackJsonUtil.java
@@ -49,7 +49,7 @@ private static Story readStory(File file) throws IOException {
   /** Iterate through the hpack-test-case resources, only picking stories for the current draft. */
   public static String[] storiesForCurrentDraft() throws URISyntaxException {
     File testCaseDirectory = new File(HpackJsonUtil.class.getResource("/hpack-test-case").toURI());
-    List<String> storyNames = new ArrayList<>();
+    List<String> storyNames = new ArrayList<String>();
     for (File path : testCaseDirectory.listFiles()) {
       if (path.isDirectory() && Arrays.asList(path.list()).contains("story_00.json")) {
         try {
@@ -69,7 +69,7 @@ private static Story readStory(File file) throws IOException {
    * Reads stories named "story_xx.json" from the folder provided.
    */
   public static List<Story> readStories(String testFolderName) throws Exception {
-    List<Story> result = new ArrayList<>();
+    List<Story> result = new ArrayList<Story>();
     int i = 0;
     while (true) { // break after last test.
       String storyResourceName = String.format(STORY_RESOURCE_FORMAT, testFolderName, i);
diff --git a/okhttp-hpacktests/src/test/java/okhttp3/internal/framed/hpackjson/Story.java b/okhttp-hpacktests/src/test/java/okhttp3/internal/framed/hpackjson/Story.java
index 3d14d5dab5..d9553635a4 100644
--- a/okhttp-hpacktests/src/test/java/okhttp3/internal/framed/hpackjson/Story.java
+++ b/okhttp-hpacktests/src/test/java/okhttp3/internal/framed/hpackjson/Story.java
@@ -49,7 +49,7 @@ public int getDraft() {
   public Story clone() throws CloneNotSupportedException {
     Story story = new Story();
     story.fileName = this.fileName;
-    story.cases = new ArrayList<>();
+    story.cases = new ArrayList<Case>();
     for (Case caze : cases) {
       story.cases.add(caze.clone());
     }
diff --git a/okhttp-logging-interceptor/pom.xml b/okhttp-logging-interceptor/pom.xml
index f53a38ded9..d64147853d 100644
--- a/okhttp-logging-interceptor/pom.xml
+++ b/okhttp-logging-interceptor/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.3.1</version>
+    <version>3.3.1.java16</version>
   </parent>
 
   <artifactId>logging-interceptor</artifactId>
diff --git a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java
index 309ebc3f30..c6c56ce920 100644
--- a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java
+++ b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java
@@ -212,7 +212,7 @@ public Level getLevel() {
       response = chain.proceed(request);
     } catch (Exception e) {
       logger.log("<-- HTTP FAILED: " + e);
-      throw e;
+      throw new IOException(e);
     }
     long tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNs);
 
diff --git a/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java b/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java
index caa6cd72bd..de379fb63d 100644
--- a/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java
+++ b/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java
@@ -674,7 +674,7 @@ private void bodyGetNoBody(int code) throws IOException {
   }
 
   private static class LogRecorder implements HttpLoggingInterceptor.Logger {
-    private final List<String> logs = new ArrayList<>();
+    private final List<String> logs = new ArrayList<String>();
     private int index;
 
     LogRecorder assertLogEqual(String expected) {
diff --git a/okhttp-testing-support/pom.xml b/okhttp-testing-support/pom.xml
index 5755d0406d..d9282b102d 100644
--- a/okhttp-testing-support/pom.xml
+++ b/okhttp-testing-support/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.3.1</version>
+    <version>3.3.1.java16</version>
   </parent>
 
   <artifactId>okhttp-testing-support</artifactId>
diff --git a/okhttp-testing-support/src/main/java/okhttp3/FakeDns.java b/okhttp-testing-support/src/main/java/okhttp3/FakeDns.java
index f2edc75d66..a5ed3a6c7b 100644
--- a/okhttp-testing-support/src/main/java/okhttp3/FakeDns.java
+++ b/okhttp-testing-support/src/main/java/okhttp3/FakeDns.java
@@ -25,12 +25,12 @@
 import static org.junit.Assert.assertEquals;
 
 public final class FakeDns implements Dns {
-  private List<String> requestedHosts = new ArrayList<>();
+  private List<String> requestedHosts = new ArrayList<String>();
   private List<InetAddress> addresses = Collections.emptyList();
 
   /** Sets the addresses to be returned by this fake DNS service. */
   public FakeDns addresses(List<InetAddress> addresses) {
-    this.addresses = new ArrayList<>(addresses);
+    this.addresses = new ArrayList<InetAddress>(addresses);
     return this;
   }
 
diff --git a/okhttp-testing-support/src/main/java/okhttp3/FakeProxySelector.java b/okhttp-testing-support/src/main/java/okhttp3/FakeProxySelector.java
index c7d37f57ea..d06fe221ee 100644
--- a/okhttp-testing-support/src/main/java/okhttp3/FakeProxySelector.java
+++ b/okhttp-testing-support/src/main/java/okhttp3/FakeProxySelector.java
@@ -25,7 +25,7 @@
 import java.util.List;
 
 public final class FakeProxySelector extends ProxySelector {
-  public final List<Proxy> proxies = new ArrayList<>();
+  public final List<Proxy> proxies = new ArrayList<Proxy>();
 
   public FakeProxySelector addProxy(Proxy proxy) {
     proxies.add(proxy);
diff --git a/okhttp-testing-support/src/main/java/okhttp3/RecordingCookieJar.java b/okhttp-testing-support/src/main/java/okhttp3/RecordingCookieJar.java
index bd4f9be142..d309ec6253 100644
--- a/okhttp-testing-support/src/main/java/okhttp3/RecordingCookieJar.java
+++ b/okhttp-testing-support/src/main/java/okhttp3/RecordingCookieJar.java
@@ -25,8 +25,8 @@
 import static org.junit.Assert.assertEquals;
 
 public final class RecordingCookieJar implements CookieJar {
-  private final Deque<List<Cookie>> requestCookies = new ArrayDeque<>();
-  private final Deque<List<Cookie>> responseCookies = new ArrayDeque<>();
+  private final Deque<List<Cookie>> requestCookies = new ArrayDeque<List<Cookie>>();
+  private final Deque<List<Cookie>> responseCookies = new ArrayDeque<List<Cookie>>();
 
   public void enqueueRequestCookies(Cookie... cookies) {
     requestCookies.add(Arrays.asList(cookies));
@@ -38,7 +38,7 @@ public void enqueueRequestCookies(Cookie... cookies) {
 
   public void assertResponseCookies(String... cookies) {
     List<Cookie> actualCookies = takeResponseCookies();
-    List<String> actualCookieStrings = new ArrayList<>();
+    List<String> actualCookieStrings = new ArrayList<String>();
     for (Cookie cookie : actualCookies) {
       actualCookieStrings.add(cookie.toString());
     }
diff --git a/okhttp-testing-support/src/main/java/okhttp3/RecordingHostnameVerifier.java b/okhttp-testing-support/src/main/java/okhttp3/RecordingHostnameVerifier.java
index 568b7c518c..0a53c1795f 100644
--- a/okhttp-testing-support/src/main/java/okhttp3/RecordingHostnameVerifier.java
+++ b/okhttp-testing-support/src/main/java/okhttp3/RecordingHostnameVerifier.java
@@ -21,7 +21,7 @@
 import javax.net.ssl.SSLSession;
 
 public final class RecordingHostnameVerifier implements HostnameVerifier {
-  public final List<String> calls = new ArrayList<>();
+  public final List<String> calls = new ArrayList<String>();
 
   public boolean verify(String hostname, SSLSession session) {
     calls.add("verify " + hostname);
diff --git a/okhttp-testing-support/src/main/java/okhttp3/internal/io/InMemoryFileSystem.java b/okhttp-testing-support/src/main/java/okhttp3/internal/io/InMemoryFileSystem.java
index bb6f519092..8d1e8ff1c0 100644
--- a/okhttp-testing-support/src/main/java/okhttp3/internal/io/InMemoryFileSystem.java
+++ b/okhttp-testing-support/src/main/java/okhttp3/internal/io/InMemoryFileSystem.java
@@ -35,9 +35,9 @@
 
 /** A simple file system where all files are held in memory. Not safe for concurrent use. */
 public final class InMemoryFileSystem implements FileSystem, TestRule {
-  private final Map<File, Buffer> files = new LinkedHashMap<>();
-  private final Map<Source, File> openSources = new IdentityHashMap<>();
-  private final Map<Sink, File> openSinks = new IdentityHashMap<>();
+  private final Map<File, Buffer> files = new LinkedHashMap<File, Buffer>();
+  private final Map<Source, File> openSources = new IdentityHashMap<Source, File>();
+  private final Map<Sink, File> openSinks = new IdentityHashMap<Sink, File>();
 
   @Override public Statement apply(final Statement base, Description description) {
     return new Statement() {
@@ -49,7 +49,7 @@
   }
 
   public void ensureResourcesClosed() {
-    List<String> openResources = new ArrayList<>();
+    List<String> openResources = new ArrayList<String>();
     for (File file : openSources.values()) {
       openResources.add("Source for " + file);
     }
diff --git a/okhttp-tests/pom.xml b/okhttp-tests/pom.xml
index 851137a2a6..14597089be 100644
--- a/okhttp-tests/pom.xml
+++ b/okhttp-tests/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.3.1</version>
+    <version>3.3.1.java16</version>
   </parent>
 
   <artifactId>okhttp-tests</artifactId>
diff --git a/okhttp-tests/src/test/java/okhttp3/CacheTest.java b/okhttp-tests/src/test/java/okhttp3/CacheTest.java
index da64492d1a..cc280301b2 100644
--- a/okhttp-tests/src/test/java/okhttp3/CacheTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CacheTest.java
@@ -1806,7 +1806,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
   }
 
   public void assertCookies(HttpUrl url, String... expectedCookies) throws Exception {
-    List<String> actualCookies = new ArrayList<>();
+    List<String> actualCookies = new ArrayList<String>();
     for (HttpCookie cookie : cookieManager.getCookieStore().get(url.uri())) {
       actualCookies.add(cookie.toString());
     }
@@ -2134,7 +2134,7 @@ public void assertCookies(HttpUrl url, String... expectedCookies) throws Excepti
     HttpUrl url = server.url("/");
     assertEquals("A", get(url).body().string());
 
-    final AtomicReference<String> ifNoneMatch = new AtomicReference<>();
+    final AtomicReference<String> ifNoneMatch = new AtomicReference<String>();
     client = client.newBuilder()
         .addNetworkInterceptor(new Interceptor() {
           @Override public Response intercept(Chain chain) throws IOException {
diff --git a/okhttp-tests/src/test/java/okhttp3/CallTest.java b/okhttp-tests/src/test/java/okhttp3/CallTest.java
index c2470c920b..15d503d60d 100644
--- a/okhttp-tests/src/test/java/okhttp3/CallTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CallTest.java
@@ -1944,7 +1944,7 @@ private InetSocketAddress startNullServer() throws IOException {
     server.enqueue(new MockResponse().setBody("A"));
 
     final CountDownLatch latch = new CountDownLatch(1);
-    final AtomicReference<String> bodyRef = new AtomicReference<>();
+    final AtomicReference<String> bodyRef = new AtomicReference<String>();
     final AtomicBoolean failureRef = new AtomicBoolean();
 
     Request request = new Request.Builder().url(server.url("/a")).build();
@@ -2058,7 +2058,7 @@ private InetSocketAddress startNullServer() throws IOException {
         .header("User-Agent", "SyncApiTest")
         .build();
 
-    final BlockingQueue<Response> responseRef = new SynchronousQueue<>();
+    final BlockingQueue<Response> responseRef = new SynchronousQueue<Response>();
     client.newCall(request).enqueue(new Callback() {
       @Override public void onFailure(Call call, IOException e) {
         throw new AssertionError();
@@ -2410,7 +2410,7 @@ private InetSocketAddress startNullServer() throws IOException {
     enableProtocol(Protocol.HTTP_2);
 
     // Capture the protocol as it is observed by the interceptor.
-    final AtomicReference<Protocol> protocolRef = new AtomicReference<>();
+    final AtomicReference<Protocol> protocolRef = new AtomicReference<Protocol>();
     Interceptor interceptor = new Interceptor() {
       @Override public Response intercept(Chain chain) throws IOException {
         protocolRef.set(chain.connection().protocol());
@@ -2686,7 +2686,7 @@ private void cancelLater(final Call call, final long delay) {
 
   private static class RecordingSSLSocketFactory extends DelegatingSSLSocketFactory {
 
-    private List<SSLSocket> socketsCreated = new ArrayList<>();
+    private List<SSLSocket> socketsCreated = new ArrayList<SSLSocket>();
 
     public RecordingSSLSocketFactory(SSLSocketFactory delegate) {
       super(delegate);
diff --git a/okhttp-tests/src/test/java/okhttp3/CertificateChainCleanerTest.java b/okhttp-tests/src/test/java/okhttp3/CertificateChainCleanerTest.java
index 261c99f8b6..1f64cc33aa 100644
--- a/okhttp-tests/src/test/java/okhttp3/CertificateChainCleanerTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CertificateChainCleanerTest.java
@@ -203,7 +203,7 @@
 
   @Test public void chainMaxLength() throws Exception {
     List<HeldCertificate> heldCertificates = chainOfLength(10);
-    List<Certificate> certificates = new ArrayList<>();
+    List<Certificate> certificates = new ArrayList<Certificate>();
     for (HeldCertificate heldCertificate : heldCertificates) {
       certificates.add(heldCertificate.certificate);
     }
@@ -216,7 +216,7 @@
 
   @Test public void chainTooLong() throws Exception {
     List<HeldCertificate> heldCertificates = chainOfLength(11);
-    List<Certificate> certificates = new ArrayList<>();
+    List<Certificate> certificates = new ArrayList<Certificate>();
     for (HeldCertificate heldCertificate : heldCertificates) {
       certificates.add(heldCertificate.certificate);
     }
@@ -232,7 +232,7 @@
 
   /** Returns a chain starting at the leaf certificate and progressing to the root. */
   private List<HeldCertificate> chainOfLength(int length) throws GeneralSecurityException {
-    List<HeldCertificate> result = new ArrayList<>();
+    List<HeldCertificate> result = new ArrayList<HeldCertificate>();
     for (int i = 1; i <= length; i++) {
       result.add(0, new HeldCertificate.Builder()
           .issuedBy(!result.isEmpty() ? result.get(0) : null)
@@ -243,7 +243,7 @@
   }
 
   private List<Certificate> list(HeldCertificate... heldCertificates) {
-    List<Certificate> result = new ArrayList<>();
+    List<Certificate> result = new ArrayList<Certificate>();
     for (HeldCertificate heldCertificate : heldCertificates) {
       result.add(heldCertificate.certificate);
     }
diff --git a/okhttp-tests/src/test/java/okhttp3/ConnectionSpecTest.java b/okhttp-tests/src/test/java/okhttp3/ConnectionSpecTest.java
index 7fbd08e628..b6d39614f5 100644
--- a/okhttp-tests/src/test/java/okhttp3/ConnectionSpecTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/ConnectionSpecTest.java
@@ -264,7 +264,7 @@
         .allEnabledTlsVersions()
         .build();
 
-    Set<Object> set = new CopyOnWriteArraySet<>();
+    Set<Object> set = new CopyOnWriteArraySet<Object>();
     assertTrue(set.add(ConnectionSpec.MODERN_TLS));
     assertTrue(set.add(ConnectionSpec.COMPATIBLE_TLS));
     assertTrue(set.add(ConnectionSpec.CLEARTEXT));
@@ -298,6 +298,6 @@
   }
 
   private static <T> Set<T> set(T... values) {
-    return new LinkedHashSet<>(Arrays.asList(values));
+    return new LinkedHashSet<T>(Arrays.asList(values));
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/DelegatingSSLSocket.java b/okhttp-tests/src/test/java/okhttp3/DelegatingSSLSocket.java
index fc863c2022..4106efc9fa 100644
--- a/okhttp-tests/src/test/java/okhttp3/DelegatingSSLSocket.java
+++ b/okhttp-tests/src/test/java/okhttp3/DelegatingSSLSocket.java
@@ -1,17 +1,15 @@
 /*
  * Copyright 2014 Square Inc.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+ * in compliance with the License. You may obtain a copy of the License at
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
  */
 package okhttp3;
 
@@ -41,247 +39,308 @@ public DelegatingSSLSocket(SSLSocket delegate) {
     this.delegate = delegate;
   }
 
-  @Override public void shutdownInput() throws IOException {
+  @Override
+  public void shutdownInput() throws IOException {
     delegate.shutdownInput();
   }
 
-  @Override public void shutdownOutput() throws IOException {
+  @Override
+  public void shutdownOutput() throws IOException {
     delegate.shutdownOutput();
   }
 
-  @Override public String[] getSupportedCipherSuites() {
+  @Override
+  public String[] getSupportedCipherSuites() {
     return delegate.getSupportedCipherSuites();
   }
 
-  @Override public String[] getEnabledCipherSuites() {
+  @Override
+  public String[] getEnabledCipherSuites() {
     return delegate.getEnabledCipherSuites();
   }
 
-  @Override public void setEnabledCipherSuites(String[] suites) {
+  @Override
+  public void setEnabledCipherSuites(String[] suites) {
     delegate.setEnabledCipherSuites(suites);
   }
 
-  @Override public String[] getSupportedProtocols() {
+  @Override
+  public String[] getSupportedProtocols() {
     return delegate.getSupportedProtocols();
   }
 
-  @Override public String[] getEnabledProtocols() {
+  @Override
+  public String[] getEnabledProtocols() {
     return delegate.getEnabledProtocols();
   }
 
-  @Override public void setEnabledProtocols(String[] protocols) {
+  @Override
+  public void setEnabledProtocols(String[] protocols) {
     delegate.setEnabledProtocols(protocols);
   }
 
-  @Override public SSLSession getSession() {
+  @Override
+  public SSLSession getSession() {
     return delegate.getSession();
   }
 
-  @Override public void addHandshakeCompletedListener(HandshakeCompletedListener listener) {
+  @Override
+  public void addHandshakeCompletedListener(HandshakeCompletedListener listener) {
     delegate.addHandshakeCompletedListener(listener);
   }
 
-  @Override public void removeHandshakeCompletedListener(HandshakeCompletedListener listener) {
+  @Override
+  public void removeHandshakeCompletedListener(HandshakeCompletedListener listener) {
     delegate.removeHandshakeCompletedListener(listener);
   }
 
-  @Override public void startHandshake() throws IOException {
+  @Override
+  public void startHandshake() throws IOException {
     delegate.startHandshake();
   }
 
-  @Override public void setUseClientMode(boolean mode) {
+  @Override
+  public void setUseClientMode(boolean mode) {
     delegate.setUseClientMode(mode);
   }
 
-  @Override public boolean getUseClientMode() {
+  @Override
+  public boolean getUseClientMode() {
     return delegate.getUseClientMode();
   }
 
-  @Override public void setNeedClientAuth(boolean need) {
+  @Override
+  public void setNeedClientAuth(boolean need) {
     delegate.setNeedClientAuth(need);
   }
 
-  @Override public void setWantClientAuth(boolean want) {
+  @Override
+  public void setWantClientAuth(boolean want) {
     delegate.setWantClientAuth(want);
   }
 
-  @Override public boolean getNeedClientAuth() {
+  @Override
+  public boolean getNeedClientAuth() {
     return delegate.getNeedClientAuth();
   }
 
-  @Override public boolean getWantClientAuth() {
+  @Override
+  public boolean getWantClientAuth() {
     return delegate.getWantClientAuth();
   }
 
-  @Override public void setEnableSessionCreation(boolean flag) {
+  @Override
+  public void setEnableSessionCreation(boolean flag) {
     delegate.setEnableSessionCreation(flag);
   }
 
-  @Override public boolean getEnableSessionCreation() {
+  @Override
+  public boolean getEnableSessionCreation() {
     return delegate.getEnableSessionCreation();
   }
 
-  @Override public SSLParameters getSSLParameters() {
+  @Override
+  public SSLParameters getSSLParameters() {
     return delegate.getSSLParameters();
   }
 
-  @Override public void setSSLParameters(SSLParameters p) {
+  @Override
+  public void setSSLParameters(SSLParameters p) {
     delegate.setSSLParameters(p);
   }
 
-  @Override public void close() throws IOException {
+  @Override
+  public void close() throws IOException {
     delegate.close();
   }
 
-  @Override public InetAddress getInetAddress() {
+  @Override
+  public InetAddress getInetAddress() {
     return delegate.getInetAddress();
   }
 
-  @Override public InputStream getInputStream() throws IOException {
+  @Override
+  public InputStream getInputStream() throws IOException {
     return delegate.getInputStream();
   }
 
-  @Override public boolean getKeepAlive() throws SocketException {
+  @Override
+  public boolean getKeepAlive() throws SocketException {
     return delegate.getKeepAlive();
   }
 
-  @Override public InetAddress getLocalAddress() {
+  @Override
+  public InetAddress getLocalAddress() {
     return delegate.getLocalAddress();
   }
 
-  @Override public int getLocalPort() {
+  @Override
+  public int getLocalPort() {
     return delegate.getLocalPort();
   }
 
-  @Override public OutputStream getOutputStream() throws IOException {
+  @Override
+  public OutputStream getOutputStream() throws IOException {
     return delegate.getOutputStream();
   }
 
-  @Override public int getPort() {
+  @Override
+  public int getPort() {
     return delegate.getPort();
   }
 
-  @Override public int getSoLinger() throws SocketException {
+  @Override
+  public int getSoLinger() throws SocketException {
     return delegate.getSoLinger();
   }
 
-  @Override public int getReceiveBufferSize() throws SocketException {
+  @Override
+  public int getReceiveBufferSize() throws SocketException {
     return delegate.getReceiveBufferSize();
   }
 
-  @Override public int getSendBufferSize() throws SocketException {
+  @Override
+  public int getSendBufferSize() throws SocketException {
     return delegate.getSendBufferSize();
   }
 
-  @Override public int getSoTimeout() throws SocketException {
+  @Override
+  public int getSoTimeout() throws SocketException {
     return delegate.getSoTimeout();
   }
 
-  @Override public boolean getTcpNoDelay() throws SocketException {
+  @Override
+  public boolean getTcpNoDelay() throws SocketException {
     return delegate.getTcpNoDelay();
   }
 
-  @Override public void setKeepAlive(boolean keepAlive) throws SocketException {
+  @Override
+  public void setKeepAlive(boolean keepAlive) throws SocketException {
     delegate.setKeepAlive(keepAlive);
   }
 
-  @Override public void setSendBufferSize(int size) throws SocketException {
+  @Override
+  public void setSendBufferSize(int size) throws SocketException {
     delegate.setSendBufferSize(size);
   }
 
-  @Override public void setReceiveBufferSize(int size) throws SocketException {
+  @Override
+  public void setReceiveBufferSize(int size) throws SocketException {
     delegate.setReceiveBufferSize(size);
   }
 
-  @Override public void setSoLinger(boolean on, int timeout) throws SocketException {
+  @Override
+  public void setSoLinger(boolean on, int timeout) throws SocketException {
     delegate.setSoLinger(on, timeout);
   }
 
-  @Override public void setSoTimeout(int timeout) throws SocketException {
+  @Override
+  public void setSoTimeout(int timeout) throws SocketException {
     delegate.setSoTimeout(timeout);
   }
 
-  @Override public void setTcpNoDelay(boolean on) throws SocketException {
+  @Override
+  public void setTcpNoDelay(boolean on) throws SocketException {
     delegate.setTcpNoDelay(on);
   }
 
-  @Override public String toString() {
+  @Override
+  public String toString() {
     return delegate.toString();
   }
 
-  @Override public SocketAddress getLocalSocketAddress() {
+  @Override
+  public SocketAddress getLocalSocketAddress() {
     return delegate.getLocalSocketAddress();
   }
 
-  @Override public SocketAddress getRemoteSocketAddress() {
+  @Override
+  public SocketAddress getRemoteSocketAddress() {
     return delegate.getRemoteSocketAddress();
   }
 
-  @Override public boolean isBound() {
+  @Override
+  public boolean isBound() {
     return delegate.isBound();
   }
 
-  @Override public boolean isConnected() {
+  @Override
+  public boolean isConnected() {
     return delegate.isConnected();
   }
 
-  @Override public boolean isClosed() {
+  @Override
+  public boolean isClosed() {
     return delegate.isClosed();
   }
 
-  @Override public void bind(SocketAddress localAddr) throws IOException {
+  @Override
+  public void bind(SocketAddress localAddr) throws IOException {
     delegate.bind(localAddr);
   }
 
-  @Override public void connect(SocketAddress remoteAddr) throws IOException {
+  @Override
+  public void connect(SocketAddress remoteAddr) throws IOException {
     delegate.connect(remoteAddr);
   }
 
-  @Override public void connect(SocketAddress remoteAddr, int timeout) throws IOException {
+  @Override
+  public void connect(SocketAddress remoteAddr, int timeout) throws IOException {
     delegate.connect(remoteAddr, timeout);
   }
 
-  @Override public boolean isInputShutdown() {
+  @Override
+  public boolean isInputShutdown() {
     return delegate.isInputShutdown();
   }
 
-  @Override public boolean isOutputShutdown() {
+  @Override
+  public boolean isOutputShutdown() {
     return delegate.isOutputShutdown();
   }
 
-  @Override public void setReuseAddress(boolean reuse) throws SocketException {
+  @Override
+  public void setReuseAddress(boolean reuse) throws SocketException {
     delegate.setReuseAddress(reuse);
   }
 
-  @Override public boolean getReuseAddress() throws SocketException {
+  @Override
+  public boolean getReuseAddress() throws SocketException {
     return delegate.getReuseAddress();
   }
 
-  @Override public void setOOBInline(boolean oobinline) throws SocketException {
+  @Override
+  public void setOOBInline(boolean oobinline) throws SocketException {
     delegate.setOOBInline(oobinline);
   }
 
-  @Override public boolean getOOBInline() throws SocketException {
+  @Override
+  public boolean getOOBInline() throws SocketException {
     return delegate.getOOBInline();
   }
 
-  @Override public void setTrafficClass(int value) throws SocketException {
+  @Override
+  public void setTrafficClass(int value) throws SocketException {
     delegate.setTrafficClass(value);
   }
 
-  @Override public int getTrafficClass() throws SocketException {
+  @Override
+  public int getTrafficClass() throws SocketException {
     return delegate.getTrafficClass();
   }
 
-  @Override public void sendUrgentData(int value) throws IOException {
+  @Override
+  public void sendUrgentData(int value) throws IOException {
     delegate.sendUrgentData(value);
   }
 
-  @Override public SocketChannel getChannel() {
+  @Override
+  public SocketChannel getChannel() {
     return delegate.getChannel();
   }
 
-  @Override public void setPerformancePreferences(int connectionTime, int latency, int bandwidth) {
+  @Override
+  public void setPerformancePreferences(int connectionTime, int latency, int bandwidth) {
     delegate.setPerformancePreferences(connectionTime, latency, bandwidth);
   }
 
@@ -290,7 +349,9 @@ public DelegatingSSLSocket(SSLSocket delegate) {
   public SSLSession getHandshakeSession() {
     try {
       return (SSLSession) SSLSocket.class.getMethod("getHandshakeSession").invoke(delegate);
-    } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
+    } catch (IllegalAccessException e) {
+    } catch (InvocationTargetException e) {
+    } catch (NoSuchMethodException e) {
       throw new AssertionError();
     }
   }
@@ -298,7 +359,9 @@ public SSLSession getHandshakeSession() {
   public String getApplicationProtocol() {
     try {
       return (String) SSLSocket.class.getMethod("getApplicationProtocol").invoke(delegate);
-    } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
+    } catch (IllegalAccessException e) {
+    } catch (InvocationTargetException e) {
+    } catch (NoSuchMethodException e) {
       throw new AssertionError();
     }
   }
@@ -306,16 +369,21 @@ public String getApplicationProtocol() {
   public String getHandshakeApplicationProtocol() {
     try {
       return (String) SSLSocket.class.getMethod("getHandshakeApplicationProtocol").invoke(delegate);
-    } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
+    } catch (IllegalAccessException e) {
+    } catch (InvocationTargetException e) {
+    } catch (NoSuchMethodException e) {
       throw new AssertionError();
     }
   }
 
   public <T> Socket setOption(SocketOption<T> name, T value) throws IOException {
     try {
-      SSLSocket.class.getMethod("setOption", SocketOption.class, Object.class).invoke(delegate, name, value);
+      SSLSocket.class.getMethod("setOption", SocketOption.class, Object.class).invoke(delegate,
+          name, value);
       return this;
-    } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
+    } catch (IllegalAccessException e) {
+    } catch (InvocationTargetException e) {
+    } catch (NoSuchMethodException e) {
       throw new AssertionError();
     }
   }
@@ -323,7 +391,9 @@ public String getHandshakeApplicationProtocol() {
   public <T> T getOption(SocketOption<T> name) throws IOException {
     try {
       return (T) SSLSocket.class.getMethod("getOption", SocketOption.class).invoke(delegate, name);
-    } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
+    } catch (IllegalAccessException e) {
+    } catch (InvocationTargetException e) {
+    } catch (NoSuchMethodException e) {
       throw new AssertionError();
     }
   }
@@ -331,7 +401,9 @@ public String getHandshakeApplicationProtocol() {
   public Set<SocketOption<?>> supportedOptions() {
     try {
       return (Set<SocketOption<?>>) SSLSocket.class.getMethod("supportedOptions").invoke(delegate);
-    } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
+    } catch (IllegalAccessException e) {
+    } catch (InvocationTargetException e) {
+    } catch (NoSuchMethodException e) {
       throw new AssertionError();
     }
   }
diff --git a/okhttp-tests/src/test/java/okhttp3/DispatcherTest.java b/okhttp-tests/src/test/java/okhttp3/DispatcherTest.java
index 4dc3d0c6bd..b1be17ae97 100644
--- a/okhttp-tests/src/test/java/okhttp3/DispatcherTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/DispatcherTest.java
@@ -218,7 +218,7 @@
   }
 
   private <T> Set<T> set(List<T> list) {
-    return new LinkedHashSet<>(list);
+    return new LinkedHashSet<T>(list);
   }
 
   private Thread makeSynchronousCall(final Call call) {
@@ -236,14 +236,14 @@ private Thread makeSynchronousCall(final Call call) {
   }
 
   class RecordingExecutor extends AbstractExecutorService {
-    private List<AsyncCall> calls = new ArrayList<>();
+    private List<AsyncCall> calls = new ArrayList<AsyncCall>();
 
     @Override public void execute(Runnable command) {
       calls.add((AsyncCall) command);
     }
 
     public void assertJobs(String... expectedUrls) {
-      List<String> actualUrls = new ArrayList<>();
+      List<String> actualUrls = new ArrayList<String>();
       for (AsyncCall call : calls) {
         actualUrls.add(call.request().url().toString());
       }
diff --git a/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java b/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java
index f7d655dbf0..4f426491b7 100644
--- a/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java
@@ -1333,7 +1333,7 @@
   @Test public void queryParametersWithoutValues() throws Exception {
     HttpUrl url = HttpUrl.parse("http://host/?foo&bar&baz");
     assertEquals(3, url.querySize());
-    assertEquals(new LinkedHashSet<>(Arrays.asList("foo", "bar", "baz")),
+    assertEquals(new LinkedHashSet<String>(Arrays.asList("foo", "bar", "baz")),
         url.queryParameterNames());
     assertEquals(null, url.queryParameterValue(0));
     assertEquals(null, url.queryParameterValue(1));
@@ -1346,7 +1346,7 @@
   @Test public void queryParametersWithEmptyValues() throws Exception {
     HttpUrl url = HttpUrl.parse("http://host/?foo=&bar=&baz=");
     assertEquals(3, url.querySize());
-    assertEquals(new LinkedHashSet<>(Arrays.asList("foo", "bar", "baz")),
+    assertEquals(new LinkedHashSet<String>(Arrays.asList("foo", "bar", "baz")),
         url.queryParameterNames());
     assertEquals("", url.queryParameterValue(0));
     assertEquals("", url.queryParameterValue(1));
diff --git a/okhttp-tests/src/test/java/okhttp3/InterceptorTest.java b/okhttp-tests/src/test/java/okhttp3/InterceptorTest.java
index 287f12a317..8ba35752c4 100644
--- a/okhttp-tests/src/test/java/okhttp3/InterceptorTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/InterceptorTest.java
@@ -719,7 +719,7 @@ private void addInterceptor(boolean network, Interceptor interceptor) {
 
   /** Catches exceptions that are otherwise headed for the uncaught exception handler. */
   private static class ExceptionCatchingExecutor extends ThreadPoolExecutor {
-    private final BlockingQueue<Exception> exceptions = new LinkedBlockingQueue<>();
+    private final BlockingQueue<Exception> exceptions = new LinkedBlockingQueue<Exception>();
 
     public ExceptionCatchingExecutor() {
       super(1, 1, 0, TimeUnit.SECONDS, new SynchronousQueue<Runnable>());
diff --git a/okhttp-tests/src/test/java/okhttp3/RecordingCallback.java b/okhttp-tests/src/test/java/okhttp3/RecordingCallback.java
index 56a1d7e003..38f0a4d5f0 100644
--- a/okhttp-tests/src/test/java/okhttp3/RecordingCallback.java
+++ b/okhttp-tests/src/test/java/okhttp3/RecordingCallback.java
@@ -27,7 +27,7 @@
 public class RecordingCallback implements Callback {
   public static final long TIMEOUT_MILLIS = TimeUnit.SECONDS.toMillis(10);
 
-  private final List<RecordedResponse> responses = new ArrayList<>();
+  private final List<RecordedResponse> responses = new ArrayList<RecordedResponse>();
 
   @Override public synchronized void onFailure(Call call, IOException e) {
     responses.add(new RecordedResponse(call.request(), null, null, null, e));
diff --git a/okhttp-tests/src/test/java/okhttp3/TestLogHandler.java b/okhttp-tests/src/test/java/okhttp3/TestLogHandler.java
index 10f3cbb9d2..535ae0d9f7 100644
--- a/okhttp-tests/src/test/java/okhttp3/TestLogHandler.java
+++ b/okhttp-tests/src/test/java/okhttp3/TestLogHandler.java
@@ -25,7 +25,7 @@
  * assertions about them.
  */
 public final class TestLogHandler extends Handler {
-  private final List<String> logs = new ArrayList<>();
+  private final List<String> logs = new ArrayList<String>();
 
   @Override public synchronized void publish(LogRecord logRecord) {
     logs.add(logRecord.getLevel() + ": " + logRecord.getMessage());
diff --git a/okhttp-tests/src/test/java/okhttp3/TestUtil.java b/okhttp-tests/src/test/java/okhttp3/TestUtil.java
index a4581960eb..7bd26cedb3 100644
--- a/okhttp-tests/src/test/java/okhttp3/TestUtil.java
+++ b/okhttp-tests/src/test/java/okhttp3/TestUtil.java
@@ -32,7 +32,7 @@ public static OkHttpClient defaultClient() {
   }
 
   public static List<Header> headerEntries(String... elements) {
-    List<Header> result = new ArrayList<>(elements.length / 2);
+    List<Header> result = new ArrayList<Header>(elements.length / 2);
     for (int i = 0; i < elements.length; i += 2) {
       result.add(new Header(elements[i], elements[i + 1]));
     }
@@ -44,7 +44,7 @@ public static OkHttpClient defaultClient() {
   }
 
   public static <T> Set<T> setOf(Collection<T> elements) {
-    return new LinkedHashSet<>(elements);
+    return new LinkedHashSet<T>(elements);
   }
 
   public static String repeat(char c, int count) {
diff --git a/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java b/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
index cdfc26a76d..15c1f371c6 100644
--- a/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
@@ -142,8 +142,8 @@
     assertEquals("f", connection.getRequestProperty("D"));
     assertEquals("f", connection.getRequestProperty("d"));
     Map<String, List<String>> requestHeaders = connection.getRequestProperties();
-    assertEquals(newSet("e", "f"), new LinkedHashSet<>(requestHeaders.get("D")));
-    assertEquals(newSet("e", "f"), new LinkedHashSet<>(requestHeaders.get("d")));
+    assertEquals(newSet("e", "f"), new LinkedHashSet<String>(requestHeaders.get("D")));
+    assertEquals(newSet("e", "f"), new LinkedHashSet<String>(requestHeaders.get("d")));
     try {
       requestHeaders.put("G", Arrays.asList("h"));
       fail("Modified an unmodifiable view.");
@@ -214,8 +214,8 @@
     assertEquals("HTTP/1.0 200 Fantastic", connection.getHeaderField(null));
     Map<String, List<String>> responseHeaders = connection.getHeaderFields();
     assertEquals(Arrays.asList("HTTP/1.0 200 Fantastic"), responseHeaders.get(null));
-    assertEquals(newSet("c", "e"), new LinkedHashSet<>(responseHeaders.get("A")));
-    assertEquals(newSet("c", "e"), new LinkedHashSet<>(responseHeaders.get("a")));
+    assertEquals(newSet("c", "e"), new LinkedHashSet<String>(responseHeaders.get("A")));
+    assertEquals(newSet("c", "e"), new LinkedHashSet<String>(responseHeaders.get("a")));
     try {
       responseHeaders.put("N", Arrays.asList("o"));
       fail("Modified an unmodifiable view.");
@@ -3503,7 +3503,7 @@ private void assertContent(String expected, HttpURLConnection connection) throws
   }
 
   private Set<String> newSet(String... elements) {
-    return new LinkedHashSet<>(Arrays.asList(elements));
+    return new LinkedHashSet<String>(Arrays.asList(elements));
   }
 
   enum TransferKind {
diff --git a/okhttp-tests/src/test/java/okhttp3/UrlComponentEncodingTester.java b/okhttp-tests/src/test/java/okhttp3/UrlComponentEncodingTester.java
index 56611be40a..4414b3330e 100644
--- a/okhttp-tests/src/test/java/okhttp3/UrlComponentEncodingTester.java
+++ b/okhttp-tests/src/test/java/okhttp3/UrlComponentEncodingTester.java
@@ -41,7 +41,7 @@
   private static final Map<Integer, Encoding> defaultEncodings;
 
   static {
-    Map<Integer, Encoding> map = new LinkedHashMap<>();
+    Map<Integer, Encoding> map = new LinkedHashMap<Integer, Encoding>();
     map.put(       0x0, Encoding.PERCENT); // Null character
     map.put(       0x1, Encoding.PERCENT); // Start of Header
     map.put(       0x2, Encoding.PERCENT); // Start of Text
@@ -180,7 +180,7 @@
   private final StringBuilder uriEscapedCodePoints = new StringBuilder();
 
   public UrlComponentEncodingTester() {
-    this.encodings = new LinkedHashMap<>(defaultEncodings);
+    this.encodings = new LinkedHashMap<Integer,Encoding>(defaultEncodings);
   }
 
   public UrlComponentEncodingTester override(Encoding encoding, int... codePoints) {
diff --git a/okhttp-tests/src/test/java/okhttp3/WebPlatformUrlTest.java b/okhttp-tests/src/test/java/okhttp3/WebPlatformUrlTest.java
index a15c57ea35..ebc2a06755 100644
--- a/okhttp-tests/src/test/java/okhttp3/WebPlatformUrlTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/WebPlatformUrlTest.java
@@ -36,7 +36,7 @@
   @Parameterized.Parameters(name = "{0}")
   public static List<Object[]> parameters() {
     try {
-      List<Object[]> result = new ArrayList<>();
+      List<Object[]> result = new ArrayList<Object[]>();
       for (WebPlatformUrlTestData urlTestData : loadTests()) {
         result.add(new Object[] {urlTestData});
       }
diff --git a/okhttp-tests/src/test/java/okhttp3/WebPlatformUrlTestData.java b/okhttp-tests/src/test/java/okhttp3/WebPlatformUrlTestData.java
index 72f92f9abf..65cd577d4f 100644
--- a/okhttp-tests/src/test/java/okhttp3/WebPlatformUrlTestData.java
+++ b/okhttp-tests/src/test/java/okhttp3/WebPlatformUrlTestData.java
@@ -86,7 +86,7 @@ private void set(String name, String value) {
   }
 
   public static List<WebPlatformUrlTestData> load(BufferedSource source) throws IOException {
-    List<WebPlatformUrlTestData> list = new ArrayList<>();
+    List<WebPlatformUrlTestData> list = new ArrayList<WebPlatformUrlTestData>();
     for (String line; (line = source.readUtf8Line()) != null; ) {
       if (line.isEmpty() || line.startsWith("#")) continue;
 
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ConnectionSpecSelectorTest.java b/okhttp-tests/src/test/java/okhttp3/internal/ConnectionSpecSelectorTest.java
index 96c6585a34..2aaa10b5d1 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/ConnectionSpecSelectorTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/ConnectionSpecSelectorTest.java
@@ -126,8 +126,8 @@ private SSLSocket createSocketWithEnabledProtocols(TlsVersion... tlsVersions) th
   }
 
   private static void assertEnabledProtocols(SSLSocket socket, TlsVersion... required) {
-    Set<String> actual = new LinkedHashSet<>(Arrays.asList(socket.getEnabledProtocols()));
-    Set<String> expected = new LinkedHashSet<>(Arrays.asList(javaNames(required)));
+    Set<String> actual = new LinkedHashSet<String>(Arrays.asList(socket.getEnabledProtocols()));
+    Set<String> expected = new LinkedHashSet<String>(Arrays.asList(javaNames(required)));
     assertEquals(expected, actual);
   }
 
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/DiskLruCacheTest.java b/okhttp-tests/src/test/java/okhttp3/internal/DiskLruCacheTest.java
index be2d0be61d..95d563b529 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/DiskLruCacheTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/DiskLruCacheTest.java
@@ -60,7 +60,7 @@
   private final TestExecutor executor = new TestExecutor();
 
   private DiskLruCache cache;
-  private final Deque<DiskLruCache> toClose = new ArrayDeque<>();
+  private final Deque<DiskLruCache> toClose = new ArrayDeque<DiskLruCache>();
 
   private void createNewCache() throws IOException {
     createNewCacheWithSize(Integer.MAX_VALUE);
@@ -1611,7 +1611,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
   }
 
   private void assertJournalEquals(String... expectedBodyLines) throws Exception {
-    List<String> expectedLines = new ArrayList<>();
+    List<String> expectedLines = new ArrayList<String>();
     expectedLines.add(MAGIC);
     expectedLines.add(VERSION_1);
     expectedLines.add("100");
@@ -1641,7 +1641,7 @@ private void createJournalWithHeader(String magic, String version, String appVer
   }
 
   private List<String> readJournalLines() throws Exception {
-    List<String> result = new ArrayList<>();
+    List<String> result = new ArrayList<String>();
     BufferedSource source = Okio.buffer(fileSystem.source(journalFile));
     for (String line; (line = source.readUtf8Line()) != null; ) {
       result.add(line);
@@ -1774,7 +1774,7 @@ private void copyFile(File from, File to) throws IOException {
   }
 
   private static class TestExecutor implements Executor {
-    final Deque<Runnable> jobs = new ArrayDeque<>();
+    final Deque<Runnable> jobs = new ArrayDeque<Runnable>();
 
     @Override public void execute(Runnable command) {
       jobs.addLast(command);
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/FaultyFileSystem.java b/okhttp-tests/src/test/java/okhttp3/internal/FaultyFileSystem.java
index 3f237d0ad0..6cf25aa187 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/FaultyFileSystem.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/FaultyFileSystem.java
@@ -28,9 +28,9 @@
 
 public final class FaultyFileSystem implements FileSystem {
   private final FileSystem delegate;
-  private final Set<File> writeFaults = new LinkedHashSet<>();
-  private final Set<File> deleteFaults = new LinkedHashSet<>();
-  private final Set<File> renameFaults = new LinkedHashSet<>();
+  private final Set<File> writeFaults = new LinkedHashSet<File>();
+  private final Set<File> deleteFaults = new LinkedHashSet<File>();
+  private final Set<File> renameFaults = new LinkedHashSet<File>();
 
   public FaultyFileSystem(FileSystem delegate) {
     this.delegate = delegate;
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/RecordingAuthenticator.java b/okhttp-tests/src/test/java/okhttp3/internal/RecordingAuthenticator.java
index aeb34f742f..90191a4799 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/RecordingAuthenticator.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/RecordingAuthenticator.java
@@ -24,7 +24,7 @@
   /** base64("username:password") */
   public static final String BASE_64_CREDENTIALS = "dXNlcm5hbWU6cGFzc3dvcmQ=";
 
-  public final List<String> calls = new ArrayList<>();
+  public final List<String> calls = new ArrayList<String>();
   public final PasswordAuthentication authentication;
 
   public RecordingAuthenticator(PasswordAuthentication authentication) {
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/RecordingOkAuthenticator.java b/okhttp-tests/src/test/java/okhttp3/internal/RecordingOkAuthenticator.java
index 7d9d2bfe6a..cf7c2f2b21 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/RecordingOkAuthenticator.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/RecordingOkAuthenticator.java
@@ -25,8 +25,8 @@
 import okhttp3.Route;
 
 public final class RecordingOkAuthenticator implements Authenticator {
-  public final List<Response> responses = new ArrayList<>();
-  public final List<Proxy> proxies = new ArrayList<>();
+  public final List<Response> responses = new ArrayList<Response>();
+  public final List<Proxy> proxies = new ArrayList<Proxy>();
   public final String credential;
 
   public RecordingOkAuthenticator(String credential) {
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/framed/Http2ConnectionTest.java b/okhttp-tests/src/test/java/okhttp3/internal/framed/Http2ConnectionTest.java
index 67d6964d7f..88519574e3 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/framed/Http2ConnectionTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/framed/Http2ConnectionTest.java
@@ -308,7 +308,7 @@
     MockSpdyPeer.InFrame synStream = peer.takeFrame();
     assertEquals(TYPE_HEADERS, synStream.type);
     for (int i = 0; i < 3; i++) {
-      List<Integer> windowUpdateStreamIds = new ArrayList<>(2);
+      List<Integer> windowUpdateStreamIds = new ArrayList<Integer>(2);
       for (int j = 0; j < 2; j++) {
         MockSpdyPeer.InFrame windowUpdate = peer.takeFrame();
         assertEquals(TYPE_WINDOW_UPDATE, windowUpdate.type);
@@ -572,7 +572,7 @@ private FramedConnection connection(MockSpdyPeer peer, Variant variant) throws I
   };
 
   private static class RecordingPushObserver implements PushObserver {
-    final List<Object> events = new ArrayList<>();
+    final List<Object> events = new ArrayList<Object>();
 
     public synchronized Object takeEvent() throws InterruptedException {
       while (events.isEmpty()) {
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/framed/Http2FrameLoggerTest.java b/okhttp-tests/src/test/java/okhttp3/internal/framed/Http2FrameLoggerTest.java
index 864a368774..c34bcfee48 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/framed/Http2FrameLoggerTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/framed/Http2FrameLoggerTest.java
@@ -91,7 +91,7 @@
    * also demonstrates how sparse the lookup table is.
    */
   @Test public void allFormattedFlagsWithValidBits() {
-    List<String> formattedFlags = new ArrayList<>(0x40); // Highest valid flag is 0x20.
+    List<String> formattedFlags = new ArrayList<String>(0x40); // Highest valid flag is 0x20.
     for (byte i = 0; i < 0x40; i++) formattedFlags.add(formatFlags(TYPE_HEADERS, i));
 
     assertEquals(Arrays.asList(
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/framed/MockSpdyPeer.java b/okhttp-tests/src/test/java/okhttp3/internal/framed/MockSpdyPeer.java
index edc8f41c30..84953be58a 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/framed/MockSpdyPeer.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/framed/MockSpdyPeer.java
@@ -46,8 +46,8 @@
   private Variant variant = new Spdy3();
   private final Buffer bytesOut = new Buffer();
   private FrameWriter frameWriter = variant.newWriter(bytesOut, client);
-  private final List<OutFrame> outFrames = new ArrayList<>();
-  private final BlockingQueue<InFrame> inFrames = new LinkedBlockingQueue<>();
+  private final List<OutFrame> outFrames = new ArrayList<OutFrame>();
+  private final BlockingQueue<InFrame> inFrames = new LinkedBlockingQueue<InFrame>();
   private int port;
   private final ExecutorService executor = Executors.newSingleThreadExecutor(
       Util.threadFactory("MockSpdyPeer", false));
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/framed/Spdy3ConnectionTest.java b/okhttp-tests/src/test/java/okhttp3/internal/framed/Spdy3ConnectionTest.java
index 96a6fb4288..cfe91998fe 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/framed/Spdy3ConnectionTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/framed/Spdy3ConnectionTest.java
@@ -1146,7 +1146,7 @@
     MockSpdyPeer.InFrame synStream = peer.takeFrame();
     assertEquals(TYPE_HEADERS, synStream.type);
     for (int i = 0; i < 3; i++) {
-      List<Integer> windowUpdateStreamIds = new ArrayList<>(2);
+      List<Integer> windowUpdateStreamIds = new ArrayList<Integer>(2);
       for (int j = 0; j < 2; j++) {
         MockSpdyPeer.InFrame windowUpdate = peer.takeFrame();
         assertEquals(TYPE_WINDOW_UPDATE, windowUpdate.type);
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/CookiesTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http/CookiesTest.java
index bf01f36fac..ed0f6604dc 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http/CookiesTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http/CookiesTest.java
@@ -257,7 +257,7 @@ public void testNetscapeResponse() throws Exception {
         .cookieJar(new JavaNetCookieJar(new CookieManager() {
           @Override public Map<String, List<String>> get(URI uri,
               Map<String, List<String>> requestHeaders) throws IOException {
-            Map<String, List<String>> result = new HashMap<>();
+            Map<String, List<String>> result = new HashMap<String, List<String>>();
             result.put("COOKIE", Collections.singletonList("Bar=bar"));
             result.put("cooKIE2", Collections.singletonList("Baz=baz"));
             return result;
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/HeadersTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http/HeadersTest.java
index 84f37d13a3..cf7f4ea543 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http/HeadersTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http/HeadersTest.java
@@ -271,7 +271,7 @@
   }
 
   @Test public void ofMapMakesDefensiveCopy() {
-    Map<String, String> namesAndValues = new HashMap<>();
+    Map<String, String> namesAndValues = new HashMap<String, String>();
     namesAndValues.put("User-Agent", "OkHttp");
 
     Headers headers = Headers.of(namesAndValues);
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/RecordingProxySelector.java b/okhttp-tests/src/test/java/okhttp3/internal/http/RecordingProxySelector.java
index 33a51500e0..10b4f32150 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http/RecordingProxySelector.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http/RecordingProxySelector.java
@@ -29,9 +29,9 @@
 import static org.junit.Assert.assertEquals;
 
 public final class RecordingProxySelector extends ProxySelector {
-  public final List<Proxy> proxies = new ArrayList<>();
-  public final List<URI> requestedUris = new ArrayList<>();
-  public final List<String> failures = new ArrayList<>();
+  public final List<Proxy> proxies = new ArrayList<Proxy>();
+  public final List<URI> requestedUris = new ArrayList<URI>();
+  public final List<String> failures = new ArrayList<String>();
 
   @Override public List<Proxy> select(URI uri) {
     requestedUris.add(uri);
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/RouteSelectorTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http/RouteSelectorTest.java
index b1e3fca305..6f41e8d435 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http/RouteSelectorTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http/RouteSelectorTest.java
@@ -302,7 +302,7 @@
     dns.addresses(makeFakeAddresses(255, numberOfAddresses));
 
     // Extract the regular sequence of routes from selector.
-    List<Route> regularRoutes = new ArrayList<>();
+    List<Route> regularRoutes = new ArrayList<Route>();
     while (routeSelector.hasNext()) {
       regularRoutes.add(routeSelector.next());
     }
@@ -314,7 +314,7 @@
     // Reset selector
     routeSelector = new RouteSelector(address, routeDatabase);
 
-    List<Route> routesWithFailedRoute = new ArrayList<>();
+    List<Route> routesWithFailedRoute = new ArrayList<Route>();
     while (routeSelector.hasNext()) {
       routesWithFailedRoute.add(routeSelector.next());
     }
@@ -363,7 +363,7 @@ private Address httpsAddress() {
 
   private static List<InetAddress> makeFakeAddresses(int prefix, int count) {
     try {
-      List<InetAddress> result = new ArrayList<>();
+      List<InetAddress> result = new ArrayList<InetAddress>();
       for (int i = 0; i < count; i++) {
         result.add(InetAddress.getByAddress(
             new byte[] {(byte) prefix, (byte) 0, (byte) 0, (byte) i}));
diff --git a/okhttp-urlconnection/pom.xml b/okhttp-urlconnection/pom.xml
index 042e6c470c..9d4a0df7b7 100644
--- a/okhttp-urlconnection/pom.xml
+++ b/okhttp-urlconnection/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.3.1</version>
+    <version>3.3.1.java16</version>
   </parent>
 
   <artifactId>okhttp-urlconnection</artifactId>
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/JavaNetCookieJar.java b/okhttp-urlconnection/src/main/java/okhttp3/JavaNetCookieJar.java
index 6af8a69b65..b09a8bd56c 100644
--- a/okhttp-urlconnection/src/main/java/okhttp3/JavaNetCookieJar.java
+++ b/okhttp-urlconnection/src/main/java/okhttp3/JavaNetCookieJar.java
@@ -38,7 +38,7 @@ public JavaNetCookieJar(CookieHandler cookieHandler) {
 
   @Override public void saveFromResponse(HttpUrl url, List<Cookie> cookies) {
     if (cookieHandler != null) {
-      List<String> cookieStrings = new ArrayList<>();
+      List<String> cookieStrings = new ArrayList<String>();
       for (Cookie cookie : cookies) {
         cookieStrings.add(cookie.toString());
       }
@@ -68,7 +68,7 @@ public JavaNetCookieJar(CookieHandler cookieHandler) {
       if (("Cookie".equalsIgnoreCase(key) || "Cookie2".equalsIgnoreCase(key))
           && !entry.getValue().isEmpty()) {
         for (String header : entry.getValue()) {
-          if (cookies == null) cookies = new ArrayList<>();
+          if (cookies == null) cookies = new ArrayList<Cookie>();
           cookies.addAll(decodeHeaderAsJavaNetCookies(url, header));
         }
       }
@@ -84,7 +84,7 @@ public JavaNetCookieJar(CookieHandler cookieHandler) {
    * multiple cookies in a single request header, which {@link Cookie#parse} doesn't support.
    */
   private List<Cookie> decodeHeaderAsJavaNetCookies(HttpUrl url, String header) {
-    List<Cookie> result = new ArrayList<>();
+    List<Cookie> result = new ArrayList<Cookie>();
     for (int pos = 0, limit = header.length(), pairEnd; pos < limit; pos = pairEnd + 1) {
       pairEnd = delimiterOffset(header, pos, limit, ";,");
       int equalsSign = delimiterOffset(header, pos, pairEnd, '=');
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/JavaNetHeaders.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/JavaNetHeaders.java
index 0b7a02e1f9..5d59e023c9 100644
--- a/okhttp-urlconnection/src/main/java/okhttp3/internal/JavaNetHeaders.java
+++ b/okhttp-urlconnection/src/main/java/okhttp3/internal/JavaNetHeaders.java
@@ -49,12 +49,12 @@ private JavaNetHeaders() {
    * non-null, this value is mapped to the null key.
    */
   public static Map<String, List<String>> toMultimap(Headers headers, String valueForNullKey) {
-    Map<String, List<String>> result = new TreeMap<>(FIELD_NAME_COMPARATOR);
+    Map<String, List<String>> result = new TreeMap<String, List<String>>(FIELD_NAME_COMPARATOR);
     for (int i = 0, size = headers.size(); i < size; i++) {
       String fieldName = headers.name(i);
       String value = headers.value(i);
 
-      List<String> allValues = new ArrayList<>();
+      List<String> allValues = new ArrayList<String>();
       List<String> otherValues = result.get(fieldName);
       if (otherValues != null) {
         allValues.addAll(otherValues);
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/HttpURLConnectionImpl.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/HttpURLConnectionImpl.java
index 08f73710dd..902d28c8c2 100644
--- a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/HttpURLConnectionImpl.java
+++ b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/HttpURLConnectionImpl.java
@@ -82,7 +82,7 @@
  * are immutable.
  */
 public class HttpURLConnectionImpl extends HttpURLConnection {
-  private static final Set<String> METHODS = new LinkedHashSet<>(
+  private static final Set<String> METHODS = new LinkedHashSet<String>(
       Arrays.asList("OPTIONS", "GET", "HEAD", "POST", "PUT", "DELETE", "TRACE", "PATCH"));
   private static final RequestBody EMPTY_REQUEST_BODY = RequestBody.create(null, new byte[0]);
 
@@ -617,7 +617,7 @@ private boolean execute(boolean readResponse) throws IOException {
    * defined in {@link Protocol OkHttp's protocol enumeration}.
    */
   private void setProtocols(String protocolsString, boolean append) {
-    List<Protocol> protocolsList = new ArrayList<>();
+    List<Protocol> protocolsList = new ArrayList<Protocol>();
     if (append) {
       protocolsList.addAll(client.protocols());
     }
diff --git a/okhttp-urlconnection/src/test/java/okhttp3/internal/huc/URLEncodingTest.java b/okhttp-urlconnection/src/test/java/okhttp3/internal/huc/URLEncodingTest.java
index 1cc63d8f34..a3b4d639ed 100644
--- a/okhttp-urlconnection/src/test/java/okhttp3/internal/huc/URLEncodingTest.java
+++ b/okhttp-urlconnection/src/test/java/okhttp3/internal/huc/URLEncodingTest.java
@@ -121,7 +121,7 @@ private void testUrlToUriMapping(String string, String asAuthority, String asFil
   }
 
   private URI backdoorUrlToUri(URL url) throws Exception {
-    final AtomicReference<URI> uriReference = new AtomicReference<>();
+    final AtomicReference<URI> uriReference = new AtomicReference<URI>();
 
     OkHttpClient.Builder builder = new OkHttpClient.Builder();
     Internal.instance.setCache(builder, new InternalCache() {
diff --git a/okhttp-ws-tests/pom.xml b/okhttp-ws-tests/pom.xml
index c7688dbf9a..bc2776d479 100644
--- a/okhttp-ws-tests/pom.xml
+++ b/okhttp-ws-tests/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.3.1</version>
+    <version>3.3.1.java16</version>
   </parent>
 
   <artifactId>okhttp-ws-tests</artifactId>
diff --git a/okhttp-ws-tests/src/main/java/okhttp3/ws/AutobahnTester.java b/okhttp-ws-tests/src/main/java/okhttp3/ws/AutobahnTester.java
index 707f58c116..00ffdbad24 100644
--- a/okhttp-ws-tests/src/main/java/okhttp3/ws/AutobahnTester.java
+++ b/okhttp-ws-tests/src/main/java/okhttp3/ws/AutobahnTester.java
@@ -131,7 +131,7 @@ private void runTest(final long number, final long count) throws IOException {
   private long getTestCount() throws IOException {
     final CountDownLatch latch = new CountDownLatch(1);
     final AtomicLong countRef = new AtomicLong();
-    final AtomicReference<IOException> failureRef = new AtomicReference<>();
+    final AtomicReference<IOException> failureRef = new AtomicReference<IOException>();
     newWebSocket("/getCaseCount").enqueue(new WebSocketListener() {
       @Override public void onOpen(WebSocket webSocket, Response response) {
       }
diff --git a/okhttp-ws-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java b/okhttp-ws-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
index 6bb7ef86d8..13d67c0429 100644
--- a/okhttp-ws-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
+++ b/okhttp-ws-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
@@ -313,7 +313,7 @@
   @Test public void closedMessageSourceThrows() throws IOException {
     data.write(ByteString.decodeHex("810548656c6c6f")); // Hello
 
-    final AtomicReference<Exception> exception = new AtomicReference<>();
+    final AtomicReference<Exception> exception = new AtomicReference<Exception>();
     callback.setNextMessageDelegate(new MessageDelegate() {
       @Override public void onMessage(ResponseBody message) throws IOException {
         message.close();
diff --git a/okhttp-ws-tests/src/test/java/okhttp3/ws/WebSocketCallTest.java b/okhttp-ws-tests/src/test/java/okhttp3/ws/WebSocketCallTest.java
index 06dd4a2e28..3f92f21ebb 100644
--- a/okhttp-ws-tests/src/test/java/okhttp3/ws/WebSocketCallTest.java
+++ b/okhttp-ws-tests/src/test/java/okhttp3/ws/WebSocketCallTest.java
@@ -223,9 +223,9 @@ private WebSocket awaitWebSocket() {
   private WebSocket awaitWebSocket(Request request) {
     WebSocketCall call = new WebSocketCall(client, request, random);
 
-    final AtomicReference<Response> responseRef = new AtomicReference<>();
-    final AtomicReference<WebSocket> webSocketRef = new AtomicReference<>();
-    final AtomicReference<IOException> failureRef = new AtomicReference<>();
+    final AtomicReference<Response> responseRef = new AtomicReference<Response>();
+    final AtomicReference<WebSocket> webSocketRef = new AtomicReference<WebSocket>();
+    final AtomicReference<IOException> failureRef = new AtomicReference<IOException>();
     final CountDownLatch latch = new CountDownLatch(1);
     call.enqueue(new WebSocketListener() {
       @Override public void onOpen(WebSocket webSocket, Response response) {
diff --git a/okhttp-ws-tests/src/test/java/okhttp3/ws/WebSocketRecorder.java b/okhttp-ws-tests/src/test/java/okhttp3/ws/WebSocketRecorder.java
index 485a4a1e88..76ea5821c6 100644
--- a/okhttp-ws-tests/src/test/java/okhttp3/ws/WebSocketRecorder.java
+++ b/okhttp-ws-tests/src/test/java/okhttp3/ws/WebSocketRecorder.java
@@ -36,7 +36,7 @@
     void onMessage(ResponseBody message) throws IOException;
   }
 
-  private final BlockingQueue<Object> events = new LinkedBlockingQueue<>();
+  private final BlockingQueue<Object> events = new LinkedBlockingQueue<Object>();
   private MessageDelegate delegate;
   private Response response;
 
diff --git a/okhttp-ws/pom.xml b/okhttp-ws/pom.xml
index 3fc9bef1e2..a9f3051a7c 100644
--- a/okhttp-ws/pom.xml
+++ b/okhttp-ws/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.3.1</version>
+    <version>3.3.1.java16</version>
   </parent>
 
   <artifactId>okhttp-ws</artifactId>
diff --git a/okhttp-ws/src/main/java/okhttp3/internal/ws/WebSocketProtocol.java b/okhttp-ws/src/main/java/okhttp3/internal/ws/WebSocketProtocol.java
index 0a1126a147..6c6c46c4ef 100644
--- a/okhttp-ws/src/main/java/okhttp3/internal/ws/WebSocketProtocol.java
+++ b/okhttp-ws/src/main/java/okhttp3/internal/ws/WebSocketProtocol.java
@@ -34,30 +34,30 @@
   */
 
   /** Byte 0 flag for whether this is the final fragment in a message. */
-  static final int B0_FLAG_FIN = 0b10000000;
+  static final int B0_FLAG_FIN = Integer.parseInt("10000000", 2);
   /** Byte 0 reserved flag 1. Must be 0 unless negotiated otherwise. */
-  static final int B0_FLAG_RSV1 = 0b01000000;
+  static final int B0_FLAG_RSV1 = Integer.parseInt("01000000", 2);
   /** Byte 0 reserved flag 2. Must be 0 unless negotiated otherwise. */
-  static final int B0_FLAG_RSV2 = 0b00100000;
+  static final int B0_FLAG_RSV2 = Integer.parseInt("00100000", 2);
   /** Byte 0 reserved flag 3. Must be 0 unless negotiated otherwise. */
-  static final int B0_FLAG_RSV3 = 0b00010000;
+  static final int B0_FLAG_RSV3 = Integer.parseInt("00010000", 2);
   /** Byte 0 mask for the frame opcode. */
-  static final int B0_MASK_OPCODE = 0b00001111;
+  static final int B0_MASK_OPCODE = Integer.parseInt("00001111", 2);
   /** Flag in the opcode which indicates a control frame. */
-  static final int OPCODE_FLAG_CONTROL = 0b00001000;
+  static final int OPCODE_FLAG_CONTROL = Integer.parseInt("00001000", 2);
 
   /**
    * Byte 1 flag for whether the payload data is masked. <p> If this flag is set, the next four
    * bytes represent the mask key. These bytes appear after any additional bytes specified by {@link
    * #B1_MASK_LENGTH}.
    */
-  static final int B1_FLAG_MASK = 0b10000000;
+  static final int B1_FLAG_MASK = Integer.parseInt("10000000", 2);
   /**
    * Byte 1 mask for the payload length. <p> If this value is {@link #PAYLOAD_SHORT}, the next two
    * bytes represent the length. If this value is {@link #PAYLOAD_LONG}, the next eight bytes
    * represent the length.
    */
-  static final int B1_MASK_LENGTH = 0b01111111;
+  static final int B1_MASK_LENGTH = Integer.parseInt("01111111", 2);
 
   static final int OPCODE_CONTINUATION = 0x0;
   static final int OPCODE_TEXT = 0x1;
diff --git a/okhttp/pom.xml b/okhttp/pom.xml
index ac7292212c..0a17385787 100644
--- a/okhttp/pom.xml
+++ b/okhttp/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.3.1</version>
+    <version>3.3.1.java16</version>
   </parent>
 
   <artifactId>okhttp</artifactId>
diff --git a/okhttp/src/main/java/okhttp3/Cache.java b/okhttp/src/main/java/okhttp3/Cache.java
index 7473edef75..b025d28b9e 100644
--- a/okhttp/src/main/java/okhttp3/Cache.java
+++ b/okhttp/src/main/java/okhttp3/Cache.java
@@ -656,7 +656,7 @@ private boolean isHttps() {
 
       try {
         CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509");
-        List<Certificate> result = new ArrayList<>(length);
+        List<Certificate> result = new ArrayList<Certificate>(length);
         for (int i = 0; i < length; i++) {
           String line = source.readUtf8LineStrict();
           Buffer bytes = new Buffer();
diff --git a/okhttp/src/main/java/okhttp3/CertificatePinner.java b/okhttp/src/main/java/okhttp3/CertificatePinner.java
index 2d90224922..27625afbe7 100644
--- a/okhttp/src/main/java/okhttp3/CertificatePinner.java
+++ b/okhttp/src/main/java/okhttp3/CertificatePinner.java
@@ -201,7 +201,7 @@ public void check(String hostname, Certificate... peerCertificates)
     List<Pin> result = Collections.emptyList();
     for (Pin pin : pins) {
       if (pin.matches(hostname)) {
-        if (result.isEmpty()) result = new ArrayList<>();
+        if (result.isEmpty()) result = new ArrayList<Pin>();
         result.add(pin);
       }
     }
@@ -291,7 +291,7 @@ boolean matches(String hostname) {
 
   /** Builds a configured certificate pinner. */
   public static final class Builder {
-    private final List<Pin> pins = new ArrayList<>();
+    private final List<Pin> pins = new ArrayList<Pin>();
 
     /**
      * Pins certificates for {@code pattern}.
diff --git a/okhttp/src/main/java/okhttp3/ConnectionPool.java b/okhttp/src/main/java/okhttp3/ConnectionPool.java
index d6391c3f83..6264edc9c8 100644
--- a/okhttp/src/main/java/okhttp3/ConnectionPool.java
+++ b/okhttp/src/main/java/okhttp3/ConnectionPool.java
@@ -72,7 +72,7 @@
     }
   };
 
-  private final Deque<RealConnection> connections = new ArrayDeque<>();
+  private final Deque<RealConnection> connections = new ArrayDeque<RealConnection>();
   final RouteDatabase routeDatabase = new RouteDatabase();
   boolean cleanupRunning;
 
@@ -154,7 +154,7 @@ boolean connectionBecameIdle(RealConnection connection) {
 
   /** Close and remove all idle connections in the pool. */
   public void evictAll() {
-    List<RealConnection> evictedConnections = new ArrayList<>();
+    List<RealConnection> evictedConnections = new ArrayList<RealConnection>();
     synchronized (this) {
       for (Iterator<RealConnection> i = connections.iterator(); i.hasNext(); ) {
         RealConnection connection = i.next();
diff --git a/okhttp/src/main/java/okhttp3/Cookie.java b/okhttp/src/main/java/okhttp3/Cookie.java
index 29a4bf84d1..19dd900ad5 100644
--- a/okhttp/src/main/java/okhttp3/Cookie.java
+++ b/okhttp/src/main/java/okhttp3/Cookie.java
@@ -435,7 +435,7 @@ private static String parseDomain(String s) {
     for (int i = 0, size = cookieStrings.size(); i < size; i++) {
       Cookie cookie = Cookie.parse(url, cookieStrings.get(i));
       if (cookie == null) continue;
-      if (cookies == null) cookies = new ArrayList<>();
+      if (cookies == null) cookies = new ArrayList<Cookie>();
       cookies.add(cookie);
     }
 
diff --git a/okhttp/src/main/java/okhttp3/Dispatcher.java b/okhttp/src/main/java/okhttp3/Dispatcher.java
index 5a135b325d..8ac9e5b02d 100644
--- a/okhttp/src/main/java/okhttp3/Dispatcher.java
+++ b/okhttp/src/main/java/okhttp3/Dispatcher.java
@@ -43,13 +43,13 @@
   private ExecutorService executorService;
 
   /** Ready async calls in the order they'll be run. */
-  private final Deque<AsyncCall> readyAsyncCalls = new ArrayDeque<>();
+  private final Deque<AsyncCall> readyAsyncCalls = new ArrayDeque<AsyncCall>();
 
   /** Running asynchronous calls. Includes canceled calls that haven't finished yet. */
-  private final Deque<AsyncCall> runningAsyncCalls = new ArrayDeque<>();
+  private final Deque<AsyncCall> runningAsyncCalls = new ArrayDeque<AsyncCall>();
 
   /** Running synchronous calls. Includes canceled calls that haven't finished yet. */
-  private final Deque<RealCall> runningSyncCalls = new ArrayDeque<>();
+  private final Deque<RealCall> runningSyncCalls = new ArrayDeque<RealCall>();
 
   public Dispatcher(ExecutorService executorService) {
     this.executorService = executorService;
@@ -177,7 +177,7 @@ synchronized void finished(Call call) {
 
   /** Returns a snapshot of the calls currently awaiting execution. */
   public synchronized List<Call> queuedCalls() {
-    List<Call> result = new ArrayList<>();
+    List<Call> result = new ArrayList<Call>();
     for (AsyncCall asyncCall : readyAsyncCalls) {
       result.add(asyncCall.get());
     }
@@ -186,7 +186,7 @@ synchronized void finished(Call call) {
 
   /** Returns a snapshot of the calls currently being executed. */
   public synchronized List<Call> runningCalls() {
-    List<Call> result = new ArrayList<>();
+    List<Call> result = new ArrayList<Call>();
     result.addAll(runningSyncCalls);
     for (AsyncCall asyncCall : runningAsyncCalls) {
       result.add(asyncCall.get());
diff --git a/okhttp/src/main/java/okhttp3/FormBody.java b/okhttp/src/main/java/okhttp3/FormBody.java
index 95181b1f76..62d7fab720 100644
--- a/okhttp/src/main/java/okhttp3/FormBody.java
+++ b/okhttp/src/main/java/okhttp3/FormBody.java
@@ -102,8 +102,8 @@ private long writeOrCountBytes(BufferedSink sink, boolean countBytes) {
   }
 
   public static final class Builder {
-    private final List<String> names = new ArrayList<>();
-    private final List<String> values = new ArrayList<>();
+    private final List<String> names = new ArrayList<String>();
+    private final List<String> values = new ArrayList<String>();
 
     public Builder add(String name, String value) {
       names.add(HttpUrl.canonicalize(name, FORM_ENCODE_SET, false, false, true, true));
diff --git a/okhttp/src/main/java/okhttp3/Headers.java b/okhttp/src/main/java/okhttp3/Headers.java
index 5080883af7..1c799d5f90 100644
--- a/okhttp/src/main/java/okhttp3/Headers.java
+++ b/okhttp/src/main/java/okhttp3/Headers.java
@@ -88,7 +88,7 @@ public String value(int index) {
 
   /** Returns an immutable case-insensitive set of header names. */
   public Set<String> names() {
-    TreeSet<String> result = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);
+    TreeSet<String> result = new TreeSet<String>(String.CASE_INSENSITIVE_ORDER);
     for (int i = 0, size = size(); i < size; i++) {
       result.add(name(i));
     }
@@ -100,7 +100,7 @@ public String value(int index) {
     List<String> result = null;
     for (int i = 0, size = size(); i < size; i++) {
       if (name.equalsIgnoreCase(name(i))) {
-        if (result == null) result = new ArrayList<>(2);
+        if (result == null) result = new ArrayList<String>(2);
         result.add(value(i));
       }
     }
@@ -159,12 +159,12 @@ public Builder newBuilder() {
   }
 
   public Map<String, List<String>> toMultimap() {
-    Map<String, List<String>> result = new LinkedHashMap<>();
+    Map<String, List<String>> result = new LinkedHashMap<String, List<String>>();
     for (int i = 0, size = size(); i < size; i++) {
       String name = name(i).toLowerCase(Locale.US);
       List<String> values = result.get(name);
       if (values == null) {
-        values = new ArrayList<>(2);
+        values = new ArrayList<String>(2);
         result.put(name, values);
       }
       values.add(value(i));
@@ -237,7 +237,7 @@ public static Headers of(Map<String, String> headers) {
   }
 
   public static final class Builder {
-    private final List<String> namesAndValues = new ArrayList<>(20);
+    private final List<String> namesAndValues = new ArrayList<String>(20);
 
     /**
      * Add a header line without any validation. Only appropriate for headers from the remote peer
diff --git a/okhttp/src/main/java/okhttp3/HttpUrl.java b/okhttp/src/main/java/okhttp3/HttpUrl.java
index 45effb8f6d..0f38e24d39 100644
--- a/okhttp/src/main/java/okhttp3/HttpUrl.java
+++ b/okhttp/src/main/java/okhttp3/HttpUrl.java
@@ -473,7 +473,7 @@ static void pathSegmentsToString(StringBuilder out, List<String> pathSegments) {
   public List<String> encodedPathSegments() {
     int pathStart = url.indexOf('/', scheme.length() + 3);
     int pathEnd = delimiterOffset(url, pathStart, url.length(), "?#");
-    List<String> result = new ArrayList<>();
+    List<String> result = new ArrayList<String>();
     for (int i = pathStart; i < pathEnd; ) {
       i++; // Skip the '/'.
       int segmentEnd = delimiterOffset(url, i, pathEnd, '/');
@@ -519,7 +519,7 @@ static void namesAndValuesToQueryString(StringBuilder out, List<String> namesAnd
    * characters.
    */
   static List<String> queryStringToNamesAndValues(String encodedQuery) {
-    List<String> result = new ArrayList<>();
+    List<String> result = new ArrayList<String>();
     for (int pos = 0; pos <= encodedQuery.length(); ) {
       int ampersandOffset = encodedQuery.indexOf('&', pos);
       if (ampersandOffset == -1) ampersandOffset = encodedQuery.length();
@@ -564,7 +564,7 @@ public String queryParameter(String name) {
 
   public Set<String> queryParameterNames() {
     if (queryNamesAndValues == null) return Collections.emptySet();
-    Set<String> result = new LinkedHashSet<>();
+    Set<String> result = new LinkedHashSet<String>();
     for (int i = 0, size = queryNamesAndValues.size(); i < size; i += 2) {
       result.add(queryNamesAndValues.get(i));
     }
@@ -573,7 +573,7 @@ public String queryParameter(String name) {
 
   public List<String> queryParameterValues(String name) {
     if (queryNamesAndValues == null) return Collections.emptyList();
-    List<String> result = new ArrayList<>();
+    List<String> result = new ArrayList<String>();
     for (int i = 0, size = queryNamesAndValues.size(); i < size; i += 2) {
       if (name.equals(queryNamesAndValues.get(i))) {
         result.add(queryNamesAndValues.get(i + 1));
@@ -697,7 +697,7 @@ public static HttpUrl get(URI uri) {
     String encodedPassword = "";
     String host;
     int port = -1;
-    final List<String> encodedPathSegments = new ArrayList<>();
+    final List<String> encodedPathSegments = new ArrayList<String>();
     List<String> encodedQueryNamesAndValues;
     String encodedFragment;
 
@@ -872,7 +872,7 @@ public Builder encodedQuery(String encodedQuery) {
     /** Encodes the query parameter using UTF-8 and adds it to this URL's query string. */
     public Builder addQueryParameter(String name, String value) {
       if (name == null) throw new NullPointerException("name == null");
-      if (encodedQueryNamesAndValues == null) encodedQueryNamesAndValues = new ArrayList<>();
+      if (encodedQueryNamesAndValues == null) encodedQueryNamesAndValues = new ArrayList<String>();
       encodedQueryNamesAndValues.add(
           canonicalize(name, QUERY_COMPONENT_ENCODE_SET, false, false, true, true));
       encodedQueryNamesAndValues.add(value != null
@@ -884,7 +884,7 @@ public Builder addQueryParameter(String name, String value) {
     /** Adds the pre-encoded query parameter to this URL's query string. */
     public Builder addEncodedQueryParameter(String encodedName, String encodedValue) {
       if (encodedName == null) throw new NullPointerException("encodedName == null");
-      if (encodedQueryNamesAndValues == null) encodedQueryNamesAndValues = new ArrayList<>();
+      if (encodedQueryNamesAndValues == null) encodedQueryNamesAndValues = new ArrayList<String>();
       encodedQueryNamesAndValues.add(
           canonicalize(encodedName, QUERY_COMPONENT_ENCODE_SET, true, false, true, true));
       encodedQueryNamesAndValues.add(encodedValue != null
@@ -1474,7 +1474,7 @@ static String percentDecode(String encoded, boolean plusIsSpace) {
   }
 
   private List<String> percentDecode(List<String> list, boolean plusIsSpace) {
-    List<String> result = new ArrayList<>(list.size());
+    List<String> result = new ArrayList<String>(list.size());
     for (String s : list) {
       result.add(s != null ? percentDecode(s, plusIsSpace) : null);
     }
diff --git a/okhttp/src/main/java/okhttp3/MultipartBody.java b/okhttp/src/main/java/okhttp3/MultipartBody.java
index 7ac584d1d9..c24ea60042 100644
--- a/okhttp/src/main/java/okhttp3/MultipartBody.java
+++ b/okhttp/src/main/java/okhttp3/MultipartBody.java
@@ -269,7 +269,7 @@ private Part(Headers headers, RequestBody body) {
   public static final class Builder {
     private final ByteString boundary;
     private MediaType type = MIXED;
-    private final List<Part> parts = new ArrayList<>();
+    private final List<Part> parts = new ArrayList<Part>();
 
     public Builder() {
       this(UUID.randomUUID().toString());
diff --git a/okhttp/src/main/java/okhttp3/OkHttpClient.java b/okhttp/src/main/java/okhttp3/OkHttpClient.java
index b23e6a2212..b638ec9073 100644
--- a/okhttp/src/main/java/okhttp3/OkHttpClient.java
+++ b/okhttp/src/main/java/okhttp3/OkHttpClient.java
@@ -68,8 +68,10 @@
   private static final List<ConnectionSpec> DEFAULT_CONNECTION_SPECS;
 
   static {
-    List<ConnectionSpec> connSpecs = new ArrayList<>(Arrays.asList(ConnectionSpec.MODERN_TLS,
-        ConnectionSpec.COMPATIBLE_TLS));
+    List<ConnectionSpec> connSpecs = new ArrayList<ConnectionSpec>(
+      Arrays.asList(ConnectionSpec.MODERN_TLS,
+      ConnectionSpec.COMPATIBLE_TLS)
+    );
     if (Platform.get().isCleartextTrafficPermitted()) {
       connSpecs.add(ConnectionSpec.CLEARTEXT);
     }
@@ -354,8 +356,8 @@ public Builder newBuilder() {
     Proxy proxy;
     List<Protocol> protocols;
     List<ConnectionSpec> connectionSpecs;
-    final List<Interceptor> interceptors = new ArrayList<>();
-    final List<Interceptor> networkInterceptors = new ArrayList<>();
+    final List<Interceptor> interceptors = new ArrayList<Interceptor>();
+    final List<Interceptor> networkInterceptors = new ArrayList<Interceptor>();
     ProxySelector proxySelector;
     CookieJar cookieJar;
     Cache cache;
@@ -392,9 +394,9 @@ public Builder() {
       followSslRedirects = true;
       followRedirects = true;
       retryOnConnectionFailure = true;
-      connectTimeout = 10_000;
-      readTimeout = 10_000;
-      writeTimeout = 10_000;
+      connectTimeout = 10000;
+      readTimeout = 10000;
+      writeTimeout = 10000;
     }
 
     Builder(OkHttpClient okHttpClient) {
diff --git a/okhttp/src/main/java/okhttp3/TlsVersion.java b/okhttp/src/main/java/okhttp3/TlsVersion.java
index 668cd9732b..9c707f115d 100644
--- a/okhttp/src/main/java/okhttp3/TlsVersion.java
+++ b/okhttp/src/main/java/okhttp3/TlsVersion.java
@@ -33,16 +33,14 @@
   }
 
   public static TlsVersion forJavaName(String javaName) {
-    switch (javaName) {
-      case "TLSv1.2":
-        return TLS_1_2;
-      case "TLSv1.1":
-        return TLS_1_1;
-      case "TLSv1":
-        return TLS_1_0;
-      case "SSLv3":
-        return SSL_3_0;
-    }
+    if (javaName.equals("TLSv1.2"))
+      return TLS_1_2;
+    if (javaName.equals("TLSv1.1"))
+      return TLS_1_1;
+    if (javaName.equals("TLSv1"))
+      return TLS_1_0;
+    if (javaName.equals("SSLv3"))
+      return SSL_3_0;
     throw new IllegalArgumentException("Unexpected TLS version: " + javaName);
   }
 
diff --git a/okhttp/src/main/java/okhttp3/internal/AndroidPlatform.java b/okhttp/src/main/java/okhttp3/internal/AndroidPlatform.java
index 65e97020b2..f2b41d7f1e 100644
--- a/okhttp/src/main/java/okhttp3/internal/AndroidPlatform.java
+++ b/okhttp/src/main/java/okhttp3/internal/AndroidPlatform.java
@@ -15,16 +15,17 @@
  */
 package okhttp3.internal;
 
-import android.util.Log;
 import java.io.IOException;
-import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.net.InetSocketAddress;
 import java.net.Socket;
 import java.util.List;
+
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
 import javax.net.ssl.X509TrustManager;
+
+import android.util.Log;
 import okhttp3.Protocol;
 
 /** Android 2.3 or better. */
@@ -133,13 +134,14 @@ public AndroidPlatform(Class<?> sslParametersClass, OptionalMethod<Socket> setUs
       Object networkSecurityPolicy = getInstanceMethod.invoke(null);
       Method isCleartextTrafficPermittedMethod = networkPolicyClass
           .getMethod("isCleartextTrafficPermitted");
-      boolean cleartextPermitted = (boolean) isCleartextTrafficPermittedMethod
+      Boolean cleartextPermitted = (Boolean) isCleartextTrafficPermittedMethod
           .invoke(networkSecurityPolicy);
+      if (cleartextPermitted == null)
+        cleartextPermitted = false;
       return cleartextPermitted;
     } catch (ClassNotFoundException e) {
       return super.isCleartextTrafficPermitted();
-    } catch (NoSuchMethodException | IllegalAccessException | IllegalArgumentException
-        | InvocationTargetException e) {
+    } catch (Exception e) {
       throw new AssertionError();
     }
   }
@@ -156,9 +158,9 @@ public static Platform buildIfSupported() {
             "org.apache.harmony.xnet.provider.jsse.SSLParametersImpl");
       }
 
-      OptionalMethod<Socket> setUseSessionTickets = new OptionalMethod<>(
+      OptionalMethod<Socket> setUseSessionTickets = new OptionalMethod<Socket>(
           null, "setUseSessionTickets", boolean.class);
-      OptionalMethod<Socket> setHostname = new OptionalMethod<>(
+      OptionalMethod<Socket> setHostname = new OptionalMethod<Socket>(
           null, "setHostname", String.class);
       OptionalMethod<Socket> getAlpnSelectedProtocol = null;
       OptionalMethod<Socket> setAlpnProtocols = null;
@@ -166,8 +168,10 @@ public static Platform buildIfSupported() {
       // Attempt to find Android 5.0+ APIs.
       try {
         Class.forName("android.net.Network"); // Arbitrary class added in Android 5.0.
-        getAlpnSelectedProtocol = new OptionalMethod<>(byte[].class, "getAlpnSelectedProtocol");
-        setAlpnProtocols = new OptionalMethod<>(null, "setAlpnProtocols", byte[].class);
+        getAlpnSelectedProtocol = new OptionalMethod<Socket>(
+            byte[].class, "getAlpnSelectedProtocol"
+        );
+        setAlpnProtocols = new OptionalMethod<Socket>(null, "setAlpnProtocols", byte[].class);
       } catch (ClassNotFoundException ignored) {
       }
 
diff --git a/okhttp/src/main/java/okhttp3/internal/DiskLruCache.java b/okhttp/src/main/java/okhttp3/internal/DiskLruCache.java
index 097686bf28..dc18245c03 100644
--- a/okhttp/src/main/java/okhttp3/internal/DiskLruCache.java
+++ b/okhttp/src/main/java/okhttp3/internal/DiskLruCache.java
@@ -1,17 +1,15 @@
 /*
  * Copyright (C) 2011 The Android Open Source Project
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+ * in compliance with the License. You may obtain a copy of the License at
  *
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
  */
 package okhttp3.internal;
 
@@ -49,36 +47,41 @@
  * Values are byte sequences, accessible as streams or files. Each value must be between {@code 0}
  * and {@code Integer.MAX_VALUE} bytes in length.
  *
- * <p>The cache stores its data in a directory on the filesystem. This directory must be exclusive
- * to the cache; the cache may delete or overwrite files from its directory. It is an error for
+ * <p>
+ * The cache stores its data in a directory on the filesystem. This directory must be exclusive to
+ * the cache; the cache may delete or overwrite files from its directory. It is an error for
  * multiple processes to use the same cache directory at the same time.
  *
- * <p>This cache limits the number of bytes that it will store on the filesystem. When the number of
+ * <p>
+ * This cache limits the number of bytes that it will store on the filesystem. When the number of
  * stored bytes exceeds the limit, the cache will remove entries in the background until the limit
  * is satisfied. The limit is not strict: the cache may temporarily exceed it while waiting for
  * files to be deleted. The limit does not include filesystem overhead or the cache journal so
  * space-sensitive applications should set a conservative limit.
  *
- * <p>Clients call {@link #edit} to create or update the values of an entry. An entry may have only
- * one editor at one time; if a value is not available to be edited then {@link #edit} will return
- * null.
+ * <p>
+ * Clients call {@link #edit} to create or update the values of an entry. An entry may have only one
+ * editor at one time; if a value is not available to be edited then {@link #edit} will return null.
  *
  * <ul>
- *     <li>When an entry is being <strong>created</strong> it is necessary to supply a full set of
- *         values; the empty value should be used as a placeholder if necessary.
- *     <li>When an entry is being <strong>edited</strong>, it is not necessary to supply data for
- *         every value; values default to their previous value.
+ * <li>When an entry is being <strong>created</strong> it is necessary to supply a full set of
+ * values; the empty value should be used as a placeholder if necessary.
+ * <li>When an entry is being <strong>edited</strong>, it is not necessary to supply data for every
+ * value; values default to their previous value.
  * </ul>
  *
- * <p>Every {@link #edit} call must be matched by a call to {@link Editor#commit} or {@link
- * Editor#abort}. Committing is atomic: a read observes the full set of values as they were before
- * or after the commit, but never a mix of values.
+ * <p>
+ * Every {@link #edit} call must be matched by a call to {@link Editor#commit} or
+ * {@link Editor#abort}. Committing is atomic: a read observes the full set of values as they were
+ * before or after the commit, but never a mix of values.
  *
- * <p>Clients call {@link #get} to read a snapshot of an entry. The read will observe the value at
- * the time that {@link #get} was called. Updates and removals after the call do not impact ongoing
+ * <p>
+ * Clients call {@link #get} to read a snapshot of an entry. The read will observe the value at the
+ * time that {@link #get} was called. Updates and removals after the call do not impact ongoing
  * reads.
  *
- * <p>This class is tolerant of some I/O errors. If files are missing from the filesystem, the
+ * <p>
+ * This class is tolerant of some I/O errors. If files are missing from the filesystem, the
  * corresponding entries will be dropped from the cache. If an error occurs while writing a cache
  * value, the edit will fail silently. Callers should handle other problems by catching {@code
  * IOException} and responding appropriately.
@@ -96,45 +99,32 @@
   private static final String REMOVE = "REMOVE";
   private static final String READ = "READ";
 
-    /*
-     * This cache uses a journal file named "journal". A typical journal file
-     * looks like this:
-     *     libcore.io.DiskLruCache
-     *     1
-     *     100
-     *     2
-     *
-     *     CLEAN 3400330d1dfc7f3f7f4b8d4d803dfcf6 832 21054
-     *     DIRTY 335c4c6028171cfddfbaae1a9c313c52
-     *     CLEAN 335c4c6028171cfddfbaae1a9c313c52 3934 2342
-     *     REMOVE 335c4c6028171cfddfbaae1a9c313c52
-     *     DIRTY 1ab96a171faeeee38496d8b330771a7a
-     *     CLEAN 1ab96a171faeeee38496d8b330771a7a 1600 234
-     *     READ 335c4c6028171cfddfbaae1a9c313c52
-     *     READ 3400330d1dfc7f3f7f4b8d4d803dfcf6
-     *
-     * The first five lines of the journal form its header. They are the
-     * constant string "libcore.io.DiskLruCache", the disk cache's version,
-     * the application's version, the value count, and a blank line.
-     *
-     * Each of the subsequent lines in the file is a record of the state of a
-     * cache entry. Each line contains space-separated values: a state, a key,
-     * and optional state-specific values.
-     *   o DIRTY lines track that an entry is actively being created or updated.
-     *     Every successful DIRTY action should be followed by a CLEAN or REMOVE
-     *     action. DIRTY lines without a matching CLEAN or REMOVE indicate that
-     *     temporary files may need to be deleted.
-     *   o CLEAN lines track a cache entry that has been successfully published
-     *     and may be read. A publish line is followed by the lengths of each of
-     *     its values.
-     *   o READ lines track accesses for LRU.
-     *   o REMOVE lines track entries that have been deleted.
-     *
-     * The journal file is appended to as cache operations occur. The journal may
-     * occasionally be compacted by dropping redundant lines. A temporary file named
-     * "journal.tmp" will be used during compaction; that file should be deleted if
-     * it exists when the cache is opened.
-     */
+  /*
+   * This cache uses a journal file named "journal". A typical journal file looks like this:
+   * libcore.io.DiskLruCache 1 100 2
+   *
+   * CLEAN 3400330d1dfc7f3f7f4b8d4d803dfcf6 832 21054 DIRTY 335c4c6028171cfddfbaae1a9c313c52 CLEAN
+   * 335c4c6028171cfddfbaae1a9c313c52 3934 2342 REMOVE 335c4c6028171cfddfbaae1a9c313c52 DIRTY
+   * 1ab96a171faeeee38496d8b330771a7a CLEAN 1ab96a171faeeee38496d8b330771a7a 1600 234 READ
+   * 335c4c6028171cfddfbaae1a9c313c52 READ 3400330d1dfc7f3f7f4b8d4d803dfcf6
+   *
+   * The first five lines of the journal form its header. They are the constant string
+   * "libcore.io.DiskLruCache", the disk cache's version, the application's version, the value
+   * count, and a blank line.
+   *
+   * Each of the subsequent lines in the file is a record of the state of a cache entry. Each line
+   * contains space-separated values: a state, a key, and optional state-specific values. o DIRTY
+   * lines track that an entry is actively being created or updated. Every successful DIRTY action
+   * should be followed by a CLEAN or REMOVE action. DIRTY lines without a matching CLEAN or REMOVE
+   * indicate that temporary files may need to be deleted. o CLEAN lines track a cache entry that
+   * has been successfully published and may be read. A publish line is followed by the lengths of
+   * each of its values. o READ lines track accesses for LRU. o REMOVE lines track entries that have
+   * been deleted.
+   *
+   * The journal file is appended to as cache operations occur. The journal may occasionally be
+   * compacted by dropping redundant lines. A temporary file named "journal.tmp" will be used during
+   * compaction; that file should be deleted if it exists when the cache is opened.
+   */
 
   private final FileSystem fileSystem;
   private final File directory;
@@ -146,7 +136,8 @@
   private final int valueCount;
   private long size = 0;
   private BufferedSink journalWriter;
-  private final LinkedHashMap<String, Entry> lruEntries = new LinkedHashMap<>(0, 0.75f, true);
+  private final LinkedHashMap<String, Entry> lruEntries =
+      new LinkedHashMap<String, Entry>(0, 0.75f, true);
   private int redundantOpCount;
   private boolean hasJournalErrors;
 
@@ -273,11 +264,9 @@ private void readJournal() throws IOException {
       String appVersionString = source.readUtf8LineStrict();
       String valueCountString = source.readUtf8LineStrict();
       String blank = source.readUtf8LineStrict();
-      if (!MAGIC.equals(magic)
-          || !VERSION_1.equals(version)
+      if (!MAGIC.equals(magic) || !VERSION_1.equals(version)
           || !Integer.toString(appVersion).equals(appVersionString)
-          || !Integer.toString(valueCount).equals(valueCountString)
-          || !"".equals(blank)) {
+          || !Integer.toString(valueCount).equals(valueCountString) || !"".equals(blank)) {
         throw new IOException("unexpected journal header: [" + magic + ", " + version + ", "
             + valueCountString + ", " + blank + "]");
       }
@@ -307,7 +296,8 @@ private void readJournal() throws IOException {
   private BufferedSink newJournalWriter() throws FileNotFoundException {
     Sink fileSink = fileSystem.appendingSink(journalFile);
     Sink faultHidingSink = new FaultHidingSink(fileSink) {
-      @Override protected void onException(IOException e) {
+      @Override
+      protected void onException(IOException e) {
         assert (Thread.holdsLock(DiskLruCache.this));
         hasJournalErrors = true;
       }
@@ -360,7 +350,7 @@ private void readJournalLine(String line) throws IOException {
    */
   private void processJournal() throws IOException {
     fileSystem.delete(journalFileTmp);
-    for (Iterator<Entry> i = lruEntries.values().iterator(); i.hasNext(); ) {
+    for (Iterator<Entry> i = lruEntries.values().iterator(); i.hasNext();) {
       Entry entry = i.next();
       if (entry.currentEditor == null) {
         for (int t = 0; t < valueCount; t++) {
@@ -431,10 +421,12 @@ public synchronized Snapshot get(String key) throws IOException {
     checkNotClosed();
     validateKey(key);
     Entry entry = lruEntries.get(key);
-    if (entry == null || !entry.readable) return null;
+    if (entry == null || !entry.readable)
+      return null;
 
     Snapshot snapshot = entry.snapshot();
-    if (snapshot == null) return null;
+    if (snapshot == null)
+      return null;
 
     redundantOpCount++;
     journalWriter.writeUtf8(READ).writeByte(' ').writeUtf8(key).writeByte('\n');
@@ -458,8 +450,8 @@ private synchronized Editor edit(String key, long expectedSequenceNumber) throws
     checkNotClosed();
     validateKey(key);
     Entry entry = lruEntries.get(key);
-    if (expectedSequenceNumber != ANY_SEQUENCE_NUMBER && (entry == null
-        || entry.sequenceNumber != expectedSequenceNumber)) {
+    if (expectedSequenceNumber != ANY_SEQUENCE_NUMBER
+        && (entry == null || entry.sequenceNumber != expectedSequenceNumber)) {
       return null; // Snapshot is stale.
     }
     if (entry != null && entry.currentEditor != null) {
@@ -590,8 +582,7 @@ private synchronized void completeEdit(Editor editor, boolean success) throws IO
    */
   private boolean journalRebuildRequired() {
     final int redundantOpCompactThreshold = 2000;
-    return redundantOpCount >= redundantOpCompactThreshold
-        && redundantOpCount >= lruEntries.size();
+    return redundantOpCount >= redundantOpCompactThreshold && redundantOpCount >= lruEntries.size();
   }
 
   /**
@@ -606,9 +597,11 @@ public synchronized boolean remove(String key) throws IOException {
     checkNotClosed();
     validateKey(key);
     Entry entry = lruEntries.get(key);
-    if (entry == null) return false;
+    if (entry == null)
+      return false;
     boolean removed = removeEntry(entry);
-    if (removed && size <= maxSize) mostRecentTrimFailed = false;
+    if (removed && size <= maxSize)
+      mostRecentTrimFailed = false;
     return removed;
   }
 
@@ -646,8 +639,10 @@ private synchronized void checkNotClosed() {
   }
 
   /** Force buffered operations to the filesystem. */
-  @Override public synchronized void flush() throws IOException {
-    if (!initialized) return;
+  @Override
+  public synchronized void flush() throws IOException {
+    if (!initialized)
+      return;
 
     checkNotClosed();
     trimToSize();
@@ -655,7 +650,8 @@ private synchronized void checkNotClosed() {
   }
 
   /** Closes this cache. Stored values will remain on the filesystem. */
-  @Override public synchronized void close() throws IOException {
+  @Override
+  public synchronized void close() throws IOException {
     if (!initialized || closed) {
       closed = true;
       return;
@@ -716,20 +712,23 @@ private void validateKey(String key) {
    * entries will not be returned by the iterator. If existing entries are removed during iteration,
    * they will be absent (unless they were already returned).
    *
-   * <p>If there are I/O problems during iteration, this iterator fails silently. For example, if
-   * the hosting filesystem becomes unreachable, the iterator will omit elements rather than
-   * throwing exceptions.
+   * <p>
+   * If there are I/O problems during iteration, this iterator fails silently. For example, if the
+   * hosting filesystem becomes unreachable, the iterator will omit elements rather than throwing
+   * exceptions.
    *
-   * <p><strong>The caller must {@link Snapshot#close close}</strong> each snapshot returned by
+   * <p>
+   * <strong>The caller must {@link Snapshot#close close}</strong> each snapshot returned by
    * {@link Iterator#next}. Failing to do so leaks open files!
    *
-   * <p>The returned iterator supports {@link Iterator#remove}.
+   * <p>
+   * The returned iterator supports {@link Iterator#remove}.
    */
   public synchronized Iterator<Snapshot> snapshots() throws IOException {
     initialize();
     return new Iterator<Snapshot>() {
       /** Iterate a copy of the entries to defend against concurrent modification errors. */
-      final Iterator<Entry> delegate = new ArrayList<>(lruEntries.values()).iterator();
+      final Iterator<Entry> delegate = new ArrayList<Entry>(lruEntries.values()).iterator();
 
       /** The snapshot to return from {@link #next}. Null if we haven't computed that yet. */
       Snapshot nextSnapshot;
@@ -737,17 +736,21 @@ private void validateKey(String key) {
       /** The snapshot to remove with {@link #remove}. Null if removal is illegal. */
       Snapshot removeSnapshot;
 
-      @Override public boolean hasNext() {
-        if (nextSnapshot != null) return true;
+      @Override
+      public boolean hasNext() {
+        if (nextSnapshot != null)
+          return true;
 
         synchronized (DiskLruCache.this) {
           // If the cache is closed, truncate the iterator.
-          if (closed) return false;
+          if (closed)
+            return false;
 
           while (delegate.hasNext()) {
             Entry entry = delegate.next();
             Snapshot snapshot = entry.snapshot();
-            if (snapshot == null) continue; // Evicted since we copied the entries.
+            if (snapshot == null)
+              continue; // Evicted since we copied the entries.
             nextSnapshot = snapshot;
             return true;
           }
@@ -756,15 +759,19 @@ private void validateKey(String key) {
         return false;
       }
 
-      @Override public Snapshot next() {
-        if (!hasNext()) throw new NoSuchElementException();
+      @Override
+      public Snapshot next() {
+        if (!hasNext())
+          throw new NoSuchElementException();
         removeSnapshot = nextSnapshot;
         nextSnapshot = null;
         return removeSnapshot;
       }
 
-      @Override public void remove() {
-        if (removeSnapshot == null) throw new IllegalStateException("remove() before next()");
+      @Override
+      public void remove() {
+        if (removeSnapshot == null)
+          throw new IllegalStateException("remove() before next()");
         try {
           DiskLruCache.this.remove(removeSnapshot.key);
         } catch (IOException ignored) {
@@ -821,19 +828,21 @@ public void close() {
   }
 
   private static final Sink NULL_SINK = new Sink() {
-    @Override public void write(Buffer source, long byteCount) throws IOException {
+    @Override
+    public void write(Buffer source, long byteCount) throws IOException {
       source.skip(byteCount);
     }
 
-    @Override public void flush() throws IOException {
-    }
+    @Override
+    public void flush() throws IOException { }
 
-    @Override public Timeout timeout() {
+    @Override
+    public Timeout timeout() {
       return Timeout.NONE;
     }
 
-    @Override public void close() throws IOException {
-    }
+    @Override
+    public void close() throws IOException { }
   };
 
   /** Edits the values for an entry. */
@@ -910,7 +919,8 @@ public Sink newSink(int index) throws IOException {
           return NULL_SINK;
         }
         return new FaultHidingSink(sink) {
-          @Override protected void onException(IOException e) {
+          @Override
+          protected void onException(IOException e) {
             synchronized (DiskLruCache.this) {
               detach();
             }
@@ -920,7 +930,7 @@ public Sink newSink(int index) throws IOException {
     }
 
     /**
-     * Commits this edit so it is visible to readers.  This releases the edit lock so another edit
+     * Commits this edit so it is visible to readers. This releases the edit lock so another edit
      * may be started on the same key.
      */
     public void commit() throws IOException {
@@ -936,8 +946,7 @@ public void commit() throws IOException {
     }
 
     /**
-     * Aborts this edit. This releases the edit lock so another edit may be started on the same
-     * key.
+     * Aborts this edit. This releases the edit lock so another edit may be started on the same key.
      */
     public void abort() throws IOException {
       synchronized (DiskLruCache.this) {
@@ -1031,7 +1040,8 @@ private IOException invalidLengths(String[] strings) throws IOException {
      * different edits.
      */
     Snapshot snapshot() {
-      if (!Thread.holdsLock(DiskLruCache.this)) throw new AssertionError();
+      if (!Thread.holdsLock(DiskLruCache.this))
+        throw new AssertionError();
 
       Source[] sources = new Source[valueCount];
       long[] lengths = this.lengths.clone(); // Defensive copy since these can be zeroed out.
diff --git a/okhttp/src/main/java/okhttp3/internal/Jdk9Platform.java b/okhttp/src/main/java/okhttp3/internal/Jdk9Platform.java
index 1cd04f965a..ae64b5da25 100644
--- a/okhttp/src/main/java/okhttp3/internal/Jdk9Platform.java
+++ b/okhttp/src/main/java/okhttp3/internal/Jdk9Platform.java
@@ -48,7 +48,9 @@ public void configureTlsExtensions(SSLSocket sslSocket, String hostname,
           new Object[] {names.toArray(new String[names.size()])});
 
       sslSocket.setSSLParameters(sslParameters);
-    } catch (IllegalAccessException | InvocationTargetException e) {
+    } catch (IllegalAccessException e) {
+      throw new AssertionError();
+    } catch (InvocationTargetException e) {
       throw new AssertionError();
     }
   }
@@ -65,7 +67,11 @@ public String getSelectedProtocol(SSLSocket socket) {
       }
 
       return protocol;
-    } catch (IllegalAccessException | InvocationTargetException e) {
+    } catch (IllegalAccessException e) {
+      throw new AssertionError();
+    } catch (IllegalArgumentException e) {
+      throw new AssertionError();
+    } catch (InvocationTargetException e) {
       throw new AssertionError();
     }
   }
diff --git a/okhttp/src/main/java/okhttp3/internal/JdkWithJettyBootPlatform.java b/okhttp/src/main/java/okhttp3/internal/JdkWithJettyBootPlatform.java
index 5e5e5a43f6..99e3de17e4 100644
--- a/okhttp/src/main/java/okhttp3/internal/JdkWithJettyBootPlatform.java
+++ b/okhttp/src/main/java/okhttp3/internal/JdkWithJettyBootPlatform.java
@@ -1,17 +1,15 @@
 /*
  * Copyright (C) 2016 Square, Inc.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+ * in compliance with the License. You may obtain a copy of the License at
  *
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
  */
 package okhttp3.internal;
 
@@ -20,7 +18,9 @@
 import java.lang.reflect.Method;
 import java.lang.reflect.Proxy;
 import java.util.List;
+
 import javax.net.ssl.SSLSocket;
+
 import okhttp3.Protocol;
 
 /**
@@ -42,28 +42,35 @@ public JdkWithJettyBootPlatform(Method putMethod, Method getMethod, Method remov
     this.serverProviderClass = serverProviderClass;
   }
 
-  @Override public void configureTlsExtensions(
-      SSLSocket sslSocket, String hostname, List<Protocol> protocols) {
+  @Override
+  public void configureTlsExtensions(SSLSocket sslSocket, String hostname,
+      List<Protocol> protocols) {
     List<String> names = alpnProtocolNames(protocols);
 
     try {
       Object provider = Proxy.newProxyInstance(Platform.class.getClassLoader(),
           new Class[] {clientProviderClass, serverProviderClass}, new JettyNegoProvider(names));
       putMethod.invoke(null, sslSocket, provider);
-    } catch (InvocationTargetException | IllegalAccessException e) {
+    } catch (InvocationTargetException e) {
+      throw new AssertionError(e);
+    } catch (IllegalAccessException e) {
       throw new AssertionError(e);
     }
   }
 
-  @Override public void afterHandshake(SSLSocket sslSocket) {
+  @Override
+  public void afterHandshake(SSLSocket sslSocket) {
     try {
       removeMethod.invoke(null, sslSocket);
-    } catch (IllegalAccessException | InvocationTargetException ignored) {
+    } catch (IllegalAccessException e) {
+      throw new AssertionError();
+    } catch (InvocationTargetException ignored) {
       throw new AssertionError();
     }
   }
 
-  @Override public String getSelectedProtocol(SSLSocket socket) {
+  @Override
+  public String getSelectedProtocol(SSLSocket socket) {
     try {
       JettyNegoProvider provider =
           (JettyNegoProvider) Proxy.getInvocationHandler(getMethod.invoke(null, socket));
@@ -73,7 +80,9 @@ public JdkWithJettyBootPlatform(Method putMethod, Method getMethod, Method remov
         return null;
       }
       return provider.unsupported ? null : provider.selected;
-    } catch (InvocationTargetException | IllegalAccessException e) {
+    } catch (IllegalAccessException e) {
+      throw new AssertionError();
+    } catch (InvocationTargetException ignored) {
       throw new AssertionError();
     }
   }
@@ -89,9 +98,13 @@ public static Platform buildIfSupported() {
       Method putMethod = negoClass.getMethod("put", SSLSocket.class, providerClass);
       Method getMethod = negoClass.getMethod("get", SSLSocket.class);
       Method removeMethod = negoClass.getMethod("remove", SSLSocket.class);
-      return new JdkWithJettyBootPlatform(
-          putMethod, getMethod, removeMethod, clientProviderClass, serverProviderClass);
-    } catch (ClassNotFoundException | NoSuchMethodException ignored) {
+      return new JdkWithJettyBootPlatform(putMethod, getMethod, removeMethod, clientProviderClass,
+          serverProviderClass);
+    } catch (ClassNotFoundException e) {
+      throw new AssertionError();
+    } catch (NoSuchMethodException e) {
+      // TODO Auto-generated catch block
+      e.printStackTrace();
     }
 
     return null;
@@ -113,7 +126,8 @@ public JettyNegoProvider(List<String> protocols) {
       this.protocols = protocols;
     }
 
-    @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
+    @Override
+    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
       String methodName = method.getName();
       Class<?> returnType = method.getReturnType();
       if (args == null) {
diff --git a/okhttp/src/main/java/okhttp3/internal/Platform.java b/okhttp/src/main/java/okhttp3/internal/Platform.java
index 34da83c0d2..9a9106ab77 100644
--- a/okhttp/src/main/java/okhttp3/internal/Platform.java
+++ b/okhttp/src/main/java/okhttp3/internal/Platform.java
@@ -131,7 +131,7 @@ public boolean isCleartextTrafficPermitted() {
   }
 
   public static List<String> alpnProtocolNames(List<Protocol> protocols) {
-    List<String> names = new ArrayList<>(protocols.size());
+    List<String> names = new ArrayList<String>(protocols.size());
     for (int i = 0, size = protocols.size(); i < size; i++) {
       Protocol protocol = protocols.get(i);
       if (protocol == Protocol.HTTP_1_0) continue; // No HTTP/1.0 for ALPN.
diff --git a/okhttp/src/main/java/okhttp3/internal/RouteDatabase.java b/okhttp/src/main/java/okhttp3/internal/RouteDatabase.java
index 613e0bf215..867496c145 100644
--- a/okhttp/src/main/java/okhttp3/internal/RouteDatabase.java
+++ b/okhttp/src/main/java/okhttp3/internal/RouteDatabase.java
@@ -26,7 +26,7 @@
  * preferred.
  */
 public final class RouteDatabase {
-  private final Set<Route> failedRoutes = new LinkedHashSet<>();
+  private final Set<Route> failedRoutes = new LinkedHashSet<Route>();
 
   /** Records a failure connecting to {@code failedRoute}. */
   public synchronized void failed(Route failedRoute) {
diff --git a/okhttp/src/main/java/okhttp3/internal/Util.java b/okhttp/src/main/java/okhttp3/internal/Util.java
index 0d72116405..a23ad15620 100644
--- a/okhttp/src/main/java/okhttp3/internal/Util.java
+++ b/okhttp/src/main/java/okhttp3/internal/Util.java
@@ -1,17 +1,15 @@
 /*
  * Copyright (C) 2012 The Android Open Source Project
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+ * in compliance with the License. You may obtain a copy of the License at
  *
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
  */
 package okhttp3.internal;
 
@@ -37,6 +35,7 @@
 import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.TimeUnit;
 import java.util.regex.Pattern;
+
 import okhttp3.HttpUrl;
 import okio.Buffer;
 import okio.ByteString;
@@ -57,17 +56,17 @@
    * Quick and dirty pattern to differentiate IP addresses from hostnames. This is an approximation
    * of Android's private InetAddress#isNumeric API.
    *
-   * <p>This matches IPv6 addresses as a hex string containing at least one colon, and possibly
+   * <p>
+   * This matches IPv6 addresses as a hex string containing at least one colon, and possibly
    * including dots after the first colon. It matches IPv4 addresses as strings containing only
    * decimal digits and dots. This pattern matches strings like "a:.23" and "54" that are neither IP
    * addresses nor hostnames; they will be verified as IP addresses (which is a more strict
    * verification).
    */
-  private static final Pattern VERIFY_AS_IP_ADDRESS = Pattern.compile(
-      "([0-9a-fA-F]*:[0-9a-fA-F:.]*)|([\\d.]+)");
+  private static final Pattern VERIFY_AS_IP_ADDRESS =
+      Pattern.compile("([0-9a-fA-F]*:[0-9a-fA-F:.]*)|([\\d.]+)");
 
-  private Util() {
-  }
+  private Util() { }
 
   public static void checkOffsetAndCount(long arrayLength, long offset, long count) {
     if ((offset | count) < 0 || offset > arrayLength || arrayLength - offset < count) {
@@ -96,15 +95,15 @@ public static void closeQuietly(Closeable closeable) {
   }
 
   /**
-   * Closes {@code socket}, ignoring any checked exceptions. Does nothing if {@code socket} is
-   * null.
+   * Closes {@code socket}, ignoring any checked exceptions. Does nothing if {@code socket} is null.
    */
   public static void closeQuietly(Socket socket) {
     if (socket != null) {
       try {
         socket.close();
       } catch (AssertionError e) {
-        if (!isAndroidGetsocknameError(e)) throw e;
+        if (!isAndroidGetsocknameError(e))
+          throw e;
       } catch (RuntimeException rethrown) {
         throw rethrown;
       } catch (Exception ignored) {
@@ -141,12 +140,17 @@ public static void closeAll(Closeable a, Closeable b) throws IOException {
     try {
       b.close();
     } catch (Throwable e) {
-      if (thrown == null) thrown = e;
+      if (thrown == null)
+        thrown = e;
     }
-    if (thrown == null) return;
-    if (thrown instanceof IOException) throw (IOException) thrown;
-    if (thrown instanceof RuntimeException) throw (RuntimeException) thrown;
-    if (thrown instanceof Error) throw (Error) thrown;
+    if (thrown == null)
+      return;
+    if (thrown instanceof IOException)
+      throw (IOException) thrown;
+    if (thrown instanceof RuntimeException)
+      throw (RuntimeException) thrown;
+    if (thrown instanceof Error)
+      throw (Error) thrown;
     throw new AssertionError(thrown);
   }
 
@@ -169,9 +173,8 @@ public static boolean discard(Source source, int timeout, TimeUnit timeUnit) {
    */
   public static boolean skipAll(Source source, int duration, TimeUnit timeUnit) throws IOException {
     long now = System.nanoTime();
-    long originalDuration = source.timeout().hasDeadline()
-        ? source.timeout().deadlineNanoTime() - now
-        : Long.MAX_VALUE;
+    long originalDuration =
+        source.timeout().hasDeadline() ? source.timeout().deadlineNanoTime() - now : Long.MAX_VALUE;
     source.timeout().deadlineNanoTime(now + Math.min(originalDuration, timeUnit.toNanos(duration)));
     try {
       Buffer skipBuffer = new Buffer();
@@ -196,7 +199,9 @@ public static String md5Hex(String s) {
       MessageDigest messageDigest = MessageDigest.getInstance("MD5");
       byte[] md5bytes = messageDigest.digest(s.getBytes("UTF-8"));
       return ByteString.of(md5bytes).hex();
-    } catch (NoSuchAlgorithmException | UnsupportedEncodingException e) {
+    } catch (NoSuchAlgorithmException e) {
+      throw new AssertionError(e);
+    } catch (UnsupportedEncodingException e) {
       throw new AssertionError(e);
     }
   }
@@ -207,7 +212,9 @@ public static String shaBase64(String s) {
       MessageDigest messageDigest = MessageDigest.getInstance("SHA-1");
       byte[] sha1Bytes = messageDigest.digest(s.getBytes("UTF-8"));
       return ByteString.of(sha1Bytes).base64();
-    } catch (NoSuchAlgorithmException | UnsupportedEncodingException e) {
+    } catch (NoSuchAlgorithmException e) {
+      throw new AssertionError(e);
+    } catch (UnsupportedEncodingException e) {
       throw new AssertionError(e);
     }
   }
@@ -236,7 +243,7 @@ public static ByteString sha256(ByteString s) {
 
   /** Returns an immutable copy of {@code list}. */
   public static <T> List<T> immutableList(List<T> list) {
-    return Collections.unmodifiableList(new ArrayList<>(list));
+    return Collections.unmodifiableList(new ArrayList<T>(list));
   }
 
   /** Returns an immutable list containing {@code elements}. */
@@ -246,12 +253,13 @@ public static ByteString sha256(ByteString s) {
 
   /** Returns an immutable copy of {@code map}. */
   public static <K, V> Map<K, V> immutableMap(Map<K, V> map) {
-    return Collections.unmodifiableMap(new LinkedHashMap<>(map));
+    return Collections.unmodifiableMap(new LinkedHashMap<K, V>(map));
   }
 
   public static ThreadFactory threadFactory(final String name, final boolean daemon) {
     return new ThreadFactory() {
-      @Override public Thread newThread(Runnable runnable) {
+      @Override
+      public Thread newThread(Runnable runnable) {
         Thread result = new Thread(runnable, name);
         result.setDaemon(daemon);
         return result;
@@ -260,7 +268,7 @@ public static ThreadFactory threadFactory(final String name, final boolean daemo
   }
 
   /**
-   * Returns an array containing containing only elements found in {@code first}  and also in {@code
+   * Returns an array containing containing only elements found in {@code first} and also in {@code
    * second}. The returned elements are in the same order as in {@code first}.
    */
   @SuppressWarnings("unchecked")
@@ -270,11 +278,11 @@ public static ThreadFactory threadFactory(final String name, final boolean daemo
   }
 
   /**
-   * Returns a list containing containing only elements found in {@code first}  and also in {@code
+   * Returns a list containing containing only elements found in {@code first} and also in {@code
    * second}. The returned elements are in the same order as in {@code first}.
    */
   private static <T> List<T> intersect(T[] first, T[] second) {
-    List<T> result = new ArrayList<>();
+    List<T> result = new ArrayList<T>();
     for (T a : first) {
       for (T b : second) {
         if (a.equals(b)) {
@@ -287,19 +295,17 @@ public static ThreadFactory threadFactory(final String name, final boolean daemo
   }
 
   public static String hostHeader(HttpUrl url, boolean includeDefaultPort) {
-    String host = url.host().contains(":")
-        ? "[" + url.host() + "]"
-        : url.host();
+    String host = url.host().contains(":") ? "[" + url.host() + "]" : url.host();
     return includeDefaultPort || url.port() != HttpUrl.defaultPort(url.scheme())
-        ? host + ":" + url.port()
-        : host;
+        ? host + ":" + url.port() : host;
   }
 
   /** Returns {@code s} with control characters and non-ASCII characters replaced with '?'. */
   public static String toHumanReadableAscii(String s) {
     for (int i = 0, length = s.length(), c; i < length; i += Character.charCount(c)) {
       c = s.codePointAt(i);
-      if (c > '\u001f' && c < '\u007f') continue;
+      if (c > '\u001f' && c < '\u007f')
+        continue;
 
       Buffer buffer = new Buffer();
       buffer.writeUtf8(s, 0, i);
@@ -385,7 +391,8 @@ public static String trimSubstring(String string, int pos, int limit) {
    */
   public static int delimiterOffset(String input, int pos, int limit, String delimiters) {
     for (int i = pos; i < limit; i++) {
-      if (delimiters.indexOf(input.charAt(i)) != -1) return i;
+      if (delimiters.indexOf(input.charAt(i)) != -1)
+        return i;
     }
     return limit;
   }
@@ -396,7 +403,8 @@ public static int delimiterOffset(String input, int pos, int limit, String delim
    */
   public static int delimiterOffset(String input, int pos, int limit, char delimiter) {
     for (int i = pos; i < limit; i++) {
-      if (input.charAt(i) == delimiter) return i;
+      if (input.charAt(i) == delimiter)
+        return i;
     }
     return limit;
   }
@@ -404,13 +412,14 @@ public static int delimiterOffset(String input, int pos, int limit, char delimit
   /**
    * Performs IDN ToASCII encoding and canonicalize the result to lowercase. e.g. This converts
    * {@code ☃.net} to {@code xn--n3h.net}, and {@code WwW.GoOgLe.cOm} to {@code www.google.com}.
-   * {@code null} will be returned if the input cannot be ToASCII encoded or if the result
-   * contains unsupported ASCII characters.
+   * {@code null} will be returned if the input cannot be ToASCII encoded or if the result contains
+   * unsupported ASCII characters.
    */
   public static String domainToAscii(String input) {
     try {
       String result = IDN.toASCII(input).toLowerCase(Locale.US);
-      if (result.isEmpty()) return null;
+      if (result.isEmpty())
+        return null;
 
       // Confirm that the IDN ToASCII result doesn't contain any illegal characters.
       if (containsInvalidHostnameAsciiCodes(result)) {
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/FramedConnection.java b/okhttp/src/main/java/okhttp3/internal/framed/FramedConnection.java
index 90c8e38057..971a782114 100644
--- a/okhttp/src/main/java/okhttp3/internal/framed/FramedConnection.java
+++ b/okhttp/src/main/java/okhttp3/internal/framed/FramedConnection.java
@@ -81,7 +81,7 @@
    * on {@link #executor}.
    */
   private final Listener listener;
-  private final Map<Integer, FramedStream> streams = new HashMap<>();
+  private final Map<Integer, FramedStream> streams = new HashMap<Integer, FramedStream>();
   private final String hostname;
   private int lastGoodStreamId;
   private int nextStreamId;
@@ -381,7 +381,7 @@ public Ping ping() throws IOException {
       }
       pingId = nextPingId;
       nextPingId += 2;
-      if (pings == null) pings = new HashMap<>();
+      if (pings == null) pings = new HashMap<Integer, Ping>();
       pings.put(pingId, ping);
     }
     writePing(false, pingId, 0x4f4b6f6b /* ASCII "OKok" */, ping);
@@ -836,7 +836,7 @@ private boolean pushedStream(int streamId) {
   }
 
   // Guarded by this.
-  private final Set<Integer> currentPushRequests = new LinkedHashSet<>();
+  private final Set<Integer> currentPushRequests = new LinkedHashSet<Integer>();
 
   private void pushRequestLater(final int streamId, final List<Header> requestHeaders) {
     synchronized (this) {
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/FramedStream.java b/okhttp/src/main/java/okhttp3/internal/framed/FramedStream.java
index d6ce15eeb6..34c1fc7d1f 100644
--- a/okhttp/src/main/java/okhttp3/internal/framed/FramedStream.java
+++ b/okhttp/src/main/java/okhttp3/internal/framed/FramedStream.java
@@ -266,7 +266,7 @@ void receiveHeaders(List<Header> headers, HeadersMode headersMode) {
         if (headersMode.failIfHeadersPresent()) {
           errorCode = ErrorCode.STREAM_IN_USE;
         } else {
-          List<Header> newHeaders = new ArrayList<>();
+          List<Header> newHeaders = new ArrayList<Header>();
           newHeaders.addAll(responseHeaders);
           newHeaders.addAll(headers);
           this.responseHeaders = newHeaders;
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/Hpack.java b/okhttp/src/main/java/okhttp3/internal/framed/Hpack.java
index 2b49784e9b..72d52b7d75 100644
--- a/okhttp/src/main/java/okhttp3/internal/framed/Hpack.java
+++ b/okhttp/src/main/java/okhttp3/internal/framed/Hpack.java
@@ -1,17 +1,15 @@
 /*
  * Copyright (C) 2013 Square, Inc.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+ * in compliance with the License. You may obtain a copy of the License at
  *
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
  */
 package okhttp3.internal.framed;
 
@@ -33,8 +31,8 @@
  *
  * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12
  *
- * This implementation uses an array for the dynamic table and a list for indexed entries.  Dynamic
- * entries are added to the array, starting in the last position moving forward.  When the array
+ * This implementation uses an array for the dynamic table and a list for indexed entries. Dynamic
+ * entries are added to the array, starting in the last position moving forward. When the array
  * fills, it is doubled.
  */
 final class Hpack {
@@ -44,76 +42,39 @@
   private static final int PREFIX_7_BITS = 0x7f;
 
   private static final Header[] STATIC_HEADER_TABLE = new Header[] {
-      new Header(Header.TARGET_AUTHORITY, ""),
-      new Header(Header.TARGET_METHOD, "GET"),
-      new Header(Header.TARGET_METHOD, "POST"),
-      new Header(Header.TARGET_PATH, "/"),
-      new Header(Header.TARGET_PATH, "/index.html"),
-      new Header(Header.TARGET_SCHEME, "http"),
-      new Header(Header.TARGET_SCHEME, "https"),
-      new Header(Header.RESPONSE_STATUS, "200"),
-      new Header(Header.RESPONSE_STATUS, "204"),
-      new Header(Header.RESPONSE_STATUS, "206"),
-      new Header(Header.RESPONSE_STATUS, "304"),
-      new Header(Header.RESPONSE_STATUS, "400"),
-      new Header(Header.RESPONSE_STATUS, "404"),
-      new Header(Header.RESPONSE_STATUS, "500"),
-      new Header("accept-charset", ""),
-      new Header("accept-encoding", "gzip, deflate"),
-      new Header("accept-language", ""),
-      new Header("accept-ranges", ""),
-      new Header("accept", ""),
-      new Header("access-control-allow-origin", ""),
-      new Header("age", ""),
-      new Header("allow", ""),
-      new Header("authorization", ""),
-      new Header("cache-control", ""),
-      new Header("content-disposition", ""),
-      new Header("content-encoding", ""),
-      new Header("content-language", ""),
-      new Header("content-length", ""),
-      new Header("content-location", ""),
-      new Header("content-range", ""),
-      new Header("content-type", ""),
-      new Header("cookie", ""),
-      new Header("date", ""),
-      new Header("etag", ""),
-      new Header("expect", ""),
-      new Header("expires", ""),
-      new Header("from", ""),
-      new Header("host", ""),
-      new Header("if-match", ""),
-      new Header("if-modified-since", ""),
-      new Header("if-none-match", ""),
-      new Header("if-range", ""),
-      new Header("if-unmodified-since", ""),
-      new Header("last-modified", ""),
-      new Header("link", ""),
-      new Header("location", ""),
-      new Header("max-forwards", ""),
-      new Header("proxy-authenticate", ""),
-      new Header("proxy-authorization", ""),
-      new Header("range", ""),
-      new Header("referer", ""),
-      new Header("refresh", ""),
-      new Header("retry-after", ""),
-      new Header("server", ""),
-      new Header("set-cookie", ""),
-      new Header("strict-transport-security", ""),
-      new Header("transfer-encoding", ""),
-      new Header("user-agent", ""),
-      new Header("vary", ""),
-      new Header("via", ""),
-      new Header("www-authenticate", "")
-  };
-
-  private Hpack() {
-  }
+      new Header(Header.TARGET_AUTHORITY, ""), new Header(Header.TARGET_METHOD, "GET"),
+      new Header(Header.TARGET_METHOD, "POST"), new Header(Header.TARGET_PATH, "/"),
+      new Header(Header.TARGET_PATH, "/index.html"), new Header(Header.TARGET_SCHEME, "http"),
+      new Header(Header.TARGET_SCHEME, "https"), new Header(Header.RESPONSE_STATUS, "200"),
+      new Header(Header.RESPONSE_STATUS, "204"), new Header(Header.RESPONSE_STATUS, "206"),
+      new Header(Header.RESPONSE_STATUS, "304"), new Header(Header.RESPONSE_STATUS, "400"),
+      new Header(Header.RESPONSE_STATUS, "404"), new Header(Header.RESPONSE_STATUS, "500"),
+      new Header("accept-charset", ""), new Header("accept-encoding", "gzip, deflate"),
+      new Header("accept-language", ""), new Header("accept-ranges", ""), new Header("accept", ""),
+      new Header("access-control-allow-origin", ""), new Header("age", ""), new Header("allow", ""),
+      new Header("authorization", ""), new Header("cache-control", ""),
+      new Header("content-disposition", ""), new Header("content-encoding", ""),
+      new Header("content-language", ""), new Header("content-length", ""),
+      new Header("content-location", ""), new Header("content-range", ""),
+      new Header("content-type", ""), new Header("cookie", ""), new Header("date", ""),
+      new Header("etag", ""), new Header("expect", ""), new Header("expires", ""),
+      new Header("from", ""), new Header("host", ""), new Header("if-match", ""),
+      new Header("if-modified-since", ""), new Header("if-none-match", ""),
+      new Header("if-range", ""), new Header("if-unmodified-since", ""),
+      new Header("last-modified", ""), new Header("link", ""), new Header("location", ""),
+      new Header("max-forwards", ""), new Header("proxy-authenticate", ""),
+      new Header("proxy-authorization", ""), new Header("range", ""), new Header("referer", ""),
+      new Header("refresh", ""), new Header("retry-after", ""), new Header("server", ""),
+      new Header("set-cookie", ""), new Header("strict-transport-security", ""),
+      new Header("transfer-encoding", ""), new Header("user-agent", ""), new Header("vary", ""),
+      new Header("via", ""), new Header("www-authenticate", "")};
+
+  private Hpack() { }
 
   // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#section-3.1
   static final class Reader {
 
-    private final List<Header> headerList = new ArrayList<>();
+    private final List<Header> headerList = new ArrayList<Header>();
     private final BufferedSource source;
 
     private int headerTableSizeSetting;
@@ -140,7 +101,8 @@ int maxDynamicTableByteCount() {
      * establishes the maximum dynamic table size, the {@link #maxDynamicTableByteCount} set during
      * processing may limit the table size to a smaller amount.
      *
-     * <p>Evicts entries or clears the table as needed.
+     * <p>
+     * Evicts entries or clears the table as needed.
      */
     void headerTableSizeSetting(int headerTableSizeSetting) {
       this.headerTableSizeSetting = headerTableSizeSetting;
@@ -198,13 +160,12 @@ void readHeaders() throws IOException {
           readIndexedHeader(index - 1);
         } else if (b == 0x40) { // 01000000
           readLiteralHeaderWithIncrementalIndexingNewName();
-        } else if ((b & 0x40) == 0x40) {  // 01NNNNNN
+        } else if ((b & 0x40) == 0x40) { // 01NNNNNN
           int index = readInt(b, PREFIX_6_BITS);
           readLiteralHeaderWithIncrementalIndexingIndexedName(index - 1);
-        } else if ((b & 0x20) == 0x20) {  // 001NNNNN
+        } else if ((b & 0x20) == 0x20) { // 001NNNNN
           maxDynamicTableByteCount = readInt(b, PREFIX_5_BITS);
-          if (maxDynamicTableByteCount < 0
-              || maxDynamicTableByteCount > headerTableSizeSetting) {
+          if (maxDynamicTableByteCount < 0 || maxDynamicTableByteCount > headerTableSizeSetting) {
             throw new IOException("Invalid dynamic table size update " + maxDynamicTableByteCount);
           }
           adjustDynamicTableByteCount();
@@ -218,7 +179,7 @@ void readHeaders() throws IOException {
     }
 
     public List<Header> getAndResetHeaderList() {
-      List<Header> result = new ArrayList<>(headerList);
+      List<Header> result = new ArrayList<Header>(headerList);
       headerList.clear();
       return result;
     }
@@ -357,7 +318,8 @@ ByteString readByteString() throws IOException {
   private static final Map<ByteString, Integer> NAME_TO_FIRST_INDEX = nameToFirstIndex();
 
   private static Map<ByteString, Integer> nameToFirstIndex() {
-    Map<ByteString, Integer> result = new LinkedHashMap<>(STATIC_HEADER_TABLE.length);
+    Map<ByteString, Integer> result =
+        new LinkedHashMap<ByteString, Integer>(STATIC_HEADER_TABLE.length);
     for (int i = 0; i < STATIC_HEADER_TABLE.length; i++) {
       if (!result.containsKey(STATIC_HEADER_TABLE[i].name)) {
         result.put(STATIC_HEADER_TABLE[i].name, i);
@@ -420,8 +382,7 @@ void writeByteString(ByteString data) throws IOException {
   }
 
   /**
-   * An HTTP/2 response cannot contain uppercase header characters and must be treated as
-   * malformed.
+   * An HTTP/2 response cannot contain uppercase header characters and must be treated as malformed.
    */
   private static ByteString checkLowercase(ByteString name) throws IOException {
     for (int i = 0, length = name.size(); i < length; i++) {
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/NameValueBlockReader.java b/okhttp/src/main/java/okhttp3/internal/framed/NameValueBlockReader.java
index 75cd9594f7..22969e37e3 100644
--- a/okhttp/src/main/java/okhttp3/internal/framed/NameValueBlockReader.java
+++ b/okhttp/src/main/java/okhttp3/internal/framed/NameValueBlockReader.java
@@ -84,7 +84,7 @@ public NameValueBlockReader(BufferedSource source) {
     if (numberOfPairs < 0) throw new IOException("numberOfPairs < 0: " + numberOfPairs);
     if (numberOfPairs > 1024) throw new IOException("numberOfPairs > 1024: " + numberOfPairs);
 
-    List<Header> entries = new ArrayList<>(numberOfPairs);
+    List<Header> entries = new ArrayList<Header>(numberOfPairs);
     for (int i = 0; i < numberOfPairs; i++) {
       ByteString name = readByteString().toAsciiLowercase();
       ByteString values = readByteString();
diff --git a/okhttp/src/main/java/okhttp3/internal/http/Http2xStream.java b/okhttp/src/main/java/okhttp3/internal/http/Http2xStream.java
index 5c8fdfe667..7357af36a5 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/Http2xStream.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/Http2xStream.java
@@ -158,14 +158,14 @@ public Http2xStream(StreamAllocation streamAllocation, FramedConnection framedCo
    */
   public static List<Header> spdy3HeadersList(Request request) {
     Headers headers = request.headers();
-    List<Header> result = new ArrayList<>(headers.size() + 5);
+    List<Header> result = new ArrayList<Header>(headers.size() + 5);
     result.add(new Header(TARGET_METHOD, request.method()));
     result.add(new Header(TARGET_PATH, RequestLine.requestPath(request.url())));
     result.add(new Header(VERSION, "HTTP/1.1"));
     result.add(new Header(TARGET_HOST, Util.hostHeader(request.url(), false)));
     result.add(new Header(TARGET_SCHEME, request.url().scheme()));
 
-    Set<ByteString> names = new LinkedHashSet<>();
+    Set<ByteString> names = new LinkedHashSet<ByteString>();
     for (int i = 0, size = headers.size(); i < size; i++) {
       // header names must be lowercase.
       ByteString name = ByteString.encodeUtf8(headers.name(i).toLowerCase(Locale.US));
@@ -198,7 +198,7 @@ private static String joinOnNull(String first, String second) {
 
   public static List<Header> http2HeadersList(Request request) {
     Headers headers = request.headers();
-    List<Header> result = new ArrayList<>(headers.size() + 4);
+    List<Header> result = new ArrayList<Header>(headers.size() + 4);
     result.add(new Header(TARGET_METHOD, request.method()));
     result.add(new Header(TARGET_PATH, RequestLine.requestPath(request.url())));
     result.add(new Header(TARGET_AUTHORITY, Util.hostHeader(request.url(), false))); // Optional.
diff --git a/okhttp/src/main/java/okhttp3/internal/http/OkHeaders.java b/okhttp/src/main/java/okhttp3/internal/http/OkHeaders.java
index db8011c542..b61720ca03 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/OkHeaders.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/OkHeaders.java
@@ -117,7 +117,7 @@ public static boolean hasVaryAll(Headers responseHeaders) {
 
       String value = responseHeaders.value(i);
       if (result.isEmpty()) {
-        result = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);
+        result = new TreeSet<String>(String.CASE_INSENSITIVE_ORDER);
       }
       for (String varyField : value.split(",")) {
         result.add(varyField.trim());
@@ -181,7 +181,7 @@ static boolean isEndToEnd(String fieldName) {
     // challenge   = auth-scheme 1*SP 1#auth-param
     // realm       = "realm" "=" realm-value
     // realm-value = quoted-string
-    List<Challenge> result = new ArrayList<>();
+    List<Challenge> result = new ArrayList<Challenge>();
     for (int i = 0, size = responseHeaders.size(); i < size; i++) {
       if (!challengeHeader.equalsIgnoreCase(responseHeaders.name(i))) {
         continue;
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RouteException.java b/okhttp/src/main/java/okhttp3/internal/http/RouteException.java
index 030b346a5a..62951c1a4e 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/RouteException.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/RouteException.java
@@ -1,17 +1,15 @@
 /*
  * Copyright (C) 2015 Square, Inc.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+ * in compliance with the License. You may obtain a copy of the License at
  *
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
  */
 package okhttp3.internal.http;
 
@@ -56,7 +54,10 @@ private void addSuppressedIfPossible(IOException e, IOException suppressed) {
     if (addSuppressedExceptionMethod != null) {
       try {
         addSuppressedExceptionMethod.invoke(e, suppressed);
-      } catch (InvocationTargetException | IllegalAccessException ignored) {
+      } catch (InvocationTargetException ignored) {
+
+      } catch (IllegalAccessException ignored) {
+
       }
     }
   }
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RouteSelector.java b/okhttp/src/main/java/okhttp3/internal/http/RouteSelector.java
index 3b5725cbe6..48d82466a4 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/RouteSelector.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/RouteSelector.java
@@ -51,7 +51,7 @@
   private int nextInetSocketAddressIndex;
 
   /* State for negotiating failed routes */
-  private final List<Route> postponedRoutes = new ArrayList<>();
+  private final List<Route> postponedRoutes = new ArrayList<Route>();
 
   public RouteSelector(Address address, RouteDatabase routeDatabase) {
     this.address = address;
@@ -114,7 +114,7 @@ private void resetNextProxy(HttpUrl url, Proxy proxy) {
     } else {
       // Try each of the ProxySelector choices until one connection succeeds. If none succeed
       // then we'll try a direct connection below.
-      proxies = new ArrayList<>();
+      proxies = new ArrayList<Proxy>();
       List<Proxy> selectedProxies = address.proxySelector().select(url.uri());
       if (selectedProxies != null) proxies.addAll(selectedProxies);
       // Finally try a direct connection. We only try it once!
@@ -143,7 +143,7 @@ private Proxy nextProxy() throws IOException {
   /** Prepares the socket addresses to attempt for the current proxy or host. */
   private void resetNextInetSocketAddress(Proxy proxy) throws IOException {
     // Clear the addresses. Necessary if getAllByName() below throws!
-    inetSocketAddresses = new ArrayList<>();
+    inetSocketAddresses = new ArrayList<InetSocketAddress>();
 
     String socketHost;
     int socketPort;
diff --git a/okhttp/src/main/java/okhttp3/internal/http/StreamAllocation.java b/okhttp/src/main/java/okhttp3/internal/http/StreamAllocation.java
index aee74cf0bb..bdf586eb44 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/StreamAllocation.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/StreamAllocation.java
@@ -311,7 +311,7 @@ public void streamFailed(IOException e) {
    * {@link #release} on the same connection.
    */
   public void acquire(RealConnection connection) {
-    connection.allocations.add(new WeakReference<>(this));
+    connection.allocations.add(new WeakReference<StreamAllocation>(this));
   }
 
   /** Remove this allocation from the connection's list of allocations. */
diff --git a/okhttp/src/main/java/okhttp3/internal/io/RealConnection.java b/okhttp/src/main/java/okhttp3/internal/io/RealConnection.java
index ef6e8f84d9..774d9f88d0 100644
--- a/okhttp/src/main/java/okhttp3/internal/io/RealConnection.java
+++ b/okhttp/src/main/java/okhttp3/internal/io/RealConnection.java
@@ -1,18 +1,16 @@
 /*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
  *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
  */
 package okhttp3.internal.io;
 
@@ -81,7 +79,8 @@
   public BufferedSource source;
   public BufferedSink sink;
   public int allocationLimit;
-  public final List<Reference<StreamAllocation>> allocations = new ArrayList<>();
+  public final List<Reference<StreamAllocation>> allocations =
+      new ArrayList<Reference<StreamAllocation>>();
   public boolean noNewStreams;
   public long idleAtNanos = Long.MAX_VALUE;
 
@@ -91,15 +90,16 @@ public RealConnection(Route route) {
 
   public void connect(int connectTimeout, int readTimeout, int writeTimeout,
       List<ConnectionSpec> connectionSpecs, boolean connectionRetryEnabled) throws RouteException {
-    if (protocol != null) throw new IllegalStateException("already connected");
+    if (protocol != null)
+      throw new IllegalStateException("already connected");
 
     RouteException routeException = null;
     ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);
 
     if (route.address().sslSocketFactory() == null
         && !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {
-      throw new RouteException(new UnknownServiceException(
-          "CLEARTEXT communication not supported: " + connectionSpecs));
+      throw new RouteException(
+          new UnknownServiceException("CLEARTEXT communication not supported: " + connectionSpecs));
     }
 
     while (protocol == null) {
@@ -151,7 +151,8 @@ private void buildTunneledConnection(int connectTimeout, int readTimeout, int wr
       connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);
       tunnelRequest = createTunnel(readTimeout, writeTimeout, tunnelRequest, url);
 
-      if (tunnelRequest == null) break; // Tunnel successfully created.
+      if (tunnelRequest == null)
+        break; // Tunnel successfully created.
 
       // The proxy decided to close the connection after an auth challenge. We need to create a new
       // connection, but this time with the auth credentials.
@@ -177,8 +178,7 @@ private void connectSocket(int connectTimeout, int readTimeout, int writeTimeout
     Address address = route.address();
 
     rawSocket = proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP
-        ? address.socketFactory().createSocket()
-        : new Socket(proxy);
+        ? address.socketFactory().createSocket() : new Socket(proxy);
 
     rawSocket.setSoTimeout(readTimeout);
     try {
@@ -203,10 +203,8 @@ private void establishProtocol(int readTimeout, int writeTimeout,
       socket.setSoTimeout(0); // Framed connection timeouts are set per-stream.
 
       FramedConnection framedConnection = new FramedConnection.Builder(true)
-          .socket(socket, route.address().url().host(), source, sink)
-          .protocol(protocol)
-          .listener(this)
-          .build();
+          .socket(socket, route.address().url().host(), source, sink).protocol(protocol)
+          .listener(this).build();
       framedConnection.start();
 
       // Only assign the framed connection once the preface has been sent successfully.
@@ -225,14 +223,13 @@ private void connectTls(int readTimeout, int writeTimeout,
     SSLSocket sslSocket = null;
     try {
       // Create the wrapper over the connected socket.
-      sslSocket = (SSLSocket) sslSocketFactory.createSocket(
-          rawSocket, address.url().host(), address.url().port(), true /* autoClose */);
+      sslSocket = (SSLSocket) sslSocketFactory.createSocket(rawSocket, address.url().host(),
+          address.url().port(), true /* autoClose */);
 
       // Configure the socket's ciphers, TLS versions, and extensions.
       ConnectionSpec connectionSpec = connectionSpecSelector.configureSecureSocket(sslSocket);
       if (connectionSpec.supportsTlsExtensions()) {
-        Platform.get().configureTlsExtensions(
-            sslSocket, address.url().host(), address.protocols());
+        Platform.get().configureTlsExtensions(sslSocket, address.url().host(), address.protocols());
       }
 
       // Force handshake. This can throw!
@@ -242,10 +239,10 @@ private void connectTls(int readTimeout, int writeTimeout,
       // Verify that the socket's certificates are acceptable for the target host.
       if (!address.hostnameVerifier().verify(address.url().host(), sslSocket.getSession())) {
         X509Certificate cert = (X509Certificate) unverifiedHandshake.peerCertificates().get(0);
-        throw new SSLPeerUnverifiedException("Hostname " + address.url().host() + " not verified:"
-            + "\n    certificate: " + CertificatePinner.pin(cert)
-            + "\n    DN: " + cert.getSubjectDN().getName()
-            + "\n    subjectAltNames: " + OkHostnameVerifier.allSubjectAltNames(cert));
+        throw new SSLPeerUnverifiedException(
+            "Hostname " + address.url().host() + " not verified:" + "\n    certificate: "
+                + CertificatePinner.pin(cert) + "\n    DN: " + cert.getSubjectDN().getName()
+                + "\n    subjectAltNames: " + OkHostnameVerifier.allSubjectAltNames(cert));
       }
 
       // Check that the certificate pinner is satisfied by the certificates presented.
@@ -254,18 +251,16 @@ private void connectTls(int readTimeout, int writeTimeout,
 
       // Success! Save the handshake and the ALPN protocol.
       String maybeProtocol = connectionSpec.supportsTlsExtensions()
-          ? Platform.get().getSelectedProtocol(sslSocket)
-          : null;
+          ? Platform.get().getSelectedProtocol(sslSocket) : null;
       socket = sslSocket;
       source = Okio.buffer(Okio.source(socket));
       sink = Okio.buffer(Okio.sink(socket));
       handshake = unverifiedHandshake;
-      protocol = maybeProtocol != null
-          ? Protocol.get(maybeProtocol)
-          : Protocol.HTTP_1_1;
+      protocol = maybeProtocol != null ? Protocol.get(maybeProtocol) : Protocol.HTTP_1_1;
       success = true;
     } catch (AssertionError e) {
-      if (Util.isAndroidGetsocknameError(e)) throw new IOException(e);
+      if (Util.isAndroidGetsocknameError(e))
+        throw new IOException(e);
       throw e;
     } finally {
       if (sslSocket != null) {
@@ -315,7 +310,8 @@ private Request createTunnel(int readTimeout, int writeTimeout, Request tunnelRe
 
         case HTTP_PROXY_AUTH:
           tunnelRequest = route.address().proxyAuthenticator().authenticate(route, response);
-          if (tunnelRequest == null) throw new IOException("Failed to authenticate with proxy");
+          if (tunnelRequest == null)
+            throw new IOException("Failed to authenticate with proxy");
 
           if ("close".equalsIgnoreCase(response.header("Connection"))) {
             return tunnelRequest;
@@ -323,8 +319,7 @@ private Request createTunnel(int readTimeout, int writeTimeout, Request tunnelRe
           break;
 
         default:
-          throw new IOException(
-              "Unexpected response code for CONNECT: " + response.code());
+          throw new IOException("Unexpected response code for CONNECT: " + response.code());
       }
     }
   }
@@ -335,11 +330,9 @@ private Request createTunnel(int readTimeout, int writeTimeout, Request tunnelRe
    * This avoids sending potentially sensitive data like HTTP cookies to the proxy unencrypted.
    */
   private Request createTunnelRequest() throws IOException {
-    return new Request.Builder()
-        .url(route.address().url())
+    return new Request.Builder().url(route.address().url())
         .header("Host", Util.hostHeader(route.address().url(), true))
-        .header("Proxy-Connection", "Keep-Alive")
-        .header("User-Agent", Version.userAgent()) // For HTTP/1.0 proxies like Squid.
+        .header("Proxy-Connection", "Keep-Alive").header("User-Agent", Version.userAgent())
         .build();
   }
 
@@ -348,7 +341,8 @@ boolean isConnected() {
     return protocol != null;
   }
 
-  @Override public Route route() {
+  @Override
+  public Route route() {
     return route;
   }
 
@@ -357,7 +351,8 @@ public void cancel() {
     closeQuietly(rawSocket);
   }
 
-  @Override public Socket socket() {
+  @Override
+  public Socket socket() {
     return socket;
   }
 
@@ -394,16 +389,19 @@ public boolean isHealthy(boolean doExtensiveChecks) {
   }
 
   /** Refuse incoming streams. */
-  @Override public void onStream(FramedStream stream) throws IOException {
+  @Override
+  public void onStream(FramedStream stream) throws IOException {
     stream.close(ErrorCode.REFUSED_STREAM);
   }
 
   /** When settings are received, adjust the allocation limit. */
-  @Override public void onSettings(FramedConnection connection) {
+  @Override
+  public void onSettings(FramedConnection connection) {
     allocationLimit = connection.maxConcurrentStreams();
   }
 
-  @Override public Handshake handshake() {
+  @Override
+  public Handshake handshake() {
     return handshake;
   }
 
@@ -415,7 +413,8 @@ public boolean isMultiplexed() {
     return framedConnection != null;
   }
 
-  @Override public Protocol protocol() {
+  @Override
+  public Protocol protocol() {
     if (framedConnection == null) {
       return protocol != null ? protocol : Protocol.HTTP_1_1;
     } else {
@@ -423,17 +422,10 @@ public boolean isMultiplexed() {
     }
   }
 
-  @Override public String toString() {
-    return "Connection{"
-        + route.address().url().host() + ":" + route.address().url().port()
-        + ", proxy="
-        + route.proxy()
-        + " hostAddress="
-        + route.socketAddress()
-        + " cipherSuite="
-        + (handshake != null ? handshake.cipherSuite() : "none")
-        + " protocol="
-        + protocol
-        + '}';
+  @Override
+  public String toString() {
+    return "Connection{" + route.address().url().host() + ":" + route.address().url().port()
+        + ", proxy=" + route.proxy() + " hostAddress=" + route.socketAddress() + " cipherSuite="
+        + (handshake != null ? handshake.cipherSuite() : "none") + " protocol=" + protocol + '}';
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/tls/CertificateChainCleaner.java b/okhttp/src/main/java/okhttp3/internal/tls/CertificateChainCleaner.java
index 672e48651b..55e47e85cb 100644
--- a/okhttp/src/main/java/okhttp3/internal/tls/CertificateChainCleaner.java
+++ b/okhttp/src/main/java/okhttp3/internal/tls/CertificateChainCleaner.java
@@ -88,8 +88,8 @@ public BasicCertificateChainCleaner(TrustRootIndex trustRootIndex) {
      */
     @Override public List<Certificate> clean(List<Certificate> chain, String hostname)
         throws SSLPeerUnverifiedException {
-      Deque<Certificate> queue = new ArrayDeque<>(chain);
-      List<Certificate> result = new ArrayList<>();
+      Deque<Certificate> queue = new ArrayDeque<Certificate>(chain);
+      List<Certificate> result = new ArrayList<Certificate>();
       result.add(queue.removeFirst());
       boolean foundTrustedCertificate = false;
 
diff --git a/okhttp/src/main/java/okhttp3/internal/tls/OkHostnameVerifier.java b/okhttp/src/main/java/okhttp3/internal/tls/OkHostnameVerifier.java
index a85df784d7..b55129e5b9 100644
--- a/okhttp/src/main/java/okhttp3/internal/tls/OkHostnameVerifier.java
+++ b/okhttp/src/main/java/okhttp3/internal/tls/OkHostnameVerifier.java
@@ -97,14 +97,14 @@ private boolean verifyHostname(String hostname, X509Certificate certificate) {
   public static List<String> allSubjectAltNames(X509Certificate certificate) {
     List<String> altIpaNames = getSubjectAltNames(certificate, ALT_IPA_NAME);
     List<String> altDnsNames = getSubjectAltNames(certificate, ALT_DNS_NAME);
-    List<String> result = new ArrayList<>(altIpaNames.size() + altDnsNames.size());
+    List<String> result = new ArrayList<String>(altIpaNames.size() + altDnsNames.size());
     result.addAll(altIpaNames);
     result.addAll(altDnsNames);
     return result;
   }
 
   private static List<String> getSubjectAltNames(X509Certificate certificate, int type) {
-    List<String> result = new ArrayList<>();
+    List<String> result = new ArrayList<String>();
     try {
       Collection<?> subjectAltNames = certificate.getSubjectAlternativeNames();
       if (subjectAltNames == null) {
diff --git a/okhttp/src/main/java/okhttp3/internal/tls/TrustRootIndex.java b/okhttp/src/main/java/okhttp3/internal/tls/TrustRootIndex.java
index fcc7468e0e..d7e2e86751 100644
--- a/okhttp/src/main/java/okhttp3/internal/tls/TrustRootIndex.java
+++ b/okhttp/src/main/java/okhttp3/internal/tls/TrustRootIndex.java
@@ -86,12 +86,12 @@ public static TrustRootIndex get(X509Certificate... caCerts) {
     private final Map<X500Principal, List<X509Certificate>> subjectToCaCerts;
 
     public BasicTrustRootIndex(X509Certificate... caCerts) {
-      subjectToCaCerts = new LinkedHashMap<>();
+      subjectToCaCerts = new LinkedHashMap<X500Principal, List<X509Certificate>>();
       for (X509Certificate caCert : caCerts) {
         X500Principal subject = caCert.getSubjectX500Principal();
         List<X509Certificate> subjectCaCerts = subjectToCaCerts.get(subject);
         if (subjectCaCerts == null) {
-          subjectCaCerts = new ArrayList<>(1);
+          subjectCaCerts = new ArrayList<X509Certificate>(1);
           subjectToCaCerts.put(subject, subjectCaCerts);
         }
         subjectCaCerts.add(caCert);
diff --git a/pom.xml b/pom.xml
index d0c4b4ec95..d333259da3 100644
--- a/pom.xml
+++ b/pom.xml
@@ -11,7 +11,7 @@
 
   <groupId>com.squareup.okhttp3</groupId>
   <artifactId>parent</artifactId>
-  <version>3.3.1</version>
+  <version>3.3.1.java16</version>
   <packaging>pom</packaging>
 
   <name>OkHttp (Parent)</name>
@@ -19,23 +19,17 @@
   <url>https://github.com/square/okhttp</url>
 
   <modules>
-    <module>okhttp</module>
+<module>okhttp</module>
     <module>okhttp-tests</module>
-
     <module>okhttp-android-support</module>
-
     <module>okhttp-apache</module>
     <module>okhttp-testing-support</module>
     <module>okhttp-urlconnection</module>
-
     <module>okhttp-ws</module>
     <module>okhttp-ws-tests</module>
-
     <module>okhttp-logging-interceptor</module>
-
     <module>okcurl</module>
     <module>mockwebserver</module>
-    <module>samples</module>
     <module>benchmarks</module>
   </modules>
 
@@ -52,9 +46,9 @@
     <apache.http.version>4.2.2</apache.http.version>
     <bouncycastle.version>1.50</bouncycastle.version>
     <guava.version>16.0</guava.version>
-    <java.version>1.7</java.version>
+    <java.version>1.6</java.version>
     <moshi.version>1.1.0</moshi.version>
-    <okio.version>1.8.0</okio.version>
+    <okio.version>1.10.0.java16</okio.version>
 
     <!-- Test Dependencies -->
     <junit.version>4.12</junit.version>
@@ -67,7 +61,7 @@
     <url>https://github.com/square/okhttp/</url>
     <connection>scm:git:https://github.com/square/okhttp.git</connection>
     <developerConnection>scm:git:git@github.com:square/okhttp.git</developerConnection>
-    <tag>parent-3.3.1</tag>
+    <tag>parent-3.3.1-SNAPSHOT</tag>
   </scm>
 
   <issueManagement>
