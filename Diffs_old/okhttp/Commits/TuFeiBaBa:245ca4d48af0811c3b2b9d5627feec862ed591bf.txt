diff --git a/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java b/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java
index d46494d95b..4f755e8fdb 100644
--- a/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java
@@ -54,21 +54,26 @@ public CacheInterceptor(InternalCache cache) {
         ? cache.get(chain.request())
         : null;
 
+    // 获取当前时间，会和之前缓存的时间进行比较
     long now = System.currentTimeMillis();
 
+    // 得到缓存策略
     CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();
     Request networkRequest = strategy.networkRequest;
     Response cacheResponse = strategy.cacheResponse;
 
+    // 追踪缓存，其实就是计数
     if (cache != null) {
       cache.trackResponse(strategy);
     }
 
+    // 缓存不适用，关闭
     if (cacheCandidate != null && cacheResponse == null) {
       closeQuietly(cacheCandidate.body()); // The cache candidate wasn't applicable. Close it.
     }
 
     // If we're forbidden from using the network and the cache is insufficient, fail.
+    // 禁止网络并且没有缓存的话，返回失败
     if (networkRequest == null && cacheResponse == null) {
       return new Response.Builder()
           .request(chain.request())
@@ -82,6 +87,7 @@ public CacheInterceptor(InternalCache cache) {
     }
 
     // If we don't need the network, we're done.
+    // 不用网络请求，返回缓存
     if (networkRequest == null) {
       return cacheResponse.newBuilder()
           .cacheResponse(stripBody(cacheResponse))
@@ -90,6 +96,7 @@ public CacheInterceptor(InternalCache cache) {
 
     Response networkResponse = null;
     try {
+      // 交给下一个拦截器，返回 networkResponse
       networkResponse = chain.proceed(networkRequest);
     } finally {
       // If we're crashing on I/O or otherwise, don't leak the cache body.
@@ -99,6 +106,7 @@ public CacheInterceptor(InternalCache cache) {
     }
 
     // If we have a cache response too, then we're doing a conditional get.
+    // 如果我们同时有缓存和 networkResponse ，根据情况使用
     if (cacheResponse != null) {
       if (networkResponse.code() == HTTP_NOT_MODIFIED) {
         Response response = cacheResponse.newBuilder()
@@ -110,6 +118,7 @@ public CacheInterceptor(InternalCache cache) {
             .build();
         networkResponse.body().close();
 
+        // 更新原来的缓存至最新
         // Update the cache after combining headers but before stripping the
         // Content-Encoding header (as performed by initContentStream()).
         cache.trackConditionalCacheHit();
@@ -125,6 +134,7 @@ public CacheInterceptor(InternalCache cache) {
         .networkResponse(stripBody(networkResponse))
         .build();
 
+    // 保存之前未缓存的缓存
     if (cache != null) {
       if (HttpHeaders.hasBody(response) && CacheStrategy.isCacheable(response, networkRequest)) {
         // Offer this request to the cache.
