diff --git a/okhttp-hpacktests/pom.xml b/okhttp-hpacktests/pom.xml
index 7e8fb57ad7..12bc4e4b49 100644
--- a/okhttp-hpacktests/pom.xml
+++ b/okhttp-hpacktests/pom.xml
@@ -8,7 +8,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.3.0-SNAPSHOT</version>
+    <version>3.5.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-hpacktests</artifactId>
diff --git a/okhttp/src/main/java/okhttp3/ConnectionSpec.java b/okhttp/src/main/java/okhttp3/ConnectionSpec.java
index 6049e320f4..3b9d447b6f 100644
--- a/okhttp/src/main/java/okhttp3/ConnectionSpec.java
+++ b/okhttp/src/main/java/okhttp3/ConnectionSpec.java
@@ -20,8 +20,8 @@
 import javax.net.ssl.SSLSocket;
 
 import static okhttp3.internal.Util.concat;
-import static okhttp3.internal.Util.contains;
 import static okhttp3.internal.Util.immutableList;
+import static okhttp3.internal.Util.indexOf;
 import static okhttp3.internal.Util.intersect;
 
 /**
@@ -153,7 +153,7 @@ private ConnectionSpec supportedSpec(SSLSocket sslSocket, boolean isFallback) {
 
     // In accordance with https://tools.ietf.org/html/draft-ietf-tls-downgrade-scsv-00
     // the SCSV cipher is added to signal that a protocol fallback has taken place.
-    if (isFallback && contains(sslSocket.getSupportedCipherSuites(), "TLS_FALLBACK_SCSV")) {
+    if (isFallback && indexOf(sslSocket.getSupportedCipherSuites(), "TLS_FALLBACK_SCSV") != -1) {
       cipherSuitesIntersection = concat(cipherSuitesIntersection, "TLS_FALLBACK_SCSV");
     }
 
@@ -202,7 +202,7 @@ private static boolean nonEmptyIntersection(String[] a, String[] b) {
       return false;
     }
     for (String toFind : a) {
-      if (contains(b, toFind)) {
+      if (indexOf(b, toFind) != -1) {
         return true;
       }
     }
diff --git a/okhttp/src/main/java/okhttp3/internal/Util.java b/okhttp/src/main/java/okhttp3/internal/Util.java
index a80f482362..3bd2d16b53 100644
--- a/okhttp/src/main/java/okhttp3/internal/Util.java
+++ b/okhttp/src/main/java/okhttp3/internal/Util.java
@@ -314,8 +314,11 @@ public static boolean isAndroidGetsocknameError(AssertionError e) {
         && e.getMessage().contains("getsockname failed");
   }
 
-  public static boolean contains(String[] array, String value) {
-    return Arrays.asList(array).contains(value);
+  public static <T> int indexOf(T[] array, T value) {
+    for (int i = 0, size = array.length; i < size; i++) {
+      if (equal(array[i], value)) return i;
+    }
+    return -1;
   }
 
   public static String[] concat(String[] array, String value) {
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Hpack.java b/okhttp/src/main/java/okhttp3/internal/http2/Hpack.java
index 1c52d7028f..3ee89bbd23 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Hpack.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Hpack.java
@@ -22,6 +22,7 @@
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
+import okhttp3.internal.Util;
 import okio.Buffer;
 import okio.BufferedSource;
 import okio.ByteString;
@@ -359,7 +360,6 @@ ByteString readByteString() throws IOException {
   }
 
   static final class Writer {
-    private static final byte SEPARATED_TOKEN = ':';
     private static final int SETTINGS_HEADER_TABLE_SIZE = 4096;
 
     /**
@@ -370,7 +370,6 @@ ByteString readByteString() throws IOException {
     private static final int SETTINGS_HEADER_TABLE_SIZE_LIMIT = 16384;
 
     private final Buffer out;
-    private final Map<ByteString, Integer> headerStringToDynamicIndex = new LinkedHashMap<>();
 
     /**
      * In the scenario where the dynamic table size changes multiple times between transmission of
@@ -399,18 +398,8 @@ ByteString readByteString() throws IOException {
       this.out = out;
     }
 
-    ByteString getHeaderString(Header entry) {
-      byte[] ret = new byte[entry.name.size() + 1 + entry.value.size()];
-      System.arraycopy(entry.name.toByteArray(), 0, ret, 0, entry.name.size());
-      ret[entry.name.size()] = SEPARATED_TOKEN;
-      System.arraycopy(entry.value.toByteArray(), 0, ret, entry.name.size() + 1,
-          entry.value.size());
-      return ByteString.of(ret);
-    }
-
     private void clearDynamicTable() {
       Arrays.fill(dynamicTable, null);
-      headerStringToDynamicIndex.clear();
       nextHeaderIndex = dynamicTable.length - 1;
       headerCount = 0;
       dynamicTableByteCount = 0;
@@ -429,9 +418,7 @@ private int evictToRecoverBytes(int bytesToRecover) {
         }
         System.arraycopy(dynamicTable, nextHeaderIndex + 1, dynamicTable,
             nextHeaderIndex + 1 + entriesToEvict, headerCount);
-        for (Map.Entry<ByteString, Integer> p : headerStringToDynamicIndex.entrySet()) {
-          p.setValue(p.getValue() + entriesToEvict);
-        }
+        Arrays.fill(dynamicTable, nextHeaderIndex + 1, nextHeaderIndex + 1 + entriesToEvict, null);
         nextHeaderIndex += entriesToEvict;
       }
       return entriesToEvict;
@@ -453,15 +440,11 @@ private void insertIntoDynamicTable(Header entry) {
       if (headerCount + 1 > dynamicTable.length) { // Need to grow the dynamic table.
         Header[] doubled = new Header[dynamicTable.length * 2];
         System.arraycopy(dynamicTable, 0, doubled, dynamicTable.length, dynamicTable.length);
-        for (Map.Entry<ByteString, Integer> p : headerStringToDynamicIndex.entrySet()) {
-          p.setValue(p.getValue() + dynamicTable.length);
-        }
         nextHeaderIndex = dynamicTable.length - 1;
         dynamicTable = doubled;
       }
       int index = nextHeaderIndex--;
       dynamicTable[index] = entry;
-      headerStringToDynamicIndex.put(getHeaderString(entry), index);
       headerCount++;
       dynamicTableByteCount += delta;
     }
@@ -489,11 +472,10 @@ void writeHeaders(List<Header> headerBlock) throws IOException {
           writeInt(staticIndex + 1, PREFIX_4_BITS, 0);
           writeByteString(value);
         } else {
-          ByteString headerString = getHeaderString(header);
-          Integer dynamicIndex = headerStringToDynamicIndex.get(headerString);
-          if (dynamicIndex != null) {
+          int dynamicIndex = Util.indexOf(dynamicTable, header);
+          if (dynamicIndex != -1) {
             // Indexed Header.
-            writeInt(dynamicTable.length - dynamicIndex + STATIC_HEADER_TABLE.length, PREFIX_7_BITS,
+            writeInt(dynamicIndex - nextHeaderIndex + STATIC_HEADER_TABLE.length, PREFIX_7_BITS,
                 0x80);
           } else {
             // Literal Header Field with Incremental Indexing - New Name
