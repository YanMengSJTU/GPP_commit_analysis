diff --git a/CHANGELOG.md b/CHANGELOG.md
index 5772abad0c..7229b70050 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,6 +1,150 @@
 Change Log
 ==========
 
+## Version 3.0.1
+
+_2016-01-14_
+
+ *  Rollback OSGi support. This was causing library jars to include more classes
+    than expected, which interfered with Gradle builds.
+
+
+## Version 3.0.0
+
+_2016-01-13_
+
+This release commits to a stable 3.0 API. Read the 3.0.0-RC1 changes for advice
+on upgrading from 2.x to 3.x.
+
+ *  **The `Callback` interface now takes a `Call`**. This makes it easier to
+    check if the call was canceled from within the callback. When migrating
+    async calls to this new API, `Call` is now the first parameter for both
+    `onResponse()` and `onFailure()`.
+ *  Fix: handle multiple cookies in `JavaNetCookieJar` on Android.
+ *  Fix: improve the default HTTP message in MockWebServer responses.
+ *  Fix: don't leak file handles when a conditional GET throws.
+ *  Fix: Use charset specified by the request body content type in OkHttp's
+    logging interceptor.
+ *  Fix: Don't eagerly release pools on cache hits.
+ *  New: Make OkHttp OSGi ready.
+ *  New: Add already-implemented interfaces Closeable and Flushable to the cache.
+
+## Version 3.0.0-RC1
+
+_2016-01-02_
+
+OkHttp 3 is a major release focused on API simplicity and consistency. The API
+changes are numerous but most are cosmetic. Applications should be able to
+upgrade from the 2.x API to the 3.x API mechanically and without risk.
+
+Because the release includes breaking API changes, we're changing the project's
+package name from `com.squareup.okhttp` to `okhttp3`. This should make it
+possible for large applications to migrate incrementally. The Maven group ID
+is now `com.squareup.okhttp3`. For an explanation of this strategy, see Jake
+Wharton's post, [Java Interoperability Policy for Major Version
+Updates][major_versions].
+
+This release obsoletes OkHttp 2.x, and all code that uses OkHttp's
+`com.squareup.okhttp` package should upgrade to the `okhttp3` package. Libraries
+that depend on OkHttp should upgrade quickly to prevent applications from being
+stuck on the old version.
+
+ *  **There is no longer a global singleton connection pool.** In OkHttp 2.x,
+    all `OkHttpClient` instances shared a common connection pool by default.
+    In OkHttp 3.x, each new `OkHttpClient` gets its own private connection pool.
+    Applications should avoid creating many connection pools as doing so
+    prevents connection reuse. Each connection pool holds its own set of
+    connections alive so applications that have many pools also risk exhausting
+    memory!
+
+    The best practice in OkHttp 3 is to create a single OkHttpClient instance
+    and share it throughout the application. Requests that needs a customized
+    client should call `OkHttpClient.newBuilder()` on that shared instance.
+    This allows customization without the drawbacks of separate connection
+    pools.
+
+ *  **OkHttpClient is now stateless.** In the 2.x API `OkHttpClient` had getters
+    and setters. Internally each request was forced to make its own complete
+    snapshot of the `OkHttpClient` instance to defend against racy configuration
+    changes. In 3.x, `OkHttpClient` is now stateless and has a builder. Note
+    that this class is not strictly immutable as it has stateful members like
+    the connection pool and cache.
+
+ *  **Get and Set prefixes are now avoided.** With ubiquitous builders
+    throughout OkHttp these accessor prefixes aren't necessary. Previously
+    OkHttp used _get_ and _set_ prefixes sporadically which make the API
+    inconsistent and awkward to explore.
+
+ *  **OkHttpClient now implements the new `Call.Factory` interface.** This
+    interface will make your code easier to test. When you test code that makes
+    HTTP requests, you can use this interface to replace the real `OkHttpClient`
+    with your own mocks or fakes.
+
+    The interface will also let you use OkHttp's API with another HTTP client's
+    implementation. This is useful in sandboxed environments like Google App
+    Engine.
+
+ *  **OkHttp now does cookies.** We've replaced `java.net.CookieHandler` with
+    a new interface, `CookieJar` and added our own `Cookie` model class. This
+    new cookie follows the latest RFC and supports the same cookie attributes
+    as modern web browsers.
+
+ *  **Form and Multipart bodies are now modeled.** We've replaced the opaque
+    `FormEncodingBuilder` with the more powerful `FormBody` and
+    `FormBody.Builder` combo. Similarly we've upgraded `MultipartBuilder` into
+    `MultipartBody`, `MultipartBody.Part`, and `MultipartBody.Builder`.
+
+ *  **The Apache HTTP client and HttpURLConnection APIs are deprecated.** They
+    continue to work as they always have, but we're moving everything to the new
+    OkHttp 3 API. The `okhttp-apache` and `okhttp-urlconnection` modules should
+    be only be used to accelerate a transition to OkHttp's request/response API.
+    These deprecated modules will be dropped in an upcoming OkHttp 3.x release.
+
+ *  **Canceling batches of calls is now the application's responsibility.**
+    The API to cancel calls by tag has been removed and replaced with a more
+    general mechanism. The dispatcher now exposes all in-flight calls via its
+    `runningCalls()` and `queuedCalls()` methods. You can write code that
+    selects calls by tag, host, or whatever, and invokes `Call.cancel()` on the
+    ones that are no longer necessary.
+
+ *  **OkHttp no longer uses the global `java.net.Authenticator` by default.**
+    We've changed our `Authenticator` interface to authenticate web and proxy
+    authentication failures through a single method. An adapter for the old
+    authenticator is available in the `okhttp-urlconnection` module.
+
+ *  Fix: Don't throw `IOException` on `ResponseBody.contentLength()` or `close()`.
+ *  Fix: Never throw converting an `HttpUrl` to a `java.net.URI`. This changes
+    the `uri()` method to handle malformed percent-escapes and characters
+    forbidden by `URI`.
+ *  Fix: When a connect times out, attempt an alternate route. Previously route
+    selection was less efficient when differentiating failures.
+ *  New: `Response.peekBody()` lets you access the response body without
+    consuming it. This may be handy for interceptors!
+ *  New: `HttpUrl.newBuilder()` resolves a link to a builder.
+ *  New: Add the TLS version to the `Handshake`.
+ *  New: Drop `Request.uri()` and `Request#urlString()`. Just use
+    `Request.url().uri()` and `Request.url().toString()`.
+ *  New: Add URL to HTTP response logging.
+ *  New: Make `HttpUrl` the blessed URL method of `Request`.
+
+
+## Version 2.7.2
+
+_2016-01-07_
+
+ *  Fix: Don't eagerly release stream allocations on cache hits. We might still
+    need them to handle redirects.
+
+
+## Version 2.7.1
+
+_2016-01-01_
+
+ *  Fix: Don't do a health check on newly-created connections. This is
+    unnecessary work that could put the client in an inconsistent state if the
+    health check fails.
+
+
 ## Version 2.7.0
 
 _2015-12-13_
@@ -772,3 +916,4 @@ Initial release.
 
  [brick]: https://noncombatant.org/2015/05/01/about-http-public-key-pinning/
  [webdav]: https://tools.ietf.org/html/rfc4918
+ [major_versions]: http://jakewharton.com/java-interoperability-policy-for-major-version-updates/
diff --git a/README.md b/README.md
index 52dcc5b862..c84574ca82 100644
--- a/README.md
+++ b/README.md
@@ -1,7 +1,7 @@
 OkHttp
 ======
 
-An HTTP & SPDY client for Android and Java applications. For more information see [the website][1] and [the wiki][2].
+An HTTP & HTTP/2 client for Android and Java applications. For more information see [the website][1] and [the wiki][2].
 
 Download
 --------
@@ -9,14 +9,14 @@ Download
 Download [the latest JAR][3] or grab via Maven:
 ```xml
 <dependency>
-  <groupId>com.squareup.okhttp</groupId>
+  <groupId>com.squareup.okhttp3</groupId>
   <artifactId>okhttp</artifactId>
-  <version>2.7.0</version>
+  <version>3.0.1</version>
 </dependency>
 ```
 or Gradle:
 ```groovy
-compile 'com.squareup.okhttp:okhttp:2.7.0'
+compile 'com.squareup.okhttp3:okhttp:3.0.1'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
@@ -27,22 +27,22 @@ MockWebServer
 
 A library for testing HTTP, HTTPS, HTTP/2.0, and SPDY clients.
 
-MockWebServer coupling with OkHttp is essential for proper testing of SPDY and HTTP/2.0 so that code can be shared.
+MockWebServer coupling with OkHttp is essential for proper testing of HTTP/2.0 so that code can be shared.
 
 ### Download
 
 Download [the latest JAR][4] or grab via Maven:
 ```xml
 <dependency>
-  <groupId>com.squareup.okhttp</groupId>
+  <groupId>com.squareup.okhttp3</groupId>
   <artifactId>mockwebserver</artifactId>
-  <version>2.7.0</version>
+  <version>3.0.1</version>
   <scope>test</scope>
 </dependency>
 ```
 or Gradle:
 ```groovy
-testCompile 'com.squareup.okhttp:mockwebserver:2.7.0'
+testCompile 'com.squareup.okhttp3:mockwebserver:3.0.1'
 ```
 
 
@@ -65,6 +65,6 @@ License
 
  [1]: http://square.github.io/okhttp
  [2]: https://github.com/square/okhttp/wiki
- [3]: https://search.maven.org/remote_content?g=com.squareup.okhttp&a=okhttp&v=LATEST
- [4]: https://search.maven.org/remote_content?g=com.squareup.okhttp&a=mockwebserver&v=LATEST
+ [3]: https://search.maven.org/remote_content?g=com.squareup.okhttp3&a=okhttp&v=LATEST
+ [4]: https://search.maven.org/remote_content?g=com.squareup.okhttp3&a=mockwebserver&v=LATEST
  [snap]: https://oss.sonatype.org/content/repositories/snapshots/
diff --git a/benchmarks/pom.xml b/benchmarks/pom.xml
index bd6d7efd05..6a4459e971 100644
--- a/benchmarks/pom.xml
+++ b/benchmarks/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.0.0-SNAPSHOT</version>
+    <version>3.1.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>benchmarks</artifactId>
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/ApacheHttpClient.java b/benchmarks/src/main/java/okhttp3/benchmarks/ApacheHttpClient.java
index a5b1637e3e..2f97519a29 100644
--- a/benchmarks/src/main/java/okhttp3/benchmarks/ApacheHttpClient.java
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/ApacheHttpClient.java
@@ -15,13 +15,13 @@
  */
 package okhttp3.benchmarks;
 
-import okhttp3.HttpUrl;
-import okhttp3.internal.SslContextBuilder;
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.concurrent.TimeUnit;
 import java.util.zip.GZIPInputStream;
 import javax.net.ssl.SSLContext;
+import okhttp3.HttpUrl;
+import okhttp3.internal.SslContextBuilder;
 import org.apache.http.Header;
 import org.apache.http.HttpResponse;
 import org.apache.http.client.HttpClient;
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/Benchmark.java b/benchmarks/src/main/java/okhttp3/benchmarks/Benchmark.java
index 94abd95d5d..d69530fe0e 100644
--- a/benchmarks/src/main/java/okhttp3/benchmarks/Benchmark.java
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/Benchmark.java
@@ -18,13 +18,6 @@
 import com.google.caliper.Param;
 import com.google.caliper.model.ArbitraryMeasurement;
 import com.google.caliper.runner.CaliperMain;
-import okhttp3.HttpUrl;
-import okhttp3.Protocol;
-import okhttp3.internal.SslContextBuilder;
-import okhttp3.mockwebserver.Dispatcher;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.mockwebserver.RecordedRequest;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -34,13 +27,20 @@
 import java.util.logging.Level;
 import java.util.logging.Logger;
 import javax.net.ssl.SSLContext;
+import okhttp3.HttpUrl;
+import okhttp3.Protocol;
+import okhttp3.internal.SslContextBuilder;
+import okhttp3.mockwebserver.Dispatcher;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
 import okio.Buffer;
 import okio.GzipSink;
 
 /**
- * This benchmark is fake, but may be useful for certain relative comparisons.
- * It uses a local connection to a MockWebServer to measure how many identical
- * requests per second can be carried over a fixed number of threads.
+ * This benchmark is fake, but may be useful for certain relative comparisons. It uses a local
+ * connection to a MockWebServer to measure how many identical requests per second can be carried
+ * over a fixed number of threads.
  */
 public class Benchmark extends com.google.caliper.Benchmark {
   private static final int NUM_REPORTS = 10;
@@ -48,16 +48,16 @@
 
   private final Random random = new Random(0);
 
-  /** Which client to run.*/
+  /** Which client to run. */
   @Param
   Client client;
 
   /** How many concurrent requests to execute. */
-  @Param({ "1", "10" })
+  @Param({"1", "10"})
   int concurrencyLevel;
 
   /** How many requests to enqueue to await threads to execute them. */
-  @Param({ "10" })
+  @Param({"10"})
   int targetBacklog;
 
   /** True to use TLS. */
@@ -74,11 +74,11 @@
   boolean chunked;
 
   /** The size of the HTTP response body, in uncompressed bytes. */
-  @Param({ "128", "1048576" })
+  @Param({"128", "1048576"})
   int bodyByteCount;
 
   /** How many additional headers were included, beyond the built-in ones. */
-  @Param({ "0", "20" })
+  @Param({"0", "20"})
   int headerCount;
 
   /** Which ALPN protocols are in use. Only useful with TLS. */
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/HttpClient.java b/benchmarks/src/main/java/okhttp3/benchmarks/HttpClient.java
index 1f45927c0f..0c0986ffeb 100644
--- a/benchmarks/src/main/java/okhttp3/benchmarks/HttpClient.java
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/HttpClient.java
@@ -20,6 +20,8 @@
 /** An HTTP client to benchmark. */
 interface HttpClient {
   void prepare(Benchmark benchmark);
+
   void enqueue(HttpUrl url) throws Exception;
+
   boolean acceptingJobs();
 }
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/NettyHttpClient.java b/benchmarks/src/main/java/okhttp3/benchmarks/NettyHttpClient.java
index 62d5c37bc1..8caa046c73 100644
--- a/benchmarks/src/main/java/okhttp3/benchmarks/NettyHttpClient.java
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/NettyHttpClient.java
@@ -15,8 +15,6 @@
  */
 package okhttp3.benchmarks;
 
-import okhttp3.HttpUrl;
-import okhttp3.internal.SslContextBuilder;
 import io.netty.bootstrap.Bootstrap;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.PooledByteBufAllocator;
@@ -46,6 +44,8 @@
 import java.util.concurrent.TimeUnit;
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLEngine;
+import okhttp3.HttpUrl;
+import okhttp3.internal.SslContextBuilder;
 
 /** Netty isn't an HTTP client, but it's almost one. */
 class NettyHttpClient implements HttpClient {
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/OkHttp.java b/benchmarks/src/main/java/okhttp3/benchmarks/OkHttp.java
index 0d80f4c82c..05eb5044d2 100644
--- a/benchmarks/src/main/java/okhttp3/benchmarks/OkHttp.java
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/OkHttp.java
@@ -15,18 +15,18 @@
  */
 package okhttp3.benchmarks;
 
-import okhttp3.Call;
-import okhttp3.HttpUrl;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.ResponseBody;
-import okhttp3.internal.SslContextBuilder;
 import java.io.IOException;
 import java.util.concurrent.TimeUnit;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLSession;
 import javax.net.ssl.SSLSocketFactory;
+import okhttp3.Call;
+import okhttp3.HttpUrl;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.ResponseBody;
+import okhttp3.internal.SslContextBuilder;
 
 class OkHttp extends SynchronousHttpClient {
   private static final boolean VERBOSE = false;
@@ -35,8 +35,9 @@
 
   @Override public void prepare(Benchmark benchmark) {
     super.prepare(benchmark);
-    client = new OkHttpClient();
-    client.setProtocols(benchmark.protocols);
+    client = new OkHttpClient.Builder()
+        .protocols(benchmark.protocols)
+        .build();
 
     if (benchmark.tls) {
       SSLContext sslContext = SslContextBuilder.localhost();
@@ -46,8 +47,10 @@
           return true;
         }
       };
-      client.setSslSocketFactory(socketFactory);
-      client.setHostnameVerifier(hostnameVerifier);
+      client = new OkHttpClient.Builder()
+          .sslSocketFactory(socketFactory)
+          .hostnameVerifier(hostnameVerifier)
+          .build();
     }
   }
 
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/OkHttpAsync.java b/benchmarks/src/main/java/okhttp3/benchmarks/OkHttpAsync.java
index 6aa6c333d7..09bd3a73e3 100644
--- a/benchmarks/src/main/java/okhttp3/benchmarks/OkHttpAsync.java
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/OkHttpAsync.java
@@ -15,14 +15,6 @@
  */
 package okhttp3.benchmarks;
 
-import okhttp3.Callback;
-import okhttp3.Dispatcher;
-import okhttp3.HttpUrl;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.ResponseBody;
-import okhttp3.internal.SslContextBuilder;
 import java.io.IOException;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.ThreadPoolExecutor;
@@ -32,6 +24,15 @@
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLSession;
 import javax.net.ssl.SSLSocketFactory;
+import okhttp3.Call;
+import okhttp3.Callback;
+import okhttp3.Dispatcher;
+import okhttp3.HttpUrl;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+import okhttp3.internal.SslContextBuilder;
 
 class OkHttpAsync implements HttpClient {
   private static final boolean VERBOSE = false;
@@ -47,10 +48,11 @@
     concurrencyLevel = benchmark.concurrencyLevel;
     targetBacklog = benchmark.targetBacklog;
 
-    client = new OkHttpClient();
-    client.setProtocols(benchmark.protocols);
-    client.setDispatcher(new Dispatcher(new ThreadPoolExecutor(benchmark.concurrencyLevel,
-        benchmark.concurrencyLevel, 60, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>())));
+    client = new OkHttpClient.Builder()
+        .protocols(benchmark.protocols)
+        .dispatcher(new Dispatcher(new ThreadPoolExecutor(benchmark.concurrencyLevel,
+            benchmark.concurrencyLevel, 60, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>())))
+        .build();
 
     if (benchmark.tls) {
       SSLContext sslContext = SslContextBuilder.localhost();
@@ -60,16 +62,18 @@
           return true;
         }
       };
-      client.setSslSocketFactory(socketFactory);
-      client.setHostnameVerifier(hostnameVerifier);
+      client = client.newBuilder()
+          .sslSocketFactory(socketFactory)
+          .hostnameVerifier(hostnameVerifier)
+          .build();
     }
 
     callback = new Callback() {
-      @Override public void onFailure(Request request, IOException e) {
+      @Override public void onFailure(Call call, IOException e) {
         System.out.println("Failed: " + e);
       }
 
-      @Override public void onResponse(Response response) throws IOException {
+      @Override public void onResponse(Call call, Response response) throws IOException {
         ResponseBody body = response.body();
         long total = SynchronousHttpClient.readAllAndClose(body.byteStream());
         long finish = System.nanoTime();
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/SynchronousHttpClient.java b/benchmarks/src/main/java/okhttp3/benchmarks/SynchronousHttpClient.java
index 76c267cec6..4a17b8693d 100644
--- a/benchmarks/src/main/java/okhttp3/benchmarks/SynchronousHttpClient.java
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/SynchronousHttpClient.java
@@ -15,12 +15,12 @@
  */
 package okhttp3.benchmarks;
 
-import okhttp3.HttpUrl;
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
+import okhttp3.HttpUrl;
 
 /** Any HTTP client with a blocking API. */
 abstract class SynchronousHttpClient implements HttpClient {
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/UrlConnection.java b/benchmarks/src/main/java/okhttp3/benchmarks/UrlConnection.java
index 2a1c75baa7..f5c02ce0b6 100644
--- a/benchmarks/src/main/java/okhttp3/benchmarks/UrlConnection.java
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/UrlConnection.java
@@ -15,8 +15,6 @@
  */
 package okhttp3.benchmarks;
 
-import okhttp3.HttpUrl;
-import okhttp3.internal.SslContextBuilder;
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.HttpURLConnection;
@@ -27,6 +25,8 @@
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLSession;
 import javax.net.ssl.SSLSocketFactory;
+import okhttp3.HttpUrl;
+import okhttp3.internal.SslContextBuilder;
 
 class UrlConnection extends SynchronousHttpClient {
   private static final boolean VERBOSE = false;
diff --git a/checkstyle.xml b/checkstyle.xml
index 0d6d8a420d..d8540c6168 100644
--- a/checkstyle.xml
+++ b/checkstyle.xml
@@ -82,7 +82,15 @@
     <module name="ParenPad"/>
     <module name="TypecastParenPad"/>
     <module name="WhitespaceAfter"/>
-    <module name="WhitespaceAround"/>
+    <module name="WhitespaceAround">
+      <property name="tokens"
+          value="ASSIGN, BAND, BAND_ASSIGN, BOR, BOR_ASSIGN, BSR, BSR_ASSIGN, BXOR, BXOR_ASSIGN,
+          COLON, DIV, DIV_ASSIGN, DO_WHILE, EQUAL, GE, GT, LAND, LCURLY, LE, LITERAL_CATCH,
+          LITERAL_DO, LITERAL_ELSE, LITERAL_FINALLY, LITERAL_FOR, LITERAL_IF, LITERAL_RETURN,
+          LITERAL_SWITCH, LITERAL_SYNCHRONIZED, LITERAL_TRY, LITERAL_WHILE, LOR, LT, MINUS,
+          MINUS_ASSIGN, MOD, MOD_ASSIGN, NOT_EQUAL, PLUS, PLUS_ASSIGN, QUESTION, SL, SLIST,
+          SL_ASSIGN, SR, SR_ASSIGN, STAR, STAR_ASSIGN, LITERAL_ASSERT, TYPE_EXTENSION_AND"/>
+    </module>
 
 
     <!-- Modifier Checks                                    -->
diff --git a/mockwebserver/README.md b/mockwebserver/README.md
index ba40bf5727..c672fc6aef 100644
--- a/mockwebserver/README.md
+++ b/mockwebserver/README.md
@@ -19,7 +19,7 @@ awkward-to-reproduce situations like 500 errors or slow-loading responses.
 ### Example
 
 Use MockWebServer the same way that you use mocking frameworks like
-[Mockito](https://code.google.com/p/mockito/):
+[Mockito](https://github.com/mockito/mockito):
 
 1. Script the mocks.
 2. Run application code.
@@ -143,7 +143,7 @@ server.setDispatcher(dispatcher);
 Get MockWebServer via Maven:
 ```xml
 <dependency>
-  <groupId>com.squareup.okhttp</groupId>
+  <groupId>com.squareup.okhttp3</groupId>
   <artifactId>mockwebserver</artifactId>
   <version>(insert latest version)</version>
   <scope>test</scope>
@@ -152,7 +152,7 @@ Get MockWebServer via Maven:
 
 or via Gradle 
 ```groovy
-testCompile 'com.squareup.okhttp:mockwebserver:(insert latest version)'
+testCompile 'com.squareup.okhttp3:mockwebserver:(insert latest version)'
 ```
 
 ### License
diff --git a/mockwebserver/pom.xml b/mockwebserver/pom.xml
index 3899b1b12b..c87dbc23bb 100644
--- a/mockwebserver/pom.xml
+++ b/mockwebserver/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.0.0-SNAPSHOT</version>
+    <version>3.1.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>mockwebserver</artifactId>
diff --git a/mockwebserver/src/main/java/okhttp3/internal/SslContextBuilder.java b/mockwebserver/src/main/java/okhttp3/internal/SslContextBuilder.java
index fcb5d68f5d..9c7eb40153 100644
--- a/mockwebserver/src/main/java/okhttp3/internal/SslContextBuilder.java
+++ b/mockwebserver/src/main/java/okhttp3/internal/SslContextBuilder.java
@@ -38,11 +38,11 @@
 import org.bouncycastle.x509.X509V3CertificateGenerator;
 
 /**
- * Constructs an SSL context for testing. This uses Bouncy Castle to generate a
- * self-signed certificate for a single hostname such as "localhost".
+ * Constructs an SSL context for testing. This uses Bouncy Castle to generate a self-signed
+ * certificate for a single hostname such as "localhost".
  *
- * <p>The crypto performed by this class is relatively slow. Clients should
- * reuse SSL context instances where possible.
+ * <p>The crypto performed by this class is relatively slow. Clients should reuse SSL context
+ * instances where possible.
  */
 public final class SslContextBuilder {
   static {
@@ -57,8 +57,8 @@
   private long notAfter = System.currentTimeMillis() + ONE_DAY_MILLIS;
 
   /**
-   * @param hostName the subject of the host. For TLS this should be the
-   * domain name that the client uses to identify the server.
+   * @param hostName the subject of the host. For TLS this should be the domain name that the client
+   * uses to identify the server.
    */
   public SslContextBuilder(String hostName) {
     this.hostName = hostName;
@@ -87,7 +87,7 @@ public SSLContext build() throws GeneralSecurityException {
 
     // Put 'em in a key store.
     KeyStore keyStore = newEmptyKeyStore(password);
-    Certificate[] certificateChain = { certificate };
+    Certificate[] certificateChain = {certificate};
     keyStore.setKeyEntry("private", keyPair.getPrivate(), password, certificateChain);
     keyStore.setCertificateEntry("cert", certificate);
 
@@ -111,8 +111,8 @@ public KeyPair generateKeyPair() throws GeneralSecurityException {
   }
 
   /**
-   * Generates a certificate for {@code hostName} containing {@code keyPair}'s
-   * public key, signed by {@code keyPair}'s private key.
+   * Generates a certificate for {@code hostName} containing {@code keyPair}'s public key, signed by
+   * {@code keyPair}'s private key.
    */
   @SuppressWarnings("deprecation") // use the old Bouncy Castle APIs to reduce dependencies.
   public X509Certificate selfSignedCertificate(KeyPair keyPair, String serialNumber)
diff --git a/mockwebserver/src/main/java/okhttp3/internal/framed/FramedServer.java b/mockwebserver/src/main/java/okhttp3/internal/framed/FramedServer.java
index dcf5334107..5461090246 100644
--- a/mockwebserver/src/main/java/okhttp3/internal/framed/FramedServer.java
+++ b/mockwebserver/src/main/java/okhttp3/internal/framed/FramedServer.java
@@ -16,10 +16,6 @@
 
 package okhttp3.internal.framed;
 
-import okhttp3.Protocol;
-import okhttp3.internal.Platform;
-import okhttp3.internal.SslContextBuilder;
-import okhttp3.internal.Util;
 import java.io.File;
 import java.io.IOException;
 import java.net.ProtocolException;
@@ -31,6 +27,10 @@
 import java.util.logging.Logger;
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
+import okhttp3.Protocol;
+import okhttp3.internal.Platform;
+import okhttp3.internal.SslContextBuilder;
+import okhttp3.internal.Util;
 import okio.BufferedSink;
 import okio.Okio;
 import okio.Source;
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/Dispatcher.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/Dispatcher.java
index 4e3e05177f..c7cff55202 100644
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/Dispatcher.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/Dispatcher.java
@@ -18,17 +18,16 @@
 /** Handler for mock server requests. */
 public abstract class Dispatcher {
   /**
-   * Returns a response to satisfy {@code request}. This method may block (for
-   * instance, to wait on a CountdownLatch).
+   * Returns a response to satisfy {@code request}. This method may block (for instance, to wait on
+   * a CountdownLatch).
    */
   public abstract MockResponse dispatch(RecordedRequest request) throws InterruptedException;
 
   /**
-   * Returns an early guess of the next response, used for policy on how an
-   * incoming request should be received. The default implementation returns an
-   * empty response. Mischievous implementations can return other values to test
-   * HTTP edge cases, such as unhappy socket policies or throttled request
-   * bodies.
+   * Returns an early guess of the next response, used for policy on how an incoming request should
+   * be received. The default implementation returns an empty response. Mischievous implementations
+   * can return other values to test HTTP edge cases, such as unhappy socket policies or throttled
+   * request bodies.
    */
   public MockResponse peek() {
     return new MockResponse().setSocketPolicy(SocketPolicy.KEEP_OPEN);
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.java
index 43b9fd264b..9f56b34f99 100644
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.java
@@ -15,21 +15,20 @@
  */
 package okhttp3.mockwebserver;
 
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
 import okhttp3.Headers;
 import okhttp3.internal.Internal;
 import okhttp3.internal.framed.Settings;
 import okhttp3.ws.WebSocketListener;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.concurrent.TimeUnit;
-import okhttp3.Protocol;
 import okio.Buffer;
 
 /** A scripted response to be replayed by the mock web server. */
 public final class MockResponse implements Cloneable {
   private static final String CHUNKED_BODY_HEADER = "Transfer-encoding: chunked";
 
-  private String status = "HTTP/1.1 200 OK";
+  private String status;
   private Headers.Builder headers = new Headers.Builder();
 
   private Buffer body;
@@ -49,6 +48,7 @@
 
   /** Creates a new mock response with an empty body. */
   public MockResponse() {
+    setResponseCode(200);
     setHeader("Content-Length", 0);
   }
 
@@ -69,7 +69,19 @@ public String getStatus() {
   }
 
   public MockResponse setResponseCode(int code) {
-    return setStatus("HTTP/1.1 " + code + " OK");
+    String reason = "Mock Response";
+    if (code >= 100 && code < 200) {
+      reason = "Informational";
+    } else if (code >= 200 && code < 300) {
+      reason = "OK";
+    } else if (code >= 300 && code < 400) {
+      reason = "Redirection";
+    } else if (code >= 400 && code < 500) {
+      reason = "Client Error";
+    } else if (code >= 500 && code < 600) {
+      reason = "Server Error";
+    }
+    return setStatus("HTTP/1.1 " + code + " " + reason);
   }
 
   public MockResponse setStatus(String status) {
@@ -83,8 +95,8 @@ public Headers getHeaders() {
   }
 
   /**
-   * Removes all HTTP headers including any "Content-Length" and
-   * "Transfer-encoding" headers that were added by default.
+   * Removes all HTTP headers including any "Content-Length" and "Transfer-encoding" headers that
+   * were added by default.
    */
   public MockResponse clearHeaders() {
     headers = new Headers.Builder();
@@ -92,8 +104,8 @@ public MockResponse clearHeaders() {
   }
 
   /**
-   * Adds {@code header} as an HTTP header. For well-formed HTTP {@code header}
-   * should contain a name followed by a colon and a value.
+   * Adds {@code header} as an HTTP header. For well-formed HTTP {@code header} should contain a
+   * name followed by a colon and a value.
    */
   public MockResponse addHeader(String header) {
     headers.add(header);
@@ -101,8 +113,8 @@ public MockResponse addHeader(String header) {
   }
 
   /**
-   * Adds a new header with the name and value. This may be used to add multiple
-   * headers with the same name.
+   * Adds a new header with the name and value. This may be used to add multiple headers with the
+   * same name.
    */
   public MockResponse addHeader(String name, Object value) {
     headers.add(name, String.valueOf(value));
@@ -110,9 +122,9 @@ public MockResponse addHeader(String name, Object value) {
   }
 
   /**
-   * Adds a new header with the name and value. This may be used to add multiple
-   * headers with the same name. Unlike {@link #addHeader(String, Object)} this
-   * does not validate the name and value.
+   * Adds a new header with the name and value. This may be used to add multiple headers with the
+   * same name. Unlike {@link #addHeader(String, Object)} this does not validate the name and
+   * value.
    */
   public MockResponse addHeaderLenient(String name, Object value) {
     Internal.instance.addLenient(headers, name, String.valueOf(value));
@@ -120,8 +132,7 @@ public MockResponse addHeaderLenient(String name, Object value) {
   }
 
   /**
-   * Removes all headers named {@code name}, then adds a new header with the
-   * name and value.
+   * Removes all headers named {@code name}, then adds a new header with the name and value.
    */
   public MockResponse setHeader(String name, Object value) {
     removeHeader(name);
@@ -157,8 +168,7 @@ public MockResponse setBody(String body) {
   }
 
   /**
-   * Sets the response body to {@code body}, chunked every {@code maxChunkSize}
-   * bytes.
+   * Sets the response body to {@code body}, chunked every {@code maxChunkSize} bytes.
    */
   public MockResponse setChunkedBody(Buffer body, int maxChunkSize) {
     removeHeader("Content-Length");
@@ -179,8 +189,8 @@ public MockResponse setChunkedBody(Buffer body, int maxChunkSize) {
   }
 
   /**
-   * Sets the response body to the UTF-8 encoded bytes of {@code body}, chunked
-   * every {@code maxChunkSize} bytes.
+   * Sets the response body to the UTF-8 encoded bytes of {@code body}, chunked every {@code
+   * maxChunkSize} bytes.
    */
   public MockResponse setChunkedBody(String body, int maxChunkSize) {
     return setChunkedBody(new Buffer().writeUtf8(body), maxChunkSize);
@@ -215,8 +225,8 @@ public long getThrottlePeriod(TimeUnit unit) {
   }
 
   /**
-   * Set the delayed time of the response body to {@code delay}. This applies to the
-   * response body only; response headers are not affected.
+   * Set the delayed time of the response body to {@code delay}. This applies to the response body
+   * only; response headers are not affected.
    */
   public MockResponse setBodyDelay(long delay, TimeUnit unit) {
     bodyDelayAmount = delay;
@@ -229,9 +239,8 @@ public long getBodyDelay(TimeUnit unit) {
   }
 
   /**
-   * When {@link MockWebServer#setProtocols(java.util.List) protocols}
-   * include {@linkplain Protocol#HTTP_2}, this attaches a
-   * pushed stream to this response.
+   * When {@link MockWebServer#setProtocols(java.util.List) protocols} include {@linkplain
+   * okhttp3.Protocol#HTTP_2}, this attaches a pushed stream to this response.
    */
   public MockResponse withPush(PushPromise promise) {
     this.promises.add(promise);
@@ -244,9 +253,8 @@ public MockResponse withPush(PushPromise promise) {
   }
 
   /**
-   * When {@linkplain MockWebServer#setProtocols(java.util.List) protocols}
-   * include {@linkplain Protocol#HTTP_2 HTTP/2}, this
-   * pushes {@code settings} before writing the response.
+   * When {@linkplain MockWebServer#setProtocols(java.util.List) protocols} include {@linkplain
+   * okhttp3.Protocol#HTTP_2 HTTP/2}, this pushes {@code settings} before writing the response.
    */
   public MockResponse withSettings(Settings settings) {
     this.settings = settings;
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
index 0ecd8c0da5..1e4db28d41 100644
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
@@ -17,23 +17,6 @@
 
 package okhttp3.mockwebserver;
 
-import okhttp3.Headers;
-import okhttp3.HttpUrl;
-import okhttp3.Protocol;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.internal.NamedRunnable;
-import okhttp3.internal.Platform;
-import okhttp3.internal.Util;
-import okhttp3.internal.framed.ErrorCode;
-import okhttp3.internal.framed.FramedConnection;
-import okhttp3.internal.framed.FramedStream;
-import okhttp3.internal.framed.Header;
-import okhttp3.internal.framed.Settings;
-import okhttp3.internal.http.HttpMethod;
-import okhttp3.internal.ws.RealWebSocket;
-import okhttp3.internal.ws.WebSocketProtocol;
-import okhttp3.ws.WebSocketListener;
 import java.io.IOException;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
@@ -69,6 +52,23 @@
 import javax.net.ssl.SSLSocketFactory;
 import javax.net.ssl.TrustManager;
 import javax.net.ssl.X509TrustManager;
+import okhttp3.Headers;
+import okhttp3.HttpUrl;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.internal.NamedRunnable;
+import okhttp3.internal.Platform;
+import okhttp3.internal.Util;
+import okhttp3.internal.framed.ErrorCode;
+import okhttp3.internal.framed.FramedConnection;
+import okhttp3.internal.framed.FramedStream;
+import okhttp3.internal.framed.Header;
+import okhttp3.internal.framed.Settings;
+import okhttp3.internal.http.HttpMethod;
+import okhttp3.internal.ws.RealWebSocket;
+import okhttp3.internal.ws.WebSocketProtocol;
+import okhttp3.ws.WebSocketListener;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -93,8 +93,8 @@
 import static okhttp3.mockwebserver.SocketPolicy.UPGRADE_TO_SSL_AT_END;
 
 /**
- * A scriptable web server. Callers supply canned responses and the server
- * replays them upon request in sequence.
+ * A scriptable web server. Callers supply canned responses and the server replays them upon request
+ * in sequence.
  */
 public final class MockWebServer implements TestRule {
   private static final X509TrustManager UNTRUSTED_TRUST_MANAGER = new X509TrustManager() {
@@ -202,39 +202,26 @@ public HttpUrl url(String path) {
   }
 
   /**
-   * Returns a cookie domain for this server. This returns the server's
-   * non-loopback host name if it is known. Otherwise this returns ".local" for
-   * this server's loopback name.
-   */
-  public String getCookieDomain() {
-    String hostName = getHostName();
-    return hostName.contains(".") ? hostName : ".local";
-  }
-
-  /**
-   * Sets the number of bytes of the POST body to keep in memory to the given
-   * limit.
+   * Sets the number of bytes of the POST body to keep in memory to the given limit.
    */
   public void setBodyLimit(long maxBodyLength) {
     this.bodyLimit = maxBodyLength;
   }
 
   /**
-   * Sets whether ALPN is used on incoming HTTPS connections to
-   * negotiate a protocol like HTTP/1.1 or HTTP/2. Call this method to disable
-   * negotiation and restrict connections to HTTP/1.1.
+   * Sets whether ALPN is used on incoming HTTPS connections to negotiate a protocol like HTTP/1.1
+   * or HTTP/2. Call this method to disable negotiation and restrict connections to HTTP/1.1.
    */
   public void setProtocolNegotiationEnabled(boolean protocolNegotiationEnabled) {
     this.protocolNegotiationEnabled = protocolNegotiationEnabled;
   }
 
   /**
-   * Indicates the protocols supported by ALPN on incoming HTTPS
-   * connections. This list is ignored when
-   * {@link #setProtocolNegotiationEnabled negotiation is disabled}.
+   * Indicates the protocols supported by ALPN on incoming HTTPS connections. This list is ignored
+   * when {@link #setProtocolNegotiationEnabled negotiation is disabled}.
    *
-   * @param protocols the protocols to use, in order of preference. The list
-   * must contain {@linkplain Protocol#HTTP_1_1}. It must not contain null.
+   * @param protocols the protocols to use, in order of preference. The list must contain
+   * {@linkplain Protocol#HTTP_1_1}. It must not contain null.
    */
   public void setProtocols(List<Protocol> protocols) {
     protocols = Util.immutableList(protocols);
@@ -250,8 +237,7 @@ public void setProtocols(List<Protocol> protocols) {
   /**
    * Serve requests with HTTPS rather than otherwise.
    *
-   * @param tunnelProxy true to expect the HTTP CONNECT method before
-   * negotiating TLS.
+   * @param tunnelProxy true to expect the HTTP CONNECT method before negotiating TLS.
    */
   public void useHttps(SSLSocketFactory sslSocketFactory, boolean tunnelProxy) {
     this.sslSocketFactory = sslSocketFactory;
@@ -259,9 +245,9 @@ public void useHttps(SSLSocketFactory sslSocketFactory, boolean tunnelProxy) {
   }
 
   /**
-   * Awaits the next HTTP request, removes it, and returns it. Callers should
-   * use this to verify the request was sent as intended. This method will block until the
-   * request is available, possibly forever.
+   * Awaits the next HTTP request, removes it, and returns it. Callers should use this to verify the
+   * request was sent as intended. This method will block until the request is available, possibly
+   * forever.
    *
    * @return the head of the request queue
    */
@@ -270,14 +256,12 @@ public RecordedRequest takeRequest() throws InterruptedException {
   }
 
   /**
-   * Awaits the next HTTP request (waiting up to the
-   * specified wait time if necessary), removes it, and returns it. Callers should
-   * use this to verify the request was sent as intended within the given time.
+   * Awaits the next HTTP request (waiting up to the specified wait time if necessary), removes it,
+   * and returns it. Callers should use this to verify the request was sent as intended within the
+   * given time.
    *
-   * @param timeout how long to wait before giving up, in units of
-   * {@code unit}
-   * @param unit a {@code TimeUnit} determining how to interpret the
-   * {@code timeout} parameter
+   * @param timeout how long to wait before giving up, in units of {@code unit}
+   * @param unit a {@code TimeUnit} determining how to interpret the {@code timeout} parameter
    * @return the head of the request queue
    */
   public RecordedRequest takeRequest(long timeout, TimeUnit unit) throws InterruptedException {
@@ -285,21 +269,20 @@ public RecordedRequest takeRequest(long timeout, TimeUnit unit) throws Interrupt
   }
 
   /**
-   * Returns the number of HTTP requests received thus far by this server. This
-   * may exceed the number of HTTP connections when connection reuse is in
-   * practice.
+   * Returns the number of HTTP requests received thus far by this server. This may exceed the
+   * number of HTTP connections when connection reuse is in practice.
    */
   public int getRequestCount() {
     return requestCount.get();
   }
 
   /**
-   * Scripts {@code response} to be returned to a request made in sequence. The
-   * first request is served by the first enqueued response; the second request
-   * by the second enqueued response; and so on.
+   * Scripts {@code response} to be returned to a request made in sequence. The first request is
+   * served by the first enqueued response; the second request by the second enqueued response; and
+   * so on.
    *
-   * @throws ClassCastException if the default dispatcher has been replaced
-   * with {@link #setDispatcher(Dispatcher)}.
+   * @throws ClassCastException if the default dispatcher has been replaced with {@link
+   * #setDispatcher(Dispatcher)}.
    */
   public void enqueue(MockResponse response) {
     ((QueueDispatcher) dispatcher).enqueueResponse(response.clone());
@@ -313,9 +296,8 @@ public void start() throws IOException {
   /**
    * Starts the server on the loopback interface for the given port.
    *
-   * @param port the port to listen to, or 0 for any available port. Automated
-   * tests should always use port 0 to avoid flakiness when a specific port
-   * is unavailable.
+   * @param port the port to listen to, or 0 for any available port. Automated tests should always
+   * use port 0 to avoid flakiness when a specific port is unavailable.
    */
   public void start(int port) throws IOException {
     start(InetAddress.getByName("localhost"), port);
@@ -325,9 +307,8 @@ public void start(int port) throws IOException {
    * Starts the server on the given address and port.
    *
    * @param inetAddress the address to create the server socket on
-   * @param port the port to listen to, or 0 for any available port. Automated
-   * tests should always use port 0 to avoid flakiness when a specific port
-   * is unavailable.
+   * @param port the port to listen to, or 0 for any available port. Automated tests should always
+   * use port 0 to avoid flakiness when a specific port is unavailable.
    */
   public void start(InetAddress inetAddress, int port) throws IOException {
     start(new InetSocketAddress(inetAddress, port));
@@ -565,7 +546,7 @@ private boolean processOneRequest(Socket socket, BufferedSource source, Buffered
 
   private void processHandshakeFailure(Socket raw) throws Exception {
     SSLContext context = SSLContext.getInstance("TLS");
-    context.init(null, new TrustManager[] { UNTRUSTED_TRUST_MANAGER }, new SecureRandom());
+    context.init(null, new TrustManager[] {UNTRUSTED_TRUST_MANAGER}, new SecureRandom());
     SSLSocketFactory sslSocketFactory = context.getSocketFactory();
     SSLSocket socket = (SSLSocket) sslSocketFactory.createSocket(
         raw, raw.getInetAddress().getHostAddress(), raw.getPort(), true);
@@ -743,9 +724,9 @@ private void sleepIfDelayed(MockResponse response) {
   }
 
   /**
-   * Transfer bytes from {@code source} to {@code sink} until either {@code byteCount}
-   * bytes have been transferred or {@code source} is exhausted. The transfer is
-   * throttled according to {@code policy}.
+   * Transfer bytes from {@code source} to {@code sink} until either {@code byteCount} bytes have
+   * been transferred or {@code source} is exhausted. The transfer is throttled according to {@code
+   * policy}.
    */
   private void throttledTransfer(MockResponse policy, Socket socket, BufferedSource source,
       BufferedSink sink, long byteCount, boolean isRequest) throws IOException {
@@ -801,10 +782,9 @@ private void readEmptyLine(BufferedSource source) throws IOException {
   }
 
   /**
-   * Sets the dispatcher used to match incoming requests to mock responses.
-   * The default dispatcher simply serves a fixed sequence of responses from
-   * a {@link #enqueue(MockResponse) queue}; custom dispatchers can vary the
-   * response based on timing or the content of the request.
+   * Sets the dispatcher used to match incoming requests to mock responses. The default dispatcher
+   * simply serves a fixed sequence of responses from a {@link #enqueue(MockResponse) queue}; custom
+   * dispatchers can vary the response based on timing or the content of the request.
    */
   public void setDispatcher(Dispatcher dispatcher) {
     if (dispatcher == null) throw new NullPointerException();
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/QueueDispatcher.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/QueueDispatcher.java
index d79418d977..be87280377 100644
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/QueueDispatcher.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/QueueDispatcher.java
@@ -21,8 +21,8 @@
 import java.util.logging.Logger;
 
 /**
- * Default dispatcher that processes a script of responses. Populate the script
- * by calling {@link #enqueueResponse(MockResponse)}.
+ * Default dispatcher that processes a script of responses. Populate the script by calling {@link
+ * #enqueueResponse(MockResponse)}.
  */
 public class QueueDispatcher extends Dispatcher {
   private static final Logger logger = Logger.getLogger(QueueDispatcher.class.getName());
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/RecordedRequest.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/RecordedRequest.java
index 2498af49c4..aa847001a2 100644
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/RecordedRequest.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/RecordedRequest.java
@@ -16,11 +16,11 @@
 
 package okhttp3.mockwebserver;
 
-import okhttp3.Headers;
-import okhttp3.TlsVersion;
 import java.net.Socket;
 import java.util.List;
 import javax.net.ssl.SSLSocket;
+import okhttp3.Headers;
+import okhttp3.TlsVersion;
 import okio.Buffer;
 
 /** An HTTP request that came into the mock web server. */
@@ -82,16 +82,15 @@ public String getHeader(String name) {
   }
 
   /**
-   * Returns the sizes of the chunks of this request's body, or an empty list
-   * if the request's body was empty or unchunked.
+   * Returns the sizes of the chunks of this request's body, or an empty list if the request's body
+   * was empty or unchunked.
    */
   public List<Integer> getChunkSizes() {
     return chunkSizes;
   }
 
   /**
-   * Returns the total size of the body of this POST request (before
-   * truncation).
+   * Returns the total size of the body of this POST request (before truncation).
    */
   public long getBodySize() {
     return bodySize;
@@ -108,9 +107,8 @@ public String getUtf8Body() {
   }
 
   /**
-   * Returns the index of this request on its HTTP connection. Since a single
-   * HTTP connection may serve multiple requests, each request is assigned its
-   * own sequence number.
+   * Returns the index of this request on its HTTP connection. Since a single HTTP connection may
+   * serve multiple requests, each request is assigned its own sequence number.
    */
   public int getSequenceNumber() {
     return sequenceNumber;
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/SocketPolicy.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/SocketPolicy.java
index fd8fd43d5c..3142cb0767 100644
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/SocketPolicy.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/SocketPolicy.java
@@ -32,35 +32,32 @@
 public enum SocketPolicy {
 
   /**
-   * Keep the socket open after the response. This is the default HTTP/1.1
-   * behavior.
+   * Keep the socket open after the response. This is the default HTTP/1.1 behavior.
    */
   KEEP_OPEN,
 
   /**
-   * Close the socket after the response. This is the default HTTP/1.0
-   * behavior.
+   * Close the socket after the response. This is the default HTTP/1.0 behavior.
    *
    * <p>See {@link SocketPolicy} for reasons why this can cause test flakiness and how to avoid it.
    */
   DISCONNECT_AT_END,
 
   /**
-   * Wrap the socket with SSL at the completion of this request/response pair.
-   * Used for CONNECT messages to tunnel SSL over an HTTP proxy.
+   * Wrap the socket with SSL at the completion of this request/response pair. Used for CONNECT
+   * messages to tunnel SSL over an HTTP proxy.
    */
   UPGRADE_TO_SSL_AT_END,
 
   /**
-   * Request immediate close of connection without even reading the request. Use
-   * to simulate buggy SSL servers closing connections in response to
-   * unrecognized TLS extensions.
+   * Request immediate close of connection without even reading the request. Use to simulate buggy
+   * SSL servers closing connections in response to unrecognized TLS extensions.
    */
   DISCONNECT_AT_START,
 
   /**
-   * Close connection after reading the request but before writing the response.
-   * Use this to simulate late connection pool failures.
+   * Close connection after reading the request but before writing the response. Use this to
+   * simulate late connection pool failures.
    */
   DISCONNECT_AFTER_REQUEST,
 
@@ -74,24 +71,22 @@
   FAIL_HANDSHAKE,
 
   /**
-   * Shutdown the socket input after sending the response. For testing bad
-   * behavior.
+   * Shutdown the socket input after sending the response. For testing bad behavior.
    *
    * <p>See {@link SocketPolicy} for reasons why this can cause test flakiness and how to avoid it.
    */
   SHUTDOWN_INPUT_AT_END,
 
   /**
-   * Shutdown the socket output after sending the response. For testing bad
-   * behavior.
+   * Shutdown the socket output after sending the response. For testing bad behavior.
    *
    * <p>See {@link SocketPolicy} for reasons why this can cause test flakiness and how to avoid it.
    */
   SHUTDOWN_OUTPUT_AT_END,
 
   /**
-   * Don't respond to the request but keep the socket open. For testing
-   * read response header timeout issue.
+   * Don't respond to the request but keep the socket open. For testing read response header timeout
+   * issue.
    */
   NO_RESPONSE
 }
diff --git a/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java b/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java
index 0e0dcf2986..b178622d16 100644
--- a/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java
+++ b/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java
@@ -15,7 +15,6 @@
  */
 package okhttp3.mockwebserver;
 
-import okhttp3.Headers;
 import java.io.BufferedReader;
 import java.io.IOException;
 import java.io.InputStream;
@@ -32,6 +31,7 @@
 import java.util.List;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
+import okhttp3.Headers;
 import org.junit.After;
 import org.junit.Rule;
 import org.junit.Test;
@@ -55,11 +55,34 @@
     assertEquals("HTTP/1.1 200 OK", response.getStatus());
   }
 
+  @Test public void setResponseMockReason() {
+    String[] reasons = {
+        "Mock Response",
+        "Informational",
+        "OK",
+        "Redirection",
+        "Client Error",
+        "Server Error",
+        "Mock Response"
+    };
+    for (int i = 0; i < 600; i++) {
+      MockResponse response = new MockResponse().setResponseCode(i);
+      String expectedReason = reasons[i / 100];
+      assertEquals("HTTP/1.1 " + i + " " + expectedReason, response.getStatus());
+      assertEquals(Arrays.asList("Content-Length: 0"), headersToList(response));
+    }
+  }
+
+  @Test public void setStatusControlsWholeStatusLine() {
+    MockResponse response = new MockResponse().setStatus("HTTP/1.1 202 That'll do pig");
+    assertEquals(Arrays.asList("Content-Length: 0"), headersToList(response));
+    assertEquals("HTTP/1.1 202 That'll do pig", response.getStatus());
+  }
+
   @Test public void setBodyAdjustsHeaders() throws IOException {
     MockResponse response = new MockResponse().setBody("ABC");
     assertEquals(Arrays.asList("Content-Length: 3"), headersToList(response));
     assertEquals("ABC", response.getBody().readUtf8());
-    assertEquals("HTTP/1.1 200 OK", response.getStatus());
   }
 
   @Test public void mockResponseAddHeader() {
@@ -115,8 +138,8 @@
   }
 
   /**
-   * Test that MockWebServer blocks for a call to enqueue() if a request
-   * is made before a mock response is ready.
+   * Test that MockWebServer blocks for a call to enqueue() if a request is made before a mock
+   * response is ready.
    */
   @Test public void dispatchBlocksWaitingForEnqueue() throws Exception {
     new Thread() {
@@ -192,8 +215,8 @@
   }
 
   /**
-   * Throttle the request body by sleeping 500ms after every 3 bytes. With a
-   * 6-byte request, this should yield one sleep for a total delay of 500ms.
+   * Throttle the request body by sleeping 500ms after every 3 bytes. With a 6-byte request, this
+   * should yield one sleep for a total delay of 500ms.
    */
   @Test public void throttleRequest() throws Exception {
     server.enqueue(new MockResponse()
@@ -213,8 +236,8 @@
   }
 
   /**
-   * Throttle the response body by sleeping 500ms after every 3 bytes. With a
-   * 6-byte response, this should yield one sleep for a total delay of 500ms.
+   * Throttle the response body by sleeping 500ms after every 3 bytes. With a 6-byte response, this
+   * should yield one sleep for a total delay of 500ms.
    */
   @Test public void throttleResponse() throws Exception {
     server.enqueue(new MockResponse()
diff --git a/okcurl/pom.xml b/okcurl/pom.xml
index 2b9b7ceab0..9acb2289e6 100644
--- a/okcurl/pom.xml
+++ b/okcurl/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.0.0-SNAPSHOT</version>
+    <version>3.1.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okcurl</artifactId>
diff --git a/okcurl/src/main/java/okhttp3/curl/Main.java b/okcurl/src/main/java/okhttp3/curl/Main.java
index 25f3c2b5c1..21a9d0f75e 100644
--- a/okcurl/src/main/java/okhttp3/curl/Main.java
+++ b/okcurl/src/main/java/okhttp3/curl/Main.java
@@ -16,17 +16,6 @@
 package okhttp3.curl;
 
 import com.google.common.base.Joiner;
-import okhttp3.ConnectionPool;
-import okhttp3.Headers;
-import okhttp3.MediaType;
-import okhttp3.OkHttpClient;
-import okhttp3.Protocol;
-import okhttp3.Request;
-import okhttp3.RequestBody;
-import okhttp3.Response;
-import okhttp3.internal.http.StatusLine;
-import okhttp3.internal.framed.Http2;
-
 import io.airlift.command.Arguments;
 import io.airlift.command.Command;
 import io.airlift.command.HelpOption;
@@ -49,6 +38,15 @@
 import javax.net.ssl.SSLSocketFactory;
 import javax.net.ssl.TrustManager;
 import javax.net.ssl.X509TrustManager;
+import okhttp3.Headers;
+import okhttp3.MediaType;
+import okhttp3.OkHttpClient;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
+import okhttp3.internal.framed.Http2;
+import okhttp3.internal.http.StatusLine;
 import okio.BufferedSource;
 import okio.Okio;
 import okio.Sink;
@@ -84,16 +82,16 @@ private static String protocols() {
     return Joiner.on(", ").join(Protocol.values());
   }
 
-  @Option(name = { "-X", "--request" }, description = "Specify request command to use")
+  @Option(name = {"-X", "--request"}, description = "Specify request command to use")
   public String method;
 
-  @Option(name = { "-d", "--data" }, description = "HTTP POST data")
+  @Option(name = {"-d", "--data"}, description = "HTTP POST data")
   public String data;
 
-  @Option(name = { "-H", "--header" }, description = "Custom header to pass to server")
+  @Option(name = {"-H", "--header"}, description = "Custom header to pass to server")
   public List<String> headers;
 
-  @Option(name = { "-A", "--user-agent" }, description = "User-Agent to send to server")
+  @Option(name = {"-A", "--user-agent"}, description = "User-Agent to send to server")
   public String userAgent = NAME + "/" + versionString();
 
   @Option(name = "--connect-timeout", description = "Maximum time allowed for connection (seconds)")
@@ -102,23 +100,23 @@ private static String protocols() {
   @Option(name = "--read-timeout", description = "Maximum time allowed for reading data (seconds)")
   public int readTimeout = DEFAULT_TIMEOUT;
 
-  @Option(name = { "-L", "--location" }, description = "Follow redirects")
+  @Option(name = {"-L", "--location"}, description = "Follow redirects")
   public boolean followRedirects;
 
-  @Option(name = { "-k", "--insecure" },
+  @Option(name = {"-k", "--insecure"},
       description = "Allow connections to SSL sites without certs")
   public boolean allowInsecure;
 
-  @Option(name = { "-i", "--include" }, description = "Include protocol headers in the output")
+  @Option(name = {"-i", "--include"}, description = "Include protocol headers in the output")
   public boolean showHeaders;
 
   @Option(name = "--frames", description = "Log HTTP/2 frames to STDERR")
   public boolean showHttp2Frames;
 
-  @Option(name = { "-e", "--referer" }, description = "Referer URL")
+  @Option(name = {"-e", "--referer"}, description = "Referer URL")
   public String referer;
 
-  @Option(name = { "-V", "--version" }, description = "Show version number and quit")
+  @Option(name = {"-V", "--version"}, description = "Show version number and quit")
   public boolean version;
 
   @Arguments(title = "url", description = "Remote resource URL")
@@ -170,21 +168,19 @@ private static String protocols() {
   }
 
   private OkHttpClient createClient() {
-    OkHttpClient client = new OkHttpClient();
-    client.setFollowSslRedirects(followRedirects);
+    OkHttpClient.Builder builder = new OkHttpClient.Builder();
+    builder.followSslRedirects(followRedirects);
     if (connectTimeout != DEFAULT_TIMEOUT) {
-      client.setConnectTimeout(connectTimeout, SECONDS);
+      builder.connectTimeout(connectTimeout, SECONDS);
     }
     if (readTimeout != DEFAULT_TIMEOUT) {
-      client.setReadTimeout(readTimeout, SECONDS);
+      builder.readTimeout(readTimeout, SECONDS);
     }
     if (allowInsecure) {
-      client.setSslSocketFactory(createInsecureSslSocketFactory());
-      client.setHostnameVerifier(createInsecureHostnameVerifier());
+      builder.sslSocketFactory(createInsecureSslSocketFactory());
+      builder.hostnameVerifier(createInsecureHostnameVerifier());
     }
-    // If we don't set this reference, there's no way to clean shutdown persistent connections.
-    client.setConnectionPool(ConnectionPool.getDefault());
-    return client;
+    return builder.build();
   }
 
   private String getRequestMethod() {
@@ -239,7 +235,7 @@ Request createRequest() {
   }
 
   private void close() {
-    client.getConnectionPool().evictAll(); // Close any persistent connections.
+    client.connectionPool().evictAll(); // Close any persistent connections.
   }
 
   private static SSLSocketFactory createInsecureSslSocketFactory() {
@@ -258,7 +254,7 @@ private static SSLSocketFactory createInsecureSslSocketFactory() {
           return null;
         }
       };
-      context.init(null, new TrustManager[] { permissive }, null);
+      context.init(null, new TrustManager[] {permissive}, null);
       return context.getSocketFactory();
     } catch (Exception e) {
       throw new AssertionError(e);
diff --git a/okcurl/src/test/java/okhttp3/curl/MainTest.java b/okcurl/src/test/java/okhttp3/curl/MainTest.java
index 9f4d553a09..12fe6d5ec4 100644
--- a/okcurl/src/test/java/okhttp3/curl/MainTest.java
+++ b/okcurl/src/test/java/okhttp3/curl/MainTest.java
@@ -15,9 +15,9 @@
  */
 package okhttp3.curl;
 
+import java.io.IOException;
 import okhttp3.Request;
 import okhttp3.RequestBody;
-import java.io.IOException;
 import okio.Buffer;
 import org.junit.Test;
 
diff --git a/okhttp-android-support/pom.xml b/okhttp-android-support/pom.xml
index 58ec87b3ea..0344a33097 100644
--- a/okhttp-android-support/pom.xml
+++ b/okhttp-android-support/pom.xml
@@ -6,12 +6,14 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.0.0-SNAPSHOT</version>
+    <version>3.1.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-android-support</artifactId>
   <name>OkHttp Android Platform Support</name>
-  <description>Classes to support the Android platform's use of OkHttp (not required for most developers).</description>
+  <description>Classes to support the Android platform's use of OkHttp (not required for most
+    developers).
+  </description>
 
   <dependencies>
     <dependency>
@@ -25,7 +27,7 @@
       <artifactId>okhttp-urlconnection</artifactId>
       <version>${project.version}</version>
     </dependency>
- 
+
     <dependency>
       <groupId>junit</groupId>
       <artifactId>junit</artifactId>
diff --git a/okhttp-android-support/src/main/java/okhttp3/AndroidInternal.java b/okhttp-android-support/src/main/java/okhttp3/AndroidInternal.java
index 9a16786895..de5788539a 100644
--- a/okhttp-android-support/src/main/java/okhttp3/AndroidInternal.java
+++ b/okhttp-android-support/src/main/java/okhttp3/AndroidInternal.java
@@ -15,9 +15,8 @@
  */
 package okhttp3;
 
-import okhttp3.internal.huc.CacheAdapter;
-
 import java.net.ResponseCache;
+import okhttp3.internal.huc.CacheAdapter;
 
 /**
  * Back doors to enable the use of OkHttp within the Android platform libraries. OkHttp is used to
@@ -31,15 +30,16 @@ private AndroidInternal() {
 
   /** Sets the response cache to be used to read and write cached responses. */
   public static void setResponseCache(OkUrlFactory okUrlFactory, ResponseCache responseCache) {
-    OkHttpClient client = okUrlFactory.client();
+    OkHttpClient.Builder builder = okUrlFactory.client().newBuilder();
     if (responseCache instanceof OkCacheContainer) {
       // Avoid adding layers of wrappers. Rather than wrap the ResponseCache in yet another layer to
       // make the ResponseCache look like an InternalCache, we can unwrap the Cache instead.
       // This means that Cache stats will be correctly updated.
       OkCacheContainer okCacheContainer = (OkCacheContainer) responseCache;
-      client.setCache(okCacheContainer.getCache());
+      builder.cache(okCacheContainer.getCache());
     } else {
-      client.setInternalCache(responseCache != null ? new CacheAdapter(responseCache) : null);
+      builder.setInternalCache(responseCache != null ? new CacheAdapter(responseCache) : null);
     }
+    okUrlFactory.setClient(builder.build());
   }
 }
diff --git a/okhttp-android-support/src/main/java/okhttp3/AndroidShimResponseCache.java b/okhttp-android-support/src/main/java/okhttp3/AndroidShimResponseCache.java
index cc669ae890..b0bb9fcf73 100644
--- a/okhttp-android-support/src/main/java/okhttp3/AndroidShimResponseCache.java
+++ b/okhttp-android-support/src/main/java/okhttp3/AndroidShimResponseCache.java
@@ -15,8 +15,6 @@
  */
 package okhttp3;
 
-import okhttp3.internal.huc.JavaApiConverter;
-
 import java.io.File;
 import java.io.IOException;
 import java.net.CacheRequest;
@@ -26,6 +24,7 @@
 import java.net.URLConnection;
 import java.util.List;
 import java.util.Map;
+import okhttp3.internal.huc.JavaApiConverter;
 
 /**
  * A class provided for use by Android so that it can continue supporting a {@link ResponseCache}
@@ -46,8 +45,8 @@ public static AndroidShimResponseCache create(File directory, long maxSize) thro
 
   public boolean isEquivalent(File directory, long maxSize) {
     Cache installedCache = getCache();
-    return (installedCache.getDirectory().equals(directory)
-        && installedCache.getMaxSize() == maxSize
+    return (installedCache.directory().equals(directory)
+        && installedCache.maxSize() == maxSize
         && !installedCache.isClosed());
   }
 
@@ -80,60 +79,55 @@ public Cache getCache() {
   }
 
   /**
-   * Returns the number of bytes currently being used to store the values in
-   * this cache. This may be greater than the {@link #maxSize} if a background
-   * deletion is pending.
+   * Returns the number of bytes currently being used to store the values in this cache. This may be
+   * greater than the {@link #maxSize} if a background deletion is pending.
    */
   public long size() throws IOException {
-    return delegate.getSize();
+    return delegate.size();
   }
 
   /**
-   * Returns the maximum number of bytes that this cache should use to store
-   * its data.
+   * Returns the maximum number of bytes that this cache should use to store its data.
    */
   public long maxSize() {
-    return delegate.getMaxSize();
+    return delegate.maxSize();
   }
 
   /**
-   * Force buffered operations to the filesystem. This ensures that responses
-   * written to the cache will be available the next time the cache is opened,
-   * even if this process is killed.
+   * Force buffered operations to the filesystem. This ensures that responses written to the cache
+   * will be available the next time the cache is opened, even if this process is killed.
    */
   public void flush() throws IOException {
     delegate.flush();
   }
 
   /**
-   * Returns the number of HTTP requests that required the network to either
-   * supply a response or validate a locally cached response.
+   * Returns the number of HTTP requests that required the network to either supply a response or
+   * validate a locally cached response.
    */
   public int getNetworkCount() {
-    return delegate.getNetworkCount();
+    return delegate.networkCount();
   }
 
   /**
-   * Returns the number of HTTP requests whose response was provided by the
-   * cache. This may include conditional {@code GET} requests that were
-   * validated over the network.
+   * Returns the number of HTTP requests whose response was provided by the cache. This may include
+   * conditional {@code GET} requests that were validated over the network.
    */
   public int getHitCount() {
-    return delegate.getHitCount();
+    return delegate.hitCount();
   }
 
   /**
-   * Returns the total number of HTTP requests that were made. This includes
-   * both client requests and requests that were made on the client's behalf
-   * to handle a redirects and retries.
+   * Returns the total number of HTTP requests that were made. This includes both client requests
+   * and requests that were made on the client's behalf to handle a redirects and retries.
    */
   public int getRequestCount() {
-    return delegate.getRequestCount();
+    return delegate.requestCount();
   }
 
   /**
-   * Uninstalls the cache and releases any active resources. Stored contents
-   * will remain on the filesystem.
+   * Uninstalls the cache and releases any active resources. Stored contents will remain on the
+   * filesystem.
    */
   public void close() throws IOException {
     delegate.close();
@@ -145,5 +139,4 @@ public void close() throws IOException {
   public void delete() throws IOException {
     delegate.delete();
   }
-
 }
diff --git a/okhttp-android-support/src/main/java/okhttp3/OkCacheContainer.java b/okhttp-android-support/src/main/java/okhttp3/OkCacheContainer.java
index 06810999b4..d52cb0133d 100644
--- a/okhttp-android-support/src/main/java/okhttp3/OkCacheContainer.java
+++ b/okhttp-android-support/src/main/java/okhttp3/OkCacheContainer.java
@@ -16,8 +16,8 @@
 package okhttp3;
 
 /**
- * An interface that allows OkHttp to detect that a {@link java.net.ResponseCache} contains a
- * {@link Cache}.
+ * An interface that allows OkHttp to detect that a {@link java.net.ResponseCache} contains a {@link
+ * Cache}.
  */
 public interface OkCacheContainer {
   Cache getCache();
diff --git a/okhttp-android-support/src/main/java/okhttp3/internal/huc/CacheAdapter.java b/okhttp-android-support/src/main/java/okhttp3/internal/huc/CacheAdapter.java
index b846f5ff19..8e02239dea 100644
--- a/okhttp-android-support/src/main/java/okhttp3/internal/huc/CacheAdapter.java
+++ b/okhttp-android-support/src/main/java/okhttp3/internal/huc/CacheAdapter.java
@@ -15,11 +15,6 @@
  */
 package okhttp3.internal.huc;
 
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.internal.InternalCache;
-import okhttp3.internal.http.CacheRequest;
-import okhttp3.internal.http.CacheStrategy;
 import java.io.IOException;
 import java.io.OutputStream;
 import java.net.CacheResponse;
@@ -28,6 +23,11 @@
 import java.net.URI;
 import java.util.List;
 import java.util.Map;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.internal.InternalCache;
+import okhttp3.internal.http.CacheRequest;
+import okhttp3.internal.http.CacheStrategy;
 import okio.Okio;
 import okio.Sink;
 
@@ -95,8 +95,8 @@ public ResponseCache getDelegate() {
   }
 
   /**
-   * Returns the {@link CacheResponse} from the delegate by converting the
-   * OkHttp {@link Request} into the arguments required by the {@link ResponseCache}.
+   * Returns the {@link CacheResponse} from the delegate by converting the OkHttp {@link Request}
+   * into the arguments required by the {@link ResponseCache}.
    */
   private CacheResponse getJavaCachedResponse(Request request) throws IOException {
     Map<String, List<String>> headers = JavaApiConverter.extractJavaHeaders(request);
diff --git a/okhttp-android-support/src/main/java/okhttp3/internal/huc/JavaApiConverter.java b/okhttp-android-support/src/main/java/okhttp3/internal/huc/JavaApiConverter.java
index 57f1792afe..0c7a75a87e 100644
--- a/okhttp-android-support/src/main/java/okhttp3/internal/huc/JavaApiConverter.java
+++ b/okhttp-android-support/src/main/java/okhttp3/internal/huc/JavaApiConverter.java
@@ -15,20 +15,6 @@
  */
 package okhttp3.internal.huc;
 
-import okhttp3.CipherSuite;
-import okhttp3.Handshake;
-import okhttp3.Headers;
-import okhttp3.MediaType;
-import okhttp3.Request;
-import okhttp3.RequestBody;
-import okhttp3.Response;
-import okhttp3.ResponseBody;
-import okhttp3.internal.Internal;
-import okhttp3.internal.Util;
-import okhttp3.internal.http.CacheRequest;
-import okhttp3.internal.http.HttpMethod;
-import okhttp3.internal.http.OkHeaders;
-import okhttp3.internal.http.StatusLine;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
@@ -48,6 +34,21 @@
 import javax.net.ssl.HttpsURLConnection;
 import javax.net.ssl.SSLPeerUnverifiedException;
 import javax.net.ssl.SSLSocketFactory;
+import okhttp3.CipherSuite;
+import okhttp3.Handshake;
+import okhttp3.Headers;
+import okhttp3.MediaType;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+import okhttp3.internal.Internal;
+import okhttp3.internal.JavaNetHeaders;
+import okhttp3.internal.Util;
+import okhttp3.internal.http.CacheRequest;
+import okhttp3.internal.http.HttpMethod;
+import okhttp3.internal.http.OkHeaders;
+import okhttp3.internal.http.StatusLine;
 import okio.BufferedSource;
 import okio.Okio;
 import okio.Sink;
@@ -62,9 +63,9 @@ private JavaApiConverter() {
   }
 
   /**
-   * Creates an OkHttp {@link Response} using the supplied {@link URI} and {@link URLConnection}
-   * to supply the data. The URLConnection is assumed to already be connected. If this method
-   * returns {@code null} the response is uncacheable.
+   * Creates an OkHttp {@link Response} using the supplied {@link URI} and {@link URLConnection} to
+   * supply the data. The URLConnection is assumed to already be connected. If this method returns
+   * {@code null} the response is uncacheable.
    */
   public static Response createOkResponseForCachePut(URI uri, URLConnection urlConnection)
       throws IOException {
@@ -127,8 +128,8 @@ public static Response createOkResponseForCachePut(URI uri, URLConnection urlCon
 
       String cipherSuiteString = httpsUrlConnection.getCipherSuite();
       CipherSuite cipherSuite = CipherSuite.forJavaName(cipherSuiteString);
-      Handshake handshake = Handshake.get(cipherSuite, nullSafeImmutableList(peerCertificates),
-          nullSafeImmutableList(localCertificates));
+      Handshake handshake = Handshake.get(null, cipherSuite,
+          nullSafeImmutableList(peerCertificates), nullSafeImmutableList(localCertificates));
       okResponseBuilder.handshake(handshake);
     }
 
@@ -254,7 +255,7 @@ static Response createOkResponseForCacheGet(Request request, CacheResponse javaR
 
       String cipherSuiteString = javaSecureCacheResponse.getCipherSuite();
       CipherSuite cipherSuite = CipherSuite.forJavaName(cipherSuiteString);
-      Handshake handshake = Handshake.get(cipherSuite, peerCertificates, localCertificates);
+      Handshake handshake = Handshake.get(null, cipherSuite, peerCertificates, localCertificates);
       okResponseBuilder.handshake(handshake);
     }
 
@@ -264,9 +265,9 @@ static Response createOkResponseForCacheGet(Request request, CacheResponse javaR
   /**
    * Creates an OkHttp {@link Request} from the supplied information.
    *
-   * <p>This method allows a {@code null} value for {@code requestHeaders} for situations
-   * where a connection is already connected and access to the headers has been lost.
-   * See {@link java.net.HttpURLConnection#getRequestProperties()} for details.
+   * <p>This method allows a {@code null} value for {@code requestHeaders} for situations where a
+   * connection is already connected and access to the headers has been lost. See {@link
+   * java.net.HttpURLConnection#getRequestProperties()} for details.
    */
   public static Request createOkRequest(
       URI uri, String requestMethod, Map<String, List<String>> requestHeaders) {
@@ -287,8 +288,8 @@ public static Request createOkRequest(
   }
 
   /**
-   * Creates a {@link java.net.CacheResponse} of the correct (sub)type using information
-   * gathered from the supplied {@link Response}.
+   * Creates a {@link java.net.CacheResponse} of the correct (sub)type using information gathered
+   * from the supplied {@link Response}.
    */
   public static CacheResponse createJavaCacheResponse(final Response response) {
     final Headers headers = response.headers();
@@ -332,7 +333,7 @@ public Principal getLocalPrincipal() {
         @Override
         public Map<String, List<String>> getHeaders() throws IOException {
           // Java requires that the entry with a null key be the status line.
-          return OkHeaders.toMultimap(headers, StatusLine.get(response).toString());
+          return JavaNetHeaders.toMultimap(headers, StatusLine.get(response).toString());
         }
 
         @Override
@@ -346,7 +347,7 @@ public InputStream getBody() throws IOException {
         @Override
         public Map<String, List<String>> getHeaders() throws IOException {
           // Java requires that the entry with a null key be the status line.
-          return OkHeaders.toMultimap(headers, StatusLine.get(response).toString());
+          return JavaNetHeaders.toMultimap(headers, StatusLine.get(response).toString());
         }
 
         @Override
@@ -364,6 +365,7 @@ public InputStream getBody() throws IOException {
       public void abort() {
         okCacheRequest.abort();
       }
+
       @Override
       public OutputStream getBody() throws IOException {
         Sink body = okCacheRequest.body();
@@ -393,7 +395,7 @@ static HttpURLConnection createJavaUrlConnectionForCachePut(Response okResponse)
    * Extracts an immutable request header map from the supplied {@link Headers}.
    */
   static Map<String, List<String>> extractJavaHeaders(Request request) {
-    return OkHeaders.toMultimap(request.headers(), null);
+    return JavaNetHeaders.toMultimap(request.headers(), null);
   }
 
   /**
@@ -415,8 +417,8 @@ private static Headers extractOkResponseHeaders(HttpURLConnection httpUrlConnect
   }
 
   /**
-   * Extracts OkHttp headers from the supplied {@link Map}. Only real headers are
-   * extracted. Any entry (one with a {@code null} key) is discarded.
+   * Extracts OkHttp headers from the supplied {@link Map}. Only real headers are extracted. Any
+   * entry (one with a {@code null} key) is discarded.
    */
   // @VisibleForTesting
   static Headers extractOkHeaders(Map<String, List<String>> javaHeaders) {
@@ -438,9 +440,9 @@ static Headers extractOkHeaders(Map<String, List<String>> javaHeaders) {
   }
 
   /**
-   * Extracts the status line from the supplied Java API {@link java.net.HttpURLConnection}.
-   * As per the spec, the status line is held as the header with the null key. Returns {@code null}
-   * if there is no status line.
+   * Extracts the status line from the supplied Java API {@link java.net.HttpURLConnection}. As per
+   * the spec, the status line is held as the header with the null key. Returns {@code null} if
+   * there is no status line.
    */
   private static String extractStatusLine(HttpURLConnection httpUrlConnection) {
     // Java specifies that this will be be response header with a null key.
@@ -448,9 +450,9 @@ private static String extractStatusLine(HttpURLConnection httpUrlConnection) {
   }
 
   /**
-   * Extracts the status line from the supplied Java API {@link java.net.CacheResponse}.
-   * As per the spec, the status line is held as the header with the null key. Throws a
-   * {@link ProtocolException} if there is no status line.
+   * Extracts the status line from the supplied Java API {@link java.net.CacheResponse}. As per the
+   * spec, the status line is held as the header with the null key. Throws a {@link
+   * ProtocolException} if there is no status line.
    */
   private static String extractStatusLine(CacheResponse javaResponse) throws IOException {
     Map<String, List<String>> javaResponseHeaders = javaResponse.getHeaders();
@@ -465,7 +467,7 @@ static String extractStatusLine(Map<String, List<String>> javaResponseHeaders)
       // The status line is missing. This suggests a badly behaving cache.
       throw new ProtocolException(
           "CacheResponse is missing a \'null\' header containing the status line. Headers="
-          + javaResponseHeaders);
+              + javaResponseHeaders);
     }
     return values.get(0);
   }
@@ -487,6 +489,7 @@ public MediaType contentType() {
       public long contentLength() {
         return OkHeaders.contentLength(okHeaders);
       }
+
       @Override public BufferedSource source() {
         return body;
       }
@@ -507,10 +510,12 @@ private static ResponseBody createOkBody(final URLConnection urlConnection) thro
         String contentTypeHeader = urlConnection.getContentType();
         return contentTypeHeader == null ? null : MediaType.parse(contentTypeHeader);
       }
+
       @Override public long contentLength() {
         String s = urlConnection.getHeaderField("Content-Length");
         return stringToLong(s);
       }
+
       @Override public BufferedSource source() {
         return body;
       }
@@ -518,10 +523,10 @@ private static ResponseBody createOkBody(final URLConnection urlConnection) thro
   }
 
   /**
-   * An {@link java.net.HttpURLConnection} that represents an HTTP request at the point where
-   * the request has been made, and the response headers have been received, but the body content,
-   * if present, has not been read yet. This intended to provide enough information for
-   * {@link java.net.ResponseCache} subclasses and no more.
+   * An {@link java.net.HttpURLConnection} that represents an HTTP request at the point where the
+   * request has been made, and the response headers have been received, but the body content, if
+   * present, has not been read yet. This intended to provide enough information for {@link
+   * java.net.ResponseCache} subclasses and no more.
    *
    * <p>Much of the method implementations are overrides to delegate to the OkHttp request and
    * response, or to deny access to information as a real HttpURLConnection would after connection.
@@ -581,7 +586,7 @@ public String getRequestProperty(String key) {
       // spec. There seems no good reason why this should fail while getRequestProperty() is ok.
       // We don't fail here, because we need all request header values for caching Vary responses
       // correctly.
-      return OkHeaders.toMultimap(request.headers(), null);
+      return JavaNetHeaders.toMultimap(request.headers(), null);
     }
 
     @Override
@@ -628,7 +633,7 @@ public String getHeaderFieldKey(int position) {
       if (position < 0) {
         throw new IllegalArgumentException("Invalid header index: " + position);
       }
-      if (position == 0) {
+      if (position == 0 || position > response.headers().size()) {
         return null;
       }
       return response.headers().name(position - 1);
@@ -643,6 +648,9 @@ public String getHeaderField(int position) {
       if (position == 0) {
         return StatusLine.get(response).toString();
       }
+      if (position > response.headers().size()) {
+        return null;
+      }
       return response.headers().value(position - 1);
     }
 
@@ -655,7 +663,7 @@ public String getHeaderField(String fieldName) {
 
     @Override
     public Map<String, List<String>> getHeaderFields() {
-      return OkHeaders.toMultimap(response.headers(), StatusLine.get(response).toString());
+      return JavaNetHeaders.toMultimap(response.headers(), StatusLine.get(response).toString());
     }
 
     @Override
diff --git a/okhttp-android-support/src/test/java/okhttp3/android/HttpResponseCache.java b/okhttp-android-support/src/test/java/okhttp3/android/HttpResponseCache.java
index 6b0802020e..c569a3b365 100644
--- a/okhttp-android-support/src/test/java/okhttp3/android/HttpResponseCache.java
+++ b/okhttp-android-support/src/test/java/okhttp3/android/HttpResponseCache.java
@@ -16,10 +16,6 @@
 
 package okhttp3.android;
 
-import okhttp3.Cache;
-import okhttp3.AndroidShimResponseCache;
-import okhttp3.OkCacheContainer;
-
 import java.io.Closeable;
 import java.io.File;
 import java.io.IOException;
@@ -30,15 +26,18 @@
 import java.net.URLConnection;
 import java.util.List;
 import java.util.Map;
+import okhttp3.AndroidShimResponseCache;
+import okhttp3.Cache;
+import okhttp3.OkCacheContainer;
 
 /**
  * A copy of android.net.http.HttpResponseCache taken from AOSP. Android need to keep this code
  * working somehow. Dependencies on okhttp3 are com.android.okhttp on Android.
  *
  * <p>This class exists in okhttp-android-support to help keep the API as it always has been on
- * Android. The public API cannot be changed. This class delegates to
- * {@link AndroidShimResponseCache}, a class that exists in a package that
- * enables it to interact with non-public OkHttp classes.
+ * Android. The public API cannot be changed. This class delegates to {@link
+ * AndroidShimResponseCache}, a class that exists in a package that enables it to interact with
+ * non-public OkHttp classes.
  */
 public final class HttpResponseCache extends ResponseCache implements Closeable, OkCacheContainer {
 
@@ -49,8 +48,8 @@ private HttpResponseCache(AndroidShimResponseCache shimResponseCache) {
   }
 
   /**
-   * Returns the currently-installed {@code HttpResponseCache}, or null if
-   * there is no cache installed or it is not a {@code HttpResponseCache}.
+   * Returns the currently-installed {@code HttpResponseCache}, or null if there is no cache
+   * installed or it is not a {@code HttpResponseCache}.
    */
   public static HttpResponseCache getInstalled() {
     ResponseCache installed = ResponseCache.getDefault();
@@ -66,9 +65,8 @@ public static HttpResponseCache getInstalled() {
    * @param directory the directory to hold cache data.
    * @param maxSize the maximum size of the cache in bytes.
    * @return the newly-installed cache
-   * @throws java.io.IOException if {@code directory} cannot be used for this cache.
-   *     Most applications should respond to this exception by logging a
-   *     warning.
+   * @throws java.io.IOException if {@code directory} cannot be used for this cache. Most
+   * applications should respond to this exception by logging a warning.
    */
   public static synchronized HttpResponseCache install(File directory, long maxSize) throws
       IOException {
@@ -103,9 +101,8 @@ public static synchronized HttpResponseCache install(File directory, long maxSiz
   }
 
   /**
-   * Returns the number of bytes currently being used to store the values in
-   * this cache. This may be greater than the {@link #maxSize} if a background
-   * deletion is pending.
+   * Returns the number of bytes currently being used to store the values in this cache. This may be
+   * greater than the {@link #maxSize} if a background deletion is pending.
    */
   public long size() {
     try {
@@ -117,17 +114,15 @@ public long size() {
   }
 
   /**
-   * Returns the maximum number of bytes that this cache should use to store
-   * its data.
+   * Returns the maximum number of bytes that this cache should use to store its data.
    */
   public long maxSize() {
     return shimResponseCache.maxSize();
   }
 
   /**
-   * Force buffered operations to the filesystem. This ensures that responses
-   * written to the cache will be available the next time the cache is opened,
-   * even if this process is killed.
+   * Force buffered operations to the filesystem. This ensures that responses written to the cache
+   * will be available the next time the cache is opened, even if this process is killed.
    */
   public void flush() {
     try {
@@ -137,34 +132,32 @@ public void flush() {
   }
 
   /**
-   * Returns the number of HTTP requests that required the network to either
-   * supply a response or validate a locally cached response.
+   * Returns the number of HTTP requests that required the network to either supply a response or
+   * validate a locally cached response.
    */
   public int getNetworkCount() {
     return shimResponseCache.getNetworkCount();
   }
 
   /**
-   * Returns the number of HTTP requests whose response was provided by the
-   * cache. This may include conditional {@code GET} requests that were
-   * validated over the network.
+   * Returns the number of HTTP requests whose response was provided by the cache. This may include
+   * conditional {@code GET} requests that were validated over the network.
    */
   public int getHitCount() {
     return shimResponseCache.getHitCount();
   }
 
   /**
-   * Returns the total number of HTTP requests that were made. This includes
-   * both client requests and requests that were made on the client's behalf
-   * to handle a redirects and retries.
+   * Returns the total number of HTTP requests that were made. This includes both client requests
+   * and requests that were made on the client's behalf to handle a redirects and retries.
    */
   public int getRequestCount() {
     return shimResponseCache.getRequestCount();
   }
 
   /**
-   * Uninstalls the cache and releases any active resources. Stored contents
-   * will remain on the filesystem.
+   * Uninstalls the cache and releases any active resources. Stored contents will remain on the
+   * filesystem.
    */
   @Override public void close() throws IOException {
     if (ResponseCache.getDefault() == this) {
@@ -187,5 +180,4 @@ public void delete() throws IOException {
   public Cache getCache() {
     return shimResponseCache.getCache();
   }
-
 }
diff --git a/okhttp-android-support/src/test/java/okhttp3/android/HttpResponseCacheTest.java b/okhttp-android-support/src/test/java/okhttp3/android/HttpResponseCacheTest.java
index dbaf9db93b..dcb1c01815 100644
--- a/okhttp-android-support/src/test/java/okhttp3/android/HttpResponseCacheTest.java
+++ b/okhttp-android-support/src/test/java/okhttp3/android/HttpResponseCacheTest.java
@@ -16,12 +16,6 @@
 
 package okhttp3.android;
 
-import okhttp3.AndroidInternal;
-import okhttp3.HttpUrl;
-import okhttp3.OkHttpClient;
-import okhttp3.OkUrlFactory;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
 import java.io.File;
 import java.io.InputStream;
 import java.net.CacheRequest;
@@ -31,6 +25,12 @@
 import java.net.URLConnection;
 import java.util.List;
 import java.util.Map;
+import okhttp3.AndroidInternal;
+import okhttp3.HttpUrl;
+import okhttp3.OkHttpClient;
+import okhttp3.OkUrlFactory;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Rule;
@@ -48,16 +48,15 @@
  * A port of Android's android.net.http.HttpResponseCacheTest to JUnit4.
  */
 public final class HttpResponseCacheTest {
-
   @Rule public TemporaryFolder cacheRule = new TemporaryFolder();
   @Rule public MockWebServer server = new MockWebServer();
 
   private File cacheDir;
-  private OkUrlFactory client;
+  private OkUrlFactory urlFactory;
 
   @Before public void setUp() throws Exception {
     cacheDir = cacheRule.getRoot();
-    client = new OkUrlFactory(new OkHttpClient());
+    urlFactory = new OkUrlFactory(new OkHttpClient());
   }
 
   @After public void tearDown() throws Exception {
@@ -133,8 +132,8 @@ public CacheRequest put(URI uri, URLConnection connection) {
   }
 
   /**
-   * Make sure that statistics tracking are wired all the way through the
-   * wrapper class. http://code.google.com/p/android/issues/detail?id=25418
+   * Make sure that statistics tracking are wired all the way through the wrapper class.
+   * http://code.google.com/p/android/issues/detail?id=25418
    */
   @Test public void statisticsTracking() throws Exception {
     HttpResponseCache cache = HttpResponseCache.install(cacheDir, 10 * 1024 * 1024);
@@ -165,8 +164,8 @@ public CacheRequest put(URI uri, URLConnection connection) {
   // This mimics the Android HttpHandler, which is found in the okhttp3 package.
   private URLConnection openUrl(HttpUrl url) {
     ResponseCache responseCache = ResponseCache.getDefault();
-    AndroidInternal.setResponseCache(client, responseCache);
-    return client.open(url.url());
+    AndroidInternal.setResponseCache(urlFactory, responseCache);
+    return urlFactory.open(url.url());
   }
 
   private void initializeCache(HttpResponseCache cache) {
diff --git a/okhttp-android-support/src/test/java/okhttp3/internal/huc/CacheAdapterTest.java b/okhttp-android-support/src/test/java/okhttp3/internal/huc/CacheAdapterTest.java
index eff0cd395f..81aeaf2b9a 100644
--- a/okhttp-android-support/src/test/java/okhttp3/internal/huc/CacheAdapterTest.java
+++ b/okhttp-android-support/src/test/java/okhttp3/internal/huc/CacheAdapterTest.java
@@ -15,14 +15,6 @@
  */
 package okhttp3.internal.huc;
 
-import okhttp3.AbstractResponseCache;
-import okhttp3.OkHttpClient;
-import okhttp3.OkUrlFactory;
-import okhttp3.internal.Internal;
-import okhttp3.internal.SslContextBuilder;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.testing.RecordingHostnameVerifier;
 import java.io.IOException;
 import java.net.CacheRequest;
 import java.net.CacheResponse;
@@ -38,6 +30,15 @@
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.HttpsURLConnection;
 import javax.net.ssl.SSLContext;
+import okhttp3.AbstractResponseCache;
+import okhttp3.OkHttpClient;
+import okhttp3.OkUrlFactory;
+import okhttp3.internal.Internal;
+import okhttp3.internal.InternalCache;
+import okhttp3.internal.SslContextBuilder;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.RecordingHostnameVerifier;
 import okio.Buffer;
 import org.junit.After;
 import org.junit.Before;
@@ -51,10 +52,10 @@
 /**
  * A white-box test for {@link CacheAdapter}. See also:
  * <ul>
- *   <li>{@link ResponseCacheTest} for black-box tests that check that {@link ResponseCache}
- *   classes are called correctly by OkHttp.</li>
- *   <li>{@link JavaApiConverterTest} for tests that check Java API classes / OkHttp conversion
- *   logic. </li>
+ *     <li>{@link ResponseCacheTest} for black-box tests that check that {@link ResponseCache}
+ *         classes are called correctly by OkHttp.
+ *     <li>{@link JavaApiConverterTest} for tests that check Java API classes / OkHttp conversion
+ *         logic.
  * </ul>
  */
 public class CacheAdapterTest {
@@ -81,8 +82,8 @@
     assertEquals("http", serverUrl.getProtocol());
 
     ResponseCache responseCache = new AbstractResponseCache() {
-      @Override
-      public CacheResponse get(URI uri, String method, Map<String, List<String>> headers) throws IOException {
+      @Override public CacheResponse get(
+          URI uri, String method, Map<String, List<String>> headers) throws IOException {
         assertEquals(toUri(serverUrl), uri);
         assertEquals("GET", method);
         assertTrue("Arbitrary standard header not present", headers.containsKey("User-Agent"));
@@ -90,7 +91,7 @@ public CacheResponse get(URI uri, String method, Map<String, List<String>> heade
         return null;
       }
     };
-    Internal.instance.setCache(client, new CacheAdapter(responseCache));
+    setInternalCache(new CacheAdapter(responseCache));
 
     connection = new OkUrlFactory(client).open(serverUrl);
     connection.setRequestProperty("key1", "value1");
@@ -113,9 +114,11 @@ public CacheResponse get(URI uri, String method, Map<String, List<String>> heade
         return null;
       }
     };
-    Internal.instance.setCache(client, new CacheAdapter(responseCache));
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(hostnameVerifier);
+    setInternalCache(new CacheAdapter(responseCache));
+    client = client.newBuilder()
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .hostnameVerifier(hostnameVerifier)
+        .build();
 
     connection = new OkUrlFactory(client).open(serverUrl);
     connection.setRequestProperty("key1", "value1");
@@ -157,7 +160,7 @@ public CacheResponse get(URI uri, String method, Map<String, List<String>> heade
         return null;
       }
     };
-    Internal.instance.setCache(client, new CacheAdapter(responseCache));
+    setInternalCache(new CacheAdapter(responseCache));
 
     connection = new OkUrlFactory(client).open(serverUrl);
     connection.setRequestProperty("key", "value");
@@ -196,7 +199,7 @@ public CacheResponse get(URI uri, String method, Map<String, List<String>> heade
         return null;
       }
     };
-    Internal.instance.setCache(client, new CacheAdapter(responseCache));
+    setInternalCache(new CacheAdapter(responseCache));
 
     connection = new OkUrlFactory(client).open(serverUrl);
 
@@ -214,7 +217,8 @@ public CacheResponse get(URI uri, String method, Map<String, List<String>> heade
         assertEquals(serverUrl, connection.getURL());
 
         HttpsURLConnection cacheHttpsUrlConnection = (HttpsURLConnection) connection;
-        HttpsURLConnection realHttpsUrlConnection = (HttpsURLConnection) CacheAdapterTest.this.connection;
+        HttpsURLConnection realHttpsUrlConnection =
+            (HttpsURLConnection) CacheAdapterTest.this.connection;
         assertEquals(realHttpsUrlConnection.getCipherSuite(),
             cacheHttpsUrlConnection.getCipherSuite());
         assertEquals(realHttpsUrlConnection.getPeerPrincipal(),
@@ -228,9 +232,11 @@ public CacheResponse get(URI uri, String method, Map<String, List<String>> heade
         return null;
       }
     };
-    Internal.instance.setCache(client, new CacheAdapter(responseCache));
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(hostnameVerifier);
+    setInternalCache(new CacheAdapter(responseCache));
+    client = client.newBuilder()
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .hostnameVerifier(hostnameVerifier)
+        .build();
 
     connection = new OkUrlFactory(client).open(serverUrl);
     executeGet(connection);
@@ -261,4 +267,10 @@ private URL configureHttpsServer(MockResponse mockResponse) throws Exception {
     server.start();
     return server.url("/").url();
   }
+
+  private void setInternalCache(InternalCache internalCache) {
+    OkHttpClient.Builder builder = client.newBuilder();
+    Internal.instance.setCache(builder, internalCache);
+    client = builder.build();
+  }
 }
diff --git a/okhttp-android-support/src/test/java/okhttp3/internal/huc/JavaApiConverterTest.java b/okhttp-android-support/src/test/java/okhttp3/internal/huc/JavaApiConverterTest.java
index e06572cbec..13f9382492 100644
--- a/okhttp-android-support/src/test/java/okhttp3/internal/huc/JavaApiConverterTest.java
+++ b/okhttp-android-support/src/test/java/okhttp3/internal/huc/JavaApiConverterTest.java
@@ -15,18 +15,6 @@
  */
 package okhttp3.internal.huc;
 
-import okhttp3.CipherSuite;
-import okhttp3.Handshake;
-import okhttp3.Headers;
-import okhttp3.MediaType;
-import okhttp3.Protocol;
-import okhttp3.Request;
-import okhttp3.RequestBody;
-import okhttp3.Response;
-import okhttp3.ResponseBody;
-import okhttp3.internal.Internal;
-import okhttp3.internal.Util;
-import okhttp3.mockwebserver.MockWebServer;
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
@@ -50,9 +38,20 @@
 import java.util.Set;
 import javax.net.ssl.HttpsURLConnection;
 import javax.net.ssl.SSLPeerUnverifiedException;
+import okhttp3.CipherSuite;
+import okhttp3.Handshake;
+import okhttp3.Headers;
+import okhttp3.MediaType;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+import okhttp3.internal.Internal;
+import okhttp3.internal.Util;
+import okhttp3.mockwebserver.MockWebServer;
 import okio.Buffer;
 import okio.BufferedSource;
-import org.junit.Assert;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
@@ -185,7 +184,8 @@
         return localCertificates;
       }
 
-      @Override public List<Certificate> getServerCertificateChain() throws SSLPeerUnverifiedException {
+      @Override public List<Certificate> getServerCertificateChain()
+          throws SSLPeerUnverifiedException {
         return serverCertificates;
       }
 
@@ -223,7 +223,7 @@
   @Test public void createOkRequest_nullRequestHeaders() throws Exception {
     URI uri = new URI("http://foo/bar");
 
-    Map<String,List<String>> javaRequestHeaders = null;
+    Map<String, List<String>> javaRequestHeaders = null;
     Request request = JavaApiConverter.createOkRequest(uri, "POST", javaRequestHeaders);
     assertFalse(request.isHttps());
     assertEquals(uri, request.url().uri());
@@ -235,7 +235,7 @@
   @Test public void createOkRequest_nonNullRequestHeaders() throws Exception {
     URI uri = new URI("https://foo/bar");
 
-    Map<String,List<String>> javaRequestHeaders = new HashMap<>();
+    Map<String, List<String>> javaRequestHeaders = new HashMap<>();
     javaRequestHeaders.put("Foo", Arrays.asList("Bar"));
     Request request = JavaApiConverter.createOkRequest(uri, "POST", javaRequestHeaders);
     assertTrue(request.isHttps());
@@ -253,7 +253,7 @@
   @Test public void createOkRequest_nullRequestHeaderKey() throws Exception {
     URI uri = new URI("https://foo/bar");
 
-    Map<String,List<String>> javaRequestHeaders = new HashMap<>();
+    Map<String, List<String>> javaRequestHeaders = new HashMap<>();
     javaRequestHeaders.put(null, Arrays.asList("GET / HTTP 1.1"));
     javaRequestHeaders.put("Foo", Arrays.asList("Bar"));
     Request request = JavaApiConverter.createOkRequest(uri, "POST", javaRequestHeaders);
@@ -464,7 +464,7 @@ private void assertHeadersContainsMapping(Map<String, List<String>> headers, Str
         .get()
         .url("https://secure/request")
         .build();
-    Handshake handshake = Handshake.get(CipherSuite.TLS_RSA_WITH_NULL_MD5,
+    Handshake handshake = Handshake.get(null, CipherSuite.TLS_RSA_WITH_NULL_MD5,
         Arrays.<Certificate>asList(SERVER_CERT), Arrays.<Certificate>asList(LOCAL_CERT));
     Response okResponse = createArbitraryOkResponse(okRequest).newBuilder()
         .handshake(handshake)
@@ -474,8 +474,8 @@ private void assertHeadersContainsMapping(Map<String, List<String>> headers, Str
 
     assertEquals("SSL_RSA_WITH_NULL_MD5", httpsUrlConnection.getCipherSuite());
     assertEquals(SERVER_CERT.getSubjectX500Principal(), httpsUrlConnection.getPeerPrincipal());
-    assertArrayEquals(new Certificate[] { LOCAL_CERT }, httpsUrlConnection.getLocalCertificates());
-    assertArrayEquals(new Certificate[] { SERVER_CERT },
+    assertArrayEquals(new Certificate[] {LOCAL_CERT}, httpsUrlConnection.getLocalCertificates());
+    assertArrayEquals(new Certificate[] {SERVER_CERT},
         httpsUrlConnection.getServerCertificates());
     assertEquals(LOCAL_CERT.getSubjectX500Principal(), httpsUrlConnection.getLocalPrincipal());
   }
@@ -551,10 +551,10 @@ private void assertHeadersContainsMapping(Map<String, List<String>> headers, Str
     Request okRequest =
         createArbitraryOkRequest().newBuilder()
             .url("https://secure/request")
-            .post(createRequestBody("RequestBody") )
+            .post(createRequestBody("RequestBody"))
             .build();
     ResponseBody responseBody = createResponseBody("ResponseBody");
-    Handshake handshake = Handshake.get(CipherSuite.TLS_RSA_WITH_NULL_MD5,
+    Handshake handshake = Handshake.get(null, CipherSuite.TLS_RSA_WITH_NULL_MD5,
         Arrays.<Certificate>asList(SERVER_CERT), Arrays.<Certificate>asList(LOCAL_CERT));
     Response okResponse = createArbitraryOkResponse(okRequest).newBuilder()
         .protocol(Protocol.HTTP_1_1)
diff --git a/okhttp-android-support/src/test/java/okhttp3/internal/huc/ResponseCacheTest.java b/okhttp-android-support/src/test/java/okhttp3/internal/huc/ResponseCacheTest.java
index bfd7a39765..2ac16c6187 100644
--- a/okhttp-android-support/src/test/java/okhttp3/internal/huc/ResponseCacheTest.java
+++ b/okhttp-android-support/src/test/java/okhttp3/internal/huc/ResponseCacheTest.java
@@ -16,18 +16,6 @@
 
 package okhttp3.internal.huc;
 
-import okhttp3.AbstractResponseCache;
-import okhttp3.AndroidInternal;
-import okhttp3.AndroidShimResponseCache;
-import okhttp3.Headers;
-import okhttp3.OkHttpClient;
-import okhttp3.OkUrlFactory;
-import okhttp3.internal.Internal;
-import okhttp3.internal.SslContextBuilder;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.mockwebserver.RecordedRequest;
-import okhttp3.testing.RecordingHostnameVerifier;
 import java.io.BufferedReader;
 import java.io.ByteArrayInputStream;
 import java.io.FileNotFoundException;
@@ -67,7 +55,20 @@
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.HttpsURLConnection;
 import javax.net.ssl.SSLContext;
+import okhttp3.AbstractResponseCache;
+import okhttp3.AndroidInternal;
+import okhttp3.AndroidShimResponseCache;
+import okhttp3.Headers;
+import okhttp3.OkHttpClient;
+import okhttp3.OkUrlFactory;
+import okhttp3.internal.Internal;
+import okhttp3.internal.InternalCache;
+import okhttp3.internal.SslContextBuilder;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
 import okhttp3.mockwebserver.SocketPolicy;
+import okhttp3.RecordingHostnameVerifier;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.GzipSink;
@@ -86,8 +87,8 @@
 import static org.junit.Assert.fail;
 
 /**
- * Tests the interaction between OkHttp and {@link ResponseCache}.
- * Based on okhttp3.CacheTest with changes for ResponseCache and HttpURLConnection.
+ * Tests the interaction between OkHttp and {@link ResponseCache}. Based on okhttp3.CacheTest with
+ * changes for ResponseCache and HttpURLConnection.
  */
 public final class ResponseCacheTest {
   @Rule public TemporaryFolder cacheRule = new TemporaryFolder();
@@ -96,29 +97,26 @@
 
   private HostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
   private SSLContext sslContext = SslContextBuilder.localhost();
-  private OkHttpClient client;
   private ResponseCache cache;
   private CookieManager cookieManager;
+  private OkUrlFactory urlFactory;
 
   @Before public void setUp() throws Exception {
     server.setProtocolNegotiationEnabled(false);
 
-    client = new OkHttpClient();
-
     cache = AndroidShimResponseCache.create(cacheRule.getRoot(), 10 * 1024 * 1024);
-    AndroidInternal.setResponseCache(new OkUrlFactory(client), cache);
+    urlFactory = new OkUrlFactory(new OkHttpClient());
+    AndroidInternal.setResponseCache(urlFactory, cache);
 
     cookieManager = new CookieManager();
-    CookieManager.setDefault(cookieManager);
   }
 
   @After public void tearDown() throws Exception {
-    CookieManager.setDefault(null);
     ResponseCache.setDefault(null);
   }
 
   private HttpURLConnection openConnection(URL url) {
-    return new OkUrlFactory(client).open(url);
+    return urlFactory.open(url);
   }
 
   /**
@@ -133,45 +131,45 @@ private HttpURLConnection openConnection(URL url) {
     // assertCached(false, 100);
     assertCached(false, 101);
     assertCached(false, 102);
-    assertCached(true,  200);
+    assertCached(true, 200);
     assertCached(false, 201);
     assertCached(false, 202);
-    assertCached(true,  203);
-    assertCached(true,  204);
+    assertCached(true, 203);
+    assertCached(true, 204);
     assertCached(false, 205);
     assertCached(false, 206); //Electing to not cache partial responses
     assertCached(false, 207);
-    assertCached(true,  300);
-    assertCached(true,  301);
-    assertCached(true,  302);
+    assertCached(true, 300);
+    assertCached(true, 301);
+    assertCached(true, 302);
     assertCached(false, 303);
     assertCached(false, 304);
     assertCached(false, 305);
     assertCached(false, 306);
-    assertCached(true,  307);
-    assertCached(true,  308);
+    assertCached(true, 307);
+    assertCached(true, 308);
     assertCached(false, 400);
     assertCached(false, 401);
     assertCached(false, 402);
     assertCached(false, 403);
-    assertCached(true,  404);
-    assertCached(true,  405);
+    assertCached(true, 404);
+    assertCached(true, 405);
     assertCached(false, 406);
     assertCached(false, 408);
     assertCached(false, 409);
     // the HTTP spec permits caching 410s, but the RI doesn't.
-    assertCached(true,  410);
+    assertCached(true, 410);
     assertCached(false, 411);
     assertCached(false, 412);
     assertCached(false, 413);
-    assertCached(true,  414);
+    assertCached(true, 414);
     assertCached(false, 415);
     assertCached(false, 416);
     assertCached(false, 417);
     assertCached(false, 418);
 
     assertCached(false, 500);
-    assertCached(true,  501);
+    assertCached(true, 501);
     assertCached(false, 502);
     assertCached(false, 503);
     assertCached(false, 504);
@@ -347,8 +345,10 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     server.enqueue(new MockResponse()
         .setBody("DEF"));
 
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(hostnameVerifier);
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .hostnameVerifier(hostnameVerifier)
+        .build());
 
     HttpsURLConnection connection1 = (HttpsURLConnection) openConnection(server.url("/").url());
     assertEquals("ABC", readAscii(connection1));
@@ -363,10 +363,9 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
   }
 
   /**
-   * We've had bugs where caching and cross-protocol redirects yield class
-   * cast exceptions internal to the cache because we incorrectly assumed that
-   * HttpsURLConnection was always HTTPS and HttpURLConnection was always HTTP;
-   * in practice redirects mean that each can do either.
+   * We've had bugs where caching and cross-protocol redirects yield class cast exceptions internal
+   * to the cache because we incorrectly assumed that HttpsURLConnection was always HTTPS and
+   * HttpURLConnection was always HTTP; in practice redirects mean that each can do either.
    *
    * https://github.com/square/okhttp/issues/214
    */
@@ -385,8 +384,10 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
         .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
         .addHeader("Location: " + server2.url("/").url()));
 
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(hostnameVerifier);
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .hostnameVerifier(hostnameVerifier)
+        .build());
 
     HttpURLConnection connection1 = openConnection(server.url("/").url());
     assertEquals("ABC", readAscii(connection1));
@@ -767,7 +768,8 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
   /**
    * Equivalent to {@code CacheTest.postInvalidatesCacheWithUncacheableResponse()} but demonstrating
    * that {@link ResponseCache} provides no mechanism for cache invalidation as the result of
-   * locally-made requests. In reality invalidation could take place from other clients at any time.
+   * locally-made requests. In reality invalidation could take place from other clients at any
+   * time.
    */
   @Test public void postInvalidatesCacheWithUncacheableResponse() throws Exception {
     // 1. seed the cache
@@ -1168,8 +1170,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
   }
 
   /**
-   * For Last-Modified and Date headers, we should echo the date back in the
-   * exact format we were served.
+   * For Last-Modified and Date headers, we should echo the date back in the exact format we were
+   * served.
    */
   @Test public void retainServedDateFormat() throws Exception {
     // Serve a response with a non-standard date format that OkHttp supports.
@@ -1454,8 +1456,10 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(hostnameVerifier);
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .hostnameVerifier(hostnameVerifier)
+        .build());
 
     URL url = server.url("/").url();
     HttpURLConnection connection1 = openConnection(url);
@@ -1467,23 +1471,6 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     assertEquals("A", readAscii(connection2));
   }
 
-  @Test public void cachePlusCookies() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Set-Cookie: a=FIRST; domain=" + server.getCookieDomain() + ";")
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .addHeader("Set-Cookie: a=SECOND; domain=" + server.getCookieDomain() + ";")
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    URL url = server.url("/").url();
-    assertEquals("A", readAscii(openConnection(url)));
-    assertCookies(url, "a=FIRST");
-    assertEquals("A", readAscii(openConnection(url)));
-    assertCookies(url, "a=SECOND");
-  }
-
   @Test public void getHeadersReturnsNetworkEndToEndHeaders() throws Exception {
     server.enqueue(new MockResponse()
         .addHeader("Allow: GET, HEAD")
@@ -1566,7 +1553,7 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
     assertEquals(Arrays.asList(expectedCookies), actualCookies);
   }
 
-  @Test public void doNotCachePartialResponse() throws Exception  {
+  @Test public void doNotCachePartialResponse() throws Exception {
     assertNotCached(new MockResponse()
         .setResponseCode(HttpURLConnection.HTTP_PARTIAL)
         .addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
@@ -1682,9 +1669,8 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
   }
 
   /**
-   * @param delta the offset from the current date to use. Negative
-   * values yield dates in the past; positive values yield dates in the
-   * future.
+   * @param delta the offset from the current date to use. Negative values yield dates in the past;
+   * positive values yield dates in the future.
    */
   private String formatDate(long delta, TimeUnit timeUnit) {
     return formatDate(new Date(System.currentTimeMillis() + timeUnit.toMillis(delta)));
@@ -1750,9 +1736,8 @@ private void assertFullyCached(MockResponse response) throws Exception {
   }
 
   /**
-   * Shortens the body of {@code response} but not the corresponding headers.
-   * Only useful to test how clients respond to the premature conclusion of
-   * the HTTP body.
+   * Shortens the body of {@code response} but not the corresponding headers. Only useful to test
+   * how clients respond to the premature conclusion of the HTTP body.
    */
   private MockResponse truncateViolently(MockResponse response, int numBytesToKeep) {
     response.setSocketPolicy(SocketPolicy.DISCONNECT_AT_END);
@@ -1801,9 +1786,8 @@ public Buffer gzip(String data) throws IOException {
   }
 
   /**
-   * Reads {@code count} characters from the stream. If the stream is
-   * exhausted before {@code count} characters can be read, the remaining
-   * characters are returned and the stream is closed.
+   * Reads {@code count} characters from the stream. If the stream is exhausted before {@code count}
+   * characters can be read, the remaining characters are returned and the stream is closed.
    */
   private String readAscii(URLConnection connection, int count) throws IOException {
     HttpURLConnection httpConnection = (HttpURLConnection) connection;
@@ -1848,8 +1832,8 @@ private void assertGatewayTimeout(HttpURLConnection connection) throws IOExcepti
   // Android-added tests.
 
   /**
-   * Test that we can interrogate the response when the cache is being
-   * populated. http://code.google.com/p/android/issues/detail?id=7787
+   * Test that we can interrogate the response when the cache is being populated.
+   * http://code.google.com/p/android/issues/detail?id=7787
    */
   @Test public void responseCacheCallbackApis() throws Exception {
     final String body = "ABCDE";
@@ -1861,7 +1845,7 @@ private void assertGatewayTimeout(HttpURLConnection connection) throws IOExcepti
         .addHeader("fgh: ijk")
         .setBody(body));
 
-    Internal.instance.setCache(client, new CacheAdapter(new AbstractResponseCache() {
+    setInternalCache(new CacheAdapter(new AbstractResponseCache() {
       @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
         HttpURLConnection httpURLConnection = (HttpURLConnection) connection;
         assertEquals(server.url("/").url(), uri.toURL());
@@ -1889,7 +1873,7 @@ private void assertGatewayTimeout(HttpURLConnection connection) throws IOExcepti
   /** Don't explode if the cache returns a null body. http://b/3373699 */
   @Test public void responseCacheReturnsNullOutputStream() throws Exception {
     final AtomicBoolean aborted = new AtomicBoolean();
-    Internal.instance.setCache(client, new CacheAdapter(new AbstractResponseCache() {
+    setInternalCache(new CacheAdapter(new AbstractResponseCache() {
       @Override public CacheRequest put(URI uri, URLConnection connection) {
         return new CacheRequest() {
           @Override public void abort() {
@@ -1919,7 +1903,7 @@ private void assertGatewayTimeout(HttpURLConnection connection) throws IOExcepti
     String cachedContentString = "Hello";
     final byte[] cachedContent = cachedContentString.getBytes(StandardCharsets.US_ASCII);
 
-    Internal.instance.setCache(client, new CacheAdapter(new AbstractResponseCache() {
+    setInternalCache(new CacheAdapter(new AbstractResponseCache() {
       @Override
       public CacheResponse get(URI uri, String requestMethod,
           Map<String, List<String>> requestHeaders)
@@ -1973,6 +1957,7 @@ private InsecureResponseCache(ResponseCache delegate) {
           @Override public InputStream getBody() throws IOException {
             return response.getBody();
           }
+
           @Override public Map<String, List<String>> getHeaders() throws IOException {
             return response.getHeaders();
           }
@@ -1987,7 +1972,7 @@ private InsecureResponseCache(ResponseCache delegate) {
     server.enqueue(new MockResponse().setBody("ABC"));
     server.enqueue(new MockResponse().setBody("DEF"));
 
-    AndroidInternal.setResponseCache(new OkUrlFactory(client), new InsecureResponseCache(cache));
+    AndroidInternal.setResponseCache(urlFactory, new InsecureResponseCache(cache));
 
     HttpsURLConnection connection1 = (HttpsURLConnection) openConnection(server.url("/").url());
     connection1.setSSLSocketFactory(sslContext.getSocketFactory());
@@ -2006,7 +1991,7 @@ private InsecureResponseCache(ResponseCache delegate) {
         .setBody("ABC"));
 
     final AtomicReference<Map<String, List<String>>> requestHeadersRef = new AtomicReference<>();
-    Internal.instance.setCache(client, new CacheAdapter(new AbstractResponseCache() {
+    setInternalCache(new CacheAdapter(new AbstractResponseCache() {
       @Override public CacheResponse get(URI uri, String requestMethod,
           Map<String, List<String>> requestHeaders) throws IOException {
         requestHeadersRef.set(requestHeaders);
@@ -2182,4 +2167,10 @@ private InsecureResponseCache(ResponseCache delegate) {
     assertFalse(connection2 instanceof HttpURLConnectionImpl);
     assertEquals("B", readAscii(connection2));
   }
+
+  private void setInternalCache(InternalCache internalCache) {
+    OkHttpClient.Builder builder = urlFactory.client().newBuilder();
+    Internal.instance.setCache(builder, internalCache);
+    urlFactory.setClient(builder.build());
+  }
 }
diff --git a/okhttp-apache/pom.xml b/okhttp-apache/pom.xml
index 6e9a797cd3..dcf813e04f 100644
--- a/okhttp-apache/pom.xml
+++ b/okhttp-apache/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.0.0-SNAPSHOT</version>
+    <version>3.1.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-apache</artifactId>
diff --git a/okhttp-apache/src/main/java/okhttp3/apache/HttpEntityBody.java b/okhttp-apache/src/main/java/okhttp3/apache/HttpEntityBody.java
index c971691f3f..45d27aafd1 100644
--- a/okhttp-apache/src/main/java/okhttp3/apache/HttpEntityBody.java
+++ b/okhttp-apache/src/main/java/okhttp3/apache/HttpEntityBody.java
@@ -1,8 +1,8 @@
 package okhttp3.apache;
 
+import java.io.IOException;
 import okhttp3.MediaType;
 import okhttp3.RequestBody;
-import java.io.IOException;
 import okio.BufferedSink;
 import org.apache.http.HttpEntity;
 
diff --git a/okhttp-apache/src/main/java/okhttp3/apache/OkApacheClient.java b/okhttp-apache/src/main/java/okhttp3/apache/OkApacheClient.java
index 2a862fa52f..a1af89f867 100644
--- a/okhttp-apache/src/main/java/okhttp3/apache/OkApacheClient.java
+++ b/okhttp-apache/src/main/java/okhttp3/apache/OkApacheClient.java
@@ -1,15 +1,15 @@
 // Copyright 2013 Square, Inc.
 package okhttp3.apache;
 
+import java.io.IOException;
+import java.net.InetSocketAddress;
+import java.net.Proxy;
 import okhttp3.Headers;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
 import okhttp3.RequestBody;
 import okhttp3.Response;
 import okhttp3.ResponseBody;
-import java.io.IOException;
-import java.net.InetSocketAddress;
-import java.net.Proxy;
 import org.apache.http.Header;
 import org.apache.http.HttpEntity;
 import org.apache.http.HttpEntityEnclosingRequest;
@@ -32,9 +32,9 @@
 import static org.apache.http.HttpVersion.HTTP_1_1;
 
 /**
- * @deprecated OkHttp will be dropping its ability to be used with {@link HttpClient} in an
- *     upcoming release. Applications that need this should either downgrade to the Apache
- *     implementation or upgrade to OkHttp's Request/Response API.
+ * @deprecated OkHttp will be dropping its ability to be used with {@link HttpClient} in an upcoming
+ * release. Applications that need this should either downgrade to the Apache implementation or
+ * upgrade to OkHttp's Request/Response API.
  */
 public final class OkApacheClient implements HttpClient {
   private static Request transformRequest(HttpRequest request) {
@@ -101,7 +101,7 @@ private static HttpResponse transformResponse(Response response) throws IOExcept
   private final HttpParams params = new AbstractHttpParams() {
     @Override public Object getParameter(String name) {
       if (name.equals(ConnRouteParams.DEFAULT_PROXY)) {
-        Proxy proxy = client.getProxy();
+        Proxy proxy = client.proxy();
         if (proxy == null) {
           return null;
         }
@@ -118,7 +118,9 @@ private static HttpResponse transformResponse(Response response) throws IOExcept
         if (host != null) {
           proxy = new Proxy(HTTP, new InetSocketAddress(host.getHostName(), host.getPort()));
         }
-        client.setProxy(proxy);
+        client = client.newBuilder()
+            .proxy(proxy)
+            .build();
         return this;
       }
       throw new IllegalArgumentException(name);
@@ -133,7 +135,7 @@ private static HttpResponse transformResponse(Response response) throws IOExcept
     }
   };
 
-  private final OkHttpClient client;
+  private OkHttpClient client;
 
   public OkApacheClient() {
     this(new OkHttpClient());
diff --git a/okhttp-apache/src/test/java/okhttp3/apache/OkApacheClientTest.java b/okhttp-apache/src/test/java/okhttp3/apache/OkApacheClientTest.java
index 8f5c3cd15c..77493a2540 100644
--- a/okhttp-apache/src/test/java/okhttp3/apache/OkApacheClientTest.java
+++ b/okhttp-apache/src/test/java/okhttp3/apache/OkApacheClientTest.java
@@ -1,13 +1,13 @@
 package okhttp3.apache;
 
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.mockwebserver.RecordedRequest;
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.URISyntaxException;
 import java.util.zip.GZIPInputStream;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
 import okio.Buffer;
 import okio.GzipSink;
 import okio.Okio;
@@ -114,20 +114,22 @@
     assertEquals("Hello, world!", request.getBody().readUtf8());
     assertEquals(request.getHeader("Content-Length"), "13");
   }
+
   @Test public void postEmptyEntity() throws Exception {
     server.enqueue(new MockResponse());
     final HttpPost post = new HttpPost(server.url("/").url().toURI());
     client.execute(post);
-    
+
     RecordedRequest request = server.takeRequest();
     assertEquals(0, request.getBodySize());
     assertNotNull(request.getBody());
   }
+
   @Test public void putEmptyEntity() throws Exception {
     server.enqueue(new MockResponse());
     final HttpPut put = new HttpPut(server.url("/").url().toURI());
     client.execute(put);
-    
+
     RecordedRequest request = server.takeRequest();
     assertEquals(0, request.getBodySize());
     assertNotNull(request.getBody());
diff --git a/okhttp-hpacktests/pom.xml b/okhttp-hpacktests/pom.xml
index 98947ce301..0a64ace197 100644
--- a/okhttp-hpacktests/pom.xml
+++ b/okhttp-hpacktests/pom.xml
@@ -1,6 +1,8 @@
 <?xml version="1.0" encoding="UTF-8"?>
 
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+<project xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
   <modelVersion>4.0.0</modelVersion>
 
   <parent>
diff --git a/okhttp-hpacktests/src/test/java/okhttp3/internal/spdy/HpackDecodeInteropTest.java b/okhttp-hpacktests/src/test/java/okhttp3/internal/spdy/HpackDecodeInteropTest.java
index bab0503a47..74ca6a2fb2 100644
--- a/okhttp-hpacktests/src/test/java/okhttp3/internal/spdy/HpackDecodeInteropTest.java
+++ b/okhttp-hpacktests/src/test/java/okhttp3/internal/spdy/HpackDecodeInteropTest.java
@@ -15,8 +15,8 @@
  */
 package okhttp3.internal.spdy;
 
-import okhttp3.internal.spdy.hpackjson.Story;
 import java.util.Collection;
+import okhttp3.internal.spdy.hpackjson.Story;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
@@ -30,7 +30,7 @@ public HpackDecodeInteropTest(Story story) {
     super(story);
   }
 
-  @Parameterized.Parameters(name="{0}")
+  @Parameterized.Parameters(name = "{0}")
   public static Collection<Story[]> createStories() throws Exception {
     return createStories(storiesForCurrentDraft());
   }
diff --git a/okhttp-hpacktests/src/test/java/okhttp3/internal/spdy/HpackDecodeTestBase.java b/okhttp-hpacktests/src/test/java/okhttp3/internal/spdy/HpackDecodeTestBase.java
index f5cc86aaf9..77c7ddf1aa 100644
--- a/okhttp-hpacktests/src/test/java/okhttp3/internal/spdy/HpackDecodeTestBase.java
+++ b/okhttp-hpacktests/src/test/java/okhttp3/internal/spdy/HpackDecodeTestBase.java
@@ -15,13 +15,13 @@
  */
 package okhttp3.internal.spdy;
 
-import okhttp3.internal.spdy.hpackjson.Case;
-import okhttp3.internal.spdy.hpackjson.HpackJsonUtil;
-import okhttp3.internal.spdy.hpackjson.Story;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.LinkedHashSet;
 import java.util.List;
+import okhttp3.internal.spdy.hpackjson.Case;
+import okhttp3.internal.spdy.hpackjson.HpackJsonUtil;
+import okhttp3.internal.spdy.hpackjson.Story;
 import okio.Buffer;
 
 import static org.junit.Assert.assertEquals;
@@ -44,7 +44,7 @@
         fail("No stories for: " + interopTestName);
       }
       for (Story story : stories) {
-        result.add(new Story[] { story });
+        result.add(new Story[] {story});
       }
     }
     return result;
@@ -60,8 +60,7 @@ public HpackDecodeTestBase(Story story) {
   }
 
   /**
-   * Expects wire to be set for all cases, and compares the decoder's output to
-   * expected headers.
+   * Expects wire to be set for all cases, and compares the decoder's output to expected headers.
    */
   protected void testDecoder() throws Exception {
     testDecoder(story);
@@ -75,9 +74,10 @@ protected void testDecoder(Story story) throws Exception {
           hpackReader.getAndResetHeaderList());
     }
   }
+
   /**
-   * Checks if {@code expected} and {@code observed} are equal when viewed as a
-   * set and headers are deduped.
+   * Checks if {@code expected} and {@code observed} are equal when viewed as a set and headers are
+   * deduped.
    *
    * TODO: See if duped headers should be preserved on decode and verify.
    */
diff --git a/okhttp-hpacktests/src/test/java/okhttp3/internal/spdy/HpackRoundTripTest.java b/okhttp-hpacktests/src/test/java/okhttp3/internal/spdy/HpackRoundTripTest.java
index 7d130c2634..22eecd7766 100644
--- a/okhttp-hpacktests/src/test/java/okhttp3/internal/spdy/HpackRoundTripTest.java
+++ b/okhttp-hpacktests/src/test/java/okhttp3/internal/spdy/HpackRoundTripTest.java
@@ -15,6 +15,7 @@
  */
 package okhttp3.internal.spdy;
 
+import java.util.Collection;
 import okhttp3.internal.spdy.hpackjson.Case;
 import okhttp3.internal.spdy.hpackjson.Story;
 import okio.Buffer;
@@ -22,8 +23,6 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
-import java.util.Collection;
-
 /**
  * Tests for round-tripping headers through hpack..
  */
@@ -34,9 +33,9 @@
 @RunWith(Parameterized.class)
 public class HpackRoundTripTest extends HpackDecodeTestBase {
 
-  private static final String[] RAW_DATA = { "raw-data" };
+  private static final String[] RAW_DATA = {"raw-data"};
 
-  @Parameterized.Parameters(name="{0}")
+  @Parameterized.Parameters(name = "{0}")
   public static Collection<Story[]> getStories() throws Exception {
     return createStories(RAW_DATA);
   }
@@ -59,5 +58,4 @@ public void testRoundTrip() throws Exception {
 
     testDecoder(story);
   }
-
 }
diff --git a/okhttp-hpacktests/src/test/java/okhttp3/internal/spdy/hpackjson/Case.java b/okhttp-hpacktests/src/test/java/okhttp3/internal/spdy/hpackjson/Case.java
index 74d413f873..6ff0eb0578 100644
--- a/okhttp-hpacktests/src/test/java/okhttp3/internal/spdy/hpackjson/Case.java
+++ b/okhttp-hpacktests/src/test/java/okhttp3/internal/spdy/hpackjson/Case.java
@@ -23,9 +23,8 @@
 import okio.ByteString;
 
 /**
- * Representation of an individual case (set of headers and wire format).
- * There are many cases for a single story.  This class is used reflectively
- * with Gson to parse stories.
+ * Representation of an individual case (set of headers and wire format). There are many cases for a
+ * single story.  This class is used reflectively with Gson to parse stories.
  */
 public class Case implements Cloneable {
 
diff --git a/okhttp-hpacktests/src/test/java/okhttp3/internal/spdy/hpackjson/HpackJsonUtil.java b/okhttp-hpacktests/src/test/java/okhttp3/internal/spdy/hpackjson/HpackJsonUtil.java
index 5e31fb29c7..f53ab78859 100644
--- a/okhttp-hpacktests/src/test/java/okhttp3/internal/spdy/hpackjson/HpackJsonUtil.java
+++ b/okhttp-hpacktests/src/test/java/okhttp3/internal/spdy/hpackjson/HpackJsonUtil.java
@@ -85,5 +85,6 @@ private static Story readStory(InputStream jsonResource) throws IOException {
     return result;
   }
 
-  private HpackJsonUtil() { } // Utilities only.
+  private HpackJsonUtil() {
+  } // Utilities only.
 }
diff --git a/okhttp-hpacktests/src/test/java/okhttp3/internal/spdy/hpackjson/Story.java b/okhttp-hpacktests/src/test/java/okhttp3/internal/spdy/hpackjson/Story.java
index a33c3a6f98..417d426c7b 100644
--- a/okhttp-hpacktests/src/test/java/okhttp3/internal/spdy/hpackjson/Story.java
+++ b/okhttp-hpacktests/src/test/java/okhttp3/internal/spdy/hpackjson/Story.java
@@ -19,8 +19,8 @@
 import java.util.List;
 
 /**
- * Representation of one story, a set of request headers to encode or decode.
- * This class is used reflectively with Gson to parse stories from files.
+ * Representation of one story, a set of request headers to encode or decode. This class is used
+ * reflectively with Gson to parse stories from files.
  */
 public class Story implements Cloneable {
 
diff --git a/okhttp-logging-interceptor/README.md b/okhttp-logging-interceptor/README.md
index a16bbd2f99..1c5dcd952a 100644
--- a/okhttp-logging-interceptor/README.md
+++ b/okhttp-logging-interceptor/README.md
@@ -4,10 +4,11 @@ Logging Interceptor
 An [OkHttp interceptor][1] which logs HTTP request and response data.
 
 ```java
-OkHttpClient client = new OkHttpClient();
 HttpLoggingInterceptor logging = new HttpLoggingInterceptor();
 logging.setLevel(Level.BASIC);
-client.interceptors().add(logging);
+OkHttpClient client = new OkHttpClient.Builder()
+  .addInterceptor(logging)
+  .build();
 ```
 
 You can change the log level at any time by calling `setLevel`.
@@ -33,7 +34,7 @@ Download
 Get via Maven:
 ```xml
 <dependency>
-  <groupId>com.squareup.okhttp</groupId>
+  <groupId>com.squareup.okhttp3</groupId>
   <artifactId>logging-interceptor</artifactId>
   <version>(insert latest version)</version>
 </dependency>
@@ -41,7 +42,7 @@ Get via Maven:
 
 or via Gradle 
 ```groovy
-compile 'com.squareup.okhttp:logging-interceptor:(insert latest version)'
+compile 'com.squareup.okhttp3:logging-interceptor:(insert latest version)'
 ```
 
 
diff --git a/okhttp-logging-interceptor/pom.xml b/okhttp-logging-interceptor/pom.xml
index 011ed00fbf..789f036075 100644
--- a/okhttp-logging-interceptor/pom.xml
+++ b/okhttp-logging-interceptor/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.0.0-SNAPSHOT</version>
+    <version>3.1.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>logging-interceptor</artifactId>
diff --git a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java
index abb6f210fd..5e738b341a 100644
--- a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java
+++ b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java
@@ -15,6 +15,10 @@
  */
 package okhttp3.logging;
 
+import java.io.IOException;
+import java.nio.charset.Charset;
+import java.nio.charset.UnsupportedCharsetException;
+import java.util.concurrent.TimeUnit;
 import okhttp3.Connection;
 import okhttp3.Headers;
 import okhttp3.Interceptor;
@@ -27,19 +31,15 @@
 import okhttp3.ResponseBody;
 import okhttp3.internal.Platform;
 import okhttp3.internal.http.HttpEngine;
-import java.io.IOException;
-import java.nio.charset.Charset;
-import java.util.concurrent.TimeUnit;
 import okio.Buffer;
 import okio.BufferedSource;
 
 /**
  * An OkHttp interceptor which logs request and response information. Can be applied as an
- * {@linkplain OkHttpClient#interceptors() application interceptor} or as a
- * {@linkplain OkHttpClient#networkInterceptors() network interceptor}.
- * <p>
- * The format of the logs created by this class should not be considered stable and may change
- * slightly between releases. If you need a stable logging format, use your own interceptor.
+ * {@linkplain OkHttpClient#interceptors() application interceptor} or as a {@linkplain
+ * OkHttpClient#networkInterceptors() network interceptor}. <p> The format of the logs created by
+ * this class should not be considered stable and may change slightly between releases. If you need
+ * a stable logging format, use your own interceptor.
  */
 public final class HttpLoggingInterceptor implements Interceptor {
   private static final Charset UTF8 = Charset.forName("UTF-8");
@@ -49,27 +49,27 @@
     NONE,
     /**
      * Logs request and response lines.
-     * <p>
-     * Example:
+     *
+     * <p>Example:
      * <pre>{@code
-     * --> POST /greeting HTTP/1.1 (3-byte body)
+     * --> POST /greeting http/1.1 (3-byte body)
      *
-     * <-- HTTP/1.1 200 OK (22ms, 6-byte body)
+     * <-- 200 OK (22ms, 6-byte body)
      * }</pre>
      */
     BASIC,
     /**
      * Logs request and response lines and their respective headers.
-     * <p>
-     * Example:
+     *
+     * <p>Example:
      * <pre>{@code
-     * --> POST /greeting HTTP/1.1
+     * --> POST /greeting http/1.1
      * Host: example.com
      * Content-Type: plain/text
      * Content-Length: 3
      * --> END POST
      *
-     * <-- HTTP/1.1 200 OK (22ms)
+     * <-- 200 OK (22ms)
      * Content-Type: plain/text
      * Content-Length: 6
      * <-- END HTTP
@@ -78,10 +78,10 @@
     HEADERS,
     /**
      * Logs request and response lines and their respective headers and bodies (if present).
-     * <p>
-     * Example:
+     *
+     * <p>Example:
      * <pre>{@code
-     * --> POST /greeting HTTP/1.1
+     * --> POST /greeting http/1.1
      * Host: example.com
      * Content-Type: plain/text
      * Content-Length: 3
@@ -89,7 +89,7 @@
      * Hi?
      * --> END GET
      *
-     * <-- HTTP/1.1 200 OK (22ms)
+     * <-- 200 OK (22ms)
      * Content-Type: plain/text
      * Content-Length: 6
      *
@@ -149,9 +149,8 @@ public Level getLevel() {
     boolean hasRequestBody = requestBody != null;
 
     Connection connection = chain.connection();
-    Protocol protocol = connection != null ? connection.getProtocol() : Protocol.HTTP_1_1;
-    String requestStartMessage =
-        "--> " + request.method() + ' ' + request.url() + ' ' + protocol(protocol);
+    Protocol protocol = connection != null ? connection.protocol() : Protocol.HTTP_1_1;
+    String requestStartMessage = "--> " + request.method() + ' ' + request.url() + ' ' + protocol;
     if (!logHeaders && hasRequestBody) {
       requestStartMessage += " (" + requestBody.contentLength() + "-byte body)";
     }
@@ -189,7 +188,7 @@ public Level getLevel() {
         Charset charset = UTF8;
         MediaType contentType = requestBody.contentType();
         if (contentType != null) {
-          contentType.charset(UTF8);
+          charset = contentType.charset(UTF8);
         }
 
         logger.log("");
@@ -205,9 +204,11 @@ public Level getLevel() {
     long tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNs);
 
     ResponseBody responseBody = response.body();
+    long contentLength = responseBody.contentLength();
+    String bodySize = contentLength != -1 ? contentLength + "-byte" : "unknown-length";
     logger.log("<-- " + response.code() + ' ' + response.message() + ' '
         + response.request().url() + " (" + tookMs + "ms" + (!logHeaders ? ", "
-        + responseBody.contentLength() + "-byte body" : "") + ')');
+        + bodySize + " body" : "") + ')');
 
     if (logHeaders) {
       Headers headers = response.headers();
@@ -227,10 +228,18 @@ public Level getLevel() {
         Charset charset = UTF8;
         MediaType contentType = responseBody.contentType();
         if (contentType != null) {
-          charset = contentType.charset(UTF8);
+          try {
+            charset = contentType.charset(UTF8);
+          } catch (UnsupportedCharsetException e) {
+            logger.log("");
+            logger.log("Couldn't decode the response body; charset is likely malformed.");
+            logger.log("<-- END HTTP");
+
+            return response;
+          }
         }
 
-        if (responseBody.contentLength() != 0) {
+        if (contentLength != 0) {
           logger.log("");
           logger.log(buffer.clone().readString(charset));
         }
@@ -246,8 +255,4 @@ private boolean bodyEncoded(Headers headers) {
     String contentEncoding = headers.get("Content-Encoding");
     return contentEncoding != null && !contentEncoding.equalsIgnoreCase("identity");
   }
-
-  private static String protocol(Protocol protocol) {
-    return protocol == Protocol.HTTP_1_0 ? "HTTP/1.0" : "HTTP/1.1";
-  }
 }
diff --git a/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java b/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java
index e31a163919..88630b500c 100644
--- a/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java
+++ b/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java
@@ -15,6 +15,10 @@
  */
 package okhttp3.logging;
 
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.regex.Pattern;
 import okhttp3.HttpUrl;
 import okhttp3.MediaType;
 import okhttp3.OkHttpClient;
@@ -24,10 +28,6 @@
 import okhttp3.logging.HttpLoggingInterceptor.Level;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.regex.Pattern;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.ByteString;
@@ -46,7 +46,7 @@
 
   @Rule public final MockWebServer server = new MockWebServer();
 
-  private final OkHttpClient client = new OkHttpClient();
+  private OkHttpClient client;
   private String host;
   private HttpUrl url;
 
@@ -64,9 +64,10 @@ private void setLevel(Level level) {
   }
 
   @Before public void setUp() {
-    client.networkInterceptors().add(networkInterceptor);
-    client.interceptors().add(applicationInterceptor);
-    client.setConnectionPool(null);
+    client = new OkHttpClient.Builder()
+        .addNetworkInterceptor(networkInterceptor)
+        .addInterceptor(applicationInterceptor)
+        .build();
 
     host = server.getHostName() + ":" + server.getPort();
     url = server.url("/");
@@ -112,12 +113,12 @@ private void setLevel(Level level) {
     client.newCall(request().build()).execute();
 
     applicationLogs
-        .assertLogEqual("--> GET " + url + " HTTP/1.1")
+        .assertLogEqual("--> GET " + url + " http/1.1")
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms, 0-byte body\\)")
         .assertNoMoreLogs();
 
     networkLogs
-        .assertLogEqual("--> GET " + url + " HTTP/1.1")
+        .assertLogEqual("--> GET " + url + " http/1.1")
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms, 0-byte body\\)")
         .assertNoMoreLogs();
   }
@@ -129,12 +130,12 @@ private void setLevel(Level level) {
     client.newCall(request().post(RequestBody.create(PLAIN, "Hi?")).build()).execute();
 
     applicationLogs
-        .assertLogEqual("--> POST " + url + " HTTP/1.1 (3-byte body)")
+        .assertLogEqual("--> POST " + url + " http/1.1 (3-byte body)")
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms, 0-byte body\\)")
         .assertNoMoreLogs();
 
     networkLogs
-        .assertLogEqual("--> POST " + url + " HTTP/1.1 (3-byte body)")
+        .assertLogEqual("--> POST " + url + " http/1.1 (3-byte body)")
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms, 0-byte body\\)")
         .assertNoMoreLogs();
   }
@@ -149,16 +150,36 @@ private void setLevel(Level level) {
     response.body().close();
 
     applicationLogs
-        .assertLogEqual("--> GET " + url + " HTTP/1.1")
+        .assertLogEqual("--> GET " + url + " http/1.1")
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms, 6-byte body\\)")
         .assertNoMoreLogs();
 
     networkLogs
-        .assertLogEqual("--> GET " + url + " HTTP/1.1")
+        .assertLogEqual("--> GET " + url + " http/1.1")
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms, 6-byte body\\)")
         .assertNoMoreLogs();
   }
 
+  @Test public void basicChunkedResponseBody() throws IOException {
+    setLevel(Level.BASIC);
+
+    server.enqueue(new MockResponse()
+        .setChunkedBody("Hello!", 2)
+        .setHeader("Content-Type", PLAIN));
+    Response response = client.newCall(request().build()).execute();
+    response.body().close();
+
+    applicationLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms, unknown-length body\\)")
+        .assertNoMoreLogs();
+
+    networkLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms, unknown-length body\\)")
+        .assertNoMoreLogs();
+  }
+
   @Test public void headersGet() throws IOException {
     setLevel(Level.HEADERS);
 
@@ -167,7 +188,7 @@ private void setLevel(Level level) {
     response.body().close();
 
     applicationLogs
-        .assertLogEqual("--> GET " + url + " HTTP/1.1")
+        .assertLogEqual("--> GET " + url + " http/1.1")
         .assertLogEqual("--> END GET")
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
         .assertLogEqual("Content-Length: 0")
@@ -177,7 +198,7 @@ private void setLevel(Level level) {
         .assertNoMoreLogs();
 
     networkLogs
-        .assertLogEqual("--> GET " + url + " HTTP/1.1")
+        .assertLogEqual("--> GET " + url + " http/1.1")
         .assertLogEqual("Host: " + host)
         .assertLogEqual("Connection: Keep-Alive")
         .assertLogEqual("Accept-Encoding: gzip")
@@ -200,7 +221,7 @@ private void setLevel(Level level) {
     response.body().close();
 
     applicationLogs
-        .assertLogEqual("--> POST " + url + " HTTP/1.1")
+        .assertLogEqual("--> POST " + url + " http/1.1")
         .assertLogEqual("Content-Type: text/plain; charset=utf-8")
         .assertLogEqual("Content-Length: 3")
         .assertLogEqual("--> END POST")
@@ -212,7 +233,7 @@ private void setLevel(Level level) {
         .assertNoMoreLogs();
 
     networkLogs
-        .assertLogEqual("--> POST " + url + " HTTP/1.1")
+        .assertLogEqual("--> POST " + url + " http/1.1")
         .assertLogEqual("Content-Type: text/plain; charset=utf-8")
         .assertLogEqual("Content-Length: 3")
         .assertLogEqual("Host: " + host)
@@ -237,7 +258,7 @@ private void setLevel(Level level) {
     response.body().close();
 
     applicationLogs
-        .assertLogEqual("--> POST " + url + " HTTP/1.1")
+        .assertLogEqual("--> POST " + url + " http/1.1")
         .assertLogEqual("Content-Length: 3")
         .assertLogEqual("--> END POST")
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
@@ -248,7 +269,7 @@ private void setLevel(Level level) {
         .assertNoMoreLogs();
 
     networkLogs
-        .assertLogEqual("--> POST " + url + " HTTP/1.1")
+        .assertLogEqual("--> POST " + url + " http/1.1")
         .assertLogEqual("Content-Length: 3")
         .assertLogEqual("Host: " + host)
         .assertLogEqual("Connection: Keep-Alive")
@@ -280,7 +301,7 @@ private void setLevel(Level level) {
     response.body().close();
 
     applicationLogs
-        .assertLogEqual("--> POST " + url + " HTTP/1.1")
+        .assertLogEqual("--> POST " + url + " http/1.1")
         .assertLogEqual("Content-Type: text/plain; charset=utf-8")
         .assertLogEqual("--> END POST")
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
@@ -291,7 +312,7 @@ private void setLevel(Level level) {
         .assertNoMoreLogs();
 
     networkLogs
-        .assertLogEqual("--> POST " + url + " HTTP/1.1")
+        .assertLogEqual("--> POST " + url + " http/1.1")
         .assertLogEqual("Content-Type: text/plain; charset=utf-8")
         .assertLogEqual("Transfer-Encoding: chunked")
         .assertLogEqual("Host: " + host)
@@ -317,7 +338,7 @@ private void setLevel(Level level) {
     response.body().close();
 
     applicationLogs
-        .assertLogEqual("--> GET " + url + " HTTP/1.1")
+        .assertLogEqual("--> GET " + url + " http/1.1")
         .assertLogEqual("--> END GET")
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
         .assertLogEqual("Content-Length: 6")
@@ -328,7 +349,7 @@ private void setLevel(Level level) {
         .assertNoMoreLogs();
 
     networkLogs
-        .assertLogEqual("--> GET " + url + " HTTP/1.1")
+        .assertLogEqual("--> GET " + url + " http/1.1")
         .assertLogEqual("Host: " + host)
         .assertLogEqual("Connection: Keep-Alive")
         .assertLogEqual("Accept-Encoding: gzip")
@@ -351,7 +372,7 @@ private void setLevel(Level level) {
     response.body().close();
 
     applicationLogs
-        .assertLogEqual("--> GET " + url + " HTTP/1.1")
+        .assertLogEqual("--> GET " + url + " http/1.1")
         .assertLogEqual("--> END GET")
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
         .assertLogEqual("Content-Length: 0")
@@ -361,7 +382,7 @@ private void setLevel(Level level) {
         .assertNoMoreLogs();
 
     networkLogs
-        .assertLogEqual("--> GET " + url + " HTTP/1.1")
+        .assertLogEqual("--> GET " + url + " http/1.1")
         .assertLogEqual("Host: " + host)
         .assertLogEqual("Connection: Keep-Alive")
         .assertLogEqual("Accept-Encoding: gzip")
@@ -392,7 +413,7 @@ private void bodyGetNoBody(int code) throws IOException {
     response.body().close();
 
     applicationLogs
-        .assertLogEqual("--> GET " + url + " HTTP/1.1")
+        .assertLogEqual("--> GET " + url + " http/1.1")
         .assertLogEqual("--> END GET")
         .assertLogMatch("<-- " + code + " No Content " + url + " \\(\\d+ms\\)")
         .assertLogEqual("Content-Length: 0")
@@ -402,7 +423,7 @@ private void bodyGetNoBody(int code) throws IOException {
         .assertNoMoreLogs();
 
     networkLogs
-        .assertLogEqual("--> GET " + url + " HTTP/1.1")
+        .assertLogEqual("--> GET " + url + " http/1.1")
         .assertLogEqual("Host: " + host)
         .assertLogEqual("Connection: Keep-Alive")
         .assertLogEqual("Accept-Encoding: gzip")
@@ -425,7 +446,7 @@ private void bodyGetNoBody(int code) throws IOException {
     response.body().close();
 
     applicationLogs
-        .assertLogEqual("--> POST " + url + " HTTP/1.1")
+        .assertLogEqual("--> POST " + url + " http/1.1")
         .assertLogEqual("Content-Type: text/plain; charset=utf-8")
         .assertLogEqual("Content-Length: 3")
         .assertLogEqual("")
@@ -439,7 +460,7 @@ private void bodyGetNoBody(int code) throws IOException {
         .assertNoMoreLogs();
 
     networkLogs
-        .assertLogEqual("--> POST " + url + " HTTP/1.1")
+        .assertLogEqual("--> POST " + url + " http/1.1")
         .assertLogEqual("Content-Type: text/plain; charset=utf-8")
         .assertLogEqual("Content-Length: 3")
         .assertLogEqual("Host: " + host)
@@ -467,7 +488,7 @@ private void bodyGetNoBody(int code) throws IOException {
     response.body().close();
 
     applicationLogs
-        .assertLogEqual("--> GET " + url + " HTTP/1.1")
+        .assertLogEqual("--> GET " + url + " http/1.1")
         .assertLogEqual("--> END GET")
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
         .assertLogEqual("Content-Length: 6")
@@ -480,7 +501,7 @@ private void bodyGetNoBody(int code) throws IOException {
         .assertNoMoreLogs();
 
     networkLogs
-        .assertLogEqual("--> GET " + url + " HTTP/1.1")
+        .assertLogEqual("--> GET " + url + " http/1.1")
         .assertLogEqual("Host: " + host)
         .assertLogEqual("Connection: Keep-Alive")
         .assertLogEqual("Accept-Encoding: gzip")
@@ -507,7 +528,7 @@ private void bodyGetNoBody(int code) throws IOException {
     response.body().close();
 
     applicationLogs
-        .assertLogEqual("--> GET " + url + " HTTP/1.1")
+        .assertLogEqual("--> GET " + url + " http/1.1")
         .assertLogEqual("--> END GET")
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
         .assertLogEqual("Transfer-encoding: chunked")
@@ -520,7 +541,7 @@ private void bodyGetNoBody(int code) throws IOException {
         .assertNoMoreLogs();
 
     networkLogs
-        .assertLogEqual("--> GET " + url + " HTTP/1.1")
+        .assertLogEqual("--> GET " + url + " http/1.1")
         .assertLogEqual("Host: " + host)
         .assertLogEqual("Connection: Keep-Alive")
         .assertLogEqual("Accept-Encoding: gzip")
@@ -549,7 +570,7 @@ private void bodyGetNoBody(int code) throws IOException {
     response.body().close();
 
     networkLogs
-        .assertLogEqual("--> GET " + url + " HTTP/1.1")
+        .assertLogEqual("--> GET " + url + " http/1.1")
         .assertLogEqual("Host: " + host)
         .assertLogEqual("Connection: Keep-Alive")
         .assertLogEqual("Accept-Encoding: gzip")
@@ -565,7 +586,7 @@ private void bodyGetNoBody(int code) throws IOException {
         .assertNoMoreLogs();
 
     applicationLogs
-        .assertLogEqual("--> GET " + url + " HTTP/1.1")
+        .assertLogEqual("--> GET " + url + " http/1.1")
         .assertLogEqual("--> END GET")
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
         .assertLogEqual("Content-Type: text/plain; charset=utf-8")
@@ -577,6 +598,46 @@ private void bodyGetNoBody(int code) throws IOException {
         .assertNoMoreLogs();
   }
 
+  @Test public void bodyGetMalformedCharset() throws IOException {
+    setLevel(Level.BODY);
+
+    server.enqueue(new MockResponse()
+        .setHeader("Content-Type", "text/html; charset=0")
+        .setBody("Ignore This"));
+    Response response = client.newCall(request().build()).execute();
+    response.body().close();
+
+    networkLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("Host: " + host)
+        .assertLogEqual("Connection: Keep-Alive")
+        .assertLogEqual("Accept-Encoding: gzip")
+        .assertLogMatch("User-Agent: okhttp/.+")
+        .assertLogEqual("--> END GET")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Type: text/html; charset=0")
+        .assertLogMatch("Content-Length: \\d+")
+        .assertLogMatch("OkHttp-Sent-Millis: \\d+")
+        .assertLogMatch("OkHttp-Received-Millis: \\d+")
+        .assertLogMatch("")
+        .assertLogEqual("Couldn't decode the response body; charset is likely malformed.")
+        .assertLogEqual("<-- END HTTP")
+        .assertNoMoreLogs();
+
+    applicationLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("--> END GET")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Type: text/html; charset=0")
+        .assertLogMatch("Content-Length: \\d+")
+        .assertLogMatch("OkHttp-Sent-Millis: \\d+")
+        .assertLogMatch("OkHttp-Received-Millis: \\d+")
+        .assertLogEqual("")
+        .assertLogEqual("Couldn't decode the response body; charset is likely malformed.")
+        .assertLogEqual("<-- END HTTP")
+        .assertNoMoreLogs();
+  }
+
   private Request.Builder request() {
     return new Request.Builder().url(url);
   }
diff --git a/okhttp-testing-support/pom.xml b/okhttp-testing-support/pom.xml
index d363749faa..a11bef1489 100644
--- a/okhttp-testing-support/pom.xml
+++ b/okhttp-testing-support/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.0.0-SNAPSHOT</version>
+    <version>3.1.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-testing-support</artifactId>
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/FakeDns.java b/okhttp-testing-support/src/main/java/okhttp3/FakeDns.java
similarity index 97%
rename from okhttp-tests/src/test/java/okhttp3/internal/http/FakeDns.java
rename to okhttp-testing-support/src/main/java/okhttp3/FakeDns.java
index a8e5a8687f..f2edc75d66 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http/FakeDns.java
+++ b/okhttp-testing-support/src/main/java/okhttp3/FakeDns.java
@@ -13,9 +13,8 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.http;
+package okhttp3;
 
-import okhttp3.Dns;
 import java.net.InetAddress;
 import java.net.UnknownHostException;
 import java.util.ArrayList;
diff --git a/okhttp-testing-support/src/main/java/okhttp3/FakeProxySelector.java b/okhttp-testing-support/src/main/java/okhttp3/FakeProxySelector.java
new file mode 100644
index 0000000000..c7d37f57ea
--- /dev/null
+++ b/okhttp-testing-support/src/main/java/okhttp3/FakeProxySelector.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.net.Proxy;
+import java.net.ProxySelector;
+import java.net.SocketAddress;
+import java.net.URI;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+public final class FakeProxySelector extends ProxySelector {
+  public final List<Proxy> proxies = new ArrayList<>();
+
+  public FakeProxySelector addProxy(Proxy proxy) {
+    proxies.add(proxy);
+    return this;
+  }
+
+  @Override public List<Proxy> select(URI uri) {
+    // Don't handle 'socket' schemes, which the RI's Socket class may request (for SOCKS).
+    return uri.getScheme().equals("http") || uri.getScheme().equals("https") ? proxies
+        : Collections.singletonList(Proxy.NO_PROXY);
+  }
+
+  @Override public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/tls/FakeSSLSession.java b/okhttp-testing-support/src/main/java/okhttp3/FakeSSLSession.java
similarity index 97%
rename from okhttp-tests/src/test/java/okhttp3/internal/tls/FakeSSLSession.java
rename to okhttp-testing-support/src/main/java/okhttp3/FakeSSLSession.java
index ead8c1b871..ab67a9f06e 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/tls/FakeSSLSession.java
+++ b/okhttp-testing-support/src/main/java/okhttp3/FakeSSLSession.java
@@ -14,7 +14,7 @@
  * License for the specific language governing permissions and limitations under
  * the License.
  */
-package okhttp3.internal.tls;
+package okhttp3;
 
 import java.security.Principal;
 import java.security.cert.Certificate;
@@ -23,7 +23,7 @@
 import javax.net.ssl.SSLSessionContext;
 import javax.security.cert.X509Certificate;
 
-final class FakeSSLSession implements SSLSession {
+public final class FakeSSLSession implements SSLSession {
   private final Certificate[] certificates;
 
   public FakeSSLSession(Certificate... certificates) throws Exception {
diff --git a/okhttp-testing-support/src/main/java/okhttp3/RecordingCookieJar.java b/okhttp-testing-support/src/main/java/okhttp3/RecordingCookieJar.java
new file mode 100644
index 0000000000..bd4f9be142
--- /dev/null
+++ b/okhttp-testing-support/src/main/java/okhttp3/RecordingCookieJar.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.Deque;
+import java.util.List;
+
+import static org.junit.Assert.assertEquals;
+
+public final class RecordingCookieJar implements CookieJar {
+  private final Deque<List<Cookie>> requestCookies = new ArrayDeque<>();
+  private final Deque<List<Cookie>> responseCookies = new ArrayDeque<>();
+
+  public void enqueueRequestCookies(Cookie... cookies) {
+    requestCookies.add(Arrays.asList(cookies));
+  }
+
+  public List<Cookie> takeResponseCookies() {
+    return responseCookies.removeFirst();
+  }
+
+  public void assertResponseCookies(String... cookies) {
+    List<Cookie> actualCookies = takeResponseCookies();
+    List<String> actualCookieStrings = new ArrayList<>();
+    for (Cookie cookie : actualCookies) {
+      actualCookieStrings.add(cookie.toString());
+    }
+    assertEquals(Arrays.asList(cookies), actualCookieStrings);
+  }
+
+  @Override public void saveFromResponse(HttpUrl url, List<Cookie> cookies) {
+    responseCookies.add(cookies);
+  }
+
+  @Override public List<Cookie> loadForRequest(HttpUrl url) {
+    if (requestCookies.isEmpty()) return Collections.emptyList();
+    return requestCookies.removeFirst();
+  }
+}
diff --git a/okhttp-testing-support/src/main/java/okhttp3/testing/RecordingHostnameVerifier.java b/okhttp-testing-support/src/main/java/okhttp3/RecordingHostnameVerifier.java
similarity index 97%
rename from okhttp-testing-support/src/main/java/okhttp3/testing/RecordingHostnameVerifier.java
rename to okhttp-testing-support/src/main/java/okhttp3/RecordingHostnameVerifier.java
index 7b682e56db..568b7c518c 100644
--- a/okhttp-testing-support/src/main/java/okhttp3/testing/RecordingHostnameVerifier.java
+++ b/okhttp-testing-support/src/main/java/okhttp3/RecordingHostnameVerifier.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.testing;
+package okhttp3;
 
 import java.util.ArrayList;
 import java.util.List;
diff --git a/okhttp-testing-support/src/main/java/okhttp3/testing/InstallUncaughtExceptionHandlerListener.java b/okhttp-testing-support/src/main/java/okhttp3/testing/InstallUncaughtExceptionHandlerListener.java
index bcb4df7a21..38652c07de 100644
--- a/okhttp-testing-support/src/main/java/okhttp3/testing/InstallUncaughtExceptionHandlerListener.java
+++ b/okhttp-testing-support/src/main/java/okhttp3/testing/InstallUncaughtExceptionHandlerListener.java
@@ -15,18 +15,16 @@
  */
 package okhttp3.testing;
 
+import java.io.PrintWriter;
+import java.io.StringWriter;
 import org.junit.runner.Description;
 import org.junit.runner.Result;
 import org.junit.runner.notification.RunListener;
 
-import java.io.PrintWriter;
-import java.io.StringWriter;
-
 /**
- * A {@link org.junit.runner.notification.RunListener} used to install an aggressive default
- * {@link java.lang.Thread.UncaughtExceptionHandler} similar to the one found on Android.
- * No exceptions should escape from OkHttp that might cause apps to be killed or tests to fail on
- * Android.
+ * A {@link org.junit.runner.notification.RunListener} used to install an aggressive default {@link
+ * java.lang.Thread.UncaughtExceptionHandler} similar to the one found on Android. No exceptions
+ * should escape from OkHttp that might cause apps to be killed or tests to fail on Android.
  */
 public class InstallUncaughtExceptionHandlerListener extends RunListener {
 
diff --git a/okhttp-tests/pom.xml b/okhttp-tests/pom.xml
index cb0c01793b..59383f4c59 100644
--- a/okhttp-tests/pom.xml
+++ b/okhttp-tests/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.0.0-SNAPSHOT</version>
+    <version>3.1.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-tests</artifactId>
diff --git a/okhttp-tests/src/test/java/okhttp3/AddressTest.java b/okhttp-tests/src/test/java/okhttp3/AddressTest.java
index 5f346c9787..30e376be5b 100644
--- a/okhttp-tests/src/test/java/okhttp3/AddressTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/AddressTest.java
@@ -15,11 +15,10 @@
  */
 package okhttp3;
 
-import okhttp3.internal.Util;
-import okhttp3.internal.http.AuthenticatorAdapter;
-import okhttp3.internal.http.RecordingProxySelector;
 import java.util.List;
 import javax.net.SocketFactory;
+import okhttp3.internal.Util;
+import okhttp3.internal.http.RecordingProxySelector;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
@@ -28,7 +27,7 @@
 public final class AddressTest {
   private Dns dns = Dns.SYSTEM;
   private SocketFactory socketFactory = SocketFactory.getDefault();
-  private Authenticator authenticator = AuthenticatorAdapter.INSTANCE;
+  private Authenticator authenticator = Authenticator.NONE;
   private List<Protocol> protocols = Util.immutableList(Protocol.HTTP_1_1);
   private List<ConnectionSpec> connectionSpecs = Util.immutableList(ConnectionSpec.MODERN_TLS);
   private RecordingProxySelector proxySelector = new RecordingProxySelector();
diff --git a/okhttp-tests/src/test/java/okhttp3/CacheTest.java b/okhttp-tests/src/test/java/okhttp3/CacheTest.java
index c6d77d7f30..4596bb6155 100644
--- a/okhttp-tests/src/test/java/okhttp3/CacheTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CacheTest.java
@@ -16,16 +16,8 @@
 
 package okhttp3;
 
-import okhttp3.internal.Internal;
-import okhttp3.internal.SslContextBuilder;
-import okhttp3.internal.Util;
-import okhttp3.internal.io.InMemoryFileSystem;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.mockwebserver.RecordedRequest;
 import java.io.File;
 import java.io.IOException;
-import java.net.CookieHandler;
 import java.net.CookieManager;
 import java.net.HttpCookie;
 import java.net.HttpURLConnection;
@@ -47,6 +39,13 @@
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLSession;
+import okhttp3.internal.Internal;
+import okhttp3.internal.SslContextBuilder;
+import okhttp3.internal.Util;
+import okhttp3.internal.io.InMemoryFileSystem;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -65,7 +64,6 @@
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
-/** Test caching with {@link OkUrlFactory}. */
 public final class CacheTest {
   private static final HostnameVerifier NULL_HOSTNAME_VERIFIER = new HostnameVerifier() {
     @Override public boolean verify(String s, SSLSession sslSession) {
@@ -78,20 +76,21 @@
   @Rule public InMemoryFileSystem fileSystem = new InMemoryFileSystem();
 
   private final SSLContext sslContext = SslContextBuilder.localhost();
-  private final OkHttpClient client = new OkHttpClient();
+  private OkHttpClient client;
   private Cache cache;
   private final CookieManager cookieManager = new CookieManager();
 
   @Before public void setUp() throws Exception {
     server.setProtocolNegotiationEnabled(false);
     cache = new Cache(new File("/cache/"), Integer.MAX_VALUE, fileSystem);
-    client.setCache(cache);
-    CookieHandler.setDefault(cookieManager);
+    client = new OkHttpClient.Builder()
+        .cache(cache)
+        .cookieJar(new JavaNetCookieJar(cookieManager))
+        .build();
   }
 
   @After public void tearDown() throws Exception {
     ResponseCache.setDefault(null);
-    CookieHandler.setDefault(null);
     cache.delete();
   }
 
@@ -107,45 +106,45 @@
     // assertCached(false, 100);
     assertCached(false, 101);
     assertCached(false, 102);
-    assertCached(true,  200);
+    assertCached(true, 200);
     assertCached(false, 201);
     assertCached(false, 202);
-    assertCached(true,  203);
-    assertCached(true,  204);
+    assertCached(true, 203);
+    assertCached(true, 204);
     assertCached(false, 205);
     assertCached(false, 206); //Electing to not cache partial responses
     assertCached(false, 207);
-    assertCached(true,  300);
-    assertCached(true,  301);
-    assertCached(true,  302);
+    assertCached(true, 300);
+    assertCached(true, 301);
+    assertCached(true, 302);
     assertCached(false, 303);
     assertCached(false, 304);
     assertCached(false, 305);
     assertCached(false, 306);
-    assertCached(true,  307);
-    assertCached(true,  308);
+    assertCached(true, 307);
+    assertCached(true, 308);
     assertCached(false, 400);
     assertCached(false, 401);
     assertCached(false, 402);
     assertCached(false, 403);
-    assertCached(true,  404);
-    assertCached(true,  405);
+    assertCached(true, 404);
+    assertCached(true, 405);
     assertCached(false, 406);
     assertCached(false, 408);
     assertCached(false, 409);
     // the HTTP spec permits caching 410s, but the RI doesn't.
-    assertCached(true,  410);
+    assertCached(true, 410);
     assertCached(false, 411);
     assertCached(false, 412);
     assertCached(false, 413);
-    assertCached(true,  414);
+    assertCached(true, 414);
     assertCached(false, 415);
     assertCached(false, 416);
     assertCached(false, 417);
     assertCached(false, 418);
 
     assertCached(false, 500);
-    assertCached(true,  501);
+    assertCached(true, 501);
     assertCached(false, 502);
     assertCached(false, 503);
     assertCached(false, 504);
@@ -225,8 +224,8 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     assertEquals("spiders", in1.readUtf8("spiders".length()));
     assertTrue(in1.exhausted());
     in1.close();
-    assertEquals(1, cache.getWriteSuccessCount());
-    assertEquals(0, cache.getWriteAbortCount());
+    assertEquals(1, cache.writeSuccessCount());
+    assertEquals(0, cache.writeAbortCount());
 
     Response response2 = client.newCall(request).execute();
     BufferedSource in2 = response2.body().source();
@@ -237,10 +236,10 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
 
     assertTrue(in2.exhausted());
     in2.close();
-    assertEquals(1, cache.getWriteSuccessCount());
-    assertEquals(0, cache.getWriteAbortCount());
-    assertEquals(2, cache.getRequestCount());
-    assertEquals(1, cache.getHitCount());
+    assertEquals(1, cache.writeSuccessCount());
+    assertEquals(0, cache.writeAbortCount());
+    assertEquals(2, cache.requestCount());
+    assertEquals(1, cache.hitCount());
   }
 
   @Test public void secureResponseCaching() throws IOException {
@@ -250,8 +249,10 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .setBody("ABC"));
 
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+    client = client.newBuilder()
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
+        .build();
 
     Request request = new Request.Builder().url(server.url("/")).build();
     Response response1 = client.newCall(request).execute();
@@ -268,9 +269,9 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     Response response2 = client.newCall(request).execute(); // Cached!
     assertEquals("ABC", response2.body().string());
 
-    assertEquals(2, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(1, cache.getHitCount());
+    assertEquals(2, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(1, cache.hitCount());
 
     assertEquals(cipherSuite, response2.handshake().cipherSuite());
     assertEquals(localCerts, response2.handshake().localCertificates());
@@ -299,9 +300,9 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     Response response2 = client.newCall(request).execute(); // Cached!
     assertEquals("ABC", response2.body().string());
 
-    assertEquals(4, cache.getRequestCount()); // 2 requests + 2 redirects
-    assertEquals(2, cache.getNetworkCount());
-    assertEquals(2, cache.getHitCount());
+    assertEquals(4, cache.requestCount()); // 2 requests + 2 redirects
+    assertEquals(2, cache.networkCount());
+    assertEquals(2, cache.hitCount());
   }
 
   @Test public void redirectToCachedResult() throws Exception {
@@ -351,8 +352,10 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     server.enqueue(new MockResponse()
         .setBody("DEF"));
 
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+    client = client.newBuilder()
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
+        .build();
 
     Response response1 = get(server.url("/"));
     assertEquals("ABC", response1.body().string());
@@ -363,16 +366,15 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     assertEquals("ABC", response2.body().string());
     assertNotNull(response2.handshake().cipherSuite());
 
-    assertEquals(4, cache.getRequestCount()); // 2 direct + 2 redirect = 4
-    assertEquals(2, cache.getHitCount());
+    assertEquals(4, cache.requestCount()); // 2 direct + 2 redirect = 4
+    assertEquals(2, cache.hitCount());
     assertEquals(response1.handshake().cipherSuite(), response2.handshake().cipherSuite());
   }
 
   /**
-   * We've had bugs where caching and cross-protocol redirects yield class
-   * cast exceptions internal to the cache because we incorrectly assumed that
-   * HttpsURLConnection was always HTTPS and HttpURLConnection was always HTTP;
-   * in practice redirects mean that each can do either.
+   * We've had bugs where caching and cross-protocol redirects yield class cast exceptions internal
+   * to the cache because we incorrectly assumed that HttpsURLConnection was always HTTPS and
+   * HttpURLConnection was always HTTP; in practice redirects mean that each can do either.
    *
    * https://github.com/square/okhttp/issues/214
    */
@@ -391,8 +393,10 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
         .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
         .addHeader("Location: " + server2.url("/")));
 
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+    client = client.newBuilder()
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
+        .build();
 
     Response response1 = get(server.url("/"));
     assertEquals("ABC", response1.body().string());
@@ -401,8 +405,8 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     Response response2 = get(server.url("/"));
     assertEquals("ABC", response2.body().string());
 
-    assertEquals(4, cache.getRequestCount()); // 2 direct + 2 redirect = 4
-    assertEquals(2, cache.getHitCount());
+    assertEquals(4, cache.requestCount()); // 2 direct + 2 redirect = 4
+    assertEquals(2, cache.hitCount());
   }
 
   @Test public void foundCachedWithExpiresHeader() throws Exception {
@@ -462,6 +466,26 @@ private void temporaryRedirectNotCachedWithoutCachingHeader(int responseCode) th
     assertEquals("b", get(url).body().string());
   }
 
+  /** https://github.com/square/okhttp/issues/2198 */
+  @Test public void cachedRedirect() throws IOException {
+    server.enqueue(new MockResponse()
+        .setResponseCode(301)
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Location: /bar"));
+    server.enqueue(new MockResponse()
+        .setBody("ABC"));
+    server.enqueue(new MockResponse()
+        .setBody("ABC"));
+
+    Request request1 = new Request.Builder().url(server.url("/")).build();
+    Response response1 = client.newCall(request1).execute();
+    assertEquals("ABC", response1.body().string());
+
+    Request request2 = new Request.Builder().url(server.url("/")).build();
+    Response response2 = client.newCall(request2).execute();
+    assertEquals("ABC", response2.body().string());
+  }
+
   @Test public void serverDisconnectsPrematurelyWithContentLengthHeader() throws IOException {
     testServerPrematureDisconnect(TransferKind.FIXED_LENGTH);
   }
@@ -493,12 +517,12 @@ private void testServerPrematureDisconnect(TransferKind transferKind) throws IOE
       bodySource.close();
     }
 
-    assertEquals(1, cache.getWriteAbortCount());
-    assertEquals(0, cache.getWriteSuccessCount());
+    assertEquals(1, cache.writeAbortCount());
+    assertEquals(0, cache.writeSuccessCount());
     Response response = get(server.url("/"));
     assertEquals("Request #2", response.body().string());
-    assertEquals(1, cache.getWriteAbortCount());
-    assertEquals(1, cache.getWriteSuccessCount());
+    assertEquals(1, cache.writeAbortCount());
+    assertEquals(1, cache.writeSuccessCount());
   }
 
   @Test public void clientPrematureDisconnectWithContentLengthHeader() throws IOException {
@@ -532,12 +556,12 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
     } catch (IllegalStateException expected) {
     }
 
-    assertEquals(1, cache.getWriteAbortCount());
-    assertEquals(0, cache.getWriteSuccessCount());
+    assertEquals(1, cache.writeAbortCount());
+    assertEquals(0, cache.writeSuccessCount());
     Response response2 = get(server.url("/"));
     assertEquals("Request #2", response2.body().string());
-    assertEquals(1, cache.getWriteAbortCount());
-    assertEquals(1, cache.getWriteSuccessCount());
+    assertEquals(1, cache.writeAbortCount());
+    assertEquals(1, cache.writeSuccessCount());
   }
 
   @Test public void defaultExpirationDateFullyCachedForLessThan24Hours() throws Exception {
@@ -740,8 +764,8 @@ private void testRequestMethod(String requestMethod, boolean expectCached) throw
 
   private RequestBody requestBodyOrNull(String requestMethod) {
     return (requestMethod.equals("POST") || requestMethod.equals("PUT"))
-          ? RequestBody.create(MediaType.parse("text/plain"), "foo")
-          : null;
+        ? RequestBody.create(MediaType.parse("text/plain"), "foo")
+        : null;
   }
 
   @Test public void postInvalidatesCache() throws Exception {
@@ -1001,13 +1025,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .clearHeaders()
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    ConnectionPool pool = ConnectionPool.getDefault();
-    pool.evictAll();
-    client.setConnectionPool(pool);
-
     assertEquals("A", get(server.url("/")).body().string());
     assertEquals("A", get(server.url("/")).body().string());
-    assertEquals(1, client.getConnectionPool().getIdleConnectionCount());
+    assertEquals(1, client.connectionPool().idleConnectionCount());
   }
 
   @Test public void expiresDateBeforeModifiedDate() throws Exception {
@@ -1121,9 +1141,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     Response response = client.newCall(request).execute();
     assertTrue(response.body().source().exhausted());
     assertEquals(504, response.code());
-    assertEquals(1, cache.getRequestCount());
-    assertEquals(0, cache.getNetworkCount());
-    assertEquals(0, cache.getHitCount());
+    assertEquals(1, cache.requestCount());
+    assertEquals(0, cache.networkCount());
+    assertEquals(0, cache.hitCount());
   }
 
   @Test public void requestOnlyIfCachedWithFullResponseCached() throws IOException {
@@ -1139,9 +1159,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .build();
     Response response = client.newCall(request).execute();
     assertEquals("A", response.body().string());
-    assertEquals(2, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(1, cache.getHitCount());
+    assertEquals(2, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(1, cache.hitCount());
   }
 
   @Test public void requestOnlyIfCachedWithConditionalResponseCached() throws IOException {
@@ -1158,9 +1178,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     Response response = client.newCall(request).execute();
     assertTrue(response.body().source().exhausted());
     assertEquals(504, response.code());
-    assertEquals(2, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(0, cache.getHitCount());
+    assertEquals(2, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(0, cache.hitCount());
   }
 
   @Test public void requestOnlyIfCachedWithUnhelpfulResponseCached() throws IOException {
@@ -1175,9 +1195,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     Response response = client.newCall(request).execute();
     assertTrue(response.body().source().exhausted());
     assertEquals(504, response.code());
-    assertEquals(2, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(0, cache.getHitCount());
+    assertEquals(2, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(0, cache.hitCount());
   }
 
   @Test public void requestCacheControlNoCache() throws Exception {
@@ -1262,8 +1282,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
   }
 
   /**
-   * For Last-Modified and Date headers, we should echo the date back in the
-   * exact format we were served.
+   * For Last-Modified and Date headers, we should echo the date back in the exact format we were
+   * served.
    */
   @Test public void retainServedDateFormat() throws Exception {
     // Serve a response with a non-standard date format that OkHttp supports.
@@ -1366,14 +1386,14 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setBody("C"));
 
     assertEquals("A", get(server.url("/")).body().string());
-    assertEquals(1, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(0, cache.getHitCount());
+    assertEquals(1, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(0, cache.hitCount());
     assertEquals("B", get(server.url("/")).body().string());
     assertEquals("C", get(server.url("/")).body().string());
-    assertEquals(3, cache.getRequestCount());
-    assertEquals(3, cache.getNetworkCount());
-    assertEquals(0, cache.getHitCount());
+    assertEquals(3, cache.requestCount());
+    assertEquals(3, cache.networkCount());
+    assertEquals(0, cache.hitCount());
   }
 
   @Test public void statisticsConditionalCacheHit() throws Exception {
@@ -1387,14 +1407,14 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
     assertEquals("A", get(server.url("/")).body().string());
-    assertEquals(1, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(0, cache.getHitCount());
+    assertEquals(1, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(0, cache.hitCount());
     assertEquals("A", get(server.url("/")).body().string());
     assertEquals("A", get(server.url("/")).body().string());
-    assertEquals(3, cache.getRequestCount());
-    assertEquals(3, cache.getNetworkCount());
-    assertEquals(2, cache.getHitCount());
+    assertEquals(3, cache.requestCount());
+    assertEquals(3, cache.networkCount());
+    assertEquals(2, cache.hitCount());
   }
 
   @Test public void statisticsFullCacheHit() throws Exception {
@@ -1403,14 +1423,14 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setBody("A"));
 
     assertEquals("A", get(server.url("/")).body().string());
-    assertEquals(1, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(0, cache.getHitCount());
+    assertEquals(1, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(0, cache.hitCount());
     assertEquals("A", get(server.url("/")).body().string());
     assertEquals("A", get(server.url("/")).body().string());
-    assertEquals(3, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(2, cache.getHitCount());
+    assertEquals(3, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(2, cache.hitCount());
   }
 
   @Test public void varyMatchesChangedRequestHeaderField() throws Exception {
@@ -1656,8 +1676,10 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+    client = client.newBuilder()
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
+        .build();
 
     HttpUrl url = server.url("/");
     Request request1 = new Request.Builder()
@@ -1676,20 +1698,25 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
   }
 
   @Test public void cachePlusCookies() throws Exception {
+    RecordingCookieJar cookieJar = new RecordingCookieJar();
+    client = client.newBuilder()
+        .cookieJar(cookieJar)
+        .build();
+
     server.enqueue(new MockResponse()
-        .addHeader("Set-Cookie: a=FIRST; domain=" + server.getCookieDomain() + ";")
+        .addHeader("Set-Cookie: a=FIRST")
         .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Cache-Control: max-age=0")
         .setBody("A"));
     server.enqueue(new MockResponse()
-        .addHeader("Set-Cookie: a=SECOND; domain=" + server.getCookieDomain() + ";")
+        .addHeader("Set-Cookie: a=SECOND")
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
     HttpUrl url = server.url("/");
     assertEquals("A", get(url).body().string());
-    assertCookies(url, "a=FIRST");
+    cookieJar.assertResponseCookies("a=FIRST; path=/");
     assertEquals("A", get(url).body().string());
-    assertCookies(url, "a=SECOND");
+    cookieJar.assertResponseCookies("a=SECOND; path=/");
   }
 
   @Test public void getHeadersReturnsNetworkEndToEndHeaders() throws Exception {
@@ -1774,7 +1801,7 @@ public void assertCookies(HttpUrl url, String... expectedCookies) throws Excepti
     assertEquals(Arrays.asList(expectedCookies), actualCookies);
   }
 
-  @Test public void doNotCachePartialResponse() throws Exception  {
+  @Test public void doNotCachePartialResponse() throws Exception {
     assertNotCached(new MockResponse()
         .setResponseCode(HttpURLConnection.HTTP_PARTIAL)
         .addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
@@ -1877,10 +1904,9 @@ public void assertCookies(HttpUrl url, String... expectedCookies) throws Excepti
   }
 
   /**
-   * Old implementations of OkHttp's response cache wrote header fields like
-   * ":status: 200 OK". This broke our cached response parser because it split
-   * on the first colon. This regression test exists to help us read these old
-   * bad cache entries.
+   * Old implementations of OkHttp's response cache wrote header fields like ":status: 200 OK". This
+   * broke our cached response parser because it split on the first colon. This regression test
+   * exists to help us read these old bad cache entries.
    *
    * https://github.com/square/okhttp/issues/227
    */
@@ -1924,11 +1950,13 @@ public void assertCookies(HttpUrl url, String... expectedCookies) throws Excepti
         + "2\n"
         + "\n"
         + "CLEAN " + urlKey + " " + entryMetadata.length() + " " + entryBody.length() + "\n";
-    writeFile(cache.getDirectory(), urlKey + ".0", entryMetadata);
-    writeFile(cache.getDirectory(), urlKey + ".1", entryBody);
-    writeFile(cache.getDirectory(), "journal", journalBody);
-    cache = new Cache(cache.getDirectory(), Integer.MAX_VALUE, fileSystem);
-    client.setCache(cache);
+    writeFile(cache.directory(), urlKey + ".0", entryMetadata);
+    writeFile(cache.directory(), urlKey + ".1", entryBody);
+    writeFile(cache.directory(), "journal", journalBody);
+    cache = new Cache(cache.directory(), Integer.MAX_VALUE, fileSystem);
+    client = client.newBuilder()
+        .cache(cache)
+        .build();
 
     Response response = get(url);
     assertEquals(entryBody, response.body().string());
@@ -1936,6 +1964,139 @@ public void assertCookies(HttpUrl url, String... expectedCookies) throws Excepti
     assertEquals("foo", response.header("etag"));
   }
 
+  /** Exercise the cache format in OkHttp 2.7 and all earlier releases. */
+  @Test public void testGoldenCacheHttpsResponseOkHttp27() throws Exception {
+    HttpUrl url = server.url("/");
+    String urlKey = Util.md5Hex(url.toString());
+    String entryMetadata = ""
+        + "" + url + "\n"
+        + "GET\n"
+        + "0\n"
+        + "HTTP/1.1 200 OK\n"
+        + "4\n"
+        + "Content-Length: 3\n"
+        + "OkHttp-Received-Millis: " + System.currentTimeMillis() + "\n"
+        + "OkHttp-Sent-Millis: " + System.currentTimeMillis() + "\n"
+        + "Cache-Control: max-age=60\n"
+        + "\n"
+        + "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\n"
+        + "1\n"
+        + "MIIBnDCCAQWgAwIBAgIBATANBgkqhkiG9w0BAQsFADAUMRIwEAYDVQQDEwlsb2NhbGhvc3QwHhcNMTUxMjIyMDEx"
+        + "MTQwWhcNMTUxMjIzMDExMTQwWjAUMRIwEAYDVQQDEwlsb2NhbGhvc3QwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJ"
+        + "AoGBAJTn2Dh8xYmegvpOSmsKb2Os6Cxf1L4fYbnHr/turInUD5r1P7ZAuxurY880q3GT5bUDoirS3IfucddrT1Ac"
+        + "AmUzEmk/FDjggiP8DlxFkY/XwXBlhRDVIp/mRuASPMGInckc0ZaixOkRFyrxADj+r1eaSmXCIvV5yTY6IaIokLj1"
+        + "AgMBAAEwDQYJKoZIhvcNAQELBQADgYEAFblnedqtfRqI9j2WDyPPoG0NTZf9xwjeUu+ju+Ktty8u9k7Lgrrd/DH2"
+        + "mQEtBD1Ctvp91MJfAClNg3faZzwClUyu5pd0QXRZEUwSwZQNen2QWDHRlVsItclBJ4t+AJLqTbwofWi4m4K8REOl"
+        + "593hD55E4+lY22JZiVQyjsQhe6I=\n"
+        + "0\n";
+    String entryBody = "abc";
+    String journalBody = ""
+        + "libcore.io.DiskLruCache\n"
+        + "1\n"
+        + "201105\n"
+        + "2\n"
+        + "\n"
+        + "DIRTY " + urlKey + "\n"
+        + "CLEAN " + urlKey + " " + entryMetadata.length() + " " + entryBody.length() + "\n";
+    writeFile(cache.directory(), urlKey + ".0", entryMetadata);
+    writeFile(cache.directory(), urlKey + ".1", entryBody);
+    writeFile(cache.directory(), "journal", journalBody);
+    cache.close();
+    cache = new Cache(cache.directory(), Integer.MAX_VALUE, fileSystem);
+    client = client.newBuilder()
+        .cache(cache)
+        .build();
+
+    Response response = get(url);
+    assertEquals(entryBody, response.body().string());
+    assertEquals("3", response.header("Content-Length"));
+  }
+
+  /** The TLS version is present in OkHttp 3.0 and beyond. */
+  @Test public void testGoldenCacheHttpsResponseOkHttp30() throws Exception {
+    HttpUrl url = server.url("/");
+    String urlKey = Util.md5Hex(url.toString());
+    String entryMetadata = ""
+        + "" + url + "\n"
+        + "GET\n"
+        + "0\n"
+        + "HTTP/1.1 200 OK\n"
+        + "4\n"
+        + "Content-Length: 3\n"
+        + "OkHttp-Received-Millis: " + System.currentTimeMillis() + "\n"
+        + "OkHttp-Sent-Millis: " + System.currentTimeMillis() + "\n"
+        + "Cache-Control: max-age=60\n"
+        + "\n"
+        + "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\n"
+        + "1\n"
+        + "MIIBnDCCAQWgAwIBAgIBATANBgkqhkiG9w0BAQsFADAUMRIwEAYDVQQDEwlsb2NhbGhvc3QwHhcNMTUxMjIyMDEx"
+        + "MTQwWhcNMTUxMjIzMDExMTQwWjAUMRIwEAYDVQQDEwlsb2NhbGhvc3QwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJ"
+        + "AoGBAJTn2Dh8xYmegvpOSmsKb2Os6Cxf1L4fYbnHr/turInUD5r1P7ZAuxurY880q3GT5bUDoirS3IfucddrT1Ac"
+        + "AmUzEmk/FDjggiP8DlxFkY/XwXBlhRDVIp/mRuASPMGInckc0ZaixOkRFyrxADj+r1eaSmXCIvV5yTY6IaIokLj1"
+        + "AgMBAAEwDQYJKoZIhvcNAQELBQADgYEAFblnedqtfRqI9j2WDyPPoG0NTZf9xwjeUu+ju+Ktty8u9k7Lgrrd/DH2"
+        + "mQEtBD1Ctvp91MJfAClNg3faZzwClUyu5pd0QXRZEUwSwZQNen2QWDHRlVsItclBJ4t+AJLqTbwofWi4m4K8REOl"
+        + "593hD55E4+lY22JZiVQyjsQhe6I=\n"
+        + "0\n"
+        + "TLSv1.2\n";
+    String entryBody = "abc";
+    String journalBody = ""
+        + "libcore.io.DiskLruCache\n"
+        + "1\n"
+        + "201105\n"
+        + "2\n"
+        + "\n"
+        + "DIRTY " + urlKey + "\n"
+        + "CLEAN " + urlKey + " " + entryMetadata.length() + " " + entryBody.length() + "\n";
+    writeFile(cache.directory(), urlKey + ".0", entryMetadata);
+    writeFile(cache.directory(), urlKey + ".1", entryBody);
+    writeFile(cache.directory(), "journal", journalBody);
+    cache.close();
+    cache = new Cache(cache.directory(), Integer.MAX_VALUE, fileSystem);
+    client = client.newBuilder()
+        .cache(cache)
+        .build();
+
+    Response response = get(url);
+    assertEquals(entryBody, response.body().string());
+    assertEquals("3", response.header("Content-Length"));
+  }
+
+  @Test public void testGoldenCacheHttpResponseOkHttp30() throws Exception {
+    HttpUrl url = server.url("/");
+    String urlKey = Util.md5Hex(url.toString());
+    String entryMetadata = ""
+        + "" + url + "\n"
+        + "GET\n"
+        + "0\n"
+        + "HTTP/1.1 200 OK\n"
+        + "4\n"
+        + "Cache-Control: max-age=60\n"
+        + "Content-Length: 3\n"
+        + "OkHttp-Received-Millis: " + System.currentTimeMillis() + "\n"
+        + "OkHttp-Sent-Millis: " + System.currentTimeMillis() + "\n";
+    String entryBody = "abc";
+    String journalBody = ""
+        + "libcore.io.DiskLruCache\n"
+        + "1\n"
+        + "201105\n"
+        + "2\n"
+        + "\n"
+        + "DIRTY " + urlKey + "\n"
+        + "CLEAN " + urlKey + " " + entryMetadata.length() + " " + entryBody.length() + "\n";
+    writeFile(cache.directory(), urlKey + ".0", entryMetadata);
+    writeFile(cache.directory(), urlKey + ".1", entryBody);
+    writeFile(cache.directory(), "journal", journalBody);
+    cache.close();
+    cache = new Cache(cache.directory(), Integer.MAX_VALUE, fileSystem);
+    client = client.newBuilder()
+        .cache(cache)
+        .build();
+
+    Response response = get(url);
+    assertEquals(entryBody, response.body().string());
+    assertEquals("3", response.header("Content-Length"));
+  }
+
   @Test public void evictAll() throws Exception {
     server.enqueue(new MockResponse()
         .addHeader("Cache-Control: max-age=60")
@@ -1945,8 +2106,8 @@ public void assertCookies(HttpUrl url, String... expectedCookies) throws Excepti
 
     HttpUrl url = server.url("/");
     assertEquals("A", get(url).body().string());
-    client.getCache().evictAll();
-    assertEquals(0, client.getCache().getSize());
+    client.cache().evictAll();
+    assertEquals(0, client.cache().size());
     assertEquals("B", get(url).body().string());
   }
 
@@ -1962,12 +2123,13 @@ public void assertCookies(HttpUrl url, String... expectedCookies) throws Excepti
     assertEquals("A", get(url).body().string());
 
     final AtomicReference<String> ifNoneMatch = new AtomicReference<>();
-    client.networkInterceptors().add(new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        ifNoneMatch.compareAndSet(null, chain.request().header("If-None-Match"));
-        return chain.proceed(chain.request());
-      }
-    });
+    client = client.newBuilder()
+        .addNetworkInterceptor(new Interceptor() {
+          @Override public Response intercept(Chain chain) throws IOException {
+            ifNoneMatch.compareAndSet(null, chain.request().header("If-None-Match"));
+            return chain.proceed(chain.request());
+          }
+        }).build();
 
     // Confirm the value is cached and intercepted.
     assertEquals("A", get(url).body().string());
@@ -1984,11 +2146,12 @@ public void assertCookies(HttpUrl url, String... expectedCookies) throws Excepti
     assertEquals("A", get(url).body().string());
 
     // Confirm the interceptor isn't exercised.
-    client.networkInterceptors().add(new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        throw new AssertionError();
-      }
-    });
+    client = client.newBuilder()
+        .addNetworkInterceptor(new Interceptor() {
+          @Override public Response intercept(Chain chain) throws IOException {
+            throw new AssertionError();
+          }
+        }).build();
     assertEquals("A", get(url).body().string());
   }
 
@@ -2151,7 +2314,6 @@ private Response get(HttpUrl url) throws IOException {
     return client.newCall(request).execute();
   }
 
-
   private void writeFile(File directory, String file, String content) throws IOException {
     BufferedSink sink = Okio.buffer(fileSystem.sink(new File(directory, file)));
     sink.writeUtf8(content);
@@ -2159,9 +2321,8 @@ private void writeFile(File directory, String file, String content) throws IOExc
   }
 
   /**
-   * @param delta the offset from the current date to use. Negative
-   * values yield dates in the past; positive values yield dates in the
-   * future.
+   * @param delta the offset from the current date to use. Negative values yield dates in the past;
+   * positive values yield dates in the future.
    */
   private String formatDate(long delta, TimeUnit timeUnit) {
     return formatDate(new Date(System.currentTimeMillis() + timeUnit.toMillis(delta)));
@@ -2231,9 +2392,8 @@ private void assertFullyCached(MockResponse response) throws Exception {
   }
 
   /**
-   * Shortens the body of {@code response} but not the corresponding headers.
-   * Only useful to test how clients respond to the premature conclusion of
-   * the HTTP body.
+   * Shortens the body of {@code response} but not the corresponding headers. Only useful to test
+   * how clients respond to the premature conclusion of the HTTP body.
    */
   private MockResponse truncateViolently(MockResponse response, int numBytesToKeep) {
     response.setSocketPolicy(DISCONNECT_AT_END);
diff --git a/okhttp-tests/src/test/java/okhttp3/CallTest.java b/okhttp-tests/src/test/java/okhttp3/CallTest.java
index 21c4f2d8cf..3ccecfa654 100644
--- a/okhttp-tests/src/test/java/okhttp3/CallTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CallTest.java
@@ -24,8 +24,9 @@
 import java.net.HttpURLConnection;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
-import java.net.ProtocolException;
+import java.net.Proxy;
 import java.net.ServerSocket;
+import java.net.UnknownHostException;
 import java.net.UnknownServiceException;
 import java.security.cert.Certificate;
 import java.util.ArrayList;
@@ -54,14 +55,13 @@
 import okhttp3.internal.SslContextBuilder;
 import okhttp3.internal.Util;
 import okhttp3.internal.Version;
-import okhttp3.internal.http.FakeDns;
+import okhttp3.internal.http.RecordingProxySelector;
 import okhttp3.internal.io.InMemoryFileSystem;
 import okhttp3.mockwebserver.Dispatcher;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.RecordedRequest;
 import okhttp3.mockwebserver.SocketPolicy;
-import okhttp3.testing.RecordingHostnameVerifier;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -69,12 +69,14 @@
 import okio.Okio;
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.TestRule;
 import org.junit.rules.Timeout;
 
 import static java.net.CookiePolicy.ACCEPT_ORIGINAL_SERVER;
+import static okhttp3.TestUtil.defaultClient;
 import static okhttp3.internal.Internal.logger;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
@@ -90,7 +92,7 @@
   @Rule public final InMemoryFileSystem fileSystem = new InMemoryFileSystem();
 
   private SSLContext sslContext = SslContextBuilder.localhost();
-  private OkHttpClient client = new OkHttpClient();
+  private OkHttpClient client = defaultClient();
   private RecordingCallback callback = new RecordingCallback();
   private TestLogHandler logHandler = new TestLogHandler();
   private Cache cache = new Cache(new File("/cache/"), Integer.MAX_VALUE, fileSystem);
@@ -109,12 +111,7 @@
   @Test public void get() throws Exception {
     server.enqueue(new MockResponse().setBody("abc").addHeader("Content-Type: text/plain"));
 
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .header("User-Agent", "SyncApiTest")
-        .build();
-
-    executeSynchronously(request)
+    executeSynchronously("/", "User-Agent", "SyncApiTest")
         .assertCode(200)
         .assertSuccessful()
         .assertHeader("Content-Type", "text/plain")
@@ -129,14 +126,7 @@
 
   @Test public void buildRequestUsingHttpUrl() throws Exception {
     server.enqueue(new MockResponse());
-
-    HttpUrl httpUrl = server.url("/");
-    Request request = new Request.Builder()
-        .url(httpUrl)
-        .build();
-    assertEquals(httpUrl, request.url());
-
-    executeSynchronously(request).assertSuccessful();
+    executeSynchronously("/").assertSuccessful();
   }
 
   @Test public void invalidScheme() throws Exception {
@@ -161,12 +151,7 @@
 
   @Test public void getReturns500() throws Exception {
     server.enqueue(new MockResponse().setResponseCode(500));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-
-    executeSynchronously(request)
+    executeSynchronously("/")
         .assertCode(500)
         .assertNotSuccessful();
   }
@@ -191,13 +176,7 @@
         .addHeader("B", "123")
         .addHeader("B", "234"));
 
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .addHeader("A", "345")
-        .addHeader("A", "456")
-        .build();
-
-    executeSynchronously(request)
+    executeSynchronously("/", "A", "345", "A", "456")
         .assertCode(200)
         .assertHeader("B", "123", "234");
 
@@ -377,7 +356,9 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .build();
 
     String credential = Credentials.basic("jesse", "secret");
-    client.setAuthenticator(new RecordingOkAuthenticator(credential));
+    client = client.newBuilder()
+        .authenticator(new RecordingOkAuthenticator(credential))
+        .build();
 
     Response response = client.newCall(request).execute();
     assertEquals(200, response.code());
@@ -400,10 +381,11 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     server.enqueue(new MockResponse().setBody("Success!"));
 
     String credential = Credentials.basic("jesse", "secret");
-    client.setAuthenticator(new RecordingOkAuthenticator(credential));
+    client = client.newBuilder()
+        .authenticator(new RecordingOkAuthenticator(credential))
+        .build();
 
-    Request request = new Request.Builder().url(server.url("/")).build();
-    executeSynchronously(request)
+    executeSynchronously("/")
         .assertCode(200)
         .assertBody("Success!");
   }
@@ -414,7 +396,9 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     }
 
     String credential = Credentials.basic("jesse", "secret");
-    client.setAuthenticator(new RecordingOkAuthenticator(credential));
+    client = client.newBuilder()
+        .authenticator(new RecordingOkAuthenticator(credential))
+        .build();
 
     try {
       client.newCall(new Request.Builder().url(server.url("/0")).build()).execute();
@@ -576,14 +560,14 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     try {
       call.execute();
       fail();
-    } catch (IllegalStateException e){
+    } catch (IllegalStateException e) {
       assertEquals("Already Executed", e.getMessage());
     }
 
     try {
       call.enqueue(callback);
       fail();
-    } catch (IllegalStateException e){
+    } catch (IllegalStateException e) {
       assertEquals("Already Executed", e.getMessage());
     }
 
@@ -606,14 +590,14 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     try {
       call.execute();
       fail();
-    } catch (IllegalStateException e){
+    } catch (IllegalStateException e) {
       assertEquals("Already Executed", e.getMessage());
     }
 
     try {
       call.enqueue(callback);
       fail();
-    } catch (IllegalStateException e){
+    } catch (IllegalStateException e) {
       assertEquals("Already Executed", e.getMessage());
     }
 
@@ -647,11 +631,11 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .build();
 
     client.newCall(request).enqueue(new Callback() {
-      @Override public void onFailure(Request request, IOException e) {
+      @Override public void onFailure(Call call, IOException e) {
         fail();
       }
 
-      @Override public void onResponse(Response response) throws IOException {
+      @Override public void onResponse(Call call, Response response) throws IOException {
         throw new IOException("a");
       }
     });
@@ -665,14 +649,9 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     server.enqueue(new MockResponse().setBody("def"));
     server.enqueue(new MockResponse().setBody("ghi"));
 
-    executeSynchronously(new Request.Builder().url(server.url("/a")).build())
-        .assertBody("abc");
-
-    executeSynchronously(new Request.Builder().url(server.url("/b")).build())
-        .assertBody("def");
-
-    executeSynchronously(new Request.Builder().url(server.url("/c")).build())
-        .assertBody("ghi");
+    executeSynchronously("/a").assertBody("abc");
+    executeSynchronously("/b").assertBody("def");
+    executeSynchronously("/c").assertBody("ghi");
 
     assertEquals(0, server.takeRequest().getSequenceNumber());
     assertEquals(1, server.takeRequest().getSequenceNumber());
@@ -704,11 +683,11 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     Request request = new Request.Builder().url(server.url("/a")).build();
     client.newCall(request).enqueue(new Callback() {
-      @Override public void onFailure(Request request, IOException e) {
+      @Override public void onFailure(Call call, IOException e) {
         throw new AssertionError();
       }
 
-      @Override public void onResponse(Response response) throws IOException {
+      @Override public void onResponse(Call call, Response response) throws IOException {
         InputStream bytes = response.body().byteStream();
         assertEquals('a', bytes.read());
         assertEquals('b', bytes.read());
@@ -729,11 +708,15 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     server.enqueue(new MockResponse().setBody("def").throttleBody(1, 750, TimeUnit.MILLISECONDS));
 
     // First request: time out after 1000ms.
-    client.setReadTimeout(1000, TimeUnit.MILLISECONDS);
-    executeSynchronously(new Request.Builder().url(server.url("/a")).build()).assertBody("abc");
+    client = client.newBuilder()
+        .readTimeout(1000, TimeUnit.MILLISECONDS)
+        .build();
+    executeSynchronously("/a").assertBody("abc");
 
     // Second request: time out after 250ms.
-    client.setReadTimeout(250, TimeUnit.MILLISECONDS);
+    client = client.newBuilder()
+        .readTimeout(250, TimeUnit.MILLISECONDS)
+        .build();
     Request request = new Request.Builder().url(server.url("/b")).build();
     Response response = client.newCall(request).execute();
     BufferedSource bodySource = response.body().source();
@@ -755,14 +738,16 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
   }
 
   /** https://github.com/square/okhttp/issues/442 */
-  @Test public void timeoutsNotRetried() throws Exception {
+  @Test public void tlsTimeoutsNotRetried() throws Exception {
+    enableTls();
     server.enqueue(new MockResponse()
         .setSocketPolicy(SocketPolicy.NO_RESPONSE));
     server.enqueue(new MockResponse()
         .setBody("unreachable!"));
 
-    client.setDns(new DoubleInetAddressDns());
-    client.setReadTimeout(100, TimeUnit.MILLISECONDS);
+    client = client.newBuilder()
+        .readTimeout(100, TimeUnit.MILLISECONDS)
+        .build();
 
     Request request = new Request.Builder().url(server.url("/")).build();
     try {
@@ -773,14 +758,40 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     }
   }
 
+  /**
+   * Make a request with two routes. The first route will time out because it's connecting via a
+   * null proxy server. The second will succeed.
+   */
+  @Test public void connectTimeoutsAttemptsAlternateRoute() throws Exception {
+    InetSocketAddress nullServerAddress = startNullServer();
+
+    RecordingProxySelector proxySelector = new RecordingProxySelector();
+    proxySelector.proxies.add(new Proxy(Proxy.Type.HTTP, nullServerAddress));
+    proxySelector.proxies.add(server.toProxyAddress());
+
+    server.enqueue(new MockResponse()
+        .setBody("success!"));
+
+    client = client.newBuilder()
+        .proxySelector(proxySelector)
+        .readTimeout(100, TimeUnit.MILLISECONDS)
+        .build();
+
+    Request request = new Request.Builder().url("http://android.com/").build();
+    executeSynchronously(request)
+        .assertCode(200)
+        .assertBody("success!");
+  }
+
   /** https://github.com/square/okhttp/issues/1801 */
   @Test public void asyncCallEngineInitialized() throws Exception {
-    OkHttpClient c = new OkHttpClient();
-    c.interceptors().add(new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        throw new IOException();
-      }
-    });
+    OkHttpClient c = new OkHttpClient.Builder()
+        .addInterceptor(new Interceptor() {
+          @Override public Response intercept(Chain chain) throws IOException {
+            throw new IOException();
+          }
+        })
+        .build();
     Request request = new Request.Builder().url(server.url("/")).build();
     c.newCall(request).enqueue(callback);
     RecordedResponse response = callback.await(request.url());
@@ -796,6 +807,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
       @Override public MediaType contentType() {
         return MediaType.parse("text/plain");
       }
+
       @Override public void writeTo(BufferedSink sink) throws IOException {
         sink.writeUtf8("abc");
         sink.timeout().deadline(5, TimeUnit.SECONDS);
@@ -813,6 +825,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
       @Override public MediaType contentType() {
         return MediaType.parse("text/plain");
       }
+
       @Override public void writeTo(BufferedSink sink) throws IOException {
         assertFalse(sink.timeout().hasDeadline());
         sink.writeUtf8("def");
@@ -859,8 +872,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .setBody("abc")
         .addHeader("Content-Type: text/plain"));
 
-    executeSynchronously(new Request.Builder().url(server.url("/")).build())
-        .assertHandshake();
+    executeSynchronously("/").assertHandshake();
   }
 
   @Test public void tls_Async() throws Exception {
@@ -882,12 +894,13 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AFTER_REQUEST));
     server.enqueue(new MockResponse().setBody("retry success"));
 
-    client.setDns(new DoubleInetAddressDns());
-    assertTrue(client.getRetryOnConnectionFailure());
+    client = client.newBuilder()
+        .dns(new DoubleInetAddressDns())
+        .build();
+    assertTrue(client.retryOnConnectionFailure());
 
-    Request request = new Request.Builder().url(server.url("/")).build();
-    executeSynchronously(request).assertBody("seed connection pool");
-    executeSynchronously(request).assertBody("retry success");
+    executeSynchronously("/").assertBody("seed connection pool");
+    executeSynchronously("/").assertBody("retry success");
   }
 
   @Test public void noRecoverWhenRetryOnConnectionFailureIsFalse() throws Exception {
@@ -895,17 +908,15 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AFTER_REQUEST));
     server.enqueue(new MockResponse().setBody("unreachable!"));
 
-    client.setDns(new DoubleInetAddressDns());
-    client.setRetryOnConnectionFailure(false);
+    client = client.newBuilder()
+        .dns(new DoubleInetAddressDns())
+        .retryOnConnectionFailure(false)
+        .build();
 
-    Request request = new Request.Builder().url(server.url("/")).build();
-    executeSynchronously(request).assertBody("seed connection pool");
-    try {
-      // If this succeeds, too many requests were made.
-      client.newCall(request).execute();
-      fail();
-    } catch (IOException expected) {
-    }
+    executeSynchronously("/").assertBody("seed connection pool");
+
+    // If this succeeds, too many requests were made.
+    executeSynchronously("/").assertFailure(IOException.class);
   }
 
   @Test public void recoverFromTlsHandshakeFailure() throws Exception {
@@ -913,12 +924,13 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
     server.enqueue(new MockResponse().setBody("abc"));
 
-    suppressTlsFallbackScsv(client);
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
-    client.setDns(new SingleInetAddressDns());
+    client = client.newBuilder()
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .dns(new SingleInetAddressDns())
+        .sslSocketFactory(suppressTlsFallbackClientSocketFactory())
+        .build();
 
-    executeSynchronously(new Request.Builder().url(server.url("/")).build())
-        .assertBody("abc");
+    executeSynchronously("/").assertBody("abc");
   }
 
   @Test public void recoverFromTlsHandshakeFailure_tlsFallbackScsvEnabled() throws Exception {
@@ -935,9 +947,11 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     RecordingSSLSocketFactory clientSocketFactory =
         new RecordingSSLSocketFactory(sslContext.getSocketFactory());
-    client.setSslSocketFactory(clientSocketFactory);
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
-    client.setDns(new SingleInetAddressDns());
+    client = client.newBuilder()
+        .sslSocketFactory(clientSocketFactory)
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .dns(new SingleInetAddressDns())
+        .build();
 
     Request request = new Request.Builder().url(server.url("/")).build();
     try {
@@ -958,8 +972,10 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
     server.enqueue(new MockResponse().setBody("abc"));
 
-    suppressTlsFallbackScsv(client);
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
+    client = client.newBuilder()
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .sslSocketFactory(suppressTlsFallbackClientSocketFactory())
+        .build();
 
     Request request = new Request.Builder()
         .url(server.url("/"))
@@ -970,15 +986,16 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
   }
 
   @Test public void noRecoveryFromTlsHandshakeFailureWhenTlsFallbackIsDisabled() throws Exception {
-    client.setConnectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.CLEARTEXT));
+    client = client.newBuilder()
+        .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.CLEARTEXT))
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .dns(new SingleInetAddressDns())
+        .sslSocketFactory(suppressTlsFallbackClientSocketFactory())
+        .build();
 
     server.useHttps(sslContext.getSocketFactory(), false);
     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
 
-    suppressTlsFallbackScsv(client);
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
-    client.setDns(new SingleInetAddressDns());
-
     Request request = new Request.Builder().url(server.url("/")).build();
     try {
       client.newCall(request).execute();
@@ -992,8 +1009,9 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
   @Test public void cleartextCallsFailWhenCleartextIsDisabled() throws Exception {
     // Configure the client with only TLS configurations. No cleartext!
-    client.setConnectionSpecs(
-        Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS));
+    client = client.newBuilder()
+        .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS))
+        .build();
 
     server.enqueue(new MockResponse());
 
@@ -1012,7 +1030,9 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .setResponseCode(301)
         .addHeader("Location: http://square.com"));
 
-    client.setFollowSslRedirects(false);
+    client = client.newBuilder()
+        .followSslRedirects(false)
+        .build();
 
     Request request = new Request.Builder().url(server.url("/")).build();
     Response response = client.newCall(request).execute();
@@ -1035,7 +1055,9 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     response1.body().close();
 
     // Make another request with certificate pinning. It should complete normally.
-    client.setCertificatePinner(certificatePinnerBuilder.build());
+    client = client.newBuilder()
+        .certificatePinner(certificatePinnerBuilder.build())
+        .build();
     Request request2 = new Request.Builder().url(server.url("/")).build();
     Response response2 = client.newCall(request2).execute();
     assertNotSame(response2.handshake(), response1.handshake());
@@ -1047,9 +1069,11 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     server.enqueue(new MockResponse());
 
     // Pin publicobject.com's cert.
-    client.setCertificatePinner(new CertificatePinner.Builder()
-        .add(server.getHostName(), "sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw=")
-        .build());
+    client = client.newBuilder()
+        .certificatePinner(new CertificatePinner.Builder()
+            .add(server.getHostName(), "sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw=")
+            .build())
+        .build();
 
     // When we pin the wrong certificate, connectivity fails.
     Request request = new Request.Builder().url(server.url("/")).build();
@@ -1116,33 +1140,26 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .addHeader("Vary: Accept-Charset")
         .setBody("A"));
 
-    client.setCache(cache);
+    client = client.newBuilder()
+        .cache(cache)
+        .build();
 
     // Store a response in the cache.
     HttpUrl url = server.url("/");
-    Request cacheStoreRequest = new Request.Builder()
-        .url(url)
-        .addHeader("Accept-Language", "fr-CA")
-        .addHeader("Accept-Charset", "UTF-8")
-        .build();
-    executeSynchronously(cacheStoreRequest)
+    executeSynchronously("/", "Accept-Language", "fr-CA", "Accept-Charset", "UTF-8")
         .assertCode(200)
         .assertBody("A");
     assertNull(server.takeRequest().getHeader("If-None-Match"));
 
-    // Hit that stored response.
-    Request cacheHitRequest = new Request.Builder()
-        .url(url)
-        .addHeader("Accept-Language", "en-US") // Different, but Vary says it doesn't matter.
-        .addHeader("Accept-Charset", "UTF-8")
-        .build();
-    RecordedResponse cacheHit = executeSynchronously(cacheHitRequest);
+    // Hit that stored response. It's different, but Vary says it doesn't matter.
+    RecordedResponse cacheHit = executeSynchronously(
+        "/", "Accept-Language", "en-US", "Accept-Charset", "UTF-8");
 
     // Check the merged response. The request is the application's original request.
     cacheHit.assertCode(200)
         .assertBody("A")
         .assertHeader("ETag", "v1")
-        .assertRequestUrl(cacheStoreRequest.url())
+        .assertRequestUrl(url)
         .assertRequestHeader("Accept-Language", "en-US")
         .assertRequestHeader("Accept-Charset", "UTF-8");
 
@@ -1151,7 +1168,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .assertCode(200)
         .assertHeader("ETag", "v1")
         .assertRequestMethod("GET")
-        .assertRequestUrl(cacheStoreRequest.url())
+        .assertRequestUrl(url)
         .assertRequestHeader("Accept-Language")
         .assertRequestHeader("Accept-Charset", "UTF-8");
 
@@ -1168,35 +1185,27 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .addHeader("Donut: b")
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    client.setCache(cache);
+    client = client.newBuilder()
+        .cache(cache)
+        .build();
 
     // Store a response in the cache.
-    HttpUrl url = server.url("/");
-    Request cacheStoreRequest = new Request.Builder()
-        .url(url)
-        .addHeader("Accept-Language", "fr-CA")
-        .addHeader("Accept-Charset", "UTF-8")
-        .build();
-    executeSynchronously(cacheStoreRequest)
+    executeSynchronously("/", "Accept-Language", "fr-CA", "Accept-Charset", "UTF-8")
         .assertCode(200)
         .assertHeader("Donut", "a")
         .assertBody("A");
     assertNull(server.takeRequest().getHeader("If-None-Match"));
 
-    // Hit that stored response.
-    Request cacheHitRequest = new Request.Builder()
-        .url(url)
-        .addHeader("Accept-Language", "en-US") // Different, but Vary says it doesn't matter.
-        .addHeader("Accept-Charset", "UTF-8")
-        .build();
-    RecordedResponse cacheHit = executeSynchronously(cacheHitRequest);
+    // Hit that stored response. It's different, but Vary says it doesn't matter.
+    RecordedResponse cacheHit = executeSynchronously(
+        "/", "Accept-Language", "en-US", "Accept-Charset", "UTF-8");
     assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
 
     // Check the merged response. The request is the application's original request.
     cacheHit.assertCode(200)
         .assertBody("A")
         .assertHeader("Donut", "b")
-        .assertRequestUrl(cacheStoreRequest.url())
+        .assertRequestUrl(server.url("/"))
         .assertRequestHeader("Accept-Language", "en-US")
         .assertRequestHeader("Accept-Charset", "UTF-8")
         .assertRequestHeader("If-None-Match"); // No If-None-Match on the user's request.
@@ -1206,7 +1215,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .assertCode(200)
         .assertHeader("Donut", "a")
         .assertHeader("ETag", "v1")
-        .assertRequestUrl(cacheStoreRequest.url())
+        .assertRequestUrl(server.url("/"))
         .assertRequestHeader("Accept-Language") // No Vary on Accept-Language.
         .assertRequestHeader("Accept-Charset", "UTF-8") // Because of Vary on Accept-Charset.
         .assertRequestHeader("If-None-Match"); // This wasn't present in the original request.
@@ -1226,7 +1235,9 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .clearHeaders()
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    client.setCache(cache);
+    client = client.newBuilder()
+        .cache(cache)
+        .build();
 
     Request request1 = new Request.Builder()
         .url(server.url("/"))
@@ -1253,52 +1264,48 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .addHeader("Donut: b")
         .setBody("B"));
 
-    client.setCache(cache);
-
-    Request cacheStoreRequest = new Request.Builder()
-        .url(server.url("/"))
-        .addHeader("Accept-Language", "fr-CA")
-        .addHeader("Accept-Charset", "UTF-8")
+    client = client.newBuilder()
+        .cache(cache)
         .build();
-    executeSynchronously(cacheStoreRequest)
+
+    executeSynchronously("/", "Accept-Language", "fr-CA", "Accept-Charset", "UTF-8")
         .assertCode(200)
         .assertBody("A");
     assertNull(server.takeRequest().getHeader("If-None-Match"));
 
-    Request cacheMissRequest = new Request.Builder()
-        .url(server.url("/"))
-        .addHeader("Accept-Language", "en-US") // Different, but Vary says it doesn't matter.
-        .addHeader("Accept-Charset", "UTF-8")
-        .build();
-    RecordedResponse cacheHit = executeSynchronously(cacheMissRequest);
+    // Different request, but Vary says it doesn't matter.
+    RecordedResponse cacheHit = executeSynchronously(
+        "/", "Accept-Language", "en-US", "Accept-Charset", "UTF-8");
     assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
 
     // Check the user response. It has the application's original request.
     cacheHit.assertCode(200)
         .assertBody("B")
         .assertHeader("Donut", "b")
-        .assertRequestUrl(cacheStoreRequest.url());
+        .assertRequestUrl(server.url("/"));
 
     // Check the cache response. Even though it's a miss, we used the cache.
     cacheHit.cacheResponse()
         .assertCode(200)
         .assertHeader("Donut", "a")
         .assertHeader("ETag", "v1")
-        .assertRequestUrl(cacheStoreRequest.url());
+        .assertRequestUrl(server.url("/"));
 
     // Check the network response. It has the network request, plus caching headers.
     cacheHit.networkResponse()
         .assertCode(200)
         .assertHeader("Donut", "b")
         .assertRequestHeader("If-None-Match", "v1")  // If-None-Match in the validation request.
-        .assertRequestUrl(cacheStoreRequest.url());
+        .assertRequestUrl(server.url("/"));
   }
 
   @Test public void conditionalCacheMiss_Async() throws Exception {
     server.enqueue(new MockResponse().setBody("A").addHeader("ETag: v1"));
     server.enqueue(new MockResponse().setBody("B"));
 
-    client.setCache(cache);
+    client = client.newBuilder()
+        .cache(cache)
+        .build();
 
     Request request1 = new Request.Builder()
         .url(server.url("/"))
@@ -1316,18 +1323,34 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
   }
 
   @Test public void onlyIfCachedReturns504WhenNotCached() throws Exception {
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .header("Cache-Control", "only-if-cached")
-        .build();
-
-    executeSynchronously(request)
+    executeSynchronously("/", "Cache-Control", "only-if-cached")
         .assertCode(504)
         .assertBody("")
         .assertNoNetworkResponse()
         .assertNoCacheResponse();
   }
 
+  @Test public void networkDropsOnConditionalGet() throws IOException {
+    client = client.newBuilder()
+        .cache(cache)
+        .build();
+
+    // Seed the cache.
+    server.enqueue(new MockResponse()
+        .addHeader("ETag: v1")
+        .setBody("A"));
+    executeSynchronously("/")
+        .assertCode(200)
+        .assertBody("A");
+
+    // Attempt conditional cache validation and a DNS miss.
+    client.connectionPool().evictAll();
+    client = client.newBuilder()
+        .dns(new FakeDns().unknownHost())
+        .build();
+    executeSynchronously("/").assertFailure(UnknownHostException.class);
+  }
+
   @Test public void redirect() throws Exception {
     server.enqueue(new MockResponse()
         .setResponseCode(301)
@@ -1341,7 +1364,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .setBody("/b has moved!"));
     server.enqueue(new MockResponse().setBody("C"));
 
-    executeSynchronously(new Request.Builder().url(server.url("/a")).build())
+    executeSynchronously("/a")
         .assertCode(200)
         .assertBody("C")
         .priorResponse()
@@ -1398,6 +1421,44 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     assertEquals("PROPFIND /page2 HTTP/1.1", page2.getRequestLine());
   }
 
+  @Test public void responseCookies() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Set-Cookie", "a=b; Expires=Thu, 01 Jan 1970 00:00:00 GMT")
+        .addHeader("Set-Cookie", "c=d; Expires=Fri, 02 Jan 1970 23:59:59 GMT; path=/bar; secure"));
+
+    RecordingCookieJar cookieJar = new RecordingCookieJar();
+    client = client.newBuilder()
+        .cookieJar(cookieJar)
+        .build();
+
+    executeSynchronously("/").assertCode(200);
+
+    List<Cookie> responseCookies = cookieJar.takeResponseCookies();
+    assertEquals(2, responseCookies.size());
+    assertEquals("a=b; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/",
+        responseCookies.get(0).toString());
+    assertEquals("c=d; expires=Fri, 02 Jan 1970 23:59:59 GMT; path=/bar; secure",
+        responseCookies.get(1).toString());
+  }
+
+  @Test public void requestCookies() throws Exception {
+    server.enqueue(new MockResponse());
+
+    RecordingCookieJar cookieJar = new RecordingCookieJar();
+
+    cookieJar.enqueueRequestCookies(
+        new Cookie.Builder().name("a").value("b").domain(server.getHostName()).build(),
+        new Cookie.Builder().name("c").value("d").domain(server.getHostName()).build());
+    client = client.newBuilder()
+        .cookieJar(cookieJar)
+        .build();
+
+    executeSynchronously("/").assertCode(200);
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("a=b; c=d", recordedRequest.getHeader("Cookie"));
+  }
+
   @Test public void redirectsDoNotIncludeTooManyCookies() throws Exception {
     server2.enqueue(new MockResponse().setBody("Page 2"));
     server.enqueue(new MockResponse()
@@ -1406,12 +1467,14 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
     HttpCookie cookie = new HttpCookie("c", "cookie");
-    cookie.setDomain(server.getCookieDomain());
+    cookie.setDomain(server.getHostName());
     cookie.setPath("/");
     String portList = Integer.toString(server.getPort());
     cookie.setPortlist(portList);
     cookieManager.getCookieStore().add(server.url("/").uri(), cookie);
-    client.setCookieHandler(cookieManager);
+    client = client.newBuilder()
+        .cookieJar(new JavaNetCookieJar(cookieManager))
+        .build();
 
     Response response = client.newCall(new Request.Builder()
         .url(server.url("/page1"))
@@ -1419,11 +1482,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     assertEquals("Page 2", response.body().string());
 
     RecordedRequest request1 = server.takeRequest();
-    assertEquals("$Version=\"1\"; c=\"cookie\";$Path=\"/\";$Domain=\""
-        + server.getCookieDomain()
-        + "\";$Port=\""
-        + portList
-        + "\"", request1.getHeader("Cookie"));
+    assertEquals("c=cookie", request1.getHeader("Cookie"));
 
     RecordedRequest request2 = server2.takeRequest();
     assertNull(request2.getHeader("Cookie"));
@@ -1437,7 +1496,9 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .setResponseCode(302)
         .addHeader("Location: " + server2.url("/b")));
 
-    client.setAuthenticator(new RecordingOkAuthenticator(Credentials.basic("jesse", "secret")));
+    client = client.newBuilder()
+        .authenticator(new RecordingOkAuthenticator(Credentials.basic("jesse", "secret")))
+        .build();
 
     Request request = new Request.Builder().url(server.url("/a")).build();
     Response response = client.newCall(request).execute();
@@ -1464,7 +1525,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     Request request = new Request.Builder().url(server.url("/a")).build();
     client.newCall(request).enqueue(callback);
 
-    callback.await(server.url("/c"))
+    callback.await(server.url("/a"))
         .assertCode(200)
         .assertBody("C")
         .priorResponse()
@@ -1488,7 +1549,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     }
     server.enqueue(new MockResponse().setBody("Success!"));
 
-    executeSynchronously(new Request.Builder().url(server.url("/0")).build())
+    executeSynchronously("/0")
         .assertCode(200)
         .assertBody("Success!");
   }
@@ -1504,7 +1565,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     Request request = new Request.Builder().url(server.url("/0")).build();
     client.newCall(request).enqueue(callback);
-    callback.await(server.url("/20"))
+    callback.await(server.url("/0"))
         .assertCode(200)
         .assertBody("Success!");
   }
@@ -1535,7 +1596,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     Request request = new Request.Builder().url(server.url("/0")).build();
     client.newCall(request).enqueue(callback);
-    callback.await(server.url("/20")).assertFailure("Too many follow-up requests: 21");
+    callback.await(server.url("/0")).assertFailure("Too many follow-up requests: 21");
   }
 
   @Test public void http204WithBodyDisallowed() throws IOException {
@@ -1543,12 +1604,8 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .setResponseCode(204)
         .setBody("I'm not even supposed to be here today."));
 
-    try {
-      executeSynchronously(new Request.Builder().url(server.url("/")).build());
-      fail();
-    } catch (ProtocolException e) {
-      assertEquals("HTTP 204 had non-zero Content-Length: 39", e.getMessage());
-    }
+    executeSynchronously("/")
+        .assertFailure("HTTP 204 had non-zero Content-Length: 39");
   }
 
   @Test public void http205WithBodyDisallowed() throws IOException {
@@ -1556,12 +1613,8 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .setResponseCode(205)
         .setBody("I'm not even supposed to be here today."));
 
-    try {
-      executeSynchronously(new Request.Builder().url(server.url("/")).build());
-      fail();
-    } catch (ProtocolException e) {
-      assertEquals("HTTP 205 had non-zero Content-Length: 39", e.getMessage());
-    }
+    executeSynchronously("/")
+        .assertFailure("HTTP 205 had non-zero Content-Length: 39");
   }
 
   @Test public void canceledBeforeExecute() throws Exception {
@@ -1615,17 +1668,25 @@ private InetSocketAddress startNullServer() throws IOException {
     return new InetSocketAddress(address.getAddress(), nullServer.getLocalPort());
   }
 
-  @Test public void cancelTagImmediatelyAfterEnqueue() throws Exception {
+  @Test public void cancelImmediatelyAfterEnqueue() throws Exception {
     server.enqueue(new MockResponse());
     Call call = client.newCall(new Request.Builder()
         .url(server.url("/a"))
-        .tag("request")
         .build());
     call.enqueue(callback);
-    client.cancel("request");
+    call.cancel();
     callback.await(server.url("/a")).assertFailure("Canceled");
   }
 
+  @Test public void cancelAll() throws Exception {
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    call.enqueue(callback);
+    client.dispatcher().cancelAll();
+    callback.await(server.url("/")).assertFailure("Canceled");
+  }
+
   @Test public void cancelBeforeBodyIsRead() throws Exception {
     server.enqueue(new MockResponse().setBody("def").throttleBody(1, 750, TimeUnit.MILLISECONDS));
 
@@ -1649,16 +1710,18 @@ private InetSocketAddress startNullServer() throws IOException {
   }
 
   @Test public void cancelInFlightBeforeResponseReadThrowsIOE() throws Exception {
+    Request request = new Request.Builder().url(server.url("/a")).build();
+    final Call call = client.newCall(request);
+
     server.setDispatcher(new Dispatcher() {
       @Override public MockResponse dispatch(RecordedRequest request) {
-        client.cancel("request");
+        call.cancel();
         return new MockResponse().setBody("A");
       }
     });
 
-    Request request = new Request.Builder().url(server.url("/a")).tag("request").build();
     try {
-      client.newCall(request).execute();
+      call.execute();
       fail();
     } catch (IOException expected) {
     }
@@ -1684,23 +1747,26 @@ private InetSocketAddress startNullServer() throws IOException {
    * I/O takes place.
    */
   @Test public void canceledBeforeIOSignalsOnFailure() throws Exception {
-    client.getDispatcher().setMaxRequests(1); // Force requests to be executed serially.
+    client.dispatcher().setMaxRequests(1); // Force requests to be executed serially.
+
+    Request requestA = new Request.Builder().url(server.url("/a")).build();
+    Request requestB = new Request.Builder().url(server.url("/b")).build();
+    final Call callA = client.newCall(requestA);
+    final Call callB = client.newCall(requestB);
+
     server.setDispatcher(new Dispatcher() {
       char nextResponse = 'A';
 
       @Override public MockResponse dispatch(RecordedRequest request) {
-        client.cancel("request B");
+        callB.cancel();
         return new MockResponse().setBody(Character.toString(nextResponse++));
       }
     });
 
-    Request requestA = new Request.Builder().url(server.url("/a")).tag("request A").build();
-    client.newCall(requestA).enqueue(callback);
+    callA.enqueue(callback);
+    callB.enqueue(callback);
     assertEquals("/a", server.takeRequest().getPath());
 
-    Request requestB = new Request.Builder().url(server.url("/b")).tag("request B").build();
-    client.newCall(requestB).enqueue(callback);
-
     callback.await(requestA.url()).assertBody("A");
     // At this point we know the callback is ready, and that it will receive a cancel failure.
     callback.await(requestB.url()).assertFailure("Canceled");
@@ -1722,7 +1788,7 @@ private InetSocketAddress startNullServer() throws IOException {
   }
 
   @Test public void canceledBeforeResponseReadSignalsOnFailure() throws Exception {
-    Request requestA = new Request.Builder().url(server.url("/a")).tag("request A").build();
+    Request requestA = new Request.Builder().url(server.url("/a")).build();
     final Call call = client.newCall(requestA);
     server.setDispatcher(new Dispatcher() {
       @Override public MockResponse dispatch(RecordedRequest request) {
@@ -1764,15 +1830,15 @@ private InetSocketAddress startNullServer() throws IOException {
     final AtomicReference<String> bodyRef = new AtomicReference<>();
     final AtomicBoolean failureRef = new AtomicBoolean();
 
-    Request request = new Request.Builder().url(server.url("/a")).tag("request A").build();
+    Request request = new Request.Builder().url(server.url("/a")).build();
     final Call call = client.newCall(request);
     call.enqueue(new Callback() {
-      @Override public void onFailure(Request request, IOException e) {
+      @Override public void onFailure(Call call, IOException e) {
         failureRef.set(true);
         latch.countDown();
       }
 
-      @Override public void onResponse(Response response) throws IOException {
+      @Override public void onResponse(Call call, Response response) throws IOException {
         call.cancel();
         try {
           bodyRef.set(response.body().string());
@@ -1809,12 +1875,13 @@ private InetSocketAddress startNullServer() throws IOException {
   }
 
   @Test public void cancelWithInterceptor() throws Exception {
-    client.interceptors().add(new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        chain.proceed(chain.request());
-        throw new AssertionError(); // We expect an exception.
-      }
-    });
+    client = client.newBuilder()
+        .addInterceptor(new Interceptor() {
+          @Override public Response intercept(Chain chain) throws IOException {
+            chain.proceed(chain.request());
+            throw new AssertionError(); // We expect an exception.
+          }
+        }).build();
 
     Call call = client.newCall(new Request.Builder().url(server.url("/a")).build());
     call.cancel();
@@ -1835,13 +1902,9 @@ private InetSocketAddress startNullServer() throws IOException {
         .setBody(gzippedBody)
         .addHeader("Content-Encoding: gzip"));
 
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-
     // Confirm that the user request doesn't have Accept-Encoding, and the user
     // response doesn't have a Content-Encoding or Content-Length.
-    RecordedResponse userResponse = executeSynchronously(request);
+    RecordedResponse userResponse = executeSynchronously("/");
     userResponse.assertCode(200)
         .assertRequestHeader("Accept-Encoding")
         .assertHeader("Content-Encoding")
@@ -1862,13 +1925,11 @@ private InetSocketAddress startNullServer() throws IOException {
     server.enqueue(new MockResponse()
         .setBody(gzip("abcabcabc"))
         .addHeader("Content-Encoding: gzip"));
-    client.setAuthenticator(new RecordingOkAuthenticator("password"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
+    client = client.newBuilder()
+        .authenticator(new RecordingOkAuthenticator("password"))
         .build();
-    executeSynchronously(request)
-        .assertBody("abcabcabc");
+
+    executeSynchronously("/").assertBody("abcabcabc");
   }
 
   @Test public void asyncResponseCanBeConsumedLater() throws Exception {
@@ -1882,11 +1943,11 @@ private InetSocketAddress startNullServer() throws IOException {
 
     final BlockingQueue<Response> responseRef = new SynchronousQueue<>();
     client.newCall(request).enqueue(new Callback() {
-      @Override public void onFailure(Request request, IOException e) {
+      @Override public void onFailure(Call call, IOException e) {
         throw new AssertionError();
       }
 
-      @Override public void onResponse(Response response) throws IOException {
+      @Override public void onResponse(Call call, Response response) throws IOException {
         try {
           responseRef.put(response);
         } catch (InterruptedException e) {
@@ -1900,7 +1961,7 @@ private InetSocketAddress startNullServer() throws IOException {
     assertEquals("abc", response.body().string());
 
     // Make another request just to confirm that that connection can be reused...
-    executeSynchronously(new Request.Builder().url(server.url("/")).build()).assertBody("def");
+    executeSynchronously("/").assertBody("def");
     assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
     assertEquals(1, server.takeRequest().getSequenceNumber()); // Connection reused.
 
@@ -1911,7 +1972,7 @@ private InetSocketAddress startNullServer() throws IOException {
   @Test public void userAgentIsIncludedByDefault() throws Exception {
     server.enqueue(new MockResponse());
 
-    executeSynchronously(new Request.Builder().url(server.url("/")).build());
+    executeSynchronously("/");
 
     RecordedRequest recordedRequest = server.takeRequest();
     assertTrue(recordedRequest.getHeader("User-Agent")
@@ -1925,11 +1986,10 @@ private InetSocketAddress startNullServer() throws IOException {
         .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
 
-    client.setFollowRedirects(false);
-    RecordedResponse recordedResponse = executeSynchronously(
-        new Request.Builder().url(server.url("/a")).build());
-
-    recordedResponse
+    client = client.newBuilder()
+        .followRedirects(false)
+        .build();
+    executeSynchronously("/a")
         .assertBody("A")
         .assertCode(302);
   }
@@ -1974,11 +2034,7 @@ private InetSocketAddress startNullServer() throws IOException {
         .build();
     server.enqueue(new MockResponse().setHeaders(headers));
 
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-
-    executeSynchronously(request)
+    executeSynchronously("/")
         .assertHeader("a\tb", "c\u007fd")
         .assertHeader("\ud83c\udf69", "\u2615\ufe0f")
         .assertHeader("", "ef");
@@ -1988,7 +2044,9 @@ private InetSocketAddress startNullServer() throws IOException {
     // Configure a DNS that returns our MockWebServer for every hostname.
     FakeDns dns = new FakeDns();
     dns.addresses(Dns.SYSTEM.lookup(server.url("/").host()));
-    client.setDns(dns);
+    client = client.newBuilder()
+        .dns(dns)
+        .build();
 
     server.enqueue(new MockResponse());
     Request request = new Request.Builder()
@@ -2037,10 +2095,12 @@ private InetSocketAddress startNullServer() throws IOException {
     server.enqueue(new MockResponse()
         .setBody("encrypted response from the origin server"));
 
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setProxy(server.toProxyAddress());
     RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-    client.setHostnameVerifier(hostnameVerifier);
+    client = client.newBuilder()
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .proxy(server.toProxyAddress())
+        .hostnameVerifier(hostnameVerifier)
+        .build();
 
     Request request = new Request.Builder()
         .url("https://android.com/foo")
@@ -2075,10 +2135,12 @@ private InetSocketAddress startNullServer() throws IOException {
     server.enqueue(new MockResponse()
         .setBody("response body"));
 
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setProxy(server.toProxyAddress());
-    client.setProxyAuthenticator(new RecordingOkAuthenticator("password"));
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
+    client = client.newBuilder()
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .proxy(server.toProxyAddress())
+        .proxyAuthenticator(new RecordingOkAuthenticator("password"))
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build();
 
     Request request = new Request.Builder()
         .url("https://android.com/foo")
@@ -2112,9 +2174,11 @@ private InetSocketAddress startNullServer() throws IOException {
     server.enqueue(new MockResponse()
         .setBody("response body"));
 
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setProxy(server.toProxyAddress());
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
+    client = client.newBuilder()
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .proxy(server.toProxyAddress())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build();
 
     Request request = new Request.Builder()
         .url("https://android.com/foo")
@@ -2130,6 +2194,162 @@ private InetSocketAddress startNullServer() throws IOException {
     assertEquals("password", get.getHeader("Proxy-Authorization"));
   }
 
+  @Test public void interceptorGetsFramedProtocol() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+
+    // Capture the protocol as it is observed by the interceptor.
+    final AtomicReference<Protocol> protocolRef = new AtomicReference<>();
+    Interceptor interceptor = new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        protocolRef.set(chain.connection().protocol());
+        return chain.proceed(chain.request());
+      }
+    };
+    client = client.newBuilder()
+        .addNetworkInterceptor(interceptor)
+        .build();
+
+    // Make an HTTP/2 request and confirm that the protocol matches.
+    server.enqueue(new MockResponse());
+    executeSynchronously("/");
+    assertEquals(Protocol.HTTP_2, protocolRef.get());
+  }
+
+  @Test public void serverSendsInvalidResponseHeaders() throws Exception {
+    server.enqueue(new MockResponse()
+        .setStatus("HTP/1.1 200 OK"));
+
+    executeSynchronously("/")
+        .assertFailure("Unexpected status line: HTP/1.1 200 OK");
+  }
+
+  @Test public void serverSendsInvalidCodeTooLarge() throws Exception {
+    server.enqueue(new MockResponse()
+        .setStatus("HTTP/1.1 2147483648 OK"));
+
+    executeSynchronously("/")
+        .assertFailure("Unexpected status line: HTTP/1.1 2147483648 OK");
+  }
+
+  @Test public void serverSendsInvalidCodeNotANumber() throws Exception {
+    server.enqueue(new MockResponse()
+        .setStatus("HTTP/1.1 00a OK"));
+
+    executeSynchronously("/")
+        .assertFailure("Unexpected status line: HTTP/1.1 00a OK");
+  }
+
+  @Test public void serverSendsUnnecessaryWhitespace() throws Exception {
+    server.enqueue(new MockResponse()
+        .setStatus(" HTTP/1.1 200 OK"));
+
+    executeSynchronously("/")
+        .assertFailure("Unexpected status line:  HTTP/1.1 200 OK");
+  }
+
+  @Test public void connectFails() throws Exception {
+    server.shutdown();
+
+    executeSynchronously("/")
+        .assertFailure(IOException.class);
+  }
+
+  @Test public void requestBodySurvivesRetries() throws Exception {
+    server.enqueue(new MockResponse());
+
+    // Enable a misconfigured proxy selector to guarantee that the request is retried.
+    client = client.newBuilder()
+        .proxySelector(new FakeProxySelector()
+            .addProxy(server2.toProxyAddress()))
+        .build();
+    server2.shutdown();
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .post(RequestBody.create(MediaType.parse("text/plain"), "abc"))
+        .build();
+
+    executeSynchronously(request);
+    assertEquals("abc", server.takeRequest().getBody().readUtf8());
+  }
+
+  @Ignore // This may fail in DNS lookup, which we don't have timeouts for.
+  @Test public void invalidHost() throws Exception {
+    Request request = new Request.Builder()
+        .url(HttpUrl.parse("http://1234.1.1.1/"))
+        .build();
+
+    executeSynchronously(request)
+        .assertFailure(UnknownHostException.class);
+  }
+
+  @Test public void uploadBodySmallChunkedEncoding() throws Exception {
+    upload(true, 1048576, 256);
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals(1048576, recordedRequest.getBodySize());
+    assertFalse(recordedRequest.getChunkSizes().isEmpty());
+  }
+
+  @Test public void uploadBodyLargeChunkedEncoding() throws Exception {
+    upload(true, 1048576, 65536);
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals(1048576, recordedRequest.getBodySize());
+    assertFalse(recordedRequest.getChunkSizes().isEmpty());
+  }
+
+  @Test public void uploadBodySmallFixedLength() throws Exception {
+    upload(false, 1048576, 256);
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals(1048576, recordedRequest.getBodySize());
+    assertTrue(recordedRequest.getChunkSizes().isEmpty());
+  }
+
+  @Test public void uploadBodyLargeFixedLength() throws Exception {
+    upload(false, 1048576, 65536);
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals(1048576, recordedRequest.getBodySize());
+    assertTrue(recordedRequest.getChunkSizes().isEmpty());
+  }
+
+  private void upload(
+      final boolean chunked, final int size, final int writeSize) throws Exception {
+    server.enqueue(new MockResponse());
+    executeSynchronously(new Request.Builder()
+        .url(server.url("/"))
+        .post(requestBody(chunked, size, writeSize))
+        .build());
+  }
+
+  private RequestBody requestBody(final boolean chunked, final long size, final int writeSize) {
+    final byte[] buffer = new byte[writeSize];
+    Arrays.fill(buffer, (byte) 'x');
+
+    return new RequestBody() {
+      @Override public MediaType contentType() {
+        return MediaType.parse("text/plain; charset=utf-8");
+      }
+
+      @Override public long contentLength() throws IOException {
+        return chunked ? -1L : size;
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        for (int count = 0; count < size; count += writeSize) {
+          sink.write(buffer, 0, (int) Math.min(size - count, writeSize));
+        }
+      }
+    };
+  }
+
+  @Test public void emptyResponseBody() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("abc", "def"));
+    executeSynchronously("/")
+        .assertCode(200)
+        .assertHeader("abc", "def")
+        .assertBody("");
+  }
+
   private void makeFailingCall() {
     RequestBody requestBody = new RequestBody() {
       @Override public MediaType contentType() {
@@ -2144,7 +2364,10 @@ private void makeFailingCall() {
         throw new IOException("write body fail!");
       }
     };
-    Call call = client.newCall(new Request.Builder()
+    OkHttpClient nonRetryingClient = client.newBuilder()
+        .retryOnConnectionFailure(false)
+        .build();
+    Call call = nonRetryingClient.newCall(new Request.Builder()
         .url(server.url("/"))
         .post(requestBody)
         .build());
@@ -2156,9 +2379,24 @@ private void makeFailingCall() {
     }
   }
 
+  private RecordedResponse executeSynchronously(String path, String... headers) throws IOException {
+    Request.Builder builder = new Request.Builder();
+    builder.url(server.url(path));
+    for (int i = 0, size = headers.length; i < size; i += 2) {
+      builder.addHeader(headers[i], headers[i + 1]);
+    }
+    return executeSynchronously(builder.build());
+  }
+
   private RecordedResponse executeSynchronously(Request request) throws IOException {
-    Response response = client.newCall(request).execute();
-    return new RecordedResponse(request, response, null, response.body().string(), null);
+    Call call = client.newCall(request);
+    try {
+      Response response = call.execute();
+      String bodyString = response.body().string();
+      return new RecordedResponse(request, response, null, bodyString, null);
+    } catch (IOException e) {
+      return new RecordedResponse(request, null, null, null, e);
+    }
   }
 
   /**
@@ -2167,13 +2405,17 @@ private RecordedResponse executeSynchronously(Request request) throws IOExceptio
    */
   private void enableProtocol(Protocol protocol) {
     enableTls();
-    client.setProtocols(Arrays.asList(protocol, Protocol.HTTP_1_1));
-    server.setProtocols(client.getProtocols());
+    client = client.newBuilder()
+        .protocols(Arrays.asList(protocol, Protocol.HTTP_1_1))
+        .build();
+    server.setProtocols(client.protocols());
   }
 
   private void enableTls() {
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
+    client = client.newBuilder()
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build();
     server.useHttps(sslContext.getSocketFactory(), false);
   }
 
@@ -2219,12 +2461,10 @@ protected SSLSocket configureSocket(SSLSocket sslSocket) throws IOException {
 
   /**
    * Used during tests that involve TLS connection fallback attempts. OkHttp includes the
-   * TLS_FALLBACK_SCSV cipher on fallback connections. See
-   * {@link FallbackTestClientSocketFactory} for details.
+   * TLS_FALLBACK_SCSV cipher on fallback connections. See {@link FallbackTestClientSocketFactory}
+   * for details.
    */
-  private void suppressTlsFallbackScsv(OkHttpClient client) {
-    FallbackTestClientSocketFactory clientSocketFactory =
-        new FallbackTestClientSocketFactory(sslContext.getSocketFactory());
-    client.setSslSocketFactory(clientSocketFactory);
+  private FallbackTestClientSocketFactory suppressTlsFallbackClientSocketFactory() {
+    return new FallbackTestClientSocketFactory(sslContext.getSocketFactory());
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/CertificatePinnerTest.java b/okhttp-tests/src/test/java/okhttp3/CertificatePinnerTest.java
index baa17fb26e..cdfe9b0f09 100644
--- a/okhttp-tests/src/test/java/okhttp3/CertificatePinnerTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CertificatePinnerTest.java
@@ -15,12 +15,12 @@
  */
 package okhttp3;
 
-import okhttp3.internal.SslContextBuilder;
 import java.security.GeneralSecurityException;
 import java.security.KeyPair;
 import java.security.cert.X509Certificate;
 import java.util.Set;
 import javax.net.ssl.SSLPeerUnverifiedException;
+import okhttp3.internal.SslContextBuilder;
 import okio.ByteString;
 import org.junit.Test;
 
@@ -165,7 +165,8 @@ static ByteString pinToBase64(String pin) {
     certificatePinner.check("a.example.com", keypairACertificate1);
   }
 
-  @Test public void successfulMatchAcceptsAnyMatchingCertificateForWildcardHostname() throws Exception {
+  @Test public void successfulMatchAcceptsAnyMatchingCertificateForWildcardHostname()
+      throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
         .add("*.example.com", keypairBCertificate1Pin)
         .build();
@@ -194,7 +195,8 @@ static ByteString pinToBase64(String pin) {
     certificatePinner.check("a.example.com", keypairBCertificate1);
   }
 
-  @Test public void successfulCheckForOneHostnameWithWildcardAndDirectCertificate() throws Exception {
+  @Test public void successfulCheckForOneHostnameWithWildcardAndDirectCertificate()
+      throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
         .add("*.example.com", keypairACertificate1Pin)
         .add("a.example.com", keypairBCertificate1Pin)
@@ -204,7 +206,8 @@ static ByteString pinToBase64(String pin) {
     certificatePinner.check("a.example.com", keypairBCertificate1);
   }
 
-  @Test public void unsuccessfulCheckForOneHostnameWithWildcardAndDirectCertificate() throws Exception {
+  @Test public void unsuccessfulCheckForOneHostnameWithWildcardAndDirectCertificate()
+      throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
         .add("*.example.com", keypairACertificate1Pin)
         .add("a.example.com", keypairBCertificate1Pin)
@@ -223,8 +226,9 @@ static ByteString pinToBase64(String pin) {
         .add("second.com", keypairCCertificate1Pin)
         .build();
 
-    Set<ByteString> expectedPins = setOf(keypairACertificate1PinBase64, keypairBCertificate1PinBase64);
-    Set<ByteString> matchedPins  = certificatePinner.findMatchingPins("first.com");
+    Set<ByteString> expectedPins =
+        setOf(keypairACertificate1PinBase64, keypairBCertificate1PinBase64);
+    Set<ByteString> matchedPins = certificatePinner.findMatchingPins("first.com");
 
     assertEquals(expectedPins, matchedPins);
   }
@@ -236,8 +240,9 @@ static ByteString pinToBase64(String pin) {
         .add("b.example.com", keypairCCertificate1Pin)
         .build();
 
-    Set<ByteString> expectedPins = setOf(keypairACertificate1PinBase64, keypairBCertificate1PinBase64);
-    Set<ByteString> matchedPins  = certificatePinner.findMatchingPins("a.example.com");
+    Set<ByteString> expectedPins =
+        setOf(keypairACertificate1PinBase64, keypairBCertificate1PinBase64);
+    Set<ByteString> matchedPins = certificatePinner.findMatchingPins("a.example.com");
 
     assertEquals(expectedPins, matchedPins);
   }
diff --git a/okhttp-tests/src/test/java/okhttp3/ConnectionPoolTest.java b/okhttp-tests/src/test/java/okhttp3/ConnectionPoolTest.java
index 86b5fdaa33..84ebbc6824 100644
--- a/okhttp-tests/src/test/java/okhttp3/ConnectionPoolTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/ConnectionPoolTest.java
@@ -15,9 +15,6 @@
  */
 package okhttp3;
 
-import okhttp3.internal.RecordingOkAuthenticator;
-import okhttp3.internal.http.StreamAllocation;
-import okhttp3.internal.io.RealConnection;
 import java.net.InetSocketAddress;
 import java.net.Proxy;
 import java.net.ProxySelector;
@@ -25,6 +22,10 @@
 import java.util.Collections;
 import java.util.concurrent.TimeUnit;
 import javax.net.SocketFactory;
+import okhttp3.internal.Internal;
+import okhttp3.internal.RecordingOkAuthenticator;
+import okhttp3.internal.http.StreamAllocation;
+import okhttp3.internal.io.RealConnection;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
@@ -32,11 +33,6 @@
 import static org.junit.Assert.assertTrue;
 
 public final class ConnectionPoolTest {
-  private final Runnable emptyRunnable = new Runnable() {
-    @Override public void run() {
-    }
-  };
-
   private final Address addressA = newAddress("a");
   private final Route routeA1 = newRoute(addressA);
   private final Address addressB = newAddress("b");
@@ -44,41 +40,45 @@
   private final Address addressC = newAddress("c");
   private final Route routeC1 = newRoute(addressC);
 
+  static {
+    Internal.initializeInstanceForTests();
+  }
+
   @Test public void connectionsEvictedWhenIdleLongEnough() throws Exception {
     ConnectionPool pool = new ConnectionPool(Integer.MAX_VALUE, 100L, TimeUnit.NANOSECONDS);
-    pool.setCleanupRunnableForTest(emptyRunnable);
+    pool.cleanupRunning = true; // Prevent the cleanup runnable from being started.
 
     RealConnection c1 = newConnection(pool, routeA1, 50L);
 
     // Running at time 50, the pool returns that nothing can be evicted until time 150.
     assertEquals(100L, pool.cleanup(50L));
-    assertEquals(1, pool.getConnectionCount());
+    assertEquals(1, pool.connectionCount());
     assertFalse(c1.socket.isClosed());
 
     // Running at time 60, the pool returns that nothing can be evicted until time 150.
     assertEquals(90L, pool.cleanup(60L));
-    assertEquals(1, pool.getConnectionCount());
+    assertEquals(1, pool.connectionCount());
     assertFalse(c1.socket.isClosed());
 
     // Running at time 149, the pool returns that nothing can be evicted until time 150.
     assertEquals(1L, pool.cleanup(149L));
-    assertEquals(1, pool.getConnectionCount());
+    assertEquals(1, pool.connectionCount());
     assertFalse(c1.socket.isClosed());
 
     // Running at time 150, the pool evicts.
     assertEquals(0, pool.cleanup(150L));
-    assertEquals(0, pool.getConnectionCount());
+    assertEquals(0, pool.connectionCount());
     assertTrue(c1.socket.isClosed());
 
     // Running again, the pool reports that no further runs are necessary.
     assertEquals(-1, pool.cleanup(150L));
-    assertEquals(0, pool.getConnectionCount());
+    assertEquals(0, pool.connectionCount());
     assertTrue(c1.socket.isClosed());
   }
 
   @Test public void inUseConnectionsNotEvicted() throws Exception {
     ConnectionPool pool = new ConnectionPool(Integer.MAX_VALUE, 100L, TimeUnit.NANOSECONDS);
-    pool.setCleanupRunnableForTest(emptyRunnable);
+    pool.cleanupRunning = true; // Prevent the cleanup runnable from being started.
 
     RealConnection c1 = newConnection(pool, routeA1, 50L);
     StreamAllocation streamAllocation = new StreamAllocation(pool, addressA);
@@ -86,62 +86,62 @@
 
     // Running at time 50, the pool returns that nothing can be evicted until time 150.
     assertEquals(100L, pool.cleanup(50L));
-    assertEquals(1, pool.getConnectionCount());
+    assertEquals(1, pool.connectionCount());
     assertFalse(c1.socket.isClosed());
 
     // Running at time 60, the pool returns that nothing can be evicted until time 160.
     assertEquals(100L, pool.cleanup(60L));
-    assertEquals(1, pool.getConnectionCount());
+    assertEquals(1, pool.connectionCount());
     assertFalse(c1.socket.isClosed());
 
     // Running at time 160, the pool returns that nothing can be evicted until time 260.
     assertEquals(100L, pool.cleanup(160L));
-    assertEquals(1, pool.getConnectionCount());
+    assertEquals(1, pool.connectionCount());
     assertFalse(c1.socket.isClosed());
   }
 
   @Test public void cleanupPrioritizesEarliestEviction() throws Exception {
     ConnectionPool pool = new ConnectionPool(Integer.MAX_VALUE, 100L, TimeUnit.NANOSECONDS);
-    pool.setCleanupRunnableForTest(emptyRunnable);
+    pool.cleanupRunning = true; // Prevent the cleanup runnable from being started.
 
     RealConnection c1 = newConnection(pool, routeA1, 75L);
     RealConnection c2 = newConnection(pool, routeB1, 50L);
 
     // Running at time 75, the pool returns that nothing can be evicted until time 150.
     assertEquals(75L, pool.cleanup(75L));
-    assertEquals(2, pool.getConnectionCount());
+    assertEquals(2, pool.connectionCount());
 
     // Running at time 149, the pool returns that nothing can be evicted until time 150.
     assertEquals(1L, pool.cleanup(149L));
-    assertEquals(2, pool.getConnectionCount());
+    assertEquals(2, pool.connectionCount());
 
     // Running at time 150, the pool evicts c2.
     assertEquals(0L, pool.cleanup(150L));
-    assertEquals(1, pool.getConnectionCount());
+    assertEquals(1, pool.connectionCount());
     assertFalse(c1.socket.isClosed());
     assertTrue(c2.socket.isClosed());
 
     // Running at time 150, the pool returns that nothing can be evicted until time 175.
     assertEquals(25L, pool.cleanup(150L));
-    assertEquals(1, pool.getConnectionCount());
+    assertEquals(1, pool.connectionCount());
 
     // Running at time 175, the pool evicts c1.
     assertEquals(0L, pool.cleanup(175L));
-    assertEquals(0, pool.getConnectionCount());
+    assertEquals(0, pool.connectionCount());
     assertTrue(c1.socket.isClosed());
     assertTrue(c2.socket.isClosed());
   }
 
   @Test public void oldestConnectionsEvictedIfIdleLimitExceeded() throws Exception {
     ConnectionPool pool = new ConnectionPool(2, 100L, TimeUnit.NANOSECONDS);
-    pool.setCleanupRunnableForTest(emptyRunnable);
+    pool.cleanupRunning = true; // Prevent the cleanup runnable from being started.
 
     RealConnection c1 = newConnection(pool, routeA1, 50L);
     RealConnection c2 = newConnection(pool, routeB1, 75L);
 
     // With 2 connections, there's no need to evict until the connections time out.
     assertEquals(50L, pool.cleanup(100L));
-    assertEquals(2, pool.getConnectionCount());
+    assertEquals(2, pool.connectionCount());
     assertFalse(c1.socket.isClosed());
     assertFalse(c2.socket.isClosed());
 
@@ -150,7 +150,7 @@
 
     // The third connection bounces the first.
     assertEquals(0L, pool.cleanup(100L));
-    assertEquals(2, pool.getConnectionCount());
+    assertEquals(2, pool.connectionCount());
     assertTrue(c1.socket.isClosed());
     assertFalse(c2.socket.isClosed());
     assertFalse(c3.socket.isClosed());
@@ -158,7 +158,7 @@
 
   @Test public void leakedAllocation() throws Exception {
     ConnectionPool pool = new ConnectionPool(2, 100L, TimeUnit.NANOSECONDS);
-    pool.setCleanupRunnableForTest(emptyRunnable);
+    pool.cleanupRunning = true; // Prevent the cleanup runnable from being started.
 
     RealConnection c1 = newConnection(pool, routeA1, 0L);
     allocateAndLeakAllocation(pool, c1);
@@ -172,7 +172,7 @@
 
   /** Use a helper method so there's no hidden reference remaining on the stack. */
   private void allocateAndLeakAllocation(ConnectionPool pool, RealConnection connection) {
-    StreamAllocation leak = new StreamAllocation(pool, connection.getRoute().address());
+    StreamAllocation leak = new StreamAllocation(pool, connection.route().address());
     leak.acquire(connection);
   }
 
diff --git a/okhttp-tests/src/test/java/okhttp3/ConnectionReuseTest.java b/okhttp-tests/src/test/java/okhttp3/ConnectionReuseTest.java
index b482798044..a25d8debef 100644
--- a/okhttp-tests/src/test/java/okhttp3/ConnectionReuseTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/ConnectionReuseTest.java
@@ -15,27 +15,30 @@
  */
 package okhttp3;
 
+import java.util.Arrays;
+import java.util.concurrent.TimeUnit;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLException;
+import javax.net.ssl.SSLSocketFactory;
 import okhttp3.internal.SslContextBuilder;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.SocketPolicy;
-import okhttp3.testing.RecordingHostnameVerifier;
-import java.util.Arrays;
-import java.util.concurrent.TimeUnit;
-import javax.net.ssl.SSLContext;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.TestRule;
 import org.junit.rules.Timeout;
 
+import static okhttp3.TestUtil.defaultClient;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
 
 public final class ConnectionReuseTest {
   @Rule public final TestRule timeout = new Timeout(30_000);
   @Rule public final MockWebServer server = new MockWebServer();
 
   private SSLContext sslContext = SslContextBuilder.localhost();
-  private OkHttpClient client = new OkHttpClient();
+  private OkHttpClient client = defaultClient();
 
   @Test public void connectionsAreReused() throws Exception {
     server.enqueue(new MockResponse().setBody("a"));
@@ -101,7 +104,9 @@
   }
 
   @Test public void connectionsAreNotReusedIfPoolIsSizeZero() throws Exception {
-    client.setConnectionPool(new ConnectionPool(0, 5000));
+    client = client.newBuilder()
+        .connectionPool(new ConnectionPool(0, 5, TimeUnit.SECONDS))
+        .build();
     server.enqueue(new MockResponse().setBody("a"));
     server.enqueue(new MockResponse().setBody("b"));
 
@@ -112,7 +117,9 @@
   }
 
   @Test public void connectionsReusedWithRedirectEvenIfPoolIsSizeZero() throws Exception {
-    client.setConnectionPool(new ConnectionPool(0, 5000));
+    client = client.newBuilder()
+        .connectionPool(new ConnectionPool(0, 5, TimeUnit.SECONDS))
+        .build();
     server.enqueue(new MockResponse()
         .setResponseCode(301)
         .addHeader("Location: /b")
@@ -129,7 +136,9 @@
   }
 
   @Test public void connectionsNotReusedWithRedirectIfDiscardingResponseIsSlow() throws Exception {
-    client.setConnectionPool(new ConnectionPool(0, 5000));
+    client = client.newBuilder()
+        .connectionPool(new ConnectionPool(0, 5, TimeUnit.SECONDS))
+        .build();
     server.enqueue(new MockResponse()
         .setResponseCode(301)
         .addHeader("Location: /b")
@@ -206,7 +215,9 @@
     server.enqueue(new MockResponse().setBody("a"));
     server.enqueue(new MockResponse().setBody("b"));
 
-    client.setConnectionPool(new ConnectionPool(5, 250, TimeUnit.MILLISECONDS));
+    client = client.newBuilder()
+        .connectionPool(new ConnectionPool(5, 250, TimeUnit.MILLISECONDS))
+        .build();
     Request request = new Request.Builder()
         .url(server.url("/"))
         .build();
@@ -224,12 +235,74 @@
     assertEquals(0, server.takeRequest().getSequenceNumber());
   }
 
+  @Test public void connectionsAreNotReusedIfSslSocketFactoryChanges() throws Exception {
+    enableHttps();
+    server.enqueue(new MockResponse());
+    server.enqueue(new MockResponse());
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    Response response = client.newCall(request).execute();
+    response.body().close();
+
+    // This client shares a connection pool but has a different SSL socket factory.
+    SSLContext sslContext2 = SSLContext.getInstance("TLS");
+    sslContext2.init(null, null, null);
+    SSLSocketFactory sslSocketFactory2 = sslContext2.getSocketFactory();
+    OkHttpClient anotherClient = client.newBuilder()
+        .sslSocketFactory(sslSocketFactory2)
+        .build();
+
+    // This client fails to connect because the new SSL socket factory refuses.
+    try {
+      anotherClient.newCall(request).execute();
+      fail();
+    } catch (SSLException expected) {
+    }
+  }
+
+  @Test public void connectionsAreNotReusedIfHostnameVerifierChanges() throws Exception {
+    enableHttps();
+    server.enqueue(new MockResponse());
+    server.enqueue(new MockResponse());
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    Response response1 = client.newCall(request).execute();
+    response1.body().close();
+
+    // This client shares a connection pool but has a different SSL socket factory.
+    OkHttpClient anotherClient = client.newBuilder()
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build();
+
+    Response response2 = anotherClient.newCall(request).execute();
+    response2.body().close();
+
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+  }
+
+  private void enableHttps() {
+    enableHttpsAndAlpn(Protocol.HTTP_1_1);
+  }
+
   private void enableHttp2() {
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
-    client.setProtocols(Arrays.asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
+    enableHttpsAndAlpn(Protocol.HTTP_2, Protocol.HTTP_1_1);
+  }
+
+  private void enableHttpsAndAlpn(Protocol... protocols) {
+    client = client.newBuilder()
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .protocols(Arrays.asList(protocols))
+        .build();
     server.useHttps(sslContext.getSocketFactory(), false);
-    server.setProtocols(client.getProtocols());
+    server.setProtocols(client.protocols());
   }
 
   private void assertConnectionReused(Request... requests) throws Exception {
diff --git a/okhttp-tests/src/test/java/okhttp3/ConnectionSpecTest.java b/okhttp-tests/src/test/java/okhttp3/ConnectionSpecTest.java
index 7db756d5a4..7fbd08e628 100644
--- a/okhttp-tests/src/test/java/okhttp3/ConnectionSpecTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/ConnectionSpecTest.java
@@ -214,8 +214,8 @@
 
     tlsSpec.apply(sslSocket, false);
     assertEquals(Arrays.asList(
-            CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName,
-            CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName),
+        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName,
+        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName),
         Arrays.asList(sslSocket.getEnabledCipherSuites()));
   }
 
@@ -249,10 +249,10 @@
     });
 
     socket.setEnabledProtocols(
-        new String[] { TlsVersion.TLS_1_2.javaName, TlsVersion.TLS_1_1.javaName });
+        new String[] {TlsVersion.TLS_1_2.javaName, TlsVersion.TLS_1_1.javaName});
     assertTrue(tlsSpec.isCompatible(socket));
 
-    socket.setEnabledProtocols(new String[] { TlsVersion.TLS_1_1.javaName });
+    socket.setEnabledProtocols(new String[] {TlsVersion.TLS_1_1.javaName});
     assertFalse(tlsSpec.isCompatible(socket));
   }
 
diff --git a/okhttp-tests/src/test/java/okhttp3/CookieTest.java b/okhttp-tests/src/test/java/okhttp3/CookieTest.java
new file mode 100644
index 0000000000..bffa4c7bec
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/CookieTest.java
@@ -0,0 +1,467 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.text.ParseException;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.List;
+import okhttp3.internal.Util;
+import okhttp3.internal.http.HttpDate;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class CookieTest {
+  HttpUrl url = HttpUrl.parse("https://example.com/");
+
+  @Test public void simpleCookie() throws Exception {
+    Cookie cookie = Cookie.parse(url, "SID=31d4d96e407aad42");
+    assertEquals("SID=31d4d96e407aad42; path=/", cookie.toString());
+  }
+
+  @Test public void noEqualsSign() throws Exception {
+    assertNull(Cookie.parse(url, "foo"));
+    assertNull(Cookie.parse(url, "foo; Path=/"));
+  }
+
+  @Test public void emptyName() throws Exception {
+    assertNull(Cookie.parse(url, "=b"));
+    assertNull(Cookie.parse(url, " =b"));
+    assertNull(Cookie.parse(url, "\r\t \n=b"));
+  }
+
+  @Test public void trimLeadingAndTrailingWhitespaceFromName() throws Exception {
+    assertEquals("a", Cookie.parse(url, " a=b").name());
+    assertEquals("a", Cookie.parse(url, "a =b").name());
+    assertEquals("a", Cookie.parse(url, "\r\t \na\n\t \n=b").name());
+  }
+
+  @Test public void emptyValue() throws Exception {
+    assertEquals("", Cookie.parse(url, "a=").value());
+    assertEquals("", Cookie.parse(url, "a= ").value());
+    assertEquals("", Cookie.parse(url, "a=\r\t \n").value());
+  }
+
+  @Test public void trimLeadingAndTrailingWhitespaceFromValue() throws Exception {
+    assertEquals("", Cookie.parse(url, "a= ").value());
+    assertEquals("b", Cookie.parse(url, "a= b").value());
+    assertEquals("b", Cookie.parse(url, "a=b ").value());
+    assertEquals("b", Cookie.parse(url, "a=\r\t \nb\n\t \n").value());
+  }
+
+  @Test public void maxAge() throws Exception {
+    assertEquals(51000L,
+        Cookie.parse(50000L, url, "a=b; Max-Age=1").expiresAt());
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(50000L, url, "a=b; Max-Age=9223372036854724").expiresAt());
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(50000L, url, "a=b; Max-Age=9223372036854725").expiresAt());
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(50000L, url, "a=b; Max-Age=9223372036854726").expiresAt());
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(9223372036854773807L, url, "a=b; Max-Age=1").expiresAt());
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(9223372036854773807L, url, "a=b; Max-Age=2").expiresAt());
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(9223372036854773807L, url, "a=b; Max-Age=3").expiresAt());
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(50000L, url, "a=b; Max-Age=10000000000000000000").expiresAt());
+  }
+
+  @Test public void maxAgeNonPositive() throws Exception {
+    assertEquals(Long.MIN_VALUE,
+        Cookie.parse(50000L, url, "a=b; Max-Age=-1").expiresAt());
+    assertEquals(Long.MIN_VALUE,
+        Cookie.parse(50000L, url, "a=b; Max-Age=0").expiresAt());
+    assertEquals(Long.MIN_VALUE,
+        Cookie.parse(50000L, url, "a=b; Max-Age=-9223372036854775808").expiresAt());
+    assertEquals(Long.MIN_VALUE,
+        Cookie.parse(50000L, url, "a=b; Max-Age=-9223372036854775809").expiresAt());
+    assertEquals(Long.MIN_VALUE,
+        Cookie.parse(50000L, url, "a=b; Max-Age=-10000000000000000000").expiresAt());
+  }
+
+  @Test public void domainAndPath() throws Exception {
+    Cookie cookie = Cookie.parse(url, "SID=31d4d96e407aad42; Path=/; Domain=example.com");
+    assertEquals("example.com", cookie.domain());
+    assertEquals("/", cookie.path());
+    assertFalse(cookie.hostOnly());
+    assertEquals("SID=31d4d96e407aad42; domain=example.com; path=/", cookie.toString());
+  }
+
+  @Test public void secureAndHttpOnly() throws Exception {
+    Cookie cookie = Cookie.parse(url, "SID=31d4d96e407aad42; Path=/; Secure; HttpOnly");
+    assertTrue(cookie.secure());
+    assertTrue(cookie.httpOnly());
+    assertEquals("SID=31d4d96e407aad42; path=/; secure; httponly", cookie.toString());
+  }
+
+  @Test public void expiresDate() throws Exception {
+    assertEquals(date("1970-01-01T00:00:00.000+0000"), new Date(
+        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 00:00:00 GMT").expiresAt()));
+    assertEquals(date("2021-06-09T10:18:14.000+0000"), new Date(
+        Cookie.parse(url, "a=b; Expires=Wed, 09 Jun 2021 10:18:14 GMT").expiresAt()));
+    assertEquals(date("1994-11-06T08:49:37.000+0000"), new Date(
+        Cookie.parse(url, "a=b; Expires=Sun, 06 Nov 1994 08:49:37 GMT").expiresAt()));
+  }
+
+  @Test public void awkwardDates() throws Exception {
+    assertEquals(0L,
+        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 70 00:00:00 GMT").expiresAt());
+    assertEquals(0L,
+        Cookie.parse(url, "a=b; Expires=Thu, 01 January 1970 00:00:00 GMT").expiresAt());
+    assertEquals(0L,
+        Cookie.parse(url, "a=b; Expires=Thu, 01 Janucember 1970 00:00:00 GMT").expiresAt());
+    assertEquals(0L,
+        Cookie.parse(url, "a=b; Expires=Thu, 1 Jan 1970 00:00:00 GMT").expiresAt());
+    assertEquals(0L,
+        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 0:00:00 GMT").expiresAt());
+    assertEquals(0L,
+        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 00:0:00 GMT").expiresAt());
+    assertEquals(0L,
+        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 00:00:0 GMT").expiresAt());
+    assertEquals(0L,
+        Cookie.parse(url, "a=b; Expires=00:00:00 Thu, 01 Jan 1970 GMT").expiresAt());
+    assertEquals(0L,
+        Cookie.parse(url, "a=b; Expires=00:00:00 1970 Jan 01").expiresAt());
+    assertEquals(0L,
+        Cookie.parse(url, "a=b; Expires=00:00:00 1970 Jan 1").expiresAt());
+  }
+
+  @Test public void invalidYear() throws Exception {
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1600 00:00:00 GMT").expiresAt());
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 19999 00:00:00 GMT").expiresAt());
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 00:00:00 GMT").expiresAt());
+  }
+
+  @Test public void invalidMonth() throws Exception {
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(url, "a=b; Expires=Thu, 01 Foo 1970 00:00:00 GMT").expiresAt());
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(url, "a=b; Expires=Thu, 01 Foocember 1970 00:00:00 GMT").expiresAt());
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(url, "a=b; Expires=Thu, 01 1970 00:00:00 GMT").expiresAt());
+  }
+
+  @Test public void invalidDayOfMonth() throws Exception {
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(url, "a=b; Expires=Thu, 32 Jan 1970 00:00:00 GMT").expiresAt());
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(url, "a=b; Expires=Thu, Jan 1970 00:00:00 GMT").expiresAt());
+  }
+
+  @Test public void invalidHour() throws Exception {
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 24:00:00 GMT").expiresAt());
+  }
+
+  @Test public void invalidMinute() throws Exception {
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 00:60:00 GMT").expiresAt());
+  }
+
+  @Test public void invalidSecond() throws Exception {
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 00:00:60 GMT").expiresAt());
+  }
+
+  @Test public void domainMatches() throws Exception {
+    Cookie cookie = Cookie.parse(url, "a=b; domain=example.com");
+    assertTrue(cookie.matches(HttpUrl.parse("http://example.com")));
+    assertTrue(cookie.matches(HttpUrl.parse("http://www.example.com")));
+    assertFalse(cookie.matches(HttpUrl.parse("http://square.com")));
+  }
+
+  /** If no domain is present, match only the origin domain. */
+  @Test public void domainMatchesNoDomain() throws Exception {
+    Cookie cookie = Cookie.parse(url, "a=b");
+    assertTrue(cookie.matches(HttpUrl.parse("http://example.com")));
+    assertFalse(cookie.matches(HttpUrl.parse("http://www.example.com")));
+    assertFalse(cookie.matches(HttpUrl.parse("http://square.com")));
+  }
+
+  /** Ignore an optional leading `.` in the domain. */
+  @Test public void domainMatchesIgnoresLeadingDot() throws Exception {
+    Cookie cookie = Cookie.parse(url, "a=b; domain=.example.com");
+    assertTrue(cookie.matches(HttpUrl.parse("http://example.com")));
+    assertTrue(cookie.matches(HttpUrl.parse("http://www.example.com")));
+    assertFalse(cookie.matches(HttpUrl.parse("http://square.com")));
+  }
+
+  /** Ignore the entire attribute if the domain ends with `.`. */
+  @Test public void domainIgnoredWithTrailingDot() throws Exception {
+    Cookie cookie = Cookie.parse(url, "a=b; domain=example.com.");
+    assertTrue(cookie.matches(HttpUrl.parse("http://example.com")));
+    assertFalse(cookie.matches(HttpUrl.parse("http://www.example.com")));
+    assertFalse(cookie.matches(HttpUrl.parse("http://square.com")));
+  }
+
+  @Test public void idnDomainMatches() throws Exception {
+    Cookie cookie = Cookie.parse(HttpUrl.parse("http://☃.net/"), "a=b; domain=☃.net");
+    assertTrue(cookie.matches(HttpUrl.parse("http://☃.net/")));
+    assertTrue(cookie.matches(HttpUrl.parse("http://xn--n3h.net/")));
+    assertTrue(cookie.matches(HttpUrl.parse("http://www.☃.net/")));
+    assertTrue(cookie.matches(HttpUrl.parse("http://www.xn--n3h.net/")));
+  }
+
+  @Test public void punycodeDomainMatches() throws Exception {
+    Cookie cookie = Cookie.parse(HttpUrl.parse("http://xn--n3h.net/"), "a=b; domain=xn--n3h.net");
+    assertTrue(cookie.matches(HttpUrl.parse("http://☃.net/")));
+    assertTrue(cookie.matches(HttpUrl.parse("http://xn--n3h.net/")));
+    assertTrue(cookie.matches(HttpUrl.parse("http://www.☃.net/")));
+    assertTrue(cookie.matches(HttpUrl.parse("http://www.xn--n3h.net/")));
+  }
+
+  @Test public void domainMatchesIpAddress() throws Exception {
+    HttpUrl urlWithIp = HttpUrl.parse("http://123.45.234.56/");
+    assertNull(Cookie.parse(urlWithIp, "a=b; domain=234.56"));
+    assertEquals("123.45.234.56", Cookie.parse(urlWithIp, "a=b; domain=123.45.234.56").domain());
+  }
+
+  @Test public void hostOnly() throws Exception {
+    assertTrue(Cookie.parse(url, "a=b").hostOnly());
+    assertFalse(Cookie.parse(url, "a=b; domain=example.com").hostOnly());
+  }
+
+  @Test public void defaultPath() throws Exception {
+    assertEquals("/foo", Cookie.parse(HttpUrl.parse("http://example.com/foo/bar"), "a=b").path());
+    assertEquals("/foo", Cookie.parse(HttpUrl.parse("http://example.com/foo/"), "a=b").path());
+    assertEquals("/", Cookie.parse(HttpUrl.parse("http://example.com/foo"), "a=b").path());
+    assertEquals("/", Cookie.parse(HttpUrl.parse("http://example.com/"), "a=b").path());
+  }
+
+  @Test public void defaultPathIsUsedIfPathDoesntHaveLeadingSlash() throws Exception {
+    assertEquals("/foo", Cookie.parse(HttpUrl.parse("http://example.com/foo/bar"),
+        "a=b; path=quux").path());
+    assertEquals("/foo", Cookie.parse(HttpUrl.parse("http://example.com/foo/bar"),
+        "a=b; path=").path());
+  }
+
+  @Test public void pathAttributeDoesntNeedToMatch() throws Exception {
+    assertEquals("/quux", Cookie.parse(HttpUrl.parse("http://example.com/"),
+        "a=b; path=/quux").path());
+    assertEquals("/quux", Cookie.parse(HttpUrl.parse("http://example.com/foo/bar"),
+        "a=b; path=/quux").path());
+  }
+
+  @Test public void httpOnly() throws Exception {
+    assertFalse(Cookie.parse(url, "a=b").httpOnly());
+    assertTrue(Cookie.parse(url, "a=b; HttpOnly").httpOnly());
+  }
+
+  @Test public void secure() throws Exception {
+    assertFalse(Cookie.parse(url, "a=b").secure());
+    assertTrue(Cookie.parse(url, "a=b; Secure").secure());
+  }
+
+  @Test public void maxAgeTakesPrecedenceOverExpires() throws Exception {
+    // Max-Age = 1, Expires = 2. In either order.
+    assertEquals(1000L, Cookie.parse(
+        0L, url, "a=b; Max-Age=1; Expires=Thu, 01 Jan 1970 00:00:02 GMT").expiresAt());
+    assertEquals(1000L, Cookie.parse(
+        0L, url, "a=b; Expires=Thu, 01 Jan 1970 00:00:02 GMT; Max-Age=1").expiresAt());
+    // Max-Age = 2, Expires = 1. In either order.
+    assertEquals(2000L, Cookie.parse(
+        0L, url, "a=b; Max-Age=2; Expires=Thu, 01 Jan 1970 00:00:01 GMT").expiresAt());
+    assertEquals(2000L, Cookie.parse(
+        0L, url, "a=b; Expires=Thu, 01 Jan 1970 00:00:01 GMT; Max-Age=2").expiresAt());
+  }
+
+  /** If a cookie incorrectly defines multiple 'Max-Age' attributes, the last one defined wins. */
+  @Test public void lastMaxAgeWins() throws Exception {
+    assertEquals(3000L, Cookie.parse(
+        0L, url, "a=b; Max-Age=2; Max-Age=4; Max-Age=1; Max-Age=3").expiresAt());
+  }
+
+  /** If a cookie incorrectly defines multiple 'Expires' attributes, the last one defined wins. */
+  @Test public void lastExpiresAtWins() throws Exception {
+    assertEquals(3000L, Cookie.parse(0L, url, "a=b; "
+        + "Expires=Thu, 01 Jan 1970 00:00:02 GMT; "
+        + "Expires=Thu, 01 Jan 1970 00:00:04 GMT; "
+        + "Expires=Thu, 01 Jan 1970 00:00:01 GMT; "
+        + "Expires=Thu, 01 Jan 1970 00:00:03 GMT").expiresAt());
+  }
+
+  @Test public void maxAgeOrExpiresMakesCookiePersistent() throws Exception {
+    assertFalse(Cookie.parse(0L, url, "a=b").persistent());
+    assertTrue(Cookie.parse(0L, url, "a=b; Max-Age=1").persistent());
+    assertTrue(Cookie.parse(0L, url, "a=b; Expires=Thu, 01 Jan 1970 00:00:01 GMT").persistent());
+  }
+
+  @Test public void parseAll() throws Exception {
+    Headers headers = new Headers.Builder()
+        .add("Set-Cookie: a=b")
+        .add("Set-Cookie: c=d")
+        .build();
+    List<Cookie> cookies = Cookie.parseAll(url, headers);
+    assertEquals(2, cookies.size());
+    assertEquals("a=b; path=/", cookies.get(0).toString());
+    assertEquals("c=d; path=/", cookies.get(1).toString());
+  }
+
+  @Test public void builder() throws Exception {
+    Cookie cookie = new Cookie.Builder()
+        .name("a")
+        .value("b")
+        .domain("example.com")
+        .build();
+    assertEquals("a", cookie.name());
+    assertEquals("b", cookie.value());
+    assertEquals(HttpDate.MAX_DATE, cookie.expiresAt());
+    assertEquals("example.com", cookie.domain());
+    assertEquals("/", cookie.path());
+    assertFalse(cookie.secure());
+    assertFalse(cookie.httpOnly());
+    assertFalse(cookie.persistent());
+    assertFalse(cookie.hostOnly());
+  }
+
+  @Test public void builderNameValidation() throws Exception {
+    try {
+      new Cookie.Builder().name(null);
+      fail();
+    } catch (NullPointerException expected) {
+    }
+    try {
+      new Cookie.Builder().name(" a ");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void builderValueValidation() throws Exception {
+    try {
+      new Cookie.Builder().value(null);
+      fail();
+    } catch (NullPointerException expected) {
+    }
+    try {
+      new Cookie.Builder().value(" b ");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void builderClampsMaxDate() throws Exception {
+    Cookie cookie = new Cookie.Builder()
+        .name("a")
+        .value("b")
+        .hostOnlyDomain("example.com")
+        .expiresAt(Long.MAX_VALUE)
+        .build();
+    assertEquals("a=b; expires=Fri, 31 Dec 9999 23:59:59 GMT; path=/", cookie.toString());
+  }
+
+  @Test public void builderExpiresAt() throws Exception {
+    Cookie cookie = new Cookie.Builder()
+        .name("a")
+        .value("b")
+        .hostOnlyDomain("example.com")
+        .expiresAt(date("1970-01-01T00:00:01.000+0000").getTime())
+        .build();
+    assertEquals("a=b; expires=Thu, 01 Jan 1970 00:00:01 GMT; path=/", cookie.toString());
+  }
+
+  @Test public void builderClampsMinDate() throws Exception {
+    Cookie cookie = new Cookie.Builder()
+        .name("a")
+        .value("b")
+        .hostOnlyDomain("example.com")
+        .expiresAt(date("1970-01-01T00:00:00.000+0000").getTime())
+        .build();
+    assertEquals("a=b; max-age=0; path=/", cookie.toString());
+  }
+
+  @Test public void builderDomainValidation() throws Exception {
+    try {
+      new Cookie.Builder().hostOnlyDomain(null);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+    try {
+      new Cookie.Builder().hostOnlyDomain("a/b");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void builderDomain() throws Exception {
+    Cookie cookie = new Cookie.Builder()
+        .name("a")
+        .value("b")
+        .hostOnlyDomain("squareup.com")
+        .build();
+    assertEquals("squareup.com", cookie.domain());
+    assertTrue(cookie.hostOnly());
+  }
+
+  @Test public void builderPath() throws Exception {
+    Cookie cookie = new Cookie.Builder()
+        .name("a")
+        .value("b")
+        .hostOnlyDomain("example.com")
+        .path("/foo")
+        .build();
+    assertEquals("/foo", cookie.path());
+  }
+
+  @Test public void builderPathValidation() throws Exception {
+    try {
+      new Cookie.Builder().path(null);
+      fail();
+    } catch (NullPointerException expected) {
+    }
+    try {
+      new Cookie.Builder().path("foo");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void builderSecure() throws Exception {
+    Cookie cookie = new Cookie.Builder()
+        .name("a")
+        .value("b")
+        .hostOnlyDomain("example.com")
+        .secure()
+        .build();
+    assertEquals(true, cookie.secure());
+  }
+
+  @Test public void builderHttpOnly() throws Exception {
+    Cookie cookie = new Cookie.Builder()
+        .name("a")
+        .value("b")
+        .hostOnlyDomain("example.com")
+        .httpOnly()
+        .build();
+    assertEquals(true, cookie.httpOnly());
+  }
+
+  private Date date(String s) throws ParseException {
+    SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ");
+    format.setTimeZone(Util.UTC);
+    return format.parse(s);
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/DelegatingSSLSocketFactory.java b/okhttp-tests/src/test/java/okhttp3/DelegatingSSLSocketFactory.java
index 8d0d092f2d..5a14d0fbd6 100644
--- a/okhttp-tests/src/test/java/okhttp3/DelegatingSSLSocketFactory.java
+++ b/okhttp-tests/src/test/java/okhttp3/DelegatingSSLSocketFactory.java
@@ -19,13 +19,12 @@
 import java.net.InetAddress;
 import java.net.Socket;
 import java.net.UnknownHostException;
-import javax.net.SocketFactory;
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
 
 /**
- * A {@link SSLSocketFactory} that delegates calls. Sockets can be configured after
- * creation by overriding {@link #configureSocket(javax.net.ssl.SSLSocket)}.
+ * A {@link SSLSocketFactory} that delegates calls. Sockets can be configured after creation by
+ * overriding {@link #configureSocket(javax.net.ssl.SSLSocket)}.
  */
 public class DelegatingSSLSocketFactory extends SSLSocketFactory {
 
@@ -35,51 +34,43 @@ public DelegatingSSLSocketFactory(SSLSocketFactory delegate) {
     this.delegate = delegate;
   }
 
-  @Override
-  public SSLSocket createSocket() throws IOException {
+  @Override public SSLSocket createSocket() throws IOException {
     SSLSocket sslSocket = (SSLSocket) delegate.createSocket();
     return configureSocket(sslSocket);
   }
 
-  @Override
-  public SSLSocket createSocket(String host, int port) throws IOException, UnknownHostException {
+  @Override public SSLSocket createSocket(String host, int port) throws IOException {
     SSLSocket sslSocket = (SSLSocket) delegate.createSocket(host, port);
     return configureSocket(sslSocket);
   }
 
-  @Override
-  public SSLSocket createSocket(String host, int port, InetAddress localAddress, int localPort)
-      throws IOException, UnknownHostException {
+  @Override public SSLSocket createSocket(
+      String host, int port, InetAddress localAddress, int localPort) throws IOException {
     SSLSocket sslSocket = (SSLSocket) delegate.createSocket(host, port, localAddress, localPort);
     return configureSocket(sslSocket);
   }
 
-  @Override
-  public SSLSocket createSocket(InetAddress host, int port) throws IOException {
+  @Override public SSLSocket createSocket(InetAddress host, int port) throws IOException {
     SSLSocket sslSocket = (SSLSocket) delegate.createSocket(host, port);
     return configureSocket(sslSocket);
   }
 
-  @Override
-  public SSLSocket createSocket(InetAddress host, int port, InetAddress localAddress, int localPort)
-      throws IOException {
+  @Override public SSLSocket createSocket(
+      InetAddress host, int port, InetAddress localAddress, int localPort) throws IOException {
     SSLSocket sslSocket = (SSLSocket) delegate.createSocket(host, port, localAddress, localPort);
     return configureSocket(sslSocket);
   }
 
-  @Override
-  public String[] getDefaultCipherSuites() {
+  @Override public String[] getDefaultCipherSuites() {
     return delegate.getDefaultCipherSuites();
   }
 
-  @Override
-  public String[] getSupportedCipherSuites() {
+  @Override public String[] getSupportedCipherSuites() {
     return delegate.getSupportedCipherSuites();
   }
 
-  @Override
-  public SSLSocket createSocket(Socket socket, String host, int port, boolean autoClose)
-      throws IOException {
+  @Override public SSLSocket createSocket(
+      Socket socket, String host, int port, boolean autoClose) throws IOException {
     SSLSocket sslSocket = (SSLSocket) delegate.createSocket(socket, host, port, autoClose);
     return configureSocket(sslSocket);
   }
diff --git a/okhttp-tests/src/test/java/okhttp3/DispatcherTest.java b/okhttp-tests/src/test/java/okhttp3/DispatcherTest.java
index bb82b2f786..4dc3d0c6bd 100644
--- a/okhttp-tests/src/test/java/okhttp3/DispatcherTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/DispatcherTest.java
@@ -1,22 +1,32 @@
 package okhttp3;
 
+import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.Iterator;
+import java.util.LinkedHashSet;
 import java.util.List;
+import java.util.Set;
 import java.util.concurrent.AbstractExecutorService;
+import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
+import okhttp3.RealCall.AsyncCall;
 import org.junit.Before;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 public final class DispatcherTest {
   RecordingExecutor executor = new RecordingExecutor();
   RecordingCallback callback = new RecordingCallback();
   Dispatcher dispatcher = new Dispatcher(executor);
-  OkHttpClient client = new OkHttpClient().setDispatcher(dispatcher);
+  OkHttpClient client = new OkHttpClient.Builder()
+      .dispatcher(dispatcher)
+      .build();
 
   @Before public void setUp() throws Exception {
     dispatcher.setMaxRequests(20);
@@ -113,32 +123,136 @@
 
   @Test public void cancelingRunningJobTakesNoEffectUntilJobFinishes() throws Exception {
     dispatcher.setMaxRequests(1);
-    client.newCall(newRequest("http://a/1", "tag1")).enqueue(callback);
-    client.newCall(newRequest("http://a/2")).enqueue(callback);
-    dispatcher.cancel("tag1");
+    Call c1 = client.newCall(newRequest("http://a/1", "tag1"));
+    Call c2 = client.newCall(newRequest("http://a/2"));
+    c1.enqueue(callback);
+    c2.enqueue(callback);
+    c1.cancel();
     executor.assertJobs("http://a/1");
     executor.finishJob("http://a/1");
     executor.assertJobs("http://a/2");
   }
 
+  @Test public void asyncCallAccessors() throws Exception {
+    dispatcher.setMaxRequests(3);
+    Call a1 = client.newCall(newRequest("http://a/1"));
+    Call a2 = client.newCall(newRequest("http://a/2"));
+    Call a3 = client.newCall(newRequest("http://a/3"));
+    Call a4 = client.newCall(newRequest("http://a/4"));
+    Call a5 = client.newCall(newRequest("http://a/5"));
+    a1.enqueue(callback);
+    a2.enqueue(callback);
+    a3.enqueue(callback);
+    a4.enqueue(callback);
+    a5.enqueue(callback);
+    assertEquals(3, dispatcher.runningCallsCount());
+    assertEquals(2, dispatcher.queuedCallsCount());
+    assertEquals(set(a1, a2, a3), set(dispatcher.runningCalls()));
+    assertEquals(set(a4, a5), set(dispatcher.queuedCalls()));
+  }
+
+  @Test public void synchronousCallAccessors() throws Exception {
+    final CountDownLatch ready = new CountDownLatch(2);
+    final CountDownLatch waiting = new CountDownLatch(1);
+    client = client.newBuilder()
+        .addInterceptor(
+            new Interceptor() {
+              @Override public Response intercept(Chain chain) throws IOException {
+                try {
+                  ready.countDown();
+                  waiting.await();
+                } catch (InterruptedException e) {
+                  throw new AssertionError();
+                }
+                throw new IOException();
+              }
+            })
+        .build();
+
+    Call a1 = client.newCall(newRequest("http://a/1"));
+    Call a2 = client.newCall(newRequest("http://a/2"));
+    Call a3 = client.newCall(newRequest("http://a/3"));
+    Call a4 = client.newCall(newRequest("http://a/4"));
+    Thread t1 = makeSynchronousCall(a1);
+    Thread t2 = makeSynchronousCall(a2);
+
+    // We created 4 calls and started 2 of them. That's 2 running calls and 0 queued.
+    ready.await();
+    assertEquals(2, dispatcher.runningCallsCount());
+    assertEquals(0, dispatcher.queuedCallsCount());
+    assertEquals(set(a1, a2), set(dispatcher.runningCalls()));
+    assertEquals(Collections.emptyList(), dispatcher.queuedCalls());
+
+    // Cancel some calls. That doesn't impact running or queued.
+    a2.cancel();
+    a3.cancel();
+    assertEquals(set(a1, a2), set(dispatcher.runningCalls()));
+    assertEquals(Collections.emptyList(), dispatcher.queuedCalls());
+
+    // Let the calls finish.
+    waiting.countDown();
+    t1.join();
+    t2.join();
+
+    // Now we should have 0 running calls and 0 queued calls.
+    assertEquals(0, dispatcher.runningCallsCount());
+    assertEquals(0, dispatcher.queuedCallsCount());
+    assertEquals(Collections.emptyList(), dispatcher.runningCalls());
+    assertEquals(Collections.emptyList(), dispatcher.queuedCalls());
+
+    assertTrue(a1.isExecuted());
+    assertFalse(a1.isCanceled());
+
+    assertTrue(a2.isExecuted());
+    assertTrue(a2.isCanceled());
+
+    assertFalse(a3.isExecuted());
+    assertTrue(a3.isCanceled());
+
+    assertFalse(a4.isExecuted());
+    assertFalse(a4.isCanceled());
+  }
+
+  private <T> Set<T> set(T... values) {
+    return set(Arrays.asList(values));
+  }
+
+  private <T> Set<T> set(List<T> list) {
+    return new LinkedHashSet<>(list);
+  }
+
+  private Thread makeSynchronousCall(final Call call) {
+    Thread thread = new Thread() {
+      @Override public void run() {
+        try {
+          call.execute();
+          throw new AssertionError();
+        } catch (IOException expected) {
+        }
+      }
+    };
+    thread.start();
+    return thread;
+  }
+
   class RecordingExecutor extends AbstractExecutorService {
-    private List<Call.AsyncCall> calls = new ArrayList<>();
+    private List<AsyncCall> calls = new ArrayList<>();
 
     @Override public void execute(Runnable command) {
-      calls.add((Call.AsyncCall) command);
+      calls.add((AsyncCall) command);
     }
 
     public void assertJobs(String... expectedUrls) {
       List<String> actualUrls = new ArrayList<>();
-      for (Call.AsyncCall call : calls) {
+      for (AsyncCall call : calls) {
         actualUrls.add(call.request().url().toString());
       }
       assertEquals(Arrays.asList(expectedUrls), actualUrls);
     }
 
     public void finishJob(String url) {
-      for (Iterator<Call.AsyncCall> i = calls.iterator(); i.hasNext(); ) {
-        Call.AsyncCall call = i.next();
+      for (Iterator<AsyncCall> i = calls.iterator(); i.hasNext(); ) {
+        AsyncCall call = i.next();
         if (call.request().url().toString().equals(url)) {
           i.remove();
           dispatcher.finished(call);
diff --git a/okhttp-tests/src/test/java/okhttp3/FallbackTestClientSocketFactory.java b/okhttp-tests/src/test/java/okhttp3/FallbackTestClientSocketFactory.java
index 7a34362b4a..eb9aaaa2d3 100644
--- a/okhttp-tests/src/test/java/okhttp3/FallbackTestClientSocketFactory.java
+++ b/okhttp-tests/src/test/java/okhttp3/FallbackTestClientSocketFactory.java
@@ -29,8 +29,8 @@
  */
 public class FallbackTestClientSocketFactory extends DelegatingSSLSocketFactory {
   /**
-   * The cipher suite used during TLS connection fallback to indicate a fallback.
-   * See https://tools.ietf.org/html/draft-ietf-tls-downgrade-scsv-00
+   * The cipher suite used during TLS connection fallback to indicate a fallback. See
+   * https://tools.ietf.org/html/draft-ietf-tls-downgrade-scsv-00
    */
   public static final String TLS_FALLBACK_SCSV = "TLS_FALLBACK_SCSV";
 
diff --git a/okhttp-tests/src/test/java/okhttp3/FormBodyTest.java b/okhttp-tests/src/test/java/okhttp3/FormBodyTest.java
index a572ff235f..34e40b96f7 100644
--- a/okhttp-tests/src/test/java/okhttp3/FormBodyTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/FormBodyTest.java
@@ -189,7 +189,7 @@
   private String formEncode(int codePoint) throws IOException {
     // Wrap the codepoint with regular printable characters to prevent trimming.
     FormBody body = new FormBody.Builder()
-        .add("a", new String(new int[] { 'b', codePoint, 'c' }, 0, 3))
+        .add("a", new String(new int[] {'b', codePoint, 'c'}, 0, 3))
         .build();
     Buffer buffer = new Buffer();
     body.writeTo(buffer);
diff --git a/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java b/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java
index 36f99c5658..a67dc380d4 100644
--- a/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java
@@ -108,6 +108,22 @@
     assertEquals(null, HttpUrl.parse("#fragment"));
   }
 
+  @Test public void newBuilderResolve() throws Exception {
+    // Non-exhaustive tests because implementation is the same as resolve.
+    HttpUrl base = HttpUrl.parse("http://host/a/b");
+    assertEquals(HttpUrl.parse("https://host2/"), base.newBuilder("https://host2").build());
+    assertEquals(HttpUrl.parse("http://host2/"), base.newBuilder("//host2").build());
+    assertEquals(HttpUrl.parse("http://host/path"), base.newBuilder("/path").build());
+    assertEquals(HttpUrl.parse("http://host/a/path"), base.newBuilder("path").build());
+    assertEquals(HttpUrl.parse("http://host/a/b?query"), base.newBuilder("?query").build());
+    assertEquals(HttpUrl.parse("http://host/a/b#fragment"), base.newBuilder("#fragment").build());
+    assertEquals(HttpUrl.parse("http://host/a/b"), base.newBuilder("").build());
+    assertEquals(null, base.newBuilder("ftp://b"));
+    assertEquals(null, base.newBuilder("ht+tp://b"));
+    assertEquals(null, base.newBuilder("ht-tp://b"));
+    assertEquals(null, base.newBuilder("ht.tp://b"));
+  }
+
   @Test public void resolveNoScheme() throws Exception {
     HttpUrl base = HttpUrl.parse("http://host/a/b");
     assertEquals(HttpUrl.parse("http://host2/"), base.resolve("//host2"));
@@ -483,12 +499,7 @@
     assertEquals("http://host/#\u0080", url.toString());
     assertEquals("\u0080", url.fragment());
     assertEquals("\u0080", url.encodedFragment());
-    try {
-      url.uri();
-      fail();
-    } catch (IllegalStateException expected) {
-      // Possibly a bug in java.net.URI. Many non-ASCII code points work, this one doesn't!
-    }
+    assertEquals(new URI("http://host/#"), url.uri()); // Control characters may be stripped!
   }
 
   @Test public void fragmentPercentEncodedNonAscii() throws Exception {
@@ -1017,7 +1028,7 @@
     assertEquals("http://host/=[]:;%22~%7C%3F%23@%5E%2F$%25*", url.toString());
     assertEquals("http://host/=%5B%5D:;%22~%7C%3F%23@%5E%2F$%25*", url.uri().toString());
   }
-  
+
   @Test public void toUriQueryParameterNameSpecialCharacters() throws Exception {
     HttpUrl url = new HttpUrl.Builder()
         .scheme("http")
@@ -1058,19 +1069,46 @@
     assertEquals("http://host/#=[]:;%22~%7C?%23@%5E/$%25*", url.uri().toString());
   }
 
-  @Test public void toUriWithMalformedPercentEscape() throws Exception {
-    HttpUrl url = new HttpUrl.Builder()
-        .scheme("http")
-        .host("host")
-        .encodedPath("/%xx")
-        .build();
-    assertEquals("http://host/%xx", url.toString());
-    try {
-      url.uri();
-      fail();
-    } catch (IllegalStateException expected) {
-      assertEquals("not valid as a java.net.URI: http://host/%xx", expected.getMessage());
-    }
+  @Test public void toUriWithControlCharacters() throws Exception {
+    // Percent-encoded in the path.
+    assertEquals(new URI("http://host/a%00b"), HttpUrl.parse("http://host/a\u0000b").uri());
+    assertEquals(new URI("http://host/a%C2%80b"), HttpUrl.parse("http://host/a\u0080b").uri());
+    assertEquals(new URI("http://host/a%C2%9Fb"), HttpUrl.parse("http://host/a\u009fb").uri());
+    // Percent-encoded in the query.
+    assertEquals(new URI("http://host/?a%00b"), HttpUrl.parse("http://host/?a\u0000b").uri());
+    assertEquals(new URI("http://host/?a%C2%80b"), HttpUrl.parse("http://host/?a\u0080b").uri());
+    assertEquals(new URI("http://host/?a%C2%9Fb"), HttpUrl.parse("http://host/?a\u009fb").uri());
+    // Stripped from the fragment.
+    assertEquals(new URI("http://host/#a%00b"), HttpUrl.parse("http://host/#a\u0000b").uri());
+    assertEquals(new URI("http://host/#ab"), HttpUrl.parse("http://host/#a\u0080b").uri());
+    assertEquals(new URI("http://host/#ab"), HttpUrl.parse("http://host/#a\u009fb").uri());
+  }
+
+  @Test public void toUriWithSpaceCharacters() throws Exception {
+    // Percent-encoded in the path.
+    assertEquals(new URI("http://host/a%0Bb"), HttpUrl.parse("http://host/a\u000bb").uri());
+    assertEquals(new URI("http://host/a%20b"), HttpUrl.parse("http://host/a b").uri());
+    assertEquals(new URI("http://host/a%E2%80%89b"), HttpUrl.parse("http://host/a\u2009b").uri());
+    assertEquals(new URI("http://host/a%E3%80%80b"), HttpUrl.parse("http://host/a\u3000b").uri());
+    // Percent-encoded in the query.
+    assertEquals(new URI("http://host/?a%0Bb"), HttpUrl.parse("http://host/?a\u000bb").uri());
+    assertEquals(new URI("http://host/?a%20b"), HttpUrl.parse("http://host/?a b").uri());
+    assertEquals(new URI("http://host/?a%E2%80%89b"), HttpUrl.parse("http://host/?a\u2009b").uri());
+    assertEquals(new URI("http://host/?a%E3%80%80b"), HttpUrl.parse("http://host/?a\u3000b").uri());
+    // Stripped from the fragment.
+    assertEquals(new URI("http://host/#a%0Bb"), HttpUrl.parse("http://host/#a\u000bb").uri());
+    assertEquals(new URI("http://host/#a%20b"), HttpUrl.parse("http://host/#a b").uri());
+    assertEquals(new URI("http://host/#ab"), HttpUrl.parse("http://host/#a\u2009b").uri());
+    assertEquals(new URI("http://host/#ab"), HttpUrl.parse("http://host/#a\u3000b").uri());
+  }
+
+  @Test public void toUriWithNonHexPercentEscape() throws Exception {
+    assertEquals(new URI("http://host/%25xx"), HttpUrl.parse("http://host/%xx").uri());
+  }
+
+  @Test public void toUriWithTruncatedPercentEscape() throws Exception {
+    assertEquals(new URI("http://host/%25a"), HttpUrl.parse("http://host/%a").uri());
+    assertEquals(new URI("http://host/%25"), HttpUrl.parse("http://host/%").uri());
   }
 
   @Test public void fromJavaNetUrl() throws Exception {
@@ -1285,8 +1323,8 @@
   }
 
   /**
-   * Although HttpUrl prefers percent-encodings in uppercase, it should preserve the exact
-   * structure of the original encoding.
+   * Although HttpUrl prefers percent-encodings in uppercase, it should preserve the exact structure
+   * of the original encoding.
    */
   @Test public void rawEncodingRetained() throws Exception {
     String urlString = "http://%6d%6D:%6d%6D@host/%6d%6D?%6d%6D#%6d%6D";
diff --git a/okhttp-tests/src/test/java/okhttp3/InterceptorTest.java b/okhttp-tests/src/test/java/okhttp3/InterceptorTest.java
index ebce641a38..dd1f3a977b 100644
--- a/okhttp-tests/src/test/java/okhttp3/InterceptorTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/InterceptorTest.java
@@ -15,18 +15,17 @@
  */
 package okhttp3;
 
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.mockwebserver.RecordedRequest;
 import java.io.IOException;
 import java.util.Arrays;
-import java.util.List;
 import java.util.Locale;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.ForwardingSink;
@@ -38,6 +37,7 @@
 import org.junit.Rule;
 import org.junit.Test;
 
+import static okhttp3.TestUtil.defaultClient;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
@@ -47,7 +47,7 @@
 public final class InterceptorTest {
   @Rule public MockWebServer server = new MockWebServer();
 
-  private OkHttpClient client = new OkHttpClient();
+  private OkHttpClient client = defaultClient();
   private RecordingCallback callback = new RecordingCallback();
 
   @Test public void applicationInterceptorsCanShortCircuitResponses() throws Exception {
@@ -65,11 +65,12 @@
         .body(ResponseBody.create(MediaType.parse("text/plain; charset=utf-8"), "abc"))
         .build();
 
-    client.interceptors().add(new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        return interceptorResponse;
-      }
-    });
+    client = client.newBuilder()
+        .addInterceptor(new Interceptor() {
+          @Override public Response intercept(Chain chain) throws IOException {
+            return interceptorResponse;
+          }
+        }).build();
 
     Response response = client.newCall(request).execute();
     assertSame(interceptorResponse, response);
@@ -89,7 +90,9 @@
             .build();
       }
     };
-    client.networkInterceptors().add(interceptor);
+    client = client.newBuilder()
+        .addNetworkInterceptor(interceptor)
+        .build();
 
     Request request = new Request.Builder()
         .url(server.url("/"))
@@ -114,7 +117,9 @@
         return chain.proceed(chain.request());
       }
     };
-    client.networkInterceptors().add(interceptor);
+    client = client.newBuilder()
+        .addNetworkInterceptor(interceptor)
+        .build();
 
     Request request = new Request.Builder()
         .url(server.url("/"))
@@ -134,7 +139,7 @@
 
     Interceptor interceptor = new Interceptor() {
       @Override public Response intercept(Chain chain) throws IOException {
-        Address address = chain.connection().getRoute().address();
+        Address address = chain.connection().route().address();
         String sameHost = address.url().host();
         int differentPort = address.url().port() + 1;
         return chain.proceed(chain.request().newBuilder()
@@ -142,7 +147,9 @@
             .build());
       }
     };
-    client.networkInterceptors().add(interceptor);
+    client = client.newBuilder()
+        .addNetworkInterceptor(interceptor)
+        .build();
 
     Request request = new Request.Builder()
         .url(server.url("/"))
@@ -160,13 +167,16 @@
   @Test public void networkInterceptorsHaveConnectionAccess() throws Exception {
     server.enqueue(new MockResponse());
 
-    client.networkInterceptors().add(new Interceptor() {
+    Interceptor interceptor = new Interceptor() {
       @Override public Response intercept(Chain chain) throws IOException {
         Connection connection = chain.connection();
         assertNotNull(connection);
         return chain.proceed(chain.request());
       }
-    });
+    };
+    client = client.newBuilder()
+        .addNetworkInterceptor(interceptor)
+        .build();
 
     Request request = new Request.Builder()
         .url(server.url("/"))
@@ -179,7 +189,7 @@
         .setBody(gzip("abcabcabc"))
         .addHeader("Content-Encoding: gzip"));
 
-    client.networkInterceptors().add(new Interceptor() {
+    Interceptor interceptor = new Interceptor() {
       @Override public Response intercept(Chain chain) throws IOException {
         // The network request has everything: User-Agent, Host, Accept-Encoding.
         Request networkRequest = chain.request();
@@ -193,7 +203,10 @@
         assertEquals("gzip", networkResponse.header("Content-Encoding"));
         return networkResponse;
       }
-    });
+    };
+    client = client.newBuilder()
+        .addNetworkInterceptor(interceptor)
+        .build();
 
     Request request = new Request.Builder()
         .url(server.url("/"))
@@ -213,9 +226,8 @@
   @Test public void networkInterceptorsCanChangeRequestMethodFromGetToPost() throws Exception {
     server.enqueue(new MockResponse());
 
-    client.networkInterceptors().add(new Interceptor() {
-      @Override
-      public Response intercept(Chain chain) throws IOException {
+    Interceptor interceptor = new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
         Request originalRequest = chain.request();
         MediaType mediaType = MediaType.parse("text/plain");
         RequestBody body = RequestBody.create(mediaType, "abc");
@@ -225,7 +237,10 @@ public Response intercept(Chain chain) throws IOException {
             .header("Content-Length", Long.toString(body.contentLength()))
             .build());
       }
-    });
+    };
+    client = client.newBuilder()
+        .addNetworkInterceptor(interceptor)
+        .build();
 
     Request request = new Request.Builder()
         .url(server.url("/"))
@@ -240,17 +255,17 @@ public Response intercept(Chain chain) throws IOException {
   }
 
   @Test public void applicationInterceptorsRewriteRequestToServer() throws Exception {
-    rewriteRequestToServer(client.interceptors());
+    rewriteRequestToServer(false);
   }
 
   @Test public void networkInterceptorsRewriteRequestToServer() throws Exception {
-    rewriteRequestToServer(client.networkInterceptors());
+    rewriteRequestToServer(true);
   }
 
-  private void rewriteRequestToServer(List<Interceptor> interceptors) throws Exception {
+  private void rewriteRequestToServer(boolean network) throws Exception {
     server.enqueue(new MockResponse());
 
-    interceptors.add(new Interceptor() {
+    addInterceptor(network, new Interceptor() {
       @Override public Response intercept(Chain chain) throws IOException {
         Request originalRequest = chain.request();
         return chain.proceed(originalRequest.newBuilder()
@@ -276,19 +291,19 @@ private void rewriteRequestToServer(List<Interceptor> interceptors) throws Excep
   }
 
   @Test public void applicationInterceptorsRewriteResponseFromServer() throws Exception {
-    rewriteResponseFromServer(client.interceptors());
+    rewriteResponseFromServer(false);
   }
 
   @Test public void networkInterceptorsRewriteResponseFromServer() throws Exception {
-    rewriteResponseFromServer(client.networkInterceptors());
+    rewriteResponseFromServer(true);
   }
 
-  private void rewriteResponseFromServer(List<Interceptor> interceptors) throws Exception {
+  private void rewriteResponseFromServer(boolean network) throws Exception {
     server.enqueue(new MockResponse()
         .addHeader("Original-Header: foo")
         .setBody("abc"));
 
-    interceptors.add(new Interceptor() {
+    addInterceptor(network, new Interceptor() {
       @Override public Response intercept(Chain chain) throws IOException {
         Response originalResponse = chain.proceed(chain.request());
         return originalResponse.newBuilder()
@@ -309,17 +324,17 @@ private void rewriteResponseFromServer(List<Interceptor> interceptors) throws Ex
   }
 
   @Test public void multipleApplicationInterceptors() throws Exception {
-    multipleInterceptors(client.interceptors());
+    multipleInterceptors(false);
   }
 
   @Test public void multipleNetworkInterceptors() throws Exception {
-    multipleInterceptors(client.networkInterceptors());
+    multipleInterceptors(true);
   }
 
-  private void multipleInterceptors(List<Interceptor> interceptors) throws Exception {
+  private void multipleInterceptors(boolean network) throws Exception {
     server.enqueue(new MockResponse());
 
-    interceptors.add(new Interceptor() {
+    addInterceptor(network, new Interceptor() {
       @Override public Response intercept(Chain chain) throws IOException {
         Request originalRequest = chain.request();
         Response originalResponse = chain.proceed(originalRequest.newBuilder()
@@ -330,7 +345,7 @@ private void multipleInterceptors(List<Interceptor> interceptors) throws Excepti
             .build();
       }
     });
-    interceptors.add(new Interceptor() {
+    addInterceptor(network, new Interceptor() {
       @Override public Response intercept(Chain chain) throws IOException {
         Request originalRequest = chain.request();
         Response originalResponse = chain.proceed(originalRequest.newBuilder()
@@ -356,17 +371,17 @@ private void multipleInterceptors(List<Interceptor> interceptors) throws Excepti
   }
 
   @Test public void asyncApplicationInterceptors() throws Exception {
-    asyncInterceptors(client.interceptors());
+    asyncInterceptors(false);
   }
 
   @Test public void asyncNetworkInterceptors() throws Exception {
-    asyncInterceptors(client.networkInterceptors());
+    asyncInterceptors(true);
   }
 
-  private void asyncInterceptors(List<Interceptor> interceptors) throws Exception {
+  private void asyncInterceptors(boolean network) throws Exception {
     server.enqueue(new MockResponse());
 
-    interceptors.add(new Interceptor() {
+    addInterceptor(network, new Interceptor() {
       @Override public Response intercept(Chain chain) throws IOException {
         Response originalResponse = chain.proceed(chain.request());
         return originalResponse.newBuilder()
@@ -389,13 +404,14 @@ private void asyncInterceptors(List<Interceptor> interceptors) throws Exception
     server.enqueue(new MockResponse().setBody("a"));
     server.enqueue(new MockResponse().setBody("b"));
 
-    client.interceptors().add(new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        Response response1 = chain.proceed(chain.request());
-        response1.body().close();
-        return chain.proceed(chain.request());
-      }
-    });
+    client = client.newBuilder()
+        .addInterceptor(new Interceptor() {
+          @Override public Response intercept(Chain chain) throws IOException {
+            Response response1 = chain.proceed(chain.request());
+            response1.body().close();
+            return chain.proceed(chain.request());
+          }
+        }).build();
 
     Request request = new Request.Builder()
         .url(server.url("/"))
@@ -410,19 +426,20 @@ private void asyncInterceptors(List<Interceptor> interceptors) throws Exception
     server.enqueue(new MockResponse().setBody("a")); // Fetched by interceptor.
     server.enqueue(new MockResponse().setBody("b")); // Fetched directly.
 
-    client.interceptors().add(new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        if (chain.request().url().encodedPath().equals("/b")) {
-          Request requestA = new Request.Builder()
-              .url(server.url("/a"))
-              .build();
-          Response responseA = client.newCall(requestA).execute();
-          assertEquals("a", responseA.body().string());
-        }
-
-        return chain.proceed(chain.request());
-      }
-    });
+    client = client.newBuilder()
+        .addInterceptor(new Interceptor() {
+          @Override public Response intercept(Chain chain) throws IOException {
+            if (chain.request().url().encodedPath().equals("/b")) {
+              Request requestA = new Request.Builder()
+                  .url(server.url("/a"))
+                  .build();
+              Response responseA = client.newCall(requestA).execute();
+              assertEquals("a", responseA.body().string());
+            }
+
+            return chain.proceed(chain.request());
+          }
+        }).build();
 
     Request requestB = new Request.Builder()
         .url(server.url("/b"))
@@ -436,25 +453,26 @@ private void asyncInterceptors(List<Interceptor> interceptors) throws Exception
     server.enqueue(new MockResponse().setBody("a")); // Fetched by interceptor.
     server.enqueue(new MockResponse().setBody("b")); // Fetched directly.
 
-    client.interceptors().add(new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        if (chain.request().url().encodedPath().equals("/b")) {
-          Request requestA = new Request.Builder()
-              .url(server.url("/a"))
-              .build();
-
-          try {
-            RecordingCallback callbackA = new RecordingCallback();
-            client.newCall(requestA).enqueue(callbackA);
-            callbackA.await(requestA.url()).assertBody("a");
-          } catch (Exception e) {
-            throw new RuntimeException(e);
+    client = client.newBuilder()
+        .addInterceptor(new Interceptor() {
+          @Override public Response intercept(Chain chain) throws IOException {
+            if (chain.request().url().encodedPath().equals("/b")) {
+              Request requestA = new Request.Builder()
+                  .url(server.url("/a"))
+                  .build();
+
+              try {
+                RecordingCallback callbackA = new RecordingCallback();
+                client.newCall(requestA).enqueue(callbackA);
+                callbackA.await(requestA.url()).assertBody("a");
+              } catch (Exception e) {
+                throw new RuntimeException(e);
+              }
+            }
+
+            return chain.proceed(chain.request());
           }
-        }
-
-        return chain.proceed(chain.request());
-      }
-    });
+        }).build();
 
     Request requestB = new Request.Builder()
         .url(server.url("/b"))
@@ -464,21 +482,20 @@ private void asyncInterceptors(List<Interceptor> interceptors) throws Exception
     callbackB.await(requestB.url()).assertBody("b");
   }
 
-  @Test public void applicationkInterceptorThrowsRuntimeExceptionSynchronous() throws Exception {
-    interceptorThrowsRuntimeExceptionSynchronous(client.interceptors());
+  @Test public void applicationInterceptorThrowsRuntimeExceptionSynchronous() throws Exception {
+    interceptorThrowsRuntimeExceptionSynchronous(false);
   }
 
   @Test public void networkInterceptorThrowsRuntimeExceptionSynchronous() throws Exception {
-    interceptorThrowsRuntimeExceptionSynchronous(client.networkInterceptors());
+    interceptorThrowsRuntimeExceptionSynchronous(true);
   }
 
   /**
    * When an interceptor throws an unexpected exception, synchronous callers can catch it and deal
    * with it.
    */
-  private void interceptorThrowsRuntimeExceptionSynchronous(
-      List<Interceptor> interceptors) throws Exception {
-    interceptors.add(new Interceptor() {
+  private void interceptorThrowsRuntimeExceptionSynchronous(boolean network) throws Exception {
+    addInterceptor(network, new Interceptor() {
       @Override public Response intercept(Chain chain) throws IOException {
         throw new RuntimeException("boom!");
       }
@@ -502,12 +519,14 @@ private void interceptorThrowsRuntimeExceptionSynchronous(
     Interceptor modifyHeaderInterceptor = new Interceptor() {
       @Override public Response intercept(Chain chain) throws IOException {
         return chain.proceed(chain.request().newBuilder()
-          .header("User-Agent", "intercepted request")
-          .build());
+            .header("User-Agent", "intercepted request")
+            .build());
       }
     };
 
-    client.networkInterceptors().add(modifyHeaderInterceptor);
+    client = client.newBuilder()
+        .addNetworkInterceptor(modifyHeaderInterceptor)
+        .build();
 
     Request request = new Request.Builder()
         .url(server.url("/"))
@@ -521,27 +540,28 @@ private void interceptorThrowsRuntimeExceptionSynchronous(
   }
 
   @Test public void applicationInterceptorThrowsRuntimeExceptionAsynchronous() throws Exception {
-    interceptorThrowsRuntimeExceptionAsynchronous(client.interceptors());
+    interceptorThrowsRuntimeExceptionAsynchronous(false);
   }
 
   @Test public void networkInterceptorThrowsRuntimeExceptionAsynchronous() throws Exception {
-    interceptorThrowsRuntimeExceptionAsynchronous(client.networkInterceptors());
+    interceptorThrowsRuntimeExceptionAsynchronous(true);
   }
 
   /**
    * When an interceptor throws an unexpected exception, asynchronous callers are left hanging. The
    * exception goes to the uncaught exception handler.
    */
-  private void interceptorThrowsRuntimeExceptionAsynchronous(
-        List<Interceptor> interceptors) throws Exception {
-    interceptors.add(new Interceptor() {
+  private void interceptorThrowsRuntimeExceptionAsynchronous(boolean network) throws Exception {
+    addInterceptor(network, new Interceptor() {
       @Override public Response intercept(Chain chain) throws IOException {
         throw new RuntimeException("boom!");
       }
     });
 
     ExceptionCatchingExecutor executor = new ExceptionCatchingExecutor();
-    client.setDispatcher(new Dispatcher(executor));
+    client = client.newBuilder()
+        .dispatcher(new Dispatcher(executor))
+        .build();
 
     Request request = new Request.Builder()
         .url(server.url("/"))
@@ -560,10 +580,14 @@ private void interceptorThrowsRuntimeExceptionAsynchronous(
         return null;
       }
     };
-    client.interceptors().add(interceptor);
+    client = client.newBuilder()
+        .addInterceptor(interceptor)
+        .build();
 
     ExceptionCatchingExecutor executor = new ExceptionCatchingExecutor();
-    client.setDispatcher(new Dispatcher(executor));
+    client = client.newBuilder()
+        .dispatcher(new Dispatcher(executor))
+        .build();
 
     Request request = new Request.Builder()
         .url(server.url("/"))
@@ -586,10 +610,14 @@ private void interceptorThrowsRuntimeExceptionAsynchronous(
         return null;
       }
     };
-    client.networkInterceptors().add(interceptor);
+    client = client.newBuilder()
+        .addNetworkInterceptor(interceptor)
+        .build();
 
     ExceptionCatchingExecutor executor = new ExceptionCatchingExecutor();
-    client.setDispatcher(new Dispatcher(executor));
+    client = client.newBuilder()
+        .dispatcher(new Dispatcher(executor))
+        .build();
 
     Request request = new Request.Builder()
         .url(server.url("/"))
@@ -653,6 +681,16 @@ private Buffer gzip(String data) throws IOException {
     return result;
   }
 
+  private void addInterceptor(boolean network, Interceptor interceptor) {
+    OkHttpClient.Builder builder = client.newBuilder();
+    if (network) {
+      builder.addNetworkInterceptor(interceptor);
+    } else {
+      builder.addInterceptor(interceptor);
+    }
+    client = builder.build();
+  }
+
   /** Catches exceptions that are otherwise headed for the uncaught exception handler. */
   private static class ExceptionCatchingExecutor extends ThreadPoolExecutor {
     private final BlockingQueue<Exception> exceptions = new LinkedBlockingQueue<>();
diff --git a/okhttp-tests/src/test/java/okhttp3/MediaTypeTest.java b/okhttp-tests/src/test/java/okhttp3/MediaTypeTest.java
index 8f2dbe79eb..b4e9c2ec2a 100644
--- a/okhttp-tests/src/test/java/okhttp3/MediaTypeTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/MediaTypeTest.java
@@ -16,10 +16,10 @@
  */
 package okhttp3;
 
-import okhttp3.internal.Util;
 import java.nio.charset.Charset;
 import java.nio.charset.IllegalCharsetNameException;
 import java.nio.charset.UnsupportedCharsetException;
+import okhttp3.internal.Util;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
@@ -30,8 +30,8 @@
 /**
  * Test MediaType API and parsing.
  *
- * <p>This test includes tests from <a
- * href="https://code.google.com/p/guava-libraries/">Guava's</a> MediaTypeTest.
+ * <p>This test includes tests from <a href="https://code.google.com/p/guava-libraries/">Guava's</a>
+ * MediaTypeTest.
  */
 public class MediaTypeTest {
   @Test public void testParse() throws Exception {
diff --git a/okhttp-tests/src/test/java/okhttp3/OkHttpClientTest.java b/okhttp-tests/src/test/java/okhttp3/OkHttpClientTest.java
index 7a5477d04c..e369a4d4b1 100644
--- a/okhttp-tests/src/test/java/okhttp3/OkHttpClientTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/OkHttpClientTest.java
@@ -16,179 +16,106 @@
 package okhttp3;
 
 import java.io.IOException;
-import java.net.Authenticator;
-import java.net.CacheRequest;
-import java.net.CacheResponse;
 import java.net.CookieHandler;
 import java.net.CookieManager;
 import java.net.ProxySelector;
 import java.net.ResponseCache;
-import java.net.URI;
-import java.net.URLConnection;
 import java.util.Arrays;
-import java.util.List;
-import java.util.Map;
 import java.util.concurrent.TimeUnit;
-import javax.net.SocketFactory;
-import okhttp3.internal.RecordingAuthenticator;
-import okhttp3.internal.http.AuthenticatorAdapter;
-import okhttp3.internal.http.RecordingProxySelector;
-import okhttp3.internal.tls.OkHostnameVerifier;
 import org.junit.After;
 import org.junit.Test;
 
+import static okhttp3.TestUtil.defaultClient;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 public final class OkHttpClientTest {
   private static final ProxySelector DEFAULT_PROXY_SELECTOR = ProxySelector.getDefault();
   private static final CookieHandler DEFAULT_COOKIE_HANDLER = CookieManager.getDefault();
   private static final ResponseCache DEFAULT_RESPONSE_CACHE = ResponseCache.getDefault();
-  private static final Authenticator DEFAULT_AUTHENTICATOR = null; // No Authenticator.getDefault().
 
   @After public void tearDown() throws Exception {
     ProxySelector.setDefault(DEFAULT_PROXY_SELECTOR);
     CookieManager.setDefault(DEFAULT_COOKIE_HANDLER);
     ResponseCache.setDefault(DEFAULT_RESPONSE_CACHE);
-    Authenticator.setDefault(DEFAULT_AUTHENTICATOR);
   }
 
   @Test public void timeoutDefaults() {
-    OkHttpClient client = new OkHttpClient();
-    assertEquals(10_000, client.getConnectTimeout());
-    assertEquals(10_000, client.getReadTimeout());
-    assertEquals(10_000, client.getWriteTimeout());
+    OkHttpClient client = defaultClient();
+    assertEquals(10_000, client.connectTimeoutMillis());
+    assertEquals(10_000, client.readTimeoutMillis());
+    assertEquals(10_000, client.writeTimeoutMillis());
   }
 
   @Test public void timeoutValidRange() {
-    OkHttpClient client = new OkHttpClient();
+    OkHttpClient.Builder builder = new OkHttpClient.Builder();
     try {
-      client.setConnectTimeout(1, TimeUnit.NANOSECONDS);
+      builder.connectTimeout(1, TimeUnit.NANOSECONDS);
     } catch (IllegalArgumentException ignored) {
     }
     try {
-      client.setWriteTimeout(1, TimeUnit.NANOSECONDS);
+      builder.writeTimeout(1, TimeUnit.NANOSECONDS);
     } catch (IllegalArgumentException ignored) {
     }
     try {
-      client.setReadTimeout(1, TimeUnit.NANOSECONDS);
+      builder.readTimeout(1, TimeUnit.NANOSECONDS);
     } catch (IllegalArgumentException ignored) {
     }
     try {
-      client.setConnectTimeout(365, TimeUnit.DAYS);
+      builder.connectTimeout(365, TimeUnit.DAYS);
     } catch (IllegalArgumentException ignored) {
     }
     try {
-      client.setWriteTimeout(365, TimeUnit.DAYS);
+      builder.writeTimeout(365, TimeUnit.DAYS);
     } catch (IllegalArgumentException ignored) {
     }
     try {
-      client.setReadTimeout(365, TimeUnit.DAYS);
+      builder.readTimeout(365, TimeUnit.DAYS);
     } catch (IllegalArgumentException ignored) {
     }
   }
 
-  /** Confirm that {@code copyWithDefaults} gets expected constant values. */
-  @Test public void copyWithDefaultsWhenDefaultIsAConstant() throws Exception {
-    OkHttpClient client = new OkHttpClient().copyWithDefaults();
-    assertNull(client.internalCache());
-    assertEquals(10_000, client.getConnectTimeout());
-    assertEquals(10_000, client.getReadTimeout());
-    assertEquals(10_000, client.getWriteTimeout());
-    assertTrue(client.getFollowSslRedirects());
-    assertNull(client.getProxy());
-    assertEquals(Arrays.asList(Protocol.HTTP_2, Protocol.SPDY_3, Protocol.HTTP_1_1),
-        client.getProtocols());
-  }
-
-  /**
-   * Confirm that {@code copyWithDefaults} gets some default implementations
-   * from the core library.
-   */
-  @Test public void copyWithDefaultsWhenDefaultIsGlobal() throws Exception {
-    ProxySelector proxySelector = new RecordingProxySelector();
-    CookieManager cookieManager = new CookieManager();
-    Authenticator authenticator = new RecordingAuthenticator();
-    SocketFactory socketFactory = SocketFactory.getDefault(); // Global isn't configurable.
-    OkHostnameVerifier hostnameVerifier = OkHostnameVerifier.INSTANCE; // Global isn't configurable.
-    CertificatePinner certificatePinner = CertificatePinner.DEFAULT; // Global isn't configurable.
-
-    CookieManager.setDefault(cookieManager);
-    ProxySelector.setDefault(proxySelector);
-    Authenticator.setDefault(authenticator);
-
-    OkHttpClient client = new OkHttpClient().copyWithDefaults();
-
-    assertSame(proxySelector, client.getProxySelector());
-    assertSame(cookieManager, client.getCookieHandler());
-    assertSame(AuthenticatorAdapter.INSTANCE, client.getAuthenticator());
-    assertSame(AuthenticatorAdapter.INSTANCE, client.getProxyAuthenticator());
-    assertSame(socketFactory, client.getSocketFactory());
-    assertSame(hostnameVerifier, client.getHostnameVerifier());
-    assertSame(certificatePinner, client.getCertificatePinner());
-  }
-
-  /** There is no default cache. */
-  @Test public void copyWithDefaultsCacheIsNull() throws Exception {
-    OkHttpClient client = new OkHttpClient().copyWithDefaults();
-    assertNull(client.getCache());
-  }
-
-  @Test public void copyWithDefaultsDoesNotHonorGlobalResponseCache() {
-    ResponseCache.setDefault(new ResponseCache() {
-      @Override public CacheResponse get(URI uri, String requestMethod,
-          Map<String, List<String>> requestHeaders) throws IOException {
-        throw new AssertionError();
-      }
-
-      @Override public CacheRequest put(URI uri, URLConnection connection) {
-        throw new AssertionError();
-      }
-    });
-
-    OkHttpClient client = new OkHttpClient().copyWithDefaults();
-    assertNull(client.internalCache());
-  }
-
   @Test public void clonedInterceptorsListsAreIndependent() throws Exception {
-    OkHttpClient original = new OkHttpClient();
-    OkHttpClient clone = original.clone();
-    clone.interceptors().add(null);
-    clone.networkInterceptors().add(null);
+    Interceptor interceptor = new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        return chain.proceed(chain.request());
+      }
+    };
+    OkHttpClient original = defaultClient();
+    original.newBuilder()
+        .addInterceptor(interceptor)
+        .addNetworkInterceptor(interceptor)
+        .build();
     assertEquals(0, original.interceptors().size());
     assertEquals(0, original.networkInterceptors().size());
   }
 
   /**
-   * When copying the client, stateful things like the connection pool are
-   * shared across all clients.
+   * When copying the client, stateful things like the connection pool are shared across all
+   * clients.
    */
   @Test public void cloneSharesStatefulInstances() throws Exception {
-    OkHttpClient client = new OkHttpClient();
+    OkHttpClient client = defaultClient();
 
     // Values should be non-null.
-    OkHttpClient a = client.clone().copyWithDefaults();
-    assertNotNull(a.routeDatabase());
-    assertNotNull(a.getDispatcher());
-    assertNotNull(a.getConnectionPool());
-    assertNotNull(a.getSslSocketFactory());
+    OkHttpClient a = client.newBuilder().build();
+    assertNotNull(a.dispatcher());
+    assertNotNull(a.connectionPool());
+    assertNotNull(a.sslSocketFactory());
 
     // Multiple clients share the instances.
-    OkHttpClient b = client.clone().copyWithDefaults();
-    assertSame(a.routeDatabase(), b.routeDatabase());
-    assertSame(a.getDispatcher(), b.getDispatcher());
-    assertSame(a.getConnectionPool(), b.getConnectionPool());
-    assertSame(a.getSslSocketFactory(), b.getSslSocketFactory());
+    OkHttpClient b = client.newBuilder().build();
+    assertSame(a.dispatcher(), b.dispatcher());
+    assertSame(a.connectionPool(), b.connectionPool());
+    assertSame(a.sslSocketFactory(), b.sslSocketFactory());
   }
 
   @Test public void setProtocolsRejectsHttp10() throws Exception {
-    OkHttpClient client = new OkHttpClient();
+    OkHttpClient.Builder builder = new OkHttpClient.Builder();
     try {
-      client.setProtocols(Arrays.asList(Protocol.HTTP_1_0, Protocol.HTTP_1_1));
+      builder.protocols(Arrays.asList(Protocol.HTTP_1_0, Protocol.HTTP_1_1));
       fail();
     } catch (IllegalArgumentException expected) {
     }
diff --git a/okhttp-tests/src/test/java/okhttp3/RecordedResponse.java b/okhttp-tests/src/test/java/okhttp3/RecordedResponse.java
index dca73617ef..6e1f0728bf 100644
--- a/okhttp-tests/src/test/java/okhttp3/RecordedResponse.java
+++ b/okhttp-tests/src/test/java/okhttp3/RecordedResponse.java
@@ -15,9 +15,9 @@
  */
 package okhttp3;
 
-import okhttp3.ws.WebSocket;
 import java.io.IOException;
 import java.util.Arrays;
+import okhttp3.ws.WebSocket;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
@@ -86,6 +86,7 @@ public RecordedResponse assertBody(String expectedBody) {
 
   public RecordedResponse assertHandshake() {
     Handshake handshake = response.handshake();
+    assertNotNull(handshake.tlsVersion());
     assertNotNull(handshake.cipherSuite());
     assertNotNull(handshake.peerPrincipal());
     assertEquals(1, handshake.peerCertificates().size());
@@ -95,8 +96,7 @@ public RecordedResponse assertHandshake() {
   }
 
   /**
-   * Asserts that the current response was redirected and returns the prior
-   * response.
+   * Asserts that the current response was redirected and returns the prior response.
    */
   public RecordedResponse priorResponse() {
     Response priorResponse = response.priorResponse();
@@ -106,8 +106,7 @@ public RecordedResponse priorResponse() {
   }
 
   /**
-   * Asserts that the current response used the network and returns the network
-   * response.
+   * Asserts that the current response used the network and returns the network response.
    */
   public RecordedResponse networkResponse() {
     Response networkResponse = response.networkResponse();
@@ -129,8 +128,7 @@ public RecordedResponse assertNoCacheResponse() {
   }
 
   /**
-   * Asserts that the current response used the cache and returns the cache
-   * response.
+   * Asserts that the current response used the cache and returns the cache response.
    */
   public RecordedResponse cacheResponse() {
     Response cacheResponse = response.cacheResponse();
@@ -139,8 +137,14 @@ public RecordedResponse cacheResponse() {
     return new RecordedResponse(cacheResponse.request(), cacheResponse, null, null, null);
   }
 
-  public void assertFailure(String... messages) {
+  public RecordedResponse assertFailure(Class<?> exceptionClass) {
+    assertTrue(exceptionClass.isInstance(failure));
+    return this;
+  }
+
+  public RecordedResponse assertFailure(String... messages) {
     assertNotNull(failure);
     assertTrue(failure.getMessage(), Arrays.asList(messages).contains(failure.getMessage()));
+    return this;
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/RecordingCallback.java b/okhttp-tests/src/test/java/okhttp3/RecordingCallback.java
index 68d4adbab3..56a1d7e003 100644
--- a/okhttp-tests/src/test/java/okhttp3/RecordingCallback.java
+++ b/okhttp-tests/src/test/java/okhttp3/RecordingCallback.java
@@ -29,20 +29,20 @@
 
   private final List<RecordedResponse> responses = new ArrayList<>();
 
-  @Override public synchronized void onFailure(Request request, IOException e) {
-    responses.add(new RecordedResponse(request, null, null, null, e));
+  @Override public synchronized void onFailure(Call call, IOException e) {
+    responses.add(new RecordedResponse(call.request(), null, null, null, e));
     notifyAll();
   }
 
-  @Override public synchronized void onResponse(Response response) throws IOException {
+  @Override public synchronized void onResponse(Call call, Response response) throws IOException {
     String body = response.body().string();
-    responses.add(new RecordedResponse(response.request(), response, null, body, null));
+    responses.add(new RecordedResponse(call.request(), response, null, body, null));
     notifyAll();
   }
 
   /**
-   * Returns the recorded response triggered by {@code request}. Throws if the
-   * response isn't enqueued before the timeout.
+   * Returns the recorded response triggered by {@code request}. Throws if the response isn't
+   * enqueued before the timeout.
    */
   public synchronized RecordedResponse await(HttpUrl url) throws Exception {
     long timeoutMillis = TimeUnit.NANOSECONDS.toMillis(System.nanoTime()) + TIMEOUT_MILLIS;
@@ -62,12 +62,4 @@ public synchronized RecordedResponse await(HttpUrl url) throws Exception {
 
     throw new AssertionError("Timed out waiting for response to " + url);
   }
-
-  public synchronized void assertNoResponse(HttpUrl url) throws Exception {
-    for (RecordedResponse recordedResponse : responses) {
-      if (recordedResponse.request.url().equals(url)) {
-        throw new AssertionError("Expected no response for " + url);
-      }
-    }
-  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/RequestTest.java b/okhttp-tests/src/test/java/okhttp3/RequestTest.java
index 929d04b356..0ef87d6c86 100644
--- a/okhttp-tests/src/test/java/okhttp3/RequestTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/RequestTest.java
@@ -15,13 +15,13 @@
  */
 package okhttp3;
 
-import okhttp3.internal.Util;
 import java.io.File;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.net.URI;
 import java.util.Arrays;
 import java.util.Collections;
+import okhttp3.internal.Util;
 import okio.Buffer;
 import org.junit.Test;
 
@@ -125,7 +125,8 @@
 
   @Test public void newBuilderUrlResetsUrl() throws Exception {
     Request requestWithoutCache = new Request.Builder().url("http://localhost/api").build();
-    Request builtRequestWithoutCache = requestWithoutCache.newBuilder().url("http://localhost/api/foo").build();
+    Request builtRequestWithoutCache =
+        requestWithoutCache.newBuilder().url("http://localhost/api/foo").build();
     assertEquals(HttpUrl.parse("http://localhost/api/foo"), builtRequestWithoutCache.url());
 
     Request requestWithCache = new Request.Builder().url("http://localhost/api").build();
diff --git a/okhttp-tests/src/test/java/okhttp3/ResponseTest.java b/okhttp-tests/src/test/java/okhttp3/ResponseTest.java
new file mode 100644
index 0000000000..8977fdf441
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/ResponseTest.java
@@ -0,0 +1,101 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import okio.Buffer;
+import okio.BufferedSource;
+import okio.Okio;
+import okio.Source;
+import okio.Timeout;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+public final class ResponseTest {
+  @Test public void peekShorterThanResponse() throws Exception {
+    Response response = newResponse(responseBody("abcdef"));
+    ResponseBody peekedBody = response.peekBody(3);
+    assertEquals("abc", peekedBody.string());
+    assertEquals("abcdef", response.body().string());
+  }
+
+  @Test public void peekLongerThanResponse() throws Exception {
+    Response response = newResponse(responseBody("abc"));
+    ResponseBody peekedBody = response.peekBody(6);
+    assertEquals("abc", peekedBody.string());
+    assertEquals("abc", response.body().string());
+  }
+
+  @Test public void peekAfterReadingResponse() throws Exception {
+    Response response = newResponse(responseBody("abc"));
+    assertEquals("abc", response.body().string());
+
+    try {
+      response.peekBody(3);
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+  }
+
+  @Test public void eachPeakIsIndependent() throws Exception {
+    Response response = newResponse(responseBody("abcdef"));
+    ResponseBody p1 = response.peekBody(4);
+    ResponseBody p2 = response.peekBody(2);
+    assertEquals("abcdef", response.body().string());
+    assertEquals("abcd", p1.string());
+    assertEquals("ab", p2.string());
+  }
+
+  /**
+   * Returns a new response body that refuses to be read once it has been closed. This is true of
+   * most {@link BufferedSource} instances, but not of {@link Buffer}.
+   */
+  private ResponseBody responseBody(String content) {
+    final Buffer data = new Buffer().writeUtf8(content);
+
+    Source source = new Source() {
+      boolean closed;
+
+      @Override public void close() throws IOException {
+        closed = true;
+      }
+
+      @Override public long read(Buffer sink, long byteCount) throws IOException {
+        if (closed) throw new IllegalStateException();
+        return data.read(sink, byteCount);
+      }
+
+      @Override public Timeout timeout() {
+        return Timeout.NONE;
+      }
+    };
+
+    return ResponseBody.create(null, -1, Okio.buffer(source));
+  }
+
+  private Response newResponse(ResponseBody responseBody) {
+    return new Response.Builder()
+        .request(new Request.Builder()
+            .url("https://example.com/")
+            .build())
+        .protocol(Protocol.HTTP_1_1)
+        .code(200)
+        .body(responseBody)
+        .build();
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/SocksProxy.java b/okhttp-tests/src/test/java/okhttp3/SocksProxy.java
index 4cc4cae673..ce949ebaef 100644
--- a/okhttp-tests/src/test/java/okhttp3/SocksProxy.java
+++ b/okhttp-tests/src/test/java/okhttp3/SocksProxy.java
@@ -15,8 +15,6 @@
  */
 package okhttp3;
 
-import okhttp3.internal.NamedRunnable;
-import okhttp3.internal.Util;
 import java.io.IOException;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
@@ -31,6 +29,8 @@
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.logging.Level;
 import java.util.logging.Logger;
+import okhttp3.internal.NamedRunnable;
+import okhttp3.internal.Util;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
diff --git a/okhttp-tests/src/test/java/okhttp3/SocksProxyTest.java b/okhttp-tests/src/test/java/okhttp3/SocksProxyTest.java
index 83a7ba1af4..f74cb6f075 100644
--- a/okhttp-tests/src/test/java/okhttp3/SocksProxyTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/SocksProxyTest.java
@@ -15,8 +15,6 @@
  */
 package okhttp3;
 
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
 import java.io.IOException;
 import java.net.Proxy;
 import java.net.ProxySelector;
@@ -24,6 +22,8 @@
 import java.net.URI;
 import java.util.Collections;
 import java.util.List;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -48,8 +48,9 @@
     server.enqueue(new MockResponse().setBody("abc"));
     server.enqueue(new MockResponse().setBody("def"));
 
-    OkHttpClient client = new OkHttpClient()
-        .setProxy(socksProxy.proxy());
+    OkHttpClient client = new OkHttpClient.Builder()
+        .proxy(socksProxy.proxy())
+        .build();
 
     Request request1 = new Request.Builder().url(server.url("/")).build();
     Response response1 = client.newCall(request1).execute();
@@ -76,8 +77,9 @@
       }
     };
 
-    OkHttpClient client = new OkHttpClient()
-        .setProxySelector(proxySelector);
+    OkHttpClient client = new OkHttpClient.Builder()
+        .proxySelector(proxySelector)
+        .build();
 
     Request request = new Request.Builder().url(server.url("/")).build();
     Response response = client.newCall(request).execute();
@@ -90,8 +92,9 @@
     // This testcase will fail if the target is resolved locally instead of through the proxy.
     server.enqueue(new MockResponse().setBody("abc"));
 
-    OkHttpClient client = new OkHttpClient()
-        .setProxy(socksProxy.proxy());
+    OkHttpClient client = new OkHttpClient.Builder()
+        .proxy(socksProxy.proxy())
+        .build();
 
     HttpUrl url = server.url("/")
         .newBuilder()
diff --git a/okhttp-tests/src/test/java/okhttp3/TestUtil.java b/okhttp-tests/src/test/java/okhttp3/TestUtil.java
index dffa667115..a4581960eb 100644
--- a/okhttp-tests/src/test/java/okhttp3/TestUtil.java
+++ b/okhttp-tests/src/test/java/okhttp3/TestUtil.java
@@ -1,17 +1,36 @@
 package okhttp3;
 
-import okhttp3.internal.framed.Header;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Set;
+import okhttp3.internal.SingleInetAddressDns;
+import okhttp3.internal.framed.Header;
 
 public final class TestUtil {
   private TestUtil() {
   }
 
+  private static final ConnectionPool connectionPool = new ConnectionPool();
+
+  /**
+   * Returns an OkHttpClient for all tests to use as a starting point.
+   *
+   * <p>The shared instance allows all tests to share a single connection pool, which prevents idle
+   * connections from consuming unnecessary resources while connections wait to be evicted.
+   *
+   * <p>This client is also configured to be slightly more deterministic, returning a single IP
+   * address for all hosts, regardless of the actual number of IP addresses reported by DNS.
+   */
+  public static OkHttpClient defaultClient() {
+    return new OkHttpClient.Builder()
+        .connectionPool(connectionPool)
+        .dns(new SingleInetAddressDns()) // Prevent unexpected fallback addresses.
+        .build();
+  }
+
   public static List<Header> headerEntries(String... elements) {
     List<Header> result = new ArrayList<>(elements.length / 2);
     for (int i = 0; i < elements.length; i += 2) {
diff --git a/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java b/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
index 494f09fd92..b864383364 100644
--- a/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
@@ -13,21 +13,8 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
 package okhttp3;
 
-import okhttp3.internal.Internal;
-import okhttp3.internal.RecordingAuthenticator;
-import okhttp3.internal.RecordingOkAuthenticator;
-import okhttp3.internal.SingleInetAddressDns;
-import okhttp3.internal.SslContextBuilder;
-import okhttp3.internal.Util;
-import okhttp3.internal.Version;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.mockwebserver.RecordedRequest;
-import okhttp3.mockwebserver.SocketPolicy;
-import okhttp3.testing.RecordingHostnameVerifier;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
@@ -69,6 +56,18 @@
 import javax.net.ssl.SSLSocketFactory;
 import javax.net.ssl.TrustManager;
 import javax.net.ssl.X509TrustManager;
+import okhttp3.internal.DoubleInetAddressDns;
+import okhttp3.internal.Internal;
+import okhttp3.internal.RecordingAuthenticator;
+import okhttp3.internal.RecordingOkAuthenticator;
+import okhttp3.internal.SingleInetAddressDns;
+import okhttp3.internal.SslContextBuilder;
+import okhttp3.internal.Util;
+import okhttp3.internal.Version;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
+import okhttp3.mockwebserver.SocketPolicy;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.GzipSink;
@@ -82,6 +81,7 @@
 
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
+import static okhttp3.TestUtil.defaultClient;
 import static okhttp3.internal.Util.UTF_8;
 import static okhttp3.internal.http.OkHeaders.SELECTED_PROTOCOL;
 import static okhttp3.internal.http.StatusLine.HTTP_PERM_REDIRECT;
@@ -107,13 +107,13 @@
   @Rule public final TemporaryFolder tempDir = new TemporaryFolder();
 
   private SSLContext sslContext = SslContextBuilder.localhost();
-  private OkUrlFactory client;
+  private OkUrlFactory urlFactory;
   private HttpURLConnection connection;
   private Cache cache;
 
   @Before public void setUp() throws Exception {
     server.setProtocolNegotiationEnabled(false);
-    client = new OkUrlFactory(new OkHttpClient());
+    urlFactory = new OkUrlFactory(defaultClient());
   }
 
   @After public void tearDown() throws Exception {
@@ -133,7 +133,7 @@
   @Test public void requestHeaders() throws IOException, InterruptedException {
     server.enqueue(new MockResponse());
 
-    connection = client.open(server.url("/").url());
+    connection = urlFactory.open(server.url("/").url());
     connection.addRequestProperty("D", "e");
     connection.addRequestProperty("D", "f");
     assertEquals("f", connection.getRequestProperty("D"));
@@ -192,7 +192,7 @@
   }
 
   @Test public void getRequestPropertyReturnsLastValue() throws Exception {
-    connection = client.open(server.url("/").url());
+    connection = urlFactory.open(server.url("/").url());
     connection.addRequestProperty("A", "value1");
     connection.addRequestProperty("A", "value2");
     assertEquals("value2", connection.getRequestProperty("A"));
@@ -205,7 +205,7 @@
         .addHeader("A: e")
         .setChunkedBody("ABCDE\nFGHIJ\nKLMNO\nPQR", 8));
 
-    connection = client.open(server.url("/").url());
+    connection = urlFactory.open(server.url("/").url());
     assertEquals(200, connection.getResponseCode());
     assertEquals("Fantastic", connection.getResponseMessage());
     assertEquals("HTTP/1.0 200 Fantastic", connection.getHeaderField(null));
@@ -235,7 +235,7 @@
   @Test public void serverSendsInvalidResponseHeaders() throws Exception {
     server.enqueue(new MockResponse().setStatus("HTP/1.1 200 OK"));
 
-    connection = client.open(server.url("/").url());
+    connection = urlFactory.open(server.url("/").url());
     try {
       connection.getResponseCode();
       fail();
@@ -246,7 +246,7 @@
   @Test public void serverSendsInvalidCodeTooLarge() throws Exception {
     server.enqueue(new MockResponse().setStatus("HTTP/1.1 2147483648 OK"));
 
-    connection = client.open(server.url("/").url());
+    connection = urlFactory.open(server.url("/").url());
     try {
       connection.getResponseCode();
       fail();
@@ -257,7 +257,7 @@
   @Test public void serverSendsInvalidCodeNotANumber() throws Exception {
     server.enqueue(new MockResponse().setStatus("HTTP/1.1 00a OK"));
 
-    connection = client.open(server.url("/").url());
+    connection = urlFactory.open(server.url("/").url());
     try {
       connection.getResponseCode();
       fail();
@@ -268,7 +268,7 @@
   @Test public void serverSendsUnnecessaryWhitespace() throws Exception {
     server.enqueue(new MockResponse().setStatus(" HTTP/1.1 2147483648 OK"));
 
-    connection = client.open(server.url("/").url());
+    connection = urlFactory.open(server.url("/").url());
     try {
       connection.getResponseCode();
       fail();
@@ -280,7 +280,7 @@
     URL url = server.url("/foo").url();
     server.shutdown();
 
-    connection = client.open(url);
+    connection = urlFactory.open(url);
     try {
       connection.connect();
       fail();
@@ -304,12 +304,13 @@ private void testRequestBodySurvivesRetries(TransferKind transferKind) throws Ex
     server.enqueue(new MockResponse().setBody("abc"));
 
     // Use a misconfigured proxy to guarantee that the request is retried.
-    FakeProxySelector proxySelector = new FakeProxySelector();
-    proxySelector.proxies.add(server2.toProxyAddress());
-    client.client().setProxySelector(proxySelector);
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .proxySelector(new FakeProxySelector()
+            .addProxy(server2.toProxyAddress()))
+        .build());
     server2.shutdown();
 
-    connection = client.open(server.url("/def").url());
+    connection = urlFactory.open(server.url("/def").url());
     connection.setDoOutput(true);
     transferKind.setForRequest(connection, 4);
     connection.getOutputStream().write("body".getBytes("UTF-8"));
@@ -320,14 +321,14 @@ private void testRequestBodySurvivesRetries(TransferKind transferKind) throws Ex
 
   @Test public void getErrorStreamOnSuccessfulRequest() throws Exception {
     server.enqueue(new MockResponse().setBody("A"));
-    connection = client.open(server.url("/").url());
+    connection = urlFactory.open(server.url("/").url());
     assertNull(connection.getErrorStream());
     connection.getInputStream().close();
   }
 
   @Test public void getErrorStreamOnUnsuccessfulRequest() throws Exception {
     server.enqueue(new MockResponse().setResponseCode(404).setBody("A"));
-    connection = client.open(server.url("/").url());
+    connection = urlFactory.open(server.url("/").url());
     assertEquals("A", readAscii(connection.getErrorStream(), Integer.MAX_VALUE));
   }
 
@@ -340,9 +341,9 @@ private void testRequestBodySurvivesRetries(TransferKind transferKind) throws Ex
     server.enqueue(response);
     server.enqueue(response);
 
-    HttpURLConnection c1 = client.open(server.url("/").url());
+    HttpURLConnection c1 = urlFactory.open(server.url("/").url());
     assertContent("ABCDE", c1, 5);
-    HttpURLConnection c2 = client.open(server.url("/").url());
+    HttpURLConnection c2 = urlFactory.open(server.url("/").url());
     assertContent("ABCDE", c2, 5);
 
     c1.getInputStream().close();
@@ -363,11 +364,11 @@ private void testRequestBodySurvivesRetries(TransferKind transferKind) throws Ex
     server.enqueue(response);
     server.enqueue(response);
 
-    assertContent("ABCDEFGHIJKLMNOPQR", client.open(server.url("/foo").url()));
+    assertContent("ABCDEFGHIJKLMNOPQR", urlFactory.open(server.url("/foo").url()));
     assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertContent("ABCDEFGHIJKLMNOPQR", client.open(server.url("/bar?baz=quux").url()));
+    assertContent("ABCDEFGHIJKLMNOPQR", urlFactory.open(server.url("/bar?baz=quux").url()));
     assertEquals(1, server.takeRequest().getSequenceNumber());
-    assertContent("ABCDEFGHIJKLMNOPQR", client.open(server.url("/z").url()));
+    assertContent("ABCDEFGHIJKLMNOPQR", urlFactory.open(server.url("/z").url()));
     assertEquals(2, server.takeRequest().getSequenceNumber());
   }
 
@@ -378,11 +379,11 @@ private void testRequestBodySurvivesRetries(TransferKind transferKind) throws Ex
     server.enqueue(response);
     server.enqueue(response);
 
-    assertContent("ABCDEFGHIJKLMNOPQR", client.open(server.url("/foo").url()));
+    assertContent("ABCDEFGHIJKLMNOPQR", urlFactory.open(server.url("/foo").url()));
     assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertContent("ABCDEFGHIJKLMNOPQR", client.open(server.url("/bar?baz=quux").url()));
+    assertContent("ABCDEFGHIJKLMNOPQR", urlFactory.open(server.url("/bar?baz=quux").url()));
     assertEquals(1, server.takeRequest().getSequenceNumber());
-    assertContent("ABCDEFGHIJKLMNOPQR", client.open(server.url("/z").url()));
+    assertContent("ABCDEFGHIJKLMNOPQR", urlFactory.open(server.url("/z").url()));
     assertEquals(2, server.takeRequest().getSequenceNumber());
   }
 
@@ -401,7 +402,7 @@ private void testRequestBodySurvivesRetries(TransferKind transferKind) throws Ex
   @Test public void invalidHost() throws Exception {
     // Note that 1234.1.1.1 is an invalid host in a URI, but URL isn't as strict.
     URL url = new URL("http://1234.1.1.1/index.html");
-    HttpURLConnection connection = client.open(url);
+    HttpURLConnection connection = urlFactory.open(url);
     try {
       connection.connect();
       fail();
@@ -416,7 +417,7 @@ private void testServerClosesOutput(SocketPolicy socketPolicy) throws Exception
     server.enqueue(responseAfter);
     server.enqueue(responseAfter); // Enqueue 2x because the broken connection may be reused.
 
-    HttpURLConnection connection1 = client.open(server.url("/a").url());
+    HttpURLConnection connection1 = urlFactory.open(server.url("/a").url());
     connection1.setReadTimeout(100);
     assertContent("This connection won't pool properly", connection1);
     assertEquals(0, server.takeRequest().getSequenceNumber());
@@ -425,7 +426,7 @@ private void testServerClosesOutput(SocketPolicy socketPolicy) throws Exception
     // client has received the response.
     Thread.sleep(500);
 
-    HttpURLConnection connection2 = client.open(server.url("/b").url());
+    HttpURLConnection connection2 = urlFactory.open(server.url("/b").url());
     connection2.setReadTimeout(100);
     assertContent("This comes after a busted connection", connection2);
 
@@ -469,7 +470,7 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
     server.setBodyLimit(0);
     server.enqueue(new MockResponse());
 
-    HttpURLConnection conn = client.open(server.url("/").url());
+    HttpURLConnection conn = urlFactory.open(server.url("/").url());
     conn.setDoOutput(true);
     conn.setRequestMethod("POST");
     if (uploadKind == TransferKind.CHUNKED) {
@@ -504,7 +505,7 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
     server.enqueue(new MockResponse().addHeader("abc: def"));
 
     URL url = server.url("/").url();
-    HttpURLConnection conn = client.open(url);
+    HttpURLConnection conn = urlFactory.open(url);
     conn.setDoInput(false);
     assertEquals("def", conn.getHeaderField("abc"));
     assertEquals(200, conn.getResponseCode());
@@ -519,9 +520,11 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
     server.useHttps(sslContext.getSocketFactory(), false);
     server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
 
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
-    connection = client.open(server.url("/foo").url());
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build());
+    connection = urlFactory.open(server.url("/foo").url());
 
     assertContent("this response comes via HTTPS", connection);
 
@@ -533,10 +536,13 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
     server.useHttps(sslContext.getSocketFactory(), false);
     server.enqueue(new MockResponse());
 
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build());
 
-    HttpsURLConnection httpsConnection = (HttpsURLConnection) client.open(server.url("/foo").url());
+    HttpsURLConnection httpsConnection
+        = (HttpsURLConnection) urlFactory.open(server.url("/foo").url());
 
     // Prior to calling connect(), getting the cipher suite is forbidden.
     try {
@@ -567,32 +573,40 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
     SSLSocketFactory clientSocketFactory = sslContext.getSocketFactory();
     RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
 
-    client.client().setSslSocketFactory(clientSocketFactory);
-    client.client().setHostnameVerifier(hostnameVerifier);
-    connection = client.open(server.url("/").url());
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .sslSocketFactory(clientSocketFactory)
+        .hostnameVerifier(hostnameVerifier)
+        .build());
+    connection = urlFactory.open(server.url("/").url());
     assertContent("this response comes via HTTPS", connection);
 
-    connection = client.open(server.url("/").url());
+    connection = urlFactory.open(server.url("/").url());
     assertContent("another response via HTTPS", connection);
 
     assertEquals(0, server.takeRequest().getSequenceNumber());
     assertEquals(1, server.takeRequest().getSequenceNumber());
   }
 
-  @Test public void connectViaHttpsReusingConnectionsDifferentFactories()
-      throws IOException, InterruptedException {
+  @Test public void connectViaHttpsReusingConnectionsDifferentFactories() throws Exception {
     server.useHttps(sslContext.getSocketFactory(), false);
     server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
     server.enqueue(new MockResponse().setBody("another response via HTTPS"));
 
     // install a custom SSL socket factory so the server can be authorized
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
-    HttpURLConnection connection1 = client.open(server.url("/").url());
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build());
+    HttpURLConnection connection1 = urlFactory.open(server.url("/").url());
     assertContent("this response comes via HTTPS", connection1);
 
-    client.client().setSslSocketFactory(null);
-    HttpURLConnection connection2 = client.open(server.url("/").url());
+    SSLContext sslContext2 = SSLContext.getInstance("TLS");
+    sslContext2.init(null, null, null);
+    SSLSocketFactory sslSocketFactory2 = sslContext2.getSocketFactory();
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .sslSocketFactory(sslSocketFactory2)
+        .build());
+    HttpURLConnection connection2 = urlFactory.open(server.url("/").url());
     try {
       readAscii(connection2.getInputStream(), Integer.MAX_VALUE);
       fail("without an SSL socket factory, the connection should fail");
@@ -600,14 +614,18 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
     }
   }
 
+  // TODO(jwilson): tests below this marker need to be migrated to OkHttp's request/response API.
+
   @Test public void connectViaHttpsWithSSLFallback() throws Exception {
     server.useHttps(sslContext.getSocketFactory(), false);
     server.enqueue(new MockResponse().setSocketPolicy(FAIL_HANDSHAKE));
     server.enqueue(new MockResponse().setBody("this response comes via SSL"));
 
-    suppressTlsFallbackScsv(client.client());
-    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
-    connection = client.open(server.url("/foo").url());
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .sslSocketFactory(suppressTlsFallbackClientSocketFactory())
+        .build());
+    connection = urlFactory.open(server.url("/foo").url());
 
     assertContent("this response comes via SSL", connection);
 
@@ -621,11 +639,12 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
     server.enqueue(new MockResponse().setSocketPolicy(FAIL_HANDSHAKE));
     server.enqueue(new MockResponse().setSocketPolicy(FAIL_HANDSHAKE));
 
-    suppressTlsFallbackScsv(client.client());
-    client.client().setDns(new SingleInetAddressDns());
-
-    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
-    connection = client.open(server.url("/foo").url());
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .dns(new SingleInetAddressDns())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .sslSocketFactory(suppressTlsFallbackClientSocketFactory())
+        .build());
+    connection = urlFactory.open(server.url("/foo").url());
 
     try {
       connection.getResponseCode();
@@ -636,8 +655,8 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
   }
 
   /**
-   * When a pooled connection fails, don't blame the route. Otherwise pooled
-   * connection failures can cause unnecessary SSL fallbacks.
+   * When a pooled connection fails, don't blame the route. Otherwise pooled connection failures can
+   * cause unnecessary SSL fallbacks.
    *
    * https://github.com/square/okhttp/issues/515
    */
@@ -648,15 +667,17 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
         .setSocketPolicy(DISCONNECT_AT_END));
     server.enqueue(new MockResponse().setBody("def"));
 
-    suppressTlsFallbackScsv(client.client());
-    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .sslSocketFactory(suppressTlsFallbackClientSocketFactory())
+        .build());
 
-    assertContent("abc", client.open(server.url("/").url()));
+    assertContent("abc", urlFactory.open(server.url("/").url()));
 
     // Give the server time to disconnect.
     Thread.sleep(500);
 
-    assertContent("def", client.open(server.url("/").url()));
+    assertContent("def", urlFactory.open(server.url("/").url()));
 
     Set<TlsVersion> tlsVersions =
         EnumSet.of(TlsVersion.TLS_1_0, TlsVersion.TLS_1_2); // v1.2 on OpenJDK 8.
@@ -677,7 +698,7 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
     server.useHttps(sslContext.getSocketFactory(), false);
     server.enqueue(new MockResponse()); // unused
 
-    connection = client.open(server.url("/foo").url());
+    connection = urlFactory.open(server.url("/foo").url());
     try {
       connection.getInputStream();
       fail();
@@ -704,7 +725,7 @@ private void testConnectViaProxy(ProxyConfig proxyConfig) throws Exception {
     server.enqueue(mockResponse);
 
     URL url = new URL("http://android.com/foo");
-    connection = proxyConfig.connect(server, client, url);
+    connection = proxyConfig.connect(server, urlFactory, url);
     assertContent("this response comes via a proxy", connection);
     assertTrue(connection.usingProxy());
 
@@ -717,7 +738,7 @@ private void testConnectViaProxy(ProxyConfig proxyConfig) throws Exception {
     server.enqueue(new MockResponse().setBody("abc\r\nYOU SHOULD NOT SEE THIS")
         .clearHeaders()
         .addHeader("Content-Length: 3"));
-    assertContent("abc", client.open(server.url("/").url()));
+    assertContent("abc", urlFactory.open(server.url("/").url()));
   }
 
   @Test public void contentDisagreesWithContentLengthHeaderBodyTooShort() throws IOException {
@@ -725,7 +746,7 @@ private void testConnectViaProxy(ProxyConfig proxyConfig) throws Exception {
         .setHeader("Content-Length", "5")
         .setSocketPolicy(DISCONNECT_AT_END));
     try {
-      readAscii(client.open(server.url("/").url()).getInputStream(), 5);
+      readAscii(urlFactory.open(server.url("/").url()).getInputStream(), 5);
       fail();
     } catch (ProtocolException expected) {
     }
@@ -733,11 +754,23 @@ private void testConnectViaProxy(ProxyConfig proxyConfig) throws Exception {
 
   public void testConnectViaSocketFactory(boolean useHttps) throws IOException {
     SocketFactory uselessSocketFactory = new SocketFactory() {
-      public Socket createSocket() { throw new IllegalArgumentException("useless"); }
-      public Socket createSocket(InetAddress host, int port) { return null; }
+      public Socket createSocket() {
+        throw new IllegalArgumentException("useless");
+      }
+
+      public Socket createSocket(InetAddress host, int port) {
+        return null;
+      }
+
       public Socket createSocket(InetAddress address, int port, InetAddress localAddress,
-          int localPort) { return null; }
-      public Socket createSocket(String host, int port) { return null; }
+          int localPort) {
+        return null;
+      }
+
+      public Socket createSocket(String host, int port) {
+        return null;
+      }
+
       public Socket createSocket(String host, int port, InetAddress localHost, int localPort) {
         return null;
       }
@@ -745,22 +778,28 @@ public Socket createSocket(String host, int port, InetAddress localHost, int loc
 
     if (useHttps) {
       server.useHttps(sslContext.getSocketFactory(), false);
-      client.client().setSslSocketFactory(sslContext.getSocketFactory());
-      client.client().setHostnameVerifier(new RecordingHostnameVerifier());
+      urlFactory.setClient(urlFactory.client().newBuilder()
+          .sslSocketFactory(sslContext.getSocketFactory())
+          .hostnameVerifier(new RecordingHostnameVerifier())
+          .build());
     }
 
     server.enqueue(new MockResponse().setStatus("HTTP/1.1 200 OK"));
 
-    client.client().setSocketFactory(uselessSocketFactory);
-    connection = client.open(server.url("/").url());
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .socketFactory(uselessSocketFactory)
+        .build());
+    connection = urlFactory.open(server.url("/").url());
     try {
       connection.getResponseCode();
       fail();
     } catch (IllegalArgumentException expected) {
     }
 
-    client.client().setSocketFactory(SocketFactory.getDefault());
-    connection = client.open(server.url("/").url());
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .socketFactory(SocketFactory.getDefault())
+        .build());
+    connection = urlFactory.open(server.url("/").url());
     assertEquals(200, connection.getResponseCode());
   }
 
@@ -783,7 +822,7 @@ public Socket createSocket(String host, int port, InetAddress localHost, int loc
 
     server.enqueue(mockResponse);
 
-    assertContent("abc", client.open(server.url("/").url()));
+    assertContent("abc", urlFactory.open(server.url("/").url()));
   }
 
   @Test public void contentDisagreesWithChunkedHeaderBodyTooShort() throws IOException {
@@ -802,7 +841,7 @@ public Socket createSocket(String host, int port, InetAddress localHost, int loc
     server.enqueue(mockResponse);
 
     try {
-      readAscii(client.open(server.url("/").url()).getInputStream(), 5);
+      readAscii(urlFactory.open(server.url("/").url()).getInputStream(), 5);
       fail();
     } catch (ProtocolException expected) {
     }
@@ -822,9 +861,11 @@ private void testConnectViaDirectProxyToHttps(ProxyConfig proxyConfig) throws Ex
     server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
 
     URL url = server.url("/foo").url();
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
-    connection = proxyConfig.connect(server, client, url);
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build());
+    connection = proxyConfig.connect(server, urlFactory, url);
 
     assertContent("this response comes via HTTPS", connection);
 
@@ -837,8 +878,8 @@ private void testConnectViaDirectProxyToHttps(ProxyConfig proxyConfig) throws Ex
   }
 
   /**
-   * We weren't honoring all of the appropriate proxy system properties when
-   * connecting via HTTPS. http://b/3097518
+   * We weren't honoring all of the appropriate proxy system properties when connecting via HTTPS.
+   * http://b/3097518
    */
   @Test public void connectViaHttpProxyToHttpsUsingProxySystemProperty() throws Exception {
     testConnectViaHttpProxyToHttps(ProxyConfig.PROXY_SYSTEM_PROPERTY);
@@ -849,8 +890,8 @@ private void testConnectViaDirectProxyToHttps(ProxyConfig proxyConfig) throws Ex
   }
 
   /**
-   * We were verifying the wrong hostname when connecting to an HTTPS site
-   * through a proxy. http://b/3097277
+   * We were verifying the wrong hostname when connecting to an HTTPS site through a proxy.
+   * http://b/3097277
    */
   private void testConnectViaHttpProxyToHttps(ProxyConfig proxyConfig) throws Exception {
     RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
@@ -861,9 +902,11 @@ private void testConnectViaHttpProxyToHttps(ProxyConfig proxyConfig) throws Exce
     server.enqueue(new MockResponse().setBody("this response comes via a secure proxy"));
 
     URL url = new URL("https://android.com/foo");
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setHostnameVerifier(hostnameVerifier);
-    connection = proxyConfig.connect(server, client, url);
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .hostnameVerifier(hostnameVerifier)
+        .build());
+    connection = proxyConfig.connect(server, urlFactory, url);
 
     assertContent("this response comes via a secure proxy", connection);
 
@@ -892,14 +935,16 @@ private void testConnectViaHttpProxyToHttps(ProxyConfig proxyConfig) throws Exce
 
     // Configure a single IP address for the host and a single configuration, so we only need one
     // failure to fail permanently.
-    client.client().setDns(new SingleInetAddressDns());
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setConnectionSpecs(Util.immutableList(ConnectionSpec.MODERN_TLS));
-    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
-    client.client().setProxy(server.toProxyAddress());
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .dns(new SingleInetAddressDns())
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .connectionSpecs(Util.immutableList(ConnectionSpec.MODERN_TLS))
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .proxy(server.toProxyAddress())
+        .build());
 
     URL url = new URL("https://android.com/foo");
-    connection = client.open(url);
+    connection = urlFactory.open(url);
     assertContent("response", connection);
 
     RecordedRequest connect = server.takeRequest();
@@ -909,7 +954,9 @@ private void testConnectViaHttpProxyToHttps(ProxyConfig proxyConfig) throws Exce
 
   private void initResponseCache() throws IOException {
     cache = new Cache(tempDir.getRoot(), Integer.MAX_VALUE);
-    client.client().setCache(cache);
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .cache(cache)
+        .build());
   }
 
   /** Test which headers are sent unencrypted to the HTTP proxy. */
@@ -922,12 +969,14 @@ private void initResponseCache() throws IOException {
         new MockResponse().setSocketPolicy(UPGRADE_TO_SSL_AT_END).clearHeaders());
     server.enqueue(new MockResponse().setBody("encrypted response from the origin server"));
 
-    client.client().setProxy(server.toProxyAddress());
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .proxy(server.toProxyAddress())
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .hostnameVerifier(hostnameVerifier)
+        .build());
 
     URL url = new URL("https://android.com/foo");
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setHostnameVerifier(hostnameVerifier);
-    connection = client.open(url);
+    connection = urlFactory.open(url);
     connection.addRequestProperty("Private", "Secret");
     connection.addRequestProperty("Proxy-Authorization", "bar");
     connection.addRequestProperty("User-Agent", "baz");
@@ -954,12 +1003,15 @@ private void initResponseCache() throws IOException {
         new MockResponse().setSocketPolicy(UPGRADE_TO_SSL_AT_END).clearHeaders());
     server.enqueue(new MockResponse().setBody("A"));
 
-    client.client().setProxy(server.toProxyAddress());
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .proxyAuthenticator(new JavaNetAuthenticator())
+        .proxy(server.toProxyAddress())
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build());
 
     URL url = new URL("https://android.com/foo");
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
-    connection = client.open(url);
+    connection = urlFactory.open(url);
     assertContent("A", connection);
 
     RecordedRequest connect1 = server.takeRequest();
@@ -984,12 +1036,14 @@ private void initResponseCache() throws IOException {
         new MockResponse().setSocketPolicy(UPGRADE_TO_SSL_AT_END).clearHeaders());
     server.enqueue(new MockResponse().setBody("this response comes via a proxy"));
 
-    client.client().setProxy(server.toProxyAddress());
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .proxy(server.toProxyAddress())
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build());
 
     URL url = new URL("https://android.com/foo");
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
-    connection = client.open(url);
+    connection = urlFactory.open(url);
     connection.setRequestProperty("Connection", "close");
 
     assertContent("this response comes via a proxy", connection);
@@ -1005,13 +1059,14 @@ private void initResponseCache() throws IOException {
     server.enqueue(new MockResponse().setBody("response 1"));
     server.enqueue(new MockResponse().setBody("response 2"));
 
-    client.client().setProxy(server.toProxyAddress());
-
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .proxy(server.toProxyAddress())
+        .sslSocketFactory(socketFactory)
+        .hostnameVerifier(hostnameVerifier)
+        .build());
     URL url = new URL("https://android.com/foo");
-    client.client().setSslSocketFactory(socketFactory);
-    client.client().setHostnameVerifier(hostnameVerifier);
-    assertContent("response 1", client.open(url));
-    assertContent("response 2", client.open(url));
+    assertContent("response 1", urlFactory.open(url));
+    assertContent("response 2", urlFactory.open(url));
   }
 
   @Test public void disconnectedConnection() throws IOException {
@@ -1019,7 +1074,7 @@ private void initResponseCache() throws IOException {
         .throttleBody(2, 100, TimeUnit.MILLISECONDS)
         .setBody("ABCD"));
 
-    connection = client.open(server.url("/").url());
+    connection = urlFactory.open(server.url("/").url());
     InputStream in = connection.getInputStream();
     assertEquals('A', (char) in.read());
     connection.disconnect();
@@ -1038,7 +1093,7 @@ private void initResponseCache() throws IOException {
   @Test public void disconnectBeforeConnect() throws IOException {
     server.enqueue(new MockResponse().setBody("A"));
 
-    connection = client.open(server.url("/").url());
+    connection = urlFactory.open(server.url("/").url());
     connection.disconnect();
     assertContent("A", connection);
     assertEquals(200, connection.getResponseCode());
@@ -1050,9 +1105,8 @@ private void initResponseCache() throws IOException {
   }
 
   /**
-   * Reads {@code count} characters from the stream. If the stream is
-   * exhausted before {@code count} characters can be read, the remaining
-   * characters are returned and the stream is closed.
+   * Reads {@code count} characters from the stream. If the stream is exhausted before {@code count}
+   * characters can be read, the remaining characters are returned and the stream is closed.
    */
   private String readAscii(InputStream in, int count) throws IOException {
     StringBuilder result = new StringBuilder();
@@ -1085,7 +1139,7 @@ private void testMarkAndReset(TransferKind transferKind) throws IOException {
     server.enqueue(response);
     server.enqueue(response);
 
-    InputStream in = client.open(server.url("/").url()).getInputStream();
+    InputStream in = urlFactory.open(server.url("/").url()).getInputStream();
     assertFalse("This implementation claims to support mark().", in.markSupported());
     in.mark(5);
     assertEquals("ABCDE", readAscii(in, 5));
@@ -1096,13 +1150,12 @@ private void testMarkAndReset(TransferKind transferKind) throws IOException {
     }
     assertEquals("FGHIJKLMNOPQRSTUVWXYZ", readAscii(in, Integer.MAX_VALUE));
     in.close();
-    assertContent("ABCDEFGHIJKLMNOPQRSTUVWXYZ", client.open(server.url("/").url()));
+    assertContent("ABCDEFGHIJKLMNOPQRSTUVWXYZ", urlFactory.open(server.url("/").url()));
   }
 
   /**
-   * We've had a bug where we forget the HTTP response when we see response
-   * code 401. This causes a new HTTP request to be issued for every call into
-   * the URLConnection.
+   * We've had a bug where we forget the HTTP response when we see response code 401. This causes a
+   * new HTTP request to be issued for every call into the URLConnection.
    */
   @Test public void unauthorizedResponseHandling() throws IOException {
     MockResponse response = new MockResponse().addHeader("WWW-Authenticate: challenge")
@@ -1113,7 +1166,7 @@ private void testMarkAndReset(TransferKind transferKind) throws IOException {
     server.enqueue(response);
 
     URL url = server.url("/").url();
-    HttpURLConnection conn = client.open(url);
+    HttpURLConnection conn = urlFactory.open(url);
 
     assertEquals(401, conn.getResponseCode());
     assertEquals(401, conn.getResponseCode());
@@ -1127,7 +1180,7 @@ private void testMarkAndReset(TransferKind transferKind) throws IOException {
         .clearHeaders()
         .addHeader("Transfer-encoding: chunked"));
 
-    URLConnection connection = client.open(server.url("/").url());
+    URLConnection connection = urlFactory.open(server.url("/").url());
     try {
       readAscii(connection.getInputStream(), Integer.MAX_VALUE);
       fail();
@@ -1141,7 +1194,7 @@ private void testMarkAndReset(TransferKind transferKind) throws IOException {
         .clearHeaders()
         .addHeader("Transfer-encoding: chunked"));
 
-    URLConnection connection = client.open(server.url("/").url());
+    URLConnection connection = urlFactory.open(server.url("/").url());
     try {
       readAscii(connection.getInputStream(), Integer.MAX_VALUE);
       fail();
@@ -1156,7 +1209,7 @@ private void testMarkAndReset(TransferKind transferKind) throws IOException {
         .clearHeaders()
         .addHeader("Transfer-encoding: chunked"));
 
-    HttpURLConnection connection = client.open(server.url("/").url());
+    HttpURLConnection connection = urlFactory.open(server.url("/").url());
     assertContent("ABCDE", connection);
   }
 
@@ -1166,7 +1219,7 @@ private void testMarkAndReset(TransferKind transferKind) throws IOException {
         .addHeader("Transfer-encoding: chunked")
         .setSocketPolicy(DISCONNECT_AT_END));
 
-    URLConnection connection = client.open(server.url("/").url());
+    URLConnection connection = urlFactory.open(server.url("/").url());
     try {
       readAscii(connection.getInputStream(), Integer.MAX_VALUE);
       fail();
@@ -1177,16 +1230,15 @@ private void testMarkAndReset(TransferKind transferKind) throws IOException {
   }
 
   /**
-   * This test checks whether connections are gzipped by default. This
-   * behavior in not required by the API, so a failure of this test does not
-   * imply a bug in the implementation.
+   * This test checks whether connections are gzipped by default. This behavior in not required by
+   * the API, so a failure of this test does not imply a bug in the implementation.
    */
   @Test public void gzipEncodingEnabledByDefault() throws IOException, InterruptedException {
     server.enqueue(new MockResponse()
         .setBody(gzip("ABCABCABC"))
         .addHeader("Content-Encoding: gzip"));
 
-    URLConnection connection = client.open(server.url("/").url());
+    URLConnection connection = urlFactory.open(server.url("/").url());
     assertEquals("ABCABCABC", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
     assertNull(connection.getContentEncoding());
     assertEquals(-1, connection.getContentLength());
@@ -1201,7 +1253,7 @@ private void testMarkAndReset(TransferKind transferKind) throws IOException {
         .setBody(bodyBytes)
         .addHeader("Content-Encoding: gzip"));
 
-    URLConnection connection = client.open(server.url("/").url());
+    URLConnection connection = urlFactory.open(server.url("/").url());
     connection.addRequestProperty("Accept-Encoding", "gzip");
     InputStream gunzippedIn = new GZIPInputStream(connection.getInputStream());
     assertEquals("ABCDEFGHIJKLMNOPQRSTUVWXYZ", readAscii(gunzippedIn, Integer.MAX_VALUE));
@@ -1230,7 +1282,7 @@ private void testMarkAndReset(TransferKind transferKind) throws IOException {
   @Test public void clientConfiguredCustomContentEncoding() throws Exception {
     server.enqueue(new MockResponse().setBody("ABCDE").addHeader("Content-Encoding: custom"));
 
-    URLConnection connection = client.open(server.url("/").url());
+    URLConnection connection = urlFactory.open(server.url("/").url());
     connection.addRequestProperty("Accept-Encoding", "custom");
     assertEquals("ABCDE", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
 
@@ -1239,8 +1291,8 @@ private void testMarkAndReset(TransferKind transferKind) throws IOException {
   }
 
   /**
-   * Test a bug where gzip input streams weren't exhausting the input stream,
-   * which corrupted the request that followed or prevented connection reuse.
+   * Test a bug where gzip input streams weren't exhausting the input stream, which corrupted the
+   * request that followed or prevented connection reuse.
    * http://code.google.com/p/android/issues/detail?id=7059
    * http://code.google.com/p/android/issues/detail?id=38817
    */
@@ -1250,8 +1302,10 @@ private void testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferK
       SSLSocketFactory socketFactory = sslContext.getSocketFactory();
       RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
       server.useHttps(socketFactory, false);
-      client.client().setSslSocketFactory(socketFactory);
-      client.client().setHostnameVerifier(hostnameVerifier);
+      urlFactory.setClient(urlFactory.client().newBuilder()
+          .sslSocketFactory(socketFactory)
+          .hostnameVerifier(hostnameVerifier)
+          .build());
     }
 
     MockResponse responseOne = new MockResponse();
@@ -1262,13 +1316,13 @@ private void testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferK
     transferKind.setBody(responseTwo, "two (identity)", 5);
     server.enqueue(responseTwo);
 
-    HttpURLConnection connection1 = client.open(server.url("/").url());
+    HttpURLConnection connection1 = urlFactory.open(server.url("/").url());
     connection1.addRequestProperty("Accept-Encoding", "gzip");
     InputStream gunzippedIn = new GZIPInputStream(connection1.getInputStream());
     assertEquals("one (gzipped)", readAscii(gunzippedIn, Integer.MAX_VALUE));
     assertEquals(0, server.takeRequest().getSequenceNumber());
 
-    HttpURLConnection connection2 = client.open(server.url("/").url());
+    HttpURLConnection connection2 = urlFactory.open(server.url("/").url());
     assertEquals("two (identity)", readAscii(connection2.getInputStream(), Integer.MAX_VALUE));
     assertEquals(1, server.takeRequest().getSequenceNumber());
   }
@@ -1282,31 +1336,28 @@ private void testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferK
         .setBody(gzip("b")));
 
     // Seed the pool with a bad connection.
-    assertContent("a", client.open(server.url("/").url()));
+    assertContent("a", urlFactory.open(server.url("/").url()));
 
     // Give the server time to disconnect.
     Thread.sleep(500);
 
     // This connection will need to be recovered. When it is, transparent gzip should still work!
-    assertContent("b", client.open(server.url("/").url()));
+    assertContent("b", urlFactory.open(server.url("/").url()));
 
     assertEquals(0, server.takeRequest().getSequenceNumber());
     assertEquals(0, server.takeRequest().getSequenceNumber()); // Connection is not pooled.
   }
 
   @Test public void endOfStreamResponseIsNotPooled() throws Exception {
+    urlFactory.client().connectionPool().evictAll();
     server.enqueue(new MockResponse()
         .setBody("{}")
         .clearHeaders()
         .setSocketPolicy(DISCONNECT_AT_END));
 
-    ConnectionPool pool = ConnectionPool.getDefault();
-    pool.evictAll();
-    client.client().setConnectionPool(pool);
-
-    HttpURLConnection connection = client.open(server.url("/").url());
+    HttpURLConnection connection = urlFactory.open(server.url("/").url());
     assertContent("{}", connection);
-    assertEquals(0, client.client().getConnectionPool().getIdleConnectionCount());
+    assertEquals(0, urlFactory.client().connectionPool().idleConnectionCount());
   }
 
   @Test public void earlyDisconnectDoesntHarmPoolingWithChunkedEncoding() throws Exception {
@@ -1326,13 +1377,13 @@ private void testEarlyDisconnectDoesntHarmPooling(TransferKind transferKind) thr
     transferKind.setBody(response2, "LMNOPQRSTUV", 1024);
     server.enqueue(response2);
 
-    HttpURLConnection connection1 = client.open(server.url("/").url());
+    HttpURLConnection connection1 = urlFactory.open(server.url("/").url());
     InputStream in1 = connection1.getInputStream();
     assertEquals("ABCDE", readAscii(in1, 5));
     in1.close();
     connection1.disconnect();
 
-    HttpURLConnection connection2 = client.open(server.url("/").url());
+    HttpURLConnection connection2 = urlFactory.open(server.url("/").url());
     InputStream in2 = connection2.getInputStream();
     assertEquals("LMNOP", readAscii(in2, 5));
     in2.close();
@@ -1350,7 +1401,7 @@ private void testEarlyDisconnectDoesntHarmPooling(TransferKind transferKind) thr
     server.enqueue(new MockResponse().setBody("A"));
 
     long startNanos = System.nanoTime();
-    URLConnection connection1 = client.open(server.url("/").url());
+    URLConnection connection1 = urlFactory.open(server.url("/").url());
     InputStream in = connection1.getInputStream();
     in.close();
     long elapsedNanos = System.nanoTime() - startNanos;
@@ -1362,7 +1413,7 @@ private void testEarlyDisconnectDoesntHarmPooling(TransferKind transferKind) thr
     assertTrue(String.format("Time to close: %sms", elapsedMillis), elapsedMillis < 500);
 
     // Do another request to confirm that the discarded connection was not pooled.
-    assertContent("A", client.open(server.url("/").url()));
+    assertContent("A", urlFactory.open(server.url("/").url()));
 
     assertEquals(0, server.takeRequest().getSequenceNumber());
     assertEquals(0, server.takeRequest().getSequenceNumber()); // Connection is not pooled.
@@ -1372,7 +1423,7 @@ private void testEarlyDisconnectDoesntHarmPooling(TransferKind transferKind) thr
     server.enqueue(new MockResponse());
 
     String body = "ABCDEFGHIJKLMNOPQ";
-    connection = client.open(server.url("/").url());
+    connection = urlFactory.open(server.url("/").url());
     connection.setChunkedStreamingMode(0); // OkHttp does not honor specific chunk sizes.
     connection.setDoOutput(true);
     OutputStream outputStream = connection.getOutputStream();
@@ -1400,9 +1451,12 @@ private void testAuthenticateWithStreamingPost(StreamingMode streamingMode) thro
     server.enqueue(pleaseAuthenticate);
 
     Authenticator.setDefault(new RecordingAuthenticator());
-    connection = client.open(server.url("/").url());
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .authenticator(new JavaNetAuthenticator())
+        .build());
+    connection = urlFactory.open(server.url("/").url());
     connection.setDoOutput(true);
-    byte[] requestBody = { 'A', 'B', 'C', 'D' };
+    byte[] requestBody = {'A', 'B', 'C', 'D'};
     if (streamingMode == StreamingMode.FIXED_LENGTH) {
       connection.setFixedLengthStreamingMode(requestBody.length);
     } else if (streamingMode == StreamingMode.CHUNKED) {
@@ -1457,9 +1511,11 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     server.enqueue(new MockResponse());
 
     String credential = Credentials.basic("jesse", "secret");
-    client.client().setAuthenticator(new RecordingOkAuthenticator(credential));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .authenticator(new RecordingOkAuthenticator(credential))
+        .build());
 
-    connection = client.open(server.url("/").url());
+    connection = urlFactory.open(server.url("/").url());
     connection.setDoOutput(true);
     OutputStream outputStream = connection.getOutputStream();
     outputStream.write(body.getBytes("UTF-8"));
@@ -1538,11 +1594,16 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .setBody("Please authenticate.");
     server.enqueue(pleaseAuthenticate);
 
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .authenticator(new JavaNetAuthenticator())
+        .build());
     if (proxy) {
-      client.client().setProxy(server.toProxyAddress());
-      connection = client.open(new URL("http://android.com"));
+      urlFactory.setClient(urlFactory.client().newBuilder()
+          .proxy(server.toProxyAddress())
+          .build());
+      connection = urlFactory.open(new URL("http://android.com"));
     } else {
-      connection = client.open(server.url("/").url());
+      connection = urlFactory.open(server.url("/").url());
     }
     assertEquals(responseCode, connection.getResponseCode());
     connection.getErrorStream().close();
@@ -1561,7 +1622,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
   }
 
   private void assertValidRequestMethod(String requestMethod) throws Exception {
-    connection = client.open(server.url("/").url());
+    connection = urlFactory.open(server.url("/").url());
     connection.setRequestMethod(requestMethod);
     assertEquals(requestMethod, connection.getRequestMethod());
   }
@@ -1575,7 +1636,7 @@ private void assertValidRequestMethod(String requestMethod) throws Exception {
   }
 
   private void assertInvalidRequestMethod(String requestMethod) throws Exception {
-    connection = client.open(server.url("/").url());
+    connection = urlFactory.open(server.url("/").url());
     try {
       connection.setRequestMethod(requestMethod);
       fail();
@@ -1602,14 +1663,14 @@ private void assertInvalidRequestMethod(String requestMethod) throws Exception {
         .addHeader("Expires: Mon, 26 Jul 1997 05:00:00 GMT")
         .addHeader("icy-metaint:16000")
         .setBody("mp3 data"));
-    connection = client.open(server.url("/").url());
+    connection = urlFactory.open(server.url("/").url());
     assertEquals(200, connection.getResponseCode());
     assertEquals("OK", connection.getResponseMessage());
     assertContent("mp3 data", connection);
   }
 
   @Test public void cannotSetNegativeFixedLengthStreamingMode() throws Exception {
-    connection = client.open(server.url("/").url());
+    connection = urlFactory.open(server.url("/").url());
     try {
       connection.setFixedLengthStreamingMode(-2);
       fail();
@@ -1618,13 +1679,13 @@ private void assertInvalidRequestMethod(String requestMethod) throws Exception {
   }
 
   @Test public void canSetNegativeChunkedStreamingMode() throws Exception {
-    connection = client.open(server.url("/").url());
+    connection = urlFactory.open(server.url("/").url());
     connection.setChunkedStreamingMode(-2);
   }
 
   @Test public void cannotSetFixedLengthStreamingModeAfterConnect() throws Exception {
     server.enqueue(new MockResponse().setBody("A"));
-    connection = client.open(server.url("/").url());
+    connection = urlFactory.open(server.url("/").url());
     assertEquals("A", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
     try {
       connection.setFixedLengthStreamingMode(1);
@@ -1635,7 +1696,7 @@ private void assertInvalidRequestMethod(String requestMethod) throws Exception {
 
   @Test public void cannotSetChunkedStreamingModeAfterConnect() throws Exception {
     server.enqueue(new MockResponse().setBody("A"));
-    connection = client.open(server.url("/").url());
+    connection = urlFactory.open(server.url("/").url());
     assertEquals("A", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
     try {
       connection.setChunkedStreamingMode(1);
@@ -1645,7 +1706,7 @@ private void assertInvalidRequestMethod(String requestMethod) throws Exception {
   }
 
   @Test public void cannotSetFixedLengthStreamingModeAfterChunkedStreamingMode() throws Exception {
-    connection = client.open(server.url("/").url());
+    connection = urlFactory.open(server.url("/").url());
     connection.setChunkedStreamingMode(1);
     try {
       connection.setFixedLengthStreamingMode(1);
@@ -1655,7 +1716,7 @@ private void assertInvalidRequestMethod(String requestMethod) throws Exception {
   }
 
   @Test public void cannotSetChunkedStreamingModeAfterFixedLengthStreamingMode() throws Exception {
-    connection = client.open(server.url("/").url());
+    connection = urlFactory.open(server.url("/").url());
     connection.setFixedLengthStreamingMode(1);
     try {
       connection.setChunkedStreamingMode(1);
@@ -1680,11 +1741,13 @@ private void testSecureStreamingPost(StreamingMode streamingMode) throws Excepti
     server.useHttps(sslContext.getSocketFactory(), false);
     server.enqueue(new MockResponse().setBody("Success!"));
 
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
-    connection = client.open(server.url("/").url());
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build());
+    connection = urlFactory.open(server.url("/").url());
     connection.setDoOutput(true);
-    byte[] requestBody = { 'A', 'B', 'C', 'D' };
+    byte[] requestBody = {'A', 'B', 'C', 'D'};
     if (streamingMode == StreamingMode.FIXED_LENGTH) {
       connection.setFixedLengthStreamingMode(requestBody.length);
     } else if (streamingMode == StreamingMode.CHUNKED) {
@@ -1721,9 +1784,12 @@ private void testSecureStreamingPost(StreamingMode streamingMode) throws Excepti
     server.enqueue(new MockResponse().setBody("Successful auth!"));
 
     Authenticator.setDefault(new RecordingAuthenticator());
-    connection = client.open(server.url("/").url());
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .authenticator(new JavaNetAuthenticator())
+        .build());
+    connection = urlFactory.open(server.url("/").url());
     connection.setDoOutput(true);
-    byte[] requestBody = { 'A', 'B', 'C', 'D' };
+    byte[] requestBody = {'A', 'B', 'C', 'D'};
     OutputStream outputStream = connection.getOutputStream();
     outputStream.write(requestBody);
     outputStream.close();
@@ -1755,7 +1821,10 @@ private void testSecureStreamingPost(StreamingMode streamingMode) throws Excepti
     server.enqueue(new MockResponse().setBody("Successful auth!"));
 
     Authenticator.setDefault(new RecordingAuthenticator());
-    connection = client.open(server.url("/").url());
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .authenticator(new JavaNetAuthenticator())
+        .build());
+    connection = urlFactory.open(server.url("/").url());
     assertEquals("Successful auth!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
 
     // no authorization header for the first request...
@@ -1787,7 +1856,10 @@ private void testSecureStreamingPost(StreamingMode streamingMode) throws Excepti
     server.enqueue(successfulResponse);
 
     Authenticator.setDefault(new RecordingAuthenticator());
-    connection = client.open(server.url("/").url());
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .authenticator(new JavaNetAuthenticator())
+        .build());
+    connection = urlFactory.open(server.url("/").url());
     assertEquals("Successful auth!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
 
     // no authorization header for the first request...
@@ -1811,7 +1883,10 @@ private void testSecureStreamingPost(StreamingMode streamingMode) throws Excepti
     server.enqueue(new MockResponse().setBody("Successful auth!"));
 
     Authenticator.setDefault(new RecordingAuthenticator());
-    connection = client.open(server.url("/").url());
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .authenticator(new JavaNetAuthenticator())
+        .build());
+    connection = urlFactory.open(server.url("/").url());
     assertEquals("Successful auth!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
   }
 
@@ -1834,7 +1909,7 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
     server.enqueue(response);
     server.enqueue(new MockResponse().setBody("This is the new location!"));
 
-    URLConnection connection = client.open(server.url("/").url());
+    URLConnection connection = urlFactory.open(server.url("/").url());
     assertEquals("This is the new location!",
         readAscii(connection.getInputStream(), Integer.MAX_VALUE));
 
@@ -1854,9 +1929,11 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
         .setBody("This page has moved!"));
     server.enqueue(new MockResponse().setBody("This is the new location!"));
 
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
-    connection = client.open(server.url("/").url());
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build());
+    connection = urlFactory.open(server.url("/").url());
     assertEquals("This is the new location!",
         readAscii(connection.getInputStream(), Integer.MAX_VALUE));
 
@@ -1873,10 +1950,12 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
         .addHeader("Location: http://anyhost/foo")
         .setBody("This page has moved!"));
 
-    client.client().setFollowSslRedirects(false);
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
-    connection = client.open(server.url("/").url());
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .followSslRedirects(false)
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build());
+    connection = urlFactory.open(server.url("/").url());
     assertEquals("This page has moved!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
   }
 
@@ -1885,8 +1964,10 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
         .addHeader("Location: https://anyhost/foo")
         .setBody("This page has moved!"));
 
-    client.client().setFollowSslRedirects(false);
-    connection = client.open(server.url("/").url());
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .followSslRedirects(false)
+        .build());
+    connection = urlFactory.open(server.url("/").url());
     assertEquals("This page has moved!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
   }
 
@@ -1898,10 +1979,12 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
         .addHeader("Location: " + server2.url("/").url())
         .setBody("This page has moved!"));
 
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
-    client.client().setFollowSslRedirects(true);
-    HttpsURLConnection connection = (HttpsURLConnection) client.open(server.url("/").url());
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .followSslRedirects(true)
+        .build());
+    HttpsURLConnection connection = (HttpsURLConnection) urlFactory.open(server.url("/").url());
     assertContent("This is insecure HTTP!", connection);
     assertNull(connection.getCipherSuite());
     assertNull(connection.getLocalCertificates());
@@ -1918,10 +2001,12 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
         .addHeader("Location: " + server2.url("/").url())
         .setBody("This page has moved!"));
 
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
-    client.client().setFollowSslRedirects(true);
-    connection = client.open(server.url("/").url());
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .followSslRedirects(true)
+        .build());
+    connection = urlFactory.open(server.url("/").url());
     assertContent("This is secure HTTPS!", connection);
     assertFalse(connection instanceof HttpsURLConnection);
   }
@@ -1939,8 +2024,10 @@ private void redirectToAnotherOriginServer(boolean https) throws Exception {
       server.useHttps(sslContext.getSocketFactory(), false);
       server2.useHttps(sslContext.getSocketFactory(), false);
       server2.setProtocolNegotiationEnabled(false);
-      client.client().setSslSocketFactory(sslContext.getSocketFactory());
-      client.client().setHostnameVerifier(new RecordingHostnameVerifier());
+      urlFactory.setClient(urlFactory.client().newBuilder()
+          .sslSocketFactory(sslContext.getSocketFactory())
+          .hostnameVerifier(new RecordingHostnameVerifier())
+          .build());
     }
 
     server2.enqueue(new MockResponse().setBody("This is the 2nd server!"));
@@ -1951,13 +2038,13 @@ private void redirectToAnotherOriginServer(boolean https) throws Exception {
         .setBody("This page has moved!"));
     server.enqueue(new MockResponse().setBody("This is the first server again!"));
 
-    connection = client.open(server.url("/").url());
+    connection = urlFactory.open(server.url("/").url());
     assertContent("This is the 2nd server!", connection);
     assertEquals(server2.url("/").url(), connection.getURL());
 
     // make sure the first server was careful to recycle the connection
-    assertContent("This is the first server again!", client.open(server.url("/").url()));
-    assertContent("This is the 2nd server, again!", client.open(server2.url("/").url()));
+    assertContent("This is the first server again!", urlFactory.open(server.url("/").url()));
+    assertContent("This is the 2nd server, again!", urlFactory.open(server2.url("/").url()));
 
     String server1Host = server.getHostName() + ":" + server.getPort();
     String server2Host = server2.getHostName() + ":" + server2.getPort();
@@ -1969,19 +2056,21 @@ private void redirectToAnotherOriginServer(boolean https) throws Exception {
 
   @Test public void redirectWithProxySelector() throws Exception {
     final List<URI> proxySelectionRequests = new ArrayList<URI>();
-    client.client().setProxySelector(new ProxySelector() {
-      @Override public List<Proxy> select(URI uri) {
-        proxySelectionRequests.add(uri);
-        MockWebServer proxyServer = (uri.getPort() == server.getPort())
-            ? server
-            : server2;
-        return Arrays.asList(proxyServer.toProxyAddress());
-      }
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .proxySelector(new ProxySelector() {
+          @Override public List<Proxy> select(URI uri) {
+            proxySelectionRequests.add(uri);
+            MockWebServer proxyServer = (uri.getPort() == server.getPort())
+                ? server
+                : server2;
+            return Arrays.asList(proxyServer.toProxyAddress());
+          }
 
-      @Override public void connectFailed(URI uri, SocketAddress address, IOException failure) {
-        throw new AssertionError();
-      }
-    });
+          @Override public void connectFailed(URI uri, SocketAddress address, IOException failure) {
+            throw new AssertionError();
+          }
+        })
+        .build());
 
     server2.enqueue(new MockResponse().setBody("This is the 2nd server!"));
 
@@ -1989,7 +2078,7 @@ private void redirectToAnotherOriginServer(boolean https) throws Exception {
         .addHeader("Location: " + server2.url("/b").url().toString())
         .setBody("This page has moved!"));
 
-    assertContent("This is the 2nd server!", client.open(server.url("/a").url()));
+    assertContent("This is the 2nd server!", urlFactory.open(server.url("/a").url()));
 
     assertEquals(Arrays.asList(server.url("/").url().toURI(), server2.url("/").url().toURI()),
         proxySelectionRequests);
@@ -2002,9 +2091,10 @@ private void redirectToAnotherOriginServer(boolean https) throws Exception {
     server.enqueue(new MockResponse().setResponseCode(302)
         .addHeader("Location: " + server2.url("/b").url()));
 
-    client.client().setAuthenticator(
-        new RecordingOkAuthenticator(Credentials.basic("jesse", "secret")));
-    assertContent("Page 2", client.open(server.url("/a").url()));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .authenticator(new RecordingOkAuthenticator(Credentials.basic("jesse", "secret")))
+        .build());
+    assertContent("Page 2", urlFactory.open(server.url("/a").url()));
 
     RecordedRequest redirectRequest = server2.takeRequest();
     assertNull(redirectRequest.getHeader("Authorization"));
@@ -2043,10 +2133,10 @@ private void testResponseRedirectedWithPost(int redirectCode, TransferKind trans
         .setBody("This page has moved!"));
     server.enqueue(new MockResponse().setBody("Page 2"));
 
-    connection = client.open(server.url("/page1").url());
+    connection = urlFactory.open(server.url("/page1").url());
     connection.setDoOutput(true);
     transferKind.setForRequest(connection, 4);
-    byte[] requestBody = { 'A', 'B', 'C', 'D' };
+    byte[] requestBody = {'A', 'B', 'C', 'D'};
     OutputStream outputStream = connection.getOutputStream();
     outputStream.write(requestBody);
     outputStream.close();
@@ -2066,7 +2156,7 @@ private void testResponseRedirectedWithPost(int redirectCode, TransferKind trans
         .addHeader("Location: /page2"));
     server.enqueue(new MockResponse().setBody("Page 2"));
 
-    connection = client.open(server.url("/page1").url());
+    connection = urlFactory.open(server.url("/page1").url());
     connection.setDoOutput(true);
     connection.addRequestProperty("Content-Length", "4");
     connection.addRequestProperty("Content-Type", "text/plain; charset=utf-8");
@@ -2091,7 +2181,7 @@ private void testResponseRedirectedWithPost(int redirectCode, TransferKind trans
         .setBody("This page has moved!"));
     server.enqueue(new MockResponse().setBody("Proxy Response"));
 
-    connection = client.open(server.url("/foo").url());
+    connection = urlFactory.open(server.url("/foo").url());
     // Fails on the RI, which gets "Proxy Response"
     assertEquals("This page has moved!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
 
@@ -2142,9 +2232,9 @@ private void testRedirect(boolean temporary, String method) throws Exception {
     server.enqueue(response1);
     server.enqueue(new MockResponse().setBody("Page 2"));
 
-    connection = client.open(server.url("/page1").url());
+    connection = urlFactory.open(server.url("/page1").url());
     connection.setRequestMethod(method);
-    byte[] requestBody = { 'A', 'B', 'C', 'D' };
+    byte[] requestBody = {'A', 'B', 'C', 'D'};
     if (method.equals("POST")) {
       connection.setDoOutput(true);
       OutputStream outputStream = connection.getOutputStream();
@@ -2159,7 +2249,7 @@ private void testRedirect(boolean temporary, String method) throws Exception {
 
     if (method.equals("GET")) {
       assertEquals("Page 2", response);
-    } else if (method.equals("HEAD"))  {
+    } else if (method.equals("HEAD")) {
       assertEquals("", response);
     } else {
       // Methods other than GET/HEAD shouldn't follow the redirect
@@ -2187,7 +2277,7 @@ private void testRedirect(boolean temporary, String method) throws Exception {
     }
     server.enqueue(new MockResponse().setBody("Success!"));
 
-    connection = client.open(server.url("/0").url());
+    connection = urlFactory.open(server.url("/0").url());
     assertContent("Success!", connection);
     assertEquals(server.url("/20").url(), connection.getURL());
   }
@@ -2199,7 +2289,7 @@ private void testRedirect(boolean temporary, String method) throws Exception {
           .setBody("Redirecting to /" + (i + 1)));
     }
 
-    connection = client.open(server.url("/0").url());
+    connection = urlFactory.open(server.url("/0").url());
     try {
       connection.getInputStream();
       fail();
@@ -2215,19 +2305,21 @@ private void testRedirect(boolean temporary, String method) throws Exception {
     RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
     RecordingTrustManager trustManager = new RecordingTrustManager();
     SSLContext sc = SSLContext.getInstance("TLS");
-    sc.init(null, new TrustManager[] { trustManager }, new java.security.SecureRandom());
+    sc.init(null, new TrustManager[] {trustManager}, new java.security.SecureRandom());
 
-    client.client().setHostnameVerifier(hostnameVerifier);
-    client.client().setSslSocketFactory(sc.getSocketFactory());
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .hostnameVerifier(hostnameVerifier)
+        .sslSocketFactory(sc.getSocketFactory())
+        .build());
     server.useHttps(sslContext.getSocketFactory(), false);
     server.enqueue(new MockResponse().setBody("ABC"));
     server.enqueue(new MockResponse().setBody("DEF"));
     server.enqueue(new MockResponse().setBody("GHI"));
 
     URL url = server.url("/").url();
-    assertContent("ABC", client.open(url));
-    assertContent("DEF", client.open(url));
-    assertContent("GHI", client.open(url));
+    assertContent("ABC", urlFactory.open(url));
+    assertContent("DEF", urlFactory.open(url));
+    assertContent("GHI", urlFactory.open(url));
 
     assertEquals(Arrays.asList("verify " + server.getHostName()),
         hostnameVerifier.calls);
@@ -2244,7 +2336,7 @@ private void testRedirect(boolean temporary, String method) throws Exception {
     server.enqueue(timeout);
     server.enqueue(new MockResponse().setBody("unused")); // to keep the server alive
 
-    URLConnection connection = client.open(server.url("/").url());
+    URLConnection connection = urlFactory.open(server.url("/").url());
     connection.setReadTimeout(1000);
     InputStream in = connection.getInputStream();
     assertEquals('A', in.read());
@@ -2273,21 +2365,22 @@ protected ServerSocket configureServerSocket(ServerSocket serverSocket)
             return serverSocket;
           }
         });
-    client.client().setSocketFactory(new DelegatingSocketFactory(SocketFactory.getDefault()) {
-      @Override
-      protected Socket configureSocket(Socket socket) throws IOException {
-        socket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
-        socket.setSendBufferSize(SOCKET_BUFFER_SIZE);
-        return socket;
-      }
-    });
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .socketFactory(new DelegatingSocketFactory(SocketFactory.getDefault()) {
+          @Override protected Socket configureSocket(Socket socket) throws IOException {
+            socket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
+            socket.setSendBufferSize(SOCKET_BUFFER_SIZE);
+            return socket;
+          }
+        })
+        .writeTimeout(500, TimeUnit.MILLISECONDS)
+        .build());
 
     server.start();
     server.enqueue(new MockResponse()
         .throttleBody(1, 1, TimeUnit.SECONDS)); // Prevent the server from reading!
 
-    client.client().setWriteTimeout(500, TimeUnit.MILLISECONDS);
-    connection = client.open(server.url("/").url());
+    connection = urlFactory.open(server.url("/").url());
     connection.setDoOutput(true);
     connection.setChunkedStreamingMode(0);
     OutputStream out = connection.getOutputStream();
@@ -2302,7 +2395,7 @@ protected Socket configureSocket(Socket socket) throws IOException {
   @Test public void setChunkedEncodingAsRequestProperty() throws IOException, InterruptedException {
     server.enqueue(new MockResponse());
 
-    connection = client.open(server.url("/").url());
+    connection = urlFactory.open(server.url("/").url());
     connection.setRequestProperty("Transfer-encoding", "chunked");
     connection.setDoOutput(true);
     connection.getOutputStream().write("ABC".getBytes("UTF-8"));
@@ -2316,11 +2409,11 @@ protected Socket configureSocket(Socket socket) throws IOException {
     server.enqueue(new MockResponse()); // server doesn't honor the connection: close header!
     server.enqueue(new MockResponse());
 
-    HttpURLConnection a = client.open(server.url("/").url());
+    HttpURLConnection a = urlFactory.open(server.url("/").url());
     a.setRequestProperty("Connection", "close");
     assertEquals(200, a.getResponseCode());
 
-    HttpURLConnection b = client.open(server.url("/").url());
+    HttpURLConnection b = urlFactory.open(server.url("/").url());
     assertEquals(200, b.getResponseCode());
 
     assertEquals(0, server.takeRequest().getSequenceNumber());
@@ -2332,10 +2425,10 @@ protected Socket configureSocket(Socket socket) throws IOException {
     server.enqueue(new MockResponse().addHeader("Connection: close"));
     server.enqueue(new MockResponse());
 
-    HttpURLConnection a = client.open(server.url("/").url());
+    HttpURLConnection a = urlFactory.open(server.url("/").url());
     assertEquals(200, a.getResponseCode());
 
-    HttpURLConnection b = client.open(server.url("/").url());
+    HttpURLConnection b = urlFactory.open(server.url("/").url());
     assertEquals(200, b.getResponseCode());
 
     assertEquals(0, server.takeRequest().getSequenceNumber());
@@ -2344,13 +2437,15 @@ protected Socket configureSocket(Socket socket) throws IOException {
   }
 
   @Test public void connectionCloseWithRedirect() throws IOException, InterruptedException {
-    MockResponse response = new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+    MockResponse response = new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
         .addHeader("Location: /foo")
         .addHeader("Connection: close");
     server.enqueue(response);
-    server.enqueue(new MockResponse().setBody("This is the new location!"));
+    server.enqueue(new MockResponse()
+        .setBody("This is the new location!"));
 
-    URLConnection connection = client.open(server.url("/").url());
+    URLConnection connection = urlFactory.open(server.url("/").url());
     assertEquals("This is the new location!",
         readAscii(connection.getInputStream(), Integer.MAX_VALUE));
 
@@ -2364,12 +2459,18 @@ protected Socket configureSocket(Socket socket) throws IOException {
    * https://code.google.com/p/android/issues/detail?id=41576
    */
   @Test public void sameConnectionRedirectAndReuse() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+    // TODO(jwilson): this behavior shouldn't rely on having another IP address to attempt.
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .dns(new DoubleInetAddressDns())
+        .build());
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
         .setSocketPolicy(SHUTDOWN_INPUT_AT_END)
         .addHeader("Location: /foo"));
-    server.enqueue(new MockResponse().setBody("This is the new page!"));
+    server.enqueue(new MockResponse()
+        .setBody("This is the new page!"));
 
-    assertContent("This is the new page!", client.open(server.url("/").url()));
+    assertContent("This is the new page!", urlFactory.open(server.url("/").url()));
 
     assertEquals(0, server.takeRequest().getSequenceNumber());
     assertEquals(0, server.takeRequest().getSequenceNumber());
@@ -2379,7 +2480,7 @@ protected Socket configureSocket(Socket socket) throws IOException {
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NO_CONTENT)
         .setBody("This body is not allowed!"));
 
-    URLConnection connection = client.open(server.url("/").url());
+    URLConnection connection = urlFactory.open(server.url("/").url());
     assertEquals("This body is not allowed!",
         readAscii(connection.getInputStream(), Integer.MAX_VALUE));
   }
@@ -2387,7 +2488,7 @@ protected Socket configureSocket(Socket socket) throws IOException {
   @Test public void singleByteReadIsSigned() throws IOException {
     server.enqueue(new MockResponse().setBody(new Buffer().writeByte(-2).writeByte(-1)));
 
-    connection = client.open(server.url("/").url());
+    connection = urlFactory.open(server.url("/").url());
     InputStream in = connection.getInputStream();
     assertEquals(254, in.read());
     assertEquals(255, in.read());
@@ -2407,14 +2508,14 @@ protected Socket configureSocket(Socket socket) throws IOException {
   }
 
   /**
-   * We explicitly permit apps to close the upload stream even after it has
-   * been transmitted.  We also permit flush so that buffered streams can
-   * do a no-op flush when they are closed. http://b/3038470
+   * We explicitly permit apps to close the upload stream even after it has been transmitted.  We
+   * also permit flush so that buffered streams can do a no-op flush when they are closed.
+   * http://b/3038470
    */
   private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws IOException {
     server.enqueue(new MockResponse().setBody("abc"));
 
-    connection = client.open(server.url("/").url());
+    connection = urlFactory.open(server.url("/").url());
     connection.setDoOutput(true);
     byte[] upload = "def".getBytes("UTF-8");
 
@@ -2439,7 +2540,7 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
   @Test public void getHeadersThrows() throws IOException {
     server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AT_START));
 
-    connection = client.open(server.url("/").url());
+    connection = urlFactory.open(server.url("/").url());
     try {
       connection.getInputStream();
       fail();
@@ -2454,7 +2555,7 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
   }
 
   @Test public void dnsFailureThrowsIOException() throws IOException {
-    connection = client.open(new URL("http://host.unlikelytld"));
+    connection = urlFactory.open(new URL("http://host.unlikelytld"));
     try {
       connection.connect();
       fail();
@@ -2463,7 +2564,7 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
   }
 
   @Test public void malformedUrlThrowsUnknownHostException() throws IOException {
-    connection = client.open(new URL("http://./foo.html"));
+    connection = urlFactory.open(new URL("http://./foo.html"));
     try {
       connection.connect();
       fail();
@@ -2475,13 +2576,13 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
     server.enqueue(new MockResponse().setBody("ABC"));
 
     // The request should work once and then fail
-    HttpURLConnection connection1 = client.open(server.url("/").url());
+    HttpURLConnection connection1 = urlFactory.open(server.url("/").url());
     connection1.setReadTimeout(100);
     InputStream input = connection1.getInputStream();
     assertEquals("ABC", readAscii(input, Integer.MAX_VALUE));
     server.shutdown();
     try {
-      HttpURLConnection connection2 = client.open(server.url("").url());
+      HttpURLConnection connection2 = urlFactory.open(server.url("").url());
       connection2.setReadTimeout(100);
       connection2.getInputStream();
       fail();
@@ -2496,7 +2597,7 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
         .addHeader("Connection: close")
         .setSocketPolicy(DISCONNECT_AT_END));
 
-    connection = client.open(server.url("/").url());
+    connection = urlFactory.open(server.url("/").url());
     InputStream in = connection.getInputStream();
     assertEquals("ABC", readAscii(in, 3));
     assertEquals(-1, in.read());
@@ -2505,31 +2606,31 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
 
   @Test public void getContent() throws Exception {
     server.enqueue(new MockResponse().addHeader("Content-Type: text/plain").setBody("A"));
-    connection = client.open(server.url("/").url());
+    connection = urlFactory.open(server.url("/").url());
     InputStream in = (InputStream) connection.getContent();
     assertEquals("A", readAscii(in, Integer.MAX_VALUE));
   }
 
   @Test public void getContentOfType() throws Exception {
     server.enqueue(new MockResponse().addHeader("Content-Type: text/plain").setBody("A"));
-    connection = client.open(server.url("/").url());
+    connection = urlFactory.open(server.url("/").url());
     try {
       connection.getContent(null);
       fail();
     } catch (NullPointerException expected) {
     }
     try {
-      connection.getContent(new Class[] { null });
+      connection.getContent(new Class[] {null});
       fail();
     } catch (NullPointerException expected) {
     }
-    assertNull(connection.getContent(new Class[] { getClass() }));
+    assertNull(connection.getContent(new Class[] {getClass()}));
     connection.getInputStream().close();
   }
 
   @Test public void getOutputStreamOnGetFails() throws Exception {
     server.enqueue(new MockResponse());
-    connection = client.open(server.url("/").url());
+    connection = urlFactory.open(server.url("/").url());
     try {
       connection.getOutputStream();
       fail();
@@ -2540,7 +2641,7 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
 
   @Test public void getOutputAfterGetInputStreamFails() throws Exception {
     server.enqueue(new MockResponse());
-    connection = client.open(server.url("/").url());
+    connection = urlFactory.open(server.url("/").url());
     connection.setDoOutput(true);
     try {
       connection.getInputStream();
@@ -2552,7 +2653,7 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
 
   @Test public void setDoOutputOrDoInputAfterConnectFails() throws Exception {
     server.enqueue(new MockResponse());
-    connection = client.open(server.url("/").url());
+    connection = urlFactory.open(server.url("/").url());
     connection.connect();
     try {
       connection.setDoOutput(true);
@@ -2569,10 +2670,10 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
 
   @Test public void clientSendsContentLength() throws Exception {
     server.enqueue(new MockResponse().setBody("A"));
-    connection = client.open(server.url("/").url());
+    connection = urlFactory.open(server.url("/").url());
     connection.setDoOutput(true);
     OutputStream out = connection.getOutputStream();
-    out.write(new byte[] { 'A', 'B', 'C' });
+    out.write(new byte[] {'A', 'B', 'C'});
     out.close();
     assertEquals("A", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
     RecordedRequest request = server.takeRequest();
@@ -2582,21 +2683,21 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
 
   @Test public void getContentLengthConnects() throws Exception {
     server.enqueue(new MockResponse().setBody("ABC"));
-    connection = client.open(server.url("/").url());
+    connection = urlFactory.open(server.url("/").url());
     assertEquals(3, connection.getContentLength());
     connection.getInputStream().close();
   }
 
   @Test public void getContentTypeConnects() throws Exception {
     server.enqueue(new MockResponse().addHeader("Content-Type: text/plain").setBody("ABC"));
-    connection = client.open(server.url("/").url());
+    connection = urlFactory.open(server.url("/").url());
     assertEquals("text/plain", connection.getContentType());
     connection.getInputStream().close();
   }
 
   @Test public void getContentEncodingConnects() throws Exception {
     server.enqueue(new MockResponse().addHeader("Content-Encoding: identity").setBody("ABC"));
-    connection = client.open(server.url("/").url());
+    connection = urlFactory.open(server.url("/").url());
     assertEquals("identity", connection.getContentEncoding());
     connection.getInputStream().close();
   }
@@ -2606,13 +2707,13 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
     server.enqueue(new MockResponse().setBody("A"));
 
     URL url = new URL("http", server.getHostName(), server.getPort(), "?query");
-    assertEquals("A", readAscii(client.open(url).getInputStream(), Integer.MAX_VALUE));
+    assertEquals("A", readAscii(urlFactory.open(url).getInputStream(), Integer.MAX_VALUE));
     RecordedRequest request = server.takeRequest();
     assertEquals("GET /?query HTTP/1.1", request.getRequestLine());
   }
 
   @Test public void doOutputForMethodThatDoesntSupportOutput() throws Exception {
-    connection = client.open(server.url("/").url());
+    connection = urlFactory.open(server.url("/").url());
     connection.setRequestMethod("HEAD");
     connection.setDoOutput(true);
     try {
@@ -2640,7 +2741,7 @@ private void testInputStreamAvailable(TransferKind transferKind) throws IOExcept
     MockResponse response = new MockResponse();
     transferKind.setBody(response, body, 4);
     server.enqueue(response);
-    connection = client.open(server.url("/").url());
+    connection = urlFactory.open(server.url("/").url());
     InputStream in = connection.getInputStream();
     for (int i = 0; i < body.length(); i++) {
       assertTrue(in.available() >= 0);
@@ -2680,7 +2781,7 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
     server.enqueue(new MockResponse().setBody("B"));
     server.enqueue(new MockResponse().setBody("C"));
 
-    assertContent("A", client.open(server.url("/a").url()));
+    assertContent("A", urlFactory.open(server.url("/a").url()));
 
     // Give the server time to disconnect.
     Thread.sleep(500);
@@ -2691,7 +2792,7 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
 
     for (int j = 0; j < 2; j++) {
       try {
-        connection = client.open(server.url("/b").url());
+        connection = urlFactory.open(server.url("/b").url());
         connection.setRequestMethod("POST");
         transferKind.setForRequest(connection, requestBody.length);
         for (int i = 0; i < requestBody.length; i += 1024) {
@@ -2721,9 +2822,9 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
     server.enqueue(new MockResponse().setBody("def"));
 
     // Seed the connection pool so we have something that can fail.
-    assertContent("abc", client.open(server.url("/").url()));
+    assertContent("abc", urlFactory.open(server.url("/").url()));
 
-    HttpURLConnection post = client.open(server.url("/").url());
+    HttpURLConnection post = urlFactory.open(server.url("/").url());
     post.setDoOutput(true);
     post.getOutputStream().write("body!".getBytes(UTF_8));
     assertContent("def", post);
@@ -2743,7 +2844,7 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
   @Test public void fullyBufferedPostIsTooShort() throws Exception {
     server.enqueue(new MockResponse().setBody("A"));
 
-    connection = client.open(server.url("/b").url());
+    connection = urlFactory.open(server.url("/b").url());
     connection.setRequestProperty("Content-Length", "4");
     connection.setRequestMethod("POST");
     OutputStream out = connection.getOutputStream();
@@ -2760,7 +2861,7 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
   @Test public void fullyBufferedPostIsTooLong() throws Exception {
     server.enqueue(new MockResponse().setBody("A"));
 
-    connection = client.open(server.url("/b").url());
+    connection = urlFactory.open(server.url("/b").url());
     connection.setRequestProperty("Content-Length", "3");
     connection.setRequestMethod("POST");
     OutputStream out = connection.getOutputStream();
@@ -2801,7 +2902,7 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
 
   @Test public void emptyRequestHeaderValueIsAllowed() throws Exception {
     server.enqueue(new MockResponse().setBody("body"));
-    connection = client.open(server.url("/").url());
+    connection = urlFactory.open(server.url("/").url());
     connection.addRequestProperty("B", "");
     assertContent("body", connection);
     assertEquals("", connection.getRequestProperty("B"));
@@ -2809,14 +2910,14 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
 
   @Test public void emptyResponseHeaderValueIsAllowed() throws Exception {
     server.enqueue(new MockResponse().addHeader("A:").setBody("body"));
-    connection = client.open(server.url("/").url());
+    connection = urlFactory.open(server.url("/").url());
     assertContent("body", connection);
     assertEquals("", connection.getHeaderField("A"));
   }
 
   @Test public void emptyRequestHeaderNameIsStrict() throws Exception {
     server.enqueue(new MockResponse().setBody("body"));
-    connection = client.open(server.url("/").url());
+    connection = urlFactory.open(server.url("/").url());
     try {
       connection.setRequestProperty("", "A");
       fail();
@@ -2828,14 +2929,14 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
     Headers.Builder headers = new Headers.Builder();
     Internal.instance.addLenient(headers, ":A");
     server.enqueue(new MockResponse().setHeaders(headers.build()).setBody("body"));
-    connection = client.open(server.url("/").url());
+    connection = urlFactory.open(server.url("/").url());
     connection.getResponseCode();
     assertEquals("A", connection.getHeaderField(""));
     connection.getInputStream().close();
   }
 
   @Test public void requestHeaderValidationIsStrict() throws Exception {
-    connection = client.open(server.url("/").url());
+    connection = urlFactory.open(server.url("/").url());
     try {
       connection.addRequestProperty("a\tb", "Value");
       fail();
@@ -2872,7 +2973,7 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
         .build();
     server.enqueue(new MockResponse().setHeaders(headers));
 
-    connection = client.open(server.url("/").url());
+    connection = urlFactory.open(server.url("/").url());
     connection.getResponseCode();
     assertEquals("c\u007fd", connection.getHeaderField("a\tb"));
     assertEquals("\u2615\ufe0f", connection.getHeaderField("\ud83c\udf69"));
@@ -2900,8 +3001,10 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
 
     String credential = Credentials.basic("jesse", "peanutbutter");
     RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator(credential);
-    client.client().setAuthenticator(authenticator);
-    assertContent("A", client.open(server.url("/private").url()));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .authenticator(authenticator)
+        .build());
+    assertContent("A", urlFactory.open(server.url("/private").url()));
 
     assertNull(server.takeRequest().getHeader("Authorization"));
     assertEquals(credential, server.takeRequest().getHeader("Authorization"));
@@ -2914,14 +3017,16 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
 
   @Test public void customTokenAuthenticator() throws Exception {
     MockResponse pleaseAuthenticate = new MockResponse().setResponseCode(401)
-            .addHeader("WWW-Authenticate: Bearer realm=\"oauthed\"")
-            .setBody("Please authenticate.");
+        .addHeader("WWW-Authenticate: Bearer realm=\"oauthed\"")
+        .setBody("Please authenticate.");
     server.enqueue(pleaseAuthenticate);
     server.enqueue(new MockResponse().setBody("A"));
 
     RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator("oauthed abc123");
-    client.client().setAuthenticator(authenticator);
-    assertContent("A", client.open(server.url("/private").url()));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .authenticator(authenticator)
+        .build());
+    assertContent("A", urlFactory.open(server.url("/private").url()));
 
     assertNull(server.takeRequest().getHeader("Authorization"));
     assertEquals("oauthed abc123", server.takeRequest().getHeader("Authorization"));
@@ -2942,8 +3047,10 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
 
     RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator(
         Credentials.basic("jesse", "peanutbutter"));
-    client.client().setAuthenticator(authenticator);
-    assertContent("c", client.open(server.url("/a").url()));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .authenticator(authenticator)
+        .build());
+    assertContent("c", urlFactory.open(server.url("/a").url()));
 
     Response challengeResponse = authenticator.responses.get(0);
     assertEquals("/b", challengeResponse.request().url().url().getPath());
@@ -2959,9 +3066,11 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
     server.enqueue(new MockResponse().setBody("Success!"));
 
     String credential = Credentials.basic("jesse", "peanutbutter");
-    client.client().setAuthenticator(new RecordingOkAuthenticator(credential));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .authenticator(new RecordingOkAuthenticator(credential))
+        .build());
 
-    connection = client.open(server.url("/0").url());
+    connection = urlFactory.open(server.url("/0").url());
     assertContent("Success!", connection);
   }
 
@@ -2971,9 +3080,11 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
     }
 
     String credential = Credentials.basic("jesse", "peanutbutter");
-    client.client().setAuthenticator(new RecordingOkAuthenticator(credential));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .authenticator(new RecordingOkAuthenticator(credential))
+        .build());
 
-    connection = client.open(server.url("/").url());
+    connection = urlFactory.open(server.url("/").url());
     try {
       connection.getInputStream();
       fail();
@@ -2994,8 +3105,10 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
   private void setsNegotiatedProtocolHeader(Protocol protocol) throws IOException {
     enableProtocol(protocol);
     server.enqueue(new MockResponse().setBody("A"));
-    client.client().setProtocols(Arrays.asList(protocol, Protocol.HTTP_1_1));
-    connection = client.open(server.url("/").url());
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .protocols(Arrays.asList(protocol, Protocol.HTTP_1_1))
+        .build());
+    connection = urlFactory.open(server.url("/").url());
     List<String> protocolValues = connection.getHeaderFields().get(SELECTED_PROTOCOL);
     assertEquals(Arrays.asList(protocol.toString()), protocolValues);
     assertContent("A", connection);
@@ -3003,14 +3116,14 @@ private void setsNegotiatedProtocolHeader(Protocol protocol) throws IOException
 
   @Test public void http10SelectedProtocol() throws Exception {
     server.enqueue(new MockResponse().setStatus("HTTP/1.0 200 OK"));
-    connection = client.open(server.url("/").url());
+    connection = urlFactory.open(server.url("/").url());
     List<String> protocolValues = connection.getHeaderFields().get(SELECTED_PROTOCOL);
     assertEquals(Arrays.asList("http/1.0"), protocolValues);
   }
 
   @Test public void http11SelectedProtocol() throws Exception {
     server.enqueue(new MockResponse().setStatus("HTTP/1.1 200 OK"));
-    connection = client.open(server.url("/").url());
+    connection = urlFactory.open(server.url("/").url());
     List<String> protocolValues = connection.getHeaderFields().get(SELECTED_PROTOCOL);
     assertEquals(Arrays.asList("http/1.1"), protocolValues);
   }
@@ -3048,7 +3161,7 @@ private void setsNegotiatedProtocolHeader(Protocol protocol) throws IOException
   private void zeroLengthPayload(String method)
       throws IOException, InterruptedException {
     server.enqueue(new MockResponse());
-    connection = client.open(server.url("/").url());
+    connection = urlFactory.open(server.url("/").url());
     connection.setRequestProperty("Content-Length", "0");
     connection.setRequestMethod(method);
     connection.setFixedLengthStreamingMode(0);
@@ -3063,7 +3176,7 @@ private void zeroLengthPayload(String method)
   @Test public void unspecifiedRequestBodyContentTypeGetsDefault() throws Exception {
     server.enqueue(new MockResponse());
 
-    connection = client.open(server.url("/").url());
+    connection = urlFactory.open(server.url("/").url());
     connection.setDoOutput(true);
     connection.getOutputStream().write("abc".getBytes(UTF_8));
     assertEquals(200, connection.getResponseCode());
@@ -3076,13 +3189,15 @@ private void zeroLengthPayload(String method)
 
   @Test public void setProtocols() throws Exception {
     server.enqueue(new MockResponse().setBody("A"));
-    client.client().setProtocols(Arrays.asList(Protocol.HTTP_1_1));
-    assertContent("A", client.open(server.url("/").url()));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .protocols(Arrays.asList(Protocol.HTTP_1_1))
+        .build());
+    assertContent("A", urlFactory.open(server.url("/").url()));
   }
 
   @Test public void setProtocolsWithoutHttp11() throws Exception {
     try {
-      client.client().setProtocols(Arrays.asList(Protocol.SPDY_3));
+      new OkHttpClient.Builder().protocols(Arrays.asList(Protocol.SPDY_3));
       fail();
     } catch (IllegalArgumentException expected) {
     }
@@ -3090,7 +3205,7 @@ private void zeroLengthPayload(String method)
 
   @Test public void setProtocolsWithNull() throws Exception {
     try {
-      client.client().setProtocols(Arrays.asList(Protocol.HTTP_1_1, null));
+      new OkHttpClient.Builder().protocols(Arrays.asList(Protocol.HTTP_1_1, null));
       fail();
     } catch (IllegalArgumentException expected) {
     }
@@ -3100,7 +3215,7 @@ private void zeroLengthPayload(String method)
     server.setBodyLimit(0);
     server.enqueue(new MockResponse());
 
-    connection = client.open(server.url("/").url());
+    connection = urlFactory.open(server.url("/").url());
     connection.setDoOutput(true);
     long contentLength = Integer.MAX_VALUE + 1L;
     connection.setFixedLengthStreamingMode(contentLength);
@@ -3118,10 +3233,9 @@ private void zeroLengthPayload(String method)
   }
 
   /**
-   * We had a bug where we attempted to gunzip responses that didn't have a
-   * body. This only came up with 304s since that response code can include
-   * headers (like "Content-Encoding") without any content to go along with it.
-   * https://github.com/square/okhttp/issues/358
+   * We had a bug where we attempted to gunzip responses that didn't have a body. This only came up
+   * with 304s since that response code can include headers (like "Content-Encoding") without any
+   * content to go along with it. https://github.com/square/okhttp/issues/358
    */
   @Test public void noTransparentGzipFor304NotModified() throws Exception {
     server.enqueue(new MockResponse()
@@ -3130,11 +3244,11 @@ private void zeroLengthPayload(String method)
         .addHeader("Content-Encoding: gzip"));
     server.enqueue(new MockResponse().setBody("b"));
 
-    HttpURLConnection connection1 = client.open(server.url("/").url());
+    HttpURLConnection connection1 = urlFactory.open(server.url("/").url());
     assertEquals(HttpURLConnection.HTTP_NOT_MODIFIED, connection1.getResponseCode());
     assertContent("", connection1);
 
-    HttpURLConnection connection2 = client.open(server.url("/").url());
+    HttpURLConnection connection2 = urlFactory.open(server.url("/").url());
     assertEquals(HttpURLConnection.HTTP_OK, connection2.getResponseCode());
     assertContent("b", connection2);
 
@@ -3157,7 +3271,7 @@ private void zeroLengthPayload(String method)
         .setBody(gzip("Moved! Moved! Moved!")));
     server.enqueue(new MockResponse().setBody("This is the new page!"));
 
-    HttpURLConnection connection = client.open(server.url("/").url());
+    HttpURLConnection connection = urlFactory.open(server.url("/").url());
     assertContent("This is the new page!", connection);
 
     RecordedRequest requestA = server.takeRequest();
@@ -3168,13 +3282,13 @@ private void zeroLengthPayload(String method)
   }
 
   /**
-   * The RFC is unclear in this regard as it only specifies that this should
-   * invalidate the cache entry (if any).
+   * The RFC is unclear in this regard as it only specifies that this should invalidate the cache
+   * entry (if any).
    */
   @Test public void bodyPermittedOnDelete() throws Exception {
     server.enqueue(new MockResponse());
 
-    HttpURLConnection connection = client.open(server.url("/").url());
+    HttpURLConnection connection = urlFactory.open(server.url("/").url());
     connection.setRequestMethod("DELETE");
     connection.setDoOutput(true);
     connection.getOutputStream().write("BODY".getBytes(UTF_8));
@@ -3189,7 +3303,7 @@ private void zeroLengthPayload(String method)
     server.enqueue(new MockResponse().setBody("abc"));
 
     System.setProperty("http.agent", "foo");
-    assertContent("abc", client.open(server.url("/").url()));
+    assertContent("abc", urlFactory.open(server.url("/").url()));
 
     RecordedRequest request = server.takeRequest();
     assertEquals("foo", request.getHeader("User-Agent"));
@@ -3200,7 +3314,7 @@ private void zeroLengthPayload(String method)
     server.enqueue(new MockResponse().setBody("abc"));
 
     System.setProperty("http.agent", "a\nb\ud83c\udf69c\ud83c\udf68d\u007fe");
-    assertContent("abc", client.open(server.url("/").url()));
+    assertContent("abc", urlFactory.open(server.url("/").url()));
 
     RecordedRequest request = server.takeRequest();
     assertEquals("a?b?c?d?e", request.getHeader("User-Agent"));
@@ -3209,7 +3323,7 @@ private void zeroLengthPayload(String method)
   @Test public void userAgentDefaultsToOkHttpVersion() throws Exception {
     server.enqueue(new MockResponse().setBody("abc"));
 
-    assertContent("abc", client.open(server.url("/").url()));
+    assertContent("abc", urlFactory.open(server.url("/").url()));
 
     RecordedRequest request = server.takeRequest();
     assertEquals(Version.userAgent(), request.getHeader("User-Agent"));
@@ -3221,15 +3335,17 @@ private void zeroLengthPayload(String method)
         throw new AssertionError();
       }
     };
-    client.client().interceptors().add(interceptor);
-    client.client().networkInterceptors().add(interceptor);
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .addInterceptor(interceptor)
+        .addNetworkInterceptor(interceptor)
+        .build());
 
     server.enqueue(new MockResponse().setBody("abc"));
-    assertContent("abc", client.open(server.url("/").url()));
+    assertContent("abc", urlFactory.open(server.url("/").url()));
   }
 
   @Test public void urlWithSpaceInHost() throws Exception {
-    URLConnection urlConnection = client.open(new URL("http://and roid.com/"));
+    URLConnection urlConnection = urlFactory.open(new URL("http://and roid.com/"));
     try {
       urlConnection.getInputStream();
       fail();
@@ -3240,7 +3356,7 @@ private void zeroLengthPayload(String method)
   @Test public void urlWithSpaceInHostViaHttpProxy() throws Exception {
     server.enqueue(new MockResponse());
     URLConnection urlConnection =
-        client.open(new URL("http://and roid.com/"), server.toProxyAddress());
+        urlFactory.open(new URL("http://and roid.com/"), server.toProxyAddress());
 
     try {
       // This test is to check that a NullPointerException is not thrown.
@@ -3251,7 +3367,7 @@ private void zeroLengthPayload(String method)
   }
 
   @Test public void urlHostWithNul() throws Exception {
-    URLConnection urlConnection = client.open(new URL("http://host\u0000/"));
+    URLConnection urlConnection = urlFactory.open(new URL("http://host\u0000/"));
     try {
       urlConnection.getInputStream();
       fail();
@@ -3264,13 +3380,13 @@ private void zeroLengthPayload(String method)
     server.enqueue(new MockResponse().setResponseCode(302)
         .addHeaderLenient("Location", redirectUrl));
 
-    HttpURLConnection urlConnection = client.open(server.url("/").url());
+    HttpURLConnection urlConnection = urlFactory.open(server.url("/").url());
     assertEquals(302, urlConnection.getResponseCode());
     assertEquals(redirectUrl, urlConnection.getHeaderField("Location"));
   }
 
   @Test public void urlWithBadAsciiHost() throws Exception {
-    URLConnection urlConnection = client.open(new URL("http://host\u0001/"));
+    URLConnection urlConnection = urlFactory.open(new URL("http://host\u0001/"));
     try {
       urlConnection.getInputStream();
       fail();
@@ -3285,7 +3401,7 @@ private void zeroLengthPayload(String method)
 
   private void testInstanceFollowsRedirects(String spec) throws Exception {
     URL url = new URL(spec);
-    HttpURLConnection urlConnection = client.open(url);
+    HttpURLConnection urlConnection = urlFactory.open(url);
     urlConnection.setInstanceFollowRedirects(true);
     assertTrue(urlConnection.getInstanceFollowRedirects());
     urlConnection.setInstanceFollowRedirects(false);
@@ -3302,8 +3418,8 @@ public Buffer gzip(String data) throws IOException {
   }
 
   /**
-   * Reads at most {@code limit} characters from {@code in} and asserts that
-   * content equals {@code expected}.
+   * Reads at most {@code limit} characters from {@code in} and asserts that content equals {@code
+   * expected}.
    */
   private void assertContent(String expected, HttpURLConnection connection, int limit)
       throws IOException {
@@ -3325,6 +3441,7 @@ private void assertContent(String expected, HttpURLConnection connection) throws
           throws IOException {
         response.setChunkedBody(content, chunkSize);
       }
+
       @Override void setForRequest(HttpURLConnection connection, int contentLength) {
         connection.setChunkedStreamingMode(5);
       }
@@ -3333,6 +3450,7 @@ private void assertContent(String expected, HttpURLConnection connection) throws
       @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
         response.setBody(content);
       }
+
       @Override void setForRequest(HttpURLConnection connection, int contentLength) {
         connection.setFixedLengthStreamingMode(contentLength);
       }
@@ -3343,6 +3461,7 @@ private void assertContent(String expected, HttpURLConnection connection) throws
         response.setSocketPolicy(DISCONNECT_AT_END);
         response.removeHeader("Content-Length");
       }
+
       @Override void setForRequest(HttpURLConnection connection, int contentLength) {
       }
     };
@@ -3361,7 +3480,9 @@ void setBody(MockResponse response, String content, int chunkSize) throws IOExce
       @Override public HttpURLConnection connect(
           MockWebServer server, OkUrlFactory streamHandlerFactory, URL url)
           throws IOException {
-        streamHandlerFactory.client().setProxy(Proxy.NO_PROXY);
+        streamHandlerFactory.setClient(streamHandlerFactory.client().newBuilder()
+            .proxy(Proxy.NO_PROXY)
+            .build());
         return streamHandlerFactory.open(url);
       }
     },
@@ -3370,7 +3491,9 @@ void setBody(MockResponse response, String content, int chunkSize) throws IOExce
       @Override public HttpURLConnection connect(
           MockWebServer server, OkUrlFactory streamHandlerFactory, URL url)
           throws IOException {
-        streamHandlerFactory.client().setProxy(server.toProxyAddress());
+        streamHandlerFactory.setClient(streamHandlerFactory.client().newBuilder()
+            .proxy(server.toProxyAddress())
+            .build());
         return streamHandlerFactory.open(url);
       }
     },
@@ -3414,7 +3537,7 @@ public abstract HttpURLConnection connect(
     private final List<String> calls = new ArrayList<String>();
 
     public X509Certificate[] getAcceptedIssuers() {
-      return new X509Certificate[] { };
+      return new X509Certificate[] {};
     }
 
     public void checkClientTrusted(X509Certificate[] chain, String authType)
@@ -3436,40 +3559,27 @@ private String certificatesToString(X509Certificate[] certificates) {
     }
   }
 
-  private static class FakeProxySelector extends ProxySelector {
-    List<Proxy> proxies = new ArrayList<>();
-
-    @Override public List<Proxy> select(URI uri) {
-      // Don't handle 'socket' schemes, which the RI's Socket class may request (for SOCKS).
-      return uri.getScheme().equals("http") || uri.getScheme().equals("https") ? proxies
-          : Collections.singletonList(Proxy.NO_PROXY);
-    }
-
-    @Override public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {
-    }
-  }
-
   /**
    * Tests that use this will fail unless boot classpath is set. Ex. {@code
    * -Xbootclasspath/p:/tmp/alpn-boot-8.0.0.v20140317}
    */
   private void enableProtocol(Protocol protocol) {
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
-    client.client().setProtocols(Arrays.asList(protocol, Protocol.HTTP_1_1));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .protocols(Arrays.asList(protocol, Protocol.HTTP_1_1))
+        .build());
     server.useHttps(sslContext.getSocketFactory(), false);
     server.setProtocolNegotiationEnabled(true);
-    server.setProtocols(client.client().getProtocols());
+    server.setProtocols(urlFactory.client().protocols());
   }
 
   /**
    * Used during tests that involve TLS connection fallback attempts. OkHttp includes the
-   * TLS_FALLBACK_SCSV cipher on fallback connections. See
-   * {@link FallbackTestClientSocketFactory} for details.
+   * TLS_FALLBACK_SCSV cipher on fallback connections. See {@link FallbackTestClientSocketFactory}
+   * for details.
    */
-  private void suppressTlsFallbackScsv(OkHttpClient client) {
-    FallbackTestClientSocketFactory clientSocketFactory =
-        new FallbackTestClientSocketFactory(sslContext.getSocketFactory());
-    client.setSslSocketFactory(clientSocketFactory);
+  private FallbackTestClientSocketFactory suppressTlsFallbackClientSocketFactory() {
+    return new FallbackTestClientSocketFactory(sslContext.getSocketFactory());
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/UrlComponentEncodingTester.java b/okhttp-tests/src/test/java/okhttp3/UrlComponentEncodingTester.java
index 65b80e149f..1645acc907 100644
--- a/okhttp-tests/src/test/java/okhttp3/UrlComponentEncodingTester.java
+++ b/okhttp-tests/src/test/java/okhttp3/UrlComponentEncodingTester.java
@@ -38,6 +38,7 @@
    * See https://url.spec.whatwg.org/#percent-encoded-bytes
    */
   private static final Map<Integer, Encoding> defaultEncodings;
+
   static {
     Map<Integer, Encoding> map = new LinkedHashMap<>();
     map.put(       0x0, Encoding.PERCENT); // Null character
@@ -278,7 +279,7 @@ private void testFromUrl(int codePoint, Encoding encoding, Component component)
 
   private void testUri(
       int codePoint, Encoding encoding, Component component, boolean uriEscaped) {
-    String string = new String(new int[] { codePoint }, 0, 1);
+    String string = new String(new int[] {codePoint}, 0, 1);
     String encoded = encoding.encode(codePoint);
     HttpUrl httpUrl = HttpUrl.parse(component.urlString(encoded));
     URI uri = httpUrl.uri();
@@ -305,7 +306,7 @@ private void testUri(
   public enum Encoding {
     IDENTITY {
       public String encode(int codePoint) {
-        return new String(new int[] { codePoint }, 0, 1);
+        return new String(new int[] {codePoint}, 0, 1);
       }
     },
 
@@ -332,12 +333,15 @@ public String encode(int codePoint) {
       @Override public String urlString(String value) {
         return "http://" + value + "@example.com/";
       }
+
       @Override public String encodedValue(HttpUrl url) {
         return url.encodedUsername();
       }
+
       @Override public void set(HttpUrl.Builder builder, String value) {
         builder.username(value);
       }
+
       @Override public String get(HttpUrl url) {
         return url.username();
       }
@@ -346,12 +350,15 @@ public String encode(int codePoint) {
       @Override public String urlString(String value) {
         return "http://:" + value + "@example.com/";
       }
+
       @Override public String encodedValue(HttpUrl url) {
         return url.encodedPassword();
       }
+
       @Override public void set(HttpUrl.Builder builder, String value) {
         builder.password(value);
       }
+
       @Override public String get(HttpUrl url) {
         return url.password();
       }
@@ -360,13 +367,16 @@ public String encode(int codePoint) {
       @Override public String urlString(String value) {
         return "http://example.com/a" + value + "z/";
       }
+
       @Override public String encodedValue(HttpUrl url) {
         String path = url.encodedPath();
         return path.substring(2, path.length() - 2);
       }
+
       @Override public void set(HttpUrl.Builder builder, String value) {
         builder.addPathSegment("a" + value + "z");
       }
+
       @Override public String get(HttpUrl url) {
         String pathSegment = url.pathSegments().get(0);
         return pathSegment.substring(1, pathSegment.length() - 1);
@@ -376,13 +386,16 @@ public String encode(int codePoint) {
       @Override public String urlString(String value) {
         return "http://example.com/?a" + value + "z";
       }
+
       @Override public String encodedValue(HttpUrl url) {
         String query = url.encodedQuery();
         return query.substring(1, query.length() - 1);
       }
+
       @Override public void set(HttpUrl.Builder builder, String value) {
         builder.query("a" + value + "z");
       }
+
       @Override public String get(HttpUrl url) {
         String query = url.query();
         return query.substring(1, query.length() - 1);
@@ -392,13 +405,16 @@ public String encode(int codePoint) {
       @Override public String urlString(String value) {
         return "http://example.com/#a" + value + "z";
       }
+
       @Override public String encodedValue(HttpUrl url) {
         String fragment = url.encodedFragment();
         return fragment.substring(1, fragment.length() - 1);
       }
+
       @Override public void set(HttpUrl.Builder builder, String value) {
         builder.fragment("a" + value + "z");
       }
+
       @Override public String get(HttpUrl url) {
         String fragment = url.fragment();
         return fragment.substring(1, fragment.length() - 1);
diff --git a/okhttp-tests/src/test/java/okhttp3/WebPlatformUrlTest.java b/okhttp-tests/src/test/java/okhttp3/WebPlatformUrlTest.java
index a6205e9f8f..a15c57ea35 100644
--- a/okhttp-tests/src/test/java/okhttp3/WebPlatformUrlTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/WebPlatformUrlTest.java
@@ -15,10 +15,10 @@
  */
 package okhttp3;
 
-import okhttp3.internal.Util;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
+import okhttp3.internal.Util;
 import okio.BufferedSource;
 import okio.Okio;
 import org.junit.Test;
@@ -38,7 +38,7 @@
     try {
       List<Object[]> result = new ArrayList<>();
       for (WebPlatformUrlTestData urlTestData : loadTests()) {
-        result.add(new Object[] { urlTestData });
+        result.add(new Object[] {urlTestData});
       }
       return result;
     } catch (IOException e) {
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ConnectionSpecSelectorTest.java b/okhttp-tests/src/test/java/okhttp3/internal/ConnectionSpecSelectorTest.java
index e01ffdb8de..b6aa5344c2 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/ConnectionSpecSelectorTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/ConnectionSpecSelectorTest.java
@@ -15,8 +15,6 @@
  */
 package okhttp3.internal;
 
-import okhttp3.ConnectionSpec;
-import okhttp3.TlsVersion;
 import java.io.IOException;
 import java.security.cert.CertificateException;
 import java.util.Arrays;
@@ -25,6 +23,8 @@
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLHandshakeException;
 import javax.net.ssl.SSLSocket;
+import okhttp3.ConnectionSpec;
+import okhttp3.TlsVersion;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
@@ -91,7 +91,7 @@ public void someFallbacksSupported() throws Exception {
     ConnectionSpecSelector connectionSpecSelector = createConnectionSpecSelector(
         ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS, sslV3);
 
-    TlsVersion[] enabledSocketTlsVersions = { TlsVersion.TLS_1_1, TlsVersion.TLS_1_0 };
+    TlsVersion[] enabledSocketTlsVersions = {TlsVersion.TLS_1_1, TlsVersion.TLS_1_0};
     SSLSocket socket = createSocketWithEnabledProtocols(enabledSocketTlsVersions);
 
     // MODERN_TLS is used here.
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/DiskLruCacheTest.java b/okhttp-tests/src/test/java/okhttp3/internal/DiskLruCacheTest.java
index 1895bb38f4..955214068e 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/DiskLruCacheTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/DiskLruCacheTest.java
@@ -15,7 +15,6 @@
  */
 package okhttp3.internal;
 
-import okhttp3.internal.io.FileSystem;
 import java.io.File;
 import java.io.IOException;
 import java.util.ArrayDeque;
@@ -26,6 +25,7 @@
 import java.util.List;
 import java.util.NoSuchElementException;
 import java.util.concurrent.Executor;
+import okhttp3.internal.io.FileSystem;
 import okio.BufferedSink;
 import okio.BufferedSource;
 import okio.Okio;
@@ -282,8 +282,8 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
   }
 
   /**
-   * Each read sees a snapshot of the file at the time read was called.
-   * This means that two reads of the same key can see different data.
+   * Each read sees a snapshot of the file at the time read was called. This means that two reads of
+   * the same key can see different data.
    */
   @Test public void readAndWriteOverlapsMaintainConsistency() throws Exception {
     DiskLruCache.Editor v1Creator = cache.edit("k1");
@@ -859,9 +859,8 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
   }
 
   /**
-   * We had a long-lived bug where {@link DiskLruCache#trimToSize} could
-   * infinite loop if entries being edited required deletion for the operation
-   * to complete.
+   * We had a long-lived bug where {@link DiskLruCache#trimToSize} could infinite loop if entries
+   * being edited required deletion for the operation to complete.
    */
   @Test public void trimToSizeWithActiveEdit() throws Exception {
     set("a", "a1234", "a1234");
@@ -1275,7 +1274,8 @@ private void set(String key, String value0, String value1) throws Exception {
     editor.commit();
   }
 
-  public static void setString(DiskLruCache.Editor editor, int index, String value) throws IOException {
+  public static void setString(DiskLruCache.Editor editor, int index, String value)
+      throws IOException {
     BufferedSink writer = Okio.buffer(editor.newSink(index));
     writer.writeUtf8(value);
     writer.close();
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/DoubleInetAddressDns.java b/okhttp-tests/src/test/java/okhttp3/internal/DoubleInetAddressDns.java
index 929eccffc7..7811ff5d75 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/DoubleInetAddressDns.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/DoubleInetAddressDns.java
@@ -15,11 +15,11 @@
  */
 package okhttp3.internal;
 
-import okhttp3.Dns;
 import java.net.InetAddress;
 import java.net.UnknownHostException;
 import java.util.Arrays;
 import java.util.List;
+import okhttp3.Dns;
 
 /**
  * A network that always resolves two IP addresses per host. Use this when testing route selection
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/FaultyFileSystem.java b/okhttp-tests/src/test/java/okhttp3/internal/FaultyFileSystem.java
index 4eb260bdbe..22b1758227 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/FaultyFileSystem.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/FaultyFileSystem.java
@@ -15,12 +15,12 @@
  */
 package okhttp3.internal;
 
-import okhttp3.internal.io.FileSystem;
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.util.LinkedHashSet;
 import java.util.Set;
+import okhttp3.internal.io.FileSystem;
 import okio.Buffer;
 import okio.ForwardingSink;
 import okio.Sink;
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/OptionalMethodTest.java b/okhttp-tests/src/test/java/okhttp3/internal/OptionalMethodTest.java
index aa4a0a4cce..08e025c5d9 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/OptionalMethodTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/OptionalMethodTest.java
@@ -17,10 +17,9 @@
 
 package okhttp3.internal;
 
-import org.junit.Test;
-
 import java.io.IOException;
 import java.lang.reflect.InvocationTargetException;
+import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
@@ -38,7 +37,8 @@ public String stringMethod() {
       return "string";
     }
 
-    public void voidMethod() {}
+    public void voidMethod() {
+    }
   }
 
   @SuppressWarnings("unused")
@@ -70,7 +70,8 @@ public void throwsRuntimeException() throws Exception {
       throw new NumberFormatException();
     }
 
-    protected void nonPublic() {}
+    protected void nonPublic() {
+    }
   }
 
   private final static OptionalMethod<BaseClass> STRING_METHOD_RETURNS_ANY =
@@ -194,8 +195,10 @@ public void invokeBadArgs() throws Exception {
     assertIllegalArgumentExceptionOnInvoke(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1); // no args
     assertIllegalArgumentExceptionOnInvoke(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1, 123);
     assertIllegalArgumentExceptionOnInvoke(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1, true);
-    assertIllegalArgumentExceptionOnInvoke(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1, new Object());
-    assertIllegalArgumentExceptionOnInvoke(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1, "one", "two");
+    assertIllegalArgumentExceptionOnInvoke(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1,
+        new Object());
+    assertIllegalArgumentExceptionOnInvoke(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1, "one",
+        "two");
   }
 
   @Test
@@ -268,11 +271,15 @@ public void invokeOptional() throws Exception {
   @Test
   public void invokeOptionalBadArgs() throws Exception {
     SubClass1 subClass1 = new SubClass1();
-    assertIllegalArgumentExceptionOnInvokeOptional(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1); // no args
+    assertIllegalArgumentExceptionOnInvokeOptional(METHOD_WITH_ARGS_CORRECT_PARAMS,
+        subClass1); // no args
     assertIllegalArgumentExceptionOnInvokeOptional(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1, 123);
-    assertIllegalArgumentExceptionOnInvokeOptional(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1, true);
-    assertIllegalArgumentExceptionOnInvokeOptional(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1, new Object());
-    assertIllegalArgumentExceptionOnInvokeOptional(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1, "one", "two");
+    assertIllegalArgumentExceptionOnInvokeOptional(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1,
+        true);
+    assertIllegalArgumentExceptionOnInvokeOptional(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1,
+        new Object());
+    assertIllegalArgumentExceptionOnInvokeOptional(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1,
+        "one", "two");
   }
 
   @Test
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/SingleInetAddressDns.java b/okhttp-tests/src/test/java/okhttp3/internal/SingleInetAddressDns.java
index 225fee9e6f..03e8ce08e9 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/SingleInetAddressDns.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/SingleInetAddressDns.java
@@ -15,16 +15,15 @@
  */
 package okhttp3.internal;
 
-import okhttp3.Dns;
 import java.net.InetAddress;
 import java.net.UnknownHostException;
 import java.util.Collections;
 import java.util.List;
+import okhttp3.Dns;
 
 /**
- * A network that resolves only one IP address per host. Use this when testing
- * route selection fallbacks to prevent the host machine's various IP addresses
- * from interfering.
+ * A network that resolves only one IP address per host. Use this when testing route selection
+ * fallbacks to prevent the host machine's various IP addresses from interfering.
  */
 public class SingleInetAddressDns implements Dns {
   @Override public List<InetAddress> lookup(String hostname) throws UnknownHostException {
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/framed/HpackTest.java b/okhttp-tests/src/test/java/okhttp3/internal/framed/HpackTest.java
index 70c10ec25f..068ab647e7 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/framed/HpackTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/framed/HpackTest.java
@@ -41,8 +41,8 @@
   }
 
   /**
-   * Variable-length quantity special cases strings which are longer than 127
-   * bytes.  Values such as cookies can be 4KiB, and should be possible to send.
+   * Variable-length quantity special cases strings which are longer than 127 bytes.  Values such as
+   * cookies can be 4KiB, and should be possible to send.
    *
    * <p> http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#section-5.2
    */
@@ -61,8 +61,8 @@
   }
 
   /**
-   * HPACK has a max header table size, which can be smaller than the max header message.
-   * Ensure the larger header content is not lost.
+   * HPACK has a max header table size, which can be smaller than the max header message. Ensure the
+   * larger header content is not lost.
    */
   @Test public void tooLargeToHPackIsStillEmitted() throws IOException {
     bytesIn.writeByte(0x00); // Literal indexed
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/framed/Http2Test.java b/okhttp-tests/src/test/java/okhttp3/internal/framed/Http2Test.java
index 7d1cc0c1a7..0ae2f31c78 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/framed/Http2Test.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/framed/Http2Test.java
@@ -15,17 +15,17 @@
  */
 package okhttp3.internal.framed;
 
-import okhttp3.internal.Util;
 import java.io.IOException;
 import java.util.Arrays;
 import java.util.List;
+import java.util.concurrent.atomic.AtomicInteger;
+import okhttp3.internal.Util;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
 import okio.ByteString;
 import okio.GzipSink;
 import okio.Okio;
-import org.junit.Assert;
 import org.junit.Test;
 
 import static okhttp3.TestUtil.headerEntries;
@@ -269,7 +269,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     }
   }
 
-  @Test public void readSettingsFrameInvalidSettingId() throws IOException {
+  @Test public void readSettingsFrameUnknownSettingId() throws IOException {
     writeMedium(frame, 6); // 2 for the code and 4 for the value
     frame.writeByte(Http2.TYPE_SETTINGS);
     frame.writeByte(Http2.FLAG_NONE);
@@ -277,12 +277,13 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.writeShort(7); // old number for SETTINGS_INITIAL_WINDOW_SIZE
     frame.writeInt(1);
 
-    try {
-      fr.nextFrame(new BaseTestHandler());
-      fail();
-    } catch (IOException e) {
-      assertEquals("PROTOCOL_ERROR invalid settings id: 7", e.getMessage());
-    }
+    final AtomicInteger settingValue = new AtomicInteger();
+    fr.nextFrame(new BaseTestHandler() {
+      @Override public void settings(boolean clearPrevious, Settings settings) {
+        settingValue.set(settings.get(7));
+      }
+    });
+    assertEquals(settingValue.intValue(), 1);
   }
 
   @Test public void readSettingsFrameNegativeWindowSize() throws IOException {
@@ -730,7 +731,7 @@ private static Buffer gzip(byte[] data) throws IOException {
   private static List<Header> largeHeaders() {
     String[] nameValues = new String[32];
     char[] chars = new char[512];
-    for (int i = 0; i < nameValues.length;) {
+    for (int i = 0; i < nameValues.length; ) {
       Arrays.fill(chars, (char) i);
       nameValues[i++] = nameValues[i++] = String.valueOf(chars);
     }
@@ -739,7 +740,7 @@ private static Buffer gzip(byte[] data) throws IOException {
 
   private static void writeMedium(BufferedSink sink, int i) throws IOException {
     sink.writeByte((i >>> 16) & 0xff);
-    sink.writeByte((i >>>  8) & 0xff);
-    sink.writeByte( i         & 0xff);
+    sink.writeByte((i >>> 8) & 0xff);
+    sink.writeByte(i & 0xff);
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/framed/HttpOverHttp2Test.java b/okhttp-tests/src/test/java/okhttp3/internal/framed/HttpOverHttp2Test.java
index ac330e411a..c747f0b7a4 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/framed/HttpOverHttp2Test.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/framed/HttpOverHttp2Test.java
@@ -15,12 +15,14 @@
  */
 package okhttp3.internal.framed;
 
+import okhttp3.Call;
 import okhttp3.Headers;
 import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.Response;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.PushPromise;
 import okhttp3.mockwebserver.RecordedRequest;
-import java.net.HttpURLConnection;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
@@ -35,16 +37,19 @@ public HttpOverHttp2Test() {
   @Test public void serverSendsPushPromise_GET() throws Exception {
     PushPromise pushPromise = new PushPromise("GET", "/foo/bar", Headers.of("foo", "bar"),
         new MockResponse().setBody("bar").setStatus("HTTP/1.1 200 Sweet"));
-    MockResponse response = new MockResponse()
+    server.enqueue(new MockResponse()
         .setBody("ABCDE")
         .setStatus("HTTP/1.1 200 Sweet")
-        .withPush(pushPromise);
-    server.enqueue(response);
+        .withPush(pushPromise));
 
-    connection = client.open(server.url("/foo").url());
-    assertContent("ABCDE", connection, Integer.MAX_VALUE);
-    assertEquals(200, connection.getResponseCode());
-    assertEquals("Sweet", connection.getResponseMessage());
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/foo"))
+        .build());
+    Response response = call.execute();
+
+    assertEquals("ABCDE", response.body().string());
+    assertEquals(200, response.code());
+    assertEquals("Sweet", response.message());
 
     RecordedRequest request = server.takeRequest();
     assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
@@ -59,16 +64,18 @@ public HttpOverHttp2Test() {
   @Test public void serverSendsPushPromise_HEAD() throws Exception {
     PushPromise pushPromise = new PushPromise("HEAD", "/foo/bar", Headers.of("foo", "bar"),
         new MockResponse().setStatus("HTTP/1.1 204 Sweet"));
-    MockResponse response = new MockResponse()
+    server.enqueue(new MockResponse()
         .setBody("ABCDE")
         .setStatus("HTTP/1.1 200 Sweet")
-        .withPush(pushPromise);
-    server.enqueue(response);
+        .withPush(pushPromise));
 
-    connection = client.open(server.url("/foo").url());
-    assertContent("ABCDE", connection, Integer.MAX_VALUE);
-    assertEquals(200, connection.getResponseCode());
-    assertEquals("Sweet", connection.getResponseMessage());
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/foo"))
+        .build());
+    Response response = call.execute();
+    assertEquals("ABCDE", response.body().string());
+    assertEquals(200, response.code());
+    assertEquals("Sweet", response.message());
 
     RecordedRequest request = server.takeRequest();
     assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
@@ -90,22 +97,38 @@ public HttpOverHttp2Test() {
 
     // Read & write a full request to confirm settings are accepted.
     server.enqueue(new MockResponse().withSettings(settings));
-    HttpURLConnection settingsConnection = client.open(server.url("/").url());
-    assertContent("", settingsConnection, Integer.MAX_VALUE);
-
-    server.enqueue(new MockResponse().setBody("ABC"));
-    server.enqueue(new MockResponse().setBody("DEF"));
-    server.enqueue(new MockResponse().setBody("GHI"));
-
-    HttpURLConnection connection1 = client.open(server.url("/").url());
-    connection1.connect();
-    HttpURLConnection connection2 = client.open(server.url("/").url());
-    connection2.connect();
-    HttpURLConnection connection3 = client.open(server.url("/").url());
-    connection3.connect();
-    assertContent("ABC", connection1, Integer.MAX_VALUE);
-    assertContent("DEF", connection2, Integer.MAX_VALUE);
-    assertContent("GHI", connection3, Integer.MAX_VALUE);
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals("", response.body().string());
+
+    server.enqueue(new MockResponse()
+        .setBody("ABC"));
+    server.enqueue(new MockResponse()
+        .setBody("DEF"));
+    server.enqueue(new MockResponse()
+        .setBody("GHI"));
+
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response1 = call1.execute();
+
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+
+    Call call3 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response3 = call3.execute();
+
+    assertEquals("ABC", response1.body().string());
+    assertEquals("DEF", response2.body().string());
+    assertEquals("GHI", response3.body().string());
     assertEquals(0, server.takeRequest().getSequenceNumber()); // Settings connection.
     assertEquals(1, server.takeRequest().getSequenceNumber()); // Reuse settings connection.
     assertEquals(2, server.takeRequest().getSequenceNumber()); // Reuse settings connection.
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/framed/HttpOverSpdyTest.java b/okhttp-tests/src/test/java/okhttp3/internal/framed/HttpOverSpdyTest.java
index fac19015bc..7c27cd29d7 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/framed/HttpOverSpdyTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/framed/HttpOverSpdyTest.java
@@ -15,36 +15,36 @@
  */
 package okhttp3.internal.framed;
 
-import okhttp3.Cache;
-import okhttp3.ConnectionPool;
-import okhttp3.HttpUrl;
-import okhttp3.OkHttpClient;
-import okhttp3.OkUrlFactory;
-import okhttp3.Protocol;
-import okhttp3.internal.RecordingAuthenticator;
-import okhttp3.internal.SslContextBuilder;
-import okhttp3.internal.Util;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.mockwebserver.RecordedRequest;
-import okhttp3.mockwebserver.SocketPolicy;
-import okhttp3.testing.RecordingHostnameVerifier;
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.Authenticator;
-import java.net.CookieManager;
 import java.net.HttpURLConnection;
 import java.net.SocketTimeoutException;
 import java.util.Arrays;
-import java.util.Collections;
-import java.util.List;
-import java.util.Map;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
-import java.util.concurrent.TimeUnit;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLContext;
+import okhttp3.Cache;
+import okhttp3.Call;
+import okhttp3.Cookie;
+import okhttp3.Credentials;
+import okhttp3.MediaType;
+import okhttp3.OkHttpClient;
+import okhttp3.Protocol;
+import okhttp3.RecordingCookieJar;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
+import okhttp3.internal.RecordingOkAuthenticator;
+import okhttp3.internal.SslContextBuilder;
+import okhttp3.internal.Util;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
+import okhttp3.mockwebserver.SocketPolicy;
+import okhttp3.RecordingHostnameVerifier;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.GzipSink;
@@ -56,6 +56,7 @@
 import org.junit.Test;
 import org.junit.rules.TemporaryFolder;
 
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static java.util.concurrent.TimeUnit.SECONDS;
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
@@ -73,20 +74,21 @@
 
   protected SSLContext sslContext = SslContextBuilder.localhost();
   protected HostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-  protected final OkUrlFactory client = new OkUrlFactory(new OkHttpClient());
-  protected HttpURLConnection connection;
+  protected OkHttpClient client;
   protected Cache cache;
 
-  protected HttpOverSpdyTest(Protocol protocol){
+  protected HttpOverSpdyTest(Protocol protocol) {
     this.protocol = protocol;
   }
 
   @Before public void setUp() throws Exception {
     server.useHttps(sslContext.getSocketFactory(), false);
-    client.client().setProtocols(Arrays.asList(protocol, Protocol.HTTP_1_1));
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setHostnameVerifier(hostnameVerifier);
     cache = new Cache(tempDir.getRoot(), Integer.MAX_VALUE);
+    client = new OkHttpClient.Builder()
+        .protocols(Arrays.asList(protocol, Protocol.HTTP_1_1))
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .hostnameVerifier(hostnameVerifier)
+        .build();
   }
 
   @After public void tearDown() throws Exception {
@@ -94,13 +96,18 @@ protected HttpOverSpdyTest(Protocol protocol){
   }
 
   @Test public void get() throws Exception {
-    MockResponse response = new MockResponse().setBody("ABCDE").setStatus("HTTP/1.1 200 Sweet");
-    server.enqueue(response);
+    server.enqueue(new MockResponse()
+        .setBody("ABCDE")
+        .setStatus("HTTP/1.1 200 Sweet"));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/foo"))
+        .build());
+    Response response = call.execute();
 
-    connection = client.open(server.url("/foo").url());
-    assertContent("ABCDE", connection, Integer.MAX_VALUE);
-    assertEquals(200, connection.getResponseCode());
-    assertEquals("Sweet", connection.getResponseMessage());
+    assertEquals("ABCDE", response.body().string());
+    assertEquals(200, response.code());
+    assertEquals("Sweet", response.message());
 
     RecordedRequest request = server.takeRequest();
     assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
@@ -111,8 +118,13 @@ protected HttpOverSpdyTest(Protocol protocol){
   @Test public void emptyResponse() throws IOException {
     server.enqueue(new MockResponse());
 
-    connection = client.open(server.url("/foo").url());
-    assertEquals(-1, connection.getInputStream().read());
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/foo"))
+        .build());
+    Response response = call.execute();
+
+    assertEquals(-1, response.body().byteStream().read());
+    response.body().close();
   }
 
   byte[] postBytes = "FGHIJ".getBytes(Util.UTF_8);
@@ -120,11 +132,21 @@ protected HttpOverSpdyTest(Protocol protocol){
   @Test public void noDefaultContentLengthOnStreamingPost() throws Exception {
     server.enqueue(new MockResponse().setBody("ABCDE"));
 
-    connection = client.open(server.url("/foo").url());
-    connection.setDoOutput(true);
-    connection.setChunkedStreamingMode(0);
-    connection.getOutputStream().write(postBytes);
-    assertContent("ABCDE", connection, Integer.MAX_VALUE);
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/foo"))
+        .post(new RequestBody() {
+          @Override public MediaType contentType() {
+            return MediaType.parse("text/plain; charset=utf-8");
+          }
+
+          @Override public void writeTo(BufferedSink sink) throws IOException {
+            sink.write(postBytes);
+          }
+        })
+        .build());
+
+    Response response = call.execute();
+    assertEquals("ABCDE", response.body().string());
 
     RecordedRequest request = server.takeRequest();
     assertEquals("POST /foo HTTP/1.1", request.getRequestLine());
@@ -135,11 +157,25 @@ protected HttpOverSpdyTest(Protocol protocol){
   @Test public void userSuppliedContentLengthHeader() throws Exception {
     server.enqueue(new MockResponse().setBody("ABCDE"));
 
-    connection = client.open(server.url("/foo").url());
-    connection.setRequestProperty("Content-Length", String.valueOf(postBytes.length));
-    connection.setDoOutput(true);
-    connection.getOutputStream().write(postBytes);
-    assertContent("ABCDE", connection, Integer.MAX_VALUE);
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/foo"))
+        .post(new RequestBody() {
+          @Override public MediaType contentType() {
+            return MediaType.parse("text/plain; charset=utf-8");
+          }
+
+          @Override public long contentLength() throws IOException {
+            return postBytes.length;
+          }
+
+          @Override public void writeTo(BufferedSink sink) throws IOException {
+            sink.write(postBytes);
+          }
+        })
+        .build());
+
+    Response response = call.execute();
+    assertEquals("ABCDE", response.body().string());
 
     RecordedRequest request = server.takeRequest();
     assertEquals("POST /foo HTTP/1.1", request.getRequestLine());
@@ -150,28 +186,27 @@ protected HttpOverSpdyTest(Protocol protocol){
   @Test public void closeAfterFlush() throws Exception {
     server.enqueue(new MockResponse().setBody("ABCDE"));
 
-    connection = client.open(server.url("/foo").url());
-    connection.setRequestProperty("Content-Length", String.valueOf(postBytes.length));
-    connection.setDoOutput(true);
-    connection.getOutputStream().write(postBytes); // push bytes into SpdyDataOutputStream.buffer
-    connection.getOutputStream().flush(); // FramedConnection.writeData subject to write window
-    connection.getOutputStream().close(); // FramedConnection.writeData empty frame
-    assertContent("ABCDE", connection, Integer.MAX_VALUE);
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/foo"))
+        .post(new RequestBody() {
+          @Override public MediaType contentType() {
+            return MediaType.parse("text/plain; charset=utf-8");
+          }
 
-    RecordedRequest request = server.takeRequest();
-    assertEquals("POST /foo HTTP/1.1", request.getRequestLine());
-    assertArrayEquals(postBytes, request.getBody().readByteArray());
-    assertEquals(postBytes.length, Integer.parseInt(request.getHeader("Content-Length")));
-  }
+          @Override public long contentLength() throws IOException {
+            return postBytes.length;
+          }
 
-  @Test public void setFixedLengthStreamingModeSetsContentLength() throws Exception {
-    server.enqueue(new MockResponse().setBody("ABCDE"));
+          @Override public void writeTo(BufferedSink sink) throws IOException {
+            sink.write(postBytes);  // push bytes into SpdyDataOutputStream.buffer
+            sink.flush(); // FramedConnection.writeData subject to write window
+            sink.close(); // FramedConnection.writeData empty frame
+          }
+        })
+        .build());
 
-    connection = client.open(server.url("/foo").url());
-    connection.setFixedLengthStreamingMode(postBytes.length);
-    connection.setDoOutput(true);
-    connection.getOutputStream().write(postBytes);
-    assertContent("ABCDE", connection, Integer.MAX_VALUE);
+    Response response = call.execute();
+    assertEquals("ABCDE", response.body().string());
 
     RecordedRequest request = server.takeRequest();
     assertEquals("POST /foo HTTP/1.1", request.getRequestLine());
@@ -183,12 +218,19 @@ protected HttpOverSpdyTest(Protocol protocol){
     server.enqueue(new MockResponse().setBody("ABCDEF"));
     server.enqueue(new MockResponse().setBody("GHIJKL"));
 
-    HttpURLConnection connection1 = client.open(server.url("/r1").url());
-    HttpURLConnection connection2 = client.open(server.url("/r2").url());
-    assertEquals("ABC", readAscii(connection1.getInputStream(), 3));
-    assertEquals("GHI", readAscii(connection2.getInputStream(), 3));
-    assertEquals("DEF", readAscii(connection1.getInputStream(), 3));
-    assertEquals("JKL", readAscii(connection2.getInputStream(), 3));
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/r1"))
+        .build());
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/r1"))
+        .build());
+    Response response1 = call1.execute();
+    Response response2 = call2.execute();
+
+    assertEquals("ABC", response1.body().source().readUtf8(3));
+    assertEquals("GHI", response2.body().source().readUtf8(3));
+    assertEquals("DEF", response1.body().source().readUtf8(3));
+    assertEquals("JKL", response2.body().source().readUtf8(3));
     assertEquals(0, server.takeRequest().getSequenceNumber());
     assertEquals(1, server.takeRequest().getSequenceNumber());
   }
@@ -207,27 +249,42 @@ protected HttpOverSpdyTest(Protocol protocol){
   }
 
   @Test public void gzippedResponseBody() throws Exception {
-    server.enqueue(
-        new MockResponse().addHeader("Content-Encoding: gzip").setBody(gzip("ABCABCABC")));
-    assertContent("ABCABCABC", client.open(server.url("/r1").url()), Integer.MAX_VALUE);
+    server.enqueue(new MockResponse()
+        .addHeader("Content-Encoding: gzip")
+        .setBody(gzip("ABCABCABC")));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/r1"))
+        .build());
+
+    Response response = call.execute();
+    assertEquals("ABCABCABC", response.body().string());
   }
 
   @Test public void authenticate() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_UNAUTHORIZED)
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_UNAUTHORIZED)
         .addHeader("www-authenticate: Basic realm=\"protected area\"")
         .setBody("Please authenticate."));
-    server.enqueue(new MockResponse().setBody("Successful auth!"));
+    server.enqueue(new MockResponse()
+        .setBody("Successful auth!"));
 
-    Authenticator.setDefault(new RecordingAuthenticator());
-    connection = client.open(server.url("/").url());
-    assertEquals("Successful auth!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
+    String credential = Credentials.basic("username", "password");
+    client = client.newBuilder()
+        .authenticator(new RecordingOkAuthenticator(credential))
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals("Successful auth!", response.body().string());
 
     RecordedRequest denied = server.takeRequest();
     assertNull(denied.getHeader("Authorization"));
     RecordedRequest accepted = server.takeRequest();
     assertEquals("GET / HTTP/1.1", accepted.getRequestLine());
-    assertEquals("Basic " + RecordingAuthenticator.BASE_64_CREDENTIALS,
-        accepted.getHeader("Authorization"));
+    assertEquals(credential, accepted.getHeader("Authorization"));
   }
 
   @Test public void redirect() throws Exception {
@@ -236,8 +293,12 @@ protected HttpOverSpdyTest(Protocol protocol){
         .setBody("This page has moved!"));
     server.enqueue(new MockResponse().setBody("This is the new location!"));
 
-    connection = client.open(server.url("/").url());
-    assertContent("This is the new location!", connection, Integer.MAX_VALUE);
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+
+    Response response = call.execute();
+    assertEquals("This is the new location!", response.body().string());
 
     RecordedRequest request1 = server.takeRequest();
     assertEquals("/", request1.getPath());
@@ -248,9 +309,15 @@ protected HttpOverSpdyTest(Protocol protocol){
   @Test public void readAfterLastByte() throws Exception {
     server.enqueue(new MockResponse().setBody("ABC"));
 
-    connection = client.open(server.url("/").url());
-    InputStream in = connection.getInputStream();
-    assertEquals("ABC", readAscii(in, 3));
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+
+    InputStream in = response.body().byteStream();
+    assertEquals('A', in.read());
+    assertEquals('B', in.read());
+    assertEquals('C', in.read());
     assertEquals(-1, in.read());
     assertEquals(-1, in.read());
   }
@@ -260,47 +327,64 @@ protected HttpOverSpdyTest(Protocol protocol){
     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.NO_RESPONSE));
     server.enqueue(new MockResponse().setBody("A"));
 
-    connection = client.open(server.url("/").url());
-    connection.setReadTimeout(1000);
-    assertContent("A", connection, Integer.MAX_VALUE);
+    client = client.newBuilder()
+        .readTimeout(1000, MILLISECONDS)
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals("A", response.body().string());
   }
 
   /**
-   * Test to ensure we don't  throw a read timeout on responses that are
-   * progressing.  For this case, we take a 4KiB body and throttle it to
-   * 1KiB/second.  We set the read timeout to two seconds.  If our
-   * implementation is acting correctly, it will not throw, as it is
-   * progressing.
+   * Test to ensure we don't  throw a read timeout on responses that are progressing.  For this
+   * case, we take a 4KiB body and throttle it to 1KiB/second.  We set the read timeout to two
+   * seconds.  If our implementation is acting correctly, it will not throw, as it is progressing.
    */
   @Test public void readTimeoutMoreGranularThanBodySize() throws Exception {
-    char[] body = new char[4096]; // 4KiB to read
+    char[] body = new char[4096]; // 4KiB to read.
     Arrays.fill(body, 'y');
-    server.enqueue(new MockResponse().setBody(new String(body)).throttleBody(1024, 1, SECONDS)); // slow connection 1KiB/second
+    server.enqueue(new MockResponse().setBody(new String(body))
+        .throttleBody(1024, 1, SECONDS)); // Slow connection 1KiB/second.
+
+    client = client.newBuilder()
+        .readTimeout(2, SECONDS)
+        .build();
 
-    connection = client.open(server.url("/").url());
-    connection.setReadTimeout(2000); // 2 seconds to read something.
-    assertContent(new String(body), connection, Integer.MAX_VALUE);
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+
+    Response response = call.execute();
+    assertEquals(new String(body), response.body().string());
   }
 
   /**
-   * Test to ensure we throw a read timeout on responses that are progressing
-   * too slowly.  For this case, we take a 2KiB body and throttle it to
-   * 1KiB/second.  We set the read timeout to half a second.  If our
-   * implementation is acting correctly, it will throw, as a byte doesn't
-   * arrive in time.
+   * Test to ensure we throw a read timeout on responses that are progressing too slowly.  For this
+   * case, we take a 2KiB body and throttle it to 1KiB/second.  We set the read timeout to half a
+   * second.  If our implementation is acting correctly, it will throw, as a byte doesn't arrive in
+   * time.
    */
   @Test public void readTimeoutOnSlowConnection() throws Exception {
-    char[] body = new char[2048]; // 2KiB to read
+    char[] body = new char[2048]; // 2KiB to read.
     Arrays.fill(body, 'y');
     server.enqueue(new MockResponse()
         .setBody(new String(body))
-        .throttleBody(1024, 1, SECONDS)); // slow connection 1KiB/second
+        .throttleBody(1024, 1, SECONDS)); // Slow connection 1KiB/second.
+
+    client = client.newBuilder()
+        .readTimeout(500, MILLISECONDS) // Half a second to read something.
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
 
-    connection = client.open(server.url("/").url());
-    connection.setReadTimeout(500); // half a second to read something
-    connection.connect();
     try {
-      readAscii(connection.getInputStream(), Integer.MAX_VALUE);
+      response.body().string();
       fail("Should have timed out!");
     } catch (SocketTimeoutException expected) {
       assertEquals("timeout", expected.getMessage());
@@ -308,129 +392,196 @@ protected HttpOverSpdyTest(Protocol protocol){
   }
 
   @Test public void spdyConnectionTimeout() throws Exception {
-    MockResponse response = new MockResponse().setBody("A");
-    response.setBodyDelay(1, TimeUnit.SECONDS);
-    server.enqueue(response);
-
-    HttpURLConnection connection1 = client.open(server.url("/").url());
-    connection1.setReadTimeout(2000);
-    HttpURLConnection connection2 = client.open(server.url("/").url());
-    connection2.setReadTimeout(200);
-    connection1.connect();
-    connection2.connect();
-    assertContent("A", connection1, Integer.MAX_VALUE);
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .setBodyDelay(1, SECONDS));
+
+    OkHttpClient client1 = client.newBuilder()
+        .readTimeout(2000, MILLISECONDS)
+        .build();
+    Call call1 = client1
+        .newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+
+    OkHttpClient client2 = client.newBuilder()
+        .readTimeout(200, MILLISECONDS)
+        .build();
+    Call call2 = client2
+        .newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+
+    Response response1 = call1.execute();
+    assertEquals("A", response1.body().string());
+
+    try {
+      call2.execute();
+      fail();
+    } catch (IOException expected) {
+    }
   }
 
   @Test public void responsesAreCached() throws IOException {
-    client.client().setCache(cache);
-
-    server.enqueue(new MockResponse().addHeader("cache-control: max-age=60").setBody("A"));
-
-    assertContent("A", client.open(server.url("/").url()), Integer.MAX_VALUE);
-    assertEquals(1, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(0, cache.getHitCount());
-    assertContent("A", client.open(server.url("/").url()), Integer.MAX_VALUE);
-    assertContent("A", client.open(server.url("/").url()), Integer.MAX_VALUE);
-    assertEquals(3, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(2, cache.getHitCount());
+    client = client.newBuilder()
+        .cache(cache)
+        .build();
+
+    server.enqueue(new MockResponse()
+        .addHeader("cache-control: max-age=60")
+        .setBody("A"));
+
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response1 = call1.execute();
+
+    assertEquals("A", response1.body().string());
+    assertEquals(1, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(0, cache.hitCount());
+
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+    assertEquals("A", response2.body().string());
+
+    Call call3 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response3 = call3.execute();
+    assertEquals("A", response3.body().string());
+
+    assertEquals(3, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(2, cache.hitCount());
   }
 
   @Test public void conditionalCache() throws IOException {
-    client.client().setCache(cache);
-
-    server.enqueue(new MockResponse().addHeader("ETag: v1").setBody("A"));
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    assertContent("A", client.open(server.url("/").url()), Integer.MAX_VALUE);
-    assertEquals(1, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(0, cache.getHitCount());
-    assertContent("A", client.open(server.url("/").url()), Integer.MAX_VALUE);
-    assertEquals(2, cache.getRequestCount());
-    assertEquals(2, cache.getNetworkCount());
-    assertEquals(1, cache.getHitCount());
+    client = client.newBuilder()
+        .cache(cache)
+        .build();
+
+    server.enqueue(new MockResponse()
+        .addHeader("ETag: v1")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response1 = call1.execute();
+    assertEquals("A", response1.body().string());
+
+    assertEquals(1, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(0, cache.hitCount());
+
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+    assertEquals("A", response2.body().string());
+
+    assertEquals(2, cache.requestCount());
+    assertEquals(2, cache.networkCount());
+    assertEquals(1, cache.hitCount());
   }
 
   @Test public void responseCachedWithoutConsumingFullBody() throws IOException {
-    client.client().setCache(cache);
+    client = client.newBuilder()
+        .cache(cache)
+        .build();
+
+    server.enqueue(new MockResponse()
+        .addHeader("cache-control: max-age=60")
+        .setBody("ABCD"));
+    server.enqueue(new MockResponse()
+        .addHeader("cache-control: max-age=60")
+        .setBody("EFGH"));
+
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response1 = call1.execute();
+    assertEquals("AB", response1.body().source().readUtf8(2));
+    response1.body().close();
+
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+    assertEquals("ABCD", response2.body().source().readUtf8());
+    response2.body().close();
+  }
 
-    server.enqueue(new MockResponse().addHeader("cache-control: max-age=60").setBody("ABCD"));
-    server.enqueue(new MockResponse().addHeader("cache-control: max-age=60").setBody("EFGH"));
+  @Test public void sendRequestCookies() throws Exception {
+    RecordingCookieJar cookieJar = new RecordingCookieJar();
+    Cookie requestCookie = new Cookie.Builder()
+        .name("a")
+        .value("b")
+        .domain(server.getHostName())
+        .build();
+    cookieJar.enqueueRequestCookies(requestCookie);
+    client = client.newBuilder()
+        .cookieJar(cookieJar)
+        .build();
 
-    HttpURLConnection connection1 = client.open(server.url("/").url());
-    InputStream in1 = connection1.getInputStream();
-    assertEquals("AB", readAscii(in1, 2));
-    in1.close();
+    server.enqueue(new MockResponse());
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals("", response.body().string());
 
-    HttpURLConnection connection2 = client.open(server.url("/").url());
-    InputStream in2 = connection2.getInputStream();
-    assertEquals("ABCD", readAscii(in2, Integer.MAX_VALUE));
-    in2.close();
+    RecordedRequest request = server.takeRequest();
+    assertEquals("a=b", request.getHeader("Cookie"));
   }
 
-  @Test public void acceptAndTransmitCookies() throws Exception {
-    CookieManager cookieManager = new CookieManager();
-    client.client().setCookieHandler(cookieManager);
+  @Test public void receiveResponseCookies() throws Exception {
+    RecordingCookieJar cookieJar = new RecordingCookieJar();
+    client = client.newBuilder()
+        .cookieJar(cookieJar)
+        .build();
 
     server.enqueue(new MockResponse()
-        .addHeader("set-cookie: c=oreo; domain=" + server.getCookieDomain())
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    HttpUrl url = server.url("/");
-    assertContent("A", client.open(url.url()), Integer.MAX_VALUE);
-    Map<String, List<String>> requestHeaders = Collections.emptyMap();
-    assertEquals(Collections.singletonMap("Cookie", Arrays.asList("c=oreo")),
-        cookieManager.get(url.uri(), requestHeaders));
-
-    assertContent("B", client.open(url.url()), Integer.MAX_VALUE);
-    RecordedRequest requestA = server.takeRequest();
-    assertNull(requestA.getHeader("Cookie"));
-    RecordedRequest requestB = server.takeRequest();
-    assertEquals("c=oreo", requestB.getHeader("Cookie"));
+        .addHeader("set-cookie: a=b"));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals("", response.body().string());
+
+    cookieJar.assertResponseCookies("a=b; path=/");
   }
 
   /** https://github.com/square/okhttp/issues/1191 */
-  @Test public void disconnectWithStreamNotEstablished() throws Exception {
-    ConnectionPool connectionPool = new ConnectionPool(5, 5000);
-    client.client().setConnectionPool(connectionPool);
-
-    server.enqueue(new MockResponse().setBody("abc"));
+  @Test public void cancelWithStreamNotCompleted() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("abc"));
+    server.enqueue(new MockResponse()
+        .setBody("def"));
 
     // Disconnect before the stream is created. A connection is still established!
-    HttpURLConnection connection1 = client.open(server.url("/").url());
-    connection1.connect();
-    connection1.disconnect();
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    call1.execute();
+    call1.cancel();
 
     // That connection is pooled, and it works.
-    assertEquals(1, connectionPool.getMultiplexedConnectionCount());
-    HttpURLConnection connection2 = client.open(server.url("/").url());
-    assertContent("abc", connection2, 3);
+    assertEquals(1, client.connectionPool().connectionCount());
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+    assertEquals("def", response2.body().string());
     assertEquals(0, server.takeRequest().getSequenceNumber());
   }
 
-  void assertContent(String expected, HttpURLConnection connection, int limit)
-      throws IOException {
-    connection.connect();
-    assertEquals(expected, readAscii(connection.getInputStream(), limit));
-  }
-
-  private String readAscii(InputStream in, int count) throws IOException {
-    StringBuilder result = new StringBuilder();
-    for (int i = 0; i < count; i++) {
-      int value = in.read();
-      if (value == -1) {
-        in.close();
-        break;
-      }
-      result.append((char) value);
-    }
-    return result.toString();
-  }
-
   public Buffer gzip(String bytes) throws IOException {
     Buffer bytesOut = new Buffer();
     BufferedSink sink = Okio.buffer(new GzipSink(bytesOut));
@@ -442,6 +593,7 @@ public Buffer gzip(String bytes) throws IOException {
   class SpdyRequest implements Runnable {
     String path;
     CountDownLatch countDownLatch;
+
     public SpdyRequest(String path, CountDownLatch countDownLatch) {
       this.path = path;
       this.countDownLatch = countDownLatch;
@@ -449,8 +601,11 @@ public SpdyRequest(String path, CountDownLatch countDownLatch) {
 
     @Override public void run() {
       try {
-        HttpURLConnection conn = client.open(server.url(path).url());
-        assertEquals("A", readAscii(conn.getInputStream(), 1));
+        Call call = client.newCall(new Request.Builder()
+            .url(server.url(path))
+            .build());
+        Response response = call.execute();
+        assertEquals("A", response.body().string());
         countDownLatch.countDown();
       } catch (Exception e) {
         throw new RuntimeException(e);
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/framed/MockSpdyPeer.java b/okhttp-tests/src/test/java/okhttp3/internal/framed/MockSpdyPeer.java
index 1a5b6d811d..edc8f41c30 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/framed/MockSpdyPeer.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/framed/MockSpdyPeer.java
@@ -83,8 +83,8 @@ public FrameWriter sendFrame() {
   }
 
   /**
-   * Sends a manually-constructed frame. This is useful to test frames that
-   * won't be generated naturally.
+   * Sends a manually-constructed frame. This is useful to test frames that won't be generated
+   * naturally.
    */
   public void sendFrame(byte[] frame) throws IOException {
     outFrames.add(new OutFrame(frameCount++, bytesOut.size(), false));
@@ -92,9 +92,9 @@ public void sendFrame(byte[] frame) throws IOException {
   }
 
   /**
-   * Shortens the last frame from its original length to {@code length}. This
-   * will cause the peer to close the socket as soon as this frame has been
-   * written; otherwise the peer stays open until explicitly closed.
+   * Shortens the last frame from its original length to {@code length}. This will cause the peer to
+   * close the socket as soon as this frame has been written; otherwise the peer stays open until
+   * explicitly closed.
    */
   public FrameWriter truncateLastFrame(int length) {
     OutFrame lastFrame = outFrames.remove(outFrames.size() - 1);
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/framed/Spdy3ConnectionTest.java b/okhttp-tests/src/test/java/okhttp3/internal/framed/Spdy3ConnectionTest.java
index 0b2876cfb8..58cdc04bde 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/framed/Spdy3ConnectionTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/framed/Spdy3ConnectionTest.java
@@ -15,7 +15,6 @@
  */
 package okhttp3.internal.framed;
 
-import okhttp3.internal.Util;
 import java.io.IOException;
 import java.io.InterruptedIOException;
 import java.net.Socket;
@@ -26,6 +25,7 @@
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
+import okhttp3.internal.Util;
 import okio.AsyncTimeout;
 import okio.Buffer;
 import okio.BufferedSink;
@@ -274,6 +274,7 @@
       @Override public void onStream(FramedStream stream) throws IOException {
         throw new AssertionError();
       }
+
       @Override public void onSettings(FramedConnection connection) {
         maxConcurrentStreams.set(connection.maxConcurrentStreams());
       }
@@ -475,8 +476,7 @@
   }
 
   /**
-   * Test that the client sends a RST_STREAM if doing so won't disrupt the
-   * output stream.
+   * Test that the client sends a RST_STREAM if doing so won't disrupt the output stream.
    */
   @Test public void clientClosesClientInputStream() throws Exception {
     // write the mocking script
@@ -517,8 +517,7 @@
   }
 
   /**
-   * Test that the client doesn't send a RST_STREAM if doing so will disrupt
-   * the output stream.
+   * Test that the client doesn't send a RST_STREAM if doing so will disrupt the output stream.
    */
   @Test public void clientClosesClientInputStreamIfOutputStreamIsClosed() throws Exception {
     // write the mocking script
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/framed/Spdy3Test.java b/okhttp-tests/src/test/java/okhttp3/internal/framed/Spdy3Test.java
index c026b84ba7..953009ffc1 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/framed/Spdy3Test.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/framed/Spdy3Test.java
@@ -15,8 +15,8 @@
  */
 package okhttp3.internal.framed;
 
-import okhttp3.internal.Util;
 import java.io.IOException;
+import okhttp3.internal.Util;
 import okio.Buffer;
 import okio.ByteString;
 import org.junit.Test;
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/CookiesTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http/CookiesTest.java
index 8fe535cd8f..bf01f36fac 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http/CookiesTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http/CookiesTest.java
@@ -16,62 +16,55 @@
 
 package okhttp3.internal.http;
 
-import okhttp3.OkHttpClient;
-import okhttp3.OkUrlFactory;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.mockwebserver.RecordedRequest;
 import java.io.IOException;
 import java.net.CookieHandler;
 import java.net.CookieManager;
 import java.net.HttpCookie;
 import java.net.HttpURLConnection;
+import java.net.InetAddress;
 import java.net.URI;
-import java.net.URLConnection;
-import java.util.Collection;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
-import org.junit.After;
-import org.junit.Before;
+import okhttp3.Call;
+import okhttp3.HttpUrl;
+import okhttp3.JavaNetCookieJar;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
 import org.junit.Test;
 
 import static java.net.CookiePolicy.ACCEPT_ORIGINAL_SERVER;
+import static okhttp3.TestUtil.defaultClient;
 import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
-/** Android's CookiesTest. */
+/** Derived from Android's CookiesTest. */
 public class CookiesTest {
-
-  private OkHttpClient client;
-
-  @Before
-  public void setUp() throws Exception {
-    client = new OkHttpClient();
-  }
-
-  @After
-  public void tearDown() throws Exception {
-    CookieHandler.setDefault(null);
-  }
+  private OkHttpClient client = defaultClient();
 
   @Test
   public void testNetscapeResponse() throws Exception {
     CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
-    CookieHandler.setDefault(cookieManager);
+    client = client.newBuilder()
+        .cookieJar(new JavaNetCookieJar(cookieManager))
+        .build();
     MockWebServer server = new MockWebServer();
     server.start();
 
+    HttpUrl urlWithIpAddress = urlWithIpAddress(server, "/path/foo");
     server.enqueue(new MockResponse().addHeader("Set-Cookie: a=android; "
         + "expires=Fri, 31-Dec-9999 23:59:59 GMT; "
         + "path=/path; "
-        + "domain=" + server.getCookieDomain() + "; "
+        + "domain=" + urlWithIpAddress.host() + "; "
         + "secure"));
-    get(server, "/path/foo");
+    get(urlWithIpAddress);
 
     List<HttpCookie> cookies = cookieManager.getCookieStore().getCookies();
     assertEquals(1, cookies.size());
@@ -81,7 +74,6 @@ public void testNetscapeResponse() throws Exception {
     assertEquals(null, cookie.getComment());
     assertEquals(null, cookie.getCommentURL());
     assertEquals(false, cookie.getDiscard());
-    assertTrue(server.getCookieDomain().equalsIgnoreCase(cookie.getDomain()));
     assertTrue(cookie.getMaxAge() > 100000000000L);
     assertEquals("/path", cookie.getPath());
     assertEquals(true, cookie.getSecure());
@@ -90,159 +82,168 @@ public void testNetscapeResponse() throws Exception {
 
   @Test public void testRfc2109Response() throws Exception {
     CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
-    CookieHandler.setDefault(cookieManager);
+    client = client.newBuilder()
+        .cookieJar(new JavaNetCookieJar(cookieManager))
+        .build();
     MockWebServer server = new MockWebServer();
     server.start();
 
+    HttpUrl urlWithIpAddress = urlWithIpAddress(server, "/path/foo");
     server.enqueue(new MockResponse().addHeader("Set-Cookie: a=android; "
         + "Comment=this cookie is delicious; "
-        + "Domain=" + server.getCookieDomain() + "; "
+        + "Domain=" + urlWithIpAddress.host() + "; "
         + "Max-Age=60; "
         + "Path=/path; "
         + "Secure; "
         + "Version=1"));
-    get(server, "/path/foo");
+    get(urlWithIpAddress);
 
     List<HttpCookie> cookies = cookieManager.getCookieStore().getCookies();
     assertEquals(1, cookies.size());
     HttpCookie cookie = cookies.get(0);
     assertEquals("a", cookie.getName());
     assertEquals("android", cookie.getValue());
-    assertEquals("this cookie is delicious", cookie.getComment());
     assertEquals(null, cookie.getCommentURL());
     assertEquals(false, cookie.getDiscard());
-    assertTrue(server.getCookieDomain().equalsIgnoreCase(cookie.getDomain()));
-    assertEquals(60, cookie.getMaxAge());
+    assertEquals(60.0, cookie.getMaxAge(), 1.0); // Converting to a fixed date can cause rounding!
     assertEquals("/path", cookie.getPath());
     assertEquals(true, cookie.getSecure());
-    assertEquals(1, cookie.getVersion());
-  }
-
-  @Test public void testRfc2965Response() throws Exception {
-    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
-    CookieHandler.setDefault(cookieManager);
-    MockWebServer server = new MockWebServer();
-    server.start();
-
-    server.enqueue(new MockResponse().addHeader("Set-Cookie2: a=android; "
-        + "Comment=this cookie is delicious; "
-        + "CommentURL=http://google.com/; "
-        + "Discard; "
-        + "Domain=" + server.getCookieDomain() + "; "
-        + "Max-Age=60; "
-        + "Path=/path; "
-        + "Port=\"80,443," + server.getPort() + "\"; "
-        + "Secure; "
-        + "Version=1"));
-    get(server, "/path/foo");
-
-    List<HttpCookie> cookies = cookieManager.getCookieStore().getCookies();
-    assertEquals(1, cookies.size());
-    HttpCookie cookie = cookies.get(0);
-    assertEquals("a", cookie.getName());
-    assertEquals("android", cookie.getValue());
-    assertEquals("this cookie is delicious", cookie.getComment());
-    assertEquals("http://google.com/", cookie.getCommentURL());
-    assertEquals(true, cookie.getDiscard());
-    assertTrue(server.getCookieDomain().equalsIgnoreCase(cookie.getDomain()));
-    assertEquals(60, cookie.getMaxAge());
-    assertEquals("/path", cookie.getPath());
-    assertEquals("80,443," + server.getPort(), cookie.getPortlist());
-    assertEquals(true, cookie.getSecure());
-    assertEquals(1, cookie.getVersion());
   }
 
   @Test public void testQuotedAttributeValues() throws Exception {
     CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
-    CookieHandler.setDefault(cookieManager);
+    client = client.newBuilder()
+        .cookieJar(new JavaNetCookieJar(cookieManager))
+        .build();
     MockWebServer server = new MockWebServer();
     server.start();
 
-    server.enqueue(new MockResponse().addHeader("Set-Cookie2: a=\"android\"; "
+    HttpUrl urlWithIpAddress = urlWithIpAddress(server, "/path/foo");
+    server.enqueue(new MockResponse().addHeader("Set-Cookie: a=\"android\"; "
         + "Comment=\"this cookie is delicious\"; "
         + "CommentURL=\"http://google.com/\"; "
         + "Discard; "
-        + "Domain=\"" + server.getCookieDomain() + "\"; "
-        + "Max-Age=\"60\"; "
+        + "Domain=" + urlWithIpAddress.host() + "; "
+        + "Max-Age=60; "
         + "Path=\"/path\"; "
         + "Port=\"80,443," + server.getPort() + "\"; "
         + "Secure; "
         + "Version=\"1\""));
-    get(server, "/path/foo");
+    get(urlWithIpAddress);
 
     List<HttpCookie> cookies = cookieManager.getCookieStore().getCookies();
     assertEquals(1, cookies.size());
     HttpCookie cookie = cookies.get(0);
     assertEquals("a", cookie.getName());
     assertEquals("android", cookie.getValue());
-    assertEquals("this cookie is delicious", cookie.getComment());
-    assertEquals("http://google.com/", cookie.getCommentURL());
-    assertEquals(true, cookie.getDiscard());
-    assertTrue(server.getCookieDomain().equalsIgnoreCase(cookie.getDomain()));
-    assertEquals(60, cookie.getMaxAge());
+    assertEquals(60.0, cookie.getMaxAge(), 1.0); // Converting to a fixed date can cause rounding!
     assertEquals("/path", cookie.getPath());
-    assertEquals("80,443," + server.getPort(), cookie.getPortlist());
     assertEquals(true, cookie.getSecure());
-    assertEquals(1, cookie.getVersion());
   }
 
   @Test public void testSendingCookiesFromStore() throws Exception {
     MockWebServer server = new MockWebServer();
     server.enqueue(new MockResponse());
     server.start();
+    HttpUrl serverUrl = urlWithIpAddress(server, "/");
 
     CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
     HttpCookie cookieA = new HttpCookie("a", "android");
-    cookieA.setDomain(server.getCookieDomain());
+    cookieA.setDomain(serverUrl.host());
     cookieA.setPath("/");
-    cookieManager.getCookieStore().add(server.url("/").uri(), cookieA);
+    cookieManager.getCookieStore().add(serverUrl.uri(), cookieA);
     HttpCookie cookieB = new HttpCookie("b", "banana");
-    cookieB.setDomain(server.getCookieDomain());
+    cookieB.setDomain(serverUrl.host());
     cookieB.setPath("/");
-    cookieManager.getCookieStore().add(server.url("/").uri(), cookieB);
-    CookieHandler.setDefault(cookieManager);
+    cookieManager.getCookieStore().add(serverUrl.uri(), cookieB);
+    client = client.newBuilder()
+        .cookieJar(new JavaNetCookieJar(cookieManager))
+        .build();
+
+    get(serverUrl);
+    RecordedRequest request = server.takeRequest();
+
+    assertEquals("a=android; b=banana", request.getHeader("Cookie"));
+  }
 
-    get(server, "/");
+  @Test public void cookieHandlerLikeAndroid() throws Exception {
+    final MockWebServer server = new MockWebServer();
+    server.enqueue(new MockResponse());
+    server.start();
+    final HttpUrl serverUrl = urlWithIpAddress(server, "/");
+
+    CookieHandler androidCookieHandler = new CookieHandler() {
+      @Override public Map<String, List<String>> get(URI uri, Map<String, List<String>> map)
+          throws IOException {
+        return Collections.singletonMap("Cookie", Collections.singletonList("$Version=\"1\"; "
+            + "a=\"android\";$Path=\"/\";$Domain=\"" + serverUrl.host() + "\"; "
+            + "b=\"banana\";$Path=\"/\";$Domain=\"" + serverUrl.host() + "\""));
+      }
+
+      @Override public void put(URI uri, Map<String, List<String>> map) throws IOException {
+      }
+    };
+
+    client = client.newBuilder()
+        .cookieJar(new JavaNetCookieJar(androidCookieHandler))
+        .build();
+
+    get(serverUrl);
     RecordedRequest request = server.takeRequest();
 
-    assertEquals("$Version=\"1\"; "
-            + "a=\"android\";$Path=\"/\";$Domain=\""
-            + server.getCookieDomain()
-            + "\"; "
-            + "b=\"banana\";$Path=\"/\";$Domain=\""
-            + server.getCookieDomain()
-            + "\"", request.getHeader("Cookie"));
+    assertEquals("a=android; b=banana", request.getHeader("Cookie"));
+  }
+
+  @Test public void receiveAndSendMultipleCookies() throws Exception {
+    MockWebServer server = new MockWebServer();
+    server.enqueue(new MockResponse()
+        .addHeader("Set-Cookie", "a=android")
+        .addHeader("Set-Cookie", "b=banana"));
+    server.enqueue(new MockResponse());
+    server.start();
+
+    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
+    client = client.newBuilder()
+        .cookieJar(new JavaNetCookieJar(cookieManager))
+        .build();
+
+    get(urlWithIpAddress(server, "/"));
+    RecordedRequest request1 = server.takeRequest();
+    assertNull(request1.getHeader("Cookie"));
+
+    get(urlWithIpAddress(server, "/"));
+    RecordedRequest request2 = server.takeRequest();
+    assertEquals("a=android; b=banana", request2.getHeader("Cookie"));
   }
 
   @Test public void testRedirectsDoNotIncludeTooManyCookies() throws Exception {
     MockWebServer redirectTarget = new MockWebServer();
     redirectTarget.enqueue(new MockResponse().setBody("A"));
     redirectTarget.start();
+    HttpUrl redirectTargetUrl = urlWithIpAddress(redirectTarget, "/");
 
     MockWebServer redirectSource = new MockWebServer();
     redirectSource.enqueue(new MockResponse()
         .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: " + redirectTarget.url("/")));
+        .addHeader("Location: " + redirectTargetUrl));
     redirectSource.start();
+    HttpUrl redirectSourceUrl = urlWithIpAddress(redirectSource, "/");
 
     CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
     HttpCookie cookie = new HttpCookie("c", "cookie");
-    cookie.setDomain(redirectSource.getCookieDomain());
+    cookie.setDomain(redirectSourceUrl.host());
     cookie.setPath("/");
     String portList = Integer.toString(redirectSource.getPort());
     cookie.setPortlist(portList);
-    cookieManager.getCookieStore().add(redirectSource.url("/").uri(), cookie);
-    CookieHandler.setDefault(cookieManager);
+    cookieManager.getCookieStore().add(redirectSourceUrl.uri(), cookie);
+    client = client.newBuilder()
+        .cookieJar(new JavaNetCookieJar(cookieManager))
+        .build();
 
-    get(redirectSource, "/");
+    get(redirectSourceUrl);
     RecordedRequest request = redirectSource.takeRequest();
 
-    assertEquals("$Version=\"1\"; "
-            + "c=\"cookie\";$Path=\"/\";$Domain=\""
-            + redirectSource.getCookieDomain()
-            + "\";$Port=\""
-            + portList
-            + "\"", request.getHeader("Cookie"));
+    assertEquals("c=cookie", request.getHeader("Cookie"));
 
     for (String header : redirectTarget.takeRequest().getHeaders().names()) {
       if (header.startsWith("Cookie")) {
@@ -251,110 +252,43 @@ public void testNetscapeResponse() throws Exception {
     }
   }
 
-  /**
-   * Test which headers show up where. The cookie manager should be notified
-   * of both user-specified and derived headers like {@code Host}. Headers
-   * named {@code Cookie} or {@code Cookie2} that are returned by the cookie
-   * manager should show up in the request and in {@code
-   * getRequestProperties}.
-   */
-  @Test public void testHeadersSentToCookieHandler() throws IOException, InterruptedException {
-    final Map<String, List<String>> cookieHandlerHeaders = new HashMap<>();
-    CookieHandler.setDefault(new CookieManager() {
-      @Override
-      public Map<String, List<String>> get(URI uri,
-          Map<String, List<String>> requestHeaders) throws IOException {
-        cookieHandlerHeaders.putAll(requestHeaders);
-        Map<String, List<String>> result = new HashMap<>();
-        result.put("Cookie", Collections.singletonList("Bar=bar"));
-        result.put("Cookie2", Collections.singletonList("Baz=baz"));
-        result.put("Quux", Collections.singletonList("quux"));
-        return result;
-      }
-    });
-    MockWebServer server = new MockWebServer();
-    server.enqueue(new MockResponse());
-    server.start();
-
-    HttpURLConnection connection = new OkUrlFactory(client).open(server.url("/").url());
-    assertEquals(Collections.<String, List<String>>emptyMap(),
-        connection.getRequestProperties());
-
-    connection.setRequestProperty("Foo", "foo");
-    connection.setDoOutput(true);
-    connection.getOutputStream().write(5);
-    connection.getOutputStream().close();
-    connection.getInputStream().close();
-
-    RecordedRequest request = server.takeRequest();
-
-    assertContainsAll(cookieHandlerHeaders.keySet(), "Foo");
-    assertContainsAll(cookieHandlerHeaders.keySet(),
-        "Content-type", "User-Agent", "Connection", "Host");
-    assertFalse(cookieHandlerHeaders.containsKey("Cookie"));
-
-    /*
-     * The API specifies that calling getRequestProperties() on a connected instance should fail
-     * with an IllegalStateException, but the RI violates the spec and returns a valid map.
-     * http://www.mail-archive.com/net-dev@openjdk.java.net/msg01768.html
-     */
-    try {
-      assertContainsAll(connection.getRequestProperties().keySet(), "Foo");
-      assertContainsAll(connection.getRequestProperties().keySet(),
-          "Content-type", "Content-Length", "User-Agent", "Connection", "Host");
-      assertContainsAll(connection.getRequestProperties().keySet(), "Cookie", "Cookie2");
-      assertFalse(connection.getRequestProperties().containsKey("Quux"));
-    } catch (IllegalStateException expected) {
-    }
-
-    assertEquals("foo", request.getHeader("Foo"));
-    assertEquals("Bar=bar", request.getHeader("Cookie"));
-    assertEquals("Baz=baz", request.getHeader("Cookie2"));
-    assertNull(request.getHeader("Quux"));
-  }
-
   @Test public void testCookiesSentIgnoresCase() throws Exception {
-    CookieHandler.setDefault(new CookieManager() {
-      @Override public Map<String, List<String>> get(URI uri,
-          Map<String, List<String>> requestHeaders) throws IOException {
-        Map<String, List<String>> result = new HashMap<>();
-        result.put("COOKIE", Collections.singletonList("Bar=bar"));
-        result.put("cooKIE2", Collections.singletonList("Baz=baz"));
-        return result;
-      }
-    });
+    client = client.newBuilder()
+        .cookieJar(new JavaNetCookieJar(new CookieManager() {
+          @Override public Map<String, List<String>> get(URI uri,
+              Map<String, List<String>> requestHeaders) throws IOException {
+            Map<String, List<String>> result = new HashMap<>();
+            result.put("COOKIE", Collections.singletonList("Bar=bar"));
+            result.put("cooKIE2", Collections.singletonList("Baz=baz"));
+            return result;
+          }
+        }))
+        .build();
+
     MockWebServer server = new MockWebServer();
-    server. enqueue(new MockResponse());
+    server.enqueue(new MockResponse());
     server.start();
 
-    get(server, "/");
+    get(server.url("/"));
 
     RecordedRequest request = server.takeRequest();
-    assertEquals("Bar=bar", request.getHeader("Cookie"));
-    assertEquals("Baz=baz", request.getHeader("Cookie2"));
+    assertEquals("Bar=bar; Baz=baz", request.getHeader("Cookie"));
+    assertNull(request.getHeader("Cookie2"));
     assertNull(request.getHeader("Quux"));
   }
 
-  private void assertContains(Collection<String> collection, String element) {
-    for (String c : collection) {
-      if (c != null && c.equalsIgnoreCase(element)) {
-        return;
-      }
-    }
-    fail("No " + element + " in " + collection);
+  private HttpUrl urlWithIpAddress(MockWebServer server, String path) throws Exception {
+    return server.url(path)
+        .newBuilder()
+        .host(InetAddress.getByName(server.getHostName()).getHostAddress())
+        .build();
   }
 
-  private void assertContainsAll(Collection<String> collection, String... toFind) {
-    for (String s : toFind) {
-      assertContains(collection, s);
-    }
-  }
-
-  private Map<String,List<String>> get(MockWebServer server, String path) throws Exception {
-    URLConnection connection = new OkUrlFactory(client).open(server.url(path).url());
-    Map<String, List<String>> headers = connection.getHeaderFields();
-    connection.getInputStream().close();
-    return headers;
+  private void get(HttpUrl url) throws Exception {
+    Call call = client.newCall(new Request.Builder()
+        .url(url)
+        .build());
+    Response response = call.execute();
+    response.body().close();
   }
-
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/DisconnectTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http/DisconnectTest.java
index 47b604df7e..eb85913192 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http/DisconnectTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http/DisconnectTest.java
@@ -15,12 +15,6 @@
  */
 package okhttp3.internal.http;
 
-import okhttp3.DelegatingServerSocketFactory;
-import okhttp3.DelegatingSocketFactory;
-import okhttp3.OkHttpClient;
-import okhttp3.OkUrlFactory;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
@@ -28,14 +22,18 @@
 import java.net.ServerSocket;
 import java.net.Socket;
 import java.util.concurrent.TimeUnit;
-
+import javax.net.ServerSocketFactory;
+import javax.net.SocketFactory;
+import okhttp3.DelegatingServerSocketFactory;
+import okhttp3.DelegatingSocketFactory;
+import okhttp3.OkHttpClient;
+import okhttp3.OkUrlFactory;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
 import okio.Buffer;
 import org.junit.Before;
 import org.junit.Test;
 
-import javax.net.ServerSocketFactory;
-import javax.net.SocketFactory;
-
 import static org.junit.Assert.fail;
 
 public final class DisconnectTest {
@@ -47,28 +45,26 @@
   private OkHttpClient client;
 
   @Before public void setUp() throws Exception {
-    server = new MockWebServer();
-    client = new OkHttpClient();
-
     // Sockets on some platforms can have large buffers that mean writes do not block when
     // required. These socket factories explicitly set the buffer sizes on sockets created.
+    server = new MockWebServer();
     server.setServerSocketFactory(
         new DelegatingServerSocketFactory(ServerSocketFactory.getDefault()) {
-          @Override
-          protected ServerSocket configureServerSocket(ServerSocket serverSocket)
-              throws IOException {
+          @Override protected ServerSocket configureServerSocket(
+              ServerSocket serverSocket) throws IOException {
             serverSocket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
             return serverSocket;
           }
         });
-    client.setSocketFactory(new DelegatingSocketFactory(SocketFactory.getDefault()) {
-      @Override
-      protected Socket configureSocket(Socket socket) throws IOException {
-        socket.setSendBufferSize(SOCKET_BUFFER_SIZE);
-        socket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
-        return socket;
-      }
-    });
+    client = new OkHttpClient.Builder()
+        .socketFactory(new DelegatingSocketFactory(SocketFactory.getDefault()) {
+          @Override protected Socket configureSocket(Socket socket) throws IOException {
+            socket.setSendBufferSize(SOCKET_BUFFER_SIZE);
+            socket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
+            return socket;
+          }
+        })
+        .build();
   }
 
   @Test public void interruptWritingRequestBody() throws Exception {
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/ExternalHttp2Example.java b/okhttp-tests/src/test/java/okhttp3/internal/http/ExternalHttp2Example.java
index bb6a346b64..73f9471fac 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http/ExternalHttp2Example.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http/ExternalHttp2Example.java
@@ -16,48 +16,36 @@
 
 package okhttp3.internal.http;
 
+import okhttp3.Call;
 import okhttp3.OkHttpClient;
-import okhttp3.OkUrlFactory;
 import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.Response;
 import okhttp3.internal.Util;
-import java.io.BufferedReader;
-import java.io.InputStreamReader;
-import java.net.URL;
-import java.util.List;
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.HttpsURLConnection;
-import javax.net.ssl.SSLSession;
-
-import static okhttp3.internal.http.OkHeaders.SELECTED_PROTOCOL;
 
 public final class ExternalHttp2Example {
   public static void main(String[] args) throws Exception {
-    URL url = new URL("https://twitter.com");
-    OkHttpClient client = new OkHttpClient()
-        .setProtocols(Util.immutableList(Protocol.HTTP_2, Protocol.HTTP_1_1));
-    HttpsURLConnection connection = (HttpsURLConnection) new OkUrlFactory(client)
-        .open(url);
+    OkHttpClient client = new OkHttpClient.Builder()
+        .protocols(Util.immutableList(Protocol.HTTP_2, Protocol.HTTP_1_1))
+        .build();
 
-    connection.setHostnameVerifier(new HostnameVerifier() {
-      @Override public boolean verify(String s, SSLSession sslSession) {
-        System.out.println("VERIFYING " + s);
-        return true;
-      }
-    });
+    Call call = client.newCall(new Request.Builder()
+        .url("https://www.google.ca/")
+        .build());
 
-    int responseCode = connection.getResponseCode();
-    System.out.println(responseCode);
-    List<String> protocolValues = connection.getHeaderFields().get(SELECTED_PROTOCOL);
-    // If null, probably you didn't add jetty's alpn jar to your boot classpath!
-    if (protocolValues != null && !protocolValues.isEmpty()) {
-      System.out.println("PROTOCOL " + protocolValues.get(0));
-    }
+    Response response = call.execute();
+    try {
+      System.out.println(response.code());
+      System.out.println("PROTOCOL " + response.protocol());
 
-    BufferedReader reader =
-        new BufferedReader(new InputStreamReader(connection.getInputStream(), "UTF-8"));
-    String line;
-    while ((line = reader.readLine()) != null) {
-      System.out.println(line);
+      String line;
+      while ((line = response.body().source().readUtf8Line()) != null) {
+        System.out.println(line);
+      }
+    } finally {
+      response.body().close();
     }
+
+    client.connectionPool().evictAll();
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/ExternalSpdyExample.java b/okhttp-tests/src/test/java/okhttp3/internal/http/ExternalSpdyExample.java
index 57cd3a3ab2..c1598480ec 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http/ExternalSpdyExample.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http/ExternalSpdyExample.java
@@ -16,48 +16,36 @@
 
 package okhttp3.internal.http;
 
+import okhttp3.Call;
 import okhttp3.OkHttpClient;
-import okhttp3.OkUrlFactory;
 import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.Response;
 import okhttp3.internal.Util;
-import java.io.BufferedReader;
-import java.io.InputStreamReader;
-import java.net.URL;
-import java.util.List;
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.HttpsURLConnection;
-import javax.net.ssl.SSLSession;
-
-import static okhttp3.internal.http.OkHeaders.SELECTED_PROTOCOL;
 
 public final class ExternalSpdyExample {
   public static void main(String[] args) throws Exception {
-    URL url = new URL("https://www.google.ca/");
-    OkHttpClient client = new OkHttpClient()
-        .setProtocols(Util.immutableList(Protocol.SPDY_3, Protocol.HTTP_1_1));
-    HttpsURLConnection connection = (HttpsURLConnection) new OkUrlFactory(client)
-        .open(url);
+    OkHttpClient client = new OkHttpClient.Builder()
+        .protocols(Util.immutableList(Protocol.SPDY_3, Protocol.HTTP_1_1))
+        .build();
 
-    connection.setHostnameVerifier(new HostnameVerifier() {
-      @Override public boolean verify(String s, SSLSession sslSession) {
-        System.out.println("VERIFYING " + s);
-        return true;
-      }
-    });
+    Call call = client.newCall(new Request.Builder()
+        .url("https://www.google.ca/")
+        .build());
 
-    int responseCode = connection.getResponseCode();
-    System.out.println(responseCode);
-    List<String> protocolValues = connection.getHeaderFields().get(SELECTED_PROTOCOL);
-    // If null, probably you didn't add jetty's alpn jar to your boot classpath!
-    if (protocolValues != null && !protocolValues.isEmpty()) {
-      System.out.println("PROTOCOL " + protocolValues.get(0));
-    }
+    Response response = call.execute();
+    try {
+      System.out.println(response.code());
+      System.out.println("PROTOCOL " + response.protocol());
 
-    BufferedReader reader =
-        new BufferedReader(new InputStreamReader(connection.getInputStream(), "UTF-8"));
-    String line;
-    while ((line = reader.readLine()) != null) {
-      System.out.println(line);
+      String line;
+      while ((line = response.body().source().readUtf8Line()) != null) {
+        System.out.println(line);
+      }
+    } finally {
+      response.body().close();
     }
+
+    client.connectionPool().evictAll();
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/HeadersTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http/HeadersTest.java
index 098d9df05f..4e649dc88c 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http/HeadersTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http/HeadersTest.java
@@ -15,17 +15,17 @@
  */
 package okhttp3.internal.http;
 
-import okhttp3.Headers;
-import okhttp3.Protocol;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.internal.framed.Header;
 import java.io.IOException;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import okhttp3.Headers;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.internal.framed.Header;
 import org.junit.Assert;
 import org.junit.Test;
 
@@ -302,4 +302,56 @@
     assertEquals(2, headerMap.get("cache-control").size());
     assertEquals(1, headerMap.get("user-agent").size());
   }
+
+  @Test public void nameIndexesAreStrict() {
+    Headers headers = Headers.of("a", "b", "c", "d");
+    try {
+      headers.name(-1);
+      fail();
+    } catch (IndexOutOfBoundsException expected) {
+    }
+    assertEquals("a", headers.name(0));
+    assertEquals("c", headers.name(1));
+    try {
+      headers.name(2);
+      fail();
+    } catch (IndexOutOfBoundsException expected) {
+    }
+  }
+
+  @Test public void valueIndexesAreStrict() {
+    Headers headers = Headers.of("a", "b", "c", "d");
+    try {
+      headers.value(-1);
+      fail();
+    } catch (IndexOutOfBoundsException expected) {
+    }
+    assertEquals("b", headers.value(0));
+    assertEquals("d", headers.value(1));
+    try {
+      headers.value(2);
+      fail();
+    } catch (IndexOutOfBoundsException expected) {
+    }
+  }
+
+  @Test public void builderRejectsUnicodeInHeaderName() {
+    try {
+      new Headers.Builder().add("héader1", "value1");
+      fail("Should have complained about invalid name");
+    } catch (IllegalArgumentException expected) {
+      assertEquals("Unexpected char 0xe9 at 1 in header name: héader1",
+          expected.getMessage());
+    }
+  }
+
+  @Test public void builderRejectsUnicodeInHeaderValue() {
+    try {
+      new Headers.Builder().add("header1", "valué1");
+      fail("Should have complained about invalid value");
+    } catch (IllegalArgumentException expected) {
+      assertEquals("Unexpected char 0xe9 at 4 in header1 value: valué1",
+          expected.getMessage());
+    }
+  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/HttpDateTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http/HttpDateTest.java
index 2098d68103..0a22eb0f8a 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http/HttpDateTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http/HttpDateTest.java
@@ -15,13 +15,12 @@
  */
 package okhttp3.internal.http;
 
+import java.util.Date;
+import java.util.TimeZone;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 
-import java.util.Date;
-import java.util.TimeZone;
-
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
 
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/RecordingProxySelector.java b/okhttp-tests/src/test/java/okhttp3/internal/http/RecordingProxySelector.java
index 94b9f2fcd7..5b4b630d32 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http/RecordingProxySelector.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http/RecordingProxySelector.java
@@ -28,9 +28,9 @@
 import static org.junit.Assert.assertEquals;
 
 public final class RecordingProxySelector extends ProxySelector {
-  final List<URI> requestedUris = new ArrayList<>();
-  List<Proxy> proxies = new ArrayList<>();
-  final List<String> failures = new ArrayList<>();
+  public final List<Proxy> proxies = new ArrayList<>();
+  public final List<URI> requestedUris = new ArrayList<>();
+  public final List<String> failures = new ArrayList<>();
 
   @Override public List<Proxy> select(URI uri) {
     requestedUris.add(uri);
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/RouteExceptionTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http/RouteExceptionTest.java
index 7ae8a9666e..1a0c2d8f02 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http/RouteExceptionTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http/RouteExceptionTest.java
@@ -15,9 +15,8 @@
  */
 package okhttp3.internal.http;
 
-import org.junit.Test;
-
 import java.io.IOException;
+import org.junit.Test;
 
 import static org.junit.Assert.assertSame;
 
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/RouteSelectorTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http/RouteSelectorTest.java
index adc7f17043..7f0b47037d 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http/RouteSelectorTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http/RouteSelectorTest.java
@@ -15,17 +15,13 @@
  */
 package okhttp3.internal.http;
 
-import okhttp3.Address;
-import okhttp3.Authenticator;
-import okhttp3.ConnectionSpec;
-import okhttp3.Protocol;
-import okhttp3.Route;
-import okhttp3.internal.RouteDatabase;
-import okhttp3.internal.SslContextBuilder;
-import okhttp3.internal.Util;
+import java.io.IOException;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.net.Proxy;
+import java.net.ProxySelector;
+import java.net.SocketAddress;
+import java.net.URI;
 import java.net.UnknownHostException;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -36,6 +32,15 @@
 import javax.net.ssl.HttpsURLConnection;
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLSocketFactory;
+import okhttp3.Address;
+import okhttp3.Authenticator;
+import okhttp3.ConnectionSpec;
+import okhttp3.FakeDns;
+import okhttp3.Protocol;
+import okhttp3.Route;
+import okhttp3.internal.RouteDatabase;
+import okhttp3.internal.SslContextBuilder;
+import okhttp3.internal.Util;
 import org.junit.Before;
 import org.junit.Test;
 
@@ -67,7 +72,7 @@
   private final SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();
   private HostnameVerifier hostnameVerifier;
 
-  private final Authenticator authenticator = AuthenticatorAdapter.INSTANCE;
+  private final Authenticator authenticator = Authenticator.NONE;
   private final List<Protocol> protocols = Arrays.asList(Protocol.HTTP_1_1);
   private final FakeDns dns = new FakeDns();
   private final RecordingProxySelector proxySelector = new RecordingProxySelector();
@@ -144,12 +149,21 @@
   }
 
   @Test public void proxySelectorReturnsNull() throws Exception {
-    Address address = httpAddress();
+    ProxySelector nullProxySelector = new ProxySelector() {
+      @Override public List<Proxy> select(URI uri) {
+        assertEquals(uriHost, uri.getHost());
+        return null;
+      }
 
-    proxySelector.proxies = null;
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase);
-    proxySelector.assertRequests(address.url().uri());
+      @Override public void connectFailed(
+          URI uri, SocketAddress socketAddress, IOException e) {
+        throw new AssertionError();
+      }
+    };
 
+    Address address = new Address(uriHost, uriPort, dns, socketFactory, null, null, null,
+        authenticator, null, protocols, connectionSpecs, nullProxySelector);
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase);
     assertTrue(routeSelector.hasNext());
     dns.addresses(makeFakeAddresses(255, 1));
     assertRoute(routeSelector.next(), address, NO_PROXY, dns.address(0), uriPort);
@@ -322,10 +336,10 @@
     socketAddress = new InetSocketAddress(InetAddress.getByName("localhost"), 1234);
     assertEquals("127.0.0.1", RouteSelector.getHostString(socketAddress));
     socketAddress = new InetSocketAddress(
-        InetAddress.getByAddress(new byte[] { 127, 0, 0, 1 }), 1234);
+        InetAddress.getByAddress(new byte[] {127, 0, 0, 1}), 1234);
     assertEquals("127.0.0.1", RouteSelector.getHostString(socketAddress));
     socketAddress = new InetSocketAddress(
-        InetAddress.getByAddress("foobar", new byte[] { 127, 0, 0, 1 }), 1234);
+        InetAddress.getByAddress("foobar", new byte[] {127, 0, 0, 1}), 1234);
     assertEquals("127.0.0.1", RouteSelector.getHostString(socketAddress));
   }
 
@@ -353,7 +367,7 @@ private Address httpsAddress() {
       List<InetAddress> result = new ArrayList<>();
       for (int i = 0; i < count; i++) {
         result.add(InetAddress.getByAddress(
-            new byte[] { (byte) prefix, (byte) 0, (byte) 0, (byte) i }));
+            new byte[] {(byte) prefix, (byte) 0, (byte) 0, (byte) i}));
       }
       return result;
     } catch (UnknownHostException e) {
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/StatusLineTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http/StatusLineTest.java
index be97c012e1..6eb1aa8b12 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http/StatusLineTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http/StatusLineTest.java
@@ -15,9 +15,9 @@
  */
 package okhttp3.internal.http;
 
-import okhttp3.Protocol;
 import java.io.IOException;
 import java.net.ProtocolException;
+import okhttp3.Protocol;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
@@ -44,9 +44,8 @@
   }
 
   /**
-   * This is not defined in the protocol but some servers won't add the leading
-   * empty space when the message is empty.
-   * http://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html#sec6.1
+   * This is not defined in the protocol but some servers won't add the leading empty space when the
+   * message is empty. http://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html#sec6.1
    */
   @Test public void emptyMessageAndNoLeadingSpace() throws IOException {
     int version = 1;
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/ThreadInterruptTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http/ThreadInterruptTest.java
index 4e304781ee..47f4f0fc6b 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http/ThreadInterruptTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http/ThreadInterruptTest.java
@@ -15,13 +15,6 @@
  */
 package okhttp3.internal.http;
 
-import okhttp3.DelegatingServerSocketFactory;
-import okhttp3.DelegatingSocketFactory;
-import okhttp3.OkHttpClient;
-import okhttp3.OkUrlFactory;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InterruptedIOException;
@@ -30,14 +23,18 @@
 import java.net.ServerSocket;
 import java.net.Socket;
 import java.util.concurrent.TimeUnit;
-
+import javax.net.ServerSocketFactory;
+import javax.net.SocketFactory;
+import okhttp3.DelegatingServerSocketFactory;
+import okhttp3.DelegatingSocketFactory;
+import okhttp3.OkHttpClient;
+import okhttp3.OkUrlFactory;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
 import okio.Buffer;
 import org.junit.Before;
 import org.junit.Test;
 
-import javax.net.ServerSocketFactory;
-import javax.net.SocketFactory;
-
 import static org.junit.Assert.fail;
 
 public final class ThreadInterruptTest {
@@ -49,11 +46,9 @@
   private OkHttpClient client;
 
   @Before public void setUp() throws Exception {
-    server = new MockWebServer();
-    client = new OkHttpClient();
-
     // Sockets on some platforms can have large buffers that mean writes do not block when
     // required. These socket factories explicitly set the buffer sizes on sockets created.
+    server = new MockWebServer();
     server.setServerSocketFactory(
         new DelegatingServerSocketFactory(ServerSocketFactory.getDefault()) {
           @Override
@@ -63,14 +58,16 @@ protected ServerSocket configureServerSocket(ServerSocket serverSocket)
             return serverSocket;
           }
         });
-    client.setSocketFactory(new DelegatingSocketFactory(SocketFactory.getDefault()) {
-      @Override
-      protected Socket configureSocket(Socket socket) throws IOException {
-        socket.setSendBufferSize(SOCKET_BUFFER_SIZE);
-        socket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
-        return socket;
-      }
-    });
+    client = new OkHttpClient.Builder()
+        .socketFactory(new DelegatingSocketFactory(SocketFactory.getDefault()) {
+          @Override
+          protected Socket configureSocket(Socket socket) throws IOException {
+            socket.setSendBufferSize(SOCKET_BUFFER_SIZE);
+            socket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
+            return socket;
+          }
+        })
+        .build();
   }
 
   @Test public void interruptWritingRequestBody() throws Exception {
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/tls/HostnameVerifierTest.java b/okhttp-tests/src/test/java/okhttp3/internal/tls/HostnameVerifierTest.java
index da6056aa56..f03f197d94 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/tls/HostnameVerifierTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/tls/HostnameVerifierTest.java
@@ -17,13 +17,14 @@
 
 package okhttp3.internal.tls;
 
-import okhttp3.internal.Util;
 import java.io.ByteArrayInputStream;
 import java.security.cert.CertificateFactory;
 import java.security.cert.X509Certificate;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLSession;
 import javax.security.auth.x500.X500Principal;
+import okhttp3.FakeSSLSession;
+import okhttp3.internal.Util;
 import org.junit.Ignore;
 import org.junit.Test;
 
@@ -32,8 +33,8 @@
 import static org.junit.Assert.assertTrue;
 
 /**
- * Tests for our hostname verifier. Most of these tests are from AOSP, which
- * itself includes tests from the Apache HTTP Client test suite.
+ * Tests for our hostname verifier. Most of these tests are from AOSP, which itself includes tests
+ * from the Apache HTTP Client test suite.
  */
 public final class HostnameVerifierTest {
   private HostnameVerifier verifier = OkHostnameVerifier.INSTANCE;
@@ -144,9 +145,9 @@
   }
 
   /**
-   * Ignored due to incompatibilities between Android and Java on how non-ASCII
-   * subject alt names are parsed. Android fails to parse these, which means we
-   * fall back to the CN. The RI does parse them, so the CN is unused.
+   * Ignored due to incompatibilities between Android and Java on how non-ASCII subject alt names
+   * are parsed. Android fails to parse these, which means we fall back to the CN. The RI does parse
+   * them, so the CN is unused.
    */
   @Test @Ignore public void verifyNonAsciiSubjectAlt() throws Exception {
     // CN=foo.com, subjectAlt=bar.com, subjectAlt=&#x82b1;&#x5b50;.co.jp
@@ -329,9 +330,9 @@
   }
 
   /**
-   * Ignored due to incompatibilities between Android and Java on how non-ASCII
-   * subject alt names are parsed. Android fails to parse these, which means we
-   * fall back to the CN. The RI does parse them, so the CN is unused.
+   * Ignored due to incompatibilities between Android and Java on how non-ASCII subject alt names
+   * are parsed. Android fails to parse these, which means we fall back to the CN. The RI does parse
+   * them, so the CN is unused.
    */
   @Test @Ignore public void testWilcardNonAsciiSubjectAlt() throws Exception {
     // CN=*.foo.com, subjectAlt=*.bar.com, subjectAlt=*.&#x82b1;&#x5b50;.co.jp
@@ -432,10 +433,9 @@
   }
 
   /**
-   * Earlier implementations of Android's hostname verifier required that
-   * wildcard names wouldn't match "*.com" or similar. This was a nonstandard
-   * check that we've since dropped. It is the CA's responsibility to not hand
-   * out certificates that match so broadly.
+   * Earlier implementations of Android's hostname verifier required that wildcard names wouldn't
+   * match "*.com" or similar. This was a nonstandard check that we've since dropped. It is the CA's
+   * responsibility to not hand out certificates that match so broadly.
    */
   @Test public void wildcardsDoesNotNeedTwoDots() throws Exception {
     // openssl req -x509 -nodes -days 36500 -subj '/CN=*.com' -newkey rsa:512 -out cert.pem
@@ -518,28 +518,28 @@
 
   @Test public void verifyAsIpAddress() {
     // IPv4
-    assertTrue(OkHostnameVerifier.verifyAsIpAddress("127.0.0.1"));
-    assertTrue(OkHostnameVerifier.verifyAsIpAddress("1.2.3.4"));
+    assertTrue(Util.verifyAsIpAddress("127.0.0.1"));
+    assertTrue(Util.verifyAsIpAddress("1.2.3.4"));
 
     // IPv6
-    assertTrue(OkHostnameVerifier.verifyAsIpAddress("::1"));
-    assertTrue(OkHostnameVerifier.verifyAsIpAddress("2001:db8::1"));
-    assertTrue(OkHostnameVerifier.verifyAsIpAddress("::192.168.0.1"));
-    assertTrue(OkHostnameVerifier.verifyAsIpAddress("::ffff:192.168.0.1"));
-    assertTrue(OkHostnameVerifier.verifyAsIpAddress("FEDC:BA98:7654:3210:FEDC:BA98:7654:3210"));
-    assertTrue(OkHostnameVerifier.verifyAsIpAddress("1080:0:0:0:8:800:200C:417A"));
-    assertTrue(OkHostnameVerifier.verifyAsIpAddress("1080::8:800:200C:417A"));
-    assertTrue(OkHostnameVerifier.verifyAsIpAddress("FF01::101"));
-    assertTrue(OkHostnameVerifier.verifyAsIpAddress("0:0:0:0:0:0:13.1.68.3"));
-    assertTrue(OkHostnameVerifier.verifyAsIpAddress("0:0:0:0:0:FFFF:129.144.52.38"));
-    assertTrue(OkHostnameVerifier.verifyAsIpAddress("::13.1.68.3"));
-    assertTrue(OkHostnameVerifier.verifyAsIpAddress("::FFFF:129.144.52.38"));
+    assertTrue(Util.verifyAsIpAddress("::1"));
+    assertTrue(Util.verifyAsIpAddress("2001:db8::1"));
+    assertTrue(Util.verifyAsIpAddress("::192.168.0.1"));
+    assertTrue(Util.verifyAsIpAddress("::ffff:192.168.0.1"));
+    assertTrue(Util.verifyAsIpAddress("FEDC:BA98:7654:3210:FEDC:BA98:7654:3210"));
+    assertTrue(Util.verifyAsIpAddress("1080:0:0:0:8:800:200C:417A"));
+    assertTrue(Util.verifyAsIpAddress("1080::8:800:200C:417A"));
+    assertTrue(Util.verifyAsIpAddress("FF01::101"));
+    assertTrue(Util.verifyAsIpAddress("0:0:0:0:0:0:13.1.68.3"));
+    assertTrue(Util.verifyAsIpAddress("0:0:0:0:0:FFFF:129.144.52.38"));
+    assertTrue(Util.verifyAsIpAddress("::13.1.68.3"));
+    assertTrue(Util.verifyAsIpAddress("::FFFF:129.144.52.38"));
 
     // Hostnames
-    assertFalse(OkHostnameVerifier.verifyAsIpAddress("go"));
-    assertFalse(OkHostnameVerifier.verifyAsIpAddress("localhost"));
-    assertFalse(OkHostnameVerifier.verifyAsIpAddress("squareup.com"));
-    assertFalse(OkHostnameVerifier.verifyAsIpAddress("www.nintendo.co.jp"));
+    assertFalse(Util.verifyAsIpAddress("go"));
+    assertFalse(Util.verifyAsIpAddress("localhost"));
+    assertFalse(Util.verifyAsIpAddress("squareup.com"));
+    assertFalse(Util.verifyAsIpAddress("www.nintendo.co.jp"));
   }
 
   private X509Certificate certificate(String certificate) throws Exception {
diff --git a/okhttp-urlconnection/pom.xml b/okhttp-urlconnection/pom.xml
index a700dffd97..5004d5fb0d 100644
--- a/okhttp-urlconnection/pom.xml
+++ b/okhttp-urlconnection/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.0.0-SNAPSHOT</version>
+    <version>3.1.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-urlconnection</artifactId>
@@ -44,7 +44,7 @@
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-javadoc-plugin</artifactId>
         <configuration>
-          <excludePackageNames>okhttp3.internal.*</excludePackageNames>
+          <excludePackageNames>okhttp3.internal:okhttp3.internal.*</excludePackageNames>
           <links>
             <link>http://square.github.io/okhttp/javadoc/</link>
           </links>
diff --git a/okhttp/src/main/java/okhttp3/internal/http/AuthenticatorAdapter.java b/okhttp-urlconnection/src/main/java/okhttp3/JavaNetAuthenticator.java
similarity index 84%
rename from okhttp/src/main/java/okhttp3/internal/http/AuthenticatorAdapter.java
rename to okhttp-urlconnection/src/main/java/okhttp3/JavaNetAuthenticator.java
index 09d875999c..b5440a4d02 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/AuthenticatorAdapter.java
+++ b/okhttp-urlconnection/src/main/java/okhttp3/JavaNetAuthenticator.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.http;
+package okhttp3;
 
 import java.io.IOException;
 import java.net.Authenticator.RequestorType;
@@ -22,19 +22,13 @@
 import java.net.PasswordAuthentication;
 import java.net.Proxy;
 import java.util.List;
-import okhttp3.Authenticator;
-import okhttp3.Challenge;
-import okhttp3.Credentials;
-import okhttp3.HttpUrl;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.Route;
-
-/** Adapts {@link java.net.Authenticator} to {@link Authenticator}. */
-public final class AuthenticatorAdapter implements Authenticator {
-  /** Uses the global authenticator to get the password. */
-  public static final Authenticator INSTANCE = new AuthenticatorAdapter();
 
+/**
+ * Adapts {@link java.net.Authenticator} to {@link Authenticator}. Configure OkHttp to use {@link
+ * java.net.Authenticator} with {@link OkHttpClient.Builder#authenticator} or {@link
+ * OkHttpClient.Builder#proxyAuthenticator(Authenticator)}.
+ */
+public final class JavaNetAuthenticator implements Authenticator {
   @Override public Request authenticate(Route route, Response response) throws IOException {
     List<Challenge> challenges = response.challenges();
     Request request = response.request();
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/JavaNetCookieJar.java b/okhttp-urlconnection/src/main/java/okhttp3/JavaNetCookieJar.java
new file mode 100644
index 0000000000..3d9daf64b8
--- /dev/null
+++ b/okhttp-urlconnection/src/main/java/okhttp3/JavaNetCookieJar.java
@@ -0,0 +1,112 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.net.CookieHandler;
+import java.net.HttpCookie;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import okhttp3.internal.Internal;
+
+import static java.util.logging.Level.WARNING;
+import static okhttp3.internal.Util.delimiterOffset;
+import static okhttp3.internal.Util.trimSubstring;
+
+/** A cookie jar that delegates to a {@link java.net.CookieHandler}. */
+public final class JavaNetCookieJar implements CookieJar {
+  private final CookieHandler cookieHandler;
+
+  public JavaNetCookieJar(CookieHandler cookieHandler) {
+    this.cookieHandler = cookieHandler;
+  }
+
+  @Override public void saveFromResponse(HttpUrl url, List<Cookie> cookies) {
+    if (cookieHandler != null) {
+      List<String> cookieStrings = new ArrayList<>();
+      for (Cookie cookie : cookies) {
+        cookieStrings.add(cookie.toString());
+      }
+      Map<String, List<String>> multimap = Collections.singletonMap("Set-Cookie", cookieStrings);
+      try {
+        cookieHandler.put(url.uri(), multimap);
+      } catch (IOException e) {
+        Internal.logger.log(WARNING, "Saving cookies failed for " + url.resolve("/..."), e);
+      }
+    }
+  }
+
+  @Override public List<Cookie> loadForRequest(HttpUrl url) {
+    // The RI passes all headers. We don't have 'em, so we don't pass 'em!
+    Map<String, List<String>> headers = Collections.emptyMap();
+    Map<String, List<String>> cookieHeaders;
+    try {
+      cookieHeaders = cookieHandler.get(url.uri(), headers);
+    } catch (IOException e) {
+      Internal.logger.log(WARNING, "Loading cookies failed for " + url.resolve("/..."), e);
+      return Collections.emptyList();
+    }
+
+    List<Cookie> cookies = null;
+    for (Map.Entry<String, List<String>> entry : cookieHeaders.entrySet()) {
+      String key = entry.getKey();
+      if (("Cookie".equalsIgnoreCase(key) || "Cookie2".equalsIgnoreCase(key))
+          && !entry.getValue().isEmpty()) {
+        for (String header : entry.getValue()) {
+          if (cookies == null) cookies = new ArrayList<>();
+          cookies.addAll(decodeHeaderAsJavaNetCookies(url, header));
+        }
+      }
+    }
+
+    return cookies != null
+        ? Collections.unmodifiableList(cookies)
+        : Collections.<Cookie>emptyList();
+  }
+
+  /**
+   * Convert a request header to OkHttp's cookies via {@link HttpCookie}. That extra step handles
+   * multiple cookies in a single request header, which {@link Cookie#parse} doesn't support.
+   */
+  private List<Cookie> decodeHeaderAsJavaNetCookies(HttpUrl url, String header) {
+    List<Cookie> result = new ArrayList<>();
+    for (int pos = 0, limit = header.length(), pairEnd; pos < limit; pos = pairEnd + 1) {
+      pairEnd = delimiterOffset(header, pos, limit, ";,");
+      int equalsSign = delimiterOffset(header, pos, pairEnd, '=');
+      String name = trimSubstring(header, pos, equalsSign);
+      if (name.startsWith("$")) continue;
+
+      // We have either name=value or just a name.
+      String value = equalsSign < pairEnd
+          ? trimSubstring(header, equalsSign + 1, pairEnd)
+          : "";
+
+      // If the value is "quoted", drop the quotes.
+      if (value.startsWith("\"") && value.endsWith("\"")) {
+        value = value.substring(1, value.length() - 1);
+      }
+
+      result.add(new Cookie.Builder()
+          .name(name)
+          .value(value)
+          .domain(url.host())
+          .build());
+    }
+    return result;
+  }
+}
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/OkUrlFactory.java b/okhttp-urlconnection/src/main/java/okhttp3/OkUrlFactory.java
index 5a11ba972d..973c70578b 100644
--- a/okhttp-urlconnection/src/main/java/okhttp3/OkUrlFactory.java
+++ b/okhttp-urlconnection/src/main/java/okhttp3/OkUrlFactory.java
@@ -15,22 +15,24 @@
  */
 package okhttp3;
 
-import okhttp3.internal.huc.HttpURLConnectionImpl;
-import okhttp3.internal.huc.HttpsURLConnectionImpl;
 import java.net.HttpURLConnection;
 import java.net.Proxy;
 import java.net.URL;
 import java.net.URLConnection;
 import java.net.URLStreamHandler;
 import java.net.URLStreamHandlerFactory;
+import okhttp3.internal.URLFilter;
+import okhttp3.internal.huc.HttpURLConnectionImpl;
+import okhttp3.internal.huc.HttpsURLConnectionImpl;
 
 /**
  * @deprecated OkHttp will be dropping its ability to be used with {@link HttpURLConnection} in an
- *     upcoming release. Applications that need this should either downgrade to the system's
- *     built-in {@link HttpURLConnection} or upgrade to OkHttp's Request/Response API.
+ * upcoming release. Applications that need this should either downgrade to the system's built-in
+ * {@link HttpURLConnection} or upgrade to OkHttp's Request/Response API.
  */
 public final class OkUrlFactory implements URLStreamHandlerFactory, Cloneable {
-  private final OkHttpClient client;
+  private OkHttpClient client;
+  private URLFilter urlFilter;
 
   public OkUrlFactory(OkHttpClient client) {
     this.client = client;
@@ -40,25 +42,35 @@ public OkHttpClient client() {
     return client;
   }
 
+  public OkUrlFactory setClient(OkHttpClient client) {
+    this.client = client;
+    return this;
+  }
+
+  void setUrlFilter(URLFilter filter) {
+    urlFilter = filter;
+  }
+
   /**
-   * Returns a copy of this stream handler factory that includes a shallow copy
-   * of the internal {@linkplain OkHttpClient HTTP client}.
+   * Returns a copy of this stream handler factory that includes a shallow copy of the internal
+   * {@linkplain OkHttpClient HTTP client}.
    */
   @Override public OkUrlFactory clone() {
-    return new OkUrlFactory(client.clone());
+    return new OkUrlFactory(client);
   }
 
   public HttpURLConnection open(URL url) {
-    return open(url, client.getProxy());
+    return open(url, client.proxy());
   }
 
   HttpURLConnection open(URL url, Proxy proxy) {
     String protocol = url.getProtocol();
-    OkHttpClient copy = client.copyWithDefaults();
-    copy.setProxy(proxy);
+    OkHttpClient copy = client.newBuilder()
+        .proxy(proxy)
+        .build();
 
-    if (protocol.equals("http")) return new HttpURLConnectionImpl(url, copy);
-    if (protocol.equals("https")) return new HttpsURLConnectionImpl(url, copy);
+    if (protocol.equals("http")) return new HttpURLConnectionImpl(url, copy, urlFilter);
+    if (protocol.equals("https")) return new HttpsURLConnectionImpl(url, copy, urlFilter);
     throw new IllegalArgumentException("Unexpected protocol: " + protocol);
   }
 
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/JavaNetHeaders.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/JavaNetHeaders.java
new file mode 100644
index 0000000000..0b7a02e1f9
--- /dev/null
+++ b/okhttp-urlconnection/src/main/java/okhttp3/internal/JavaNetHeaders.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.List;
+import java.util.Map;
+import java.util.TreeMap;
+import okhttp3.Headers;
+
+public final class JavaNetHeaders {
+  private JavaNetHeaders() {
+  }
+
+  private static final Comparator<String> FIELD_NAME_COMPARATOR = new Comparator<String>() {
+    // @FindBugsSuppressWarnings("ES_COMPARING_PARAMETER_STRING_WITH_EQ")
+    @Override public int compare(String a, String b) {
+      if (a == b) {
+        return 0;
+      } else if (a == null) {
+        return -1;
+      } else if (b == null) {
+        return 1;
+      } else {
+        return String.CASE_INSENSITIVE_ORDER.compare(a, b);
+      }
+    }
+  };
+
+  /**
+   * Returns an immutable map containing each field to its list of values.
+   *
+   * @param valueForNullKey the request line for requests, or the status line for responses. If
+   * non-null, this value is mapped to the null key.
+   */
+  public static Map<String, List<String>> toMultimap(Headers headers, String valueForNullKey) {
+    Map<String, List<String>> result = new TreeMap<>(FIELD_NAME_COMPARATOR);
+    for (int i = 0, size = headers.size(); i < size; i++) {
+      String fieldName = headers.name(i);
+      String value = headers.value(i);
+
+      List<String> allValues = new ArrayList<>();
+      List<String> otherValues = result.get(fieldName);
+      if (otherValues != null) {
+        allValues.addAll(otherValues);
+      }
+      allValues.add(value);
+      result.put(fieldName, Collections.unmodifiableList(allValues));
+    }
+    if (valueForNullKey != null) {
+      result.put(null, Collections.unmodifiableList(Collections.singletonList(valueForNullKey)));
+    }
+    return Collections.unmodifiableMap(result);
+  }
+}
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/SystemPropertiesConnectionPool.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/SystemPropertiesConnectionPool.java
new file mode 100644
index 0000000000..e0c9523fb0
--- /dev/null
+++ b/okhttp-urlconnection/src/main/java/okhttp3/internal/SystemPropertiesConnectionPool.java
@@ -0,0 +1,67 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package okhttp3.internal;
+
+import java.util.concurrent.TimeUnit;
+import okhttp3.ConnectionPool;
+
+/**
+ * A shared connection pool that uses system properties for tuning parameters:
+ *
+ * <ul>
+ *     <li>{@code http.keepAlive} true if HTTP and SPDY connections should be pooled at all. Default
+ *         is true.
+ *     <li>{@code http.maxConnections} maximum number of idle connections to each to keep in the
+ *         pool. Default is 5.
+ *     <li>{@code http.keepAliveDuration} Time in milliseconds to keep the connection alive in the
+ *         pool before closing it. Default is 5 minutes. This property isn't used by {@code
+ *         HttpURLConnection}.
+ * </ul>
+ *
+ * <p>The default instance <i>doesn't</i> adjust its configuration as system properties are changed.
+ * This assumes that the applications that set these parameters do so before making HTTP
+ * connections, and that this class is initialized lazily.
+ */
+public final class SystemPropertiesConnectionPool {
+  private static final long DEFAULT_KEEP_ALIVE_DURATION_MS = 5 * 60 * 1000; // 5 min
+
+  public static final ConnectionPool INSTANCE;
+  static {
+    String keepAlive = System.getProperty("http.keepAlive");
+    int maxIdleConnections;
+    if (keepAlive != null && !Boolean.parseBoolean(keepAlive)) {
+      maxIdleConnections = 0;
+    } else {
+      String maxIdleConnectionsString = System.getProperty("http.maxConnections");
+      if (maxIdleConnectionsString != null) {
+        maxIdleConnections = Integer.parseInt(maxIdleConnectionsString);
+      } else {
+        maxIdleConnections = 5;
+      }
+    }
+
+    String keepAliveDurationString = System.getProperty("http.keepAliveDuration");
+    long keepAliveDurationMs = keepAliveDurationString != null
+        ? Long.parseLong(keepAliveDurationString)
+        : DEFAULT_KEEP_ALIVE_DURATION_MS;
+
+    INSTANCE = new ConnectionPool(maxIdleConnections, keepAliveDurationMs, TimeUnit.MILLISECONDS);
+  }
+
+  private SystemPropertiesConnectionPool() {
+  }
+}
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/URLFilter.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/URLFilter.java
new file mode 100644
index 0000000000..3b077f8bc4
--- /dev/null
+++ b/okhttp-urlconnection/src/main/java/okhttp3/internal/URLFilter.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal;
+import java.io.IOException;
+import java.net.URL;
+
+/**
+ * Request filter based on the request's URL.
+ *
+ * @deprecated use {@link okhttp3.Interceptor} for non-HttpURLConnection filtering.
+ */
+public interface URLFilter {
+  /**
+   * Check whether request to the provided URL is permitted to be issued.
+   *
+   * @throws IOException if the request to the provided URL is not permitted.
+   */
+  void checkURLPermitted(URL url) throws IOException;
+}
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/DelegatingHttpsURLConnection.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/DelegatingHttpsURLConnection.java
index c03eded309..86f4aa7807 100644
--- a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/DelegatingHttpsURLConnection.java
+++ b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/DelegatingHttpsURLConnection.java
@@ -16,7 +16,6 @@
  */
 package okhttp3.internal.huc;
 
-import okhttp3.Handshake;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
@@ -32,10 +31,11 @@
 import javax.net.ssl.HttpsURLConnection;
 import javax.net.ssl.SSLPeerUnverifiedException;
 import javax.net.ssl.SSLSocketFactory;
+import okhttp3.Handshake;
 
 /**
- * Implement an HTTPS connection by delegating to an HTTP connection for
- * everything but the HTTPS-specific stuff.
+ * Implement an HTTPS connection by delegating to an HTTP connection for everything but the
+ * HTTPS-specific stuff.
  */
 abstract class DelegatingHttpsURLConnection extends HttpsURLConnection {
   private final HttpURLConnection delegate;
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/HttpURLConnectionImpl.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/HttpURLConnectionImpl.java
index 668661f618..aa90bae4b4 100644
--- a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/HttpURLConnectionImpl.java
+++ b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/HttpURLConnectionImpl.java
@@ -17,29 +17,6 @@
 
 package okhttp3.internal.huc;
 
-import okhttp3.Connection;
-import okhttp3.Handshake;
-import okhttp3.Headers;
-import okhttp3.HttpUrl;
-import okhttp3.OkHttpClient;
-import okhttp3.Protocol;
-import okhttp3.Request;
-import okhttp3.RequestBody;
-import okhttp3.Response;
-import okhttp3.Route;
-import okhttp3.internal.Internal;
-import okhttp3.internal.Platform;
-import okhttp3.internal.Util;
-import okhttp3.internal.Version;
-import okhttp3.internal.http.HttpDate;
-import okhttp3.internal.http.HttpEngine;
-import okhttp3.internal.http.HttpMethod;
-import okhttp3.internal.http.OkHeaders;
-import okhttp3.internal.http.RequestException;
-import okhttp3.internal.http.RetryableSink;
-import okhttp3.internal.http.RouteException;
-import okhttp3.internal.http.StatusLine;
-import okhttp3.internal.http.StreamAllocation;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
@@ -63,27 +40,51 @@
 import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.TimeUnit;
+import okhttp3.Connection;
+import okhttp3.Handshake;
+import okhttp3.Headers;
+import okhttp3.HttpUrl;
+import okhttp3.OkHttpClient;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
+import okhttp3.Route;
+import okhttp3.internal.Internal;
+import okhttp3.internal.JavaNetHeaders;
+import okhttp3.internal.Platform;
+import okhttp3.internal.URLFilter;
+import okhttp3.internal.Util;
+import okhttp3.internal.Version;
+import okhttp3.internal.http.HttpDate;
+import okhttp3.internal.http.HttpEngine;
+import okhttp3.internal.http.HttpMethod;
+import okhttp3.internal.http.OkHeaders;
+import okhttp3.internal.http.RequestException;
+import okhttp3.internal.http.RetryableSink;
+import okhttp3.internal.http.RouteException;
+import okhttp3.internal.http.StatusLine;
+import okhttp3.internal.http.StreamAllocation;
 import okio.BufferedSink;
 import okio.Sink;
 
 /**
- * This implementation uses HttpEngine to send requests and receive responses.
- * This class may use multiple HttpEngines to follow redirects, authentication
- * retries, etc. to retrieve the final response body.
+ * This implementation uses HttpEngine to send requests and receive responses. This class may use
+ * multiple HttpEngines to follow redirects, authentication retries, etc. to retrieve the final
+ * response body.
  *
- * <h3>What does 'connected' mean?</h3>
- * This class inherits a {@code connected} field from the superclass. That field
- * is <strong>not</strong> used to indicate whether this URLConnection is
- * currently connected. Instead, it indicates whether a connection has ever been
- * attempted. Once a connection has been attempted, certain properties (request
- * header fields, request method, etc.) are immutable.
+ * <h3>What does 'connected' mean?</h3> This class inherits a {@code connected} field from the
+ * superclass. That field is <strong>not</strong> used to indicate whether this URLConnection is
+ * currently connected. Instead, it indicates whether a connection has ever been attempted. Once a
+ * connection has been attempted, certain properties (request header fields, request method, etc.)
+ * are immutable.
  */
 public class HttpURLConnectionImpl extends HttpURLConnection {
   private static final Set<String> METHODS = new LinkedHashSet<>(
       Arrays.asList("OPTIONS", "GET", "HEAD", "POST", "PUT", "DELETE", "TRACE", "PATCH"));
   private static final RequestBody EMPTY_REQUEST_BODY = RequestBody.create(null, new byte[0]);
 
-  final OkHttpClient client;
+  OkHttpClient client;
 
   private Headers.Builder requestHeaders = new Headers.Builder();
 
@@ -96,22 +97,29 @@
   private Headers responseHeaders;
 
   /**
-   * The most recently attempted route. This will be null if we haven't sent a
-   * request yet, or if the response comes from a cache.
+   * The most recently attempted route. This will be null if we haven't sent a request yet, or if
+   * the response comes from a cache.
    */
   private Route route;
 
   /**
-   * The most recently received TLS handshake. This will be null if we haven't
-   * connected yet, or if the most recent connection was HTTP (and not HTTPS).
+   * The most recently received TLS handshake. This will be null if we haven't connected yet, or if
+   * the most recent connection was HTTP (and not HTTPS).
    */
   Handshake handshake;
 
+  private URLFilter urlFilter;
+
   public HttpURLConnectionImpl(URL url, OkHttpClient client) {
     super(url);
     this.client = client;
   }
 
+  public HttpURLConnectionImpl(URL url, OkHttpClient client, URLFilter urlFilter) {
+    this(url, client);
+    this.urlFilter = urlFilter;
+  }
+
   @Override public final void connect() throws IOException {
     initHttpEngine();
     boolean success;
@@ -134,8 +142,8 @@ public HttpURLConnectionImpl(URL url, OkHttpClient client) {
   }
 
   /**
-   * Returns an input stream from the server in the case of error such as the
-   * requested file (txt, htm, html) is not found on the remote server.
+   * Returns an input stream from the server in the case of error such as the requested file (txt,
+   * htm, html) is not found on the remote server.
    */
   @Override public final InputStream getErrorStream() {
     try {
@@ -176,21 +184,22 @@ private static String responseSourceHeader(Response response) {
   }
 
   /**
-   * Returns the value of the field at {@code position}. Returns null if there
-   * are fewer than {@code position} headers.
+   * Returns the value of the field at {@code position}. Returns null if there are fewer than {@code
+   * position} headers.
    */
   @Override public final String getHeaderField(int position) {
     try {
-      return getHeaders().value(position);
+      Headers headers = getHeaders();
+      if (position < 0 || position >= headers.size()) return null;
+      return headers.value(position);
     } catch (IOException e) {
       return null;
     }
   }
 
   /**
-   * Returns the value of the field corresponding to the {@code fieldName}, or
-   * null if there is no such field. If the field has multiple values, the
-   * last value is returned.
+   * Returns the value of the field corresponding to the {@code fieldName}, or null if there is no
+   * such field. If the field has multiple values, the last value is returned.
    */
   @Override public final String getHeaderField(String fieldName) {
     try {
@@ -204,7 +213,9 @@ private static String responseSourceHeader(Response response) {
 
   @Override public final String getHeaderFieldKey(int position) {
     try {
-      return getHeaders().name(position);
+      Headers headers = getHeaders();
+      if (position < 0 || position >= headers.size()) return null;
+      return headers.name(position);
     } catch (IOException e) {
       return null;
     }
@@ -212,7 +223,7 @@ private static String responseSourceHeader(Response response) {
 
   @Override public final Map<String, List<String>> getHeaderFields() {
     try {
-      return OkHeaders.toMultimap(getHeaders(),
+      return JavaNetHeaders.toMultimap(getHeaders(),
           StatusLine.get(getResponse().getResponse()).toString());
     } catch (IOException e) {
       return Collections.emptyMap();
@@ -225,7 +236,7 @@ private static String responseSourceHeader(Response response) {
           "Cannot access request header fields after connection is set");
     }
 
-    return OkHeaders.toMultimap(requestHeaders.build(), null);
+    return JavaNetHeaders.toMultimap(requestHeaders.build(), null);
   }
 
   @Override public final InputStream getInputStream() throws IOException {
@@ -266,7 +277,7 @@ private static String responseSourceHeader(Response response) {
         ? url.getPort()
         : HttpUrl.defaultPort(url.getProtocol());
     if (usingProxy()) {
-      InetSocketAddress proxyAddress = (InetSocketAddress) client.getProxy().address();
+      InetSocketAddress proxyAddress = (InetSocketAddress) client.proxy().address();
       hostName = proxyAddress.getHostName();
       hostPort = proxyAddress.getPort();
     }
@@ -279,28 +290,34 @@ private static String responseSourceHeader(Response response) {
   }
 
   @Override public void setConnectTimeout(int timeoutMillis) {
-    client.setConnectTimeout(timeoutMillis, TimeUnit.MILLISECONDS);
+    client = client.newBuilder()
+        .connectTimeout(timeoutMillis, TimeUnit.MILLISECONDS)
+        .build();
   }
 
   @Override
   public void setInstanceFollowRedirects(boolean followRedirects) {
-    client.setFollowRedirects(followRedirects);
+    client = client.newBuilder()
+        .followRedirects(followRedirects)
+        .build();
   }
 
   @Override public boolean getInstanceFollowRedirects() {
-    return client.getFollowRedirects();
+    return client.followRedirects();
   }
 
   @Override public int getConnectTimeout() {
-    return client.getConnectTimeout();
+    return client.connectTimeoutMillis();
   }
 
   @Override public void setReadTimeout(int timeoutMillis) {
-    client.setReadTimeout(timeoutMillis, TimeUnit.MILLISECONDS);
+    client = client.newBuilder()
+        .readTimeout(timeoutMillis, TimeUnit.MILLISECONDS)
+        .build();
   }
 
   @Override public int getReadTimeout() {
-    return client.getReadTimeout();
+    return client.readTimeoutMillis();
   }
 
   private void initHttpEngine() throws IOException {
@@ -371,7 +388,9 @@ private HttpEngine newHttpEngine(String method, StreamAllocation streamAllocatio
     // If we're currently not using caches, make sure the engine's client doesn't have one.
     OkHttpClient engineClient = client;
     if (Internal.instance.internalCache(engineClient) != null && !getUseCaches()) {
-      engineClient = client.clone().setCache(null);
+      engineClient = client.newBuilder()
+          .cache(null)
+          .build();
     }
 
     return new HttpEngine(engineClient, request, bufferRequestBody, true, false, streamAllocation,
@@ -384,9 +403,8 @@ private String defaultUserAgent() {
   }
 
   /**
-   * Aggressively tries to get the final HTTP response, potentially making
-   * many HTTP requests in the process in order to cope with redirects and
-   * authentication.
+   * Aggressively tries to get the final HTTP response, potentially making many HTTP requests in the
+   * process in order to cope with redirects and authentication.
    */
   private HttpEngine getResponse() throws IOException {
     initHttpEngine();
@@ -440,18 +458,21 @@ private HttpEngine getResponse() throws IOException {
   }
 
   /**
-   * Sends a request and optionally reads a response. Returns true if the
-   * request was successfully executed, and false if the request can be
-   * retried. Throws an exception if the request failed permanently.
+   * Sends a request and optionally reads a response. Returns true if the request was successfully
+   * executed, and false if the request can be retried. Throws an exception if the request failed
+   * permanently.
    */
   private boolean execute(boolean readResponse) throws IOException {
     boolean releaseConnection = true;
+    if (urlFilter != null) {
+      urlFilter.checkURLPermitted(httpEngine.getRequest().url().url());
+    }
     try {
       httpEngine.sendRequest();
       Connection connection = httpEngine.getConnection();
       if (connection != null) {
-        route = connection.getRoute();
-        handshake = connection.getHandshake();
+        route = connection.route();
+        handshake = connection.handshake();
       } else {
         route = null;
         handshake = null;
@@ -469,7 +490,7 @@ private boolean execute(boolean readResponse) throws IOException {
       throw toThrow;
     } catch (RouteException e) {
       // The attempt to connect via a route failed. The request will not have been sent.
-      HttpEngine retryEngine = httpEngine.recover(e);
+      HttpEngine retryEngine = httpEngine.recover(e.getLastConnectException());
       if (retryEngine != null) {
         releaseConnection = false;
         httpEngine = retryEngine;
@@ -503,19 +524,20 @@ private boolean execute(boolean readResponse) throws IOException {
 
   /**
    * Returns true if either:
+   *
    * <ul>
    *   <li>A specific proxy was explicitly configured for this connection.
    *   <li>The response has already been retrieved, and a proxy was {@link
    *       java.net.ProxySelector selected} in order to get it.
    * </ul>
    *
-   * <p><strong>Warning:</strong> This method may return false before attempting
-   * to connect and true afterwards.
+   * <p><strong>Warning:</strong> This method may return false before attempting to connect and true
+   * afterwards.
    */
   @Override public final boolean usingProxy() {
     Proxy proxy = route != null
         ? route.proxy()
-        : client.getProxy();
+        : client.proxy();
     return proxy != null && proxy.type() != Proxy.Type.DIRECT;
   }
 
@@ -595,7 +617,7 @@ private boolean execute(boolean readResponse) throws IOException {
   private void setProtocols(String protocolsString, boolean append) {
     List<Protocol> protocolsList = new ArrayList<>();
     if (append) {
-      protocolsList.addAll(client.getProtocols());
+      protocolsList.addAll(client.protocols());
     }
     for (String protocol : protocolsString.split(",", -1)) {
       try {
@@ -604,7 +626,9 @@ private void setProtocols(String protocolsString, boolean append) {
         throw new IllegalStateException(e);
       }
     }
-    client.setProtocols(protocolsList);
+    client = client.newBuilder()
+        .protocols(protocolsList)
+        .build();
   }
 
   @Override public void setRequestMethod(String method) throws ProtocolException {
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/HttpsURLConnectionImpl.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/HttpsURLConnectionImpl.java
index 3b18d3d9d6..1bf1fa6566 100644
--- a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/HttpsURLConnectionImpl.java
+++ b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/HttpsURLConnectionImpl.java
@@ -16,11 +16,12 @@
  */
 package okhttp3.internal.huc;
 
-import okhttp3.Handshake;
-import okhttp3.OkHttpClient;
 import java.net.URL;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLSocketFactory;
+import okhttp3.Handshake;
+import okhttp3.OkHttpClient;
+import okhttp3.internal.URLFilter;
 
 public final class HttpsURLConnectionImpl extends DelegatingHttpsURLConnection {
   private final HttpURLConnectionImpl delegate;
@@ -29,6 +30,10 @@ public HttpsURLConnectionImpl(URL url, OkHttpClient client) {
     this(new HttpURLConnectionImpl(url, client));
   }
 
+  public HttpsURLConnectionImpl(URL url, OkHttpClient client, URLFilter filter) {
+    this(new HttpURLConnectionImpl(url, client, filter));
+  }
+
   public HttpsURLConnectionImpl(HttpURLConnectionImpl delegate) {
     super(delegate);
     this.delegate = delegate;
@@ -48,19 +53,23 @@ public HttpsURLConnectionImpl(HttpURLConnectionImpl delegate) {
   }
 
   @Override public void setHostnameVerifier(HostnameVerifier hostnameVerifier) {
-    delegate.client.setHostnameVerifier(hostnameVerifier);
+    delegate.client = delegate.client.newBuilder()
+        .hostnameVerifier(hostnameVerifier)
+        .build();
   }
 
   @Override public HostnameVerifier getHostnameVerifier() {
-    return delegate.client.getHostnameVerifier();
+    return delegate.client.hostnameVerifier();
   }
 
   @Override public void setSSLSocketFactory(SSLSocketFactory sslSocketFactory) {
-    delegate.client.setSslSocketFactory(sslSocketFactory);
+    delegate.client = delegate.client.newBuilder()
+        .sslSocketFactory(sslSocketFactory)
+        .build();
   }
 
   @Override public SSLSocketFactory getSSLSocketFactory() {
-    return delegate.client.getSslSocketFactory();
+    return delegate.client.sslSocketFactory();
   }
 
   @Override public long getContentLengthLong() {
diff --git a/okhttp-urlconnection/src/test/java/okhttp3/OkUrlFactoryTest.java b/okhttp-urlconnection/src/test/java/okhttp3/OkUrlFactoryTest.java
index 1856c2c1ce..d357807ef3 100644
--- a/okhttp-urlconnection/src/test/java/okhttp3/OkUrlFactoryTest.java
+++ b/okhttp-urlconnection/src/test/java/okhttp3/OkUrlFactoryTest.java
@@ -1,18 +1,23 @@
 package okhttp3;
 
-import okhttp3.internal.http.OkHeaders;
-import okhttp3.internal.io.InMemoryFileSystem;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
 import java.io.File;
 import java.io.IOException;
 import java.net.HttpURLConnection;
+import java.net.URL;
 import java.text.DateFormat;
 import java.text.SimpleDateFormat;
 import java.util.Date;
 import java.util.Locale;
 import java.util.TimeZone;
 import java.util.concurrent.TimeUnit;
+import javax.net.ssl.HttpsURLConnection;
+import javax.net.ssl.SSLContext;
+import okhttp3.internal.URLFilter;
+import okhttp3.internal.SslContextBuilder;
+import okhttp3.internal.http.OkHeaders;
+import okhttp3.internal.io.InMemoryFileSystem;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
 import okio.BufferedSource;
 import org.junit.After;
 import org.junit.Before;
@@ -33,9 +38,10 @@
   private Cache cache;
 
   @Before public void setUp() throws IOException {
-    OkHttpClient client = new OkHttpClient();
     cache = new Cache(new File("/cache/"), 10 * 1024 * 1024, fileSystem);
-    client.setCache(cache);
+    OkHttpClient client = new OkHttpClient.Builder()
+        .cache(cache)
+        .build();
     factory = new OkUrlFactory(client);
   }
 
@@ -44,8 +50,8 @@
   }
 
   /**
-   * Response code 407 should only come from proxy servers. Android's client
-   * throws if it is sent by an origin server.
+   * Response code 407 should only come from proxy servers. Android's client throws if it is sent by
+   * an origin server.
    */
   @Test public void originServerSends407() throws Exception {
     server.enqueue(new MockResponse().setResponseCode(407));
@@ -147,6 +153,66 @@ public void setInstanceFollowRedirectsFalse() throws Exception {
     assertResponseCode(connection, 302);
   }
 
+  @Test
+  public void testURLFilter() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+    final URL blockedURL = server.url("/a").url();
+    factory.setUrlFilter(new URLFilter() {
+      @Override
+      public void checkURLPermitted(URL url) throws IOException {
+        if (blockedURL.equals(url)) {
+          throw new IOException("Blocked");
+        }
+      }
+    });
+    try {
+      HttpURLConnection connection = factory.open(server.url("/a").url());
+      connection.getInputStream();
+      fail("Connection was successful");
+    } catch (IOException e) {
+      assertEquals("Blocked", e.getMessage());
+    }
+    HttpURLConnection connection = factory.open(server.url("/b").url());
+    assertResponseBody(connection, "B");
+  }
+
+  @Test
+  public void testURLFilterRedirect() throws Exception {
+    MockWebServer cleartextServer = new MockWebServer();
+    cleartextServer.enqueue(new MockResponse()
+        .setBody("Blocked!"));
+    final URL blockedURL = cleartextServer.url("/").url();
+
+    SSLContext context = SslContextBuilder.localhost();
+    server.useHttps(context.getSocketFactory(), false);
+    factory.setClient(factory.client().newBuilder()
+        .sslSocketFactory(context.getSocketFactory())
+        .followSslRedirects(true)
+        .build());
+    factory.setUrlFilter(new URLFilter() {
+      @Override
+      public void checkURLPermitted(URL url) throws IOException {
+        if (blockedURL.equals(url)) {
+          throw new IOException("Blocked");
+        }
+      }
+    });
+
+    server.enqueue(new MockResponse()
+        .setResponseCode(302)
+        .addHeader("Location: " + blockedURL)
+        .setBody("This page has moved"));
+    URL destination = server.url("/").url();
+    try {
+      HttpsURLConnection httpsConnection = (HttpsURLConnection) factory.open(destination);
+      httpsConnection.getInputStream();
+      fail("Connection was successful");
+    } catch (IOException e) {
+      assertEquals("Blocked", e.getMessage());
+    }
+  }
+
   private void assertResponseBody(HttpURLConnection connection, String expected) throws Exception {
     BufferedSource source = buffer(source(connection.getInputStream()));
     String actual = source.readString(US_ASCII);
diff --git a/okhttp-urlconnection/src/test/java/okhttp3/UrlConnectionCacheTest.java b/okhttp-urlconnection/src/test/java/okhttp3/UrlConnectionCacheTest.java
index 73c25ad49d..abec44ee2a 100644
--- a/okhttp-urlconnection/src/test/java/okhttp3/UrlConnectionCacheTest.java
+++ b/okhttp-urlconnection/src/test/java/okhttp3/UrlConnectionCacheTest.java
@@ -16,13 +16,6 @@
 
 package okhttp3;
 
-import okhttp3.internal.Internal;
-import okhttp3.internal.SslContextBuilder;
-import okhttp3.internal.Util;
-import okhttp3.internal.io.InMemoryFileSystem;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.mockwebserver.RecordedRequest;
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileNotFoundException;
@@ -30,9 +23,7 @@
 import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.io.OutputStream;
-import java.net.CookieHandler;
 import java.net.CookieManager;
-import java.net.HttpCookie;
 import java.net.HttpURLConnection;
 import java.net.ResponseCache;
 import java.net.URL;
@@ -41,7 +32,6 @@
 import java.security.cert.Certificate;
 import java.text.DateFormat;
 import java.text.SimpleDateFormat;
-import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Date;
 import java.util.List;
@@ -52,6 +42,13 @@
 import javax.net.ssl.HttpsURLConnection;
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLSession;
+import okhttp3.internal.Internal;
+import okhttp3.internal.SslContextBuilder;
+import okhttp3.internal.Util;
+import okhttp3.internal.io.InMemoryFileSystem;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.GzipSink;
@@ -83,25 +80,26 @@
   @Rule public InMemoryFileSystem fileSystem = new InMemoryFileSystem();
 
   private final SSLContext sslContext = SslContextBuilder.localhost();
-  private final OkUrlFactory client = new OkUrlFactory(new OkHttpClient());
+  private OkUrlFactory urlFactory = new OkUrlFactory(new OkHttpClient());
   private Cache cache;
   private final CookieManager cookieManager = new CookieManager();
 
   @Before public void setUp() throws Exception {
     server.setProtocolNegotiationEnabled(false);
     cache = new Cache(new File("/cache/"), Integer.MAX_VALUE, fileSystem);
-    client.client().setCache(cache);
-    CookieHandler.setDefault(cookieManager);
+    urlFactory = new OkUrlFactory(new OkHttpClient.Builder()
+        .cache(cache)
+        .cookieJar(new JavaNetCookieJar(cookieManager))
+        .build());
   }
 
   @After public void tearDown() throws Exception {
     ResponseCache.setDefault(null);
-    CookieHandler.setDefault(null);
     cache.delete();
   }
 
   @Test public void responseCacheAccessWithOkHttpMember() throws IOException {
-    assertSame(cache, client.client().getCache());
+    assertSame(cache, urlFactory.client().cache());
   }
 
   /**
@@ -109,57 +107,57 @@
    * http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.4
    */
   @Test public void responseCachingByResponseCode() throws Exception {
-      // Test each documented HTTP/1.1 code, plus the first unused value in each range.
-      // http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html
-
-      // We can't test 100 because it's not really a response.
-      // assertCached(false, 100);
-      assertCached(false, 101);
-      assertCached(false, 102);
-      assertCached(true,  200);
-      assertCached(false, 201);
-      assertCached(false, 202);
-      assertCached(true,  203);
-      assertCached(true,  204);
-      assertCached(false, 205);
-      assertCached(false, 206); //Electing to not cache partial responses
-      assertCached(false, 207);
-      assertCached(true,  300);
-      assertCached(true,  301);
-      assertCached(true,  302);
-      assertCached(false, 303);
-      assertCached(false, 304);
-      assertCached(false, 305);
-      assertCached(false, 306);
-      assertCached(true,  307);
-      assertCached(true,  308);
-      assertCached(false, 400);
-      assertCached(false, 401);
-      assertCached(false, 402);
-      assertCached(false, 403);
-      assertCached(true,  404);
-      assertCached(true,  405);
-      assertCached(false, 406);
-      assertCached(false, 408);
-      assertCached(false, 409);
-      // the HTTP spec permits caching 410s, but the RI doesn't.
-      assertCached(true,  410);
-      assertCached(false, 411);
-      assertCached(false, 412);
-      assertCached(false, 413);
-      assertCached(true,  414);
-      assertCached(false, 415);
-      assertCached(false, 416);
-      assertCached(false, 417);
-      assertCached(false, 418);
-
-      assertCached(false, 500);
-      assertCached(true,  501);
-      assertCached(false, 502);
-      assertCached(false, 503);
-      assertCached(false, 504);
-      assertCached(false, 505);
-      assertCached(false, 506);
+    // Test each documented HTTP/1.1 code, plus the first unused value in each range.
+    // http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html
+
+    // We can't test 100 because it's not really a response.
+    // assertCached(false, 100);
+    assertCached(false, 101);
+    assertCached(false, 102);
+    assertCached(true, 200);
+    assertCached(false, 201);
+    assertCached(false, 202);
+    assertCached(true, 203);
+    assertCached(true, 204);
+    assertCached(false, 205);
+    assertCached(false, 206); //Electing to not cache partial responses
+    assertCached(false, 207);
+    assertCached(true, 300);
+    assertCached(true, 301);
+    assertCached(true, 302);
+    assertCached(false, 303);
+    assertCached(false, 304);
+    assertCached(false, 305);
+    assertCached(false, 306);
+    assertCached(true, 307);
+    assertCached(true, 308);
+    assertCached(false, 400);
+    assertCached(false, 401);
+    assertCached(false, 402);
+    assertCached(false, 403);
+    assertCached(true, 404);
+    assertCached(true, 405);
+    assertCached(false, 406);
+    assertCached(false, 408);
+    assertCached(false, 409);
+    // the HTTP spec permits caching 410s, but the RI doesn't.
+    assertCached(true, 410);
+    assertCached(false, 411);
+    assertCached(false, 412);
+    assertCached(false, 413);
+    assertCached(true, 414);
+    assertCached(false, 415);
+    assertCached(false, 416);
+    assertCached(false, 417);
+    assertCached(false, 418);
+
+    assertCached(false, 500);
+    assertCached(true, 501);
+    assertCached(false, 502);
+    assertCached(false, 503);
+    assertCached(false, 504);
+    assertCached(false, 505);
+    assertCached(false, 506);
   }
 
   private void assertCached(boolean shouldPut, int responseCode) throws Exception {
@@ -179,7 +177,7 @@ private void assertCached(boolean shouldPut, int responseCode) throws Exception
     server.start();
 
     URL url = server.url("/").url();
-    HttpURLConnection conn = client.open(url);
+    HttpURLConnection conn = urlFactory.open(url);
     assertEquals(responseCode, conn.getResponseCode());
 
     // exhaust the content stream
@@ -220,17 +218,17 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     server.enqueue(response);
 
     // Make sure that calling skip() doesn't omit bytes from the cache.
-    HttpURLConnection urlConnection = client.open(server.url("/").url());
+    HttpURLConnection urlConnection = urlFactory.open(server.url("/").url());
     InputStream in = urlConnection.getInputStream();
     assertEquals("I love ", readAscii(urlConnection, "I love ".length()));
     reliableSkip(in, "puppies but hate ".length());
     assertEquals("spiders", readAscii(urlConnection, "spiders".length()));
     assertEquals(-1, in.read());
     in.close();
-    assertEquals(1, cache.getWriteSuccessCount());
-    assertEquals(0, cache.getWriteAbortCount());
+    assertEquals(1, cache.writeSuccessCount());
+    assertEquals(0, cache.writeAbortCount());
 
-    urlConnection = client.open(server.url("/").url()); // cached!
+    urlConnection = urlFactory.open(server.url("/").url()); // cached!
     in = urlConnection.getInputStream();
     assertEquals("I love puppies but hate spiders",
         readAscii(urlConnection, "I love puppies but hate spiders".length()));
@@ -239,10 +237,10 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
 
     assertEquals(-1, in.read());
     in.close();
-    assertEquals(1, cache.getWriteSuccessCount());
-    assertEquals(0, cache.getWriteAbortCount());
-    assertEquals(2, cache.getRequestCount());
-    assertEquals(1, cache.getHitCount());
+    assertEquals(1, cache.writeSuccessCount());
+    assertEquals(0, cache.writeAbortCount());
+    assertEquals(2, cache.requestCount());
+    assertEquals(1, cache.hitCount());
   }
 
   @Test public void secureResponseCaching() throws IOException {
@@ -251,7 +249,7 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .setBody("ABC"));
 
-    HttpsURLConnection c1 = (HttpsURLConnection) client.open(server.url("/").url());
+    HttpsURLConnection c1 = (HttpsURLConnection) urlFactory.open(server.url("/").url());
     c1.setSSLSocketFactory(sslContext.getSocketFactory());
     c1.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
     assertEquals("ABC", readAscii(c1));
@@ -263,14 +261,14 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     Principal peerPrincipal = c1.getPeerPrincipal();
     Principal localPrincipal = c1.getLocalPrincipal();
 
-    HttpsURLConnection c2 = (HttpsURLConnection) client.open(server.url("/").url()); // cached!
+    HttpsURLConnection c2 = (HttpsURLConnection) urlFactory.open(server.url("/").url()); // cached!
     c2.setSSLSocketFactory(sslContext.getSocketFactory());
     c2.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
     assertEquals("ABC", readAscii(c2));
 
-    assertEquals(2, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(1, cache.getHitCount());
+    assertEquals(2, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(1, cache.hitCount());
 
     assertEquals(suite, c2.getCipherSuite());
     assertEquals(localCerts, toListOrNull(c2.getLocalCertificates()));
@@ -289,15 +287,15 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
         .setBody("ABC"));
     server.enqueue(new MockResponse().setBody("DEF"));
 
-    HttpURLConnection connection = client.open(server.url("/").url());
+    HttpURLConnection connection = urlFactory.open(server.url("/").url());
     assertEquals("ABC", readAscii(connection));
 
-    connection = client.open(server.url("/").url()); // cached!
+    connection = urlFactory.open(server.url("/").url()); // cached!
     assertEquals("ABC", readAscii(connection));
 
-    assertEquals(4, cache.getRequestCount()); // 2 requests + 2 redirects
-    assertEquals(2, cache.getNetworkCount());
-    assertEquals(2, cache.getHitCount());
+    assertEquals(4, cache.requestCount()); // 2 requests + 2 redirects
+    assertEquals(2, cache.networkCount());
+    assertEquals(2, cache.hitCount());
   }
 
   @Test public void redirectToCachedResult() throws Exception {
@@ -306,18 +304,18 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
         .addHeader("Location: /foo"));
     server.enqueue(new MockResponse().setBody("DEF"));
 
-    assertEquals("ABC", readAscii(client.open(server.url("/foo").url())));
+    assertEquals("ABC", readAscii(urlFactory.open(server.url("/foo").url())));
     RecordedRequest request1 = server.takeRequest();
     assertEquals("GET /foo HTTP/1.1", request1.getRequestLine());
     assertEquals(0, request1.getSequenceNumber());
 
-    assertEquals("ABC", readAscii(client.open(server.url("/bar").url())));
+    assertEquals("ABC", readAscii(urlFactory.open(server.url("/bar").url())));
     RecordedRequest request2 = server.takeRequest();
     assertEquals("GET /bar HTTP/1.1", request2.getRequestLine());
     assertEquals(1, request2.getSequenceNumber());
 
     // an unrelated request should reuse the pooled connection
-    assertEquals("DEF", readAscii(client.open(server.url("/baz").url())));
+    assertEquals("DEF", readAscii(urlFactory.open(server.url("/baz").url())));
     RecordedRequest request3 = server.takeRequest();
     assertEquals("GET /baz HTTP/1.1", request3.getRequestLine());
     assertEquals(2, request3.getSequenceNumber());
@@ -334,28 +332,29 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
         .setBody("ABC"));
     server.enqueue(new MockResponse().setBody("DEF"));
 
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
+        .build());
 
-    HttpsURLConnection connection1 = (HttpsURLConnection) client.open(server.url("/").url());
+    HttpsURLConnection connection1 = (HttpsURLConnection) urlFactory.open(server.url("/").url());
     assertEquals("ABC", readAscii(connection1));
     assertNotNull(connection1.getCipherSuite());
 
     // Cached!
-    HttpsURLConnection connection2 = (HttpsURLConnection) client.open(server.url("/").url());
+    HttpsURLConnection connection2 = (HttpsURLConnection) urlFactory.open(server.url("/").url());
     assertEquals("ABC", readAscii(connection2));
     assertNotNull(connection2.getCipherSuite());
 
-    assertEquals(4, cache.getRequestCount()); // 2 direct + 2 redirect = 4
-    assertEquals(2, cache.getHitCount());
+    assertEquals(4, cache.requestCount()); // 2 direct + 2 redirect = 4
+    assertEquals(2, cache.hitCount());
     assertEquals(connection1.getCipherSuite(), connection2.getCipherSuite());
   }
 
   /**
-   * We've had bugs where caching and cross-protocol redirects yield class
-   * cast exceptions internal to the cache because we incorrectly assumed that
-   * HttpsURLConnection was always HTTPS and HttpURLConnection was always HTTP;
-   * in practice redirects mean that each can do either.
+   * We've had bugs where caching and cross-protocol redirects yield class cast exceptions internal
+   * to the cache because we incorrectly assumed that HttpsURLConnection was always HTTPS and
+   * HttpURLConnection was always HTTP; in practice redirects mean that each can do either.
    *
    * https://github.com/square/okhttp/issues/214
    */
@@ -371,18 +370,20 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
         .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
         .addHeader("Location: " + server2.url("/").url()));
 
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
+        .build());
 
-    HttpURLConnection connection1 = client.open(server.url("/").url());
+    HttpURLConnection connection1 = urlFactory.open(server.url("/").url());
     assertEquals("ABC", readAscii(connection1));
 
     // Cached!
-    HttpURLConnection connection2 = client.open(server.url("/").url());
+    HttpURLConnection connection2 = urlFactory.open(server.url("/").url());
     assertEquals("ABC", readAscii(connection2));
 
-    assertEquals(4, cache.getRequestCount()); // 2 direct + 2 redirect = 4
-    assertEquals(2, cache.getHitCount());
+    assertEquals(4, cache.requestCount()); // 2 direct + 2 redirect = 4
+    assertEquals(2, cache.hitCount());
   }
 
   @Test public void serverDisconnectsPrematurelyWithContentLengthHeader() throws IOException {
@@ -406,7 +407,7 @@ private void testServerPrematureDisconnect(TransferKind transferKind) throws IOE
     server.enqueue(new MockResponse().setBody("Request #2"));
 
     BufferedReader reader = new BufferedReader(
-        new InputStreamReader(client.open(server.url("/").url()).getInputStream()));
+        new InputStreamReader(urlFactory.open(server.url("/").url()).getInputStream()));
     assertEquals("ABCDE", reader.readLine());
     try {
       reader.readLine();
@@ -416,12 +417,12 @@ private void testServerPrematureDisconnect(TransferKind transferKind) throws IOE
       reader.close();
     }
 
-    assertEquals(1, cache.getWriteAbortCount());
-    assertEquals(0, cache.getWriteSuccessCount());
-    URLConnection connection = client.open(server.url("/").url());
+    assertEquals(1, cache.writeAbortCount());
+    assertEquals(0, cache.writeSuccessCount());
+    URLConnection connection = urlFactory.open(server.url("/").url());
     assertEquals("Request #2", readAscii(connection));
-    assertEquals(1, cache.getWriteAbortCount());
-    assertEquals(1, cache.getWriteSuccessCount());
+    assertEquals(1, cache.writeAbortCount());
+    assertEquals(1, cache.writeSuccessCount());
   }
 
   @Test public void clientPrematureDisconnectWithContentLengthHeader() throws IOException {
@@ -443,7 +444,7 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
     server.enqueue(response);
     server.enqueue(new MockResponse().setBody("Request #2"));
 
-    URLConnection connection = client.open(server.url("/").url());
+    URLConnection connection = urlFactory.open(server.url("/").url());
     InputStream in = connection.getInputStream();
     assertEquals("ABCDE", readAscii(connection, 5));
     in.close();
@@ -453,12 +454,12 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
     } catch (IOException expected) {
     }
 
-    assertEquals(1, cache.getWriteAbortCount());
-    assertEquals(0, cache.getWriteSuccessCount());
-    connection = client.open(server.url("/").url());
+    assertEquals(1, cache.writeAbortCount());
+    assertEquals(0, cache.writeSuccessCount());
+    connection = urlFactory.open(server.url("/").url());
     assertEquals("Request #2", readAscii(connection));
-    assertEquals(1, cache.getWriteAbortCount());
-    assertEquals(1, cache.getWriteSuccessCount());
+    assertEquals(1, cache.writeAbortCount());
+    assertEquals(1, cache.writeSuccessCount());
   }
 
   @Test public void defaultExpirationDateFullyCachedForLessThan24Hours() throws Exception {
@@ -472,8 +473,8 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
             .setBody("A"));
 
     URL url = server.url("/").url();
-    assertEquals("A", readAscii(client.open(url)));
-    URLConnection connection = client.open(url);
+    assertEquals("A", readAscii(urlFactory.open(url)));
+    URLConnection connection = urlFactory.open(url);
     assertEquals("A", readAscii(connection));
     assertNull(connection.getHeaderField("Warning"));
   }
@@ -499,8 +500,8 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
         .addHeader("Date: " + formatDate(-5, TimeUnit.DAYS))
         .setBody("A"));
 
-    assertEquals("A", readAscii(client.open(server.url("/").url())));
-    URLConnection connection = client.open(server.url("/").url());
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    URLConnection connection = urlFactory.open(server.url("/").url());
     assertEquals("A", readAscii(connection));
     assertEquals("113 HttpURLConnection \"Heuristic expiration\"",
         connection.getHeaderField("Warning"));
@@ -514,8 +515,8 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
     server.enqueue(new MockResponse().setBody("B"));
 
     URL url = server.url("/?foo=bar").url();
-    assertEquals("A", readAscii(client.open(url)));
-    assertEquals("B", readAscii(client.open(url)));
+    assertEquals("A", readAscii(urlFactory.open(url)));
+    assertEquals("B", readAscii(urlFactory.open(url)));
   }
 
   @Test public void expirationDateInThePastWithLastModifiedHeader() throws Exception {
@@ -629,13 +630,13 @@ private void testRequestMethod(String requestMethod, boolean expectCached) throw
 
     URL url = server.url("/").url();
 
-    HttpURLConnection request1 = client.open(url);
+    HttpURLConnection request1 = urlFactory.open(url);
     request1.setRequestMethod(requestMethod);
     addRequestBodyIfNecessary(requestMethod, request1);
     request1.getInputStream().close();
     assertEquals("1", request1.getHeaderField("X-Response-ID"));
 
-    URLConnection request2 = client.open(url);
+    URLConnection request2 = urlFactory.open(url);
     request2.getInputStream().close();
     if (expectCached) {
       assertEquals("1", request2.getHeaderField("X-Response-ID"));
@@ -667,14 +668,14 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
 
     URL url = server.url("/").url();
 
-    assertEquals("A", readAscii(client.open(url)));
+    assertEquals("A", readAscii(urlFactory.open(url)));
 
-    HttpURLConnection invalidate = client.open(url);
+    HttpURLConnection invalidate = urlFactory.open(url);
     invalidate.setRequestMethod(requestMethod);
     addRequestBodyIfNecessary(requestMethod, invalidate);
     assertEquals("B", readAscii(invalidate));
 
-    assertEquals("C", readAscii(client.open(url)));
+    assertEquals("C", readAscii(urlFactory.open(url)));
   }
 
   @Test public void postInvalidatesCacheWithUncacheableResponse() throws Exception {
@@ -688,14 +689,14 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
 
     URL url = server.url("/").url();
 
-    assertEquals("A", readAscii(client.open(url)));
+    assertEquals("A", readAscii(urlFactory.open(url)));
 
-    HttpURLConnection invalidate = client.open(url);
+    HttpURLConnection invalidate = urlFactory.open(url);
     invalidate.setRequestMethod("POST");
     addRequestBodyIfNecessary("POST", invalidate);
     assertEquals("B", readAscii(invalidate));
 
-    assertEquals("C", readAscii(client.open(url)));
+    assertEquals("C", readAscii(urlFactory.open(url)));
   }
 
   @Test public void etag() throws Exception {
@@ -767,11 +768,11 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
 
     URL url = server.url("/").url();
 
-    URLConnection range = client.open(url);
+    URLConnection range = urlFactory.open(url);
     range.addRequestProperty("Range", "bytes=1000-1001");
     assertEquals("AA", readAscii(range));
 
-    assertEquals("BB", readAscii(client.open(url)));
+    assertEquals("BB", readAscii(urlFactory.open(url)));
   }
 
   @Test public void serverReturnsDocumentOlderThanCache() throws Exception {
@@ -783,8 +784,8 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
 
     URL url = server.url("/").url();
 
-    assertEquals("A", readAscii(client.open(url)));
-    assertEquals("A", readAscii(client.open(url)));
+    assertEquals("A", readAscii(urlFactory.open(url)));
+    assertEquals("A", readAscii(urlFactory.open(url)));
   }
 
   @Test public void nonIdentityEncodingAndConditionalCache() throws Exception {
@@ -808,9 +809,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     // At least three request/response pairs are required because after the first request is cached
     // a different execution path might be taken. Thus modifications to the cache applied during
     // the second request might not be visible until another request is performed.
-    assertEquals("ABCABCABC", readAscii(client.open(server.url("/").url())));
-    assertEquals("ABCABCABC", readAscii(client.open(server.url("/").url())));
-    assertEquals("ABCABCABC", readAscii(client.open(server.url("/").url())));
+    assertEquals("ABCABCABC", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals("ABCABCABC", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals("ABCABCABC", readAscii(urlFactory.open(server.url("/").url())));
   }
 
   @Test public void notModifiedSpecifiesEncoding() throws Exception {
@@ -825,9 +826,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     server.enqueue(new MockResponse()
         .setBody("DEFDEFDEF"));
 
-    assertEquals("ABCABCABC", readAscii(client.open(server.url("/").url())));
-    assertEquals("ABCABCABC", readAscii(client.open(server.url("/").url())));
-    assertEquals("DEFDEFDEF", readAscii(client.open(server.url("/").url())));
+    assertEquals("ABCABCABC", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals("ABCABCABC", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals("DEFDEFDEF", readAscii(urlFactory.open(server.url("/").url())));
   }
 
   /** https://github.com/square/okhttp/issues/947 */
@@ -839,8 +840,8 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .addHeader("Cache-Control: max-age=60"));
     server.enqueue(new MockResponse().setBody("FAIL"));
 
-    assertEquals("ABCABCABC", readAscii(client.open(server.url("/").url())));
-    assertEquals("ABCABCABC", readAscii(client.open(server.url("/").url())));
+    assertEquals("ABCABCABC", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals("ABCABCABC", readAscii(urlFactory.open(server.url("/").url())));
   }
 
   @Test public void conditionalCacheHitIsNotDoublePooled() throws Exception {
@@ -849,13 +850,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .clearHeaders()
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    ConnectionPool pool = ConnectionPool.getDefault();
-    pool.evictAll();
-    client.client().setConnectionPool(pool);
-
-    assertEquals("A", readAscii(client.open(server.url("/").url())));
-    assertEquals("A", readAscii(client.open(server.url("/").url())));
-    assertEquals(1, client.client().getConnectionPool().getIdleConnectionCount());
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals(1, urlFactory.client().connectionPool().idleConnectionCount());
   }
 
   @Test public void expiresDateBeforeModifiedDate() throws Exception {
@@ -871,9 +868,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
     server.enqueue(new MockResponse().setBody("B"));
 
-    assertEquals("A", readAscii(client.open(server.url("/").url())));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
 
-    URLConnection connection = client.open(server.url("/").url());
+    URLConnection connection = urlFactory.open(server.url("/").url());
     connection.addRequestProperty("Cache-Control", "max-age=30");
     assertEquals("B", readAscii(connection));
   }
@@ -884,9 +881,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
     server.enqueue(new MockResponse().setBody("B"));
 
-    assertEquals("A", readAscii(client.open(server.url("/").url())));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
 
-    URLConnection connection = client.open(server.url("/").url());
+    URLConnection connection = urlFactory.open(server.url("/").url());
     connection.addRequestProperty("Cache-Control", "min-fresh=120");
     assertEquals("B", readAscii(connection));
   }
@@ -897,9 +894,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .addHeader("Date: " + formatDate(-4, TimeUnit.MINUTES)));
     server.enqueue(new MockResponse().setBody("B"));
 
-    assertEquals("A", readAscii(client.open(server.url("/").url())));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
 
-    URLConnection connection = client.open(server.url("/").url());
+    URLConnection connection = urlFactory.open(server.url("/").url());
     connection.addRequestProperty("Cache-Control", "max-stale=180");
     assertEquals("A", readAscii(connection));
     assertEquals("110 HttpURLConnection \"Response is stale\"",
@@ -912,9 +909,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .addHeader("Date: " + formatDate(-4, TimeUnit.MINUTES)));
     server.enqueue(new MockResponse().setBody("B"));
 
-    assertEquals("A", readAscii(client.open(server.url("/").url())));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
 
-    URLConnection connection = client.open(server.url("/").url());
+    URLConnection connection = urlFactory.open(server.url("/").url());
     connection.addRequestProperty("Cache-Control", "max-stale=180");
     assertEquals("B", readAscii(connection));
   }
@@ -922,12 +919,12 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
   @Test public void requestOnlyIfCachedWithNoResponseCached() throws IOException {
     // (no responses enqueued)
 
-    HttpURLConnection connection = client.open(server.url("/").url());
+    HttpURLConnection connection = urlFactory.open(server.url("/").url());
     connection.addRequestProperty("Cache-Control", "only-if-cached");
     assertGatewayTimeout(connection);
-    assertEquals(1, cache.getRequestCount());
-    assertEquals(0, cache.getNetworkCount());
-    assertEquals(0, cache.getHitCount());
+    assertEquals(1, cache.requestCount());
+    assertEquals(0, cache.networkCount());
+    assertEquals(0, cache.hitCount());
   }
 
   @Test public void requestOnlyIfCachedWithFullResponseCached() throws IOException {
@@ -935,13 +932,13 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .addHeader("Cache-Control: max-age=30")
         .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
 
-    assertEquals("A", readAscii(client.open(server.url("/").url())));
-    URLConnection connection = client.open(server.url("/").url());
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    URLConnection connection = urlFactory.open(server.url("/").url());
     connection.addRequestProperty("Cache-Control", "only-if-cached");
     assertEquals("A", readAscii(connection));
-    assertEquals(2, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(1, cache.getHitCount());
+    assertEquals(2, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(1, cache.hitCount());
   }
 
   @Test public void requestOnlyIfCachedWithConditionalResponseCached() throws IOException {
@@ -949,25 +946,25 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .addHeader("Cache-Control: max-age=30")
         .addHeader("Date: " + formatDate(-1, TimeUnit.MINUTES)));
 
-    assertEquals("A", readAscii(client.open(server.url("/").url())));
-    HttpURLConnection connection = client.open(server.url("/").url());
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    HttpURLConnection connection = urlFactory.open(server.url("/").url());
     connection.addRequestProperty("Cache-Control", "only-if-cached");
     assertGatewayTimeout(connection);
-    assertEquals(2, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(0, cache.getHitCount());
+    assertEquals(2, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(0, cache.hitCount());
   }
 
   @Test public void requestOnlyIfCachedWithUnhelpfulResponseCached() throws IOException {
     server.enqueue(new MockResponse().setBody("A"));
 
-    assertEquals("A", readAscii(client.open(server.url("/").url())));
-    HttpURLConnection connection = client.open(server.url("/").url());
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    HttpURLConnection connection = urlFactory.open(server.url("/").url());
     connection.addRequestProperty("Cache-Control", "only-if-cached");
     assertGatewayTimeout(connection);
-    assertEquals(2, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(0, cache.getHitCount());
+    assertEquals(2, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(0, cache.hitCount());
   }
 
   @Test public void requestCacheControlNoCache() throws Exception {
@@ -979,8 +976,8 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     server.enqueue(new MockResponse().setBody("B"));
 
     URL url = server.url("/").url();
-    assertEquals("A", readAscii(client.open(url)));
-    URLConnection connection = client.open(url);
+    assertEquals("A", readAscii(urlFactory.open(url)));
+    URLConnection connection = urlFactory.open(url);
     connection.setRequestProperty("Cache-Control", "no-cache");
     assertEquals("B", readAscii(connection));
   }
@@ -994,8 +991,8 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     server.enqueue(new MockResponse().setBody("B"));
 
     URL url = server.url("/").url();
-    assertEquals("A", readAscii(client.open(url)));
-    URLConnection connection = client.open(url);
+    assertEquals("A", readAscii(urlFactory.open(url)));
+    URLConnection connection = urlFactory.open(url);
     connection.setRequestProperty("Pragma", "no-cache");
     assertEquals("B", readAscii(connection));
   }
@@ -1026,9 +1023,9 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
     URL url = server.url("/").url();
-    assertEquals("A", readAscii(client.open(url)));
+    assertEquals("A", readAscii(urlFactory.open(url)));
 
-    HttpURLConnection connection = client.open(url);
+    HttpURLConnection connection = urlFactory.open(url);
     connection.addRequestProperty(conditionName, conditionValue);
     assertEquals(HttpURLConnection.HTTP_NOT_MODIFIED, connection.getResponseCode());
     assertEquals("", readAscii(connection));
@@ -1038,8 +1035,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
   }
 
   /**
-   * Confirm that {@link URLConnection#setIfModifiedSince} causes an
-   * If-Modified-Since header with a GMT timestamp.
+   * Confirm that {@link URLConnection#setIfModifiedSince} causes an If-Modified-Since header with a
+   * GMT timestamp.
    *
    * https://code.google.com/p/android/issues/detail?id=66135
    */
@@ -1047,7 +1044,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse().setBody("A"));
 
     URL url = server.url("/").url();
-    URLConnection connection = client.open(url);
+    URLConnection connection = urlFactory.open(url);
     connection.setIfModifiedSince(1393666200000L);
     assertEquals("A", readAscii(connection));
     RecordedRequest request = server.takeRequest();
@@ -1056,8 +1053,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
   }
 
   /**
-   * For Last-Modified and Date headers, we should echo the date back in the
-   * exact format we were served.
+   * For Last-Modified and Date headers, we should echo the date back in the exact format we were
+   * served.
    */
   @Test public void retainServedDateFormat() throws Exception {
     // Serve a response with a non-standard date format that OkHttp supports.
@@ -1076,8 +1073,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    assertEquals("A", readAscii(client.open(server.url("/").url())));
-    assertEquals("A", readAscii(client.open(server.url("/").url())));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
 
     // The first request has no conditions.
     RecordedRequest request1 = server.takeRequest();
@@ -1091,7 +1088,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
   @Test public void clientSuppliedConditionWithoutCachedResult() throws Exception {
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    HttpURLConnection connection = client.open(server.url("/").url());
+    HttpURLConnection connection = urlFactory.open(server.url("/").url());
     String clientIfModifiedSince = formatDate(-24, TimeUnit.HOURS);
     connection.addRequestProperty("If-Modified-Since", clientIfModifiedSince);
     assertEquals(HttpURLConnection.HTTP_NOT_MODIFIED, connection.getResponseCode());
@@ -1103,10 +1100,10 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse().setBody("B"));
 
     URL url = server.url("/").url();
-    URLConnection connection = client.open(url);
+    URLConnection connection = urlFactory.open(url);
     connection.addRequestProperty("Authorization", "password");
     assertEquals("A", readAscii(connection));
-    assertEquals("A", readAscii(client.open(url)));
+    assertEquals("A", readAscii(urlFactory.open(url)));
   }
 
   @Test public void contentLocationDoesNotPopulateCache() throws Exception {
@@ -1115,8 +1112,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
 
-    assertEquals("A", readAscii(client.open(server.url("/foo").url())));
-    assertEquals("B", readAscii(client.open(server.url("/bar").url())));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/foo").url())));
+    assertEquals("B", readAscii(urlFactory.open(server.url("/bar").url())));
   }
 
   @Test public void useCachesFalseDoesNotWriteToCache() throws Exception {
@@ -1124,10 +1121,10 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         new MockResponse().addHeader("Cache-Control: max-age=60").setBody("A").setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
 
-    URLConnection connection = client.open(server.url("/").url());
+    URLConnection connection = urlFactory.open(server.url("/").url());
     connection.setUseCaches(false);
     assertEquals("A", readAscii(connection));
-    assertEquals("B", readAscii(client.open(server.url("/").url())));
+    assertEquals("B", readAscii(urlFactory.open(server.url("/").url())));
   }
 
   @Test public void useCachesFalseDoesNotReadFromCache() throws Exception {
@@ -1135,22 +1132,22 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         new MockResponse().addHeader("Cache-Control: max-age=60").setBody("A").setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
 
-    assertEquals("A", readAscii(client.open(server.url("/").url())));
-    URLConnection connection = client.open(server.url("/").url());
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    URLConnection connection = urlFactory.open(server.url("/").url());
     connection.setUseCaches(false);
     assertEquals("B", readAscii(connection));
   }
 
   @Test public void defaultUseCachesSetsInitialValueOnly() throws Exception {
     URL url = new URL("http://localhost/");
-    URLConnection c1 = client.open(url);
-    URLConnection c2 = client.open(url);
+    URLConnection c1 = urlFactory.open(url);
+    URLConnection c2 = urlFactory.open(url);
     assertTrue(c1.getDefaultUseCaches());
     c1.setDefaultUseCaches(false);
     try {
       assertTrue(c1.getUseCaches());
       assertTrue(c2.getUseCaches());
-      URLConnection c3 = client.open(url);
+      URLConnection c3 = urlFactory.open(url);
       assertFalse(c3.getUseCaches());
     } finally {
       c1.setDefaultUseCaches(true);
@@ -1164,9 +1161,9 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
     server.enqueue(new MockResponse().setBody("B"));
 
-    assertEquals("A", readAscii(client.open(server.url("/a").url())));
-    assertEquals("A", readAscii(client.open(server.url("/a").url())));
-    assertEquals("B", readAscii(client.open(server.url("/b").url())));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/a").url())));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/a").url())));
+    assertEquals("B", readAscii(urlFactory.open(server.url("/b").url())));
 
     assertEquals(0, server.takeRequest().getSequenceNumber());
     assertEquals(1, server.takeRequest().getSequenceNumber());
@@ -1180,15 +1177,15 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse().setBody("B"));
     server.enqueue(new MockResponse().setBody("C"));
 
-    assertEquals("A", readAscii(client.open(server.url("/").url())));
-    assertEquals(1, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(0, cache.getHitCount());
-    assertEquals("B", readAscii(client.open(server.url("/").url())));
-    assertEquals("C", readAscii(client.open(server.url("/").url())));
-    assertEquals(3, cache.getRequestCount());
-    assertEquals(3, cache.getNetworkCount());
-    assertEquals(0, cache.getHitCount());
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals(1, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(0, cache.hitCount());
+    assertEquals("B", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals("C", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals(3, cache.requestCount());
+    assertEquals(3, cache.networkCount());
+    assertEquals(0, cache.hitCount());
   }
 
   @Test public void statisticsConditionalCacheHit() throws Exception {
@@ -1198,29 +1195,29 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    assertEquals("A", readAscii(client.open(server.url("/").url())));
-    assertEquals(1, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(0, cache.getHitCount());
-    assertEquals("A", readAscii(client.open(server.url("/").url())));
-    assertEquals("A", readAscii(client.open(server.url("/").url())));
-    assertEquals(3, cache.getRequestCount());
-    assertEquals(3, cache.getNetworkCount());
-    assertEquals(2, cache.getHitCount());
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals(1, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(0, cache.hitCount());
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals(3, cache.requestCount());
+    assertEquals(3, cache.networkCount());
+    assertEquals(2, cache.hitCount());
   }
 
   @Test public void statisticsFullCacheHit() throws Exception {
     server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60").setBody("A"));
 
-    assertEquals("A", readAscii(client.open(server.url("/").url())));
-    assertEquals(1, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(0, cache.getHitCount());
-    assertEquals("A", readAscii(client.open(server.url("/").url())));
-    assertEquals("A", readAscii(client.open(server.url("/").url())));
-    assertEquals(3, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(2, cache.getHitCount());
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals(1, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(0, cache.hitCount());
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals(3, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(2, cache.hitCount());
   }
 
   @Test public void varyMatchesChangedRequestHeaderField() throws Exception {
@@ -1230,11 +1227,11 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse().setBody("B"));
 
     URL url = server.url("/").url();
-    HttpURLConnection frConnection = client.open(url);
+    HttpURLConnection frConnection = urlFactory.open(url);
     frConnection.addRequestProperty("Accept-Language", "fr-CA");
     assertEquals("A", readAscii(frConnection));
 
-    HttpURLConnection enConnection = client.open(url);
+    HttpURLConnection enConnection = urlFactory.open(url);
     enConnection.addRequestProperty("Accept-Language", "en-US");
     assertEquals("B", readAscii(enConnection));
   }
@@ -1246,10 +1243,10 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse().setBody("B"));
 
     URL url = server.url("/").url();
-    URLConnection connection1 = client.open(url);
+    URLConnection connection1 = urlFactory.open(url);
     connection1.addRequestProperty("Accept-Language", "fr-CA");
     assertEquals("A", readAscii(connection1));
-    URLConnection connection2 = client.open(url);
+    URLConnection connection2 = urlFactory.open(url);
     connection2.addRequestProperty("Accept-Language", "fr-CA");
     assertEquals("A", readAscii(connection2));
   }
@@ -1260,8 +1257,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
 
-    assertEquals("A", readAscii(client.open(server.url("/").url())));
-    assertEquals("A", readAscii(client.open(server.url("/").url())));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
   }
 
   @Test public void varyMatchesAddedRequestHeaderField() throws Exception {
@@ -1270,8 +1267,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
 
-    assertEquals("A", readAscii(client.open(server.url("/").url())));
-    URLConnection fooConnection = client.open(server.url("/").url());
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    URLConnection fooConnection = urlFactory.open(server.url("/").url());
     fooConnection.addRequestProperty("Foo", "bar");
     assertEquals("B", readAscii(fooConnection));
   }
@@ -1282,10 +1279,10 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
 
-    URLConnection fooConnection = client.open(server.url("/").url());
+    URLConnection fooConnection = urlFactory.open(server.url("/").url());
     fooConnection.addRequestProperty("Foo", "bar");
     assertEquals("A", readAscii(fooConnection));
-    assertEquals("B", readAscii(client.open(server.url("/").url())));
+    assertEquals("B", readAscii(urlFactory.open(server.url("/").url())));
   }
 
   @Test public void varyFieldsAreCaseInsensitive() throws Exception {
@@ -1295,10 +1292,10 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse().setBody("B"));
 
     URL url = server.url("/").url();
-    URLConnection connection1 = client.open(url);
+    URLConnection connection1 = urlFactory.open(url);
     connection1.addRequestProperty("Accept-Language", "fr-CA");
     assertEquals("A", readAscii(connection1));
-    URLConnection connection2 = client.open(url);
+    URLConnection connection2 = urlFactory.open(url);
     connection2.addRequestProperty("accept-language", "fr-CA");
     assertEquals("A", readAscii(connection2));
   }
@@ -1311,12 +1308,12 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse().setBody("B"));
 
     URL url = server.url("/").url();
-    URLConnection connection1 = client.open(url);
+    URLConnection connection1 = urlFactory.open(url);
     connection1.addRequestProperty("Accept-Language", "fr-CA");
     connection1.addRequestProperty("Accept-Charset", "UTF-8");
     connection1.addRequestProperty("Accept-Encoding", "identity");
     assertEquals("A", readAscii(connection1));
-    URLConnection connection2 = client.open(url);
+    URLConnection connection2 = urlFactory.open(url);
     connection2.addRequestProperty("Accept-Language", "fr-CA");
     connection2.addRequestProperty("Accept-Charset", "UTF-8");
     connection2.addRequestProperty("Accept-Encoding", "identity");
@@ -1331,12 +1328,12 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse().setBody("B"));
 
     URL url = server.url("/").url();
-    URLConnection frConnection = client.open(url);
+    URLConnection frConnection = urlFactory.open(url);
     frConnection.addRequestProperty("Accept-Language", "fr-CA");
     frConnection.addRequestProperty("Accept-Charset", "UTF-8");
     frConnection.addRequestProperty("Accept-Encoding", "identity");
     assertEquals("A", readAscii(frConnection));
-    URLConnection enConnection = client.open(url);
+    URLConnection enConnection = urlFactory.open(url);
     enConnection.addRequestProperty("Accept-Language", "en-CA");
     enConnection.addRequestProperty("Accept-Charset", "UTF-8");
     enConnection.addRequestProperty("Accept-Encoding", "identity");
@@ -1350,12 +1347,12 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse().setBody("B"));
 
     URL url = server.url("/").url();
-    URLConnection connection1 = client.open(url);
+    URLConnection connection1 = urlFactory.open(url);
     connection1.addRequestProperty("Accept-Language", "fr-CA, fr-FR");
     connection1.addRequestProperty("Accept-Language", "en-US");
     assertEquals("A", readAscii(connection1));
 
-    URLConnection connection2 = client.open(url);
+    URLConnection connection2 = urlFactory.open(url);
     connection2.addRequestProperty("Accept-Language", "fr-CA, fr-FR");
     connection2.addRequestProperty("Accept-Language", "en-US");
     assertEquals("A", readAscii(connection2));
@@ -1368,12 +1365,12 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse().setBody("B"));
 
     URL url = server.url("/").url();
-    URLConnection connection1 = client.open(url);
+    URLConnection connection1 = urlFactory.open(url);
     connection1.addRequestProperty("Accept-Language", "fr-CA, fr-FR");
     connection1.addRequestProperty("Accept-Language", "en-US");
     assertEquals("A", readAscii(connection1));
 
-    URLConnection connection2 = client.open(url);
+    URLConnection connection2 = urlFactory.open(url);
     connection2.addRequestProperty("Accept-Language", "fr-CA");
     connection2.addRequestProperty("Accept-Language", "en-US");
     assertEquals("B", readAscii(connection2));
@@ -1385,8 +1382,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
 
-    assertEquals("A", readAscii(client.open(server.url("/").url())));
-    assertEquals("B", readAscii(client.open(server.url("/").url())));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals("B", readAscii(urlFactory.open(server.url("/").url())));
   }
 
   @Test public void varyAndHttps() throws Exception {
@@ -1397,13 +1394,13 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse().setBody("B"));
 
     URL url = server.url("/").url();
-    HttpsURLConnection connection1 = (HttpsURLConnection) client.open(url);
+    HttpsURLConnection connection1 = (HttpsURLConnection) urlFactory.open(url);
     connection1.setSSLSocketFactory(sslContext.getSocketFactory());
     connection1.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
     connection1.addRequestProperty("Accept-Language", "en-US");
     assertEquals("A", readAscii(connection1));
 
-    HttpsURLConnection connection2 = (HttpsURLConnection) client.open(url);
+    HttpsURLConnection connection2 = (HttpsURLConnection) urlFactory.open(url);
     connection2.setSSLSocketFactory(sslContext.getSocketFactory());
     connection2.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
     connection2.addRequestProperty("Accept-Language", "en-US");
@@ -1411,20 +1408,26 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
   }
 
   @Test public void cachePlusCookies() throws Exception {
-    server.enqueue(new MockResponse().addHeader(
-        "Set-Cookie: a=FIRST; domain=" + server.getCookieDomain() + ";")
+    RecordingCookieJar cookieJar = new RecordingCookieJar();
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .cookieJar(cookieJar)
+        .build());
+
+    server.enqueue(new MockResponse()
+        .addHeader("Set-Cookie: a=FIRST")
         .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Cache-Control: max-age=0")
         .setBody("A"));
-    server.enqueue(new MockResponse().addHeader(
-        "Set-Cookie: a=SECOND; domain=" + server.getCookieDomain() + ";")
+    server.enqueue(new MockResponse()
+        .addHeader("Set-Cookie: a=SECOND")
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
     URL url = server.url("/").url();
-    assertEquals("A", readAscii(client.open(url)));
-    assertCookies(url, "a=FIRST");
-    assertEquals("A", readAscii(client.open(url)));
-    assertCookies(url, "a=SECOND");
+    assertEquals("A", readAscii(urlFactory.open(url)));
+    cookieJar.assertResponseCookies("a=FIRST; path=/");
+
+    assertEquals("A", readAscii(urlFactory.open(url)));
+    cookieJar.assertResponseCookies("a=SECOND; path=/");
   }
 
   @Test public void getHeadersReturnsNetworkEndToEndHeaders() throws Exception {
@@ -1435,11 +1438,11 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse().addHeader("Allow: GET, HEAD, PUT")
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    URLConnection connection1 = client.open(server.url("/").url());
+    URLConnection connection1 = urlFactory.open(server.url("/").url());
     assertEquals("A", readAscii(connection1));
     assertEquals("GET, HEAD", connection1.getHeaderField("Allow"));
 
-    URLConnection connection2 = client.open(server.url("/").url());
+    URLConnection connection2 = urlFactory.open(server.url("/").url());
     assertEquals("A", readAscii(connection2));
     assertEquals("GET, HEAD, PUT", connection2.getHeaderField("Allow"));
   }
@@ -1452,11 +1455,11 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse().addHeader("Transfer-Encoding: none")
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    URLConnection connection1 = client.open(server.url("/").url());
+    URLConnection connection1 = urlFactory.open(server.url("/").url());
     assertEquals("A", readAscii(connection1));
     assertEquals("identity", connection1.getHeaderField("Transfer-Encoding"));
 
-    URLConnection connection2 = client.open(server.url("/").url());
+    URLConnection connection2 = urlFactory.open(server.url("/").url());
     assertEquals("A", readAscii(connection2));
     assertEquals("identity", connection2.getHeaderField("Transfer-Encoding"));
   }
@@ -1468,11 +1471,11 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setBody("A"));
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    URLConnection connection1 = client.open(server.url("/").url());
+    URLConnection connection1 = urlFactory.open(server.url("/").url());
     assertEquals("A", readAscii(connection1));
     assertEquals("199 test danger", connection1.getHeaderField("Warning"));
 
-    URLConnection connection2 = client.open(server.url("/").url());
+    URLConnection connection2 = urlFactory.open(server.url("/").url());
     assertEquals("A", readAscii(connection2));
     assertEquals(null, connection2.getHeaderField("Warning"));
   }
@@ -1484,28 +1487,20 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setBody("A"));
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    URLConnection connection1 = client.open(server.url("/").url());
+    URLConnection connection1 = urlFactory.open(server.url("/").url());
     assertEquals("A", readAscii(connection1));
     assertEquals("299 test danger", connection1.getHeaderField("Warning"));
 
-    URLConnection connection2 = client.open(server.url("/").url());
+    URLConnection connection2 = urlFactory.open(server.url("/").url());
     assertEquals("A", readAscii(connection2));
     assertEquals("299 test danger", connection2.getHeaderField("Warning"));
   }
 
-  public void assertCookies(URL url, String... expectedCookies) throws Exception {
-    List<String> actualCookies = new ArrayList<>();
-    for (HttpCookie cookie : cookieManager.getCookieStore().get(url.toURI())) {
-      actualCookies.add(cookie.toString());
-    }
-    assertEquals(Arrays.asList(expectedCookies), actualCookies);
-  }
-
   @Test public void cachePlusRange() throws Exception {
     assertNotCached(new MockResponse().setResponseCode(HttpURLConnection.HTTP_PARTIAL)
-            .addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
-            .addHeader("Content-Range: bytes 100-100/200")
-            .addHeader("Cache-Control: max-age=60"));
+        .addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
+        .addHeader("Content-Range: bytes 100-100/200")
+        .addHeader("Cache-Control: max-age=60"));
   }
 
   @Test public void conditionalHitUpdatesCache() throws Exception {
@@ -1518,18 +1513,18 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
     server.enqueue(new MockResponse().setBody("B"));
 
     // cache miss; seed the cache
-    HttpURLConnection connection1 = client.open(server.url("/a").url());
+    HttpURLConnection connection1 = urlFactory.open(server.url("/a").url());
     assertEquals("A", readAscii(connection1));
     assertEquals(null, connection1.getHeaderField("Allow"));
 
     // conditional cache hit; update the cache
-    HttpURLConnection connection2 = client.open(server.url("/a").url());
+    HttpURLConnection connection2 = urlFactory.open(server.url("/a").url());
     assertEquals(HttpURLConnection.HTTP_OK, connection2.getResponseCode());
     assertEquals("A", readAscii(connection2));
     assertEquals("GET, HEAD", connection2.getHeaderField("Allow"));
 
     // full cache hit
-    HttpURLConnection connection3 = client.open(server.url("/a").url());
+    HttpURLConnection connection3 = urlFactory.open(server.url("/a").url());
     assertEquals("A", readAscii(connection3));
     assertEquals("GET, HEAD", connection3.getHeaderField("Allow"));
 
@@ -1541,8 +1536,8 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
         .addHeader("Cache-Control: max-age=30")
         .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
 
-    assertEquals("A", readAscii(client.open(server.url("/").url())));
-    URLConnection connection = client.open(server.url("/").url());
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    URLConnection connection = urlFactory.open(server.url("/").url());
     connection.addRequestProperty("Cache-Control", "only-if-cached");
     assertEquals("A", readAscii(connection));
   }
@@ -1555,8 +1550,8 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
         .addHeader("Cache-Control: max-age=30")
         .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
 
-    assertEquals("A", readAscii(client.open(server.url("/").url())));
-    HttpURLConnection connection = client.open(server.url("/").url());
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    HttpURLConnection connection = urlFactory.open(server.url("/").url());
     assertEquals("B", readAscii(connection));
   }
 
@@ -1566,15 +1561,15 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
         .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
     server.enqueue(new MockResponse().setResponseCode(304));
 
-    assertEquals("A", readAscii(client.open(server.url("/").url())));
-    HttpURLConnection connection = client.open(server.url("/").url());
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    HttpURLConnection connection = urlFactory.open(server.url("/").url());
     assertEquals("A", readAscii(connection));
   }
 
   @Test public void responseSourceHeaderFetched() throws IOException {
     server.enqueue(new MockResponse().setBody("A"));
 
-    URLConnection connection = client.open(server.url("/").url());
+    URLConnection connection = urlFactory.open(server.url("/").url());
     assertEquals("A", readAscii(connection));
   }
 
@@ -1584,16 +1579,15 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
     Internal.instance.addLenient(headers, ": A");
     server.enqueue(new MockResponse().setHeaders(headers.build()).setBody("body"));
 
-    HttpURLConnection connection = client.open(server.url("/").url());
+    HttpURLConnection connection = urlFactory.open(server.url("/").url());
     assertEquals("A", connection.getHeaderField(""));
     assertEquals("body", readAscii(connection));
   }
 
   /**
-   * Old implementations of OkHttp's response cache wrote header fields like
-   * ":status: 200 OK". This broke our cached response parser because it split
-   * on the first colon. This regression test exists to help us read these old
-   * bad cache entries.
+   * Old implementations of OkHttp's response cache wrote header fields like ":status: 200 OK". This
+   * broke our cached response parser because it split on the first colon. This regression test
+   * exists to help us read these old bad cache entries.
    *
    * https://github.com/square/okhttp/issues/227
    */
@@ -1637,13 +1631,15 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
         + "2\n"
         + "\n"
         + "CLEAN " + urlKey + " " + entryMetadata.length() + " " + entryBody.length() + "\n";
-    writeFile(cache.getDirectory(), urlKey + ".0", entryMetadata);
-    writeFile(cache.getDirectory(), urlKey + ".1", entryBody);
-    writeFile(cache.getDirectory(), "journal", journalBody);
-    cache = new Cache(cache.getDirectory(), Integer.MAX_VALUE, fileSystem);
-    client.client().setCache(cache);
-
-    HttpURLConnection connection = client.open(url);
+    writeFile(cache.directory(), urlKey + ".0", entryMetadata);
+    writeFile(cache.directory(), urlKey + ".1", entryBody);
+    writeFile(cache.directory(), "journal", journalBody);
+    cache = new Cache(cache.directory(), Integer.MAX_VALUE, fileSystem);
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .cache(cache)
+        .build());
+
+    HttpURLConnection connection = urlFactory.open(url);
     assertEquals(entryBody, readAscii(connection));
     assertEquals("3", connection.getHeaderField("Content-Length"));
     assertEquals("foo", connection.getHeaderField("etag"));
@@ -1656,9 +1652,8 @@ private void writeFile(File directory, String file, String content) throws IOExc
   }
 
   /**
-   * @param delta the offset from the current date to use. Negative
-   * values yield dates in the past; positive values yield dates in the
-   * future.
+   * @param delta the offset from the current date to use. Negative values yield dates in the past;
+   * positive values yield dates in the future.
    */
   private String formatDate(long delta, TimeUnit timeUnit) {
     return formatDate(new Date(System.currentTimeMillis() + timeUnit.toMillis(delta)));
@@ -1685,8 +1680,8 @@ private void assertNotCached(MockResponse response) throws Exception {
     server.enqueue(new MockResponse().setBody("B"));
 
     URL url = server.url("/").url();
-    assertEquals("A", readAscii(client.open(url)));
-    assertEquals("B", readAscii(client.open(url)));
+    assertEquals("A", readAscii(urlFactory.open(url)));
+    assertEquals("B", readAscii(urlFactory.open(url)));
   }
 
   /** @return the request with the conditional get headers. */
@@ -1700,21 +1695,21 @@ private RecordedRequest assertConditionallyCached(MockResponse response) throws
     server.enqueue(new MockResponse().setStatus("HTTP/1.1 200 C-OK").setBody("C"));
 
     URL valid = server.url("/valid").url();
-    HttpURLConnection connection1 = client.open(valid);
+    HttpURLConnection connection1 = urlFactory.open(valid);
     assertEquals("A", readAscii(connection1));
     assertEquals(HttpURLConnection.HTTP_OK, connection1.getResponseCode());
     assertEquals("A-OK", connection1.getResponseMessage());
-    HttpURLConnection connection2 = client.open(valid);
+    HttpURLConnection connection2 = urlFactory.open(valid);
     assertEquals("A", readAscii(connection2));
     assertEquals(HttpURLConnection.HTTP_OK, connection2.getResponseCode());
     assertEquals("A-OK", connection2.getResponseMessage());
 
     URL invalid = server.url("/invalid").url();
-    HttpURLConnection connection3 = client.open(invalid);
+    HttpURLConnection connection3 = urlFactory.open(invalid);
     assertEquals("B", readAscii(connection3));
     assertEquals(HttpURLConnection.HTTP_OK, connection3.getResponseCode());
     assertEquals("B-OK", connection3.getResponseMessage());
-    HttpURLConnection connection4 = client.open(invalid);
+    HttpURLConnection connection4 = urlFactory.open(invalid);
     assertEquals("C", readAscii(connection4));
     assertEquals(HttpURLConnection.HTTP_OK, connection4.getResponseCode());
     assertEquals("C-OK", connection4.getResponseMessage());
@@ -1728,14 +1723,13 @@ private void assertFullyCached(MockResponse response) throws Exception {
     server.enqueue(response.setBody("B"));
 
     URL url = server.url("/").url();
-    assertEquals("A", readAscii(client.open(url)));
-    assertEquals("A", readAscii(client.open(url)));
+    assertEquals("A", readAscii(urlFactory.open(url)));
+    assertEquals("A", readAscii(urlFactory.open(url)));
   }
 
   /**
-   * Shortens the body of {@code response} but not the corresponding headers.
-   * Only useful to test how clients respond to the premature conclusion of
-   * the HTTP body.
+   * Shortens the body of {@code response} but not the corresponding headers. Only useful to test
+   * how clients respond to the premature conclusion of the HTTP body.
    */
   private MockResponse truncateViolently(MockResponse response, int numBytesToKeep) {
     response.setSocketPolicy(DISCONNECT_AT_END);
@@ -1748,9 +1742,8 @@ private MockResponse truncateViolently(MockResponse response, int numBytesToKeep
   }
 
   /**
-   * Reads {@code count} characters from the stream. If the stream is
-   * exhausted before {@code count} characters can be read, the remaining
-   * characters are returned and the stream is closed.
+   * Reads {@code count} characters from the stream. If the stream is exhausted before {@code count}
+   * characters can be read, the remaining characters are returned and the stream is closed.
    */
   private String readAscii(URLConnection connection, int count) throws IOException {
     HttpURLConnection httpConnection = (HttpURLConnection) connection;
diff --git a/okhttp-urlconnection/src/test/java/okhttp3/internal/huc/URLEncodingTest.java b/okhttp-urlconnection/src/test/java/okhttp3/internal/huc/URLEncodingTest.java
index 5f05639106..b61f266f4c 100644
--- a/okhttp-urlconnection/src/test/java/okhttp3/internal/huc/URLEncodingTest.java
+++ b/okhttp-urlconnection/src/test/java/okhttp3/internal/huc/URLEncodingTest.java
@@ -16,6 +16,12 @@
 
 package okhttp3.internal.huc;
 
+import java.io.IOException;
+import java.net.HttpURLConnection;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.net.URL;
+import java.util.concurrent.atomic.AtomicReference;
 import okhttp3.OkHttpClient;
 import okhttp3.OkUrlFactory;
 import okhttp3.Request;
@@ -24,28 +30,20 @@
 import okhttp3.internal.InternalCache;
 import okhttp3.internal.http.CacheRequest;
 import okhttp3.internal.http.CacheStrategy;
-
-import java.io.IOException;
-import java.net.HttpURLConnection;
-import java.net.URI;
-import java.net.URISyntaxException;
-import java.net.URL;
-import java.util.concurrent.atomic.AtomicReference;
 import org.junit.Ignore;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
 
 /**
- * Exercises HttpURLConnection to convert URL to a URI. Unlike URL#toURI,
- * HttpURLConnection recovers from URLs with unescaped but unsupported URI
- * characters like '{' and '|' by escaping these characters.
+ * Exercises HttpURLConnection to convert URL to a URI. Unlike URL#toURI, HttpURLConnection recovers
+ * from URLs with unescaped but unsupported URI characters like '{' and '|' by escaping these
+ * characters.
  */
 public final class URLEncodingTest {
   /**
-   * This test goes through the exhaustive set of interesting ASCII characters
-   * because most of those characters are interesting in some way according to
-   * RFC 2396 and RFC 2732. http://b/1158780
+   * This test goes through the exhaustive set of interesting ASCII characters because most of those
+   * characters are interesting in some way according to RFC 2396 and RFC 2732. http://b/1158780
    */
   @Test @Ignore public void lenientUrlToUri() throws Exception {
     // alphanum
@@ -125,8 +123,8 @@ private void testUrlToUriMapping(String string, String asAuthority, String asFil
   private URI backdoorUrlToUri(URL url) throws Exception {
     final AtomicReference<URI> uriReference = new AtomicReference<>();
 
-    OkHttpClient client = new OkHttpClient();
-    Internal.instance.setCache(client, new InternalCache() {
+    OkHttpClient.Builder builder = new OkHttpClient.Builder();
+    Internal.instance.setCache(builder, new InternalCache() {
       @Override
       public Response get(Request request) throws IOException {
         uriReference.set(request.url().uri());
@@ -160,7 +158,7 @@ public void trackResponse(CacheStrategy cacheStrategy) {
     });
 
     try {
-      HttpURLConnection connection = new OkUrlFactory(client).open(url);
+      HttpURLConnection connection = new OkUrlFactory(builder.build()).open(url);
       connection.getResponseCode();
     } catch (Exception expected) {
       if (expected.getCause() instanceof URISyntaxException) {
diff --git a/okhttp-ws-tests/pom.xml b/okhttp-ws-tests/pom.xml
index 3fc750ab5b..926b4be468 100644
--- a/okhttp-ws-tests/pom.xml
+++ b/okhttp-ws-tests/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.0.0-SNAPSHOT</version>
+    <version>3.1.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-ws-tests</artifactId>
diff --git a/okhttp-ws-tests/src/main/java/okhttp3/ws/AutobahnTester.java b/okhttp-ws-tests/src/main/java/okhttp3/ws/AutobahnTester.java
index 3401822360..707f58c116 100644
--- a/okhttp-ws-tests/src/main/java/okhttp3/ws/AutobahnTester.java
+++ b/okhttp-ws-tests/src/main/java/okhttp3/ws/AutobahnTester.java
@@ -15,12 +15,6 @@
  */
 package okhttp3.ws;
 
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.RequestBody;
-import okhttp3.Response;
-import okhttp3.ResponseBody;
-import okhttp3.internal.Version;
 import java.io.IOException;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutorService;
@@ -28,6 +22,12 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.atomic.AtomicReference;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+import okhttp3.internal.Version;
 import okio.Buffer;
 import okio.BufferedSource;
 
@@ -35,8 +35,8 @@
 import static okhttp3.ws.WebSocket.TEXT;
 
 /**
- * Exercises the web socket implementation against the
- * <a href="http://autobahn.ws/testsuite/">Autobahn Testsuite</a>.
+ * Exercises the web socket implementation against the <a
+ * href="http://autobahn.ws/testsuite/">Autobahn Testsuite</a>.
  */
 public final class AutobahnTester {
   private static final String HOST = "ws://localhost:9001";
@@ -63,7 +63,7 @@ public void run() throws IOException {
 
       updateReports();
     } finally {
-      client.getDispatcher().getExecutorService().shutdown();
+      client.dispatcher().executorService().shutdown();
     }
   }
 
diff --git a/okhttp-ws-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java b/okhttp-ws-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
index d9e0b9e7bb..90a803ec14 100644
--- a/okhttp-ws-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
+++ b/okhttp-ws-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
@@ -15,14 +15,14 @@
  */
 package okhttp3.internal.ws;
 
-import okhttp3.MediaType;
-import okhttp3.RequestBody;
-import okhttp3.ws.WebSocketRecorder;
 import java.io.Closeable;
 import java.io.IOException;
 import java.net.ProtocolException;
 import java.util.Random;
 import java.util.concurrent.Executor;
+import okhttp3.MediaType;
+import okhttp3.RequestBody;
+import okhttp3.ws.WebSocketRecorder;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -112,7 +112,7 @@
   @Test public void binaryMessage() throws IOException {
     client.sendMessage(RequestBody.create(BINARY, "Hello!"));
     server.readMessage();
-    serverListener.assertBinaryMessage(new byte[] { 'H', 'e', 'l', 'l', 'o', '!' });
+    serverListener.assertBinaryMessage(new byte[] {'H', 'e', 'l', 'l', 'o', '!'});
   }
 
   @Test public void missingContentTypeThrows() throws IOException {
diff --git a/okhttp-ws-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java b/okhttp-ws-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
index 602382ea8c..358b35990a 100644
--- a/okhttp-ws-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
+++ b/okhttp-ws-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
@@ -15,14 +15,14 @@
  */
 package okhttp3.internal.ws;
 
-import okhttp3.ResponseBody;
-import okhttp3.ws.WebSocketRecorder;
 import java.io.EOFException;
 import java.io.IOException;
 import java.net.ProtocolException;
 import java.util.Random;
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.regex.Pattern;
+import okhttp3.ResponseBody;
+import okhttp3.ws.WebSocketRecorder;
 import okhttp3.ws.WebSocketRecorder.MessageDelegate;
 import okio.Buffer;
 import okio.BufferedSource;
diff --git a/okhttp-ws-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java b/okhttp-ws-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java
index f7b80796f0..c60fe58341 100644
--- a/okhttp-ws-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java
+++ b/okhttp-ws-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java
@@ -198,13 +198,13 @@
   }
 
   @Test public void serverCloseWithCode() throws IOException {
-    serverWriter.writeClose(1005, null);
-    assertData("880203ed");
+    serverWriter.writeClose(1001, null);
+    assertData("880203e9");
   }
 
   @Test public void serverCloseWithCodeAndReason() throws IOException {
-    serverWriter.writeClose(1005, "Hello");
-    assertData("880703ed48656c6c6f");
+    serverWriter.writeClose(1001, "Hello");
+    assertData("880703e948656c6c6f");
   }
 
   @Test public void clientEmptyClose() throws IOException {
@@ -213,13 +213,13 @@
   }
 
   @Test public void clientCloseWithCode() throws IOException {
-    clientWriter.writeClose(1005, null);
-    assertData("888260b420bb6359");
+    clientWriter.writeClose(1001, null);
+    assertData("888260b420bb635d");
   }
 
   @Test public void clientCloseWithCodeAndReason() throws IOException {
-    clientWriter.writeClose(1005, "Hello");
-    assertData("888760b420bb635968de0cd84f");
+    clientWriter.writeClose(1001, "Hello");
+    assertData("888760b420bb635d68de0cd84f");
   }
 
   @Test public void closeWithOnlyReasonThrows() throws IOException {
@@ -232,7 +232,16 @@
       clientWriter.writeClose(98724976, "Hello");
       fail();
     } catch (IllegalArgumentException e) {
-      assertEquals("Code must be in range [1000,5000).", e.getMessage());
+      assertEquals("Code must be in range [1000,5000): 98724976", e.getMessage());
+    }
+  }
+
+  @Test public void closeReservedThrows() throws IOException {
+    try {
+      clientWriter.writeClose(1005, "Hello");
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("Code 1005 is reserved and may not be used.", e.getMessage());
     }
   }
 
diff --git a/okhttp-ws-tests/src/test/java/okhttp3/ws/WebSocketCallTest.java b/okhttp-ws-tests/src/test/java/okhttp3/ws/WebSocketCallTest.java
index a139d04dcb..9315152093 100644
--- a/okhttp-ws-tests/src/test/java/okhttp3/ws/WebSocketCallTest.java
+++ b/okhttp-ws-tests/src/test/java/okhttp3/ws/WebSocketCallTest.java
@@ -15,6 +15,13 @@
  */
 package okhttp3.ws;
 
+import java.io.IOException;
+import java.net.ProtocolException;
+import java.util.Random;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicReference;
+import javax.net.ssl.SSLContext;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
 import okhttp3.RequestBody;
@@ -23,14 +30,7 @@
 import okhttp3.internal.SslContextBuilder;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.testing.RecordingHostnameVerifier;
-import java.io.IOException;
-import java.net.ProtocolException;
-import java.util.Random;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicReference;
-import javax.net.ssl.SSLContext;
+import okhttp3.RecordingHostnameVerifier;
 import okio.Buffer;
 import org.junit.After;
 import org.junit.Rule;
@@ -43,8 +43,8 @@
 
   private final SSLContext sslContext = SslContextBuilder.localhost();
   private final WebSocketRecorder listener = new WebSocketRecorder();
-  private final OkHttpClient client = new OkHttpClient();
   private final Random random = new Random(0);
+  private OkHttpClient client = new OkHttpClient();
 
   @After public void tearDown() {
     listener.assertExhausted();
@@ -89,7 +89,7 @@
   }
 
   @Test public void okButNotOk() {
-    server.enqueue(new MockResponse());
+    server.enqueue(new MockResponse().setResponseCode(200));
     awaitWebSocket();
     listener.assertFailure(ProtocolException.class, "Expected HTTP 101 response but was '200 OK'");
   }
@@ -174,16 +174,20 @@
 
   @Test public void wssScheme() throws IOException {
     server.useHttps(sslContext.getSocketFactory(), false);
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
+    client = client.newBuilder()
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build();
 
     websocketScheme("wss");
   }
 
   @Test public void httpsScheme() throws IOException {
     server.useHttps(sslContext.getSocketFactory(), false);
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
+    client = client.newBuilder()
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build();
 
     websocketScheme("https");
   }
diff --git a/okhttp-ws-tests/src/test/java/okhttp3/ws/WebSocketRecorder.java b/okhttp-ws-tests/src/test/java/okhttp3/ws/WebSocketRecorder.java
index 14a111d1b0..0f019c6b79 100644
--- a/okhttp-ws-tests/src/test/java/okhttp3/ws/WebSocketRecorder.java
+++ b/okhttp-ws-tests/src/test/java/okhttp3/ws/WebSocketRecorder.java
@@ -15,14 +15,14 @@
  */
 package okhttp3.ws;
 
-import okhttp3.MediaType;
-import okhttp3.Response;
-import okhttp3.ResponseBody;
-import okhttp3.internal.ws.WebSocketReader;
 import java.io.IOException;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.TimeUnit;
+import okhttp3.MediaType;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+import okhttp3.internal.ws.WebSocketReader;
 import okio.Buffer;
 
 import static okhttp3.ws.WebSocket.BINARY;
diff --git a/okhttp-ws/pom.xml b/okhttp-ws/pom.xml
index c28edd0c95..3841ecc74e 100644
--- a/okhttp-ws/pom.xml
+++ b/okhttp-ws/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.0.0-SNAPSHOT</version>
+    <version>3.1.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-ws</artifactId>
diff --git a/okhttp-ws/src/main/java/okhttp3/internal/ws/RealWebSocket.java b/okhttp-ws/src/main/java/okhttp3/internal/ws/RealWebSocket.java
index 2f80c1d710..84bbbeedce 100644
--- a/okhttp-ws/src/main/java/okhttp3/internal/ws/RealWebSocket.java
+++ b/okhttp-ws/src/main/java/okhttp3/internal/ws/RealWebSocket.java
@@ -15,17 +15,17 @@
  */
 package okhttp3.internal.ws;
 
+import java.io.IOException;
+import java.net.ProtocolException;
+import java.util.Random;
+import java.util.concurrent.Executor;
+import java.util.concurrent.atomic.AtomicBoolean;
 import okhttp3.MediaType;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import okhttp3.internal.NamedRunnable;
 import okhttp3.ws.WebSocket;
 import okhttp3.ws.WebSocketListener;
-import java.io.IOException;
-import java.net.ProtocolException;
-import java.util.Random;
-import java.util.concurrent.Executor;
-import java.util.concurrent.atomic.AtomicBoolean;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -89,8 +89,8 @@ public RealWebSocket(boolean isClient, BufferedSource source, BufferedSink sink,
   }
 
   /**
-   * Read a single message from the web socket and deliver it to the listener. This method should
-   * be called in a loop with the return value indicating whether looping should continue.
+   * Read a single message from the web socket and deliver it to the listener. This method should be
+   * called in a loop with the return value indicating whether looping should continue.
    */
   public boolean readMessage() {
     try {
diff --git a/okhttp-ws/src/main/java/okhttp3/internal/ws/WebSocketProtocol.java b/okhttp-ws/src/main/java/okhttp3/internal/ws/WebSocketProtocol.java
index c01db03537..0a1126a147 100644
--- a/okhttp-ws/src/main/java/okhttp3/internal/ws/WebSocketProtocol.java
+++ b/okhttp-ws/src/main/java/okhttp3/internal/ws/WebSocketProtocol.java
@@ -15,6 +15,8 @@
  */
 package okhttp3.internal.ws;
 
+import java.net.ProtocolException;
+
 public final class WebSocketProtocol {
   /** Magic value which must be appended to the key in a response header. */
   public static final String ACCEPT_MAGIC = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
@@ -45,17 +47,15 @@
   static final int OPCODE_FLAG_CONTROL = 0b00001000;
 
   /**
-   * Byte 1 flag for whether the payload data is masked.
-   * <p>
-   * If this flag is set, the next four bytes represent the mask key. These bytes appear after
-   * any additional bytes specified by {@link #B1_MASK_LENGTH}.
+   * Byte 1 flag for whether the payload data is masked. <p> If this flag is set, the next four
+   * bytes represent the mask key. These bytes appear after any additional bytes specified by {@link
+   * #B1_MASK_LENGTH}.
    */
   static final int B1_FLAG_MASK = 0b10000000;
   /**
-   * Byte 1 mask for the payload length.
-   * <p>
-   * If this value is {@link #PAYLOAD_SHORT}, the next two bytes represent the length.
-   * If this value is {@link #PAYLOAD_LONG}, the next eight bytes represent the length.
+   * Byte 1 mask for the payload length. <p> If this value is {@link #PAYLOAD_SHORT}, the next two
+   * bytes represent the length. If this value is {@link #PAYLOAD_LONG}, the next eight bytes
+   * represent the length.
    */
   static final int B1_MASK_LENGTH = 0b01111111;
 
@@ -92,6 +92,21 @@ static void toggleMask(byte[] buffer, long byteCount, byte[] key, long frameByte
     }
   }
 
+  static void validateCloseCode(int code, boolean argument) throws ProtocolException {
+    String message = null;
+    if (code < 1000 || code >= 5000) {
+      message = "Code must be in range [1000,5000): " + code;
+    } else if ((code >= 1004 && code <= 1006) || (code >= 1012 && code <= 2999)) {
+      message = "Code " + code + " is reserved and may not be used.";
+    }
+    if (message != null) {
+      if (argument) {
+        throw new IllegalArgumentException(message);
+      }
+      throw new ProtocolException(message);
+    }
+  }
+
   private WebSocketProtocol() {
     throw new AssertionError("No instances.");
   }
diff --git a/okhttp-ws/src/main/java/okhttp3/internal/ws/WebSocketReader.java b/okhttp-ws/src/main/java/okhttp3/internal/ws/WebSocketReader.java
index 6d5f822257..6a72c6c77e 100644
--- a/okhttp-ws/src/main/java/okhttp3/internal/ws/WebSocketReader.java
+++ b/okhttp-ws/src/main/java/okhttp3/internal/ws/WebSocketReader.java
@@ -15,12 +15,12 @@
  */
 package okhttp3.internal.ws;
 
-import okhttp3.MediaType;
-import okhttp3.ResponseBody;
-import okhttp3.ws.WebSocket;
 import java.io.EOFException;
 import java.io.IOException;
 import java.net.ProtocolException;
+import okhttp3.MediaType;
+import okhttp3.ResponseBody;
+import okhttp3.ws.WebSocket;
 import okio.Buffer;
 import okio.BufferedSource;
 import okio.Okio;
@@ -46,6 +46,7 @@
 import static okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_LONG;
 import static okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_SHORT;
 import static okhttp3.internal.ws.WebSocketProtocol.toggleMask;
+import static okhttp3.internal.ws.WebSocketProtocol.validateCloseCode;
 
 /**
  * An <a href="http://tools.ietf.org/html/rfc6455">RFC 6455</a>-compatible WebSocket frame reader.
@@ -53,8 +54,11 @@
 public final class WebSocketReader {
   public interface FrameCallback {
     void onMessage(ResponseBody body) throws IOException;
+
     void onPing(Buffer buffer);
+
     void onPong(Buffer buffer);
+
     void onClose(int code, String reason);
   }
 
@@ -88,11 +92,12 @@ public WebSocketReader(boolean isClient, BufferedSource source, FrameCallback fr
 
   /**
    * Process the next protocol frame.
+   *
    * <ul>
-   * <li>If it is a control frame this will result in a single call to {@link FrameCallback}.</li>
-   * <li>If it is a message frame this will result in a single call to {@link
-   * FrameCallback#onMessage}. If the message spans multiple frames, each interleaved control
-   * frame will result in a corresponding call to {@link FrameCallback}.
+   *     <li>If it is a control frame this will result in a single call to {@link FrameCallback}.
+   *     <li>If it is a message frame this will result in a single call to {@link
+   *         FrameCallback#onMessage}. If the message spans multiple frames, each interleaved
+   *         control frame will result in a corresponding call to {@link FrameCallback}.
    * </ul>
    */
   public void processNextFrame() throws IOException {
@@ -192,12 +197,7 @@ private void readControlFrame() throws IOException {
             throw new ProtocolException("Malformed close payload length of 1.");
           } else if (bufferSize != 0) {
             code = buffer.readShort();
-            if (code < 1000 || code >= 5000) {
-              throw new ProtocolException("Code must be in range [1000,5000): " + code);
-            }
-            if ((code >= 1004 && code <= 1006) || (code >= 1012 && code <= 2999)) {
-              throw new ProtocolException("Code " + code + " is reserved and may not be used.");
-            }
+            validateCloseCode(code, false);
 
             reason = buffer.readUtf8();
           }
diff --git a/okhttp-ws/src/main/java/okhttp3/internal/ws/WebSocketWriter.java b/okhttp-ws/src/main/java/okhttp3/internal/ws/WebSocketWriter.java
index d4d63a3bca..f4f0794711 100644
--- a/okhttp-ws/src/main/java/okhttp3/internal/ws/WebSocketWriter.java
+++ b/okhttp-ws/src/main/java/okhttp3/internal/ws/WebSocketWriter.java
@@ -34,14 +34,15 @@
 import static okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_SHORT;
 import static okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_SHORT_MAX;
 import static okhttp3.internal.ws.WebSocketProtocol.toggleMask;
+import static okhttp3.internal.ws.WebSocketProtocol.validateCloseCode;
 
 /**
  * An <a href="http://tools.ietf.org/html/rfc6455">RFC 6455</a>-compatible WebSocket frame writer.
- * <p>
- * This class is partially thread safe. Only a single "main" thread should be sending messages via
- * calls to {@link #newMessageSink}, {@link #writePing}, or {@link #writeClose}. Other threads may
- * call {@link #writePing}, {@link #writePong}, or {@link #writeClose} which will interleave on the
- * wire with frames from the "main" sending thread.
+ *
+ * <p>This class is partially thread safe. Only a single "main" thread should be sending messages
+ * via calls to {@link #newMessageSink}, {@link #writePing}, or {@link #writeClose}. Other threads
+ * may call {@link #writePing}, {@link #writePong}, or {@link #writeClose} which will interleave on
+ * the wire with frames from the "main" sending thread.
  */
 public final class WebSocketWriter {
   private final boolean isClient;
@@ -89,16 +90,15 @@ public void writePong(Buffer payload) throws IOException {
   /**
    * Send a close frame with optional code and reason.
    *
-   * @param code Status code as defined by
-   * <a href="http://tools.ietf.org/html/rfc6455#section-7.4">Section 7.4 of RFC 6455</a> or
-   * {@code 0}.
+   * @param code Status code as defined by <a
+   * href="http://tools.ietf.org/html/rfc6455#section-7.4">Section 7.4 of RFC 6455</a> or {@code 0}.
    * @param reason Reason for shutting down or {@code null}.
    */
   public void writeClose(int code, String reason) throws IOException {
     Buffer payload = null;
     if (code != 0 || reason != null) {
-      if (code != 0 && (code < 1000 || code >= 5000)) {
-        throw new IllegalArgumentException("Code must be in range [1000,5000).");
+      if (code != 0) {
+        validateCloseCode(code, true);
       }
       payload = new Buffer();
       payload.writeShort(code);
diff --git a/okhttp-ws/src/main/java/okhttp3/ws/WebSocket.java b/okhttp-ws/src/main/java/okhttp3/ws/WebSocket.java
index 20536c11e0..7435c01d7f 100644
--- a/okhttp-ws/src/main/java/okhttp3/ws/WebSocket.java
+++ b/okhttp-ws/src/main/java/okhttp3/ws/WebSocket.java
@@ -15,9 +15,9 @@
  */
 package okhttp3.ws;
 
+import java.io.IOException;
 import okhttp3.MediaType;
 import okhttp3.RequestBody;
-import java.io.IOException;
 import okio.Buffer;
 
 /** Blocking interface to connect and write to a web socket. */
@@ -50,11 +50,11 @@
 
   /**
    * Send a close frame to the server.
-   * <p>
-   * The corresponding {@link WebSocketListener} will continue to get messages until its
-   * {@link WebSocketListener#onClose onClose()} method is called.
-   * <p>
-   * It is an error to call this method before calling close on an active writer. Calling this
+   *
+   * <p>The corresponding {@link WebSocketListener} will continue to get messages until its {@link
+   * WebSocketListener#onClose onClose()} method is called.
+   *
+   * <p>It is an error to call this method before calling close on an active writer. Calling this
    * method more than once has no effect.
    *
    * @throws IOException if unable to write the close message. Resources will still be freed.
diff --git a/okhttp-ws/src/main/java/okhttp3/ws/WebSocketCall.java b/okhttp-ws/src/main/java/okhttp3/ws/WebSocketCall.java
index a36a3cd57a..8e5c5ce055 100644
--- a/okhttp-ws/src/main/java/okhttp3/ws/WebSocketCall.java
+++ b/okhttp-ws/src/main/java/okhttp3/ws/WebSocketCall.java
@@ -15,6 +15,14 @@
  */
 package okhttp3.ws;
 
+import java.io.IOException;
+import java.net.ProtocolException;
+import java.security.SecureRandom;
+import java.util.Collections;
+import java.util.Random;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.LinkedBlockingDeque;
+import java.util.concurrent.ThreadPoolExecutor;
 import okhttp3.Call;
 import okhttp3.Callback;
 import okhttp3.OkHttpClient;
@@ -26,14 +34,6 @@
 import okhttp3.internal.http.StreamAllocation;
 import okhttp3.internal.ws.RealWebSocket;
 import okhttp3.internal.ws.WebSocketProtocol;
-import java.io.IOException;
-import java.net.ProtocolException;
-import java.security.SecureRandom;
-import java.util.Collections;
-import java.util.Random;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.LinkedBlockingDeque;
-import java.util.concurrent.ThreadPoolExecutor;
 import okio.ByteString;
 
 import static java.util.concurrent.TimeUnit.SECONDS;
@@ -64,11 +64,9 @@ public static WebSocketCall create(OkHttpClient client, Request request) {
     random.nextBytes(nonce);
     key = ByteString.of(nonce).base64();
 
-    // Copy the client. Otherwise changes (socket factory, redirect policy,
-    // etc.) may incorrectly be reflected in the request when it is executed.
-    client = client.clone();
-    // Force HTTP/1.1 until the WebSocket over HTTP/2 version is finalized.
-    client.setProtocols(Collections.singletonList(Protocol.HTTP_1_1));
+    client = client.newBuilder()
+        .protocols(Collections.singletonList(Protocol.HTTP_1_1))
+        .build();
 
     request = request.newBuilder()
         .header("Upgrade", "websocket")
@@ -83,8 +81,8 @@ public static WebSocketCall create(OkHttpClient client, Request request) {
   /**
    * Schedules the request to be executed at some point in the future.
    *
-   * <p>The {@link OkHttpClient#getDispatcher dispatcher} defines when the request will run:
-   * usually immediately unless there are several other requests currently being executed.
+   * <p>The {@link OkHttpClient#dispatcher dispatcher} defines when the request will run: usually
+   * immediately unless there are several other requests currently being executed.
    *
    * <p>This client will later call back {@code responseCallback} with either an HTTP response or a
    * failure exception. If you {@link #cancel} a request before it completes the callback will not
@@ -94,7 +92,7 @@ public static WebSocketCall create(OkHttpClient client, Request request) {
    */
   public void enqueue(final WebSocketListener listener) {
     Callback responseCallback = new Callback() {
-      @Override public void onResponse(Response response) throws IOException {
+      @Override public void onResponse(Call call, Response response) throws IOException {
         try {
           createWebSocket(response, listener);
         } catch (IOException e) {
@@ -102,7 +100,7 @@ public void enqueue(final WebSocketListener listener) {
         }
       }
 
-      @Override public void onFailure(Request request, IOException e) {
+      @Override public void onFailure(Call call, IOException e) {
         listener.onFailure(e, null);
       }
     };
@@ -182,7 +180,7 @@ private StreamWebSocket(StreamAllocation streamAllocation,
     @Override protected void close() throws IOException {
       replyExecutor.shutdown();
       streamAllocation.noNewStreams();
-      streamAllocation.streamFinished(streamAllocation.stream());
+      streamAllocation.streamFinished(true, streamAllocation.stream());
     }
   }
 }
diff --git a/okhttp-ws/src/main/java/okhttp3/ws/WebSocketListener.java b/okhttp-ws/src/main/java/okhttp3/ws/WebSocketListener.java
index feb7e1fba8..12d5e66aab 100644
--- a/okhttp-ws/src/main/java/okhttp3/ws/WebSocketListener.java
+++ b/okhttp-ws/src/main/java/okhttp3/ws/WebSocketListener.java
@@ -15,20 +15,19 @@
  */
 package okhttp3.ws;
 
+import java.io.IOException;
 import okhttp3.Response;
 import okhttp3.ResponseBody;
-import java.io.IOException;
 import okio.Buffer;
 
 /** Listener for server-initiated messages on a connected {@link WebSocket}. */
 public interface WebSocketListener {
   /**
    * Called when the request has successfully been upgraded to a web socket. This method is called
-   * on the message reading thread to allow setting up any state before the
-   * {@linkplain #onMessage message}, {@linkplain #onPong pong}, and {@link #onClose close}
-   * callbacks start.
-   * <p>
-   * <b>Do not</b> use this callback to write to the web socket. Start a new thread or use
+   * on the message reading thread to allow setting up any state before the {@linkplain #onMessage
+   * message}, {@linkplain #onPong pong}, and {@link #onClose close} callbacks start.
+   *
+   * <p><b>Do not</b> use this callback to write to the web socket. Start a new thread or use
    * another thread in your application.
    */
   void onOpen(WebSocket webSocket, Response response);
@@ -42,12 +41,12 @@
   void onFailure(IOException e, Response response);
 
   /**
-   * Called when a server message is received. The {@code type} indicates whether the
-   * {@code payload} should be interpreted as UTF-8 text or binary data.
+   * Called when a server message is received. The {@code type} indicates whether the {@code
+   * payload} should be interpreted as UTF-8 text or binary data.
    *
    * <p>Implementations <strong>must</strong> call {@code source.close()} before returning. This
-   * indicates completion of parsing the message payload and will consume any remaining bytes in
-   * the message.
+   * indicates completion of parsing the message payload and will consume any remaining bytes in the
+   * message.
    *
    * <p>The {@linkplain ResponseBody#contentType() content type} of {@code message} will be either
    * {@link WebSocket#TEXT} or {@link WebSocket#BINARY} which indicates the format of the message.
@@ -61,9 +60,8 @@
   void onPong(Buffer payload);
 
   /**
-   * Called when the server sends a close message. This may have been initiated
-   * from a call to {@link WebSocket#close(int, String) close()} or as an unprompted
-   * message from the server.
+   * Called when the server sends a close message. This may have been initiated from a call to
+   * {@link WebSocket#close(int, String) close()} or as an unprompted message from the server.
    *
    * @param code The <a href="http://tools.ietf.org/html/rfc6455#section-7.4.1">RFC-compliant</a>
    * status code.
diff --git a/okhttp/pom.xml b/okhttp/pom.xml
index 01fd8200b4..8629395db6 100644
--- a/okhttp/pom.xml
+++ b/okhttp/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.0.0-SNAPSHOT</version>
+    <version>3.1.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp</artifactId>
diff --git a/okhttp/src/main/java/okhttp3/Address.java b/okhttp/src/main/java/okhttp3/Address.java
index 51f2452184..cec154262d 100644
--- a/okhttp/src/main/java/okhttp3/Address.java
+++ b/okhttp/src/main/java/okhttp3/Address.java
@@ -26,14 +26,13 @@
 import static okhttp3.internal.Util.equal;
 
 /**
- * A specification for a connection to an origin server. For simple connections,
- * this is the server's hostname and port. If an explicit proxy is requested (or
- * {@linkplain Proxy#NO_PROXY no proxy} is explicitly requested), this also includes
- * that proxy information. For secure connections the address also includes the
- * SSL socket factory, hostname verifier, and certificate pinner.
+ * A specification for a connection to an origin server. For simple connections, this is the
+ * server's hostname and port. If an explicit proxy is requested (or {@linkplain Proxy#NO_PROXY no
+ * proxy} is explicitly requested), this also includes that proxy information. For secure
+ * connections the address also includes the SSL socket factory, hostname verifier, and certificate
+ * pinner.
  *
- * <p>HTTP requests that share the same {@code Address} may also share the same
- * {@link Connection}.
+ * <p>HTTP requests that share the same {@code Address} may also share the same {@link Connection}.
  */
 public final class Address {
   final HttpUrl url;
@@ -108,8 +107,8 @@ public Authenticator proxyAuthenticator() {
   }
 
   /**
-   * Returns the protocols the client supports. This method always returns a
-   * non-null list that contains minimally {@link Protocol#HTTP_1_1}.
+   * Returns the protocols the client supports. This method always returns a non-null list that
+   * contains minimally {@link Protocol#HTTP_1_1}.
    */
   public List<Protocol> protocols() {
     return protocols;
@@ -128,8 +127,8 @@ public ProxySelector proxySelector() {
   }
 
   /**
-   * Returns this address's explicitly-specified HTTP proxy, or null to
-   * delegate to the {@linkplain #proxySelector proxy selector}.
+   * Returns this address's explicitly-specified HTTP proxy, or null to delegate to the {@linkplain
+   * #proxySelector proxy selector}.
    */
   public Proxy proxy() {
     return proxy;
diff --git a/okhttp/src/main/java/okhttp3/Authenticator.java b/okhttp/src/main/java/okhttp3/Authenticator.java
index 01568038be..ede539805f 100644
--- a/okhttp/src/main/java/okhttp3/Authenticator.java
+++ b/okhttp/src/main/java/okhttp3/Authenticator.java
@@ -35,7 +35,7 @@
  *
  * <p>Whn authentication is requested by a proxy server, the response code is 407 and the
  * implementation should respond with a new request that sets the "Proxy-Authorization" header.
- *  <pre>   {@code
+ * <pre>   {@code
  *
  *    String credential = Credentials.basic(...)
  *    return response.request().newBuilder()
@@ -47,6 +47,13 @@
  * or both.
  */
 public interface Authenticator {
+  /** An authenticator that knows no credentials and makes no attempt to authenticate. */
+  Authenticator NONE = new Authenticator() {
+    @Override public Request authenticate(Route route, Response response) {
+      return null;
+    }
+  };
+
   /**
    * Returns a request that includes a credential to satisfy an authentication challenge in {@code
    * response}. Returns null if the challenge cannot be satisfied.
diff --git a/okhttp/src/main/java/okhttp3/Cache.java b/okhttp/src/main/java/okhttp3/Cache.java
index 14488c9a29..3717417b6d 100644
--- a/okhttp/src/main/java/okhttp3/Cache.java
+++ b/okhttp/src/main/java/okhttp3/Cache.java
@@ -16,16 +16,9 @@
 
 package okhttp3;
 
-import okhttp3.internal.DiskLruCache;
-import okhttp3.internal.InternalCache;
-import okhttp3.internal.Util;
-import okhttp3.internal.http.CacheRequest;
-import okhttp3.internal.http.CacheStrategy;
-import okhttp3.internal.http.HttpMethod;
-import okhttp3.internal.http.OkHeaders;
-import okhttp3.internal.http.StatusLine;
-import okhttp3.internal.io.FileSystem;
+import java.io.Closeable;
 import java.io.File;
+import java.io.Flushable;
 import java.io.IOException;
 import java.security.cert.Certificate;
 import java.security.cert.CertificateEncodingException;
@@ -36,6 +29,15 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.NoSuchElementException;
+import okhttp3.internal.DiskLruCache;
+import okhttp3.internal.InternalCache;
+import okhttp3.internal.Util;
+import okhttp3.internal.http.CacheRequest;
+import okhttp3.internal.http.CacheStrategy;
+import okhttp3.internal.http.HttpMethod;
+import okhttp3.internal.http.OkHeaders;
+import okhttp3.internal.http.StatusLine;
+import okhttp3.internal.io.FileSystem;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -51,14 +53,15 @@
  * bandwidth.
  *
  * <h3>Cache Optimization</h3>
- * To measure cache effectiveness, this class tracks three statistics:
+ *
+ * <p>To measure cache effectiveness, this class tracks three statistics:
  * <ul>
- *   <li><strong>{@linkplain #getRequestCount() Request Count:}</strong> the number of HTTP
- *     requests issued since this cache was created.
- *   <li><strong>{@linkplain #getNetworkCount() Network Count:}</strong> the number of those
- *     requests that required network use.
- *   <li><strong>{@linkplain #getHitCount() Hit Count:}</strong> the number of those requests whose
- *     responses were served by the cache.
+ *     <li><strong>{@linkplain #requestCount() Request Count:}</strong> the number of HTTP
+ *         requests issued since this cache was created.
+ *     <li><strong>{@linkplain #networkCount() Network Count:}</strong> the number of those
+ *         requests that required network use.
+ *     <li><strong>{@linkplain #hitCount() Hit Count:}</strong> the number of those requests
+ *         whose responses were served by the cache.
  * </ul>
  *
  * Sometimes a request will result in a conditional cache hit. If the cache contains a stale copy of
@@ -72,8 +75,9 @@
  * partial responses.
  *
  * <h3>Force a Network Response</h3>
- * In some situations, such as after a user clicks a 'refresh' button, it may be necessary to skip
- * the cache, and fetch data directly from the server. To force a full refresh, add the {@code
+ *
+ * <p>In some situations, such as after a user clicks a 'refresh' button, it may be necessary to
+ * skip the cache, and fetch data directly from the server. To force a full refresh, add the {@code
  * no-cache} directive: <pre>   {@code
  *
  *   Request request = new Request.Builder()
@@ -94,7 +98,8 @@
  * }</pre>
  *
  * <h3>Force a Cache Response</h3>
- * Sometimes you'll want to show resources if they are available immediately, but not otherwise.
+ *
+ * <p>Sometimes you'll want to show resources if they are available immediately, but not otherwise.
  * This can be used so your application can show <i>something</i> while waiting for the latest data
  * to be downloaded. To restrict a request to locally-cached resources, add the {@code
  * only-if-cached} directive: <pre>   {@code
@@ -128,7 +133,7 @@
  * caching directives. It even offers convenient constants {@link CacheControl#FORCE_NETWORK} and
  * {@link CacheControl#FORCE_CACHE} that address the use cases above.
  */
-public final class Cache {
+public final class Cache implements Closeable, Flushable {
   private static final int VERSION = 201105;
   private static final int ENTRY_METADATA = 0;
   private static final int ENTRY_BODY = 1;
@@ -138,18 +143,23 @@
     @Override public Response get(Request request) throws IOException {
       return Cache.this.get(request);
     }
+
     @Override public CacheRequest put(Response response) throws IOException {
       return Cache.this.put(response);
     }
+
     @Override public void remove(Request request) throws IOException {
       Cache.this.remove(request);
     }
+
     @Override public void update(Response cached, Response network) throws IOException {
       Cache.this.update(cached, network);
     }
+
     @Override public void trackConditionalCacheHit() {
       Cache.this.trackConditionalCacheHit();
     }
+
     @Override public void trackResponse(CacheStrategy cacheStrategy) {
       Cache.this.trackResponse(cacheStrategy);
     }
@@ -274,34 +284,31 @@ private void abortQuietly(DiskLruCache.Editor editor) {
   }
 
   /**
-   * Initialize the cache. This will include reading the journal files from
-   * the storage and building up the necessary in-memory cache information.
-   * <p>
-   * The initialization time may vary depending on the journal file size and
-   * the current actual cache size. The application needs to be aware of calling
-   * this function during the initialization phase and preferably in a background
-   * worker thread.
-   * <p>
-   * Note that if the application chooses to not call this method to initialize
-   * the cache. By default, the okhttp will perform lazy initialization upon the
-   * first usage of the cache.
+   * Initialize the cache. This will include reading the journal files from the storage and building
+   * up the necessary in-memory cache information.
+   *
+   * <p>The initialization time may vary depending on the journal file size and the current actual
+   * cache size. The application needs to be aware of calling this function during the
+   * initialization phase and preferably in a background worker thread.
+   *
+   * <p>Note that if the application chooses to not call this method to initialize the cache. By
+   * default, the okhttp will perform lazy initialization upon the first usage of the cache.
    */
   public void initialize() throws IOException {
     cache.initialize();
   }
 
   /**
-   * Closes the cache and deletes all of its stored values. This will delete
-   * all files in the cache directory including files that weren't created by
-   * the cache.
+   * Closes the cache and deletes all of its stored values. This will delete all files in the cache
+   * directory including files that weren't created by the cache.
    */
   public void delete() throws IOException {
     cache.delete();
   }
 
   /**
-   * Deletes all values stored in the cache. In-flight writes to the cache will
-   * complete normally, but the corresponding responses will not be stored.
+   * Deletes all values stored in the cache. In-flight writes to the cache will complete normally,
+   * but the corresponding responses will not be stored.
    */
   public void evictAll() throws IOException {
     cache.evictAll();
@@ -359,31 +366,31 @@ public void evictAll() throws IOException {
     };
   }
 
-  public synchronized int getWriteAbortCount() {
+  public synchronized int writeAbortCount() {
     return writeAbortCount;
   }
 
-  public synchronized int getWriteSuccessCount() {
+  public synchronized int writeSuccessCount() {
     return writeSuccessCount;
   }
 
-  public long getSize() throws IOException {
+  public long size() throws IOException {
     return cache.size();
   }
 
-  public long getMaxSize() {
+  public long maxSize() {
     return cache.getMaxSize();
   }
 
-  public void flush() throws IOException {
+  @Override public void flush() throws IOException {
     cache.flush();
   }
 
-  public void close() throws IOException {
+  @Override public void close() throws IOException {
     cache.close();
   }
 
-  public File getDirectory() {
+  public File directory() {
     return cache.getDirectory();
   }
 
@@ -397,7 +404,6 @@ private synchronized void trackResponse(CacheStrategy cacheStrategy) {
     if (cacheStrategy.networkRequest != null) {
       // If this is a conditional request, we'll increment hitCount if/when it hits.
       networkCount++;
-
     } else if (cacheStrategy.cacheResponse != null) {
       // This response uses the cache and not the network. That's a cache hit.
       hitCount++;
@@ -408,15 +414,15 @@ private synchronized void trackConditionalCacheHit() {
     hitCount++;
   }
 
-  public synchronized int getNetworkCount() {
+  public synchronized int networkCount() {
     return networkCount;
   }
 
-  public synchronized int getHitCount() {
+  public synchronized int hitCount() {
     return hitCount;
   }
 
-  public synchronized int getRequestCount() {
+  public synchronized int requestCount() {
     return requestCount;
   }
 
@@ -507,21 +513,20 @@ public CacheRequestImpl(final DiskLruCache.Editor editor) throws IOException {
      *   base64-encoded peerCertificate[0]
      *   base64-encoded peerCertificate[1]
      *   -1
+     *   TLSv1.2
      * }</pre>
-     * The file is newline separated. The first two lines are the URL and
-     * the request method. Next is the number of HTTP Vary request header
-     * lines, followed by those lines.
+     * The file is newline separated. The first two lines are the URL and the request method. Next
+     * is the number of HTTP Vary request header lines, followed by those lines.
      *
-     * <p>Next is the response status line, followed by the number of HTTP
-     * response header lines, followed by those lines.
+     * <p>Next is the response status line, followed by the number of HTTP response header lines,
+     * followed by those lines.
      *
-     * <p>HTTPS responses also contain SSL session information. This begins
-     * with a blank line, and then a line containing the cipher suite. Next
-     * is the length of the peer certificate chain. These certificates are
-     * base64-encoded and appear each on their own line. The next line
-     * contains the length of the local certificate chain. These
-     * certificates are also base64-encoded and appear each on their own
-     * line. A length of -1 is used to encode a null array.
+     * <p>HTTPS responses also contain SSL session information. This begins with a blank line, and
+     * then a line containing the cipher suite. Next is the length of the peer certificate chain.
+     * These certificates are base64-encoded and appear each on their own line. The next line
+     * contains the length of the local certificate chain. These certificates are also
+     * base64-encoded and appear each on their own line. A length of -1 is used to encode a null
+     * array. The last line is optional. If present, it contains the TLS version.
      */
     public Entry(Source in) throws IOException {
       try {
@@ -555,7 +560,10 @@ public Entry(Source in) throws IOException {
           CipherSuite cipherSuite = CipherSuite.forJavaName(cipherSuiteString);
           List<Certificate> peerCertificates = readCertificateList(source);
           List<Certificate> localCertificates = readCertificateList(source);
-          handshake = Handshake.get(cipherSuite, peerCertificates, localCertificates);
+          TlsVersion tlsVersion = !source.exhausted()
+              ? TlsVersion.forJavaName(source.readUtf8LineStrict())
+              : null;
+          handshake = Handshake.get(tlsVersion, cipherSuite, peerCertificates, localCertificates);
         } else {
           handshake = null;
         }
@@ -608,6 +616,11 @@ public void writeTo(DiskLruCache.Editor editor) throws IOException {
         sink.writeByte('\n');
         writeCertList(sink, handshake.peerCertificates());
         writeCertList(sink, handshake.localCertificates());
+        // The handshake’s TLS version is null on HttpsURLConnection and on older cached responses.
+        if (handshake.tlsVersion() != null) {
+          sink.writeUtf8(handshake.tlsVersion().javaName());
+          sink.writeByte('\n');
+        }
       }
       sink.close();
     }
diff --git a/okhttp/src/main/java/okhttp3/CacheControl.java b/okhttp/src/main/java/okhttp3/CacheControl.java
index 3f3bd166a1..d8eb446149 100644
--- a/okhttp/src/main/java/okhttp3/CacheControl.java
+++ b/okhttp/src/main/java/okhttp3/CacheControl.java
@@ -1,29 +1,26 @@
 package okhttp3;
 
-import okhttp3.internal.http.HeaderParser;
 import java.util.concurrent.TimeUnit;
+import okhttp3.internal.http.HeaderParser;
 
 /**
- * A Cache-Control header with cache directives from a server or client. These
- * directives set policy on what responses can be stored, and which requests can
- * be satisfied by those stored responses.
+ * A Cache-Control header with cache directives from a server or client. These directives set policy
+ * on what responses can be stored, and which requests can be satisfied by those stored responses.
  *
- * <p>See <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9">RFC
- * 2616, 14.9</a>.
+ * <p>See <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9">RFC 2616,
+ * 14.9</a>.
  */
 public final class CacheControl {
   /**
-   * Cache control request directives that require network validation of
-   * responses. Note that such requests may be assisted by the cache via
-   * conditional GET requests.
+   * Cache control request directives that require network validation of responses. Note that such
+   * requests may be assisted by the cache via conditional GET requests.
    */
   public static final CacheControl FORCE_NETWORK = new Builder().noCache().build();
 
   /**
-   * Cache control request directives that uses the cache only, even if the
-   * cached response is stale. If the response isn't available in the cache or
-   * requires server validation, the call will fail with a {@code 504
-   * Unsatisfiable Request}.
+   * Cache control request directives that uses the cache only, even if the cached response is
+   * stale. If the response isn't available in the cache or requires server validation, the call
+   * will fail with a {@code 504 Unsatisfiable Request}.
    */
   public static final CacheControl FORCE_CACHE = new Builder()
       .onlyIfCached()
@@ -42,7 +39,7 @@
   private final boolean onlyIfCached;
   private final boolean noTransform;
 
-  String headerValue; // Lazily computed, if absent.
+  String headerValue; // Lazily computed, null if absent.
 
   private CacheControl(boolean noCache, boolean noStore, int maxAgeSeconds, int sMaxAgeSeconds,
       boolean isPrivate, boolean isPublic, boolean mustRevalidate, int maxStaleSeconds,
@@ -76,10 +73,9 @@ private CacheControl(Builder builder) {
   }
 
   /**
-   * In a response, this field's name "no-cache" is misleading. It doesn't
-   * prevent us from caching the response; it only means we have to validate the
-   * response with the origin server before returning it. We can do this with a
-   * conditional GET.
+   * In a response, this field's name "no-cache" is misleading. It doesn't prevent us from caching
+   * the response; it only means we have to validate the response with the origin server before
+   * returning it. We can do this with a conditional GET.
    *
    * <p>In a request, it means do not use a cache to satisfy the request.
    */
@@ -93,17 +89,15 @@ public boolean noStore() {
   }
 
   /**
-   * The duration past the response's served date that it can be served without
-   * validation.
+   * The duration past the response's served date that it can be served without validation.
    */
   public int maxAgeSeconds() {
     return maxAgeSeconds;
   }
 
   /**
-   * The "s-maxage" directive is the max age for shared caches. Not to be
-   * confused with "max-age" for non-shared caches, As in Firefox and Chrome,
-   * this directive is not honored by this cache.
+   * The "s-maxage" directive is the max age for shared caches. Not to be confused with "max-age"
+   * for non-shared caches, As in Firefox and Chrome, this directive is not honored by this cache.
    */
   public int sMaxAgeSeconds() {
     return sMaxAgeSeconds;
@@ -130,11 +124,10 @@ public int minFreshSeconds() {
   }
 
   /**
-   * This field's name "only-if-cached" is misleading. It actually means "do
-   * not use the network". It is set by a client who only wants to make a
-   * request if it can be fully satisfied by the cache. Cached responses that
-   * would require validation (ie. conditional gets) are not permitted if this
-   * header is set.
+   * This field's name "only-if-cached" is misleading. It actually means "do not use the network".
+   * It is set by a client who only wants to make a request if it can be fully satisfied by the
+   * cache. Cached responses that would require validation (ie. conditional gets) are not permitted
+   * if this header is set.
    */
   public boolean onlyIfCached() {
     return onlyIfCached;
@@ -145,8 +138,8 @@ public boolean noTransform() {
   }
 
   /**
-   * Returns the cache directives of {@code headers}. This honors both
-   * Cache-Control and Pragma headers if they are present.
+   * Returns the cache directives of {@code headers}. This honors both Cache-Control and Pragma
+   * headers if they are present.
    */
   public static CacheControl parse(Headers headers) {
     boolean noCache = false;
@@ -291,12 +284,11 @@ public Builder noStore() {
     }
 
     /**
-     * Sets the maximum age of a cached response. If the cache response's age
-     * exceeds {@code maxAge}, it will not be used and a network request will
-     * be made.
+     * Sets the maximum age of a cached response. If the cache response's age exceeds {@code
+     * maxAge}, it will not be used and a network request will be made.
      *
-     * @param maxAge a non-negative integer. This is stored and transmitted with
-     *     {@link TimeUnit#SECONDS} precision; finer precision will be lost.
+     * @param maxAge a non-negative integer. This is stored and transmitted with {@link
+     * TimeUnit#SECONDS} precision; finer precision will be lost.
      */
     public Builder maxAge(int maxAge, TimeUnit timeUnit) {
       if (maxAge < 0) throw new IllegalArgumentException("maxAge < 0: " + maxAge);
@@ -308,13 +300,11 @@ public Builder maxAge(int maxAge, TimeUnit timeUnit) {
     }
 
     /**
-     * Accept cached responses that have exceeded their freshness lifetime by
-     * up to {@code maxStale}. If unspecified, stale cache responses will not be
-     * used.
+     * Accept cached responses that have exceeded their freshness lifetime by up to {@code
+     * maxStale}. If unspecified, stale cache responses will not be used.
      *
-     * @param maxStale a non-negative integer. This is stored and transmitted
-     *     with {@link TimeUnit#SECONDS} precision; finer precision will be
-     *     lost.
+     * @param maxStale a non-negative integer. This is stored and transmitted with {@link
+     * TimeUnit#SECONDS} precision; finer precision will be lost.
      */
     public Builder maxStale(int maxStale, TimeUnit timeUnit) {
       if (maxStale < 0) throw new IllegalArgumentException("maxStale < 0: " + maxStale);
@@ -326,14 +316,12 @@ public Builder maxStale(int maxStale, TimeUnit timeUnit) {
     }
 
     /**
-     * Sets the minimum number of seconds that a response will continue to be
-     * fresh for. If the response will be stale when {@code minFresh} have
-     * elapsed, the cached response will not be used and a network request will
-     * be made.
+     * Sets the minimum number of seconds that a response will continue to be fresh for. If the
+     * response will be stale when {@code minFresh} have elapsed, the cached response will not be
+     * used and a network request will be made.
      *
-     * @param minFresh a non-negative integer. This is stored and transmitted
-     *     with {@link TimeUnit#SECONDS} precision; finer precision will be
-     *     lost.
+     * @param minFresh a non-negative integer. This is stored and transmitted with {@link
+     * TimeUnit#SECONDS} precision; finer precision will be lost.
      */
     public Builder minFresh(int minFresh, TimeUnit timeUnit) {
       if (minFresh < 0) throw new IllegalArgumentException("minFresh < 0: " + minFresh);
@@ -345,8 +333,8 @@ public Builder minFresh(int minFresh, TimeUnit timeUnit) {
     }
 
     /**
-     * Only accept the response if it is in the cache. If the response isn't
-     * cached, a {@code 504 Unsatisfiable Request} response will be returned.
+     * Only accept the response if it is in the cache. If the response isn't cached, a {@code 504
+     * Unsatisfiable Request} response will be returned.
      */
     public Builder onlyIfCached() {
       this.onlyIfCached = true;
diff --git a/okhttp/src/main/java/okhttp3/Call.java b/okhttp/src/main/java/okhttp3/Call.java
index 78804a9f5b..3baaf647da 100644
--- a/okhttp/src/main/java/okhttp3/Call.java
+++ b/okhttp/src/main/java/okhttp3/Call.java
@@ -15,334 +15,61 @@
  */
 package okhttp3;
 
-import okhttp3.internal.NamedRunnable;
-import okhttp3.internal.http.HttpEngine;
-import okhttp3.internal.http.RequestException;
-import okhttp3.internal.http.RouteException;
-import okhttp3.internal.http.StreamAllocation;
 import java.io.IOException;
-import java.net.ProtocolException;
-import java.util.logging.Level;
-
-import static okhttp3.internal.Internal.logger;
-import static okhttp3.internal.http.HttpEngine.MAX_FOLLOW_UPS;
 
 /**
- * A call is a request that has been prepared for execution. A call can be
- * canceled. As this object represents a single request/response pair (stream),
- * it cannot be executed twice.
+ * A call is a request that has been prepared for execution. A call can be canceled. As this object
+ * represents a single request/response pair (stream), it cannot be executed twice.
  */
-public class Call {
-  private final OkHttpClient client;
-
-  // Guarded by this.
-  private boolean executed;
-  volatile boolean canceled;
-
-  /** The application's original request unadulterated by redirects or auth headers. */
-  Request originalRequest;
-  HttpEngine engine;
-
-  protected Call(OkHttpClient client, Request originalRequest) {
-    // Copy the client. Otherwise changes (socket factory, redirect policy,
-    // etc.) may incorrectly be reflected in the request when it is executed.
-    this.client = client.copyWithDefaults();
-    this.originalRequest = originalRequest;
-  }
+public interface Call {
+  /** Returns the original request that initiated this call. */
+  Request request();
 
   /**
-   * Invokes the request immediately, and blocks until the response can be
-   * processed or is in error.
-   *
-   * <p>The caller may read the response body with the response's
-   * {@link Response#body} method.  To facilitate connection recycling, callers
-   * should always {@link ResponseBody#close() close the response body}.
+   * Invokes the request immediately, and blocks until the response can be processed or is in
+   * error.
    *
-   * <p>Note that transport-layer success (receiving a HTTP response code,
-   * headers and body) does not necessarily indicate application-layer success:
-   * {@code response} may still indicate an unhappy HTTP response code like 404
-   * or 500.
+   * <p>The caller may read the response body with the response's {@link Response#body} method.  To
+   * facilitate connection recycling, callers should always {@link ResponseBody#close() close the
+   * response body}.
    *
-   * @throws IOException if the request could not be executed due to
-   *     cancellation, a connectivity problem or timeout. Because networks can
-   *     fail during an exchange, it is possible that the remote server
-   *     accepted the request before the failure.
+   * <p>Note that transport-layer success (receiving a HTTP response code, headers and body) does
+   * not necessarily indicate application-layer success: {@code response} may still indicate an
+   * unhappy HTTP response code like 404 or 500.
    *
+   * @throws IOException if the request could not be executed due to cancellation, a connectivity
+   * problem or timeout. Because networks can fail during an exchange, it is possible that the
+   * remote server accepted the request before the failure.
    * @throws IllegalStateException when the call has already been executed.
    */
-  public Response execute() throws IOException {
-    synchronized (this) {
-      if (executed) throw new IllegalStateException("Already Executed");
-      executed = true;
-    }
-    try {
-      client.getDispatcher().executed(this);
-      Response result = getResponseWithInterceptorChain(false);
-      if (result == null) throw new IOException("Canceled");
-      return result;
-    } finally {
-      client.getDispatcher().finished(this);
-    }
-  }
-
-  Object tag() {
-    return originalRequest.tag();
-  }
+  Response execute() throws IOException;
 
   /**
    * Schedules the request to be executed at some point in the future.
    *
-   * <p>The {@link OkHttpClient#getDispatcher dispatcher} defines when the
-   * request will run: usually immediately unless there are several other
-   * requests currently being executed.
+   * <p>The {@link OkHttpClient#dispatcher dispatcher} defines when the request will run: usually
+   * immediately unless there are several other requests currently being executed.
    *
-   * <p>This client will later call back {@code responseCallback} with either
-   * an HTTP response or a failure exception. If you {@link #cancel} a request
-   * before it completes the callback will not be invoked.
+   * <p>This client will later call back {@code responseCallback} with either an HTTP response or a
+   * failure exception. If you {@link #cancel} a request before it completes the callback will not
+   * be invoked.
    *
    * @throws IllegalStateException when the call has already been executed.
    */
-  public void enqueue(Callback responseCallback) {
-    enqueue(responseCallback, false);
-  }
+  void enqueue(Callback responseCallback);
 
-  void enqueue(Callback responseCallback, boolean forWebSocket) {
-    synchronized (this) {
-      if (executed) throw new IllegalStateException("Already Executed");
-      executed = true;
-    }
-    client.getDispatcher().enqueue(new AsyncCall(responseCallback, forWebSocket));
-  }
-
-  /**
-   * Cancels the request, if possible. Requests that are already complete
-   * cannot be canceled.
-   */
-  public void cancel() {
-    canceled = true;
-    if (engine != null) engine.cancel();
-  }
+  /** Cancels the request, if possible. Requests that are already complete cannot be canceled. */
+  void cancel();
 
   /**
    * Returns true if this call has been either {@linkplain #execute() executed} or {@linkplain
    * #enqueue(Callback) enqueued}. It is an error to execute a call more than once.
    */
-  public synchronized boolean isExecuted() {
-    return executed;
-  }
-
-  public boolean isCanceled() {
-    return canceled;
-  }
-
-  final class AsyncCall extends NamedRunnable {
-    private final Callback responseCallback;
-    private final boolean forWebSocket;
-
-    private AsyncCall(Callback responseCallback, boolean forWebSocket) {
-      super("OkHttp %s", originalRequest.url().toString());
-      this.responseCallback = responseCallback;
-      this.forWebSocket = forWebSocket;
-    }
-
-    String host() {
-      return originalRequest.url().host();
-    }
-
-    Request request() {
-      return originalRequest;
-    }
-
-    Object tag() {
-      return originalRequest.tag();
-    }
-
-    void cancel() {
-      Call.this.cancel();
-    }
-
-    Call get() {
-      return Call.this;
-    }
-
-    @Override protected void execute() {
-      boolean signalledCallback = false;
-      try {
-        Response response = getResponseWithInterceptorChain(forWebSocket);
-        if (canceled) {
-          signalledCallback = true;
-          responseCallback.onFailure(originalRequest, new IOException("Canceled"));
-        } else {
-          signalledCallback = true;
-          responseCallback.onResponse(response);
-        }
-      } catch (IOException e) {
-        if (signalledCallback) {
-          // Do not signal the callback twice!
-          logger.log(Level.INFO, "Callback failure for " + toLoggableString(), e);
-        } else {
-          Request request = engine == null ? originalRequest : engine.getRequest();
-          responseCallback.onFailure(request, e);
-        }
-      } finally {
-        client.getDispatcher().finished(this);
-      }
-    }
-  }
-
-  /**
-   * Returns a string that describes this call. Doesn't include a full URL as that might contain
-   * sensitive information.
-   */
-  private String toLoggableString() {
-    String string = canceled ? "canceled call" : "call";
-    HttpUrl redactedUrl = originalRequest.url().resolve("/...");
-    return string + " to " + redactedUrl;
-  }
-
-  private Response getResponseWithInterceptorChain(boolean forWebSocket) throws IOException {
-    Interceptor.Chain chain = new ApplicationInterceptorChain(0, originalRequest, forWebSocket);
-    return chain.proceed(originalRequest);
-  }
-
-  class ApplicationInterceptorChain implements Interceptor.Chain {
-    private final int index;
-    private final Request request;
-    private final boolean forWebSocket;
-
-    ApplicationInterceptorChain(int index, Request request, boolean forWebSocket) {
-      this.index = index;
-      this.request = request;
-      this.forWebSocket = forWebSocket;
-    }
-
-    @Override public Connection connection() {
-      return null;
-    }
-
-    @Override public Request request() {
-      return request;
-    }
-
-    @Override public Response proceed(Request request) throws IOException {
-      // If there's another interceptor in the chain, call that.
-      if (index < client.interceptors().size()) {
-        Interceptor.Chain chain = new ApplicationInterceptorChain(index + 1, request, forWebSocket);
-        Interceptor interceptor = client.interceptors().get(index);
-        Response interceptedResponse = interceptor.intercept(chain);
-
-        if (interceptedResponse == null) {
-          throw new NullPointerException("application interceptor " + interceptor
-              + " returned null");
-        }
-
-        return interceptedResponse;
-      }
-
-      // No more interceptors. Do HTTP.
-      return getResponse(request, forWebSocket);
-    }
-  }
-
-  /**
-   * Performs the request and returns the response. May return null if this
-   * call was canceled.
-   */
-  Response getResponse(Request request, boolean forWebSocket) throws IOException {
-    // Copy body metadata to the appropriate request headers.
-    RequestBody body = request.body();
-    if (body != null) {
-      Request.Builder requestBuilder = request.newBuilder();
-
-      MediaType contentType = body.contentType();
-      if (contentType != null) {
-        requestBuilder.header("Content-Type", contentType.toString());
-      }
-
-      long contentLength = body.contentLength();
-      if (contentLength != -1) {
-        requestBuilder.header("Content-Length", Long.toString(contentLength));
-        requestBuilder.removeHeader("Transfer-Encoding");
-      } else {
-        requestBuilder.header("Transfer-Encoding", "chunked");
-        requestBuilder.removeHeader("Content-Length");
-      }
-
-      request = requestBuilder.build();
-    }
-
-    // Create the initial HTTP engine. Retries and redirects need new engine for each attempt.
-    engine = new HttpEngine(client, request, false, false, forWebSocket, null, null, null);
-
-    int followUpCount = 0;
-    while (true) {
-      if (canceled) {
-        engine.releaseStreamAllocation();
-        throw new IOException("Canceled");
-      }
-
-      boolean releaseConnection = true;
-      try {
-        engine.sendRequest();
-        engine.readResponse();
-        releaseConnection = false;
-      } catch (RequestException e) {
-        // The attempt to interpret the request failed. Give up.
-        throw e.getCause();
-      } catch (RouteException e) {
-        // The attempt to connect via a route failed. The request will not have been sent.
-        HttpEngine retryEngine = engine.recover(e);
-        if (retryEngine != null) {
-          releaseConnection = false;
-          engine = retryEngine;
-          continue;
-        }
-        // Give up; recovery is not possible.
-        throw e.getLastConnectException();
-      } catch (IOException e) {
-        // An attempt to communicate with a server failed. The request may have been sent.
-        HttpEngine retryEngine = engine.recover(e, null);
-        if (retryEngine != null) {
-          releaseConnection = false;
-          engine = retryEngine;
-          continue;
-        }
-
-        // Give up; recovery is not possible.
-        throw e;
-      } finally {
-        // We're throwing an unchecked exception. Release any resources.
-        if (releaseConnection) {
-          StreamAllocation streamAllocation = engine.close();
-          streamAllocation.release();
-        }
-      }
-
-      Response response = engine.getResponse();
-      Request followUp = engine.followUpRequest();
-
-      if (followUp == null) {
-        if (!forWebSocket) {
-          engine.releaseStreamAllocation();
-        }
-        return response;
-      }
-
-      StreamAllocation streamAllocation = engine.close();
-
-      if (++followUpCount > MAX_FOLLOW_UPS) {
-        streamAllocation.release();
-        throw new ProtocolException("Too many follow-up requests: " + followUpCount);
-      }
+  boolean isExecuted();
 
-      if (!engine.sameConnection(followUp.url())) {
-        streamAllocation.release();
-        streamAllocation = null;
-      }
+  boolean isCanceled();
 
-      request = followUp;
-      engine = new HttpEngine(client, request, false, false, forWebSocket, streamAllocation, null,
-          response);
-    }
+  interface Factory {
+    Call newCall(Request request);
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/Callback.java b/okhttp/src/main/java/okhttp3/Callback.java
index 6c267364eb..42a8a109b2 100644
--- a/okhttp/src/main/java/okhttp3/Callback.java
+++ b/okhttp/src/main/java/okhttp3/Callback.java
@@ -19,24 +19,21 @@
 
 public interface Callback {
   /**
-   * Called when the request could not be executed due to cancellation, a
-   * connectivity problem or timeout. Because networks can fail during an
-   * exchange, it is possible that the remote server accepted the request
-   * before the failure.
+   * Called when the request could not be executed due to cancellation, a connectivity problem or
+   * timeout. Because networks can fail during an exchange, it is possible that the remote server
+   * accepted the request before the failure.
    */
-  void onFailure(Request request, IOException e);
+  void onFailure(Call call, IOException e);
 
   /**
-   * Called when the HTTP response was successfully returned by the remote
-   * server. The callback may proceed to read the response body with {@link
-   * Response#body}. The response is still live until its response body is
-   * closed with {@code response.body().close()}. The recipient of the callback
+   * Called when the HTTP response was successfully returned by the remote server. The callback may
+   * proceed to read the response body with {@link Response#body}. The response is still live until
+   * its response body is closed with {@code response.body().close()}. The recipient of the callback
    * may even consume the response body on another thread.
    *
-   * <p>Note that transport-layer success (receiving a HTTP response code,
-   * headers and body) does not necessarily indicate application-layer
-   * success: {@code response} may still indicate an unhappy HTTP response
-   * code like 404 or 500.
+   * <p>Note that transport-layer success (receiving a HTTP response code, headers and body) does
+   * not necessarily indicate application-layer success: {@code response} may still indicate an
+   * unhappy HTTP response code like 404 or 500.
    */
-  void onResponse(Response response) throws IOException;
+  void onResponse(Call call, Response response) throws IOException;
 }
diff --git a/okhttp/src/main/java/okhttp3/CertificatePinner.java b/okhttp/src/main/java/okhttp3/CertificatePinner.java
index 78f774232d..4c56d6c140 100644
--- a/okhttp/src/main/java/okhttp3/CertificatePinner.java
+++ b/okhttp/src/main/java/okhttp3/CertificatePinner.java
@@ -15,7 +15,6 @@
  */
 package okhttp3;
 
-import okhttp3.internal.Util;
 import java.security.cert.Certificate;
 import java.security.cert.X509Certificate;
 import java.util.Arrays;
@@ -25,28 +24,27 @@
 import java.util.Map;
 import java.util.Set;
 import javax.net.ssl.SSLPeerUnverifiedException;
+import okhttp3.internal.Util;
 import okio.ByteString;
 
 import static java.util.Collections.unmodifiableSet;
 
 /**
- * Constrains which certificates are trusted. Pinning certificates defends
- * against attacks on certificate authorities. It also prevents connections
- * through man-in-the-middle certificate authorities either known or unknown to
- * the application's user.
+ * Constrains which certificates are trusted. Pinning certificates defends against attacks on
+ * certificate authorities. It also prevents connections through man-in-the-middle certificate
+ * authorities either known or unknown to the application's user.
  *
- * <p>This class currently pins a certificate's Subject Public Key Info as
- * described on <a href="http://goo.gl/AIx3e5">Adam Langley's Weblog</a>. Pins
- * are base-64 SHA-1 hashes, consistent with the format Chromium uses for <a
- * href="http://goo.gl/XDh6je">static certificates</a>. See Chromium's <a
- * href="http://goo.gl/4CCnGs">pinsets</a> for hostnames that are pinned in that
+ * <p>This class currently pins a certificate's Subject Public Key Info as described on <a
+ * href="http://goo.gl/AIx3e5">Adam Langley's Weblog</a>. Pins are base-64 SHA-1 hashes, consistent
+ * with the format Chromium uses for <a href="http://goo.gl/XDh6je">static certificates</a>. See
+ * Chromium's <a href="http://goo.gl/4CCnGs">pinsets</a> for hostnames that are pinned in that
  * browser.
  *
  * <h3>Setting up Certificate Pinning</h3>
- * The easiest way to pin a host is turn on pinning with a broken configuration
- * and read the expected configuration when the connection fails. Be sure to
- * do this on a trusted network, and without man-in-the-middle tools like <a
- * href="http://charlesproxy.com">Charles</a> or <a
+ *
+ * <p>The easiest way to pin a host is turn on pinning with a broken configuration and read the
+ * expected configuration when the connection fails. Be sure to do this on a trusted network, and
+ * without man-in-the-middle tools like <a href="http://charlesproxy.com">Charles</a> or <a
  * href="http://fiddlertool.com">Fiddler</a>.
  *
  * <p>For example, to pin {@code https://publicobject.com}, start with a broken
@@ -92,42 +90,39 @@
  *       .build();
  * }</pre>
  *
- * Pinning is per-hostname and/or per-wildcard pattern. To pin both
- * {@code publicobject.com} and {@code www.publicobject.com}, you must
- * configure both hostnames.
+ * Pinning is per-hostname and/or per-wildcard pattern. To pin both {@code publicobject.com} and
+ * {@code www.publicobject.com}, you must configure both hostnames.
  *
  * <p>Wildcard pattern rules:
  * <ol>
- *   <li>Asterisk {@code *} is only permitted in the left-most
- *       domain name label and must be the only character in that label
- *       (i.e., must match the whole left-most label). For example,
- *       {@code *.example.com} is permitted, while {@code *a.example.com},
- *       {@code a*.example.com}, {@code a*b.example.com}, {@code a.*.example.com}
- *       are not permitted.
- *   <li>Asterisk {@code *} cannot match across domain name labels.
- *       For example, {@code *.example.com} matches {@code test.example.com}
- *       but does not match {@code sub.test.example.com}.
- *   <li>Wildcard patterns for single-label domain names are not permitted.
+ *     <li>Asterisk {@code *} is only permitted in the left-most domain name label and must be the
+ *         only character in that label (i.e., must match the whole left-most label). For example,
+ *         {@code *.example.com} is permitted, while {@code *a.example.com}, {@code a*.example.com},
+ *         {@code a*b.example.com}, {@code a.*.example.com} are not permitted.
+ *     <li>Asterisk {@code *} cannot match across domain name labels. For example,
+ *         {@code *.example.com} matches {@code test.example.com} but does not match
+ *         {@code sub.test.example.com}.
+ *     <li>Wildcard patterns for single-label domain names are not permitted.
  * </ol>
  *
- * If hostname pinned directly and via wildcard pattern, both
- * direct and wildcard pins will be used. For example: {@code *.example.com} pinned
- * with {@code pin1} and {@code a.example.com} pinned with {@code pin2},
- * to check {@code a.example.com} both {@code pin1} and {@code pin2} will be used.
+ * If hostname pinned directly and via wildcard pattern, both direct and wildcard pins will be used.
+ * For example: {@code *.example.com} pinned with {@code pin1} and {@code a.example.com} pinned with
+ * {@code pin2}, to check {@code a.example.com} both {@code pin1} and {@code pin2} will be used.
  *
  * <h3>Warning: Certificate Pinning is Dangerous!</h3>
- * Pinning certificates limits your server team's abilities to update their TLS
- * certificates. By pinning certificates, you take on additional operational
- * complexity and limit your ability to migrate between certificate authorities.
- * Do not use certificate pinning without the blessing of your server's TLS
- * administrator!
+ *
+ * <p>Pinning certificates limits your server team's abilities to update their TLS certificates. By
+ * pinning certificates, you take on additional operational complexity and limit your ability to
+ * migrate between certificate authorities. Do not use certificate pinning without the blessing of
+ * your server's TLS administrator!
  *
  * <h4>Note about self-signed certificates</h4>
- * {@link CertificatePinner} can not be used to pin self-signed certificate
- * if such certificate is not accepted by {@link javax.net.ssl.TrustManager}.
  *
- * @see <a href="https://www.owasp.org/index.php/Certificate_and_Public_Key_Pinning">
- *     OWASP: Certificate and Public Key Pinning</a>
+ * <p>{@link CertificatePinner} can not be used to pin self-signed certificate if such certificate
+ * is not accepted by {@link javax.net.ssl.TrustManager}.
+ *
+ * @see <a href="https://www.owasp.org/index.php/Certificate_and_Public_Key_Pinning"> OWASP:
+ * Certificate and Public Key Pinning</a>
  */
 public final class CertificatePinner {
   public static final CertificatePinner DEFAULT = new Builder().build();
@@ -139,13 +134,12 @@ private CertificatePinner(Builder builder) {
   }
 
   /**
-   * Confirms that at least one of the certificates pinned for {@code hostname}
-   * is in {@code peerCertificates}. Does nothing if there are no certificates
-   * pinned for {@code hostname}. OkHttp calls this after a successful TLS
-   * handshake, but before the connection is used.
+   * Confirms that at least one of the certificates pinned for {@code hostname} is in {@code
+   * peerCertificates}. Does nothing if there are no certificates pinned for {@code hostname}.
+   * OkHttp calls this after a successful TLS handshake, but before the connection is used.
    *
-   * @throws SSLPeerUnverifiedException if {@code peerCertificates} don't match
-   *     the certificates pinned for {@code hostname}.
+   * @throws SSLPeerUnverifiedException if {@code peerCertificates} don't match the certificates
+   * pinned for {@code hostname}.
    */
   public void check(String hostname, List<Certificate> peerCertificates)
       throws SSLPeerUnverifiedException {
@@ -182,15 +176,15 @@ public void check(String hostname, Certificate... peerCertificates)
   }
 
   /**
-   * Returns list of matching certificates' pins for the hostname
-   * or {@code null} if hostname does not have pinned certificates.
+   * Returns list of matching certificates' pins for the hostname or {@code null} if hostname does
+   * not have pinned certificates.
    */
   Set<ByteString> findMatchingPins(String hostname) {
-    Set<ByteString> directPins   = hostnameToPins.get(hostname);
+    Set<ByteString> directPins = hostnameToPins.get(hostname);
     Set<ByteString> wildcardPins = null;
 
     int indexOfFirstDot = hostname.indexOf('.');
-    int indexOfLastDot  = hostname.lastIndexOf('.');
+    int indexOfLastDot = hostname.lastIndexOf('.');
 
     // Skip hostnames with one dot symbol for wildcard pattern search
     //   example.com   will  be skipped
@@ -215,9 +209,9 @@ public void check(String hostname, Certificate... peerCertificates)
   }
 
   /**
-   * Returns the SHA-1 of {@code certificate}'s public key. This uses the
-   * mechanism Moxie Marlinspike describes in <a
-   * href="https://github.com/moxie0/AndroidPinning">Android Pinning</a>.
+   * Returns the SHA-1 of {@code certificate}'s public key. This uses the mechanism Moxie
+   * Marlinspike describes in <a href="https://github.com/moxie0/AndroidPinning">Android
+   * Pinning</a>.
    */
   public static String pin(Certificate certificate) {
     if (!(certificate instanceof X509Certificate)) {
@@ -238,9 +232,8 @@ private static ByteString sha1(X509Certificate x509Certificate) {
      * Pins certificates for {@code hostname}.
      *
      * @param hostname lower-case host name or wildcard pattern such as {@code *.example.com}.
-     * @param pins SHA-1 hashes. Each pin is a SHA-1 hash of a
-     *     certificate's Subject Public Key Info, base64-encoded and prefixed with
-     *     {@code sha1/}.
+     * @param pins SHA-1 hashes. Each pin is a SHA-1 hash of a certificate's Subject Public Key
+     * Info, base64-encoded and prefixed with {@code sha1/}.
      */
     public Builder add(String hostname, String... pins) {
       if (hostname == null) throw new IllegalArgumentException("hostname == null");
diff --git a/okhttp/src/main/java/okhttp3/CipherSuite.java b/okhttp/src/main/java/okhttp3/CipherSuite.java
index ed4167c981..6697cad846 100644
--- a/okhttp/src/main/java/okhttp3/CipherSuite.java
+++ b/okhttp/src/main/java/okhttp3/CipherSuite.java
@@ -356,7 +356,7 @@
 
   /**
    * @param javaName the name used by Java APIs for this cipher suite. Different than the IANA name
-   *     for older cipher suites because the prefix is {@code SSL_} instead of {@code TLS_}.
+   * for older cipher suites because the prefix is {@code SSL_} instead of {@code TLS_}.
    * @param value the integer identifier for this cipher suite. (Documentation only.)
    * @param rfc the RFC describing this cipher suite. (Documentation only.)
    * @param sinceJavaVersion the first major Java release supporting this cipher suite.
diff --git a/okhttp/src/main/java/okhttp3/Connection.java b/okhttp/src/main/java/okhttp3/Connection.java
index 20e4564823..de3c22d98b 100644
--- a/okhttp/src/main/java/okhttp3/Connection.java
+++ b/okhttp/src/main/java/okhttp3/Connection.java
@@ -30,19 +30,23 @@
  * connection as a single request/response exchange.
  *
  * <h3>Modern TLS</h3>
- * There are tradeoffs when selecting which options to include when negotiating a secure connection
- * to a remote host. Newer TLS options are quite useful:
+ *
+ * <p>There are tradeoffs when selecting which options to include when negotiating a secure
+ * connection to a remote host. Newer TLS options are quite useful:
+ *
  * <ul>
- *   <li>Server Name Indication (SNI) enables one IP address to negotiate secure connections for
- *       multiple domain names.
- *   <li>Application Layer Protocol Negotiation (ALPN) enables the HTTPS port (443) to be used for
- *       different HTTP and SPDY protocols.
+ *     <li>Server Name Indication (SNI) enables one IP address to negotiate secure connections for
+ *         multiple domain names.
+ *     <li>Application Layer Protocol Negotiation (ALPN) enables the HTTPS port (443) to be used for
+ *         different HTTP and SPDY protocols.
  * </ul>
- * Unfortunately, older HTTPS servers refuse to connect when such options are presented. Rather than
- * avoiding these options entirely, this class allows a connection to be attempted with modern
+ *
+ * <p>Unfortunately, older HTTPS servers refuse to connect when such options are presented. Rather
+ * than avoiding these options entirely, this class allows a connection to be attempted with modern
  * options and then retried without them should the attempt fail.
  *
  * <h3>Connection Reuse</h3>
+ *
  * <p>Each connection can carry a varying number streams, depending on the underlying protocol being
  * used. HTTP/1.x connections can carry either zero or one streams. HTTP/2 connections can carry any
  * number of streams, dynamically configured with {@code SETTINGS_MAX_CONCURRENT_STREAMS}. A
@@ -53,8 +57,8 @@
  * challenges, we prefer to use the same physical connection for all streams in the sequence. There
  * are potential performance and behavior consequences to this preference. To support this feature,
  * this class separates <i>allocations</i> from <i>streams</i>. An allocation is created by a call,
- * used for one or more streams, and then released. An allocated connection won't be stolen by
- * other calls while a redirect or authorization challenge is being handled.
+ * used for one or more streams, and then released. An allocated connection won't be stolen by other
+ * calls while a redirect or authorization challenge is being handled.
  *
  * <p>When the maximum concurrent streams limit is reduced, some allocations will be rescinded.
  * Attempting to create new streams on these allocations will fail.
@@ -65,20 +69,25 @@
  */
 public interface Connection {
   /** Returns the route used by this connection. */
-  Route getRoute();
+  Route route();
 
   /**
-   * Returns the socket that this connection uses, or null if the connection
-   * is not currently connected.
+   * Returns the socket that this connection is using. Returns an {@linkplain
+   * javax.net.ssl.SSLSocket SSL socket} if this connection is HTTPS. If this is an HTTP/2 or SPDY
+   * connection the socket may be shared by multiple concurrent calls.
    */
-  Socket getSocket();
+  Socket socket();
 
-  Handshake getHandshake();
+  /**
+   * Returns the TLS handshake used to establish this connection, or null if the connection is not
+   * HTTPS.
+   */
+  Handshake handshake();
 
   /**
    * Returns the protocol negotiated by this connection, or {@link Protocol#HTTP_1_1} if no protocol
    * has been negotiated. This method returns {@link Protocol#HTTP_1_1} even if the remote peer is
    * using {@link Protocol#HTTP_1_0}.
    */
-  Protocol getProtocol();
+  Protocol protocol();
 }
diff --git a/okhttp/src/main/java/okhttp3/ConnectionPool.java b/okhttp/src/main/java/okhttp3/ConnectionPool.java
index aefb4e2190..701a98813b 100644
--- a/okhttp/src/main/java/okhttp3/ConnectionPool.java
+++ b/okhttp/src/main/java/okhttp3/ConnectionPool.java
@@ -16,11 +16,6 @@
  */
 package okhttp3;
 
-import okhttp3.internal.Internal;
-import okhttp3.internal.RouteDatabase;
-import okhttp3.internal.Util;
-import okhttp3.internal.http.StreamAllocation;
-import okhttp3.internal.io.RealConnection;
 import java.lang.ref.Reference;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
@@ -28,67 +23,36 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.concurrent.Executor;
-import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
+import okhttp3.internal.Internal;
+import okhttp3.internal.RouteDatabase;
+import okhttp3.internal.Util;
+import okhttp3.internal.http.StreamAllocation;
+import okhttp3.internal.io.RealConnection;
+
+import static okhttp3.internal.Util.closeQuietly;
 
 /**
- * Manages reuse of HTTP and SPDY connections for reduced network latency. HTTP
- * requests that share the same {@link Address} may share a
- * {@link Connection}. This class implements the policy of which connections to
- * keep open for future use.
- *
- * <p>The {@link #getDefault() system-wide default} uses system properties for
- * tuning parameters:
- * <ul>
- *     <li>{@code http.keepAlive} true if HTTP and SPDY connections should be
- *         pooled at all. Default is true.
- *     <li>{@code http.maxConnections} maximum number of idle connections to
- *         each to keep in the pool. Default is 5.
- *     <li>{@code http.keepAliveDuration} Time in milliseconds to keep the
- *         connection alive in the pool before closing it. Default is 5 minutes.
- *         This property isn't used by {@code HttpURLConnection}.
- * </ul>
- *
- * <p>The default instance <i>doesn't</i> adjust its configuration as system
- * properties are changed. This assumes that the applications that set these
- * parameters do so before making HTTP connections, and that this class is
- * initialized lazily.
+ * Manages reuse of HTTP and SPDY connections for reduced network latency. HTTP requests that share
+ * the same {@link Address} may share a {@link Connection}. This class implements the policy of
+ * which connections to keep open for future use.
  */
 public final class ConnectionPool {
-  private static final long DEFAULT_KEEP_ALIVE_DURATION_MS = 5 * 60 * 1000; // 5 min
-
-  private static final ConnectionPool systemDefault;
-
-  static {
-    String keepAlive = System.getProperty("http.keepAlive");
-    String keepAliveDuration = System.getProperty("http.keepAliveDuration");
-    String maxIdleConnections = System.getProperty("http.maxConnections");
-    long keepAliveDurationMs = keepAliveDuration != null
-        ? Long.parseLong(keepAliveDuration)
-        : DEFAULT_KEEP_ALIVE_DURATION_MS;
-    if (keepAlive != null && !Boolean.parseBoolean(keepAlive)) {
-      systemDefault = new ConnectionPool(0, keepAliveDurationMs);
-    } else if (maxIdleConnections != null) {
-      systemDefault = new ConnectionPool(Integer.parseInt(maxIdleConnections), keepAliveDurationMs);
-    } else {
-      systemDefault = new ConnectionPool(5, keepAliveDurationMs);
-    }
-  }
-
   /**
-   * A background thread is used to cleanup expired connections. There will be, at most, a single
-   * thread running per connection pool. We use a thread pool executor because it can shrink to
-   * zero threads, permitting this pool to be garbage collected.
+   * Background threads are used to cleanup expired connections. There will be at most a single
+   * thread running per connection pool. The thread pool executor permits the pool itself to be
+   * garbage collected.
    */
-  private final Executor executor = new ThreadPoolExecutor(
-      0 /* corePoolSize */, 1 /* maximumPoolSize */, 60L /* keepAliveTime */, TimeUnit.SECONDS,
-      new LinkedBlockingQueue<Runnable>(), Util.threadFactory("OkHttp ConnectionPool", true));
+  private static final Executor executor = new ThreadPoolExecutor(0 /* corePoolSize */,
+      Integer.MAX_VALUE /* maximumPoolSize */, 60L /* keepAliveTime */, TimeUnit.SECONDS,
+      new SynchronousQueue<Runnable>(), Util.threadFactory("OkHttp ConnectionPool", true));
 
   /** The maximum number of idle connections for each address. */
   private final int maxIdleConnections;
   private final long keepAliveDurationNs;
-  private Runnable cleanupRunnable = new Runnable() {
+  private final Runnable cleanupRunnable = new Runnable() {
     @Override public void run() {
       while (true) {
         long waitNanos = cleanup(System.nanoTime());
@@ -109,9 +73,15 @@
 
   private final Deque<RealConnection> connections = new ArrayDeque<>();
   final RouteDatabase routeDatabase = new RouteDatabase();
+  boolean cleanupRunning;
 
-  public ConnectionPool(int maxIdleConnections, long keepAliveDurationMs) {
-    this(maxIdleConnections, keepAliveDurationMs, TimeUnit.MILLISECONDS);
+  /**
+   * Create a new connection pool with tuning parameters appropriate for a single-user application.
+   * The tuning parameters in this pool are subject to change in future OkHttp releases. Currently
+   * this pool holds up to 5 idle connections which will be evicted after 5 minutes of inactivity.
+   */
+  public ConnectionPool() {
+    this(5, 5, TimeUnit.MINUTES);
   }
 
   public ConnectionPool(int maxIdleConnections, long keepAliveDuration, TimeUnit timeUnit) {
@@ -124,12 +94,8 @@ public ConnectionPool(int maxIdleConnections, long keepAliveDuration, TimeUnit t
     }
   }
 
-  public static ConnectionPool getDefault() {
-    return systemDefault;
-  }
-
   /** Returns the number of idle connections in the pool. */
-  public synchronized int getIdleConnectionCount() {
+  public synchronized int idleConnectionCount() {
     int total = 0;
     for (RealConnection connection : connections) {
       if (connection.allocations.isEmpty()) total++;
@@ -139,36 +105,20 @@ public synchronized int getIdleConnectionCount() {
 
   /**
    * Returns total number of connections in the pool. Note that prior to OkHttp 2.7 this included
-   * only idle connections and SPDY connections. In OkHttp 2.7 this includes all connections, both
-   * active and inactive. Use {@link #getIdleConnectionCount()} to count connections not currently
+   * only idle connections and SPDY connections. Since OkHttp 2.7 this includes all connections,
+   * both active and inactive. Use {@link #idleConnectionCount()} to count connections not currently
    * in use.
    */
-  public synchronized int getConnectionCount() {
+  public synchronized int connectionCount() {
     return connections.size();
   }
 
-  /** Returns total number of multiplexed connections in the pool. */
-  public synchronized int getMultiplexedConnectionCount() {
-    int total = 0;
-    for (RealConnection connection : connections) {
-      if (connection.isMultiplexed()) total++;
-    }
-    return total;
-  }
-
-  /** Returns total number of http connections in the pool. */
-  public synchronized int getHttpConnectionCount() {
-    return connections.size() - getMultiplexedConnectionCount();
-  }
-
   /** Returns a recycled connection to {@code address}, or null if no such connection exists. */
   RealConnection get(Address address, StreamAllocation streamAllocation) {
     assert (Thread.holdsLock(this));
     for (RealConnection connection : connections) {
-      // TODO(jwilson): this is awkward. We're already holding a lock on 'this', and
-      //     connection.allocationLimit() may also lock the FramedConnection.
-      if (connection.allocations.size() < connection.allocationLimit()
-          && address.equals(connection.getRoute().address)
+      if (connection.allocations.size() < connection.allocationLimit
+          && address.equals(connection.route().address)
           && !connection.noNewStreams) {
         streamAllocation.acquire(connection);
         return connection;
@@ -179,15 +129,16 @@ RealConnection get(Address address, StreamAllocation streamAllocation) {
 
   void put(RealConnection connection) {
     assert (Thread.holdsLock(this));
-    if (connections.isEmpty()) {
+    if (!cleanupRunning) {
+      cleanupRunning = true;
       executor.execute(cleanupRunnable);
     }
     connections.add(connection);
   }
 
   /**
-   * Notify this pool that {@code connection} has become idle. Returns true if the connection
-   * has been removed from the pool and should be closed.
+   * Notify this pool that {@code connection} has become idle. Returns true if the connection has
+   * been removed from the pool and should be closed.
    */
   boolean connectionBecameIdle(RealConnection connection) {
     assert (Thread.holdsLock(this));
@@ -215,7 +166,7 @@ public void evictAll() {
     }
 
     for (RealConnection connection : evictedConnections) {
-      Util.closeQuietly(connection.getSocket());
+      closeQuietly(connection.socket());
     }
   }
 
@@ -223,8 +174,8 @@ public void evictAll() {
    * Performs maintenance on this pool, evicting the connection that has been idle the longest if
    * either it has exceeded the keep alive limit or the idle connections limit.
    *
-   * <p>Returns the duration in nanos to sleep until the next scheduled call to this method.
-   * Returns -1 if no further cleanups are required.
+   * <p>Returns the duration in nanos to sleep until the next scheduled call to this method. Returns
+   * -1 if no further cleanups are required.
    */
   long cleanup(long now) {
     int inUseConnectionCount = 0;
@@ -258,22 +209,20 @@ long cleanup(long now) {
         // We've found a connection to evict. Remove it from the list, then close it below (outside
         // of the synchronized block).
         connections.remove(longestIdleConnection);
-
       } else if (idleConnectionCount > 0) {
         // A connection will be ready to evict soon.
         return keepAliveDurationNs - longestIdleDurationNs;
-
       } else if (inUseConnectionCount > 0) {
         // All connections are in use. It'll be at least the keep alive duration 'til we run again.
         return keepAliveDurationNs;
-
       } else {
         // No connections, idle or in use.
+        cleanupRunning = false;
         return -1;
       }
     }
 
-    Util.closeQuietly(longestIdleConnection.getSocket());
+    closeQuietly(longestIdleConnection.socket());
 
     // Cleanup again immediately.
     return 0;
@@ -296,7 +245,7 @@ private int pruneAndGetAllocationCount(RealConnection connection, long now) {
       }
 
       // We've discovered a leaked allocation. This is an application bug.
-      Internal.logger.warning("A connection to " + connection.getRoute().address().url()
+      Internal.logger.warning("A connection to " + connection.route().address().url()
           + " was leaked. Did you forget to close a response body?");
       references.remove(i);
       connection.noNewStreams = true;
@@ -310,8 +259,4 @@ private int pruneAndGetAllocationCount(RealConnection connection, long now) {
 
     return references.size();
   }
-
-  void setCleanupRunnableForTest(Runnable cleanupRunnable) {
-    this.cleanupRunnable = cleanupRunnable;
-  }
 }
diff --git a/okhttp/src/main/java/okhttp3/ConnectionSpec.java b/okhttp/src/main/java/okhttp3/ConnectionSpec.java
index 9b7569495e..8c99932f9e 100644
--- a/okhttp/src/main/java/okhttp3/ConnectionSpec.java
+++ b/okhttp/src/main/java/okhttp3/ConnectionSpec.java
@@ -162,8 +162,8 @@ private ConnectionSpec supportedSpec(SSLSocket sslSocket, boolean isFallback) {
   }
 
   /**
-   * Returns {@code true} if the socket, as currently configured, supports this connection spec.
-   * In order for a socket to be compatible the enabled cipher suites and protocols must intersect.
+   * Returns {@code true} if the socket, as currently configured, supports this connection spec. In
+   * order for a socket to be compatible the enabled cipher suites and protocols must intersect.
    *
    * <p>For cipher suites, at least one of the {@link #cipherSuites() required cipher suites} must
    * match the socket's enabled cipher suites. If there are no required cipher suites the socket
@@ -191,9 +191,9 @@ public boolean isCompatible(SSLSocket socket) {
   }
 
   /**
-   * An N*M intersection that terminates if any intersection is found. The sizes of both
-   * arguments are assumed to be so small, and the likelihood of an intersection so great, that it
-   * is not worth the CPU cost of sorting or the memory cost of hashing.
+   * An N*M intersection that terminates if any intersection is found. The sizes of both arguments
+   * are assumed to be so small, and the likelihood of an intersection so great, that it is not
+   * worth the CPU cost of sorting or the memory cost of hashing.
    */
   private static boolean nonEmptyIntersection(String[] a, String[] b) {
     if (a == null || b == null || a.length == 0 || b.length == 0) {
diff --git a/okhttp/src/main/java/okhttp3/Cookie.java b/okhttp/src/main/java/okhttp3/Cookie.java
new file mode 100644
index 0000000000..12c4584b18
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/Cookie.java
@@ -0,0 +1,562 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.util.ArrayList;
+import java.util.Calendar;
+import java.util.Collections;
+import java.util.Date;
+import java.util.GregorianCalendar;
+import java.util.List;
+import java.util.Locale;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import okhttp3.internal.Util;
+import okhttp3.internal.http.HttpDate;
+
+import static okhttp3.internal.Util.UTC;
+import static okhttp3.internal.Util.delimiterOffset;
+import static okhttp3.internal.Util.domainToAscii;
+import static okhttp3.internal.Util.trimSubstring;
+import static okhttp3.internal.Util.verifyAsIpAddress;
+
+/**
+ * An <a href="http://tools.ietf.org/html/rfc6265">RFC 6265</a> Cookie.
+ *
+ * <p>This class doesn't support additional attributes on cookies, like <a
+ * href="https://code.google.com/p/chromium/issues/detail?id=232693">Chromium's Priority=HIGH
+ * extension</a>.
+ */
+public final class Cookie {
+  private static final Pattern YEAR_PATTERN
+      = Pattern.compile("(\\d{2,4})[^\\d]*");
+  private static final Pattern MONTH_PATTERN
+      = Pattern.compile("(?i)(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec).*");
+  private static final Pattern DAY_OF_MONTH_PATTERN
+      = Pattern.compile("(\\d{1,2})[^\\d]*");
+  private static final Pattern TIME_PATTERN
+      = Pattern.compile("(\\d{1,2}):(\\d{1,2}):(\\d{1,2})[^\\d]*");
+
+  private final String name;
+  private final String value;
+  private final long expiresAt;
+  private final String domain;
+  private final String path;
+  private final boolean secure;
+  private final boolean httpOnly;
+
+  private final boolean persistent; // True if 'expires' or 'max-age' is present.
+  private final boolean hostOnly; // True unless 'domain' is present.
+
+  private Cookie(String name, String value, long expiresAt, String domain, String path,
+      boolean secure, boolean httpOnly, boolean hostOnly, boolean persistent) {
+    this.name = name;
+    this.value = value;
+    this.expiresAt = expiresAt;
+    this.domain = domain;
+    this.path = path;
+    this.secure = secure;
+    this.httpOnly = httpOnly;
+    this.hostOnly = hostOnly;
+    this.persistent = persistent;
+  }
+
+  private Cookie(Builder builder) {
+    if (builder.name == null) throw new IllegalArgumentException("builder.name == null");
+    if (builder.value == null) throw new IllegalArgumentException("builder.value == null");
+    if (builder.domain == null) throw new IllegalArgumentException("builder.domain == null");
+
+    this.name = builder.name;
+    this.value = builder.value;
+    this.expiresAt = builder.expiresAt;
+    this.domain = builder.domain;
+    this.path = builder.path;
+    this.secure = builder.secure;
+    this.httpOnly = builder.httpOnly;
+    this.persistent = builder.persistent;
+    this.hostOnly = builder.hostOnly;
+  }
+
+  /** Returns a non-empty string with this cookie's name. */
+  public String name() {
+    return name;
+  }
+
+  /** Returns a possibly-empty string with this cookie's value. */
+  public String value() {
+    return value;
+  }
+
+  /** Returns true if this cookie expires at the end of the current session. */
+  public boolean persistent() {
+    return persistent;
+  }
+
+  /**
+   * Returns the time that this cookie expires, in the same format as {@link
+   * System#currentTimeMillis()}. This is December 31, 9999 if the cookie is {@linkplain
+   * #persistent() not persistent}, in which case it will expire at the end of the current session.
+   *
+   * <p>This may return a value less than the current time, in which case the cookie is already
+   * expired. Webservers may return expired cookies as a mechanism to delete previously set cookies
+   * that may or may not themselves be expired.
+   */
+  public long expiresAt() {
+    return expiresAt;
+  }
+
+  /**
+   * Returns true if this cookie's domain should be interpreted as a single host name, or false if
+   * it should be interpreted as a pattern. This flag will be false if its {@code Set-Cookie} header
+   * included a {@code domain} attribute.
+   *
+   * <p>For example, suppose the cookie's domain is {@code example.com}. If this flag is true it
+   * matches <strong>only</strong> {@code example.com}. If this flag is false it matches {@code
+   * example.com} and all subdomains including {@code api.example.com}, {@code www.example.com}, and
+   * {@code beta.api.example.com}.
+   */
+  public boolean hostOnly() {
+    return hostOnly;
+  }
+
+  /**
+   * Returns the cookie's domain. If {@link #hostOnly()} returns true this is the only domain that
+   * matches this cookie; otherwise it matches this domain and all subdomains.
+   */
+  public String domain() {
+    return domain;
+  }
+
+  /**
+   * Returns this cookie's path. This cookie matches URLs prefixed with path segments that match
+   * this path's segments. For example, if this path is {@code /foo} this cookie matches requests to
+   * {@code /foo} and {@code /foo/bar}, but not {@code /} or {@code /football}.
+   */
+  public String path() {
+    return path;
+  }
+
+  /**
+   * Returns true if this cookie should be limited to only HTTP APIs. In web browsers this prevents
+   * the cookie from being accessible to scripts.
+   */
+  public boolean httpOnly() {
+    return httpOnly;
+  }
+
+  /** Returns true if this cookie should be limited to only HTTPS requests. */
+  public boolean secure() {
+    return secure;
+  }
+
+  /**
+   * Returns true if this cookie should be included on a request to {@code url}. In addition to this
+   * check callers should also confirm that this cookie has not expired.
+   */
+  public boolean matches(HttpUrl url) {
+    boolean domainMatch = hostOnly
+        ? url.host().equals(domain)
+        : domainMatch(url, domain);
+    if (!domainMatch) return false;
+
+    if (!pathMatch(url, path)) return false;
+
+    if (secure && !url.isHttps()) return false;
+
+    return true;
+  }
+
+  private static boolean domainMatch(HttpUrl url, String domain) {
+    String urlHost = url.host();
+
+    if (urlHost.equals(domain)) {
+      return true; // As in 'example.com' matching 'example.com'.
+    }
+
+    if (urlHost.endsWith(domain)
+        && urlHost.charAt(urlHost.length() - domain.length() - 1) == '.'
+        && !verifyAsIpAddress(urlHost)) {
+      return true; // As in 'example.com' matching 'www.example.com'.
+    }
+
+    return false;
+  }
+
+  private static boolean pathMatch(HttpUrl url, String path) {
+    String urlPath = url.encodedPath();
+
+    if (urlPath.equals(path)) {
+      return true; // As in '/foo' matching '/foo'.
+    }
+
+    if (urlPath.startsWith(path)) {
+      if (path.endsWith("/")) return true; // As in '/' matching '/foo'.
+      if (urlPath.charAt(path.length()) == '/') return true; // As in '/foo' matching '/foo/bar'.
+    }
+
+    return false;
+  }
+
+  /**
+   * Attempt to parse a {@code Set-Cookie} HTTP header value {@code setCookie} as a cookie. Returns
+   * null if {@code setCookie} is not a well-formed cookie.
+   */
+  public static Cookie parse(HttpUrl url, String setCookie) {
+    return parse(System.currentTimeMillis(), url, setCookie);
+  }
+
+  static Cookie parse(long currentTimeMillis, HttpUrl url, String setCookie) {
+    int pos = 0;
+    int limit = setCookie.length();
+    int cookiePairEnd = delimiterOffset(setCookie, pos, limit, ';');
+
+    int pairEqualsSign = delimiterOffset(setCookie, pos, cookiePairEnd, '=');
+    if (pairEqualsSign == cookiePairEnd) return null;
+
+    String cookieName = trimSubstring(setCookie, pos, pairEqualsSign);
+    if (cookieName.isEmpty()) return null;
+
+    String cookieValue = trimSubstring(setCookie, pairEqualsSign + 1, cookiePairEnd);
+
+    long expiresAt = HttpDate.MAX_DATE;
+    long deltaSeconds = -1L;
+    String domain = null;
+    String path = null;
+    boolean secureOnly = false;
+    boolean httpOnly = false;
+    boolean hostOnly = true;
+    boolean persistent = false;
+
+    pos = cookiePairEnd + 1;
+    while (pos < limit) {
+      int attributePairEnd = delimiterOffset(setCookie, pos, limit, ';');
+
+      int attributeEqualsSign = delimiterOffset(setCookie, pos, attributePairEnd, '=');
+      String attributeName = trimSubstring(setCookie, pos, attributeEqualsSign);
+      String attributeValue = attributeEqualsSign < attributePairEnd
+          ? trimSubstring(setCookie, attributeEqualsSign + 1, attributePairEnd)
+          : "";
+
+      if (attributeName.equalsIgnoreCase("expires")) {
+        try {
+          expiresAt = parseExpires(attributeValue, 0, attributeValue.length());
+          persistent = true;
+        } catch (IllegalArgumentException e) {
+          // Ignore this attribute, it isn't recognizable as a date.
+        }
+      } else if (attributeName.equalsIgnoreCase("max-age")) {
+        try {
+          deltaSeconds = parseMaxAge(attributeValue);
+          persistent = true;
+        } catch (NumberFormatException e) {
+          // Ignore this attribute, it isn't recognizable as a max age.
+        }
+      } else if (attributeName.equalsIgnoreCase("domain")) {
+        try {
+          domain = parseDomain(attributeValue);
+          hostOnly = false;
+        } catch (IllegalArgumentException e) {
+          // Ignore this attribute, it isn't recognizable as a domain.
+        }
+      } else if (attributeName.equalsIgnoreCase("path")) {
+        path = attributeValue;
+      } else if (attributeName.equalsIgnoreCase("secure")) {
+        secureOnly = true;
+      } else if (attributeName.equalsIgnoreCase("httponly")) {
+        httpOnly = true;
+      }
+
+      pos = attributePairEnd + 1;
+    }
+
+    // If 'Max-Age' is present, it takes precedence over 'Expires', regardless of the order the two
+    // attributes are declared in the cookie string.
+    if (deltaSeconds == Long.MIN_VALUE) {
+      expiresAt = Long.MIN_VALUE;
+    } else if (deltaSeconds != -1L) {
+      long deltaMilliseconds = deltaSeconds <= (Long.MAX_VALUE / 1000)
+          ? deltaSeconds * 1000
+          : Long.MAX_VALUE;
+      expiresAt = currentTimeMillis + deltaMilliseconds;
+      if (expiresAt < currentTimeMillis || expiresAt > HttpDate.MAX_DATE) {
+        expiresAt = HttpDate.MAX_DATE; // Handle overflow & limit the date range.
+      }
+    }
+
+    // If the domain is present, it must domain match. Otherwise we have a host-only cookie.
+    if (domain == null) {
+      domain = url.host();
+    } else if (!domainMatch(url, domain)) {
+      return null; // No domain match? This is either incompetence or malice!
+    }
+
+    // If the path is absent or didn't start with '/', use the default path. It's a string like
+    // '/foo/bar' for a URL like 'http://example.com/foo/bar/baz'. It always starts with '/'.
+    if (path == null || !path.startsWith("/")) {
+      String encodedPath = url.encodedPath();
+      int lastSlash = encodedPath.lastIndexOf('/');
+      path = lastSlash != 0 ? encodedPath.substring(0, lastSlash) : "/";
+    }
+
+    return new Cookie(cookieName, cookieValue, expiresAt, domain, path, secureOnly, httpOnly,
+        hostOnly, persistent);
+  }
+
+  /** Parse a date as specified in RFC 6265, section 5.1.1. */
+  private static long parseExpires(String s, int pos, int limit) {
+    pos = dateCharacterOffset(s, pos, limit, false);
+
+    int hour = -1;
+    int minute = -1;
+    int second = -1;
+    int dayOfMonth = -1;
+    int month = -1;
+    int year = -1;
+    Matcher matcher = TIME_PATTERN.matcher(s);
+
+    while (pos < limit) {
+      int end = dateCharacterOffset(s, pos + 1, limit, true);
+      matcher.region(pos, end);
+
+      if (hour == -1 && matcher.usePattern(TIME_PATTERN).matches()) {
+        hour = Integer.parseInt(matcher.group(1));
+        minute = Integer.parseInt(matcher.group(2));
+        second = Integer.parseInt(matcher.group(3));
+      } else if (dayOfMonth == -1 && matcher.usePattern(DAY_OF_MONTH_PATTERN).matches()) {
+        dayOfMonth = Integer.parseInt(matcher.group(1));
+      } else if (month == -1 && matcher.usePattern(MONTH_PATTERN).matches()) {
+        String monthString = matcher.group(1).toLowerCase(Locale.US);
+        month = MONTH_PATTERN.pattern().indexOf(monthString) / 4; // Sneaky! jan=1, dec=12.
+      } else if (year == -1 && matcher.usePattern(YEAR_PATTERN).matches()) {
+        year = Integer.parseInt(matcher.group(1));
+      }
+
+      pos = dateCharacterOffset(s, end + 1, limit, false);
+    }
+
+    // Convert two-digit years into four-digit years. 99 becomes 1999, 15 becomes 2015.
+    if (year >= 70 && year <= 99) year += 1900;
+    if (year >= 0 && year <= 69) year += 2000;
+
+    // If any partial is omitted or out of range, return -1. The date is impossible. Note that leap
+    // seconds are not supported by this syntax.
+    if (year < 1601) throw new IllegalArgumentException();
+    if (month == -1) throw new IllegalArgumentException();
+    if (dayOfMonth < 1 || dayOfMonth > 31) throw new IllegalArgumentException();
+    if (hour < 0 || hour > 23) throw new IllegalArgumentException();
+    if (minute < 0 || minute > 59) throw new IllegalArgumentException();
+    if (second < 0 || second > 59) throw new IllegalArgumentException();
+
+    Calendar calendar = new GregorianCalendar(UTC);
+    calendar.setLenient(false);
+    calendar.set(Calendar.YEAR, year);
+    calendar.set(Calendar.MONTH, month - 1);
+    calendar.set(Calendar.DAY_OF_MONTH, dayOfMonth);
+    calendar.set(Calendar.HOUR_OF_DAY, hour);
+    calendar.set(Calendar.MINUTE, minute);
+    calendar.set(Calendar.SECOND, second);
+    calendar.set(Calendar.MILLISECOND, 0);
+    return calendar.getTimeInMillis();
+  }
+
+  /**
+   * Returns the index of the next date character in {@code input}, or if {@code invert} the index
+   * of the next non-date character in {@code input}.
+   */
+  private static int dateCharacterOffset(String input, int pos, int limit, boolean invert) {
+    for (int i = pos; i < limit; i++) {
+      int c = input.charAt(i);
+      boolean dateCharacter = (c < ' ' && c != '\t') || (c >= '\u007f')
+          || (c >= '0' && c <= '9')
+          || (c >= 'a' && c <= 'z')
+          || (c >= 'A' && c <= 'Z')
+          || (c == ':');
+      if (dateCharacter == !invert) return i;
+    }
+    return limit;
+  }
+
+  /**
+   * Returns the positive value if {@code attributeValue} is positive, or {@link Long#MIN_VALUE} if
+   * it is either 0 or negative. If the value is positive but out of range, this returns {@link
+   * Long#MAX_VALUE}.
+   *
+   * @throws NumberFormatException if {@code s} is not an integer of any precision.
+   */
+  private static long parseMaxAge(String s) {
+    try {
+      long parsed = Long.parseLong(s);
+      return parsed <= 0L ? Long.MIN_VALUE : parsed;
+    } catch (NumberFormatException e) {
+      // Check if the value is an integer (positive or negative) that's too big for a long.
+      if (s.matches("-?\\d+")) {
+        return s.startsWith("-") ? Long.MIN_VALUE : Long.MAX_VALUE;
+      }
+      throw e;
+    }
+  }
+
+  /**
+   * Returns a domain string like {@code example.com} for an input domain like {@code EXAMPLE.COM}
+   * or {@code .example.com}.
+   */
+  private static String parseDomain(String s) {
+    if (s.endsWith(".")) {
+      throw new IllegalArgumentException();
+    }
+    if (s.startsWith(".")) {
+      s = s.substring(1);
+    }
+    String canonicalDomain = domainToAscii(s);
+    if (canonicalDomain == null) {
+      throw new IllegalArgumentException();
+    }
+    return canonicalDomain;
+  }
+
+  /** Returns all of the cookies from a set of HTTP response headers. */
+  public static List<Cookie> parseAll(HttpUrl url, Headers headers) {
+    List<String> cookieStrings = headers.values("Set-Cookie");
+    List<Cookie> cookies = null;
+
+    for (int i = 0, size = cookieStrings.size(); i < size; i++) {
+      Cookie cookie = Cookie.parse(url, cookieStrings.get(i));
+      if (cookie == null) continue;
+      if (cookies == null) cookies = new ArrayList<>();
+      cookies.add(cookie);
+    }
+
+    return cookies != null
+        ? Collections.unmodifiableList(cookies)
+        : Collections.<Cookie>emptyList();
+  }
+
+  /**
+   * Builds a cookie. The {@linkplain #name() name}, {@linkplain #value() value}, and {@linkplain
+   * #domain() domain} values must all be set before calling {@link #build}.
+   */
+  public static final class Builder {
+    String name;
+    String value;
+    long expiresAt = HttpDate.MAX_DATE;
+    String domain;
+    String path = "/";
+    boolean secure;
+    boolean httpOnly;
+    boolean persistent;
+    boolean hostOnly;
+
+    public Builder name(String name) {
+      if (name == null) throw new NullPointerException("name == null");
+      if (!name.trim().equals(name)) throw new IllegalArgumentException("name is not trimmed");
+      this.name = name;
+      return this;
+    }
+
+    public Builder value(String value) {
+      if (value == null) throw new NullPointerException("value == null");
+      if (!value.trim().equals(value)) throw new IllegalArgumentException("value is not trimmed");
+      this.value = value;
+      return this;
+    }
+
+    public Builder expiresAt(long expiresAt) {
+      if (expiresAt <= 0) expiresAt = Long.MIN_VALUE;
+      if (expiresAt > HttpDate.MAX_DATE) expiresAt = HttpDate.MAX_DATE;
+      this.expiresAt = expiresAt;
+      this.persistent = true;
+      return this;
+    }
+
+    /**
+     * Set the domain pattern for this cookie. The cookie will match {@code domain} and all of its
+     * subdomains.
+     */
+    public Builder domain(String domain) {
+      return domain(domain, false);
+    }
+
+    /**
+     * Set the host-only domain for this cookie. The cookie will match {@code domain} but none of
+     * its subdomains.
+     */
+    public Builder hostOnlyDomain(String domain) {
+      return domain(domain, true);
+    }
+
+    private Builder domain(String domain, boolean hostOnly) {
+      if (domain == null) throw new IllegalArgumentException("domain == null");
+      String canonicalDomain = Util.domainToAscii(domain);
+      if (canonicalDomain == null) {
+        throw new IllegalArgumentException("unexpected domain: " + domain);
+      }
+      this.domain = canonicalDomain;
+      this.hostOnly = hostOnly;
+      return this;
+    }
+
+    public Builder path(String path) {
+      if (!path.startsWith("/")) throw new IllegalArgumentException("path must start with '/'");
+      this.path = path;
+      return this;
+    }
+
+    public Builder secure() {
+      this.secure = true;
+      return this;
+    }
+
+    public Builder httpOnly() {
+      this.httpOnly = true;
+      return this;
+    }
+
+    public Cookie build() {
+      return new Cookie(this);
+    }
+  }
+
+  @Override public String toString() {
+    StringBuilder result = new StringBuilder();
+    result.append(name);
+    result.append('=');
+    result.append(value);
+
+    if (persistent) {
+      if (expiresAt == Long.MIN_VALUE) {
+        result.append("; max-age=0");
+      } else {
+        result.append("; expires=").append(HttpDate.format(new Date(expiresAt)));
+      }
+    }
+
+    if (!hostOnly) {
+      result.append("; domain=").append(domain);
+    }
+
+    result.append("; path=").append(path);
+
+    if (secure) {
+      result.append("; secure");
+    }
+
+    if (httpOnly) {
+      result.append("; httponly");
+    }
+
+    return result.toString();
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/CookieJar.java b/okhttp/src/main/java/okhttp3/CookieJar.java
new file mode 100644
index 0000000000..d2cdfce22a
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/CookieJar.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * Provides <strong>policy</strong> and <strong>persistence</strong> for HTTP cookies.
+ *
+ * <p>As policy, implementations of this interface are responsible for selecting which cookies to
+ * accept and which to reject. A reasonable policy is to reject all cookies, though that may be
+ * interfere with session-based authentication schemes that require cookies.
+ *
+ * <p>As persistence, implementations of this interface must also provide storage of cookies. Simple
+ * implementations may store cookies in memory; sophisticated ones may use the file system or
+ * database to hold accepted cookies. The <a
+ * href="https://tools.ietf.org/html/rfc6265#section-5.3">cookie storage model</a> specifies
+ * policies for updating and expiring cookies.
+ */
+public interface CookieJar {
+  /** A cookie jar that never accepts any cookies. */
+  CookieJar NO_COOKIES = new CookieJar() {
+    @Override public void saveFromResponse(HttpUrl url, List<Cookie> cookies) {
+    }
+
+    @Override public List<Cookie> loadForRequest(HttpUrl url) {
+      return Collections.emptyList();
+    }
+  };
+
+  /**
+   * Saves {@code cookies} from an HTTP response to this store according to this jar's policy.
+   *
+   * <p>Note that this method may be called a second time for a single HTTP response if the response
+   * includes a trailer. For this obscure HTTP feature, {@code cookies} contains only the trailer's
+   * cookies.
+   */
+  void saveFromResponse(HttpUrl url, List<Cookie> cookies);
+
+  /**
+   * Load cookies from the jar for an HTTP request to {@code url}. This method returns a possibly
+   * empty list of cookies for the network request.
+   *
+   * <p>Simple implementations will return the accepted cookies that have not yet expired and that
+   * {@linkplain Cookie#matches match} {@code url}.
+   */
+  List<Cookie> loadForRequest(HttpUrl url);
+}
diff --git a/okhttp/src/main/java/okhttp3/Dispatcher.java b/okhttp/src/main/java/okhttp3/Dispatcher.java
index 4c1dc0bda4..5a135b325d 100644
--- a/okhttp/src/main/java/okhttp3/Dispatcher.java
+++ b/okhttp/src/main/java/okhttp3/Dispatcher.java
@@ -15,23 +15,25 @@
  */
 package okhttp3;
 
-import okhttp3.Call.AsyncCall;
-import okhttp3.internal.Util;
-import okhttp3.internal.http.HttpEngine;
 import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Collections;
 import java.util.Deque;
 import java.util.Iterator;
+import java.util.List;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
+import okhttp3.RealCall.AsyncCall;
+import okhttp3.internal.Util;
 
 /**
  * Policy on when async requests are executed.
  *
- * <p>Each dispatcher uses an {@link ExecutorService} to run calls internally. If you
- * supply your own executor, it should be able to run {@linkplain #getMaxRequests the
- * configured maximum} number of calls concurrently.
+ * <p>Each dispatcher uses an {@link ExecutorService} to run calls internally. If you supply your
+ * own executor, it should be able to run {@linkplain #getMaxRequests the configured maximum} number
+ * of calls concurrently.
  */
 public final class Dispatcher {
   private int maxRequests = 64;
@@ -40,14 +42,14 @@
   /** Executes calls. Created lazily. */
   private ExecutorService executorService;
 
-  /** Ready calls in the order they'll be run. */
-  private final Deque<AsyncCall> readyCalls = new ArrayDeque<>();
+  /** Ready async calls in the order they'll be run. */
+  private final Deque<AsyncCall> readyAsyncCalls = new ArrayDeque<>();
 
-  /** Running calls. Includes canceled calls that haven't finished yet. */
-  private final Deque<AsyncCall> runningCalls = new ArrayDeque<>();
+  /** Running asynchronous calls. Includes canceled calls that haven't finished yet. */
+  private final Deque<AsyncCall> runningAsyncCalls = new ArrayDeque<>();
 
-  /** In-flight synchronous calls. Includes canceled calls that haven't finished yet. */
-  private final Deque<Call> executedCalls = new ArrayDeque<>();
+  /** Running synchronous calls. Includes canceled calls that haven't finished yet. */
+  private final Deque<RealCall> runningSyncCalls = new ArrayDeque<>();
 
   public Dispatcher(ExecutorService executorService) {
     this.executorService = executorService;
@@ -56,7 +58,7 @@ public Dispatcher(ExecutorService executorService) {
   public Dispatcher() {
   }
 
-  public synchronized ExecutorService getExecutorService() {
+  public synchronized ExecutorService executorService() {
     if (executorService == null) {
       executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,
           new SynchronousQueue<Runnable>(), Util.threadFactory("OkHttp Dispatcher", false));
@@ -65,11 +67,11 @@ public synchronized ExecutorService getExecutorService() {
   }
 
   /**
-   * Set the maximum number of requests to execute concurrently. Above this
-   * requests queue in memory, waiting for the running calls to complete.
+   * Set the maximum number of requests to execute concurrently. Above this requests queue in
+   * memory, waiting for the running calls to complete.
    *
-   * <p>If more than {@code maxRequests} requests are in flight when this is
-   * invoked, those requests will remain in flight.
+   * <p>If more than {@code maxRequests} requests are in flight when this is invoked, those requests
+   * will remain in flight.
    */
   public synchronized void setMaxRequests(int maxRequests) {
     if (maxRequests < 1) {
@@ -84,13 +86,13 @@ public synchronized int getMaxRequests() {
   }
 
   /**
-   * Set the maximum number of requests for each host to execute concurrently.
-   * This limits requests by the URL's host name. Note that concurrent requests
-   * to a single IP address may still exceed this limit: multiple hostnames may
-   * share an IP address or be routed through the same HTTP proxy.
+   * Set the maximum number of requests for each host to execute concurrently. This limits requests
+   * by the URL's host name. Note that concurrent requests to a single IP address may still exceed
+   * this limit: multiple hostnames may share an IP address or be routed through the same HTTP
+   * proxy.
    *
-   * <p>If more than {@code maxRequestsPerHost} requests are in flight when this
-   * is invoked, those requests will remain in flight.
+   * <p>If more than {@code maxRequestsPerHost} requests are in flight when this is invoked, those
+   * requests will remain in flight.
    */
   public synchronized void setMaxRequestsPerHost(int maxRequestsPerHost) {
     if (maxRequestsPerHost < 1) {
@@ -105,84 +107,98 @@ public synchronized int getMaxRequestsPerHost() {
   }
 
   synchronized void enqueue(AsyncCall call) {
-    if (runningCalls.size() < maxRequests && runningCallsForHost(call) < maxRequestsPerHost) {
-      runningCalls.add(call);
-      getExecutorService().execute(call);
+    if (runningAsyncCalls.size() < maxRequests && runningCallsForHost(call) < maxRequestsPerHost) {
+      runningAsyncCalls.add(call);
+      executorService().execute(call);
     } else {
-      readyCalls.add(call);
+      readyAsyncCalls.add(call);
     }
   }
 
-  /** Cancel all calls with the tag {@code tag}. */
-  public synchronized void cancel(Object tag) {
-    for (AsyncCall call : readyCalls) {
-      if (Util.equal(tag, call.tag())) {
-        call.cancel();
-      }
+  /**
+   * Cancel all calls currently enqueued or executing. Includes calls executed both {@linkplain
+   * Call#execute() synchronously} and {@linkplain Call#enqueue asynchronously}.
+   */
+  public synchronized void cancelAll() {
+    for (AsyncCall call : readyAsyncCalls) {
+      call.cancel();
     }
 
-    for (AsyncCall call : runningCalls) {
-      if (Util.equal(tag, call.tag())) {
-        call.get().canceled = true;
-        HttpEngine engine = call.get().engine;
-        if (engine != null) engine.cancel();
-      }
+    for (AsyncCall call : runningAsyncCalls) {
+      call.cancel();
     }
 
-    for (Call call : executedCalls) {
-      if (Util.equal(tag, call.tag())) {
-        call.cancel();
-      }
+    for (RealCall call : runningSyncCalls) {
+      call.cancel();
     }
   }
 
   /** Used by {@code AsyncCall#run} to signal completion. */
   synchronized void finished(AsyncCall call) {
-    if (!runningCalls.remove(call)) throw new AssertionError("AsyncCall wasn't running!");
+    if (!runningAsyncCalls.remove(call)) throw new AssertionError("AsyncCall wasn't running!");
     promoteCalls();
   }
 
   private void promoteCalls() {
-    if (runningCalls.size() >= maxRequests) return; // Already running max capacity.
-    if (readyCalls.isEmpty()) return; // No ready calls to promote.
+    if (runningAsyncCalls.size() >= maxRequests) return; // Already running max capacity.
+    if (readyAsyncCalls.isEmpty()) return; // No ready calls to promote.
 
-    for (Iterator<AsyncCall> i = readyCalls.iterator(); i.hasNext(); ) {
+    for (Iterator<AsyncCall> i = readyAsyncCalls.iterator(); i.hasNext(); ) {
       AsyncCall call = i.next();
 
       if (runningCallsForHost(call) < maxRequestsPerHost) {
         i.remove();
-        runningCalls.add(call);
-        getExecutorService().execute(call);
+        runningAsyncCalls.add(call);
+        executorService().execute(call);
       }
 
-      if (runningCalls.size() >= maxRequests) return; // Reached max capacity.
+      if (runningAsyncCalls.size() >= maxRequests) return; // Reached max capacity.
     }
   }
 
   /** Returns the number of running calls that share a host with {@code call}. */
   private int runningCallsForHost(AsyncCall call) {
     int result = 0;
-    for (AsyncCall c : runningCalls) {
+    for (AsyncCall c : runningAsyncCalls) {
       if (c.host().equals(call.host())) result++;
     }
     return result;
   }
 
   /** Used by {@code Call#execute} to signal it is in-flight. */
-  synchronized void executed(Call call) {
-    executedCalls.add(call);
+  synchronized void executed(RealCall call) {
+    runningSyncCalls.add(call);
   }
 
   /** Used by {@code Call#execute} to signal completion. */
   synchronized void finished(Call call) {
-    if (!executedCalls.remove(call)) throw new AssertionError("Call wasn't in-flight!");
+    if (!runningSyncCalls.remove(call)) throw new AssertionError("Call wasn't in-flight!");
+  }
+
+  /** Returns a snapshot of the calls currently awaiting execution. */
+  public synchronized List<Call> queuedCalls() {
+    List<Call> result = new ArrayList<>();
+    for (AsyncCall asyncCall : readyAsyncCalls) {
+      result.add(asyncCall.get());
+    }
+    return Collections.unmodifiableList(result);
+  }
+
+  /** Returns a snapshot of the calls currently being executed. */
+  public synchronized List<Call> runningCalls() {
+    List<Call> result = new ArrayList<>();
+    result.addAll(runningSyncCalls);
+    for (AsyncCall asyncCall : runningAsyncCalls) {
+      result.add(asyncCall.get());
+    }
+    return Collections.unmodifiableList(result);
   }
 
-  public synchronized int getRunningCallCount() {
-    return runningCalls.size();
+  public synchronized int queuedCallsCount() {
+    return readyAsyncCalls.size();
   }
 
-  public synchronized int getQueuedCallCount() {
-    return readyCalls.size();
+  public synchronized int runningCallsCount() {
+    return runningAsyncCalls.size() + runningSyncCalls.size();
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/Dns.java b/okhttp/src/main/java/okhttp3/Dns.java
index 37cb31e316..a2e6db591c 100644
--- a/okhttp/src/main/java/okhttp3/Dns.java
+++ b/okhttp/src/main/java/okhttp3/Dns.java
@@ -41,10 +41,9 @@
   };
 
   /**
-   * Returns the IP addresses of {@code hostname}, in the order they will be attempted by OkHttp.
-   * If a connection to an address fails, OkHttp will retry the connection with the next address
-   * until either a connection is made, the set of IP addresses is exhausted, or a limit is
-   * exceeded.
+   * Returns the IP addresses of {@code hostname}, in the order they will be attempted by OkHttp. If
+   * a connection to an address fails, OkHttp will retry the connection with the next address until
+   * either a connection is made, the set of IP addresses is exhausted, or a limit is exceeded.
    */
   List<InetAddress> lookup(String hostname) throws UnknownHostException;
 }
diff --git a/okhttp/src/main/java/okhttp3/FormBody.java b/okhttp/src/main/java/okhttp3/FormBody.java
index 2743a0aada..95181b1f76 100644
--- a/okhttp/src/main/java/okhttp3/FormBody.java
+++ b/okhttp/src/main/java/okhttp3/FormBody.java
@@ -15,10 +15,10 @@
  */
 package okhttp3;
 
-import okhttp3.internal.Util;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
+import okhttp3.internal.Util;
 import okio.Buffer;
 import okio.BufferedSink;
 
@@ -72,8 +72,8 @@ public String value(int index) {
 
   /**
    * Either writes this request to {@code sink} or measures its content length. We have one method
-   * do double-duty to make sure the counting and content are consistent, particularly when it
-   * comes to awkward operations like measuring the encoded length of header strings, or the
+   * do double-duty to make sure the counting and content are consistent, particularly when it comes
+   * to awkward operations like measuring the encoded length of header strings, or the
    * length-in-digits of an encoded integer.
    */
   private long writeOrCountBytes(BufferedSink sink, boolean countBytes) {
@@ -106,14 +106,14 @@ private long writeOrCountBytes(BufferedSink sink, boolean countBytes) {
     private final List<String> values = new ArrayList<>();
 
     public Builder add(String name, String value) {
-      names.add(HttpUrl.canonicalize(name, FORM_ENCODE_SET, false, true, true));
-      values.add(HttpUrl.canonicalize(value, FORM_ENCODE_SET, false, true, true));
+      names.add(HttpUrl.canonicalize(name, FORM_ENCODE_SET, false, false, true, true));
+      values.add(HttpUrl.canonicalize(value, FORM_ENCODE_SET, false, false, true, true));
       return this;
     }
 
     public Builder addEncoded(String name, String value) {
-      names.add(HttpUrl.canonicalize(name, FORM_ENCODE_SET, true, true, true));
-      values.add(HttpUrl.canonicalize(value, FORM_ENCODE_SET, true, true, true));
+      names.add(HttpUrl.canonicalize(name, FORM_ENCODE_SET, true, false, true, true));
+      values.add(HttpUrl.canonicalize(value, FORM_ENCODE_SET, true, false, true, true));
       return this;
     }
 
diff --git a/okhttp/src/main/java/okhttp3/Handshake.java b/okhttp/src/main/java/okhttp3/Handshake.java
index 1d579ac643..0221482750 100644
--- a/okhttp/src/main/java/okhttp3/Handshake.java
+++ b/okhttp/src/main/java/okhttp3/Handshake.java
@@ -16,7 +16,6 @@
 
 package okhttp3;
 
-import okhttp3.internal.Util;
 import java.security.Principal;
 import java.security.cert.Certificate;
 import java.security.cert.X509Certificate;
@@ -24,21 +23,24 @@
 import java.util.List;
 import javax.net.ssl.SSLPeerUnverifiedException;
 import javax.net.ssl.SSLSession;
+import okhttp3.internal.Util;
 
 /**
- * A record of a TLS handshake. For HTTPS clients, the client is <i>local</i>
- * and the remote server is its <i>peer</i>.
+ * A record of a TLS handshake. For HTTPS clients, the client is <i>local</i> and the remote server
+ * is its <i>peer</i>.
  *
- * <p>This value object describes a completed handshake. Use {@link
- * javax.net.ssl.SSLSocketFactory} to set policy for new handshakes.
+ * <p>This value object describes a completed handshake. Use {@link ConnectionSpec} to set policy
+ * for new handshakes.
  */
 public final class Handshake {
+  private final TlsVersion tlsVersion;
   private final CipherSuite cipherSuite;
   private final List<Certificate> peerCertificates;
   private final List<Certificate> localCertificates;
 
-  private Handshake(CipherSuite cipherSuite, List<Certificate> peerCertificates,
-      List<Certificate> localCertificates) {
+  private Handshake(TlsVersion tlsVersion, CipherSuite cipherSuite,
+      List<Certificate> peerCertificates, List<Certificate> localCertificates) {
+    this.tlsVersion = tlsVersion;
     this.cipherSuite = cipherSuite;
     this.peerCertificates = peerCertificates;
     this.localCertificates = localCertificates;
@@ -49,6 +51,10 @@ public static Handshake get(SSLSession session) {
     if (cipherSuiteString == null) throw new IllegalStateException("cipherSuite == null");
     CipherSuite cipherSuite = CipherSuite.forJavaName(cipherSuiteString);
 
+    String tlsVersionString = session.getProtocol();
+    if (tlsVersionString == null) throw new IllegalStateException("tlsVersion == null");
+    TlsVersion tlsVersion = TlsVersion.forJavaName(tlsVersionString);
+
     Certificate[] peerCertificates;
     try {
       peerCertificates = session.getPeerCertificates();
@@ -64,16 +70,24 @@ public static Handshake get(SSLSession session) {
         ? Util.immutableList(localCertificates)
         : Collections.<Certificate>emptyList();
 
-    return new Handshake(cipherSuite, peerCertificatesList, localCertificatesList);
+    return new Handshake(tlsVersion, cipherSuite, peerCertificatesList, localCertificatesList);
   }
 
-  public static Handshake get(CipherSuite cipherSuite, List<Certificate> peerCertificates,
-      List<Certificate> localCertificates) {
+  public static Handshake get(TlsVersion tlsVersion, CipherSuite cipherSuite,
+      List<Certificate> peerCertificates, List<Certificate> localCertificates) {
     if (cipherSuite == null) throw new IllegalArgumentException("cipherSuite == null");
-    return new Handshake(cipherSuite, Util.immutableList(peerCertificates),
+    return new Handshake(tlsVersion, cipherSuite, Util.immutableList(peerCertificates),
         Util.immutableList(localCertificates));
   }
 
+  /**
+   * Returns the TLS version used for this connection. May return null if the response was cached
+   * with a version of OkHttp prior to 3.0.
+   */
+  public TlsVersion tlsVersion() {
+    return tlsVersion;
+  }
+
   /** Returns the cipher suite used for the connection. */
   public CipherSuite cipherSuite() {
     return cipherSuite;
@@ -106,13 +120,15 @@ public Principal localPrincipal() {
   @Override public boolean equals(Object other) {
     if (!(other instanceof Handshake)) return false;
     Handshake that = (Handshake) other;
-    return cipherSuite.equals(that.cipherSuite)
+    return Util.equal(cipherSuite, that.cipherSuite)
+        && cipherSuite.equals(that.cipherSuite)
         && peerCertificates.equals(that.peerCertificates)
         && localCertificates.equals(that.localCertificates);
   }
 
   @Override public int hashCode() {
     int result = 17;
+    result = 31 * result + (tlsVersion != null ? tlsVersion.hashCode() : 0);
     result = 31 * result + cipherSuite.hashCode();
     result = 31 * result + peerCertificates.hashCode();
     result = 31 * result + localCertificates.hashCode();
diff --git a/okhttp/src/main/java/okhttp3/Headers.java b/okhttp/src/main/java/okhttp3/Headers.java
index 42cbd17abf..6f72d0cc4d 100644
--- a/okhttp/src/main/java/okhttp3/Headers.java
+++ b/okhttp/src/main/java/okhttp3/Headers.java
@@ -17,7 +17,6 @@
 
 package okhttp3;
 
-import okhttp3.internal.http.HttpDate;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Date;
@@ -26,24 +25,23 @@
 import java.util.Map;
 import java.util.Set;
 import java.util.TreeSet;
+import okhttp3.internal.http.HttpDate;
 
 /**
- * The header fields of a single HTTP message. Values are uninterpreted strings;
- * use {@code Request} and {@code Response} for interpreted headers. This class
- * maintains the order of the header fields within the HTTP message.
+ * The header fields of a single HTTP message. Values are uninterpreted strings; use {@code Request}
+ * and {@code Response} for interpreted headers. This class maintains the order of the header fields
+ * within the HTTP message.
  *
- * <p>This class tracks header values line-by-line. A field with multiple comma-
- * separated values on the same line will be treated as a field with a single
- * value by this class. It is the caller's responsibility to detect and split
- * on commas if their field permits multiple values. This simplifies use of
- * single-valued fields whose values routinely contain commas, such as cookies
- * or dates.
+ * <p>This class tracks header values line-by-line. A field with multiple comma- separated values on
+ * the same line will be treated as a field with a single value by this class. It is the caller's
+ * responsibility to detect and split on commas if their field permits multiple values. This
+ * simplifies use of single-valued fields whose values routinely contain commas, such as cookies or
+ * dates.
  *
- * <p>This class trims whitespace from values. It never returns values with
- * leading or trailing whitespace.
+ * <p>This class trims whitespace from values. It never returns values with leading or trailing
+ * whitespace.
  *
- * <p>Instances of this class are immutable. Use {@link Builder} to create
- * instances.
+ * <p>Instances of this class are immutable. Use {@link Builder} to create instances.
  */
 public final class Headers {
   private final String[] namesAndValues;
@@ -62,9 +60,8 @@ public String get(String name) {
   }
 
   /**
-   * Returns the last value corresponding to the specified field parsed as an
-   * HTTP date, or null if either the field is absent or cannot be parsed as a
-   * date.
+   * Returns the last value corresponding to the specified field parsed as an HTTP date, or null if
+   * either the field is absent or cannot be parsed as a date.
    */
   public Date getDate(String name) {
     String value = get(name);
@@ -76,22 +73,14 @@ public int size() {
     return namesAndValues.length / 2;
   }
 
-  /** Returns the field at {@code position} or null if that is out of range. */
+  /** Returns the field at {@code position}. */
   public String name(int index) {
-    int nameIndex = index * 2;
-    if (nameIndex < 0 || nameIndex >= namesAndValues.length) {
-      return null;
-    }
-    return namesAndValues[nameIndex];
+    return namesAndValues[index * 2];
   }
 
-  /** Returns the value at {@code index} or null if that is out of range. */
+  /** Returns the value at {@code index}. */
   public String value(int index) {
-    int valueIndex = index * 2 + 1;
-    if (valueIndex < 0 || valueIndex >= namesAndValues.length) {
-      return null;
-    }
-    return namesAndValues[valueIndex];
+    return namesAndValues[index * 2 + 1];
   }
 
   /** Returns an immutable case-insensitive set of header names. */
@@ -155,9 +144,8 @@ private static String get(String[] namesAndValues, String name) {
   }
 
   /**
-   * Returns headers for the alternating header names and values. There must be
-   * an even number of arguments, and they must alternate between header names
-   * and values.
+   * Returns headers for the alternating header names and values. There must be an even number of
+   * arguments, and they must alternate between header names and values.
    */
   public static Headers of(String... namesAndValues) {
     if (namesAndValues == null || namesAndValues.length % 2 != 0) {
@@ -247,8 +235,8 @@ public Builder add(String name, String value) {
     }
 
     /**
-     * Add a field with the specified value without any validation. Only
-     * appropriate for headers from the remote peer or cache.
+     * Add a field with the specified value without any validation. Only appropriate for headers
+     * from the remote peer or cache.
      */
     Builder addLenient(String name, String value) {
       namesAndValues.add(name);
@@ -268,8 +256,8 @@ public Builder removeAll(String name) {
     }
 
     /**
-     * Set a field with the specified value. If the field is not found, it is
-     * added. If the field is found, the existing values are replaced.
+     * Set a field with the specified value. If the field is not found, it is added. If the field is
+     * found, the existing values are replaced.
      */
     public Builder set(String name, String value) {
       checkNameAndValue(name, value);
@@ -293,7 +281,7 @@ private void checkNameAndValue(String name, String value) {
         char c = value.charAt(i);
         if (c <= '\u001f' || c >= '\u007f') {
           throw new IllegalArgumentException(String.format(
-              "Unexpected char %#04x at %d in header value: %s", (int) c, i, value));
+              "Unexpected char %#04x at %d in %s value: %s", (int) c, i, name, value));
         }
       }
     }
diff --git a/okhttp/src/main/java/okhttp3/HttpUrl.java b/okhttp/src/main/java/okhttp3/HttpUrl.java
index 8ac1514834..59cbdd4350 100644
--- a/okhttp/src/main/java/okhttp3/HttpUrl.java
+++ b/okhttp/src/main/java/okhttp3/HttpUrl.java
@@ -15,7 +15,6 @@
  */
 package okhttp3;
 
-import java.net.IDN;
 import java.net.InetAddress;
 import java.net.MalformedURLException;
 import java.net.URI;
@@ -27,10 +26,14 @@
 import java.util.Collections;
 import java.util.LinkedHashSet;
 import java.util.List;
-import java.util.Locale;
 import java.util.Set;
 import okio.Buffer;
 
+import static okhttp3.internal.Util.delimiterOffset;
+import static okhttp3.internal.Util.domainToAscii;
+import static okhttp3.internal.Util.skipLeadingAsciiWhitespace;
+import static okhttp3.internal.Util.skipTrailingAsciiWhitespace;
+
 /**
  * A uniform resource locator (URL) with a scheme of either {@code http} or {@code https}. Use this
  * class to compose and decompose Internet addresses. For example, this code will compose and print
@@ -84,58 +87,67 @@
  * A URL has several components.
  *
  * <h4>Scheme</h4>
- * Sometimes referred to as <i>protocol</i>, A URL's scheme describes what mechanism should be used
- * to retrieve the resource. Although URLs have many schemes ({@code mailto}, {@code file}, {@code
- * ftp}), this class only supports {@code http} and {@code https}. Use {@link URI java.net.URI} for
- * URLs with arbitrary schemes.
+ *
+ * <p>Sometimes referred to as <i>protocol</i>, A URL's scheme describes what mechanism should be
+ * used to retrieve the resource. Although URLs have many schemes ({@code mailto}, {@code file},
+ * {@code ftp}), this class only supports {@code http} and {@code https}. Use {@link URI
+ * java.net.URI} for URLs with arbitrary schemes.
  *
  * <h4>Username and Password</h4>
- * Username and password are either present, or the empty string {@code ""} if absent. This class
+ *
+ * <p>Username and password are either present, or the empty string {@code ""} if absent. This class
  * offers no mechanism to differentiate empty from absent. Neither of these components are popular
  * in practice. Typically HTTP applications use other mechanisms for user identification and
  * authentication.
  *
  * <h4>Host</h4>
- * The host identifies the webserver that serves the URL's resource. It is either a hostname like
+ *
+ * <p>The host identifies the webserver that serves the URL's resource. It is either a hostname like
  * {@code square.com} or {@code localhost}, an IPv4 address like {@code 192.168.0.1}, or an IPv6
  * address like {@code ::1}.
  *
  * <p>Usually a webserver is reachable with multiple identifiers: its IP addresses, registered
  * domain names, and even {@code localhost} when connecting from the server itself. Each of a
- * webserver's names is a distinct URL and they are not interchangeable. For example, even if
- * {@code http://square.github.io/dagger} and {@code http://google.github.io/dagger} are served by
- * the same IP address, the two URLs identify different resources.
+ * webserver's names is a distinct URL and they are not interchangeable. For example, even if {@code
+ * http://square.github.io/dagger} and {@code http://google.github.io/dagger} are served by the same
+ * IP address, the two URLs identify different resources.
  *
  * <h4>Port</h4>
- * The port used to connect to the webserver. By default this is 80 for HTTP and 443 for HTTPS. This
- * class never returns -1 for the port: if no port is explicitly specified in the URL then the
+ *
+ * <p>The port used to connect to the webserver. By default this is 80 for HTTP and 443 for HTTPS.
+ * This class never returns -1 for the port: if no port is explicitly specified in the URL then the
  * scheme's default is used.
  *
  * <h4>Path</h4>
- * The path identifies a specific resource on the host. Paths have a hierarchical structure like
+ *
+ * <p>The path identifies a specific resource on the host. Paths have a hierarchical structure like
  * "/square/okhttp/issues/1486". Each path segment is prefixed with "/". This class offers methods
  * to compose and decompose paths by segment. If a path's last segment is the empty string, then the
  * path ends with "/". This class always builds non-empty paths: if the path is omitted it defaults
  * to "/", which is a path whose only segment is the empty string.
  *
  * <h4>Query</h4>
- * The query is optional: it can be null, empty, or non-empty. For many HTTP URLs the query string
- * is subdivided into a collection of name-value parameters. This class offers methods to set the
- * query as the single string, or as individual name-value parameters. With name-value parameters
- * the values are optional and names may be repeated.
+ *
+ * <p>The query is optional: it can be null, empty, or non-empty. For many HTTP URLs the query
+ * string is subdivided into a collection of name-value parameters. This class offers methods to set
+ * the query as the single string, or as individual name-value parameters. With name-value
+ * parameters the values are optional and names may be repeated.
  *
  * <h4>Fragment</h4>
- * The fragment is optional: it can be null, empty, or non-empty. Unlike host, port, path, and query
- * the fragment is not sent to the webserver: it's private to the client.
+ *
+ * <p>The fragment is optional: it can be null, empty, or non-empty. Unlike host, port, path, and
+ * query the fragment is not sent to the webserver: it's private to the client.
  *
  * <h3>Encoding</h3>
- * Each component must be encoded before it is embedded in the complete URL. As we saw above, the
+ *
+ * <p>Each component must be encoded before it is embedded in the complete URL. As we saw above, the
  * string {@code cute #puppies} is encoded as {@code cute%20%23puppies} when used as a query
  * parameter value.
  *
  * <h4>Percent encoding</h4>
- * Percent encoding replaces a character (like {@code \ud83c\udf69}) with its UTF-8 hex bytes (like
- * {@code %F0%9F%8D%A9}). This approach works for whitespace characters, control characters,
+ *
+ * <p>Percent encoding replaces a character (like {@code \ud83c\udf69}) with its UTF-8 hex bytes
+ * (like {@code %F0%9F%8D%A9}). This approach works for whitespace characters, control characters,
  * non-ASCII characters, and characters that already have another meaning in a particular context.
  *
  * <p>Percent encoding is used in every URL component except for the hostname. But the set of
@@ -161,11 +173,12 @@
  * the offending characters.
  *
  * <h4>IDNA Mapping and Punycode encoding</h4>
- * Hostnames have different requirements and use a different encoding scheme. It consists of IDNA
+ *
+ * <p>Hostnames have different requirements and use a different encoding scheme. It consists of IDNA
  * mapping and Punycode encoding.
  *
- * <p>In order to avoid confusion and discourage phishing attacks,
- * <a href="http://www.unicode.org/reports/tr46/#ToASCII">IDNA Mapping</a> transforms names to avoid
+ * <p>In order to avoid confusion and discourage phishing attacks, <a
+ * href="http://www.unicode.org/reports/tr46/#ToASCII">IDNA Mapping</a> transforms names to avoid
  * confusing characters. This includes basic case folding: transforming shouting {@code SQUARE.COM}
  * into cool and casual {@code square.com}. It also handles more exotic characters. For example, the
  * Unicode trademark sign (™) could be confused for the letters "TM" in {@code http://ho™mail.com}.
@@ -174,21 +187,25 @@
  * not mapped and cannot be used in a hostname.
  *
  * <p><a href="http://ietf.org/rfc/rfc3492.txt">Punycode</a> converts a Unicode string to an ASCII
- * string to make international domain names work everywhere. For example, "σ" encodes as
- * "xn--4xa". The encoded string is not human readable, but can be used with classes like {@link
- * InetAddress} to establish connections.
+ * string to make international domain names work everywhere. For example, "σ" encodes as "xn--4xa".
+ * The encoded string is not human readable, but can be used with classes like {@link InetAddress}
+ * to establish connections.
  *
  * <h3>Why another URL model?</h3>
- * Java includes both {@link URL java.net.URL} and {@link URI java.net.URI}. We offer a new URL
+ *
+ * <p>Java includes both {@link URL java.net.URL} and {@link URI java.net.URI}. We offer a new URL
  * model to address problems that the others don't.
  *
  * <h4>Different URLs should be different</h4>
- * Although they have different content, {@code java.net.URL} considers the following two URLs
+ *
+ * <p>Although they have different content, {@code java.net.URL} considers the following two URLs
  * equal, and the {@link Object#equals equals()} method between them returns true:
+ *
  * <ul>
  *   <li>http://square.github.io/
  *   <li>http://google.github.io/
  * </ul>
+ *
  * This is because those two hosts share the same IP address. This is an old, bad design decision
  * that makes {@code java.net.URL} unusable for many things. It shouldn't be used as a {@link
  * java.util.Map Map} key or in a {@link Set}. Doing so is both inefficient because equality may
@@ -196,11 +213,14 @@
  * hosted.
  *
  * <h4>Equal URLs should be equal</h4>
- * These two URLs are semantically identical, but {@code java.net.URI} disagrees:
+ *
+ * <p>These two URLs are semantically identical, but {@code java.net.URI} disagrees:
+ *
  * <ul>
  *   <li>http://host:80/
  *   <li>http://host
  * </ul>
+ *
  * Both the unnecessary port specification ({@code :80}) and the absent trailing slash ({@code /})
  * cause URI to bucket the two URLs separately. This harms URI's usefulness in collections. Any
  * application that stores information-per-URL will need to either canonicalize manually, or suffer
@@ -226,21 +246,24 @@
  * }</pre>
  *
  * <h4>If it works on the web, it should work in your application</h4>
- * The {@code java.net.URI} class is strict around what URLs it accepts. It rejects URLs like
+ *
+ * <p>The {@code java.net.URI} class is strict around what URLs it accepts. It rejects URLs like
  * "http://example.com/abc|def" because the '|' character is unsupported. This class is more
  * forgiving: it will automatically percent-encode the '|', yielding "http://example.com/abc%7Cdef".
  * This kind behavior is consistent with web browsers. {@code HttpUrl} prefers consistency with
  * major web browsers over consistency with obsolete specifications.
  *
  * <h4>Paths and Queries should decompose</h4>
- * Neither of the built-in URL models offer direct access to path segments or query parameters.
+ *
+ * <p>Neither of the built-in URL models offer direct access to path segments or query parameters.
  * Manually using {@code StringBuilder} to assemble these components is cumbersome: do '+'
  * characters get silently replaced with spaces? If a query parameter contains a '&amp;', does that
  * get escaped? By offering methods to read and write individual query parameters directly,
  * application developers are saved from the hassles of encoding and decoding.
  *
  * <h4>Plus a modern API</h4>
- * The URL (JDK1.0) and URI (Java 1.4) classes predate builders and instead use telescoping
+ *
+ * <p>The URL (JDK1.0) and URI (Java 1.4) classes predate builders and instead use telescoping
  * constructors. For example, there's no API to compose a URI with a custom port without also
  * providing a query and fragment.
  *
@@ -254,7 +277,7 @@
  */
 public final class HttpUrl {
   private static final char[] HEX_DIGITS =
-      { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
+      {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
   static final String USERNAME_ENCODE_SET = " \"':;<=>@[]^`{}|/\\?#";
   static final String PASSWORD_ENCODE_SET = " \"':;<=>@[]^`{}|/\\?#";
   static final String PATH_SEGMENT_ENCODE_SET = " \"<>^`{}|/\\?#";
@@ -282,9 +305,9 @@
   private final int port;
 
   /**
-   * A list of canonical path segments. This list always contains at least one element, which may
-   * be the empty string. Each segment is formatted with a leading '/', so if path segments were
-   * ["a", "b", ""], then the encoded path would be "/a/b/".
+   * A list of canonical path segments. This list always contains at least one element, which may be
+   * the empty string. Each segment is formatted with a leading '/', so if path segments were ["a",
+   * "b", ""], then the encoded path would be "/a/b/".
    */
   private final List<String> pathSegments;
 
@@ -327,19 +350,30 @@ public URL url() {
   }
 
   /**
-   * Returns this URL as a {@link URI java.net.URI}. Because {@code URI} forbids certain characters
-   * like {@code [} and {@code |}, the returned URI may escape more characters than this URL.
+   * Returns this URL as a {@link URI java.net.URI}. Because {@code URI} is more strict than this
+   * class, the returned URI may be semantically different from this URL:
+   *
+   * <ul>
+   *     <li>Characters forbidden by URI like {@code [} and {@code |} will be escaped.
+   *     <li>Invalid percent-encoded sequences like {@code %xx} will be encoded like {@code %25xx}.
+   *     <li>Whitespace and control characters in the fragment will be stripped.
+   * </ul>
    *
-   * <p>This method throws an unchecked {@link IllegalStateException} if it cannot be converted to a
-   * URI even after escaping forbidden characters. In particular, URLs that contain malformed
-   * percent escapes like {@code http://host/%xx} will trigger this exception.
+   * <p>These differences may have a significant consequence when the URI is interpretted by a
+   * webserver. For this reason the {@linkplain URI URI class} and this method should be avoided.
    */
   public URI uri() {
+    String uri = newBuilder().reencodeForUri().toString();
     try {
-      String uri = newBuilder().reencodeForUri().toString();
       return new URI(uri);
     } catch (URISyntaxException e) {
-      throw new IllegalStateException("not valid as a java.net.URI: " + url);
+      // Unlikely edge case: the URI has a forbidden character in the fragment. Strip it & retry.
+      try {
+        String stripped = uri.replaceAll("[\\u0000-\\u001F\\u007F-\\u009F\\p{javaWhitespace}]", "");
+        return URI.create(stripped);
+      } catch (Exception e1) {
+        throw new RuntimeException(e); // Unexpected!
+      }
     }
   }
 
@@ -380,6 +414,7 @@ public String password() {
   /**
    * Returns the host address suitable for use with {@link InetAddress#getAllByName(String)}. May
    * be:
+   *
    * <ul>
    *   <li>A regular host name, like {@code android.com}.
    *   <li>An IPv4 address, like {@code 127.0.0.1}.
@@ -419,8 +454,8 @@ public int pathSize() {
   }
 
   /**
-   * Returns the entire path of this URL, encoded for use in HTTP resource resolution. The
-   * returned path is always nonempty and is prefixed with {@code /}.
+   * Returns the entire path of this URL, encoded for use in HTTP resource resolution. The returned
+   * path is always nonempty and is prefixed with {@code /}.
    */
   public String encodedPath() {
     int pathStart = url.indexOf('/', scheme.length() + 3); // "://".length() == 3.
@@ -441,7 +476,7 @@ static void pathSegmentsToString(StringBuilder out, List<String> pathSegments) {
     List<String> result = new ArrayList<>();
     for (int i = pathStart; i < pathEnd; ) {
       i++; // Skip the '/'.
-      int segmentEnd = delimiterOffset(url, i, pathEnd, "/");
+      int segmentEnd = delimiterOffset(url, i, pathEnd, '/');
       result.add(url.substring(i, segmentEnd));
       i = segmentEnd;
     }
@@ -460,7 +495,7 @@ static void pathSegmentsToString(StringBuilder out, List<String> pathSegments) {
   public String encodedQuery() {
     if (queryNamesAndValues == null) return null; // No query.
     int queryStart = url.indexOf('?') + 1;
-    int queryEnd = delimiterOffset(url, queryStart + 1, url.length(), "#");
+    int queryEnd = delimiterOffset(url, queryStart + 1, url.length(), '#');
     return url.substring(queryStart, queryEnd);
   }
 
@@ -478,10 +513,10 @@ static void namesAndValuesToQueryString(StringBuilder out, List<String> namesAnd
   }
 
   /**
-   * Cuts {@code encodedQuery} up into alternating parameter names and values. This divides a
-   * query string like {@code subject=math&easy&problem=5-2=3} into the list {@code ["subject",
-   * "math", "easy", null, "problem", "5-2=3"]}. Note that values may be null and may contain
-   * '=' characters.
+   * Cuts {@code encodedQuery} up into alternating parameter names and values. This divides a query
+   * string like {@code subject=math&easy&problem=5-2=3} into the list {@code ["subject", "math",
+   * "easy", null, "problem", "5-2=3"]}. Note that values may be null and may contain '='
+   * characters.
    */
   static List<String> queryStringToNamesAndValues(String encodedQuery) {
     List<String> result = new ArrayList<>();
@@ -565,11 +600,13 @@ public String fragment() {
     return fragment;
   }
 
-  /** Returns the URL that would be retrieved by following {@code link} from this URL. */
+  /**
+   * Returns the URL that would be retrieved by following {@code link} from this URL, or null if
+   * the resulting URL is not well-formed.
+   */
   public HttpUrl resolve(String link) {
-    Builder builder = new Builder();
-    Builder.ParseResult result = builder.parse(this, link);
-    return result == Builder.ParseResult.SUCCESS ? builder.build() : null;
+    Builder builder = newBuilder(link);
+    return builder != null ? builder.build() : null;
   }
 
   public Builder newBuilder() {
@@ -587,6 +624,16 @@ public Builder newBuilder() {
     return result;
   }
 
+  /**
+   * Returns a builder for the URL that would be retrieved by following {@code link} from this URL,
+   * or null if the resulting URL is not well-formed.
+   */
+  public Builder newBuilder(String link) {
+    Builder builder = new Builder();
+    Builder.ParseResult result = builder.parse(this, link);
+    return result == Builder.ParseResult.SUCCESS ? builder : null;
+  }
+
   /**
    * Returns a new {@code HttpUrl} representing {@code url} if it is a well-formed HTTP or HTTPS
    * URL, or null if it isn't.
@@ -673,31 +720,33 @@ public Builder scheme(String scheme) {
 
     public Builder username(String username) {
       if (username == null) throw new IllegalArgumentException("username == null");
-      this.encodedUsername = canonicalize(username, USERNAME_ENCODE_SET, false, false, true);
+      this.encodedUsername = canonicalize(username, USERNAME_ENCODE_SET, false, false, false, true);
       return this;
     }
 
     public Builder encodedUsername(String encodedUsername) {
       if (encodedUsername == null) throw new IllegalArgumentException("encodedUsername == null");
-      this.encodedUsername = canonicalize(encodedUsername, USERNAME_ENCODE_SET, true, false, true);
+      this.encodedUsername = canonicalize(
+          encodedUsername, USERNAME_ENCODE_SET, true, false, false, true);
       return this;
     }
 
     public Builder password(String password) {
       if (password == null) throw new IllegalArgumentException("password == null");
-      this.encodedPassword = canonicalize(password, PASSWORD_ENCODE_SET, false, false, true);
+      this.encodedPassword = canonicalize(password, PASSWORD_ENCODE_SET, false, false, false, true);
       return this;
     }
 
     public Builder encodedPassword(String encodedPassword) {
       if (encodedPassword == null) throw new IllegalArgumentException("encodedPassword == null");
-      this.encodedPassword = canonicalize(encodedPassword, PASSWORD_ENCODE_SET, true, false, true);
+      this.encodedPassword = canonicalize(
+          encodedPassword, PASSWORD_ENCODE_SET, true, false, false, true);
       return this;
     }
 
     /**
      * @param host either a regular hostname, International Domain Name, IPv4 address, or IPv6
-     *     address.
+     * address.
      */
     public Builder host(String host) {
       if (host == null) throw new IllegalArgumentException("host == null");
@@ -734,7 +783,7 @@ public Builder addEncodedPathSegment(String encodedPathSegment) {
     public Builder setPathSegment(int index, String pathSegment) {
       if (pathSegment == null) throw new IllegalArgumentException("pathSegment == null");
       String canonicalPathSegment = canonicalize(
-          pathSegment, 0, pathSegment.length(), PATH_SEGMENT_ENCODE_SET, false, false, true);
+          pathSegment, 0, pathSegment.length(), PATH_SEGMENT_ENCODE_SET, false, false, false, true);
       if (isDot(canonicalPathSegment) || isDotDot(canonicalPathSegment)) {
         throw new IllegalArgumentException("unexpected path segment: " + pathSegment);
       }
@@ -747,7 +796,7 @@ public Builder setEncodedPathSegment(int index, String encodedPathSegment) {
         throw new IllegalArgumentException("encodedPathSegment == null");
       }
       String canonicalPathSegment = canonicalize(encodedPathSegment,
-          0, encodedPathSegment.length(), PATH_SEGMENT_ENCODE_SET, true, false, true);
+          0, encodedPathSegment.length(), PATH_SEGMENT_ENCODE_SET, true, false, false, true);
       encodedPathSegments.set(index, canonicalPathSegment);
       if (isDot(canonicalPathSegment) || isDotDot(canonicalPathSegment)) {
         throw new IllegalArgumentException("unexpected path segment: " + encodedPathSegment);
@@ -774,7 +823,8 @@ public Builder encodedPath(String encodedPath) {
 
     public Builder query(String query) {
       this.encodedQueryNamesAndValues = query != null
-          ? queryStringToNamesAndValues(canonicalize(query, QUERY_ENCODE_SET, false, true, true))
+          ? queryStringToNamesAndValues(canonicalize(
+          query, QUERY_ENCODE_SET, false, false, true, true))
           : null;
       return this;
     }
@@ -782,7 +832,7 @@ public Builder query(String query) {
     public Builder encodedQuery(String encodedQuery) {
       this.encodedQueryNamesAndValues = encodedQuery != null
           ? queryStringToNamesAndValues(
-              canonicalize(encodedQuery, QUERY_ENCODE_SET, true, true, true))
+          canonicalize(encodedQuery, QUERY_ENCODE_SET, true, false, true, true))
           : null;
       return this;
     }
@@ -792,9 +842,9 @@ public Builder addQueryParameter(String name, String value) {
       if (name == null) throw new IllegalArgumentException("name == null");
       if (encodedQueryNamesAndValues == null) encodedQueryNamesAndValues = new ArrayList<>();
       encodedQueryNamesAndValues.add(
-          canonicalize(name, QUERY_COMPONENT_ENCODE_SET, false, true, true));
+          canonicalize(name, QUERY_COMPONENT_ENCODE_SET, false, false, true, true));
       encodedQueryNamesAndValues.add(value != null
-          ? canonicalize(value, QUERY_COMPONENT_ENCODE_SET, false, true, true)
+          ? canonicalize(value, QUERY_COMPONENT_ENCODE_SET, false, false, true, true)
           : null);
       return this;
     }
@@ -804,9 +854,9 @@ public Builder addEncodedQueryParameter(String encodedName, String encodedValue)
       if (encodedName == null) throw new IllegalArgumentException("encodedName == null");
       if (encodedQueryNamesAndValues == null) encodedQueryNamesAndValues = new ArrayList<>();
       encodedQueryNamesAndValues.add(
-          canonicalize(encodedName, QUERY_COMPONENT_ENCODE_SET, true, true, true));
+          canonicalize(encodedName, QUERY_COMPONENT_ENCODE_SET, true, false, true, true));
       encodedQueryNamesAndValues.add(encodedValue != null
-          ? canonicalize(encodedValue, QUERY_COMPONENT_ENCODE_SET, true, true, true)
+          ? canonicalize(encodedValue, QUERY_COMPONENT_ENCODE_SET, true, false, true, true)
           : null);
       return this;
     }
@@ -826,7 +876,8 @@ public Builder setEncodedQueryParameter(String encodedName, String encodedValue)
     public Builder removeAllQueryParameters(String name) {
       if (name == null) throw new IllegalArgumentException("name == null");
       if (encodedQueryNamesAndValues == null) return this;
-      String nameToRemove = canonicalize(name, QUERY_COMPONENT_ENCODE_SET, false, true, true);
+      String nameToRemove = canonicalize(
+          name, QUERY_COMPONENT_ENCODE_SET, false, false, true, true);
       removeAllCanonicalQueryParameters(nameToRemove);
       return this;
     }
@@ -835,7 +886,7 @@ public Builder removeAllEncodedQueryParameters(String encodedName) {
       if (encodedName == null) throw new IllegalArgumentException("encodedName == null");
       if (encodedQueryNamesAndValues == null) return this;
       removeAllCanonicalQueryParameters(
-          canonicalize(encodedName, QUERY_COMPONENT_ENCODE_SET, true, true, true));
+          canonicalize(encodedName, QUERY_COMPONENT_ENCODE_SET, true, false, true, true));
       return this;
     }
 
@@ -854,14 +905,14 @@ private void removeAllCanonicalQueryParameters(String canonicalName) {
 
     public Builder fragment(String fragment) {
       this.encodedFragment = fragment != null
-          ? canonicalize(fragment, FRAGMENT_ENCODE_SET, false, false, false)
+          ? canonicalize(fragment, FRAGMENT_ENCODE_SET, false, false, false, false)
           : null;
       return this;
     }
 
     public Builder encodedFragment(String encodedFragment) {
       this.encodedFragment = encodedFragment != null
-          ? canonicalize(encodedFragment, FRAGMENT_ENCODE_SET, true, false, false)
+          ? canonicalize(encodedFragment, FRAGMENT_ENCODE_SET, true, false, false, false)
           : null;
       return this;
     }
@@ -874,20 +925,20 @@ Builder reencodeForUri() {
       for (int i = 0, size = encodedPathSegments.size(); i < size; i++) {
         String pathSegment = encodedPathSegments.get(i);
         encodedPathSegments.set(i,
-            canonicalize(pathSegment, PATH_SEGMENT_ENCODE_SET_URI, true, false, true));
+            canonicalize(pathSegment, PATH_SEGMENT_ENCODE_SET_URI, true, true, false, true));
       }
       if (encodedQueryNamesAndValues != null) {
         for (int i = 0, size = encodedQueryNamesAndValues.size(); i < size; i++) {
           String component = encodedQueryNamesAndValues.get(i);
           if (component != null) {
             encodedQueryNamesAndValues.set(i,
-                canonicalize(component, QUERY_COMPONENT_ENCODE_SET_URI, true, true, true));
+                canonicalize(component, QUERY_COMPONENT_ENCODE_SET_URI, true, true, true, true));
           }
         }
       }
       if (encodedFragment != null) {
         encodedFragment = canonicalize(
-            encodedFragment, FRAGMENT_ENCODE_SET_URI, true, false, false);
+            encodedFragment, FRAGMENT_ENCODE_SET_URI, true, true, false, false);
       }
       return this;
     }
@@ -998,21 +1049,21 @@ ParseResult parse(HttpUrl base, String input) {
               // User info precedes.
               if (!hasPassword) {
                 int passwordColonOffset = delimiterOffset(
-                    input, pos, componentDelimiterOffset, ":");
+                    input, pos, componentDelimiterOffset, ':');
                 String canonicalUsername = canonicalize(
-                    input, pos, passwordColonOffset, USERNAME_ENCODE_SET, true, false, true);
+                    input, pos, passwordColonOffset, USERNAME_ENCODE_SET, true, false, false, true);
                 this.encodedUsername = hasUsername
                     ? this.encodedUsername + "%40" + canonicalUsername
                     : canonicalUsername;
                 if (passwordColonOffset != componentDelimiterOffset) {
                   hasPassword = true;
                   this.encodedPassword = canonicalize(input, passwordColonOffset + 1,
-                      componentDelimiterOffset, PASSWORD_ENCODE_SET, true, false, true);
+                      componentDelimiterOffset, PASSWORD_ENCODE_SET, true, false, false, true);
                 }
                 hasUsername = true;
               } else {
-                this.encodedPassword = this.encodedPassword + "%40" + canonicalize(
-                    input, pos, componentDelimiterOffset, PASSWORD_ENCODE_SET, true, false, true);
+                this.encodedPassword = this.encodedPassword + "%40" + canonicalize(input, pos,
+                    componentDelimiterOffset, PASSWORD_ENCODE_SET, true, false, false, true);
               }
               pos = componentDelimiterOffset + 1;
               break;
@@ -1057,16 +1108,16 @@ ParseResult parse(HttpUrl base, String input) {
 
       // Query.
       if (pos < limit && input.charAt(pos) == '?') {
-        int queryDelimiterOffset = delimiterOffset(input, pos, limit, "#");
+        int queryDelimiterOffset = delimiterOffset(input, pos, limit, '#');
         this.encodedQueryNamesAndValues = queryStringToNamesAndValues(canonicalize(
-            input, pos + 1, queryDelimiterOffset, QUERY_ENCODE_SET, true, true, true));
+            input, pos + 1, queryDelimiterOffset, QUERY_ENCODE_SET, true, false, true, true));
         pos = queryDelimiterOffset;
       }
 
       // Fragment.
       if (pos < limit && input.charAt(pos) == '#') {
         this.encodedFragment = canonicalize(
-            input, pos + 1, limit, FRAGMENT_ENCODE_SET, true, false, false);
+            input, pos + 1, limit, FRAGMENT_ENCODE_SET, true, false, false, false);
       }
 
       return ParseResult.SUCCESS;
@@ -1103,7 +1154,7 @@ private void resolvePath(String input, int pos, int limit) {
     private void push(String input, int pos, int limit, boolean addTrailingSlash,
         boolean alreadyEncoded) {
       String segment = canonicalize(
-          input, pos, limit, PATH_SEGMENT_ENCODE_SET, alreadyEncoded, false, true);
+          input, pos, limit, PATH_SEGMENT_ENCODE_SET, alreadyEncoded, false, false, true);
       if (isDot(segment)) {
         return; // Skip '.' path segments.
       }
@@ -1136,8 +1187,8 @@ private boolean isDotDot(String input) {
      * Removes a path segment. When this method returns the last segment is always "", which means
      * the encoded path will have a trailing '/'.
      *
-     * <p>Popping "/a/b/c/" yields "/a/b/". In this case the list of path segments goes from
-     * ["a", "b", "c", ""] to ["a", "b", ""].
+     * <p>Popping "/a/b/c/" yields "/a/b/". In this case the list of path segments goes from ["a",
+     * "b", "c", ""] to ["a", "b", ""].
      *
      * <p>Popping "/a/b/c" also yields "/a/b/". The list of path segments goes from ["a", "b", "c"]
      * to ["a", "b", ""].
@@ -1153,46 +1204,6 @@ private void pop() {
       }
     }
 
-    /**
-     * Increments {@code pos} until {@code input[pos]} is not ASCII whitespace. Stops at {@code
-     * limit}.
-     */
-    private int skipLeadingAsciiWhitespace(String input, int pos, int limit) {
-      for (int i = pos; i < limit; i++) {
-        switch (input.charAt(i)) {
-          case '\t':
-          case '\n':
-          case '\f':
-          case '\r':
-          case ' ':
-            continue;
-          default:
-            return i;
-        }
-      }
-      return limit;
-    }
-
-    /**
-     * Decrements {@code limit} until {@code input[limit - 1]} is not ASCII whitespace. Stops at
-     * {@code pos}.
-     */
-    private int skipTrailingAsciiWhitespace(String input, int pos, int limit) {
-      for (int i = limit - 1; i >= pos; i--) {
-        switch (input.charAt(i)) {
-          case '\t':
-          case '\n':
-          case '\f':
-          case '\r':
-          case ' ':
-            continue;
-          default:
-            return i + 1;
-        }
-      }
-      return pos;
-    }
-
     /**
      * Returns the index of the ':' in {@code input} that is after scheme characters. Returns -1 if
      * {@code input} does not have a scheme that starts at {@code pos}.
@@ -1377,47 +1388,6 @@ private static boolean decodeIpv4Suffix(
       return true; // Success.
     }
 
-    /**
-     * Performs IDN ToASCII encoding and canonicalize the result to lowercase. e.g. This converts
-     * {@code ☃.net} to {@code xn--n3h.net}, and {@code WwW.GoOgLe.cOm} to {@code www.google.com}.
-     * {@code null} will be returned if the input cannot be ToASCII encoded or if the result
-     * contains unsupported ASCII characters.
-     */
-    private static String domainToAscii(String input) {
-      try {
-        String result = IDN.toASCII(input).toLowerCase(Locale.US);
-        if (result.isEmpty()) return null;
-
-        // Confirm that the IDN ToASCII result doesn't contain any illegal characters.
-        if (containsInvalidHostnameAsciiCodes(result)) {
-          return null;
-        }
-        // TODO: implement all label limits.
-        return result;
-      } catch (IllegalArgumentException e) {
-        return null;
-      }
-    }
-
-    private static boolean containsInvalidHostnameAsciiCodes(String hostnameAscii) {
-      for (int i = 0; i < hostnameAscii.length(); i++) {
-        char c = hostnameAscii.charAt(i);
-        // The WHATWG Host parsing rules accepts some character codes which are invalid by
-        // definition for OkHttp's host header checks (and the WHATWG Host syntax definition). Here
-        // we rule out characters that would cause problems in host headers.
-        if (c <= '\u001f' || c >= '\u007f') {
-          return true;
-        }
-        // Check for the characters mentioned in the WHATWG Host parsing spec:
-        // U+0000, U+0009, U+000A, U+000D, U+0020, "#", "%", "/", ":", "?", "@", "[", "\", and "]"
-        // (excluding the characters covered above).
-        if (" #%/:?@[\\]".indexOf(c) != -1) {
-          return true;
-        }
-      }
-      return false;
-    }
-
     private static String inet6AddressToAscii(byte[] address) {
       // Go through the address looking for the longest run of 0s. Each group is 2-bytes.
       int longestRunOffset = -1;
@@ -1454,7 +1424,7 @@ private static String inet6AddressToAscii(byte[] address) {
     private static int parsePort(String input, int pos, int limit) {
       try {
         // Canonicalize the port string to skip '\n' etc.
-        String portString = canonicalize(input, pos, limit, "", false, false, true);
+        String portString = canonicalize(input, pos, limit, "", false, false, false, true);
         int i = Integer.parseInt(portString);
         if (i > 0 && i <= 65535) return i;
         return -1;
@@ -1464,17 +1434,6 @@ private static int parsePort(String input, int pos, int limit) {
     }
   }
 
-  /**
-   * Returns the index of the first character in {@code input} that contains a character in {@code
-   * delimiters}. Returns limit if there is no such character.
-   */
-  private static int delimiterOffset(String input, int pos, int limit, String delimiters) {
-    for (int i = pos; i < limit; i++) {
-      if (delimiters.indexOf(input.charAt(i)) != -1) return i;
-    }
-    return limit;
-  }
-
   static String percentDecode(String encoded, boolean plusIsSpace) {
     return percentDecode(encoded, 0, encoded.length(), plusIsSpace);
   }
@@ -1523,6 +1482,13 @@ static void percentDecode(Buffer out, String encoded, int pos, int limit, boolea
     }
   }
 
+  static boolean percentEncoded(String encoded, int pos, int limit) {
+    return pos + 2 < limit
+        && encoded.charAt(pos) == '%'
+        && decodeHexDigit(encoded.charAt(pos + 1)) != -1
+        && decodeHexDigit(encoded.charAt(pos + 2)) != -1;
+  }
+
   static int decodeHexDigit(char c) {
     if (c >= '0' && c <= '9') return c - '0';
     if (c >= 'a' && c <= 'f') return c - 'a' + 10;
@@ -1542,24 +1508,26 @@ static int decodeHexDigit(char c) {
    * </ul>
    *
    * @param alreadyEncoded true to leave '%' as-is; false to convert it to '%25'.
+   * @param strict true to encode '%' if it is not the prefix of a valid percent encoding.
    * @param plusIsSpace true to encode '+' as "%2B" if it is not already encoded.
    * @param asciiOnly true to encode all non-ASCII codepoints.
    */
   static String canonicalize(String input, int pos, int limit, String encodeSet,
-      boolean alreadyEncoded, boolean plusIsSpace, boolean asciiOnly) {
+      boolean alreadyEncoded, boolean strict, boolean plusIsSpace, boolean asciiOnly) {
     int codePoint;
     for (int i = pos; i < limit; i += Character.charCount(codePoint)) {
       codePoint = input.codePointAt(i);
       if (codePoint < 0x20
           || codePoint == 0x7f
-          || (codePoint >= 0x80 && asciiOnly)
+          || codePoint >= 0x80 && asciiOnly
           || encodeSet.indexOf(codePoint) != -1
-          || (codePoint == '%' && !alreadyEncoded)
-          || (codePoint == '+' && plusIsSpace)) {
+          || codePoint == '%' && (!alreadyEncoded || strict && !percentEncoded(input, i, limit))
+          || codePoint == '+' && plusIsSpace) {
         // Slow path: the character at i requires encoding!
         Buffer out = new Buffer();
         out.writeUtf8(input, pos, i);
-        canonicalize(out, input, i, limit, encodeSet, alreadyEncoded, plusIsSpace, asciiOnly);
+        canonicalize(out, input, i, limit, encodeSet, alreadyEncoded, strict, plusIsSpace,
+            asciiOnly);
         return out.readUtf8();
       }
     }
@@ -1568,8 +1536,8 @@ static String canonicalize(String input, int pos, int limit, String encodeSet,
     return input.substring(pos, limit);
   }
 
-  static void canonicalize(Buffer out, String input, int pos, int limit,
-      String encodeSet, boolean alreadyEncoded, boolean plusIsSpace, boolean asciiOnly) {
+  static void canonicalize(Buffer out, String input, int pos, int limit, String encodeSet,
+      boolean alreadyEncoded, boolean strict, boolean plusIsSpace, boolean asciiOnly) {
     Buffer utf8Buffer = null; // Lazily allocated.
     int codePoint;
     for (int i = pos; i < limit; i += Character.charCount(codePoint)) {
@@ -1582,9 +1550,9 @@ static void canonicalize(Buffer out, String input, int pos, int limit,
         out.writeUtf8(alreadyEncoded ? "+" : "%2B");
       } else if (codePoint < 0x20
           || codePoint == 0x7f
-          || (codePoint >= 0x80 && asciiOnly)
+          || codePoint >= 0x80 && asciiOnly
           || encodeSet.indexOf(codePoint) != -1
-          || (codePoint == '%' && !alreadyEncoded)) {
+          || codePoint == '%' && (!alreadyEncoded || strict && !percentEncoded(input, i, limit))) {
         // Percent encode this character.
         if (utf8Buffer == null) {
           utf8Buffer = new Buffer();
@@ -1603,9 +1571,9 @@ static void canonicalize(Buffer out, String input, int pos, int limit,
     }
   }
 
-  static String canonicalize(String input, String encodeSet, boolean alreadyEncoded,
+  static String canonicalize(String input, String encodeSet, boolean alreadyEncoded, boolean strict,
       boolean plusIsSpace, boolean asciiOnly) {
     return canonicalize(
-        input, 0, input.length(), encodeSet, alreadyEncoded, plusIsSpace, asciiOnly);
+        input, 0, input.length(), encodeSet, alreadyEncoded, strict, plusIsSpace, asciiOnly);
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/Interceptor.java b/okhttp/src/main/java/okhttp3/Interceptor.java
index e18440cc78..94effbdf40 100644
--- a/okhttp/src/main/java/okhttp3/Interceptor.java
+++ b/okhttp/src/main/java/okhttp3/Interceptor.java
@@ -27,7 +27,9 @@
 
   interface Chain {
     Request request();
+
     Response proceed(Request request) throws IOException;
+
     Connection connection();
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/MediaType.java b/okhttp/src/main/java/okhttp3/MediaType.java
index 805d1c7d6f..bbdcedf686 100644
--- a/okhttp/src/main/java/okhttp3/MediaType.java
+++ b/okhttp/src/main/java/okhttp3/MediaType.java
@@ -21,8 +21,8 @@
 import java.util.regex.Pattern;
 
 /**
- * An <a href="http://tools.ietf.org/html/rfc2045">RFC 2045</a> Media Type,
- * appropriate to describe the content type of an HTTP request or response body.
+ * An <a href="http://tools.ietf.org/html/rfc2045">RFC 2045</a> Media Type, appropriate to describe
+ * the content type of an HTTP request or response body.
  */
 public final class MediaType {
   private static final String TOKEN = "([a-zA-Z0-9-!#$%&'*+.^_`{|}~]+)";
@@ -44,8 +44,8 @@ private MediaType(String mediaType, String type, String subtype, String charset)
   }
 
   /**
-   * Returns a media type for {@code string}, or null if {@code string} is not a
-   * well-formed media type.
+   * Returns a media type for {@code string}, or null if {@code string} is not a well-formed media
+   * type.
    */
   public static MediaType parse(String string) {
     Matcher typeSubtype = TYPE_SUBTYPE.matcher(string);
@@ -74,40 +74,38 @@ public static MediaType parse(String string) {
   }
 
   /**
-   * Returns the high-level media type, such as "text", "image", "audio",
-   * "video", or "application".
+   * Returns the high-level media type, such as "text", "image", "audio", "video", or
+   * "application".
    */
   public String type() {
     return type;
   }
 
   /**
-   * Returns a specific media subtype, such as "plain" or "png", "mpeg",
-   * "mp4" or "xml".
+   * Returns a specific media subtype, such as "plain" or "png", "mpeg", "mp4" or "xml".
    */
   public String subtype() {
     return subtype;
   }
 
   /**
-   * Returns the charset of this media type, or null if this media type doesn't
-   * specify a charset.
+   * Returns the charset of this media type, or null if this media type doesn't specify a charset.
    */
   public Charset charset() {
     return charset != null ? Charset.forName(charset) : null;
   }
 
   /**
-   * Returns the charset of this media type, or {@code defaultValue} if this
-   * media type doesn't specify a charset.
+   * Returns the charset of this media type, or {@code defaultValue} if this media type doesn't
+   * specify a charset.
    */
   public Charset charset(Charset defaultValue) {
     return charset != null ? Charset.forName(charset) : defaultValue;
   }
 
   /**
-   * Returns the encoded media type, like "text/plain; charset=utf-8",
-   * appropriate for use in a Content-Type header.
+   * Returns the encoded media type, like "text/plain; charset=utf-8", appropriate for use in a
+   * Content-Type header.
    */
   @Override public String toString() {
     return mediaType;
diff --git a/okhttp/src/main/java/okhttp3/MultipartBody.java b/okhttp/src/main/java/okhttp3/MultipartBody.java
index 57f6095d4b..7ac584d1d9 100644
--- a/okhttp/src/main/java/okhttp3/MultipartBody.java
+++ b/okhttp/src/main/java/okhttp3/MultipartBody.java
@@ -15,11 +15,11 @@
  */
 package okhttp3;
 
-import okhttp3.internal.Util;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.UUID;
+import okhttp3.internal.Util;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.ByteString;
@@ -27,46 +27,42 @@
 /** An <a href="http://www.ietf.org/rfc/rfc2387.txt">RFC 2387</a>-compliant request body. */
 public final class MultipartBody extends RequestBody {
   /**
-   * The "mixed" subtype of "multipart" is intended for use when the body
-   * parts are independent and need to be bundled in a particular order. Any
-   * "multipart" subtypes that an implementation does not recognize must be
-   * treated as being of subtype "mixed".
+   * The "mixed" subtype of "multipart" is intended for use when the body parts are independent and
+   * need to be bundled in a particular order. Any "multipart" subtypes that an implementation does
+   * not recognize must be treated as being of subtype "mixed".
    */
   public static final MediaType MIXED = MediaType.parse("multipart/mixed");
 
   /**
-   * The "multipart/alternative" type is syntactically identical to
-   * "multipart/mixed", but the semantics are different. In particular, each
-   * of the body parts is an "alternative" version of the same information.
+   * The "multipart/alternative" type is syntactically identical to "multipart/mixed", but the
+   * semantics are different. In particular, each of the body parts is an "alternative" version of
+   * the same information.
    */
   public static final MediaType ALTERNATIVE = MediaType.parse("multipart/alternative");
 
   /**
-   * This type is syntactically identical to "multipart/mixed", but the
-   * semantics are different. In particular, in a digest, the default {@code
-   * Content-Type} value for a body part is changed from "text/plain" to
-   * "message/rfc822".
+   * This type is syntactically identical to "multipart/mixed", but the semantics are different. In
+   * particular, in a digest, the default {@code Content-Type} value for a body part is changed from
+   * "text/plain" to "message/rfc822".
    */
   public static final MediaType DIGEST = MediaType.parse("multipart/digest");
 
   /**
-   * This type is syntactically identical to "multipart/mixed", but the
-   * semantics are different. In particular, in a parallel entity, the order
-   * of body parts is not significant.
+   * This type is syntactically identical to "multipart/mixed", but the semantics are different. In
+   * particular, in a parallel entity, the order of body parts is not significant.
    */
   public static final MediaType PARALLEL = MediaType.parse("multipart/parallel");
 
   /**
-   * The media-type multipart/form-data follows the rules of all multipart
-   * MIME data streams as outlined in RFC 2046. In forms, there are a series
-   * of fields to be supplied by the user who fills out the form. Each field
-   * has a name. Within a given form, the names are unique.
+   * The media-type multipart/form-data follows the rules of all multipart MIME data streams as
+   * outlined in RFC 2046. In forms, there are a series of fields to be supplied by the user who
+   * fills out the form. Each field has a name. Within a given form, the names are unique.
    */
   public static final MediaType FORM = MediaType.parse("multipart/form-data");
 
-  private static final byte[] COLONSPACE = { ':', ' ' };
-  private static final byte[] CRLF = { '\r', '\n' };
-  private static final byte[] DASHDASH = { '-', '-' };
+  private static final byte[] COLONSPACE = {':', ' '};
+  private static final byte[] CRLF = {'\r', '\n'};
+  private static final byte[] DASHDASH = {'-', '-'};
 
   private final ByteString boundary;
   private final MediaType originalType;
@@ -119,8 +115,8 @@ public Part part(int index) {
 
   /**
    * Either writes this request to {@code sink} or measures its content length. We have one method
-   * do double-duty to make sure the counting and content are consistent, particularly when it
-   * comes to awkward operations like measuring the encoded length of header strings, or the
+   * do double-duty to make sure the counting and content are consistent, particularly when it comes
+   * to awkward operations like measuring the encoded length of header strings, or the
    * length-in-digits of an encoded integer.
    */
   private long writeOrCountBytes(BufferedSink sink, boolean countBytes) throws IOException {
@@ -194,13 +190,12 @@ private long writeOrCountBytes(BufferedSink sink, boolean countBytes) throws IOE
   /**
    * Appends a quoted-string to a StringBuilder.
    *
-   * <p>RFC 2388 is rather vague about how one should escape special characters
-   * in form-data parameters, and as it turns out Firefox and Chrome actually
-   * do rather different things, and both say in their comments that they're
-   * not really sure what the right approach is. We go with Chrome's behavior
-   * (which also experimentally seems to match what IE does), but if you
-   * actually want to have a good chance of things working, please avoid
-   * double-quotes, newlines, percent signs, and the like in your field names.
+   * <p>RFC 2388 is rather vague about how one should escape special characters in form-data
+   * parameters, and as it turns out Firefox and Chrome actually do rather different things, and
+   * both say in their comments that they're not really sure what the right approach is. We go with
+   * Chrome's behavior (which also experimentally seems to match what IE does), but if you actually
+   * want to have a good chance of things working, please avoid double-quotes, newlines, percent
+   * signs, and the like in your field names.
    */
   static StringBuilder appendQuotedString(StringBuilder target, String key) {
     target.append('"');
@@ -225,7 +220,6 @@ static StringBuilder appendQuotedString(StringBuilder target, String key) {
     return target;
   }
 
-
   public static final class Part {
     public static Part create(RequestBody body) {
       return create(null, body);
@@ -286,9 +280,8 @@ public Builder(String boundary) {
     }
 
     /**
-     * Set the MIME type. Expected values for {@code type} are {@link #MIXED} (the
-     * default), {@link #ALTERNATIVE}, {@link #DIGEST}, {@link #PARALLEL} and
-     * {@link #FORM}.
+     * Set the MIME type. Expected values for {@code type} are {@link #MIXED} (the default), {@link
+     * #ALTERNATIVE}, {@link #DIGEST}, {@link #PARALLEL} and {@link #FORM}.
      */
     public Builder setType(MediaType type) {
       if (type == null) {
diff --git a/okhttp/src/main/java/okhttp3/OkHttpClient.java b/okhttp/src/main/java/okhttp3/OkHttpClient.java
index 7e1c2549c7..3b2fa79aeb 100644
--- a/okhttp/src/main/java/okhttp3/OkHttpClient.java
+++ b/okhttp/src/main/java/okhttp3/OkHttpClient.java
@@ -15,11 +15,9 @@
  */
 package okhttp3;
 
-import java.net.CookieHandler;
 import java.net.MalformedURLException;
 import java.net.Proxy;
 import java.net.ProxySelector;
-import java.net.URLConnection;
 import java.net.UnknownHostException;
 import java.security.GeneralSecurityException;
 import java.util.ArrayList;
@@ -30,27 +28,35 @@
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
+import javax.net.ssl.X509TrustManager;
 import okhttp3.internal.Internal;
 import okhttp3.internal.InternalCache;
+import okhttp3.internal.Platform;
 import okhttp3.internal.RouteDatabase;
 import okhttp3.internal.Util;
-import okhttp3.internal.http.AuthenticatorAdapter;
 import okhttp3.internal.http.StreamAllocation;
 import okhttp3.internal.io.RealConnection;
 import okhttp3.internal.tls.OkHostnameVerifier;
 
 /**
- * Configures and creates HTTP connections. Most applications can use a single
- * OkHttpClient for all of their HTTP requests - benefiting from a shared
- * response cache, thread pool, connection re-use, etc.
+ * Factory for {@linkplain Call calls}, which can be used to send HTTP requests and read their
+ * responses. Most applications can use a single OkHttpClient for all of their HTTP requests,
+ * benefiting from a shared response cache, thread pool, connection re-use, etc.
  *
- * <p>Instances of OkHttpClient are intended to be fully configured before they're
- * shared - once shared they should be treated as immutable and can safely be used
- * to concurrently open new connections. If required, threads can call
- * {@link #clone()} to make a shallow copy of the OkHttpClient that can be
- * safely modified with further configuration changes.
+ * <p>To create an {@code OkHttpClient} with the default settings, use the {@linkplain
+ * #OkHttpClient() default constructor}. Or create a configured instance with {@link
+ * OkHttpClient.Builder}. To adjust an existing client before making a request, use {@link
+ * #newBuilder()}. This example shows a call with a 30 second timeout:
+ * <pre>   {@code
+ *
+ *   OkHttpClient client = ...
+ *   OkHttpClient clientWith30sTimeout = client.newBuilder()
+ *       .readTimeout(30, TimeUnit.SECONDS)
+ *       .build();
+ *   Response response = clientWith30sTimeout.newCall(request).execute();
+ * }</pre>
  */
-public class OkHttpClient implements Cloneable {
+public class OkHttpClient implements Cloneable, Call.Factory {
   private static final List<Protocol> DEFAULT_PROTOCOLS = Util.immutableList(
       Protocol.HTTP_2, Protocol.SPDY_3, Protocol.HTTP_1_1);
 
@@ -67,8 +73,8 @@
         builder.addLenient(name, value);
       }
 
-      @Override public void setCache(OkHttpClient client, InternalCache internalCache) {
-        client.setInternalCache(internalCache);
+      @Override public void setCache(OkHttpClient.Builder builder, InternalCache internalCache) {
+        builder.setInternalCache(internalCache);
       }
 
       @Override public InternalCache internalCache(OkHttpClient client) {
@@ -95,11 +101,11 @@
 
       @Override
       public void callEnqueue(Call call, Callback responseCallback, boolean forWebSocket) {
-        call.enqueue(responseCallback, forWebSocket);
+        ((RealCall) call).enqueue(responseCallback, forWebSocket);
       }
 
       @Override public StreamAllocation callEngineGetStreamAllocation(Call call) {
-        return call.engine.streamAllocation;
+        return ((RealCall) call).engine.streamAllocation;
       }
 
       @Override
@@ -114,455 +120,182 @@ public void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket, boolean
     };
   }
 
-  /** Lazily-initialized. */
-  private static SSLSocketFactory defaultSslSocketFactory;
-
-  private final RouteDatabase routeDatabase;
-  private Dispatcher dispatcher;
-  private Proxy proxy;
-  private List<Protocol> protocols;
-  private List<ConnectionSpec> connectionSpecs;
-  private final List<Interceptor> interceptors = new ArrayList<>();
-  private final List<Interceptor> networkInterceptors = new ArrayList<>();
-  private ProxySelector proxySelector;
-  private CookieHandler cookieHandler;
-
-  /** Non-null if this client is caching; possibly by {@code cache}. */
-  private InternalCache internalCache;
-  private Cache cache;
-
-  private SocketFactory socketFactory;
-  private SSLSocketFactory sslSocketFactory;
-  private HostnameVerifier hostnameVerifier;
-  private CertificatePinner certificatePinner;
-  private Authenticator proxyAuthenticator;
-  private Authenticator authenticator;
-  private ConnectionPool connectionPool;
-  private Dns dns;
-  private boolean followSslRedirects = true;
-  private boolean followRedirects = true;
-  private boolean retryOnConnectionFailure = true;
-  private int connectTimeout = 10_000;
-  private int readTimeout = 10_000;
-  private int writeTimeout = 10_000;
+  final Dispatcher dispatcher;
+  final Proxy proxy;
+  final List<Protocol> protocols;
+  final List<ConnectionSpec> connectionSpecs;
+  final List<Interceptor> interceptors;
+  final List<Interceptor> networkInterceptors;
+  final ProxySelector proxySelector;
+  final CookieJar cookieJar;
+  final Cache cache;
+  final InternalCache internalCache;
+  final SocketFactory socketFactory;
+  final SSLSocketFactory sslSocketFactory;
+  final X509TrustManager trustManager;
+  final HostnameVerifier hostnameVerifier;
+  final CertificatePinner certificatePinner;
+  final Authenticator proxyAuthenticator;
+  final Authenticator authenticator;
+  final ConnectionPool connectionPool;
+  final Dns dns;
+  final boolean followSslRedirects;
+  final boolean followRedirects;
+  final boolean retryOnConnectionFailure;
+  final int connectTimeout;
+  final int readTimeout;
+  final int writeTimeout;
 
   public OkHttpClient() {
-    routeDatabase = new RouteDatabase();
-    dispatcher = new Dispatcher();
-  }
+    this(new Builder());
+  }
+
+  private OkHttpClient(Builder builder) {
+    this.dispatcher = builder.dispatcher;
+    this.proxy = builder.proxy;
+    this.protocols = builder.protocols;
+    this.connectionSpecs = builder.connectionSpecs;
+    this.interceptors = Util.immutableList(builder.interceptors);
+    this.networkInterceptors = Util.immutableList(builder.networkInterceptors);
+    this.proxySelector = builder.proxySelector;
+    this.cookieJar = builder.cookieJar;
+    this.cache = builder.cache;
+    this.internalCache = builder.internalCache;
+    this.socketFactory = builder.socketFactory;
+
+    boolean isTLS = false;
+    for (ConnectionSpec spec : connectionSpecs) {
+      isTLS = isTLS || spec.isTls();
+    }
 
-  private OkHttpClient(OkHttpClient okHttpClient) {
-    this.routeDatabase = okHttpClient.routeDatabase;
-    this.dispatcher = okHttpClient.dispatcher;
-    this.proxy = okHttpClient.proxy;
-    this.protocols = okHttpClient.protocols;
-    this.connectionSpecs = okHttpClient.connectionSpecs;
-    this.interceptors.addAll(okHttpClient.interceptors);
-    this.networkInterceptors.addAll(okHttpClient.networkInterceptors);
-    this.proxySelector = okHttpClient.proxySelector;
-    this.cookieHandler = okHttpClient.cookieHandler;
-    this.cache = okHttpClient.cache;
-    this.internalCache = cache != null ? cache.internalCache : okHttpClient.internalCache;
-    this.socketFactory = okHttpClient.socketFactory;
-    this.sslSocketFactory = okHttpClient.sslSocketFactory;
-    this.hostnameVerifier = okHttpClient.hostnameVerifier;
-    this.certificatePinner = okHttpClient.certificatePinner;
-    this.proxyAuthenticator = okHttpClient.proxyAuthenticator;
-    this.authenticator = okHttpClient.authenticator;
-    this.connectionPool = okHttpClient.connectionPool;
-    this.dns = okHttpClient.dns;
-    this.followSslRedirects = okHttpClient.followSslRedirects;
-    this.followRedirects = okHttpClient.followRedirects;
-    this.retryOnConnectionFailure = okHttpClient.retryOnConnectionFailure;
-    this.connectTimeout = okHttpClient.connectTimeout;
-    this.readTimeout = okHttpClient.readTimeout;
-    this.writeTimeout = okHttpClient.writeTimeout;
-  }
+    if (builder.sslSocketFactory != null || !isTLS) {
+      this.sslSocketFactory = builder.sslSocketFactory;
+    } else {
+      try {
+        SSLContext sslContext = SSLContext.getInstance("TLS");
+        sslContext.init(null, null, null);
+        this.sslSocketFactory = sslContext.getSocketFactory();
+      } catch (GeneralSecurityException e) {
+        throw new AssertionError(); // The system has no TLS. Just give up.
+      }
+    }
+    if (this.sslSocketFactory != null) {
+      this.trustManager = Platform.get().trustManager(sslSocketFactory);
+      if (trustManager == null) {
+        throw new IllegalStateException("Unable to extract the trust manager on " + Platform.get()
+            + ", sslSocketFactory is " + sslSocketFactory.getClass());
+      }
+    } else {
+      this.trustManager = null;
+    }
 
-  /**
-   * Sets the default connect timeout for new connections. A value of 0 means no timeout, otherwise
-   * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
-   *
-   * @see URLConnection#setConnectTimeout(int)
-   */
-  public OkHttpClient setConnectTimeout(long timeout, TimeUnit unit) {
-    if (timeout < 0) throw new IllegalArgumentException("timeout < 0");
-    if (unit == null) throw new IllegalArgumentException("unit == null");
-    long millis = unit.toMillis(timeout);
-    if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException("Timeout too large.");
-    if (millis == 0 && timeout > 0) throw new IllegalArgumentException("Timeout too small.");
-    connectTimeout = (int) millis;
-    return this;
+    this.hostnameVerifier = builder.hostnameVerifier;
+    this.certificatePinner = builder.certificatePinner;
+    this.proxyAuthenticator = builder.proxyAuthenticator;
+    this.authenticator = builder.authenticator;
+    this.connectionPool = builder.connectionPool;
+    this.dns = builder.dns;
+    this.followSslRedirects = builder.followSslRedirects;
+    this.followRedirects = builder.followRedirects;
+    this.retryOnConnectionFailure = builder.retryOnConnectionFailure;
+    this.connectTimeout = builder.connectTimeout;
+    this.readTimeout = builder.readTimeout;
+    this.writeTimeout = builder.writeTimeout;
   }
 
   /** Default connect timeout (in milliseconds). */
-  public int getConnectTimeout() {
+  public int connectTimeoutMillis() {
     return connectTimeout;
   }
 
-  /**
-   * Sets the default read timeout for new connections. A value of 0 means no timeout, otherwise
-   * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
-   *
-   * @see URLConnection#setReadTimeout(int)
-   */
-  public OkHttpClient setReadTimeout(long timeout, TimeUnit unit) {
-    if (timeout < 0) throw new IllegalArgumentException("timeout < 0");
-    if (unit == null) throw new IllegalArgumentException("unit == null");
-    long millis = unit.toMillis(timeout);
-    if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException("Timeout too large.");
-    if (millis == 0 && timeout > 0) throw new IllegalArgumentException("Timeout too small.");
-    readTimeout = (int) millis;
-    return this;
-  }
-
   /** Default read timeout (in milliseconds). */
-  public int getReadTimeout() {
+  public int readTimeoutMillis() {
     return readTimeout;
   }
 
-  /**
-   * Sets the default write timeout for new connections. A value of 0 means no timeout, otherwise
-   * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
-   */
-  public OkHttpClient setWriteTimeout(long timeout, TimeUnit unit) {
-    if (timeout < 0) throw new IllegalArgumentException("timeout < 0");
-    if (unit == null) throw new IllegalArgumentException("unit == null");
-    long millis = unit.toMillis(timeout);
-    if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException("Timeout too large.");
-    if (millis == 0 && timeout > 0) throw new IllegalArgumentException("Timeout too small.");
-    writeTimeout = (int) millis;
-    return this;
-  }
-
   /** Default write timeout (in milliseconds). */
-  public int getWriteTimeout() {
+  public int writeTimeoutMillis() {
     return writeTimeout;
   }
 
-  /**
-   * Sets the HTTP proxy that will be used by connections created by this
-   * client. This takes precedence over {@link #setProxySelector}, which is
-   * only honored when this proxy is null (which it is by default). To disable
-   * proxy use completely, call {@code setProxy(Proxy.NO_PROXY)}.
-   */
-  public OkHttpClient setProxy(Proxy proxy) {
-    this.proxy = proxy;
-    return this;
-  }
-
-  public Proxy getProxy() {
+  public Proxy proxy() {
     return proxy;
   }
 
-  /**
-   * Sets the proxy selection policy to be used if no {@link #setProxy proxy}
-   * is specified explicitly. The proxy selector may return multiple proxies;
-   * in that case they will be tried in sequence until a successful connection
-   * is established.
-   *
-   * <p>If unset, the {@link ProxySelector#getDefault() system-wide default}
-   * proxy selector will be used.
-   */
-  public OkHttpClient setProxySelector(ProxySelector proxySelector) {
-    this.proxySelector = proxySelector;
-    return this;
-  }
-
-  public ProxySelector getProxySelector() {
+  public ProxySelector proxySelector() {
     return proxySelector;
   }
 
-  /**
-   * Sets the cookie handler to be used to read outgoing cookies and write
-   * incoming cookies.
-   *
-   * <p>If unset, the {@link CookieHandler#getDefault() system-wide default}
-   * cookie handler will be used.
-   */
-  public OkHttpClient setCookieHandler(CookieHandler cookieHandler) {
-    this.cookieHandler = cookieHandler;
-    return this;
-  }
-
-  public CookieHandler getCookieHandler() {
-    return cookieHandler;
-  }
-
-  /** Sets the response cache to be used to read and write cached responses. */
-  void setInternalCache(InternalCache internalCache) {
-    this.internalCache = internalCache;
-    this.cache = null;
-  }
-
-  InternalCache internalCache() {
-    return internalCache;
-  }
-
-  public OkHttpClient setCache(Cache cache) {
-    this.cache = cache;
-    this.internalCache = null;
-    return this;
+  public CookieJar cookieJar() {
+    return cookieJar;
   }
 
-  public Cache getCache() {
+  public Cache cache() {
     return cache;
   }
 
-  /**
-   * Sets the DNS service used to lookup IP addresses for hostnames.
-   *
-   * <p>If unset, the {@link Dns#SYSTEM system-wide default} DNS will be used.
-   */
-  public OkHttpClient setDns(Dns dns) {
-    this.dns = dns;
-    return this;
+  InternalCache internalCache() {
+    return cache != null ? cache.internalCache : internalCache;
   }
 
-  public Dns getDns() {
+  public Dns dns() {
     return dns;
   }
 
-  /**
-   * Sets the socket factory used to create connections. OkHttp only uses
-   * the parameterless {@link SocketFactory#createSocket() createSocket()}
-   * method to create unconnected sockets. Overriding this method,
-   * e. g., allows the socket to be bound to a specific local address.
-   *
-   * <p>If unset, the {@link SocketFactory#getDefault() system-wide default}
-   * socket factory will be used.
-   */
-  public OkHttpClient setSocketFactory(SocketFactory socketFactory) {
-    this.socketFactory = socketFactory;
-    return this;
-  }
-
-  public SocketFactory getSocketFactory() {
+  public SocketFactory socketFactory() {
     return socketFactory;
   }
 
-  /**
-   * Sets the socket factory used to secure HTTPS connections.
-   *
-   * <p>If unset, a lazily created SSL socket factory will be used.
-   */
-  public OkHttpClient setSslSocketFactory(SSLSocketFactory sslSocketFactory) {
-    this.sslSocketFactory = sslSocketFactory;
-    return this;
-  }
-
-  public SSLSocketFactory getSslSocketFactory() {
+  public SSLSocketFactory sslSocketFactory() {
     return sslSocketFactory;
   }
 
-  /**
-   * Sets the verifier used to confirm that response certificates apply to
-   * requested hostnames for HTTPS connections.
-   *
-   * <p>If unset, a default hostname verifier will be used.
-   */
-  public OkHttpClient setHostnameVerifier(HostnameVerifier hostnameVerifier) {
-    this.hostnameVerifier = hostnameVerifier;
-    return this;
-  }
-
-  public HostnameVerifier getHostnameVerifier() {
+  public HostnameVerifier hostnameVerifier() {
     return hostnameVerifier;
   }
 
-  /**
-   * Sets the certificate pinner that constrains which certificates are trusted.
-   * By default HTTPS connections rely on only the {@link #setSslSocketFactory
-   * SSL socket factory} to establish trust. Pinning certificates avoids the
-   * need to trust certificate authorities.
-   */
-  public OkHttpClient setCertificatePinner(CertificatePinner certificatePinner) {
-    this.certificatePinner = certificatePinner;
-    return this;
-  }
-
-  public CertificatePinner getCertificatePinner() {
+  public CertificatePinner certificatePinner() {
     return certificatePinner;
   }
 
-  /**
-   * Sets the authenticator used to respond to challenges from origin servers. Use {@link
-   * #setProxyAuthenticator} to set the authenticator for proxy servers.
-   *
-   * <p>If unset, the {@linkplain java.net.Authenticator#setDefault system-wide default}
-   * authenticator will be used.
-   */
-  public OkHttpClient setAuthenticator(Authenticator authenticator) {
-    this.authenticator = authenticator;
-    return this;
-  }
-
-  public Authenticator getAuthenticator() {
+  public Authenticator authenticator() {
     return authenticator;
   }
 
-  /**
-   * Sets the authenticator used to respond to challenges from proxy servers. Use {@link
-   * #setAuthenticator} to set the authenticator for origin servers.
-   *
-   * <p>If unset, the {@linkplain java.net.Authenticator#setDefault system-wide default}
-   * authenticator will be used.
-   */
-  public OkHttpClient setProxyAuthenticator(Authenticator proxyAuthenticator) {
-    this.proxyAuthenticator = proxyAuthenticator;
-    return this;
-  }
-
-  public Authenticator getProxyAuthenticator() {
+  public Authenticator proxyAuthenticator() {
     return proxyAuthenticator;
   }
 
-  /**
-   * Sets the connection pool used to recycle HTTP and HTTPS connections.
-   *
-   * <p>If unset, the {@link ConnectionPool#getDefault() system-wide
-   * default} connection pool will be used.
-   */
-  public OkHttpClient setConnectionPool(ConnectionPool connectionPool) {
-    this.connectionPool = connectionPool;
-    return this;
-  }
-
-  public ConnectionPool getConnectionPool() {
+  public ConnectionPool connectionPool() {
     return connectionPool;
   }
 
-  /**
-   * Configure this client to follow redirects from HTTPS to HTTP and from HTTP
-   * to HTTPS.
-   *
-   * <p>If unset, protocol redirects will be followed. This is different than
-   * the built-in {@code HttpURLConnection}'s default.
-   */
-  public OkHttpClient setFollowSslRedirects(boolean followProtocolRedirects) {
-    this.followSslRedirects = followProtocolRedirects;
-    return this;
-  }
-
-  public boolean getFollowSslRedirects() {
+  public boolean followSslRedirects() {
     return followSslRedirects;
   }
 
-  /** Configure this client to follow redirects. If unset, redirects be followed. */
-  public OkHttpClient setFollowRedirects(boolean followRedirects) {
-    this.followRedirects = followRedirects;
-    return this;
-  }
-
-  public boolean getFollowRedirects() {
+  public boolean followRedirects() {
     return followRedirects;
   }
 
-  /**
-   * Configure this client to retry or not when a connectivity problem is encountered. By default,
-   * this client silently recovers from the following problems:
-   *
-   * <ul>
-   *   <li><strong>Unreachable IP addresses.</strong> If the URL's host has multiple IP addresses,
-   *       failure to reach any individual IP address doesn't fail the overall request. This can
-   *       increase availability of multi-homed services.
-   *   <li><strong>Stale pooled connections.</strong> The {@link ConnectionPool} reuses sockets
-   *       to decrease request latency, but these connections will occasionally time out.
-   *   <li><strong>Unreachable proxy servers.</strong> A {@link ProxySelector} can be used to
-   *       attempt multiple proxy servers in sequence, eventually falling back to a direct
-   *       connection.
-   * </ul>
-   *
-   * Set this to false to avoid retrying requests when doing so is destructive. In this case the
-   * calling application should do its own recovery of connectivity failures.
-   */
-  public OkHttpClient setRetryOnConnectionFailure(boolean retryOnConnectionFailure) {
-    this.retryOnConnectionFailure = retryOnConnectionFailure;
-    return this;
-  }
-
-  public boolean getRetryOnConnectionFailure() {
+  public boolean retryOnConnectionFailure() {
     return retryOnConnectionFailure;
   }
 
-  RouteDatabase routeDatabase() {
-    return routeDatabase;
-  }
-
-  /**
-   * Sets the dispatcher used to set policy and execute asynchronous requests.
-   * Must not be null.
-   */
-  public OkHttpClient setDispatcher(Dispatcher dispatcher) {
-    if (dispatcher == null) throw new IllegalArgumentException("dispatcher == null");
-    this.dispatcher = dispatcher;
-    return this;
-  }
-
-  public Dispatcher getDispatcher() {
+  public Dispatcher dispatcher() {
     return dispatcher;
   }
 
-  /**
-   * Configure the protocols used by this client to communicate with remote
-   * servers. By default this client will prefer the most efficient transport
-   * available, falling back to more ubiquitous protocols. Applications should
-   * only call this method to avoid specific compatibility problems, such as web
-   * servers that behave incorrectly when SPDY is enabled.
-   *
-   * <p>The following protocols are currently supported:
-   * <ul>
-   *   <li><a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html">http/1.1</a>
-   *   <li><a href="http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1">spdy/3.1</a>
-   *   <li><a href="http://tools.ietf.org/html/draft-ietf-httpbis-http2-17">h2</a>
-   * </ul>
-   *
-   * <p><strong>This is an evolving set.</strong> Future releases include
-   * support for transitional protocols. The http/1.1 transport will never be
-   * dropped.
-   *
-   * <p>If multiple protocols are specified, <a
-   * href="http://tools.ietf.org/html/draft-ietf-tls-applayerprotoneg">ALPN</a>
-   * will be used to negotiate a transport.
-   *
-   * <p>{@link Protocol#HTTP_1_0} is not supported in this set. Requests are
-   * initiated with {@code HTTP/1.1} only. If the server responds with {@code
-   * HTTP/1.0}, that will be exposed by {@link Response#protocol()}.
-   *
-   * @param protocols the protocols to use, in order of preference. The list
-   *     must contain {@link Protocol#HTTP_1_1}. It must not contain null or
-   *     {@link Protocol#HTTP_1_0}.
-   */
-  public OkHttpClient setProtocols(List<Protocol> protocols) {
-    protocols = Util.immutableList(protocols);
-    if (!protocols.contains(Protocol.HTTP_1_1)) {
-      throw new IllegalArgumentException("protocols doesn't contain http/1.1: " + protocols);
-    }
-    if (protocols.contains(Protocol.HTTP_1_0)) {
-      throw new IllegalArgumentException("protocols must not contain http/1.0: " + protocols);
-    }
-    if (protocols.contains(null)) {
-      throw new IllegalArgumentException("protocols must not contain null");
-    }
-    this.protocols = Util.immutableList(protocols);
-    return this;
-  }
-
-  public List<Protocol> getProtocols() {
+  public List<Protocol> protocols() {
     return protocols;
   }
 
-  public OkHttpClient setConnectionSpecs(List<ConnectionSpec> connectionSpecs) {
-    this.connectionSpecs = Util.immutableList(connectionSpecs);
-    return this;
-  }
-
-  public List<ConnectionSpec> getConnectionSpecs() {
+  public List<ConnectionSpec> connectionSpecs() {
     return connectionSpecs;
   }
 
   /**
-   * Returns a modifiable list of interceptors that observe the full span of each call: from before
+   * Returns an immutable list of interceptors that observe the full span of each call: from before
    * the connection is established (if any) until after the response source is selected (either the
    * origin server, cache, or both).
    */
@@ -571,7 +304,7 @@ public OkHttpClient setConnectionSpecs(List<ConnectionSpec> connectionSpecs) {
   }
 
   /**
-   * Returns a modifiable list of interceptors that observe a single network request and response.
+   * Returns an immutable list of interceptors that observe a single network request and response.
    * These interceptors must call {@link Interceptor.Chain#proceed} exactly once: it is an error for
    * a network interceptor to short-circuit or repeat a network request.
    */
@@ -582,90 +315,400 @@ public OkHttpClient setConnectionSpecs(List<ConnectionSpec> connectionSpecs) {
   /**
    * Prepares the {@code request} to be executed at some point in the future.
    */
-  public Call newCall(Request request) {
-    return new Call(this, request);
-  }
+  @Override public Call newCall(Request request) {
+    return new RealCall(this, request);
+  }
+
+  public Builder newBuilder() {
+    return new Builder(this);
+  }
+
+  public static final class Builder {
+    Dispatcher dispatcher;
+    Proxy proxy;
+    List<Protocol> protocols;
+    List<ConnectionSpec> connectionSpecs;
+    final List<Interceptor> interceptors = new ArrayList<>();
+    final List<Interceptor> networkInterceptors = new ArrayList<>();
+    ProxySelector proxySelector;
+    CookieJar cookieJar;
+    Cache cache;
+    InternalCache internalCache;
+    SocketFactory socketFactory;
+    SSLSocketFactory sslSocketFactory;
+    HostnameVerifier hostnameVerifier;
+    CertificatePinner certificatePinner;
+    Authenticator proxyAuthenticator;
+    Authenticator authenticator;
+    ConnectionPool connectionPool;
+    Dns dns;
+    boolean followSslRedirects;
+    boolean followRedirects;
+    boolean retryOnConnectionFailure;
+    int connectTimeout;
+    int readTimeout;
+    int writeTimeout;
+
+    public Builder() {
+      dispatcher = new Dispatcher();
+      protocols = DEFAULT_PROTOCOLS;
+      connectionSpecs = DEFAULT_CONNECTION_SPECS;
+      proxySelector = ProxySelector.getDefault();
+      cookieJar = CookieJar.NO_COOKIES;
+      socketFactory = SocketFactory.getDefault();
+      hostnameVerifier = OkHostnameVerifier.INSTANCE;
+      certificatePinner = CertificatePinner.DEFAULT;
+      proxyAuthenticator = Authenticator.NONE;
+      authenticator = Authenticator.NONE;
+      connectionPool = new ConnectionPool();
+      dns = Dns.SYSTEM;
+      followSslRedirects = true;
+      followRedirects = true;
+      retryOnConnectionFailure = true;
+      connectTimeout = 10_000;
+      readTimeout = 10_000;
+      writeTimeout = 10_000;
+    }
 
-  /**
-   * Cancels all scheduled or in-flight calls tagged with {@code tag}. Requests
-   * that are already complete cannot be canceled.
-   */
-  public OkHttpClient cancel(Object tag) {
-    getDispatcher().cancel(tag);
-    return this;
-  }
+    Builder(OkHttpClient okHttpClient) {
+      this.dispatcher = okHttpClient.dispatcher;
+      this.proxy = okHttpClient.proxy;
+      this.protocols = okHttpClient.protocols;
+      this.connectionSpecs = okHttpClient.connectionSpecs;
+      this.interceptors.addAll(okHttpClient.interceptors);
+      this.networkInterceptors.addAll(okHttpClient.networkInterceptors);
+      this.proxySelector = okHttpClient.proxySelector;
+      this.cookieJar = okHttpClient.cookieJar;
+      this.internalCache = okHttpClient.internalCache;
+      this.cache = okHttpClient.cache;
+      this.socketFactory = okHttpClient.socketFactory;
+      this.sslSocketFactory = okHttpClient.sslSocketFactory;
+      this.hostnameVerifier = okHttpClient.hostnameVerifier;
+      this.certificatePinner = okHttpClient.certificatePinner;
+      this.proxyAuthenticator = okHttpClient.proxyAuthenticator;
+      this.authenticator = okHttpClient.authenticator;
+      this.connectionPool = okHttpClient.connectionPool;
+      this.dns = okHttpClient.dns;
+      this.followSslRedirects = okHttpClient.followSslRedirects;
+      this.followRedirects = okHttpClient.followRedirects;
+      this.retryOnConnectionFailure = okHttpClient.retryOnConnectionFailure;
+      this.connectTimeout = okHttpClient.connectTimeout;
+      this.readTimeout = okHttpClient.readTimeout;
+      this.writeTimeout = okHttpClient.writeTimeout;
+    }
 
-  /**
-   * Returns a shallow copy of this OkHttpClient that uses the system-wide
-   * default for each field that hasn't been explicitly configured.
-   */
-  OkHttpClient copyWithDefaults() {
-    OkHttpClient result = new OkHttpClient(this);
-    if (result.proxySelector == null) {
-      result.proxySelector = ProxySelector.getDefault();
+    /**
+     * Sets the default connect timeout for new connections. A value of 0 means no timeout,
+     * otherwise values must be between 1 and {@link Integer#MAX_VALUE} when converted to
+     * milliseconds.
+     */
+    public Builder connectTimeout(long timeout, TimeUnit unit) {
+      if (timeout < 0) throw new IllegalArgumentException("timeout < 0");
+      if (unit == null) throw new IllegalArgumentException("unit == null");
+      long millis = unit.toMillis(timeout);
+      if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException("Timeout too large.");
+      if (millis == 0 && timeout > 0) throw new IllegalArgumentException("Timeout too small.");
+      connectTimeout = (int) millis;
+      return this;
     }
-    if (result.cookieHandler == null) {
-      result.cookieHandler = CookieHandler.getDefault();
+
+    /**
+     * Sets the default read timeout for new connections. A value of 0 means no timeout, otherwise
+     * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
+     */
+    public Builder readTimeout(long timeout, TimeUnit unit) {
+      if (timeout < 0) throw new IllegalArgumentException("timeout < 0");
+      if (unit == null) throw new IllegalArgumentException("unit == null");
+      long millis = unit.toMillis(timeout);
+      if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException("Timeout too large.");
+      if (millis == 0 && timeout > 0) throw new IllegalArgumentException("Timeout too small.");
+      readTimeout = (int) millis;
+      return this;
     }
-    if (result.socketFactory == null) {
-      result.socketFactory = SocketFactory.getDefault();
+
+    /**
+     * Sets the default write timeout for new connections. A value of 0 means no timeout, otherwise
+     * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
+     */
+    public Builder writeTimeout(long timeout, TimeUnit unit) {
+      if (timeout < 0) throw new IllegalArgumentException("timeout < 0");
+      if (unit == null) throw new IllegalArgumentException("unit == null");
+      long millis = unit.toMillis(timeout);
+      if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException("Timeout too large.");
+      if (millis == 0 && timeout > 0) throw new IllegalArgumentException("Timeout too small.");
+      writeTimeout = (int) millis;
+      return this;
     }
-    if (result.sslSocketFactory == null) {
-      result.sslSocketFactory = getDefaultSSLSocketFactory();
+
+    /**
+     * Sets the HTTP proxy that will be used by connections created by this client. This takes
+     * precedence over {@link #proxySelector}, which is only honored when this proxy is null (which
+     * it is by default). To disable proxy use completely, call {@code setProxy(Proxy.NO_PROXY)}.
+     */
+    public Builder proxy(Proxy proxy) {
+      this.proxy = proxy;
+      return this;
     }
-    if (result.hostnameVerifier == null) {
-      result.hostnameVerifier = OkHostnameVerifier.INSTANCE;
+
+    /**
+     * Sets the proxy selection policy to be used if no {@link #proxy proxy} is specified
+     * explicitly. The proxy selector may return multiple proxies; in that case they will be tried
+     * in sequence until a successful connection is established.
+     *
+     * <p>If unset, the {@link ProxySelector#getDefault() system-wide default} proxy selector will
+     * be used.
+     */
+    public Builder proxySelector(ProxySelector proxySelector) {
+      this.proxySelector = proxySelector;
+      return this;
     }
-    if (result.certificatePinner == null) {
-      result.certificatePinner = CertificatePinner.DEFAULT;
+
+    /**
+     * Sets the handler that can accept cookies from incoming HTTP responses and provides cookies to
+     * outgoing HTTP requests.
+     *
+     * <p>If unset, {@linkplain CookieJar#NO_COOKIES no cookies} will be accepted nor provided.
+     */
+    public Builder cookieJar(CookieJar cookieJar) {
+      if (cookieJar == null) throw new NullPointerException("cookieJar == null");
+      this.cookieJar = cookieJar;
+      return this;
     }
-    if (result.authenticator == null) {
-      result.authenticator = AuthenticatorAdapter.INSTANCE;
+
+    /** Sets the response cache to be used to read and write cached responses. */
+    void setInternalCache(InternalCache internalCache) {
+      this.internalCache = internalCache;
+      this.cache = null;
     }
-    if (result.proxyAuthenticator == null) {
-      result.proxyAuthenticator = AuthenticatorAdapter.INSTANCE;
+
+    public Builder cache(Cache cache) {
+      this.cache = cache;
+      this.internalCache = null;
+      return this;
     }
-    if (result.connectionPool == null) {
-      result.connectionPool = ConnectionPool.getDefault();
+
+    /**
+     * Sets the DNS service used to lookup IP addresses for hostnames.
+     *
+     * <p>If unset, the {@link Dns#SYSTEM system-wide default} DNS will be used.
+     */
+    public Builder dns(Dns dns) {
+      if (dns == null) throw new NullPointerException("dns == null");
+      this.dns = dns;
+      return this;
     }
-    if (result.protocols == null) {
-      result.protocols = DEFAULT_PROTOCOLS;
+
+    /**
+     * Sets the socket factory used to create connections. OkHttp only uses the parameterless {@link
+     * SocketFactory#createSocket() createSocket()} method to create unconnected sockets. Overriding
+     * this method, e. g., allows the socket to be bound to a specific local address.
+     *
+     * <p>If unset, the {@link SocketFactory#getDefault() system-wide default} socket factory will
+     * be used.
+     */
+    public Builder socketFactory(SocketFactory socketFactory) {
+      if (socketFactory == null) throw new NullPointerException("socketFactory == null");
+      this.socketFactory = socketFactory;
+      return this;
     }
-    if (result.connectionSpecs == null) {
-      result.connectionSpecs = DEFAULT_CONNECTION_SPECS;
+
+    /**
+     * Sets the socket factory used to secure HTTPS connections.
+     *
+     * <p>If unset, a lazily created SSL socket factory will be used.
+     */
+    public Builder sslSocketFactory(SSLSocketFactory sslSocketFactory) {
+      if (sslSocketFactory == null) throw new NullPointerException("sslSocketFactory == null");
+      this.sslSocketFactory = sslSocketFactory;
+      return this;
     }
-    if (result.dns == null) {
-      result.dns = Dns.SYSTEM;
+
+    /**
+     * Sets the verifier used to confirm that response certificates apply to requested hostnames for
+     * HTTPS connections.
+     *
+     * <p>If unset, a default hostname verifier will be used.
+     */
+    public Builder hostnameVerifier(HostnameVerifier hostnameVerifier) {
+      if (hostnameVerifier == null) throw new NullPointerException("hostnameVerifier == null");
+      this.hostnameVerifier = hostnameVerifier;
+      return this;
     }
-    return result;
-  }
 
-  /**
-   * Java and Android programs default to using a single global SSL context,
-   * accessible to HTTP clients as {@link SSLSocketFactory#getDefault()}. If we
-   * used the shared SSL context, when OkHttp enables ALPN for its SPDY-related
-   * stuff, it would also enable ALPN for other usages, which might crash them
-   * because ALPN is enabled when it isn't expected to be.
-   *
-   * <p>This code avoids that by defaulting to an OkHttp-created SSL context.
-   * The drawback of this approach is that apps that customize the global SSL
-   * context will lose these customizations.
-   */
-  private synchronized SSLSocketFactory getDefaultSSLSocketFactory() {
-    if (defaultSslSocketFactory == null) {
-      try {
-        SSLContext sslContext = SSLContext.getInstance("TLS");
-        sslContext.init(null, null, null);
-        defaultSslSocketFactory = sslContext.getSocketFactory();
-      } catch (GeneralSecurityException e) {
-        throw new AssertionError(); // The system has no TLS. Just give up.
+    /**
+     * Sets the certificate pinner that constrains which certificates are trusted. By default HTTPS
+     * connections rely on only the {@link #sslSocketFactory SSL socket factory} to establish trust.
+     * Pinning certificates avoids the need to trust certificate authorities.
+     */
+    public Builder certificatePinner(CertificatePinner certificatePinner) {
+      if (certificatePinner == null) throw new NullPointerException("certificatePinner == null");
+      this.certificatePinner = certificatePinner;
+      return this;
+    }
+
+    /**
+     * Sets the authenticator used to respond to challenges from origin servers. Use {@link
+     * #proxyAuthenticator} to set the authenticator for proxy servers.
+     *
+     * <p>If unset, the {@linkplain Authenticator#NONE no authentication will be attempted}.
+     */
+    public Builder authenticator(Authenticator authenticator) {
+      if (authenticator == null) throw new NullPointerException("authenticator == null");
+      this.authenticator = authenticator;
+      return this;
+    }
+
+    /**
+     * Sets the authenticator used to respond to challenges from proxy servers. Use {@link
+     * #authenticator} to set the authenticator for origin servers.
+     *
+     * <p>If unset, the {@linkplain Authenticator#NONE no authentication will be attempted}.
+     */
+    public Builder proxyAuthenticator(Authenticator proxyAuthenticator) {
+      if (proxyAuthenticator == null) throw new NullPointerException("proxyAuthenticator == null");
+      this.proxyAuthenticator = proxyAuthenticator;
+      return this;
+    }
+
+    /**
+     * Sets the connection pool used to recycle HTTP and HTTPS connections.
+     *
+     * <p>If unset, a new connection pool will be used.
+     */
+    public Builder connectionPool(ConnectionPool connectionPool) {
+      if (connectionPool == null) throw new NullPointerException("connectionPool == null");
+      this.connectionPool = connectionPool;
+      return this;
+    }
+
+    /**
+     * Configure this client to follow redirects from HTTPS to HTTP and from HTTP to HTTPS.
+     *
+     * <p>If unset, protocol redirects will be followed. This is different than the built-in {@code
+     * HttpURLConnection}'s default.
+     */
+    public Builder followSslRedirects(boolean followProtocolRedirects) {
+      this.followSslRedirects = followProtocolRedirects;
+      return this;
+    }
+
+    /** Configure this client to follow redirects. If unset, redirects be followed. */
+    public Builder followRedirects(boolean followRedirects) {
+      this.followRedirects = followRedirects;
+      return this;
+    }
+
+    /**
+     * Configure this client to retry or not when a connectivity problem is encountered. By default,
+     * this client silently recovers from the following problems:
+     *
+     * <ul>
+     *   <li><strong>Unreachable IP addresses.</strong> If the URL's host has multiple IP addresses,
+     *       failure to reach any individual IP address doesn't fail the overall request. This can
+     *       increase availability of multi-homed services.
+     *   <li><strong>Stale pooled connections.</strong> The {@link ConnectionPool} reuses sockets
+     *       to decrease request latency, but these connections will occasionally time out.
+     *   <li><strong>Unreachable proxy servers.</strong> A {@link ProxySelector} can be used to
+     *       attempt multiple proxy servers in sequence, eventually falling back to a direct
+     *       connection.
+     * </ul>
+     *
+     * Set this to false to avoid retrying requests when doing so is destructive. In this case the
+     * calling application should do its own recovery of connectivity failures.
+     */
+    public Builder retryOnConnectionFailure(boolean retryOnConnectionFailure) {
+      this.retryOnConnectionFailure = retryOnConnectionFailure;
+      return this;
+    }
+
+    /**
+     * Sets the dispatcher used to set policy and execute asynchronous requests. Must not be null.
+     */
+    public Builder dispatcher(Dispatcher dispatcher) {
+      if (dispatcher == null) throw new IllegalArgumentException("dispatcher == null");
+      this.dispatcher = dispatcher;
+      return this;
+    }
+
+    /**
+     * Configure the protocols used by this client to communicate with remote servers. By default
+     * this client will prefer the most efficient transport available, falling back to more
+     * ubiquitous protocols. Applications should only call this method to avoid specific
+     * compatibility problems, such as web servers that behave incorrectly when SPDY is enabled.
+     *
+     * <p>The following protocols are currently supported:
+     *
+     * <ul>
+     *     <li><a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html">http/1.1</a>
+     *     <li><a
+     *         href="http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1">spdy/3.1</a>
+     *     <li><a href="http://tools.ietf.org/html/draft-ietf-httpbis-http2-17">h2</a>
+     * </ul>
+     *
+     * <p><strong>This is an evolving set.</strong> Future releases include support for transitional
+     * protocols. The http/1.1 transport will never be dropped.
+     *
+     * <p>If multiple protocols are specified, <a
+     * href="http://tools.ietf.org/html/draft-ietf-tls-applayerprotoneg">ALPN</a> will be used to
+     * negotiate a transport.
+     *
+     * <p>{@link Protocol#HTTP_1_0} is not supported in this set. Requests are initiated with {@code
+     * HTTP/1.1} only. If the server responds with {@code HTTP/1.0}, that will be exposed by {@link
+     * Response#protocol()}.
+     *
+     * @param protocols the protocols to use, in order of preference. The list must contain {@link
+     * Protocol#HTTP_1_1}. It must not contain null or {@link Protocol#HTTP_1_0}.
+     */
+    public Builder protocols(List<Protocol> protocols) {
+      protocols = Util.immutableList(protocols);
+      if (!protocols.contains(Protocol.HTTP_1_1)) {
+        throw new IllegalArgumentException("protocols doesn't contain http/1.1: " + protocols);
       }
+      if (protocols.contains(Protocol.HTTP_1_0)) {
+        throw new IllegalArgumentException("protocols must not contain http/1.0: " + protocols);
+      }
+      if (protocols.contains(null)) {
+        throw new IllegalArgumentException("protocols must not contain null");
+      }
+      this.protocols = Util.immutableList(protocols);
+      return this;
+    }
+
+    public Builder connectionSpecs(List<ConnectionSpec> connectionSpecs) {
+      this.connectionSpecs = Util.immutableList(connectionSpecs);
+      return this;
     }
-    return defaultSslSocketFactory;
-  }
 
-  /** Returns a shallow copy of this OkHttpClient. */
-  @Override public OkHttpClient clone() {
-    return new OkHttpClient(this);
+    /**
+     * Returns a modifiable list of interceptors that observe the full span of each call: from
+     * before the connection is established (if any) until after the response source is selected
+     * (either the origin server, cache, or both).
+     */
+    public List<Interceptor> interceptors() {
+      return interceptors;
+    }
+
+    public Builder addInterceptor(Interceptor interceptor) {
+      interceptors.add(interceptor);
+      return this;
+    }
+
+    /**
+     * Returns a modifiable list of interceptors that observe a single network request and response.
+     * These interceptors must call {@link Interceptor.Chain#proceed} exactly once: it is an error
+     * for a network interceptor to short-circuit or repeat a network request.
+     */
+    public List<Interceptor> networkInterceptors() {
+      return networkInterceptors;
+    }
+
+    public Builder addNetworkInterceptor(Interceptor interceptor) {
+      networkInterceptors.add(interceptor);
+      return this;
+    }
+
+    public OkHttpClient build() {
+      return new OkHttpClient(this);
+    }
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/Protocol.java b/okhttp/src/main/java/okhttp3/Protocol.java
index 6bb47c6f37..eec1c1219c 100644
--- a/okhttp/src/main/java/okhttp3/Protocol.java
+++ b/okhttp/src/main/java/okhttp3/Protocol.java
@@ -19,52 +19,45 @@
 
 /**
  * Protocols that OkHttp implements for <a
- * href="http://tools.ietf.org/html/draft-ietf-tls-applayerprotoneg">ALPN</a>
- * selection.
+ * href="http://tools.ietf.org/html/draft-ietf-tls-applayerprotoneg">ALPN</a> selection.
  *
- * <h3>Protocol vs Scheme</h3>
- * Despite its name, {@link java.net.URL#getProtocol()} returns the
- * {@linkplain java.net.URI#getScheme() scheme} (http, https, etc.) of the URL, not
- * the protocol (http/1.1, spdy/3.1, etc.). OkHttp uses the word <i>protocol</i>
- * to identify how HTTP messages are framed.
+ * <h3>Protocol vs Scheme</h3> Despite its name, {@link java.net.URL#getProtocol()} returns the
+ * {@linkplain java.net.URI#getScheme() scheme} (http, https, etc.) of the URL, not the protocol
+ * (http/1.1, spdy/3.1, etc.). OkHttp uses the word <i>protocol</i> to identify how HTTP messages
+ * are framed.
  */
 public enum Protocol {
   /**
-   * An obsolete plaintext framing that does not use persistent sockets by
-   * default.
+   * An obsolete plaintext framing that does not use persistent sockets by default.
    */
   HTTP_1_0("http/1.0"),
 
   /**
    * A plaintext framing that includes persistent connections.
    *
-   * <p>This version of OkHttp implements <a
-   * href="http://www.ietf.org/rfc/rfc2616.txt">RFC 2616</a>, and tracks
-   * revisions to that spec.
+   * <p>This version of OkHttp implements <a href="http://www.ietf.org/rfc/rfc2616.txt">RFC
+   * 2616</a>, and tracks revisions to that spec.
    */
   HTTP_1_1("http/1.1"),
 
   /**
-   * Chromium's binary-framed protocol that includes header compression,
-   * multiplexing multiple requests on the same socket, and server-push.
-   * HTTP/1.1 semantics are layered on SPDY/3.
+   * Chromium's binary-framed protocol that includes header compression, multiplexing multiple
+   * requests on the same socket, and server-push. HTTP/1.1 semantics are layered on SPDY/3.
    *
    * <p>This version of OkHttp implements SPDY 3 <a
-   * href="http://dev.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1">draft
-   * 3.1</a>. Future releases of OkHttp may use this identifier for a newer draft
-   * of the SPDY spec.
+   * href="http://dev.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1">draft 3.1</a>. Future
+   * releases of OkHttp may use this identifier for a newer draft of the SPDY spec.
    */
   SPDY_3("spdy/3.1"),
 
   /**
-   * The IETF's binary-framed protocol that includes header compression,
-   * multiplexing multiple requests on the same socket, and server-push.
-   * HTTP/1.1 semantics are layered on HTTP/2.
+   * The IETF's binary-framed protocol that includes header compression, multiplexing multiple
+   * requests on the same socket, and server-push. HTTP/1.1 semantics are layered on HTTP/2.
    *
-   * <p>HTTP/2 requires deployments of HTTP/2 that use TLS 1.2 support
-   * {@linkplain CipherSuite#TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256}
-   * , present in Java 8+ and Android 5+. Servers that enforce this may send an
-   * exception message including the string {@code INADEQUATE_SECURITY}.
+   * <p>HTTP/2 requires deployments of HTTP/2 that use TLS 1.2 support {@linkplain
+   * CipherSuite#TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256} , present in Java 8+ and Android 5+. Servers
+   * that enforce this may send an exception message including the string {@code
+   * INADEQUATE_SECURITY}.
    */
   HTTP_2("h2");
 
@@ -76,6 +69,7 @@
 
   /**
    * Returns the protocol identified by {@code protocol}.
+   *
    * @throws IOException if {@code protocol} is unknown.
    */
   public static Protocol get(String protocol) throws IOException {
@@ -88,8 +82,8 @@ public static Protocol get(String protocol) throws IOException {
   }
 
   /**
-   * Returns the string used to identify this protocol for ALPN, like
-   * "http/1.1", "spdy/3.1" or "h2".
+   * Returns the string used to identify this protocol for ALPN, like "http/1.1", "spdy/3.1" or
+   * "h2".
    */
   @Override public String toString() {
     return protocol;
diff --git a/okhttp/src/main/java/okhttp3/RealCall.java b/okhttp/src/main/java/okhttp3/RealCall.java
new file mode 100644
index 0000000000..16cb67cdc4
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/RealCall.java
@@ -0,0 +1,302 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.net.ProtocolException;
+import java.util.logging.Level;
+import okhttp3.internal.NamedRunnable;
+import okhttp3.internal.http.HttpEngine;
+import okhttp3.internal.http.RequestException;
+import okhttp3.internal.http.RouteException;
+import okhttp3.internal.http.StreamAllocation;
+
+import static okhttp3.internal.Internal.logger;
+import static okhttp3.internal.http.HttpEngine.MAX_FOLLOW_UPS;
+
+final class RealCall implements Call {
+  private final OkHttpClient client;
+
+  // Guarded by this.
+  private boolean executed;
+  volatile boolean canceled;
+
+  /** The application's original request unadulterated by redirects or auth headers. */
+  Request originalRequest;
+  HttpEngine engine;
+
+  protected RealCall(OkHttpClient client, Request originalRequest) {
+    this.client = client;
+    this.originalRequest = originalRequest;
+  }
+
+  @Override public Request request() {
+    return originalRequest;
+  }
+
+  @Override public Response execute() throws IOException {
+    synchronized (this) {
+      if (executed) throw new IllegalStateException("Already Executed");
+      executed = true;
+    }
+    try {
+      client.dispatcher().executed(this);
+      Response result = getResponseWithInterceptorChain(false);
+      if (result == null) throw new IOException("Canceled");
+      return result;
+    } finally {
+      client.dispatcher().finished(this);
+    }
+  }
+
+  Object tag() {
+    return originalRequest.tag();
+  }
+
+  @Override public void enqueue(Callback responseCallback) {
+    enqueue(responseCallback, false);
+  }
+
+  void enqueue(Callback responseCallback, boolean forWebSocket) {
+    synchronized (this) {
+      if (executed) throw new IllegalStateException("Already Executed");
+      executed = true;
+    }
+    client.dispatcher().enqueue(new AsyncCall(responseCallback, forWebSocket));
+  }
+
+  @Override public void cancel() {
+    canceled = true;
+    if (engine != null) engine.cancel();
+  }
+
+  @Override public synchronized boolean isExecuted() {
+    return executed;
+  }
+
+  @Override public boolean isCanceled() {
+    return canceled;
+  }
+
+  final class AsyncCall extends NamedRunnable {
+    private final Callback responseCallback;
+    private final boolean forWebSocket;
+
+    private AsyncCall(Callback responseCallback, boolean forWebSocket) {
+      super("OkHttp %s", originalRequest.url().toString());
+      this.responseCallback = responseCallback;
+      this.forWebSocket = forWebSocket;
+    }
+
+    String host() {
+      return originalRequest.url().host();
+    }
+
+    Request request() {
+      return originalRequest;
+    }
+
+    Object tag() {
+      return originalRequest.tag();
+    }
+
+    void cancel() {
+      RealCall.this.cancel();
+    }
+
+    RealCall get() {
+      return RealCall.this;
+    }
+
+    @Override protected void execute() {
+      boolean signalledCallback = false;
+      try {
+        Response response = getResponseWithInterceptorChain(forWebSocket);
+        if (canceled) {
+          signalledCallback = true;
+          responseCallback.onFailure(RealCall.this, new IOException("Canceled"));
+        } else {
+          signalledCallback = true;
+          responseCallback.onResponse(RealCall.this, response);
+        }
+      } catch (IOException e) {
+        if (signalledCallback) {
+          // Do not signal the callback twice!
+          logger.log(Level.INFO, "Callback failure for " + toLoggableString(), e);
+        } else {
+          responseCallback.onFailure(RealCall.this, e);
+        }
+      } finally {
+        client.dispatcher().finished(this);
+      }
+    }
+  }
+
+  /**
+   * Returns a string that describes this call. Doesn't include a full URL as that might contain
+   * sensitive information.
+   */
+  private String toLoggableString() {
+    String string = canceled ? "canceled call" : "call";
+    HttpUrl redactedUrl = originalRequest.url().resolve("/...");
+    return string + " to " + redactedUrl;
+  }
+
+  private Response getResponseWithInterceptorChain(boolean forWebSocket) throws IOException {
+    Interceptor.Chain chain = new ApplicationInterceptorChain(0, originalRequest, forWebSocket);
+    return chain.proceed(originalRequest);
+  }
+
+  class ApplicationInterceptorChain implements Interceptor.Chain {
+    private final int index;
+    private final Request request;
+    private final boolean forWebSocket;
+
+    ApplicationInterceptorChain(int index, Request request, boolean forWebSocket) {
+      this.index = index;
+      this.request = request;
+      this.forWebSocket = forWebSocket;
+    }
+
+    @Override public Connection connection() {
+      return null;
+    }
+
+    @Override public Request request() {
+      return request;
+    }
+
+    @Override public Response proceed(Request request) throws IOException {
+      // If there's another interceptor in the chain, call that.
+      if (index < client.interceptors().size()) {
+        Interceptor.Chain chain = new ApplicationInterceptorChain(index + 1, request, forWebSocket);
+        Interceptor interceptor = client.interceptors().get(index);
+        Response interceptedResponse = interceptor.intercept(chain);
+
+        if (interceptedResponse == null) {
+          throw new NullPointerException("application interceptor " + interceptor
+              + " returned null");
+        }
+
+        return interceptedResponse;
+      }
+
+      // No more interceptors. Do HTTP.
+      return getResponse(request, forWebSocket);
+    }
+  }
+
+  /**
+   * Performs the request and returns the response. May return null if this call was canceled.
+   */
+  Response getResponse(Request request, boolean forWebSocket) throws IOException {
+    // Copy body metadata to the appropriate request headers.
+    RequestBody body = request.body();
+    if (body != null) {
+      Request.Builder requestBuilder = request.newBuilder();
+
+      MediaType contentType = body.contentType();
+      if (contentType != null) {
+        requestBuilder.header("Content-Type", contentType.toString());
+      }
+
+      long contentLength = body.contentLength();
+      if (contentLength != -1) {
+        requestBuilder.header("Content-Length", Long.toString(contentLength));
+        requestBuilder.removeHeader("Transfer-Encoding");
+      } else {
+        requestBuilder.header("Transfer-Encoding", "chunked");
+        requestBuilder.removeHeader("Content-Length");
+      }
+
+      request = requestBuilder.build();
+    }
+
+    // Create the initial HTTP engine. Retries and redirects need new engine for each attempt.
+    engine = new HttpEngine(client, request, false, false, forWebSocket, null, null, null);
+
+    int followUpCount = 0;
+    while (true) {
+      if (canceled) {
+        engine.releaseStreamAllocation();
+        throw new IOException("Canceled");
+      }
+
+      boolean releaseConnection = true;
+      try {
+        engine.sendRequest();
+        engine.readResponse();
+        releaseConnection = false;
+      } catch (RequestException e) {
+        // The attempt to interpret the request failed. Give up.
+        throw e.getCause();
+      } catch (RouteException e) {
+        // The attempt to connect via a route failed. The request will not have been sent.
+        HttpEngine retryEngine = engine.recover(e.getLastConnectException(), null);
+        if (retryEngine != null) {
+          releaseConnection = false;
+          engine = retryEngine;
+          continue;
+        }
+        // Give up; recovery is not possible.
+        throw e.getLastConnectException();
+      } catch (IOException e) {
+        // An attempt to communicate with a server failed. The request may have been sent.
+        HttpEngine retryEngine = engine.recover(e, null);
+        if (retryEngine != null) {
+          releaseConnection = false;
+          engine = retryEngine;
+          continue;
+        }
+
+        // Give up; recovery is not possible.
+        throw e;
+      } finally {
+        // We're throwing an unchecked exception. Release any resources.
+        if (releaseConnection) {
+          StreamAllocation streamAllocation = engine.close();
+          streamAllocation.release();
+        }
+      }
+
+      Response response = engine.getResponse();
+      Request followUp = engine.followUpRequest();
+
+      if (followUp == null) {
+        if (!forWebSocket) {
+          engine.releaseStreamAllocation();
+        }
+        return response;
+      }
+
+      StreamAllocation streamAllocation = engine.close();
+
+      if (++followUpCount > MAX_FOLLOW_UPS) {
+        streamAllocation.release();
+        throw new ProtocolException("Too many follow-up requests: " + followUpCount);
+      }
+
+      if (!engine.sameConnection(followUp.url())) {
+        streamAllocation.release();
+        streamAllocation = null;
+      }
+
+      request = followUp;
+      engine = new HttpEngine(client, request, false, false, forWebSocket, streamAllocation, null,
+          response);
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/Request.java b/okhttp/src/main/java/okhttp3/Request.java
index 4ff8702300..2daa0ab9b3 100644
--- a/okhttp/src/main/java/okhttp3/Request.java
+++ b/okhttp/src/main/java/okhttp3/Request.java
@@ -15,14 +15,14 @@
  */
 package okhttp3;
 
-import okhttp3.internal.http.HttpMethod;
 import java.net.URI;
 import java.net.URL;
 import java.util.List;
+import okhttp3.internal.http.HttpMethod;
 
 /**
- * An HTTP request. Instances of this class are immutable if their {@link #body}
- * is null or itself immutable.
+ * An HTTP request. Instances of this class are immutable if their {@link #body} is null or itself
+ * immutable.
  */
 public final class Request {
   private final HttpUrl url;
@@ -75,8 +75,8 @@ public Builder newBuilder() {
   }
 
   /**
-   * Returns the cache control directives for this response. This is never null,
-   * even if this response contains no {@code Cache-Control} header.
+   * Returns the cache control directives for this response. This is never null, even if this
+   * response contains no {@code Cache-Control} header.
    */
   public CacheControl cacheControl() {
     CacheControl result = cacheControl;
@@ -127,7 +127,7 @@ public Builder url(HttpUrl url) {
      * Sets the URL target of this request.
      *
      * @throws IllegalArgumentException if {@code url} is not a valid HTTP or HTTPS URL. Avoid this
-     *     exception by calling {@link HttpUrl#parse}; it returns null for invalid URLs.
+     * exception by calling {@link HttpUrl#parse}; it returns null for invalid URLs.
      */
     public Builder url(String url) {
       if (url == null) throw new IllegalArgumentException("url == null");
@@ -148,7 +148,7 @@ public Builder url(String url) {
      * Sets the URL target of this request.
      *
      * @throws IllegalArgumentException if the scheme of {@code url} is not {@code http} or {@code
-     *     https}.
+     * https}.
      */
     public Builder url(URL url) {
       if (url == null) throw new IllegalArgumentException("url == null");
@@ -158,8 +158,8 @@ public Builder url(URL url) {
     }
 
     /**
-     * Sets the header named {@code name} to {@code value}. If this request
-     * already has any headers with that name, they are all replaced.
+     * Sets the header named {@code name} to {@code value}. If this request already has any headers
+     * with that name, they are all replaced.
      */
     public Builder header(String name, String value) {
       headers.set(name, value);
@@ -167,8 +167,8 @@ public Builder header(String name, String value) {
     }
 
     /**
-     * Adds a header with {@code name} and {@code value}. Prefer this method for
-     * multiply-valued headers like "Cookie".
+     * Adds a header with {@code name} and {@code value}. Prefer this method for multiply-valued
+     * headers like "Cookie".
      *
      * <p>Note that for some headers including {@code Content-Length} and {@code Content-Encoding},
      * OkHttp may replace {@code value} with a header derived from the request body.
@@ -190,9 +190,9 @@ public Builder headers(Headers headers) {
     }
 
     /**
-     * Sets this request's {@code Cache-Control} header, replacing any cache
-     * control headers already present. If {@code cacheControl} doesn't define
-     * any directives, this clears this request's cache-control headers.
+     * Sets this request's {@code Cache-Control} header, replacing any cache control headers already
+     * present. If {@code cacheControl} doesn't define any directives, this clears this request's
+     * cache-control headers.
      */
     public Builder cacheControl(CacheControl cacheControl) {
       String value = cacheControl.toString();
@@ -244,9 +244,8 @@ public Builder method(String method, RequestBody body) {
     }
 
     /**
-     * Attaches {@code tag} to the request. It can be used later to cancel the
-     * request. If the tag is unspecified or null, the request is canceled by
-     * using the request itself as the tag.
+     * Attaches {@code tag} to the request. It can be used later to cancel the request. If the tag
+     * is unspecified or null, the request is canceled by using the request itself as the tag.
      */
     public Builder tag(Object tag) {
       this.tag = tag;
diff --git a/okhttp/src/main/java/okhttp3/RequestBody.java b/okhttp/src/main/java/okhttp3/RequestBody.java
index 572a45fc89..136cfdc4e3 100644
--- a/okhttp/src/main/java/okhttp3/RequestBody.java
+++ b/okhttp/src/main/java/okhttp3/RequestBody.java
@@ -15,10 +15,10 @@
  */
 package okhttp3;
 
-import okhttp3.internal.Util;
 import java.io.File;
 import java.io.IOException;
 import java.nio.charset.Charset;
+import okhttp3.internal.Util;
 import okio.BufferedSink;
 import okio.ByteString;
 import okio.Okio;
@@ -29,8 +29,8 @@
   public abstract MediaType contentType();
 
   /**
-   * Returns the number of bytes that will be written to {@code out} in a call
-   * to {@link #writeTo}, or -1 if that count is unknown.
+   * Returns the number of bytes that will be written to {@code out} in a call to {@link #writeTo},
+   * or -1 if that count is unknown.
    */
   public long contentLength() throws IOException {
     return -1;
@@ -40,8 +40,8 @@ public long contentLength() throws IOException {
   public abstract void writeTo(BufferedSink sink) throws IOException;
 
   /**
-   * Returns a new request body that transmits {@code content}. If {@code
-   * contentType} is non-null and lacks a charset, this will use UTF-8.
+   * Returns a new request body that transmits {@code content}. If {@code contentType} is non-null
+   * and lacks a charset, this will use UTF-8.
    */
   public static RequestBody create(MediaType contentType, String content) {
     Charset charset = Util.UTF_8;
diff --git a/okhttp/src/main/java/okhttp3/Response.java b/okhttp/src/main/java/okhttp3/Response.java
index ccdca395fe..7a2d717e22 100644
--- a/okhttp/src/main/java/okhttp3/Response.java
+++ b/okhttp/src/main/java/okhttp3/Response.java
@@ -15,23 +15,25 @@
  */
 package okhttp3;
 
-import okhttp3.internal.http.OkHeaders;
+import java.io.IOException;
 import java.util.Collections;
 import java.util.List;
+import okhttp3.internal.http.OkHeaders;
+import okio.Buffer;
+import okio.BufferedSource;
 
-import static okhttp3.internal.http.StatusLine.HTTP_PERM_REDIRECT;
-import static okhttp3.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
 import static java.net.HttpURLConnection.HTTP_MOVED_PERM;
 import static java.net.HttpURLConnection.HTTP_MOVED_TEMP;
 import static java.net.HttpURLConnection.HTTP_MULT_CHOICE;
 import static java.net.HttpURLConnection.HTTP_PROXY_AUTH;
 import static java.net.HttpURLConnection.HTTP_SEE_OTHER;
 import static java.net.HttpURLConnection.HTTP_UNAUTHORIZED;
+import static okhttp3.internal.http.StatusLine.HTTP_PERM_REDIRECT;
+import static okhttp3.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
 
 /**
- * An HTTP response. Instances of this class are not immutable: the response
- * body is a one-shot value that may be consumed only once. All other properties
- * are immutable.
+ * An HTTP response. Instances of this class are not immutable: the response body is a one-shot
+ * value that may be consumed only once. All other properties are immutable.
  */
 public final class Response {
   private final Request request;
@@ -63,6 +65,7 @@ private Response(Builder builder) {
   /**
    * The wire-level request that initiated this HTTP response. This is not
    * necessarily the same request issued by the application:
+   *
    * <ul>
    *     <li>It may be transformed by the HTTP client. For example, the client
    *         may copy headers like {@code Content-Length} from the request body.
@@ -76,8 +79,7 @@ public Request request() {
   }
 
   /**
-   * Returns the HTTP protocol, such as {@link Protocol#HTTP_1_1} or {@link
-   * Protocol#HTTP_1_0}.
+   * Returns the HTTP protocol, such as {@link Protocol#HTTP_1_1} or {@link Protocol#HTTP_1_0}.
    */
   public Protocol protocol() {
     return protocol;
@@ -89,8 +91,8 @@ public int code() {
   }
 
   /**
-   * Returns true if the code is in [200..300), which means the request was
-   * successfully received, understood, and accepted.
+   * Returns true if the code is in [200..300), which means the request was successfully received,
+   * understood, and accepted.
    */
   public boolean isSuccessful() {
     return code >= 200 && code < 300;
@@ -102,8 +104,8 @@ public String message() {
   }
 
   /**
-   * Returns the TLS handshake of the connection that carried this response, or
-   * null if the response was received without TLS.
+   * Returns the TLS handshake of the connection that carried this response, or null if the response
+   * was received without TLS.
    */
   public Handshake handshake() {
     return handshake;
@@ -126,6 +128,35 @@ public Headers headers() {
     return headers;
   }
 
+  /**
+   * Peeks up to {@code byteCount} bytes from the response body and returns them as a new response
+   * body. If fewer than {@code byteCount} bytes are in the response body, the full response body is
+   * returned. If more than {@code byteCount} bytes are in the response body, the returned value
+   * will be truncated to {@code byteCount} bytes.
+   *
+   * <p>It is an error to call this method after the body has been consumed.
+   *
+   * <p><strong>Warning:</strong> this method loads the requested bytes into memory. Most
+   * applications should set a modest limit on {@code byteCount}, such as 1 MiB.
+   */
+  public ResponseBody peekBody(long byteCount) throws IOException {
+    BufferedSource source = body.source();
+    source.request(byteCount);
+    Buffer copy = source.buffer().clone();
+
+    // There may be more than byteCount bytes in source.buffer(). If there is, return a prefix.
+    Buffer result;
+    if (copy.size() > byteCount) {
+      result = new Buffer();
+      result.write(copy, byteCount);
+      copy.clear();
+    } else {
+      result = copy;
+    }
+
+    return ResponseBody.create(body.contentType(), result.size(), result);
+  }
+
   public ResponseBody body() {
     return body;
   }
@@ -150,40 +181,38 @@ public boolean isRedirect() {
   }
 
   /**
-   * Returns the raw response received from the network. Will be null if this
-   * response didn't use the network, such as when the response is fully cached.
-   * The body of the returned response should not be read.
+   * Returns the raw response received from the network. Will be null if this response didn't use
+   * the network, such as when the response is fully cached. The body of the returned response
+   * should not be read.
    */
   public Response networkResponse() {
     return networkResponse;
   }
 
   /**
-   * Returns the raw response received from the cache. Will be null if this
-   * response didn't use the cache. For conditional get requests the cache
-   * response and network response may both be non-null. The body of the
-   * returned response should not be read.
+   * Returns the raw response received from the cache. Will be null if this response didn't use the
+   * cache. For conditional get requests the cache response and network response may both be
+   * non-null. The body of the returned response should not be read.
    */
   public Response cacheResponse() {
     return cacheResponse;
   }
 
   /**
-   * Returns the response for the HTTP redirect or authorization challenge that
-   * triggered this response, or null if this response wasn't triggered by an
-   * automatic retry. The body of the returned response should not be read
-   * because it has already been consumed by the redirecting client.
+   * Returns the response for the HTTP redirect or authorization challenge that triggered this
+   * response, or null if this response wasn't triggered by an automatic retry. The body of the
+   * returned response should not be read because it has already been consumed by the redirecting
+   * client.
    */
   public Response priorResponse() {
     return priorResponse;
   }
 
   /**
-   * Returns the authorization challenges appropriate for this response's code.
-   * If the response code is 401 unauthorized, this returns the
-   * "WWW-Authenticate" challenges. If the response code is 407 proxy
-   * unauthorized, this returns the "Proxy-Authenticate" challenges. Otherwise
-   * this returns an empty list of challenges.
+   * Returns the authorization challenges appropriate for this response's code. If the response code
+   * is 401 unauthorized, this returns the "WWW-Authenticate" challenges. If the response code is
+   * 407 proxy unauthorized, this returns the "Proxy-Authenticate" challenges. Otherwise this
+   * returns an empty list of challenges.
    */
   public List<Challenge> challenges() {
     String responseField;
@@ -198,8 +227,8 @@ public Response priorResponse() {
   }
 
   /**
-   * Returns the cache control directives for this response. This is never null,
-   * even if this response contains no {@code Cache-Control} header.
+   * Returns the cache control directives for this response. This is never null, even if this
+   * response contains no {@code Cache-Control} header.
    */
   public CacheControl cacheControl() {
     CacheControl result = cacheControl;
@@ -273,8 +302,8 @@ public Builder handshake(Handshake handshake) {
     }
 
     /**
-     * Sets the header named {@code name} to {@code value}. If this request
-     * already has any headers with that name, they are all replaced.
+     * Sets the header named {@code name} to {@code value}. If this request already has any headers
+     * with that name, they are all replaced.
      */
     public Builder header(String name, String value) {
       headers.set(name, value);
@@ -282,8 +311,8 @@ public Builder header(String name, String value) {
     }
 
     /**
-     * Adds a header with {@code name} and {@code value}. Prefer this method for
-     * multiply-valued headers like "Set-Cookie".
+     * Adds a header with {@code name} and {@code value}. Prefer this method for multiply-valued
+     * headers like "Set-Cookie".
      */
     public Builder addHeader(String name, String value) {
       headers.add(name, value);
diff --git a/okhttp/src/main/java/okhttp3/ResponseBody.java b/okhttp/src/main/java/okhttp3/ResponseBody.java
index 22fb4d6293..98223bbad1 100644
--- a/okhttp/src/main/java/okhttp3/ResponseBody.java
+++ b/okhttp/src/main/java/okhttp3/ResponseBody.java
@@ -15,18 +15,44 @@
  */
 package okhttp3;
 
-import okhttp3.internal.Util;
 import java.io.Closeable;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.io.Reader;
 import java.nio.charset.Charset;
+import okhttp3.internal.Util;
 import okio.Buffer;
 import okio.BufferedSource;
 
 import static okhttp3.internal.Util.UTF_8;
 
+/**
+ * A one-shot stream from the origin server to the client application with the raw bytes of the
+ * response body. Each response body is supported by an active connection to the webserver. This
+ * imposes both obligations and limits on the client application.
+ *
+ * <h3>The response body must be closed.</h3>
+ *
+ * <p>Each response body is backed by a limited resource like a socket (live network responses) or
+ * an open file (for cached responses). Failing to close the response body will leak these resources
+ * and may ultimately cause the application to slow down or crash. Close the response body by
+ * calling either {@link ResponseBody#close close()}, {@link InputStream#close()
+ * byteStream().close()}, or {@link Reader#close() reader().close()}. The {@link #bytes()} and
+ * {@link #string()} methods both close the response body automatically.
+ *
+ * <h3>The response body can be consumed only once.</h3>
+ *
+ * <p>This class may be used to stream very large responses. For example, it is possible to use this
+ * class to read a response that is larger than the entire memory allocated to the current process.
+ * It can even stream a response larger than the total storage on the current device, which is a
+ * common requirement for video streaming applications.
+ *
+ * <p>Because this class does not buffer the full response in memory, the application may not
+ * re-read the bytes of the response. Use this one shot to read the entire response into memory with
+ * {@link #bytes()} or {@link #string()}. Or stream the response with either {@link #source()},
+ * {@link #byteStream()}, or {@link #charStream()}.
+ */
 public abstract class ResponseBody implements Closeable {
   /** Multiple calls to {@link #charStream()} must return the same instance. */
   private Reader reader;
@@ -34,8 +60,8 @@
   public abstract MediaType contentType();
 
   /**
-   * Returns the number of bytes in that will returned by {@link #bytes}, or
-   * {@link #byteStream}, or -1 if unknown.
+   * Returns the number of bytes in that will returned by {@link #bytes}, or {@link #byteStream}, or
+   * -1 if unknown.
    */
   public abstract long contentLength();
 
@@ -65,9 +91,9 @@ public final InputStream byteStream() {
   }
 
   /**
-   * Returns the response as a character stream decoded with the charset
-   * of the Content-Type header. If that header is either absent or lacks a
-   * charset, this will attempt to decode the response body as UTF-8.
+   * Returns the response as a character stream decoded with the charset of the Content-Type header.
+   * If that header is either absent or lacks a charset, this will attempt to decode the response
+   * body as UTF-8.
    */
   public final Reader charStream() {
     Reader r = reader;
@@ -75,9 +101,9 @@ public final Reader charStream() {
   }
 
   /**
-   * Returns the response as a string decoded with the charset of the
-   * Content-Type header. If that header is either absent or lacks a charset,
-   * this will attempt to decode the response body as UTF-8.
+   * Returns the response as a string decoded with the charset of the Content-Type header. If that
+   * header is either absent or lacks a charset, this will attempt to decode the response body as
+   * UTF-8.
    */
   public final String string() throws IOException {
     return new String(bytes(), charset().name());
@@ -93,8 +119,8 @@ private Charset charset() {
   }
 
   /**
-   * Returns a new response body that transmits {@code content}. If {@code
-   * contentType} is non-null and lacks a charset, this will use UTF-8.
+   * Returns a new response body that transmits {@code content}. If {@code contentType} is non-null
+   * and lacks a charset, this will use UTF-8.
    */
   public static ResponseBody create(MediaType contentType, String content) {
     Charset charset = UTF_8;
diff --git a/okhttp/src/main/java/okhttp3/Route.java b/okhttp/src/main/java/okhttp3/Route.java
index 74e38f1aa7..8aaa0f5b85 100644
--- a/okhttp/src/main/java/okhttp3/Route.java
+++ b/okhttp/src/main/java/okhttp3/Route.java
@@ -19,17 +19,19 @@
 import java.net.Proxy;
 
 /**
- * The concrete route used by a connection to reach an abstract origin server.
- * When creating a connection the client has many options:
+ * The concrete route used by a connection to reach an abstract origin server. When creating a
+ * connection the client has many options:
+ *
  * <ul>
- *   <li><strong>HTTP proxy:</strong> a proxy server may be explicitly
- *       configured for the client. Otherwise the {@linkplain java.net.ProxySelector
- *       proxy selector} is used. It may return multiple proxies to attempt.
- *   <li><strong>IP address:</strong> whether connecting directly to an origin
- *       server or a proxy, opening a socket requires an IP address. The DNS
- *       server may return multiple IP addresses to attempt.
+ *     <li><strong>HTTP proxy:</strong> a proxy server may be explicitly configured for the client.
+ *         Otherwise the {@linkplain java.net.ProxySelector proxy selector} is used. It may return
+ *         multiple proxies to attempt.
+ *     <li><strong>IP address:</strong> whether connecting directly to an origin server or a proxy,
+ *         opening a socket requires an IP address. The DNS server may return multiple IP addresses
+ *         to attempt.
  * </ul>
- * Each route is a specific selection of these options.
+ *
+ * <p>Each route is a specific selection of these options.
  */
 public final class Route {
   final Address address;
@@ -58,9 +60,8 @@ public Address address() {
   /**
    * Returns the {@link Proxy} of this route.
    *
-   * <strong>Warning:</strong> This may disagree with {@link Address#proxy}
-   * when it is null. When the address's proxy is null, the proxy selector is
-   * used.
+   * <strong>Warning:</strong> This may disagree with {@link Address#proxy} when it is null. When
+   * the address's proxy is null, the proxy selector is used.
    */
   public Proxy proxy() {
     return proxy;
diff --git a/okhttp/src/main/java/okhttp3/TlsVersion.java b/okhttp/src/main/java/okhttp3/TlsVersion.java
index 49b815c254..668cd9732b 100644
--- a/okhttp/src/main/java/okhttp3/TlsVersion.java
+++ b/okhttp/src/main/java/okhttp3/TlsVersion.java
@@ -15,11 +15,9 @@
  */
 package okhttp3;
 
-import javax.net.ssl.SSLSocket;
-
 /**
- * Versions of TLS that can be offered when negotiating a secure socket. See
- * {@link SSLSocket#setEnabledProtocols}.
+ * Versions of TLS that can be offered when negotiating a secure socket. See {@link
+ * javax.net.ssl.SSLSocket#setEnabledProtocols}.
  */
 public enum TlsVersion {
   TLS_1_2("TLSv1.2"), // 2008.
@@ -36,10 +34,14 @@
 
   public static TlsVersion forJavaName(String javaName) {
     switch (javaName) {
-      case "TLSv1.2": return TLS_1_2;
-      case "TLSv1.1": return TLS_1_1;
-      case "TLSv1": return TLS_1_0;
-      case "SSLv3": return SSL_3_0;
+      case "TLSv1.2":
+        return TLS_1_2;
+      case "TLSv1.1":
+        return TLS_1_1;
+      case "TLSv1":
+        return TLS_1_0;
+      case "SSLv3":
+        return SSL_3_0;
     }
     throw new IllegalArgumentException("Unexpected TLS version: " + javaName);
   }
diff --git a/okhttp/src/main/java/okhttp3/internal/ConnectionSpecSelector.java b/okhttp/src/main/java/okhttp3/internal/ConnectionSpecSelector.java
index 844010e15d..3123eece26 100644
--- a/okhttp/src/main/java/okhttp3/internal/ConnectionSpecSelector.java
+++ b/okhttp/src/main/java/okhttp3/internal/ConnectionSpecSelector.java
@@ -16,7 +16,6 @@
 
 package okhttp3.internal;
 
-import okhttp3.ConnectionSpec;
 import java.io.IOException;
 import java.io.InterruptedIOException;
 import java.net.ProtocolException;
@@ -28,11 +27,12 @@
 import javax.net.ssl.SSLPeerUnverifiedException;
 import javax.net.ssl.SSLProtocolException;
 import javax.net.ssl.SSLSocket;
+import okhttp3.ConnectionSpec;
 
 /**
- * Handles the connection spec fallback strategy: When a secure socket connection fails
- * due to a handshake / protocol problem the connection may be retried with different protocols.
- * Instances are stateful and should be created and used for a single connection attempt.
+ * Handles the connection spec fallback strategy: When a secure socket connection fails due to a
+ * handshake / protocol problem the connection may be retried with different protocols. Instances
+ * are stateful and should be created and used for a single connection attempt.
  */
 public final class ConnectionSpecSelector {
 
@@ -81,11 +81,11 @@ public ConnectionSpec configureSecureSocket(SSLSocket sslSocket) throws IOExcept
   }
 
   /**
-   * Reports a failure to complete a connection. Determines the next {@link ConnectionSpec} to
-   * try, if any.
+   * Reports a failure to complete a connection. Determines the next {@link ConnectionSpec} to try,
+   * if any.
    *
-   * @return {@code true} if the connection should be retried using
-   *     {@link #configureSecureSocket(SSLSocket)} or {@code false} if not
+   * @return {@code true} if the connection should be retried using {@link
+   * #configureSecureSocket(SSLSocket)} or {@code false} if not
    */
   public boolean connectionFailed(IOException e) {
     // Any future attempt to connect using this strategy will be a fallback attempt.
@@ -121,7 +121,6 @@ public boolean connectionFailed(IOException e) {
       return false;
     }
 
-
     // On Android, SSLProtocolExceptions can be caused by TLS_FALLBACK_SCSV failures, which means we
     // retry those when we probably should not.
     return (e instanceof SSLHandshakeException || e instanceof SSLProtocolException);
diff --git a/okhttp/src/main/java/okhttp3/internal/DiskLruCache.java b/okhttp/src/main/java/okhttp3/internal/DiskLruCache.java
index 2b1f6aee58..34f993a9a6 100644
--- a/okhttp/src/main/java/okhttp3/internal/DiskLruCache.java
+++ b/okhttp/src/main/java/okhttp3/internal/DiskLruCache.java
@@ -16,11 +16,11 @@
 
 package okhttp3.internal;
 
-import okhttp3.internal.io.FileSystem;
 import java.io.Closeable;
 import java.io.EOFException;
 import java.io.File;
 import java.io.FileNotFoundException;
+import java.io.Flushable;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -33,6 +33,7 @@
 import java.util.concurrent.TimeUnit;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
+import okhttp3.internal.io.FileSystem;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -42,50 +43,46 @@
 import okio.Timeout;
 
 /**
- * A cache that uses a bounded amount of space on a filesystem. Each cache
- * entry has a string key and a fixed number of values. Each key must match
- * the regex <strong>[a-z0-9_-]{1,64}</strong>. Values are byte sequences,
- * accessible as streams or files. Each value must be between {@code 0} and
- * {@code Integer.MAX_VALUE} bytes in length.
+ * A cache that uses a bounded amount of space on a filesystem. Each cache entry has a string key
+ * and a fixed number of values. Each key must match the regex <strong>[a-z0-9_-]{1,64}</strong>.
+ * Values are byte sequences, accessible as streams or files. Each value must be between {@code 0}
+ * and {@code Integer.MAX_VALUE} bytes in length.
  *
- * <p>The cache stores its data in a directory on the filesystem. This
- * directory must be exclusive to the cache; the cache may delete or overwrite
- * files from its directory. It is an error for multiple processes to use the
- * same cache directory at the same time.
+ * <p>The cache stores its data in a directory on the filesystem. This directory must be exclusive
+ * to the cache; the cache may delete or overwrite files from its directory. It is an error for
+ * multiple processes to use the same cache directory at the same time.
  *
- * <p>This cache limits the number of bytes that it will store on the
- * filesystem. When the number of stored bytes exceeds the limit, the cache will
- * remove entries in the background until the limit is satisfied. The limit is
- * not strict: the cache may temporarily exceed it while waiting for files to be
- * deleted. The limit does not include filesystem overhead or the cache
- * journal so space-sensitive applications should set a conservative limit.
+ * <p>This cache limits the number of bytes that it will store on the filesystem. When the number of
+ * stored bytes exceeds the limit, the cache will remove entries in the background until the limit
+ * is satisfied. The limit is not strict: the cache may temporarily exceed it while waiting for
+ * files to be deleted. The limit does not include filesystem overhead or the cache journal so
+ * space-sensitive applications should set a conservative limit.
+ *
+ * <p>Clients call {@link #edit} to create or update the values of an entry. An entry may have only
+ * one editor at one time; if a value is not available to be edited then {@link #edit} will return
+ * null.
  *
- * <p>Clients call {@link #edit} to create or update the values of an entry. An
- * entry may have only one editor at one time; if a value is not available to be
- * edited then {@link #edit} will return null.
  * <ul>
- *     <li>When an entry is being <strong>created</strong> it is necessary to
- *         supply a full set of values; the empty value should be used as a
- *         placeholder if necessary.
- *     <li>When an entry is being <strong>edited</strong>, it is not necessary
- *         to supply data for every value; values default to their previous
- *         value.
+ *     <li>When an entry is being <strong>created</strong> it is necessary to supply a full set of
+ *         values; the empty value should be used as a placeholder if necessary.
+ *     <li>When an entry is being <strong>edited</strong>, it is not necessary to supply data for
+ *         every value; values default to their previous value.
  * </ul>
- * Every {@link #edit} call must be matched by a call to {@link Editor#commit}
- * or {@link Editor#abort}. Committing is atomic: a read observes the full set
- * of values as they were before or after the commit, but never a mix of values.
  *
- * <p>Clients call {@link #get} to read a snapshot of an entry. The read will
- * observe the value at the time that {@link #get} was called. Updates and
- * removals after the call do not impact ongoing reads.
+ * <p>Every {@link #edit} call must be matched by a call to {@link Editor#commit} or {@link
+ * Editor#abort}. Committing is atomic: a read observes the full set of values as they were before
+ * or after the commit, but never a mix of values.
+ *
+ * <p>Clients call {@link #get} to read a snapshot of an entry. The read will observe the value at
+ * the time that {@link #get} was called. Updates and removals after the call do not impact ongoing
+ * reads.
  *
- * <p>This class is tolerant of some I/O errors. If files are missing from the
- * filesystem, the corresponding entries will be dropped from the cache. If
- * an error occurs while writing a cache value, the edit will fail silently.
- * Callers should handle other problems by catching {@code IOException} and
- * responding appropriately.
+ * <p>This class is tolerant of some I/O errors. If files are missing from the filesystem, the
+ * corresponding entries will be dropped from the cache. If an error occurs while writing a cache
+ * value, the edit will fail silently. Callers should handle other problems by catching {@code
+ * IOException} and responding appropriately.
  */
-public final class DiskLruCache implements Closeable {
+public final class DiskLruCache implements Closeable, Flushable {
   static final String JOURNAL_FILE = "journal";
   static final String JOURNAL_FILE_TEMP = "journal.tmp";
   static final String JOURNAL_FILE_BACKUP = "journal.bkp";
@@ -157,9 +154,9 @@
   private boolean closed;
 
   /**
-   * To differentiate between old and current snapshots, each entry is given
-   * a sequence number each time an edit is committed. A snapshot is stale if
-   * its sequence number is not equal to its entry's sequence number.
+   * To differentiate between old and current snapshots, each entry is given a sequence number each
+   * time an edit is committed. A snapshot is stale if its sequence number is not equal to its
+   * entry's sequence number.
    */
   private long nextSequenceNumber = 0;
 
@@ -348,8 +345,8 @@ private void readJournalLine(String line) throws IOException {
   }
 
   /**
-   * Computes the initial size and collects garbage as a part of opening the
-   * cache. Dirty entries are assumed to be inconsistent and will be deleted.
+   * Computes the initial size and collects garbage as a part of opening the cache. Dirty entries
+   * are assumed to be inconsistent and will be deleted.
    */
   private void processJournal() throws IOException {
     fileSystem.delete(journalFileTmp);
@@ -371,8 +368,8 @@ private void processJournal() throws IOException {
   }
 
   /**
-   * Creates a new journal that omits redundant information. This replaces the
-   * current journal if it exists.
+   * Creates a new journal that omits redundant information. This replaces the current journal if it
+   * exists.
    */
   private synchronized void rebuildJournal() throws IOException {
     if (journalWriter != null) {
@@ -414,9 +411,8 @@ private synchronized void rebuildJournal() throws IOException {
   }
 
   /**
-   * Returns a snapshot of the entry named {@code key}, or null if it doesn't
-   * exist is not currently readable. If a value is returned, it is moved to
-   * the head of the LRU queue.
+   * Returns a snapshot of the entry named {@code key}, or null if it doesn't exist is not currently
+   * readable. If a value is returned, it is moved to the head of the LRU queue.
    */
   public synchronized Snapshot get(String key) throws IOException {
     initialize();
@@ -439,8 +435,7 @@ public synchronized Snapshot get(String key) throws IOException {
   }
 
   /**
-   * Returns an editor for the entry named {@code key}, or null if another
-   * edit is in progress.
+   * Returns an editor for the entry named {@code key}, or null if another edit is in progress.
    */
   public Editor edit(String key) throws IOException {
     return edit(key, ANY_SEQUENCE_NUMBER);
@@ -483,16 +478,15 @@ public File getDirectory() {
   }
 
   /**
-   * Returns the maximum number of bytes that this cache should use to store
-   * its data.
+   * Returns the maximum number of bytes that this cache should use to store its data.
    */
   public synchronized long getMaxSize() {
     return maxSize;
   }
 
   /**
-   * Changes the maximum number of bytes the cache can store and queues a job
-   * to trim the existing store, if necessary.
+   * Changes the maximum number of bytes the cache can store and queues a job to trim the existing
+   * store, if necessary.
    */
   public synchronized void setMaxSize(long maxSize) {
     this.maxSize = maxSize;
@@ -502,9 +496,8 @@ public synchronized void setMaxSize(long maxSize) {
   }
 
   /**
-   * Returns the number of bytes currently being used to store the values in
-   * this cache. This may be greater than the max size if a background
-   * deletion is pending.
+   * Returns the number of bytes currently being used to store the values in this cache. This may be
+   * greater than the max size if a background deletion is pending.
    */
   public synchronized long size() throws IOException {
     initialize();
@@ -572,8 +565,8 @@ private synchronized void completeEdit(Editor editor, boolean success) throws IO
   }
 
   /**
-   * We only rebuild the journal when it will halve the size of the journal
-   * and eliminate at least 2000 ops.
+   * We only rebuild the journal when it will halve the size of the journal and eliminate at least
+   * 2000 ops.
    */
   private boolean journalRebuildRequired() {
     final int redundantOpCompactThreshold = 2000;
@@ -582,9 +575,8 @@ private boolean journalRebuildRequired() {
   }
 
   /**
-   * Drops the entry for {@code key} if it exists and can be removed. If the
-   * entry for {@code key} is currently being edited, that edit will complete
-   * normally but its value will not be stored.
+   * Drops the entry for {@code key} if it exists and can be removed. If the entry for {@code key}
+   * is currently being edited, that edit will complete normally but its value will not be stored.
    *
    * @return true if an entry was removed.
    */
@@ -632,7 +624,7 @@ private synchronized void checkNotClosed() {
   }
 
   /** Force buffered operations to the filesystem. */
-  public synchronized void flush() throws IOException {
+  @Override public synchronized void flush() throws IOException {
     if (!initialized) return;
 
     checkNotClosed();
@@ -641,7 +633,7 @@ public synchronized void flush() throws IOException {
   }
 
   /** Closes this cache. Stored values will remain on the filesystem. */
-  public synchronized void close() throws IOException {
+  @Override public synchronized void close() throws IOException {
     if (!initialized || closed) {
       closed = true;
       return;
@@ -666,9 +658,8 @@ private void trimToSize() throws IOException {
   }
 
   /**
-   * Closes the cache and deletes all of its stored values. This will delete
-   * all files in the cache directory including files that weren't created by
-   * the cache.
+   * Closes the cache and deletes all of its stored values. This will delete all files in the cache
+   * directory including files that weren't created by the cache.
    */
   public void delete() throws IOException {
     close();
@@ -676,8 +667,8 @@ public void delete() throws IOException {
   }
 
   /**
-   * Deletes all stored values from the cache. In-flight edits will complete
-   * normally but their values will not be stored.
+   * Deletes all stored values from the cache. In-flight edits will complete normally but their
+   * values will not be stored.
    */
   public synchronized void evictAll() throws IOException {
     initialize();
@@ -781,9 +772,8 @@ public String key() {
     }
 
     /**
-     * Returns an editor for this snapshot's entry, or null if either the
-     * entry has changed since this snapshot was created or if another edit
-     * is in progress.
+     * Returns an editor for this snapshot's entry, or null if either the entry has changed since
+     * this snapshot was created or if another edit is in progress.
      */
     public Editor edit() throws IOException {
       return DiskLruCache.this.edit(key, sequenceNumber);
@@ -835,8 +825,8 @@ private Editor(Entry entry) {
     }
 
     /**
-     * Returns an unbuffered input stream to read the last committed value,
-     * or null if no value has been committed.
+     * Returns an unbuffered input stream to read the last committed value, or null if no value has
+     * been committed.
      */
     public Source newSource(int index) throws IOException {
       synchronized (DiskLruCache.this) {
@@ -855,11 +845,9 @@ public Source newSource(int index) throws IOException {
     }
 
     /**
-     * Returns a new unbuffered output stream to write the value at
-     * {@code index}. If the underlying output stream encounters errors
-     * when writing to the filesystem, this edit will be aborted when
-     * {@link #commit} is called. The returned output stream does not throw
-     * IOExceptions.
+     * Returns a new unbuffered output stream to write the value at {@code index}. If the underlying
+     * output stream encounters errors when writing to the filesystem, this edit will be aborted
+     * when {@link #commit} is called. The returned output stream does not throw IOExceptions.
      */
     public Sink newSink(int index) throws IOException {
       synchronized (DiskLruCache.this) {
@@ -887,8 +875,8 @@ public Sink newSink(int index) throws IOException {
     }
 
     /**
-     * Commits this edit so it is visible to readers.  This releases the
-     * edit lock so another edit may be started on the same key.
+     * Commits this edit so it is visible to readers.  This releases the edit lock so another edit
+     * may be started on the same key.
      */
     public void commit() throws IOException {
       synchronized (DiskLruCache.this) {
@@ -903,8 +891,8 @@ public void commit() throws IOException {
     }
 
     /**
-     * Aborts this edit. This releases the edit lock so another edit may be
-     * started on the same key.
+     * Aborts this edit. This releases the edit lock so another edit may be started on the same
+     * key.
      */
     public void abort() throws IOException {
       synchronized (DiskLruCache.this) {
diff --git a/okhttp/src/main/java/okhttp3/internal/Internal.java b/okhttp/src/main/java/okhttp3/internal/Internal.java
index 320143e5c5..54252084fb 100644
--- a/okhttp/src/main/java/okhttp3/internal/Internal.java
+++ b/okhttp/src/main/java/okhttp3/internal/Internal.java
@@ -15,6 +15,10 @@
  */
 package okhttp3.internal;
 
+import java.net.MalformedURLException;
+import java.net.UnknownHostException;
+import java.util.logging.Logger;
+import javax.net.ssl.SSLSocket;
 import okhttp3.Address;
 import okhttp3.Call;
 import okhttp3.Callback;
@@ -25,10 +29,6 @@
 import okhttp3.OkHttpClient;
 import okhttp3.internal.http.StreamAllocation;
 import okhttp3.internal.io.RealConnection;
-import java.net.MalformedURLException;
-import java.net.UnknownHostException;
-import java.util.logging.Logger;
-import javax.net.ssl.SSLSocket;
 
 /**
  * Escalate internal APIs in {@code okhttp3} so they can be used from OkHttp's implementation
@@ -48,7 +48,7 @@ public static void initializeInstanceForTests() {
 
   public abstract void addLenient(Headers.Builder builder, String name, String value);
 
-  public abstract void setCache(OkHttpClient client, InternalCache internalCache);
+  public abstract void setCache(OkHttpClient.Builder builder, InternalCache internalCache);
 
   public abstract InternalCache internalCache(OkHttpClient client);
 
@@ -69,5 +69,6 @@ public abstract HttpUrl getHttpUrlChecked(String url)
 
   // TODO delete the following when web sockets move into the main package.
   public abstract void callEnqueue(Call call, Callback responseCallback, boolean forWebSocket);
+
   public abstract StreamAllocation callEngineGetStreamAllocation(Call call);
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/InternalCache.java b/okhttp/src/main/java/okhttp3/internal/InternalCache.java
index d21096d45d..9752002bc5 100644
--- a/okhttp/src/main/java/okhttp3/internal/InternalCache.java
+++ b/okhttp/src/main/java/okhttp3/internal/InternalCache.java
@@ -15,16 +15,15 @@
  */
 package okhttp3.internal;
 
+import java.io.IOException;
 import okhttp3.Request;
 import okhttp3.Response;
 import okhttp3.internal.http.CacheRequest;
 import okhttp3.internal.http.CacheStrategy;
-import java.io.IOException;
-import okhttp3.Cache;
 
 /**
- * OkHttp's internal cache interface. Applications shouldn't implement this:
- * instead use {@link Cache}.
+ * OkHttp's internal cache interface. Applications shouldn't implement this: instead use {@link
+ * okhttp3.Cache}.
  */
 public interface InternalCache {
   Response get(Request request) throws IOException;
@@ -32,16 +31,15 @@
   CacheRequest put(Response response) throws IOException;
 
   /**
-   * Remove any cache entries for the supplied {@code request}. This is invoked
-   * when the client invalidates the cache, such as when making POST requests.
+   * Remove any cache entries for the supplied {@code request}. This is invoked when the client
+   * invalidates the cache, such as when making POST requests.
    */
   void remove(Request request) throws IOException;
 
   /**
-   * Handles a conditional request hit by updating the stored cache response
-   * with the headers from {@code network}. The cached response body is not
-   * updated. If the stored response has changed since {@code cached} was
-   * returned, this does nothing.
+   * Handles a conditional request hit by updating the stored cache response with the headers from
+   * {@code network}. The cached response body is not updated. If the stored response has changed
+   * since {@code cached} was returned, this does nothing.
    */
   void update(Response cached, Response network) throws IOException;
 
diff --git a/okhttp/src/main/java/okhttp3/internal/OptionalMethod.java b/okhttp/src/main/java/okhttp3/internal/OptionalMethod.java
index 7605556b59..108ec292d1 100644
--- a/okhttp/src/main/java/okhttp3/internal/OptionalMethod.java
+++ b/okhttp/src/main/java/okhttp3/internal/OptionalMethod.java
@@ -57,8 +57,7 @@ public boolean isSupported(T target) {
 
   /**
    * Invokes the method on {@code target} with {@code args}. If the method does not exist or is not
-   * public then {@code null} is returned. See also
-   * {@link #invokeOptionalWithoutCheckedException(Object, Object...)}.
+   * public then {@code null} is returned. See also {@link #invokeOptionalWithoutCheckedException}.
    *
    * @throws IllegalArgumentException if the arguments are invalid
    * @throws InvocationTargetException if the invocation throws an exception
@@ -76,9 +75,9 @@ public Object invokeOptional(T target, Object... args) throws InvocationTargetEx
   }
 
   /**
-   * Invokes the method on {@code target}.  If the method does not exist or is not
-   * public then {@code null} is returned. Any RuntimeException thrown by the method is thrown,
-   * checked exceptions are wrapped in an {@link AssertionError}.
+   * Invokes the method on {@code target}.  If the method does not exist or is not public then
+   * {@code null} is returned. Any RuntimeException thrown by the method is thrown, checked
+   * exceptions are wrapped in an {@link AssertionError}.
    *
    * @throws IllegalArgumentException if the arguments are invalid
    */
@@ -120,8 +119,8 @@ public Object invoke(T target, Object... args) throws InvocationTargetException
 
   /**
    * Invokes the method on {@code target}. Throws an error if the method is not supported. Any
-   * RuntimeException thrown by the method is thrown, checked exceptions are wrapped in
-   * an {@link AssertionError}.
+   * RuntimeException thrown by the method is thrown, checked exceptions are wrapped in an {@link
+   * AssertionError}.
    *
    * @throws IllegalArgumentException if the arguments are invalid
    */
@@ -140,10 +139,9 @@ public Object invokeWithoutCheckedException(T target, Object... args) {
   }
 
   /**
-   * Perform a lookup for the method. No caching.
-   * In order to return a method the method name and arguments must match those specified when
-   * the {@link OptionalMethod} was created. If the return type is specified (i.e. non-null) it
-   * must also be compatible. The method must also be public.
+   * Perform a lookup for the method. No caching. In order to return a method the method name and
+   * arguments must match those specified when the {@link OptionalMethod} was created. If the return
+   * type is specified (i.e. non-null) it must also be compatible. The method must also be public.
    */
   private Method getMethod(Class<?> clazz) {
     Method method = null;
diff --git a/okhttp/src/main/java/okhttp3/internal/Platform.java b/okhttp/src/main/java/okhttp3/internal/Platform.java
index d410a60ea0..bf5144155f 100644
--- a/okhttp/src/main/java/okhttp3/internal/Platform.java
+++ b/okhttp/src/main/java/okhttp3/internal/Platform.java
@@ -17,8 +17,8 @@
 package okhttp3.internal;
 
 import android.util.Log;
-import okhttp3.Protocol;
 import java.io.IOException;
+import java.lang.reflect.Field;
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
@@ -30,6 +30,9 @@
 import java.util.List;
 import java.util.logging.Level;
 import javax.net.ssl.SSLSocket;
+import javax.net.ssl.SSLSocketFactory;
+import javax.net.ssl.X509TrustManager;
+import okhttp3.Protocol;
 import okio.Buffer;
 
 import static okhttp3.internal.Internal.logger;
@@ -38,19 +41,28 @@
  * Access to platform-specific features.
  *
  * <h3>Server name indication (SNI)</h3>
- * Supported on Android 2.3+.
+ *
+ * <p>Supported on Android 2.3+.
  *
  * <h3>Session Tickets</h3>
- * Supported on Android 2.3+.
+ *
+ * <p>Supported on Android 2.3+.
  *
  * <h3>Android Traffic Stats (Socket Tagging)</h3>
- * Supported on Android 4.0+.
+ *
+ * <p>Supported on Android 4.0+.
  *
  * <h3>ALPN (Application Layer Protocol Negotiation)</h3>
- * Supported on Android 5.0+. The APIs were present in Android 4.4, but that implementation was
+ *
+ * <p>Supported on Android 5.0+. The APIs were present in Android 4.4, but that implementation was
  * unstable.
  *
  * Supported on OpenJDK 7 and 8 (via the JettyALPN-boot library).
+ *
+ * <h3>Trust Manager Extraction</h3>
+ *
+ * <p>Supported on Android 2.3+ and OpenJDK 7+. There are no public APIs to recover the trust
+ * manager that was used to create an {@link SSLSocketFactory}.
  */
 public class Platform {
   private static final Platform PLATFORM = findPlatform();
@@ -74,11 +86,14 @@ public void tagSocket(Socket socket) throws SocketException {
   public void untagSocket(Socket socket) throws SocketException {
   }
 
+  public X509TrustManager trustManager(SSLSocketFactory sslSocketFactory) {
+    return null;
+  }
+
   /**
    * Configure TLS extensions on {@code sslSocket} for {@code route}.
    *
-   * @param hostname non-null for client-side handshakes; null for
-   *     server-side handshakes.
+   * @param hostname non-null for client-side handshakes; null for server-side handshakes.
    */
   public void configureTlsExtensions(SSLSocket sslSocket, String hostname,
       List<Protocol> protocols) {
@@ -109,11 +124,13 @@ public void log(String message) {
   private static Platform findPlatform() {
     // Attempt to find Android 2.3+ APIs.
     try {
+      Class<?> sslParametersClass;
       try {
-        Class.forName("com.android.org.conscrypt.OpenSSLSocketImpl");
+        sslParametersClass = Class.forName("com.android.org.conscrypt.SSLParametersImpl");
       } catch (ClassNotFoundException e) {
         // Older platform before being unbundled.
-        Class.forName("org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl");
+        sslParametersClass = Class.forName(
+            "org.apache.harmony.xnet.provider.jsse.SSLParametersImpl");
       }
 
       OptionalMethod<Socket> setUseSessionTickets
@@ -141,25 +158,34 @@ private static Platform findPlatform() {
       } catch (ClassNotFoundException | NoSuchMethodException ignored) {
       }
 
-      return new Android(setUseSessionTickets, setHostname, trafficStatsTagSocket,
-          trafficStatsUntagSocket, getAlpnSelectedProtocol, setAlpnProtocols);
+      return new Android(sslParametersClass, setUseSessionTickets, setHostname,
+          trafficStatsTagSocket, trafficStatsUntagSocket, getAlpnSelectedProtocol,
+          setAlpnProtocols);
     } catch (ClassNotFoundException ignored) {
       // This isn't an Android runtime.
     }
 
-    // Find Jetty's ALPN extension for OpenJDK.
+    // Find an Oracle JDK.
     try {
-      String negoClassName = "org.eclipse.jetty.alpn.ALPN";
-      Class<?> negoClass = Class.forName(negoClassName);
-      Class<?> providerClass = Class.forName(negoClassName + "$Provider");
-      Class<?> clientProviderClass = Class.forName(negoClassName + "$ClientProvider");
-      Class<?> serverProviderClass = Class.forName(negoClassName + "$ServerProvider");
-      Method putMethod = negoClass.getMethod("put", SSLSocket.class, providerClass);
-      Method getMethod = negoClass.getMethod("get", SSLSocket.class);
-      Method removeMethod = negoClass.getMethod("remove", SSLSocket.class);
-      return new JdkWithJettyBootPlatform(
-          putMethod, getMethod, removeMethod, clientProviderClass, serverProviderClass);
-    } catch (ClassNotFoundException | NoSuchMethodException ignored) {
+      Class<?> sslContextClass = Class.forName("sun.security.ssl.SSLContextImpl");
+
+      // Find Jetty's ALPN extension for OpenJDK.
+      try {
+        String negoClassName = "org.eclipse.jetty.alpn.ALPN";
+        Class<?> negoClass = Class.forName(negoClassName);
+        Class<?> providerClass = Class.forName(negoClassName + "$Provider");
+        Class<?> clientProviderClass = Class.forName(negoClassName + "$ClientProvider");
+        Class<?> serverProviderClass = Class.forName(negoClassName + "$ServerProvider");
+        Method putMethod = negoClass.getMethod("put", SSLSocket.class, providerClass);
+        Method getMethod = negoClass.getMethod("get", SSLSocket.class);
+        Method removeMethod = negoClass.getMethod("remove", SSLSocket.class);
+        return new JdkWithJettyBootPlatform(sslContextClass,
+            putMethod, getMethod, removeMethod, clientProviderClass, serverProviderClass);
+      } catch (ClassNotFoundException | NoSuchMethodException ignored) {
+      }
+
+      return new JdkPlatform(sslContextClass);
+    } catch (ClassNotFoundException ignored) {
     }
 
     return new Platform();
@@ -169,6 +195,7 @@ private static Platform findPlatform() {
   private static class Android extends Platform {
     private static final int MAX_LOG_LENGTH = 4000;
 
+    private final Class<?> sslParametersClass;
     private final OptionalMethod<Socket> setUseSessionTickets;
     private final OptionalMethod<Socket> setHostname;
 
@@ -180,9 +207,11 @@ private static Platform findPlatform() {
     private final OptionalMethod<Socket> getAlpnSelectedProtocol;
     private final OptionalMethod<Socket> setAlpnProtocols;
 
-    public Android(OptionalMethod<Socket> setUseSessionTickets, OptionalMethod<Socket> setHostname,
-        Method trafficStatsTagSocket, Method trafficStatsUntagSocket,
-        OptionalMethod<Socket> getAlpnSelectedProtocol, OptionalMethod<Socket> setAlpnProtocols) {
+    public Android(Class<?> sslParametersClass, OptionalMethod<Socket> setUseSessionTickets,
+        OptionalMethod<Socket> setHostname, Method trafficStatsTagSocket,
+        Method trafficStatsUntagSocket, OptionalMethod<Socket> getAlpnSelectedProtocol,
+        OptionalMethod<Socket> setAlpnProtocols) {
+      this.sslParametersClass = sslParametersClass;
       this.setUseSessionTickets = setUseSessionTickets;
       this.setHostname = setHostname;
       this.trafficStatsTagSocket = trafficStatsTagSocket;
@@ -207,6 +236,17 @@ public Android(OptionalMethod<Socket> setUseSessionTickets, OptionalMethod<Socke
       }
     }
 
+    @Override public X509TrustManager trustManager(SSLSocketFactory sslSocketFactory) {
+      Object context = readFieldOrNull(sslSocketFactory, sslParametersClass, "sslParameters");
+      if (context == null) return null;
+
+      X509TrustManager x509TrustManager = readFieldOrNull(
+          context, X509TrustManager.class, "x509TrustManager");
+      if (x509TrustManager != null) return x509TrustManager;
+
+      return readFieldOrNull(context, X509TrustManager.class, "trustManager");
+    }
+
     @Override public void configureTlsExtensions(
         SSLSocket sslSocket, String hostname, List<Protocol> protocols) {
       // Enable SNI and session tickets.
@@ -217,7 +257,7 @@ public Android(OptionalMethod<Socket> setUseSessionTickets, OptionalMethod<Socke
 
       // Enable ALPN.
       if (setAlpnProtocols != null && setAlpnProtocols.isSupported(sslSocket)) {
-        Object[] parameters = { concatLengthPrefixed(protocols) };
+        Object[] parameters = {concatLengthPrefixed(protocols)};
         setAlpnProtocols.invokeWithoutCheckedException(sslSocket, parameters);
       }
     }
@@ -268,18 +308,34 @@ public Android(OptionalMethod<Socket> setUseSessionTickets, OptionalMethod<Socke
     }
   }
 
+  /** JDK 1.7 or better. */
+  private static class JdkPlatform extends Platform {
+    private final Class<?> sslContextClass;
+
+    public JdkPlatform(Class<?> sslContextClass) {
+      this.sslContextClass = sslContextClass;
+    }
+
+    @Override public X509TrustManager trustManager(SSLSocketFactory sslSocketFactory) {
+      Object context = readFieldOrNull(sslSocketFactory, sslContextClass, "context");
+      if (context == null) return null;
+      return readFieldOrNull(context, X509TrustManager.class, "trustManager");
+    }
+  }
+
   /**
    * OpenJDK 7+ with {@code org.mortbay.jetty.alpn/alpn-boot} in the boot class path.
    */
-  private static class JdkWithJettyBootPlatform extends Platform {
+  private static class JdkWithJettyBootPlatform extends JdkPlatform {
     private final Method putMethod;
     private final Method getMethod;
     private final Method removeMethod;
     private final Class<?> clientProviderClass;
     private final Class<?> serverProviderClass;
 
-    public JdkWithJettyBootPlatform(Method putMethod, Method getMethod, Method removeMethod,
-        Class<?> clientProviderClass, Class<?> serverProviderClass) {
+    public JdkWithJettyBootPlatform(Class<?> sslContextClass, Method putMethod, Method getMethod,
+        Method removeMethod, Class<?> clientProviderClass, Class<?> serverProviderClass) {
+      super(sslContextClass);
       this.putMethod = putMethod;
       this.getMethod = getMethod;
       this.removeMethod = removeMethod;
@@ -297,7 +353,7 @@ public JdkWithJettyBootPlatform(Method putMethod, Method getMethod, Method remov
       }
       try {
         Object provider = Proxy.newProxyInstance(Platform.class.getClassLoader(),
-            new Class[] { clientProviderClass, serverProviderClass }, new JettyNegoProvider(names));
+            new Class[] {clientProviderClass, serverProviderClass}, new JettyNegoProvider(names));
         putMethod.invoke(null, sslSocket, provider);
       } catch (InvocationTargetException | IllegalAccessException e) {
         throw new AssertionError(e);
@@ -329,8 +385,8 @@ public JdkWithJettyBootPlatform(Method putMethod, Method getMethod, Method remov
   }
 
   /**
-   * Handle the methods of ALPN's ClientProvider and ServerProvider
-   * without a compile-time dependency on those interfaces.
+   * Handle the methods of ALPN's ClientProvider and ServerProvider without a compile-time
+   * dependency on those interfaces.
    */
   private static class JettyNegoProvider implements InvocationHandler {
     /** This peer's supported protocols. */
@@ -391,4 +447,27 @@ public JettyNegoProvider(List<String> protocols) {
     }
     return result.readByteArray();
   }
+
+  static <T> T readFieldOrNull(Object instance, Class<T> fieldType, String fieldName) {
+    for (Class<?> c = instance.getClass(); c != Object.class; c = c.getSuperclass()) {
+      try {
+        Field field = c.getDeclaredField(fieldName);
+        field.setAccessible(true);
+        Object value = field.get(instance);
+        if (value == null || !fieldType.isInstance(value)) return null;
+        return fieldType.cast(value);
+      } catch (NoSuchFieldException ignored) {
+      } catch (IllegalAccessException e) {
+        throw new AssertionError();
+      }
+    }
+
+    // Didn't find the field we wanted. As a last gasp attempt, try to find the value on a delegate.
+    if (!fieldName.equals("delegate")) {
+      Object delegate = readFieldOrNull(instance, Object.class, "delegate");
+      if (delegate != null) return readFieldOrNull(delegate, fieldType, fieldName);
+    }
+
+    return null;
+  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/RouteDatabase.java b/okhttp/src/main/java/okhttp3/internal/RouteDatabase.java
index d2c2a5ea6a..613e0bf215 100644
--- a/okhttp/src/main/java/okhttp3/internal/RouteDatabase.java
+++ b/okhttp/src/main/java/okhttp3/internal/RouteDatabase.java
@@ -15,15 +15,15 @@
  */
 package okhttp3.internal;
 
-import okhttp3.Route;
 import java.util.LinkedHashSet;
 import java.util.Set;
+import okhttp3.Route;
 
 /**
- * A blacklist of failed routes to avoid when creating a new connection to a
- * target address. This is used so that OkHttp can learn from its mistakes: if
- * there was a failure attempting to connect to a specific IP address or proxy
- * server, that failure is remembered and alternate routes are preferred.
+ * A blacklist of failed routes to avoid when creating a new connection to a target address. This is
+ * used so that OkHttp can learn from its mistakes: if there was a failure attempting to connect to
+ * a specific IP address or proxy server, that failure is remembered and alternate routes are
+ * preferred.
  */
 public final class RouteDatabase {
   private final Set<Route> failedRoutes = new LinkedHashSet<>();
diff --git a/okhttp/src/main/java/okhttp3/internal/Util.java b/okhttp/src/main/java/okhttp3/internal/Util.java
index 338fe7174c..e9efad04c6 100644
--- a/okhttp/src/main/java/okhttp3/internal/Util.java
+++ b/okhttp/src/main/java/okhttp3/internal/Util.java
@@ -13,15 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
 package okhttp3.internal;
 
-import okhttp3.HttpUrl;
 import java.io.Closeable;
 import java.io.IOException;
 import java.io.InterruptedIOException;
 import java.io.UnsupportedEncodingException;
 import java.lang.reflect.Array;
+import java.net.IDN;
 import java.net.ServerSocket;
 import java.net.Socket;
 import java.nio.charset.Charset;
@@ -32,9 +31,13 @@
 import java.util.Collections;
 import java.util.LinkedHashMap;
 import java.util.List;
+import java.util.Locale;
 import java.util.Map;
+import java.util.TimeZone;
 import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.TimeUnit;
+import java.util.regex.Pattern;
+import okhttp3.HttpUrl;
 import okio.Buffer;
 import okio.ByteString;
 import okio.Source;
@@ -47,6 +50,22 @@
   /** A cheap and type-safe constant for the UTF-8 Charset. */
   public static final Charset UTF_8 = Charset.forName("UTF-8");
 
+  /** GMT and UTC are equivalent for our purposes. */
+  public static final TimeZone UTC = TimeZone.getTimeZone("GMT");
+
+  /**
+   * Quick and dirty pattern to differentiate IP addresses from hostnames. This is an approximation
+   * of Android's private InetAddress#isNumeric API.
+   *
+   * <p>This matches IPv6 addresses as a hex string containing at least one colon, and possibly
+   * including dots after the first colon. It matches IPv4 addresses as strings containing only
+   * decimal digits and dots. This pattern matches strings like "a:.23" and "54" that are neither IP
+   * addresses nor hostnames; they will be verified as IP addresses (which is a more strict
+   * verification).
+   */
+  private static final Pattern VERIFY_AS_IP_ADDRESS = Pattern.compile(
+      "([0-9a-fA-F]*:[0-9a-fA-F:.]*)|([\\d.]+)");
+
   private Util() {
   }
 
@@ -62,8 +81,8 @@ public static boolean equal(Object a, Object b) {
   }
 
   /**
-   * Closes {@code closeable}, ignoring any checked exceptions. Does nothing
-   * if {@code closeable} is null.
+   * Closes {@code closeable}, ignoring any checked exceptions. Does nothing if {@code closeable} is
+   * null.
    */
   public static void closeQuietly(Closeable closeable) {
     if (closeable != null) {
@@ -77,8 +96,8 @@ public static void closeQuietly(Closeable closeable) {
   }
 
   /**
-   * Closes {@code socket}, ignoring any checked exceptions. Does nothing if
-   * {@code socket} is null.
+   * Closes {@code socket}, ignoring any checked exceptions. Does nothing if {@code socket} is
+   * null.
    */
   public static void closeQuietly(Socket socket) {
     if (socket != null) {
@@ -94,8 +113,8 @@ public static void closeQuietly(Socket socket) {
   }
 
   /**
-   * Closes {@code serverSocket}, ignoring any checked exceptions. Does nothing if
-   * {@code serverSocket} is null.
+   * Closes {@code serverSocket}, ignoring any checked exceptions. Does nothing if {@code
+   * serverSocket} is null.
    */
   public static void closeQuietly(ServerSocket serverSocket) {
     if (serverSocket != null) {
@@ -109,8 +128,8 @@ public static void closeQuietly(ServerSocket serverSocket) {
   }
 
   /**
-   * Closes {@code a} and {@code b}. If either close fails, this completes
-   * the other close and rethrows the first encountered exception.
+   * Closes {@code a} and {@code b}. If either close fails, this completes the other close and
+   * rethrows the first encountered exception.
    */
   public static void closeAll(Closeable a, Closeable b) throws IOException {
     Throwable thrown = null;
@@ -132,8 +151,8 @@ public static void closeAll(Closeable a, Closeable b) throws IOException {
   }
 
   /**
-   * Attempts to exhaust {@code source}, returning true if successful. This is useful when reading
-   * a complete source is helpful, such as when doing so completes a cache body or frees a socket
+   * Attempts to exhaust {@code source}, returning true if successful. This is useful when reading a
+   * complete source is helpful, such as when doing so completes a cache body or frees a socket
    * connection for reuse.
    */
   public static boolean discard(Source source, int timeout, TimeUnit timeUnit) {
@@ -230,8 +249,8 @@ public static ThreadFactory threadFactory(final String name, final boolean daemo
   }
 
   /**
-   * Returns an array containing containing only elements found in {@code first}  and also in
-   * {@code second}. The returned elements are in the same order as in {@code first}.
+   * Returns an array containing containing only elements found in {@code first}  and also in {@code
+   * second}. The returned elements are in the same order as in {@code first}.
    */
   @SuppressWarnings("unchecked")
   public static <T> T[] intersect(Class<T> arrayType, T[] first, T[] second) {
@@ -240,8 +259,8 @@ public static ThreadFactory threadFactory(final String name, final boolean daemo
   }
 
   /**
-   * Returns a list containing containing only elements found in {@code first}  and also in
-   * {@code second}. The returned elements are in the same order as in {@code first}.
+   * Returns a list containing containing only elements found in {@code first}  and also in {@code
+   * second}. The returned elements are in the same order as in {@code first}.
    */
   private static <T> List<T> intersect(T[] first, T[] second) {
     List<T> result = new ArrayList<>();
@@ -299,4 +318,119 @@ public static boolean contains(String[] array, String value) {
     result[result.length - 1] = value;
     return result;
   }
+
+  /**
+   * Increments {@code pos} until {@code input[pos]} is not ASCII whitespace. Stops at {@code
+   * limit}.
+   */
+  public static int skipLeadingAsciiWhitespace(String input, int pos, int limit) {
+    for (int i = pos; i < limit; i++) {
+      switch (input.charAt(i)) {
+        case '\t':
+        case '\n':
+        case '\f':
+        case '\r':
+        case ' ':
+          continue;
+        default:
+          return i;
+      }
+    }
+    return limit;
+  }
+
+  /**
+   * Decrements {@code limit} until {@code input[limit - 1]} is not ASCII whitespace. Stops at
+   * {@code pos}.
+   */
+  public static int skipTrailingAsciiWhitespace(String input, int pos, int limit) {
+    for (int i = limit - 1; i >= pos; i--) {
+      switch (input.charAt(i)) {
+        case '\t':
+        case '\n':
+        case '\f':
+        case '\r':
+        case ' ':
+          continue;
+        default:
+          return i + 1;
+      }
+    }
+    return pos;
+  }
+
+  /** Equivalent to {@code string.substring(pos, limit).trim()}. */
+  public static String trimSubstring(String string, int pos, int limit) {
+    int start = skipLeadingAsciiWhitespace(string, pos, limit);
+    int end = skipTrailingAsciiWhitespace(string, start, limit);
+    return string.substring(start, end);
+  }
+
+  /**
+   * Returns the index of the first character in {@code input} that contains a character in {@code
+   * delimiters}. Returns limit if there is no such character.
+   */
+  public static int delimiterOffset(String input, int pos, int limit, String delimiters) {
+    for (int i = pos; i < limit; i++) {
+      if (delimiters.indexOf(input.charAt(i)) != -1) return i;
+    }
+    return limit;
+  }
+
+  /**
+   * Returns the index of the first character in {@code input} that is {@code delimiter}. Returns
+   * limit if there is no such character.
+   */
+  public static int delimiterOffset(String input, int pos, int limit, char delimiter) {
+    for (int i = pos; i < limit; i++) {
+      if (input.charAt(i) == delimiter) return i;
+    }
+    return limit;
+  }
+
+  /**
+   * Performs IDN ToASCII encoding and canonicalize the result to lowercase. e.g. This converts
+   * {@code ☃.net} to {@code xn--n3h.net}, and {@code WwW.GoOgLe.cOm} to {@code www.google.com}.
+   * {@code null} will be returned if the input cannot be ToASCII encoded or if the result
+   * contains unsupported ASCII characters.
+   */
+  public static String domainToAscii(String input) {
+    try {
+      String result = IDN.toASCII(input).toLowerCase(Locale.US);
+      if (result.isEmpty()) return null;
+
+      // Confirm that the IDN ToASCII result doesn't contain any illegal characters.
+      if (containsInvalidHostnameAsciiCodes(result)) {
+        return null;
+      }
+      // TODO: implement all label limits.
+      return result;
+    } catch (IllegalArgumentException e) {
+      return null;
+    }
+  }
+
+  private static boolean containsInvalidHostnameAsciiCodes(String hostnameAscii) {
+    for (int i = 0; i < hostnameAscii.length(); i++) {
+      char c = hostnameAscii.charAt(i);
+      // The WHATWG Host parsing rules accepts some character codes which are invalid by
+      // definition for OkHttp's host header checks (and the WHATWG Host syntax definition). Here
+      // we rule out characters that would cause problems in host headers.
+      if (c <= '\u001f' || c >= '\u007f') {
+        return true;
+      }
+      // Check for the characters mentioned in the WHATWG Host parsing spec:
+      // U+0000, U+0009, U+000A, U+000D, U+0020, "#", "%", "/", ":", "?", "@", "[", "\", and "]"
+      // (excluding the characters covered above).
+      if (" #%/:?@[\\]".indexOf(c) != -1) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  /** Returns true if {@code host} is not a host name and might be an IP address. */
+  public static boolean verifyAsIpAddress(String host) {
+    return VERIFY_AS_IP_ADDRESS.matcher(host).matches();
+  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/FrameReader.java b/okhttp/src/main/java/okhttp3/internal/framed/FrameReader.java
index 68a23337c4..cfcfac0bec 100644
--- a/okhttp/src/main/java/okhttp3/internal/framed/FrameReader.java
+++ b/okhttp/src/main/java/okhttp3/internal/framed/FrameReader.java
@@ -25,6 +25,7 @@
 /** Reads transport frames for SPDY/3 or HTTP/2. */
 public interface FrameReader extends Closeable {
   void readConnectionPreface() throws IOException;
+
   boolean nextFrame(Handler handler) throws IOException;
 
   interface Handler {
@@ -32,100 +33,92 @@ void data(boolean inFinished, int streamId, BufferedSource source, int length)
         throws IOException;
 
     /**
-     * Create or update incoming headers, creating the corresponding streams
-     * if necessary. Frames that trigger this are SPDY SYN_STREAM, HEADERS, and
-     * SYN_REPLY, and HTTP/2 HEADERS and PUSH_PROMISE.
+     * Create or update incoming headers, creating the corresponding streams if necessary. Frames
+     * that trigger this are SPDY SYN_STREAM, HEADERS, and SYN_REPLY, and HTTP/2 HEADERS and
+     * PUSH_PROMISE.
      *
      * @param outFinished true if the receiver should not send further frames.
      * @param inFinished true if the sender will not send further frames.
      * @param streamId the stream owning these headers.
-     * @param associatedStreamId the stream that triggered the sender to create
-     *     this stream.
+     * @param associatedStreamId the stream that triggered the sender to create this stream.
      */
     void headers(boolean outFinished, boolean inFinished, int streamId, int associatedStreamId,
         List<Header> headerBlock, HeadersMode headersMode);
+
     void rstStream(int streamId, ErrorCode errorCode);
+
     void settings(boolean clearPrevious, Settings settings);
 
     /** HTTP/2 only. */
     void ackSettings();
 
     /**
-     *  Read a connection-level ping from the peer.  {@code ack} indicates this
-     *  is a reply.  Payload parameters are different between SPDY/3 and HTTP/2.
-     *  <p>
-     *  In SPDY/3, only the first {@code payload1} parameter is set.  If the
-     *  reader is a client, it is an unsigned even number.  Likewise, a server
-     *  will receive an odd number.
-     *  <p>
-     *  In HTTP/2, both {@code payload1} and {@code payload2} parameters are
-     *  set. The data is opaque binary, and there are no rules on the content.
+     * Read a connection-level ping from the peer.  {@code ack} indicates this is a reply.  Payload
+     * parameters are different between SPDY/3 and HTTP/2.
+     *
+     * <p>In SPDY/3, only the first {@code payload1} parameter is set.  If the reader is a client,
+     * it is an unsigned even number. Likewise, a server will receive an odd number.
+     *
+     * <p>In HTTP/2, both {@code payload1} and {@code payload2} parameters are set. The data is
+     * opaque binary, and there are no rules on the content.
      */
     void ping(boolean ack, int payload1, int payload2);
 
     /**
-     * The peer tells us to stop creating streams.  It is safe to replay
-     * streams with {@code ID > lastGoodStreamId} on a new connection.  In-
-     * flight streams with {@code ID <= lastGoodStreamId} can only be replayed
-     * on a new connection if they are idempotent.
+     * The peer tells us to stop creating streams.  It is safe to replay streams with {@code ID >
+     * lastGoodStreamId} on a new connection.  In- flight streams with {@code ID <=
+     * lastGoodStreamId} can only be replayed on a new connection if they are idempotent.
      *
-     * @param lastGoodStreamId the last stream ID the peer processed before
-     *     sending this message. If {@code lastGoodStreamId} is zero, the peer
-     *     processed no frames.
+     * @param lastGoodStreamId the last stream ID the peer processed before sending this message. If
+     * {@code lastGoodStreamId} is zero, the peer processed no frames.
      * @param errorCode reason for closing the connection.
      * @param debugData only valid for HTTP/2; opaque debug data to send.
      */
     void goAway(int lastGoodStreamId, ErrorCode errorCode, ByteString debugData);
 
     /**
-     * Notifies that an additional {@code windowSizeIncrement} bytes can be
-     * sent on {@code streamId}, or the connection if {@code streamId} is zero.
+     * Notifies that an additional {@code windowSizeIncrement} bytes can be sent on {@code
+     * streamId}, or the connection if {@code streamId} is zero.
      */
     void windowUpdate(int streamId, long windowSizeIncrement);
 
     /**
-     * Called when reading a headers or priority frame. This may be used to
-     * change the stream's weight from the default (16) to a new value.
+     * Called when reading a headers or priority frame. This may be used to change the stream's
+     * weight from the default (16) to a new value.
      *
      * @param streamId stream which has a priority change.
      * @param streamDependency the stream ID this stream is dependent on.
      * @param weight relative proportion of priority in [1..256].
-     * @param exclusive inserts this stream ID as the sole child of
-     *     {@code streamDependency}.
+     * @param exclusive inserts this stream ID as the sole child of {@code streamDependency}.
      */
     void priority(int streamId, int streamDependency, int weight, boolean exclusive);
 
     /**
-     * HTTP/2 only. Receive a push promise header block.
-     * <p>
-     * A push promise contains all the headers that pertain to a server-initiated
-     * request, and a {@code promisedStreamId} to which response frames will be
-     * delivered. Push promise frames are sent as a part of the response to
-     * {@code streamId}.
+     * HTTP/2 only. Receive a push promise header block. <p> A push promise contains all the headers
+     * that pertain to a server-initiated request, and a {@code promisedStreamId} to which response
+     * frames will be delivered. Push promise frames are sent as a part of the response to {@code
+     * streamId}.
      *
      * @param streamId client-initiated stream ID.  Must be an odd number.
-     * @param promisedStreamId server-initiated stream ID.  Must be an even
-     * number.
-     * @param requestHeaders minimally includes {@code :method}, {@code :scheme},
-     * {@code :authority}, and (@code :path}.
+     * @param promisedStreamId server-initiated stream ID.  Must be an even number.
+     * @param requestHeaders minimally includes {@code :method}, {@code :scheme}, {@code
+     * :authority}, and (@code :path}.
      */
     void pushPromise(int streamId, int promisedStreamId, List<Header> requestHeaders)
         throws IOException;
 
     /**
-     * HTTP/2 only. Expresses that resources for the connection or a client-
-     * initiated stream are available from a different network location or
-     * protocol configuration.
+     * HTTP/2 only. Expresses that resources for the connection or a client- initiated stream are
+     * available from a different network location or protocol configuration.
      *
      * <p>See <a href="http://tools.ietf.org/html/draft-ietf-httpbis-alt-svc-01">alt-svc</a>
      *
-     * @param streamId when a client-initiated stream ID (odd number), the
-     *     origin of this alternate service is the origin of the stream. When
-     *     zero, the origin is specified in the {@code origin} parameter.
-     * @param origin when present, the
-     *     <a href="http://tools.ietf.org/html/rfc6454">origin</a> is typically
-     *     represented as a combination of scheme, host and port. When empty,
-     *     the origin is that of the {@code streamId}.
+     * @param streamId when a client-initiated stream ID (odd number), the origin of this alternate
+     * service is the origin of the stream. When zero, the origin is specified in the {@code origin}
+     * parameter.
+     * @param origin when present, the <a href="http://tools.ietf.org/html/rfc6454">origin</a> is
+     * typically represented as a combination of scheme, host and port. When empty, the origin is
+     * that of the {@code streamId}.
      * @param protocol an ALPN protocol, such as {@code h2}.
      * @param host an IP address or hostname.
      * @param port the IP port associated with the service.
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/FrameWriter.java b/okhttp/src/main/java/okhttp3/internal/framed/FrameWriter.java
index d22c12a280..ca1a7e4b8a 100644
--- a/okhttp/src/main/java/okhttp3/internal/framed/FrameWriter.java
+++ b/okhttp/src/main/java/okhttp3/internal/framed/FrameWriter.java
@@ -25,34 +25,37 @@
 public interface FrameWriter extends Closeable {
   /** HTTP/2 only. */
   void connectionPreface() throws IOException;
+
   /** Informs the peer that we've applied its latest settings. */
   void ackSettings(Settings peerSettings) throws IOException;
 
   /**
    * HTTP/2 only. Send a push promise header block.
-   * <p>
-   * A push promise contains all the headers that pertain to a server-initiated
-   * request, and a {@code promisedStreamId} to which response frames will be
-   * delivered. Push promise frames are sent as a part of the response to
-   * {@code streamId}.  The {@code promisedStreamId} has a priority of one
-   * greater than {@code streamId}.
+   *
+   * <p>A push promise contains all the headers that pertain to a server-initiated request, and a
+   * {@code promisedStreamId} to which response frames will be delivered. Push promise frames are
+   * sent as a part of the response to {@code streamId}. The {@code promisedStreamId} has a priority
+   * of one greater than {@code streamId}.
    *
    * @param streamId client-initiated stream ID.  Must be an odd number.
-   * @param promisedStreamId server-initiated stream ID.  Must be an even
-   * number.
-   * @param requestHeaders minimally includes {@code :method}, {@code :scheme},
-   * {@code :authority}, and (@code :path}.
+   * @param promisedStreamId server-initiated stream ID.  Must be an even number.
+   * @param requestHeaders minimally includes {@code :method}, {@code :scheme}, {@code :authority},
+   * and (@code :path}.
    */
   void pushPromise(int streamId, int promisedStreamId, List<Header> requestHeaders)
       throws IOException;
 
   /** SPDY/3 only. */
   void flush() throws IOException;
+
   void synStream(boolean outFinished, boolean inFinished, int streamId, int associatedStreamId,
       List<Header> headerBlock) throws IOException;
+
   void synReply(boolean outFinished, int streamId, List<Header> headerBlock)
       throws IOException;
+
   void headers(int streamId, List<Header> headerBlock) throws IOException;
+
   void rstStream(int streamId, ErrorCode errorCode) throws IOException;
 
   /** The maximum size of bytes that may be sent in a single call to {@link #data}. */
@@ -63,8 +66,8 @@ void synReply(boolean outFinished, int streamId, List<Header> headerBlock)
    * Implementations must send multiple frames as necessary.
    *
    * @param source the buffer to draw bytes from. May be null if byteCount is 0.
-   * @param byteCount must be between 0 and the minimum of {code source.length}
-   * and {@link #maxDataLength}.
+   * @param byteCount must be between 0 and the minimum of {code source.length} and {@link
+   * #maxDataLength}.
    */
   void data(boolean outFinished, int streamId, Buffer source, int byteCount) throws IOException;
 
@@ -72,32 +75,30 @@ void synReply(boolean outFinished, int streamId, List<Header> headerBlock)
   void settings(Settings okHttpSettings) throws IOException;
 
   /**
-   *  Send a connection-level ping to the peer.  {@code ack} indicates this is
-   *  a reply.  Payload parameters are different between SPDY/3 and HTTP/2.
-   *  <p>
-   *  In SPDY/3, only the first {@code payload1} parameter is sent.  If the
-   *  sender is a client, it is an unsigned odd number.  Likewise, a server
-   *  will send an even number.
-   *  <p>
-   *  In HTTP/2, both {@code payload1} and {@code payload2} parameters are
-   *  sent.  The data is opaque binary, and there are no rules on the content.
+   * Send a connection-level ping to the peer.  {@code ack} indicates this is a reply.  Payload
+   * parameters are different between SPDY/3 and HTTP/2.
+   *
+   * <p>In SPDY/3, only the first {@code payload1} parameter is sent.  If the sender is a client, it
+   * is an unsigned odd number. Likewise, a server will send an even number.
+   *
+   * <p>In HTTP/2, both {@code payload1} and {@code payload2} parameters are sent.  The data is
+   * opaque binary, and there are no rules on the content.
    */
   void ping(boolean ack, int payload1, int payload2) throws IOException;
 
   /**
-   * Tell the peer to stop creating streams and that we last processed
-   * {@code lastGoodStreamId}, or zero if no streams were processed.
+   * Tell the peer to stop creating streams and that we last processed {@code lastGoodStreamId}, or
+   * zero if no streams were processed.
    *
-   * @param lastGoodStreamId the last stream ID processed, or zero if no
-   * streams were processed.
+   * @param lastGoodStreamId the last stream ID processed, or zero if no streams were processed.
    * @param errorCode reason for closing the connection.
    * @param debugData only valid for HTTP/2; opaque debug data to send.
    */
   void goAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData) throws IOException;
 
   /**
-   * Inform peer that an additional {@code windowSizeIncrement} bytes can be
-   * sent on {@code streamId}, or the connection if {@code streamId} is zero.
+   * Inform peer that an additional {@code windowSizeIncrement} bytes can be sent on {@code
+   * streamId}, or the connection if {@code streamId} is zero.
    */
   void windowUpdate(int streamId, long windowSizeIncrement) throws IOException;
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/FramedConnection.java b/okhttp/src/main/java/okhttp3/internal/framed/FramedConnection.java
index 7ad9a40840..26d511f916 100644
--- a/okhttp/src/main/java/okhttp3/internal/framed/FramedConnection.java
+++ b/okhttp/src/main/java/okhttp3/internal/framed/FramedConnection.java
@@ -15,9 +15,6 @@
  */
 package okhttp3.internal.framed;
 
-import okhttp3.Protocol;
-import okhttp3.internal.NamedRunnable;
-import okhttp3.internal.Util;
 import java.io.Closeable;
 import java.io.IOException;
 import java.io.InterruptedIOException;
@@ -34,6 +31,9 @@
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
 import java.util.logging.Level;
+import okhttp3.Protocol;
+import okhttp3.internal.NamedRunnable;
+import okhttp3.internal.Util;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -44,13 +44,13 @@
 import static okhttp3.internal.framed.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
 
 /**
- * A socket connection to a remote peer. A connection hosts streams which can
- * send and receive data.
+ * A socket connection to a remote peer. A connection hosts streams which can send and receive
+ * data.
  *
- * <p>Many methods in this API are <strong>synchronous:</strong> the call is
- * completed before the method returns. This is typical for Java but atypical
- * for SPDY. This is motivated by exception transparency: an IOException that
- * was triggered by a certain caller can be caught and handled by that caller.
+ * <p>Many methods in this API are <strong>synchronous:</strong> the call is completed before the
+ * method returns. This is typical for Java but atypical for SPDY. This is motivated by exception
+ * transparency: an IOException that was triggered by a certain caller can be caught and handled by
+ * that caller.
  */
 public final class FramedConnection implements Closeable {
 
@@ -98,15 +98,14 @@
   private int nextPingId;
 
   /**
-   * The total number of bytes consumed by the application, but not yet
-   * acknowledged by sending a {@code WINDOW_UPDATE} frame on this connection.
+   * The total number of bytes consumed by the application, but not yet acknowledged by sending a
+   * {@code WINDOW_UPDATE} frame on this connection.
    */
   // Visible for testing
   long unacknowledgedBytesRead = 0;
 
   /**
-   * Count of bytes that can be written on the connection before receiving a
-   * window update.
+   * Count of bytes that can be written on the connection before receiving a window update.
    */
   // Visible for testing
   long bytesLeftInWriteWindow;
@@ -180,8 +179,7 @@ public Protocol getProtocol() {
   }
 
   /**
-   * Returns the number of {@link FramedStream#isOpen() open streams} on this
-   * connection.
+   * Returns the number of {@link FramedStream#isOpen() open streams} on this connection.
    */
   public synchronized int openStreamCount() {
     return streams.size();
@@ -214,8 +212,8 @@ public synchronized int maxConcurrentStreams() {
   }
 
   /**
-   * Returns the time in ns when this connection became idle or Long.MAX_VALUE
-   * if connection is not idle.
+   * Returns the time in ns when this connection became idle or Long.MAX_VALUE if connection is not
+   * idle.
    */
   public synchronized long getIdleStartTimeNs() {
     return idleStartTimeNs;
@@ -224,10 +222,9 @@ public synchronized long getIdleStartTimeNs() {
   /**
    * Returns a new server-initiated stream.
    *
-   * @param associatedStreamId the stream that triggered the sender to create
-   *     this stream.
-   * @param out true to create an output stream that we can use to send data
-   *     to the remote peer. Corresponds to {@code FLAG_FIN}.
+   * @param associatedStreamId the stream that triggered the sender to create this stream.
+   * @param out true to create an output stream that we can use to send data to the remote peer.
+   * Corresponds to {@code FLAG_FIN}.
    */
   public FramedStream pushStream(int associatedStreamId, List<Header> requestHeaders, boolean out)
       throws IOException {
@@ -240,9 +237,9 @@ public FramedStream pushStream(int associatedStreamId, List<Header> requestHeade
    * Returns a new locally-initiated stream.
    *
    * @param out true to create an output stream that we can use to send data to the remote peer.
-   *     Corresponds to {@code FLAG_FIN}.
+   * Corresponds to {@code FLAG_FIN}.
    * @param in true to create an input stream that the remote peer can use to send data to us.
-   *     Corresponds to {@code FLAG_UNIDIRECTIONAL}.
+   * Corresponds to {@code FLAG_UNIDIRECTIONAL}.
    */
   public FramedStream newStream(List<Header> requestHeaders, boolean out, boolean in)
       throws IOException {
@@ -337,8 +334,7 @@ public void writeData(int streamId, boolean outFinished, Buffer buffer, long byt
   }
 
   /**
-   * {@code delta} will be negative if a settings frame initial window is
-   * smaller than the last.
+   * {@code delta} will be negative if a settings frame initial window is smaller than the last.
    */
   void addBytesToWriteWindow(long delta) {
     bytesLeftInWriteWindow += delta;
@@ -372,8 +368,8 @@ void writeWindowUpdateLater(final int streamId, final long unacknowledgedBytesRe
   }
 
   /**
-   * Sends a ping frame to the peer. Use the returned object to await the
-   * ping's response and observe its round trip time.
+   * Sends a ping frame to the peer. Use the returned object to await the ping's response and
+   * observe its round trip time.
    */
   public Ping ping() throws IOException {
     Ping ping = new Ping();
@@ -421,10 +417,9 @@ public void flush() throws IOException {
   }
 
   /**
-   * Degrades this connection such that new streams can neither be created
-   * locally, nor accepted from the remote peer. Existing streams are not
-   * impacted. This is intended to permit an endpoint to gracefully stop
-   * accepting new requests without harming previously established streams.
+   * Degrades this connection such that new streams can neither be created locally, nor accepted
+   * from the remote peer. Existing streams are not impacted. This is intended to permit an endpoint
+   * to gracefully stop accepting new requests without harming previously established streams.
    */
   public void shutdown(ErrorCode statusCode) throws IOException {
     synchronized (frameWriter) {
@@ -442,9 +437,8 @@ public void shutdown(ErrorCode statusCode) throws IOException {
   }
 
   /**
-   * Closes this connection. This cancels all open streams and unanswered
-   * pings. It closes the underlying input and output streams and shuts down
-   * internal executor services.
+   * Closes this connection. This cancels all open streams and unanswered pings. It closes the
+   * underlying input and output streams and shuts down internal executor services.
    */
   @Override public void close() throws IOException {
     close(ErrorCode.NO_ERROR, ErrorCode.CANCEL);
@@ -507,8 +501,8 @@ private void close(ErrorCode connectionCode, ErrorCode streamCode) throws IOExce
   }
 
   /**
-   * Sends a connection header if the current variant requires it. This should
-   * be called after {@link Builder#build} for all new connections.
+   * Sends a connection header if the current variant requires it. This should be called after
+   * {@link Builder#build} for all new connections.
    */
   public void sendConnectionPreface() throws IOException {
     frameWriter.connectionPreface();
@@ -543,8 +537,8 @@ public void setSettings(Settings settings) throws IOException {
     private boolean client;
 
     /**
-     * @param client true if this peer initiated the connection; false if this
-     *     peer accepted the connection.
+     * @param client true if this peer initiated the connection; false if this peer accepted the
+     * connection.
      */
     public Builder(boolean client) throws IOException {
       this.client = client;
@@ -585,8 +579,8 @@ public FramedConnection build() throws IOException {
   }
 
   /**
-   * Methods in this class must not lock FrameWriter.  If a method needs to
-   * write a frame, create an async task to do so.
+   * Methods in this class must not lock FrameWriter.  If a method needs to write a frame, create an
+   * async task to do so.
    */
   class Reader extends NamedRunnable implements FrameReader.Handler {
     final FrameReader frameReader;
@@ -920,22 +914,19 @@ private void pushResetLater(final int streamId, final ErrorCode errorCode) {
     };
 
     /**
-     * Handle a new stream from this connection's peer. Implementations should
-     * respond by either {@linkplain FramedStream#reply replying to the stream}
-     * or {@linkplain FramedStream#close closing it}. This response does not
-     * need to be synchronous.
+     * Handle a new stream from this connection's peer. Implementations should respond by either
+     * {@linkplain FramedStream#reply replying to the stream} or {@linkplain FramedStream#close
+     * closing it}. This response does not need to be synchronous.
      */
     public abstract void onStream(FramedStream stream) throws IOException;
 
     /**
-     * Notification that the connection's peer's settings may have changed.
-     * Implementations should take appropriate action to handle the updated
-     * settings.
+     * Notification that the connection's peer's settings may have changed. Implementations should
+     * take appropriate action to handle the updated settings.
      *
-     * <p>It is the implementation's responsibility to handle concurrent calls
-     * to this method. A remote peer that sends multiple settings frames will
-     * trigger multiple calls to this method, and those calls are not
-     * necessarily serialized.
+     * <p>It is the implementation's responsibility to handle concurrent calls to this method. A
+     * remote peer that sends multiple settings frames will trigger multiple calls to this method,
+     * and those calls are not necessarily serialized.
      */
     public void onSettings(FramedConnection connection) {
     }
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/FramedStream.java b/okhttp/src/main/java/okhttp3/internal/framed/FramedStream.java
index 2532ee7ebf..857a99c3c3 100644
--- a/okhttp/src/main/java/okhttp3/internal/framed/FramedStream.java
+++ b/okhttp/src/main/java/okhttp3/internal/framed/FramedStream.java
@@ -37,17 +37,16 @@
   // blocking operations are performed while the lock is held.
 
   /**
-   * The total number of bytes consumed by the application (with {@link
-   * FramedDataSource#read}), but not yet acknowledged by sending a {@code
-   * WINDOW_UPDATE} frame on this stream.
+   * The total number of bytes consumed by the application (with {@link FramedDataSource#read}), but
+   * not yet acknowledged by sending a {@code WINDOW_UPDATE} frame on this stream.
    */
   // Visible for testing
   long unacknowledgedBytesRead = 0;
 
   /**
-   * Count of bytes that can be written on the stream before receiving a
-   * window update. Even if this is positive, writes will block until there
-   * available bytes in {@code connection.bytesLeftInWriteWindow}.
+   * Count of bytes that can be written on the stream before receiving a window update. Even if this
+   * is positive, writes will block until there available bytes in {@code
+   * connection.bytesLeftInWriteWindow}.
    */
   // guarded by this
   long bytesLeftInWriteWindow;
@@ -67,9 +66,9 @@
   private final StreamTimeout writeTimeout = new StreamTimeout();
 
   /**
-   * The reason why this stream was abnormally closed. If there are multiple
-   * reasons to abnormally close this stream (such as both peers closing it
-   * near-simultaneously) then this is the first reason known to this peer.
+   * The reason why this stream was abnormally closed. If there are multiple reasons to abnormally
+   * close this stream (such as both peers closing it near-simultaneously) then this is the first
+   * reason known to this peer.
    */
   private ErrorCode errorCode = null;
 
@@ -95,13 +94,14 @@ public int getId() {
 
   /**
    * Returns true if this stream is open. A stream is open until either:
+   *
    * <ul>
-   * <li>A {@code SYN_RESET} frame abnormally terminates the stream.
-   * <li>Both input and output streams have transmitted all data and
-   * headers.
+   *     <li>A {@code SYN_RESET} frame abnormally terminates the stream.
+   *     <li>Both input and output streams have transmitted all data and headers.
    * </ul>
-   * Note that the input stream may continue to yield data even after a stream
-   * reports itself as not open. This is because input data is buffered.
+   *
+   * <p>Note that the input stream may continue to yield data even after a stream reports itself as
+   * not open. This is because input data is buffered.
    */
   public synchronized boolean isOpen() {
     if (errorCode != null) {
@@ -130,8 +130,8 @@ public FramedConnection getConnection() {
   }
 
   /**
-   * Returns the stream's response headers, blocking if necessary if they
-   * have not been received yet.
+   * Returns the stream's response headers, blocking if necessary if they have not been received
+   * yet.
    */
   public synchronized List<Header> getResponseHeaders() throws IOException {
     readTimeout.enter();
@@ -147,8 +147,8 @@ public FramedConnection getConnection() {
   }
 
   /**
-   * Returns the reason why this stream was closed, or null if it closed
-   * normally or has not yet been closed.
+   * Returns the reason why this stream was closed, or null if it closed normally or has not yet
+   * been closed.
    */
   public synchronized ErrorCode getErrorCode() {
     return errorCode;
@@ -157,8 +157,8 @@ public synchronized ErrorCode getErrorCode() {
   /**
    * Sends a reply to an incoming stream.
    *
-   * @param out true to create an output stream that we can use to send data
-   * to the remote peer. Corresponds to {@code FLAG_FIN}.
+   * @param out true to create an output stream that we can use to send data to the remote peer.
+   * Corresponds to {@code FLAG_FIN}.
    */
   public void reply(List<Header> responseHeaders, boolean out) throws IOException {
     assert (!Thread.holdsLock(FramedStream.this));
@@ -199,8 +199,8 @@ public Source getSource() {
   /**
    * Returns a sink that can be used to write data to the peer.
    *
-   * @throws IllegalStateException if this stream was initiated by the peer
-   *     and a {@link #reply} has not yet been sent.
+   * @throws IllegalStateException if this stream was initiated by the peer and a {@link #reply} has
+   * not yet been sent.
    */
   public Sink getSink() {
     synchronized (this) {
@@ -212,8 +212,8 @@ public Sink getSink() {
   }
 
   /**
-   * Abnormally terminate this stream. This blocks until the {@code RST_STREAM}
-   * frame has been transmitted.
+   * Abnormally terminate this stream. This blocks until the {@code RST_STREAM} frame has been
+   * transmitted.
    */
   public void close(ErrorCode rstStatusCode) throws IOException {
     if (!closeInternal(rstStatusCode)) {
@@ -223,8 +223,8 @@ public void close(ErrorCode rstStatusCode) throws IOException {
   }
 
   /**
-   * Abnormally terminate this stream. This enqueues a {@code RST_STREAM}
-   * frame and returns immediately.
+   * Abnormally terminate this stream. This enqueues a {@code RST_STREAM} frame and returns
+   * immediately.
    */
   public void closeLater(ErrorCode errorCode) {
     if (!closeInternal(errorCode)) {
@@ -307,9 +307,9 @@ synchronized void receiveRstStream(ErrorCode errorCode) {
   }
 
   /**
-   * A source that reads the incoming data frames of a stream. Although this
-   * class uses synchronization to safely receive incoming data frames, it is
-   * not intended for use by multiple readers.
+   * A source that reads the incoming data frames of a stream. Although this class uses
+   * synchronization to safely receive incoming data frames, it is not intended for use by multiple
+   * readers.
    */
   private final class FramedDataSource implements Source {
     /** Buffer to receive data from the network into. Only accessed by the reader thread. */
@@ -325,8 +325,8 @@ synchronized void receiveRstStream(ErrorCode errorCode) {
     private boolean closed;
 
     /**
-     * True if either side has cleanly shut down this stream. We will
-     * receive no more bytes beyond those already in the buffer.
+     * True if either side has cleanly shut down this stream. We will receive no more bytes beyond
+     * those already in the buffer.
      */
     private boolean finished;
 
@@ -464,23 +464,21 @@ private void cancelStreamIfNecessary() throws IOException {
   }
 
   /**
-   * A sink that writes outgoing data frames of a stream. This class is not
-   * thread safe.
+   * A sink that writes outgoing data frames of a stream. This class is not thread safe.
    */
   final class FramedDataSink implements Sink {
     private static final long EMIT_BUFFER_SIZE = 16384;
 
     /**
-     * Buffer of outgoing data. This batches writes of small writes into this sink as larges
-     * frames written to the outgoing connection. Batching saves the (small) framing overhead.
+     * Buffer of outgoing data. This batches writes of small writes into this sink as larges frames
+     * written to the outgoing connection. Batching saves the (small) framing overhead.
      */
     private final Buffer sendBuffer = new Buffer();
 
     private boolean closed;
 
     /**
-     * True if either side has cleanly shut down this stream. We shall send
-     * no more bytes.
+     * True if either side has cleanly shut down this stream. We shall send no more bytes.
      */
     private boolean finished;
 
@@ -561,8 +559,7 @@ private void emitDataFrame(boolean outFinished) throws IOException {
   }
 
   /**
-   * {@code delta} will be negative if a settings frame initial window is
-   * smaller than the last.
+   * {@code delta} will be negative if a settings frame initial window is smaller than the last.
    */
   void addBytesToWriteWindow(long delta) {
     bytesLeftInWriteWindow += delta;
@@ -580,8 +577,8 @@ private void checkOutNotClosed() throws IOException {
   }
 
   /**
-   * Like {@link #wait}, but throws an {@code InterruptedIOException} when
-   * interrupted instead of the more awkward {@link InterruptedException}.
+   * Like {@link #wait}, but throws an {@code InterruptedIOException} when interrupted instead of
+   * the more awkward {@link InterruptedException}.
    */
   private void waitForIo() throws InterruptedIOException {
     try {
@@ -592,9 +589,8 @@ private void waitForIo() throws InterruptedIOException {
   }
 
   /**
-   * The Okio timeout watchdog will call {@link #timedOut} if the timeout is
-   * reached. In that case we close the stream (asynchronously) which will
-   * notify the waiting thread.
+   * The Okio timeout watchdog will call {@link #timedOut} if the timeout is reached. In that case
+   * we close the stream (asynchronously) which will notify the waiting thread.
    */
   class StreamTimeout extends AsyncTimeout {
     @Override protected void timedOut() {
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/HeadersMode.java b/okhttp/src/main/java/okhttp3/internal/framed/HeadersMode.java
index 772d58f60e..bc851ed784 100644
--- a/okhttp/src/main/java/okhttp3/internal/framed/HeadersMode.java
+++ b/okhttp/src/main/java/okhttp3/internal/framed/HeadersMode.java
@@ -32,16 +32,14 @@ public boolean failIfStreamPresent() {
   }
 
   /**
-   * Returns true if it is an error these headers to be the initial headers of a
-   * response.
+   * Returns true if it is an error these headers to be the initial headers of a response.
    */
   public boolean failIfHeadersAbsent() {
     return this == SPDY_HEADERS;
   }
 
   /**
-   * Returns true if it is an error these headers to be update existing headers
-   * of a response.
+   * Returns true if it is an error these headers to be update existing headers of a response.
    */
   public boolean failIfHeadersPresent() {
     return this == SPDY_REPLY;
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/Hpack.java b/okhttp/src/main/java/okhttp3/internal/framed/Hpack.java
index 0eb67743f0..2b49784e9b 100644
--- a/okhttp/src/main/java/okhttp3/internal/framed/Hpack.java
+++ b/okhttp/src/main/java/okhttp3/internal/framed/Hpack.java
@@ -33,9 +33,9 @@
  *
  * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12
  *
- * This implementation uses an array for the dynamic table and a list for
- * indexed entries.  Dynamic entries are added to the array, starting in the
- * last position moving forward.  When the array fills, it is doubled.
+ * This implementation uses an array for the dynamic table and a list for indexed entries.  Dynamic
+ * entries are added to the array, starting in the last position moving forward.  When the array
+ * fills, it is doubled.
  */
 final class Hpack {
   private static final int PREFIX_4_BITS = 0x0f;
@@ -136,11 +136,11 @@ int maxDynamicTableByteCount() {
     }
 
     /**
-     * Called by the reader when the peer sent {@link Settings#HEADER_TABLE_SIZE}.
-     * While this establishes the maximum dynamic table size, the
-     * {@link #maxDynamicTableByteCount} set during processing may limit the
-     * table size to a smaller amount.
-     * <p> Evicts entries or clears the table as needed.
+     * Called by the reader when the peer sent {@link Settings#HEADER_TABLE_SIZE}. While this
+     * establishes the maximum dynamic table size, the {@link #maxDynamicTableByteCount} set during
+     * processing may limit the table size to a smaller amount.
+     *
+     * <p>Evicts entries or clears the table as needed.
      */
     void headerTableSizeSetting(int headerTableSizeSetting) {
       this.headerTableSizeSetting = headerTableSizeSetting;
@@ -185,8 +185,8 @@ private int evictToRecoverBytes(int bytesToRecover) {
     }
 
     /**
-     * Read {@code byteCount} bytes of headers from the source stream. This
-     * implementation does not propagate the never indexed flag of a header.
+     * Read {@code byteCount} bytes of headers from the source stream. This implementation does not
+     * propagate the never indexed flag of a header.
      */
     void readHeaders() throws IOException {
       while (!source.exhausted()) {
@@ -420,8 +420,8 @@ void writeByteString(ByteString data) throws IOException {
   }
 
   /**
-   * An HTTP/2 response cannot contain uppercase header characters and must
-   * be treated as malformed.
+   * An HTTP/2 response cannot contain uppercase header characters and must be treated as
+   * malformed.
    */
   private static ByteString checkLowercase(ByteString name) throws IOException {
     for (int i = 0, length = name.size(); i < length; i++) {
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/Http2.java b/okhttp/src/main/java/okhttp3/internal/framed/Http2.java
index f0d4ce40d3..a6c177cc60 100644
--- a/okhttp/src/main/java/okhttp3/internal/framed/Http2.java
+++ b/okhttp/src/main/java/okhttp3/internal/framed/Http2.java
@@ -15,10 +15,10 @@
  */
 package okhttp3.internal.framed;
 
-import okhttp3.Protocol;
 import java.io.IOException;
 import java.util.List;
 import java.util.logging.Logger;
+import okhttp3.Protocol;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -26,18 +26,17 @@
 import okio.Source;
 import okio.Timeout;
 
-import static okhttp3.internal.framed.Http2.FrameLogger.formatHeader;
 import static java.lang.String.format;
 import static java.util.logging.Level.FINE;
+import static okhttp3.internal.framed.Http2.FrameLogger.formatHeader;
 import static okio.ByteString.EMPTY;
 
 /**
  * Read and write HTTP/2 frames.
- * <p>
- * This implementation assumes we do not send an increased
- * {@link Settings#getMaxFrameSize frame size setting} to the peer. Hence, we
- * expect all frames to have a max length of {@link #INITIAL_MAX_FRAME_SIZE}.
- * <p>http://tools.ietf.org/html/draft-ietf-httpbis-http2-17
+ *
+ * <p>This implementation assumes we do not send an increased {@link Settings#getMaxFrameSize frame
+ * size setting} to the peer. Hence, we expect all frames to have a max length of {@link
+ * #INITIAL_MAX_FRAME_SIZE}. <p>http://tools.ietf.org/html/draft-ietf-httpbis-http2-17
  */
 public final class Http2 implements Variant {
   private static final Logger logger = Logger.getLogger(FrameLogger.class.getName());
@@ -73,8 +72,7 @@
   static final byte FLAG_COMPRESSED = 0x20; // Used for data.
 
   /**
-   * Creates a frame reader with max header table size of 4096 and data frame
-   * compression disabled.
+   * Creates a frame reader with max header table size of 4096 and data frame compression disabled.
    */
   @Override public FrameReader newReader(BufferedSource source, boolean client) {
     return new Reader(source, 4096, client);
@@ -296,7 +294,7 @@ private void readSettings(Handler handler, int length, byte flags, int streamId)
           case 6: // SETTINGS_MAX_HEADER_LIST_SIZE
             break; // Advisory only, so ignored.
           default:
-            throw ioException("PROTOCOL_ERROR invalid settings id: %s", id);
+            break; // Must ignore setting with unknown id.
         }
         settings.set(id, 0, value);
       }
@@ -505,8 +503,11 @@ void dataFrame(int streamId, byte flags, Buffer buffer, int byteCount) throws IO
       for (int i = 0; i < Settings.COUNT; i++) {
         if (!settings.isSet(i)) continue;
         int id = i;
-        if (id == 4) id = 3; // SETTINGS_MAX_CONCURRENT_STREAMS renumbered.
-        else if (id == 7) id = 4; // SETTINGS_INITIAL_WINDOW_SIZE renumbered.
+        if (id == 4) {
+          id = 3; // SETTINGS_MAX_CONCURRENT_STREAMS renumbered.
+        } else if (id == 7) {
+          id = 4; // SETTINGS_INITIAL_WINDOW_SIZE renumbered.
+        }
         sink.writeShort(id);
         sink.writeInt(settings.get(i));
       }
@@ -585,9 +586,8 @@ private static IOException ioException(String message, Object... args) throws IO
   }
 
   /**
-   * Decompression of the header block occurs above the framing layer. This
-   * class lazily reads continuation frames as they are needed by {@link
-   * Hpack.Reader#readHeaders()}.
+   * Decompression of the header block occurs above the framing layer. This class lazily reads
+   * continuation frames as they are needed by {@link Hpack.Reader#readHeaders()}.
    */
   static final class ContinuationSource implements Source {
     private final BufferedSource source;
@@ -657,8 +657,7 @@ private static int lengthWithoutPadding(int length, byte flags, short padding)
    * </pre>
    * Where direction is {@code <<} for inbound and {@code >>} for outbound.
    *
-   * <p> For example, the following would indicate a HEAD request sent from
-   * the client.
+   * <p>For example, the following would indicate a HEAD request sent from the client.
    * <pre>
    * {@code
    *   << 0x0000000f    12 HEADERS       END_HEADERS|END_STREAM
@@ -675,8 +674,8 @@ static String formatHeader(boolean inbound, int streamId, int length, byte type,
     }
 
     /**
-     * Looks up valid string representing flags from the table. Invalid
-     * combinations are represented in binary.
+     * Looks up valid string representing flags from the table. Invalid combinations are represented
+     * in binary.
      */
     // Visible for testing.
     static String formatFlags(byte type, byte flags) {
@@ -716,8 +715,8 @@ static String formatFlags(byte type, byte flags) {
     };
 
     /**
-     * Lookup table for valid flags for DATA, HEADERS, CONTINUATION. Invalid
-     * combinations are represented in binary.
+     * Lookup table for valid flags for DATA, HEADERS, CONTINUATION. Invalid combinations are
+     * represented in binary.
      */
     private static final String[] FLAGS = new String[0x40]; // Highest bit flag is 0x20.
     private static final String[] BINARY = new String[256];
@@ -734,7 +733,7 @@ static String formatFlags(byte type, byte flags) {
 
       FLAGS[FLAG_PADDED] = "PADDED";
       for (int prefixFlag : prefixFlags) {
-         FLAGS[prefixFlag | FLAG_PADDED] = FLAGS[prefixFlag] + "|PADDED";
+        FLAGS[prefixFlag | FLAG_PADDED] = FLAGS[prefixFlag] + "|PADDED";
       }
 
       FLAGS[FLAG_END_HEADERS] = "END_HEADERS"; // Same as END_PUSH_PROMISE.
@@ -759,13 +758,13 @@ static String formatFlags(byte type, byte flags) {
 
   private static int readMedium(BufferedSource source) throws IOException {
     return (source.readByte() & 0xff) << 16
-        |  (source.readByte() & 0xff) <<  8
-        |  (source.readByte() & 0xff);
+        | (source.readByte() & 0xff) << 8
+        | (source.readByte() & 0xff);
   }
 
   private static void writeMedium(BufferedSink sink, int i) throws IOException {
     sink.writeByte((i >>> 16) & 0xff);
-    sink.writeByte((i >>>  8) & 0xff);
-    sink.writeByte(i          & 0xff);
+    sink.writeByte((i >>> 8) & 0xff);
+    sink.writeByte(i & 0xff);
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/Huffman.java b/okhttp/src/main/java/okhttp3/internal/framed/Huffman.java
index 63b6c39459..0c7f3012a7 100644
--- a/okhttp/src/main/java/okhttp3/internal/framed/Huffman.java
+++ b/okhttp/src/main/java/okhttp3/internal/framed/Huffman.java
@@ -20,12 +20,13 @@
 import java.io.OutputStream;
 
 /**
- * This class was originally composed from the following classes in
- * <a href="https://github.com/twitter/hpack">Twitter Hpack</a>.
+ * This class was originally composed from the following classes in <a
+ * href="https://github.com/twitter/hpack">Twitter Hpack</a>.
+ *
  * <ul>
- * <li>{@code com.twitter.hpack.HuffmanEncoder}</li>
- * <li>{@code com.twitter.hpack.HuffmanDecoder}</li>
- * <li>{@code com.twitter.hpack.HpackUtil}</li>
+ *     <li>{@code com.twitter.hpack.HuffmanEncoder}</li>
+ *     <li>{@code com.twitter.hpack.HuffmanDecoder}</li>
+ *     <li>{@code com.twitter.hpack.HpackUtil}</li>
  * </ul>
  */
 class Huffman {
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/NameValueBlockReader.java b/okhttp/src/main/java/okhttp3/internal/framed/NameValueBlockReader.java
index 8994722cb5..75cd9594f7 100644
--- a/okhttp/src/main/java/okhttp3/internal/framed/NameValueBlockReader.java
+++ b/okhttp/src/main/java/okhttp3/internal/framed/NameValueBlockReader.java
@@ -29,18 +29,17 @@
 import okio.Source;
 
 /**
- * Reads a SPDY/3 Name/Value header block. This class is made complicated by the
- * requirement that we're strict with which bytes we put in the compressed bytes
- * buffer. We need to put all compressed bytes into that buffer -- but no other
- * bytes.
+ * Reads a SPDY/3 Name/Value header block. This class is made complicated by the requirement that
+ * we're strict with which bytes we put in the compressed bytes buffer. We need to put all
+ * compressed bytes into that buffer -- but no other bytes.
  */
 class NameValueBlockReader {
   /** This source transforms compressed bytes into uncompressed bytes. */
   private final InflaterSource inflaterSource;
 
   /**
-   * How many compressed bytes must be read into inflaterSource before
-   * {@link #readNameValueBlock} returns.
+   * How many compressed bytes must be read into inflaterSource before {@link #readNameValueBlock}
+   * returns.
    */
   private int compressedLimit;
 
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/Ping.java b/okhttp/src/main/java/okhttp3/internal/framed/Ping.java
index 31adb1dd8f..d3e0b428d6 100644
--- a/okhttp/src/main/java/okhttp3/internal/framed/Ping.java
+++ b/okhttp/src/main/java/okhttp3/internal/framed/Ping.java
@@ -47,9 +47,8 @@ void cancel() {
   }
 
   /**
-   * Returns the round trip time for this ping in nanoseconds, waiting for the
-   * response to arrive if necessary. Returns -1 if the response was
-   * canceled.
+   * Returns the round trip time for this ping in nanoseconds, waiting for the response to arrive if
+   * necessary. Returns -1 if the response was canceled.
    */
   public long roundTripTime() throws InterruptedException {
     latch.await();
@@ -57,9 +56,8 @@ public long roundTripTime() throws InterruptedException {
   }
 
   /**
-   * Returns the round trip time for this ping in nanoseconds, or -1 if the
-   * response was canceled, or -2 if the timeout elapsed before the round
-   * trip completed.
+   * Returns the round trip time for this ping in nanoseconds, or -1 if the response was canceled,
+   * or -2 if the timeout elapsed before the round trip completed.
    */
   public long roundTripTime(long timeout, TimeUnit unit) throws InterruptedException {
     if (latch.await(timeout, unit)) {
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/PushObserver.java b/okhttp/src/main/java/okhttp3/internal/framed/PushObserver.java
index 72d2948125..95dd41a5b9 100644
--- a/okhttp/src/main/java/okhttp3/internal/framed/PushObserver.java
+++ b/okhttp/src/main/java/okhttp3/internal/framed/PushObserver.java
@@ -21,37 +21,36 @@
 import okio.BufferedSource;
 
 /**
- * {@link Protocol#HTTP_2 HTTP/2} only.
- * Processes server-initiated HTTP requests on the client. Implementations must
- * quickly dispatch callbacks to avoid creating a bottleneck.
+ * {@link Protocol#HTTP_2 HTTP/2} only. Processes server-initiated HTTP requests on the client.
+ * Implementations must quickly dispatch callbacks to avoid creating a bottleneck.
+ *
+ * <p>While {@link #onReset} may occur at any time, the following callbacks are expected in order,
+ * correlated by stream ID.
  *
- * <p>While {@link #onReset} may occur at any time, the following callbacks are
- * expected in order, correlated by stream ID.
  * <ul>
- *   <li>{@link #onRequest}</li>
- *   <li>{@link #onHeaders} (unless canceled)</li>
- *   <li>{@link #onData} (optional sequence of data frames)</li>
+ *     <li>{@link #onRequest}</li> <li>{@link #onHeaders} (unless canceled)
+ *     <li>{@link #onData} (optional sequence of data frames)
  * </ul>
  *
- * <p>As a stream ID is scoped to a single HTTP/2 connection, implementations
- * which target multiple connections should expect repetition of stream IDs.
+ * <p>As a stream ID is scoped to a single HTTP/2 connection, implementations which target multiple
+ * connections should expect repetition of stream IDs.
  *
- * <p>Return true to request cancellation of a pushed stream.  Note that this
- * does not guarantee future frames won't arrive on the stream ID.
+ * <p>Return true to request cancellation of a pushed stream.  Note that this does not guarantee
+ * future frames won't arrive on the stream ID.
  */
 public interface PushObserver {
   /**
    * Describes the request that the server intends to push a response for.
    *
    * @param streamId server-initiated stream ID: an even number.
-   * @param requestHeaders minimally includes {@code :method}, {@code :scheme},
-   * {@code :authority}, and (@code :path}.
+   * @param requestHeaders minimally includes {@code :method}, {@code :scheme}, {@code :authority},
+   * and (@code :path}.
    */
   boolean onRequest(int streamId, List<Header> requestHeaders);
 
   /**
-   * The response headers corresponding to a pushed request.  When {@code last}
-   * is true, there are no data frames to follow.
+   * The response headers corresponding to a pushed request.  When {@code last} is true, there are
+   * no data frames to follow.
    *
    * @param streamId server-initiated stream ID: an even number.
    * @param responseHeaders minimally includes {@code :status}.
@@ -60,8 +59,8 @@
   boolean onHeaders(int streamId, List<Header> responseHeaders, boolean last);
 
   /**
-   * A chunk of response data corresponding to a pushed request.  This data
-   * must either be read or skipped.
+   * A chunk of response data corresponding to a pushed request.  This data must either be read or
+   * skipped.
    *
    * @param streamId server-initiated stream ID: an even number.
    * @param source location of data corresponding with this stream ID.
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/Settings.java b/okhttp/src/main/java/okhttp3/internal/framed/Settings.java
index 598b0680b3..f4eab01731 100644
--- a/okhttp/src/main/java/okhttp3/internal/framed/Settings.java
+++ b/okhttp/src/main/java/okhttp3/internal/framed/Settings.java
@@ -23,8 +23,8 @@
  */
 public final class Settings {
   /**
-   * From the SPDY/3 and HTTP/2 specs, the default initial window size for all
-   * streams is 64 KiB. (Chrome 25 uses 10 MiB).
+   * From the SPDY/3 and HTTP/2 specs, the default initial window size for all streams is 64 KiB.
+   * (Chrome 25 uses 10 MiB).
    */
   static final int DEFAULT_INITIAL_WINDOW_SIZE = 64 * 1024;
 
@@ -212,8 +212,8 @@ boolean isFlowControlDisabled() {
   }
 
   /**
-   * Returns true if this user agent should use this setting in future spdy/3
-   * connections to the same host.
+   * Returns true if this user agent should use this setting in future spdy/3 connections to the
+   * same host.
    */
   boolean persistValue(int id) {
     int bit = 1 << id;
@@ -227,8 +227,8 @@ boolean isPersisted(int id) {
   }
 
   /**
-   * Writes {@code other} into this. If any setting is populated by this and
-   * {@code other}, the value and flags from {@code other} will be kept.
+   * Writes {@code other} into this. If any setting is populated by this and {@code other}, the
+   * value and flags from {@code other} will be kept.
    */
   void merge(Settings other) {
     for (int i = 0; i < COUNT; i++) {
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/Spdy3.java b/okhttp/src/main/java/okhttp3/internal/framed/Spdy3.java
index 11ac226a76..72053e0066 100644
--- a/okhttp/src/main/java/okhttp3/internal/framed/Spdy3.java
+++ b/okhttp/src/main/java/okhttp3/internal/framed/Spdy3.java
@@ -15,13 +15,13 @@
  */
 package okhttp3.internal.framed;
 
-import okhttp3.Protocol;
-import okhttp3.internal.Util;
 import java.io.IOException;
 import java.io.UnsupportedEncodingException;
 import java.net.ProtocolException;
 import java.util.List;
 import java.util.zip.Deflater;
+import okhttp3.Protocol;
+import okhttp3.internal.Util;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -30,8 +30,7 @@
 import okio.Okio;
 
 /**
- * Read and write spdy/3.1 frames.
- * http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1
+ * Read and write spdy/3.1 frames. http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1
  */
 public final class Spdy3 implements Variant {
 
@@ -55,6 +54,7 @@
   static final int VERSION = 3;
 
   static final byte[] DICTIONARY;
+
   static {
     try {
       DICTIONARY = ("\u0000\u0000\u0000\u0007options\u0000\u0000\u0000\u0004hea"
@@ -119,8 +119,8 @@
     }
 
     /**
-     * Send the next frame to {@code handler}. Returns true unless there are no
-     * more frames on the stream.
+     * Send the next frame to {@code handler}. Returns true unless there are no more frames on the
+     * stream.
      */
     @Override public boolean nextFrame(Handler handler) throws IOException {
       int w1;
diff --git a/okhttp/src/main/java/okhttp3/internal/http/CacheRequest.java b/okhttp/src/main/java/okhttp3/internal/http/CacheRequest.java
index 18a40c19f2..12c3134e8a 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/CacheRequest.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/CacheRequest.java
@@ -20,5 +20,6 @@
 
 public interface CacheRequest {
   Sink body() throws IOException;
+
   void abort();
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/http/CacheStrategy.java b/okhttp/src/main/java/okhttp3/internal/http/CacheStrategy.java
index 56fa0fefaf..a2f513d1d4 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/CacheStrategy.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/CacheStrategy.java
@@ -1,10 +1,10 @@
 package okhttp3.internal.http;
 
+import java.util.Date;
 import okhttp3.CacheControl;
 import okhttp3.Headers;
 import okhttp3.Request;
 import okhttp3.Response;
-import java.util.Date;
 
 import static java.net.HttpURLConnection.HTTP_BAD_METHOD;
 import static java.net.HttpURLConnection.HTTP_GONE;
@@ -20,12 +20,12 @@
 import static java.util.concurrent.TimeUnit.SECONDS;
 
 /**
- * Given a request and cached response, this figures out whether to use the
- * network, the cache, or both.
+ * Given a request and cached response, this figures out whether to use the network, the cache, or
+ * both.
  *
- * <p>Selecting a cache strategy may add conditions to the request (like the
- * "If-Modified-Since" header for conditional GETs) or warnings to the cached
- * response (if the cached data is potentially stale).
+ * <p>Selecting a cache strategy may add conditions to the request (like the "If-Modified-Since"
+ * header for conditional GETs) or warnings to the cached response (if the cached data is
+ * potentially stale).
  */
 public final class CacheStrategy {
   /** The request to send on the network, or null if this call doesn't use the network. */
@@ -39,10 +39,7 @@ private CacheStrategy(Request networkRequest, Response cacheResponse) {
     this.cacheResponse = cacheResponse;
   }
 
-  /**
-   * Returns true if {@code response} can be stored to later serve another
-   * request.
-   */
+  /** Returns true if {@code response} can be stored to later serve another request. */
   public static boolean isCacheable(Response response, Request request) {
     // Always go to network for uncacheable response codes (RFC 7231 section 6.1),
     // This implementation doesn't support caching partial content.
@@ -58,8 +55,8 @@ public static boolean isCacheable(Response response, Request request) {
       case HTTP_REQ_TOO_LONG:
       case HTTP_NOT_IMPLEMENTED:
       case StatusLine.HTTP_PERM_REDIRECT:
-      // These codes can be cached unless headers forbid it.
-      break;
+        // These codes can be cached unless headers forbid it.
+        break;
 
       case HTTP_MOVED_TEMP:
       case StatusLine.HTTP_TEMP_REDIRECT:
@@ -97,20 +94,20 @@ public static boolean isCacheable(Response response, Request request) {
     private String lastModifiedString;
 
     /**
-     * The expiration date of the cached response, if known. If both this field
-     * and the max age are set, the max age is preferred.
+     * The expiration date of the cached response, if known. If both this field and the max age are
+     * set, the max age is preferred.
      */
     private Date expires;
 
     /**
-     * Extension header set by OkHttp specifying the timestamp when the cached
-     * HTTP request was first initiated.
+     * Extension header set by OkHttp specifying the timestamp when the cached HTTP request was
+     * first initiated.
      */
     private long sentRequestMillis;
 
     /**
-     * Extension header set by OkHttp specifying the timestamp when the cached
-     * HTTP response was first received.
+     * Extension header set by OkHttp specifying the timestamp when the cached HTTP response was
+     * first received.
      */
     private long receivedResponseMillis;
 
@@ -152,8 +149,7 @@ public Factory(long nowMillis, Request request, Response cacheResponse) {
     }
 
     /**
-     * Returns a strategy to satisfy {@code request} using the a cached response
-     * {@code response}.
+     * Returns a strategy to satisfy {@code request} using the a cached response {@code response}.
      */
     public CacheStrategy get() {
       CacheStrategy candidate = getCandidate();
@@ -237,8 +233,8 @@ private CacheStrategy getCandidate() {
     }
 
     /**
-     * Returns the number of milliseconds that the response was fresh for,
-     * starting from the served date.
+     * Returns the number of milliseconds that the response was fresh for, starting from the served
+     * date.
      */
     private long computeFreshnessLifetime() {
       CacheControl responseCaching = cacheResponse.cacheControl();
@@ -266,8 +262,8 @@ private long computeFreshnessLifetime() {
     }
 
     /**
-     * Returns the current age of the response, in milliseconds. The calculation
-     * is specified by RFC 2616, 13.2.3 Age Calculations.
+     * Returns the current age of the response, in milliseconds. The calculation is specified by RFC
+     * 2616, 13.2.3 Age Calculations.
      */
     private long cacheResponseAge() {
       long apparentReceivedAge = servedDate != null
@@ -282,18 +278,17 @@ private long cacheResponseAge() {
     }
 
     /**
-     * Returns true if computeFreshnessLifetime used a heuristic. If we used a
-     * heuristic to serve a cached response older than 24 hours, we are required
-     * to attach a warning.
+     * Returns true if computeFreshnessLifetime used a heuristic. If we used a heuristic to serve a
+     * cached response older than 24 hours, we are required to attach a warning.
      */
     private boolean isFreshnessLifetimeHeuristic() {
       return cacheResponse.cacheControl().maxAgeSeconds() == -1 && expires == null;
     }
 
     /**
-     * Returns true if the request contains conditions that save the server from
-     * sending a response that the client has locally. When a request is enqueued
-     * with its own conditions, the built-in response cache won't be used.
+     * Returns true if the request contains conditions that save the server from sending a response
+     * that the client has locally. When a request is enqueued with its own conditions, the built-in
+     * response cache won't be used.
      */
     private static boolean hasConditions(Request request) {
       return request.header("If-Modified-Since") != null || request.header("If-None-Match") != null;
diff --git a/okhttp/src/main/java/okhttp3/internal/http/HeaderParser.java b/okhttp/src/main/java/okhttp3/internal/http/HeaderParser.java
index 085f6f1448..6cb3232806 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/HeaderParser.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/HeaderParser.java
@@ -18,9 +18,8 @@
 
 public final class HeaderParser {
   /**
-   * Returns the next index in {@code input} at or after {@code pos} that
-   * contains a character from {@code characters}. Returns the input length if
-   * none of the requested characters can be found.
+   * Returns the next index in {@code input} at or after {@code pos} that contains a character from
+   * {@code characters}. Returns the input length if none of the requested characters can be found.
    */
   public static int skipUntil(String input, int pos, String characters) {
     for (; pos < input.length(); pos++) {
@@ -32,8 +31,8 @@ public static int skipUntil(String input, int pos, String characters) {
   }
 
   /**
-   * Returns the next non-whitespace character in {@code input} that is white
-   * space. Result is undefined if input contains newline characters.
+   * Returns the next non-whitespace character in {@code input} that is white space. Result is
+   * undefined if input contains newline characters.
    */
   public static int skipWhitespace(String input, int pos) {
     for (; pos < input.length(); pos++) {
@@ -46,8 +45,8 @@ public static int skipWhitespace(String input, int pos) {
   }
 
   /**
-   * Returns {@code value} as a positive integer, or 0 if it is negative, or
-   * {@code defaultValue} if it cannot be parsed.
+   * Returns {@code value} as a positive integer, or 0 if it is negative, or {@code defaultValue} if
+   * it cannot be parsed.
    */
   public static int parseSeconds(String value, int defaultValue) {
     try {
diff --git a/okhttp/src/main/java/okhttp3/internal/http/Http1xStream.java b/okhttp/src/main/java/okhttp3/internal/http/Http1xStream.java
index 98e2ab3dfc..39ff4d4781 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/Http1xStream.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/Http1xStream.java
@@ -16,6 +16,9 @@
 
 package okhttp3.internal.http;
 
+import java.io.EOFException;
+import java.io.IOException;
+import java.net.ProtocolException;
 import okhttp3.Headers;
 import okhttp3.Request;
 import okhttp3.Response;
@@ -23,9 +26,6 @@
 import okhttp3.internal.Internal;
 import okhttp3.internal.Util;
 import okhttp3.internal.io.RealConnection;
-import java.io.EOFException;
-import java.io.IOException;
-import java.net.ProtocolException;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -40,23 +40,24 @@
 import static okhttp3.internal.http.StatusLine.HTTP_CONTINUE;
 
 /**
- * A socket connection that can be used to send HTTP/1.1 messages. This class
- * strictly enforces the following lifecycle:
+ * A socket connection that can be used to send HTTP/1.1 messages. This class strictly enforces the
+ * following lifecycle:
+ *
  * <ol>
- *   <li>{@link #writeRequest Send request headers}.
- *   <li>Open a sink to write the request body. Either {@link
- *       #newFixedLengthSink fixed-length} or {@link #newChunkedSink chunked}.
- *   <li>Write to and then close that sink.
- *   <li>{@link #readResponse Read response headers}.
- *   <li>Open a source to read the response body. Either {@link
- *       #newFixedLengthSource fixed-length}, {@link #newChunkedSource chunked}
- *       or {@link #newUnknownLengthSource unknown length}.
- *   <li>Read from and close that source.
+ *     <li>{@linkplain #writeRequest Send request headers}.
+ *     <li>Open a sink to write the request body. Either {@linkplain #newFixedLengthSink
+ *         fixed-length} or {@link #newChunkedSink chunked}.
+ *     <li>Write to and then close that sink.
+ *     <li>{@linkplain #readResponse Read response headers}.
+ *     <li>Open a source to read the response body. Either {@linkplain #newFixedLengthSource
+ *         fixed-length}, {@linkplain #newChunkedSource chunked} or {@linkplain
+ *         #newUnknownLengthSource unknown length}.
+ *     <li>Read from and close that source.
  * </ol>
- * <p>Exchanges that do not have a request body may skip creating and closing
- * the request body. Exchanges that do not have a response body can call {@link
- * #newFixedLengthSource(long) newFixedLengthSource(0)} and may skip reading and
- * closing that source.
+ *
+ * <p>Exchanges that do not have a request body may skip creating and closing the request body.
+ * Exchanges that do not have a response body can call {@link #newFixedLengthSource(long)
+ * newFixedLengthSource(0)} and may skip reading and closing that source.
  */
 public final class Http1xStream implements HttpStream {
   private static final int STATE_IDLE = 0; // Idle connections are ready to write request headers.
@@ -107,19 +108,17 @@ public Http1xStream(StreamAllocation streamAllocation, BufferedSource source, Bu
   /**
    * Prepares the HTTP headers and sends them to the server.
    *
-   * <p>For streaming requests with a body, headers must be prepared
-   * <strong>before</strong> the output stream has been written to. Otherwise
-   * the body would need to be buffered!
+   * <p>For streaming requests with a body, headers must be prepared <strong>before</strong> the
+   * output stream has been written to. Otherwise the body would need to be buffered!
    *
-   * <p>For non-streaming requests with a body, headers must be prepared
-   * <strong>after</strong> the output stream has been written to and closed.
-   * This ensures that the {@code Content-Length} header field receives the
-   * proper value.
+   * <p>For non-streaming requests with a body, headers must be prepared <strong>after</strong> the
+   * output stream has been written to and closed. This ensures that the {@code Content-Length}
+   * header field receives the proper value.
    */
   @Override public void writeRequestHeaders(Request request) throws IOException {
     httpEngine.writingRequestHeaders();
     String requestLine = RequestLine.get(
-        request, httpEngine.getConnection().getRoute().proxy().type());
+        request, httpEngine.getConnection().route().proxy().type());
     writeRequest(request.headers(), requestLine);
   }
 
@@ -165,7 +164,7 @@ public boolean isClosed() {
   public void writeRequest(Headers headers, String requestLine) throws IOException {
     if (state != STATE_IDLE) throw new IllegalStateException("state: " + state);
     sink.writeUtf8(requestLine).writeUtf8("\r\n");
-    for (int i = 0, size = headers.size(); i < size; i ++) {
+    for (int i = 0, size = headers.size(); i < size; i++) {
       sink.writeUtf8(headers.name(i))
           .writeUtf8(": ")
           .writeUtf8(headers.value(i))
@@ -304,9 +303,8 @@ private FixedLengthSink(long bytesRemaining) {
   }
 
   /**
-   * An HTTP body with alternating chunk sizes and chunk bodies. It is the
-   * caller's responsibility to buffer chunks; typically by using a buffered
-   * sink with this sink.
+   * An HTTP body with alternating chunk sizes and chunk bodies. It is the caller's responsibility
+   * to buffer chunks; typically by using a buffered sink with this sink.
    */
   private final class ChunkedSink implements Sink {
     private final ForwardingTimeout timeout = new ForwardingTimeout(sink.timeout());
@@ -349,27 +347,18 @@ private FixedLengthSink(long bytesRemaining) {
     }
 
     /**
-     * Closes the cache entry and makes the socket available for reuse. This
-     * should be invoked when the end of the body has been reached.
+     * Closes the cache entry and makes the socket available for reuse. This should be invoked when
+     * the end of the body has been reached.
      */
-    protected final void endOfInput() throws IOException {
+    protected final void endOfInput(boolean reuseConnection) throws IOException {
+      if (state == STATE_CLOSED) return;
       if (state != STATE_READING_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
 
       detachTimeout(timeout);
 
       state = STATE_CLOSED;
       if (streamAllocation != null) {
-        streamAllocation.streamFinished(Http1xStream.this);
-      }
-    }
-
-    protected final void unexpectedEndOfInput() {
-      if (state == STATE_CLOSED) return;
-
-      state = STATE_CLOSED;
-      if (streamAllocation != null) {
-        streamAllocation.noNewStreams();
-        streamAllocation.streamFinished(Http1xStream.this);
+        streamAllocation.streamFinished(!reuseConnection, Http1xStream.this);
       }
     }
   }
@@ -381,7 +370,7 @@ protected final void unexpectedEndOfInput() {
     public FixedLengthSource(long length) throws IOException {
       bytesRemaining = length;
       if (bytesRemaining == 0) {
-        endOfInput();
+        endOfInput(true);
       }
     }
 
@@ -392,13 +381,13 @@ public FixedLengthSource(long length) throws IOException {
 
       long read = source.read(sink, Math.min(bytesRemaining, byteCount));
       if (read == -1) {
-        unexpectedEndOfInput(); // The server didn't supply the promised content length.
+        endOfInput(false); // The server didn't supply the promised content length.
         throw new ProtocolException("unexpected end of stream");
       }
 
       bytesRemaining -= read;
       if (bytesRemaining == 0) {
-        endOfInput();
+        endOfInput(true);
       }
       return read;
     }
@@ -406,9 +395,8 @@ public FixedLengthSource(long length) throws IOException {
     @Override public void close() throws IOException {
       if (closed) return;
 
-      if (bytesRemaining != 0
-          && !Util.discard(this, DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
-        unexpectedEndOfInput();
+      if (bytesRemaining != 0 && !Util.discard(this, DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
+        endOfInput(false);
       }
 
       closed = true;
@@ -438,7 +426,7 @@ public FixedLengthSource(long length) throws IOException {
 
       long read = source.read(sink, Math.min(byteCount, bytesRemainingInChunk));
       if (read == -1) {
-        unexpectedEndOfInput(); // The server didn't supply the promised chunk length.
+        endOfInput(false); // The server didn't supply the promised chunk length.
         throw new ProtocolException("unexpected end of stream");
       }
       bytesRemainingInChunk -= read;
@@ -463,14 +451,14 @@ private void readChunkSize() throws IOException {
       if (bytesRemainingInChunk == 0L) {
         hasMoreChunks = false;
         httpEngine.receiveHeaders(readHeaders());
-        endOfInput();
+        endOfInput(true);
       }
     }
 
     @Override public void close() throws IOException {
       if (closed) return;
       if (hasMoreChunks && !Util.discard(this, DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
-        unexpectedEndOfInput();
+        endOfInput(false);
       }
       closed = true;
     }
@@ -489,7 +477,7 @@ private void readChunkSize() throws IOException {
       long read = source.read(sink, byteCount);
       if (read == -1) {
         inputExhausted = true;
-        endOfInput();
+        endOfInput(true);
         return -1;
       }
       return read;
@@ -498,7 +486,7 @@ private void readChunkSize() throws IOException {
     @Override public void close() throws IOException {
       if (closed) return;
       if (!inputExhausted) {
-        unexpectedEndOfInput();
+        endOfInput(false);
       }
       closed = true;
     }
diff --git a/okhttp/src/main/java/okhttp3/internal/http/Http2xStream.java b/okhttp/src/main/java/okhttp3/internal/http/Http2xStream.java
index 4dbd4ecabc..2f91dab9b1 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/Http2xStream.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/Http2xStream.java
@@ -16,6 +16,14 @@
 
 package okhttp3.internal.http;
 
+import java.io.IOException;
+import java.net.ProtocolException;
+import java.util.ArrayList;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Locale;
+import java.util.Set;
+import java.util.concurrent.TimeUnit;
 import okhttp3.Headers;
 import okhttp3.Protocol;
 import okhttp3.Request;
@@ -26,14 +34,6 @@
 import okhttp3.internal.framed.FramedConnection;
 import okhttp3.internal.framed.FramedStream;
 import okhttp3.internal.framed.Header;
-import java.io.IOException;
-import java.net.ProtocolException;
-import java.util.ArrayList;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Locale;
-import java.util.Set;
-import java.util.concurrent.TimeUnit;
 import okio.ByteString;
 import okio.ForwardingSource;
 import okio.Okio;
@@ -133,8 +133,8 @@ public Http2xStream(StreamAllocation streamAllocation, FramedConnection framedCo
         : spdy3HeadersList(request);
     boolean hasResponseBody = true;
     stream = framedConnection.newStream(requestHeaders, permitsRequestBody, hasResponseBody);
-    stream.readTimeout().timeout(httpEngine.client.getReadTimeout(), TimeUnit.MILLISECONDS);
-    stream.writeTimeout().timeout(httpEngine.client.getWriteTimeout(), TimeUnit.MILLISECONDS);
+    stream.readTimeout().timeout(httpEngine.client.readTimeoutMillis(), TimeUnit.MILLISECONDS);
+    stream.writeTimeout().timeout(httpEngine.client.writeTimeoutMillis(), TimeUnit.MILLISECONDS);
   }
 
   @Override public void writeRequestBody(RetryableSink requestBody) throws IOException {
@@ -152,9 +152,9 @@ public Http2xStream(StreamAllocation streamAllocation, FramedConnection framedCo
   }
 
   /**
-   * Returns a list of alternating names and values containing a SPDY request.
-   * Names are all lowercase. No names are repeated. If any name has multiple
-   * values, they are concatenated using "\0" as a delimiter.
+   * Returns a list of alternating names and values containing a SPDY request. Names are all
+   * lowercase. No names are repeated. If any name has multiple values, they are concatenated using
+   * "\0" as a delimiter.
    */
   public static List<Header> spdy3HeadersList(Request request) {
     Headers headers = request.headers();
@@ -289,7 +289,7 @@ public StreamFinishingSource(Source delegate) {
     }
 
     @Override public void close() throws IOException {
-      streamAllocation.streamFinished(Http2xStream.this);
+      streamAllocation.streamFinished(false, Http2xStream.this);
       super.close();
     }
   }
diff --git a/okhttp/src/main/java/okhttp3/internal/http/HttpDate.java b/okhttp/src/main/java/okhttp3/internal/http/HttpDate.java
index 99411fb92e..b411a17f52 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/HttpDate.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/HttpDate.java
@@ -21,14 +21,15 @@
 import java.text.SimpleDateFormat;
 import java.util.Date;
 import java.util.Locale;
-import java.util.TimeZone;
+
+import static okhttp3.internal.Util.UTC;
 
 /**
  * Best-effort parser for HTTP dates.
  */
 public final class HttpDate {
-
-  private static final TimeZone GMT = TimeZone.getTimeZone("GMT");
+  /** The last four-digit year: "Fri, 31 Dec 9999 23:59:59 GMT". */
+  public static final long MAX_DATE = 253402300799999L;
 
   /**
    * Most websites serve cookies in the blessed format. Eagerly create the parser to ensure such
@@ -40,7 +41,7 @@
           // RFC 2616 specified: RFC 822, updated by RFC 1123 format with fixed GMT.
           DateFormat rfc1123 = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss 'GMT'", Locale.US);
           rfc1123.setLenient(false);
-          rfc1123.setTimeZone(GMT);
+          rfc1123.setTimeZone(UTC);
           return rfc1123;
         }
       };
@@ -51,7 +52,7 @@
       "EEE, dd MMM yyyy HH:mm:ss zzz", // RFC 822, updated by RFC 1123 with any TZ
       "EEEE, dd-MMM-yy HH:mm:ss zzz", // RFC 850, obsoleted by RFC 1036 with any TZ.
       "EEE MMM d HH:mm:ss yyyy", // ANSI C's asctime() format
-       // Alternative formats.
+      // Alternative formats.
       "EEE, dd-MMM-yyyy HH:mm:ss z",
       "EEE, dd-MMM-yyyy HH-mm-ss z",
       "EEE, dd MMM yy HH:mm:ss z",
@@ -91,7 +92,7 @@ public static Date parse(String value) {
           format = new SimpleDateFormat(BROWSER_COMPATIBLE_DATE_FORMAT_STRINGS[i], Locale.US);
           // Set the timezone to use when interpreting formats that don't have a timezone. GMT is
           // specified by RFC 2616.
-          format.setTimeZone(GMT);
+          format.setTimeZone(UTC);
           BROWSER_COMPATIBLE_DATE_FORMATS[i] = format;
         }
         position.setIndex(0);
diff --git a/okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java b/okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java
index cdd6722cbb..a352bb64c8 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java
@@ -18,17 +18,17 @@
 package okhttp3.internal.http;
 
 import java.io.IOException;
-import java.net.CookieHandler;
 import java.net.ProtocolException;
 import java.net.Proxy;
 import java.util.Date;
 import java.util.List;
-import java.util.Map;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLSocketFactory;
 import okhttp3.Address;
 import okhttp3.CertificatePinner;
 import okhttp3.Connection;
+import okhttp3.Cookie;
+import okhttp3.CookieJar;
 import okhttp3.Headers;
 import okhttp3.HttpUrl;
 import okhttp3.Interceptor;
@@ -68,22 +68,15 @@
 import static okhttp3.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
 
 /**
- * Handles a single HTTP request/response pair. Each HTTP engine follows this
- * lifecycle:
- * <ol>
- * <li>It is created.
- * <li>The HTTP request message is sent with sendRequest(). Once the request
- * is sent it is an error to modify the request headers. After
- * sendRequest() has been called the request body can be written to if
- * it exists.
- * <li>The HTTP response message is read with readResponse(). After the
- * response has been read the response headers and body can be read.
- * All responses have a response body input stream, though in some
- * instances this stream is empty.
- * </ol>
+ * Handles a single HTTP request/response pair. Each HTTP engine follows this lifecycle: <ol> <li>It
+ * is created. <li>The HTTP request message is sent with sendRequest(). Once the request is sent it
+ * is an error to modify the request headers. After sendRequest() has been called the request body
+ * can be written to if it exists. <li>The HTTP response message is read with readResponse(). After
+ * the response has been read the response headers and body can be read. All responses have a
+ * response body input stream, though in some instances this stream is empty. </ol>
  *
- * <p>The request and response may be served by the HTTP response cache, by the
- * network, or by both in the event of a conditional GET.
+ * <p>The request and response may be served by the HTTP response cache, by the network, or by both
+ * in the event of a conditional GET.
  */
 public final class HttpEngine {
   /**
@@ -96,9 +89,11 @@
     @Override public MediaType contentType() {
       return null;
     }
+
     @Override public long contentLength() {
       return 0;
     }
+
     @Override public BufferedSource source() {
       return new Buffer();
     }
@@ -114,43 +109,40 @@
   long sentRequestMillis = -1;
 
   /**
-   * True if this client added an "Accept-Encoding: gzip" header field and is
-   * therefore responsible for also decompressing the transfer stream.
+   * True if this client added an "Accept-Encoding: gzip" header field and is therefore responsible
+   * for also decompressing the transfer stream.
    */
   private boolean transparentGzip;
 
   /**
-   * True if the request body must be completely buffered before transmission;
-   * false if it can be streamed. Buffering has two advantages: we don't need
-   * the content-length in advance and we can retransmit if necessary. The
-   * upside of streaming is that we can save memory.
+   * True if the request body must be completely buffered before transmission; false if it can be
+   * streamed. Buffering has two advantages: we don't need the content-length in advance and we can
+   * retransmit if necessary. The upside of streaming is that we can save memory.
    */
   public final boolean bufferRequestBody;
 
   /**
-   * The original application-provided request. Never modified by OkHttp. When
-   * follow-up requests are necessary, they are derived from this request.
+   * The original application-provided request. Never modified by OkHttp. When follow-up requests
+   * are necessary, they are derived from this request.
    */
   private final Request userRequest;
 
   /**
-   * The request to send on the network, or null for no network request. This is
-   * derived from the user request, and customized to support OkHttp features
-   * like compression and caching.
+   * The request to send on the network, or null for no network request. This is derived from the
+   * user request, and customized to support OkHttp features like compression and caching.
    */
   private Request networkRequest;
 
   /**
-   * The cached response, or null if the cache doesn't exist or cannot be used
-   * for this request. Conditional caching means this may be non-null even when
-   * the network request is non-null. Never modified by OkHttp.
+   * The cached response, or null if the cache doesn't exist or cannot be used for this request.
+   * Conditional caching means this may be non-null even when the network request is non-null. Never
+   * modified by OkHttp.
    */
   private Response cacheResponse;
 
   /**
-   * The user-visible response. This is derived from either the network
-   * response, cache response, or both. It is customized to support OkHttp
-   * features like compression and caching.
+   * The user-visible response. This is derived from either the network response, cache response, or
+   * both. It is customized to support OkHttp features like compression and caching.
    */
   private Response userResponse;
 
@@ -165,10 +157,10 @@
 
   /**
    * @param request the HTTP request without a body. The body must be written via the engine's
-   *     request body stream.
-   * @param callerWritesRequestBody true for the {@code HttpURLConnection}-style interaction
-   *     model where control flow is returned to the calling application to write the request body
-   *     before the response body is readable.
+   * request body stream.
+   * @param callerWritesRequestBody true for the {@code HttpURLConnection}-style interaction model
+   * where control flow is returned to the calling application to write the request body before the
+   * response body is readable.
    */
   public HttpEngine(OkHttpClient client, Request request, boolean bufferRequestBody,
       boolean callerWritesRequestBody, boolean forWebSocket, StreamAllocation streamAllocation,
@@ -180,22 +172,20 @@ public HttpEngine(OkHttpClient client, Request request, boolean bufferRequestBod
     this.forWebSocket = forWebSocket;
     this.streamAllocation = streamAllocation != null
         ? streamAllocation
-        : new StreamAllocation(client.getConnectionPool(), createAddress(client, request));
+        : new StreamAllocation(client.connectionPool(), createAddress(client, request));
     this.requestBodyOut = requestBodyOut;
     this.priorResponse = priorResponse;
   }
 
   /**
-   * Figures out what the response source will be, and opens a socket to that
-   * source if necessary. Prepares the request headers and gets ready to start
-   * writing the request body if it exists.
+   * Figures out what the response source will be, and opens a socket to that source if necessary.
+   * Prepares the request headers and gets ready to start writing the request body if it exists.
    *
    * @throws RequestException if there was a problem with request setup. Unrecoverable.
    * @throws RouteException if the was a problem during connection via a specific route. Sometimes
-   *     recoverable. See {@link #recover(RouteException)}.
+   * recoverable. See {@link #recover}.
    * @throws IOException if there was a problem while making a request. Sometimes recoverable. See
-   *     {@link #recover(IOException)}.
-   *
+   * {@link #recover(IOException)}.
    */
   public void sendRequest() throws RequestException, RouteException, IOException {
     if (cacheStrategy != null) return; // Already sent.
@@ -221,15 +211,37 @@ public void sendRequest() throws RequestException, RouteException, IOException {
       closeQuietly(cacheCandidate.body()); // The cache candidate wasn't applicable. Close it.
     }
 
-    if (networkRequest != null) {
+    // If we're forbidden from using the network and the cache is insufficient, fail.
+    if (networkRequest == null && cacheResponse == null) {
+      userResponse = new Response.Builder()
+          .request(userRequest)
+          .priorResponse(stripBody(priorResponse))
+          .protocol(Protocol.HTTP_1_1)
+          .code(504)
+          .message("Unsatisfiable Request (only-if-cached)")
+          .body(EMPTY_BODY)
+          .build();
+      return;
+    }
+
+    // If we don't need the network, we're done.
+    if (networkRequest == null) {
+      userResponse = cacheResponse.newBuilder()
+          .request(userRequest)
+          .priorResponse(stripBody(priorResponse))
+          .cacheResponse(stripBody(cacheResponse))
+          .build();
+      userResponse = unzip(userResponse);
+      return;
+    }
+
+    // We need the network to satisfy this request. Possibly for validating a conditional GET.
+    boolean success = false;
+    try {
       httpStream = connect();
       httpStream.setHttpEngine(this);
 
-      // If the caller's control flow writes the request body, we need to create that stream
-      // immediately. And that means we need to immediately write the request headers, so we can
-      // start streaming the request body. (We may already have a request body if we're retrying a
-      // failed POST.)
-      if (callerWritesRequestBody && permitsRequestBody(networkRequest) && requestBodyOut == null) {
+      if (writeRequestHeadersEagerly()) {
         long contentLength = OkHeaders.contentLength(request);
         if (bufferRequestBody) {
           if (contentLength > Integer.MAX_VALUE) {
@@ -242,9 +254,8 @@ public void sendRequest() throws RequestException, RouteException, IOException {
             httpStream.writeRequestHeaders(networkRequest);
             requestBodyOut = new RetryableSink((int) contentLength);
           } else {
-            // Buffer a request body of an unknown length. Don't write request
-            // headers until the entire body is ready; otherwise we can't set the
-            // Content-Length header correctly.
+            // Buffer a request body of an unknown length. Don't write request headers until the
+            // entire body is ready; otherwise we can't set the Content-Length header correctly.
             requestBodyOut = new RetryableSink();
           }
         } else {
@@ -252,38 +263,32 @@ public void sendRequest() throws RequestException, RouteException, IOException {
           requestBodyOut = httpStream.createRequestBody(networkRequest, contentLength);
         }
       }
-
-    } else {
-      streamAllocation.release();
-
-      if (cacheResponse != null) {
-        // We have a valid cached response. Promote it to the user response immediately.
-        this.userResponse = cacheResponse.newBuilder()
-            .request(userRequest)
-            .priorResponse(stripBody(priorResponse))
-            .cacheResponse(stripBody(cacheResponse))
-            .build();
-      } else {
-        // We're forbidden from using the network, and the cache is insufficient.
-        this.userResponse = new Response.Builder()
-            .request(userRequest)
-            .priorResponse(stripBody(priorResponse))
-            .protocol(Protocol.HTTP_1_1)
-            .code(504)
-            .message("Unsatisfiable Request (only-if-cached)")
-            .body(EMPTY_BODY)
-            .build();
+      success = true;
+    } finally {
+      // If we're crashing on I/O or otherwise, don't leak the cache body.
+      if (!success && cacheCandidate != null) {
+        closeQuietly(cacheCandidate.body());
       }
-
-      userResponse = unzip(userResponse);
     }
   }
 
+  /**
+   * If the caller's control flow writes the request body, we need to create that stream
+   * immediately. And that means we need to immediately write the request headers, so we can
+   * start streaming the request body. (We may already have a request body if we're retrying a
+   * failed POST.)
+   */
+  private boolean writeRequestHeadersEagerly() {
+    return callerWritesRequestBody
+        && permitsRequestBody(networkRequest)
+        && requestBodyOut == null;
+  }
+
   private HttpStream connect() throws RouteException, RequestException, IOException {
     boolean doExtensiveHealthChecks = !networkRequest.method().equals("GET");
-    return streamAllocation.newStream(client.getConnectTimeout(),
-        client.getReadTimeout(), client.getWriteTimeout(),
-        client.getRetryOnConnectionFailure(), doExtensiveHealthChecks);
+    return streamAllocation.newStream(client.connectTimeoutMillis(),
+        client.readTimeoutMillis(), client.writeTimeoutMillis(),
+        client.retryOnConnectionFailure(), doExtensiveHealthChecks);
   }
 
   private static Response stripBody(Response response) {
@@ -292,10 +297,9 @@ private static Response stripBody(Response response) {
         : response;
   }
 
-
   /**
-   * Called immediately before the transport transmits HTTP request headers.
-   * This is used to observe the sent time should the request be cached.
+   * Called immediately before the transport transmits HTTP request headers. This is used to observe
+   * the sent time should the request be cached.
    */
   public void writingRequestHeaders() {
     if (sentRequestMillis != -1) throw new IllegalStateException();
@@ -341,38 +345,16 @@ public Connection getConnection() {
   }
 
   /**
-   * Attempt to recover from failure to connect via a route. Returns a new HTTP engine
-   * that should be used for the retry if there are other routes to try, or null if
-   * there are no more routes to try.
-   */
-  public HttpEngine recover(RouteException e) {
-    if (!streamAllocation.recover(e)) {
-      return null;
-    }
-
-    if (!client.getRetryOnConnectionFailure()) {
-      return null;
-    }
-
-    StreamAllocation streamAllocation = close();
-
-    // For failure recovery, use the same route selector with a new connection.
-    return new HttpEngine(client, userRequest, bufferRequestBody, callerWritesRequestBody,
-        forWebSocket, streamAllocation, (RetryableSink) requestBodyOut, priorResponse);
-  }
-
-  /**
-   * Report and attempt to recover from a failure to communicate with a server. Returns a new
-   * HTTP engine that should be used for the retry if {@code e} is recoverable, or null if
-   * the failure is permanent. Requests with a body can only be recovered if the
-   * body is buffered.
+   * Report and attempt to recover from a failure to communicate with a server. Returns a new HTTP
+   * engine that should be used for the retry if {@code e} is recoverable, or null if the failure is
+   * permanent. Requests with a body can only be recovered if the body is buffered.
    */
   public HttpEngine recover(IOException e, Sink requestBodyOut) {
     if (!streamAllocation.recover(e, requestBodyOut)) {
       return null;
     }
 
-    if (!client.getRetryOnConnectionFailure()) {
+    if (!client.retryOnConnectionFailure()) {
       return null;
     }
 
@@ -408,9 +390,8 @@ private void maybeCache() throws IOException {
   }
 
   /**
-   * Configure the socket connection to be either pooled or closed when it is
-   * either exhausted or closed. If it is unneeded when this is called, it will
-   * be released immediately.
+   * Configure the socket connection to be either pooled or closed when it is either exhausted or
+   * closed. If it is unneeded when this is called, it will be released immediately.
    */
   public void releaseStreamAllocation() throws IOException {
     streamAllocation.release();
@@ -445,7 +426,7 @@ public StreamAllocation close() {
       closeQuietly(userResponse.body());
     } else {
       // If this engine never achieved a response body, its stream allocation is dead.
-      streamAllocation.connectionFailed();
+      streamAllocation.connectionFailed(null);
     }
 
     return streamAllocation;
@@ -485,8 +466,7 @@ private Response unzip(final Response response) throws IOException {
   }
 
   /**
-   * Returns true if the response must have a (possibly 0-length) body.
-   * See RFC 2616 section 4.3.
+   * Returns true if the response must have a (possibly 0-length) body. See RFC 2616 section 4.3.
    */
   public static boolean hasBody(Response response) {
     // HEAD requests never yield a body regardless of the response headers.
@@ -515,8 +495,8 @@ public static boolean hasBody(Response response) {
   /**
    * Populates request with defaults and cookies.
    *
-   * <p>This client doesn't specify a default {@code Accept} header because it
-   * doesn't know what content types the application is interested in.
+   * <p>This client doesn't specify a default {@code Accept} header because it doesn't know what
+   * content types the application is interested in.
    */
   private Request networkRequest(Request request) throws IOException {
     Request.Builder result = request.newBuilder();
@@ -534,17 +514,9 @@ private Request networkRequest(Request request) throws IOException {
       result.header("Accept-Encoding", "gzip");
     }
 
-    CookieHandler cookieHandler = client.getCookieHandler();
-    if (cookieHandler != null) {
-      // Capture the request headers added so far so that they can be offered to the CookieHandler.
-      // This is mostly to stay close to the RI; it is unlikely any of the headers above would
-      // affect cookie choice besides "Host".
-      Map<String, List<String>> headers = OkHeaders.toMultimap(result.build().headers(), null);
-
-      Map<String, List<String>> cookies = cookieHandler.get(request.url().uri(), headers);
-
-      // Add any new cookies to the request.
-      OkHeaders.addCookies(result, cookies);
+    List<Cookie> cookies = client.cookieJar().loadForRequest(request.url());
+    if (!cookies.isEmpty()) {
+      result.header("Cookie", cookieHeader(cookies));
     }
 
     if (request.header("User-Agent") == null) {
@@ -554,9 +526,22 @@ private Request networkRequest(Request request) throws IOException {
     return result.build();
   }
 
+  /** Returns a 'Cookie' HTTP request header with all cookies, like {@code a=b; c=d}. */
+  private String cookieHeader(List<Cookie> cookies) {
+    StringBuilder cookieHeader = new StringBuilder();
+    for (int i = 0, size = cookies.size(); i < size; i++) {
+      if (i > 0) {
+        cookieHeader.append("; ");
+      }
+      Cookie cookie = cookies.get(i);
+      cookieHeader.append(cookie.name()).append('=').append(cookie.value());
+    }
+    return cookieHeader.toString();
+  }
+
   /**
-   * Flushes the remaining request header and body, parses the HTTP response
-   * headers and starts reading the HTTP response body if it exists.
+   * Flushes the remaining request header and body, parses the HTTP response headers and starts
+   * reading the HTTP response body if it exists.
    */
   public void readResponse() throws IOException {
     if (userResponse != null) {
@@ -574,10 +559,8 @@ public void readResponse() throws IOException {
     if (forWebSocket) {
       httpStream.writeRequestHeaders(networkRequest);
       networkResponse = readNetworkResponse();
-
     } else if (!callerWritesRequestBody) {
       networkResponse = new NetworkInterceptorChain(0, networkRequest).proceed(networkRequest);
-
     } else {
       // Emit the request body's buffer so that everything is in requestBodyOut.
       if (bufferedRequestBody != null && bufferedRequestBody.buffer().size() > 0) {
@@ -675,7 +658,7 @@ public void readResponse() throws IOException {
 
       if (index > 0) {
         Interceptor caller = client.networkInterceptors().get(index - 1);
-        Address address = connection().getRoute().address();
+        Address address = connection().route().address();
 
         // Confirm that the interceptor uses the connection we've already prepared.
         if (!request.url().host().equals(address.url().host())
@@ -739,7 +722,7 @@ private Response readNetworkResponse() throws IOException {
 
     Response networkResponse = httpStream.readResponseHeaders()
         .request(networkRequest)
-        .handshake(streamAllocation.connection().getHandshake())
+        .handshake(streamAllocation.connection().handshake())
         .header(OkHeaders.SENT_MILLIS, Long.toString(sentRequestMillis))
         .header(OkHeaders.RECEIVED_MILLIS, Long.toString(System.currentTimeMillis()))
         .build();
@@ -821,8 +804,8 @@ private Response cacheWritingResponse(final CacheRequest cacheRequest, Response
   }
 
   /**
-   * Returns true if {@code cached} should be used; false if {@code network}
-   * response should be used.
+   * Returns true if {@code cached} should be used; false if {@code network} response should be
+   * used.
    */
   private static boolean validate(Response cached, Response network) {
     if (network.code() == HTTP_NOT_MODIFIED) {
@@ -845,8 +828,7 @@ private static boolean validate(Response cached, Response network) {
   }
 
   /**
-   * Combines cached headers with a network headers as defined by RFC 2616,
-   * 13.5.3.
+   * Combines cached headers with a network headers as defined by RFC 2616, 13.5.3.
    */
   private static Headers combine(Headers cachedHeaders, Headers networkHeaders) throws IOException {
     Headers.Builder result = new Headers.Builder();
@@ -876,22 +858,24 @@ private static Headers combine(Headers cachedHeaders, Headers networkHeaders) th
   }
 
   public void receiveHeaders(Headers headers) throws IOException {
-    CookieHandler cookieHandler = client.getCookieHandler();
-    if (cookieHandler != null) {
-      cookieHandler.put(userRequest.url().uri(), OkHeaders.toMultimap(headers, null));
-    }
+    if (client.cookieJar() == CookieJar.NO_COOKIES) return;
+
+    List<Cookie> cookies = Cookie.parseAll(userRequest.url(), headers);
+    if (cookies.isEmpty()) return;
+
+    client.cookieJar().saveFromResponse(userRequest.url(), cookies);
   }
 
   /**
-   * Figures out the HTTP request to make in response to receiving this engine's
-   * response. This will either add authentication headers or follow redirects.
-   * If a follow-up is either unnecessary or not applicable, this returns null.
+   * Figures out the HTTP request to make in response to receiving this engine's response. This will
+   * either add authentication headers or follow redirects. If a follow-up is either unnecessary or
+   * not applicable, this returns null.
    */
   public Request followUpRequest() throws IOException {
     if (userResponse == null) throw new IllegalStateException();
     Connection connection = streamAllocation.connection();
     Route route = connection != null
-        ? connection.getRoute()
+        ? connection.route()
         : null;
     int responseCode = userResponse.code();
 
@@ -900,20 +884,20 @@ public Request followUpRequest() throws IOException {
       case HTTP_PROXY_AUTH:
         Proxy selectedProxy = route != null
             ? route.proxy()
-            : client.getProxy();
+            : client.proxy();
         if (selectedProxy.type() != Proxy.Type.HTTP) {
           throw new ProtocolException("Received HTTP_PROXY_AUTH (407) code while not using proxy");
         }
         // fall-through
       case HTTP_UNAUTHORIZED:
-        return client.getAuthenticator().authenticate(route, userResponse);
+        return client.authenticator().authenticate(route, userResponse);
 
       case HTTP_PERM_REDIRECT:
       case HTTP_TEMP_REDIRECT:
         // "If the 307 or 308 status code is received in response to a request other than GET
         // or HEAD, the user agent MUST NOT automatically redirect the request"
         if (!method.equals("GET") && !method.equals("HEAD")) {
-            return null;
+          return null;
         }
         // fall-through
       case HTTP_MULT_CHOICE:
@@ -921,7 +905,7 @@ public Request followUpRequest() throws IOException {
       case HTTP_MOVED_TEMP:
       case HTTP_SEE_OTHER:
         // Does the client allow redirects?
-        if (!client.getFollowRedirects()) return null;
+        if (!client.followRedirects()) return null;
 
         String location = userResponse.header("Location");
         if (location == null) return null;
@@ -932,7 +916,7 @@ public Request followUpRequest() throws IOException {
 
         // If configured, don't follow redirects between SSL and non-SSL.
         boolean sameScheme = url.scheme().equals(userRequest.url().scheme());
-        if (!sameScheme && !client.getFollowSslRedirects()) return null;
+        if (!sameScheme && !client.followSslRedirects()) return null;
 
         // Redirects don't include a request body.
         Request.Builder requestBuilder = userRequest.newBuilder();
@@ -962,8 +946,8 @@ public Request followUpRequest() throws IOException {
   }
 
   /**
-   * Returns true if an HTTP request for {@code followUp} can reuse the
-   * connection used by this engine.
+   * Returns true if an HTTP request for {@code followUp} can reuse the connection used by this
+   * engine.
    */
   public boolean sameConnection(HttpUrl followUp) {
     HttpUrl url = userRequest.url();
@@ -977,14 +961,14 @@ private static Address createAddress(OkHttpClient client, Request request) {
     HostnameVerifier hostnameVerifier = null;
     CertificatePinner certificatePinner = null;
     if (request.isHttps()) {
-      sslSocketFactory = client.getSslSocketFactory();
-      hostnameVerifier = client.getHostnameVerifier();
-      certificatePinner = client.getCertificatePinner();
+      sslSocketFactory = client.sslSocketFactory();
+      hostnameVerifier = client.hostnameVerifier();
+      certificatePinner = client.certificatePinner();
     }
 
-    return new Address(request.url().host(), request.url().port(), client.getDns(),
-        client.getSocketFactory(), sslSocketFactory, hostnameVerifier, certificatePinner,
-        client.getProxyAuthenticator(), client.getProxy(), client.getProtocols(),
-        client.getConnectionSpecs(), client.getProxySelector());
+    return new Address(request.url().host(), request.url().port(), client.dns(),
+        client.socketFactory(), sslSocketFactory, hostnameVerifier, certificatePinner,
+        client.proxyAuthenticator(), client.proxy(), client.protocols(),
+        client.connectionSpecs(), client.proxySelector());
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/http/HttpStream.java b/okhttp/src/main/java/okhttp3/internal/http/HttpStream.java
index 147197a032..d5fc94c7b8 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/HttpStream.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/HttpStream.java
@@ -16,17 +16,17 @@
 
 package okhttp3.internal.http;
 
+import java.io.IOException;
 import okhttp3.Request;
 import okhttp3.Response;
 import okhttp3.ResponseBody;
-import java.io.IOException;
 import okio.Sink;
 
 public interface HttpStream {
   /**
-   * The timeout to use while discarding a stream of input data. Since this is
-   * used for connection reuse, this timeout should be significantly less than
-   * the time it takes to establish a new connection.
+   * The timeout to use while discarding a stream of input data. Since this is used for connection
+   * reuse, this timeout should be significantly less than the time it takes to establish a new
+   * connection.
    */
   int DISCARD_STREAM_TIMEOUT_MILLIS = 100;
 
@@ -37,8 +37,7 @@
   void writeRequestHeaders(Request request) throws IOException;
 
   /**
-   * Sends the request body returned by {@link #createRequestBody} to the
-   * remote peer.
+   * Sends the request body returned by {@link #createRequestBody} to the remote peer.
    */
   void writeRequestBody(RetryableSink requestBody) throws IOException;
 
diff --git a/okhttp/src/main/java/okhttp3/internal/http/OkHeaders.java b/okhttp/src/main/java/okhttp3/internal/http/OkHeaders.java
index a8316c0f00..db8011c542 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/OkHeaders.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/OkHeaders.java
@@ -1,12 +1,24 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package okhttp3.internal.http;
 
 import java.util.ArrayList;
 import java.util.Collections;
-import java.util.Comparator;
 import java.util.List;
-import java.util.Map;
 import java.util.Set;
-import java.util.TreeMap;
 import java.util.TreeSet;
 import okhttp3.Challenge;
 import okhttp3.Headers;
@@ -19,20 +31,6 @@
 
 /** Headers and utilities for internal use by OkHttp. */
 public final class OkHeaders {
-  private static final Comparator<String> FIELD_NAME_COMPARATOR = new Comparator<String>() {
-    // @FindBugsSuppressWarnings("ES_COMPARING_PARAMETER_STRING_WITH_EQ")
-    @Override public int compare(String a, String b) {
-      if (a == b) {
-        return 0;
-      } else if (a == null) {
-        return -1;
-      } else if (b == null) {
-        return 1;
-      } else {
-        return String.CASE_INSENSITIVE_ORDER.compare(a, b);
-      }
-    }
-  };
 
   static final String PREFIX = Platform.get().getPrefix();
 
@@ -47,8 +45,8 @@
   public static final String RECEIVED_MILLIS = PREFIX + "-Received-Millis";
 
   /**
-   * Synthetic response header: the selected
-   * {@link Protocol protocol} ("spdy/3.1", "http/1.1", etc).
+   * Synthetic response header: the selected {@link Protocol protocol} ("spdy/3.1", "http/1.1",
+   * etc).
    */
   public static final String SELECTED_PROTOCOL = PREFIX + "-Selected-Protocol";
 
@@ -80,58 +78,8 @@ private static long stringToLong(String s) {
   }
 
   /**
-   * Returns an immutable map containing each field to its list of values.
-   *
-   * @param valueForNullKey the request line for requests, or the status line
-   *     for responses. If non-null, this value is mapped to the null key.
-   */
-  public static Map<String, List<String>> toMultimap(Headers headers, String valueForNullKey) {
-    Map<String, List<String>> result = new TreeMap<>(FIELD_NAME_COMPARATOR);
-    for (int i = 0, size = headers.size(); i < size; i++) {
-      String fieldName = headers.name(i);
-      String value = headers.value(i);
-
-      List<String> allValues = new ArrayList<>();
-      List<String> otherValues = result.get(fieldName);
-      if (otherValues != null) {
-        allValues.addAll(otherValues);
-      }
-      allValues.add(value);
-      result.put(fieldName, Collections.unmodifiableList(allValues));
-    }
-    if (valueForNullKey != null) {
-      result.put(null, Collections.unmodifiableList(Collections.singletonList(valueForNullKey)));
-    }
-    return Collections.unmodifiableMap(result);
-  }
-
-  public static void addCookies(Request.Builder builder, Map<String, List<String>> cookieHeaders) {
-    for (Map.Entry<String, List<String>> entry : cookieHeaders.entrySet()) {
-      String key = entry.getKey();
-      if (("Cookie".equalsIgnoreCase(key) || "Cookie2".equalsIgnoreCase(key))
-          && !entry.getValue().isEmpty()) {
-        builder.addHeader(key, buildCookieHeader(entry.getValue()));
-      }
-    }
-  }
-
-  /**
-   * Send all cookies in one big header, as recommended by
-   * <a href="http://tools.ietf.org/html/rfc6265#section-4.2.1">RFC 6265</a>.
-   */
-  private static String buildCookieHeader(List<String> cookies) {
-    if (cookies.size() == 1) return cookies.get(0);
-    StringBuilder sb = new StringBuilder();
-    for (int i = 0, size = cookies.size(); i < size; i++) {
-      if (i > 0) sb.append("; ");
-      sb.append(cookies.get(i));
-    }
-    return sb.toString();
-  }
-
-  /**
-   * Returns true if none of the Vary headers have changed between {@code
-   * cachedRequest} and {@code newRequest}.
+   * Returns true if none of the Vary headers have changed between {@code cachedRequest} and {@code
+   * newRequest}.
    */
   public static boolean varyMatches(
       Response cachedResponse, Headers cachedRequest, Request newRequest) {
@@ -142,16 +90,14 @@ public static boolean varyMatches(
   }
 
   /**
-   * Returns true if a Vary header contains an asterisk. Such responses cannot
-   * be cached.
+   * Returns true if a Vary header contains an asterisk. Such responses cannot be cached.
    */
   public static boolean hasVaryAll(Response response) {
     return hasVaryAll(response.headers());
   }
 
   /**
-   * Returns true if a Vary header contains an asterisk. Such responses cannot
-   * be cached.
+   * Returns true if a Vary header contains an asterisk. Such responses cannot be cached.
    */
   public static boolean hasVaryAll(Headers responseHeaders) {
     return varyFields(responseHeaders).contains("*");
@@ -162,8 +108,7 @@ public static boolean hasVaryAll(Headers responseHeaders) {
   }
 
   /**
-   * Returns the names of the request headers that need to be checked for
-   * equality when caching.
+   * Returns the names of the request headers that need to be checked for equality when caching.
    */
   public static Set<String> varyFields(Headers responseHeaders) {
     Set<String> result = Collections.emptySet();
@@ -182,8 +127,8 @@ public static boolean hasVaryAll(Headers responseHeaders) {
   }
 
   /**
-   * Returns the subset of the headers in {@code response}'s request that
-   * impact the content of response's body.
+   * Returns the subset of the headers in {@code response}'s request that impact the content of
+   * response's body.
    */
   public static Headers varyHeaders(Response response) {
     // Use the request headers sent over the network, since that's what the
@@ -195,8 +140,8 @@ public static Headers varyHeaders(Response response) {
   }
 
   /**
-   * Returns the subset of the headers in {@code requestHeaders} that
-   * impact the content of response's body.
+   * Returns the subset of the headers in {@code requestHeaders} that impact the content of
+   * response's body.
    */
   public static Headers varyHeaders(Headers requestHeaders, Headers responseHeaders) {
     Set<String> varyFields = varyFields(responseHeaders);
@@ -213,8 +158,8 @@ public static Headers varyHeaders(Headers requestHeaders, Headers responseHeader
   }
 
   /**
-   * Returns true if {@code fieldName} is an end-to-end HTTP header, as
-   * defined by RFC 2616, 13.5.1.
+   * Returns true if {@code fieldName} is an end-to-end HTTP header, as defined by RFC 2616,
+   * 13.5.1.
    */
   static boolean isEndToEnd(String fieldName) {
     return !"Connection".equalsIgnoreCase(fieldName)
@@ -228,8 +173,7 @@ static boolean isEndToEnd(String fieldName) {
   }
 
   /**
-   * Parse RFC 2617 challenges. This API is only interested in the scheme
-   * name and realm.
+   * Parse RFC 2617 challenges. This API is only interested in the scheme name and realm.
    */
   public static List<Challenge> parseChallenges(Headers responseHeaders, String challengeHeader) {
     // auth-scheme = token
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RequestLine.java b/okhttp/src/main/java/okhttp3/internal/http/RequestLine.java
index 756524a591..ff2bc5598f 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/RequestLine.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/RequestLine.java
@@ -1,18 +1,18 @@
 package okhttp3.internal.http;
 
-import okhttp3.HttpUrl;
-import okhttp3.Request;
 import java.net.HttpURLConnection;
 import java.net.Proxy;
+import okhttp3.HttpUrl;
+import okhttp3.Request;
 
 public final class RequestLine {
   private RequestLine() {
   }
 
   /**
-   * Returns the request status line, like "GET / HTTP/1.1". This is exposed
-   * to the application by {@link HttpURLConnection#getHeaderFields}, so it
-   * needs to be set even if the transport is SPDY.
+   * Returns the request status line, like "GET / HTTP/1.1". This is exposed to the application by
+   * {@link HttpURLConnection#getHeaderFields}, so it needs to be set even if the transport is
+   * SPDY.
    */
   static String get(Request request, Proxy.Type proxyType) {
     StringBuilder result = new StringBuilder();
@@ -30,17 +30,16 @@ static String get(Request request, Proxy.Type proxyType) {
   }
 
   /**
-   * Returns true if the request line should contain the full URL with host
-   * and port (like "GET http://android.com/foo HTTP/1.1") or only the path
-   * (like "GET /foo HTTP/1.1").
+   * Returns true if the request line should contain the full URL with host and port (like "GET
+   * http://android.com/foo HTTP/1.1") or only the path (like "GET /foo HTTP/1.1").
    */
   private static boolean includeAuthorityInRequestLine(Request request, Proxy.Type proxyType) {
     return !request.isHttps() && proxyType == Proxy.Type.HTTP;
   }
 
   /**
-   * Returns the path to request, like the '/' in 'GET / HTTP/1.1'. Never empty,
-   * even if the request URL is. Includes the query component if it exists.
+   * Returns the path to request, like the '/' in 'GET / HTTP/1.1'. Never empty, even if the request
+   * URL is. Includes the query component if it exists.
    */
   public static String requestPath(HttpUrl url) {
     String path = url.encodedPath();
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RetryableSink.java b/okhttp/src/main/java/okhttp3/internal/http/RetryableSink.java
index 08ef9fc275..8fb13a8a75 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/RetryableSink.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/RetryableSink.java
@@ -25,9 +25,8 @@
 import static okhttp3.internal.Util.checkOffsetAndCount;
 
 /**
- * An HTTP request body that's completely buffered in memory. This allows
- * the post body to be transparently re-sent if the HTTP request must be
- * sent multiple times.
+ * An HTTP request body that's completely buffered in memory. This allows the post body to be
+ * transparently re-sent if the HTTP request must be sent multiple times.
  */
 public final class RetryableSink implements Sink {
   private boolean closed;
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RouteException.java b/okhttp/src/main/java/okhttp3/internal/http/RouteException.java
index a6aeeeeddd..030b346a5a 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/RouteException.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/RouteException.java
@@ -25,6 +25,7 @@
  */
 public final class RouteException extends Exception {
   private static final Method addSuppressedExceptionMethod;
+
   static {
     Method m;
     try {
@@ -34,6 +35,7 @@
     }
     addSuppressedExceptionMethod = m;
   }
+
   private IOException lastException;
 
   public RouteException(IOException cause) {
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RouteSelector.java b/okhttp/src/main/java/okhttp3/internal/http/RouteSelector.java
index f6f06caa0a..3b5725cbe6 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/RouteSelector.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/RouteSelector.java
@@ -15,10 +15,6 @@
  */
 package okhttp3.internal.http;
 
-import okhttp3.Address;
-import okhttp3.HttpUrl;
-import okhttp3.Route;
-import okhttp3.internal.RouteDatabase;
 import java.io.IOException;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
@@ -29,11 +25,14 @@
 import java.util.Collections;
 import java.util.List;
 import java.util.NoSuchElementException;
+import okhttp3.Address;
+import okhttp3.HttpUrl;
+import okhttp3.Route;
+import okhttp3.internal.RouteDatabase;
 
 /**
- * Selects routes to connect to an origin server. Each connection requires a
- * choice of proxy server, IP address, and TLS mode. Connections may also be
- * recycled.
+ * Selects routes to connect to an origin server. Each connection requires a choice of proxy server,
+ * IP address, and TLS mode. Connections may also be recycled.
  */
 public final class RouteSelector {
   private final Address address;
@@ -62,8 +61,7 @@ public RouteSelector(Address address, RouteDatabase routeDatabase) {
   }
 
   /**
-   * Returns true if there's another route to attempt. Every address has at
-   * least one route.
+   * Returns true if there's another route to attempt. Every address has at least one route.
    */
   public boolean hasNext() {
     return hasNextInetSocketAddress()
@@ -95,8 +93,8 @@ public Route next() throws IOException {
   }
 
   /**
-   * Clients should invoke this method when they encounter a connectivity
-   * failure on a connection returned by this route selector.
+   * Clients should invoke this method when they encounter a connectivity failure on a connection
+   * returned by this route selector.
    */
   public void connectFailed(Route failedRoute, IOException failure) {
     if (failedRoute.proxy().type() != Proxy.Type.DIRECT && address.proxySelector() != null) {
diff --git a/okhttp/src/main/java/okhttp3/internal/http/StatusLine.java b/okhttp/src/main/java/okhttp3/internal/http/StatusLine.java
index de27241a9e..ccc642b4bc 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/StatusLine.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/StatusLine.java
@@ -1,9 +1,9 @@
 package okhttp3.internal.http;
 
-import okhttp3.Protocol;
-import okhttp3.Response;
 import java.io.IOException;
 import java.net.ProtocolException;
+import okhttp3.Protocol;
+import okhttp3.Response;
 
 /** An HTTP response status line like "HTTP/1.1 200 OK". */
 public final class StatusLine {
diff --git a/okhttp/src/main/java/okhttp3/internal/http/StreamAllocation.java b/okhttp/src/main/java/okhttp3/internal/http/StreamAllocation.java
index 7ac6c613ec..bd9abecaae 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/StreamAllocation.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/StreamAllocation.java
@@ -15,13 +15,6 @@
  */
 package okhttp3.internal.http;
 
-import okhttp3.Address;
-import okhttp3.ConnectionPool;
-import okhttp3.Route;
-import okhttp3.internal.Internal;
-import okhttp3.internal.RouteDatabase;
-import okhttp3.internal.Util;
-import okhttp3.internal.io.RealConnection;
 import java.io.IOException;
 import java.io.InterruptedIOException;
 import java.lang.ref.Reference;
@@ -31,6 +24,13 @@
 import java.security.cert.CertificateException;
 import javax.net.ssl.SSLHandshakeException;
 import javax.net.ssl.SSLPeerUnverifiedException;
+import okhttp3.Address;
+import okhttp3.ConnectionPool;
+import okhttp3.Route;
+import okhttp3.internal.Internal;
+import okhttp3.internal.RouteDatabase;
+import okhttp3.internal.Util;
+import okhttp3.internal.io.RealConnection;
 import okio.Sink;
 
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
@@ -39,41 +39,42 @@
  * This class coordinates the relationship between three entities:
  *
  * <ul>
- *   <li><strong>Connections:</strong> physical socket connections to remote servers. These are
- *       potentially slow to establish so it is necessary to be able to cancel a connection
- *       currently being connected.
- *   <li><strong>Streams:</strong> logical HTTP request/response pairs that are layered on
- *       connections. Each connection has its own allocation limit, which defines how many
- *       concurrent streams that connection can carry. HTTP/1.x connections can carry 1 stream
- *       at a time, SPDY and HTTP/2 typically carry multiple.
- *   <li><strong>Calls:</strong> a logical sequence of streams, typically an initial request and
- *       its follow up requests. We prefer to keep all streams of a single call on the same
- *       connection for better behavior and locality.
+ *     <li><strong>Connections:</strong> physical socket connections to remote servers. These are
+ *         potentially slow to establish so it is necessary to be able to cancel a connection
+ *         currently being connected.
+ *     <li><strong>Streams:</strong> logical HTTP request/response pairs that are layered on
+ *         connections. Each connection has its own allocation limit, which defines how many
+ *         concurrent streams that connection can carry. HTTP/1.x connections can carry 1 stream
+ *         at a time, SPDY and HTTP/2 typically carry multiple.
+ *     <li><strong>Calls:</strong> a logical sequence of streams, typically an initial request and
+ *         its follow up requests. We prefer to keep all streams of a single call on the same
+ *         connection for better behavior and locality.
  * </ul>
  *
- * <p>Instances of this class act on behalf of the call, using one or more streams over one or
- * more connections. This class has APIs to release each of the above resources:
+ * <p>Instances of this class act on behalf of the call, using one or more streams over one or more
+ * connections. This class has APIs to release each of the above resources:
  *
  * <ul>
- *   <li>{@link #noNewStreams()} prevents the connection from being used for new streams in the
- *       future. Use this after a {@code Connection: close} header, or when the connection may be
- *       inconsistent.
- *   <li>{@link #streamFinished streamFinished()} releases the active stream from this allocation.
- *       Note that only one stream may be active at a given time, so it is necessary to call {@link
- *       #streamFinished streamFinished()} before creating a subsequent stream with {@link
- *       #newStream newStream()}.
- *   <li>{@link #release()} removes the call's hold on the connection. Note that this won't
- *       immediately free the connection if there is a stream still lingering. That happens when a
- *       call is complete but its response body has yet to be fully consumed.
+ *     <li>{@link #noNewStreams()} prevents the connection from being used for new streams in the
+ *         future. Use this after a {@code Connection: close} header, or when the connection may be
+ *         inconsistent.
+ *     <li>{@link #streamFinished streamFinished()} releases the active stream from this allocation.
+ *         Note that only one stream may be active at a given time, so it is necessary to call
+ *         {@link #streamFinished streamFinished()} before creating a subsequent stream with {@link
+ *         #newStream newStream()}.
+ *     <li>{@link #release()} removes the call's hold on the connection. Note that this won't
+ *         immediately free the connection if there is a stream still lingering. That happens when a
+ *         call is complete but its response body has yet to be fully consumed.
  * </ul>
  *
- * <p>This class supports {@linkplain #cancel asynchronous canceling}. This is intended to have
- * the smallest blast radius possible. If an HTTP/2 stream is active, canceling will cancel that
- * stream but not the other streams sharing its connection. But if the TLS handshake is still in
- * progress then canceling may break the entire connection.
+ * <p>This class supports {@linkplain #cancel asynchronous canceling}. This is intended to have the
+ * smallest blast radius possible. If an HTTP/2 stream is active, canceling will cancel that stream
+ * but not the other streams sharing its connection. But if the TLS handshake is still in progress
+ * then canceling may break the entire connection.
  */
 public final class StreamAllocation {
   public final Address address;
+  private Route route;
   private final ConnectionPool connectionPool;
 
   // State guarded by connectionPool.
@@ -86,6 +87,7 @@
   public StreamAllocation(ConnectionPool connectionPool, Address address) {
     this.connectionPool = connectionPool;
     this.address = address;
+    this.routeSelector = new RouteSelector(address, routeDatabase());
   }
 
   public HttpStream newStream(int connectTimeout, int readTimeout, int writeTimeout,
@@ -99,14 +101,13 @@ public HttpStream newStream(int connectTimeout, int readTimeout, int writeTimeou
       if (resultConnection.framedConnection != null) {
         resultStream = new Http2xStream(this, resultConnection.framedConnection);
       } else {
-        resultConnection.getSocket().setSoTimeout(readTimeout);
+        resultConnection.socket().setSoTimeout(readTimeout);
         resultConnection.source.timeout().timeout(readTimeout, MILLISECONDS);
         resultConnection.sink.timeout().timeout(writeTimeout, MILLISECONDS);
         resultStream = new Http1xStream(this, resultConnection.source, resultConnection.sink);
       }
 
       synchronized (connectionPool) {
-        resultConnection.streamCount++;
         stream = resultStream;
         return resultStream;
       }
@@ -123,12 +124,22 @@ private RealConnection findHealthyConnection(int connectTimeout, int readTimeout
       int writeTimeout, boolean connectionRetryEnabled, boolean doExtensiveHealthChecks)
       throws IOException, RouteException {
     while (true) {
-      RealConnection candidate = findConnection(
-          connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled);
-      if (connection.isHealthy(doExtensiveHealthChecks)) {
+      RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,
+          connectionRetryEnabled);
+
+      // If this is a brand new connection, we can skip the extensive health checks.
+      synchronized (connectionPool) {
+        if (candidate.successCount == 0) {
+          return candidate;
+        }
+      }
+
+      // Otherwise do a potentially-slow check to confirm that the pooled connection is still good.
+      if (candidate.isHealthy(doExtensiveHealthChecks)) {
         return candidate;
       }
-      connectionFailed();
+
+      connectionFailed(new IOException());
     }
   }
 
@@ -138,6 +149,7 @@ private RealConnection findHealthyConnection(int connectTimeout, int readTimeout
    */
   private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout,
       boolean connectionRetryEnabled) throws IOException, RouteException {
+    Route selectedRoute;
     synchronized (connectionPool) {
       if (released) throw new IllegalStateException("released");
       if (stream != null) throw new IllegalStateException("stream != null");
@@ -155,14 +167,16 @@ private RealConnection findConnection(int connectTimeout, int readTimeout, int w
         return pooledConnection;
       }
 
-      // Attempt to create a connection.
-      if (routeSelector == null) {
-        routeSelector = new RouteSelector(address, routeDatabase());
-      }
+      selectedRoute = route;
     }
 
-    Route route = routeSelector.next();
-    RealConnection newConnection = new RealConnection(route);
+    if (selectedRoute == null) {
+      selectedRoute = routeSelector.next();
+      synchronized (connectionPool) {
+        route = selectedRoute;
+      }
+    }
+    RealConnection newConnection = new RealConnection(selectedRoute);
     acquire(newConnection);
 
     synchronized (connectionPool) {
@@ -173,18 +187,21 @@ private RealConnection findConnection(int connectTimeout, int readTimeout, int w
 
     newConnection.connect(connectTimeout, readTimeout, writeTimeout, address.connectionSpecs(),
         connectionRetryEnabled);
-    routeDatabase().connected(newConnection.getRoute());
+    routeDatabase().connected(newConnection.route());
 
     return newConnection;
   }
 
-  public void streamFinished(HttpStream stream) {
+  public void streamFinished(boolean noNewStreams, HttpStream stream) {
     synchronized (connectionPool) {
       if (stream == null || stream != this.stream) {
         throw new IllegalStateException("expected " + this.stream + " but was " + stream);
       }
+      if (!noNewStreams) {
+        connection.successCount++;
+      }
     }
-    deallocate(false, false, true);
+    deallocate(noNewStreams, false, true);
   }
 
   public HttpStream stream() {
@@ -229,9 +246,6 @@ private void deallocate(boolean noNewStreams, boolean released, boolean streamFi
         }
         if (this.stream == null && (this.released || connection.noNewStreams)) {
           release(connection);
-          if (connection.streamCount > 0) {
-            routeSelector = null;
-          }
           if (connection.allocations.isEmpty()) {
             connection.idleAtNanos = System.nanoTime();
             if (Internal.instance.connectionBecameIdle(connectionPool, connection)) {
@@ -243,7 +257,7 @@ private void deallocate(boolean noNewStreams, boolean released, boolean streamFi
       }
     }
     if (connectionToClose != null) {
-      Util.closeQuietly(connectionToClose.getSocket());
+      Util.closeQuietly(connectionToClose.socket());
     }
   }
 
@@ -262,24 +276,16 @@ public void cancel() {
     }
   }
 
-  private void connectionFailed(IOException e) {
+  public void connectionFailed(IOException e) {
     synchronized (connectionPool) {
-      if (routeSelector != null) {
-        if (connection.streamCount == 0) {
-          // Record the failure on a fresh route.
-          Route failedRoute = connection.getRoute();
-          routeSelector.connectFailed(failedRoute, e);
-        } else {
-          // We saw a failure on a recycled connection, reset this allocation with a fresh route.
-          routeSelector = null;
+      // Avoid this route if it's never seen a successful call.
+      if (connection != null && connection.successCount == 0) {
+        if (route != null && e != null) {
+          routeSelector.connectFailed(route, e);
         }
+        route = null;
       }
     }
-    connectionFailed();
-  }
-
-  /** Finish the current stream and prevent new streams from being created. */
-  public void connectionFailed() {
     deallocate(true, false, true);
   }
 
@@ -303,29 +309,9 @@ private void release(RealConnection connection) {
     throw new IllegalStateException();
   }
 
-  public boolean recover(RouteException e) {
-    if (connection != null) {
-      connectionFailed(e.getLastConnectException());
-    }
-
-    if ((routeSelector != null && !routeSelector.hasNext()) // No more routes to attempt.
-        || !isRecoverable(e)) {
-      return false;
-    }
-
-    return true;
-  }
-
   public boolean recover(IOException e, Sink requestBodyOut) {
     if (connection != null) {
-      int streamCount = connection.streamCount;
       connectionFailed(e);
-
-      if (streamCount == 1) {
-        // This isn't a recycled connection.
-        // TODO(jwilson): find a better way for this.
-        return false;
-      }
     }
 
     boolean canRetryRequestBody = requestBodyOut == null || requestBodyOut instanceof RetryableSink;
@@ -344,42 +330,22 @@ private boolean isRecoverable(IOException e) {
       return false;
     }
 
-    // If there was an interruption or timeout, don't recover.
-    if (e instanceof InterruptedIOException) {
-      return false;
-    }
-
-    return true;
-  }
-
-  private boolean isRecoverable(RouteException e) {
-    // Problems with a route may mean the connection can be retried with a new route, or may
-    // indicate a client-side or server-side issue that should not be retried. To tell, we must look
-    // at the cause.
-
-    IOException ioe = e.getLastConnectException();
-
-    // If there was a protocol problem, don't recover.
-    if (ioe instanceof ProtocolException) {
-      return false;
-    }
-
     // If there was an interruption don't recover, but if there was a timeout
     // we should try the next route (if there is one).
-    if (ioe instanceof InterruptedIOException) {
-      return ioe instanceof SocketTimeoutException;
+    if (e instanceof InterruptedIOException) {
+      return e instanceof SocketTimeoutException;
     }
 
     // Look for known client-side or negotiation errors that are unlikely to be fixed by trying
     // again with a different route.
-    if (ioe instanceof SSLHandshakeException) {
+    if (e instanceof SSLHandshakeException) {
       // If the problem was a CertificateException from the X509TrustManager,
       // do not retry.
-      if (ioe.getCause() instanceof CertificateException) {
+      if (e.getCause() instanceof CertificateException) {
         return false;
       }
     }
-    if (ioe instanceof SSLPeerUnverifiedException) {
+    if (e instanceof SSLPeerUnverifiedException) {
       // e.g. a certificate pinning error.
       return false;
     }
diff --git a/okhttp/src/main/java/okhttp3/internal/io/FileSystem.java b/okhttp/src/main/java/okhttp3/internal/io/FileSystem.java
index f4f120572b..6a786954b3 100644
--- a/okhttp/src/main/java/okhttp3/internal/io/FileSystem.java
+++ b/okhttp/src/main/java/okhttp3/internal/io/FileSystem.java
@@ -28,9 +28,9 @@
  * implementations may be used to inject faults (for testing) or to transform stored data (to add
  * encryption, for example).
  *
- * <p>All operations on a file system are racy. For example, guarding a call to {@link #source}
- * with {@link #exists} does not guarantee that {@link FileNotFoundException} will not be thrown.
- * The file may be moved between the two calls!
+ * <p>All operations on a file system are racy. For example, guarding a call to {@link #source} with
+ * {@link #exists} does not guarantee that {@link FileNotFoundException} will not be thrown. The
+ * file may be moved between the two calls!
  *
  * <p>This interface is less ambitious than {@link java.nio.file.FileSystem} introduced in Java 7.
  * It lacks important features like file watching, metadata, permissions, and disk space
diff --git a/okhttp/src/main/java/okhttp3/internal/io/RealConnection.java b/okhttp/src/main/java/okhttp3/internal/io/RealConnection.java
index 59a1c5b4b4..e0fe6ccc7d 100644
--- a/okhttp/src/main/java/okhttp3/internal/io/RealConnection.java
+++ b/okhttp/src/main/java/okhttp3/internal/io/RealConnection.java
@@ -44,7 +44,9 @@
 import okhttp3.internal.Platform;
 import okhttp3.internal.Util;
 import okhttp3.internal.Version;
+import okhttp3.internal.framed.ErrorCode;
 import okhttp3.internal.framed.FramedConnection;
+import okhttp3.internal.framed.FramedStream;
 import okhttp3.internal.http.Http1xStream;
 import okhttp3.internal.http.OkHeaders;
 import okhttp3.internal.http.RouteException;
@@ -60,7 +62,7 @@
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static okhttp3.internal.Util.closeQuietly;
 
-public final class RealConnection implements Connection {
+public final class RealConnection extends FramedConnection.Listener implements Connection {
   private final Route route;
 
   /** The low-level TCP socket. */
@@ -74,9 +76,10 @@
   private Handshake handshake;
   private Protocol protocol;
   public volatile FramedConnection framedConnection;
-  public int streamCount;
+  public int successCount;
   public BufferedSource source;
   public BufferedSink sink;
+  public int allocationLimit;
   public final List<Reference<StreamAllocation>> allocations = new ArrayList<>();
   public boolean noNewStreams;
   public long idleAtNanos = Long.MAX_VALUE;
@@ -154,11 +157,15 @@ private void connectSocket(int connectTimeout, int readTimeout, int writeTimeout
       FramedConnection framedConnection = new FramedConnection.Builder(true)
           .socket(socket, route.address().url().host(), source, sink)
           .protocol(protocol)
+          .listener(this)
           .build();
       framedConnection.sendConnectionPreface();
 
       // Only assign the framed connection once the preface has been sent successfully.
+      this.allocationLimit = framedConnection.maxConcurrentStreams();
       this.framedConnection = framedConnection;
+    } else {
+      this.allocationLimit = 1;
     }
   }
 
@@ -227,9 +234,8 @@ private void connectTls(int readTimeout, int writeTimeout,
   }
 
   /**
-   * To make an HTTPS connection over an HTTP proxy, send an unencrypted
-   * CONNECT request to create the proxy connection. This may need to be
-   * retried if the proxy requires authorization.
+   * To make an HTTPS connection over an HTTP proxy, send an unencrypted CONNECT request to create
+   * the proxy connection. This may need to be retried if the proxy requires authorization.
    */
   private void createTunnel(int readTimeout, int writeTimeout) throws IOException {
     // Make an SSL Tunnel on the first message pair of each SSL + proxy connection.
@@ -277,11 +283,10 @@ private void createTunnel(int readTimeout, int writeTimeout) throws IOException
   }
 
   /**
-   * Returns a request that creates a TLS tunnel via an HTTP proxy, or null if
-   * no tunnel is necessary. Everything in the tunnel request is sent
-   * unencrypted to the proxy server, so tunnels include only the minimum set of
-   * headers. This avoids sending potentially sensitive data like HTTP cookies
-   * to the proxy unencrypted.
+   * Returns a request that creates a TLS tunnel via an HTTP proxy, or null if no tunnel is
+   * necessary. Everything in the tunnel request is sent unencrypted to the proxy server, so tunnels
+   * include only the minimum set of headers. This avoids sending potentially sensitive data like
+   * HTTP cookies to the proxy unencrypted.
    */
   private Request createTunnelRequest() throws IOException {
     return new Request.Builder()
@@ -297,7 +302,7 @@ boolean isConnected() {
     return protocol != null;
   }
 
-  @Override public Route getRoute() {
+  @Override public Route route() {
     return route;
   }
 
@@ -306,17 +311,10 @@ public void cancel() {
     closeQuietly(rawSocket);
   }
 
-  @Override public Socket getSocket() {
+  @Override public Socket socket() {
     return socket;
   }
 
-  public int allocationLimit() {
-    FramedConnection framedConnection = this.framedConnection;
-    return framedConnection != null
-        ? framedConnection.maxConcurrentStreams()
-        : 1;
-  }
-
   /** Returns true if this connection is ready to host new streams. */
   public boolean isHealthy(boolean doExtensiveChecks) {
     if (socket.isClosed() || socket.isInputShutdown() || socket.isOutputShutdown()) {
@@ -349,20 +347,34 @@ public boolean isHealthy(boolean doExtensiveChecks) {
     return true;
   }
 
-  @Override public Handshake getHandshake() {
+  /** Refuse incoming streams. */
+  @Override public void onStream(FramedStream stream) throws IOException {
+    stream.close(ErrorCode.REFUSED_STREAM);
+  }
+
+  /** When settings are received, adjust the allocation limit. */
+  @Override public void onSettings(FramedConnection connection) {
+    allocationLimit = connection.maxConcurrentStreams();
+  }
+
+  @Override public Handshake handshake() {
     return handshake;
   }
 
   /**
-   * Returns true if this is a SPDY connection. Such connections can be used
-   * in multiple HTTP requests simultaneously.
+   * Returns true if this is a SPDY connection. Such connections can be used in multiple HTTP
+   * requests simultaneously.
    */
   public boolean isMultiplexed() {
     return framedConnection != null;
   }
 
-  @Override public Protocol getProtocol() {
-    return protocol != null ? protocol : Protocol.HTTP_1_1;
+  @Override public Protocol protocol() {
+    if (framedConnection == null) {
+      return protocol != null ? protocol : Protocol.HTTP_1_1;
+    } else {
+      return framedConnection.getProtocol();
+    }
   }
 
   @Override public String toString() {
diff --git a/okhttp/src/main/java/okhttp3/internal/tls/DistinguishedNameParser.java b/okhttp/src/main/java/okhttp3/internal/tls/DistinguishedNameParser.java
index 7a6814b185..ceecd9c31b 100644
--- a/okhttp/src/main/java/okhttp3/internal/tls/DistinguishedNameParser.java
+++ b/okhttp/src/main/java/okhttp3/internal/tls/DistinguishedNameParser.java
@@ -20,8 +20,8 @@
 import javax.security.auth.x500.X500Principal;
 
 /**
- * A distinguished name (DN) parser. This parser only supports extracting a
- * string value from a DN. It doesn't support values in the hex-string style.
+ * A distinguished name (DN) parser. This parser only supports extracting a string value from a DN.
+ * It doesn't support values in the hex-string style.
  */
 final class DistinguishedNameParser {
   private final String dn;
@@ -341,8 +341,8 @@ private int getByte(int position) {
   }
 
   /**
-   * Parses the DN and returns the most significant attribute value
-   * for an attribute type, or null if none found.
+   * Parses the DN and returns the most significant attribute value for an attribute type, or null
+   * if none found.
    *
    * @param attributeType attribute type to look for (e.g. "ca")
    */
diff --git a/okhttp/src/main/java/okhttp3/internal/tls/OkHostnameVerifier.java b/okhttp/src/main/java/okhttp3/internal/tls/OkHostnameVerifier.java
index aee522b055..e6ad9b8c6f 100644
--- a/okhttp/src/main/java/okhttp3/internal/tls/OkHostnameVerifier.java
+++ b/okhttp/src/main/java/okhttp3/internal/tls/OkHostnameVerifier.java
@@ -25,33 +25,19 @@
 import java.util.Collections;
 import java.util.List;
 import java.util.Locale;
-import java.util.regex.Pattern;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLException;
 import javax.net.ssl.SSLSession;
 import javax.security.auth.x500.X500Principal;
 
+import static okhttp3.internal.Util.verifyAsIpAddress;
+
 /**
- * A HostnameVerifier consistent with <a
- * href="http://www.ietf.org/rfc/rfc2818.txt">RFC 2818</a>.
+ * A HostnameVerifier consistent with <a href="http://www.ietf.org/rfc/rfc2818.txt">RFC 2818</a>.
  */
 public final class OkHostnameVerifier implements HostnameVerifier {
   public static final OkHostnameVerifier INSTANCE = new OkHostnameVerifier();
 
-  /**
-   * Quick and dirty pattern to differentiate IP addresses from hostnames. This
-   * is an approximation of Android's private InetAddress#isNumeric API.
-   *
-   * <p>This matches IPv6 addresses as a hex string containing at least one
-   * colon, and possibly including dots after the first colon. It matches IPv4
-   * addresses as strings containing only decimal digits and dots. This pattern
-   * matches strings like "a:.23" and "54" that are neither IP addresses nor
-   * hostnames; they will be verified as IP addresses (which is a more strict
-   * verification).
-   */
-  private static final Pattern VERIFY_AS_IP_ADDRESS = Pattern.compile(
-      "([0-9a-fA-F]*:[0-9a-fA-F:.]*)|([\\d.]+)");
-
   private static final int ALT_DNS_NAME = 2;
   private static final int ALT_IPA_NAME = 7;
 
@@ -74,13 +60,7 @@ public boolean verify(String host, X509Certificate certificate) {
         : verifyHostName(host, certificate);
   }
 
-  static boolean verifyAsIpAddress(String host) {
-    return VERIFY_AS_IP_ADDRESS.matcher(host).matches();
-  }
-
-  /**
-   * Returns true if {@code certificate} matches {@code ipAddress}.
-   */
+  /** Returns true if {@code certificate} matches {@code ipAddress}. */
   private boolean verifyIpAddress(String ipAddress, X509Certificate certificate) {
     List<String> altNames = getSubjectAltNames(certificate, ALT_IPA_NAME);
     for (int i = 0, size = altNames.size(); i < size; i++) {
@@ -91,9 +71,7 @@ private boolean verifyIpAddress(String ipAddress, X509Certificate certificate) {
     return false;
   }
 
-  /**
-   * Returns true if {@code certificate} matches {@code hostName}.
-   */
+  /** Returns true if {@code certificate} matches {@code hostName}. */
   private boolean verifyHostName(String hostName, X509Certificate certificate) {
     hostName = hostName.toLowerCase(Locale.US);
     boolean hasDns = false;
@@ -159,8 +137,8 @@ private boolean verifyHostName(String hostName, X509Certificate certificate) {
    * Returns {@code true} iff {@code hostName} matches the domain name {@code pattern}.
    *
    * @param hostName lower-case host name.
-   * @param pattern domain name pattern from certificate. May be a wildcard pattern such as
-   *        {@code *.android.com}.
+   * @param pattern domain name pattern from certificate. May be a wildcard pattern such as {@code
+   * *.android.com}.
    */
   private boolean verifyHostName(String hostName, String pattern) {
     // Basic sanity checks
diff --git a/pom.xml b/pom.xml
index c58d828c39..772e8a417c 100644
--- a/pom.xml
+++ b/pom.xml
@@ -11,7 +11,7 @@
 
   <groupId>com.squareup.okhttp3</groupId>
   <artifactId>parent</artifactId>
-  <version>3.0.0-SNAPSHOT</version>
+  <version>3.1.0-SNAPSHOT</version>
   <packaging>pom</packaging>
 
   <name>OkHttp (Parent)</name>
@@ -237,7 +237,9 @@
         <jdk>1.7</jdk>
       </activation>
       <properties>
-        <bootclasspathPrefix>${settings.localRepository}/org/mortbay/jetty/alpn/alpn-boot/${alpn.jdk7.version}/alpn-boot-${alpn.jdk7.version}.jar</bootclasspathPrefix>
+        <bootclasspathPrefix>
+          ${settings.localRepository}/org/mortbay/jetty/alpn/alpn-boot/${alpn.jdk7.version}/alpn-boot-${alpn.jdk7.version}.jar
+        </bootclasspathPrefix>
       </properties>
       <build>
         <pluginManagement>
@@ -266,7 +268,9 @@
         <jdk>1.8</jdk>
       </activation>
       <properties>
-        <bootclasspathPrefix>${settings.localRepository}/org/mortbay/jetty/alpn/alpn-boot/${alpn.jdk8.version}/alpn-boot-${alpn.jdk8.version}.jar</bootclasspathPrefix>
+        <bootclasspathPrefix>
+          ${settings.localRepository}/org/mortbay/jetty/alpn/alpn-boot/${alpn.jdk8.version}/alpn-boot-${alpn.jdk8.version}.jar
+        </bootclasspathPrefix>
       </properties>
       <build>
         <pluginManagement>
diff --git a/samples/crawler/pom.xml b/samples/crawler/pom.xml
index 0a1e7f6b21..63b8c43aaf 100644
--- a/samples/crawler/pom.xml
+++ b/samples/crawler/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>3.0.0-SNAPSHOT</version>
+    <version>3.1.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>crawler</artifactId>
diff --git a/samples/crawler/src/main/java/okhttp3/sample/Crawler.java b/samples/crawler/src/main/java/okhttp3/sample/Crawler.java
index 68bcdea9e9..7fad2ee5e1 100644
--- a/samples/crawler/src/main/java/okhttp3/sample/Crawler.java
+++ b/samples/crawler/src/main/java/okhttp3/sample/Crawler.java
@@ -15,12 +15,6 @@
  */
 package okhttp3.sample;
 
-import okhttp3.Cache;
-import okhttp3.HttpUrl;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.internal.NamedRunnable;
 import java.io.File;
 import java.io.IOException;
 import java.util.Collections;
@@ -31,6 +25,12 @@
 import java.util.concurrent.Executors;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.atomic.AtomicInteger;
+import okhttp3.Cache;
+import okhttp3.HttpUrl;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.internal.NamedRunnable;
 import org.jsoup.Jsoup;
 import org.jsoup.nodes.Document;
 import org.jsoup.nodes.Element;
@@ -120,9 +120,10 @@ public static void main(String[] args) throws IOException {
     int threadCount = 20;
     long cacheByteCount = 1024L * 1024L * 100L;
 
-    OkHttpClient client = new OkHttpClient();
     Cache cache = new Cache(new File(args[0]), cacheByteCount);
-    client.setCache(cache);
+    OkHttpClient client = new OkHttpClient.Builder()
+        .cache(cache)
+        .build();
 
     Crawler crawler = new Crawler(client);
     crawler.queue.add(HttpUrl.parse(args[1]));
diff --git a/samples/guide/pom.xml b/samples/guide/pom.xml
index 388758502f..c81ea17757 100644
--- a/samples/guide/pom.xml
+++ b/samples/guide/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>3.0.0-SNAPSHOT</version>
+    <version>3.1.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>guide</artifactId>
diff --git a/samples/guide/src/main/java/okhttp3/guide/GetExample.java b/samples/guide/src/main/java/okhttp3/guide/GetExample.java
index a5d1c23d39..19ef73bf2e 100644
--- a/samples/guide/src/main/java/okhttp3/guide/GetExample.java
+++ b/samples/guide/src/main/java/okhttp3/guide/GetExample.java
@@ -1,9 +1,9 @@
 package okhttp3.guide;
 
+import java.io.IOException;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
 import okhttp3.Response;
-import java.io.IOException;
 
 public class GetExample {
   OkHttpClient client = new OkHttpClient();
diff --git a/samples/guide/src/main/java/okhttp3/guide/PostExample.java b/samples/guide/src/main/java/okhttp3/guide/PostExample.java
index 43c1432095..74ddc56127 100644
--- a/samples/guide/src/main/java/okhttp3/guide/PostExample.java
+++ b/samples/guide/src/main/java/okhttp3/guide/PostExample.java
@@ -1,11 +1,11 @@
 package okhttp3.guide;
 
+import java.io.IOException;
 import okhttp3.MediaType;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
 import okhttp3.RequestBody;
 import okhttp3.Response;
-import java.io.IOException;
 
 public class PostExample {
   public static final MediaType JSON
diff --git a/samples/guide/src/main/java/okhttp3/recipes/AccessHeaders.java b/samples/guide/src/main/java/okhttp3/recipes/AccessHeaders.java
index eda73525b2..fe4d2f521f 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/AccessHeaders.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/AccessHeaders.java
@@ -15,10 +15,10 @@
  */
 package okhttp3.recipes;
 
+import java.io.IOException;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
 import okhttp3.Response;
-import java.io.IOException;
 
 public final class AccessHeaders {
   private final OkHttpClient client = new OkHttpClient();
diff --git a/samples/guide/src/main/java/okhttp3/recipes/AsynchronousGet.java b/samples/guide/src/main/java/okhttp3/recipes/AsynchronousGet.java
index bf94aad758..ad49c3e487 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/AsynchronousGet.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/AsynchronousGet.java
@@ -15,12 +15,13 @@
  */
 package okhttp3.recipes;
 
+import java.io.IOException;
+import okhttp3.Call;
 import okhttp3.Callback;
 import okhttp3.Headers;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
 import okhttp3.Response;
-import java.io.IOException;
 
 public final class AsynchronousGet {
   private final OkHttpClient client = new OkHttpClient();
@@ -31,11 +32,11 @@ public void run() throws Exception {
         .build();
 
     client.newCall(request).enqueue(new Callback() {
-      @Override public void onFailure(Request request, IOException e) {
+      @Override public void onFailure(Call call, IOException e) {
         e.printStackTrace();
       }
 
-      @Override public void onResponse(Response response) throws IOException {
+      @Override public void onResponse(Call call, Response response) throws IOException {
         if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
 
         Headers responseHeaders = response.headers();
diff --git a/samples/guide/src/main/java/okhttp3/recipes/Authenticate.java b/samples/guide/src/main/java/okhttp3/recipes/Authenticate.java
index 09b29cccd1..04c8cae2a8 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/Authenticate.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/Authenticate.java
@@ -24,20 +24,24 @@
 import okhttp3.Route;
 
 public final class Authenticate {
-  private final OkHttpClient client = new OkHttpClient();
+  private final OkHttpClient client;
 
-  public void run() throws Exception {
-    client.setAuthenticator(new Authenticator() {
-      @Override public Request authenticate(Route route, Response response) throws IOException {
-        System.out.println("Authenticating for response: " + response);
-        System.out.println("Challenges: " + response.challenges());
-        String credential = Credentials.basic("jesse", "password1");
-        return response.request().newBuilder()
-            .header("Authorization", credential)
-            .build();
-      }
-    });
+  public Authenticate() {
+    client = new OkHttpClient.Builder()
+        .authenticator(new Authenticator() {
+          @Override public Request authenticate(Route route, Response response) throws IOException {
+            System.out.println("Authenticating for response: " + response);
+            System.out.println("Challenges: " + response.challenges());
+            String credential = Credentials.basic("jesse", "password1");
+            return response.request().newBuilder()
+                .header("Authorization", credential)
+                .build();
+          }
+        })
+        .build();
+  }
 
+  public void run() throws Exception {
     Request request = new Request.Builder()
         .url("http://publicobject.com/secrets/hellosecret.txt")
         .build();
diff --git a/samples/guide/src/main/java/okhttp3/recipes/CacheResponse.java b/samples/guide/src/main/java/okhttp3/recipes/CacheResponse.java
index 59b3ce519f..8e82f4ab5f 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/CacheResponse.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/CacheResponse.java
@@ -15,12 +15,12 @@
  */
 package okhttp3.recipes;
 
+import java.io.File;
+import java.io.IOException;
 import okhttp3.Cache;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
 import okhttp3.Response;
-import java.io.File;
-import java.io.IOException;
 
 public final class CacheResponse {
   private final OkHttpClient client;
@@ -29,8 +29,9 @@ public CacheResponse(File cacheDirectory) throws Exception {
     int cacheSize = 10 * 1024 * 1024; // 10 MiB
     Cache cache = new Cache(cacheDirectory, cacheSize);
 
-    client = new OkHttpClient();
-    client.setCache(cache);
+    client = new OkHttpClient.Builder()
+        .cache(cache)
+        .build();
   }
 
   public void run() throws Exception {
diff --git a/samples/guide/src/main/java/okhttp3/recipes/CancelCall.java b/samples/guide/src/main/java/okhttp3/recipes/CancelCall.java
index b2515a7567..c3551f78be 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/CancelCall.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/CancelCall.java
@@ -15,14 +15,14 @@
  */
 package okhttp3.recipes;
 
-import okhttp3.Call;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.Response;
 import java.io.IOException;
 import java.util.concurrent.Executors;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.TimeUnit;
+import okhttp3.Call;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
 
 public class CancelCall {
   private final ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);
diff --git a/samples/guide/src/main/java/okhttp3/recipes/CertificatePinning.java b/samples/guide/src/main/java/okhttp3/recipes/CertificatePinning.java
index 2df890dfa9..b890be7577 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/CertificatePinning.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/CertificatePinning.java
@@ -15,25 +15,26 @@
  */
 package okhttp3.recipes;
 
+import java.io.IOException;
+import java.security.cert.Certificate;
 import okhttp3.CertificatePinner;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
 import okhttp3.Response;
-import java.io.IOException;
-import java.security.cert.Certificate;
 
 public final class CertificatePinning {
   private final OkHttpClient client;
 
   public CertificatePinning() {
-    client = new OkHttpClient();
-    client.setCertificatePinner(
-        new CertificatePinner.Builder()
-            .add("publicobject.com", "sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw=")
-            .add("publicobject.com", "sha1/SXxoaOSEzPC6BgGmxAt/EAcsajw=")
-            .add("publicobject.com", "sha1/blhOM3W9V/bVQhsWAcLYwPU6n24=")
-            .add("publicobject.com", "sha1/T5x9IXmcrQ7YuQxXnxoCmeeQ84c=")
-            .build());
+    client = new OkHttpClient.Builder()
+        .certificatePinner(
+            new CertificatePinner.Builder()
+                .add("publicobject.com", "sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw=")
+                .add("publicobject.com", "sha1/SXxoaOSEzPC6BgGmxAt/EAcsajw=")
+                .add("publicobject.com", "sha1/blhOM3W9V/bVQhsWAcLYwPU6n24=")
+                .add("publicobject.com", "sha1/T5x9IXmcrQ7YuQxXnxoCmeeQ84c=")
+                .build())
+        .build();
   }
 
   public void run() throws Exception {
diff --git a/samples/guide/src/main/java/okhttp3/recipes/CheckHandshake.java b/samples/guide/src/main/java/okhttp3/recipes/CheckHandshake.java
index d1ba3cee16..0f52fb426d 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/CheckHandshake.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/CheckHandshake.java
@@ -15,15 +15,15 @@
  */
 package okhttp3.recipes;
 
+import java.io.IOException;
+import java.security.cert.Certificate;
+import java.util.Collections;
+import java.util.Set;
 import okhttp3.CertificatePinner;
 import okhttp3.Interceptor;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
 import okhttp3.Response;
-import java.io.IOException;
-import java.security.cert.Certificate;
-import java.util.Collections;
-import java.util.Set;
 
 public final class CheckHandshake {
   /** Rejects otherwise-trusted certificates. */
@@ -31,7 +31,7 @@
     Set<String> blacklist = Collections.singleton("sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw=");
 
     @Override public Response intercept(Chain chain) throws IOException {
-      for (Certificate certificate : chain.connection().getHandshake().peerCertificates()) {
+      for (Certificate certificate : chain.connection().handshake().peerCertificates()) {
         String pin = CertificatePinner.pin(certificate);
         if (blacklist.contains(pin)) {
           throw new IOException("Blacklisted peer certificate: " + pin);
@@ -41,11 +41,9 @@
     }
   };
 
-  private final OkHttpClient client = new OkHttpClient();
-
-  public CheckHandshake() {
-    client.networkInterceptors().add(CHECK_HANDSHAKE_INTERCEPTOR);
-  }
+  private final OkHttpClient client = new OkHttpClient.Builder()
+      .addNetworkInterceptor(CHECK_HANDSHAKE_INTERCEPTOR)
+      .build();
 
   public void run() throws Exception {
     Request request = new Request.Builder()
diff --git a/samples/guide/src/main/java/okhttp3/recipes/ConfigureTimeouts.java b/samples/guide/src/main/java/okhttp3/recipes/ConfigureTimeouts.java
index 47852c3214..2f93880260 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/ConfigureTimeouts.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/ConfigureTimeouts.java
@@ -15,19 +15,20 @@
  */
 package okhttp3.recipes;
 
+import java.util.concurrent.TimeUnit;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
 import okhttp3.Response;
-import java.util.concurrent.TimeUnit;
 
 public final class ConfigureTimeouts {
   private final OkHttpClient client;
 
   public ConfigureTimeouts() throws Exception {
-    client = new OkHttpClient();
-    client.setConnectTimeout(10, TimeUnit.SECONDS);
-    client.setWriteTimeout(10, TimeUnit.SECONDS);
-    client.setReadTimeout(30, TimeUnit.SECONDS);
+    client = new OkHttpClient.Builder()
+        .connectTimeout(10, TimeUnit.SECONDS)
+        .writeTimeout(10, TimeUnit.SECONDS)
+        .readTimeout(30, TimeUnit.SECONDS)
+        .build();
   }
 
   public void run() throws Exception {
diff --git a/samples/guide/src/main/java/okhttp3/recipes/CustomTrust.java b/samples/guide/src/main/java/okhttp3/recipes/CustomTrust.java
index da4476e354..6fe27a3933 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/CustomTrust.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/CustomTrust.java
@@ -15,11 +15,6 @@
  */
 package okhttp3.recipes;
 
-import okhttp3.CertificatePinner;
-import okhttp3.Headers;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.Response;
 import java.io.IOException;
 import java.io.InputStream;
 import java.security.GeneralSecurityException;
@@ -31,15 +26,21 @@
 import javax.net.ssl.KeyManagerFactory;
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.TrustManagerFactory;
+import okhttp3.CertificatePinner;
+import okhttp3.Headers;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
 import okio.Buffer;
 
 public final class CustomTrust {
   private final OkHttpClient client;
 
   public CustomTrust() {
-    client = new OkHttpClient();
     SSLContext sslContext = sslContextForTrustedCertificates(trustedCertificatesInputStream());
-    client.setSslSocketFactory(sslContext.getSocketFactory());
+    client = new OkHttpClient.Builder()
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .build();
   }
 
   public void run() throws Exception {
@@ -150,8 +151,9 @@ private InputStream trustedCertificatesInputStream() {
    * the host platform's built-in trust store.
    *
    * <h3>Warning: Customizing Trusted Certificates is Dangerous!</h3>
-   * Relying on your own trusted certificates limits your server team's ability to update their TLS
-   * certificates. By installing a specific set of trusted certificates, you take on additional
+   *
+   * <p>Relying on your own trusted certificates limits your server team's ability to update their
+   * TLS certificates. By installing a specific set of trusted certificates, you take on additional
    * operational complexity and limit your ability to migrate between certificate authorities. Do
    * not use custom trusted certificates in production without the blessing of your server's TLS
    * administrator.
diff --git a/samples/guide/src/main/java/okhttp3/recipes/LoggingInterceptors.java b/samples/guide/src/main/java/okhttp3/recipes/LoggingInterceptors.java
index 8a086206a9..8cb72b4bc8 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/LoggingInterceptors.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/LoggingInterceptors.java
@@ -15,33 +15,18 @@
  */
 package okhttp3.recipes;
 
+import java.io.IOException;
+import java.util.logging.Logger;
 import okhttp3.Interceptor;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
 import okhttp3.Response;
-import java.io.IOException;
-import java.util.logging.Logger;
 
 public final class LoggingInterceptors {
   private static final Logger logger = Logger.getLogger(LoggingInterceptors.class.getName());
-  private final OkHttpClient client = new OkHttpClient();
-
-  public LoggingInterceptors() {
-    client.networkInterceptors().add(new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        long t1 = System.nanoTime();
-        Request request = chain.request();
-        logger.info(String.format("Sending request %s on %s%n%s",
-            request.url(), chain.connection(), request.headers()));
-        Response response = chain.proceed(request);
-
-        long t2 = System.nanoTime();
-        logger.info(String.format("Received response for %s in %.1fms%n%s",
-            request.url(), (t2 - t1) / 1e6d, response.headers()));
-        return response;
-      }
-    });
-  }
+  private final OkHttpClient client = new OkHttpClient.Builder()
+      .addInterceptor(new LoggingInterceptor())
+      .build();
 
   public void run() throws Exception {
     Request request = new Request.Builder()
@@ -52,6 +37,21 @@ public void run() throws Exception {
     response.body().close();
   }
 
+  private static class LoggingInterceptor implements Interceptor {
+    @Override public Response intercept(Chain chain) throws IOException {
+      long t1 = System.nanoTime();
+      Request request = chain.request();
+      logger.info(String.format("Sending request %s on %s%n%s",
+          request.url(), chain.connection(), request.headers()));
+      Response response = chain.proceed(request);
+
+      long t2 = System.nanoTime();
+      logger.info(String.format("Received response for %s in %.1fms%n%s",
+          request.url(), (t2 - t1) / 1e6d, response.headers()));
+      return response;
+    }
+  }
+
   public static void main(String... args) throws Exception {
     new LoggingInterceptors().run();
   }
diff --git a/samples/guide/src/main/java/okhttp3/recipes/ParseResponseWithGson.java b/samples/guide/src/main/java/okhttp3/recipes/ParseResponseWithGson.java
index 5253aa5516..7ca4ccb731 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/ParseResponseWithGson.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/ParseResponseWithGson.java
@@ -16,11 +16,11 @@
 package okhttp3.recipes;
 
 import com.google.gson.Gson;
+import java.io.IOException;
+import java.util.Map;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
 import okhttp3.Response;
-import java.io.IOException;
-import java.util.Map;
 
 public final class ParseResponseWithGson {
   private final OkHttpClient client = new OkHttpClient();
@@ -34,6 +34,8 @@ public void run() throws Exception {
     if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
 
     Gist gist = gson.fromJson(response.body().charStream(), Gist.class);
+    response.body().close();
+
     for (Map.Entry<String, GistFile> entry : gist.files.entrySet()) {
       System.out.println(entry.getKey());
       System.out.println(entry.getValue().content);
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PerCallSettings.java b/samples/guide/src/main/java/okhttp3/recipes/PerCallSettings.java
index 1970a434b6..9f82d1efae 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/PerCallSettings.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/PerCallSettings.java
@@ -15,11 +15,11 @@
  */
 package okhttp3.recipes;
 
+import java.io.IOException;
+import java.util.concurrent.TimeUnit;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
 import okhttp3.Response;
-import java.io.IOException;
-import java.util.concurrent.TimeUnit;
 
 public final class PerCallSettings {
   private final OkHttpClient client = new OkHttpClient();
@@ -30,20 +30,24 @@ public void run() throws Exception {
         .build();
 
     try {
-      OkHttpClient cloned = client.clone(); // Clone to make a customized OkHttp for this request.
-      cloned.setReadTimeout(500, TimeUnit.MILLISECONDS);
+      // Copy to customize OkHttp for this request.
+      OkHttpClient copy = client.newBuilder()
+          .readTimeout(500, TimeUnit.MILLISECONDS)
+          .build();
 
-      Response response = cloned.newCall(request).execute();
+      Response response = copy.newCall(request).execute();
       System.out.println("Response 1 succeeded: " + response);
     } catch (IOException e) {
       System.out.println("Response 1 failed: " + e);
     }
 
     try {
-      OkHttpClient cloned = client.clone(); // Clone to make a customized OkHttp for this request.
-      cloned.setReadTimeout(3000, TimeUnit.MILLISECONDS);
+      // Copy to customize OkHttp for this request.
+      OkHttpClient copy = client.newBuilder()
+          .readTimeout(3000, TimeUnit.MILLISECONDS)
+          .build();
 
-      Response response = cloned.newCall(request).execute();
+      Response response = copy.newCall(request).execute();
       System.out.println("Response 2 succeeded: " + response);
     } catch (IOException e) {
       System.out.println("Response 2 failed: " + e);
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PostFile.java b/samples/guide/src/main/java/okhttp3/recipes/PostFile.java
index c10993fcfe..4d69844a7a 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/PostFile.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/PostFile.java
@@ -15,13 +15,13 @@
  */
 package okhttp3.recipes;
 
+import java.io.File;
+import java.io.IOException;
 import okhttp3.MediaType;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
 import okhttp3.RequestBody;
 import okhttp3.Response;
-import java.io.File;
-import java.io.IOException;
 
 public final class PostFile {
   public static final MediaType MEDIA_TYPE_MARKDOWN
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PostForm.java b/samples/guide/src/main/java/okhttp3/recipes/PostForm.java
index 18c4b1d15b..f2f05def19 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/PostForm.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/PostForm.java
@@ -15,12 +15,12 @@
  */
 package okhttp3.recipes;
 
+import java.io.IOException;
 import okhttp3.FormBody;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
 import okhttp3.RequestBody;
 import okhttp3.Response;
-import java.io.IOException;
 
 public final class PostForm {
   private final OkHttpClient client = new OkHttpClient();
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PostMultipart.java b/samples/guide/src/main/java/okhttp3/recipes/PostMultipart.java
index 67ddf88c5f..ab3708fab5 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/PostMultipart.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/PostMultipart.java
@@ -15,20 +15,19 @@
  */
 package okhttp3.recipes;
 
+import java.io.File;
+import java.io.IOException;
 import okhttp3.MediaType;
 import okhttp3.MultipartBody;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
 import okhttp3.RequestBody;
 import okhttp3.Response;
-import java.io.File;
-import java.io.IOException;
 
 public final class PostMultipart {
   /**
-   * The imgur client ID for OkHttp recipes. If you're using imgur for anything
-   * other than running these examples, please request your own client ID!
-   *   https://api.imgur.com/oauth2
+   * The imgur client ID for OkHttp recipes. If you're using imgur for anything other than running
+   * these examples, please request your own client ID! https://api.imgur.com/oauth2
    */
   private static final String IMGUR_CLIENT_ID = "9199fdef135c122";
   private static final MediaType MEDIA_TYPE_PNG = MediaType.parse("image/png");
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PostStreaming.java b/samples/guide/src/main/java/okhttp3/recipes/PostStreaming.java
index 5086d3345e..4651240d67 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/PostStreaming.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/PostStreaming.java
@@ -15,12 +15,12 @@
  */
 package okhttp3.recipes;
 
+import java.io.IOException;
 import okhttp3.MediaType;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
 import okhttp3.RequestBody;
 import okhttp3.Response;
-import java.io.IOException;
 import okio.BufferedSink;
 
 public final class PostStreaming {
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PostString.java b/samples/guide/src/main/java/okhttp3/recipes/PostString.java
index 2eae7f6a3f..f956f97f1f 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/PostString.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/PostString.java
@@ -15,12 +15,12 @@
  */
 package okhttp3.recipes;
 
+import java.io.IOException;
 import okhttp3.MediaType;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
 import okhttp3.RequestBody;
 import okhttp3.Response;
-import java.io.IOException;
 
 public final class PostString {
   public static final MediaType MEDIA_TYPE_MARKDOWN
diff --git a/samples/guide/src/main/java/okhttp3/recipes/Progress.java b/samples/guide/src/main/java/okhttp3/recipes/Progress.java
index 5f9104c9be..f499a90cf1 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/Progress.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/Progress.java
@@ -15,13 +15,13 @@
  */
 package okhttp3.recipes;
 
+import java.io.IOException;
 import okhttp3.Interceptor;
 import okhttp3.MediaType;
 import okhttp3.OkHttpClient;
+import okhttp3.Request;
 import okhttp3.Response;
 import okhttp3.ResponseBody;
-import okhttp3.Request;
-import java.io.IOException;
 import okio.Buffer;
 import okio.BufferedSource;
 import okio.ForwardingSource;
@@ -30,8 +30,6 @@
 
 public final class Progress {
 
-  private final OkHttpClient client = new OkHttpClient();
-
   public void run() throws Exception {
     Request request = new Request.Builder()
         .url("https://publicobject.com/helloworld.txt")
@@ -46,14 +44,16 @@ public void run() throws Exception {
       }
     };
 
-    client.networkInterceptors().add(new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        Response originalResponse = chain.proceed(chain.request());
-        return originalResponse.newBuilder()
-            .body(new ProgressResponseBody(originalResponse.body(), progressListener))
-            .build();
-        }
-    });
+    OkHttpClient client = new OkHttpClient.Builder()
+        .addNetworkInterceptor(new Interceptor() {
+          @Override public Response intercept(Chain chain) throws IOException {
+            Response originalResponse = chain.proceed(chain.request());
+            return originalResponse.newBuilder()
+                .body(new ProgressResponseBody(originalResponse.body(), progressListener))
+                .build();
+          }
+        })
+        .build();
 
     Response response = client.newCall(request).execute();
     if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
@@ -94,6 +94,7 @@ public ProgressResponseBody(ResponseBody responseBody, ProgressListener progress
     private Source source(Source source) {
       return new ForwardingSource(source) {
         long totalBytesRead = 0L;
+
         @Override public long read(Buffer sink, long byteCount) throws IOException {
           long bytesRead = super.read(sink, byteCount);
           // read() returns the number of bytes read, or -1 if this source is exhausted.
diff --git a/samples/guide/src/main/java/okhttp3/recipes/RequestBodyCompression.java b/samples/guide/src/main/java/okhttp3/recipes/RequestBodyCompression.java
index 328c717fcd..d1dc18a3b1 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/RequestBodyCompression.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/RequestBodyCompression.java
@@ -16,15 +16,15 @@
 package okhttp3.recipes;
 
 import com.google.gson.Gson;
+import java.io.IOException;
+import java.util.LinkedHashMap;
+import java.util.Map;
 import okhttp3.Interceptor;
 import okhttp3.MediaType;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
 import okhttp3.RequestBody;
 import okhttp3.Response;
-import java.io.IOException;
-import java.util.LinkedHashMap;
-import java.util.Map;
 import okio.BufferedSink;
 import okio.GzipSink;
 import okio.Okio;
@@ -33,16 +33,15 @@
   /**
    * The Google API KEY for OkHttp recipes. If you're using Google APIs for anything other than
    * running these examples, please request your own client ID!
-   *   https://console.developers.google.com/project
+   *
+   * https://console.developers.google.com/project
    */
   public static final String GOOGLE_API_KEY = "AIzaSyAx2WZYe0My0i-uGurpvraYJxO7XNbwiGs";
   public static final MediaType MEDIA_TYPE_JSON = MediaType.parse("application/json");
 
-  private final OkHttpClient client = new OkHttpClient();
-
-  public RequestBodyCompression() {
-    client.interceptors().add(new GzipRequestInterceptor());
-  }
+  private final OkHttpClient client = new OkHttpClient.Builder()
+      .addInterceptor(new GzipRequestInterceptor())
+      .build();
 
   public void run() throws Exception {
     Map<String, String> requestBody = new LinkedHashMap<>();
diff --git a/samples/guide/src/main/java/okhttp3/recipes/RewriteResponseCacheControl.java b/samples/guide/src/main/java/okhttp3/recipes/RewriteResponseCacheControl.java
index 25030261d9..d034c505c2 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/RewriteResponseCacheControl.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/RewriteResponseCacheControl.java
@@ -15,13 +15,13 @@
  */
 package okhttp3.recipes;
 
+import java.io.File;
+import java.io.IOException;
 import okhttp3.Cache;
 import okhttp3.Interceptor;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
 import okhttp3.Response;
-import java.io.File;
-import java.io.IOException;
 
 public final class RewriteResponseCacheControl {
   /** Dangerous interceptor that rewrites the server's cache-control header. */
@@ -40,8 +40,9 @@ public RewriteResponseCacheControl(File cacheDirectory) throws Exception {
     Cache cache = new Cache(cacheDirectory, 1024 * 1024);
     cache.evictAll();
 
-    client = new OkHttpClient();
-    client.setCache(cache);
+    client = new OkHttpClient.Builder()
+        .cache(cache)
+        .build();
   }
 
   public void run() throws Exception {
@@ -52,17 +53,20 @@ public void run() throws Exception {
           .url("https://api.github.com/search/repositories?q=http")
           .build();
 
+      OkHttpClient clientForCall;
       if (i == 2) {
         // Force this request's response to be written to the cache. This way, subsequent responses
         // can be read from the cache.
         System.out.println("Force cache: true");
-        client.networkInterceptors().add(REWRITE_CACHE_CONTROL_INTERCEPTOR);
+        clientForCall = client.newBuilder()
+            .addNetworkInterceptor(REWRITE_CACHE_CONTROL_INTERCEPTOR)
+            .build();
       } else {
         System.out.println("Force cache: false");
-        client.networkInterceptors().clear();
+        clientForCall = client;
       }
 
-      Response response = client.newCall(request).execute();
+      Response response = clientForCall.newCall(request).execute();
       response.body().close();
       if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
 
diff --git a/samples/guide/src/main/java/okhttp3/recipes/SynchronousGet.java b/samples/guide/src/main/java/okhttp3/recipes/SynchronousGet.java
index 4b7376060e..ab8d48e3d2 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/SynchronousGet.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/SynchronousGet.java
@@ -15,11 +15,11 @@
  */
 package okhttp3.recipes;
 
+import java.io.IOException;
 import okhttp3.Headers;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
 import okhttp3.Response;
-import java.io.IOException;
 
 public final class SynchronousGet {
   private final OkHttpClient client = new OkHttpClient();
diff --git a/samples/guide/src/main/java/okhttp3/recipes/WebSocketEcho.java b/samples/guide/src/main/java/okhttp3/recipes/WebSocketEcho.java
index 6a5ed06e52..c7ee9438b0 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/WebSocketEcho.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/WebSocketEcho.java
@@ -1,5 +1,8 @@
 package okhttp3.recipes;
 
+import java.io.IOException;
+import java.util.concurrent.Executor;
+import java.util.concurrent.Executors;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
 import okhttp3.RequestBody;
@@ -8,9 +11,6 @@
 import okhttp3.ws.WebSocket;
 import okhttp3.ws.WebSocketCall;
 import okhttp3.ws.WebSocketListener;
-import java.io.IOException;
-import java.util.concurrent.Executor;
-import java.util.concurrent.Executors;
 import okio.Buffer;
 import okio.ByteString;
 
@@ -29,7 +29,7 @@ private void run() throws IOException {
     WebSocketCall.create(client, request).enqueue(this);
 
     // Trigger shutdown of the dispatcher's executor so this process can exit cleanly.
-    client.getDispatcher().getExecutorService().shutdown();
+    client.dispatcher().executorService().shutdown();
   }
 
   @Override public void onOpen(final WebSocket webSocket, Response response) {
diff --git a/samples/pom.xml b/samples/pom.xml
index 50cfe2af05..784ff1daa7 100644
--- a/samples/pom.xml
+++ b/samples/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.0.0-SNAPSHOT</version>
+    <version>3.1.0-SNAPSHOT</version>
   </parent>
 
   <groupId>com.squareup.okhttp3.sample</groupId>
diff --git a/samples/simple-client/pom.xml b/samples/simple-client/pom.xml
index d48482349c..f5b0e7fd60 100644
--- a/samples/simple-client/pom.xml
+++ b/samples/simple-client/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>3.0.0-SNAPSHOT</version>
+    <version>3.1.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>simple-client</artifactId>
diff --git a/samples/simple-client/src/main/java/okhttp3/sample/OkHttpContributors.java b/samples/simple-client/src/main/java/okhttp3/sample/OkHttpContributors.java
index 6187b9bf84..bbd5755dec 100644
--- a/samples/simple-client/src/main/java/okhttp3/sample/OkHttpContributors.java
+++ b/samples/simple-client/src/main/java/okhttp3/sample/OkHttpContributors.java
@@ -2,14 +2,14 @@
 
 import com.google.gson.Gson;
 import com.google.gson.reflect.TypeToken;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.ResponseBody;
 import java.io.Reader;
 import java.util.Collections;
 import java.util.Comparator;
 import java.util.List;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
 
 public class OkHttpContributors {
   private static final String ENDPOINT = "https://api.github.com/repos/square/okhttp/contributors";
diff --git a/samples/static-server/pom.xml b/samples/static-server/pom.xml
index b66186cff5..1acef5f3f5 100644
--- a/samples/static-server/pom.xml
+++ b/samples/static-server/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>3.0.0-SNAPSHOT</version>
+    <version>3.1.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>static-server</artifactId>
@@ -51,7 +51,9 @@
         <executions>
           <execution>
             <phase>package</phase>
-            <goals><goal>shade</goal></goals>
+            <goals>
+              <goal>shade</goal>
+            </goals>
           </execution>
         </executions>
       </plugin>
diff --git a/samples/static-server/src/main/java/okhttp3/sample/SampleServer.java b/samples/static-server/src/main/java/okhttp3/sample/SampleServer.java
index a7d1e7ca5d..e21432ed20 100644
--- a/samples/static-server/src/main/java/okhttp3/sample/SampleServer.java
+++ b/samples/static-server/src/main/java/okhttp3/sample/SampleServer.java
@@ -1,10 +1,5 @@
 package okhttp3.sample;
 
-import okhttp3.internal.Util;
-import okhttp3.mockwebserver.Dispatcher;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.mockwebserver.RecordedRequest;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
@@ -16,6 +11,11 @@
 import javax.net.ssl.KeyManagerFactory;
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.TrustManagerFactory;
+import okhttp3.internal.Util;
+import okhttp3.mockwebserver.Dispatcher;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
 import okio.Buffer;
 import okio.Okio;
 
diff --git a/website/index.html b/website/index.html
index ecc7c69136..ff9ec474b3 100644
--- a/website/index.html
+++ b/website/index.html
@@ -4,7 +4,7 @@
     <meta charset="utf-8">
     <title>OkHttp</title>
     <meta name="viewport" content="width=device-width, initial-scale=1.0">
-    <meta name="description" content="An HTTP &amp; SPDY client for Android and Java applications">
+    <meta name="description" content="An HTTP &amp; HTTP/2 client for Android and Java applications">
     <link href="static/bootstrap-combined.min.css" rel="stylesheet">
     <link href="static/app.css" rel="stylesheet">
     <link href="static/app-theme.css" rel="stylesheet">
@@ -33,7 +33,7 @@ <h1>OkHttp</h1>
       <div class="container">
         <div class="row">
           <div class="span12">
-            <h2>An <strong>HTTP &amp; SPDY</strong> client for Android and Java applications</h2>
+            <h2>An <strong>HTTP &amp; HTTP/2</strong> client for Android and Java applications</h2>
           </div>
         </div>
       </div>
@@ -48,8 +48,8 @@ <h3 id="overview">Overview</h3>
 
             <p>OkHttp is an HTTP client that’s efficient by default:</p>
             <ul>
-                <li>HTTP/2 and SPDY support allows all requests to the same host to share a socket.</li>
-                <li>Connection pooling reduces request latency (if SPDY isn’t available).</li>
+                <li>HTTP/2 support allows all requests to the same host to share a socket.</li>
+                <li>Connection pooling reduces request latency (if HTTP/2 isn’t available).</li>
                 <li>Transparent GZIP shrinks download sizes.</li>
                 <li>Response caching avoids the network completely for repeat requests.</li>
             </ul>
@@ -61,20 +61,15 @@ <h3 id="overview">Overview</h3>
                 with modern TLS features (SNI, ALPN), and falls back to TLS 1.0 if the handshake
                 fails.</p>
 
-            <p>Using OkHttp is easy. Its 2.0 API is designed with fluent builders and
+            <p>Using OkHttp is easy. Its request/response API is designed with fluent builders and
                 immutability. It supports both synchronous blocking calls and async calls with
                 callbacks.</p>
 
-            <p>You can try out OkHttp without rewriting your network code. The
-                <code>okhttp-urlconnection</code> module implements the familiar
-                <code>java.net.HttpURLConnection</code> API and the <code>okhttp-apache</code>
-                module implements the Apache <code>HttpClient</code> API.</p>
-
             <p>OkHttp supports Android 2.3 and above. For Java, the minimum requirement is 1.7.</p>
 
             <h3 id="examples">Examples</h3>
             <h4>Get a URL</h4>
-            <p>This program downloads a URL and print its contents as a string. <a href="https://raw.github.com/square/okhttp/master/samples/guide/src/main/java/com/squareup/okhttp/guide/GetExample.java">Full source</a>.
+            <p>This program downloads a URL and print its contents as a string. <a href="https://raw.github.com/square/okhttp/master/samples/guide/src/main/java/okhttp3/guide/GetExample.java">Full source</a>.
 <pre class="prettyprint">
 OkHttpClient client = new OkHttpClient();
 
@@ -88,7 +83,7 @@ <h4>Get a URL</h4>
 }
 </pre>
             <h4>Post to a Server</h4>
-            <p>This program posts data to a service. <a href="https://raw.github.com/square/okhttp/master/samples/guide/src/main/java/com/squareup/okhttp/guide/PostExample.java">Full source</a>.
+            <p>This program posts data to a service. <a href="https://raw.github.com/square/okhttp/master/samples/guide/src/main/java/okhttp3/guide/PostExample.java">Full source</a>.
 
 <pre class="prettyprint">
 public static final MediaType JSON
@@ -108,7 +103,7 @@ <h4>Post to a Server</h4>
 </pre>
 
             <h3 id="download">Download</h3>
-            <p><a href="https://search.maven.org/remote_content?g=com.squareup.okhttp&a=okhttp&v=LATEST" class="dl version-href">&darr; <span class="version-tag">Latest</span> JAR</a></p>
+            <p><a href="https://search.maven.org/remote_content?g=com.squareup.okhttp3&a=okhttp&v=LATEST" class="dl version-href">&darr; <span class="version-tag">Latest</span> JAR</a></p>
             <p>You'll also need <a href="http://github.com/square/okio">Okio</a>, which OkHttp
                 uses for fast I/O and resizable buffers. Download the
                 <a href="https://search.maven.org/remote_content?g=com.squareup.okio&a=okio&v=LATEST">latest JAR</a>.
@@ -116,13 +111,13 @@ <h3 id="download">Download</h3>
 
             <h4>Maven</h4>
             <pre class="prettyprint">&lt;dependency>
-  &lt;groupId>com.squareup.okhttp&lt;/groupId>
+  &lt;groupId>com.squareup.okhttp3&lt;/groupId>
   &lt;artifactId>okhttp&lt;/artifactId>
   &lt;version><span class="version pln"><em>(insert latest version)</em></span>&lt;/version>
 &lt;/dependency></pre>
 
             <h4>Gradle</h4>
-            <pre class="prettyprint">compile 'com.squareup.okhttp:okhttp:<span class="version pln"><em>(insert latest version)</em></span>'</pre>
+            <pre class="prettyprint">compile 'com.squareup.okhttp3:okhttp:<span class="version pln"><em>(insert latest version)</em></span>'</pre>
 
             <h3 id="contributing">Contributing</h3>
             <p>If you would like to contribute code you can do so through GitHub by forking the repository and sending a pull request.</p>
@@ -130,7 +125,7 @@ <h3 id="contributing">Contributing</h3>
             <p>Before your code can be accepted into the project you must also sign the <a href="http://squ.re/sign-the-cla">Individual Contributor License Agreement (CLA)</a>.</p>
 
             <h3 id="license">License</h3>
-            <pre>Copyright 2014 Square, Inc.
+            <pre>Copyright 2016 Square, Inc.
 
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
@@ -155,7 +150,7 @@ <h3 id="license">License</h3>
               </ul>
               <ul class="nav nav-pills nav-stacked secondary">
                 <li><a href="https://github.com/square/okhttp/wiki">Wiki</a></li>
-                <li><a href="2.x/okhttp/">Javadoc</a></li>
+                <li><a href="3.x/okhttp/">Javadoc</a></li>
                 <li><a href="http://stackoverflow.com/questions/tagged/okhttp?sort=active">StackOverflow</a></li>
               </ul>
             </div>
@@ -197,7 +192,7 @@ <h3 id="license">License</h3>
 
         // Look up the latest version of the library.
         $.fn.artifactVersion({
-          'groupId': 'com.squareup.okhttp',
+          'groupId': 'com.squareup.okhttp3',
           'artifactId': 'okhttp'
         }, function(version, url) {
           $('.version').text(version);
